<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:45:16 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKE(1P) POSIX Programmer&rsquo;s Manual MAKE(1P)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
make - maintain, update, and regenerate groups of programs
(DEVELOPMENT)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
make [-einpqrst][-f makefile]...[ -k| -S][macro=value]...
<br>
[target_name...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The make utility shall update files that are derived from
other files. A typical case is one where object files are
derived from the corresponding source files. The make
utility <br>
examines time relationships and shall update those derived
files (called targets) that have modified times earlier than
the modified times of the files (called prerequisites) <br>
from which they are derived. A description file (makefile)
contains a description of the relationships between files,
and the commands that need to be executed to update the
tar&acirc; <br>
gets to reflect changes in their prerequisites. Each
specification, or rule, shall consist of a target, optional
prerequisites, and optional commands to be executed when a
pre&acirc; <br>
requisite is newer than the target. There are two types of
rule:</p>

<p style="margin-top: 1em">1. Inference rules, which have
one target name with at least one period ( &rsquo;.&rsquo; )
and no slash ( &rsquo;/&rsquo; )</p>

<p style="margin-top: 1em">2. Target rules, which can have
more than one target name</p>

<p style="margin-top: 1em">In addition, make shall have a
collection of built-in macros and inference rules that infer
prerequisite relationships to simplify maintenance of
programs.</p>

<p style="margin-top: 1em">To receive exactly the behavior
described in this section, the user shall ensure that a
portable makefile shall:</p>

<p style="margin-top: 1em">* Include the special target
.POSIX</p>

<p style="margin-top: 1em">* Omit any special target
reserved for implementations (a leading period followed by
uppercase letters) that has not been specified by this
section</p>

<p style="margin-top: 1em">The behavior of make is
unspecified if either or both of these conditions are not
met.</p>

<p style="margin-top: 1em">OPTIONS <br>
The make utility shall conform to the Base Definitions
volume of IEEE Std 1003.1-2001, Section 12.2, Utility Syntax
Guidelines.</p>

<p style="margin-top: 1em">The following options shall be
supported:</p>

<p style="margin-top: 1em">-e Cause environment variables,
including those with null values, to override macro
assignments within makefiles.</p>

<p style="margin-top: 1em">-f makefile <br>
Specify a different makefile. The argument makefile is a
pathname of a description file, which is also referred to as
the makefile. A pathname of &rsquo;-&rsquo; shall denote the
<br>
standard input. There can be multiple instances of this
option, and they shall be processed in the order specified.
The effect of specifying the same option-argument more <br>
than once is unspecified.</p>

<p style="margin-top: 1em">-i Ignore error codes returned
by invoked commands. This mode is the same as if the special
target .IGNORE were specified without prerequisites.</p>

<p style="margin-top: 1em">-k Continue to update other
targets that do not depend on the current target if a
non-ignored error occurs while executing the commands to
bring a target up-to-date.</p>

<p style="margin-top: 1em">-n Write commands that would be
executed on standard output, but do not execute them.
However, lines with a plus sign ( &rsquo;+&rsquo; ) prefix
shall be executed. In this mode, lines <br>
with an at sign ( &rsquo;@&rsquo; ) character prefix shall
be written to standard output.</p>

<p style="margin-top: 1em">-p Write to standard output the
complete set of macro definitions and target descriptions.
The output format is unspecified.</p>

<p style="margin-top: 1em">-q Return a zero exit value if
the target file is up-to-date; otherwise, return an exit
value of 1. Targets shall not be updated if this option is
specified. However, a make&acirc; <br>
file command line (associated with the targets) with a plus
sign ( &rsquo;+&rsquo; ) prefix shall be executed.</p>

<p style="margin-top: 1em">-r Clear the suffix list and do
not use the built-in rules.</p>

<p style="margin-top: 1em">-S Terminate make if an error
occurs while executing the commands to bring a target
up-to-date. This shall be the default and the opposite of
-k.</p>

<p style="margin-top: 1em">-s Do not write makefile command
lines or touch messages (see -t) to standard output before
executing. This mode shall be the same as if the special
target .SILENT were spec&acirc; <br>
ified without prerequisites.</p>

<p style="margin-top: 1em">-t Update the modification time
of each target as though a touch target had been executed.
Targets that have prerequisites but no commands (see Target
Rules ), or that are <br>
already up-to-date, shall not be touched in this manner.
Write messages to standard output for each target file
indicating the name of the file and that it was touched.
<br>
Normally, the makefile command lines associated with each
target are not executed. However, a command line with a plus
sign ( &rsquo;+&rsquo; ) prefix shall be executed.</p>

<p style="margin-top: 1em">Any options specified in the
MAKEFLAGS environment variable shall be evaluated before any
options specified on the make utility command line. If the
-k and -S options are both <br>
specified on the make utility command line or by the
MAKEFLAGS environment variable, the last option specified
shall take precedence. If the -f or -p options appear in the
MAKE&acirc; <br>
FLAGS environment variable, the result is undefined.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operands shall be supported:</p>

<p style="margin-top: 1em">target_name <br>
Target names, as defined in the EXTENDED DESCRIPTION
section. If no target is specified, while make is processing
the makefiles, the first target that make encounters that
<br>
is not a special target or an inference rule shall be
used.</p>

<p style="margin-top: 1em">macro=value <br>
Macro definitions, as defined in Macros .</p>

<p style="margin-top: 1em">If the target_name and macro=
value operands are intermixed on the make utility command
line, the results are unspecified.</p>

<p style="margin-top: 1em">STDIN <br>
The standard input shall be used only if the makefile
option-argument is &rsquo;-&rsquo; . See the INPUT FILES
section.</p>

<p style="margin-top: 1em">INPUT FILES <br>
The input file, otherwise known as the makefile, is a text
file containing rules, macro definitions, and comments. See
the EXTENDED DESCRIPTION section.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of make:</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of IEEE Std 1003.1-2001,
Section 8.2, Internation&acirc; <br>
alization Variables for the precedence of
internationalization variables used to determine the values
of locale categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_CTYPE <br>
Determine the locale for the interpretation of sequences of
bytes of text data as characters (for example, single-byte
as opposed to multi-byte characters in arguments and <br>
input files).</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">MAKEFLAGS</p>

<p style="margin-top: 1em">This variable shall be
interpreted as a character string representing a series of
option characters to be used as the default options. The
implementation shall accept both <br>
of the following formats (but need not accept them when
intermixed):</p>

<p style="margin-top: 1em">* The characters are option
letters without the leading hyphens or &lt;blank&gt;
separation used on a make utility command line.</p>

<p style="margin-top: 1em">* The characters are formatted
in a manner similar to a portion of the make utility command
line: options are preceded by hyphens and
&lt;blank&gt;-separated as described in <br>
the Base Definitions volume of IEEE Std 1003.1-2001, Section
12.2, Utility Syntax Guidelines. The macro= value macro
definition operands can also be included. The dif&acirc;
<br>
ference between the contents of MAKEFLAGS and the make
utility command line is that the contents of the variable
shall not be subjected to the word expansions (see Word <br>
Expansions ) associated with parsing the command line
values.</p>

<p style="margin-top: 1em">NLSPATH <br>
Determine the location of message catalogs for the
processing of LC_MESSAGES .</p>

<p style="margin-top: 1em">PROJECTDIR</p>

<p style="margin-top: 1em">Provide a directory to be used
to search for SCCS files not found in the current directory.
In all of the following cases, the search for SCCS files is
made in the direc&acirc; <br>
tory SCCS in the identified directory. If the value of
PROJECTDIR begins with a slash, it shall be considered an
absolute pathname; otherwise, the value of PROJECTDIR is
<br>
treated as a user name and that user&rsquo;s initial working
directory shall be examined for a subdirectory src or
source. If such a directory is found, it shall be used.
Other&acirc; <br>
wise, the value is used as a relative pathname.</p>

<p style="margin-top: 1em">If PROJECTDIR is not set or has
a null value, the search for SCCS files shall be made in the
directory SCCS in the current directory.</p>

<p style="margin-top: 1em">The setting of PROJECTDIR
affects all files listed in the remainder of this utility
description for files with a component named SCCS.</p>

<p style="margin-top: 1em">The value of the SHELL
environment variable shall not be used as a macro and shall
not be modified by defining the SHELL macro in a makefile or
on the command line. All other <br>
environment variables, including those with null values,
shall be used as macros, as defined in Macros .</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
If not already ignored, make shall trap SIGHUP, SIGTERM,
SIGINT, and SIGQUIT and remove the current target unless the
target is a directory or the target is a prerequisite of the
<br>
special target .PRECIOUS or unless one of the -n, -p, or -q
options was specified. Any targets removed in this manner
shall be reported in diagnostic messages of unspecified
for&acirc; <br>
mat, written to standard error. After this cleanup process,
if any, make shall take the standard action for all other
signals.</p>

<p style="margin-top: 1em">STDOUT <br>
The make utility shall write all commands to be executed to
standard output unless the -s option was specified, the
command is prefixed with an at sign, or the special target
<br>
.SILENT has either the current target as a prerequisite or
has no prerequisites. If make is invoked without any work
needing to be done, it shall write a message to standard
out&acirc; <br>
put indicating that no action was taken. If the -t option is
present and a file is touched, make shall write to standard
output a message of unspecified format indicating that <br>
the file was touched, including the filename of the
file.</p>

<p style="margin-top: 1em">STDERR <br>
The standard error shall be used only for diagnostic
messages.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
Files can be created when the -t option is present.
Additional files can also be created by the utilities
invoked by make.</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
The make utility attempts to perform the actions required to
ensure that the specified targets are up-to-date. A target
is considered out-of-date if it is older than any of its
<br>
prerequisites or if it does not exist. The make utility
shall treat all prerequisites as targets themselves and
recursively ensure that they are up-to-date, processing them
in <br>
the order in which they appear in the rule. The make utility
shall use the modification times of files to determine
whether the corresponding targets are out-of-date.</p>

<p style="margin-top: 1em">After make has ensured that all
of the prerequisites of a target are up-to-date and if the
target is out-of-date, the commands associated with the
target entry shall be executed. <br>
If there are no commands listed for the target, the target
shall be treated as up-to-date.</p>

<p style="margin-top: 1em">Makefile Syntax <br>
A makefile can contain rules, macro definitions (see Macros
), and comments. There are two kinds of rules: inference
rules and target rules. The make utility shall contain a set
<br>
of built-in inference rules. If the -r option is present,
the built-in rules shall not be used and the suffix list
shall be cleared. Additional rules of both types can be
speci&acirc; <br>
fied in a makefile. If a rule is defined more than once, the
value of the rule shall be that of the last one specified.
Macros can also be defined more than once, and the value
<br>
of the macro is specified in Macros . Comments start with a
number sign ( &rsquo;#&rsquo; ) and continue until an
unescaped &lt;newline&gt; is reached.</p>

<p style="margin-top: 1em">By default, the following files
shall be tried in sequence: ./makefile and ./Makefile. If
neither ./makefile or ./Makefile are found, other
implementation-defined files may also <br>
be tried. On XSI-conformant systems, the additional files
./s.makefile, SCCS/s.makefile, ./s.Makefile, and
SCCS/s.Makefile shall also be tried.</p>

<p style="margin-top: 1em">The -f option shall direct make
to ignore any of these default files and use the specified
argument as a makefile instead. If the &rsquo;-&rsquo;
argument is specified, standard input shall <br>
be used.</p>

<p style="margin-top: 1em">The term makefile is used to
refer to any rules provided by the user, whether in
./makefile or its variants, or specified by the -f
option.</p>

<p style="margin-top: 1em">The rules in makefiles shall
consist of the following types of lines: target rules,
including special targets (see Target Rules ), inference
rules (see Inference Rules ), macro <br>
definitions (see Macros ), empty lines, and comments.</p>

<p style="margin-top: 1em">When an escaped &lt;newline&gt;
(one preceded by a backslash) is found anywhere in the
makefile except in a command line, it shall be replaced,
along with any leading white space on <br>
the following line, with a single &lt;space&gt;. When an
escaped &lt;newline&gt; is found in a command line in a
makefile, the command line shall contain the backslash, the
&lt;newline&gt;, and <br>
the next line, except that the first character of the next
line shall not be included if it is a &lt;tab&gt;.</p>

<p style="margin-top: 1em">Makefile Execution <br>
Makefile command lines shall be processed one at a time by
writing the makefile command line to the standard output
(unless one of the conditions listed under &rsquo;@&rsquo;
suppresses the <br>
writing) and executing the command(s) in the line. A
&lt;tab&gt; may precede the command to standard output.
Command execution shall be as if the makefile command line
were the argu&acirc; <br>
ment to the system() function. The environment for the
command being executed shall contain all of the variables in
the environment of make.</p>

<p style="margin-top: 1em">By default, when make receives a
non-zero status from the execution of a command, it shall
terminate with an error message to standard error.</p>

<p style="margin-top: 1em">Makefile command lines can have
one or more of the following prefixes: a hyphen (
&rsquo;-&rsquo; ), an at sign ( &rsquo;@&rsquo; ), or a plus
sign ( &rsquo;+&rsquo; ). These shall modify the way in
which make pro&acirc; <br>
cesses the command. When a command is written to standard
output, the prefix shall not be included in the output.</p>

<p style="margin-top: 1em">- If the command prefix contains
a hyphen, or the -i option is present, or the special target
.IGNORE has either the current target as a prerequisite or
has no prerequi&acirc; <br>
sites, any error found while executing the command shall be
ignored.</p>

<p style="margin-top: 1em">@ If the command prefix contains
an at sign and the make utility command line -n option is
not specified, or the -s option is present, or the special
target .SILENT has <br>
either the current target as a prerequisite or has no
prerequisites, the command shall not be written to standard
output before it is executed.</p>

<p style="margin-top: 1em">+ If the command prefix contains
a plus sign, this indicates a makefile command line that
shall be executed even if -n, -q, or -t is specified.</p>

<p style="margin-top: 1em">Target Rules <br>
Target rules are formatted as follows:</p>

<p style="margin-top: 1em">target [target...]:
[prerequisite...][;command] <br>
[&lt;tab&gt;command&lt;tab&gt;command...]</p>

<p style="margin-top: 1em">line that does not begin with
&lt;tab&gt;</p>

<p style="margin-top: 1em">Target entries are specified by
a &lt;blank&gt;-separated, non-null list of targets, then a
colon, then a &lt;blank&gt;-separated, possibly empty list
of prerequisites. Text following a <br>
semicolon, if any, and all following lines that begin with a
&lt;tab&gt;, are makefile command lines to be executed to
update the target. The first non-empty line that does not
begin <br>
with a &lt;tab&gt; or &rsquo;#&rsquo; shall begin a new
entry. An empty or blank line, or a line beginning with
&rsquo;#&rsquo;, may begin a new entry.</p>

<p style="margin-top: 1em">Applications shall select target
names from the set of characters consisting solely of
periods, underscores, digits, and alphabetics from the
portable character set (see the Base <br>
Definitions volume of IEEE Std 1003.1-2001, Section 6.1,
Portable Character Set). Implementations may allow other
characters in target names as extensions. The interpretation
of <br>
targets containing the characters &rsquo;%&rsquo; and
&rsquo;&rsquo; is implementation-defined.</p>

<p style="margin-top: 1em">A target that has prerequisites,
but does not have any commands, can be used to add to the
prerequisite list for that target. Only one target rule for
any given target can con&acirc; <br>
tain commands.</p>

<p style="margin-top: 1em">Lines that begin with one of the
following are called special targets and control the
operation of make:</p>

<p style="margin-top: 1em">.DEFAULT <br>
If the makefile uses this special target, the application
shall ensure that it is specified with commands, but without
prerequisites. The commands shall be used by make if <br>
there are no other rules available to build a target.</p>

<p style="margin-top: 1em">.IGNORE <br>
Prerequisites of this special target are targets themselves;
this shall cause errors from commands associated with them
to be ignored in the same manner as specified by <br>
the -i option. Subsequent occurrences of .IGNORE shall add
to the list of targets ignoring command errors. If no
prerequisites are specified, make shall behave as if the
<br>
-i option had been specified and errors from all commands
associated with all targets shall be ignored.</p>

<p style="margin-top: 1em">.POSIX The application shall
ensure that this special target is specified without
prerequisites or commands. If it appears as the first
non-comment line in the makefile, make <br>
shall process the makefile as specified by this section;
otherwise, the behavior of make is unspecified.</p>

<p style="margin-top: 1em">.PRECIOUS <br>
Prerequisites of this special target shall not be removed if
make receives one of the asynchronous events explicitly
described in the ASYNCHRONOUS EVENTS section. Subse&acirc;
<br>
quent occurrences of .PRECIOUS shall add to the list of
precious files. If no prerequisites are specified, all
targets in the makefile shall be treated as if specified
<br>
with .PRECIOUS.</p>

<p style="margin-top: 1em">.SCCS_GET <br>
The application shall ensure that this special target is
specified without prerequisites. If this special target is
included in a makefile, the commands specified with <br>
this target shall replace the default commands associated
with this special target (see Default Rules ). The commands
specified with this target are used to get all SCCS <br>
files that are not found in the current directory.</p>

<p style="margin-top: 1em">When source files are named in a
dependency list, make shall treat them just like any other
target. Because the source file is presumed to be present in
the directory, there is <br>
no need to add an entry for it to the makefile. When a
target has no dependencies, but is present in the directory,
make shall assume that that file is up-to-date. If, however,
<br>
an SCCS file named SCCS/s. source_file is found for a target
source_file, make compares the timestamp of the target file
with that of the SCCS/s.source_file to ensure the target
<br>
is up-to-date. If the target is missing, or if the SCCS file
is newer, make shall automatically issue the commands
specified for the .SCCS_GET special target to retrieve the
most <br>
recent version. However, if the target is writable by
anyone, make shall not retrieve a new version.</p>

<p style="margin-top: 1em">.SILENT <br>
Prerequisites of this special target are targets themselves;
this shall cause commands associated with them not to be
written to the standard output before they are exe&acirc;
<br>
cuted. Subsequent occurrences of .SILENT shall add to the
list of targets with silent commands. If no prerequisites
are specified, make shall behave as if the -s option <br>
had been specified and no commands or touch messages
associated with any target shall be written to standard
output.</p>

<p style="margin-top: 1em">.SUFFIXES <br>
Prerequisites of .SUFFIXES shall be appended to the list of
known suffixes and are used in conjunction with the
inference rules (see Inference Rules ). If .SUFFIXES does
<br>
not have any prerequisites, the list of known suffixes shall
be cleared.</p>

<p style="margin-top: 1em">The special targets .IGNORE,
.POSIX, .PRECIOUS, .SILENT, and .SUFFIXES shall be specified
without commands.</p>

<p style="margin-top: 1em">Targets with names consisting of
a leading period followed by the uppercase letters
&quot;POSIX&quot; and then any other characters are reserved
for future standardization. Targets with <br>
names consisting of a leading period followed by one or more
uppercase letters are reserved for implementation
extensions.</p>

<p style="margin-top: 1em">Macros <br>
Macro definitions are in the form:</p>

<p style="margin-top: 1em">string1 = [string2]</p>

<p style="margin-top: 1em">The macro named string1 is
defined as having the value of string2, where string2 is
defined as all characters, if any, after the equal sign, up
to a comment character ( &rsquo;#&rsquo; ) or <br>
an unescaped &lt;newline&gt;. Any &lt;blank&gt;s immediately
before or after the equal sign shall be ignored.</p>

<p style="margin-top: 1em">Applications shall select macro
names from the set of characters consisting solely of
periods, underscores, digits, and alphabetics from the
portable character set (see the Base <br>
Definitions volume of IEEE Std 1003.1-2001, Section 6.1,
Portable Character Set). A macro name shall not contain an
equals sign. Implementations may allow other characters in
<br>
macro names as extensions.</p>

<p style="margin-top: 1em">Macros can appear anywhere in
the makefile. Macro expansions using the forms $( string1)
or ${ string1} shall be replaced by string2, as follows:</p>

<p style="margin-top: 1em">* Macros in target lines shall
be evaluated when the target line is read.</p>

<p style="margin-top: 1em">* Macros in makefile command
lines shall be evaluated when the command is executed.</p>

<p style="margin-top: 1em">* Macros in the string before
the equals sign in a macro definition shall be evaluated
when the macro assignment is made.</p>

<p style="margin-top: 1em">* Macros after the equals sign
in a macro definition shall not be evaluated until the
defined macro is used in a rule or command, or before the
equals sign in a macro defini&acirc; <br>
tion.</p>

<p style="margin-top: 1em">The parentheses or braces are
optional if string1 is a single character. The macro $$
shall be replaced by the single character &rsquo;$&rsquo; .
If string1 in a macro expansion contains a <br>
macro expansion, the results are unspecified.</p>

<p style="margin-top: 1em">Macro expansions using the forms
$( string1 [: subst1 =[ subst2 ]]) or ${ string1 [: subst1
=[ subst2 ]]} can be used to replace all occurrences of
subst1 with subst2 when the <br>
macro substitution is performed. The subst1 to be replaced
shall be recognized when it is a suffix at the end of a word
in string1 (where a word, in this context, is defined to
<br>
be a string delimited by the beginning of the line, a
&lt;blank&gt;, or a &lt;newline&gt;). If string1 in a macro
expansion contains a macro expansion, the results are
unspecified.</p>

<p style="margin-top: 1em">Macro expansions in string1 of
macro definition lines shall be evaluated when read. Macro
expansions in string2 of macro definition lines shall be
performed when the macro iden&acirc; <br>
tified by string1 is expanded in a rule or command.</p>

<p style="margin-top: 1em">Macro definitions shall be taken
from the following sources, in the following logical order,
before the makefile(s) are read.</p>

<p style="margin-top: 1em">1. Macros specified on the make
utility command line, in the order specified on the command
line. It is unspecified whether the internal macros defined
in Internal Macros are <br>
accepted from this source.</p>

<p style="margin-top: 1em">2. Macros defined by the
MAKEFLAGS environment variable, in the order specified in
the environment variable. It is unspecified whether the
internal macros defined in Internal <br>
Macros are accepted from this source.</p>

<p style="margin-top: 1em">3. The contents of the
environment, excluding the MAKEFLAGS and SHELL variables and
including the variables with null values.</p>

<p style="margin-top: 1em">4. Macros defined in the
inference rules built into make.</p>

<p style="margin-top: 1em">Macro definitions from these
sources shall not override macro definitions from a
lower-numbered source. Macro definitions from a single
source (for example, the make utility com&acirc; <br>
mand line, the MAKEFLAGS environment variable, or the other
environment variables) shall override previous macro
definitions from the same source.</p>

<p style="margin-top: 1em">Macros defined in the
makefile(s) shall override macro definitions that occur
before them in the makefile(s) and macro definitions from
source 4. If the -e option is not speci&acirc; <br>
fied, macros defined in the makefile(s) shall override macro
definitions from source 3. Macros defined in the makefile(s)
shall not override macro definitions from source 1 or <br>
source 2.</p>

<p style="margin-top: 1em">Before the makefile(s) are read,
all of the make utility command line options (except -f and
-p) and make utility command line macro definitions (except
any for the MAKEFLAGS <br>
macro), not already included in the MAKEFLAGS macro, shall
be added to the MAKEFLAGS macro, quoted in an
implementation-defined manner such that when MAKEFLAGS is
read by another <br>
instance of the make command, the original macro&rsquo;s
value is recovered. Other implementation-defined options and
macros may also be added to the MAKEFLAGS macro. If this
modifies <br>
the value of the MAKEFLAGS macro, or, if the MAKEFLAGS macro
is modified at any subsequent time, the MAKEFLAGS
environment variable shall be modified to match the new
value of <br>
the MAKEFLAGS macro. The result of setting MAKEFLAGS in the
Makefile is unspecified.</p>

<p style="margin-top: 1em">Before the makefile(s) are read,
all of the make utility command line macro definitions
(except the MAKEFLAGS macro or the SHELL macro) shall be
added to the environment of make. <br>
Other implementation-defined variables may also be added to
the environment of make.</p>

<p style="margin-top: 1em">The SHELL macro shall be treated
specially. It shall be provided by make and set to the
pathname of the shell command language interpreter (see sh
). The SHELL environment vari&acirc; <br>
able shall not affect the value of the SHELL macro. If SHELL
is defined in the makefile or is specified on the command
line, it shall replace the original value of the SHELL <br>
macro, but shall not affect the SHELL environment variable.
Other effects of defining SHELL in the makefile or on the
command line are implementation-defined.</p>

<p style="margin-top: 1em">Inference Rules <br>
Inference rules are formatted as follows:</p>

<p style="margin-top: 1em">target: <br>
&lt;tab&gt;command <br>
[&lt;tab&gt;command]...</p>

<p style="margin-top: 1em">line that does not begin with
&lt;tab&gt; or #</p>

<p style="margin-top: 1em">The application shall ensure
that the target portion is a valid target name (see Target
Rules ) of the form .s2 or .s1.s2 (where .s1 and .s2 are
suffixes that have been given as <br>
prerequisites of the .SUFFIXES special target and s1 and s2
do not contain any slashes or periods.) If there is only one
period in the target, it is a single-suffix inference <br>
rule. Targets with two periods are double-suffix inference
rules. Inference rules can have only one target before the
colon.</p>

<p style="margin-top: 1em">The application shall ensure
that the makefile does not specify prerequisites for
inference rules; no characters other than white space shall
follow the colon in the first line, <br>
except when creating the empty rule, described below.
Prerequisites are inferred, as described below.</p>

<p style="margin-top: 1em">Inference rules can be
redefined. A target that matches an existing inference rule
shall overwrite the old inference rule. An empty rule can be
created with a command consisting <br>
of simply a semicolon (that is, the rule still exists and is
found during inference rule search, but since it is empty,
execution has no effect). The empty rule can also be
for&acirc; <br>
matted as follows:</p>

<p style="margin-top: 1em">rule: ;</p>

<p style="margin-top: 1em">where zero or more
&lt;blank&gt;s separate the colon and semicolon.</p>

<p style="margin-top: 1em">The make utility uses the
suffixes of targets and their prerequisites to infer how a
target can be made up-to-date. A list of inference rules
defines the commands to be executed. <br>
By default, make contains a built-in set of inference rules.
Additional rules can be specified in the makefile.</p>

<p style="margin-top: 1em">The special target .SUFFIXES
contains as its prerequisites a list of suffixes that shall
be used by the inference rules. The order in which the
suffixes are specified defines <br>
the order in which the inference rules for the suffixes are
used. New suffixes shall be appended to the current list by
specifying a .SUFFIXES special target in the makefile. A
<br>
.SUFFIXES target with no prerequisites shall clear the list
of suffixes. An empty .SUFFIXES target followed by a new
.SUFFIXES list is required to change the order of the
suf&acirc; <br>
fixes.</p>

<p style="margin-top: 1em">Normally, the user would provide
an inference rule for each suffix. The inference rule to
update a target with a suffix .s1 from a prerequisite with a
suffix .s2 is specified as <br>
a target .s2.s1. The internal macros provide the means to
specify general inference rules (see Internal Macros ).</p>

<p style="margin-top: 1em">When no target rule is found to
update a target, the inference rules shall be checked. The
suffix of the target ( .s1) to be built is compared to the
list of suffixes specified <br>
by the .SUFFIXES special targets. If the .s1 suffix is found
in .SUFFIXES, the inference rules shall be searched in the
order defined for the first .s2.s1 rule whose prerequisite
<br>
file ( $*.s2) exists. If the target is out-of-date with
respect to this prerequisite, the commands for that
inference rule shall be executed.</p>

<p style="margin-top: 1em">If the target to be built does
not contain a suffix and there is no rule for the target,
the single suffix inference rules shall be checked. The
single-suffix inference rules <br>
define how to build a target if a file is found with a name
that matches the target name with one of the single suffixes
appended. A rule with one suffix .s2 is the definition of
<br>
how to build target from target.s2. The other suffix ( .s1)
is treated as null.</p>

<p style="margin-top: 1em">A tilde ( &rsquo;~&rsquo; ) in
the above rules refers to an SCCS file in the current
directory. Thus, the rule .c~.o would transform an SCCS
C-language source file into an object file ( .o). <br>
Because the s. of the SCCS files is a prefix, it is
incompatible with make&rsquo;s suffix point of view. Hence,
the &rsquo;~&rsquo; is a way of changing any file reference
into an SCCS file ref&acirc; <br>
erence.</p>

<p style="margin-top: 1em">Libraries <br>
If a target or prerequisite contains parentheses, it shall
be treated as a member of an archive library. For the lib(
member .o) expression lib refers to the name of the archive
<br>
library and member .o to the member name. The application
shall ensure that the member is an object file with the .o
suffix. The modification time of the expression is the
modi&acirc; <br>
fication time for the member as kept in the archive library;
see ar . The .a suffix shall refer to an archive library.
The .s2.a rule shall be used to update a member in the <br>
library from a file with a suffix .s2.</p>

<p style="margin-top: 1em">Internal Macros <br>
The make utility shall maintain five internal macros that
can be used in target and inference rules. In order to
clearly define the meaning of these macros, some
clarification of <br>
the terms target rule, inference rule, target, and
prerequisite is necessary.</p>

<p style="margin-top: 1em">Target rules are specified by
the user in a makefile for a particular target. Inference
rules are user-specified or make-specified rules for a
particular class of target name. <br>
Explicit prerequisites are those prerequisites specified in
a makefile on target lines. Implicit prerequisites are those
prerequisites that are generated when inference rules are
<br>
used. Inference rules are applied to implicit prerequisites
or to explicit prerequisites that do not have target rules
defined for them in the makefile. Target rules are applied
<br>
to targets specified in the makefile.</p>

<p style="margin-top: 1em">Before any target in the
makefile is updated, each of its prerequisites (both
explicit and implicit) shall be updated. This shall be
accomplished by recursively processing each <br>
prerequisite. Upon recursion, each prerequisite shall become
a target itself. Its prerequisites in turn shall be
processed recursively until a target is found that has no
pre&acirc; <br>
requisites, at which point the recursion stops. The
recursion shall then back up, updating each target as it
goes.</p>

<p style="margin-top: 1em">In the definitions that follow,
the word target refers to one of:</p>

<p style="margin-top: 1em">* A target specified in the
makefile</p>

<p style="margin-top: 1em">* An explicit prerequisite
specified in the makefile that becomes the target when make
processes it during recursion</p>

<p style="margin-top: 1em">* An implicit prerequisite that
becomes a target when make processes it during recursion</p>

<p style="margin-top: 1em">In the definitions that follow,
the word prerequisite refers to one of the following:</p>

<p style="margin-top: 1em">* An explicit prerequisite
specified in the makefile for a particular target</p>

<p style="margin-top: 1em">* An implicit prerequisite
generated as a result of locating an appropriate inference
rule and corresponding file that matches the suffix of the
target</p>

<p style="margin-top: 1em">The five internal macros
are:</p>

<p style="margin-top: 1em">$@ The $@ shall evaluate to the
full target name of the current target, or the archive
filename part of a library archive target. It shall be
evaluated for both target and <br>
inference rules.</p>

<p style="margin-top: 1em">For example, in the .c.a
inference rule, $@ represents the out-of-date .a file to be
built. Similarly, in a makefile target rule to build lib.a
from file.c, $@ represents the <br>
out-of-date lib.a.</p>

<p style="margin-top: 1em">$% The $% macro shall be
evaluated only when the current target is an archive library
member of the form libname( member .o). In these cases, $@
shall evaluate to libname and <br>
$% shall evaluate to member .o. The $% macro shall be
evaluated for both target and inference rules.</p>

<p style="margin-top: 1em">For example, in a makefile
target rule to build lib.a( file.o), $% represents file.o,
as opposed to $@, which represents lib.a.</p>

<p style="margin-top: 1em">$? The $? macro shall evaluate
to the list of prerequisites that are newer than the current
target. It shall be evaluated for both target and inference
rules.</p>

<p style="margin-top: 1em">For example, in a makefile
target rule to build prog from file1.o, file2.o, and
file3.o, and where prog is not out-of-date with respect to
file1.o, but is out-of-date with <br>
respect to file2.o and file3.o, $? represents file2.o and
file3.o.</p>

<p style="margin-top: 1em">$&lt; In an inference rule, the
$&lt; macro shall evaluate to the filename whose existence
allowed the inference rule to be chosen for the target. In
the .DEFAULT rule, the $&lt; <br>
macro shall evaluate to the current target name. The meaning
of the $&lt; macro shall be otherwise unspecified.</p>

<p style="margin-top: 1em">For example, in the .c.a
inference rule, $&lt; represents the prerequisite .c
file.</p>

<p style="margin-top: 1em">$* The $* macro shall evaluate
to the current target name with its suffix deleted. It shall
be evaluated at least for inference rules.</p>

<p style="margin-top: 1em">For example, in the .c.a
inference rule, $*.o represents the out-of-date .o file that
corresponds to the prerequisite .c file.</p>

<p style="margin-top: 1em">Each of the internal macros has
an alternative form. When an uppercase &rsquo;D&rsquo; or
&rsquo;F&rsquo; is appended to any of the macros, the
meaning shall be changed to the directory part for
&rsquo;D&rsquo; and <br>
filename part for &rsquo;F&rsquo; . The directory part is
the path prefix of the file without a trailing slash; for
the current directory, the directory part is &rsquo;.&rsquo;
. When the $? macro con&acirc; <br>
tains more than one prerequisite filename, the $(?D) and
$(?F) (or ${?D} and ${?F}) macros expand to a list of
directory name parts and filename parts respectively.</p>

<p style="margin-top: 1em">For the target lib( member .o)
and the s2.a rule, the internal macros shall be defined
as:</p>

<p style="margin-top: 1em">$&lt; member .s2</p>

<p style="margin-top: 1em">$* member</p>

<p style="margin-top: 1em">$@ lib</p>

<p style="margin-top: 1em">$? member .s2</p>

<p style="margin-top: 1em">$% member .o</p>

<p style="margin-top: 1em">Default Rules <br>
The default rules for make shall achieve results that are
the same as if the following were used. Implementations that
do not support the C-Language Development Utilities option
<br>
may omit CC, CFLAGS, YACC, YFLAGS, LEX, LFLAGS, LDFLAGS, and
the .c, .y, and .l inference rules. Implementations that do
not support FORTRAN may omit FC, FFLAGS, and the .f <br>
inference rules. Implementations may provide additional
macros and rules.</p>

<p style="margin-top: 1em">SPECIAL TARGETS</p>

<p style="margin-top: 1em">.SCCS_GET: sccs $(SCCSFLAGS) get
$(SCCSGETFLAGS) $@</p>

<p style="margin-top: 1em">.SUFFIXES: .o .c .y .l .a .sh .f
.c~ .y~ .l~ .sh~ .f~</p>

<p style="margin-top: 1em">MACROS</p>

<p style="margin-top: 1em">MAKE=make <br>
AR=ar <br>
ARFLAGS=-rv <br>
YACC=yacc <br>
YFLAGS= <br>
LEX=lex <br>
LFLAGS= <br>
LDFLAGS= <br>
CC=c99 <br>
CFLAGS=-O <br>
FC=fort77 <br>
FFLAGS=-O 1</p>

<p style="margin-top: 1em">GET=get <br>
GFLAGS= <br>
SCCSFLAGS= <br>
SCCSGETFLAGS=-s</p>

<p style="margin-top: 1em">SINGLE SUFFIX RULES</p>

<p style="margin-top: 1em">.c: <br>
$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $&lt;</p>

<p style="margin-top: 1em">.f: <br>
$(FC) $(FFLAGS) $(LDFLAGS) -o $@ $&lt;</p>

<p style="margin-top: 1em">.sh: <br>
cp $&lt; $@ <br>
chmod a+x $@</p>

<p style="margin-top: 1em">.c~: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.c <br>
$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $*.c</p>

<p style="margin-top: 1em">.f~: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.f <br>
$(FC) $(FFLAGS) $(LDFLAGS) -o $@ $*.f</p>

<p style="margin-top: 1em">.sh~: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.sh <br>
cp $*.sh $@ <br>
chmod a+x $@</p>

<p style="margin-top: 1em">DOUBLE SUFFIX RULES</p>

<p style="margin-top: 1em">.c.o: <br>
$(CC) $(CFLAGS) -c $&lt;</p>

<p style="margin-top: 1em">.f.o: <br>
$(FC) $(FFLAGS) -c $&lt;</p>

<p style="margin-top: 1em">.y.o: <br>
$(YACC) $(YFLAGS) $&lt; <br>
$(CC) $(CFLAGS) -c y.tab.c <br>
rm -f y.tab.c <br>
mv y.tab.o $@</p>

<p style="margin-top: 1em">.l.o: <br>
$(LEX) $(LFLAGS) $&lt; <br>
$(CC) $(CFLAGS) -c lex.yy.c <br>
rm -f lex.yy.c <br>
mv lex.yy.o $@</p>

<p style="margin-top: 1em">.y.c: <br>
$(YACC) $(YFLAGS) $&lt; <br>
mv y.tab.c $@</p>

<p style="margin-top: 1em">.l.c: <br>
$(LEX) $(LFLAGS) $&lt; <br>
mv lex.yy.c $@</p>

<p style="margin-top: 1em">.c~.o: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.c <br>
$(CC) $(CFLAGS) -c $*.c</p>

<p style="margin-top: 1em">.f~.o: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.f <br>
$(FC) $(FFLAGS) -c $*.f</p>

<p style="margin-top: 1em">.y~.o: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.y <br>
$(YACC) $(YFLAGS) $*.y <br>
$(CC) $(CFLAGS) -c y.tab.c <br>
rm -f y.tab.c <br>
mv y.tab.o $@</p>

<p style="margin-top: 1em">.l~.o: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.l <br>
$(LEX) $(LFLAGS) $*.l <br>
$(CC) $(CFLAGS) -c lex.yy.c <br>
rm -f lex.yy.c <br>
mv lex.yy.o $@</p>

<p style="margin-top: 1em">.y~.c: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.y <br>
$(YACC) $(YFLAGS) $*.y <br>
mv y.tab.c $@</p>

<p style="margin-top: 1em">.l~.c: <br>
$(GET) $(GFLAGS) -p $&lt; &gt; $*.l <br>
$(LEX) $(LFLAGS) $*.l <br>
mv lex.yy.c $@</p>

<p style="margin-top: 1em">.c.a: <br>
$(CC) -c $(CFLAGS) $&lt; <br>
$(AR) $(ARFLAGS) $@ $*.o <br>
rm -f $*.o</p>

<p style="margin-top: 1em">.f.a: <br>
$(FC) -c $(FFLAGS) $&lt; <br>
$(AR) $(ARFLAGS) $@ $*.o <br>
rm -f $*.o</p>

<p style="margin-top: 1em">EXIT STATUS <br>
When the -q option is specified, the make utility shall exit
with one of the following values:</p>

<p style="margin-top: 1em">0 Successful completion.</p>

<p style="margin-top: 1em">1 The target was not
up-to-date.</p>

<p style="margin-top: 1em">&gt;1 An error occurred.</p>

<p style="margin-top: 1em">When the -q option is not
specified, the make utility shall exit with one of the
following values:</p>

<p style="margin-top: 1em">0 Successful completion.</p>

<p style="margin-top: 1em">&gt;0 An error occurred.</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
Default.</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
If there is a source file (such as ./source.c) and there are
two SCCS files corresponding to it ( ./s.source.c and
./SCCS/s.source.c), on XSI-conformant systems make uses the
<br>
SCCS file in the current directory. However, users are
advised to use the underlying SCCS utilities ( admin, delta,
get, and so on) or the sccs utility for all source files in
a <br>
given directory. If both forms are used for a given source
file, future developers are very likely to be confused.</p>

<p style="margin-top: 1em">It is incumbent upon portable
makefiles to specify the .POSIX special target in order to
guarantee that they are not affected by local
extensions.</p>

<p style="margin-top: 1em">The -k and -S options are both
present so that the relationship between the command line,
the MAKEFLAGS variable, and the makefile can be controlled
precisely. If the k flag is <br>
passed in MAKEFLAGS and a command is of the form:</p>

<p style="margin-top: 1em">$(MAKE) -S foo</p>

<p style="margin-top: 1em">then the default behavior is
restored for the child make.</p>

<p style="margin-top: 1em">When the -n option is specified,
it is always added to MAKEFLAGS . This allows a recursive
make -n target to be used to see all of the action that
would be taken to update tar&acirc; <br>
get.</p>

<p style="margin-top: 1em">Because of widespread historical
practice, interpreting a &rsquo;#&rsquo; number sign inside
a variable as the start of a comment has the unfortunate
side effect of making it impossible to <br>
place a number sign in a variable, thus forbidding something
like:</p>

<p style="margin-top: 1em">CFLAGS = &quot;-D
COMMENT_CHAR=&rsquo;#&rsquo;&quot;</p>

<p style="margin-top: 1em">Many historical make utilities
stop chaining together inference rules when an intermediate
target is nonexistent. For example, it might be possible for
a make to determine that <br>
both .y.c and .c.o could be used to convert a .y to a .o.
Instead, in this case, make requires the use of a .y.o
rule.</p>

<p style="margin-top: 1em">The best way to provide portable
makefiles is to include all of the rules needed in the
makefile itself. The rules provided use only features
provided by other parts of this vol&acirc; <br>
ume of IEEE Std 1003.1-2001. The default rules include rules
for optional commands in this volume of IEEE Std
1003.1-2001. Only rules pertaining to commands that are
provided <br>
are needed in an implementation&rsquo;s default set.</p>

<p style="margin-top: 1em">Macros used within other macros
are evaluated when the new macro is used rather than when
the new macro is defined. Therefore:</p>

<p style="margin-top: 1em">MACRO = value1NEW = $(MACRO)
<br>
MACRO = value2</p>

<p style="margin-top: 1em">target: <br>
echo $(NEW)</p>

<p style="margin-top: 1em">would produce value2 and not
value1 since NEW was not expanded until it was needed in the
echo command line.</p>

<p style="margin-top: 1em">Some historical applications
have been known to intermix target_name and macro=name
operands on the command line, expecting that all of the
macros are processed before any of the <br>
targets are dealt with. Conforming applications do not do
this, although some backwards-compatibility support may be
included in some implementations.</p>

<p style="margin-top: 1em">The following characters in
filenames may give trouble: &rsquo;=&rsquo;,
&rsquo;:&rsquo;, &rsquo;&lsquo;&rsquo;, &rsquo;&quot;, and
&rsquo;@&rsquo; . For inference rules, the description of
$&lt; and $? seem similar. However, an example shows the
<br>
minor difference. In a makefile containing:</p>

<p style="margin-top: 1em">foo.o: foo.h</p>

<p style="margin-top: 1em">if foo.h is newer than foo.o,
yet foo.c is older than foo.o, the built-in rule to make
foo.o from foo.c is used, with $&lt; equal to foo.c and $?
equal to foo.h. If foo.c is also <br>
newer than foo.o, $&lt; is equal to foo.c and $? is equal to
foo.h foo.c.</p>

<p style="margin-top: 1em">EXAMPLES <br>
1. The following command:</p>

<p style="margin-top: 1em">make</p>

<p style="margin-top: 1em">makes the first target found in
the makefile.</p>

<p style="margin-top: 1em">2. The following command:</p>

<p style="margin-top: 1em">make junk</p>

<p style="margin-top: 1em">makes the target junk.</p>

<p style="margin-top: 1em">3. The following makefile says
that pgm depends on two files, a.o and b.o, and that they in
turn depend on their corresponding source files ( a.c and
b.c), and a common file <br>
incl.h:</p>

<p style="margin-top: 1em">pgm: a.o b.o <br>
c99 a.o b.o -o pgm <br>
a.o: incl.h a.c <br>
c99 -c a.c <br>
b.o: incl.h b.c <br>
c99 -c b.c</p>

<p style="margin-top: 1em">4. An example for making
optimized .o files from .c files is:</p>

<p style="margin-top: 1em">.c.o: <br>
c99 -c -O $*.c</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">.c.o: <br>
c99 -c -O $&lt;</p>

<p style="margin-top: 1em">5. The most common use of the
archive interface follows. Here, it is assumed that the
source files are all C-language source:</p>

<p style="margin-top: 1em">lib: lib(file1.o) lib(file2.o)
lib(file3.o) <br>
@echo lib is now up-to-date</p>

<p style="margin-top: 1em">The .c.a rule is used to make
file1.o, file2.o, and file3.o and insert them into lib.</p>

<p style="margin-top: 1em">The treatment of escaped
&lt;newline&gt;s throughout the makefile is historical
practice. For example, the inference rule:</p>

<p style="margin-top: 1em">.c.o :</p>

<p style="margin-top: 1em">works, and the macro:</p>

<p style="margin-top: 1em">f= bar baz biz <br>
a: <br>
echo ==$f==</p>

<p style="margin-top: 1em">echoes &quot;==bar baz
biz==&quot; .</p>

<p style="margin-top: 1em">If $? were:</p>

<p style="margin-top: 1em">/usr/include/stdio.h
/usr/include/unistd.h foo.h</p>

<p style="margin-top: 1em">then $(?D) would be:</p>

<p style="margin-top: 1em">/usr/include /usr/include .</p>

<p style="margin-top: 1em">and $(?F) would be:</p>

<p style="margin-top: 1em">stdio.h unistd.h foo.h</p>

<p style="margin-top: 1em">6. The contents of the built-in
rules can be viewed by running:</p>

<p style="margin-top: 1em">make -p -f /dev/null
2&gt;/dev/null</p>

<p style="margin-top: 1em">RATIONALE <br>
The make utility described in this volume of IEEE Std
1003.1-2001 is intended to provide the means for changing
portable source code into executables that can be run on an
<br>
IEEE Std 1003.1-2001-conforming system. It reflects the most
common features present in System V and BSD makes.</p>

<p style="margin-top: 1em">Historically, the make utility
has been an especially fertile ground for vendor and
research organization-specific syntax modifications and
extensions. Examples include:</p>

<p style="margin-top: 1em">* Syntax supporting parallel
execution (such as from various multi-processor vendors,
GNU, and others)</p>

<p style="margin-top: 1em">* Additional
&quot;operators&quot; separating targets and their
prerequisites (System V, BSD, and others)</p>

<p style="margin-top: 1em">* Specifying that command lines
containing the strings &quot;${MAKE}&quot; and
&quot;$(MAKE)&quot; are executed when the -n option is
specified (GNU and System V)</p>

<p style="margin-top: 1em">* Modifications of the meaning
of internal macros when referencing libraries (BSD and
others)</p>

<p style="margin-top: 1em">* Using a single instance of the
shell for all of the command lines of the target (BSD and
others)</p>

<p style="margin-top: 1em">* Allowing spaces as well as
tabs to delimit command lines (BSD)</p>

<p style="margin-top: 1em">* Adding C preprocessor-style
&quot;include&quot; and &quot;ifdef&quot; constructs (System
V, GNU, BSD, and others)</p>

<p style="margin-top: 1em">* Remote execution of command
lines (Sprite and others)</p>

<p style="margin-top: 1em">* Specifying additional special
targets (BSD, System V, and most others)</p>

<p style="margin-top: 1em">Additionally, many vendors and
research organizations have rethought the basic concepts of
make, creating vastly extended, as well as completely new,
syntaxes. Each of these ver&acirc; <br>
sions of make fulfills the needs of a different community of
users; it is unreasonable for this volume of IEEE Std
1003.1-2001 to require behavior that would be incompatible
(and <br>
probably inferior) to historical practice for such a
community.</p>

<p style="margin-top: 1em">In similar circumstances, when
the industry has enough sufficiently incompatible formats as
to make them irreconcilable, this volume of IEEE Std
1003.1-2001 has followed one or <br>
both of two courses of action. Commands have been renamed (
cksum, echo, and pax) and/or command line options have been
provided to select the desired behavior ( grep, od, and <br>
pax).</p>

<p style="margin-top: 1em">Because the syntax specified for
the make utility is, by and large, a subset of the syntaxes
accepted by almost all versions of make, it was decided that
it would be counter-pro&acirc; <br>
ductive to change the name. And since the makefile itself is
a basic unit of portability, it would not be completely
effective to reserve a new option letter, such as make -P,
to <br>
achieve the portable behavior. Therefore, the special target
.POSIX was added to the makefile, allowing users to specify
&quot;standard&quot; behavior. This special target does not
pre&acirc; <br>
clude extensions in the make utility, nor does it preclude
such extensions being used by the makefile specifying the
target; it does, however, preclude any extensions from being
<br>
applied that could alter the behavior of previously valid
syntax; such extensions must be controlled via command line
options or new special targets. It is incumbent upon
porta&acirc; <br>
ble makefiles to specify the .POSIX special target in order
to guarantee that they are not affected by local
extensions.</p>

<p style="margin-top: 1em">The portable version of make
described in this reference page is not intended to be the
state-of-the-art software generation tool and, as such, some
newer and more leading-edge <br>
features have not been included. An attempt has been made to
describe the portable makefile in a manner that does not
preclude such extensions as long as they do not disturb the
<br>
portable behavior described here.</p>

<p style="margin-top: 1em">When the -n option is specified,
it is always added to MAKEFLAGS . This allows a recursive
make -n target to be used to see all of the action that
would be taken to update tar&acirc; <br>
get.</p>

<p style="margin-top: 1em">The definition of MAKEFLAGS
allows both the System V letter string and the BSD command
line formats. The two formats are sufficiently different to
allow implementations to sup&acirc; <br>
port both without ambiguity.</p>

<p style="margin-top: 1em">Early proposals stated that an
&quot;unquoted&quot; number sign was treated as the start of
a comment. The make utility does not pay any attention to
quotes. A number sign starts a comment <br>
regardless of its surroundings.</p>

<p style="margin-top: 1em">The text about &quot;other
implementation-defined pathnames may also be tried&quot; in
addition to ./makefile and ./Makefile is to allow such
extensions as SCCS/s.Makefile and other varia&acirc; <br>
tions. It was made an implementation-defined requirement (as
opposed to unspecified behavior) to highlight surprising
implementations that might select something unexpected like
<br>
/etc/Makefile. XSI-conformant systems also try ./s.makefile,
SCCS/s.makefile, ./s.Makefile, and SCCS/s.Makefile.</p>

<p style="margin-top: 1em">Early proposals contained the
macro NPROC as a means of specifying that make should use n
processes to do the work required. While this feature is a
valuable extension for many <br>
systems, it is not common usage and could require other
non-trivial extensions to makefile syntax. This extension is
not required by this volume of IEEE Std 1003.1-2001, but
<br>
could be provided as a compatible extension. The macro
PARALLEL is used by some historical systems with essentially
the same meaning (but without using a name that is a common
<br>
system limit value). It is suggested that implementors
recognize the existing use of NPROC and/or PARALLEL as
extensions to make.</p>

<p style="margin-top: 1em">The default rules are based on
System V. The default CC= value is c99 instead of cc because
this volume of IEEE Std 1003.1-2001 does not standardize the
utility named cc. Thus, <br>
every conforming application would be required to define CC=
c99 to expect to run. There is no advantage conferred by the
hope that the makefile might hit the &quot;preferred&quot;
com&acirc; <br>
piler because this cannot be guaranteed to work. Also, since
the portable makescript can only use the c99 options, no
advantage is conferred in terms of what the script can do.
<br>
It is a quality-of-implementation issue as to whether c99 is
as valuable as cc.</p>

<p style="margin-top: 1em">The -d option to make is
frequently used to produce debugging information, but is too
implementation-defined to add to this volume of IEEE Std
1003.1-2001.</p>

<p style="margin-top: 1em">The -p option is not passed in
MAKEFLAGS on most historical implementations and to change
this would cause many implementations to break without
sufficiently increased portabil&acirc; <br>
ity.</p>

<p style="margin-top: 1em">Commands that begin with a plus
sign ( &rsquo;+&rsquo; ) are executed even if the -n option
is present. Based on the GNU version of make, the behavior
of -n when the plus-sign prefix is <br>
encountered has been extended to apply to -q and -t as well.
However, the System V convention of forcing command
execution with -n when the command line of a target contains
<br>
either of the strings &quot;$(MAKE)&quot; or
&quot;${MAKE}&quot; has not been adopted. This functionality
appeared in early proposals, but the danger of this approach
was pointed out with the fol&acirc; <br>
lowing example of a portion of a makefile:</p>

<p style="margin-top: 1em">subdir: <br>
cd subdir; rm all_the_files; $(MAKE)</p>

<p style="margin-top: 1em">The loss of the System V
behavior in this case is well-balanced by the safety
afforded to other makefiles that were not aware of this
situation. In any event, the command line <br>
plus-sign prefix can provide the desired functionality.</p>

<p style="margin-top: 1em">The double colon in the target
rule format is supported in BSD systems to allow more than
one target line containing the same target name to have
commands associated with it. <br>
Since this is not functionality described in the SVID or
XPG3 it has been allowed as an extension, but not
mandated.</p>

<p style="margin-top: 1em">The default rules are provided
with text specifying that the built-in rules shall be the
same as if the listed set were used. The intent is that
implementations should be able <br>
to use the rules without change, but will be allowed to
alter them in ways that do not affect the primary
behavior.</p>

<p style="margin-top: 1em">The best way to provide portable
makefiles is to include all of the rules needed in the
makefile itself. The rules provided use only features
provided by other portions of this <br>
volume of IEEE Std 1003.1-2001. The default rules include
rules for optional commands in this volume of IEEE Std
1003.1-2001. Only rules pertaining to commands that are
provided <br>
are needed in the default set of an implementation.</p>

<p style="margin-top: 1em">One point of discussion was
whether to drop the default rules list from this volume of
IEEE Std 1003.1-2001. They provide convenience, but do not
enhance portability of applica&acirc; <br>
tions. The prime benefit is in portability of users who wish
to type make command and have the command build from a
command.c file.</p>

<p style="margin-top: 1em">The historical MAKESHELL feature
was omitted. In some implementations it is used to let a
user override the shell to be used to run make commands.
This was confusing; for a por&acirc; <br>
table make, the shell should be chosen by the makefile
writer or specified on the make command line and not by a
user running make.</p>

<p style="margin-top: 1em">The make utilities in most
historical implementations process the prerequisites of a
target in left-to-right order, and the makefile format
requires this. It supports the stan&acirc; <br>
dard idiom used in many makefiles that produce yacc
programs; for example:</p>

<p style="margin-top: 1em">foo: y.tab.o lex.o main.o <br>
$(CC) $(CFLAGS) -o $@ t.tab.o lex.o main.o</p>

<p style="margin-top: 1em">In this example, if make chose
any arbitrary order, the lex.o might not be made with the
correct y.tab.h. Although there may be better ways to
express this relationship, it is <br>
widely used historically. Implementations that desire to
update prerequisites in parallel should require an explicit
extension to make or the makefile format to accomplish it,
as <br>
described previously.</p>

<p style="margin-top: 1em">The algorithm for determining a
new entry for target rules is partially unspecified. Some
historical makes allow blank, empty, or comment lines within
the collection of commands <br>
marked by leading &lt;tab&gt;s. A conforming makefile must
ensure that each command starts with a &lt;tab&gt;, but
implementations are free to ignore blank, empty, and comment
lines without <br>
triggering the start of a new entry.</p>

<p style="margin-top: 1em">The ASYNCHRONOUS EVENTS section
includes having SIGTERM and SIGHUP, along with the more
traditional SIGINT and SIGQUIT, remove the current target
unless directed not to do so. <br>
SIGTERM and SIGHUP were added to parallel other utilities
that have historically cleaned up their work as a result of
these signals. When make receives any signal other than <br>
SIGQUIT, it is required to resend itself the signal it
received so that it exits with a status that reflects the
signal. The results from SIGQUIT are partially unspecified
<br>
because, on systems that create core files upon receipt of
SIGQUIT, the core from make would conflict with a core file
from the command that was running when the SIGQUIT arrived.
<br>
The main concern was to prevent damaged files from appearing
up-to-date when make is rerun.</p>

<p style="margin-top: 1em">The .PRECIOUS special target was
extended to affect all targets globally (by specifying no
prerequisites). The .IGNORE and .SILENT special targets were
extended to allow prereq&acirc; <br>
uisites; it was judged to be more useful in some cases to be
able to turn off errors or echoing for a list of targets
than for the entire makefile. These extensions to make in
<br>
System V were made to match historical practice from the BSD
make.</p>

<p style="margin-top: 1em">Macros are not exported to the
environment of commands to be run. This was never the case
in any historical make and would have serious consequences.
The environment is the same <br>
as the environment to make except that MAKEFLAGS and macros
defined on the make command line are added.</p>

<p style="margin-top: 1em">Some implementations do not use
system() for all command lines, as required by the portable
makefile format; as a performance enhancement, they select
lines without shell <br>
metacharacters for direct execution by execve(). There is no
requirement that system() be used specifically, but merely
that the same results be achieved. The metacharacters <br>
typically used to bypass the direct execve() execution have
been any of:</p>

<p style="margin-top: 1em">= | ^ ( ) ; &amp; &lt; &gt; * ?
[ ] : $ &lsquo; &rsquo; &quot; &nbsp;</p>

<p style="margin-top: 1em">The default in some advanced
versions of make is to group all the command lines for a
target and execute them using a single shell invocation; the
System V method is to pass each <br>
line individually to a separate shell. The single-shell
method has the advantages in performance and the lack of a
requirement for many continued lines. However, converting to
<br>
this newer method has caused portability problems with many
historical makefiles, so the behavior with the POSIX
makefile is specified to be the same as that of System V. It
is <br>
suggested that the special target .ONESHELL be used as an
implementation extension to achieve the single-shell
grouping for a target or group of targets.</p>

<p style="margin-top: 1em">Novice users of make have had
difficulty with the historical need to start commands with a
&lt;tab&gt;. Since it is often difficult to discern
differences between &lt;tab&gt;s and &lt;space&gt;s <br>
on terminals or printed listings, confusing bugs can arise.
In early proposals, an attempt was made to correct this
problem by allowing leading &lt;blank&gt;s instead of
&lt;tab&gt;s. How&acirc; <br>
ever, implementors reported many makefiles that failed in
subtle ways following this change, and it is difficult to
implement a make that unambiguously can differentiate
between <br>
macro and command lines. There is extensive historical
practice of allowing leading spaces before macro
definitions. Forcing macro lines into column 1 would be a
significant <br>
backwards-compatibility problem for some makefiles.
Therefore, historical practice was restored.</p>

<p style="margin-top: 1em">The System V INCLUDE feature was
considered, but not included. This would treat a line that
began in the first column and contained INCLUDE
&lt;filename&gt; as an indication to read <br>
&lt;filename&gt; at that point in the makefile. This is
difficult to use in a portable way, and it raises concerns
about nesting levels and diagnostics. System V, BSD, GNU,
and others <br>
have used different methods for including files.</p>

<p style="margin-top: 1em">The System V dynamic dependency
feature was not included. It would support:</p>

<p style="margin-top: 1em">cat: $$@.c</p>

<p style="margin-top: 1em">that would expand to;</p>

<p style="margin-top: 1em">cat: cat.c</p>

<p style="margin-top: 1em">This feature exists only in the
new version of System V make and, while useful, is not in
wide usage. This means that macros are expanded twice for
prerequisites: once at make&acirc; <br>
file parse time and once at target update time.</p>

<p style="margin-top: 1em">Consideration was given to
adding metarules to the POSIX make. This would make %.o: %.c
the same as .c.o:. This is quite useful and available from
some vendors, but it would <br>
cause too many changes to this make to support. It would
have introduced rule chaining and new substitution rules.
However, the rules for target names have been set to reserve
<br>
the &rsquo;%&rsquo; and &rsquo;&rsquo; characters. These are
traditionally used to implement metarules and quoting of
target names, respectively. Implementors are strongly
encouraged to use these char&acirc; <br>
acters only for these purposes.</p>

<p style="margin-top: 1em">A request was made to extend the
suffix delimiter character from a period to any character.
The metarules feature in newer makes solves this problem in
a more general way. This <br>
volume of IEEE Std 1003.1-2001 is staying with the more
conservative historical definition.</p>

<p style="margin-top: 1em">The standard output format for
the -p option is not described because it is primarily a
debugging option and because the format is not generally
useful to programs. In historical <br>
implementations the output is not suitable for use in
generating makefiles. The -p format has been variable across
historical implementations. Therefore, the definition of -p
was <br>
only to provide a consistently named option for obtaining
make script debugging information.</p>

<p style="margin-top: 1em">Some historical implementations
have not cleared the suffix list with -r.</p>

<p style="margin-top: 1em">Implementations should be aware
that some historical applications have intermixed
target_name and macro= value operands on the command line,
expecting that all of the macros are <br>
processed before any of the targets are dealt with.
Conforming applications do not do this, but some
backwards-compatibility support may be warranted.</p>

<p style="margin-top: 1em">Empty inference rules are
specified with a semicolon command rather than omitting all
commands, as described in an early proposal. The latter case
has no traditional meaning and <br>
is reserved for implementation extensions, such as in GNU
make.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
None.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Shell Command Language, ar, c99, get, lex, sccs, sh, yacc,
the System Interfaces volume of IEEE Std 1003.1-2001, exec,
system()</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2003 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 6,
Copyright (C) 2001-2003 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. In the event
<br>
of any discrepancy between this version and the original
IEEE and The Open Group Standard, the original IEEE and The
Open Group Standard is the referee document. The original
<br>
Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p style="margin-top: 1em">IEEE/The Open Group 2003
MAKE(1P)</p>
<hr>
</body>
</html>
