<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:45:17 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OD(1P) POSIX Programmer&rsquo;s Manual OD(1P)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
od - dump files in various formats</p>

<p style="margin-top: 1em">SYNOPSIS <br>
od [-v][-A address_base][-j skip][-N count][-t
type_string]... <br>
[file...]</p>

<p style="margin-top: 1em">od [-bcdosx][file]
[[+]offset[.][b]]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The od utility shall write the contents of its input files
to standard output in a user-specified format.</p>

<p style="margin-top: 1em">OPTIONS <br>
The od utility shall conform to the Base Definitions volume
of IEEE Std 1003.1-2001, Section 12.2, Utility Syntax
Guidelines, except that the order of presentation of the -t
<br>
options and the -bcdosx options is significant.</p>

<p style="margin-top: 1em">The following options shall be
supported:</p>

<p style="margin-top: 1em">-A address_base</p>

<p style="margin-top: 1em">Specify the input offset base.
See the EXTENDED DESCRIPTION section. The application shall
ensure that the address_base option-argument is a character.
The characters <br>
&rsquo;d&rsquo;, &rsquo;o&rsquo;, and &rsquo;x&rsquo;
specify that the offset base shall be written in decimal,
octal, or hexadecimal, respectively. The character
&rsquo;n&rsquo; specifies that the offset shall not be <br>
written.</p>

<p style="margin-top: 1em">-b Interpret bytes in octal.
This shall be equivalent to -t o1.</p>

<p style="margin-top: 1em">-c Interpret bytes as characters
specified by the current setting of the LC_CTYPE category.
Certain non-graphic characters appear as C escapes:
&quot;NUL= &quot;, &quot;BS=,FF=,&quot;, &quot;HT=&quot; ;
others appear as 3-digit <br>
&quot;NL=0, &quot;CR= octal numbers.</p>

<p style="margin-top: 1em">-d Interpret words (two-byte
units) in unsigned decimal. This shall be equivalent to -t
u2.</p>

<p style="margin-top: 1em">-j skip <br>
Jump over skip bytes from the beginning of the input. The od
utility shall read or seek past the first skip bytes in the
concatenated input files. If the combined input is <br>
not at least skip bytes long, the od utility shall write a
diagnostic message to standard error and exit with a
non-zero exit status.</p>

<p style="margin-top: 1em">By default, the skip
option-argument shall be interpreted as a decimal number.
With a leading 0x or 0X, the offset shall be interpreted as
a hexadecimal number; otherwise, with a <br>
leading &rsquo;0&rsquo;, the offset shall be interpreted as
an octal number. Appending the character &rsquo;b&rsquo;,
&rsquo;k&rsquo;, or &rsquo;m&rsquo; to offset shall cause it
to be interpreted as a multiple of 512, 1024, <br>
or 1048576 bytes, respectively. If the skip number is
hexadecimal, any appended &rsquo;b&rsquo; shall be
considered to be the final hexadecimal digit.</p>

<p style="margin-top: 1em">-N count <br>
Format no more than count bytes of input. By default, count
shall be interpreted as a decimal number. With a leading 0x
or 0X, count shall be interpreted as a hexadecimal <br>
number; otherwise, with a leading &rsquo;0&rsquo;, it shall
be interpreted as an octal number. If count bytes of input
(after successfully skipping, if -j skip is specified) are
not <br>
available, it shall not be considered an error; the od
utility shall format the input that is available.</p>

<p style="margin-top: 1em">-o Interpret words (two-byte
units) in octal. This shall be equivalent to -t o2.</p>

<p style="margin-top: 1em">-s Interpret words (two-byte
units) in signed decimal. This shall be equivalent to -t
d2.</p>

<p style="margin-top: 1em">-t type_string</p>

<p style="margin-top: 1em">Specify one or more output
types. See the EXTENDED DESCRIPTION section. The application
shall ensure that the type_string option-argument is a
string specifying the types <br>
to be used when writing the input data. The string shall
consist of the type specification characters a, c, d, f, o,
u, and x, specifying named character, character, <br>
signed decimal, floating point, octal, unsigned decimal, and
hexadecimal, respectively. The type specification characters
d, f, o, u, and x can be followed by an optional <br>
unsigned decimal integer that specifies the number of bytes
to be transformed by each instance of the output type. The
type specification character f can be followed by an <br>
optional F, D, or L indicating that the conversion should be
applied to an item of type float, double, or long double,
respectively. The type specification characters d, <br>
o, u, and x can be followed by an optional C, S, I, or L
indicating that the conversion should be applied to an item
of type char, short, int, or long, respectively. Mul&acirc;
<br>
tiple types can be concatenated within the same type_string
and multiple -t options can be specified. Output lines shall
be written for each type specified in the order in <br>
which the type specification characters are specified.</p>

<p style="margin-top: 1em">-v Write all input data. Without
the -v option, any number of groups of output lines, which
would be identical to the immediately preceding group of
output lines (except for <br>
the byte offsets), shall be replaced with a line containing
only an asterisk ( &rsquo;*&rsquo; ).</p>

<p style="margin-top: 1em">-x Interpret words (two-byte
units) in hexadecimal. This shall be equivalent to -t
x2.</p>

<p style="margin-top: 1em">Multiple types can be specified
by using multiple -bcdostx options. Output lines are written
for each type specified in the order in which the types are
specified.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operands shall be supported:</p>

<p style="margin-top: 1em">file A pathname of a file to be
read. If no file operands are specified, the standard input
shall be used.</p>

<p style="margin-top: 1em">If there are no more than two
operands, none of the -A, -j, -N, or -t options is
specified, and either of the following is true: the first
character of the last operand is a plus <br>
sign ( &rsquo;+&rsquo; ), or there are two operands and the
first character of the last operand is numeric; the last
operand shall be interpreted as an offset operand on
XSI-conformant sys&acirc; <br>
tems. Under these conditions, the results are unspecified on
systems that are not XSI-conformant systems.</p>

<p style="margin-top: 1em">[+]offset[.][b] <br>
The offset operand specifies the offset in the file where
dumping is to commence. This operand is normally interpreted
as octal bytes. If &rsquo;.&rsquo; is appended, the offset
shall <br>
be interpreted in decimal. If &rsquo;b&rsquo; is appended,
the offset shall be interpreted in units of 512 bytes.</p>

<p style="margin-top: 1em">STDIN <br>
The standard input shall be used only if no file operands
are specified. See the INPUT FILES section.</p>

<p style="margin-top: 1em">INPUT FILES <br>
The input files can be any file type.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of od:</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of IEEE Std 1003.1-2001,
Section 8.2, Internation&acirc; <br>
alization Variables for the precedence of
internationalization variables used to determine the values
of locale categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_CTYPE <br>
Determine the locale for the interpretation of sequences of
bytes of text data as characters (for example, single-byte
as opposed to multi-byte characters in arguments and <br>
input files).</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">LC_NUMERIC</p>

<p style="margin-top: 1em">Determine the locale for
selecting the radix character used when writing
floating-point formatted output.</p>

<p style="margin-top: 1em">NLSPATH <br>
Determine the location of message catalogs for the
processing of LC_MESSAGES .</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
Default.</p>

<p style="margin-top: 1em">STDOUT <br>
See the EXTENDED DESCRIPTION section.</p>

<p style="margin-top: 1em">STDERR <br>
The standard error shall be used only for diagnostic
messages.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
None.</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
The od utility shall copy sequentially each input file to
standard output, transforming the input data according to
the output types specified by the -t option or the -bcdosx
<br>
options. If no output type is specified, the default output
shall be as if -t oS had been specified.</p>

<p style="margin-top: 1em">The number of bytes transformed
by the output type specifier c may be variable depending on
the LC_CTYPE category.</p>

<p style="margin-top: 1em">The default number of bytes
transformed by output type specifiers d, f, o, u, and x
corresponds to the various C-language types as follows. If
the c99 compiler is present on the <br>
system, these specifiers shall correspond to the sizes used
by default in that compiler. Otherwise, these sizes may vary
among systems that conform to IEEE Std 1003.1-2001.</p>

<p style="margin-top: 1em">* For the type specifier
characters d, o, u, and x, the default number of bytes shall
correspond to the size of the underlying
implementation&rsquo;s basic integer type. For these <br>
specifier characters, the implementation shall support
values of the optional number of bytes to be converted
corresponding to the number of bytes in the C-language types
<br>
char, short, int, and long. These numbers can also be
specified by an application as the characters
&rsquo;C&rsquo;, &rsquo;S&rsquo;, &rsquo;I&rsquo;, and
&rsquo;L&rsquo;, respectively. The implementation shall also
sup&acirc; <br>
port the values 1, 2, 4, and 8, even if it provides no
C-Language types of those sizes. The implementation shall
support the decimal value corresponding to the C-language
<br>
type long long. The byte order used when interpreting
numeric values is implementation-defined, but shall
correspond to the order in which a constant of the
corresponding type <br>
is stored in memory on the system.</p>

<p style="margin-top: 1em">* For the type specifier
character f, the default number of bytes shall correspond to
the number of bytes in the underlying implementation&rsquo;s
basic double precision floating- <br>
point data type. The implementation shall support values of
the optional number of bytes to be converted corresponding
to the number of bytes in the C-language types float, <br>
double, and long double. These numbers can also be specified
by an application as the characters &rsquo;F&rsquo;,
&rsquo;D&rsquo;, and &rsquo;L&rsquo;, respectively.</p>

<p style="margin-top: 1em">The type specifier character a
specifies that bytes shall be interpreted as named
characters from the International Reference Version (IRV) of
the ISO/IEC 646:1991 standard. Only <br>
the least significant seven bits of each byte shall be used
for this type specification. Bytes with the values listed in
the following table shall be written using the corre&acirc;
<br>
sponding names for those characters.</p>

<p style="margin-top: 1em">Table: Named Characters in
od</p>

<p style="margin-top: 1em">Value Name Value Name Value Name
Value Name <br>
00 nul 01 soh 02 stx 03 etx <br>
04 eot 05 enq 06 ack 07 bel <br>
10 bs 11 ht 12 lf or nl 13 vt <br>
14 ff 15 cr 16 so 17 si <br>
20 dle 21 dc1 22 dc2 23 dc3 <br>
24 dc4 25 nak 26 syn 27 etb <br>
30 can 31 em 32 sub 33 esc <br>
34 fs 35 gs 36 rs 37 us <br>
40 sp 177 del</p>

<p style="margin-top: 1em">Note: The &quot; 12&quot; value
may be written either as lf or nl.</p>

<p style="margin-top: 1em">The type specifier character c
specifies that bytes shall be interpreted as characters
specified by the current setting of the LC_CTYPE locale
category. Characters listed in the <br>
table in the Base Definitions volume of IEEE Std
1003.1-2001, Chapter 5, File Format Notation (
&rsquo;\&rsquo; , &rsquo;&rsquo;, &rsquo;,,
&rsquo;0,&rsquo;, &rsquo;&rsquo;, &rsquo; shall be written
as the corre&acirc; &rsquo; <br>
sponding escape sequences, except that backslash shall be
written as a single backslash and a NUL shall be written as
&rsquo; &rsquo; . Other non-printable characters shall be
written as <br>
one three-digit octal number for each byte in the character.
If the size of a byte on the system is greater than nine
bits, the format used for non-printable characters is
imple&acirc; <br>
mentation-defined. Printable multi-byte characters shall be
written in the area corresponding to the first byte of the
character; the two-character sequence &quot;**&quot; shall
be writ&acirc; <br>
ten in the area corresponding to each remaining byte in the
character, as an indication that the character is continued.
When either the -j skip or -N count option is specified <br>
along with the c type specifier, and this results in an
attempt to start or finish in the middle of a multi-byte
character, the result is implementation-defined.</p>

<p style="margin-top: 1em">The input data shall be
manipulated in blocks, where a block is defined as a
multiple of the least common multiple of the number of bytes
transformed by the specified output <br>
types. If the least common multiple is greater than 16, the
results are unspecified. Each input block shall be written
as transformed by each output type, one per written line,
<br>
in the order that the output types were specified. If the
input block size is larger than the number of bytes
transformed by the output type, the output type shall
sequentially <br>
transform the parts of the input block, and the output from
each of the transformations shall be separated by one or
more &lt;blank&gt;s.</p>

<p style="margin-top: 1em">If, as a result of the
specification of the -N option or end-of-file being reached
on the last input file, input data only partially satisfies
an output type, the input shall be <br>
extended sufficiently with null bytes to write the last byte
of the input.</p>

<p style="margin-top: 1em">Unless -A n is specified, the
first output line produced for each input block shall be
preceded by the input offset, cumulative across input files,
of the next byte to be writ&acirc; <br>
ten. The format of the input offset is unspecified; however,
it shall not contain any &lt;blank&gt;s, shall start at the
first character of the output line, and shall be followed by
<br>
one or more &lt;blank&gt;s. In addition, the offset of the
byte following the last byte written shall be written after
all the input data has been processed, but shall not be
followed <br>
by any &lt;blank&gt;s.</p>

<p style="margin-top: 1em">If no -A option is specified,
the input offset base is unspecified.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The following exit values shall be returned:</p>

<p style="margin-top: 1em">0 All input files were processed
successfully.</p>

<p style="margin-top: 1em">&gt;0 An error occurred.</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
Default.</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
XSI-conformant applications are warned not to use filenames
starting with &rsquo;+&rsquo; or a first operand starting
with a numeric character so that the old functionality can
be maintained <br>
by implementations, unless they specify one of the -A, -j,
or -N options. To guarantee that one of these filenames is
always interpreted as a filename, an application could <br>
always specify the address base format with the -A
option.</p>

<p style="margin-top: 1em">EXAMPLES <br>
If a file containing 128 bytes with decimal values zero to
127, in increasing order, is supplied as standard input to
the command:</p>

<p style="margin-top: 1em">od -A d -t a</p>

<p style="margin-top: 1em">on an implementation using an
input block size of 16 bytes, the standard output,
independent of the current locale setting, would be similar
to:</p>

<p style="margin-top: 1em">0000000 nul soh stx etx eot enq
ack bel bs ht nl vt ff cr so si <br>
0000016 dle dc1 dc2 dc3 dc4 nak syn etb can em sub esc fs gs
rs us <br>
0000032 sp ! &quot; # $ % &amp; &rsquo; ( ) * + , - . / <br>
0000048 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? <br>
0000064 @ A B C D E F G H I J K L M N O <br>
0000080 P Q R S T U V W X Y Z [ &nbsp; ] ^ _ <br>
0000096 &lsquo; a b c d e f g h i j k l m n o <br>
0000112 p q r s t u v w x y z { | } ~ del <br>
0000128</p>

<p style="margin-top: 1em">Note that this volume of IEEE
Std 1003.1-2001 allows nl or lf to be used as the name for
the ISO/IEC 646:1991 standard IRV character with decimal
value 10. The IRV names this <br>
character lf (line feed), but traditional implementations
have referred to this character as newline ( nl) and the
POSIX locale character set symbolic name for the
corresponding <br>
character is a &lt;newline&gt;.</p>

<p style="margin-top: 1em">The command:</p>

<p style="margin-top: 1em">od -A o -t o2x2x -N 18</p>

<p style="margin-top: 1em">on a system with 32-bit words
and an implementation using an input block size of 16 bytes
could write 18 bytes in approximately the following
format:</p>

<p style="margin-top: 1em">0000000 032056 031440 041123
042040 052516 044530 020043 031464 <br>
342e 3320 4253 4420 554e 4958 2023 3334 <br>
342e3320 42534420 554e4958 20233334 <br>
0000020 032472 <br>
353a <br>
353a0000 <br>
0000022</p>

<p style="margin-top: 1em">The command:</p>

<p style="margin-top: 1em">od -A d -t f -t o4 -t x4 -N 24
-j 0x15</p>

<p style="margin-top: 1em">on a system with 64-bit doubles
(for example, IEEE Std 754-1985 double precision
floating-point format) would skip 21 bytes of input data and
then write 24 bytes in approximately <br>
the following format:</p>

<p style="margin-top: 1em">0000000 1.00000000000000e+00
1.57350000000000e+01 <br>
07774000000 00000000000 10013674121 35341217270 <br>
3ff00000 00000000 402f3851 eb851eb8 <br>
0000016 1.40668230000000e+02 <br>
10030312542 04370303230 <br>
40619562 23e18698 <br>
0000024</p>

<p style="margin-top: 1em">RATIONALE <br>
The od utility went through several names in early
proposals, including hd, xd, and most recently hexdump.
There were several objections to all of these based on the
following <br>
reasons:</p>

<p style="margin-top: 1em">* The hd and xd names conflicted
with historical utilities that behaved differently.</p>

<p style="margin-top: 1em">* The hexdump description was
much more complex than needed for a simple dump utility.</p>

<p style="margin-top: 1em">* The od utility has been
available on all historical implementations and there was no
need to create a new name for a utility so similar to the
historical od utility.</p>

<p style="margin-top: 1em">The original reasons for not
standardizing historical od were also fairly widespread.
Those reasons are given below along with rationale
explaining why the standard developers <br>
believe that this version does not suffer from the indicated
problem:</p>

<p style="margin-top: 1em">* The BSD and System V versions
of od have diverged, and the intersection of features
provided by both does not meet the needs of the user
community. In fact, the System V ver&acirc; <br>
sion only provides a mechanism for dumping octal bytes and
shorts, signed and unsigned decimal shorts, hexadecimal
shorts, and ASCII characters. BSD added the ability to dump
<br>
floats, doubles, named ASCII characters, and octal, signed
decimal, unsigned decimal, and hexadecimal longs. The
version presented here provides more normalized forms for
<br>
dumping bytes, shorts, ints, and longs in octal, signed
decimal, unsigned decimal, and hexadecimal; float, double,
and long double; and named ASCII as well as current locale
<br>
characters.</p>

<p style="margin-top: 1em">* It would not be possible to
come up with a compatible superset of the BSD and System V
flags that met the requirements of the standard developers.
The historical default od <br>
output is the specified default output of this utility. None
of the option letters chosen for this version of od conflict
with any of the options to historical versions of od.</p>

<p style="margin-top: 1em">* On systems with different
sizes for short, int, and long, there was no way to ask for
dumps of ints, even in the BSD version. Because of the way
options are named, the name <br>
space could not be extended to solve these problems. This is
why the -t option was added (with type specifiers more
closely matched to the printf() formats used in the rest of
<br>
this volume of IEEE Std 1003.1-2001) and the optional field
sizes were added to the d, f, o, u, and x type specifiers.
It is also one of the reasons why the historical prac&acirc;
<br>
tice was not mandated as a required obsolescent form of od.
(Although the old versions of od are not listed as an
obsolescent form, implementations are urged to continue to
<br>
recognize the older forms for several more years.) The a, c,
f, o, and x types match the meaning of the corresponding
format characters in the historical implementations of od
<br>
except for the default sizes of the fields converted. The d
format is signed in this volume of IEEE Std 1003.1-2001 to
match the printf() notation. (Historical versions of od <br>
used d as a synonym for u in this version. The System V
implementation uses s for signed decimal; BSD uses i for
signed decimal and s for null-terminated strings.) Other
than <br>
d and u, all of the type specifiers match format characters
in the historical BSD version of od.</p>

<p style="margin-top: 1em">The sizes of the C-language
types char, short, int, long, float, double, and long double
are used even though it is recognized that there may be zero
or more than one compiler <br>
for the C language on an implementation and that they may
use different sizes for some of these types. (For example,
one compiler might use 2 bytes shorts, 2 bytes ints, and 4
<br>
bytes longs, while another compiler (or an option to the
same compiler) uses 2 bytes shorts, 4 bytes ints, and 4
bytes longs.) Nonetheless, there has to be a basic size
known by <br>
the implementation for these types, corresponding to the
values reported by invocations of the getconf utility when
called with system_var operands {UCHAR_MAX}, {USHORT_MAX},
<br>
{UINT_MAX}, and {ULONG_MAX} for the types char, short, int,
and long, respectively. There are similar constants required
by the ISO C standard, but not required by the System <br>
Interfaces volume of IEEE Std 1003.1-2001 or this volume of
IEEE Std 1003.1-2001. They are {FLT_MANT_DIG},
{DBL_MANT_DIG}, and {LDBL_MANT_DIG} for the types float,
double, and <br>
long double, respectively. If the optional c99 utility is
provided by the implementation and used as specified by this
volume of IEEE Std 1003.1-2001, these are the sizes that
<br>
would be provided. If an option is used that specifies
different sizes for these types, there is no guarantee that
the od utility is able to interpret binary data output by
such <br>
a program correctly.</p>

<p style="margin-top: 1em">This volume of IEEE Std
1003.1-2001 requires that the numeric values of these
lengths be recognized by the od utility and that symbolic
forms also be recognized. Thus, a conform&acirc; <br>
ing application can always look at an array of unsigned long
data elements using od -t uL.</p>

<p style="margin-top: 1em">* The method of specifying the
format for the address field based on specifying a starting
offset in a file unnecessarily tied the two together. The -A
option now specifies the <br>
address base and the -S option specifies a starting
offset.</p>

<p style="margin-top: 1em">* It would be difficult to break
the dependence on U.S. ASCII to achieve an internationalized
utility. It does not seem to be any harder for od to dump
characters in the current <br>
locale than it is for the ed or sed l commands. The c type
specifier does this without difficulty and is completely
compatible with the historical implementations of the c <br>
format character when the current locale uses a superset of
the ISO/IEC 646:1991 standard as a codeset. The a type
specifier (from the BSD a format character) was left as a
<br>
portable means to dump ASCII (or more correctly ISO/IEC
646:1991 standard (IRV)) so that headers produced by pax
could be deciphered even on systems that do not use the <br>
ISO/IEC 646:1991 standard as a subset of their base
codeset.</p>

<p style="margin-top: 1em">The use of &quot;**&quot; as an
indication of continuation of a multi-byte character in c
specifier output was chosen based on seeing an
implementation that uses this method. The continua&acirc;
<br>
tion bytes have to be marked in a way that is not ambiguous
with another single-byte or multi-byte character.</p>

<p style="margin-top: 1em">An early proposal used -S and
-n, respectively, for the -j and -N options eventually
selected. These were changed to avoid conflicts with
historical implementations.</p>

<p style="margin-top: 1em">The original standard specified
-t o2 as the default when no output type was given. This was
changed to -t oS (the length of a short) to accommodate a
supercomputer implementa&acirc; <br>
tion that historically used 64 bits as its default (and that
defined shorts as 64 bits). This change should not affect
conforming applications. The requirement to support lengths
<br>
of 1, 2, and 4 was added at the same time to address an
historical implementation that had no two-byte data types in
its C compiler.</p>

<p style="margin-top: 1em">The use of a basic integer data
type is intended to allow the implementation to choose a
word size commonly used by applications on that
architecture.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
All option and operand interfaces marked as extensions may
be withdrawn in a future version.</p>

<p style="margin-top: 1em">SEE ALSO <br>
c99, sed</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2003 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 6,
Copyright (C) 2001-2003 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. In the event
<br>
of any discrepancy between this version and the original
IEEE and The Open Group Standard, the original IEEE and The
Open Group Standard is the referee document. The original
<br>
Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p style="margin-top: 1em">IEEE/The Open Group 2003
OD(1P)</p>
<hr>
</body>
</html>
