<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:45:21 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>SH(1P) POSIX Programmer&rsquo;s Manual SH(1P)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
sh - shell, the standard command language interpreter</p>

<p style="margin-top: 1em">SYNOPSIS <br>
sh [-abCefhimnuvx][-o option][+abCefhimnuvx][+o option] <br>
[command_file [argument...]]</p>

<p style="margin-top: 1em">sh -c[-abCefhimnuvx][-o
option][+abCefhimnuvx][+o option]command_string <br>
[command_name [argument...]]</p>

<p style="margin-top: 1em">sh -s[-abCefhimnuvx][-o
option][+abCefhimnuvx][+o option][argument]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The sh utility is a command language interpreter that shall
execute commands read from a command line string, the
standard input, or a specified file. The application shall
<br>
ensure that the commands to be executed are expressed in the
language described in Shell Command Language .</p>

<p style="margin-top: 1em">Pathname expansion shall not
fail due to the size of a file.</p>

<p style="margin-top: 1em">Shell input and output
redirections have an implementation-defined offset maximum
that is established in the open file description.</p>

<p style="margin-top: 1em">OPTIONS <br>
The sh utility shall conform to the Base Definitions volume
of IEEE Std 1003.1-2001, Section 12.2, Utility Syntax
Guidelines, with an extension for support of a leading plus
sign <br>
( &rsquo;+&rsquo; ) as noted below.</p>

<p style="margin-top: 1em">The -a, -b, -C, -e, -f, -m, -n,
-o option, -u, -v, and -x options are described as part of
the set utility in Special Built-In Utilities . The option
letters derived from the set <br>
special built-in shall also be accepted with a leading plus
sign ( &rsquo;+&rsquo; ) instead of a leading hyphen
(meaning the reverse case of the option as described in this
volume of <br>
IEEE Std 1003.1-2001).</p>

<p style="margin-top: 1em">The following additional options
shall be supported:</p>

<p style="margin-top: 1em">-c Read commands from the
command_string operand. Set the value of special parameter 0
(see Special Parameters ) from the value of the command_name
operand and the positional <br>
parameters ($1, $2, and so on) in sequence from the
remaining argument operands. No commands shall be read from
the standard input.</p>

<p style="margin-top: 1em">-i Specify that the shell is
interactive; see below. An implementation may treat
specifying the -i option as an error if the real user ID of
the calling process does not <br>
equal the effective user ID or if the real group ID does not
equal the effective group ID.</p>

<p style="margin-top: 1em">-s Read commands from the
standard input.</p>

<p style="margin-top: 1em">If there are no operands and the
-c option is not specified, the -s option shall be
assumed.</p>

<p style="margin-top: 1em">If the -i option is present, or
if there are no operands and the shell&rsquo;s standard
input and standard error are attached to a terminal, the
shell is considered to be interactive.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operands shall be supported:</p>

<p style="margin-top: 1em">- A single hyphen shall be
treated as the first operand and then ignored. If both
&rsquo;-&rsquo; and &quot;--&quot; are given as arguments,
or if other operands precede the single hyphen, the <br>
results are undefined.</p>

<p style="margin-top: 1em">argument <br>
The positional parameters ($1, $2, and so on) shall be set
to arguments, if any.</p>

<p style="margin-top: 1em">command_file <br>
The pathname of a file containing commands. If the pathname
contains one or more slash characters, the implementation
attempts to read that file; the file need not be exe&acirc;
<br>
cutable. If the pathname does not contain a slash
character:</p>

<p style="margin-top: 1em">* The implementation shall
attempt to read that file from the current working
directory; the file need not be executable.</p>

<p style="margin-top: 1em">* If the file is not in the
current working directory, the implementation may perform a
search for an executable file using the value of PATH, as
described in Command <br>
Search and Execution .</p>

<p style="margin-top: 1em">Special parameter 0 (see Special
Parameters ) shall be set to the value of command_file. If
sh is called using a synopsis form that omits command_file,
special parameter 0 shall <br>
be set to the value of the first argument passed to sh from
its parent (for example, argv[0] for a C program), which is
normally a pathname used to execute the sh utility.</p>

<p style="margin-top: 1em">command_name</p>

<p style="margin-top: 1em">A string assigned to special
parameter 0 when executing the commands in command_string.
If command_name is not specified, special parameter 0 shall
be set to the value of <br>
the first argument passed to sh from its parent (for
example, argv[0] for a C program), which is normally a
pathname used to execute the sh utility.</p>

<p style="margin-top: 1em">command_string</p>

<p style="margin-top: 1em">A string that shall be
interpreted by the shell as one or more commands, as if the
string were the argument to the system() function defined in
the System Interfaces vol&acirc; <br>
ume of IEEE Std 1003.1-2001. If the command_string operand
is an empty string, sh shall exit with a zero exit
status.</p>

<p style="margin-top: 1em">STDIN <br>
The standard input shall be used only if one of the
following is true:</p>

<p style="margin-top: 1em">* The -s option is
specified.</p>

<p style="margin-top: 1em">* The -c option is not specified
and no operands are specified.</p>

<p style="margin-top: 1em">* The script executes one or
more commands that require input from standard input (such
as a read command that does not redirect its input).</p>

<p style="margin-top: 1em">See the INPUT FILES section.</p>

<p style="margin-top: 1em">When the shell is using standard
input and it invokes a command that also uses standard
input, the shell shall ensure that the standard input file
pointer points directly after <br>
the command it has read when the command begins execution.
It shall not read ahead in such a manner that any characters
intended to be read by the invoked command are consumed by
<br>
the shell (whether interpreted by the shell or not) or that
characters that are not read by the invoked command are not
seen by the shell. When the command expecting to read <br>
standard input is started asynchronously by an interactive
shell, it is unspecified whether characters are read by the
command or interpreted by the shell.</p>

<p style="margin-top: 1em">If the standard input to sh is a
FIFO or terminal device and is set to non-blocking reads,
then sh shall enable blocking reads on standard input. This
shall remain in effect when <br>
the command completes.</p>

<p style="margin-top: 1em">INPUT FILES <br>
The input file shall be a text file, except that line
lengths shall be unlimited. If the input file is empty or
consists solely of blank lines or comments, or both, sh
shall exit <br>
with a zero exit status.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of sh:</p>

<p style="margin-top: 1em">ENV This variable, when and only
when an interactive shell is invoked, shall be subjected to
parameter expansion (see Parameter Expansion ) by the shell,
and the resulting <br>
value shall be used as a pathname of a file containing shell
commands to execute in the current environment. The file
need not be executable. If the expanded value of ENV <br>
is not an absolute pathname, the results are unspecified.
ENV shall be ignored if the real and effective user IDs or
real and effective group IDs of the process are dif&acirc;
<br>
ferent.</p>

<p style="margin-top: 1em">FCEDIT This variable, when
expanded by the shell, shall determine the default value for
the -e editor option&rsquo;s editor option-argument. If
FCEDIT is null or unset, ed shall be <br>
used as the editor. This volume of IEEE Std 1003.1-2001
specifies the effects of this variable only for systems
supporting the User Portability Utilities option.</p>

<p style="margin-top: 1em">HISTFILE <br>
Determine a pathname naming a command history file. If the
HISTFILE variable is not set, the shell may attempt to
access or create a file .sh_history in the directory <br>
referred to by the HOME environment variable. If the shell
cannot obtain both read and write access to, or create, the
history file, it shall use an unspecified mechanism <br>
that allows the history to operate properly. (References to
history &quot;file&quot; in this section shall be understood
to mean this unspecified mechanism in such cases.) An
imple&acirc; <br>
mentation may choose to access this variable only when
initializing the history file; this initialization shall
occur when fc or sh first attempt to retrieve entries from,
<br>
or add entries to, the file, as the result of commands
issued by the user, the file named by the ENV variable, or
implementation-defined system start-up files.
Implementa&acirc; <br>
tions may choose to disable the history list mechanism for
users with appropriate privileges who do not set HISTFILE ;
the specific circumstances under which this occurs <br>
are implementation-defined. If more than one instance of the
shell is using the same history file, it is unspecified how
updates to the history file from those shells <br>
interact. As entries are deleted from the history file, they
shall be deleted oldest first. It is unspecified when
history file entries are physically removed from the <br>
history file. This volume of IEEE Std 1003.1-2001 specifies
the effects of this variable only for systems supporting the
User Portability Utilities option.</p>

<p style="margin-top: 1em">HISTSIZE <br>
Determine a decimal number representing the limit to the
number of previous commands that are accessible. If this
variable is unset, an unspecified default greater than or
<br>
equal to 128 shall be used. The maximum number of commands
in the history list is unspecified, but shall be at least
128. An implementation may choose to access this vari&acirc;
<br>
able only when initializing the history file, as described
under HISTFILE. Therefore, it is unspecified whether changes
made to HISTSIZE after the history file has been <br>
initialized are effective.</p>

<p style="margin-top: 1em">HOME Determine the pathname of
the user&rsquo;s home directory. The contents of HOME are
used in tilde expansion as described in Tilde Expansion .
This volume of IEEE Std 1003.1-2001 <br>
specifies the effects of this variable only for systems
supporting the User Portability Utilities option.</p>

<p style="margin-top: 1em">IFS (Input Field Separators.) A
string treated as a list of characters that shall be used
for field splitting and to split lines into words with the
read command. See Field <br>
Splitting . If IFS is not set, the shell shall behave as if
the value of IFS were &lt;space&gt;, &lt;tab&gt;, and
&lt;newline&gt;. Implementations may ignore the value of IFS
in the envi&acirc; <br>
ronment at the time sh is invoked, treating IFS as if it
were not set.</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of IEEE Std 1003.1-2001,
Section 8.2, Internation&acirc; <br>
alization Variables for the precedence of
internationalization variables used to determine the values
of locale categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_COLLATE</p>

<p style="margin-top: 1em">Determine the behavior of range
expressions, equivalence classes, and multi-character
collating elements within pattern matching.</p>

<p style="margin-top: 1em">LC_CTYPE <br>
Determine the locale for the interpretation of sequences of
bytes of text data as characters (for example, single-byte
as opposed to multi-byte characters in arguments and <br>
input files), which characters are defined as letters
(character class alpha), and the behavior of character
classes within pattern matching.</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">MAIL Determine a pathname of the
user&rsquo;s mailbox file for purposes of incoming mail
notification. If this variable is set, the shell shall
inform the user if the file named by <br>
the variable is created or if its modification time has
changed. Informing the user shall be accomplished by writing
a string of unspecified format to standard error prior <br>
to the writing of the next primary prompt string. Such check
shall be performed only after the completion of the interval
defined by the MAILCHECK variable after the last <br>
such check. The user shall be informed only if MAIL is set
and MAILPATH is not set. This volume of IEEE Std 1003.1-2001
specifies the effects of this variable only for <br>
systems supporting the User Portability Utilities
option.</p>

<p style="margin-top: 1em">MAILCHECK</p>

<p style="margin-top: 1em">Establish a decimal integer
value that specifies how often (in seconds) the shell shall
check for the arrival of mail in the files specified by the
MAILPATH or MAIL vari&acirc; <br>
ables. The default value shall be 600 seconds. If set to
zero, the shell shall check before issuing each primary
prompt. This volume of IEEE Std 1003.1-2001 specifies the
<br>
effects of this variable only for systems supporting the
User Portability Utilities option.</p>

<p style="margin-top: 1em">MAILPATH <br>
Provide a list of pathnames and optional messages separated
by colons. If this variable is set, the shell shall inform
the user if any of the files named by the variable <br>
are created or if any of their modification times change.
(See the preceding entry for MAIL for descriptions of mail
arrival and user informing.) Each pathname can be fol&acirc;
<br>
lowed by &rsquo;%&rsquo; and a string that shall be
subjected to parameter expansion and written to standard
error when the modification time changes. If a
&rsquo;%&rsquo; character in the path&acirc; <br>
name is preceded by a backslash, it shall be treated as a
literal &rsquo;%&rsquo; in the pathname. The default message
is unspecified.</p>

<p style="margin-top: 1em">The MAILPATH environment
variable takes precedence over the MAIL variable. This
volume of IEEE Std 1003.1-2001 specifies the effects of this
variable only for systems supporting <br>
the User Portability Utilities option.</p>

<p style="margin-top: 1em">NLSPATH <br>
Determine the location of message catalogs for the
processing of LC_MESSAGES .</p>

<p style="margin-top: 1em">PATH Establish a string
formatted as described in the Base Definitions volume of
IEEE Std 1003.1-2001, Chapter 8, Environment Variables, used
to effect command interpretation; <br>
see Command Search and Execution .</p>

<p style="margin-top: 1em">PWD This variable shall
represent an absolute pathname of the current working
directory. Assignments to this variable may be ignored
unless the value is an absolute pathname <br>
of the current working directory and there are no filename
components of dot or dot-dot.</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
Default.</p>

<p style="margin-top: 1em">STDOUT <br>
See the STDERR section.</p>

<p style="margin-top: 1em">STDERR <br>
Except as otherwise stated (by the descriptions of any
invoked utilities or in interactive mode), standard error
shall be used only for diagnostic messages.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
None.</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
See Shell Command Language . The following additional
capabilities are supported on systems supporting the User
Portability Utilities option.</p>

<p style="margin-top: 1em">Command History List <br>
When the sh utility is being used interactively, it shall
maintain a list of commands previously entered from the
terminal in the file named by the HISTFILE environment
variable. <br>
The type, size, and internal format of this file are
unspecified. Multiple sh processes can share access to the
file for a user, if file access permissions allow this; see
the <br>
description of the HISTFILE environment variable.</p>

<p style="margin-top: 1em">Command Line Editing <br>
When sh is being used interactively from a terminal, the
current command and the command history (see fc ) can be
edited using vi-mode command line editing. This mode uses
com&acirc; <br>
mands, described below, similar to a subset of those
described in the vi utility. Implementations may offer other
command line editing modes corresponding to other editing
util&acirc; <br>
ities.</p>

<p style="margin-top: 1em">The command set -o vi shall
enable vi-mode editing and place sh into vi insert mode (see
Command Line Editing (vi-mode) ). This command also shall
disable any other editing mode <br>
that the implementation may provide. The command set +o vi
disables vi-mode editing.</p>

<p style="margin-top: 1em">Certain block-mode terminals may
be unable to support shell command line editing. If a
terminal is unable to provide either edit mode, it need not
be possible to set -o vi when <br>
using the shell on this terminal.</p>

<p style="margin-top: 1em">In the following sections, the
characters erase, interrupt, kill, and end-of-file are those
set by the stty utility.</p>

<p style="margin-top: 1em">Command Line Editing (vi-mode)
<br>
In vi editing mode, there shall be a distinguished line, the
edit line. All the editing operations which modify a line
affect the edit line. The edit line is always the newest
<br>
line in the command history buffer.</p>

<p style="margin-top: 1em">With vi-mode enabled, sh can be
switched between insert mode and command mode.</p>

<p style="margin-top: 1em">When in insert mode, an entered
character shall be inserted into the command line, except as
noted in vi Line Editing Insert Mode . Upon entering sh and
after termination of the <br>
previous command, sh shall be in insert mode.</p>

<p style="margin-top: 1em">Typing an escape character shall
switch sh into command mode (see vi Line Editing Command
Mode ). In command mode, an entered character shall either
invoke a defined operation, <br>
be used as part of a multi-character operation, or be
treated as an error. A character that is not recognized as
part of an editing command shall terminate any specific
editing <br>
command and shall alert the terminal. Typing the interrupt
character in command mode shall cause sh to terminate
command line editing on the current command line, reissue
the <br>
prompt on the next line of the terminal, and reset the
command history (see fc ) so that the most recently executed
command is the previous command (that is, the command that
was <br>
being edited when it was interrupted is not reentered into
the history).</p>

<p style="margin-top: 1em">In the following sections, the
phrase &quot;move the cursor to the beginning of the
word&quot; shall mean &quot;move the cursor to the first
character of the current word&quot; and the phrase
&quot;move <br>
the cursor to the end of the word&quot; shall mean
&quot;move the cursor to the last character of the current
word&quot;. The phrase &quot;beginning of the command
line&quot; indicates the point between <br>
the end of the prompt string issued by the shell (or the
beginning of the terminal line, if there is no prompt
string) and the first character of the command text.</p>

<p style="margin-top: 1em">vi Line Editing Insert Mode <br>
While in insert mode, any character typed shall be inserted
in the current command line, unless it is from the following
set.</p>

<p style="margin-top: 1em">&lt;newline&gt; <br>
Execute the current command line. If the current command
line is not empty, this line shall be entered into the
command history (see fc ).</p>

<p style="margin-top: 1em">erase Delete the character
previous to the current cursor position and move the current
cursor position back one character. In insert mode,
characters shall be erased from both <br>
the screen and the buffer when backspacing.</p>

<p style="margin-top: 1em">interrupt <br>
Terminate command line editing with the same effects as
described for interrupting command mode; see Command Line
Editing (vi-mode) .</p>

<p style="margin-top: 1em">kill Clear all the characters
from the input line.</p>

<p style="margin-top: 1em">&lt;control&gt;-V <br>
Insert the next character input, even if the character is
otherwise a special insert mode character.</p>

<p style="margin-top: 1em">&lt;control&gt;-W <br>
Delete the characters from the one preceding the cursor to
the preceding word boundary. The word boundary in this case
is the closer to the cursor of either the beginning <br>
of the line or a character that is in neither the blank nor
punct character classification of the current locale.</p>

<p style="margin-top: 1em">end-of-file <br>
Interpreted as the end of input in sh. This interpretation
shall occur only at the beginning of an input line. If
end-of-file is entered other than at the beginning of the
<br>
line, the results are unspecified.</p>

<p style="margin-top: 1em">&lt;ESC&gt; Place sh into
command mode.</p>

<p style="margin-top: 1em">vi Line Editing Command Mode
<br>
In command mode for the command line editing feature,
decimal digits not beginning with 0 that precede a command
letter shall be remembered. Some commands use these decimal
dig&acirc; <br>
its as a count number that affects the operation.</p>

<p style="margin-top: 1em">The term motion command
represents one of the commands:</p>

<p style="margin-top: 1em">&lt;space&gt; 0 b F l W ^ $ ; E
f T w | , B e h t</p>

<p style="margin-top: 1em">If the current line is not the
edit line, any command that modifies the current line shall
cause the content of the current line to replace the content
of the edit line, and the <br>
current line shall become the edit line. This replacement
cannot be undone (see the u and U commands below). The
modification requested shall then be performed to the edit
line. <br>
When the current line is the edit line, the modification
shall be done directly to the edit line.</p>

<p style="margin-top: 1em">Any command that is preceded by
count shall take a count (the numeric value of any preceding
decimal digits). Unless otherwise noted, this count shall
cause the specified opera&acirc; <br>
tion to repeat by the number of times specified by the
count. Also unless otherwise noted, a count that is out of
range is considered an error condition and shall alert the
ter&acirc; <br>
minal, but neither the cursor position, nor the command
line, shall change.</p>

<p style="margin-top: 1em">The terms word and bigword are
used as defined in the vi description. The term save buffer
corresponds to the term unnamed buffer in vi.</p>

<p style="margin-top: 1em">The following commands shall be
recognized in command mode:</p>

<p style="margin-top: 1em">&lt;newline&gt; <br>
Execute the current command line. If the current command
line is not empty, this line shall be entered into the
command history (see fc ).</p>

<p style="margin-top: 1em">&lt;control&gt;-L <br>
Redraw the current command line. Position the cursor at the
same location on the redrawn line.</p>

<p style="margin-top: 1em"># Insert the character
&rsquo;#&rsquo; at the beginning of the current command line
and treat the resulting edit line as a comment. This line
shall be entered into the command history; <br>
see fc .</p>

<p style="margin-top: 1em">= Display the possible shell
word expansions (see Word Expansions ) of the bigword at the
current command line position.</p>

<p style="margin-top: 1em">Note: <br>
This does not modify the content of the current line, and
therefore does not cause the current line to become the edit
line.</p>

<p style="margin-top: 1em">These expansions shall be
displayed on subsequent terminal lines. If the bigword
contains none of the characters &rsquo;?&rsquo;,
&rsquo;*&rsquo;, or &rsquo;[&rsquo;, an asterisk (
&rsquo;*&rsquo; ) shall be implicitly <br>
assumed at the end. If any directories are matched, these
expansions shall have a &rsquo;/&rsquo; character appended.
After the expansion, the line shall be redrawn, the cursor
repositioned <br>
at the current cursor position, and sh shall be placed in
command mode. &nbsp;</p>

<p style="margin-top: 1em">Perform pathname expansion (see
Pathname Expansion ) on the current bigword, up to the
largest set of characters that can be matched uniquely. If
the bigword contains <br>
none of the characters &rsquo;?&rsquo;, &rsquo;*&rsquo;, or
&rsquo;[&rsquo;, an asterisk ( &rsquo;*&rsquo; ) shall be
implicitly assumed at the end. This maximal expansion then
shall replace the original bigword in the <br>
command line, and the cursor shall be placed after this
expansion. If the resulting bigword completely and uniquely
matches a directory, a &rsquo;/&rsquo; character shall be
inserted <br>
directly after the bigword. If some other file is completely
matched, a single &lt;space&gt; shall be inserted after the
bigword. After this operation, sh shall be placed in <br>
insert mode.</p>

<p style="margin-top: 1em">* Perform pathname expansion on
the current bigword and insert all expansions into the
command to replace the current bigword, with each expansion
separated by a single <br>
&lt;space&gt;. If at the end of the line, the current cursor
position shall be moved to the first column position
following the expansions and sh shall be placed in insert
mode. <br>
Otherwise, the current cursor position shall be the last
column position of the first character after the expansions
and sh shall be placed in insert mode. If the current <br>
bigword contains none of the characters &rsquo;?&rsquo;,
&rsquo;*&rsquo;, or &rsquo;[&rsquo;, before the operation,
an asterisk shall be implicitly assumed at the end.</p>

<p style="margin-top: 1em">@letter <br>
Insert the value of the alias named _letter. The symbol
letter represents a single alphabetic character from the
portable character set; implementations may support
addi&acirc; <br>
tional characters as an extension. If the alias _letter
contains other editing commands, these commands shall be
performed as part of the insertion. If no alias _letter is
<br>
enabled, this command shall have no effect.</p>

<p style="margin-top: 1em">[count]~ <br>
Convert, if the current character is a lowercase letter, to
the equivalent uppercase letter and vice versa, as
prescribed by the current locale. The current cursor
posi&acirc; <br>
tion then shall be advanced by one character. If the cursor
was positioned on the last character of the line, the case
conversion shall occur, but the cursor shall not <br>
advance. If the &rsquo;~&rsquo; command is preceded by a
count, that number of characters shall be converted, and the
cursor shall be advanced to the character position after the
last <br>
character converted. If the count is larger than the number
of characters after the cursor, this shall not be considered
an error; the cursor shall advance to the last <br>
character on the line.</p>

<p style="margin-top: 1em">[count]. <br>
Repeat the most recent non-motion command, even if it was
executed on an earlier command line. If the previous command
was preceded by a count, and no count is given on <br>
the &rsquo;.&rsquo; command, the count from the previous
command shall be included as part of the repeated command.
If the &rsquo;.&rsquo; command is preceded by a count, this
shall override any <br>
count argument to the previous command. The count specified
in the &rsquo;.&rsquo; command shall become the count for
subsequent &rsquo;.&rsquo; commands issued without a
count.</p>

<p style="margin-top: 1em">[number]v <br>
Invoke the vi editor to edit the current command line in a
temporary file. When the editor exits, the commands in the
temporary file shall be executed and placed in the <br>
command history. If a number is included, it specifies the
command number in the command history to be edited, rather
than the current command line.</p>

<p style="margin-top: 1em">[count]l (ell)</p>

<p style="margin-top: 1em">[count]&lt;space&gt;</p>

<p style="margin-top: 1em">Move the current cursor position
to the next character position. If the cursor was positioned
on the last character of the line, the terminal shall be
alerted and the cur&acirc; <br>
sor shall not be advanced. If the count is larger than the
number of characters after the cursor, this shall not be
considered an error; the cursor shall advance to the <br>
last character on the line.</p>

<p style="margin-top: 1em">[count]h <br>
Move the current cursor position to the countth (default 1)
previous character position. If the cursor was positioned on
the first character of the line, the terminal <br>
shall be alerted and the cursor shall not be moved. If the
count is larger than the number of characters before the
cursor, this shall not be considered an error; the
cur&acirc; <br>
sor shall move to the first character on the line.</p>

<p style="margin-top: 1em">[count]w <br>
Move to the start of the next word. If the cursor was
positioned on the last character of the line, the terminal
shall be alerted and the cursor shall not be advanced. If
<br>
the count is larger than the number of words after the
cursor, this shall not be considered an error; the cursor
shall advance to the last character on the line.</p>

<p style="margin-top: 1em">[count]W <br>
Move to the start of the next bigword. If the cursor was
positioned on the last character of the line, the terminal
shall be alerted and the cursor shall not be advanced. <br>
If the count is larger than the number of bigwords after the
cursor, this shall not be considered an error; the cursor
shall advance to the last character on the line.</p>

<p style="margin-top: 1em">[count]e <br>
Move to the end of the current word. If at the end of a
word, move to the end of the next word. If the cursor was
positioned on the last character of the line, the
termi&acirc; <br>
nal shall be alerted and the cursor shall not be advanced.
If the count is larger than the number of words after the
cursor, this shall not be considered an error; the <br>
cursor shall advance to the last character on the line.</p>

<p style="margin-top: 1em">[count]E <br>
Move to the end of the current bigword. If at the end of a
bigword, move to the end of the next bigword. If the cursor
was positioned on the last character of the line, <br>
the terminal shall be alerted and the cursor shall not be
advanced. If the count is larger than the number of bigwords
after the cursor, this shall not be considered an <br>
error; the cursor shall advance to the last character on the
line.</p>

<p style="margin-top: 1em">[count]b <br>
Move to the beginning of the current word. If at the
beginning of a word, move to the beginning of the previous
word. If the cursor was positioned on the first character
<br>
of the line, the terminal shall be alerted and the cursor
shall not be moved. If the count is larger than the number
of words preceding the cursor, this shall not be con&acirc;
<br>
sidered an error; the cursor shall return to the first
character on the line.</p>

<p style="margin-top: 1em">[count]B <br>
Move to the beginning of the current bigword. If at the
beginning of a bigword, move to the beginning of the
previous bigword. If the cursor was positioned on the first
<br>
character of the line, the terminal shall be alerted and the
cursor shall not be moved. If the count is larger than the
number of bigwords preceding the cursor, this <br>
shall not be considered an error; the cursor shall return to
the first character on the line.</p>

<p style="margin-top: 1em">^ Move the current cursor
position to the first character on the input line that is
not a &lt;blank&gt;.</p>

<p style="margin-top: 1em">$ Move to the last character
position on the current command line.</p>

<p style="margin-top: 1em">0 (Zero.) Move to the first
character position on the current command line.</p>

<p style="margin-top: 1em">[count]| <br>
Move to the countth character position on the current
command line. If no number is specified, move to the first
position. The first character position shall be numbered
<br>
1. If the count is larger than the number of characters on
the line, this shall not be considered an error; the cursor
shall be placed on the last character on the line.</p>

<p style="margin-top: 1em">[count]fc <br>
Move to the first occurrence of the character
&rsquo;c&rsquo; that occurs after the current cursor
position. If the cursor was positioned on the last character
of the line, the termi&acirc; <br>
nal shall be alerted and the cursor shall not be advanced.
If the character &rsquo;c&rsquo; does not occur in the line
after the current cursor position, the terminal shall be
alerted <br>
and the cursor shall not be moved.</p>

<p style="margin-top: 1em">[count]Fc <br>
Move to the first occurrence of the character
&rsquo;c&rsquo; that occurs before the current cursor
position. If the cursor was positioned on the first
character of the line, the ter&acirc; <br>
minal shall be alerted and the cursor shall not be moved. If
the character &rsquo;c&rsquo; does not occur in the line
before the current cursor position, the terminal shall be
alerted <br>
and the cursor shall not be moved.</p>

<p style="margin-top: 1em">[count]tc <br>
Move to the character before the first occurrence of the
character &rsquo;c&rsquo; that occurs after the current
cursor position. If the cursor was positioned on the last
character <br>
of the line, the terminal shall be alerted and the cursor
shall not be advanced. If the character &rsquo;c&rsquo; does
not occur in the line after the current cursor position, the
<br>
terminal shall be alerted and the cursor shall not be
moved.</p>

<p style="margin-top: 1em">[count]Tc <br>
Move to the character after the first occurrence of the
character &rsquo;c&rsquo; that occurs before the current
cursor position. If the cursor was positioned on the first
character <br>
of the line, the terminal shall be alerted and the cursor
shall not be moved. If the character &rsquo;c&rsquo; does
not occur in the line before the current cursor position,
the ter&acirc; <br>
minal shall be alerted and the cursor shall not be
moved.</p>

<p style="margin-top: 1em">[count]; <br>
Repeat the most recent f, F, t, or T command. Any number
argument on that previous command shall be ignored. Errors
are those described for the repeated command.</p>

<p style="margin-top: 1em">[count], <br>
Repeat the most recent f, F, t, or T command. Any number
argument on that previous command shall be ignored. However,
reverse the direction of that command.</p>

<p style="margin-top: 1em">a Enter insert mode after the
current cursor position. Characters that are entered shall
be inserted before the next character.</p>

<p style="margin-top: 1em">A Enter insert mode after the
end of the current command line.</p>

<p style="margin-top: 1em">i Enter insert mode at the
current cursor position. Characters that are entered shall
be inserted before the current character.</p>

<p style="margin-top: 1em">I Enter insert mode at the
beginning of the current command line.</p>

<p style="margin-top: 1em">R Enter insert mode, replacing
characters from the command line beginning at the current
cursor position.</p>

<p style="margin-top: 1em">[count]cmotion</p>

<p style="margin-top: 1em">Delete the characters between
the current cursor position and the cursor position that
would result from the specified motion command. Then enter
insert mode before the <br>
first character following any deleted characters. If count
is specified, it shall be applied to the motion command. A
count shall be ignored for the following motion com&acirc;
<br>
mands:</p>

<p style="margin-top: 1em">0 ^ $ c</p>

<p style="margin-top: 1em">If the motion command is the
character &rsquo;c&rsquo;, the current command line shall be
cleared and insert mode shall be entered. If the motion
command would move the current cursor posi&acirc; <br>
tion toward the beginning of the command line, the character
under the current cursor position shall not be deleted. If
the motion command would move the current cursor position
<br>
toward the end of the command line, the character under the
current cursor position shall be deleted. If the count is
larger than the number of characters between the current
<br>
cursor position and the end of the command line toward which
the motion command would move the cursor, this shall not be
considered an error; all of the remaining characters in <br>
the aforementioned range shall be deleted and insert mode
shall be entered. If the motion command is invalid, the
terminal shall be alerted, the cursor shall not be moved,
and no <br>
text shall be deleted.</p>

<p style="margin-top: 1em">C Delete from the current
character to the end of the line and enter insert mode at
the new end-of-line.</p>

<p style="margin-top: 1em">S Clear the entire edit line and
enter insert mode.</p>

<p style="margin-top: 1em">[count]rc <br>
Replace the current character with the character
&rsquo;c&rsquo; . With a number count, replace the current
and the following count-1 characters. After this command,
the current cur&acirc; <br>
sor position shall be on the last character that was
changed. If the count is larger than the number of
characters after the cursor, this shall not be considered an
error; <br>
all of the remaining characters shall be changed.</p>

<p style="margin-top: 1em">[count]_ <br>
Append a &lt;space&gt; after the current character position
and then append the last bigword in the previous input line
after the &lt;space&gt;. Then enter insert mode after the
last <br>
character just appended. With a number count, append the
countth bigword in the previous line.</p>

<p style="margin-top: 1em">[count]x <br>
Delete the character at the current cursor position and
place the deleted characters in the save buffer. If the
cursor was positioned on the last character of the line,
<br>
the character shall be deleted and the cursor position shall
be moved to the previous character (the new last character).
If the count is larger than the number of charac&acirc; <br>
ters after the cursor, this shall not be considered an
error; all the characters from the cursor to the end of the
line shall be deleted.</p>

<p style="margin-top: 1em">[count]X <br>
Delete the character before the current cursor position and
place the deleted characters in the save buffer. The
character under the current cursor position shall not <br>
change. If the cursor was positioned on the first character
of the line, the terminal shall be alerted, and the X
command shall have no effect. If the line contained a <br>
single character, the X command shall have no effect. If the
line contained no characters, the terminal shall be alerted
and the cursor shall not be moved. If the count is <br>
larger than the number of characters before the cursor, this
shall not be considered an error; all the characters from
before the cursor to the beginning of the line shall <br>
be deleted.</p>

<p style="margin-top: 1em">[count]dmotion</p>

<p style="margin-top: 1em">Delete the characters between
the current cursor position and the character position that
would result from the motion command. A number count repeats
the motion command <br>
count times. If the motion command would move toward the
beginning of the command line, the character under the
current cursor position shall not be deleted. If the motion
<br>
command is d, the entire current command line shall be
cleared. If the count is larger than the number of
characters between the current cursor position and the end
of the <br>
command line toward which the motion command would move the
cursor, this shall not be considered an error; all of the
remaining characters in the aforementioned range <br>
shall be deleted. The deleted characters shall be placed in
the save buffer.</p>

<p style="margin-top: 1em">D Delete all characters from the
current cursor position to the end of the line. The deleted
characters shall be placed in the save buffer.</p>

<p style="margin-top: 1em">[count]ymotion</p>

<p style="margin-top: 1em">Yank (that is, copy) the
characters from the current cursor position to the position
resulting from the motion command into the save buffer. A
number count shall be <br>
applied to the motion command. If the motion command would
move toward the beginning of the command line, the character
under the current cursor position shall not be <br>
included in the set of yanked characters. If the motion
command is y, the entire current command line shall be
yanked into the save buffer. The current cursor position
<br>
shall be unchanged. If the count is larger than the number
of characters between the current cursor position and the
end of the command line toward which the motion com&acirc;
<br>
mand would move the cursor, this shall not be considered an
error; all of the remaining characters in the aforementioned
range shall be yanked.</p>

<p style="margin-top: 1em">Y Yank the characters from the
current cursor position to the end of the line into the save
buffer. The current character position shall be
unchanged.</p>

<p style="margin-top: 1em">[count]p <br>
Put a copy of the current contents of the save buffer after
the current cursor position. The current cursor position
shall be advanced to the last character put from the <br>
save buffer. A count shall indicate how many copies of the
save buffer shall be put.</p>

<p style="margin-top: 1em">[count]P <br>
Put a copy of the current contents of the save buffer before
the current cursor position. The current cursor position
shall be moved to the last character put from the <br>
save buffer. A count shall indicate how many copies of the
save buffer shall be put.</p>

<p style="margin-top: 1em">u Undo the last command that
changed the edit line. This operation shall not undo the
copy of any command line to the edit line.</p>

<p style="margin-top: 1em">U Undo all changes made to the
edit line. This operation shall not undo the copy of any
command line to the edit line.</p>

<p style="margin-top: 1em">[count]k</p>

<p style="margin-top: 1em">[count]- <br>
Set the current command line to be the countth previous
command line in the shell command history. If count is not
specified, it shall default to 1. The cursor shall be <br>
positioned on the first character of the new command. If a k
or - command would retreat past the maximum number of
commands in effect for this shell (affected by the
HIST&acirc; <br>
SIZE environment variable), the terminal shall be alerted,
and the command shall have no effect.</p>

<p style="margin-top: 1em">[count]j</p>

<p style="margin-top: 1em">[count]+ <br>
Set the current command line to be the countth next command
line in the shell command history. If count is not
specified, it shall default to 1. The cursor shall be
posi&acirc; <br>
tioned on the first character of the new command. If a j or
+ command advances past the edit line, the current command
line shall be restored to the edit line and the ter&acirc;
<br>
minal shall be alerted.</p>

<p style="margin-top: 1em">[number]G <br>
Set the current command line to be the oldest command line
stored in the shell command history. With a number number,
set the current command line to be the command line <br>
number in the history. If command line number does not
exist, the terminal shall be alerted and the command line
shall not be changed.</p>

<p style="margin-top: 1em">/pattern&lt;newline&gt;</p>

<p style="margin-top: 1em">Move backwards through the
command history, searching for the specified pattern,
beginning with the previous command line. Patterns use the
pattern matching notation <br>
described in Pattern Matching Notation, except that the
&rsquo;^&rsquo; character shall have special meaning when it
appears as the first character of pattern. In this case, the
&rsquo;^&rsquo; <br>
is discarded and the characters after the &rsquo;^&rsquo;
shall be matched only at the beginning of a line. Commands
in the command history shall be treated as strings, not as
file&acirc; <br>
names. If the pattern is not found, the current command line
shall be unchanged and the terminal is alerted. If it is
found in a previous line, the current command line <br>
shall be set to that line and the cursor shall be set to the
first character of the new command line.</p>

<p style="margin-top: 1em">If pattern is empty, the last
non-empty pattern provided to / or ? shall be used. If there
is no previous non-empty pattern, the terminal shall be
alerted and the current command <br>
line shall remain unchanged.</p>

<p style="margin-top: 1em">?pattern&lt;newline&gt;</p>

<p style="margin-top: 1em">Move forwards through the
command history, searching for the specified pattern,
beginning with the next command line. Patterns use the
pattern matching notation described <br>
in Pattern Matching Notation, except that the
&rsquo;^&rsquo; character shall have special meaning when it
appears as the first character of pattern. In this case, the
&rsquo;^&rsquo; is dis&acirc; <br>
carded and the characters after the &rsquo;^&rsquo; shall be
matched only at the beginning of a line. Commands in the
command history shall be treated as strings, not as
filenames. <br>
If the pattern is not found, the current command line shall
be unchanged and the terminal alerted. If it is found in a
following line, the current command line shall be <br>
set to that line and the cursor shall be set to the fist
character of the new command line.</p>

<p style="margin-top: 1em">If pattern is empty, the last
non-empty pattern provided to / or ? shall be used. If there
is no previous non-empty pattern, the terminal shall be
alerted and the current command <br>
line shall remain unchanged.</p>

<p style="margin-top: 1em">n Repeat the most recent / or ?
command. If there is no previous / or ?, the terminal shall
be alerted and the current command line shall remain
unchanged.</p>

<p style="margin-top: 1em">N Repeat the most recent / or ?
command, reversing the direction of the search. If there is
no previous / or ?, the terminal shall be alerted and the
current command line <br>
shall remain unchanged.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The following exit values shall be returned:</p>

<p style="margin-top: 1em">0 The script to be executed
consisted solely of zero or more blank lines or comments, or
both.</p>

<p style="margin-top: 1em">1-125 A non-interactive shell
detected a syntax, redirection, or variable assignment
error.</p>

<p style="margin-top: 1em">127 A specified command_file
could not be found by a non-interactive shell.</p>

<p style="margin-top: 1em">Otherwise, the shell shall
return the exit status of the last command it invoked or
attempted to invoke (see also the exit utility in Special
Built-In Utilities ).</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
See Consequences of Shell Errors .</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
Standard input and standard error are the files that
determine whether a shell is interactive when -i is not
specified. For example:</p>

<p style="margin-top: 1em">sh &gt; file</p>

<p style="margin-top: 1em">and:</p>

<p style="margin-top: 1em">sh 2&gt; file</p>

<p style="margin-top: 1em">create interactive and
non-interactive shells, respectively. Although both accept
terminal input, the results of error conditions are
different, as described in Consequences of <br>
Shell Errors ; in the second example a redirection error
encountered by a special built-in utility aborts the
shell.</p>

<p style="margin-top: 1em">A conforming application must
protect its first operand, if it starts with a plus sign, by
preceding it with the &quot;--&quot; argument that denotes
the end of the options.</p>

<p style="margin-top: 1em">Applications should note that
the standard PATH to the shell cannot be assumed to be
either /bin/sh or /usr/bin/sh, and should be determined by
interrogation of the PATH returned <br>
by getconf PATH, ensuring that the returned pathname is an
absolute pathname and not a shell built-in.</p>

<p style="margin-top: 1em">For example, to determine the
location of the standard sh utility:</p>

<p style="margin-top: 1em">command -v sh</p>

<p style="margin-top: 1em">On some implementations this
might return:</p>

<p style="margin-top: 1em">/usr/xpg4/bin/sh</p>

<p style="margin-top: 1em">Furthermore, on systems that
support executable scripts (the &quot;#!&quot; construct),
it is recommended that applications using executable scripts
install them using getconf -v to <br>
determine the shell pathname and update the &quot;#!&quot;
script appropriately as it is being installed (for example,
with sed). For example:</p>

<p style="margin-top: 1em"># <br>
# Installation time script to install correct POSIX shell
pathname <br>
# <br>
# Get list of paths to check <br>
# <br>
Sifs=$IFS <br>
IFS=: <br>
set $(getconf PATH) <br>
IFS=$Sifs <br>
# <br>
# Check each path for &rsquo;sh&rsquo; <br>
# <br>
for i in $@ <br>
do <br>
if [ -f ${i}/sh ]; <br>
then <br>
Pshell=${i}/sh <br>
fi <br>
done <br>
# <br>
# This is the list of scripts to update. They should be of
the <br>
# form &rsquo;${name}.source&rsquo; and will be transformed
to &rsquo;${name}&rsquo;. <br>
# Each script should begin: <br>
# <br>
# !INSTALLSHELLPATH -p <br>
# <br>
scripts=&quot;a b c&quot; <br>
# <br>
# Transform each script <br>
# <br>
for i in ${scripts} <br>
do <br>
sed -e &quot;s|INSTALLSHELLPATH|${Pshell}|&quot; &lt;
${i}.source &gt; ${i} <br>
done</p>

<p style="margin-top: 1em">EXAMPLES <br>
1. Execute a shell command from a string:</p>

<p style="margin-top: 1em">sh -c &quot;cat myfile&quot;</p>

<p style="margin-top: 1em">2. Execute a shell script from a
file in the current directory:</p>

<p style="margin-top: 1em">sh my_shell_cmds</p>

<p style="margin-top: 1em">RATIONALE <br>
The sh utility and the set special built-in utility share a
common set of options.</p>

<p style="margin-top: 1em">The KornShell ignores the
contents of IFS upon entry to the script. A conforming
application cannot rely on importing IFS. One justification
for this, beyond security considera&acirc; <br>
tions, is to assist possible future shell compilers.
Allowing IFS to be imported from the environment prevents
many optimizations that might otherwise be performed via
dataflow <br>
analysis of the script itself.</p>

<p style="margin-top: 1em">The text in the STDIN section
about non-blocking reads concerns an instance of sh that has
been invoked, probably by a C-language program, with
standard input that has been <br>
opened using the O_NONBLOCK flag; see open() in the System
Interfaces volume of IEEE Std 1003.1-2001. If the shell did
not reset this flag, it would immediately terminate because
<br>
no input data would be available yet and that would be
considered the same as end-of-file.</p>

<p style="margin-top: 1em">The options associated with a
restricted shell (command name rsh and the -r option) were
excluded because the standard developers considered that the
implied level of security <br>
could not be achieved and they did not want to raise false
expectations.</p>

<p style="margin-top: 1em">On systems that support
set-user-ID scripts, a historical trapdoor has been to link
a script to the name -i. When it is called by a sequence
such as:</p>

<p style="margin-top: 1em">sh -</p>

<p style="margin-top: 1em">or by:</p>

<p style="margin-top: 1em">#! usr/bin/sh -</p>

<p style="margin-top: 1em">the historical systems have
assumed that no option letters follow. Thus, this volume of
IEEE Std 1003.1-2001 allows the single hyphen to mark the
end of the options, in addition <br>
to the use of the regular &quot;--&quot; argument, because
it was considered that the older practice was so pervasive.
An alternative approach is taken by the KornShell, where
real and <br>
effective user/group IDs must match for an interactive
shell; this behavior is specifically allowed by this volume
of IEEE Std 1003.1-2001.</p>

<p style="margin-top: 1em">Note: There are other problems
with set-user-ID scripts that the two approaches described
here do not resolve.</p>

<p style="margin-top: 1em">The initialization process for
the history file can be dependent on the system start-up
files, in that they may contain commands that effectively
preempt the user&rsquo;s settings of <br>
HISTFILE and HISTSIZE. For example, function definition
commands are recorded in the history file, unless the set -o
nolog option is set. If the system administrator includes
<br>
function definitions in some system start-up file called
before the ENV file, the history file is initialized before
the user gets a chance to influence its characteristics. In
<br>
some historical shells, the history file is initialized just
after the ENV file has been processed. Therefore, it is
implementation-defined whether changes made to HISTFILE <br>
after the history file has been initialized are
effective.</p>

<p style="margin-top: 1em">The default messages for the
various MAIL -related messages are unspecified because they
vary across implementations. Typical messages are:</p>

<p style="margin-top: 1em">&quot;you have mail0</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">&quot;you have new mail0</p>

<p style="margin-top: 1em">It is important that the
descriptions of command line editing refer to the same shell
as that in IEEE Std 1003.1-2001 so that interactive users
can also be application program&acirc; <br>
mers without having to deal with programmatic differences in
their two environments. It is also essential that the
utility name sh be specified because this explicit utility
name <br>
is too firmly rooted in historical practice of application
programs for it to change.</p>

<p style="margin-top: 1em">Consideration was given to
mandating a diagnostic message when attempting to set
vi-mode on terminals that do not support command line
editing. However, it is not historical <br>
practice for the shell to be cognizant of all terminal types
and thus be able to detect inappropriate terminals in all
cases. Implementations are encouraged to supply
diagnos&acirc; <br>
tics in this case whenever possible, rather than leaving the
user in a state where editing commands work incorrectly.</p>

<p style="margin-top: 1em">In early proposals, the
KornShell-derived emacs mode of command line editing was
included, even though the emacs editor itself was not. The
community of emacs proponents was <br>
adamant that the full emacs editor not be standardized
because they were concerned that an attempt to standardize
this very powerful environment would encourage vendors to
ship <br>
strictly conforming versions lacking the extensibility
required by the community. The author of the original emacs
program also expressed his desire to omit the program.
Fur&acirc; <br>
thermore, there were a number of historical systems that did
not include emacs, or included it without supporting it, but
there were very few that did not include and support vi.
<br>
The shell emacs command line editing mode was finally
omitted because it became apparent that the KornShell
version and the editor being distributed with the GNU system
had <br>
diverged in some respects. The author of emacs requested
that the POSIX emacs mode either be deleted or have a
significant number of unspecified conditions. Although the
Korn&acirc; <br>
Shell author agreed to consider changes to bring the shell
into alignment, the standard developers decided to defer
specification at that time. At the time, it was assumed that
<br>
convergence on an acceptable definition would occur for a
subsequent draft, but that has not happened, and there
appears to be no impetus to do so. In any case,
implementations <br>
are free to offer additional command line editing modes
based on the exact models of editors their users are most
comfortable with.</p>

<p style="margin-top: 1em">Early proposals had the
following list entry in vi Line Editing Insert Mode :
&nbsp;</p>

<p style="margin-top: 1em">If followed by the erase or kill
character, that character shall be inserted into the input
line. Otherwise, the backslash itself shall be inserted into
the input line.</p>

<p style="margin-top: 1em">However, this is not actually a
feature of sh command line editing insert mode, but one of
some historical terminal line drivers. Some conforming
implementations continue to do <br>
this when the stty iexten flag is set.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
None.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Shell Command Language, cd, echo, exit(), fc, pwd, read(),
set, stty, test, umask(), vi, the System Interfaces volume
of IEEE Std 1003.1-2001, dup(), exec, exit(), fork(), <br>
open(), pipe(), signal(), system(), ulimit(), umask(),
wait()</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2003 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 6,
Copyright (C) 2001-2003 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. In the event
<br>
of any discrepancy between this version and the original
IEEE and The Open Group Standard, the original IEEE and The
Open Group Standard is the referee document. The original
<br>
Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p style="margin-top: 1em">IEEE/The Open Group 2003
SH(1P)</p>
<hr>
</body>
</html>
