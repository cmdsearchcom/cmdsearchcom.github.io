<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:10:35 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DRBDSETUP(8) System Administration DRBDSETUP(8)</p>

<p style="margin-top: 1em">NAME <br>
drbdsetup - Setup tool for DRBD</p>

<p style="margin-top: 1em">SYNOPSIS <br>
drbdsetup {device} disk {lower_dev} {meta_data_dev}
{meta_data_index} [-d {size}] [-e {err_handler}] [-f
{fencing_policy}] [-b] [-t {disk_timeout}]</p>

<p style="margin-top: 1em">drbdsetup {device} net [af:]
{local_addr} [:port] [af:] {remote_addr} [:port] {protocol}
[-c {time}] [-i {time}] [-t {val}] [-S {size}] [-r {size}]
[-k {count}] <br>
[-e {max_epoch_size}] [-b {max_buffers}] [-m] [-a
{hash_alg}] [-x {shared_secret}] [-A {asb-0p-policy}] [-B
{asb-1p-policy}] [-C {asb-2p-policy}] [-D] <br>
[-R {role-resync-conflict-policy}] [-p {ping_timeout}] [-u
{val}] [-d {hash_alg}] [-o] [-n] [-g {congestion_policy}]
[-f {val}] [-h {val}]</p>

<p style="margin-top: 1em">drbdsetup {device} syncer [-a
{dev_minor}] [-r {rate}] [-e {extents}] [-v
{verify-hash-alg}] [-c {cpu-mask}] [-C {csums-hash-alg}]
[-R] [-p {plan_time}] [-s {fill_target}] <br>
[-d {delay_target}] [-m {max_rate}] [-n {ond-policy}]</p>

<p style="margin-top: 1em">drbdsetup {device}
disconnect</p>

<p style="margin-top: 1em">drbdsetup {device} detach
[-f]</p>

<p style="margin-top: 1em">drbdsetup {device} down</p>

<p style="margin-top: 1em">drbdsetup {device} primary [-f]
[-o]</p>

<p style="margin-top: 1em">drbdsetup {device} secondary</p>

<p style="margin-top: 1em">drbdsetup {device} verify [-s
{start-position}] [-S {stop-position}]</p>

<p style="margin-top: 1em">drbdsetup {device}
invalidate</p>

<p style="margin-top: 1em">drbdsetup {device}
invalidate-remote</p>

<p style="margin-top: 1em">drbdsetup {device} wait-connect
[-t {wfc_timeout}] [-d {degr_wfc_timeout}] [-o
{outdated_wfc_timeout}] [-w]</p>

<p style="margin-top: 1em">drbdsetup {device} wait-sync [-t
{wfc_timeout}] [-d {degr_wfc_timeout}] [-o
{outdated_wfc_timeout}] [-w]</p>

<p style="margin-top: 1em">drbdsetup {device} role</p>

<p style="margin-top: 1em">drbdsetup {device} cstate</p>

<p style="margin-top: 1em">drbdsetup {device} dstate</p>

<p style="margin-top: 1em">drbdsetup {device} status</p>

<p style="margin-top: 1em">drbdsetup {device} resize [-d
{size}] [-f {assume-peer-has-space}] [-c {assume-clean}]</p>

<p style="margin-top: 1em">drbdsetup {device}
check-resize</p>

<p style="margin-top: 1em">drbdsetup {device}
pause-sync</p>

<p style="margin-top: 1em">drbdsetup {device}
resume-sync</p>

<p style="margin-top: 1em">drbdsetup {device} outdate</p>

<p style="margin-top: 1em">drbdsetup {device} show-gi</p>

<p style="margin-top: 1em">drbdsetup {device} get-gi</p>

<p style="margin-top: 1em">drbdsetup {device} show</p>

<p style="margin-top: 1em">drbdsetup {device}
suspend-io</p>

<p style="margin-top: 1em">drbdsetup {device} resume-io</p>

<p style="margin-top: 1em">drbdsetup {device} events [-u]
[-a]</p>

<p style="margin-top: 1em">drbdsetup {device}
new-current-uuid [-c]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
drbdsetup is used to associate DRBD devices with their
backing block devices, to set up DRBD device pairs to mirror
their backing block devices, and to inspect the
configuration <br>
of running DRBD devices.</p>

<p style="margin-top: 1em">NOTE <br>
drbdsetup is a low level tool of the DRBD program suite. It
is used by the data disk and drbd scripts to communicate
with the device driver.</p>

<p style="margin-top: 1em">COMMANDS <br>
Each drbdsetup sub-command might require arguments and bring
its own set of options. All values have default units which
might be overruled by K, M or G. These units are defined
<br>
in the usual way (e.g. K = 2^10 = 1024).</p>

<p style="margin-top: 1em">Common options <br>
All drbdsetup sub-commands accept these two options</p>

<p style="margin-top: 1em">--create-device <br>
In case the specified DRBD device (minor number) does not
exist yet, create it implicitly.</p>

<p style="margin-top: 1em">--set-defaults <br>
When --set-defaults is given on the command line, all
options of the invoked sub-command that are not explicitly
set are reset to their default values.</p>

<p style="margin-top: 1em">disk <br>
Associates device with lower_device to store its data blocks
on. The -d (or --disk-size) should only be used if you wish
not to use as much as possible from the backing block <br>
devices. If you do not use -d, the device is only ready for
use as soon as it was connected to its peer once. (See the
net command.)</p>

<p style="margin-top: 1em">-d, --disk-size size <br>
You can override DRBD&rsquo;s size determination method with
this option. If you need to use the device before it was
ever connected to its peer, use this option to pass the size
<br>
of the DRBD device to the driver. Default unit is sectors
(1s = 512 bytes).</p>

<p style="margin-top: 1em">If you use the size parameter in
drbd.conf, we strongly recommend to add an explicit unit
postfix. drbdadm and drbdsetup used to have mismatching
default units.</p>

<p style="margin-top: 1em">-e, --on-io-error err_handler
<br>
If the driver of the lower_device reports an error to DRBD,
DRBD will mark the disk as inconsistent, call a helper
program, or detach the device from its backing storage and
<br>
perform all further IO by requesting it from the peer. The
valid err_handlers are: pass_on, call-local-io-error and
detach.</p>

<p style="margin-top: 1em">-f, --fencing fencing_policy
<br>
Under fencing we understand preventive measures to avoid
situations where both nodes are primary and disconnected
(AKA split brain).</p>

<p style="margin-top: 1em">Valid fencing policies are:</p>

<p style="margin-top: 1em">dont-care <br>
This is the default policy. No fencing actions are done.</p>

<p style="margin-top: 1em">resource-only <br>
If a node becomes a disconnected primary, it tries to
outdate the peer&rsquo;s disk. This is done by calling the
fence-peer handler. The handler is supposed to reach the
other <br>
node over alternative communication paths and call
&rsquo;drbdadm outdate res&rsquo; there.</p>

<p style="margin-top: 1em">resource-and-stonith <br>
If a node becomes a disconnected primary, it freezes all its
IO operations and calls its fence-peer handler. The
fence-peer handler is supposed to reach the peer over <br>
alternative communication paths and call &rsquo;drbdadm
outdate res&rsquo; there. In case it cannot reach the peer,
it should stonith the peer. IO is resumed as soon as the
situation <br>
is resolved. In case your handler fails, you can resume IO
with the resume-io command.</p>

<p style="margin-top: 1em">-b, --use-bmbv <br>
In case the backing storage&rsquo;s driver has a
merge_bvec_fn() function, DRBD has to pretend that it can
only process IO requests in units not larger than 4 KiB. (At
time of <br>
writing the only known drivers which have such a function
are: md (software raid driver), dm (device mapper - LVM) and
DRBD itself)</p>

<p style="margin-top: 1em">To get best performance out of
DRBD on top of software raid (or any other driver with a
merge_bvec_fn() function) you might enable this option, if
you know for sure that the <br>
merge_bvec_fn() function will deliver the same results on
all nodes of your cluster. I.e. the physical disks of the
software raid are exactly of the same type. USE THIS <br>
OPTION ONLY IF YOU KNOW WHAT YOU ARE DOING.</p>

<p style="margin-top: 1em">-a, --no-disk-barrier, -i,
--no-disk-flushes, -D, --no-disk-drain <br>
DRBD has four implementations to express write-after-write
dependencies to its backing storage device. DRBD will use
the first method that is supported by the backing storage
<br>
device and that is not disabled by the user.</p>

<p style="margin-top: 1em">When selecting the method you
should not only base your decision on the measurable
performance. In case your backing storage device has a
volatile write cache (plain disks, <br>
RAID of plain disks) you should use one of the first two. In
case your backing storage device has battery-backed write
cache you may go with option 3. Option 4 (disable <br>
everything, use &quot;none&quot;) is dangerous on most IO
stacks, may result in write-reordering, and if so, can
theoretically be the reason for data corruption, or disturb
the DRBD <br>
protocol, causing spurious disconnect/reconnect cycles. Do
not use no-disk-drain.</p>

<p style="margin-top: 1em">Unfortunately device mapper
(LVM) might not support barriers.</p>

<p style="margin-top: 1em">The letter after &quot;wo:&quot;
in /proc/drbd indicates with method is currently in use for
a device: b, f, d, n. The implementations:</p>

<p style="margin-top: 1em">barrier <br>
The first requires that the driver of the backing storage
device support barriers (called &rsquo;tagged command
queuing&rsquo; in SCSI and &rsquo;native command
queuing&rsquo; in SATA speak). <br>
The use of this method can be disabled by the
--no-disk-barrier option. Note: Since Linux-2.6.36 (or
RHEL&rsquo;s 2.6.32) this method is disabled.</p>

<p style="margin-top: 1em">flush <br>
The second requires that the backing device support disk
flushes (called &rsquo;force unit access&rsquo; in the drive
vendors speak). The use of this method can be disabled using
the <br>
--no-disk-flushes option.</p>

<p style="margin-top: 1em">drain <br>
The third method is simply to let write requests drain
before write requests of a new reordering domain are issued.
That was the only implementation before 8.0.9.</p>

<p style="margin-top: 1em">none <br>
The fourth method is to not express write-after-write
dependencies to the backing store at all, by also specifying
--no-disk-drain. This is dangerous on most IO stacks, <br>
may result in write-reordering, and if so, can theoretically
be the reason for data corruption, or disturb the DRBD
protocol, causing spurious disconnect/reconnect <br>
cycles. Do not use --no-disk-drain.</p>

<p style="margin-top: 1em">-m, --no-md-flushes <br>
Disables the use of disk flushes and barrier BIOs when
accessing the meta data device. See the notes on
--no-disk-flushes.</p>

<p style="margin-top: 1em">-s, --max-bio-bvecs <br>
In some special circumstances the device mapper stack
manages to pass BIOs to DRBD that violate the constraints
that are set forth by DRBD&rsquo;s merge_bvec() function and
which <br>
have more than one bvec. A known example is: phys-disk -&gt;
DRBD -&gt; LVM -&gt; Xen -&gt; missaligned partition (63)
-&gt; DomU FS. Then you might see &quot;bio would need to,
but cannot, be <br>
split:&quot; in the Dom0&rsquo;s kernel log.</p>

<p style="margin-top: 1em">The best workaround is to proper
align the partition within the VM (E.g. start it at sector
1024). That costs 480 KiB of storage. Unfortunately the
default of most Linux <br>
partitioning tools is to start the first partition at an odd
number (63). Therefore most distributions install helpers
for virtual linux machines will end up with missaligned <br>
partitions. The second best workaround is to limit
DRBD&rsquo;s max bvecs per BIO (i.e., the max-bio-bvecs
option) to 1, but that might cost performance.</p>

<p style="margin-top: 1em">The default value of
max-bio-bvecs is 0, which means that there is no user
imposed limitation.</p>

<p style="margin-top: 1em">-t, --disk-timeout disk_timeout
<br>
If the driver of the lower_device does not finish an IO
request within disk_timeout, DRBD considers the disk as
failed. If DRBD is connected to a remote host, it will
reissue <br>
local pending IO requests to the peer, and ship all new IO
requests to the peer only. The disk state advances to
diskless, as soon as the backing block device has finished
<br>
all IO requests.</p>

<p style="margin-top: 1em">The default value of is 0, which
means that no timeout is enforced. The default unit is
100ms. This option is available since 8.3.12.</p>

<p style="margin-top: 1em">net <br>
Sets up the device to listen on af:local_addr:port for
incoming connections and to try to connect to
af:remote_addr:port. If port is omitted, 7788 is used as
default. If af is <br>
omitted ipv4 gets used. Other supported address families are
ipv6, ssocks for Dolphin Interconnect Solutions&rsquo;
&quot;super sockets&quot; and sdp for Sockets Direct
Protocol (Infiniband).</p>

<p style="margin-top: 1em">On the TCP/IP link the specified
protocol is used. Valid protocol specifiers are A, B, and
C.</p>

<p style="margin-top: 1em">Protocol A: write IO is reported
as completed, if it has reached local disk and local TCP
send buffer.</p>

<p style="margin-top: 1em">Protocol B: write IO is reported
as completed, if it has reached local disk and remote buffer
cache.</p>

<p style="margin-top: 1em">Protocol C: write IO is reported
as completed, if it has reached both local and remote
disk.</p>

<p style="margin-top: 1em">-c, --connect-int time <br>
In case it is not possible to connect to the remote DRBD
device immediately, DRBD keeps on trying to connect. With
this option you can set the time between two retries. The
<br>
default value is 10 seconds, the unit is 1 second.</p>

<p style="margin-top: 1em">-i, --ping-int time <br>
If the TCP/IP connection linking a DRBD device pair is idle
for more than time seconds, DRBD will generate a keep-alive
packet to check if its partner is still alive. The <br>
default value is 10 seconds, the unit is 1 second.</p>

<p style="margin-top: 1em">-t, --timeout val <br>
If the partner node fails to send an expected response
packet within val tenths of a second, the partner node is
considered dead and therefore the TCP/IP connection is <br>
abandoned. The default value is 60 (= 6 seconds).</p>

<p style="margin-top: 1em">-S, --sndbuf-size size <br>
The socket send buffer is used to store packets sent to the
secondary node, which are not yet acknowledged (from a
network point of view) by the secondary node. When using
<br>
protocol A, it might be necessary to increase the size of
this data structure in order to increase asynchronicity
between primary and secondary nodes. But keep in mind that
<br>
more asynchronicity is synonymous with more data loss in the
case of a primary node failure. Since 8.0.13 resp. 8.2.7
setting the size value to 0 means that the kernel should
<br>
autotune this. The default size is 0, i.e. autotune.</p>

<p style="margin-top: 1em">-r, --rcvbuf-size size <br>
Packets received from the network are stored in the socket
receive buffer first. From there they are consumed by DRBD.
Before 8.3.2 the receive buffer&rsquo;s size was always set
<br>
to the size of the socket send buffer. Since 8.3.2 they can
be tuned independently. A value of 0 means that the kernel
should autotune this. The default size is 0, i.e. <br>
autotune.</p>

<p style="margin-top: 1em">-k, --ko-count count <br>
In case the secondary node fails to complete a single write
request for count times the timeout, it is expelled from the
cluster, i.e. the primary node goes into StandAlone <br>
mode. To disable this feature, you should explicitly set it
to 0; defaults may change between versions.</p>

<p style="margin-top: 1em">-e, --max-epoch-size val <br>
With this option the maximal number of write requests
between two barriers is limited. Typically set to the same
as --max-buffers, or the allowed maximum. Values smaller
than <br>
10 can lead to degraded performance. The default value is
2048.</p>

<p style="margin-top: 1em">-b, --max-buffers val <br>
With this option the maximal number of buffer pages
allocated by DRBD&rsquo;s receiver thread is limited.
Typically set to the same as --max-epoch-size. Small values
could lead to <br>
degraded performance. The default value is 2048, the minimum
32. Increase this if you cannot saturate the IO backend of
the receiving side during linear write or during <br>
resync while otherwise idle.</p>

<p style="margin-top: 1em">See also drbd.conf(5)</p>

<p style="margin-top: 1em">-u, --unplug-watermark val <br>
This setting has no effect with recent kernels that use
explicit on-stack plugging (upstream Linux kernel 2.6.39,
distributions may have backported).</p>

<p style="margin-top: 1em">When the number of pending write
requests on the standby (secondary) node exceeds the
unplug-watermark, we trigger the request processing of our
backing storage device. Some <br>
storage controllers deliver better performance with small
values, others deliver best performance when the value is
set to the same value as max-buffers, yet others don&rsquo;t
<br>
feel much effect at all. Minimum 16, default 128, maximum
131072.</p>

<p style="margin-top: 1em">-m, --allow-two-primaries <br>
With this option set you may assign primary role to both
nodes. You only should use this option if you use a shared
storage file system on top of DRBD. At the time of writing
<br>
the only ones are: OCFS2 and GFS. If you use this option
with any other file system, you are going to crash your
nodes and to corrupt your data!</p>

<p style="margin-top: 1em">-a, --cram-hmac-alg alg <br>
You need to specify the HMAC algorithm to enable peer
authentication at all. You are strongly encouraged to use
peer authentication. The HMAC algorithm will be used for the
<br>
challenge response authentication of the peer. You may
specify any digest algorithm that is named in
/proc/crypto.</p>

<p style="margin-top: 1em">-x, --shared-secret secret <br>
The shared secret used in peer authentication. May be up to
64 characters.</p>

<p style="margin-top: 1em">-A, --after-sb-0pri
asb-0p-policy <br>
possible policies are:</p>

<p style="margin-top: 1em">disconnect <br>
No automatic resynchronization, simply disconnect.</p>

<p style="margin-top: 1em">discard-younger-primary <br>
Auto sync from the node that was primary before the
split-brain situation occurred.</p>

<p style="margin-top: 1em">discard-older-primary <br>
Auto sync from the node that became primary as second during
the split-brain situation.</p>

<p style="margin-top: 1em">discard-zero-changes <br>
In case one node did not write anything since the split
brain became evident, sync from the node that wrote
something to the node that did not write anything. In case
<br>
none wrote anything this policy uses a random decision to
perform a &quot;resync&quot; of 0 blocks. In case both have
written something this policy disconnects the nodes.</p>

<p style="margin-top: 1em">discard-least-changes <br>
Auto sync from the node that touched more blocks during the
split brain situation.</p>

<p style="margin-top: 1em">discard-node-NODENAME <br>
Auto sync to the named node.</p>

<p style="margin-top: 1em">-B, --after-sb-1pri
asb-1p-policy <br>
possible policies are:</p>

<p style="margin-top: 1em">disconnect <br>
No automatic resynchronization, simply disconnect.</p>

<p style="margin-top: 1em">consensus <br>
Discard the version of the secondary if the outcome of the
after-sb-0pri algorithm would also destroy the current
secondary&rsquo;s data. Otherwise disconnect.</p>

<p style="margin-top: 1em">discard-secondary <br>
Discard the secondary&rsquo;s version.</p>

<p style="margin-top: 1em">call-pri-lost-after-sb <br>
Always honor the outcome of the after-sb-0pri algorithm. In
case it decides the current secondary has the correct data,
call the pri-lost-after-sb on the current primary.</p>

<p style="margin-top: 1em">violently-as0p <br>
Always honor the outcome of the after-sb-0pri algorithm. In
case it decides the current secondary has the correct data,
accept a possible instantaneous change of the <br>
primary&rsquo;s data.</p>

<p style="margin-top: 1em">-C, --after-sb-2pri
asb-2p-policy <br>
possible policies are:</p>

<p style="margin-top: 1em">disconnect <br>
No automatic resynchronization, simply disconnect.</p>

<p style="margin-top: 1em">call-pri-lost-after-sb <br>
Always honor the outcome of the after-sb-0pri algorithm. In
case it decides the current secondary has the right data,
call the pri-lost-after-sb on the current primary.</p>

<p style="margin-top: 1em">violently-as0p <br>
Always honor the outcome of the after-sb-0pri algorithm. In
case it decides the current secondary has the right data,
accept a possible instantaneous change of the <br>
primary&rsquo;s data.</p>

<p style="margin-top: 1em">-P, --always-asbp <br>
Normally the automatic after-split-brain policies are only
used if current states of the UUIDs do not indicate the
presence of a third node.</p>

<p style="margin-top: 1em">With this option you request
that the automatic after-split-brain policies are used as
long as the data sets of the nodes are somehow related. This
might cause a full sync, <br>
if the UUIDs indicate the presence of a third node. (Or
double faults have led to strange UUID sets.)</p>

<p style="margin-top: 1em">-R, --rr-conflict
role-resync-conflict-policy <br>
This option sets DRBD&rsquo;s behavior when DRBD deduces
from its meta data that a resynchronization is needed, and
the SyncTarget node is already primary. The possible
settings <br>
are: disconnect, call-pri-lost and violently. While
disconnect speaks for itself, with the call-pri-lost setting
the pri-lost handler is called which is expected to either
<br>
change the role of the node to secondary, or remove the node
from the cluster. The default is disconnect.</p>

<p style="margin-top: 1em">With the violently setting you
allow DRBD to force a primary node into SyncTarget state.
This means that the data exposed by DRBD changes to the
SyncSource&rsquo;s version of the <br>
data instantaneously. USE THIS OPTION ONLY IF YOU KNOW WHAT
YOU ARE DOING.</p>

<p style="margin-top: 1em">-d, --data-integrity-alg
hash_alg <br>
DRBD can ensure the data integrity of the user&rsquo;s data
on the network by comparing hash values. Normally this is
ensured by the 16 bit checksums in the headers of TCP/IP
<br>
packets. This option can be set to any of the kernel&rsquo;s
data digest algorithms. In a typical kernel configuration
you should have at least one of md5, sha1, and crc32c <br>
available. By default this is not enabled.</p>

<p style="margin-top: 1em">See also the notes on data
integrity on the drbd.conf manpage.</p>

<p style="margin-top: 1em">-o, --no-tcp-cork <br>
DRBD usually uses the TCP socket option TCP_CORK to hint to
the network stack when it can expect more data, and when it
should flush out what it has in its send queue. There <br>
is at least one network stack that performs worse when one
uses this hinting method. Therefore we introduced this
option, which disable the setting and clearing of the <br>
TCP_CORK socket option by DRBD.</p>

<p style="margin-top: 1em">-p, --ping-timeout ping_timeout
<br>
The time the peer has to answer to a keep-alive packet. In
case the peer&rsquo;s reply is not received within this time
period, it is considered dead. The default unit is tenths of
<br>
a second, the default value is 5 (for half a second).</p>

<p style="margin-top: 1em">-D, --discard-my-data <br>
Use this option to manually recover from a split-brain
situation. In case you do not have any automatic
after-split-brain policies selected, the nodes refuse to
connect. By <br>
passing this option you make this node a sync target
immediately after successful connect.</p>

<p style="margin-top: 1em">-n, --dry-run <br>
Causes DRBD to abort the connection process after the resync
handshake, i.e. no resync gets performed. You can find out
which resync DRBD would perform by looking at the <br>
kernel&rsquo;s log file.</p>

<p style="margin-top: 1em">-g, --on-congestion
congestion_policy, -f, --congestion-fill fill_threshold, -h,
--congestion-extents active_extents_threshold <br>
By default DRBD blocks when the available TCP send queue
becomes full. That means it will slow down the application
that generates the write requests that cause DRBD to send
<br>
more data down that TCP connection.</p>

<p style="margin-top: 1em">When DRBD is deployed with
DRBD-proxy it might be more desirable that DRBD goes into
AHEAD/BEHIND mode shortly before the send queue becomes
full. In AHEAD/BEHIND mode DRBD <br>
does no longer replicate data, but still keeps the
connection open.</p>

<p style="margin-top: 1em">The advantage of the
AHEAD/BEHIND mode is that the application is not slowed
down, even if DRBD-proxy&rsquo;s buffer is not sufficient to
buffer all write requests. The downside is <br>
that the peer node falls behind, and that a resync will be
necessary to bring it back into sync. During that resync the
peer node will have an inconsistent disk.</p>

<p style="margin-top: 1em">Available congestion_policys are
block and pull-ahead. The default is block. Fill_threshold
might be in the range of 0 to 10GiBytes. The default is 0
which disables the <br>
check. Active_extents_threshold has the same limits as
al-extents.</p>

<p style="margin-top: 1em">The AHEAD/BEHIND mode and its
settings are available since DRBD 8.3.10.</p>

<p style="margin-top: 1em">syncer <br>
Changes the synchronization daemon parameters of device at
runtime.</p>

<p style="margin-top: 1em">-r, --rate rate <br>
To ensure smooth operation of the application on top of
DRBD, it is possible to limit the bandwidth that may be used
by background synchronization. The default is 250 <br>
KiB/sec, the default unit is KiB/sec.</p>

<p style="margin-top: 1em">-a, --after minor <br>
Start resync on this device only if the device with minor is
already in connected state. Otherwise this device waits in
SyncPause state.</p>

<p style="margin-top: 1em">-e, --al-extents extents <br>
DRBD automatically performs hot area detection. With this
parameter you control how big the hot area (=active set) can
get. Each extent marks 4M of the backing storage. In <br>
case a primary node leaves the cluster unexpectedly, the
areas covered by the active set must be resynced upon
rejoining of the failed node. The data structure is stored
in <br>
the meta-data area, therefore each change of the active set
is a write operation to the meta-data device. A higher
number of extents gives longer resync times but less <br>
updates to the meta-data. The default number of extents is
127. (Minimum: 7, Maximum: 3843)</p>

<p style="margin-top: 1em">-v, --verify-alg hash-alg <br>
During online verification (as initiated by the verify
sub-command), rather than doing a bit-wise comparison, DRBD
applies a hash function to the contents of every block <br>
being verified, and compares that hash with the peer. This
option defines the hash algorithm being used for that
purpose. It can be set to any of the kernel&rsquo;s data
digest <br>
algorithms. In a typical kernel configuration you should
have at least one of md5, sha1, and crc32c available. By
default this is not enabled; you must set this option <br>
explicitly in order to be able to use on-line device
verification.</p>

<p style="margin-top: 1em">See also the notes on data
integrity on the drbd.conf manpage.</p>

<p style="margin-top: 1em">-c, --cpu-mask cpu-mask <br>
Sets the cpu-affinity-mask for DRBD&rsquo;s kernel threads
of this device. The default value of cpu-mask is 0, which
means that DRBD&rsquo;s kernel threads should be spread over
all CPUs <br>
of the machine. This value must be given in hexadecimal
notation. If it is too big it will be truncated.</p>

<p style="margin-top: 1em">-C, --csums-alg hash-alg <br>
A resync process sends all marked data blocks form the
source to the destination node, as long as no csums-alg is
given. When one is specified the resync process exchanges
<br>
hash values of all marked blocks first, and sends only those
data blocks over, that have different hash values.</p>

<p style="margin-top: 1em">This setting is useful for DRBD
setups with low bandwidth links. During the restart of a
crashed primary node, all blocks covered by the activity log
are marked for resync. <br>
But a large part of those will actually be still in sync,
therefore using csums-alg will lower the required bandwidth
in exchange for CPU cycles.</p>

<p style="margin-top: 1em">-R, --use-rle <br>
During resync-handshake, the dirty-bitmaps of the nodes are
exchanged and merged (using bit-or), so the nodes will have
the same understanding of which blocks are dirty. On <br>
large devices, the fine grained dirty-bitmap can become
large as well, and the bitmap exchange can take quite some
time on low-bandwidth links.</p>

<p style="margin-top: 1em">Because the bitmap typically
contains compact areas where all bits are unset (clean) or
set (dirty), a simple run-length encoding scheme can
considerably reduce the network <br>
traffic necessary for the bitmap exchange.</p>

<p style="margin-top: 1em">For backward compatibilty
reasons, and because on fast links this possibly does not
improve transfer time but consumes cpu cycles, this defaults
to off.</p>

<p style="margin-top: 1em">Introduced in 8.3.2.</p>

<p style="margin-top: 1em">-p, --c-plan-ahead plan_time,
-s, --c-fill-target fill_target, -d, --c-delay-target
delay_target, -M, --c-max-rate max_rate <br>
The dynamic resync speed controller gets enabled with
setting plan_time to a positive value. It aims to fill the
buffers along the data path with either a constant amount of
<br>
data fill_target, or aims to have a constant delay time of
delay_target along the path. The controller has an upper
bound of max_rate.</p>

<p style="margin-top: 1em">By plan_time the agility of the
controller is configured. Higher values yield for
slower/lower responses of the controller to deviation from
the target value. It should be at <br>
least 5 times RTT. For regular data paths a fill_target in
the area of 4k to 100k is appropriate. For a setup that
contains drbd-proxy it is advisable to use delay_target <br>
instead. Only when fill_target is set to 0 the controller
will use delay_target. 5 times RTT is a reasonable starting
value. Max_rate should be set to the bandwidth <br>
available between the DRBD-hosts and the machines hosting
DRBD-proxy, or to the available disk-bandwidth.</p>

<p style="margin-top: 1em">The default value of plan_time
is 0, the default unit is 0.1 seconds. Fill_target has 0 and
sectors as default unit. Delay_target has 1 (100ms) and 0.1
as default unit. <br>
Max_rate has 10240 (100MiB/s) and KiB/s as default unit.</p>

<p style="margin-top: 1em">-m, --c-min-rate min_rate <br>
We track the disk IO rate caused by the resync, so we can
detect non-resync IO on the lower level device. If the lower
level device seems to be busy, and the current resync <br>
rate is above min_rate, we throttle the resync.</p>

<p style="margin-top: 1em">The default value of min_rate is
4M, the default unit is k. If you want to not throttle at
all, set it to zero, if you want to throttle always, set it
to one.</p>

<p style="margin-top: 1em">-n, --on-no-data-accessible
ond-policy <br>
This setting controls what happens to IO requests on a
degraded, disk less node (I.e. no data store is reachable).
The available policies are io-error and suspend-io.</p>

<p style="margin-top: 1em">If ond-policy is set to
suspend-io you can either resume IO by attaching/connecting
the last lost data storage, or by the drbdadm resume-io res
command. The latter will <br>
result in IO errors of course.</p>

<p style="margin-top: 1em">The default is io-error. This
setting is available since DRBD 8.3.9.</p>

<p style="margin-top: 1em">primary <br>
Sets the device into primary role. This means that
applications (e.g. a file system) may open the device for
read and write access. Data written to the device in primary
role are <br>
mirrored to the device in secondary role.</p>

<p style="margin-top: 1em">Normally it is not possible to
set both devices of a connected DRBD device pair to primary
role. By using the --allow-two-primaries option, you
override this behavior and <br>
instruct DRBD to allow two primaries.</p>

<p style="margin-top: 1em">-o, --overwrite-data-of-peer
<br>
Alias for --force.</p>

<p style="margin-top: 1em">-f, --force <br>
Becoming primary fails if the local replica is not
up-to-date. I.e. when it is inconsistent, outdated of
consistent. By using this option you can force it into
primary role <br>
anyway. USE THIS OPTION ONLY IF YOU KNOW WHAT YOU ARE
DOING.</p>

<p style="margin-top: 1em">secondary <br>
Brings the device into secondary role. This operation fails
as long as at least one application (or file system) has
opened the device.</p>

<p style="margin-top: 1em">It is possible that both devices
of a connected DRBD device pair are secondary.</p>

<p style="margin-top: 1em">verify <br>
This initiates on-line device verification. During on-line
verification, the contents of every block on the local node
are compared to those on the peer node. Device verification
<br>
progress can be monitored via /proc/drbd. Any blocks whose
content differs from that of the corresponding block on the
peer node will be marked out-of-sync in DRBD&rsquo;s on-disk
<br>
bitmap; they are not brought back in sync automatically. To
do that, simply disconnect and reconnect the resource.</p>

<p style="margin-top: 1em">If on-line verification is
already in progress (and this node is &quot;VerifyS&quot;),
this command silently &quot;succeeds&quot;. In this case,
any start-sector (see below) will be ignored, and any <br>
stop-sector (see below) will be honored. This can be used to
stop a running verify, or to update/shorten/extend the
coverage of the currently running verify.</p>

<p style="margin-top: 1em">This command will fail if the
device is not part of a connected device pair.</p>

<p style="margin-top: 1em">See also the notes on data
integrity on the drbd.conf manpage.</p>

<p style="margin-top: 1em">-s, --start start-sector <br>
Since version 8.3.2, on-line verification should resume from
the last position after connection loss. It may also be
started from an arbitrary position by setting this <br>
option. If you had reached some stop-sector before, and you
do not specify an explicit start-sector, verify should
resume from the previous stop-sector.</p>

<p style="margin-top: 1em">Default unit is sectors. You may
also specify a unit explicitly. The start-sector will be
rounded down to a multiple of 8 sectors (4kB).</p>

<p style="margin-top: 1em">-S, --stop stop-sector <br>
Since version 8.3.14, on-line verification can be stopped
before it reaches end-of-device. This can be</p>

<p style="margin-top: 1em">Default unit is sectors. You may
also specify a unit explicitly. The stop-sector may be
updated by issuing an additional drbdsetup verify command on
the same node while the <br>
verify is running.</p>

<p style="margin-top: 1em">invalidate <br>
This forces the local device of a pair of connected DRBD
devices into SyncTarget state, which means that all data
blocks of the device are copied over from the peer.</p>

<p style="margin-top: 1em">This command will fail if the
device is not either part of a connected device pair, or
disconnected Secondary.</p>

<p style="margin-top: 1em">invalidate-remote <br>
This forces the local device of a pair of connected DRBD
devices into SyncSource state, which means that all data
blocks of the device are copied to the peer.</p>

<p style="margin-top: 1em">On a disconnected Primary
device, this will set all bits in the out of sync bitmap. As
a side affect this suspends updates to the on disk activity
log. Updates to the on disk <br>
activity log resume automatically when necessary.</p>

<p style="margin-top: 1em">wait-connect <br>
Returns as soon as the device can communicate with its
partner device.</p>

<p style="margin-top: 1em">-t, --wfc-timeout wfc_timeout,
-d, --degr-wfc-timeout degr_wfc_timeout, -o,
--outdated-wfc-timeout outdated_wfc_timeout, -w,
--wait-after-sb <br>
This command will fail if the device cannot communicate with
its partner for timeout seconds. If the peer was working
before this node was rebooted, the wfc_timeout is used. <br>
If the peer was already down before this node was rebooted,
the degr_wfc_timeout is used. If the peer was sucessfully
outdated before this node was rebooted the <br>
outdated_wfc_timeout is used. The default value for all
those timeout values is 0 which means to wait forever. In
case the connection status goes down to StandAlone because
<br>
the peer appeared but the devices had a split brain
situation, the default for the command is to terminate. You
can change this behavior with the --wait-after-sb
option.</p>

<p style="margin-top: 1em">wait-sync <br>
Returns as soon as the device leaves any synchronization
into connected state. The options are the same as with the
wait-connect command.</p>

<p style="margin-top: 1em">disconnect <br>
Removes the information set by the net command from the
device. This means that the device goes into unconnected
state and will no longer listen for incoming
connections.</p>

<p style="margin-top: 1em">detach <br>
Removes the information set by the disk command from the
device. This means that the device is detached from its
backing storage device.</p>

<p style="margin-top: 1em">-f, --force <br>
A regular detach returns after the disk state finally
reached diskless. As a consequence detaching from a frozen
backing block device never terminates.</p>

<p style="margin-top: 1em">On the other hand A forced
detach returns immediately. It allows you to detach DRBD
from a frozen backing block device. Please note that the
disk will be marked as failed <br>
until all pending IO requests where finished by the backing
block device.</p>

<p style="margin-top: 1em">down <br>
Removes all configuration information from the device and
forces it back to unconfigured state.</p>

<p style="margin-top: 1em">role <br>
Shows the current roles of the device and its peer, as
local/peer.</p>

<p style="margin-top: 1em">state <br>
Deprecated alias for &quot;role&quot;</p>

<p style="margin-top: 1em">cstate <br>
Shows the current connection state of the device.</p>

<p style="margin-top: 1em">dstate <br>
Shows the current states of the backing storage devices, as
local/peer.</p>

<p style="margin-top: 1em">status <br>
Shows the current status of the device in XML-like format.
Example output:</p>

<p style="margin-top: 1em">&lt;resource minor=&quot;0&quot;
name=&quot;s0&quot; cs=&quot;SyncTarget&quot;
st1=&quot;Secondary&quot; st2=&quot;Secondary&quot; <br>
ds1=&quot;Inconsistent&quot; ds2=&quot;UpToDate&quot;
resynced_precent=&quot;5.9&quot; /&gt;</p>

<p style="margin-top: 1em">resize <br>
This causes DRBD to reexamine the size of the device&rsquo;s
backing storage device. To actually do online growing you
need to extend the backing storages on both devices and call
the <br>
resize command on one of your nodes.</p>

<p style="margin-top: 1em">The --assume-peer-has-space
allows you to resize a device which is currently not
connected to the peer. Use with care, since if you do not
resize the peer&rsquo;s disk as well, further <br>
connect attempts of the two will fail.</p>

<p style="margin-top: 1em">When the --assume-clean option
is given DRBD will skip the resync of the new storage. Only
do this if you know that the new storage was initialized to
the same content by other <br>
means.</p>

<p style="margin-top: 1em">check-resize <br>
To enable DRBD to detect offline resizing of backing devices
this command may be used to record the current size of
backing devices. The size is stored in files in
/var/lib/drbd/ <br>
named drbd-minor-??.lkbd</p>

<p style="margin-top: 1em">This command is called by
drbdadm resize res after drbdsetup device resize
returned.</p>

<p style="margin-top: 1em">pause-sync <br>
Temporarily suspend an ongoing resynchronization by setting
the local pause flag. Resync only progresses if neither the
local nor the remote pause flag is set. It might be <br>
desirable to postpone DRBD&rsquo;s resynchronization after
eventual resynchronization of the backing storage&rsquo;s
RAID setup.</p>

<p style="margin-top: 1em">resume-sync <br>
Unset the local sync pause flag.</p>

<p style="margin-top: 1em">outdate <br>
Mark the data on the local backing storage as outdated. An
outdated device refuses to become primary. This is used in
conjunction with fencing and by the peer&rsquo;s fence-peer
<br>
handler.</p>

<p style="margin-top: 1em">show-gi <br>
Displays the device&rsquo;s data generation identifiers
verbosely.</p>

<p style="margin-top: 1em">get-gi <br>
Displays the device&rsquo;s data generation identifiers.</p>

<p style="margin-top: 1em">show <br>
Shows all available configuration information of the
device.</p>

<p style="margin-top: 1em">suspend-io <br>
This command is of no apparent use and just provided for the
sake of completeness.</p>

<p style="margin-top: 1em">resume-io <br>
If the fence-peer handler fails to stonith the peer node,
and your fencing policy is set to resource-and-stonith, you
can unfreeze IO operations with this command.</p>

<p style="margin-top: 1em">events <br>
Displays every state change of DRBD and all calls to helper
programs. This might be used to get notified of DRBD&rsquo;s
state changes by piping the output to another program.</p>

<p style="margin-top: 1em">-a, --all-devices <br>
Display the events of all DRBD minors.</p>

<p style="margin-top: 1em">-u, --unfiltered <br>
This is a debugging aid that displays the content of all
received netlink messages.</p>

<p style="margin-top: 1em">new-current-uuid <br>
Generates a new current UUID and rotates all other UUID
values. This has at least two use cases, namely to skip the
initial sync, and to reduce network bandwidth when starting
in <br>
a single node configuration and then later (re-)integrating
a remote site.</p>

<p style="margin-top: 1em">Available option:</p>

<p style="margin-top: 1em">-c, --clear-bitmap <br>
Clears the sync bitmap in addition to generating a new
current UUID.</p>

<p style="margin-top: 1em">This can be used to skip the
initial sync, if you want to start from scratch. This
use-case does only work on &quot;Just Created&quot; meta
data. Necessary steps:</p>

<p style="margin-top: 1em">1. On both nodes, initialize
meta data and configure the device.</p>

<p style="margin-top: 1em">drbdadm -- --force create-md
res</p>

<p style="margin-top: 1em">2. They need to do the initial
handshake, so they know their sizes.</p>

<p style="margin-top: 1em">drbdadm up res</p>

<p style="margin-top: 1em">3. They are now Connected
Secondary/Secondary Inconsistent/Inconsistent. Generate a
new current-uuid and clear the dirty bitmap.</p>

<p style="margin-top: 1em">drbdadm -- --clear-bitmap
new-current-uuid res</p>

<p style="margin-top: 1em">4. They are now Connected
Secondary/Secondary UpToDate/UpToDate. Make one side primary
and create a file system.</p>

<p style="margin-top: 1em">drbdadm primary res</p>

<p style="margin-top: 1em">mkfs -t fs-type $(drbdadm sh-dev
res)</p>

<p style="margin-top: 1em">One obvious side-effect is that
the replica is full of old garbage (unless you made them
identical using other means), so any online-verify is
expected to find any number of <br>
out-of-sync blocks.</p>

<p style="margin-top: 1em">You must not use this on
pre-existing data! Even though it may appear to work at
first glance, once you switch to the other node, your data
is toast, as it never got replicated. <br>
So do not leave out the mkfs (or equivalent).</p>

<p style="margin-top: 1em">This can also be used to shorten
the initial resync of a cluster where the second node is
added after the first node is gone into production, by means
of disk shipping. This <br>
use-case works on disconnected devices only, the device may
be in primary or secondary role.</p>

<p style="margin-top: 1em">The necessary steps on the
current active server are:</p>

<p style="margin-top: 1em">1. drbdsetup device
new-current-uuid --clear-bitmap</p>

<p style="margin-top: 1em">2. Take the copy of the current
active server. E.g. by pulling a disk out of the RAID1
controller, or by copying with dd. You need to copy the
actual data, and the meta data.</p>

<p style="margin-top: 1em">3. drbdsetup device
new-current-uuid</p>

<p style="margin-top: 1em">Now add the disk to the new
secondary node, and join it to the cluster. You will get a
resync of that parts that were changed since the first call
to drbdsetup in step 1.</p>

<p style="margin-top: 1em">EXAMPLES <br>
For examples, please have a look at the DRBD User&rsquo;s
Guide[1].</p>

<p style="margin-top: 1em">VERSION <br>
This document was revised for version 8.3.2 of the DRBD
distribution.</p>

<p style="margin-top: 1em">AUTHOR <br>
Written by Philipp Reisner
&lt;philipp.reisner@linbit.com&gt; and Lars Ellenberg
&lt;lars.ellenberg@linbit.com&gt;</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to &lt;drbd-user@lists.linbit.com&gt;.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright 2001-2008 LINBIT Information Technologies, Philipp
Reisner, Lars Ellenberg. This is free software; see the
source for copying conditions. There is NO warranty; not
even <br>
for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>

<p style="margin-top: 1em">SEE ALSO <br>
drbd.conf(5), drbd(8), drbddisk(8), drbdadm(8), DRBD
User&rsquo;s Guide[1], DRBD web site[2]</p>

<p style="margin-top: 1em">NOTES <br>
1. DRBD User&rsquo;s Guide <br>
http://www.drbd.org/users-guide/</p>

<p style="margin-top: 1em">2. DRBD web site <br>
http://www.drbd.org/</p>

<p style="margin-top: 1em">DRBD 8.3.2 5 Dec 2008
DRBDSETUP(8)</p>
<hr>
</body>
</html>
