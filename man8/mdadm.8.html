<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:13:18 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MDADM(8) System Manager&rsquo;s Manual MDADM(8)</p>

<p style="margin-top: 1em">NAME <br>
mdadm - manage MD devices aka Linux Software RAID</p>

<p style="margin-top: 1em">SYNOPSIS <br>
mdadm [mode] &lt;raiddevice&gt; [options]
&lt;component-devices&gt;</p>

<p style="margin-top: 1em">DESCRIPTION <br>
RAID devices are virtual devices created from two or more
real block devices. This allows multiple devices (typically
disk drives or partitions thereof) to be combined into a
<br>
single device to hold (for example) a single filesystem.
Some RAID levels include redundancy and so can survive some
degree of device failure.</p>

<p style="margin-top: 1em">Linux Software RAID devices are
implemented through the md (Multiple Devices) device
driver.</p>

<p style="margin-top: 1em">Currently, Linux supports LINEAR
md devices, RAID0 (striping), RAID1 (mirroring), RAID4,
RAID5, RAID6, RAID10, MULTIPATH, FAULTY, and CONTAINER.</p>

<p style="margin-top: 1em">MULTIPATH is not a Software RAID
mechanism, but does involve multiple devices: each device is
a path to one common physical storage device. New
installations should not use <br>
md/multipath as it is not well supported and has no ongoing
development. Use the Device Mapper based multipath-tools
instead.</p>

<p style="margin-top: 1em">FAULTY is also not true RAID,
and it only involves one device. It provides a layer over a
true device that can be used to inject faults.</p>

<p style="margin-top: 1em">CONTAINER is different again. A
CONTAINER is a collection of devices that are managed as a
set. This is similar to the set of devices connected to a
hardware RAID controller. <br>
The set of devices may contain a number of different RAID
arrays each utilising some (or all) of the blocks from a
number of the devices in the set. For example, two devices
in <br>
a 5-device set might form a RAID1 using the whole devices.
The remaining three might have a RAID5 over the first half
of each device, and a RAID0 over the second half.</p>

<p style="margin-top: 1em">With a CONTAINER, there is one
set of metadata that describes all of the arrays in the
container. So when mdadm creates a CONTAINER device, the
device just represents the meta&acirc; <br>
data. Other normal arrays (RAID1 etc) can be created inside
the container.</p>

<p style="margin-top: 1em">MODES <br>
mdadm has several major modes of operation:</p>

<p style="margin-top: 1em">Assemble <br>
Assemble the components of a previously created array into
an active array. Components can be explicitly given or can
be searched for. mdadm checks that the components <br>
do form a bona fide array, and can, on request, fiddle
superblock information so as to assemble a faulty array.</p>

<p style="margin-top: 1em">Build Build an array that
doesn&rsquo;t have per-device metadata (superblocks). For
these sorts of arrays, mdadm cannot differentiate between
initial creation and subsequent assembly <br>
of an array. It also cannot perform any checks that
appropriate components have been requested. Because of this,
the Build mode should only be used together with a
com&acirc; <br>
plete understanding of what you are doing.</p>

<p style="margin-top: 1em">Create Create a new array with
per-device metadata (superblocks). Appropriate metadata is
written to each device, and then the array comprising those
devices is activated. A <br>
&rsquo;resync&rsquo; process is started to make sure that
the array is consistent (e.g. both sides of a mirror contain
the same data) but the content of the device is left
otherwise <br>
untouched. The array can be used as soon as it has been
created. There is no need to wait for the initial resync to
finish.</p>

<p style="margin-top: 1em">Follow or Monitor <br>
Monitor one or more md devices and act on any state changes.
This is only meaningful for RAID1, 4, 5, 6, 10 or multipath
arrays, as only these have interesting state. <br>
RAID0 or Linear never have missing, spare, or failed drives,
so there is nothing to monitor.</p>

<p style="margin-top: 1em">Grow Grow (or shrink) an array,
or otherwise reshape it in some way. Currently supported
growth options including changing the active size of
component devices and changing <br>
the number of active devices in Linear and RAID levels
0/1/4/5/6, changing the RAID level between 0, 1, 5, and 6,
and between 0 and 10, changing the chunk size and layout
<br>
for RAID 0,4,5,6,10 as well as adding or removing a
write-intent bitmap.</p>

<p style="margin-top: 1em">Incremental Assembly <br>
Add a single device to an appropriate array. If the addition
of the device makes the array runnable, the array will be
started. This provides a convenient interface to a <br>
hot-plug system. As each device is detected, mdadm has a
chance to include it in some array as appropriate.
Optionally, when the --fail flag is passed in we will remove
<br>
the device from any active array instead of adding it.</p>

<p style="margin-top: 1em">If a CONTAINER is passed to
mdadm in this mode, then any arrays within that container
will be assembled and started.</p>

<p style="margin-top: 1em">Manage This is for doing things
to specific components of an array such as adding new spares
and removing faulty devices.</p>

<p style="margin-top: 1em">Misc This is an
&rsquo;everything else&rsquo; mode that supports operations
on active arrays, operations on component devices such as
erasing old superblocks, and information gathering <br>
operations.</p>

<p style="margin-top: 1em">Auto-detect <br>
This mode does not act on a specific device or array, but
rather it requests the Linux Kernel to activate any
auto-detected arrays.</p>

<p style="margin-top: 1em">OPTIONS Options for selecting a
mode are: <br>
-A, --assemble <br>
Assemble a pre-existing array.</p>

<p style="margin-top: 1em">-B, --build <br>
Build a legacy array without superblocks.</p>

<p style="margin-top: 1em">-C, --create <br>
Create a new array.</p>

<p style="margin-top: 1em">-F, --follow, --monitor <br>
Select Monitor mode.</p>

<p style="margin-top: 1em">-G, --grow <br>
Change the size or shape of an active array.</p>

<p style="margin-top: 1em">-I, --incremental <br>
Add/remove a single device to/from an appropriate array, and
possibly start the array.</p>

<p style="margin-top: 1em">--auto-detect <br>
Request that the kernel starts any auto-detected arrays.
This can only work if md is compiled into the kernel &acirc;
not if it is a module. Arrays can be auto-detected by the
<br>
kernel if all the components are in primary MS-DOS
partitions with partition type FD, and all use v0.90
metadata. In-kernel autodetect is not recommended for new
instal&acirc; <br>
lations. Using mdadm to detect and assemble arrays &acirc;
possibly in an initrd &acirc; is substantially more flexible
and should be preferred.</p>

<p style="margin-top: 1em">If a device is given before any
options, or if the first option is one of --add, --re-add,
--add-spare, --fail, --remove, or --replace, then the MANAGE
mode is assumed. Anything <br>
other than these will cause the Misc mode to be assumed.</p>

<p style="margin-top: 1em">Options that are not
mode-specific are: <br>
-h, --help <br>
Display general help message or, after one of the above
options, a mode-specific help message.</p>

<p style="margin-top: 1em">--help-options <br>
Display more detailed help about command line parsing and
some commonly used options.</p>

<p style="margin-top: 1em">-V, --version <br>
Print version information for mdadm.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Be more verbose about what is happening. This can be used
twice to be extra-verbose. The extra verbosity currently
only affects --detail --scan and --examine --scan.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Avoid printing purely informative messages. With this, mdadm
will be silent unless there is something really important to
report.</p>

<p style="margin-top: 1em">-f, --force <br>
Be more forceful about certain operations. See the various
modes for the exact meaning of this option in different
contexts.</p>

<p style="margin-top: 1em">-c, --config= <br>
Specify the config file or directory. Default is to use
/etc/mdadm.conf and /etc/mdadm.conf.d, or if those are
missing then /etc/mdadm/mdadm.conf and <br>
/etc/mdadm/mdadm.conf.d. If the config file given is
partitions then nothing will be read, but mdadm will act as
though the config file contained exactly <br>
DEVICE partitions containers <br>
and will read /proc/partitions to find a list of devices to
scan, and /proc/mdstat to find a list of containers to
examine. If the word none is given for the config file, <br>
then mdadm will act as though the config file were
empty.</p>

<p style="margin-top: 1em">If the name given is of a
directory, then mdadm will collect all the files contained
in the directory with a name ending in .conf, sort them
lexically, and process all of <br>
those files as config files.</p>

<p style="margin-top: 1em">-s, --scan <br>
Scan config file or /proc/mdstat for missing information. In
general, this option gives mdadm permission to get any
missing information (like component devices, array <br>
devices, array identities, and alert destination) from the
configuration file (see previous option); one exception is
MISC mode when using --detail or --stop, in which <br>
case --scan says to get a list of array devices from
/proc/mdstat.</p>

<p style="margin-top: 1em">-e, --metadata= <br>
Declare the style of RAID metadata (superblock) to be used.
The default is 1.2 for --create, and to guess for other
operations. The default can be overridden by setting <br>
the metadata value for the CREATE keyword in mdadm.conf.</p>

<p style="margin-top: 1em">Options are:</p>

<p style="margin-top: 1em">0, 0.90 <br>
Use the original 0.90 format superblock. This format limits
arrays to 28 component devices and limits component devices
of levels 1 and greater to 2 terabytes. It <br>
is also possible for there to be confusion about whether the
superblock applies to a whole device or just the last
partition, if that partition starts on a 64K <br>
boundary.</p>

<p style="margin-top: 1em">1, 1.0, 1.1, 1.2 default <br>
Use the new version-1 format superblock. This has fewer
restrictions. It can easily be moved between hosts with
different endian-ness, and a recovery operation <br>
can be checkpointed and restarted. The different
sub-versions store the superblock at different locations on
the device, either at the end (for 1.0), at the start <br>
(for 1.1) or 4K from the start (for 1.2). &quot;1&quot; is
equivalent to &quot;1.2&quot; (the commonly preferred 1.x
format). &quot;default&quot; is equivalent to
&quot;1.2&quot;.</p>

<p style="margin-top: 1em">ddf Use the &quot;Industry
Standard&quot; DDF (Disk Data Format) format defined by
SNIA. When creating a DDF array a CONTAINER will be created,
and normal arrays can be created <br>
in that container.</p>

<p style="margin-top: 1em">imsm Use the Intel(R) Matrix
Storage Manager metadata format. This creates a CONTAINER
which is managed in a similar manner to DDF, and is
supported by an option-rom on <br>
some platforms:</p>


<p style="margin-top: 1em">http://www.intel.com/design/chipsets/matrixstorage_sb.htm</p>

<p style="margin-top: 1em">--homehost= <br>
This will override any HOMEHOST setting in the config file
and provides the identity of the host which should be
considered the home for any arrays.</p>

<p style="margin-top: 1em">When creating an array, the
homehost will be recorded in the metadata. For version-1
superblocks, it will be prefixed to the array name. For
version-0.90 superblocks, <br>
part of the SHA1 hash of the hostname will be stored in the
later half of the UUID.</p>

<p style="margin-top: 1em">When reporting information about
an array, any array which is tagged for the given homehost
will be reported as such.</p>

<p style="margin-top: 1em">When using Auto-Assemble, only
arrays tagged for the given homehost will be allowed to use
&rsquo;local&rsquo; names (i.e. not ending in
&rsquo;_&rsquo; followed by a digit string). See below <br>
under Auto Assembly.</p>

<p style="margin-top: 1em">The special name &quot;any&quot;
can be used as a wild card. If an array is created with
--homehost=any then the name &quot;any&quot; will be stored
in the array and it can be assembled in <br>
the same way on any host. If an array is assembled with this
option, then the homehost recorded on the array will be
ignored.</p>

<p style="margin-top: 1em">--prefer= <br>
When mdadm needs to print the name for a device it normally
finds the name in /dev which refers to the device and is
shortest. When a path component is given with --pre&acirc;
<br>
fer mdadm will prefer a longer name if it contains that
component. For example --prefer=by-uuid will prefer a name
in a subdirectory of /dev called by-uuid.</p>

<p style="margin-top: 1em">This functionality is currently
only provided by --detail and --monitor.</p>

<p style="margin-top: 1em">--home-cluster= <br>
specifies the cluster name for the md device. The md device
can be assembled only on the cluster which matches the name
specified. If this option is not provided, mdadm <br>
tries to detect the cluster name automatically.</p>

<p style="margin-top: 1em">For create, build, or grow: <br>
-n, --raid-devices= <br>
Specify the number of active devices in the array. This,
plus the number of spare devices (see below) must equal the
number of component-devices (including &quot;missing&quot;
<br>
devices) that are listed on the command line for --create.
Setting a value of 1 is probably a mistake and so requires
that --force be specified first. A value of 1 will <br>
then be allowed for linear, multipath, RAID0 and RAID1. It
is never allowed for RAID4, RAID5 or RAID6. <br>
This number can only be changed using --grow for RAID1,
RAID4, RAID5 and RAID6 arrays, and only on kernels which
provide the necessary support.</p>

<p style="margin-top: 1em">-x, --spare-devices= <br>
Specify the number of spare (eXtra) devices in the initial
array. Spares can also be added and removed later. The
number of component devices listed on the command line <br>
must equal the number of RAID devices plus the number of
spare devices.</p>

<p style="margin-top: 1em">-z, --size= <br>
Amount (in Kibibytes) of space to use from each drive in
RAID levels 1/4/5/6. This must be a multiple of the chunk
size, and must leave about 128Kb of space at the end of <br>
the drive for the RAID superblock. If this is not specified
(as it normally is not) the smallest drive (or partition)
sets the size, though if there is a variance among <br>
the drives of greater than 1%, a warning is issued.</p>

<p style="margin-top: 1em">A suffix of &rsquo;M&rsquo; or
&rsquo;G&rsquo; can be given to indicate Megabytes or
Gigabytes respectively.</p>

<p style="margin-top: 1em">Sometimes a replacement drive
can be a little smaller than the original drives though this
should be minimised by IDEMA standards. Such a replacement
drive will be <br>
rejected by md. To guard against this it can be useful to
set the initial size slightly smaller than the smaller
device with the aim that it will still be larger than any
<br>
replacement.</p>

<p style="margin-top: 1em">This value can be set with
--grow for RAID level 1/4/5/6 though CONTAINER based arrays
such as those with IMSM metadata may not be able to support
this. If the array was <br>
created with a size smaller than the currently active
drives, the extra space can be accessed using --grow. The
size can be given as max which means to choose the largest
<br>
size that fits on all current drives.</p>

<p style="margin-top: 1em">Before reducing the size of the
array (with --grow --size=) you should make sure that space
isn&rsquo;t needed. If the device holds a filesystem, you
would need to resize the <br>
filesystem to use less space.</p>

<p style="margin-top: 1em">After reducing the array size
you should check that the data stored in the device is still
available. If the device holds a filesystem, then an
&rsquo;fsck&rsquo; of the filesystem <br>
is a minimum requirement. If there are problems the array
can be made bigger again with no loss with another --grow
--size= command.</p>

<p style="margin-top: 1em">This value cannot be used when
creating a CONTAINER such as with DDF and IMSM metadata,
though it perfectly valid when creating an array inside a
container.</p>

<p style="margin-top: 1em">-Z, --array-size= <br>
This is only meaningful with --grow and its effect is not
persistent: when the array is stopped and restarted the
default array size will be restored.</p>

<p style="margin-top: 1em">Setting the array-size causes
the array to appear smaller to programs that access the
data. This is particularly needed before reshaping an array
so that it will be <br>
smaller. As the reshape is not reversible, but setting the
size with --array-size is, it is required that the array
size is reduced as appropriate before the number of <br>
devices in the array is reduced.</p>

<p style="margin-top: 1em">Before reducing the size of the
array you should make sure that space isn&rsquo;t needed. If
the device holds a filesystem, you would need to resize the
filesystem to use less <br>
space.</p>

<p style="margin-top: 1em">After reducing the array size
you should check that the data stored in the device is still
available. If the device holds a filesystem, then an
&rsquo;fsck&rsquo; of the filesystem <br>
is a minimum requirement. If there are problems the array
can be made bigger again with no loss with another --grow
--array-size= command.</p>

<p style="margin-top: 1em">A suffix of &rsquo;M&rsquo; or
&rsquo;G&rsquo; can be given to indicate Megabytes or
Gigabytes respectively. A value of max restores the apparent
size of the array to be whatever the real amount <br>
of available space is.</p>

<p style="margin-top: 1em">-c, --chunk= <br>
Specify chunk size of kibibytes. The default when creating
an array is 512KB. To ensure compatibility with earlier
versions, the default when building an array with no <br>
persistent metadata is 64KB. This is only meaningful for
RAID0, RAID4, RAID5, RAID6, and RAID10.</p>

<p style="margin-top: 1em">RAID4, RAID5, RAID6, and RAID10
require the chunk size to be a power of 2. In any case it
must be a multiple of 4KB.</p>

<p style="margin-top: 1em">A suffix of &rsquo;M&rsquo; or
&rsquo;G&rsquo; can be given to indicate Megabytes or
Gigabytes respectively.</p>

<p style="margin-top: 1em">--rounding= <br>
Specify rounding factor for a Linear array. The size of each
component will be rounded down to a multiple of this size.
This is a synonym for --chunk but highlights the <br>
different meaning for Linear as compared to other RAID
levels. The default is 64K if a kernel earlier than 2.6.16
is in use, and is 0K (i.e. no rounding) in later ker&acirc;
<br>
nels.</p>

<p style="margin-top: 1em">-l, --level= <br>
Set RAID level. When used with --create, options are:
linear, raid0, 0, stripe, raid1, 1, mirror, raid4, 4, raid5,
5, raid6, 6, raid10, 10, multipath, mp, faulty, con&acirc;
<br>
tainer. Obviously some of these are synonymous.</p>

<p style="margin-top: 1em">When a CONTAINER metadata type
is requested, only the container level is permitted, and it
does not need to be explicitly given.</p>

<p style="margin-top: 1em">When used with --build, only
linear, stripe, raid0, 0, raid1, multipath, mp, and faulty
are valid.</p>

<p style="margin-top: 1em">Can be used with --grow to
change the RAID level in some cases. See LEVEL CHANGES
below.</p>

<p style="margin-top: 1em">-p, --layout= <br>
This option configures the fine details of data layout for
RAID5, RAID6, and RAID10 arrays, and controls the failure
modes for faulty.</p>

<p style="margin-top: 1em">The layout of the RAID5 parity
block can be one of left-asymmetric, left-symmetric,
right-asymmetric, right-symmetric, la, ra, ls, rs. The
default is left-symmetric.</p>

<p style="margin-top: 1em">It is also possible to cause
RAID5 to use a RAID4-like layout by choosing parity-first,
or parity-last.</p>

<p style="margin-top: 1em">Finally for RAID5 there are
DDF-compatible layouts, ddf-zero-restart, ddf-N-restart, and
ddf-N-continue.</p>

<p style="margin-top: 1em">These same layouts are available
for RAID6. There are also 4 layouts that will provide an
intermediate stage for converting between RAID5 and RAID6.
These provide a lay&acirc; <br>
out which is identical to the corresponding RAID5 layout on
the first N-1 devices, and has the &rsquo;Q&rsquo; syndrome
(the second &rsquo;parity&rsquo; block used by RAID6) on the
last device. <br>
These layouts are: left-symmetric-6, right-symmetric-6,
left-asymmetric-6, right-asymmetric-6, and
parity-first-6.</p>

<p style="margin-top: 1em">When setting the failure mode
for level faulty, the options are: write-transient, wt,
read-transient, rt, write-persistent, wp, read-persistent,
rp, write-all, read-fix&acirc; <br>
able, rf, clear, flush, none.</p>

<p style="margin-top: 1em">Each failure mode can be
followed by a number, which is used as a period between
fault generation. Without a number, the fault is generated
once on the first relevant <br>
request. With a number, the fault will be generated after
that many requests, and will continue to be generated every
time the period elapses.</p>

<p style="margin-top: 1em">Multiple failure modes can be
current simultaneously by using the --grow option to set
subsequent failure modes.</p>

<p style="margin-top: 1em">&quot;clear&quot; or
&quot;none&quot; will remove any pending or periodic failure
modes, and &quot;flush&quot; will clear any persistent
faults.</p>

<p style="margin-top: 1em">Finally, the layout options for
RAID10 are one of &rsquo;n&rsquo;, &rsquo;o&rsquo; or
&rsquo;f&rsquo; followed by a small number. The default is
&rsquo;n2&rsquo;. The supported options are:</p>

<p style="margin-top: 1em">&rsquo;n&rsquo; signals
&rsquo;near&rsquo; copies. Multiple copies of one data block
are at similar offsets in different devices.</p>

<p style="margin-top: 1em">&rsquo;o&rsquo; signals
&rsquo;offset&rsquo; copies. Rather than the chunks being
duplicated within a stripe, whole stripes are duplicated but
are rotated by one device so duplicate blocks are <br>
on different devices. Thus subsequent copies of a block are
in the next drive, and are one chunk further down.</p>

<p style="margin-top: 1em">&rsquo;f&rsquo; signals
&rsquo;far&rsquo; copies (multiple copies have very
different offsets). See md(4) for more detail about
&rsquo;near&rsquo;, &rsquo;offset&rsquo;, and
&rsquo;far&rsquo;.</p>

<p style="margin-top: 1em">The number is the number of
copies of each datablock. 2 is normal, 3 can be useful. This
number can be at most equal to the number of devices in the
array. It does not <br>
need to divide evenly into that number (e.g. it is perfectly
legal to have an &rsquo;n2&rsquo; layout for an array with
an odd number of devices).</p>

<p style="margin-top: 1em">When an array is converted
between RAID5 and RAID6 an intermediate RAID6 layout is used
in which the second parity block (Q) is always on the last
device. To convert a <br>
RAID5 to RAID6 and leave it in this new layout (which does
not require re-striping) use --layout=preserve. This will
try to avoid any restriping.</p>

<p style="margin-top: 1em">The converse of this is
--layout=normalise which will change a non-standard RAID6
layout into a more standard arrangement.</p>

<p style="margin-top: 1em">--parity= <br>
same as --layout (thus explaining the p of -p).</p>

<p style="margin-top: 1em">-b, --bitmap= <br>
Specify a file to store a write-intent bitmap in. The file
should not exist unless --force is also given. The same file
should be provided when assembling the array. If <br>
the word internal is given, then the bitmap is stored with
the metadata on the array, and so is replicated on all
devices. If the word none is given with --grow mode, <br>
then any bitmap that is present is removed. If the word
clustered is given, the array is created for a clustered
environment. One bitmap is created for each node as <br>
defined by the --nodes parameter and are stored
internally.</p>

<p style="margin-top: 1em">To help catch typing errors, the
filename must contain at least one slash (&rsquo;/&rsquo;)
if it is a real file (not &rsquo;internal&rsquo; or
&rsquo;none&rsquo;).</p>

<p style="margin-top: 1em">Note: external bitmaps are only
known to work on ext2 and ext3. Storing bitmap files on
other filesystems may result in serious problems.</p>

<p style="margin-top: 1em">When creating an array on
devices which are 100G or larger, mdadm automatically adds
an internal bitmap as it will usually be beneficial. This
can be suppressed with <br>
--bitmap=none .</p>

<p style="margin-top: 1em">--bitmap-chunk= <br>
Set the chunksize of the bitmap. Each bit corresponds to
that many Kilobytes of storage. When using a file based
bitmap, the default is to use the smallest size that is <br>
at-least 4 and requires no more than 2^21 chunks. When using
an internal bitmap, the chunksize defaults to 64Meg, or
larger if necessary to fit the bitmap into the avail&acirc;
<br>
able space.</p>

<p style="margin-top: 1em">A suffix of &rsquo;M&rsquo; or
&rsquo;G&rsquo; can be given to indicate Megabytes or
Gigabytes respectively.</p>

<p style="margin-top: 1em">-W, --write-mostly <br>
subsequent devices listed in a --build, --create, or --add
command will be flagged as &rsquo;write-mostly&rsquo;. This
is valid for RAID1 only and means that the &rsquo;md&rsquo;
driver will <br>
avoid reading from these devices if at all possible. This
can be useful if mirroring over a slow link.</p>

<p style="margin-top: 1em">--write-behind= <br>
Specify that write-behind mode should be enabled (valid for
RAID1 only). If an argument is specified, it will set the
maximum number of outstanding writes allowed. The <br>
default value is 256. A write-intent bitmap is required in
order to use write-behind mode, and write-behind is only
attempted on drives marked as write-mostly.</p>

<p style="margin-top: 1em">--assume-clean <br>
Tell mdadm that the array pre-existed and is known to be
clean. It can be useful when trying to recover from a major
failure as you can be sure that no data will be <br>
affected unless you actually write to the array. It can also
be used when creating a RAID1 or RAID10 if you want to avoid
the initial resync, however this practice &acirc; <br>
while normally safe &acirc; is not recommended. Use this
only if you really know what you are doing.</p>

<p style="margin-top: 1em">When the devices that will be
part of a new array were filled with zeros before creation
the operator knows the array is actually clean. If that is
the case, such as after <br>
running badblocks, this argument can be used to tell mdadm
the facts the operator knows.</p>

<p style="margin-top: 1em">When an array is resized to a
larger size with --grow --size= the new space is normally
resynced in that same way that the whole array is resynced
at creation. From Linux <br>
version 3.0, --assume-clean can be used with that command to
avoid the automatic resync.</p>

<p style="margin-top: 1em">--backup-file= <br>
This is needed when --grow is used to increase the number of
raid-devices in a RAID5 or RAID6 if there are no spare
devices available, or to shrink, change RAID level or <br>
layout. See the GROW MODE section below on RAID-DEVICES
CHANGES. The file must be stored on a separate device, not
on the RAID array being reshaped.</p>

<p style="margin-top: 1em">--data-offset= <br>
Arrays with 1.x metadata can leave a gap between the start
of the device and the start of array data. This gap can be
used for various metadata. The start of data is <br>
known as the data-offset. Normally an appropriate data
offset is computed automatically. However it can be useful
to set it explicitly such as when re-creating an array <br>
which was originally created using a different version of
mdadm which computed a different offset.</p>

<p style="margin-top: 1em">Setting the offset explicitly
over-rides the default. The value given is in Kilobytes
unless an &rsquo;M&rsquo; or &rsquo;G&rsquo; suffix is
given.</p>

<p style="margin-top: 1em">Since Linux 3.4, --data-offset
can also be used with --grow for some RAID levels (initially
on RAID10). This allows the data-offset to be changed as
part of the reshape <br>
process. When the data offset is changed, no backup file is
required as the difference in offsets is used to provide the
same functionality.</p>

<p style="margin-top: 1em">When the new offset is earlier
than the old offset, the number of devices in the array
cannot shrink. When it is after the old offset, the number
of devices in the array <br>
cannot increase.</p>

<p style="margin-top: 1em">When creating an array,
--data-offset can be specified as variable. In the case each
member device is expected to have a offset appended to the
name, separated by a <br>
colon. This makes it possible to recreate exactly an array
which has varying data offsets (as can happen when different
versions of mdadm are used to add different <br>
devices).</p>

<p style="margin-top: 1em">--continue <br>
This option is complementary to the --freeze-reshape option
for assembly. It is needed when --grow operation is
interrupted and it is not restarted automatically due to
<br>
--freeze-reshape usage during array assembly. This option is
used together with -G , ( --grow ) command and device for a
pending reshape to be continued. All parameters <br>
required for reshape continuation will be read from array
metadata. If initial --grow command had required
--backup-file= option to be set, continuation option will
<br>
require to have exactly the same backup file given as
well.</p>

<p style="margin-top: 1em">Any other parameter passed
together with --continue option will be ignored.</p>

<p style="margin-top: 1em">-N, --name= <br>
Set a name for the array. This is currently only effective
when creating an array with a version-1 superblock, or an
array in a DDF container. The name is a simple tex&acirc;
<br>
tual string that can be used to identify array components
when assembling. If name is needed but not specified, it is
taken from the basename of the device that is being <br>
created. e.g. when creating /dev/md/home the name will
default to home.</p>

<p style="margin-top: 1em">-R, --run <br>
Insist that mdadm run the array, even if some of the
components appear to be active in another array or
filesystem. Normally mdadm will ask for confirmation before
<br>
including such components in an array. This option causes
that question to be suppressed.</p>

<p style="margin-top: 1em">-f, --force <br>
Insist that mdadm accept the geometry and layout specified
without question. Normally mdadm will not allow creation of
an array with only one device, and will try to cre&acirc;
<br>
ate a RAID5 array with one missing drive (as this makes the
initial resync work faster). With --force, mdadm will not
try to be so clever.</p>

<p style="margin-top: 1em">-o, --readonly <br>
Start the array read only rather than read-write as normal.
No writes will be allowed to the array, and no resync,
recovery, or reshape will be started.</p>

<p style="margin-top: 1em">-a,
--auto{=yes,md,mdp,part,p}{NN} <br>
Instruct mdadm how to create the device file if needed,
possibly allocating an unused minor number. &quot;md&quot;
causes a non-partitionable array to be used (though since
Linux <br>
2.6.28, these array devices are in fact partitionable).
&quot;mdp&quot;, &quot;part&quot; or &quot;p&quot; causes a
partitionable array (2.6 and later) to be used.
&quot;yes&quot; requires the named md device <br>
to have a &rsquo;standard&rsquo; format, and the type and
minor number will be determined from this. With mdadm 3.0,
device creation is normally left up to udev so this option
is <br>
unlikely to be needed. See DEVICE NAMES below.</p>

<p style="margin-top: 1em">The argument can also come
immediately after &quot;-a&quot;. e.g. &quot;-ap&quot;.</p>

<p style="margin-top: 1em">If --auto is not given on the
command line or in the config file, then the default will be
--auto=yes.</p>

<p style="margin-top: 1em">If --scan is also given, then
any auto= entries in the config file will override the
--auto instruction given on the command line.</p>

<p style="margin-top: 1em">For partitionable arrays, mdadm
will create the device file for the whole array and for the
first 4 partitions. A different number of partitions can be
specified at the <br>
end of this option (e.g. --auto=p7). If the device name ends
with a digit, the partition names add a &rsquo;p&rsquo;, and
a number, e.g. /dev/md/home1p3. If there is no trailing <br>
digit, then the partition names just have a number added,
e.g. /dev/md/scratch3.</p>

<p style="margin-top: 1em">If the md device name is in a
&rsquo;standard&rsquo; format as described in DEVICE NAMES,
then it will be created, if necessary, with the appropriate
device number based on that name. <br>
If the device name is not in one of these formats, then a
unused device number will be allocated. The device number
will be considered unused if there is no active array <br>
for that number, and there is no entry in /dev for that
number and with a non-standard name. Names that are not in
&rsquo;standard&rsquo; format are only allowed in
&quot;/dev/md/&quot;.</p>

<p style="margin-top: 1em">This is meaningful with --create
or --build.</p>

<p style="margin-top: 1em">-a, --add <br>
This option can be used in Grow mode in two cases.</p>

<p style="margin-top: 1em">If the target array is a Linear
array, then --add can be used to add one or more devices to
the array. They are simply catenated on to the end of the
array. Once added, <br>
the devices cannot be removed.</p>

<p style="margin-top: 1em">If the --raid-disks option is
being used to increase the number of devices in an array,
then --add can be used to add some extra devices to be
included in the array. In <br>
most cases this is not needed as the extra devices can be
added as spares first, and then the number of raid-disks can
be changed. However for RAID0, it is not possible <br>
to add spares. So to increase the number of devices in a
RAID0, it is necessary to set the new number of devices, and
to add the new devices, in the same command.</p>

<p style="margin-top: 1em">--nodes <br>
Only works when the array is for clustered environment. It
specifies the maximum number of nodes in the cluster that
will use this device simultaneously. If not specified, <br>
this defaults to 4.</p>

<p style="margin-top: 1em">--write-journal <br>
Specify journal device for the RAID-4/5/6 array. The journal
device should be a SSD with reasonable lifetime.</p>

<p style="margin-top: 1em">For assemble: <br>
-u, --uuid= <br>
uuid of array to assemble. Devices which don&rsquo;t have
this uuid are excluded</p>

<p style="margin-top: 1em">-m, --super-minor= <br>
Minor number of device that array was created for. Devices
which don&rsquo;t have this minor number are excluded. If
you create an array as /dev/md1, then all superblocks will
<br>
contain the minor number 1, even if the array is later
assembled as /dev/md2.</p>

<p style="margin-top: 1em">Giving the literal word
&quot;dev&quot; for --super-minor will cause mdadm to use
the minor number of the md device that is being assembled.
e.g. when assembling /dev/md0, <br>
--super-minor=dev will look for super blocks with a minor
number of 0.</p>

<p style="margin-top: 1em">--super-minor is only relevant
for v0.90 metadata, and should not normally be used. Using
--uuid is much safer.</p>

<p style="margin-top: 1em">-N, --name= <br>
Specify the name of the array to assemble. This must be the
name that was specified when creating the array. It must
either match the name stored in the superblock <br>
exactly, or it must match with the current homehost prefixed
to the start of the given name.</p>

<p style="margin-top: 1em">-f, --force <br>
Assemble the array even if the metadata on some devices
appears to be out-of-date. If mdadm cannot find enough
working devices to start the array, but can find some <br>
devices that are recorded as having failed, then it will
mark those devices as working so that the array can be
started. An array which requires --force to be started may
<br>
contain data corruption. Use it carefully.</p>

<p style="margin-top: 1em">-R, --run <br>
Attempt to start the array even if fewer drives were given
than were present last time the array was active. Normally
if not all the expected drives are found and --scan <br>
is not used, then the array will be assembled but not
started. With --run an attempt will be made to start it
anyway.</p>

<p style="margin-top: 1em">--no-degraded <br>
This is the reverse of --run in that it inhibits the startup
of array unless all expected drives are present. This is
only needed with --scan, and can be used if the <br>
physical connections to devices are not as reliable as you
would like.</p>

<p style="margin-top: 1em">-a, --auto{=no,yes,md,mdp,part}
<br>
See this option under Create and Build options.</p>

<p style="margin-top: 1em">-b, --bitmap= <br>
Specify the bitmap file that was given when the array was
created. If an array has an internal bitmap, there is no
need to specify this when assembling the array.</p>

<p style="margin-top: 1em">--backup-file= <br>
If --backup-file was used while reshaping an array (e.g.
changing number of devices or chunk size) and the system
crashed during the critical section, then the same <br>
--backup-file must be presented to --assemble to allow
possibly corrupted data to be restored, and the reshape to
be completed.</p>

<p style="margin-top: 1em">--invalid-backup <br>
If the file needed for the above option is not available for
any reason an empty file can be given together with this
option to indicate that the backup file is invalid. <br>
In this case the data that was being rearranged at the time
of the crash could be irrecoverably lost, but the rest of
the array may still be recoverable. This option <br>
should only be used as a last resort if there is no way to
recover the backup file.</p>

<p style="margin-top: 1em">-U, --update= <br>
Update the superblock on each device while assembling the
array. The argument given to this flag can be one of
sparc2.2, summaries, uuid, name, nodes, homehost, home- <br>
cluster, resync, byteorder, devicesize, no-bitmap, bbl,
no-bbl, metadata, or super-minor.</p>

<p style="margin-top: 1em">The sparc2.2 option will adjust
the superblock of an array what was created on a Sparc
machine running a patched 2.2 Linux kernel. This kernel got
the alignment of part <br>
of the superblock wrong. You can use the --examine
--sparc2.2 option to mdadm to see what effect this would
have.</p>

<p style="margin-top: 1em">The super-minor option will
update the preferred minor field on each superblock to match
the minor number of the array being assembled. This can be
useful if --examine <br>
reports a different &quot;Preferred Minor&quot; to --detail.
In some cases this update will be performed automatically by
the kernel driver. In particular the update happens
auto&acirc; <br>
matically at the first write to an array with redundancy
(RAID level 1 or greater) on a 2.6 (or later) kernel.</p>

<p style="margin-top: 1em">The uuid option will change the
uuid of the array. If a UUID is given with the --uuid option
that UUID will be used as a new UUID and will NOT be used to
help identify <br>
the devices in the array. If no --uuid is given, a random
UUID is chosen.</p>

<p style="margin-top: 1em">The name option will change the
name of the array as stored in the superblock. This is only
supported for version-1 superblocks.</p>

<p style="margin-top: 1em">The nodes option will change the
nodes of the array as stored in the bitmap superblock. This
option only works for a clustered environment.</p>

<p style="margin-top: 1em">The homehost option will change
the homehost as recorded in the superblock. For version-0
superblocks, this is the same as updating the UUID. For
version-1 superblocks, <br>
this involves updating the name.</p>

<p style="margin-top: 1em">The home-cluster option will
change the cluster name as recorded in the superblock and
bitmap. This option only works for clustered
environment.</p>

<p style="margin-top: 1em">The resync option will cause the
array to be marked dirty meaning that any redundancy in the
array (e.g. parity for RAID5, copies for RAID1) may be
incorrect. This will <br>
cause the RAID system to perform a &quot;resync&quot; pass
to make sure that all redundant information is correct.</p>

<p style="margin-top: 1em">The byteorder option allows
arrays to be moved between machines with different
byte-order. When assembling such an array for the first time
after a move, giving <br>
--update=byteorder will cause mdadm to expect superblocks to
have their byteorder reversed, and will correct that order
before assembling the array. This is only valid <br>
with original (Version 0.90) superblocks.</p>

<p style="margin-top: 1em">The summaries option will
correct the summaries in the superblock. That is the counts
of total, working, active, failed, and spare devices.</p>

<p style="margin-top: 1em">The devicesize option will
rarely be of use. It applies to version 1.1 and 1.2 metadata
only (where the metadata is at the start of the device) and
is only useful when <br>
the component device has changed size (typically become
larger). The version 1 metadata records the amount of the
device that can be used to store data, so if a device in
<br>
a version 1.1 or 1.2 array becomes larger, the metadata will
still be visible, but the extra space will not. In this case
it might be useful to assemble the array with <br>
--update=devicesize. This will cause mdadm to determine the
maximum usable amount of space on each device and update the
relevant field in the metadata.</p>

<p style="margin-top: 1em">The metadata option only works
on v0.90 metadata arrays and will convert them to v1.0
metadata. The array must not be dirty (i.e. it must not need
a sync) and it must not <br>
have a write-intent bitmap.</p>

<p style="margin-top: 1em">The old metadata will remain on
the devices, but will appear older than the new metadata and
so will usually be ignored. The old metadata (or indeed the
new metadata) can <br>
be removed by giving the appropriate --metadata= option to
--zero-superblock.</p>

<p style="margin-top: 1em">The no-bitmap option can be used
when an array has an internal bitmap which is corrupt in
some way so that assembling the array normally fails. It
will cause any internal <br>
bitmap to be ignored.</p>

<p style="margin-top: 1em">The bbl option will reserve
space in each device for a bad block list. This will be 4K
in size and positioned near the end of any free space
between the superblock and <br>
the data.</p>

<p style="margin-top: 1em">The no-bbl option will cause any
reservation of space for a bad block list to be removed. If
the bad block list contains entries, this will fail, as
removing the list <br>
could cause data corruption.</p>

<p style="margin-top: 1em">--freeze-reshape <br>
Option is intended to be used in start-up scripts during
initrd boot phase. When array under reshape is assembled
during initrd phase, this option stops reshape after <br>
reshape critical section is being restored. This happens
before file system pivot operation and avoids loss of file
system context. Losing file system context would cause <br>
reshape to be broken.</p>

<p style="margin-top: 1em">Reshape can be continued later
using the --continue option for the grow command.</p>

<p style="margin-top: 1em">For Manage mode: <br>
-t, --test <br>
Unless a more serious error occurred, mdadm will exit with a
status of 2 if no changes were made to the array and 0 if at
least one change was made. This can be useful <br>
when an indirect specifier such as missing, detached or
faulty is used in requesting an operation on the array.
--test will report failure if these specifiers didn&rsquo;t
find <br>
any match.</p>

<p style="margin-top: 1em">-a, --add <br>
hot-add listed devices. If a device appears to have recently
been part of the array (possibly it failed or was removed)
the device is re-added as described in the next <br>
point. If that fails or the device was never part of the
array, the device is added as a hot-spare. If the array is
degraded, it will immediately start to rebuild data <br>
onto that spare.</p>

<p style="margin-top: 1em">Note that this and the following
options are only meaningful on array with redundancy. They
don&rsquo;t apply to RAID0 or Linear.</p>

<p style="margin-top: 1em">--re-add <br>
re-add a device that was previously removed from an array.
If the metadata on the device reports that it is a member of
the array, and the slot that it used is still <br>
vacant, then the device will be added back to the array in
the same position. This will normally cause the data for
that device to be recovered. However based on the <br>
event count on the device, the recovery may only require
sections that are flagged a write-intent bitmap to be
recovered or may not require any recovery at all.</p>

<p style="margin-top: 1em">When used on an array that has
no metadata (i.e. it was built with --build) it will be
assumed that bitmap-based recovery is enough to make the
device fully consistent <br>
with the array.</p>

<p style="margin-top: 1em">When used with v1.x metadata,
--re-add can be accompanied by --update=devicesize,
--update=bbl, or --update=no-bbl. See the description of
these option when used in <br>
Assemble mode for an explanation of their use.</p>

<p style="margin-top: 1em">If the device name given is
missing then mdadm will try to find any device that looks
like it should be part of the array but isn&rsquo;t and will
try to re-add all such <br>
devices.</p>

<p style="margin-top: 1em">If the device name given is
faulty then mdadm will find all devices in the array that
are marked faulty, remove them and attempt to immediately
re-add them. This can be <br>
useful if you are certain that the reason for failure has
been resolved.</p>

<p style="margin-top: 1em">--add-spare <br>
Add a device as a spare. This is similar to --add except
that it does not attempt --re-add first. The device will be
added as a spare even if it looks like it could be <br>
an recent member of the array.</p>

<p style="margin-top: 1em">-r, --remove <br>
remove listed devices. They must not be active. i.e. they
should be failed or spare devices.</p>

<p style="margin-top: 1em">As well as the name of a device
file (e.g. /dev/sda1) the words failed, detached and names
like set-A can be given to --remove. The first causes all
failed device to be <br>
removed. The second causes any device which is no longer
connected to the system (i.e an &rsquo;open&rsquo; returns
ENXIO) to be removed. The third will remove a set as
describe <br>
below under --fail.</p>

<p style="margin-top: 1em">-f, --fail <br>
Mark listed devices as faulty. As well as the name of a
device file, the word detached or a set name like set-A can
be given. The former will cause any device that has <br>
been detached from the system to be marked as failed. It can
then be removed.</p>

<p style="margin-top: 1em">For RAID10 arrays where the
number of copies evenly divides the number of devices, the
devices can be conceptually divided into sets where each set
contains a single com&acirc; <br>
plete copy of the data on the array. Sometimes a RAID10
array will be configured so that these sets are on separate
controllers. In this case all the devices in one set <br>
can be failed by giving a name like set-A or set-B to
--fail. The appropriate set names are reported by
--detail.</p>

<p style="margin-top: 1em">--set-faulty <br>
same as --fail.</p>

<p style="margin-top: 1em">--replace <br>
Mark listed devices as requiring replacement. As soon as a
spare is available, it will be rebuilt and will replace the
marked device. This is similar to marking a device <br>
as faulty, but the device remains in service during the
recovery process to increase resilience against multiple
failures. When the replacement process finishes, the <br>
replaced device will be marked as faulty.</p>

<p style="margin-top: 1em">--with This can follow a list of
--replace devices. The devices listed after --with will be
preferentially used to replace the devices listed after
--replace. These device must <br>
already be spare devices in the array.</p>

<p style="margin-top: 1em">--write-mostly <br>
Subsequent devices that are added or re-added will have the
&rsquo;write-mostly&rsquo; flag set. This is only valid for
RAID1 and means that the &rsquo;md&rsquo; driver will avoid
reading from <br>
these devices if possible.</p>

<p style="margin-top: 1em">--readwrite <br>
Subsequent devices that are added or re-added will have the
&rsquo;write-mostly&rsquo; flag cleared.</p>

<p style="margin-top: 1em">--cluster-confirm <br>
Confirm the existence of the device. This is issued in
response to an --add request by a node in a cluster. When a
node adds a device it sends a message to all nodes in <br>
the cluster to look for a device with a UUID. This
translates to a udev notification with the UUID of the
device to be added and the slot number. The receiving node
must <br>
acknowledge this message with --cluster-confirm. Valid
arguments are &lt;slot&gt;:&lt;devicename&gt; in case the
device is found or &lt;slot&gt;:missing in case the device
is not found.</p>

<p style="margin-top: 1em">Each of these options requires
that the first device listed is the array to be acted upon,
and the remainder are component devices to be added,
removed, marked as faulty, etc. <br>
Several different operations can be specified for different
devices, e.g. <br>
mdadm /dev/md0 --add /dev/sda1 --fail /dev/sdb1 --remove
/dev/sdb1 <br>
Each operation applies to all devices listed until the next
operation.</p>

<p style="margin-top: 1em">If an array is using a
write-intent bitmap, then devices which have been removed
can be re-added in a way that avoids a full reconstruction
but instead just updates the blocks <br>
that have changed since the device was removed. For arrays
with persistent metadata (superblocks) this is done
automatically. For arrays created with --build mdadm needs
to be <br>
told that this device we removed recently with --re-add.</p>

<p style="margin-top: 1em">Devices can only be removed from
an array if they are not in active use, i.e. that must be
spares or failed devices. To remove an active device, it
must first be marked as <br>
faulty.</p>

<p style="margin-top: 1em">For Misc mode: <br>
-Q, --query <br>
Examine a device to see (1) if it is an md device and (2) if
it is a component of an md array. Information about what is
discovered is presented.</p>

<p style="margin-top: 1em">-D, --detail <br>
Print details of one or more md devices.</p>

<p style="margin-top: 1em">--detail-platform <br>
Print details of the platform&rsquo;s RAID capabilities
(firmware / hardware topology) for a given metadata format.
If used without argument, mdadm will scan all controllers
<br>
looking for their capabilities. Otherwise, mdadm will only
look at the controller specified by the argument in form of
an absolute filepath or a link, e.g. <br>
/sys/devices/pci0000:00/0000:00:1f.2.</p>

<p style="margin-top: 1em">-Y, --export <br>
When used with --detail, --detail-platform, --examine, or
--incremental output will be formatted as key=value pairs
for easy import into the environment.</p>

<p style="margin-top: 1em">With --incremental The value
MD_STARTED indicates whether an array was started (yes) or
not, which may include a reason (unsafe, nothing, no). Also
the value MD_FOREIGN <br>
indicates if the array is expected on this host (no), or
seems to be from elsewhere (yes).</p>

<p style="margin-top: 1em">-E, --examine <br>
Print contents of the metadata stored on the named
device(s). Note the contrast between --examine and --detail.
--examine applies to devices which are components of an <br>
array, while --detail applies to a whole array which is
currently active.</p>

<p style="margin-top: 1em">--sparc2.2 <br>
If an array was created on a SPARC machine with a 2.2 Linux
kernel patched with RAID support, the superblock will have
been created incorrectly, or at least incompatibly <br>
with 2.4 and later kernels. Using the --sparc2.2 flag with
--examine will fix the superblock before displaying it. If
this appears to do the right thing, then the array <br>
can be successfully assembled using --assemble
--update=sparc2.2.</p>

<p style="margin-top: 1em">-X, --examine-bitmap <br>
Report information about a bitmap file. The argument is
either an external bitmap file or an array component in case
of an internal bitmap. Note that running this on an <br>
array device (e.g. /dev/md0) does not report the bitmap for
that array.</p>

<p style="margin-top: 1em">--examine-badblocks <br>
List the bad-blocks recorded for the device, if a bad-blocks
list has been configured. Currently only 1.x metadata
supports bad-blocks lists.</p>

<p style="margin-top: 1em">--dump=directory</p>

<p style="margin-top: 1em">--restore=directory <br>
Save metadata from lists devices, or restore metadata to
listed devices.</p>

<p style="margin-top: 1em">-R, --run <br>
start a partially assembled array. If --assemble did not
find enough devices to fully start the array, it might
leaving it partially assembled. If you wish, you can then
<br>
use --run to start the array in degraded mode.</p>

<p style="margin-top: 1em">-S, --stop <br>
deactivate array, releasing all resources.</p>

<p style="margin-top: 1em">-o, --readonly <br>
mark array as readonly.</p>

<p style="margin-top: 1em">-w, --readwrite <br>
mark array as readwrite.</p>

<p style="margin-top: 1em">--zero-superblock <br>
If the device contains a valid md superblock, the block is
overwritten with zeros. With --force the block where the
superblock would be is overwritten even if it doesn&rsquo;t
<br>
appear to be valid.</p>

<p style="margin-top: 1em">--kill-subarray= <br>
If the device is a container and the argument to
--kill-subarray specifies an inactive subarray in the
container, then the subarray is deleted. Deleting all
subarrays <br>
will leave an &rsquo;empty-container&rsquo; or spare
superblock on the drives. See --zero-superblock for
completely removing a superblock. Note that some formats
depend on the sub&acirc; <br>
array index for generating a UUID, this command will fail if
it would change the UUID of an active subarray.</p>

<p style="margin-top: 1em">--update-subarray= <br>
If the device is a container and the argument to
--update-subarray specifies a subarray in the container,
then attempt to update the given superblock field in the
subar&acirc; <br>
ray. See below in MISC MODE for details.</p>

<p style="margin-top: 1em">-t, --test <br>
When used with --detail, the exit status of mdadm is set to
reflect the status of the device. See below in MISC MODE for
details.</p>

<p style="margin-top: 1em">-W, --wait <br>
For each md device given, wait for any resync, recovery, or
reshape activity to finish before returning. mdadm will
return with success if it actually waited for every <br>
device listed, otherwise it will return failure.</p>

<p style="margin-top: 1em">--wait-clean <br>
For each md device given, or each device in /proc/mdstat if
--scan is given, arrange for the array to be marked clean as
soon as possible. mdadm will return with success <br>
if the array uses external metadata and we successfully
waited. For native arrays this returns immediately as the
kernel handles dirty-clean transitions at shutdown. No <br>
action is taken if safe-mode handling is disabled.</p>

<p style="margin-top: 1em">--action= <br>
Set the &quot;sync_action&quot; for all md devices given to
one of idle, frozen, check, repair. Setting to idle will
abort any currently running action though some actions will
<br>
automatically restart. Setting to frozen will abort any
current action and ensure no other action starts
automatically.</p>

<p style="margin-top: 1em">Details of check and repair can
be found it md(4) under SCRUBBING AND MISMATCHES.</p>

<p style="margin-top: 1em">For Incremental Assembly mode:
<br>
--rebuild-map, -r <br>
Rebuild the map file (/run/mdadm/map) that mdadm uses to
help track which arrays are currently being assembled.</p>

<p style="margin-top: 1em">--run, -R <br>
Run any array assembled as soon as a minimal number of
devices are available, rather than waiting until all
expected devices are present.</p>

<p style="margin-top: 1em">--scan, -s <br>
Only meaningful with -R this will scan the map file for
arrays that are being incrementally assembled and will try
to start any that are not already started. If any such <br>
array is listed in mdadm.conf as requiring an external
bitmap, that bitmap will be attached first.</p>

<p style="margin-top: 1em">--fail, -f <br>
This allows the hot-plug system to remove devices that have
fully disappeared from the kernel. It will first fail and
then remove the device from any array it belongs to. <br>
The device name given should be a kernel device name such as
&quot;sda&quot;, not a name in /dev.</p>

<p style="margin-top: 1em">--path= <br>
Only used with --fail. The &rsquo;path&rsquo; given will be
recorded so that if a new device appears at the same
location it can be automatically added to the same array.
This <br>
allows the failed device to be automatically replaced by a
new device without metadata if it appears at specified path.
This option is normally only set by a udev <br>
script.</p>

<p style="margin-top: 1em">For Monitor mode: <br>
-m, --mail <br>
Give a mail address to send alerts to.</p>

<p style="margin-top: 1em">-p, --program, --alert <br>
Give a program to be run whenever an event is detected.</p>

<p style="margin-top: 1em">-y, --syslog <br>
Cause all events to be reported through
&rsquo;syslog&rsquo;. The messages have facility of
&rsquo;daemon&rsquo; and varying priorities.</p>

<p style="margin-top: 1em">-d, --delay <br>
Give a delay in seconds. mdadm polls the md arrays and then
waits this many seconds before polling again. The default is
60 seconds. Since 2.6.16, there is no need to <br>
reduce this as the kernel alerts mdadm immediately when
there is any change.</p>

<p style="margin-top: 1em">-r, --increment <br>
Give a percentage increment. mdadm will generate RebuildNN
events with the given percentage increment.</p>

<p style="margin-top: 1em">-f, --daemonise <br>
Tell mdadm to run as a background daemon if it decides to
monitor anything. This causes it to fork and run in the
child, and to disconnect from the terminal. The process <br>
id of the child is written to stdout. This is useful with
--scan which will only continue monitoring if a mail address
or alert program is found in the config file.</p>

<p style="margin-top: 1em">-i, --pid-file <br>
When mdadm is running in daemon mode, write the pid of the
daemon process to the specified file, instead of printing it
on standard output.</p>

<p style="margin-top: 1em">-1, --oneshot <br>
Check arrays only once. This will generate NewArray events
and more significantly DegradedArray and SparesMissing
events. Running <br>
mdadm --monitor --scan -1 <br>
from a cron script will ensure regular notification of any
degraded arrays.</p>

<p style="margin-top: 1em">-t, --test <br>
Generate a TestMessage alert for every array found at
startup. This alert gets mailed and passed to the alert
program. This can be used for testing that alert message do
<br>
get through successfully.</p>

<p style="margin-top: 1em">--no-sharing <br>
This inhibits the functionality for moving spares between
arrays. Only one monitoring process started with --scan but
without this flag is allowed, otherwise the two <br>
could interfere with each other.</p>

<p style="margin-top: 1em">ASSEMBLE MODE <br>
Usage: mdadm --assemble md-device
options-and-component-devices...</p>

<p style="margin-top: 1em">Usage: mdadm --assemble --scan
md-devices-and-options...</p>

<p style="margin-top: 1em">Usage: mdadm --assemble --scan
options...</p>

<p style="margin-top: 1em">This usage assembles one or more
RAID arrays from pre-existing components. For each array,
mdadm needs to know the md device, the identity of the
array, and a number of compo&acirc; <br>
nent-devices. These can be found in a number of ways.</p>

<p style="margin-top: 1em">In the first usage example
(without the --scan) the first device given is the md
device. In the second usage example, all devices listed are
treated as md devices and assembly <br>
is attempted. In the third (where no devices are listed) all
md devices that are listed in the configuration file are
assembled. If no arrays are described by the configuration
<br>
file, then any arrays that can be found on unused devices
will be assembled.</p>

<p style="margin-top: 1em">If precisely one device is
listed, but --scan is not given, then mdadm acts as though
--scan was given and identity information is extracted from
the configuration file.</p>

<p style="margin-top: 1em">The identity can be given with
the --uuid option, the --name option, or the --super-minor
option, will be taken from the md-device record in the
config file, or will be taken <br>
from the super block of the first component-device listed on
the command line.</p>

<p style="margin-top: 1em">Devices can be given on the
--assemble command line or in the config file. Only devices
which have an md superblock which contains the right
identity will be considered for any <br>
array.</p>

<p style="margin-top: 1em">The config file is only used if
explicitly named with --config or requested with (a possibly
implicit) --scan. In the later case, /etc/mdadm.conf or
/etc/mdadm/mdadm.conf is <br>
used.</p>

<p style="margin-top: 1em">If --scan is not given, then the
config file will only be used to find the identity of md
arrays.</p>

<p style="margin-top: 1em">Normally the array will be
started after it is assembled. However if --scan is not
given and not all expected drives were listed, then the
array is not started (to guard against <br>
usage errors). To insist that the array be started in this
case (as may work for RAID1, 4, 5, 6, or 10), give the --run
flag.</p>

<p style="margin-top: 1em">If udev is active, mdadm does
not create any entries in /dev but leaves that to udev. It
does record information in /run/mdadm/map which will allow
udev to choose the correct <br>
name.</p>

<p style="margin-top: 1em">If mdadm detects that udev is
not configured, it will create the devices in /dev
itself.</p>

<p style="margin-top: 1em">In Linux kernels prior to
version 2.6.28 there were two distinctly different types of
md devices that could be created: one that could be
partitioned using standard partitioning <br>
tools and one that could not. Since 2.6.28 that distinction
is no longer relevant as both type of devices can be
partitioned. mdadm will normally create the type that
origi&acirc; <br>
nally could not be partitioned as it has a well defined
major number (9).</p>

<p style="margin-top: 1em">Prior to 2.6.28, it is important
that mdadm chooses the correct type of array device to use.
This can be controlled with the --auto option. In
particular, a value of &quot;mdp&quot; or <br>
&quot;part&quot; or &quot;p&quot; tells mdadm to use a
partitionable device rather than the default.</p>

<p style="margin-top: 1em">In the no-udev case, the value
given to --auto can be suffixed by a number. This tells
mdadm to create that number of partition devices rather than
the default of 4.</p>

<p style="margin-top: 1em">The value given to --auto can
also be given in the configuration file as a word starting
auto= on the ARRAY line for the relevant array.</p>

<p style="margin-top: 1em">Auto Assembly <br>
When --assemble is used with --scan and no devices are
listed, mdadm will first attempt to assemble all the arrays
listed in the config file.</p>

<p style="margin-top: 1em">If no arrays are listed in the
config (other than those marked &lt;ignore&gt;) it will look
through the available devices for possible arrays and will
try to assemble anything that it <br>
finds. Arrays which are tagged as belonging to the given
homehost will be assembled and started normally. Arrays
which do not obviously belong to this host are given names
that <br>
are expected not to conflict with anything local, and are
started &quot;read-auto&quot; so that nothing is written to
any device until the array is written to. i.e. automatic
resync etc <br>
is delayed.</p>

<p style="margin-top: 1em">If mdadm finds a consistent set
of devices that look like they should comprise an array, and
if the superblock is tagged as belonging to the given home
host, it will automati&acirc; <br>
cally choose a device name and try to assemble the array. If
the array uses version-0.90 metadata, then the minor number
as recorded in the superblock is used to create a name <br>
in /dev/md/ so for example /dev/md/3. If the array uses
version-1 metadata, then the name from the superblock is
used to similarly create a name in /dev/md/ (the name will
have <br>
any &rsquo;host&rsquo; prefix stripped first).</p>

<p style="margin-top: 1em">This behaviour can be modified
by the AUTO line in the mdadm.conf configuration file. This
line can indicate that specific metadata type should, or
should not, be automatically <br>
assembled. If an array is found which is not listed in
mdadm.conf and has a metadata format that is denied by the
AUTO line, then it will not be assembled. The AUTO line can
<br>
also request that all arrays identified as being for this
homehost should be assembled regardless of their metadata
type. See mdadm.conf(5) for further details.</p>

<p style="margin-top: 1em">Note: Auto assembly cannot be
used for assembling and activating some arrays which are
undergoing reshape. In particular as the backup-file cannot
be given, any reshape which <br>
requires a backup-file to continue cannot be started by auto
assembly. An array which is growing to more devices and has
passed the critical section can be assembled using auto-
<br>
assembly.</p>

<p style="margin-top: 1em">BUILD MODE <br>
Usage: mdadm --build md-device --chunk=X --level=Y
--raid-devices=Z devices</p>

<p style="margin-top: 1em">This usage is similar to
--create. The difference is that it creates an array without
a superblock. With these arrays there is no difference
between initially creating the <br>
array and subsequently assembling the array, except that
hopefully there is useful data there in the second case.</p>

<p style="margin-top: 1em">The level may raid0, linear,
raid1, raid10, multipath, or faulty, or one of their
synonyms. All devices must be listed and the array will be
started once complete. It will <br>
often be appropriate to use --assume-clean with levels raid1
or raid10.</p>

<p style="margin-top: 1em">CREATE MODE <br>
Usage: mdadm --create md-device --chunk=X --level=Y <br>
--raid-devices=Z devices</p>

<p style="margin-top: 1em">This usage will initialise a new
md array, associate some devices with it, and activate the
array.</p>

<p style="margin-top: 1em">The named device will normally
not exist when mdadm --create is run, but will be created by
udev once the array becomes active.</p>

<p style="margin-top: 1em">As devices are added, they are
checked to see if they contain RAID superblocks or
filesystems. They are also checked to see if the variance in
device size exceeds 1%.</p>

<p style="margin-top: 1em">If any discrepancy is found, the
array will not automatically be run, though the presence of
a --run can override this caution.</p>

<p style="margin-top: 1em">To create a &quot;degraded&quot;
array in which some devices are missing, simply give the
word &quot;missing&quot; in place of a device name. This
will cause mdadm to leave the corresponding slot <br>
in the array empty. For a RAID4 or RAID5 array at most one
slot can be &quot;missing&quot;; for a RAID6 array at most
two slots. For a RAID1 array, only one real device needs to
be <br>
given. All of the others can be &quot;missing&quot;.</p>

<p style="margin-top: 1em">When creating a RAID5 array,
mdadm will automatically create a degraded array with an
extra spare drive. This is because building the spare into a
degraded array is in general <br>
faster than resyncing the parity on a non-degraded, but not
clean, array. This feature can be overridden with the
--force option.</p>

<p style="margin-top: 1em">When creating an array with
version-1 metadata a name for the array is required. If this
is not given with the --name option, mdadm will choose a
name based on the last compo&acirc; <br>
nent of the name of the device being created. So if /dev/md3
is being created, then the name 3 will be chosen. If
/dev/md/home is being created, then the name home will be
<br>
used.</p>

<p style="margin-top: 1em">When creating a partition based
array, using mdadm with version-1.x metadata, the partition
type should be set to 0xDA (non fs-data). This type
selection allows for greater pre&acirc; <br>
cision since using any other [RAID auto-detect (0xFD) or a
GNU/Linux partition (0x83)], might create problems in the
event of array recovery through a live cdrom.</p>

<p style="margin-top: 1em">A new array will normally get a
randomly assigned 128bit UUID which is very likely to be
unique. If you have a specific need, you can choose a UUID
for the array by giving the <br>
--uuid= option. Be warned that creating two arrays with the
same UUID is a recipe for disaster. Also, using --uuid= when
creating a v0.90 array will silently override any <br>
--homehost= setting.</p>

<p style="margin-top: 1em">If the array type supports a
write-intent bitmap, and if the devices in the array exceed
100G is size, an internal write-intent bitmap will
automatically be added unless some <br>
other option is explicitly requested with the --bitmap
option. In any case space for a bitmap will be reserved so
that one can be added layer with --grow
--bitmap=internal.</p>

<p style="margin-top: 1em">If the metadata type supports it
(currently only 1.x metadata), space will be allocated to
store a bad block list. This allows a modest number of bad
blocks to be recorded, <br>
allowing the drive to remain in service while only partially
functional.</p>

<p style="margin-top: 1em">When creating an array within a
CONTAINER mdadm can be given either the list of devices to
use, or simply the name of the container. The former case
gives control over which <br>
devices in the container will be used for the array. The
latter case allows mdadm to automatically choose which
devices to use based on how much spare space is
available.</p>

<p style="margin-top: 1em">The General Management options
that are valid with --create are:</p>

<p style="margin-top: 1em">--run insist on running the
array even if some devices look like they might be in
use.</p>

<p style="margin-top: 1em">--readonly <br>
start the array readonly &acirc; not supported yet.</p>

<p style="margin-top: 1em">MANAGE MODE <br>
Usage: mdadm device options... devices...</p>

<p style="margin-top: 1em">This usage will allow individual
devices in an array to be failed, removed or added. It is
possible to perform multiple operations with on command. For
example: <br>
mdadm /dev/md0 -f /dev/hda1 -r /dev/hda1 -a /dev/hda1 <br>
will firstly mark /dev/hda1 as faulty in /dev/md0 and will
then remove it from the array and finally add it back in as
a spare. However only one md array can be affected by a <br>
single command.</p>

<p style="margin-top: 1em">When a device is added to an
active array, mdadm checks to see if it has metadata on it
which suggests that it was recently a member of the array.
If it does, it tries to <br>
&quot;re-add&quot; the device. If there have been no changes
since the device was removed, or if the array has a
write-intent bitmap which has recorded whatever changes
there were, then <br>
the device will immediately become a full member of the
array and those differences recorded in the bitmap will be
resolved.</p>

<p style="margin-top: 1em">MISC MODE <br>
Usage: mdadm options ... devices ...</p>

<p style="margin-top: 1em">MISC mode includes a number of
distinct operations that operate on distinct devices. The
operations are:</p>

<p style="margin-top: 1em">--query <br>
The device is examined to see if it is (1) an active md
array, or (2) a component of an md array. The information
discovered is reported.</p>

<p style="margin-top: 1em">--detail <br>
The device should be an active md device. mdadm will display
a detailed description of the array. --brief or --scan will
cause the output to be less detailed and the <br>
format to be suitable for inclusion in mdadm.conf. The exit
status of mdadm will normally be 0 unless mdadm failed to
get useful information about the device(s); however, <br>
if the --test option is given, then the exit status will
be:</p>

<p style="margin-top: 1em">0 The array is functioning
normally.</p>

<p style="margin-top: 1em">1 The array has at least one
failed device.</p>

<p style="margin-top: 1em">2 The array has multiple failed
devices such that it is unusable.</p>

<p style="margin-top: 1em">4 There was an error while
trying to get information about the device.</p>

<p style="margin-top: 1em">--detail-platform <br>
Print detail of the platform&rsquo;s RAID capabilities
(firmware / hardware topology). If the metadata is specified
with -e or --metadata= then the return status will be:</p>

<p style="margin-top: 1em">0 metadata successfully
enumerated its platform components on this system</p>

<p style="margin-top: 1em">1 metadata is platform
independent</p>

<p style="margin-top: 1em">2 metadata failed to find its
platform components on this system</p>

<p style="margin-top: 1em">--update-subarray= <br>
If the device is a container and the argument to
--update-subarray specifies a subarray in the container,
then attempt to update the given superblock field in the
subar&acirc; <br>
ray. Similar to updating an array in &quot;assemble&quot;
mode, the field to update is selected by -U or --update=
option. Currently only name is supported.</p>

<p style="margin-top: 1em">The name option updates the
subarray name in the metadata, it may not affect the device
node name or the device node symlink until the subarray is
re-assembled. If updat&acirc; <br>
ing name would change the UUID of an active subarray this
operation is blocked, and the command will end in an
error.</p>

<p style="margin-top: 1em">--examine <br>
The device should be a component of an md array. mdadm will
read the md superblock of the device and display the
contents. If --brief or --scan is given, then multiple <br>
devices that are components of the one array are grouped
together and reported in a single entry suitable for
inclusion in mdadm.conf.</p>

<p style="margin-top: 1em">Having --scan without listing
any devices will cause all devices listed in the config file
to be examined.</p>

<p style="margin-top: 1em">--dump=directory <br>
If the device contains RAID metadata, a file will be created
in the directory and the metadata will be written to it. The
file will be the same size as the device and <br>
have the metadata written in the file at the same locate
that it exists in the device. However the file will be
&quot;sparse&quot; so that only those blocks containing
metadata <br>
will be allocated. The total space used will be small.</p>

<p style="margin-top: 1em">The file name used in the
directory will be the base name of the device. Further if
any links appear in /dev/disk/by-id which point to the
device, then hard links to the <br>
file will be created in directory based on these by-id
names.</p>

<p style="margin-top: 1em">Multiple devices can be listed
and their metadata will all be stored in the one
directory.</p>

<p style="margin-top: 1em">--restore=directory <br>
This is the reverse of --dump. mdadm will locate a file in
the directory that has a name appropriate for the given
device and will restore metadata from it. Names that <br>
match /dev/disk/by-id names are preferred, however if two of
those refer to different files, mdadm will not choose
between them but will abort the operation.</p>

<p style="margin-top: 1em">If a file name is given instead
of a directory then mdadm will restore from that file to a
single device, always provided the size of the file matches
that of the device, <br>
and the file contains valid metadata.</p>

<p style="margin-top: 1em">--stop The devices should be
active md arrays which will be deactivated, as long as they
are not currently in use.</p>

<p style="margin-top: 1em">--run This will fully activate a
partially assembled md array.</p>

<p style="margin-top: 1em">--readonly <br>
This will mark an active array as read-only, providing that
it is not currently being used.</p>

<p style="margin-top: 1em">--readwrite <br>
This will change a readonly array back to being
read/write.</p>

<p style="margin-top: 1em">--scan For all operations except
--examine, --scan will cause the operation to be applied to
all arrays listed in /proc/mdstat. For --examine, --scan
causes all devices listed <br>
in the config file to be examined.</p>

<p style="margin-top: 1em">-b, --brief <br>
Be less verbose. This is used with --detail and --examine.
Using --brief with --verbose gives an intermediate level of
verbosity.</p>

<p style="margin-top: 1em">MONITOR MODE <br>
Usage: mdadm --monitor options... devices...</p>

<p style="margin-top: 1em">This usage causes mdadm to
periodically poll a number of md arrays and to report on any
events noticed. mdadm will never exit once it decides that
there are arrays to be <br>
checked, so it should normally be run in the background.</p>

<p style="margin-top: 1em">As well as reporting events,
mdadm may move a spare drive from one array to another if
they are in the same spare-group or domain and if the
destination array has a failed drive <br>
but no spares.</p>

<p style="margin-top: 1em">If any devices are listed on the
command line, mdadm will only monitor those devices.
Otherwise all arrays listed in the configuration file will
be monitored. Further, if <br>
--scan is given, then any other md devices that appear in
/proc/mdstat will also be monitored.</p>

<p style="margin-top: 1em">The result of monitoring the
arrays is the generation of events. These events are passed
to a separate program (if specified) and may be mailed to a
given E-mail address.</p>

<p style="margin-top: 1em">When passing events to a
program, the program is run once for each event, and is
given 2 or 3 command-line arguments: the first is the name
of the event (see below), the second <br>
is the name of the md device which is affected, and the
third is the name of a related device if relevant (such as a
component device that has failed).</p>

<p style="margin-top: 1em">If --scan is given, then a
program or an E-mail address must be specified on the
command line or in the config file. If neither are
available, then mdadm will not monitor any&acirc; <br>
thing. Without --scan, mdadm will continue monitoring as
long as something was found to monitor. If no program or
email is given, then each event is reported to stdout.</p>

<p style="margin-top: 1em">The different events are:</p>

<p style="margin-top: 1em">DeviceDisappeared <br>
An md array which previously was configured appears to no
longer be configured. (syslog priority: Critical)</p>

<p style="margin-top: 1em">If mdadm was told to monitor an
array which is RAID0 or Linear, then it will report
DeviceDisappeared with the extra information Wrong-Level.
This is because RAID0 <br>
and Linear do not support the device-failed, hot-spare and
resync operations which are monitored.</p>

<p style="margin-top: 1em">RebuildStarted <br>
An md array started reconstruction (e.g. recovery, resync,
reshape, check, repair). (syslog priority: Warning)</p>

<p style="margin-top: 1em">RebuildNN <br>
Where NN is a two-digit number (ie. 05, 48). This indicates
that rebuild has passed that many percent of the total. The
events are generated with fixed increment since <br>
0. Increment size may be specified with a commandline option
(default is 20). (syslog priority: Warning)</p>

<p style="margin-top: 1em">RebuildFinished <br>
An md array that was rebuilding, isn&rsquo;t any more,
either because it finished normally or was aborted. (syslog
priority: Warning)</p>

<p style="margin-top: 1em">Fail An active component device
of an array has been marked as faulty. (syslog priority:
Critical)</p>

<p style="margin-top: 1em">FailSpare <br>
A spare component device which was being rebuilt to replace
a faulty device has failed. (syslog priority: Critical)</p>

<p style="margin-top: 1em">SpareActive <br>
A spare component device which was being rebuilt to replace
a faulty device has been successfully rebuilt and has been
made active. (syslog priority: Info)</p>

<p style="margin-top: 1em">NewArray <br>
A new md array has been detected in the /proc/mdstat file.
(syslog priority: Info)</p>

<p style="margin-top: 1em">DegradedArray <br>
A newly noticed array appears to be degraded. This message
is not generated when mdadm notices a drive failure which
causes degradation, but only when mdadm notices <br>
that an array is degraded when it first sees the array.
(syslog priority: Critical)</p>

<p style="margin-top: 1em">MoveSpare <br>
A spare drive has been moved from one array in a spare-group
or domain to another to allow a failed drive to be replaced.
(syslog priority: Info)</p>

<p style="margin-top: 1em">SparesMissing <br>
If mdadm has been told, via the config file, that an array
should have a certain number of spare devices, and mdadm
detects that it has fewer than this number when it <br>
first sees the array, it will report a SparesMissing
message. (syslog priority: Warning)</p>

<p style="margin-top: 1em">TestMessage <br>
An array was found at startup, and the --test flag was
given. (syslog priority: Info)</p>

<p style="margin-top: 1em">Only Fail, FailSpare,
DegradedArray, SparesMissing and TestMessage cause Email to
be sent. All events cause the program to be run. The program
is run with two or three argu&acirc; <br>
ments: the event name, the array device and possibly a
second device.</p>

<p style="margin-top: 1em">Each event has an associated
array device (e.g. /dev/md1) and possibly a second device.
For Fail, FailSpare, and SpareActive the second device is
the relevant component device. <br>
For MoveSpare the second device is the array that the spare
was moved from.</p>

<p style="margin-top: 1em">For mdadm to move spares from
one array to another, the different arrays need to be
labeled with the same spare-group or the spares must be
allowed to migrate through matching <br>
POLICY domains in the configuration file. The spare-group
name can be any string; it is only necessary that different
spare groups use different names.</p>

<p style="margin-top: 1em">When mdadm detects that an array
in a spare group has fewer active devices than necessary for
the complete array, and has no spare devices, it will look
for another array in the <br>
same spare group that has a full complement of working drive
and a spare. It will then attempt to remove the spare from
the second drive and add it to the first. If the removal
<br>
succeeds but the adding fails, then it is added back to the
original array.</p>

<p style="margin-top: 1em">If the spare group for a
degraded array is not defined, mdadm will look at the rules
of spare migration specified by POLICY lines in mdadm.conf
and then follow similar steps as <br>
above if a matching spare is found.</p>

<p style="margin-top: 1em">GROW MODE <br>
The GROW mode is used for changing the size or shape of an
active array. For this to work, the kernel must support the
necessary change. Various types of growth are being added
<br>
during 2.6 development.</p>

<p style="margin-top: 1em">Currently the supported changes
include</p>

<p style="margin-top: 1em">&Acirc;&middot; change the
&quot;size&quot; attribute for RAID1, RAID4, RAID5 and
RAID6.</p>

<p style="margin-top: 1em">&Acirc;&middot; increase or
decrease the &quot;raid-devices&quot; attribute of RAID0,
RAID1, RAID4, RAID5, and RAID6.</p>

<p style="margin-top: 1em">&Acirc;&middot; change the
chunk-size and layout of RAID0, RAID4, RAID5, RAID6 and
RAID10.</p>

<p style="margin-top: 1em">&Acirc;&middot; convert between
RAID1 and RAID5, between RAID5 and RAID6, between RAID0,
RAID4, and RAID5, and between RAID0 and RAID10 (in the
near-2 mode).</p>

<p style="margin-top: 1em">&Acirc;&middot; add a
write-intent bitmap to any array which supports these
bitmaps, or remove a write-intent bitmap from such an
array.</p>

<p style="margin-top: 1em">Using GROW on containers is
currently supported only for Intel&rsquo;s IMSM container
format. The number of devices in a container can be
increased - which affects all arrays in the <br>
container - or an array in a container can be converted
between levels where those levels are supported by the
container, and the conversion is on of those listed above.
Resiz&acirc; <br>
ing arrays in an IMSM container with --grow --size is not
yet supported.</p>

<p style="margin-top: 1em">Grow functionality (e.g. expand
a number of raid devices) for Intel&rsquo;s IMSM container
format has an experimental status. It is guarded by the
MDADM_EXPERIMENTAL environment vari&acirc; <br>
able which must be set to &rsquo;1&rsquo; for a GROW command
to succeed. This is for the following reasons:</p>

<p style="margin-top: 1em">1. Intel&rsquo;s native IMSM
check-pointing is not fully tested yet. This can causes IMSM
incompatibility during the grow process: an array which is
growing cannot roam between <br>
Microsoft Windows(R) and Linux systems.</p>

<p style="margin-top: 1em">2. Interrupting a grow operation
is not recommended, because it has not been fully tested for
Intel&rsquo;s IMSM container format yet.</p>

<p style="margin-top: 1em">Note: Intel&rsquo;s native
checkpointing doesn&rsquo;t use --backup-file option and it
is transparent for assembly feature.</p>

<p style="margin-top: 1em">SIZE CHANGES <br>
Normally when an array is built the &quot;size&quot; is
taken from the smallest of the drives. If all the small
drives in an arrays are, one at a time, removed and replaced
with larger <br>
drives, then you could have an array of large drives with
only a small amount used. In this situation, changing the
&quot;size&quot; with &quot;GROW&quot; mode will allow the
extra space to start <br>
being used. If the size is increased in this way, a
&quot;resync&quot; process will start to make sure the new
parts of the array are synchronised.</p>

<p style="margin-top: 1em">Note that when an array changes
size, any filesystem that may be stored in the array will
not automatically grow or shrink to use or vacate the space.
The filesystem will need <br>
to be explicitly told to use the extra space after growing,
or to reduce its size prior to shrinking the array.</p>

<p style="margin-top: 1em">Also the size of an array cannot
be changed while it has an active bitmap. If an array has a
bitmap, it must be removed before the size can be changed.
Once the change is com&acirc; <br>
plete a new bitmap can be created.</p>

<p style="margin-top: 1em">RAID-DEVICES CHANGES <br>
A RAID1 array can work with any number of devices from 1
upwards (though 1 is not very useful). There may be times
which you want to increase or decrease the number of active
<br>
devices. Note that this is different to hot-add or
hot-remove which changes the number of inactive devices.</p>

<p style="margin-top: 1em">When reducing the number of
devices in a RAID1 array, the slots which are to be removed
from the array must already be vacant. That is, the devices
which were in those slots <br>
must be failed and removed.</p>

<p style="margin-top: 1em">When the number of devices is
increased, any hot spares that are present will be activated
immediately.</p>

<p style="margin-top: 1em">Changing the number of active
devices in a RAID5 or RAID6 is much more effort. Every block
in the array will need to be read and written back to a new
location. From 2.6.17, <br>
the Linux Kernel is able to increase the number of devices
in a RAID5 safely, including restarting an interrupted
&quot;reshape&quot;. From 2.6.31, the Linux Kernel is able
to increase or <br>
decrease the number of devices in a RAID5 or RAID6.</p>

<p style="margin-top: 1em">From 2.6.35, the Linux Kernel is
able to convert a RAID0 in to a RAID4 or RAID5. mdadm uses
this functionality and the ability to add devices to a RAID4
to allow devices to be <br>
added to a RAID0. When requested to do this, mdadm will
convert the RAID0 to a RAID4, add the necessary disks and
make the reshape happen, and then convert the RAID4 back to
<br>
RAID0.</p>

<p style="margin-top: 1em">When decreasing the number of
devices, the size of the array will also decrease. If there
was data in the array, it could get destroyed and this is
not reversible, so you should <br>
firstly shrink the filesystem on the array to fit within the
new size. To help prevent accidents, mdadm requires that the
size of the array be decreased first with mdadm --grow <br>
--array-size. This is a reversible change which simply makes
the end of the array inaccessible. The integrity of any data
can then be checked before the non-reversible reduc&acirc;
<br>
tion in the number of devices is request.</p>

<p style="margin-top: 1em">When relocating the first few
stripes on a RAID5 or RAID6, it is not possible to keep the
data on disk completely consistent and crash-proof. To
provide the required safety, <br>
mdadm disables writes to the array while this &quot;critical
section&quot; is reshaped, and takes a backup of the data
that is in that section. For grows, this backup may be
stored in any <br>
spare devices that the array has, however it can also be
stored in a separate file specified with the --backup-file
option, and is required to be specified for shrinks, RAID
<br>
level changes and layout changes. If this option is used,
and the system does crash during the critical period, the
same file must be passed to --assemble to restore the backup
<br>
and reassemble the array. When shrinking rather than growing
the array, the reshape is done from the end towards the
beginning, so the &quot;critical section&quot; is at the end
of the <br>
reshape.</p>

<p style="margin-top: 1em">LEVEL CHANGES <br>
Changing the RAID level of any array happens
instantaneously. However in the RAID5 to RAID6 case this
requires a non-standard layout of the RAID6 data, and in the
RAID6 to RAID5 <br>
case that non-standard layout is required before the change
can be accomplished. So while the level change is instant,
the accompanying layout change can take quite a long time.
<br>
A --backup-file is required. If the array is not
simultaneously being grown or shrunk, so that the array size
will remain the same - for example, reshaping a 3-drive
RAID5 into <br>
a 4-drive RAID6 - the backup file will be used not just for
a &quot;cricital section&quot; but throughout the reshape
operation, as described below under LAYOUT CHANGES.</p>

<p style="margin-top: 1em">CHUNK-SIZE AND LAYOUT CHANGES
<br>
Changing the chunk-size of layout without also changing the
number of devices as the same time will involve re-writing
all blocks in-place. To ensure against data loss in the <br>
case of a crash, a --backup-file must be provided for these
changes. Small sections of the array will be copied to the
backup file while they are being rearranged. This means <br>
that all the data is copied twice, once to the backup and
once to the new layout on the array, so this type of reshape
will go very slowly.</p>

<p style="margin-top: 1em">If the reshape is interrupted
for any reason, this backup file must be made available to
mdadm --assemble so the array can be reassembled.
Consequently the file cannot be stored <br>
on the device being reshaped.</p>

<p style="margin-top: 1em">BITMAP CHANGES <br>
A write-intent bitmap can be added to, or removed from, an
active array. Either internal bitmaps, or bitmaps stored in
a separate file, can be added. Note that if you add a <br>
bitmap stored in a file which is in a filesystem that is on
the RAID array being affected, the system will deadlock. The
bitmap must be on a separate filesystem.</p>

<p style="margin-top: 1em">INCREMENTAL MODE <br>
Usage: mdadm --incremental [--run] [--quiet]
component-device [optional-aliases-for-device]</p>

<p style="margin-top: 1em">Usage: mdadm --incremental
--fail component-device</p>

<p style="margin-top: 1em">Usage: mdadm --incremental
--rebuild-map</p>

<p style="margin-top: 1em">Usage: mdadm --incremental --run
--scan</p>

<p style="margin-top: 1em">This mode is designed to be used
in conjunction with a device discovery system. As devices
are found in a system, they can be passed to mdadm
--incremental to be conditionally <br>
added to an appropriate array.</p>

<p style="margin-top: 1em">Conversely, it can also be used
with the --fail flag to do just the opposite and find
whatever array a particular device is part of and remove the
device from that array.</p>

<p style="margin-top: 1em">If the device passed is a
CONTAINER device created by a previous call to mdadm, then
rather than trying to add that device to an array, all the
arrays described by the metadata <br>
of the container will be started.</p>

<p style="margin-top: 1em">mdadm performs a number of tests
to determine if the device is part of an array, and which
array it should be part of. If an appropriate array is
found, or can be created, mdadm <br>
adds the device to the array and conditionally starts the
array.</p>

<p style="margin-top: 1em">Note that mdadm will normally
only add devices to an array which were previously working
(active or spare) parts of that array. The support for
automatic inclusion of a new <br>
drive as a spare in some array requires a configuration
through POLICY in config file.</p>

<p style="margin-top: 1em">The tests that mdadm makes are
as follow:</p>

<p style="margin-top: 1em">+ Is the device permitted by
mdadm.conf? That is, is it listed in a DEVICES line in that
file. If DEVICES is absent then the default it to allow any
device. Similarly if <br>
DEVICES contains the special word partitions then any device
is allowed. Otherwise the device name given to mdadm, or one
of the aliases given, or an alias found in the <br>
filesystem, must match one of the names or patterns in a
DEVICES line.</p>

<p style="margin-top: 1em">This is the only context where
the aliases are used. They are usually provided by a udev
rules mentioning ${DEVLINKS}.</p>

<p style="margin-top: 1em">+ Does the device have a valid
md superblock? If a specific metadata version is requested
with --metadata or -e then only that style of metadata is
accepted, otherwise <br>
mdadm finds any known version of metadata. If no md metadata
is found, the device may be still added to an array as a
spare if POLICY allows.</p>

<p style="margin-top: 1em">mdadm keeps a list of arrays
that it has partially assembled in /run/mdadm/map. If no
array exists which matches the metadata on the new device,
mdadm must choose a device name <br>
and unit number. It does this based on any name given in
mdadm.conf or any name information stored in the metadata.
If this name suggests a unit number, that number will be
<br>
used, otherwise a free unit number will be chosen. Normally
mdadm will prefer to create a partitionable array, however
if the CREATE line in mdadm.conf suggests that a
non-par&acirc; <br>
titionable array is preferred, that will be honoured.</p>

<p style="margin-top: 1em">If the array is not found in the
config file and its metadata does not identify it as
belonging to the &quot;homehost&quot;, then mdadm will
choose a name for the array which is certain <br>
not to conflict with any array which does belong to this
host. It does this be adding an underscore and a small
number to the name preferred by the metadata.</p>

<p style="margin-top: 1em">Once an appropriate array is
found or created and the device is added, mdadm must decide
if the array is ready to be started. It will normally
compare the number of available <br>
(non-spare) devices to the number of devices that the
metadata suggests need to be active. If there are at least
that many, the array will be started. This means that if any
<br>
devices are missing the array will not be restarted.</p>

<p style="margin-top: 1em">As an alternative, --run may be
passed to mdadm in which case the array will be run as soon
as there are enough devices present for the data to be
accessible. For a RAID1, that <br>
means one device will start the array. For a clean RAID5,
the array will be started as soon as all but one drive is
present.</p>

<p style="margin-top: 1em">Note that neither of these
approaches is really ideal. If it can be known that all
device discovery has completed, then <br>
mdadm -IRs <br>
can be run which will try to start all arrays that are being
incrementally assembled. They are started in
&quot;read-auto&quot; mode in which they are read-only until
the first write <br>
request. This means that no metadata updates are made and no
attempt at resync or recovery happens. Further devices that
are found before the first write can still be added <br>
safely.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
This section describes environment variables that affect how
mdadm operates.</p>

<p style="margin-top: 1em">MDADM_NO_MDMON <br>
Setting this value to 1 will prevent mdadm from
automatically launching mdmon. This variable is intended
primarily for debugging mdadm/mdmon.</p>

<p style="margin-top: 1em">MDADM_NO_UDEV <br>
Normally, mdadm does not create any device nodes in /dev,
but leaves that task to udev. If udev appears not to be
configured, or if this environment variable is set to <br>
&rsquo;1&rsquo;, the mdadm will create and devices that are
needed.</p>

<p style="margin-top: 1em">MDADM_NO_SYSTEMCTL <br>
If mdadm detects that systemd is in use it will normally
request systemd to start various background tasks
(particularly mdmon) rather than forking and running them in
the <br>
background. This can be suppressed by setting
MDADM_NO_SYSTEMCTL=1.</p>

<p style="margin-top: 1em">IMSM_NO_PLATFORM <br>
A key value of IMSM metadata is that it allows
interoperability with boot ROMs on Intel platforms, and with
other major operating systems. Consequently, mdadm will only
<br>
allow an IMSM array to be created or modified if detects
that it is running on an Intel platform which supports IMSM,
and supports the particular configuration of IMSM <br>
that is being requested (some functionality requires newer
OROM support).</p>

<p style="margin-top: 1em">These checks can be suppressed
by setting IMSM_NO_PLATFORM=1 in the environment. This can
be useful for testing or for disaster recovery. You should
be aware that inter&acirc; <br>
operability may be compromised by setting this value.</p>

<p style="margin-top: 1em">MDADM_GROW_ALLOW_OLD <br>
If an array is stopped while it is performing a reshape and
that reshape was making use of a backup file, then when the
array is re-assembled mdadm will sometimes complain <br>
that the backup file is too old. If this happens and you are
certain it is the right backup file, you can over-ride this
check by setting MDADM_GROW_ALLOW_OLD=1 in the <br>
environment.</p>

<p style="margin-top: 1em">MDADM_CONF_AUTO <br>
Any string given in this variable is added to the start of
the AUTO line in the config file, or treated as the whole
AUTO line if none is given. It can be used to disable <br>
certain metadata types when mdadm is called from a boot
script. For example <br>
export MDADM_CONF_AUTO=&rsquo;-ddf -imsm&rsquo; <br>
will make sure that mdadm does not automatically assemble
any DDF or IMSM arrays that are found. This can be useful on
systems configured to manage such arrays with <br>
dmraid.</p>

<p style="margin-top: 1em">EXAMPLES <br>
mdadm --query /dev/name-of-device <br>
This will find out if a given device is a RAID array, or is
part of one, and will provide brief information about the
device.</p>

<p style="margin-top: 1em">mdadm --assemble --scan <br>
This will assemble and start all arrays listed in the
standard config file. This command will typically go in a
system startup file.</p>

<p style="margin-top: 1em">mdadm --stop --scan <br>
This will shut down all arrays that can be shut down (i.e.
are not currently in use). This will typically go in a
system shutdown script.</p>

<p style="margin-top: 1em">mdadm --follow --scan
--delay=120 <br>
If (and only if) there is an Email address or program given
in the standard config file, then monitor the status of all
arrays listed in that file by polling them ever 2
minutes.</p>

<p style="margin-top: 1em">mdadm --create /dev/md0
--level=1 --raid-devices=2 /dev/hd[ac]1 <br>
Create /dev/md0 as a RAID1 array consisting of /dev/hda1 and
/dev/hdc1.</p>

<p style="margin-top: 1em">echo &rsquo;DEVICE /dev/hd*[0-9]
/dev/sd*[0-9]&rsquo; &gt; mdadm.conf <br>
mdadm --detail --scan &gt;&gt; mdadm.conf <br>
This will create a prototype config file that describes
currently active arrays that are known to be made from
partitions of IDE or SCSI drives. This file should be
reviewed <br>
before being used as it may contain unwanted detail.</p>

<p style="margin-top: 1em">echo &rsquo;DEVICE /dev/hd[a-z]
/dev/sd*[a-z]&rsquo; &gt; mdadm.conf <br>
mdadm --examine --scan --config=mdadm.conf &gt;&gt;
mdadm.conf <br>
This will find arrays which could be assembled from existing
IDE and SCSI whole drives (not partitions), and store the
information in the format of a config file. This file is
<br>
very likely to contain unwanted detail, particularly the
devices= entries. It should be reviewed and edited before
being used as an actual config file.</p>

<p style="margin-top: 1em">mdadm --examine --brief --scan
--config=partitions <br>
mdadm -Ebsc partitions <br>
Create a list of devices by reading /proc/partitions, scan
these for RAID superblocks, and printout a brief listing of
all that were found.</p>

<p style="margin-top: 1em">mdadm -Ac partitions -m 0
/dev/md0 <br>
Scan all partitions and devices listed in /proc/partitions
and assemble /dev/md0 out of all such devices with a RAID
superblock with a minor number of 0.</p>

<p style="margin-top: 1em">mdadm --monitor --scan
--daemonise &gt; /run/mdadm/mon.pid <br>
If config file contains a mail address or alert program, run
mdadm in the background in monitor mode monitoring all md
devices. Also write pid of mdadm daemon to <br>
/run/mdadm/mon.pid.</p>

<p style="margin-top: 1em">mdadm -Iq /dev/somedevice <br>
Try to incorporate newly discovered device into some array
as appropriate.</p>

<p style="margin-top: 1em">mdadm --incremental
--rebuild-map --run --scan <br>
Rebuild the array map from any current arrays, and then
start any that can be started.</p>

<p style="margin-top: 1em">mdadm /dev/md4 --fail detached
--remove detached <br>
Any devices which are components of /dev/md4 will be marked
as faulty and then remove from the array.</p>

<p style="margin-top: 1em">mdadm --grow /dev/md4 --level=6
--backup-file=/root/backup-md4 <br>
The array /dev/md4 which is currently a RAID5 array will be
converted to RAID6. There should normally already be a spare
drive attached to the array as a RAID6 needs one more <br>
drive than a matching RAID5.</p>

<p style="margin-top: 1em">mdadm --create /dev/md/ddf
--metadata=ddf --raid-disks 6 /dev/sd[a-f] <br>
Create a DDF array over 6 devices.</p>

<p style="margin-top: 1em">mdadm --create /dev/md/home -n3
-l5 -z 30000000 /dev/md/ddf <br>
Create a RAID5 array over any 3 devices in the given DDF
set. Use only 30 gigabytes of each device.</p>

<p style="margin-top: 1em">mdadm -A /dev/md/ddf1
/dev/sd[a-f] <br>
Assemble a pre-exist ddf array.</p>

<p style="margin-top: 1em">mdadm -I /dev/md/ddf1 <br>
Assemble all arrays contained in the ddf array, assigning
names as appropriate.</p>

<p style="margin-top: 1em">mdadm --create --help <br>
Provide help about the Create mode.</p>

<p style="margin-top: 1em">mdadm --config --help <br>
Provide help about the format of the config file.</p>

<p style="margin-top: 1em">mdadm --help <br>
Provide general help.</p>

<p style="margin-top: 1em">FILES <br>
/proc/mdstat <br>
If you&rsquo;re using the /proc filesystem, /proc/mdstat
lists all active md devices with information about them.
mdadm uses this to find arrays when --scan is given in Misc
mode, and <br>
to monitor array reconstruction on Monitor mode.</p>

<p style="margin-top: 1em">/etc/mdadm.conf <br>
The config file lists which devices may be scanned to see if
they contain MD super block, and gives identifying
information (e.g. UUID) about known MD arrays. See
mdadm.conf(5) <br>
for more details.</p>

<p style="margin-top: 1em">/etc/mdadm.conf.d <br>
A directory containing configuration files which are read in
lexical order.</p>

<p style="margin-top: 1em">/run/mdadm/map <br>
When --incremental mode is used, this file gets a list of
arrays currently being created.</p>

<p style="margin-top: 1em">DEVICE NAMES <br>
mdadm understand two sorts of names for array devices.</p>

<p style="margin-top: 1em">The first is the so-called
&rsquo;standard&rsquo; format name, which matches the names
used by the kernel and which appear in /proc/mdstat.</p>

<p style="margin-top: 1em">The second sort can be freely
chosen, but must reside in /dev/md/. When giving a device
name to mdadm to create or assemble an array, either full
path name such as /dev/md0 or <br>
/dev/md/home can be given, or just the suffix of the second
sort of name, such as home can be given.</p>

<p style="margin-top: 1em">When mdadm chooses device names
during auto-assembly or incremental assembly, it will
sometimes add a small sequence number to the end of the name
to avoid conflicted between <br>
multiple arrays that have the same name. If mdadm can
reasonably determine that the array really is meant for this
host, either by a hostname in the metadata, or by the
presence <br>
of the array in mdadm.conf, then it will leave off the
suffix if possible. Also if the homehost is specified as
&lt;ignore&gt; mdadm will only use a suffix if a different
array of the <br>
same name already exists or is listed in the config
file.</p>

<p style="margin-top: 1em">The standard names for
non-partitioned arrays (the only sort of md array available
in 2.4 and earlier) are of the form</p>

<p style="margin-top: 1em">/dev/mdNN</p>

<p style="margin-top: 1em">where NN is a number. The
standard names for partitionable arrays (as available from
2.6 onwards) are of the form:</p>

<p style="margin-top: 1em">/dev/md_dNN</p>

<p style="margin-top: 1em">Partition numbers should be
indicated by adding &quot;pMM&quot; to these, thus
&quot;/dev/md/d1p2&quot;.</p>

<p style="margin-top: 1em">From kernel version 2.6.28 the
&quot;non-partitioned array&quot; can actually be
partitioned. So the &quot;md_dNN&quot; names are no longer
needed, and partitions such as &quot;/dev/mdNNpXX&quot; are
possi&acirc; <br>
ble.</p>

<p style="margin-top: 1em">From kernel version 2.6.29
standard names can be non-numeric following the form:</p>

<p style="margin-top: 1em">/dev/md_XXX</p>

<p style="margin-top: 1em">where XXX is any string. These
names are supported by mdadm since version 3.3 provided they
are enabled in mdadm.conf.</p>

<p style="margin-top: 1em">NOTE <br>
mdadm was previously known as mdctl.</p>

<p style="margin-top: 1em">SEE ALSO <br>
For further information on mdadm usage, MD and the various
levels of RAID, see:</p>


<p style="margin-top: 1em">http://raid.wiki.kernel.org/</p>

<p style="margin-top: 1em">(based upon Jakob
&Atilde;stergaard&rsquo;s Software-RAID.HOWTO)</p>

<p style="margin-top: 1em">The latest version of mdadm
should always be available from</p>


<p style="margin-top: 1em">http://www.kernel.org/pub/linux/utils/raid/mdadm/</p>

<p style="margin-top: 1em">Related man pages:</p>

<p style="margin-top: 1em">mdmon(8), mdadm.conf(5),
md(4).</p>

<p style="margin-top: 1em">v3.4 MDADM(8)</p>
<hr>
</body>
</html>
