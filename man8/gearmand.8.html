<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:11:26 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GEARMAND(8) Gearmand GEARMAND(8)</p>

<p style="margin-top: 1em">NAME <br>
gearmand - Gearmand Documentation, http://gearman.info/</p>

<p style="margin-top: 1em">SYNOPSIS <br>
General options</p>

<p style="margin-top: 1em">-b [ --backlog ] arg (=32) <br>
Number of backlog connections for listen.</p>

<p style="margin-top: 1em">--check-args <br>
Check command line and configuration file arguments and then
exit.</p>

<p style="margin-top: 1em">-d [ --daemon ] <br>
Daemon, detach and run in the background.</p>

<p style="margin-top: 1em">-f [ --file-descriptors ] arg
<br>
Number of file descriptors to allow for the process (total
connections will be slightly less). Default is max allowed
for user.</p>

<p style="margin-top: 1em">-h [ --help ] <br>
Print this help menu.</p>

<p style="margin-top: 1em">-j [ --job-retries ] arg (=0)
<br>
Number of attempts to run the job before the job server
removes it. This is helpful to ensure a bad job does not
crash all available workers. Default is no limit.</p>

<p style="margin-top: 1em">-l [ --log-file ] arg <br>
Log file to write errors and information to. Turning this
option on also forces the first verbose level to be
enabled.</p>

<p style="margin-top: 1em">-L [ --listen ] arg <br>
Address the server should listen on. Default is
INADDR_ANY.</p>

<p style="margin-top: 1em">-p [ --port ] arg (=4730) <br>
Port the server should listen on.</p>

<p style="margin-top: 1em">-P [ --pid-file ] arg <br>
File to write process ID out to.</p>

<p style="margin-top: 1em">-r [ --protocol ] arg <br>
Load protocol module.</p>

<p style="margin-top: 1em">-R [ --round-robin ] <br>
Assign work in round-robin order per worker connection. The
default is to assign work in the order of functions added by
the worker.</p>

<p style="margin-top: 1em">-q [ --queue-type ] arg <br>
Persistent queue type to use.</p>

<p style="margin-top: 1em">-t [ --threads ] arg (=4) <br>
Number of I/O threads to use. Default=4.</p>

<p style="margin-top: 1em">-u [ --user ] arg <br>
Switch to given user after startup.</p>

<p style="margin-top: 1em">-v [ --verbose ] arg (=v) <br>
Increase verbosity level by one.</p>

<p style="margin-top: 1em">-V [ --version ] <br>
Display the version of gearmand and exit.</p>

<p style="margin-top: 1em">-w [ --worker-wakeup ] arg (=0)
<br>
Number of workers to wakeup for each job received. The
default is to wakeup all available workers.</p>

<p style="margin-top: 1em">HTTP:</p>

<p style="margin-top: 1em">--http-port arg (=8080) <br>
Port to listen on.</p>

<p style="margin-top: 1em">sqlite</p>

<p style="margin-top: 1em">--libsqlite3-db arg <br>
Database file to use.</p>

<p style="margin-top: 1em">--libsqlite3-table arg
(=gearman_queue) <br>
Table to use.</p>

<p style="margin-top: 1em">Memcached(libmemcached)</p>

<p style="margin-top: 1em">--libmemcached-servers arg <br>
List of Memcached servers to use.</p>

<p style="margin-top: 1em">Drizzle/MySQL(libdrizzle)</p>

<p style="margin-top: 1em">-host arg <br>
Host of server.</p>

<p style="margin-top: 1em">-port arg <br>
Port of server. (by default Drizzle)</p>

<p style="margin-top: 1em">-uds arg <br>
Unix domain socket for server.</p>

<p style="margin-top: 1em">-user arg <br>
User name for authentication.</p>

<p style="margin-top: 1em">-password arg <br>
Password for authentication.</p>

<p style="margin-top: 1em">-db arg <br>
Schema/Database to use.</p>

<p style="margin-top: 1em">-table arg <br>
Table to use.</p>

<p style="margin-top: 1em">-mysql arg <br>
Use MySQL protocol.</p>

<p style="margin-top: 1em">Postgres</p>

<p style="margin-top: 1em">--libpq-conninfo arg <br>
PostgreSQL connection information string.</p>

<p style="margin-top: 1em">--libpq-table arg (=queue) <br>
Table to use.</p>

<p style="margin-top: 1em">tokyocabinet</p>

<p style="margin-top: 1em">--libtokyocabinet-file arg <br>
File name of the database. [see: man tcadb, tcadbopen() for
name guidelines]</p>

<p style="margin-top: 1em">--libtokyocabinet-optimize <br>
Optimize database on open. [default=true]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Gearman provides a generic application framework to farm out
work to other machines or processes that are better suited
to do the work. It allows you to do work in parallel, to
<br>
load balance processing, and to call functions between
languages. It can be used in a variety of applications, from
high-availability web sites to the transport of database
<br>
replication events. In other words, it is the nervous system
for how distributed processing communicates. A few strong
points about Gearman:</p>

<p style="margin-top: 1em">&Acirc;&middot; Open Source -
It&rsquo;s free! (in both meanings of the word) Gearman has
an active open source community that is easy to get involved
with if you need help or want to contribute.</p>

<p style="margin-top: 1em">&Acirc;&middot; Multi-language -
There are interfaces for a number of languages, and this
list is growing. You also have the option to write
heterogeneous applications with clients submitting <br>
work in one language and workers performing that work in
another.</p>

<p style="margin-top: 1em">&Acirc;&middot; Flexible - You
are not tied to any specific design pattern. You can quickly
put together distributed applications using any model you
choose, one of those options being <br>
Map/Reduce.</p>

<p style="margin-top: 1em">&Acirc;&middot; Fast - Gearman
has a simple protocol and interface with a new optimized
server in C to minimize your application overhead.</p>

<p style="margin-top: 1em">&Acirc;&middot; Embeddable -
Since Gearman is fast and lightweight, it is great for
applications of all sizes. It is also easy to introduce into
existing applications with minimal overhead.</p>

<p style="margin-top: 1em">&Acirc;&middot; No single point
of failure - Gearman can not only help scale systems, but
can do it in a fault tolerant way.</p>

<p style="margin-top: 1em">Thread Model <br>
The -t option to gearmand allows you to specify multiple I/O
threads, this is enabled by default. There are currently
three types of threads in the job server:</p>

<p style="margin-top: 1em">Listening and management thread
- only one I/O thread - can have many Processing thread -
only one</p>

<p style="margin-top: 1em">When no -t option is given or -t
0 is given, all of three thread types happen within a single
thread. When -t 1 is given, there is a thread for
listening/management and a thread <br>
for I/O and processing. When -t 2 is given, there is a
thread for each type of thread above. For all -t option
values above 2, more I/O threads are created.</p>

<p style="margin-top: 1em">The listening and management
thread is mainly responsible for accepting new connections
and assigning those connections to an I/O thread (if there
are many). It also coordinates <br>
startup and shutdown within the server. This thread will
have an instance of libevent for managing socket events and
signals on an internal pipe. This pipe is used to wakeup the
<br>
thread or to coordinate shutdown.</p>

<p style="margin-top: 1em">The I/O thread is responsible
for doing the read and write system calls on the sockets and
initial packet parsing. Once the packet has been parsed it
it put into an asynchronous <br>
queue for the processing thread (each thread has it&rsquo;s
own queue so there is very little contention). Each I/O
thread has it&rsquo;s own instance of libevent for managing
socket events <br>
and signals on an internal pipe like the listening
thread.</p>

<p style="margin-top: 1em">The processing thread should
have no system calls within it (except for the occasional
brk() for more memory), and manages the various lists and
hash tables used for tracking <br>
unique keys, job handles, functions, and job queues. All
packets that need to be sent back to connections are put
into an asynchronous queue for the I/O thread. The I/O
thread <br>
will pick these up and send them back over the connected
socket. All packets flow through the processing thread since
it contains the information needed to process the packets.
<br>
This is due to the complex nature of the various lists and
hash tables. If multiple threads were modifying them the
locking overhead would most likely cause worse performance
<br>
than having it in a single thread (and would also complicate
the code). In the future more work may be pushed to the I/O
threads, and the processing thread can retain minimal <br>
functionality to manage those tables and lists. So far this
has not been a significant bottleneck, a 16 core Intel
machine is able to process upwards of 50k jobs per
second.</p>

<p style="margin-top: 1em">For thread safety to work when
UUID are generated, you must be running the uuidd
daemon.</p>

<p style="margin-top: 1em">Persistent Queues <br>
Inside the Gearman job server, all job queues are stored in
memory. This means if a server restarts or crashes with
pending jobs, they will be lost and are never run by a
worker. <br>
Persistent queues were added to allow background jobs to be
stored in an external durable queue so they may live between
server restarts and crashes. The persistent queue is only
<br>
enabled for background jobs because foreground jobs have an
attached client. If a job server goes away, the client can
detect this and restart the foreground job somewhere else
<br>
(or report an error back to the original caller). Background
jobs on the other hand have no attached client and are
simply expected to be run when submitted.</p>

<p style="margin-top: 1em">The persistent queue works by
calling a module callback function right before putting a
new job in the internal queue for pending jobs to be run.
This allows the module to store <br>
the job about to be run in some persistent way so that it
can later be replayed during a restart. Once it is stored
through the module, the job is put onto the active runnable
<br>
queue, waking up available workers if needed. Once the job
has been successfully completed by a worker, another module
callback function is called to notify the module the job is
<br>
done and can be removed. If a job server crashes or is
restarted between these two calls for a job, the jobs are
reloaded during the next job server start. When the job
server <br>
starts up, it will call a replay callback function in the
module to provide a list of all jobs that were not complete.
This is used to populate the internal memory queue of jobs
<br>
to be run. Once this replay is complete, the job server
finishes its initialization and the jobs are now runnable
once workers connect (the queue should be in the same state
as <br>
when it crashed). These jobs are removed from the persistent
queue when completed as normal. NOTE: Deleting jobs from the
persistent queue storage will not remove them from the <br>
in-memory queue while the server is running.</p>

<p style="margin-top: 1em">The queues are implemented using
a modular interface so it is easy to add new data stores for
the persistent queue.</p>

<p style="margin-top: 1em">A persistent queue module is
enabled by passing the -q or &acirc;queue-type option to
gearmand. Run gearmand &acirc;help to see which queue
modules are supported on your system. If you are <br>
missing options for one you would like to use, you will need
to install any dependencies and then recompile the gearmand
package.</p>

<p style="margin-top: 1em">Extended Protocols <br>
The protocol plugin interface allows you to take over the
packet send and receive functions, allowing you to pack the
buffers as required by the protocol. The core read and write
<br>
functions can (and should) be used by the protocol
plugin.</p>

<p style="margin-top: 1em">HTTP <br>
This protocol plugin allows you to map HTTP requests to
Gearman jobs. It only provides client job submission
currently, but it may be extended to support other request
types in <br>
the future. The plugin can handle both GET and POST data,
the latter being used to send a workload to the job server.
The URL being requested is translated into the function <br>
being called.</p>

<p style="margin-top: 1em">For example, the request:</p>

<p style="margin-top: 1em">POST /reverse HTTP/1.1 <br>
Content-Length: 12</p>

<p style="margin-top: 1em">Hello world!</p>

<p style="margin-top: 1em">Is translated into a job
submission request for the function &acirc;reverse&acirc;
and workload &acirc;Hello world!&acirc;. This will respond
with:</p>

<p style="margin-top: 1em">HTTP/1.0 200 OK <br>
X-Gearman-Job-Handle: H:lap:4 <br>
Content-Length: 12 <br>
Server: Gearman/0.8</p>

<p style="margin-top: 1em">!dlrow olleH</p>

<p style="margin-top: 1em">The following headers can be
passed to change the behavior of the job:</p>

<p style="margin-top: 1em">* X-Gearman-Unique: &lt;unique
key&gt; <br>
* X-Gearman-Background: true <br>
* X-Gearman-Priority: &lt;high|low&gt;</p>

<p style="margin-top: 1em">For example, to run a low
priority background job, the following request can be
sent:</p>

<p style="margin-top: 1em">POST /reverse HTTP/1.1 <br>
Content-Length: 12 <br>
X-Gearman-Background: true <br>
X-Gearman-Priority: low</p>

<p style="margin-top: 1em">Hello world!</p>

<p style="margin-top: 1em">The response for this request
will not have any data associated with it since it was a
background job:</p>

<p style="margin-top: 1em">HTTP/1.0 200 OK <br>
X-Gearman-Job-Handle: H:lap:6 <br>
Content-Length: 0 <br>
Server: Gearman/0.8</p>

<p style="margin-top: 1em">The HTTP protocol should be
considered experimental.</p>

<p style="margin-top: 1em">HOME <br>
To find out more information please check:
http://gearman.info/</p>

<p style="margin-top: 1em">SEE ALSO <br>
gearman(1) gearadmin(1) libgearmand(3)</p>

<p style="margin-top: 1em">AUTHOR <br>
Data Differential http://www.datadifferential.com/</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2011-2013, Data Differential,
http://www.datadifferential.com/</p>

<p style="margin-top: 1em">1.0.6 May 09, 2013
GEARMAND(8)</p>
<hr>
</body>
</html>
