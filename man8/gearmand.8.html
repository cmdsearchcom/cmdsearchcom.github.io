<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GEARMAND(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GEARMAND(8)</td>
    <td class="head-vol">Gearmand</td>
    <td class="head-rtitle">GEARMAND(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
gearmand - Gearmand Documentation, http://gearman.info/
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>General options</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b [ --backlog ] arg (=32)</b></dt>
  <dd class="It-tag">Number of backlog connections for listen.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--check-args</b></dt>
  <dd class="It-tag">Check command line and configuration file arguments and
      then exit.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d [ --daemon ]</b></dt>
  <dd class="It-tag">Daemon, detach and run in the background.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f [ --file-descriptors ] arg</b></dt>
  <dd class="It-tag">Number of file descriptors to allow for the process (total
      connections will be slightly less). Default is max allowed for user.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h [ --help ]</b></dt>
  <dd class="It-tag">Print this help menu.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j [ --job-retries ] arg (=0)</b></dt>
  <dd class="It-tag">Number of attempts to run the job before the job server
      removes it. This is helpful to ensure a bad job does not crash all
      available workers. Default is no limit.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l [ --log-file ] arg</b></dt>
  <dd class="It-tag">Log file to write errors and information to. Turning this
      option on also forces the first verbose level to be enabled.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L [ --listen ] arg</b></dt>
  <dd class="It-tag">Address the server should listen on. Default is
    INADDR_ANY.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p [ --port ] arg (=4730)</b></dt>
  <dd class="It-tag">Port the server should listen on.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P [ --pid-file ] arg</b></dt>
  <dd class="It-tag">File to write process ID out to.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r [ --protocol ] arg</b></dt>
  <dd class="It-tag">Load protocol module.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R [ --round-robin ]</b></dt>
  <dd class="It-tag">Assign work in round-robin order per worker connection. The
      default is to assign work in the order of functions added by the
    worker.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q [ --queue-type ] arg</b></dt>
  <dd class="It-tag">Persistent queue type to use.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t [ --threads ] arg (=4)</b></dt>
  <dd class="It-tag">Number of I/O threads to use. Default=4.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u [ --user ] arg</b></dt>
  <dd class="It-tag">Switch to given user after startup.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v [ --verbose ] arg (=v)</b></dt>
  <dd class="It-tag">Increase verbosity level by one.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V [ --version ]</b></dt>
  <dd class="It-tag">Display the version of gearmand and exit.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w [ --worker-wakeup ] arg (=0)</b></dt>
  <dd class="It-tag">Number of workers to wakeup for each job received. The
      default is to wakeup all available workers.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>HTTP:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--http-port arg (=8080)</b></dt>
  <dd class="It-tag">Port to listen on.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>sqlite</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--libsqlite3-db arg</b></dt>
  <dd class="It-tag">Database file to use.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--libsqlite3-table arg (=gearman_queue)</b></dt>
  <dd class="It-tag">Table to use.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Memcached(libmemcached)</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--libmemcached-servers arg</b></dt>
  <dd class="It-tag">List of Memcached servers to use.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Drizzle/MySQL(libdrizzle)</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-host arg</b></dt>
  <dd class="It-tag">Host of server.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-port arg</b></dt>
  <dd class="It-tag">Port of server. (by default Drizzle)</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-uds arg</b></dt>
  <dd class="It-tag">Unix domain socket for server.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-user arg</b></dt>
  <dd class="It-tag">User name for authentication.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-password arg</b></dt>
  <dd class="It-tag">Password for authentication.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-db arg</b></dt>
  <dd class="It-tag">Schema/Database to use.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-table arg</b></dt>
  <dd class="It-tag">Table to use.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-mysql arg</b></dt>
  <dd class="It-tag">Use MySQL protocol.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Postgres</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--libpq-conninfo arg</b></dt>
  <dd class="It-tag">PostgreSQL connection information string.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--libpq-table arg (=queue)</b></dt>
  <dd class="It-tag">Table to use.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>tokyocabinet</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--libtokyocabinet-file arg</b></dt>
  <dd class="It-tag">File name of the database. [see: man tcadb, tcadbopen() for
      name guidelines]</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>--libtokyocabinet-optimize</b></dt>
  <dd class="It-tag">Optimize database on open. [default=true]</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Gearman provides a generic application framework to farm out work to other
  machines or processes that are better suited to do the work. It allows you to
  do work in parallel, to load balance processing, and to call functions between
  languages. It can be used in a variety of applications, from high-availability
  web sites to the transport of database replication events. In other words, it
  is the nervous system for how distributed processing communicates. A few
  strong points about Gearman:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Open Source - It's free! (in both meanings of the word)
      Gearman has an active open source community that is easy to get involved
      with if you need help or want to contribute.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Multi-language - There are interfaces for a number of
      languages, and this list is growing. You also have the option to write
      heterogeneous applications with clients submitting work in one language
      and workers performing that work in another.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Flexible - You are not tied to any specific design pattern.
      You can quickly put together distributed applications using any model you
      choose, one of those options being Map/Reduce.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Fast - Gearman has a simple protocol and interface with a
      new optimized server in C to minimize your application overhead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Embeddable - Since Gearman is fast and lightweight, it is
      great for applications of all sizes. It is also easy to introduce into
      existing applications with minimal overhead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">No single point of failure - Gearman can not only help
      scale systems, but can do it in a fault tolerant way.</dd>
</dl>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Thread_Model"><a class="selflink" href="#Thread_Model">Thread
  Model</a></h2>
The -t option to gearmand allows you to specify multiple I/O threads, this is
  enabled by default. There are currently three types of threads in the job
  server:
<div style="height: 1.00em;">&#x00A0;</div>
Listening and management thread - only one I/O thread - can have many Processing
  thread - only one
<div style="height: 1.00em;">&#x00A0;</div>
When no -t option is given or -t 0 is given, all of three thread types happen
  within a single thread. When -t 1 is given, there is a thread for
  listening/management and a thread for I/O and processing. When -t 2 is given,
  there is a thread for each type of thread above. For all -t option values
  above 2, more I/O threads are created.
<div style="height: 1.00em;">&#x00A0;</div>
The listening and management thread is mainly responsible for accepting new
  connections and assigning those connections to an I/O thread (if there are
  many). It also coordinates startup and shutdown within the server. This thread
  will have an instance of libevent for managing socket events and signals on an
  internal pipe. This pipe is used to wakeup the thread or to coordinate
  shutdown.
<div style="height: 1.00em;">&#x00A0;</div>
The I/O thread is responsible for doing the read and write system calls on the
  sockets and initial packet parsing. Once the packet has been parsed it it put
  into an asynchronous queue for the processing thread (each thread has it's own
  queue so there is very little contention). Each I/O thread has it's own
  instance of libevent for managing socket events and signals on an internal
  pipe like the listening thread.
<div style="height: 1.00em;">&#x00A0;</div>
The processing thread should have no system calls within it (except for the
  occasional brk() for more memory), and manages the various lists and hash
  tables used for tracking unique keys, job handles, functions, and job queues.
  All packets that need to be sent back to connections are put into an
  asynchronous queue for the I/O thread. The I/O thread will pick these up and
  send them back over the connected socket. All packets flow through the
  processing thread since it contains the information needed to process the
  packets. This is due to the complex nature of the various lists and hash
  tables. If multiple threads were modifying them the locking overhead would
  most likely cause worse performance than having it in a single thread (and
  would also complicate the code). In the future more work may be pushed to the
  I/O threads, and the processing thread can retain minimal functionality to
  manage those tables and lists. So far this has not been a significant
  bottleneck, a 16 core Intel machine is able to process upwards of 50k jobs per
  second.
<div style="height: 1.00em;">&#x00A0;</div>
For thread safety to work when UUID are generated, you must be running the uuidd
  daemon.
<h2 class="Ss" title="Ss" id="Persistent_Queues"><a class="selflink" href="#Persistent_Queues">Persistent
  Queues</a></h2>
Inside the Gearman job server, all job queues are stored in memory. This means
  if a server restarts or crashes with pending jobs, they will be lost and are
  never run by a worker. Persistent queues were added to allow background jobs
  to be stored in an external durable queue so they may live between server
  restarts and crashes. The persistent queue is only enabled for background jobs
  because foreground jobs have an attached client. If a job server goes away,
  the client can detect this and restart the foreground job somewhere else (or
  report an error back to the original caller). Background jobs on the other
  hand have no attached client and are simply expected to be run when submitted.
<div style="height: 1.00em;">&#x00A0;</div>
The persistent queue works by calling a module callback function right before
  putting a new job in the internal queue for pending jobs to be run. This
  allows the module to store the job about to be run in some persistent way so
  that it can later be replayed during a restart. Once it is stored through the
  module, the job is put onto the active runnable queue, waking up available
  workers if needed. Once the job has been successfully completed by a worker,
  another module callback function is called to notify the module the job is
  done and can be removed. If a job server crashes or is restarted between these
  two calls for a job, the jobs are reloaded during the next job server start.
  When the job server starts up, it will call a replay callback function in the
  module to provide a list of all jobs that were not complete. This is used to
  populate the internal memory queue of jobs to be run. Once this replay is
  complete, the job server finishes its initialization and the jobs are now
  runnable once workers connect (the queue should be in the same state as when
  it crashed). These jobs are removed from the persistent queue when completed
  as normal. NOTE: Deleting jobs from the persistent queue storage will not
  remove them from the in-memory queue while the server is running.
<div style="height: 1.00em;">&#x00A0;</div>
The queues are implemented using a modular interface so it is easy to add new
  data stores for the persistent queue.
<div style="height: 1.00em;">&#x00A0;</div>
A persistent queue module is enabled by passing the -q or &#x2013;queue-type
  option to gearmand. Run gearmand &#x2013;help to see which queue modules are
  supported on your system. If you are missing options for one you would like to
  use, you will need to install any dependencies and then recompile the gearmand
  package.
<h2 class="Ss" title="Ss" id="Extended_Protocols"><a class="selflink" href="#Extended_Protocols">Extended
  Protocols</a></h2>
The protocol plugin interface allows you to take over the packet send and
  receive functions, allowing you to pack the buffers as required by the
  protocol. The core read and write functions can (and should) be used by the
  protocol plugin.
<h2 class="Ss" title="Ss" id="HTTP"><a class="selflink" href="#HTTP">HTTP</a></h2>
This protocol plugin allows you to map HTTP requests to Gearman jobs. It only
  provides client job submission currently, but it may be extended to support
  other request types in the future. The plugin can handle both GET and POST
  data, the latter being used to send a workload to the job server. The URL
  being requested is translated into the function being called.
<div style="height: 1.00em;">&#x00A0;</div>
For example, the request:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
POST /reverse HTTP/1.1
Content-Length: 12
<div class="Pp"></div>
Hello world!
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Is translated into a job submission request for the function
  &#x201C;reverse&#x201D; and workload &#x201C;Hello world!&#x201D;. This will
  respond with:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
HTTP/1.0 200 OK
X-Gearman-Job-Handle: H:lap:4
Content-Length: 12
Server: Gearman/0.8
<div class="Pp"></div>
!dlrow olleH
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The following headers can be passed to change the behavior of the job:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
* X-Gearman-Unique: &lt;unique key&gt;
* X-Gearman-Background: true
* X-Gearman-Priority: &lt;high|low&gt;
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
For example, to run a low priority background job, the following request can be
  sent:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
POST /reverse HTTP/1.1
Content-Length: 12
X-Gearman-Background: true
X-Gearman-Priority: low
<div class="Pp"></div>
Hello world!
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The response for this request will not have any data associated with it since it
  was a background job:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
HTTP/1.0 200 OK
X-Gearman-Job-Handle: H:lap:6
Content-Length: 0
Server: Gearman/0.8
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The HTTP protocol should be considered experimental.
<h1 class="Sh" title="Sh" id="HOME"><a class="selflink" href="#HOME">HOME</a></h1>
To find out more information please check: <i>http://gearman.info/</i>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>gearman(1)</i> <i>gearadmin(1)</i> <i>libgearmand(3)</i>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Data Differential http://www.datadifferential.com/
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2011-2013, Data Differential, http://www.datadifferential.com/</div>
<table class="foot">
  <tr>
    <td class="foot-date">May 9, 2013</td>
    <td class="foot-os">1.0.6</td>
  </tr>
</table>
</body>
</html>
