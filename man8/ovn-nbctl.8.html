<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:14:14 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>ovn-nbctl(8) Open vSwitch Manual ovn-nbctl(8)</p>

<p style="margin-top: 1em">NAME <br>
ovn-nbctl - Open Virtual Network northbound db management
utility</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ovn-nbctl [options] command [arg...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This utility can be used to manage the OVN northbound
database.</p>

<p style="margin-top: 1em">GENERAL COMMANDS <br>
init Initializes the database, if it is empty. If the
database has already been initialized, this command has no
effect.</p>

<p style="margin-top: 1em">show [switch | router] <br>
Prints a brief overview of the database contents. If switch
is provided, only records related to that logical switch are
shown. If router is provided, only records related <br>
to that logical router are shown.</p>

<p style="margin-top: 1em">LOGICAL SWITCH COMMANDS <br>
ls-add Creates a new, unnamed logical switch, which
initially has no ports. The switch does not have a name,
other commands must refer to this switch by its UUID.</p>

<p style="margin-top: 1em">[--may-exist | --add-duplicate]
ls-add switch <br>
Creates a new logical switch named switch, which initially
has no ports.</p>

<p style="margin-top: 1em">The OVN northbound database
schema does not require logical switch names to be unique,
but the whole point to the names is to provide an easy way
for humans to refer to <br>
the switches, making duplicate names unhelpful. Thus,
without any options, this command regards it as an error if
switch is a duplicate name. With --may-exist, adding a <br>
duplicate name succeeds but does not create a new logical
switch. With --add-duplicate, the command really creates a
new logical switch with a duplicate name. It is an <br>
error to specify both options. If there are multiple logical
switches with a duplicate name, configure the logical
switches using the UUID instead of the switch name.</p>

<p style="margin-top: 1em">[--if-exists] ls-del switch <br>
Deletes switch. It is an error if switch does not exist,
unless --if-exists is specified.</p>

<p style="margin-top: 1em">ls-list <br>
Lists all existing switches on standard output, one per
line.</p>

<p style="margin-top: 1em">LOGICAL SWITCH ACL COMMANDS <br>
[--log] acl-add switch direction priority match action <br>
Adds the specified ACL to switch. direction must be either
from-lport or to-lport. priority must be between 0 and
32767, inclusive. If --log is specified, packet logging <br>
is enabled for the ACL. A full description of the fields are
in ovn-nb(5).</p>

<p style="margin-top: 1em">acl-del switch [direction
[priority match]] <br>
Deletes ACLs from switch. If only switch is supplied, all
the ACLs from the logical switch are deleted. If direction
is also specified, then all the flows in that direc&acirc;
<br>
tion will be deleted from the logical switch. If all the
fields are given, then a single flow that matches all the
fields will be deleted.</p>

<p style="margin-top: 1em">acl-list switch <br>
Lists the ACLs on switch.</p>

<p style="margin-top: 1em">LOGICAL SWITCH PORT COMMANDS
<br>
[--may-exist] lsp-add switch port <br>
Creates on lswitch a new logical switch port named port.</p>

<p style="margin-top: 1em">It is an error if a logical port
named port already exists, unless --may-exist is specified.
Regardless of --may-exist, it is an error if the existing
port is in some log&acirc; <br>
ical switch other than switch or if it has a parent
port.</p>

<p style="margin-top: 1em">[--may-exist] lsp-add switch
port parent tag_request <br>
Creates on switch a logical switch port named port that is a
child of parent that is identified with VLAN ID tag_request,
which must be between 0 and 4095, inclusive. If <br>
tag_request is 0, ovn-northd generates a tag that is unique
in the scope of parent. This is useful in cases such as
virtualized container environments where Open vSwitch <br>
does not have a direct connection to the container&acirc;s
port and it must be shared with the virtual machine&acirc;s
port.</p>

<p style="margin-top: 1em">It is an error if a logical port
named port already exists, unless --may-exist is specified.
Regardless of --may-exist, it is an error if the existing
port is not in <br>
switch or if it does not have the specified parent and
tag_request.</p>

<p style="margin-top: 1em">[--if-exists] lsp-del port <br>
Deletes port. It is an error if port does not exist, unless
--if-exists is specified.</p>

<p style="margin-top: 1em">lsp-list switch <br>
Lists all the logical switch ports within switch on standard
output, one per line.</p>

<p style="margin-top: 1em">lsp-get-parent port <br>
If set, get the parent port of port. If not set, print
nothing.</p>

<p style="margin-top: 1em">lsp-get-tag port <br>
If set, get the tag for port traffic. If not set, print
nothing.</p>

<p style="margin-top: 1em">lsp-set-addresses port
[address]... <br>
Sets the addresses associated with port to address. Each
address should be one of the following:</p>

<p style="margin-top: 1em">an Ethernet address, optionally
followed by a space and one or more IP addresses <br>
OVN delivers packets for the Ethernet address to this
port.</p>

<p style="margin-top: 1em">unknown <br>
OVN delivers unicast Ethernet packets whose destination MAC
address is not in any logical port&acirc;s addresses column
to ports with address unknown.</p>

<p style="margin-top: 1em">dynamic <br>
Use this keyword to make ovn-northd generate a globally
unique MAC address and choose an unused IPv4 address with
the logical port&acirc;s subnet and store them in the <br>
port&acirc;s dynamic_addresses column.</p>

<p style="margin-top: 1em">router Accepted only when the
type of the logical switch port is router. This indicates
that the Ethernet, IPv4, and IPv6 addresses for this logical
switch port should be <br>
obtained from the connected logical router port, as
specified by router-port in lsp-set-options.</p>

<p style="margin-top: 1em">Multiple addresses may be set.
If no address argument is given, port will have no addresses
associated with it.</p>

<p style="margin-top: 1em">lsp-get-addresses port <br>
Lists all the addresses associated with port on standard
output, one per line.</p>

<p style="margin-top: 1em">lsp-set-port-security port
[addrs]... <br>
Sets the port security addresses associated with port to
addrs. Multiple sets of addresses may be set by using
multiple addrs arguments. If no addrs argument is given,
<br>
port will not have port security enabled.</p>

<p style="margin-top: 1em">Port security limits the
addresses from which a logical port may send packets and to
which it may receive packets. See the ovn-nb(5)
documentation for the port_security <br>
column in the Logical_Switch_Port table for details.</p>

<p style="margin-top: 1em">lsp-get-port-security port <br>
Lists all the port security addresses associated with port
on standard output, one per line.</p>

<p style="margin-top: 1em">lsp-get-up port <br>
Prints the state of port, either up or down.</p>

<p style="margin-top: 1em">lsp-set-enabled port state <br>
Set the administrative state of port, either enabled or
disabled. When a port is disabled, no traffic is allowed
into or out of the port.</p>

<p style="margin-top: 1em">lsp-get-enabled port <br>
Prints the administrative state of port, either enabled or
disabled.</p>

<p style="margin-top: 1em">lsp-set-type port type <br>
Set the type for the logical port. No special types have
been implemented yet.</p>

<p style="margin-top: 1em">lsp-get-type port <br>
Get the type for the logical port.</p>

<p style="margin-top: 1em">lsp-set-options port
[key=value]... <br>
Set type-specific key-value options for the logical
port.</p>

<p style="margin-top: 1em">lsp-get-options port <br>
Get the type-specific options for the logical port.</p>

<p style="margin-top: 1em">LOGICAL ROUTER COMMANDS <br>
lr-add Creates a new, unnamed logical router, which
initially has no ports. The router does not have a name,
other commands must refer to this router by its UUID.</p>

<p style="margin-top: 1em">[--may-exist | --add-duplicate]
lr-add router <br>
Creates a new logical router named router, which initially
has no ports.</p>

<p style="margin-top: 1em">The OVN northbound database
schema does not require logical router names to be unique,
but the whole point to the names is to provide an easy way
for humans to refer to <br>
the routers, making duplicate names unhelpful. Thus, without
any options, this command regards it as an error if router
is a duplicate name. With --may-exist, adding a <br>
duplicate name succeeds but does not create a new logical
router. With --add-duplicate, the command really creates a
new logical router with a duplicate name. It is an <br>
error to specify both options. If there are multiple logical
routers with a duplicate name, configure the logical routers
using the UUID instead of the router name.</p>

<p style="margin-top: 1em">[--if-exists] lr-del router <br>
Deletes router. It is an error if router does not exist,
unless --if-exists is specified.</p>

<p style="margin-top: 1em">lr-list <br>
Lists all existing routers on standard output, one per
line.</p>

<p style="margin-top: 1em">LOGICAL ROUTER PORT COMMANDS
<br>
[--may-exist] lrp-add router port mac network... [peer=peer]
<br>
Creates on router a new logical router port named port with
Ethernet address mac and one or more IP address/netmask for
each network.</p>

<p style="margin-top: 1em">The optional argument peer
identifies a logical router port that connects to this one.
The following example adds a router port with an IPv4 and
IPv6 address with peer <br>
lr1:</p>

<p style="margin-top: 1em">lrp-add lr0 lrp0
00:11:22:33:44:55 192.168.0.1/24 2001:db8::1/64 peer=lr1</p>

<p style="margin-top: 1em">It is an error if a logical
router port named port already exists, unless --may-exist is
specified. Regardless of --may-exist, it is an error if the
existing router port <br>
is in some logical router other than router.</p>

<p style="margin-top: 1em">[--if-exists] lrp-del port <br>
Deletes port. It is an error if port does not exist, unless
--if-exists is specified.</p>

<p style="margin-top: 1em">lrp-list router <br>
Lists all the logical router ports within router on standard
output, one per line.</p>

<p style="margin-top: 1em">lrp-set-enabled port state <br>
Set the administrative state of port, either enabled or
disabled. When a port is disabled, no traffic is allowed
into or out of the port.</p>

<p style="margin-top: 1em">lrp-get-enabled port <br>
Prints the administrative state of port, either enabled or
disabled.</p>

<p style="margin-top: 1em">LOGICAL ROUTER STATIC ROUTE
COMMANDS <br>
[--may-exist] [--policy=POLICY] lr-route-add router prefix
nexthop [port] <br>
Adds the specified route to router. prefix describes an IPv4
or IPv6 prefix for this route, such as 192.168.100.0/24.
nexthop specifies the gateway to use for this route, <br>
which should be the IP address of one of router logical
router ports or the IP address of a logical port. If port is
specified, packets that match this route will be sent <br>
out that port. When port is omitted, OVN infers the output
port based on nexthop.</p>

<p style="margin-top: 1em">--policy describes the policy
used to make routing decisions. This should be one of
&quot;dst-ip&quot; or &quot;src-ip&quot;. If not specified,
the default is &quot;dst-ip&quot;.</p>

<p style="margin-top: 1em">It is an error if a route with
prefix already exists, unless --may-exist is specified.</p>

<p style="margin-top: 1em">[--if-exists] lr-route-del
router [prefix] <br>
Deletes routes from router. If only router is supplied, all
the routes from the logical router are deleted. If prefix is
also specified, then all the routes that match the <br>
prefix will be deleted from the logical router.</p>

<p style="margin-top: 1em">It is an error if prefix is
specified and there is no matching route entry, unless
--if-exists is specified.</p>

<p style="margin-top: 1em">lr-route-list router <br>
Lists the routes on router.</p>

<p style="margin-top: 1em">NAT COMMANDS <br>
[--may-exist] lr-nat-add router type external_ip logical_ip
[logical_port external_mac] <br>
Adds the specified NAT to router. The type must be one of
snat, dnat, or dnat_and_snat. The external_ip is an IPv4
address. The logical_ip is an IPv4 network (e.g <br>
192.168.1.0/24) or an IPv4 address. The logical_port and
external_mac are only accepted when router is a distributed
router (rather than a gateway router) and type is <br>
dnat_and_snat. The logical_port is the name of an existing
logical switch port where the logical_ip resides. The
external_mac is an Ethernet address.</p>

<p style="margin-top: 1em">When type is dnat, the
externally visible IP address external_ip is DNATted to the
IP address logical_ip in the logical space.</p>

<p style="margin-top: 1em">When type is snat, IP packets
with their source IP address that either matches the IP
address in logical_ip or is in the network provided by
logical_ip is SNATed into the <br>
IP address in external_ip.</p>

<p style="margin-top: 1em">When type is dnat_and_snat, the
externally visible IP address external_ip is DNATted to the
IP address logical_ip in the logical space. In addition, IP
packets with the <br>
source IP address that matches logical_ip is SNATed into the
IP address in external_ip.</p>

<p style="margin-top: 1em">When the logical_port and
external_mac are specified, the NAT rule will be programmed
on the chassis where the logical_port resides. This includes
ARP replies for the <br>
external_ip, which return the value of external_mac. All
packets transmitted with source IP address equal to
external_ip will be sent using the external_mac.</p>

<p style="margin-top: 1em">It is an error if a NAT already
exists with the same values of router, type, external_ip,
and logical_ip, unless --may-exist is specified. When
--may-exist, logical_port, <br>
and external_mac are all specified, the existing values of
logical_port and external_mac are overwritten.</p>

<p style="margin-top: 1em">[--if-exists] lr-nat-del router
[type [ip]] <br>
Deletes NATs from router. If only router is supplied, all
the NATs from the logical router are deleted. If type is
also specified, then all the NATs that match the type <br>
will be deleted from the logical router. If all the fields
are given, then a single NAT rule that matches all the
fields will be deleted. When type is snat, the ip should
<br>
be logical_ip. When type is dnat or dnat_and_snat, the ip
shoud be external_ip.</p>

<p style="margin-top: 1em">It is an error if ip is
specified and there is no matching NAT entry, unless
--if-exists is specified.</p>

<p style="margin-top: 1em">lr-nat-list router <br>
Lists the NATs on router.</p>

<p style="margin-top: 1em">LOAD BALANCER COMMANDS <br>
[--may-exist | --add-duplicate] lb-add lb vip ips [protocol]
<br>
Creates a new load balancer named lb with the provided vip
and ips or adds the vip to an existing lb. vip should be a
virtual IPv4 address (or an IPv4 address and a port <br>
number with : as a separator). Examples for vip are
192.168.1.4 and 192.168.1.5:8080. ips should be comma
separated IPv4 endpoints (or comma separated IPv4 addresses
and <br>
port numbers with : as a separator). Examples for ips are
10.0.0.1,10.0.0.2 or 20.0.0.10:8800,20.0.0.11:8800.</p>

<p style="margin-top: 1em">The optional argument protocol
must be either tcp or udp. This argument is useful when a
port number is provided as part of the vip. If the protocol
is unspecified and a <br>
port number is provided as part of the vip, OVN assumes the
protocol to be tcp.</p>

<p style="margin-top: 1em">It is an error if the vip
already exists in the load balancer named lb, unless
--may-exist is specified. With --add-duplicate, the command
really creates a new load bal&acirc; <br>
ancer with a duplicate name.</p>

<p style="margin-top: 1em">The following example adds a
load balancer.</p>

<p style="margin-top: 1em">lb-add lb0 30.0.0.10:80
192.168.10.10:80,192.168.10.20:80,192.168.10.30:80 udp</p>

<p style="margin-top: 1em">[--if-exists] lb-del lb [vip]
<br>
Deletes lb or the vip from lb. If vip is supplied, only the
vip will be deleted from the lb. If only the lb is supplied,
the lb will be deleted. It is an error if vip does <br>
not already exist in lb, unless --if-exists is
specified.</p>

<p style="margin-top: 1em">lb-list [lb] <br>
Lists the LBs. If lb is also specified, then only the
specified lb will be listed.</p>

<p style="margin-top: 1em">[--may-exist] ls-lb-add switch
lb <br>
Adds the specified lb to switch. It is an error if a load
balancer named lb already exists in the switch, unless
--may-exist is specified.</p>

<p style="margin-top: 1em">[--if-exists] ls-lb-del switch
[lb] <br>
Removes lb from switch. If only switch is supplied, all the
LBs from the logical switch are removed. If lb is also
specified, then only the lb will be removed from the <br>
logical switch. It is an error if lb does not exist in the
switch, unless --if-exists is specified.</p>

<p style="margin-top: 1em">ls-lb-list switch <br>
Lists the LBs for the given switch.</p>

<p style="margin-top: 1em">[--may-exist] lr-lb-add router
lb <br>
Adds the specified lb to router. It is an error if a load
balancer named lb already exists in the router, unless
--may-exist is specified.</p>

<p style="margin-top: 1em">[--if-exists] lr-lb-del router
[lb] <br>
Removes lb from router. If only router is supplied, all the
LBs from the logical router are removed. If lb is also
specified, then only the lb will be removed from the <br>
logical router. It is an error if lb does not exist in the
router, unless --if-exists is specified.</p>

<p style="margin-top: 1em">lr-lb-list router <br>
Lists the LBs for the given router.</p>

<p style="margin-top: 1em">DHCP OPTIONS COMMANDS <br>
dhcp-options-create cidr [key=value] <br>
Creates a new DHCP Options entry in the DHCP_Options table
with the specified cidr and optional external-ids.</p>

<p style="margin-top: 1em">dhcp-options-list <br>
Lists the DHCP Options entries.</p>

<p style="margin-top: 1em">dhcp-options-del dhcp-option
<br>
Deletes the DHCP Options entry referred by dhcp-option
UUID.</p>

<p style="margin-top: 1em">dhcp-options-set-options
dhcp-option [key=value]... <br>
Set the DHCP Options for the dhcp-option UUID.</p>

<p style="margin-top: 1em">dhcp-options-get-options
dhcp-option <br>
Lists the DHCP Options for the dhcp-option UUID.</p>

<p style="margin-top: 1em">DATABASE COMMANDS <br>
These commands query and modify the contents of ovsdb
tables. They are a slight abstraction of the ovsdb interface
and as suchthey operate at a lower level than other
ovn-nbctl <br>
commands.</p>

<p style="margin-top: 1em">Identifying Tables, Records, and
Columns</p>

<p style="margin-top: 1em">Each of these commands has a
table parameter to identify a table within the database.
Many of them also take a record parameter that identifies a
particular record within a ta&acirc; <br>
ble. The record parameter may be the UUID for a record, and
many tables offer additional ways to identify records. Some
commands also take column parameters that identify a
par&acirc; <br>
ticular field within the records in a table.</p>

<p style="margin-top: 1em">The following tables are
currently defined:</p>

<p style="margin-top: 1em">Logical_Switch <br>
An L2 logical switch. Records may be identified by name.</p>

<p style="margin-top: 1em">Logical_Switch_Port <br>
A port within an L2 logical switch. Records may be
identified by name.</p>

<p style="margin-top: 1em">ACL An ACL rule for a logical
switch that points to it through its acls column.</p>

<p style="margin-top: 1em">Logical_Router <br>
An L3 logical router. Records may be identified by name.</p>

<p style="margin-top: 1em">Logical_Router_Port <br>
A port within an L3 logical router. Records may be
identified by name.</p>

<p style="margin-top: 1em">Logical_Router_Static_Route <br>
A static route belonging to an L3 logical router.</p>

<p style="margin-top: 1em">Address_Set <br>
An address set that can be used in ACLs.</p>

<p style="margin-top: 1em">Load_Balancer <br>
A load balancer for a logical switch that points to it
through its load_balancer column.</p>

<p style="margin-top: 1em">NAT A NAT rule for a Gateway
router.</p>

<p style="margin-top: 1em">DHCP_Options <br>
DHCP options.</p>

<p style="margin-top: 1em">NB_Global <br>
North bound global configurations.</p>

<p style="margin-top: 1em">Database Values</p>

<p style="margin-top: 1em">Each column in the database
accepts a fixed type of data. The currently defined basic
types, and their representations, are:</p>

<p style="margin-top: 1em">integer <br>
A decimal integer in the range -2**63 to 2**63-1,
inclusive.</p>

<p style="margin-top: 1em">real A floating-point
number.</p>

<p style="margin-top: 1em">Boolean <br>
True or false, written true or false, respectively.</p>

<p style="margin-top: 1em">string An arbitrary Unicode
string, except that null bytes are not allowed. Quotes are
optional for most strings that begin with an English letter
or underscore and con&acirc; <br>
sist only of letters, underscores, hyphens, and periods.
However, true and false and strings that match the syntax of
UUIDs (see below) must be enclosed in double <br>
quotes to distinguish them from other basic types. When
double quotes are used, the syntax is that of strings in
JSON, e.g. backslashes may be used to escape spe&acirc; <br>
cial characters. The empty string must be represented as a
pair of double quotes (&quot;&quot;).</p>

<p style="margin-top: 1em">UUID Either a universally unique
identifier in the style of RFC 4122, e.g.
f81d4fae-7dec-11d0-a765-00a0c91e6bf6, or an @name defined by
a get or create command within <br>
the same ovn-nbctl invocation.</p>

<p style="margin-top: 1em">Multiple values in a single
column may be separated by spaces or a single comma. When
multiple values are present, duplicates are not allowed, and
order is not important. Con&acirc; <br>
versely, some database columns can have an empty set of
values, represented as [], and square brackets may
optionally enclose other non-empty sets or single values as
well.</p>

<p style="margin-top: 1em">A few database columns are
&lsquo;&lsquo;maps&acirc;&acirc; of key-value pairs, where
the key and the value are each some fixed database type.
These are specified in the form key=value, where key and
<br>
value follow the syntax for the column&acirc;s key type and
value type, respectively. When multiple pairs are present
(separated by spaces or a comma), duplicate keys are not
allowed, <br>
and again the order is not important. Duplicate values are
allowed. An empty map is represented as {}. Curly braces may
optionally enclose non-empty maps as well (but use quotes
<br>
to prevent the shell from expanding other-config={0=x,1=y}
into other-config=0=x other-config=1=y, which may not have
the desired effect).</p>

<p style="margin-top: 1em">Database Command Syntax</p>

<p style="margin-top: 1em">[--if-exists]
[--columns=column[,column]...] list table [record]... <br>
Lists the data in each specified record. If no records are
specified, lists all the records in table.</p>

<p style="margin-top: 1em">If --columns is specified, only
the requested columns are listed, in the specified order.
Otherwise, all columns are listed, in alphabetical order by
column name.</p>

<p style="margin-top: 1em">Without --if-exists, it is an
error if any specified record does not exist. With
--if-exists, the command ignores any record that does not
exist, without producing <br>
any output.</p>

<p style="margin-top: 1em">[--columns=column[,column]...]
find table [column[:key]=value]... <br>
Lists the data in each record in table whose column equals
value or, if key is specified, whose column contains a key
with the specified value. The following opera&acirc; <br>
tors may be used where = is written in the syntax
summary:</p>

<p style="margin-top: 1em">= != &lt; &gt; &lt;= &gt;= <br>
Selects records in which column[:key] equals, does not
equal, is less than, is greater than, is less than or equal
to, or is greater than or equal to value, <br>
respectively.</p>

<p style="margin-top: 1em">Consider column[:key] and value
as sets of elements. Identical sets are considered equal.
Otherwise, if the sets have different numbers of elements,
then the <br>
set with more elements is considered to be larger.
Otherwise, consider a element from each set pairwise, in
increasing order within each set. The first pair <br>
that differs determines the result. (For a column that
contains key-value pairs, first all the keys are compared,
and values are considered only if the two <br>
sets contain identical keys.)</p>

<p style="margin-top: 1em">{=} {!=} <br>
Test for set equality or inequality, respectively.</p>

<p style="margin-top: 1em">{&lt;=} Selects records in which
column[:key] is a subset of value. For example,
flood-vlans{&lt;=}1,2 selects records in which the
flood-vlans column is the empty set <br>
or contains 1 or 2 or both.</p>

<p style="margin-top: 1em">{&lt;} Selects records in which
column[:key] is a proper subset of value. For example,
flood-vlans{&lt;}1,2 selects records in which the
flood-vlans column is the <br>
empty set or contains 1 or 2 but not both.</p>

<p style="margin-top: 1em">{&gt;=} {&gt;} <br>
Same as {&lt;=} and {&lt;}, respectively, except that the
relationship is reversed. For example, flood-vlans{&gt;=}1,2
selects records in which the flood-vlans column <br>
contains both 1 and 2.</p>

<p style="margin-top: 1em">For arithmetic operators (= !=
&lt; &gt; &lt;= &gt;=), when key is specified but a
particular record&acirc;s column does not contain key, the
record is always omitted from the <br>
results. Thus, the condition other-config:mtu!=1500 matches
records that have a mtu key whose value is not 1500, but not
those that lack an mtu key.</p>

<p style="margin-top: 1em">For the set operators, when key
is specified but a particular record&acirc;s column does not
contain key, the comparison is done against an empty set.
Thus, the condition <br>
other-config:mtu{!=}1500 matches records that have a mtu key
whose value is not 1500 and those that lack an mtu key.</p>

<p style="margin-top: 1em">Don&acirc;t forget to escape
&lt; or &gt; from interpretation by the shell.</p>

<p style="margin-top: 1em">If --columns is specified, only
the requested columns are listed, in the specified order.
Otherwise all columns are listed, in alphabetical order by
column name.</p>

<p style="margin-top: 1em">The UUIDs shown for rows created
in the same ovn-nbctl invocation will be wrong.</p>

<p style="margin-top: 1em">[--if-exists] [--id=@name] get
table record [column[:key]]... <br>
Prints the value of each specified column in the given
record in table. For map columns, a key may optionally be
specified, in which case the value associated with <br>
key in the column is printed, instead of the entire map.</p>

<p style="margin-top: 1em">Without --if-exists, it is an
error if record does not exist or key is specified, if key
does not exist in record. With --if-exists, a missing record
yields no out&acirc; <br>
put and a missing key prints a blank line.</p>

<p style="margin-top: 1em">If @name is specified, then the
UUID for record may be referred to by that name later in the
same ovn-nbctl invocation in contexts where a UUID is
expected.</p>

<p style="margin-top: 1em">Both --id and the column
arguments are optional, but usually at least one or the
other should be specified. If both are omitted, then get has
no effect except to <br>
verify that record exists in table.</p>

<p style="margin-top: 1em">--id and --if-exists cannot be
used together.</p>

<p style="margin-top: 1em">[--if-exists] set table record
column[:key]=value... <br>
Sets the value of each specified column in the given record
in table to value. For map columns, a key may optionally be
specified, in which case the value associ&acirc; <br>
ated with key in that column is changed (or added, if none
exists), instead of the entire map.</p>

<p style="margin-top: 1em">Without --if-exists, it is an
error if record does not exist. With --if-exists, this
command does nothing if record does not exist.</p>

<p style="margin-top: 1em">[--if-exists] add table record
column [key=]value... <br>
Adds the specified value or key-value pair to column in
record in table. If column is a map, then key is required,
otherwise it is prohibited. If key already exists <br>
in a map column, then the current value is not replaced (use
the set command to replace an existing value).</p>

<p style="margin-top: 1em">Without --if-exists, it is an
error if record does not exist. With --if-exists, this
command does nothing if record does not exist.</p>

<p style="margin-top: 1em">[--if-exists] remove table
record column value...</p>

<p style="margin-top: 1em">[--if-exists] remove table
record column key...</p>

<p style="margin-top: 1em">[--if-exists] remov table record
column key=value... Removes the specified values or
key-value pairs from column in record in table. The first
form applies to col&acirc; <br>
umns that are not maps: each specified value is removed from
the column. The second and third forms apply to map columns:
if only a key is specified, then any key- <br>
value pair with the given key is removed, regardless of its
value; if a value is given then a pair is removed only if
both key and value match.</p>

<p style="margin-top: 1em">It is not an error if the column
does not contain the specified key or value or pair.</p>

<p style="margin-top: 1em">Without --if-exists, it is an
error if record does not exist. With --if-exists, this
command does nothing if record does not exist.</p>

<p style="margin-top: 1em">[--if-exists] clear table record
column... <br>
Sets each column in record in table to the empty set or
empty map, as appropriate. This command applies only to
columns that are allowed to be empty.</p>

<p style="margin-top: 1em">Without --if-exists, it is an
error if record does not exist. With --if-exists, this
command does nothing if record does not exist.</p>

<p style="margin-top: 1em">[--id=@name] create table
column[:key]=value... <br>
Creates a new record in table and sets the initial values of
each column. Columns not explicitly set will receive their
default values. Outputs the UUID of the new <br>
row.</p>

<p style="margin-top: 1em">If @name is specified, then the
UUID for the new row may be referred to by that name
elsewhere in the same invocation in contexts where a UUID is
expected. <br>
Such references may precede or follow the create
command.</p>

<p style="margin-top: 1em">Caution (ovs-vsctl as exmaple)
<br>
Records in the Open vSwitch database are significant only
when they can be reached directly or indirectly from the
Open_vSwitch table. Except for records in <br>
the QoS or Queue tables, records that are not reachable from
the Open_vSwitch table are automatically deleted from the
database. This deletion happens imme&acirc; <br>
diately, without waiting for additional ovs-vsctl commands
or other database activity. Thus, a create command must
generally be accompanied by additional <br>
commands within the same ovs-vsctl invocation to add a chain
of references to the newly created record from the top-level
Open_vSwitch record. The EXAMPLES <br>
section gives some examples that show how to do this.</p>

<p style="margin-top: 1em">[--if-exists] destroy table
record... <br>
Deletes each specified record from table. Unless --if-exists
is specified, each records must exist.</p>

<p style="margin-top: 1em">--all destroy table <br>
Deletes all records from the table.</p>

<p style="margin-top: 1em">Caution (ovs-vsctl as exmaple)
<br>
The destroy command is only useful for records in the QoS or
Queue tables. Records in other tables are automatically
deleted from the database when they <br>
become unreachable from the Open_vSwitch table. This means
that deleting the last reference to a record is sufficient
for deleting the record itself. For <br>
records in these tables, destroy is silently ignored. See
the EXAMPLES section below for more information.</p>

<p style="margin-top: 1em">wait-until table record
[column[:key]=value]... <br>
Waits until table contains a record named record whose
column equals value or, if key is specified, whose column
contains a key with the specified value. Any of the <br>
operators !=, &lt;, &gt;, &lt;=, or &gt;= may be substituted
for = to test for inequality, less than, greater than, less
than or equal to, or greater than or equal to, respec&acirc;
<br>
tively. (Don&acirc;t forget to escape &lt; or &gt; from
interpretation by the shell.)</p>

<p style="margin-top: 1em">If no column[:key]=value
arguments are given, this command waits only until record
exists. If more than one such argument is given, the command
waits until all of <br>
them are satisfied.</p>

<p style="margin-top: 1em">Caution (ovs-vsctl as exmaple)
<br>
Usually wait-until should be placed at the beginning of a
set of ovs-vsctl commands. For example, wait-until bridge
br0 -- get bridge br0 datapath_id waits <br>
until a bridge named br0 is created, then prints its
datapath_id column, whereas get bridge br0 datapath_id --
wait-until bridge br0 will abort if no bridge <br>
named br0 exists when ovs-vsctl initially connects to the
database.</p>

<p style="margin-top: 1em">Consider specifying --timeout=0
along with --wait-until, to prevent ovn-nbctl from
terminating after waiting only at most 5 seconds.</p>

<p style="margin-top: 1em">comment [arg]... <br>
This command has no effect on behavior, but any database log
record created by the command will include the command and
its arguments.</p>

<p style="margin-top: 1em">SYNCHRONIZATION COMMANDS <br>
sync Ordinarily, --wait=sb or --wait=hv only waits for
changes by the current ovn-nbctl invocation to take effect.
This means that, if none of the commands supplied to <br>
ovn-nbctl change the database, then the command does not
wait at all. With the sync command, however, ovn-nbctl waits
even for earlier changes to the database to propagate <br>
down to the southbound database or all of the OVN chassis,
according to the argument to --wait.</p>

<p style="margin-top: 1em">REMOTE CONNECTIVITY COMMANDS
<br>
get-connection <br>
Prints the configured connection(s).</p>

<p style="margin-top: 1em">del-connection <br>
Deletes the configured connection(s).</p>

<p style="margin-top: 1em">set-connection target... <br>
Sets the configured manager target or targets.</p>

<p style="margin-top: 1em">SSL CONFIGURATION COMMANDS <br>
get-ssl <br>
Prints the SSL configuration.</p>

<p style="margin-top: 1em">del-ssl <br>
Deletes the current SSL configuration.</p>

<p style="margin-top: 1em">[--bootstrap] set-ssl
private-key certificate ca-cert <br>
Sets the SSL configuration.</p>

<p style="margin-top: 1em">OPTIONS <br>
--no-wait | --wait=none <br>
--wait=sb <br>
--wait=hv <br>
These options control whether and how ovn-nbctl waits for
the OVN system to become up-to-date with changes made in an
ovn-nbctl invocation.</p>

<p style="margin-top: 1em">By default, or if --no-wait or
--wait=none, ovn-nbctl exits immediately after confirming
that changes have been committed to the northbound database,
without waiting.</p>

<p style="margin-top: 1em">With --wait=sb, before ovn-nbctl
exits, it waits for ovn-northd to bring the southbound
database up-to-date with the northbound database
updates.</p>

<p style="margin-top: 1em">With --wait=hv, before ovn-nbctl
exits, it additionally waits for all OVN chassis
(hypervisors and gateways) to become up-to-date with the
northbound database updates. (This <br>
can become an indefinite wait if any chassis is
malfunctioning.)</p>

<p style="margin-top: 1em">Ordinarily, --wait=sb or
--wait=hv only waits for changes by the current ovn-nbctl
invocation to take effect. This means that, if none of the
commands supplied to ovn-nbctl <br>
change the database, then the command does not wait at all.
Use the sync command to override this behavior.</p>

<p style="margin-top: 1em">--db database <br>
The OVSDB database remote to contact. If the OVN_NB_DB
environment variable is set, its value is used as the
default. Otherwise, the default is unix:/var/run/open&acirc;
<br>
vswitch/db.sock, but this default is unlikely to be useful
outside of single-machine OVN test environments.</p>

<p style="margin-top: 1em">LOGGING OPTIONS <br>
-v[spec] <br>
--verbose=[spec] <br>
Sets logging levels. Without any spec, sets the log level
for every module and destination to dbg. Otherwise, spec is
a list of words separated by spaces or commas or <br>
colons, up to one from each category below:</p>

<p style="margin-top: 1em">&Acirc;&middot; A valid module
name, as displayed by the vlog/list command on
ovs-appctl(8), limits the log level change to the specified
module.</p>

<p style="margin-top: 1em">&Acirc;&middot; syslog, console,
or file, to limit the log level change to only to the system
log, to the console, or to a file, respectively. (If
--detach is specified, the daemon <br>
closes its standard file descriptors, so logging to the
console will have no effect.)</p>

<p style="margin-top: 1em">On Windows platform, syslog is
accepted as a word and is only useful along with the
--syslog-target option (the word has no effect
otherwise).</p>

<p style="margin-top: 1em">&Acirc;&middot; off, emer, err,
warn, info, or dbg, to control the log level. Messages of
the given severity or higher will be logged, and messages of
lower severity will be filtered <br>
out. off filters out all messages. See ovs-appctl(8) for a
definition of each log level.</p>

<p style="margin-top: 1em">Case is not significant within
spec.</p>

<p style="margin-top: 1em">Regardless of the log levels set
for file, logging to a file will not take place unless
--log-file is also specified (see below).</p>

<p style="margin-top: 1em">For compatibility with older
versions of OVS, any is accepted as a word but has no
effect.</p>

<p style="margin-top: 1em">-v <br>
--verbose <br>
Sets the maximum logging verbosity level, equivalent to
--verbose=dbg.</p>

<p style="margin-top: 1em">-vPATTERN:destination:pattern
<br>
--verbose=PATTERN:destination:pattern <br>
Sets the log pattern for destination to pattern. Refer to
ovs-appctl(8) for a description of the valid syntax for
pattern.</p>

<p style="margin-top: 1em">-vFACILITY:facility <br>
--verbose=FACILITY:facility <br>
Sets the RFC5424 facility of the log message. facility can
be one of kern, user, mail, daemon, auth, syslog, lpr, news,
uucp, clock, ftp, ntp, audit, alert, clock2, local0, <br>
local1, local2, local3, local4, local5, local6 or local7. If
this option is not specified, daemon is used as the default
for the local system syslog and local0 is used while <br>
sending a message to the target provided via the
--syslog-target option.</p>

<p style="margin-top: 1em">--log-file[=file] <br>
Enables logging to a file. If file is specified, then it is
used as the exact name for the log file. The default log
file name used if file is omitted is /var/log/open&acirc;
<br>
vswitch/program.log.</p>

<p style="margin-top: 1em">--syslog-target=host:port <br>
Send syslog messages to UDP port on host, in addition to the
system syslog. The host must be a numerical IP address, not
a hostname.</p>

<p style="margin-top: 1em">--syslog-method=method <br>
Specify method as how syslog messages should be sent to
syslog daemon. The following forms are supported:</p>

<p style="margin-top: 1em">&Acirc;&middot; libc, to use the
libc syslog() function. This is the default behavior.
Downside of using this options is that libc adds fixed
prefix to every message before it is <br>
actually sent to the syslog daemon over /dev/log UNIX domain
socket.</p>

<p style="margin-top: 1em">&Acirc;&middot; unix:file, to
use a UNIX domain socket directly. It is possible to specify
arbitrary message format with this option. However, rsyslogd
8.9 and older versions use <br>
hard coded parser function anyway that limits UNIX domain
socket use. If you want to use arbitrary message format with
older rsyslogd versions, then use UDP socket to <br>
localhost IP address instead.</p>

<p style="margin-top: 1em">&Acirc;&middot; udp:ip:port, to
use a UDP socket. With this method it is possible to use
arbitrary message format also with older rsyslogd. When
sending syslog messages over UDP <br>
socket extra precaution needs to be taken into account, for
example, syslog daemon needs to be configured to listen on
the specified UDP port, accidental iptables <br>
rules could be interfering with local syslog traffic and
there are some security considerations that apply to UDP
sockets, but do not apply to UNIX domain sockets.</p>

<p style="margin-top: 1em">PKI Options <br>
PKI configuration is required to use SSL for the connection
to the database.</p>

<p style="margin-top: 1em">-p privkey.pem <br>
--private-key=privkey.pem <br>
Specifies a PEM file containing the private key used as
identity for outgoing SSL connections.</p>

<p style="margin-top: 1em">-c cert.pem <br>
--certificate=cert.pem <br>
Specifies a PEM file containing a certificate that certifies
the private key specified on -p or --private-key to be
trustworthy. The certificate must be signed by the <br>
certificate authority (CA) that the peer in SSL connections
will use to verify it.</p>

<p style="margin-top: 1em">-C cacert.pem <br>
--ca-cert=cacert.pem <br>
Specifies a PEM file containing the CA certificate for
verifying certificates presented to this program by SSL
peers. (This may be the same certificate that SSL peers <br>
use to verify the certificate specified on -c or
--certificate, or it may be a different one, depending on
the PKI design in use.)</p>

<p style="margin-top: 1em">-C none <br>
--ca-cert=none <br>
Disables verification of certificates presented by SSL
peers. This introduces a security risk, because it means
that certificates cannot be verified to be those of <br>
known trusted hosts.</p>

<p style="margin-top: 1em">--bootstrap-ca-cert=cacert.pem
<br>
When cacert.pem exists, this option has the same effect as
-C or --ca-cert. If it does not exist, then the executable
will attempt to obtain the CA certificate from <br>
the SSL peer on its first SSL connection and save it to the
named PEM file. If it is successful, it will immediately
drop the connection and reconnect, and from <br>
then on all SSL connections must be authenticated by a
certificate signed by the CA certificate thus obtained.</p>

<p style="margin-top: 1em">This option exposes the SSL
connection to a man-in-the-middle attack obtaining the
initial CA certificate, but it may be useful for
bootstrapping.</p>

<p style="margin-top: 1em">This option is only useful if
the SSL peer sends its CA certificate as part of the SSL
certificate chain. The SSL protocol does not require the
server to send the <br>
CA certificate.</p>

<p style="margin-top: 1em">This option is mutually
exclusive with -C and --ca-cert.</p>

<p style="margin-top: 1em">Other Options <br>
-h <br>
--help <br>
Prints a brief help message to the console.</p>

<p style="margin-top: 1em">-V <br>
--version <br>
Prints version information to the console.</p>

<p style="margin-top: 1em">Open vSwitch 2.7.0 ovn-nbctl
ovn-nbctl(8)</p>
<hr>
</body>
</html>
