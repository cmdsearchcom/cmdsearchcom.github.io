<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:11:11 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FLASHROM(8) System Manager&rsquo;s Manual
FLASHROM(8)</p>

<p style="margin-top: 1em">NAME <br>
flashrom - detect, read, write, verify and erase flash
chips</p>

<p style="margin-top: 1em">SYNOPSIS <br>
flashrom [-h|-R|-L|-z|-p
&lt;programmername&gt;[:&lt;parameters&gt;] <br>
[-E|-r &lt;file&gt;|-w &lt;file&gt;|-v &lt;file&gt;] [-c
&lt;chipname&gt;] <br>
[-l &lt;file&gt; [-i &lt;image&gt;]] [-n] [-f]] <br>
[-V[V[V]]] [-o &lt;logfile&gt;]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
flashrom is a utility for detecting, reading, writing,
verifying and erasing flash chips. It&rsquo;s often used to
flash BIOS/EFI/coreboot/firmware images in-system using a
supported <br>
mainboard. However, it also supports various external
PCI/USB/parallel-port/serial-port based devices which can
program flash chips, including some network cards (NICs),
SATA/IDE <br>
controller cards, graphics cards, the Bus Pirate device,
various FTDI FT2232/FT4232H/FT232H based USB devices, and
more.</p>

<p style="margin-top: 1em">It supports a wide range of
DIP32, PLCC32, DIP8, SO8/SOIC8, TSOP32, TSOP40, TSOP48, and
BGA chips, which use various protocols such as LPC, FWH,
parallel flash, or SPI.</p>

<p style="margin-top: 1em">OPTIONS <br>
IMPORTANT: Please note that the command line interface for
flashrom will change before flashrom 1.0. Do not use
flashrom in scripts or other automated tools without
checking that <br>
your flashrom version won&rsquo;t interpret options in a
different way.</p>

<p style="margin-top: 1em">You can specify one of -h, -R,
-L, -z, -E, -r, -w, -v or no operation. If no operation is
specified, flashrom will only probe for flash chips. It is
recommended that if you try <br>
flashrom the first time on a system, you run it in
probe-only mode and check the output. Also you are advised
to make a backup of your current ROM contents with -r before
you try <br>
to write a new image. All operations involving any chip
access (probe/read/write/...) require the -p/--programmer
option to be used (please see below).</p>

<p style="margin-top: 1em">-r, --read &lt;file&gt; <br>
Read flash ROM contents and save them into the given
&lt;file&gt;. If the file already exists, it will be
overwritten.</p>

<p style="margin-top: 1em">-w, --write &lt;file&gt; <br>
Write &lt;file&gt; into flash ROM. This will first
automatically erase the chip, then write to it.</p>

<p style="margin-top: 1em">In the process the chip is also
read several times. First an in-memory backup is made for
disaster recovery and to be able to skip regions that are
already equal to the <br>
image file. This copy is updated along with the write
operation. In case of erase errors it is even re-read
completely. After writing has finished and if verification
is <br>
enabled, the whole flash chip is read out and compared with
the input image.</p>

<p style="margin-top: 1em">-n, --noverify <br>
Skip the automatic verification of flash ROM contents after
writing. Using this option is not recommended, you should
only use it if you know what you are doing and if you <br>
feel that the time for verification takes too long.</p>

<p style="margin-top: 1em">Typical usage is: flashrom -p
prog -n -w &lt;file&gt;</p>

<p style="margin-top: 1em">This option is only useful in
combination with --write.</p>

<p style="margin-top: 1em">-v, --verify &lt;file&gt; <br>
Verify the flash ROM contents against the given
&lt;file&gt;.</p>

<p style="margin-top: 1em">-E, --erase <br>
Erase the flash ROM chip.</p>

<p style="margin-top: 1em">-V, --verbose <br>
More verbose output. This option can be supplied multiple
times (max. 3 times, i.e. -VVV) for even more debug
output.</p>

<p style="margin-top: 1em">-c, --chip &lt;chipname&gt; <br>
Probe only for the specified flash ROM chip. This option
takes the chip name as printed by flashrom -L without the
vendor name as parameter. Please note that the chip name
<br>
is case sensitive.</p>

<p style="margin-top: 1em">-f, --force <br>
Force one or more of the following actions:</p>

<p style="margin-top: 1em">* Force chip read and pretend
the chip is there.</p>

<p style="margin-top: 1em">* Force chip access even if the
chip is bigger than the maximum supported size for the flash
bus.</p>

<p style="margin-top: 1em">* Force erase even if erase is
known bad.</p>

<p style="margin-top: 1em">* Force write even if write is
known bad.</p>

<p style="margin-top: 1em">-l, --layout &lt;file&gt; <br>
Read ROM layout from &lt;file&gt;.</p>

<p style="margin-top: 1em">flashrom supports ROM layouts.
This allows you to flash certain parts of the flash chip
only. A ROM layout file contains multiple lines with the
following syntax:</p>

<p style="margin-top: 1em">startaddr:endaddr imagename</p>

<p style="margin-top: 1em">startaddr and endaddr are
hexadecimal addresses within the ROM file and do not refer
to any physical address. Please note that using a 0x prefix
for those hexadecimal num&acirc; <br>
bers is not necessary, but you can&rsquo;t specify
decimal/octal numbers. imagename is an arbitrary name for
the region/image from startaddr to endaddr (both addresses
<br>
included).</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">00000000:00008fff gfxrom <br>
00009000:0003ffff normal <br>
00040000:0007ffff fallback</p>

<p style="margin-top: 1em">If you only want to update the
image named normal in a ROM based on the layout above,
run</p>

<p style="margin-top: 1em">flashrom -p prog --layout
rom.layout --image normal -w some.rom</p>

<p style="margin-top: 1em">To update only the images named
normal and fallback, run:</p>

<p style="margin-top: 1em">flashrom -p prog -l rom.layout
-i normal -i fallback -w some.rom</p>

<p style="margin-top: 1em">Overlapping sections are not
supported.</p>

<p style="margin-top: 1em">-i, --image &lt;imagename&gt;
<br>
Only flash region/image &lt;imagename&gt; from flash
layout.</p>

<p style="margin-top: 1em">-L, --list-supported <br>
List the flash chips, chipsets, mainboards, and external
programmers (including PCI, USB, parallel port, and serial
port based devices) supported by flashrom.</p>

<p style="margin-top: 1em">There are many unlisted boards
which will work out of the box, without special support in
flashrom. Please let us know if you can verify that other
boards work or do not <br>
work out of the box.</p>

<p style="margin-top: 1em">IMPORTANT: For verification you
have to test an ERASE and/or WRITE operation, so make sure
you only do that if you have proper means to recover from
failure!</p>

<p style="margin-top: 1em">-z, --list-supported-wiki <br>
Same as --list-supported, but outputs the supported hardware
in MediaWiki syntax, so that it can be easily pasted into
the supported hardware wiki page <br>

&acirc;&uml;https://flashrom.org/Supported_hardware&acirc;&copy;.
Please note that MediaWiki output is not compiled in by
default.</p>

<p style="margin-top: 1em">-p, --programmer
&lt;name&gt;[:parameter[,parameter[,parameter]]] <br>
Specify the programmer device. This is mandatory for all
operations involving any chip access (probe/read/write/...).
Currently supported are:</p>

<p style="margin-top: 1em">* internal (for in-system
flashing in the mainboard)</p>

<p style="margin-top: 1em">* dummy (virtual programmer for
testing flashrom)</p>

<p style="margin-top: 1em">* nic3com (for flash ROMs on
3COM network cards)</p>

<p style="margin-top: 1em">* nicrealtek (for flash ROMs on
Realtek and SMC 1211 network cards)</p>

<p style="margin-top: 1em">* nicnatsemi (for flash ROMs on
National Semiconductor DP838* network cards)</p>

<p style="margin-top: 1em">* nicintel (for parallel flash
ROMs on Intel 10/100Mbit network cards)</p>

<p style="margin-top: 1em">* gfxnvidia (for flash ROMs on
NVIDIA graphics cards)</p>

<p style="margin-top: 1em">* drkaiser (for flash ROMs on
Dr. Kaiser PC-Waechter PCI cards)</p>

<p style="margin-top: 1em">* satasii (for flash ROMs on
Silicon Image SATA/IDE controllers)</p>

<p style="margin-top: 1em">* satamv (for flash ROMs on
Marvell SATA controllers)</p>

<p style="margin-top: 1em">* atahpt (for flash ROMs on
Highpoint ATA/RAID controllers)</p>

<p style="margin-top: 1em">* atavia (for flash ROMs on VIA
VT6421A SATA controllers)</p>

<p style="margin-top: 1em">* atapromise (for flash ROMs on
Promise PDC2026x ATA/RAID controllers)</p>

<p style="margin-top: 1em">* it8212 (for flash ROMs on ITE
IT8212F ATA/RAID controller)</p>

<p style="margin-top: 1em">* ft2232_spi (for SPI flash ROMs
attached to an FT2232/FT4232H/FT232H family based USB SPI
programmer).</p>

<p style="margin-top: 1em">* serprog (for flash ROMs
attached to a programmer speaking serprog, including some
Arduino-based devices).</p>

<p style="margin-top: 1em">* buspirate_spi (for SPI flash
ROMs attached to a Bus Pirate)</p>

<p style="margin-top: 1em">* dediprog (for SPI flash ROMs
attached to a Dediprog SF100)</p>

<p style="margin-top: 1em">* rayer_spi (for SPI flash ROMs
attached to a parallel port by one of various cable
types)</p>

<p style="margin-top: 1em">* pony_spi (for SPI flash ROMs
attached to a SI-Prog serial port bitbanging adapter)</p>

<p style="margin-top: 1em">* nicintel_spi (for SPI flash
ROMs on Intel Gigabit network cards)</p>

<p style="margin-top: 1em">* ogp_spi (for SPI flash ROMs on
Open Graphics Project graphics card)</p>

<p style="margin-top: 1em">* linux_spi (for SPI flash ROMs
accessible via /dev/spidevX.Y on Linux)</p>

<p style="margin-top: 1em">* usbblaster_spi (for SPI flash
ROMs attached to an Altera USB-Blaster compatible cable)</p>

<p style="margin-top: 1em">* nicintel_eeprom (for SPI
EEPROMs on Intel Gigabit network cards)</p>

<p style="margin-top: 1em">* mstarddc_spi (for SPI flash
ROMs accessible through DDC in MSTAR-equipped displays)</p>

<p style="margin-top: 1em">* pickit2_spi (for SPI flash
ROMs accessible via Microchip PICkit2)</p>

<p style="margin-top: 1em">* ch341a_spi (for SPI flash ROMs
attached to WCH CH341A)</p>

<p style="margin-top: 1em">Some programmers have optional
or mandatory parameters which are described in detail in the
PROGRAMMER-SPECIFIC INFORMATION section. Support for some
programmers can be <br>
disabled at compile time. flashrom -h lists all supported
programmers.</p>

<p style="margin-top: 1em">-h, --help <br>
Show a help text and exit.</p>

<p style="margin-top: 1em">-o, --output &lt;logfile&gt;
<br>
Save the full debug log to &lt;logfile&gt;. If the file
already exists, it will be overwritten. This is the
recommended way to gather logs from flashrom because they
will be <br>
verbose even if the on-screen messages are not verbose and
don&rsquo;t require output redirection.</p>

<p style="margin-top: 1em">-R, --version <br>
Show version information and exit.</p>

<p style="margin-top: 1em">PROGRAMMER-SPECIFIC INFORMATION
<br>
Some programmer drivers accept further parameters to set
programmer-specific parameters. These parameters are
separated from the programmer name by a colon. While some
program&acirc; <br>
mers take arguments at fixed positions, other programmers
use a key/value interface in which the key and value is
separated by an equal sign and different pairs are separated
by <br>
a comma or a colon.</p>

<p style="margin-top: 1em">internal programmer <br>
Board Enables</p>

<p style="margin-top: 1em">Some mainboards require to run
mainboard specific code to enable flash erase and write
support (and probe support on old systems with parallel
flash). The mainboard brand <br>
and model (if it requires specific code) is usually
autodetected using one of the following mechanisms: If your
system is running coreboot, the mainboard type is
deter&acirc; <br>
mined from the coreboot table. Otherwise, the mainboard is
detected by examining the onboard PCI devices and possibly
DMI info. If PCI and DMI do not contain information <br>
to uniquely identify the mainboard (which is the exception),
or if you want to override the detected mainboard model, you
can specify the mainboard using the</p>

<p style="margin-top: 1em">flashrom -p
internal:mainboard=&lt;vendor&gt;:&lt;board&gt; syntax.</p>

<p style="margin-top: 1em">See the &rsquo;Known
boards&rsquo; or &rsquo;Known laptops&rsquo; section in the
output of &rsquo;flashrom -L&rsquo; for a list of boards
which require the specification of the board name, if no
coreboot ta&acirc; <br>
ble is found.</p>

<p style="margin-top: 1em">Some of these board-specific
flash enabling functions (called board enables) in flashrom
have not yet been tested. If your mainboard is detected
needing an untested board <br>
enable function, a warning message is printed and the board
enable is not executed, because a wrong board enable
function might cause the system to behave erratically, as
<br>
board enable functions touch the low-level internals of a
mainboard. Not executing a board enable function (if one is
needed) might cause detection or erasing failure. If <br>
your board protects only part of the flash (commonly the top
end, called boot block), flashrom might encounter an error
only after erasing the unprotected part, so running <br>
without the board-enable function might be dangerous for
erase and write (which includes erase).</p>

<p style="margin-top: 1em">The suggested procedure for a
mainboard with untested board specific code is to first try
to probe the ROM (just invoke flashrom and check that it
detects your flash chip <br>
type) without running the board enable code (i.e. without
any parameters). If it finds your chip, fine. Otherwise,
retry probing your chip with the board-enable code
run&acirc; <br>
ning, using</p>

<p style="margin-top: 1em">flashrom -p
internal:boardenable=force</p>

<p style="margin-top: 1em">If your chip is still not
detected, the board enable code seems to be broken or the
flash chip unsupported. Otherwise, make a backup of your
current ROM contents (using <br>
-r) and store it to a medium outside of your computer, like
a USB drive or a network share. If you needed to run the
board enable code already for probing, use it for <br>
reading too. If reading succeeds and the contens of the read
file look legit you can try to write the new image. You
should enable the board enable code in any case now, <br>
as it has been written because it is known that
writing/erasing without the board enable is going to fail.
In any case (success or failure), please report to the
flashrom <br>
mailing list, see below.</p>

<p style="margin-top: 1em">Coreboot</p>

<p style="margin-top: 1em">On systems running coreboot,
flashrom checks whether the desired image matches your
mainboard. This needs some special board ID to be present in
the image. If flashrom <br>
detects that the image you want to write and the current
board do not match, it will refuse to write the image unless
you specify</p>

<p style="margin-top: 1em">flashrom -p
internal:boardmismatch=force</p>

<p style="margin-top: 1em">ITE IT87 Super I/O</p>

<p style="margin-top: 1em">If your mainboard is
manufactured by GIGABYTE and supports DualBIOS it is very
likely that it uses an ITE IT87 series Super I/O to switch
between the two flash chips. Only <br>
one of them can be accessed at a time and you can manually
select which one to use with the</p>

<p style="margin-top: 1em">flashrom -p
internal:dualbiosindex=chip</p>

<p style="margin-top: 1em">syntax where chip is the index
of the chip to use (0 = main, 1 = backup). You can check
which one is currently selected by leaving out the chip
parameter.</p>

<p style="margin-top: 1em">If your mainboard uses an ITE
IT87 series Super I/O for LPC&lt;-&gt;SPI flash bus
translation, flashrom should autodetect that configuration.
If you want to set the I/O base <br>
port of the IT87 series SPI controller manually instead of
using the value provided by the BIOS, use the</p>

<p style="margin-top: 1em">flashrom -p
internal:it87spiport=portnum</p>

<p style="margin-top: 1em">syntax where portnum is the I/O
port number (must be a multiple of 8). In the unlikely case
flashrom doesn&rsquo;t detect an active IT87 LPC&lt;-&gt;SPI
bridge, please send a bug <br>
report so we can diagnose the problem.</p>

<p style="margin-top: 1em">AMD chipsets</p>

<p style="margin-top: 1em">Beginning with the SB700 chipset
there is an integrated microcontroller (IMC) based on the
8051 embedded in every AMD southbridge. Its firmware resides
in the same flash <br>
chip as the host&rsquo;s which makes writing to the flash
risky if the IMC is active. Flashrom tries to temporarily
disable the IMC but even then changing the contents of the
<br>
flash can have unwanted effects: when the IMC continues (at
the latest after a reboot) it will continue executing code
from the flash. If the code was removed or changed <br>
in an unfortunate way it is unpredictable what the IMC will
do. Therefore, if flashrom detects an active IMC it will
disable write support unless the user forces it with <br>
the</p>

<p style="margin-top: 1em">flashrom -p
internal:amd_imc_force=yes</p>

<p style="margin-top: 1em">syntax. The user is responsible
for supplying a suitable image or leaving out the IMC region
with the help of a layout file. This limitation might be
removed in the future <br>
when we understand the details better and have received
enough feedback from users. Please report the outcome if you
had to use this option to write a chip.</p>

<p style="margin-top: 1em">An optional spispeed parameter
specifies the frequency of the SPI bus where applicable
(i.e. SB600 or later with an SPI flash chip directly
attached to the chipset). Syn&acirc; <br>
tax is</p>

<p style="margin-top: 1em">flashrom -p
internal:spispeed=frequency</p>

<p style="margin-top: 1em">where frequency can be
&rsquo;16.5 MHz&rsquo;, &rsquo;22 MHz&rsquo;, &rsquo;33
MHz&rsquo;, &rsquo;66 MHz&rsquo;, &rsquo;100 MHZ&rsquo;, or
&rsquo;800 kHz&rsquo;. Support of individual frequencies
depends on the generation of the chipset:</p>

<p style="margin-top: 1em">* SB6xx, SB7xx, SP5xxx: from
16.5 MHz up to and including 33 MHz</p>

<p style="margin-top: 1em">* SB8xx, SB9xx, Hudson: from
16.5 MHz up to and including 66 MHz</p>

<p style="margin-top: 1em">* Yangtze (with SPI 100 engine
as found in Kabini and Tamesh): all of them</p>

<p style="margin-top: 1em">The default is to use 16.5 MHz
and disable Fast Reads.</p>

<p style="margin-top: 1em">Intel chipsets</p>

<p style="margin-top: 1em">If you have an Intel chipset
with an ICH8 or later southbridge with SPI flash attached,
and if a valid descriptor was written to it (e.g. by the
vendor), the chipset pro&acirc; <br>
vides an alternative way to access the flash chip(s) named
Hardware Sequencing. It is much simpler than the normal
access method (called Software Sequencing), but does <br>
not allow the software to choose the SPI commands to be
sent. You can use the</p>

<p style="margin-top: 1em">flashrom -p
internal:ich_spi_mode=value</p>

<p style="margin-top: 1em">syntax where value can be auto,
swseq or hwseq. By default (or when setting
ich_spi_mode=auto) the module tries to use swseq and only
activates hwseq if need be (e.g. if <br>
important opcodes are inaccessible due to lockdown; or if
more than one flash chip is attached). The other options
(swseq, hwseq) select the respective mode (if possible).</p>

<p style="margin-top: 1em">ICH8 and later southbridges may
also have locked address ranges of different kinds if a
valid descriptor was written to it. The flash address space
is then partitioned in <br>
multiple so called &quot;Flash Regions&quot; containing the
host firmware, the ME firmware and so on respectively. The
flash descriptor can also specify up to 5 so called
&quot;Protected <br>
Regions&quot;, which are freely chosen address ranges
independent from the aforementioned &quot;Flash
Regions&quot;. All of them can be write and/or read
protected individually. If <br>
flashrom detects such a lock it will disable write support
unless the user forces it with the</p>

<p style="margin-top: 1em">flashrom -p
internal:ich_spi_force=yes</p>

<p style="margin-top: 1em">syntax. If this leads to erase
or write accesses to the flash it would most probably bring
it into an inconsistent and unbootable state and we will not
provide any support <br>
in such a case.</p>

<p style="margin-top: 1em">If you have an Intel chipset
with an ICH2 or later southbridge and if you want to set
specific IDSEL values for a non-default flash chip or an
embedded controller (EC), <br>
you can use the</p>

<p style="margin-top: 1em">flashrom -p
internal:fwh_idsel=value</p>

<p style="margin-top: 1em">syntax where value is the 48-bit
hexadecimal raw value to be written in the IDSEL registers
of the Intel southbridge. The upper 32 bits use one hex
digit each per 512 kB <br>
range between 0xffc00000 and 0xffffffff, and the lower 16
bits use one hex digit each per 1024 kB range between
0xff400000 and 0xff7fffff. The rightmost hex digit
corre&acirc; <br>
sponds with the lowest address range. All address ranges
have a corresponding sister range 4 MB below with identical
IDSEL settings. The default value for ICH7 is given in <br>
the example below.</p>

<p style="margin-top: 1em">Example: flashrom -p
internal:fwh_idsel=0x001122334567</p>

<p style="margin-top: 1em">Laptops</p>

<p style="margin-top: 1em">Using flashrom on laptops is
dangerous and may easily make your hardware unusable (see
also the BUGS section). The embedded controller (EC) in
these machines often inter&acirc; <br>
acts badly with flashing. More information is in the wiki
&acirc;&uml;https://flashrom.org/Laptops&acirc;&copy;. For
example the EC firmware sometimes resides on the same flash
chip as the <br>
host firmware. While flashrom tries to change the contents
of that memory the EC might need to fetch new instructions
or data from it and could stop working correctly. <br>
Probing for and reading from the chip may also irritate your
EC and cause fan failure, backlight failure, sudden
poweroff, and other nasty effects. flashrom will attempt
<br>
to detect if it is running on a laptop and abort immediately
for safety reasons if it clearly identifies the host
computer as one. If you want to proceed anyway at your <br>
own risk, use</p>

<p style="margin-top: 1em">flashrom -p
internal:laptop=force_I_want_a_brick</p>

<p style="margin-top: 1em">We will not help you if you
force flashing on a laptop because this is a really dumb
idea.</p>

<p style="margin-top: 1em">You have been warned.</p>

<p style="margin-top: 1em">Currently we rely on the chassis
type encoded in the DMI/SMBIOS data to detect laptops. Some
vendors did not implement those bits correctly or set them
to generic and/or <br>
dummy values. flashrom will then issue a warning and bail
out like above. In this case you can use</p>

<p style="margin-top: 1em">flashrom -p
internal:laptop=this_is_not_a_laptop</p>

<p style="margin-top: 1em">to tell flashrom (at your own
risk) that it is not running on a laptop.</p>

<p style="margin-top: 1em">dummy programmer <br>
The dummy programmer operates on a buffer in memory only. It
provides a safe and fast way to test various aspects of
flashrom and is mainly used in development and while <br>
debugging. It is able to emulate some chips to a certain
degree (basic identify/read/erase/write operations
work).</p>

<p style="margin-top: 1em">An optional parameter specifies
the bus types it should support. For that you have to use
the</p>

<p style="margin-top: 1em">flashrom -p
dummy:bus=[type[+type[+type]]]</p>

<p style="margin-top: 1em">syntax where type can be
parallel, lpc, fwh, spi in any order. If you specify bus
without type, all buses will be disabled. If you do not
specify bus, all buses will be <br>
enabled.</p>

<p style="margin-top: 1em">Example: flashrom -p
dummy:bus=lpc+fwh</p>

<p style="margin-top: 1em">The dummy programmer supports
flash chip emulation for automated self-tests without
hardware access. If you want to emulate a flash chip, use
the</p>

<p style="margin-top: 1em">flashrom -p
dummy:emulate=chip</p>

<p style="margin-top: 1em">syntax where chip is one of the
following chips (please specify only the chip name, not the
vendor):</p>

<p style="margin-top: 1em">* ST M25P10.RES SPI flash chip
(128 kB, RES, page write)</p>

<p style="margin-top: 1em">* SST SST25VF040.REMS SPI flash
chip (512 kB, REMS, byte write)</p>

<p style="margin-top: 1em">* SST SST25VF032B SPI flash chip
(4096 kB, RDID, AAI write)</p>

<p style="margin-top: 1em">* Macronix MX25L6436 SPI flash
chip (8192 kB, RDID, SFDP)</p>

<p style="margin-top: 1em">Example: flashrom -p
dummy:emulate=SST25VF040.REMS</p>

<p style="margin-top: 1em">Persistent images</p>

<p style="margin-top: 1em">If you use flash chip emulation,
flash image persistence is available as well by using
the</p>

<p style="margin-top: 1em">flashrom -p
dummy:emulate=chip,image=image.rom</p>

<p style="margin-top: 1em">syntax where image.rom is the
file where the simulated chip contents are read on flashrom
startup and where the chip contents on flashrom shutdown are
written to.</p>

<p style="margin-top: 1em">Example: flashrom -p
dummy:emulate=M25P10.RES,image=dummy.bin</p>

<p style="margin-top: 1em">SPI write chunk size</p>

<p style="margin-top: 1em">If you use SPI flash chip
emulation for a chip which supports SPI page write with the
default opcode, you can set the maximum allowed write chunk
size with the</p>

<p style="margin-top: 1em">flashrom -p
dummy:emulate=chip,spi_write_256_chunksize=size</p>

<p style="margin-top: 1em">syntax where size is the number
of bytes (min. 1, max. 256).</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">flashrom -p
dummy:emulate=M25P10.RES,spi_write_256_chunksize=5</p>

<p style="margin-top: 1em">SPI blacklist</p>

<p style="margin-top: 1em">To simulate a programmer which
refuses to send certain SPI commands to the flash chip, you
can specify a blacklist of SPI commands with the</p>

<p style="margin-top: 1em">flashrom -p
dummy:spi_blacklist=commandlist</p>

<p style="margin-top: 1em">syntax where commandlist is a
list of two-digit hexadecimal representations of SPI
commands. If commandlist is e.g. 0302, flashrom will behave
as if the SPI controller <br>
refuses to run command 0x03 (READ) and command 0x02 (WRITE).
commandlist may be up to 512 characters (256 commands) long.
Implementation note: flashrom will detect an <br>
error during command execution.</p>

<p style="margin-top: 1em">SPI ignorelist</p>

<p style="margin-top: 1em">To simulate a flash chip which
ignores (doesn&rsquo;t support) certain SPI commands, you
can specify an ignorelist of SPI commands with the</p>

<p style="margin-top: 1em">flashrom -p
dummy:spi_ignorelist=commandlist</p>

<p style="margin-top: 1em">syntax where commandlist is a
list of two-digit hexadecimal representations of SPI
commands. If commandlist is e.g. 0302, the emulated flash
chip will ignore command 0x03 <br>
(READ) and command 0x02 (WRITE). commandlist may be up to
512 characters (256 commands) long. Implementation note:
flashrom won&rsquo;t detect an error during command
execu&acirc; <br>
tion.</p>

<p style="margin-top: 1em">SPI status register</p>

<p style="margin-top: 1em">You can specify the initial
content of the chip&rsquo;s status register with the</p>

<p style="margin-top: 1em">flashrom -p
dummy:spi_status=content</p>

<p style="margin-top: 1em">syntax where content is an 8-bit
hexadecimal value.</p>

<p style="margin-top: 1em">nic3com, nicrealtek, nicnatsemi,
nicintel, nicintel_eeprom, nicintel_spi, gfxnvidia, ogp_spi,
drkaiser, satasii, satamv, atahpt, atavia , atapromise and
it8212 programmers <br>
These programmers have an option to specify the PCI address
of the card your want to use, which must be specified if
more than one card supported by the selected program&acirc;
<br>
mer is installed in your system. The syntax is</p>

<p style="margin-top: 1em">flashrom -p
xxxx:pci=bb:dd.f,</p>

<p style="margin-top: 1em">where xxxx is the name of the
programmer, bb is the PCI bus number, dd is the PCI device
number, and f is the PCI function number of the desired
device.</p>

<p style="margin-top: 1em">Example: flashrom -p
nic3com:pci=05:04.0</p>

<p style="margin-top: 1em">atavia programmer <br>
Due to the mysterious address handling of the VIA VT6421A
controller the user can specify an offset with the</p>

<p style="margin-top: 1em">flashrom -p
atavia:offset=addr</p>

<p style="margin-top: 1em">syntax where addr will be
interpreted as usual (leading 0x (0) for hexadecimal (octal)
values, or else decimal). For more information please see
its wiki page <br>
&acirc;&uml;https://flashrom.org/VT6421A&acirc;&copy;.</p>

<p style="margin-top: 1em">atapromise programmer <br>
This programmer is currently limited to 32 kB, regardless of
the actual size of the flash chip. This stems from the fact
that, on the tested device (a Promise Ultra100), <br>
not all of the chip&rsquo;s address lines were actually
connected. You may use this programmer to flash firmware
updates, since these are only 16 kB in size (padding to 32
kB is <br>
required).</p>

<p style="margin-top: 1em">nicintel_eeprom programmer <br>
This is the first programmer module in flashrom that does
not provide access to NOR flash chips but EEPROMs mounted on
gigabit Ethernet cards based on Intel&rsquo;s 82580 NIC.
<br>
Because EEPROMs normally do not announce their size nor
allow themselves to be identified, the controller relies on
correct size values written to predefined addresses <br>
within the chip. Flashrom follows this scheme but assumes
the minimum size of 16 kB (128 kb) if an unprogrammed
EEPROM/card is detected. Intel specifies following EEPROMs
<br>
to be compatible: Atmel AT25128, AT25256, Micron (ST)
M95128, M95256 and OnSemi (Catalyst) CAT25CS128.</p>

<p style="margin-top: 1em">ft2232_spi programmer <br>
This module supports various programmers based on FTDI
FT2232/FT4232H/FT232H chips including the DLP Design
DLP-USB1232H, openbiosprog-spi, Amontec JTAGkey/JTAGkey-
<br>
tiny/JTAGkey-2, Dangerous Prototypes Bus Blaster, Olimex
ARM-USB-TINY/-H, Olimex ARM-USB-OCD/-H, OpenMoko Neo1973
Debug board (V2+), TIAO/DIYGADGET USB Multi-Protocol <br>
Adapter (TUMPA), TUMPA Lite, GOEPEL PicoTAP and Google Servo
v1/v2.</p>

<p style="margin-top: 1em">An optional parameter specifies
the controller type and channel/interface/port it should
support. For that you have to use the</p>

<p style="margin-top: 1em">flashrom -p
ft2232_spi:type=model,port=interface</p>

<p style="margin-top: 1em">syntax where model can be 2232H,
4232H, 232H, jtagkey, busblaster, openmoko, arm-usb-tiny,
arm-usb-tiny-h, arm-usb-ocd, arm-usb-ocd-h, tumpa,
tumpalite, picotap, google- <br>
servo, google-servo-v2 or google-servo-v2-legacy and
interface can be A, B, C, or D. The default model is 4232H
and the default interface is A.</p>

<p style="margin-top: 1em">If there is more than one
ft2232_spi-compatible device connected, you can select which
one should be used by specifying its serial number with
the</p>

<p style="margin-top: 1em">flashrom -p
ft2232_spi:serial=number</p>

<p style="margin-top: 1em">syntax where number is the
serial number of the device (which can be found for example
in the output of lsusb -v).</p>

<p style="margin-top: 1em">All models supported by the
ft2232_spi driver can configure the SPI clock rate by
setting a divisor. The expressible divisors are all even
numbers between 2 and 2^17 <br>
(=131072) resulting in SPI clock frequencies of 6 MHz down
to about 92 Hz for 12 MHz inputs. The default divisor is set
to 2, but you can use another one by specifying the <br>
optional divisor parameter with the</p>

<p style="margin-top: 1em">flashrom -p
ft2232_spi:divisor=div</p>

<p style="margin-top: 1em">syntax.</p>

<p style="margin-top: 1em">serprog programmer <br>
This module supports all programmers speaking the serprog
protocol. This includes some Arduino-based devices as well
as various programmers by Urja Rannikko, Juhana <br>
Helovuo, Stefan Tauner, Chi Zhang and many others.</p>

<p style="margin-top: 1em">A mandatory parameter specifies
either a serial device (and baud rate) or an IP/port
combination for communicating with the programmer. The
device/baud combination has to <br>
start with dev= and separate the optional baud rate with a
colon. For example</p>

<p style="margin-top: 1em">flashrom -p
serprog:dev=/dev/ttyS0:115200</p>

<p style="margin-top: 1em">If no baud rate is given the
default values by the operating system/hardware will be
used. For IP connections you have to use the</p>

<p style="margin-top: 1em">flashrom -p
serprog:ip=ipaddr:port</p>

<p style="margin-top: 1em">syntax. In case the device
supports it, you can set the SPI clock frequency with the
optional spispeed parameter. The frequency is parsed as
hertz, unless an M, or k suf&acirc; <br>
fix is given, then megahertz or kilohertz are used
respectively. Example that sets the frequency to 2 MHz:</p>

<p style="margin-top: 1em">flashrom -p
serprog:dev=/dev/device:baud,spispeed=2M</p>

<p style="margin-top: 1em">More information about serprog
is available in serprog-protocol.txt in the source
distribution.</p>

<p style="margin-top: 1em">buspirate_spi programmer <br>
A required dev parameter specifies the Bus Pirate device
node and an optional spispeed parameter specifies the
frequency of the SPI bus. The parameter delimiter is a <br>
comma. Syntax is</p>

<p style="margin-top: 1em">flashrom -p
buspirate_spi:dev=/dev/device,spispeed=frequency</p>

<p style="margin-top: 1em">where frequency can be 30k,
125k, 250k, 1M, 2M, 2.6M, 4M or 8M (in Hz). The default is
the maximum frequency of 8 MHz.</p>

<p style="margin-top: 1em">An optional pullups parameter
specifies the use of the Bus Pirate internal pull-up
resistors. This may be needed if you are working with a
flash ROM chip that you have <br>
physically removed from the board. Syntax is</p>

<p style="margin-top: 1em">flashrom -p
buspirate_spi:pullups=state</p>

<p style="margin-top: 1em">where state can be on or off.
More information about the Bus Pirate pull-up resistors and
their purpose is available in a guide by dangerousprototypes
&acirc;&uml;http://dangerous&acirc; <br>

prototypes.com/docs/Practical_guide_to_Bus_Pirate_pull-up_resistors&acirc;&copy;.
Only the external supply voltage (Vpu) is supported as of
this writing.</p>

<p style="margin-top: 1em">pickit2_spi programmer <br>
An optional voltage parameter specifies the voltage the
PICkit2 should use. The default unit is Volt if no unit is
specified. You can use mV, millivolt, V or Volt as unit <br>
specifier. Syntax is</p>

<p style="margin-top: 1em">flashrom -p
pickit2_spi:voltage=value</p>

<p style="margin-top: 1em">where value can be 0V, 1.8V,
2.5V, 3.5V or the equivalent in mV.</p>

<p style="margin-top: 1em">An optional spispeed parameter
specifies the frequency of the SPI bus. Syntax is</p>

<p style="margin-top: 1em">flashrom -p
pickit2_spi:spispeed=frequency</p>

<p style="margin-top: 1em">where frequency can be 250k,
333k, 500k or 1M (in Hz). The default is a frequency of 1
MHz.</p>

<p style="margin-top: 1em">dediprog programmer <br>
An optional voltage parameter specifies the voltage the
Dediprog should use. The default unit is Volt if no unit is
specified. You can use mV, milliVolt, V or Volt as unit <br>
specifier. Syntax is</p>

<p style="margin-top: 1em">flashrom -p
dediprog:voltage=value</p>

<p style="margin-top: 1em">where value can be 0V, 1.8V,
2.5V, 3.5V or the equivalent in mV.</p>

<p style="margin-top: 1em">An optional device parameter
specifies which of multiple connected Dediprog devices
should be used. Please be aware that the order depends on
libusb&rsquo;s usb_get_busses() <br>
function and that the numbering starts at 0. Usage example
to select the second device:</p>

<p style="margin-top: 1em">flashrom -p
dediprog:device=1</p>

<p style="margin-top: 1em">An optional spispeed parameter
specifies the frequency of the SPI bus. The firmware on the
device needs to be 5.0.0 or newer. Syntax is</p>

<p style="margin-top: 1em">flashrom -p
dediprog:spispeed=frequency</p>

<p style="margin-top: 1em">where frequency can be 375k,
750k, 1.5M, 2.18M, 3M, 8M, 12M or 24M (in Hz). The default
is a frequency of 12 MHz.</p>

<p style="margin-top: 1em">An optional target parameter
specifies which target chip should be used. Syntax is</p>

<p style="margin-top: 1em">flashrom -p
dediprog:target=value</p>

<p style="margin-top: 1em">where value can be 1 or 2 to
select target chip 1 or 2 respectively. The default is
target chip 1.</p>

<p style="margin-top: 1em">rayer_spi programmer <br>
The default I/O base address used for the parallel port is
0x378 and you can use the optional iobase parameter to
specify an alternate base I/O address with the</p>

<p style="margin-top: 1em">flashrom -p
rayer_spi:iobase=baseaddr</p>

<p style="margin-top: 1em">syntax where baseaddr is base
I/O port address of the parallel port, which must be a
multiple of four. Make sure to not forget the &quot;0x&quot;
prefix for hexadecimal port <br>
addresses.</p>

<p style="margin-top: 1em">The default cable type is the
RayeR cable. You can use the optional type parameter to
specify the cable type with the</p>

<p style="margin-top: 1em">flashrom -p
rayer_spi:type=model</p>

<p style="margin-top: 1em">syntax where model can be rayer
for the RayeR cable, byteblastermv for the Altera
ByteBlasterMV, stk200 for the Atmel STK200/300, wiggler for
the Macraigor Wiggler, xilinx <br>
for the Xilinx Parallel Cable III (DLC 5), or spi_tt for SPI
Tiny Tools-compatible hardware.</p>

<p style="margin-top: 1em">More information about the RayeR
hardware is available at RayeR&rsquo;s website
&acirc;&uml;http://rayer.g6.cz/elektro/spipgm.htm&acirc;&copy;.
The Altera ByteBlasterMV datasheet can be obtained from <br>
Altera
&acirc;&uml;http://www.altera.co.jp/literature/ds/dsbytemv.pdf&acirc;&copy;.
For more information about the Macraigor Wiggler see their
company homepage <br>

&acirc;&uml;http://www.macraigor.com/wiggler.htm&acirc;&copy;.
The schematic of the Xilinx DLC 5 was published in a Xilinx
user guide <br>

&acirc;&uml;http://www.xilinx.com/support/documentation/user_guides/xtp029.pdf&acirc;&copy;.</p>

<p style="margin-top: 1em">pony_spi programmer <br>
The serial port (like /dev/ttyS0, /dev/ttyUSB0 on Linux or
COM3 on windows) is specified using the mandatory dev
parameter. The adapter type is selectable between SI-Prog
<br>
(used for SPI devices with PonyProg 2000) or a custom made
serial bitbanging programmer named &quot;serbang&quot;. The
optional type parameter accepts the values
&quot;si_prog&quot; (default) <br>
or &quot;serbang&quot;.</p>

<p style="margin-top: 1em">Information about the SI-Prog
adapter can be found at its website
&acirc;&uml;http://www.lancos.com/siprogsch.html&acirc;&copy;.</p>

<p style="margin-top: 1em">An example call to flashrom
is</p>

<p style="margin-top: 1em">flashrom -p
pony_spi:dev=/dev/ttyS0,type=serbang</p>

<p style="margin-top: 1em">Please note that while
USB-to-serial adapters work under certain circumstances,
this slows down operation considerably.</p>

<p style="margin-top: 1em">ogp_spi programmer <br>
The flash ROM chip to access must be specified with the rom
parameter.</p>

<p style="margin-top: 1em">flashrom -p ogp_spi:rom=name</p>

<p style="margin-top: 1em">Where name is either cprom or s3
for the configuration ROM and bprom or bios for the BIOS
ROM. If more than one card supported by the ogp_spi
programmer is installed in <br>
your system, you have to specify the PCI address of the card
you want to use with the pci= parameter as explained in the
nic3com et al. section above.</p>

<p style="margin-top: 1em">linux_spi programmer <br>
You have to specify the SPI controller to use with the</p>

<p style="margin-top: 1em">flashrom -p
linux_spi:dev=/dev/spidevX.Y</p>

<p style="margin-top: 1em">syntax where /dev/spidevX.Y is
the Linux device node for your SPI controller.</p>

<p style="margin-top: 1em">In case the device supports it,
you can set the SPI clock frequency with the optional
spispeed parameter. The frequency is parsed as kilohertz.
Example that sets the <br>
frequency to 8 MHz:</p>

<p style="margin-top: 1em">flashrom -p
linux_spi:dev=/dev/spidevX.Y,spispeed=8000</p>

<p style="margin-top: 1em">Please note that the linux_spi
driver only works on Linux.</p>

<p style="margin-top: 1em">mstarddc_spi programmer <br>
The Display Data Channel (DDC) is an I2C bus present on VGA
and DVI connectors, that allows exchanging information
between a computer and attached displays. Its most <br>
common uses are getting display capabilities through EDID
(at I2C address 0x50) and sending commands to the display
using the DDC/CI protocol (at address 0x37). On <br>
displays driven by MSTAR SoCs, it is also possible to access
the SoC firmware flash (connected to the Soc through another
SPI bus) using an In-System Programming (ISP) <br>
port, usually at address 0x49. This flashrom module allows
the latter via Linux&rsquo;s I2C driver.</p>

<p style="margin-top: 1em">IMPORTANT: Before using this
programmer, the display MUST be in standby mode, and only
connected to the computer that will run flashrom using a VGA
cable, to an inactive <br>
VGA output. It absolutely MUST NOT be used as a display
during the procedure!</p>

<p style="margin-top: 1em">You have to specify the DDC/I2C
controller and I2C address to use with the</p>

<p style="margin-top: 1em">flashrom -p
mstarddc_spi:dev=/dev/i2c-X:YY</p>

<p style="margin-top: 1em">syntax where /dev/i2c-X is the
Linux device node for your I2C controller connected to the
display&rsquo;s DDC channel, and YY is the (hexadecimal)
address of the MSTAR ISP port <br>
(address 0x49 is usually used). Example that uses I2C
controller /dev/i2c-1 and address 0x49:</p>

<p style="margin-top: 1em">flashrom -p
mstarddc_spi:dev=/dev/i2c-1:49</p>

<p style="margin-top: 1em">It is also possible to inhibit
the reset command that is normally sent to the display once
the flashrom operation is completed using the optional
noreset parameter. A <br>
value of 1 prevents flashrom from sending the reset command.
Example that does not reset the display at the end of the
operation:</p>

<p style="margin-top: 1em">flashrom -p
mstarddc_spi:dev=/dev/i2c-1:49,noreset=1</p>

<p style="margin-top: 1em">Please note that sending the
reset command is also inhibited if an error occurred during
the operation. To send the reset command afterwards, you can
simply run flashrom <br>
once more, in chip probe mode (not specifying an operation),
without the noreset parameter, once the flash read/write
operation you intended to perform has completed <br>
successfully.</p>

<p style="margin-top: 1em">Please also note that the
mstarddc_spi driver only works on Linux.</p>

<p style="margin-top: 1em">ch341a_spi programmer <br>
The WCH CH341A programmer does not support any parameters
currently. SPI frequency is fixed at 2 MHz, and CS0 is used
as per the device.</p>

<p style="margin-top: 1em">EXAMPLES <br>
To back up and update your BIOS, run</p>

<p style="margin-top: 1em">flashrom -p internal -r
backup.rom -o backuplog.txt <br>
flashrom -p internal -w newbios.rom -o writelog.txt</p>

<p style="margin-top: 1em">Please make sure to copy
backup.rom to some external media before you try to write.
That makes offline recovery easier. <br>
If writing fails and flashrom complains about the chip being
in an unknown state, you can try to restore the backup by
running</p>

<p style="margin-top: 1em">flashrom -p internal -w
backup.rom -o restorelog.txt</p>

<p style="margin-top: 1em">If you encounter any problems,
please contact us and supply backuplog.txt, writelog.txt and
restorelog.txt. See section BUGS for contact info.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
flashrom exits with 0 on success, 1 on most failures but
with 3 if a call to mmap() fails.</p>

<p style="margin-top: 1em">REQUIREMENTS <br>
flashrom needs different access permissions for different
programmers.</p>

<p style="margin-top: 1em">internal needs raw memory
access, PCI configuration space access, raw I/O port access
(x86) and MSR access (x86).</p>

<p style="margin-top: 1em">atavia needs PCI configuration
space access.</p>

<p style="margin-top: 1em">nic3com, nicrealtek and
nicnatsemi need PCI configuration space read access and raw
I/O port access.</p>

<p style="margin-top: 1em">atahpt needs PCI configuration
space access and raw I/O port access.</p>

<p style="margin-top: 1em">gfxnvidia, drkaiser and it8212
need PCI configuration space access and raw memory
access.</p>

<p style="margin-top: 1em">rayer_spi needs raw I/O port
access.</p>

<p style="margin-top: 1em">satasii, nicintel,
nicintel_eeprom and nicintel_spi need PCI configuration
space read access and raw memory access.</p>

<p style="margin-top: 1em">satamv and atapromise need PCI
configuration space read access, raw I/O port access and raw
memory access.</p>

<p style="margin-top: 1em">serprog needs TCP access to the
network or userspace access to a serial port.</p>

<p style="margin-top: 1em">buspirate_spi needs userspace
access to a serial port.</p>

<p style="margin-top: 1em">ft2232_spi, usbblaster_spi and
pickit2_spi need access to the respective USB device via
libusb API version 0.1.</p>

<p style="margin-top: 1em">ch341a_spi and dediprog need
access to the respective USB device via libusb API version
1.0.</p>

<p style="margin-top: 1em">dummy needs no access
permissions at all.</p>

<p style="margin-top: 1em">internal, nic3com, nicrealtek,
nicnatsemi, gfxnvidia, drkaiser, satasii, satamv, atahpt,
atavia and atapromise have to be run as superuser/root, and
need additional raw access <br>
permission.</p>

<p style="margin-top: 1em">serprog, buspirate_spi,
dediprog, usbblaster_spi, ft2232_spi, pickit2_spi and
ch341a_spi can be run as normal user on most operating
systems if appropriate device permissions are <br>
set.</p>

<p style="margin-top: 1em">ogp needs PCI configuration
space read access and raw memory access.</p>

<p style="margin-top: 1em">On OpenBSD, you can obtain raw
access permission by setting securelevel=-1 in
/etc/rc.securelevel and rebooting, or rebooting into single
user mode.</p>

<p style="margin-top: 1em">BUGS <br>
Please report any bugs to the flashrom mailing list
&acirc;&uml;flashrom@flashrom.org&acirc;&copy;.</p>

<p style="margin-top: 1em">We recommend to subscribe first
at https://flashrom.org/mailman/listinfo/flashrom.</p>

<p style="margin-top: 1em">Many of the developers
communicate via the #flashrom IRC channel on
chat.freenode.net. If you don&rsquo;t have an IRC client,
you can use the freenode webchat <br>

&acirc;&uml;http://webchat.freenode.net/?channels=flashrom&acirc;&copy;.
You are welcome to join and ask questions, send us bug and
success reports there too. Please provide a way to contact
you later <br>
(e.g. a mail address) and be patient if there is no
immediate reaction. Also, we provide a pastebin service
&acirc;&uml;https://paste.flashrom.org&acirc;&copy; that is
very useful when you want to <br>
share logs etc. without spamming the channel.</p>

<p style="margin-top: 1em">Laptops <br>
Using flashrom on laptops is dangerous and may easily make
your hardware unusable. flashrom will attempt to detect if
it is running on a laptop and abort immediately for safety
<br>
reasons. Please see the detailed discussion of this topic
and associated flashrom options in the Laptops paragraph in
the internal programmer subsection of the PROGRAMMER- <br>
SPECIFIC INFORMATION section and the information in our wiki
&acirc;&uml;https://flashrom.org/Laptops&acirc;&copy;.</p>

<p style="margin-top: 1em">One-time programmable (OTP)
memory and unique IDs <br>
Some flash chips contain OTP memory often denoted as
&quot;security registers&quot;. They usually have a capacity
in the range of some bytes to a few hundred bytes and can be
used to give <br>
devices unique IDs etc. flashrom is not able to read or
write these memories and may therefore not be able to
duplicate a chip completely. For chip types known to include
OTP <br>
memories a warning is printed when they are detected.</p>

<p style="margin-top: 1em">Similar to OTP memories are
unique, factory programmed, unforgeable IDs. They are not
modifiable by the user at all.</p>

<p style="margin-top: 1em">LICENSE <br>
flashrom is covered by the GNU General Public License (GPL),
version 2. Some files are additionally available under any
later version of the GPL.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Please see the individual files.</p>

<p style="margin-top: 1em">AUTHORS <br>
Andrew Morgan <br>
Carl-Daniel Hailfinger <br>
Claus Gindhart <br>
David Borg <br>
David Hendricks <br>
Dominik Geyer <br>
Eric Biederman <br>
Giampiero Giancipoli <br>
Helge Wagner <br>
Idwer Vollering <br>
Joe Bao <br>
Joerg Fischer <br>
Joshua Roys <br>
Ky&Atilde;&para;sti M&Atilde;&curren;lkki <br>
Luc Verhaegen <br>
Li-Ta Lo <br>
Mark Marshall <br>
Markus Boas <br>
Mattias Mattsson <br>
Michael Karcher <br>
Nikolay Petukhov <br>
Patrick Georgi <br>
Peter Lemenkov <br>
Peter Stuge <br>
Reinder E.N. de Haan <br>
Ronald G. Minnich <br>
Ronald Hoogenboom <br>
Sean Nelson <br>
Stefan Reinauer <br>
Stefan Tauner <br>
Stefan Wildemann <br>
Stephan Guilloux <br>
Steven James <br>
Urja Rannikko <br>
Uwe Hermann <br>
Wang Qingpei <br>
Yinghai Lu <br>
some others, please see the flashrom svn changelog for
details. <br>
All still active authors can be reached via the mailing list
&acirc;&uml;flashrom@flashrom.org&acirc;&copy;.</p>

<p style="margin-top: 1em">This manual page was written by
Uwe Hermann &acirc;&uml;uwe@hermann-uwe.de&acirc;&copy;,
Carl-Daniel Hailfinger, Stefan Tauner and others. It is
licensed under the terms of the GNU GPL (version 2 or <br>
later).</p>

<p style="margin-top: 1em">0.9.9-r1954 2016-04-26
FLASHROM(8)</p>
<hr>
</body>
</html>
