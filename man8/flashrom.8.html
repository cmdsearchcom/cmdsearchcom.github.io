<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>FLASHROM(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">FLASHROM(8)</td>
    <td class="head-vol">System Manager's Manual</td>
    <td class="head-rtitle">FLASHROM(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
flashrom - detect, read, write, verify and erase flash chips
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>flashrom [<b>-h</b>|<b>-R</b>|<b>-L</b>|<b>-z</b>|<b>-p</b>
  &lt;programmername&gt;[:&lt;parameters&gt;]</b>
<br/>
 [ <b>-E</b>|<b>-r</b> &lt;file&gt;|<b>-w</b> &lt;file&gt;|<b>-v</b>
  &lt;file&gt;] [ <b>-c</b> &lt;chipname&gt;]
<br/>
 [ <b>-l</b> &lt;file&gt; [<b>-i</b> &lt;image&gt;]] [<b>-n</b>] [<b>-f</b>]]
<br/>
 [ <b>-V</b>[<b>V</b>[<b>V</b>]]] [<b>-o</b> &lt;logfile&gt;]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>flashrom</b> is a utility for detecting, reading, writing, verifying and
  erasing flash chips. It's often used to flash BIOS/EFI/coreboot/firmware
  images in-system using a supported mainboard. However, it also supports
  various external PCI/USB/parallel-port/serial-port based devices which can
  program flash chips, including some network cards (NICs), SATA/IDE controller
  cards, graphics cards, the Bus Pirate device, various FTDI
  FT2232/FT4232H/FT232H based USB devices, and more.
<div class="Pp"></div>
It supports a wide range of DIP32, PLCC32, DIP8, SO8/SOIC8, TSOP32, TSOP40,
  TSOP48, and BGA chips, which use various protocols such as LPC, FWH, parallel
  flash, or SPI.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<b>IMPORTANT:</b> Please note that the command line interface for flashrom will
  change before flashrom 1.0. Do not use flashrom in scripts or other automated
  tools without checking that your flashrom version won't interpret options in a
  different way.
<div class="Pp"></div>
You can specify one of <b>-h</b>, <b>-R</b>, <b>-L</b>, <b>-z</b>, <b>-E</b>,
  <b>-r</b>, <b>-w</b>, <b>-v</b> or no operation. If no operation is specified,
  flashrom will only probe for flash chips. It is recommended that if you try
  flashrom the first time on a system, you run it in probe-only mode and check
  the output. Also you are advised to make a backup of your current ROM contents
  with <b>-r</b> before you try to write a new image. All operations involving
  any chip access (probe/read/write/...) require the <b>-p/--programmer</b>
  option to be used (please see below).
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r, --read &lt;file&gt;</b></dt>
  <dd class="It-tag">Read flash ROM contents and save them into the given
      <b>&lt;file&gt;</b>. If the file already exists, it will be
    overwritten.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w, --write &lt;file&gt;</b></dt>
  <dd class="It-tag">Write <b>&lt;file&gt;</b> into flash ROM. This will first
      automatically <b>erase</b> the chip, then write to it.
    <div style="height: 1.00em;">&#x00A0;</div>
    In the process the chip is also read several times. First an in-memory
      backup is made for disaster recovery and to be able to skip regions that
      are already equal to the image file. This copy is updated along with the
      write operation. In case of erase errors it is even re-read completely.
      After writing has finished and if verification is enabled, the whole flash
      chip is read out and compared with the input image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n, --noverify</b></dt>
  <dd class="It-tag">Skip the automatic verification of flash ROM contents after
      writing. Using this option is <b>not</b> recommended, you should only use
      it if you know what you are doing and if you feel that the time for
      verification takes too long.
    <div style="height: 1.00em;">&#x00A0;</div>
    Typical usage is: <b>flashrom -p prog -n -w &lt;file&gt;</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is only useful in combination with <b>--write</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v, --verify &lt;file&gt;</b></dt>
  <dd class="It-tag">Verify the flash ROM contents against the given
      <b>&lt;file&gt;</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E, --erase</b></dt>
  <dd class="It-tag">Erase the flash ROM chip.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V, --verbose</b></dt>
  <dd class="It-tag">More verbose output. This option can be supplied multiple
      times (max. 3 times, i.e. <b>-VVV</b>) for even more debug output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c, --chip &lt;chipname&gt;</b></dt>
  <dd class="It-tag">Probe only for the specified flash ROM chip. This option
      takes the chip name as printed by <b>flashrom -L</b> without the vendor
      name as parameter. Please note that the chip name is case sensitive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f, --force</b></dt>
  <dd class="It-tag">Force one or more of the following actions:
    <div style="height: 1.00em;">&#x00A0;</div>
    * Force chip read and pretend the chip is there.
    <div style="height: 1.00em;">&#x00A0;</div>
    * Force chip access even if the chip is bigger than the maximum supported
      size for the flash bus.
    <div style="height: 1.00em;">&#x00A0;</div>
    * Force erase even if erase is known bad.
    <div style="height: 1.00em;">&#x00A0;</div>
    * Force write even if write is known bad.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l, --layout &lt;file&gt;</b></dt>
  <dd class="It-tag">Read ROM layout from <b>&lt;file&gt;</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    flashrom supports ROM layouts. This allows you to flash certain parts of the
      flash chip only. A ROM layout file contains multiple lines with the
      following syntax:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> startaddr:endaddr imagename</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>startaddr </b>and <b>endaddr </b> are hexadecimal addresses within the
      ROM file and do not refer to any physical address. Please note that using
      a 0x prefix for those hexadecimal numbers is not necessary, but you can't
      specify decimal/octal numbers. <b>imagename </b>is an arbitrary name for
      the region/image from <b> startaddr </b>to <b>endaddr </b>(both addresses
      included).
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     00000000:00008fff gfxrom
    <br/>
     00009000:0003ffff normal
    <br/>
     00040000:0007ffff fallback
    <div style="height: 1.00em;">&#x00A0;</div>
    If you only want to update the image named <b>normal </b>in a ROM based on
      the layout above, run
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p prog --layout rom.layout --image normal -w some.rom</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    To update only the images named <b>normal </b>and <b>fallback</b>, run:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p prog -l rom.layout -i normal -i fallback -w some.rom</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Overlapping sections are not supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i, --image &lt;imagename&gt;</b></dt>
  <dd class="It-tag">Only flash region/image <b>&lt;imagename&gt;</b> from flash
      layout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L, --list-supported</b></dt>
  <dd class="It-tag">List the flash chips, chipsets, mainboards, and external
      programmers (including PCI, USB, parallel port, and serial port based
      devices) supported by flashrom.
    <div style="height: 1.00em;">&#x00A0;</div>
    There are many unlisted boards which will work out of the box, without
      special support in flashrom. Please let us know if you can verify that
      other boards work or do not work out of the box.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>IMPORTANT:</b> For verification you have to test an ERASE and/or WRITE
      operation, so make sure you only do that if you have proper means to
      recover from failure!</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-z, --list-supported-wiki</b></dt>
  <dd class="It-tag">Same as <b>--list-supported</b>, but outputs the supported
      hardware in MediaWiki syntax, so that it can be easily pasted into the
      supported hardware wiki page
      &#x27E8;<b>https://flashrom.org/Supported_hardware</b>&#x27E9;. Please
      note that MediaWiki output is not compiled in by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p, --programmer
    &lt;name&gt;[:parameter[,parameter[,parameter]]]</b></dt>
  <dd class="It-tag">Specify the programmer device. This is mandatory for all
      operations involving any chip access (probe/read/write/...). Currently
      supported are:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* internal</b> (for in-system flashing in the mainboard)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* dummy</b> (virtual programmer for testing flashrom)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* nic3com</b> (for flash ROMs on 3COM network cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* nicrealtek</b> (for flash ROMs on Realtek and SMC 1211 network cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* nicnatsemi</b> (for flash ROMs on National Semiconductor DP838* network
      cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* nicintel</b> (for parallel flash ROMs on Intel 10/100Mbit network
      cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* gfxnvidia</b> (for flash ROMs on NVIDIA graphics cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* drkaiser</b> (for flash ROMs on Dr. Kaiser PC-Waechter PCI cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* satasii</b> (for flash ROMs on Silicon Image SATA/IDE controllers)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* satamv</b> (for flash ROMs on Marvell SATA controllers)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* atahpt</b> (for flash ROMs on Highpoint ATA/RAID controllers)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* atavia</b> (for flash ROMs on VIA VT6421A SATA controllers)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* atapromise</b> (for flash ROMs on Promise PDC2026x ATA/RAID
      controllers)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* it8212</b> (for flash ROMs on ITE IT8212F ATA/RAID controller)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* ft2232_spi</b> (for SPI flash ROMs attached to an FT2232/FT4232H/FT232H
      family based USB SPI programmer).
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* serprog</b> (for flash ROMs attached to a programmer speaking serprog,
      including some Arduino-based devices).
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* buspirate_spi</b> (for SPI flash ROMs attached to a Bus Pirate)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* dediprog</b> (for SPI flash ROMs attached to a Dediprog SF100)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* rayer_spi</b> (for SPI flash ROMs attached to a parallel port by one of
      various cable types)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* pony_spi</b> (for SPI flash ROMs attached to a SI-Prog serial port
      bitbanging adapter)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* nicintel_spi</b> (for SPI flash ROMs on Intel Gigabit network cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* ogp_spi</b> (for SPI flash ROMs on Open Graphics Project graphics card)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* linux_spi</b> (for SPI flash ROMs accessible via /dev/spidevX.Y on
      Linux)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* usbblaster_spi</b> (for SPI flash ROMs attached to an Altera
      USB-Blaster compatible cable)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* nicintel_eeprom</b> (for SPI EEPROMs on Intel Gigabit network cards)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* mstarddc_spi</b> (for SPI flash ROMs accessible through DDC in
      MSTAR-equipped displays)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* pickit2_spi</b> (for SPI flash ROMs accessible via Microchip PICkit2)
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>* ch341a_spi</b> (for SPI flash ROMs attached to WCH CH341A)
    <div style="height: 1.00em;">&#x00A0;</div>
    Some programmers have optional or mandatory parameters which are described
      in detail in the <b>PROGRAMMER-SPECIFIC INFORMATION</b> section. Support
      for some programmers can be disabled at compile time. <b>flashrom -h</b>
      lists all supported programmers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h, --help</b></dt>
  <dd class="It-tag">Show a help text and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o, --output &lt;logfile&gt;</b></dt>
  <dd class="It-tag">Save the full debug log to <b>&lt;logfile&gt;</b>. If the
      file already exists, it will be overwritten. This is the recommended way
      to gather logs from flashrom because they will be verbose even if the
      on-screen messages are not verbose and don't require output
    redirection.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R, --version</b></dt>
  <dd class="It-tag">Show version information and exit.</dd>
</dl>
<h1 class="Sh" title="Sh" id="PROGRAMMER-SPECIFIC_INFORMATION"><a class="selflink" href="#PROGRAMMER-SPECIFIC_INFORMATION">PROGRAMMER-SPECIFIC
  INFORMATION</a></h1>
Some programmer drivers accept further parameters to set programmer-specific
  parameters. These parameters are separated from the programmer name by a
  colon. While some programmers take arguments at fixed positions, other
  programmers use a key/value interface in which the key and value is separated
  by an equal sign and different pairs are separated by a comma or a colon.
<h2 class="Ss" title="Ss"><b>internal </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Board Enables</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    Some mainboards require to run mainboard specific code to enable flash erase
      and write support (and probe support on old systems with parallel flash).
      The mainboard brand and model (if it requires specific code) is usually
      autodetected using one of the following mechanisms: If your system is
      running coreboot, the mainboard type is determined from the coreboot
      table. Otherwise, the mainboard is detected by examining the onboard PCI
      devices and possibly DMI info. If PCI and DMI do not contain information
      to uniquely identify the mainboard (which is the exception), or if you
      want to override the detected mainboard model, you can specify the
      mainboard using the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:mainboard=&lt;vendor&gt;:&lt;board&gt;</b> syntax.
    <div style="height: 1.00em;">&#x00A0;</div>
    See the 'Known boards' or 'Known laptops' section in the output of 'flashrom
      -L' for a list of boards which require the specification of the board
      name, if no coreboot table is found.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some of these board-specific flash enabling functions (called <b>board
      enables</b>) in flashrom have not yet been tested. If your mainboard is
      detected needing an untested board enable function, a warning message is
      printed and the board enable is not executed, because a wrong board enable
      function might cause the system to behave erratically, as board enable
      functions touch the low-level internals of a mainboard. Not executing a
      board enable function (if one is needed) might cause detection or erasing
      failure. If your board protects only part of the flash (commonly the top
      end, called boot block), flashrom might encounter an error only after
      erasing the unprotected part, so running without the board-enable function
      might be dangerous for erase and write (which includes erase).
    <div style="height: 1.00em;">&#x00A0;</div>
    The suggested procedure for a mainboard with untested board specific code is
      to first try to probe the ROM (just invoke flashrom and check that it
      detects your flash chip type) without running the board enable code (i.e.
      without any parameters). If it finds your chip, fine. Otherwise, retry
      probing your chip with the board-enable code running, using
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:boardenable=force</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    If your chip is still not detected, the board enable code seems to be broken
      or the flash chip unsupported. Otherwise, make a backup of your current
      ROM contents (using <b>-r</b>) and store it to a medium outside of your
      computer, like a USB drive or a network share. If you needed to run the
      board enable code already for probing, use it for reading too. If reading
      succeeds and the contens of the read file look legit you can try to write
      the new image. You should enable the board enable code in any case now, as
      it has been written because it is known that writing/erasing without the
      board enable is going to fail. In any case (success or failure), please
      report to the flashrom mailing list, see below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Coreboot</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    On systems running coreboot, flashrom checks whether the desired image
      matches your mainboard. This needs some special board ID to be present in
      the image. If flashrom detects that the image you want to write and the
      current board do not match, it will refuse to write the image unless you
      specify
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:boardmismatch=force</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ITE IT87 Super I/O</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    If your mainboard is manufactured by GIGABYTE and supports DualBIOS it is
      very likely that it uses an ITE IT87 series Super I/O to switch between
      the two flash chips. Only one of them can be accessed at a time and you
      can manually select which one to use with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:dualbiosindex=chip</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>chip</b> is the index of the chip to use (0 = main, 1 =
      backup). You can check which one is currently selected by leaving out the
      <b>chip</b> parameter.
    <div style="height: 1.00em;">&#x00A0;</div>
    If your mainboard uses an ITE IT87 series Super I/O for LPC&lt;-&gt;SPI
      flash bus translation, flashrom should autodetect that configuration. If
      you want to set the I/O base port of the IT87 series SPI controller
      manually instead of using the value provided by the BIOS, use the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:it87spiport=portnum</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>portnum</b> is the I/O port number (must be a multiple of
      8). In the unlikely case flashrom doesn't detect an active IT87
      LPC&lt;-&gt;SPI bridge, please send a bug report so we can diagnose the
      problem.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>AMD chipsets</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    Beginning with the SB700 chipset there is an integrated microcontroller
      (IMC) based on the 8051 embedded in every AMD southbridge. Its firmware
      resides in the same flash chip as the host's which makes writing to the
      flash risky if the IMC is active. Flashrom tries to temporarily disable
      the IMC but even then changing the contents of the flash can have unwanted
      effects: when the IMC continues (at the latest after a reboot) it will
      continue executing code from the flash. If the code was removed or changed
      in an unfortunate way it is unpredictable what the IMC will do. Therefore,
      if flashrom detects an active IMC it will disable write support unless the
      user forces it with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:amd_imc_force=yes</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax. The user is responsible for supplying a suitable image or leaving
      out the IMC region with the help of a layout file. This limitation might
      be removed in the future when we understand the details better and have
      received enough feedback from users. Please report the outcome if you had
      to use this option to write a chip.
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional <b>spispeed</b> parameter specifies the frequency of the SPI bus
      where applicable (i.e. SB600 or later with an SPI flash chip directly
      attached to the chipset). Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:spispeed=frequency</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>frequency</b> can be <b>'16.5&#x00A0;MHz'</b>,
      <b>'22&#x00A0;MHz'</b>, <b>'33&#x00A0;MHz'</b>, <b>'66&#x00A0;MHz'</b>,
      <b>'100&#x00A0;MHZ'</b>, or <b>'800&#x00A0;kHz'</b>. Support of individual
      frequencies depends on the generation of the chipset:
    <div style="height: 1.00em;">&#x00A0;</div>
    * SB6xx, SB7xx, SP5xxx: from 16.5 MHz up to and including 33 MHz
    <div style="height: 1.00em;">&#x00A0;</div>
    * SB8xx, SB9xx, Hudson: from 16.5 MHz up to and including 66 MHz
    <div style="height: 1.00em;">&#x00A0;</div>
    * Yangtze (with SPI 100 engine as found in Kabini and Tamesh): all of them
    <div style="height: 1.00em;">&#x00A0;</div>
    The default is to use 16.5 MHz and disable Fast Reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Intel chipsets</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    If you have an Intel chipset with an ICH8 or later southbridge with SPI
      flash attached, and if a valid descriptor was written to it (e.g. by the
      vendor), the chipset provides an alternative way to access the flash
      chip(s) named <b>Hardware Sequencing</b>. It is much simpler than the
      normal access method (called <b>Software Sequencing</b>), but does not
      allow the software to choose the SPI commands to be sent. You can use the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:ich_spi_mode=value</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>value </b>can be <b>auto</b>, <b>swseq</b> or <b>hwseq</b>.
      By default (or when setting <b>ich_spi_mode=auto</b>) the module tries to
      use swseq and only activates hwseq if need be (e.g. if important opcodes
      are inaccessible due to lockdown; or if more than one flash chip is
      attached). The other options (swseq, hwseq) select the respective mode (if
      possible).
    <div style="height: 1.00em;">&#x00A0;</div>
    ICH8 and later southbridges may also have locked address ranges of different
      kinds if a valid descriptor was written to it. The flash address space is
      then partitioned in multiple so called &quot;Flash Regions&quot;
      containing the host firmware, the ME firmware and so on respectively. The
      flash descriptor can also specify up to 5 so called &quot;Protected
      Regions&quot;, which are freely chosen address ranges independent from the
      aforementioned &quot;Flash Regions&quot;. All of them can be write and/or
      read protected individually. If flashrom detects such a lock it will
      disable write support unless the user forces it with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:ich_spi_force=yes</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax. If this leads to erase or write accesses to the flash it would most
      probably bring it into an inconsistent and unbootable state and we will
      not provide any support in such a case.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you have an Intel chipset with an ICH2 or later southbridge and if you
      want to set specific IDSEL values for a non-default flash chip or an
      embedded controller (EC), you can use the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:fwh_idsel=value</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>value</b> is the 48-bit hexadecimal raw value to be written
      in the IDSEL registers of the Intel southbridge. The upper 32 bits use one
      hex digit each per 512 kB range between 0xffc00000 and 0xffffffff, and the
      lower 16 bits use one hex digit each per 1024 kB range between 0xff400000
      and 0xff7fffff. The rightmost hex digit corresponds with the lowest
      address range. All address ranges have a corresponding sister range 4 MB
      below with identical IDSEL settings. The default value for ICH7 is given
      in the example below.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example: <b>flashrom -p internal:fwh_idsel=0x001122334567</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Laptops</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    Using flashrom on laptops is dangerous and may easily make your hardware
      unusable (see also the <b>BUGS</b> section). The embedded controller (EC)
      in these machines often interacts badly with flashing. More information is
      in the wiki &#x27E8;<b>https://flashrom.org/Laptops</b>&#x27E9;. For
      example the EC firmware sometimes resides on the same flash chip as the
      host firmware. While flashrom tries to change the contents of that memory
      the EC might need to fetch new instructions or data from it and could stop
      working correctly. Probing for and reading from the chip may also irritate
      your EC and cause fan failure, backlight failure, sudden poweroff, and
      other nasty effects. flashrom will attempt to detect if it is running on a
      laptop and abort immediately for safety reasons if it clearly identifies
      the host computer as one. If you want to proceed anyway at your own risk,
      use
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:laptop=force_I_want_a_brick</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    We will not help you if you force flashing on a laptop because this is a
      really dumb idea.
    <div style="height: 1.00em;">&#x00A0;</div>
    You have been warned.
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently we rely on the chassis type encoded in the DMI/SMBIOS data to
      detect laptops. Some vendors did not implement those bits correctly or set
      them to generic and/or dummy values. flashrom will then issue a warning
      and bail out like above. In this case you can use
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p internal:laptop=this_is_not_a_laptop</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    to tell flashrom (at your own risk) that it is not running on a laptop.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>dummy </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The dummy programmer operates on a buffer in memory only.
      It provides a safe and fast way to test various aspects of flashrom and is
      mainly used in development and while debugging. It is able to emulate some
      chips to a certain degree (basic identify/read/erase/write operations
      work).
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional parameter specifies the bus types it should support. For that
      you have to use the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:bus=[type[+type[+type]]]</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>type</b> can be <b>parallel</b>, <b>lpc</b>, <b>fwh</b>,
      <b>spi</b> in any order. If you specify bus without type, all buses will
      be disabled. If you do not specify bus, all buses will be enabled.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example: <b>flashrom -p dummy:bus=lpc+fwh</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    The dummy programmer supports flash chip emulation for automated self-tests
      without hardware access. If you want to emulate a flash chip, use the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:emulate=chip</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>chip</b> is one of the following chips (please specify only
      the chip name, not the vendor):
    <div style="height: 1.00em;">&#x00A0;</div>
    * ST <b>M25P10.RES</b> SPI flash chip (128 kB, RES, page write)
    <div style="height: 1.00em;">&#x00A0;</div>
    * SST <b>SST25VF040.REMS</b> SPI flash chip (512 kB, REMS, byte write)
    <div style="height: 1.00em;">&#x00A0;</div>
    * SST <b>SST25VF032B</b> SPI flash chip (4096 kB, RDID, AAI write)
    <div style="height: 1.00em;">&#x00A0;</div>
    * Macronix <b>MX25L6436</b> SPI flash chip (8192 kB, RDID, SFDP)
    <div style="height: 1.00em;">&#x00A0;</div>
    Example: <b>flashrom -p dummy:emulate=SST25VF040.REMS</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Persistent images</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    If you use flash chip emulation, flash image persistence is available as
      well by using the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:emulate=chip,image=image.rom</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>image.rom</b> is the file where the simulated chip contents
      are read on flashrom startup and where the chip contents on flashrom
      shutdown are written to.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example: <b>flashrom -p dummy:emulate=M25P10.RES,image=dummy.bin</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SPI write chunk size</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    If you use SPI flash chip emulation for a chip which supports SPI page write
      with the default opcode, you can set the maximum allowed write chunk size
      with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:emulate=chip,spi_write_256_chunksize=size</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>size</b> is the number of bytes (min. 1, max. 256).
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:emulate=M25P10.RES,spi_write_256_chunksize=5</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SPI blacklist</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    To simulate a programmer which refuses to send certain SPI commands to the
      flash chip, you can specify a blacklist of SPI commands with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:spi_blacklist=commandlist</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>commandlist</b> is a list of two-digit hexadecimal
      representations of SPI commands. If commandlist is e.g. 0302, flashrom
      will behave as if the SPI controller refuses to run command 0x03 (READ)
      and command 0x02 (WRITE). commandlist may be up to 512 characters (256
      commands) long. Implementation note: flashrom will detect an error during
      command execution.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SPI ignorelist</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    To simulate a flash chip which ignores (doesn't support) certain SPI
      commands, you can specify an ignorelist of SPI commands with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:spi_ignorelist=commandlist</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>commandlist</b> is a list of two-digit hexadecimal
      representations of SPI commands. If commandlist is e.g. 0302, the emulated
      flash chip will ignore command 0x03 (READ) and command 0x02 (WRITE).
      commandlist may be up to 512 characters (256 commands) long.
      Implementation note: flashrom won't detect an error during command
      execution.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SPI status register</b></dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    You can specify the initial content of the chip's status register with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dummy:spi_status=content</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>content</b> is an 8-bit hexadecimal value.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>nic3com</b>,<b> nicrealtek</b>,<b>
  nicnatsemi</b>,<b> nicintel</b>,<b> nicintel_eeprom</b>,<b>
  nicintel_spi</b>,<b> gfxnvidia</b>,<b> ogp_spi</b>,<b> drkaiser</b>,<b>
  satasii</b>,<b> satamv</b>,<b> atahpt</b>,<b> atavia </b>,<b> atapromise
  </b>and<b> it8212 </b>programmers</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">These programmers have an option to specify the PCI address
      of the card your want to use, which must be specified if more than one
      card supported by the selected programmer is installed in your system. The
      syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p xxxx:pci=bb:dd.f</b>,
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>xxxx</b> is the name of the programmer, <b>bb</b> is the PCI bus
      number, <b>dd</b> is the PCI device number, and <b>f</b> is the PCI
      function number of the desired device.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example: <b>flashrom -p nic3com:pci=05:04.0</b></dd>
</dl>
<h2 class="Ss" title="Ss"><b>atavia </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Due to the mysterious address handling of the VIA VT6421A
      controller the user can specify an offset with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p atavia:offset=addr</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>addr</b> will be interpreted as usual (leading 0x (0) for
      hexadecimal (octal) values, or else decimal). For more information please
      see its wiki page
    &#x27E8;<b>https://flashrom.org/VT6421A</b>&#x27E9;.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>atapromise </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This programmer is currently limited to 32 kB, regardless
      of the actual size of the flash chip. This stems from the fact that, on
      the tested device (a Promise Ultra100), not all of the chip's address
      lines were actually connected. You may use this programmer to flash
      firmware updates, since these are only 16 kB in size (padding to 32 kB is
      required).</dd>
</dl>
<h2 class="Ss" title="Ss"><b>nicintel_eeprom </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This is the first programmer module in flashrom that does
      not provide access to NOR flash chips but EEPROMs mounted on gigabit
      Ethernet cards based on Intel's 82580 NIC. Because EEPROMs normally do not
      announce their size nor allow themselves to be identified, the controller
      relies on correct size values written to predefined addresses within the
      chip. Flashrom follows this scheme but assumes the minimum size of 16 kB
      (128 kb) if an unprogrammed EEPROM/card is detected. Intel specifies
      following EEPROMs to be compatible: Atmel AT25128, AT25256, Micron (ST)
      M95128, M95256 and OnSemi (Catalyst) CAT25CS128.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>ft2232_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This module supports various programmers based on FTDI
      FT2232/FT4232H/FT232H chips including the DLP Design DLP-USB1232H,
      openbiosprog-spi, Amontec JTAGkey/JTAGkey-tiny/JTAGkey-2, Dangerous
      Prototypes Bus Blaster, Olimex ARM-USB-TINY/-H, Olimex ARM-USB-OCD/-H,
      OpenMoko Neo1973 Debug board (V2+), TIAO/DIYGADGET USB Multi-Protocol
      Adapter (TUMPA), TUMPA Lite, GOEPEL PicoTAP and Google Servo v1/v2.
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional parameter specifies the controller type and
      channel/interface/port it should support. For that you have to use the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p ft2232_spi:type=model,port=interface</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>model</b> can be <b>2232H</b>, <b>4232H</b>, <b>232H</b>,
      <b>jtagkey</b>, <b>busblaster</b>, <b>openmoko</b>, <b>arm-usb-tiny</b>,
      <b>arm-usb-tiny-h</b>, <b>arm-usb-ocd</b>, <b>arm-usb-ocd-h</b>,
      <b>tumpa</b>, <b>tumpalite</b>, <b>picotap</b>, <b>google-servo</b>,
      <b>google-servo-v2</b> or <b>google-servo-v2-legacy</b> and
      <b>interface</b> can be <b>A</b>, <b>B</b>, <b>C</b>, or <b>D</b>. The
      default model is <b>4232H</b> and the default interface is <b>A</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If there is more than one ft2232_spi-compatible device connected, you can
      select which one should be used by specifying its serial number with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p ft2232_spi:serial=number</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>number</b> is the serial number of the device (which can be
      found for example in the output of lsusb -v).
    <div style="height: 1.00em;">&#x00A0;</div>
    All models supported by the ft2232_spi driver can configure the SPI clock
      rate by setting a divisor. The expressible divisors are all <b>even</b>
      numbers between 2 and 2^17 (=131072) resulting in SPI clock frequencies of
      6 MHz down to about 92 Hz for 12 MHz inputs. The default divisor is set to
      2, but you can use another one by specifying the optional <b>divisor</b>
      parameter with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p ft2232_spi:divisor=div</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>serprog </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This module supports all programmers speaking the serprog
      protocol. This includes some Arduino-based devices as well as various
      programmers by Urja Rannikko, Juhana Helovuo, Stefan Tauner, Chi Zhang and
      many others.
    <div style="height: 1.00em;">&#x00A0;</div>
    A mandatory parameter specifies either a serial device (and baud rate) or an
      IP/port combination for communicating with the programmer. The device/baud
      combination has to start with <b>dev=</b> and separate the optional baud
      rate with a colon. For example
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p serprog:dev=/dev/ttyS0:115200</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    If no baud rate is given the default values by the operating system/hardware
      will be used. For IP connections you have to use the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p serprog:ip=ipaddr:port</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax. In case the device supports it, you can set the SPI clock frequency
      with the optional <b>spispeed</b> parameter. The frequency is parsed as
      hertz, unless an <b>M</b>, or <b>k</b> suffix is given, then megahertz or
      kilohertz are used respectively. Example that sets the frequency to 2 MHz:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p serprog:dev=/dev/device:baud,spispeed=2M</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    More information about serprog is available in <b>serprog-protocol.txt</b>
      in the source distribution.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>buspirate_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A required <b>dev</b> parameter specifies the Bus Pirate
      device node and an optional <b>spispeed</b> parameter specifies the
      frequency of the SPI bus. The parameter delimiter is a comma. Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p buspirate_spi:dev=/dev/device,spispeed=frequency</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>frequency</b> can be <b>30k</b>, <b>125k</b>, <b>250k</b>,
      <b>1M</b>, <b>2M</b>, <b>2.6M</b>, <b>4M</b> or <b>8M</b> (in Hz). The
      default is the maximum frequency of 8 MHz.
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional pullups parameter specifies the use of the Bus Pirate internal
      pull-up resistors. This may be needed if you are working with a flash ROM
      chip that you have physically removed from the board. Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p buspirate_spi:pullups=state</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>state</b> can be <b>on</b> or <b>off</b>. More information about
      the Bus Pirate pull-up resistors and their purpose is available in a guide
      by dangerousprototypes
      &#x27E8;<b>http://dangerousprototypes.com/docs/Practical_guide_to_Bus_Pirate_pull-up_resistors</b>&#x27E9;.
      Only the external supply voltage (Vpu) is supported as of this
    writing.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>pickit2_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">An optional <b>voltage</b> parameter specifies the voltage
      the PICkit2 should use. The default unit is Volt if no unit is specified.
      You can use <b>mV</b>, <b>millivolt</b>, <b>V</b> or <b>Volt</b> as unit
      specifier. Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p pickit2_spi:voltage=value</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>value</b> can be <b>0V</b>, <b>1.8V</b>, <b>2.5V</b>, <b>3.5V</b>
      or the equivalent in mV.
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional <b>spispeed</b> parameter specifies the frequency of the SPI
      bus. Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p pickit2_spi:spispeed=frequency</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>frequency</b> can be <b>250k</b>, <b>333k</b>, <b>500k</b> or
      <b>1M</b> (in Hz). The default is a frequency of 1 MHz.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>dediprog </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">An optional <b>voltage</b> parameter specifies the voltage
      the Dediprog should use. The default unit is Volt if no unit is specified.
      You can use <b>mV</b>, <b>milliVolt</b>, <b>V</b> or <b>Volt</b> as unit
      specifier. Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dediprog:voltage=value</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>value</b> can be <b>0V</b>, <b>1.8V</b>, <b>2.5V</b>, <b>3.5V</b>
      or the equivalent in mV.
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional <b>device</b> parameter specifies which of multiple connected
      Dediprog devices should be used. Please be aware that the order depends on
      libusb's usb_get_busses() function and that the numbering starts at 0.
      Usage example to select the second device:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dediprog:device=1</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional <b>spispeed</b> parameter specifies the frequency of the SPI
      bus. The firmware on the device needs to be 5.0.0 or newer. Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dediprog:spispeed=frequency</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>frequency</b> can be <b>375k</b>, <b>750k</b>, <b>1.5M</b>,
      <b>2.18M</b>, <b>3M</b>, <b>8M</b>, <b>12M</b> or <b>24M</b> (in Hz). The
      default is a frequency of 12 MHz.
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional <b>target</b> parameter specifies which target chip should be
      used. Syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p dediprog:target=value</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    where <b>value</b> can be <b>1</b> or <b>2</b> to select target chip 1 or 2
      respectively. The default is target chip 1.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>rayer_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The default I/O base address used for the parallel port is
      0x378 and you can use the optional <b>iobase</b> parameter to specify an
      alternate base I/O address with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p rayer_spi:iobase=baseaddr</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>baseaddr</b> is base I/O port address of the parallel port,
      which must be a multiple of four. Make sure to not forget the
      &quot;0x&quot; prefix for hexadecimal port addresses.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default cable type is the RayeR cable. You can use the optional
      <b>type</b> parameter to specify the cable type with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p rayer_spi:type=model</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>model</b> can be <b>rayer</b> for the RayeR cable,
      <b>byteblastermv</b> for the Altera ByteBlasterMV, <b>stk200</b> for the
      Atmel STK200/300, <b>wiggler</b> for the Macraigor Wiggler, <b>xilinx</b>
      for the Xilinx Parallel Cable III (DLC 5), or<b> spi_tt</b> for SPI Tiny
      Tools-compatible hardware.
    <div style="height: 1.00em;">&#x00A0;</div>
    More information about the RayeR hardware is available at RayeR's website
      &#x27E8;<b>http://rayer.g6.cz/elektro/spipgm.htm</b>&#x27E9;. The Altera
      ByteBlasterMV datasheet can be obtained from Altera
      &#x27E8;<b>http://www.altera.co.jp/literature/ds/dsbytemv.pdf</b>&#x27E9;.
      For more information about the Macraigor Wiggler see their company
      homepage &#x27E8;<b>http://www.macraigor.com/wiggler.htm</b>&#x27E9;. The
      schematic of the Xilinx DLC 5 was published in a Xilinx user guide
      &#x27E8;<b>http://www.xilinx.com/support/documentation/user_guides/xtp029.pdf</b>&#x27E9;.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>pony_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The serial port (like /dev/ttyS0, /dev/ttyUSB0 on Linux or
      COM3 on windows) is specified using the mandatory <b>dev</b> parameter.
      The adapter type is selectable between SI-Prog (used for SPI devices with
      PonyProg 2000) or a custom made serial bitbanging programmer named
      &quot;serbang&quot;. The optional <b>type</b> parameter accepts the values
      &quot;si_prog&quot; (default) or &quot;serbang&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Information about the SI-Prog adapter can be found at its website
      &#x27E8;<b>http://www.lancos.com/siprogsch.html</b>&#x27E9;.
    <div style="height: 1.00em;">&#x00A0;</div>
    An example call to flashrom is
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p pony_spi:dev=/dev/ttyS0,type=serbang</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Please note that while USB-to-serial adapters work under certain
      circumstances, this slows down operation considerably.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>ogp_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The flash ROM chip to access must be specified with the
      <b>rom</b> parameter.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p ogp_spi:rom=name</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Where <b>name</b> is either <b>cprom</b> or <b>s3</b> for the configuration
      ROM and <b>bprom</b> or <b>bios</b> for the BIOS ROM. If more than one
      card supported by the ogp_spi programmer is installed in your system, you
      have to specify the PCI address of the card you want to use with the
      <b>pci=</b> parameter as explained in the <b>nic3com et al.</b> section
      above.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>linux_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">You have to specify the SPI controller to use with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p linux_spi:dev=/dev/spidevX.Y</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>/dev/spidevX.Y</b> is the Linux device node for your SPI
      controller.
    <div style="height: 1.00em;">&#x00A0;</div>
    In case the device supports it, you can set the SPI clock frequency with the
      optional <b>spispeed</b> parameter. The frequency is parsed as kilohertz.
      Example that sets the frequency to 8 MHz:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p linux_spi:dev=/dev/spidevX.Y,spispeed=8000</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Please note that the linux_spi driver only works on Linux.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>mstarddc_spi </b>programmer</h2>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The Display Data Channel (DDC) is an I2C bus present on VGA
      and DVI connectors, that allows exchanging information between a computer
      and attached displays. Its most common uses are getting display
      capabilities through EDID (at I2C address 0x50) and sending commands to
      the display using the DDC/CI protocol (at address 0x37). On displays
      driven by MSTAR SoCs, it is also possible to access the SoC firmware flash
      (connected to the Soc through another SPI bus) using an In-System
      Programming (ISP) port, usually at address 0x49. This flashrom module
      allows the latter via Linux's I2C driver.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>IMPORTANT:</b> Before using this programmer, the display <b>MUST</b> be
      in standby mode, and only connected to the computer that will run flashrom
      using a VGA cable, to an inactive VGA output. It absolutely <b>MUST
      NOT</b> be used as a display during the procedure!
    <div style="height: 1.00em;">&#x00A0;</div>
    You have to specify the DDC/I2C controller and I2C address to use with the
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p mstarddc_spi:dev=/dev/i2c-X:YY</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    syntax where <b>/dev/i2c-X</b> is the Linux device node for your I2C
      controller connected to the display's DDC channel, and <b>YY</b> is the
      (hexadecimal) address of the MSTAR ISP port (address 0x49 is usually
      used). Example that uses I2C controller /dev/i2c-1 and address 0x49:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p mstarddc_spi:dev=/dev/i2c-1:49</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    It is also possible to inhibit the reset command that is normally sent to
      the display once the flashrom operation is completed using the optional
      <b>noreset</b> parameter. A value of 1 prevents flashrom from sending the
      reset command. Example that does not reset the display at the end of the
      operation:
    <div style="height: 1.00em;">&#x00A0;</div>
    <b> flashrom -p mstarddc_spi:dev=/dev/i2c-1:49,noreset=1</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Please note that sending the reset command is also inhibited if an error
      occurred during the operation. To send the reset command afterwards, you
      can simply run flashrom once more, in chip probe mode (not specifying an
      operation), without the <b>noreset</b> parameter, once the flash
      read/write operation you intended to perform has completed successfully.
    <div style="height: 1.00em;">&#x00A0;</div>
    Please also note that the mstarddc_spi driver only works on Linux.</dd>
</dl>
<h2 class="Ss" title="Ss"><b>ch341a_spi </b>programmer</h2>
The WCH CH341A programmer does not support any parameters currently. SPI
  frequency is fixed at 2 MHz, and CS0 is used as per the device.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
To back up and update your BIOS, run
<div style="height: 1.00em;">&#x00A0;</div>
<b>flashrom -p internal -r backup.rom -o backuplog.txt</b>
<div>&#x00A0;</div>
<b>flashrom -p internal -w newbios.rom -o writelog.txt</b>
<div style="height: 1.00em;">&#x00A0;</div>
Please make sure to copy backup.rom to some external media before you try to
  write. That makes offline recovery easier.
<div>&#x00A0;</div>
If writing fails and flashrom complains about the chip being in an unknown
  state, you can try to restore the backup by running
<div style="height: 1.00em;">&#x00A0;</div>
<b>flashrom -p internal -w backup.rom -o restorelog.txt</b>
<div style="height: 1.00em;">&#x00A0;</div>
If you encounter any problems, please contact us and supply backuplog.txt,
  writelog.txt and restorelog.txt. See section <b>BUGS</b> for contact info.
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
flashrom exits with 0 on success, 1 on most failures but with 3 if a call to
  mmap() fails.
<h1 class="Sh" title="Sh" id="REQUIREMENTS"><a class="selflink" href="#REQUIREMENTS">REQUIREMENTS</a></h1>
flashrom needs different access permissions for different programmers.
<div style="height: 1.00em;">&#x00A0;</div>
<b>internal</b> needs raw memory access, PCI configuration space access, raw I/O
  port access (x86) and MSR access (x86).
<div style="height: 1.00em;">&#x00A0;</div>
<b>atavia</b> needs PCI configuration space access.
<div style="height: 1.00em;">&#x00A0;</div>
<b>nic3com</b>, <b>nicrealtek</b> and <b>nicnatsemi</b> need PCI configuration
  space read access and raw I/O port access.
<div style="height: 1.00em;">&#x00A0;</div>
<b>atahpt</b> needs PCI configuration space access and raw I/O port access.
<div style="height: 1.00em;">&#x00A0;</div>
<b>gfxnvidia</b>, <b>drkaiser</b> and <b>it8212</b> need PCI configuration space
  access and raw memory access.
<div style="height: 1.00em;">&#x00A0;</div>
<b>rayer_spi</b> needs raw I/O port access.
<div style="height: 1.00em;">&#x00A0;</div>
<b>satasii</b>, <b>nicintel</b>, <b>nicintel_eeprom</b> and <b>nicintel_spi</b>
  need PCI configuration space read access and raw memory access.
<div style="height: 1.00em;">&#x00A0;</div>
<b>satamv</b> and <b>atapromise</b> need PCI configuration space read access,
  raw I/O port access and raw memory access.
<div style="height: 1.00em;">&#x00A0;</div>
<b>serprog</b> needs TCP access to the network or userspace access to a serial
  port.
<div style="height: 1.00em;">&#x00A0;</div>
<b>buspirate_spi</b> needs userspace access to a serial port.
<div style="height: 1.00em;">&#x00A0;</div>
<b>ft2232_spi</b>, <b>usbblaster_spi</b> and <b>pickit2_spi</b> need access to
  the respective USB device via libusb API version 0.1.
<div style="height: 1.00em;">&#x00A0;</div>
<b>ch341a_spi</b> and <b>dediprog</b> need access to the respective USB device
  via libusb API version 1.0.
<div style="height: 1.00em;">&#x00A0;</div>
<b>dummy</b> needs no access permissions at all.
<div style="height: 1.00em;">&#x00A0;</div>
<b>internal</b>, <b>nic3com</b>, <b>nicrealtek</b>, <b>nicnatsemi</b>,
  <b>gfxnvidia</b>, <b>drkaiser</b>, <b>satasii</b>, <b>satamv</b>,
  <b>atahpt</b>, <b>atavia</b> and <b>atapromise</b> have to be run as
  superuser/root, and need additional raw access permission.
<div style="height: 1.00em;">&#x00A0;</div>
<b>serprog</b>, <b>buspirate_spi</b>, <b>dediprog</b>, <b>usbblaster_spi</b>,
  <b>ft2232_spi</b>, <b>pickit2_spi</b> and <b>ch341a_spi</b> can be run as
  normal user on most operating systems if appropriate device permissions are
  set.
<div style="height: 1.00em;">&#x00A0;</div>
<b>ogp</b> needs PCI configuration space read access and raw memory access.
<div style="height: 1.00em;">&#x00A0;</div>
On OpenBSD, you can obtain raw access permission by setting
  <b>securelevel=-1</b> in <b>/etc/rc.securelevel</b> and rebooting, or
  rebooting into single user mode.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Please report any bugs to the flashrom mailing list
  &#x27E8;<b>flashrom@flashrom.org</b>&#x27E9;.
<div style="height: 1.00em;">&#x00A0;</div>
We recommend to subscribe first at
  <b>https://flashrom.org/mailman/listinfo/flashrom</b>.
<div style="height: 1.00em;">&#x00A0;</div>
Many of the developers communicate via the <b>#flashrom</b> IRC channel on
  <b>chat.freenode.net</b>. If you don't have an IRC client, you can use the
  freenode webchat
  &#x27E8;<b>http://webchat.freenode.net/?channels=flashrom</b>&#x27E9;. You are
  welcome to join and ask questions, send us bug and success reports there too.
  Please provide a way to contact you later (e.g. a mail address) and be patient
  if there is no immediate reaction. Also, we provide a pastebin service
  &#x27E8;<b>https://paste.flashrom.org</b>&#x27E9; that is very useful when you
  want to share logs etc. without spamming the channel.
<h2 class="Ss" title="Ss"><b>Laptops</b></h2>
Using flashrom on laptops is dangerous and may easily make your hardware
  unusable. flashrom will attempt to detect if it is running on a laptop and
  abort immediately for safety reasons. Please see the detailed discussion of
  this topic and associated flashrom options in the <b>Laptops</b> paragraph in
  the <b>internal programmer</b> subsection of the <b>PROGRAMMER-SPECIFIC
  INFORMATION</b> section and the information in our wiki
  &#x27E8;<b>https://flashrom.org/Laptops</b>&#x27E9;.
<h2 class="Ss" title="Ss" id="One-time_programmable_(OTP)_memory_and_unique_IDs"><a class="selflink" href="#One-time_programmable_(OTP)_memory_and_unique_IDs">One-time
  programmable (OTP) memory and unique IDs</a></h2>
Some flash chips contain OTP memory often denoted as &quot;security
  registers&quot;. They usually have a capacity in the range of some bytes to a
  few hundred bytes and can be used to give devices unique IDs etc. flashrom is
  not able to read or write these memories and may therefore not be able to
  duplicate a chip completely. For chip types known to include OTP memories a
  warning is printed when they are detected.
<div style="height: 1.00em;">&#x00A0;</div>
Similar to OTP memories are unique, factory programmed, unforgeable IDs. They
  are not modifiable by the user at all.
<h1 class="Sh" title="Sh" id="LICENSE"><a class="selflink" href="#LICENSE">LICENSE</a></h1>
<b>flashrom</b> is covered by the GNU General Public License (GPL), version 2.
  Some files are additionally available under any later version of the GPL.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Please see the individual files.
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Andrew Morgan
<div>&#x00A0;</div>
Carl-Daniel Hailfinger
<div>&#x00A0;</div>
Claus Gindhart
<div>&#x00A0;</div>
David Borg
<div>&#x00A0;</div>
David Hendricks
<div>&#x00A0;</div>
Dominik Geyer
<div>&#x00A0;</div>
Eric Biederman
<div>&#x00A0;</div>
Giampiero Giancipoli
<div>&#x00A0;</div>
Helge Wagner
<div>&#x00A0;</div>
Idwer Vollering
<div>&#x00A0;</div>
Joe Bao
<div>&#x00A0;</div>
Joerg Fischer
<div>&#x00A0;</div>
Joshua Roys
<div>&#x00A0;</div>
Ky&#x00F6;sti M&#x00E4;lkki
<div>&#x00A0;</div>
Luc Verhaegen
<div>&#x00A0;</div>
Li-Ta Lo
<div>&#x00A0;</div>
Mark Marshall
<div>&#x00A0;</div>
Markus Boas
<div>&#x00A0;</div>
Mattias Mattsson
<div>&#x00A0;</div>
Michael Karcher
<div>&#x00A0;</div>
Nikolay Petukhov
<div>&#x00A0;</div>
Patrick Georgi
<div>&#x00A0;</div>
Peter Lemenkov
<div>&#x00A0;</div>
Peter Stuge
<div>&#x00A0;</div>
Reinder E.N. de Haan
<div>&#x00A0;</div>
Ronald G. Minnich
<div>&#x00A0;</div>
Ronald Hoogenboom
<div>&#x00A0;</div>
Sean Nelson
<div>&#x00A0;</div>
Stefan Reinauer
<div>&#x00A0;</div>
Stefan Tauner
<div>&#x00A0;</div>
Stefan Wildemann
<div>&#x00A0;</div>
Stephan Guilloux
<div>&#x00A0;</div>
Steven James
<div>&#x00A0;</div>
Urja Rannikko
<div>&#x00A0;</div>
Uwe Hermann
<div>&#x00A0;</div>
Wang Qingpei
<div>&#x00A0;</div>
Yinghai Lu
<div>&#x00A0;</div>
some others, please see the flashrom svn changelog for details.
<div>&#x00A0;</div>
All still active authors can be reached via the mailing list
  &#x27E8;<b>flashrom@flashrom.org</b>&#x27E9;.
<div class="Pp"></div>
This manual page was written by Uwe Hermann
  &#x27E8;<b>uwe@hermann-uwe.de</b>&#x27E9;, Carl-Daniel Hailfinger, Stefan
  Tauner and others. It is licensed under the terms of the GNU GPL (version 2 or
  later).</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-04-26</td>
    <td class="foot-os">0.9.9-r1954</td>
  </tr>
</table>
</body>
</html>
