<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>TCPDUMP(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">TCPDUMP(8)</td>
    <td class="head-vol">System Manager's Manual</td>
    <td class="head-rtitle">TCPDUMP(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
tcpdump - dump traffic on a network
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>tcpdump</b> [ <b>-AbdDefhHIJKlLnNOpqRStuUvxX</b> ] [ <b>-B</b>
  <i>buffer_size</i> ] [ <b>-c</b> <i>count</i> ]
<div>&#x00A0;</div>
[ <b>-C</b> <i>file_size</i> ] [ <b>-G</b> <i>rotate_seconds</i> ] [ <b>-F</b>
  <i>file</i> ]
<div>&#x00A0;</div>
[ <b>-i</b> <i>interface</i> ] [ <b>-j</b> <i>tstamp_type</i> ] [ <b>-m</b>
  <i>module</i> ] [ <b>-M</b> <i>secret</i> ]
<div>&#x00A0;</div>
[ <b>-P</b> <i>in|out|inout</i> ] [ <b>-r</b> <i>file</i> ] [ <b>-V</b>
  <i>file</i> ] [ <b>-s</b> <i>snaplen</i> ] [ <b>-T</b> <i>type</i> ] [
  <b>-w</b> <i>file</i> ]
<div>&#x00A0;</div>
[ <b>-W</b> <i>filecount</i> ]
<div>&#x00A0;</div>
[ <b>-E</b> <i>spi@ipaddr algo:secret,...</i> ]
<div>&#x00A0;</div>
[ <b>-y</b> <i>datalinktype</i> ] [ <b>-z</b> <i>postrotate-command</i> ] [
  <b>-Z</b> <i>user</i> ] [ <i>expression</i> ]
<div>&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>Tcpdump</i> prints out a description of the contents of packets on a network
  interface that match the boolean <i>expression</i>. It can also be run with
  the <b>-w</b> flag, which causes it to save the packet data to a file for
  later analysis, and/or with the <b>-r</b> flag, which causes it to read from a
  saved packet file rather than to read packets from a network interface. It can
  also be run with the <b>-V</b> flag, which causes it to read a list of saved
  packet files. In all cases, only packets that match <i>expression</i> will be
  processed by <i>tcpdump</i>.
<div class="Pp"></div>
<i>Tcpdump</i> will, if not run with the <b>-c</b> flag, continue capturing
  packets until it is interrupted by a SIGINT signal (generated, for example, by
  typing your interrupt character, typically control-C) or a SIGTERM signal
  (typically generated with the <b>kill</b>(1) command); if run with the
  <b>-c</b> flag, it will capture packets until it is interrupted by a SIGINT or
  SIGTERM signal or the specified number of packets have been processed.
<div class="Pp"></div>
When <i>tcpdump</i> finishes capturing packets, it will report counts of:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">packets ``captured'' (this is the number of packets that
      <i>tcpdump</i> has received and processed);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">packets ``received by filter'' (the meaning of this depends
      on the OS on which you're running <i>tcpdump</i>, and possibly on the way
      the OS was configured - if a filter was specified on the command line, on
      some OSes it counts packets regardless of whether they were matched by the
      filter expression and, even if they were matched by the filter expression,
      regardless of whether <i>tcpdump</i> has read and processed them yet, on
      other OSes it counts only packets that were matched by the filter
      expression regardless of whether <i>tcpdump</i> has read and processed
      them yet, and on other OSes it counts only packets that were matched by
      the filter expression and were processed by <i>tcpdump</i>);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">packets ``dropped by kernel'' (this is the number of
      packets that were dropped, due to a lack of buffer space, by the packet
      capture mechanism in the OS on which <i>tcpdump</i> is running, if the OS
      reports that information to applications; if not, it will be reported as
      0).</dd>
</dl>
<div class="Pp"></div>
On platforms that support the SIGINFO signal, such as most BSDs (including Mac
  OS X) and Digital/Tru64 UNIX, it will report those counts when it receives a
  SIGINFO signal (generated, for example, by typing your ``status'' character,
  typically control-T, although on some platforms, such as Mac OS X, the
  ``status'' character is not set by default, so you must set it with
  <b>stty</b>(1) in order to use it) and will continue capturing packets.
<div class="Pp"></div>
Reading packets from a network interface may require that you have special
  privileges; see the <b>pcap (3PCAP)</b> man page for details. Reading a saved
  packet file doesn't require special privileges.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b></dt>
  <dd class="It-tag">Print each packet (minus its link level header) in ASCII.
      Handy for capturing web pages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b></dt>
  <dd class="It-tag">Print the AS number in BGP packets in ASDOT notation rather
      than ASPLAIN notation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B</b></dt>
  <dd class="It-tag">Set the operating system capture buffer size to
      <i>buffer_size</i>, in units of KiB (1024 bytes).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag">Exit after receiving <i>count</i> packets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C</b></dt>
  <dd class="It-tag">Before writing a raw packet to a savefile, check whether
      the file is currently larger than <i>file_size</i> and, if so, close the
      current savefile and open a new one. Savefiles after the first savefile
      will have the name specified with the <b>-w</b> flag, with a number after
      it, starting at 1 and continuing upward. The units of <i>file_size</i> are
      millions of bytes (1,000,000 bytes, not 1,048,576 bytes).
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that when used with <b>-Z</b> option (enabled by default), privileges
      are dropped before opening first savefile.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b></dt>
  <dd class="It-tag">Dump the compiled packet-matching code in a human readable
      form to standard output and stop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dd</b></dt>
  <dd class="It-tag">Dump packet-matching code as a <b>C</b> program
    fragment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ddd</b></dt>
  <dd class="It-tag">Dump packet-matching code as decimal numbers (preceded with
      a count).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b></dt>
  <dd class="It-tag">Print the list of the network interfaces available on the
      system and on which <i>tcpdump</i> can capture packets. For each network
      interface, a number and an interface name, possibly followed by a text
      description of the interface, is printed. The interface name or the number
      can be supplied to the <b>-i</b> flag to specify an interface on which to
      capture.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This can be useful on systems that don't have a command to
      list them (e.g., Windows systems, or UNIX systems lacking <b>ifconfig
      -a</b>); the number can be useful on Windows 2000 and later systems, where
      the interface name is a somewhat complex string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The <b>-D</b> flag will not be supported if <i>tcpdump</i>
      was built with an older version of <i>libpcap</i> that lacks the
      <b>pcap_findalldevs()</b> function.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b></dt>
  <dd class="It-tag">Print the link-level header on each dump line. This can be
      used, for example, to print MAC layer addresses for protocols such as
      Ethernet and IEEE 802.11.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E</b></dt>
  <dd class="It-tag">Use <i>spi@ipaddr algo:secret</i> for decrypting IPsec ESP
      packets that are addressed to <i>addr</i> and contain Security Parameter
      Index value <i>spi</i>. This combination may be repeated with comma or
      newline separation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that setting the secret for IPv4 ESP packets is
      supported at this time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Algorithms may be <b>des-cbc</b>, <b>3des-cbc</b>,
      <b>blowfish-cbc</b>, <b>rc3-cbc</b>, <b>cast128-cbc</b>, or <b>none</b>.
      The default is <b>des-cbc</b>. The ability to decrypt packets is only
      present if <i>tcpdump</i> was compiled with cryptography enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><i>secret</i> is the ASCII text for ESP secret key. If
      preceded by 0x, then a hex value will be read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The option assumes RFC2406 ESP, not RFC1827 ESP. The option
      is only for debugging purposes, and the use of this option with a true
      `secret' key is discouraged. By presenting IPsec secret key onto command
      line you make it visible to others, via <i>ps</i>(1) and other
    occasions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In addition to the above syntax, the syntax <i>file
      name</i> may be used to have tcpdump read the provided file in. The file
      is opened upon receiving the first ESP packet, so any special permissions
      that tcpdump may have been given should already have been given up.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b></dt>
  <dd class="It-tag">Print `foreign' IPv4 addresses numerically rather than
      symbolically (this option is intended to get around serious brain damage
      in Sun's NIS server &#x2014; usually it hangs forever translating
      non-local internet numbers).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The test for `foreign' IPv4 addresses is done using the
      IPv4 address and netmask of the interface on which capture is being done.
      If that address or netmask are not available, available, either because
      the interface on which capture is being done has no address or netmask or
      because the capture is being done on the Linux &quot;any&quot; interface,
      which can capture on more than one interface, this option will not work
      correctly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-F</b></dt>
  <dd class="It-tag">Use <i>file</i> as input for the filter expression. An
      additional expression given on the command line is ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-G</b></dt>
  <dd class="It-tag">If specified, rotates the dump file specified with the
      <b>-w</b> option every <i>rotate_seconds</i> seconds. Savefiles will have
      the name specified by <b>-w</b> which should include a time format as
      defined by <b>strftime</b>(3). If no time format is specified, each new
      file will overwrite the previous.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If used in conjunction with the <b>-C</b> option, filenames
      will take the form of ` <i>file</i>&lt;count&gt;'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">Print the tcpdump and libpcap version strings, print a
      usage message, and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-H</b></dt>
  <dd class="It-tag">Attempt to detect 802.11s draft mesh headers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b></dt>
  <dd class="It-tag">Listen on <i>interface</i>. If unspecified, <i>tcpdump</i>
      searches the system interface list for the lowest numbered, configured up
      interface (excluding loopback), which may turn out to be, for example,
      ``eth0''.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">On Linux systems with 2.2 or later kernels, an
      <i>interface</i> argument of ``any'' can be used to capture packets from
      all interfaces. Note that captures on the ``any'' device will not be done
      in promiscuous mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the <b>-D</b> flag is supported, an interface number as
      printed by that flag can be used as the <i>interface</i> argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b></dt>
  <dd class="It-tag">Put the interface in &quot;monitor mode&quot;; this is
      supported only on IEEE 802.11 Wi-Fi interfaces, and supported only on some
      operating systems.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that in monitor mode the adapter might disassociate
      from the network with which it's associated, so that you will not be able
      to use any wireless networks with that adapter. This could prevent
      accessing files on a network server, or resolving host names or network
      addresses, if you are capturing in monitor mode and are not connected to
      another network with another adapter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This flag will affect the output of the <b>-L</b> flag. If
      <b>-I</b> isn't specified, only those link-layer types available when not
      in monitor mode will be shown; if <b>-I</b> is specified, only those
      link-layer types available when in monitor mode will be shown.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b></dt>
  <dd class="It-tag">Set the time stamp type for the capture to
      <i>tstamp_type</i>. The names to use for the time stamp types are given in
      <b>pcap-tstamp-type</b>(7); not all the types listed there will
      necessarily be valid for any given interface.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-J</b></dt>
  <dd class="It-tag">List the supported time stamp types for the interface and
      exit. If the time stamp type cannot be set for the interface, no time
      stamp types are listed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--time-stamp-precision=</b><i>tstamp_precision</i></dt>
  <dd class="It-tag">When capturing, set the time stamp precision for the
      capture to <i>tstamp_precision</i>. Note that availability of high
      precision time stamps (nanoseconds) and their actual accuracy is platform
      and hardware dependent. Also note that when writing captures made with
      nanosecond accuracy to a savefile, the time stamps are written with
      nanosecond resolution, and the file is written with a different magic
      number, to indicate that the time stamps are in seconds and nanoseconds;
      not all programs that read pcap savefiles will be able to read those
      captures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">When reading a savefile, convert time stamps to the
      precision specified by <i>timestamp_precision</i>, and display them with
      that resolution. If the precision specified is less than the precision of
      time stamps in the file, the conversion will lose precision.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The supported values for <i>timestamp_precision</i> are
      <b>micro</b> for microsecond resolution and <b>nano</b> for nanosecond
      resolution. The default is microsecond resolution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-K</b></dt>
  <dd class="It-tag">Don't attempt to verify IP, TCP, or UDP checksums. This is
      useful for interfaces that perform some or all of those checksum
      calculation in hardware; otherwise, all outgoing TCP checksums will be
      flagged as bad.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b></dt>
  <dd class="It-tag">Make stdout line buffered. Useful if you want to see the
      data while capturing it. E.g.,</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump -l | tee dat</b>
</pre>
</div>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">or</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump -l &gt; dat &amp; tail -f dat</b>
</pre>
</div>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that on Windows,``line buffered'' means
      ``unbuffered'', so that WinDump will write each character individually if
      <b>-l</b> is specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-U</b> is similar to <b>-l</b> in its behavior, but it
      will cause output to be ``packet-buffered'', so that the output is written
      to stdout at the end of each packet rather than at the end of each line;
      this is buffered on all platforms, including Windows.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b></dt>
  <dd class="It-tag">List the known data link types for the interface, in the
      specified mode, and exit. The list of known data link types may be
      dependent on the specified mode; for example, on some platforms, a Wi-Fi
      interface might support one set of data link types when not in monitor
      mode (for example, it might support only fake Ethernet headers, or might
      support 802.11 headers but not support 802.11 headers with radio
      information) and another set of data link types when in monitor mode (for
      example, it might support 802.11 headers, or 802.11 headers with radio
      information, only in monitor mode).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m</b></dt>
  <dd class="It-tag">Load SMI MIB module definitions from file <i>module</i>.
      This option can be used several times to load several MIB modules into
      <i>tcpdump</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b></dt>
  <dd class="It-tag">Use <i>secret</i> as a shared secret for validating the
      digests found in TCP segments with the TCP-MD5 option (RFC 2385), if
      present.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b></dt>
  <dd class="It-tag">Don't convert host addresses to names. This can be used to
      avoid DNS lookups.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-nn</b></dt>
  <dd class="It-tag">Don't convert protocol and port numbers etc. to names
      either.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b></dt>
  <dd class="It-tag">Don't print domain name qualification of host names. E.g.,
      if you give this flag then <i>tcpdump</i> will print ``nic'' instead of
      ``nic.ddn.mil''.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-O</b></dt>
  <dd class="It-tag">Do not run the packet-matching code optimizer. This is
      useful only if you suspect a bug in the optimizer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag"><i>Don't</i> put the interface into promiscuous mode. Note
      that the interface might be in promiscuous mode for some other reason;
      hence, `-p' cannot be used as an abbreviation for `ether host
      {local-hw-addr} or ether broadcast'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b></dt>
  <dd class="It-tag">Choose send/receive direction <i>direction</i> for which
      packets should be captured. Possible values are `in', `out' and `inout'.
      Not available on all platforms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b></dt>
  <dd class="It-tag">Quick (quiet?) output. Print less protocol information so
      output lines are shorter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b></dt>
  <dd class="It-tag">Assume ESP/AH packets to be based on old specification
      (RFC1825 to RFC1829). If specified, <i>tcpdump</i> will not print replay
      prevention field. Since there is no protocol version field in ESP/AH
      specification, <i>tcpdump</i> cannot deduce the version of ESP/AH
      protocol.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b></dt>
  <dd class="It-tag">Read packets from <i>file</i> (which was created with the
      <b>-w</b> option). Standard input is used if <i>file</i> is ``-''.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b></dt>
  <dd class="It-tag">Print absolute, rather than relative, TCP sequence
    numbers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b></dt>
  <dd class="It-tag">Snarf <i>snaplen</i> bytes of data from each packet rather
      than the default of 65535 bytes. Packets truncated because of a limited
      snapshot are indicated in the output with ``[| <i>proto</i>]'', where
      <i>proto</i> is the name of the protocol level at which the truncation has
      occurred. Note that taking larger snapshots both increases the amount of
      time it takes to process packets and, effectively, decreases the amount of
      packet buffering. This may cause packets to be lost. You should limit
      <i>snaplen</i> to the smallest number that will capture the protocol
      information you're interested in. Setting <i>snaplen</i> to 0 sets it to
      the default of 65535, for backwards compatibility with recent older
      versions of <i>tcpdump</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b></dt>
  <dd class="It-tag">Force packets selected by &quot;<i>expression</i>&quot; to
      be interpreted the specified <i>type</i>. Currently known types are
      <b>aodv</b> (Ad-hoc On-demand Distance Vector protocol), <b>carp</b>
      (Common Address Redundancy Protocol), <b>cnfp</b> (Cisco NetFlow
      protocol), <b>lmp</b> (Link Management Protocol), <b>pgm</b> (Pragmatic
      General Multicast), <b>pgm_zmtp1</b> (ZMTP/1.0 inside PGM/EPGM),
      <b>radius</b> (RADIUS), <b>rpc</b> (Remote Procedure Call), <b>rtp</b>
      (Real-Time Applications protocol), <b>rtcp</b> (Real-Time Applications
      control protocol), <b>snmp</b> (Simple Network Management Protocol),
      <b>tftp</b> (Trivial File Transfer Protocol), <b>vat</b> (Visual Audio
      Tool), <b>wb</b> (distributed White Board), <b>zmtp1</b> (ZeroMQ Message
      Transport Protocol 1.0) and <b>vxlan</b> (Virtual eXtensible Local Area
      Network).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that the <b>pgm</b> type above affects UDP
      interpretation only, the native PGM is always recognised as IP protocol
      113 regardless. UDP-encapsulated PGM is often called &quot;EPGM&quot; or
      &quot;PGM/UDP&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that the <b>pgm_zmtp1</b> type above affects
      interpretation of both native PGM and UDP at once. During the native PGM
      decoding the application data of an ODATA/RDATA packet would be decoded as
      a ZeroMQ datagram with ZMTP/1.0 frames. During the UDP decoding in
      addition to that any UDP packet would be treated as an encapsulated PGM
      packet.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b></dt>
  <dd class="It-tag"><i>Don't</i> print a timestamp on each dump line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-tt</b></dt>
  <dd class="It-tag">Print an unformatted timestamp on each dump line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ttt</b></dt>
  <dd class="It-tag">Print a delta (micro-second resolution) between current and
      previous line on each dump line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-tttt</b></dt>
  <dd class="It-tag">Print a timestamp in default format proceeded by date on
      each dump line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ttttt</b></dt>
  <dd class="It-tag">Print a delta (micro-second resolution) between current and
      first line on each dump line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u</b></dt>
  <dd class="It-tag">Print undecoded NFS handles.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-U</b></dt>
  <dd class="It-tag">If the <b>-w</b> option is not specified, make the printed
      packet output ``packet-buffered''; i.e., as the description of the
      contents of each packet is printed, it will be written to the standard
      output, rather than, when not writing to a terminal, being written only
      when the output buffer fills.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the <b>-w</b> option is specified, make the saved raw
      packet output ``packet-buffered''; i.e., as each packet is saved, it will
      be written to the output file, rather than being written only when the
      output buffer fills.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The <b>-U</b> flag will not be supported if <i>tcpdump</i>
      was built with an older version of <i>libpcap</i> that lacks the
      <b>pcap_dump_flush()</b> function.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag">When parsing and printing, produce (slightly more) verbose
      output. For example, the time to live, identification, total length and
      options in an IP packet are printed. Also enables additional packet
      integrity checks such as verifying the IP and ICMP header checksum.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">When writing to a file with the <b>-w</b> option, report,
      every 10 seconds, the number of packets captured.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vv</b></dt>
  <dd class="It-tag">Even more verbose output. For example, additional fields
      are printed from NFS reply packets, and SMB packets are fully
    decoded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vvv</b></dt>
  <dd class="It-tag">Even more verbose output. For example, telnet <b>SB</b> ...
      <b>SE</b> options are printed in full. With <b>-X</b> Telnet options are
      printed in hex as well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag">Read a list of filenames from <i>file</i>. Standard input
      is used if <i>file</i> is ``-''.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b></dt>
  <dd class="It-tag">Write the raw packets to <i>file</i> rather than parsing
      and printing them out. They can later be printed with the -r option.
      Standard output is used if <i>file</i> is ``-''.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This output will be buffered if written to a file or pipe,
      so a program reading from the file or pipe may not see packets for an
      arbitrary amount of time after they are received. Use the <b>-U</b> flag
      to cause packets to be written as soon as they are received.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The MIME type <i>application/vnd.tcpdump.pcap</i> has been
      registered with IANA for <i>pcap</i> files. The filename extension
      <i>.pcap</i> appears to be the most commonly used along with <i>.cap</i>
      and <i>.dmp</i>. <i>Tcpdump</i> itself doesn't check the extension when
      reading capture files and doesn't add an extension when writing them (it
      uses magic numbers in the file header instead). However, many operating
      systems and applications will use the extension if it is present and
      adding one (e.g. .pcap) is recommended.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">See <b>pcap-savefile</b>(5) for a description of the file
      format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-W</b></dt>
  <dd class="It-tag">Used in conjunction with the <b>-C</b> option, this will
      limit the number of files created to the specified number, and begin
      overwriting files from the beginning, thus creating a 'rotating' buffer.
      In addition, it will name the files with enough leading 0s to support the
      maximum number of files, allowing them to sort correctly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Used in conjunction with the <b>-G</b> option, this will
      limit the number of rotated dump files that get created, exiting with
      status 0 when reaching the limit. If used with <b>-C</b> as well, the
      behavior will result in cyclical files per timeslice.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b></dt>
  <dd class="It-tag">When parsing and printing, in addition to printing the
      headers of each packet, print the data of each packet (minus its link
      level header) in hex. The smaller of the entire packet or <i>snaplen</i>
      bytes will be printed. Note that this is the entire link-layer packet, so
      for link layers that pad (e.g. Ethernet), the padding bytes will also be
      printed when the higher layer packet is shorter than the required
    padding.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-xx</b></dt>
  <dd class="It-tag">When parsing and printing, in addition to printing the
      headers of each packet, print the data of each packet, <i>including</i>
      its link level header, in hex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-X</b></dt>
  <dd class="It-tag">When parsing and printing, in addition to printing the
      headers of each packet, print the data of each packet (minus its link
      level header) in hex and ASCII. This is very handy for analysing new
      protocols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-XX</b></dt>
  <dd class="It-tag">When parsing and printing, in addition to printing the
      headers of each packet, print the data of each packet, <i>including</i>
      its link level header, in hex and ASCII.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-y</b></dt>
  <dd class="It-tag">Set the data link type to use while capturing packets to
      <i>datalinktype</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-z</b></dt>
  <dd class="It-tag">Used in conjunction with the <b>-C</b> or <b>-G</b>
      options, this will make <i>tcpdump</i> run &quot; <i>command file</i>
      &quot; where <i>file</i> is the savefile being closed after each rotation.
      For example, specifying <b>-z gzip</b> or <b>-z bzip2</b> will compress
      each savefile using gzip or bzip2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that tcpdump will run the command in parallel to the
      capture, using the lowest priority so that this doesn't disturb the
      capture process.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">And in case you would like to use a command that itself
      takes flags or different arguments, you can always write a shell script
      that will take the savefile name as the only argument, make the flags
      &amp; arguments arrangements and execute the command that you want.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Z</b></dt>
  <dd class="It-tag">If <i>tcpdump</i> is running as root, after opening the
      capture device or input savefile, but before opening any savefiles for
      output, change the user ID to <i>user</i> and the group ID to the primary
      group of <i>user</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This behavior is enabled by default (<b>-Z tcpdump</b>),
      and can be disabled by <b>-Z root</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i> expression</i></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 5.00ex;">selects which packets will be dumped. If no
  <i>expression</i> is given, all packets on the net will be dumped. Otherwise,
  only packets for which <i>expression</i> is `true' will be dumped.
<div class="Pp"></div>
For the <i>expression</i> syntax, see <b>pcap-filter</b>(7).
<div class="Pp"></div>
The <i>expression</i> argument can be passed to <i>tcpdump</i> as either a
  single Shell argument, or as multiple Shell arguments, whichever is more
  convenient. Generally, if the expression contains Shell metacharacters, such
  as backslashes used to escape protocol names, it is easier to pass it as a
  single, quoted argument rather than to escape the Shell metacharacters.
  Multiple arguments are concatenated with spaces before being parsed.</div>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
To print all packets arriving at or departing from <i>sundown</i>:
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump host sundown</b>
</pre>
</div>
<div class="Pp"></div>
To print traffic between <i>helios</i> and either <i>hot</i> or <i>ace</i>:
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump host helios and \( hot or ace \)</b>
</pre>
</div>
<div class="Pp"></div>
To print all IP packets between <i>ace</i> and any host except <i>helios</i>:
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump ip host ace and not helios</b>
</pre>
</div>
<div class="Pp"></div>
To print all traffic between local hosts and hosts at Berkeley:
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump net ucb-ether</b>
</pre>
</div>
<div class="Pp"></div>
To print all ftp traffic through internet gateway <i>snup</i>: (note that the
  expression is quoted to prevent the shell from (mis-)interpreting the
  parentheses):
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump 'gateway snup and (port ftp or ftp-data)'</b>
</pre>
</div>
<div class="Pp"></div>
To print traffic neither sourced from nor destined for local hosts (if you
  gateway to one other net, this stuff should never make it onto your local
  net).
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump ip and not net <i>localnet</i></b>
</pre>
</div>
<div class="Pp"></div>
To print the start and end packets (the SYN and FIN packets) of each TCP
  conversation that involves a non-local host.
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump 'tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net <i>localnet</i>'</b>
</pre>
</div>
<div class="Pp"></div>
To print all IPv4 HTTP packets to and from port 80, i.e. print only packets that
  contain data, not, for example, SYN and FIN packets and ACK-only packets.
  (IPv6 is left as an exercise for the reader.)
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)'</b>
</pre>
</div>
<div class="Pp"></div>
To print IP packets longer than 576 bytes sent through gateway <i>snup</i>:
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump 'gateway snup and ip[2:2] &gt; 576'</b>
</pre>
</div>
<div class="Pp"></div>
To print IP broadcast or multicast packets that were <i>not</i> sent via
  Ethernet broadcast or multicast:
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump 'ether[0] &amp; 1 = 0 and ip[16] &gt;= 224'</b>
</pre>
</div>
<div class="Pp"></div>
To print all ICMP packets that are not echo requests/replies (i.e., not ping
  packets):
<div style="margin-left: 5.00ex;">
<pre>
<b>tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'</b>
</pre>
</div>
<h1 class="Sh" title="Sh" id="OUTPUT_FORMAT"><a class="selflink" href="#OUTPUT_FORMAT">OUTPUT
  FORMAT</a></h1>
The output of <i>tcpdump</i> is protocol dependent. The following gives a brief
  description and examples of most of the formats.
<div style="height: 1.50em;">&#x00A0;</div>
<b>Link Level Headers</b>
<div class="Pp"></div>
If the '-e' option is given, the link level header is printed out. On Ethernets,
  the source and destination addresses, protocol, and packet length are printed.
<div class="Pp"></div>
On FDDI networks, the '-e' option causes <i>tcpdump</i> to print the `frame
  control' field, the source and destination addresses, and the packet length.
  (The `frame control' field governs the interpretation of the rest of the
  packet. Normal packets (such as those containing IP datagrams) are `async'
  packets, with a priority value between 0 and 7; for example, ` <b>async4</b>'.
  Such packets are assumed to contain an 802.2 Logical Link Control (LLC)
  packet; the LLC header is printed if it is <i>not</i> an ISO datagram or a
  so-called SNAP packet.
<div class="Pp"></div>
On Token Ring networks, the '-e' option causes <i>tcpdump</i> to print the
  `access control' and `frame control' fields, the source and destination
  addresses, and the packet length. As on FDDI networks, packets are assumed to
  contain an LLC packet. Regardless of whether the '-e' option is specified or
  not, the source routing information is printed for source-routed packets.
<div class="Pp"></div>
On 802.11 networks, the '-e' option causes <i>tcpdump</i> to print the `frame
  control' fields, all of the addresses in the 802.11 header, and the packet
  length. As on FDDI networks, packets are assumed to contain an LLC packet.
<div class="Pp"></div>
<i>(N.B.: The following description assumes familiarity with</i> <i>the SLIP
  compression algorithm described in RFC-1144.)</i>
<div class="Pp"></div>
On SLIP links, a direction indicator (``I'' for inbound, ``O'' for outbound),
  packet type, and compression information are printed out. The packet type is
  printed first. The three types are <i>ip</i>, <i>utcp</i>, and <i>ctcp</i>. No
  further link information is printed for <i>ip</i> packets. For TCP packets,
  the connection identifier is printed following the type. If the packet is
  compressed, its encoded header is printed out. The special cases are printed
  out as <b>*S+</b><i>n</i> and <b>*SA+</b><i>n</i>, where <i>n</i> is the
  amount by which the sequence number (or sequence number and ack) has changed.
  If it is not a special case, zero or more changes are printed. A change is
  indicated by U (urgent pointer), W (window), A (ack), S (sequence number), and
  I (packet ID), followed by a delta (+n or -n), or a new value (=n). Finally,
  the amount of data in the packet and compressed header length are printed.
<div class="Pp"></div>
For example, the following line shows an outbound compressed TCP packet, with an
  implicit connection identifier; the ack has changed by 6, the sequence number
  by 49, and the packet ID by 6; there are 3 bytes of data and 6 bytes of
  compressed header:
<div style="margin-left: 5.00ex;">
<pre>
<b>O ctcp * A+6 S+49 I+6 3 (6)</b>
</pre>
</div>
<div style="height: 1.50em;">&#x00A0;</div>
<b>ARP/RARP Packets</b>
<div class="Pp"></div>
Arp/rarp output shows the type of request and its arguments. The format is
  intended to be self explanatory. Here is a short sample taken from the start
  of an `rlogin' from host <i>rtsg</i> to host <i>csam</i>:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
arp who-has csam tell rtsg
arp reply csam is-at CSAM
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
The first line says that rtsg sent an arp packet asking for the Ethernet address
  of internet host csam. Csam replies with its Ethernet address (in this
  example, Ethernet addresses are in caps and internet addresses in lower case).
<div class="Pp"></div>
This would look less redundant if we had done <i>tcpdump -n</i>:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
arp who-has 128.3.254.6 tell 128.3.254.68
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4
</pre>
</div>
<div class="Pp"></div>
If we had done <i>tcpdump -e</i>, the fact that the first packet is broadcast
  and the second is point-to-point would be visible:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
RTSG Broadcast 0806  64: arp who-has csam tell rtsg
CSAM RTSG 0806  64: arp reply csam is-at CSAM
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
For the first packet this says the Ethernet source address is RTSG, the
  destination is the Ethernet broadcast address, the type field contained hex
  0806 (type ETHER_ARP) and the total length was 64 bytes.
<div style="height: 1.50em;">&#x00A0;</div>
<b>TCP Packets</b>
<div class="Pp"></div>
<i>(N.B.:The following description assumes familiarity with</i> <i>the TCP
  protocol described in RFC-793.</i> <i>If you are not familiar</i> <i>with the
  protocol, neither this description nor </i> <i>tcpdump</i><i> will</i> <i>be
  of much use to you.)</i> <i></i>
<div class="Pp"></div>
The general format of a tcp protocol line is:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<i>src &gt; dst: flags data-seqno ack window urgent options</i>
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
<i>Src</i> and <i>dst</i> are the source and destination IP addresses and ports.
  <i>Flags</i> are some combination of S (SYN), F (FIN), P (PUSH), R (RST), U
  (URG), W (ECN CWR), E (ECN-Echo) or `.' (ACK), or `none' if no flags are set.
  <i>Data-seqno</i> describes the portion of sequence space covered by the data
  in this packet (see example below). <i>Ack</i> is sequence number of the next
  data expected the other direction on this connection. <i>Window</i> is the
  number of bytes of receive buffer space available the other direction on this
  connection. <i>Urg</i> indicates there is `urgent' data in the packet.
  <i>Options</i> are tcp options enclosed in angle brackets (e.g., &lt;mss
  1024&gt;).
<div class="Pp"></div>
<i>Src, dst</i> and <i>flags</i> are always present. The other fields depend on
  the contents of the packet's tcp protocol header and are output only if
  appropriate.
<div class="Pp"></div>
Here is the opening portion of an rlogin from host <i>rtsg</i> to host
  <i>csam</i>.
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;
csam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;
rtsg.1023 &gt; csam.login: . ack 1 win 4096
rtsg.1023 &gt; csam.login: P 1:2(1) ack 1 win 4096
csam.login &gt; rtsg.1023: . ack 2 win 4096
rtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096
csam.login &gt; rtsg.1023: P 1:2(1) ack 21 win 4077
csam.login &gt; rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
csam.login &gt; rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
The first line says that tcp port 1023 on rtsg sent a packet to port
  <i>login</i> on csam. The <b>S</b> indicates that the <i>SYN</i> flag was set.
  The packet sequence number was 768512 and it contained no data. (The notation
  is `first:last(nbytes)' which means `sequence numbers <i>first</i> up to but
  not including <i>last</i> which is <i>nbytes</i> bytes of user data'.) There
  was no piggy-backed ack, the available receive window was 4096 bytes and there
  was a max-segment-size option requesting an mss of 1024 bytes.
<div class="Pp"></div>
Csam replies with a similar packet except it includes a piggy-backed ack for
  rtsg's SYN. Rtsg then acks csam's SYN. The `.' means the ACK flag was set. The
  packet contained no data so there is no data sequence number. Note that the
  ack sequence number is a small integer (1). The first time <i>tcpdump</i> sees
  a tcp `conversation', it prints the sequence number from the packet. On
  subsequent packets of the conversation, the difference between the current
  packet's sequence number and this initial sequence number is printed. This
  means that sequence numbers after the first can be interpreted as relative
  byte positions in the conversation's data stream (with the first data byte
  each direction being `1'). `-S' will override this feature, causing the
  original sequence numbers to be output.
<div class="Pp"></div>
On the 6th line, rtsg sends csam 19 bytes of data (bytes 2 through 20 in the
  rtsg &#x2192; csam side of the conversation). The PUSH flag is set in the
  packet. On the 7th line, csam says it's received data sent by rtsg up to but
  not including byte 21. Most of this data is apparently sitting in the socket
  buffer since csam's receive window has gotten 19 bytes smaller. Csam also
  sends one byte of data to rtsg in this packet. On the 8th and 9th lines, csam
  sends two bytes of urgent, pushed data to rtsg.
<div class="Pp"></div>
If the snapshot was small enough that <i>tcpdump</i> didn't capture the full TCP
  header, it interprets as much of the header as it can and then reports ``[|
  <i>tcp</i>]'' to indicate the remainder could not be interpreted. If the
  header contains a bogus option (one with a length that's either too small or
  beyond the end of the header), <i>tcpdump</i> reports it as ``[ <i>bad
  opt</i>]'' and does not interpret any further options (since it's impossible
  to tell where they start). If the header length indicates options are present
  but the IP datagram length is not long enough for the options to actually be
  there, <i>tcpdump</i> reports it as ``[ <i>bad hdr length</i>]''.
<div style="height: 1.50em;">&#x00A0;</div>
<b>Capturing TCP packets with particular flag combinations (SYN-ACK, URG-ACK,
  etc.)</b>
<div class="Pp"></div>
There are 8 bits in the control bits section of the TCP header:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><i>CWR | ECE | URG | ACK | PSH | RST | SYN | FIN</i></dd>
</dl>
<div class="Pp"></div>
Let's assume that we want to watch packets used in establishing a TCP
  connection. Recall that TCP uses a 3-way handshake protocol when it
  initializes a new connection; the connection sequence with regard to the TCP
  control bits is
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">1) Caller sends SYN</div>
<div style="margin-left: 5.00ex;">2) Recipient responds with SYN, ACK</div>
<div style="margin-left: 5.00ex;">3) Caller sends ACK</div>
<div class="Pp"></div>
Now we're interested in capturing packets that have only the SYN bit set (Step
  1). Note that we don't want packets from step 2 (SYN-ACK), just a plain
  initial SYN. What we need is a correct filter expression for <i>tcpdump</i>.
<div class="Pp"></div>
Recall the structure of a TCP header without options:
<div class="Pp"></div>
<pre>
 0                            15                              31
-----------------------------------------------------------------
|          source port          |       destination port        |
-----------------------------------------------------------------
|                        sequence number                        |
-----------------------------------------------------------------
|                     acknowledgment number                     |
-----------------------------------------------------------------
|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
-----------------------------------------------------------------
|         TCP checksum          |       urgent pointer          |
-----------------------------------------------------------------
</pre>
<div class="Pp"></div>
A TCP header usually holds 20 octets of data, unless options are present. The
  first line of the graph contains octets 0 - 3, the second line shows octets 4
  - 7 etc.
<div class="Pp"></div>
Starting to count with 0, the relevant TCP control bits are contained in octet
  13:
<div class="Pp"></div>
<pre>
 0             7|             15|             23|             31
----------------|---------------|---------------|----------------
|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
----------------|---------------|---------------|----------------
|               |  13th octet   |               |               |
</pre>
<div class="Pp"></div>
Let's have a closer look at octet no. 13:
<div class="Pp"></div>
<pre>
                |               |
                |---------------|
                |C|E|U|A|P|R|S|F|
                |---------------|
                |7   5   3     0|
</pre>
<div class="Pp"></div>
These are the TCP control bits we are interested in. We have numbered the bits
  in this octet from 0 to 7, right to left, so the PSH bit is bit number 3,
  while the URG bit is number 5.
<div class="Pp"></div>
Recall that we want to capture packets with only SYN set. Let's see what happens
  to octet 13 if a TCP datagram arrives with the SYN bit set in its header:
<div class="Pp"></div>
<pre>
                |C|E|U|A|P|R|S|F|
                |---------------|
                |0 0 0 0 0 0 1 0|
                |---------------|
                |7 6 5 4 3 2 1 0|
</pre>
<div class="Pp"></div>
Looking at the control bits section we see that only bit number 1 (SYN) is set.
<div class="Pp"></div>
Assuming that octet number 13 is an 8-bit unsigned integer in network byte
  order, the binary value of this octet is
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">00000010</dd>
</dl>
<div class="Pp"></div>
and its decimal representation is
<div class="Pp"></div>
<pre>
   7     6     5     4     3     2     1     0
0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2  =  2
</pre>
<div class="Pp"></div>
We're almost done, because now we know that if only SYN is set, the value of the
  13th octet in the TCP header, when interpreted as a 8-bit unsigned integer in
  network byte order, must be exactly 2.
<div class="Pp"></div>
This relationship can be expressed as
<div style="margin-left: 5.00ex;"><b>tcp[13] == 2</b></div>
<div class="Pp"></div>
We can use this expression as the filter for <i>tcpdump</i> in order to watch
  packets which have only SYN set:
<div style="margin-left: 5.00ex;"><b>tcpdump -i xl0 tcp[13] == 2</b></div>
<div class="Pp"></div>
The expression says &quot;let the 13th octet of a TCP datagram have the decimal
  value 2&quot;, which is exactly what we want.
<div class="Pp"></div>
Now, let's assume that we need to capture SYN packets, but we don't care if ACK
  or any other TCP control bit is set at the same time. Let's see what happens
  to octet 13 when a TCP datagram with SYN-ACK set arrives:
<div class="Pp"></div>
<pre>
     |C|E|U|A|P|R|S|F|
     |---------------|
     |0 0 0 1 0 0 1 0|
     |---------------|
     |7 6 5 4 3 2 1 0|
</pre>
<div class="Pp"></div>
Now bits 1 and 4 are set in the 13th octet. The binary value of octet 13 is
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <br/>
     00010010</dd>
</dl>
<div class="Pp"></div>
which translates to decimal
<div class="Pp"></div>
<pre>
   7     6     5     4     3     2     1     0
0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2   = 18
</pre>
<div class="Pp"></div>
Now we can't just use 'tcp[13] == 18' in the <i>tcpdump</i> filter expression,
  because that would select only those packets that have SYN-ACK set, but not
  those with only SYN set. Remember that we don't care if ACK or any other
  control bit is set as long as SYN is set.
<div class="Pp"></div>
In order to achieve our goal, we need to logically AND the binary value of octet
  13 with some other value to preserve the SYN bit. We know that we want SYN to
  be set in any case, so we'll logically AND the value in the 13th octet with
  the binary value of a SYN:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
          00010010 SYN-ACK              00000010 SYN
     AND  00000010 (we want SYN)   AND  00000010 (we want SYN)
          --------                      --------
     =    00000010                 =    00000010
</pre>
<div class="Pp"></div>
We see that this AND operation delivers the same result regardless whether ACK
  or another TCP control bit is set. The decimal representation of the AND value
  as well as the result of this operation is 2 (binary 00000010), so we know
  that for packets with SYN set the following relation must hold true:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">( ( value of octet 13 ) AND ( 2 ) ) == ( 2 )</dd>
</dl>
<div class="Pp"></div>
This points us to the <i>tcpdump</i> filter expression
<div style="margin-left: 5.00ex;"><b>
<br/>
 tcpdump -i xl0 'tcp[13] &amp; 2 == 2'</b></div>
<div class="Pp"></div>
Some offsets and field values may be expressed as names rather than as numeric
  values. For example tcp[13] may be replaced with tcp[tcpflags]. The following
  TCP flag field values are also available: tcp-fin, tcp-syn, tcp-rst, tcp-push,
  tcp-act, tcp-urg.
<div class="Pp"></div>
This can be demonstrated as:
<div style="margin-left: 5.00ex;"><b>
<br/>
 tcpdump -i xl0 'tcp[tcpflags] &amp; tcp-push != 0'</b></div>
<div class="Pp"></div>
Note that you should use single quotes or a backslash in the expression to hide
  the AND ('&amp;') special character from the shell.
<div style="height: 1.50em;">&#x00A0;</div>
<b>UDP Packets</b>
<div class="Pp"></div>
UDP format is illustrated by this rwho packet:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
actinide.who &gt; broadcast.who: udp 84
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
This says that port <i>who</i> on host <i>actinide</i> sent a udp datagram to
  port <i>who</i> on host <i>broadcast</i>, the Internet broadcast address. The
  packet contained 84 bytes of user data.
<div class="Pp"></div>
Some UDP services are recognized (from the source or destination port number)
  and the higher level protocol information printed. In particular, Domain Name
  service requests (RFC-1034/1035) and Sun RPC calls (RFC-1050) to NFS.
<div style="height: 1.50em;">&#x00A0;</div>
<b>UDP Name Server Requests</b>
<div class="Pp"></div>
<i>(N.B.:The following description assumes familiarity with</i> <i>the Domain
  Service protocol described in RFC-1035.</i> <i>If you are not familiar</i>
  <i>with the protocol, the following description will appear to be written</i>
  <i>in greek.)</i>
<div class="Pp"></div>
Name server requests are formatted as
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<i>src &gt; dst: id op? flags qtype qclass name (len)</i>
<div style="height: 0.50em;">&#x00A0;</div>
h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
Host <i>h2opolo</i> asked the domain server on <i>helios</i> for an address
  record (qtype=A) associated with the name <i>ucbvax.berkeley.edu.</i> The
  query id was `3'. The `+' indicates the <i>recursion desired</i> flag was set.
  The query length was 37 bytes, not including the UDP and IP protocol headers.
  The query operation was the normal one, <i>Query</i>, so the op field was
  omitted. If the op had been anything else, it would have been printed between
  the `3' and the `+'. Similarly, the qclass was the normal one, <i>C_IN</i>,
  and omitted. Any other qclass would have been printed immediately after the
  `A'.
<div class="Pp"></div>
A few anomalies are checked and may result in extra fields enclosed in square
  brackets: If a query contains an answer, authority records or additional
  records section, <i>ancount</i>, <i>nscount</i>, or <i>arcount</i> are printed
  as `[ <i>n</i>a]', `[<i>n</i>n]' or `[<i>n</i>au]' where <i>n</i> is the
  appropriate count. If any of the response bits are set (AA, RA or rcode) or
  any of the `must be zero' bits are set in bytes two and three, `[b2&amp;3=
  <i>x</i>]' is printed, where <i>x</i> is the hex value of header bytes two and
  three.
<div style="height: 1.50em;">&#x00A0;</div>
<b>UDP Name Server Responses</b>
<div class="Pp"></div>
Name server responses are formatted as
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<i>src &gt; dst:  id op rcode flags a/n/au type class data (len)</i>
<div style="height: 0.50em;">&#x00A0;</div>
helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
In the first example, <i>helios</i> responds to query id 3 from <i>h2opolo</i>
  with 3 answer records, 3 name server records and 7 additional records. The
  first answer record is type A (address) and its data is internet address
  128.32.137.3. The total size of the response was 273 bytes, excluding UDP and
  IP headers. The op (Query) and response code (NoError) were omitted, as was
  the class (C_IN) of the A record.
<div class="Pp"></div>
In the second example, <i>helios</i> responds to query 2 with a response code of
  non-existent domain (NXDomain) with no answers, one name server and no
  authority records. The `*' indicates that the <i>authoritative answer</i> bit
  was set. Since there were no answers, no type, class or data were printed.
<div class="Pp"></div>
Other flag characters that might appear are `-' (recursion available, RA,
  <i>not</i> set) and `|' (truncated message, TC, set). If the `question'
  section doesn't contain exactly one entry, `[ <i>n</i>q]' is printed.
<div style="height: 1.50em;">&#x00A0;</div>
<b>SMB/CIFS decoding</b>
<div class="Pp"></div>
<i>tcpdump</i> now includes fairly extensive SMB/CIFS/NBT decoding for data on
  UDP/137, UDP/138 and TCP/139. Some primitive decoding of IPX and NetBEUI SMB
  data is also done.
<div class="Pp"></div>
By default a fairly minimal decode is done, with a much more detailed decode
  done if -v is used. Be warned that with -v a single SMB packet may take up a
  page or more, so only use -v if you really want all the gory details.
<div class="Pp"></div>
For information on SMB packet formats and what all the fields mean see
  www.cifs.org or the pub/samba/specs/ directory on your favorite samba.org
  mirror site. The SMB patches were written by Andrew Tridgell
  (tridge@samba.org).
<div style="height: 1.50em;">&#x00A0;</div>
<b>NFS Requests and Replies</b>
<div class="Pp"></div>
Sun NFS (Network File System) requests and replies are printed as:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<i>src.xid &gt; dst.nfs: len op args</i>
<i>src.nfs &gt; dst.xid: reply stat len op results</i>
<div style="height: 0.50em;">&#x00A0;</div>
sushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165
wrl.nfs &gt; sushi.6709: reply ok 40 readlink &quot;../var&quot;
sushi.201b &gt; wrl.nfs:
	144 lookup fh 9,74/4096.6878 &quot;xcolors&quot;
wrl.nfs &gt; sushi.201b:
	reply ok 128 lookup fh 9,74/4134.3150
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
In the first line, host <i>sushi</i> sends a transaction with id <i>6709</i> to
  <i>wrl</i> (note that the number following the src host is a transaction id,
  <i>not</i> the source port). The request was 112 bytes, excluding the UDP and
  IP headers. The operation was a <i>readlink</i> (read symbolic link) on file
  handle ( <i>fh</i>) 21,24/10.731657119. (If one is lucky, as in this case, the
  file handle can be interpreted as a major,minor device number pair, followed
  by the inode number and generation number.) <i>Wrl</i> replies `ok' with the
  contents of the link.
<div class="Pp"></div>
In the third line, <i>sushi</i> asks <i>wrl</i> to lookup the name `
  <i>xcolors</i>' in directory file 9,74/4096.6878. Note that the data printed
  depends on the operation type. The format is intended to be self explanatory
  if read in conjunction with an NFS protocol spec.
<div class="Pp"></div>
If the -v (verbose) flag is given, additional information is printed. For
  example:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
sushi.1372a &gt; wrl.nfs:
	148 read fh 21,11/12.195 8192 bytes @ 24576
wrl.nfs &gt; sushi.1372a:
	reply ok 1472 read REG 100664 ids 417/0 sz 29388
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
(-v also prints the IP header TTL, ID, length, and fragmentation fields, which
  have been omitted from this example.) In the first line, <i>sushi</i> asks
  <i>wrl</i> to read 8192 bytes from file 21,11/12.195, at byte offset 24576.
  <i>Wrl</i> replies `ok'; the packet shown on the second line is the first
  fragment of the reply, and hence is only 1472 bytes long (the other bytes will
  follow in subsequent fragments, but these fragments do not have NFS or even
  UDP headers and so might not be printed, depending on the filter expression
  used). Because the -v flag is given, some of the file attributes (which are
  returned in addition to the file data) are printed: the file type (``REG'',
  for regular file), the file mode (in octal), the uid and gid, and the file
  size.
<div class="Pp"></div>
If the -v flag is given more than once, even more details are printed.
<div class="Pp"></div>
Note that NFS requests are very large and much of the detail won't be printed
  unless <i>snaplen</i> is increased. Try using ` <b>-s 192</b>' to watch NFS
  traffic.
<div class="Pp"></div>
NFS reply packets do not explicitly identify the RPC operation. Instead,
  <i>tcpdump</i> keeps track of ``recent'' requests, and matches them to the
  replies using the transaction ID. If a reply does not closely follow the
  corresponding request, it might not be parsable.
<div style="height: 1.50em;">&#x00A0;</div>
<b>AFS Requests and Replies</b>
<div class="Pp"></div>
Transarc AFS (Andrew File System) requests and replies are printed as:
<div style="height: 1.50em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<i>src.sport &gt; dst.dport: rx packet-type</i>
<i>src.sport &gt; dst.dport: rx packet-type service call call-name args</i>
<i>src.sport &gt; dst.dport: rx packet-type service reply call-name args</i>
<div style="height: 0.50em;">&#x00A0;</div>
elvis.7001 &gt; pike.afsfs:
	rx data fs call rename old fid 536876964/1/1 &quot;.newsrc.new&quot;
	new fid 536876964/1/1 &quot;.newsrc&quot;
pike.afsfs &gt; elvis.7001: rx data fs reply rename
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
In the first line, host elvis sends a RX packet to pike. This was a RX data
  packet to the fs (fileserver) service, and is the start of an RPC call. The
  RPC call was a rename, with the old directory file id of 536876964/1/1 and an
  old filename of `.newsrc.new', and a new directory file id of 536876964/1/1
  and a new filename of `.newsrc'. The host pike responds with a RPC reply to
  the rename call (which was successful, because it was a data packet and not an
  abort packet).
<div class="Pp"></div>
In general, all AFS RPCs are decoded at least by RPC call name. Most AFS RPCs
  have at least some of the arguments decoded (generally only the `interesting'
  arguments, for some definition of interesting).
<div class="Pp"></div>
The format is intended to be self-describing, but it will probably not be useful
  to people who are not familiar with the workings of AFS and RX.
<div class="Pp"></div>
If the -v (verbose) flag is given twice, acknowledgement packets and additional
  header information is printed, such as the RX call ID, call number, sequence
  number, serial number, and the RX packet flags.
<div class="Pp"></div>
If the -v flag is given twice, additional information is printed, such as the RX
  call ID, serial number, and the RX packet flags. The MTU negotiation
  information is also printed from RX ack packets.
<div class="Pp"></div>
If the -v flag is given three times, the security index and service id are
  printed.
<div class="Pp"></div>
Error codes are printed for abort packets, with the exception of Ubik beacon
  packets (because abort packets are used to signify a yes vote for the Ubik
  protocol).
<div class="Pp"></div>
Note that AFS requests are very large and many of the arguments won't be printed
  unless <i>snaplen</i> is increased. Try using ` <b>-s 256</b>' to watch AFS
  traffic.
<div class="Pp"></div>
AFS reply packets do not explicitly identify the RPC operation. Instead,
  <i>tcpdump</i> keeps track of ``recent'' requests, and matches them to the
  replies using the call number and service ID. If a reply does not closely
  follow the corresponding request, it might not be parsable.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.50em;">&#x00A0;</div>
<b>KIP AppleTalk (DDP in UDP)</b>
<div class="Pp"></div>
AppleTalk DDP packets encapsulated in UDP datagrams are de-encapsulated and
  dumped as DDP packets (i.e., all the UDP header information is discarded). The
  file <i>/etc/atalk.names</i> is used to translate AppleTalk net and node
  numbers to names. Lines in this file have the form
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<i>number	name</i>
<div class="Pp"></div>
1.254		ether
16.1		icsd-net
1.254.110	ace
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
The first two lines give the names of AppleTalk networks. The third line gives
  the name of a particular host (a host is distinguished from a net by the 3rd
  octet in the number - a net number <i>must</i> have two octets and a host
  number <i>must</i> have three octets.) The number and name should be separated
  by whitespace (blanks or tabs). The <i>/etc/atalk.names</i> file may contain
  blank lines or comment lines (lines starting with a `#').
<div class="Pp"></div>
AppleTalk addresses are printed in the form
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<i>net.host.port</i>
<div class="Pp"></div>
144.1.209.2 &gt; icsd-net.112.220
office.2 &gt; icsd-net.112.220
jssmag.149.235 &gt; icsd-net.2
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
(If the <i>/etc/atalk.names</i> doesn't exist or doesn't contain an entry for
  some AppleTalk host/net number, addresses are printed in numeric form.) In the
  first example, NBP (DDP port 2) on net 144.1 node 209 is sending to whatever
  is listening on port 220 of net icsd node 112. The second line is the same
  except the full name of the source node is known (`office'). The third line is
  a send from port 235 on net jssmag node 149 to broadcast on the icsd-net NBP
  port (note that the broadcast address (255) is indicated by a net name with no
  host number - for this reason it's a good idea to keep node names and net
  names distinct in /etc/atalk.names).
<div class="Pp"></div>
NBP (name binding protocol) and ATP (AppleTalk transaction protocol) packets
  have their contents interpreted. Other protocols just dump the protocol name
  (or number if no name is registered for the protocol) and packet size.
<div style="height: 1.00em;">&#x00A0;</div>
<b>NBP packets</b> are formatted like the following examples:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: &quot;=:LaserWriter@*&quot;
jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;RM1140:LaserWriter@*&quot; 250
techpit.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;techpit:LaserWriter@*&quot; 186
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
The first line is a name lookup request for laserwriters sent by net icsd host
  112 and broadcast on net jssmag. The nbp id for the lookup is 190. The second
  line shows a reply for this request (note that it has the same id) from host
  jssmag.209 saying that it has a laserwriter resource named &quot;RM1140&quot;
  registered on port 250. The third line is another reply to the same request
  saying host techpit has laserwriter &quot;techpit&quot; registered on port
  186.
<div style="height: 1.00em;">&#x00A0;</div>
<b>ATP packet</b> formatting is demonstrated by the following example:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001
helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
jssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
jssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001
jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
Jssmag.209 initiates transaction id 12266 with host helios by requesting up to 8
  packets (the `&lt;0-7&gt;'). The hex number at the end of the line is the
  value of the `userdata' field in the request.
<div class="Pp"></div>
Helios responds with 8 512-byte packets. The `:digit' following the transaction
  id gives the packet sequence number in the transaction and the number in
  parens is the amount of data in the packet, excluding the atp header. The `*'
  on packet 7 indicates that the EOM bit was set.
<div class="Pp"></div>
Jssmag.209 then requests that packets 3 &amp; 5 be retransmitted. Helios resends
  them then jssmag.209 releases the transaction. Finally, jssmag.209 initiates
  the next request. The `*' on the request indicates that XO (`exactly once')
  was <i>not</i> set.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.50em;">&#x00A0;</div>
<b>IP Fragmentation</b>
<div class="Pp"></div>
Fragmented Internet datagrams are printed as
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
<b>(frag </b><i>id</i><b>:</b><i>size</i><b>@</b><i>offset</i><b>+)</b>
<b>(frag </b><i>id</i><b>:</b><i>size</i><b>@</b><i>offset</i><b>)</b>
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
(The first form indicates there are more fragments. The second indicates this is
  the last fragment.)
<div class="Pp"></div>
<i>Id</i> is the fragment id. <i>Size</i> is the fragment size (in bytes)
  excluding the IP header. <i>Offset</i> is this fragment's offset (in bytes) in
  the original datagram.
<div class="Pp"></div>
The fragment information is output for each fragment. The first fragment
  contains the higher level protocol header and the frag info is printed after
  the protocol info. Fragments after the first contain no higher level protocol
  header and the frag info is printed after the source and destination
  addresses. For example, here is part of an ftp from arizona.edu to
  lbl-rtsg.arpa over a CSNET connection that doesn't appear to handle 576 byte
  datagrams:
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
arizona &gt; rtsg: (frag 595a:204@328)
rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
There are a couple of things to note here: First, addresses in the 2nd line
  don't include port numbers. This is because the TCP protocol information is
  all in the first fragment and we have no idea what the port or sequence
  numbers are when we print the later fragments. Second, the tcp sequence
  information in the first line is printed as if there were 308 bytes of user
  data when, in fact, there are 512 bytes (308 in the first frag and 204 in the
  second). If you are looking for holes in the sequence space or trying to match
  up acks with packets, this can fool you.
<div class="Pp"></div>
A packet with the IP <i>don't fragment</i> flag is marked with a trailing
  <b>(DF)</b>.
<div style="height: 1.50em;">&#x00A0;</div>
<b>Timestamps</b>
<div class="Pp"></div>
By default, all output lines are preceded by a timestamp. The timestamp is the
  current clock time in the form
<div style="margin-left: 5.00ex;">
<pre>
<i>hh:mm:ss.frac</i>
</pre>
</div>
and is as accurate as the kernel's clock. The timestamp reflects the time the
  kernel first saw the packet. No attempt is made to account for the time lag
  between when the Ethernet interface removed the packet from the wire and when
  the kernel serviced the `new packet' interrupt.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
stty(1), pcap(3PCAP), bpf(4), nit(4P), pcap-savefile(5), pcap-filter(7),
  pcap-tstamp-type(7)
<div class="Pp"></div>
<div style="margin-left: 5.00ex;"><i>http://www.iana.org/assignments/media-types/application/vnd.tcpdump.pcap</i></div>
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
The original authors are:
<div class="Pp"></div>
Van Jacobson, Craig Leres and Steven McCanne, all of the Lawrence Berkeley
  National Laboratory, University of California, Berkeley, CA.
<div class="Pp"></div>
It is currently being maintained by tcpdump.org.
<div class="Pp"></div>
The current version is available via http:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;"><i>http://www.tcpdump.org/</i></div>
<div class="Pp"></div>
The original distribution is available via anonymous ftp:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;"><i>ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z</i></div>
<div class="Pp"></div>
IPv6/IPsec support is added by WIDE/KAME project. This program uses Eric Young's
  SSLeay library, under specific configurations.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Please send problems, bugs, questions, desirable enhancements, patches etc. to:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">tcpdump-workers@lists.tcpdump.org</div>
<div class="Pp"></div>
NIT doesn't let you watch your own outbound traffic, BPF will. We recommend that
  you use the latter.
<div class="Pp"></div>
On Linux systems with 2.0[.x] kernels:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">packets on the loopback device will be seen twice;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">packet filtering cannot be done in the kernel, so that all
      packets must be copied from the kernel in order to be filtered in user
      mode;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">all of a packet, not just the part that's within the
      snapshot length, will be copied from the kernel (the 2.0[.x] packet
      capture mechanism, if asked to copy only part of a packet to userland,
      will not report the true length of the packet; this would cause most IP
      packets to get an error from <b>tcpdump</b>);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">capturing on some PPP devices won't work correctly.</dd>
</dl>
<div class="Pp"></div>
We recommend that you upgrade to a 2.2 or later kernel.
<div class="Pp"></div>
Some attempt should be made to reassemble IP fragments or, at least to compute
  the right length for the higher level protocol.
<div class="Pp"></div>
Name server inverse queries are not dumped correctly: the (empty) question
  section is printed rather than real query in the answer section. Some believe
  that inverse queries are themselves a bug and prefer to fix the program
  generating them rather than <i>tcpdump</i>.
<div class="Pp"></div>
A packet trace that crosses a daylight savings time change will give skewed time
  stamps (the time change is ignored).
<div class="Pp"></div>
Filter expressions on fields other than those in Token Ring headers will not
  correctly handle source-routed Token Ring packets.
<div class="Pp"></div>
Filter expressions on fields other than those in 802.11 headers will not
  correctly handle 802.11 data packets with both To DS and From DS set.
<div class="Pp"></div>
<b>ip6 proto</b> should chase header chain, but at this moment it does not.
  <b>ip6 protochain</b> is supplied for this behavior.
<div class="Pp"></div>
Arithmetic expression against transport layer headers, like <b>tcp[0]</b>, does
  not work against IPv6 packets. It only looks at IPv4 packets.</div>
<table class="foot">
  <tr>
    <td class="foot-date">12 July 2012</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
