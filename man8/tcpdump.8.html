<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:16:49 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>TCPDUMP(8) System Manager&rsquo;s Manual TCPDUMP(8)</p>

<p style="margin-top: 1em">NAME <br>
tcpdump - dump traffic on a network</p>

<p style="margin-top: 1em">SYNOPSIS <br>
tcpdump [ -AbdDefhHIJKlLnNOpqRStuUvxX ] [ -B buffer_size ] [
-c count ] <br>
[ -C file_size ] [ -G rotate_seconds ] [ -F file ] <br>
[ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M
secret ] <br>
[ -P in|out|inout ] <br>
[ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file
] <br>
[ -W filecount ] <br>
[ -E spi@ipaddr algo:secret,... ] <br>
[ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]
<br>
[ expression ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Tcpdump prints out a description of the contents of packets
on a network interface that match the boolean expression. It
can also be run with the -w flag, which causes it to <br>
save the packet data to a file for later analysis, and/or
with the -r flag, which causes it to read from a saved
packet file rather than to read packets from a network
interface. <br>
It can also be run with the -V flag, which causes it to read
a list of saved packet files. In all cases, only packets
that match expression will be processed by tcpdump.</p>

<p style="margin-top: 1em">Tcpdump will, if not run with
the -c flag, continue capturing packets until it is
interrupted by a SIGINT signal (generated, for example, by
typing your interrupt character, typ&acirc; <br>
ically control-C) or a SIGTERM signal (typically generated
with the kill(1) command); if run with the -c flag, it will
capture packets until it is interrupted by a SIGINT or <br>
SIGTERM signal or the specified number of packets have been
processed.</p>

<p style="margin-top: 1em">When tcpdump finishes capturing
packets, it will report counts of:</p>

<p style="margin-top: 1em">packets
&lsquo;&lsquo;captured&rsquo;&rsquo; (this is the number of
packets that tcpdump has received and processed);</p>

<p style="margin-top: 1em">packets &lsquo;&lsquo;received
by filter&rsquo;&rsquo; (the meaning of this depends on the
OS on which you&rsquo;re running tcpdump, and possibly on
the way the OS was configured - if a filter was <br>
specified on the command line, on some OSes it counts
packets regardless of whether they were matched by the
filter expression and, even if they were matched by the
filter <br>
expression, regardless of whether tcpdump has read and
processed them yet, on other OSes it counts only packets
that were matched by the filter expression regardless of
<br>
whether tcpdump has read and processed them yet, and on
other OSes it counts only packets that were matched by the
filter expression and were processed by tcpdump);</p>

<p style="margin-top: 1em">packets &lsquo;&lsquo;dropped by
kernel&rsquo;&rsquo; (this is the number of packets that
were dropped, due to a lack of buffer space, by the packet
capture mechanism in the OS on which tcpdump <br>
is running, if the OS reports that information to
applications; if not, it will be reported as 0).</p>

<p style="margin-top: 1em">On platforms that support the
SIGINFO signal, such as most BSDs (including Mac OS X) and
Digital/Tru64 UNIX, it will report those counts when it
receives a SIGINFO signal (gener&acirc; <br>
ated, for example, by typing your
&lsquo;&lsquo;status&rsquo;&rsquo; character, typically
control-T, although on some platforms, such as Mac OS X, the
&lsquo;&lsquo;status&rsquo;&rsquo; character is not set by
default, so you <br>
must set it with stty(1) in order to use it) and will
continue capturing packets.</p>

<p style="margin-top: 1em">Reading packets from a network
interface may require that you have special privileges; see
the pcap (3PCAP) man page for details. Reading a saved
packet file doesn&rsquo;t require <br>
special privileges.</p>

<p style="margin-top: 1em">OPTIONS <br>
-A Print each packet (minus its link level header) in ASCII.
Handy for capturing web pages.</p>

<p style="margin-top: 1em">-b Print the AS number in BGP
packets in ASDOT notation rather than ASPLAIN notation.</p>

<p style="margin-top: 1em">-B Set the operating system
capture buffer size to buffer_size, in units of KiB (1024
bytes).</p>

<p style="margin-top: 1em">-c Exit after receiving count
packets.</p>

<p style="margin-top: 1em">-C Before writing a raw packet
to a savefile, check whether the file is currently larger
than file_size and, if so, close the current savefile and
open a new one. Savefiles <br>
after the first savefile will have the name specified with
the -w flag, with a number after it, starting at 1 and
continuing upward. The units of file_size are millions <br>
of bytes (1,000,000 bytes, not 1,048,576 bytes).</p>

<p style="margin-top: 1em">Note that when used with -Z
option (enabled by default), privileges are dropped before
opening first savefile.</p>

<p style="margin-top: 1em">-d Dump the compiled
packet-matching code in a human readable form to standard
output and stop.</p>

<p style="margin-top: 1em">-dd Dump packet-matching code as
a C program fragment.</p>

<p style="margin-top: 1em">-ddd Dump packet-matching code
as decimal numbers (preceded with a count).</p>

<p style="margin-top: 1em">-D Print the list of the network
interfaces available on the system and on which tcpdump can
capture packets. For each network interface, a number and an
interface name, <br>
possibly followed by a text description of the interface, is
printed. The interface name or the number can be supplied to
the -i flag to specify an interface on which to <br>
capture.</p>

<p style="margin-top: 1em">This can be useful on systems
that don&rsquo;t have a command to list them (e.g., Windows
systems, or UNIX systems lacking ifconfig -a); the number
can be useful on Windows 2000 <br>
and later systems, where the interface name is a somewhat
complex string.</p>

<p style="margin-top: 1em">The -D flag will not be
supported if tcpdump was built with an older version of
libpcap that lacks the pcap_findalldevs() function.</p>

<p style="margin-top: 1em">-e Print the link-level header
on each dump line. This can be used, for example, to print
MAC layer addresses for protocols such as Ethernet and IEEE
802.11.</p>

<p style="margin-top: 1em">-E Use spi@ipaddr algo:secret
for decrypting IPsec ESP packets that are addressed to addr
and contain Security Parameter Index value spi. This
combination may be repeated <br>
with comma or newline separation.</p>

<p style="margin-top: 1em">Note that setting the secret for
IPv4 ESP packets is supported at this time.</p>

<p style="margin-top: 1em">Algorithms may be des-cbc,
3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, or none. The
default is des-cbc. The ability to decrypt packets is only
present if tcpdump was <br>
compiled with cryptography enabled.</p>

<p style="margin-top: 1em">secret is the ASCII text for ESP
secret key. If preceded by 0x, then a hex value will be
read.</p>

<p style="margin-top: 1em">The option assumes RFC2406 ESP,
not RFC1827 ESP. The option is only for debugging purposes,
and the use of this option with a true &lsquo;secret&rsquo;
key is discouraged. By pre&acirc; <br>
senting IPsec secret key onto command line you make it
visible to others, via ps(1) and other occasions.</p>

<p style="margin-top: 1em">In addition to the above syntax,
the syntax file name may be used to have tcpdump read the
provided file in. The file is opened upon receiving the
first ESP packet, so any <br>
special permissions that tcpdump may have been given should
already have been given up.</p>

<p style="margin-top: 1em">-f Print &lsquo;foreign&rsquo;
IPv4 addresses numerically rather than symbolically (this
option is intended to get around serious brain damage in
Sun&rsquo;s NIS server &acirc; usually it hangs for&acirc;
<br>
ever translating non-local internet numbers).</p>

<p style="margin-top: 1em">The test for
&lsquo;foreign&rsquo; IPv4 addresses is done using the IPv4
address and netmask of the interface on which capture is
being done. If that address or netmask are not <br>
available, available, either because the interface on which
capture is being done has no address or netmask or because
the capture is being done on the Linux &quot;any&quot;
inter&acirc; <br>
face, which can capture on more than one interface, this
option will not work correctly.</p>

<p style="margin-top: 1em">-F Use file as input for the
filter expression. An additional expression given on the
command line is ignored.</p>

<p style="margin-top: 1em">-G If specified, rotates the
dump file specified with the -w option every rotate_seconds
seconds. Savefiles will have the name specified by -w which
should include a time <br>
format as defined by strftime(3). If no time format is
specified, each new file will overwrite the previous.</p>

<p style="margin-top: 1em">If used in conjunction with the
-C option, filenames will take the form of
&lsquo;file&lt;count&gt;&rsquo;.</p>

<p style="margin-top: 1em">-h Print the tcpdump and libpcap
version strings, print a usage message, and exit.</p>

<p style="margin-top: 1em">-H Attempt to detect 802.11s
draft mesh headers.</p>

<p style="margin-top: 1em">-i Listen on interface. If
unspecified, tcpdump searches the system interface list for
the lowest numbered, configured up interface (excluding
loopback), which may turn out <br>
to be, for example, &lsquo;&lsquo;eth0&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">On Linux systems with 2.2 or
later kernels, an interface argument of
&lsquo;&lsquo;any&rsquo;&rsquo; can be used to capture
packets from all interfaces. Note that captures on the
&lsquo;&lsquo;any&rsquo;&rsquo; device <br>
will not be done in promiscuous mode.</p>

<p style="margin-top: 1em">If the -D flag is supported, an
interface number as printed by that flag can be used as the
interface argument.</p>

<p style="margin-top: 1em">-I Put the interface in
&quot;monitor mode&quot;; this is supported only on IEEE
802.11 Wi-Fi interfaces, and supported only on some
operating systems.</p>

<p style="margin-top: 1em">Note that in monitor mode the
adapter might disassociate from the network with which
it&rsquo;s associated, so that you will not be able to use
any wireless networks with that <br>
adapter. This could prevent accessing files on a network
server, or resolving host names or network addresses, if you
are capturing in monitor mode and are not connected <br>
to another network with another adapter.</p>

<p style="margin-top: 1em">This flag will affect the output
of the -L flag. If -I isn&rsquo;t specified, only those
link-layer types available when not in monitor mode will be
shown; if -I is specified, <br>
only those link-layer types available when in monitor mode
will be shown.</p>

<p style="margin-top: 1em">-j Set the time stamp type for
the capture to tstamp_type. The names to use for the time
stamp types are given in pcap-tstamp-type(7); not all the
types listed there will <br>
necessarily be valid for any given interface.</p>

<p style="margin-top: 1em">-J List the supported time stamp
types for the interface and exit. If the time stamp type
cannot be set for the interface, no time stamp types are
listed.</p>


<p style="margin-top: 1em">--time-stamp-precision=tstamp_precision
<br>
When capturing, set the time stamp precision for the capture
to tstamp_precision. Note that availability of high
precision time stamps (nanoseconds) and their actual <br>
accuracy is platform and hardware dependent. Also note that
when writing captures made with nanosecond accuracy to a
savefile, the time stamps are written with nanosecond <br>
resolution, and the file is written with a different magic
number, to indicate that the time stamps are in seconds and
nanoseconds; not all programs that read pcap save&acirc;
<br>
files will be able to read those captures.</p>

<p style="margin-top: 1em">When reading a savefile, convert
time stamps to the precision specified by
timestamp_precision, and display them with that resolution.
If the precision specified is less <br>
than the precision of time stamps in the file, the
conversion will lose precision.</p>

<p style="margin-top: 1em">The supported values for
timestamp_precision are micro for microsecond resolution and
nano for nanosecond resolution. The default is microsecond
resolution.</p>

<p style="margin-top: 1em">-K Don&rsquo;t attempt to verify
IP, TCP, or UDP checksums. This is useful for interfaces
that perform some or all of those checksum calculation in
hardware; otherwise, all outgo&acirc; <br>
ing TCP checksums will be flagged as bad.</p>

<p style="margin-top: 1em">-l Make stdout line buffered.
Useful if you want to see the data while capturing it.
E.g.,</p>

<p style="margin-top: 1em">tcpdump -l | tee dat</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">tcpdump -l &gt; dat &amp; tail
-f dat</p>

<p style="margin-top: 1em">Note that on
Windows,&lsquo;&lsquo;line buffered&rsquo;&rsquo; means
&lsquo;&lsquo;unbuffered&rsquo;&rsquo;, so that WinDump will
write each character individually if -l is specified.</p>

<p style="margin-top: 1em">-U is similar to -l in its
behavior, but it will cause output to be
&lsquo;&lsquo;packet-buffered&rsquo;&rsquo;, so that the
output is written to stdout at the end of each packet rather
than at <br>
the end of each line; this is buffered on all platforms,
including Windows.</p>

<p style="margin-top: 1em">-L List the known data link
types for the interface, in the specified mode, and exit.
The list of known data link types may be dependent on the
specified mode; for example, <br>
on some platforms, a Wi-Fi interface might support one set
of data link types when not in monitor mode (for example, it
might support only fake Ethernet headers, or might <br>
support 802.11 headers but not support 802.11 headers with
radio information) and another set of data link types when
in monitor mode (for example, it might support 802.11 <br>
headers, or 802.11 headers with radio information, only in
monitor mode).</p>

<p style="margin-top: 1em">-m Load SMI MIB module
definitions from file module. This option can be used
several times to load several MIB modules into tcpdump.</p>

<p style="margin-top: 1em">-M Use secret as a shared secret
for validating the digests found in TCP segments with the
TCP-MD5 option (RFC 2385), if present.</p>

<p style="margin-top: 1em">-n Don&rsquo;t convert host
addresses to names. This can be used to avoid DNS
lookups.</p>

<p style="margin-top: 1em">-nn Don&rsquo;t convert protocol
and port numbers etc. to names either.</p>

<p style="margin-top: 1em">-N Don&rsquo;t print domain name
qualification of host names. E.g., if you give this flag
then tcpdump will print &lsquo;&lsquo;nic&rsquo;&rsquo;
instead of &lsquo;&lsquo;nic.ddn.mil&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">-O Do not run the
packet-matching code optimizer. This is useful only if you
suspect a bug in the optimizer.</p>

<p style="margin-top: 1em">-p Don&rsquo;t put the interface
into promiscuous mode. Note that the interface might be in
promiscuous mode for some other reason; hence,
&lsquo;-p&rsquo; cannot be used as an abbreviation <br>
for &lsquo;ether host {local-hw-addr} or ether
broadcast&rsquo;.</p>

<p style="margin-top: 1em">-P Choose send/receive direction
direction for which packets should be captured. Possible
values are &lsquo;in&rsquo;, &lsquo;out&rsquo; and
&lsquo;inout&rsquo;. Not available on all platforms.</p>

<p style="margin-top: 1em">-q Quick (quiet?) output. Print
less protocol information so output lines are shorter.</p>

<p style="margin-top: 1em">-R Assume ESP/AH packets to be
based on old specification (RFC1825 to RFC1829). If
specified, tcpdump will not print replay prevention field.
Since there is no protocol <br>
version field in ESP/AH specification, tcpdump cannot deduce
the version of ESP/AH protocol.</p>

<p style="margin-top: 1em">-r Read packets from file (which
was created with the -w option). Standard input is used if
file is &lsquo;&lsquo;-&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">-S Print absolute, rather than
relative, TCP sequence numbers.</p>

<p style="margin-top: 1em">-s Snarf snaplen bytes of data
from each packet rather than the default of 65535 bytes.
Packets truncated because of a limited snapshot are
indicated in the output with <br>
&lsquo;&lsquo;[|proto]&rsquo;&rsquo;, where proto is the
name of the protocol level at which the truncation has
occurred. Note that taking larger snapshots both increases
the amount of time it <br>
takes to process packets and, effectively, decreases the
amount of packet buffering. This may cause packets to be
lost. You should limit snaplen to the smallest number <br>
that will capture the protocol information you&rsquo;re
interested in. Setting snaplen to 0 sets it to the default
of 65535, for backwards compatibility with recent older
ver&acirc; <br>
sions of tcpdump.</p>

<p style="margin-top: 1em">-T Force packets selected by
&quot;expression&quot; to be interpreted the specified type.
Currently known types are aodv (Ad-hoc On-demand Distance
Vector protocol), carp (Common <br>
Address Redundancy Protocol), cnfp (Cisco NetFlow protocol),
lmp (Link Management Protocol), pgm (Pragmatic General
Multicast), pgm_zmtp1 (ZMTP/1.0 inside PGM/EPGM), <br>
radius (RADIUS), rpc (Remote Procedure Call), rtp (Real-Time
Applications protocol), rtcp (Real-Time Applications control
protocol), snmp (Simple Network Management Proto&acirc; <br>
col), tftp (Trivial File Transfer Protocol), vat (Visual
Audio Tool), wb (distributed White Board), zmtp1 (ZeroMQ
Message Transport Protocol 1.0) and vxlan (Virtual
eXten&acirc; <br>
sible Local Area Network).</p>

<p style="margin-top: 1em">Note that the pgm type above
affects UDP interpretation only, the native PGM is always
recognised as IP protocol 113 regardless. UDP-encapsulated
PGM is often called <br>
&quot;EPGM&quot; or &quot;PGM/UDP&quot;.</p>

<p style="margin-top: 1em">Note that the pgm_zmtp1 type
above affects interpretation of both native PGM and UDP at
once. During the native PGM decoding the application data of
an ODATA/RDATA packet <br>
would be decoded as a ZeroMQ datagram with ZMTP/1.0 frames.
During the UDP decoding in addition to that any UDP packet
would be treated as an encapsulated PGM packet.</p>

<p style="margin-top: 1em">-t Don&rsquo;t print a timestamp
on each dump line.</p>

<p style="margin-top: 1em">-tt Print an unformatted
timestamp on each dump line.</p>

<p style="margin-top: 1em">-ttt Print a delta (micro-second
resolution) between current and previous line on each dump
line.</p>

<p style="margin-top: 1em">-tttt Print a timestamp in
default format proceeded by date on each dump line.</p>

<p style="margin-top: 1em">-ttttt Print a delta
(micro-second resolution) between current and first line on
each dump line.</p>

<p style="margin-top: 1em">-u Print undecoded NFS
handles.</p>

<p style="margin-top: 1em">-U If the -w option is not
specified, make the printed packet output
&lsquo;&lsquo;packet-buffered&rsquo;&rsquo;; i.e., as the
description of the contents of each packet is printed, it
will be writ&acirc; <br>
ten to the standard output, rather than, when not writing to
a terminal, being written only when the output buffer
fills.</p>

<p style="margin-top: 1em">If the -w option is specified,
make the saved raw packet output
&lsquo;&lsquo;packet-buffered&rsquo;&rsquo;; i.e., as each
packet is saved, it will be written to the output file,
rather than <br>
being written only when the output buffer fills.</p>

<p style="margin-top: 1em">The -U flag will not be
supported if tcpdump was built with an older version of
libpcap that lacks the pcap_dump_flush() function.</p>

<p style="margin-top: 1em">-v When parsing and printing,
produce (slightly more) verbose output. For example, the
time to live, identification, total length and options in an
IP packet are printed. <br>
Also enables additional packet integrity checks such as
verifying the IP and ICMP header checksum.</p>

<p style="margin-top: 1em">When writing to a file with the
-w option, report, every 10 seconds, the number of packets
captured.</p>

<p style="margin-top: 1em">-vv Even more verbose output.
For example, additional fields are printed from NFS reply
packets, and SMB packets are fully decoded.</p>

<p style="margin-top: 1em">-vvv Even more verbose output.
For example, telnet SB ... SE options are printed in full.
With -X Telnet options are printed in hex as well.</p>

<p style="margin-top: 1em">-V Read a list of filenames from
file. Standard input is used if file is
&lsquo;&lsquo;-&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">-w Write the raw packets to file
rather than parsing and printing them out. They can later be
printed with the -r option. Standard output is used if file
is &lsquo;&lsquo;-&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">This output will be buffered if
written to a file or pipe, so a program reading from the
file or pipe may not see packets for an arbitrary amount of
time after they are <br>
received. Use the -U flag to cause packets to be written as
soon as they are received.</p>

<p style="margin-top: 1em">The MIME type
application/vnd.tcpdump.pcap has been registered with IANA
for pcap files. The filename extension .pcap appears to be
the most commonly used along with .cap <br>
and .dmp. Tcpdump itself doesn&rsquo;t check the extension
when reading capture files and doesn&rsquo;t add an
extension when writing them (it uses magic numbers in the
file header <br>
instead). However, many operating systems and applications
will use the extension if it is present and adding one (e.g.
.pcap) is recommended.</p>

<p style="margin-top: 1em">See pcap-savefile(5) for a
description of the file format.</p>

<p style="margin-top: 1em">-W Used in conjunction with the
-C option, this will limit the number of files created to
the specified number, and begin overwriting files from the
beginning, thus creating <br>
a &rsquo;rotating&rsquo; buffer. In addition, it will name
the files with enough leading 0s to support the maximum
number of files, allowing them to sort correctly.</p>

<p style="margin-top: 1em">Used in conjunction with the -G
option, this will limit the number of rotated dump files
that get created, exiting with status 0 when reaching the
limit. If used with -C <br>
as well, the behavior will result in cyclical files per
timeslice.</p>

<p style="margin-top: 1em">-x When parsing and printing, in
addition to printing the headers of each packet, print the
data of each packet (minus its link level header) in hex.
The smaller of the <br>
entire packet or snaplen bytes will be printed. Note that
this is the entire link-layer packet, so for link layers
that pad (e.g. Ethernet), the padding bytes will also <br>
be printed when the higher layer packet is shorter than the
required padding.</p>

<p style="margin-top: 1em">-xx When parsing and printing,
in addition to printing the headers of each packet, print
the data of each packet, including its link level header, in
hex.</p>

<p style="margin-top: 1em">-X When parsing and printing, in
addition to printing the headers of each packet, print the
data of each packet (minus its link level header) in hex and
ASCII. This is very <br>
handy for analysing new protocols.</p>

<p style="margin-top: 1em">-XX When parsing and printing,
in addition to printing the headers of each packet, print
the data of each packet, including its link level header, in
hex and ASCII.</p>

<p style="margin-top: 1em">-y Set the data link type to use
while capturing packets to datalinktype.</p>

<p style="margin-top: 1em">-z Used in conjunction with the
-C or -G options, this will make tcpdump run &quot; command
file &quot; where file is the savefile being closed after
each rotation. For example, speci&acirc; <br>
fying -z gzip or -z bzip2 will compress each savefile using
gzip or bzip2.</p>

<p style="margin-top: 1em">Note that tcpdump will run the
command in parallel to the capture, using the lowest
priority so that this doesn&rsquo;t disturb the capture
process.</p>

<p style="margin-top: 1em">And in case you would like to
use a command that itself takes flags or different
arguments, you can always write a shell script that will
take the savefile name as the <br>
only argument, make the flags &amp; arguments arrangements
and execute the command that you want.</p>

<p style="margin-top: 1em">-Z If tcpdump is running as
root, after opening the capture device or input savefile,
but before opening any savefiles for output, change the user
ID to user and the group ID <br>
to the primary group of user.</p>

<p style="margin-top: 1em">This behavior is enabled by
default (-Z tcpdump), and can be disabled by -Z root.</p>

<p style="margin-top: 1em">expression <br>
selects which packets will be dumped. If no expression is
given, all packets on the net will be dumped. Otherwise,
only packets for which expression is &lsquo;true&rsquo; will
be <br>
dumped.</p>

<p style="margin-top: 1em">For the expression syntax, see
pcap-filter(7).</p>

<p style="margin-top: 1em">The expression argument can be
passed to tcpdump as either a single Shell argument, or as
multiple Shell arguments, whichever is more convenient.
Generally, if the <br>
expression contains Shell metacharacters, such as
backslashes used to escape protocol names, it is easier to
pass it as a single, quoted argument rather than to escape
the <br>
Shell metacharacters. Multiple arguments are concatenated
with spaces before being parsed.</p>

<p style="margin-top: 1em">EXAMPLES <br>
To print all packets arriving at or departing from sundown:
<br>
tcpdump host sundown</p>

<p style="margin-top: 1em">To print traffic between helios
and either hot or ace: <br>
tcpdump host helios and hot or ace</p>

<p style="margin-top: 1em">To print all IP packets between
ace and any host except helios: <br>
tcpdump ip host ace and not helios</p>

<p style="margin-top: 1em">To print all traffic between
local hosts and hosts at Berkeley: <br>
tcpdump net ucb-ether</p>

<p style="margin-top: 1em">To print all ftp traffic through
internet gateway snup: (note that the expression is quoted
to prevent the shell from (mis-)interpreting the
parentheses): <br>
tcpdump &rsquo;gateway snup and (port ftp or
ftp-data)&rsquo;</p>

<p style="margin-top: 1em">To print traffic neither sourced
from nor destined for local hosts (if you gateway to one
other net, this stuff should never make it onto your local
net). <br>
tcpdump ip and not net localnet</p>

<p style="margin-top: 1em">To print the start and end
packets (the SYN and FIN packets) of each TCP conversation
that involves a non-local host. <br>
tcpdump &rsquo;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0
and not src and dst net localnet&rsquo;</p>

<p style="margin-top: 1em">To print all IPv4 HTTP packets
to and from port 80, i.e. print only packets that contain
data, not, for example, SYN and FIN packets and ACK-only
packets. (IPv6 is left as an <br>
exercise for the reader.) <br>
tcpdump &rsquo;tcp port 80 and (((ip[2:2] -
((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2))
!= 0)&rsquo;</p>

<p style="margin-top: 1em">To print IP packets longer than
576 bytes sent through gateway snup: <br>
tcpdump &rsquo;gateway snup and ip[2:2] &gt; 576&rsquo;</p>

<p style="margin-top: 1em">To print IP broadcast or
multicast packets that were not sent via Ethernet broadcast
or multicast: <br>
tcpdump &rsquo;ether[0] &amp; 1 = 0 and ip[16] &gt;=
224&rsquo;</p>

<p style="margin-top: 1em">To print all ICMP packets that
are not echo requests/replies (i.e., not ping packets): <br>
tcpdump &rsquo;icmp[icmptype] != icmp-echo and
icmp[icmptype] != icmp-echoreply&rsquo;</p>

<p style="margin-top: 1em">OUTPUT FORMAT <br>
The output of tcpdump is protocol dependent. The following
gives a brief description and examples of most of the
formats.</p>

<p style="margin-top: 1em">Link Level Headers</p>

<p style="margin-top: 1em">If the &rsquo;-e&rsquo; option
is given, the link level header is printed out. On
Ethernets, the source and destination addresses, protocol,
and packet length are printed.</p>

<p style="margin-top: 1em">On FDDI networks, the
&rsquo;-e&rsquo; option causes tcpdump to print the
&lsquo;frame control&rsquo; field, the source and
destination addresses, and the packet length. (The
&lsquo;frame control&rsquo; field <br>
governs the interpretation of the rest of the packet. Normal
packets (such as those containing IP datagrams) are
&lsquo;async&rsquo; packets, with a priority value between 0
and 7; for <br>
example, &lsquo;async4&rsquo;. Such packets are assumed to
contain an 802.2 Logical Link Control (LLC) packet; the LLC
header is printed if it is not an ISO datagram or a
so-called SNAP <br>
packet.</p>

<p style="margin-top: 1em">On Token Ring networks, the
&rsquo;-e&rsquo; option causes tcpdump to print the
&lsquo;access control&rsquo; and &lsquo;frame control&rsquo;
fields, the source and destination addresses, and the packet
length. As <br>
on FDDI networks, packets are assumed to contain an LLC
packet. Regardless of whether the &rsquo;-e&rsquo; option is
specified or not, the source routing information is printed
for source- <br>
routed packets.</p>

<p style="margin-top: 1em">On 802.11 networks, the
&rsquo;-e&rsquo; option causes tcpdump to print the
&lsquo;frame control&rsquo; fields, all of the addresses in
the 802.11 header, and the packet length. As on FDDI
networks, <br>
packets are assumed to contain an LLC packet.</p>

<p style="margin-top: 1em">(N.B.: The following description
assumes familiarity with the SLIP compression algorithm
described in RFC-1144.)</p>

<p style="margin-top: 1em">On SLIP links, a direction
indicator (&lsquo;&lsquo;I&rsquo;&rsquo; for inbound,
&lsquo;&lsquo;O&rsquo;&rsquo; for outbound), packet type,
and compression information are printed out. The packet type
is printed first. The <br>
three types are ip, utcp, and ctcp. No further link
information is printed for ip packets. For TCP packets, the
connection identifier is printed following the type. If the
<br>
packet is compressed, its encoded header is printed out. The
special cases are printed out as *S+n and *SA+n, where n is
the amount by which the sequence number (or sequence <br>
number and ack) has changed. If it is not a special case,
zero or more changes are printed. A change is indicated by U
(urgent pointer), W (window), A (ack), S (sequence
num&acirc; <br>
ber), and I (packet ID), followed by a delta (+n or -n), or
a new value (=n). Finally, the amount of data in the packet
and compressed header length are printed.</p>

<p style="margin-top: 1em">For example, the following line
shows an outbound compressed TCP packet, with an implicit
connection identifier; the ack has changed by 6, the
sequence number by 49, and the <br>
packet ID by 6; there are 3 bytes of data and 6 bytes of
compressed header: <br>
O ctcp * A+6 S+49 I+6 3 (6)</p>

<p style="margin-top: 1em">ARP/RARP Packets</p>

<p style="margin-top: 1em">Arp/rarp output shows the type
of request and its arguments. The format is intended to be
self explanatory. Here is a short sample taken from the
start of an &lsquo;rlogin&rsquo; from host <br>
rtsg to host csam: <br>
arp who-has csam tell rtsg <br>
arp reply csam is-at CSAM <br>
The first line says that rtsg sent an arp packet asking for
the Ethernet address of internet host csam. Csam replies
with its Ethernet address (in this example, Ethernet <br>
addresses are in caps and internet addresses in lower
case).</p>

<p style="margin-top: 1em">This would look less redundant
if we had done tcpdump -n: <br>
arp who-has 128.3.254.6 tell 128.3.254.68 <br>
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4</p>

<p style="margin-top: 1em">If we had done tcpdump -e, the
fact that the first packet is broadcast and the second is
point-to-point would be visible: <br>
RTSG Broadcast 0806 64: arp who-has csam tell rtsg <br>
CSAM RTSG 0806 64: arp reply csam is-at CSAM <br>
For the first packet this says the Ethernet source address
is RTSG, the destination is the Ethernet broadcast address,
the type field contained hex 0806 (type ETHER_ARP) and the
<br>
total length was 64 bytes.</p>

<p style="margin-top: 1em">TCP Packets</p>

<p style="margin-top: 1em">(N.B.:The following description
assumes familiarity with the TCP protocol described in
RFC-793. If you are not familiar with the protocol, neither
this description nor tcpdump <br>
will be of much use to you.)</p>

<p style="margin-top: 1em">The general format of a tcp
protocol line is: <br>
src &gt; dst: flags data-seqno ack window urgent options
<br>
Src and dst are the source and destination IP addresses and
ports. Flags are some combination of S (SYN), F (FIN), P
(PUSH), R (RST), U (URG), W (ECN CWR), E (ECN-Echo) or
&lsquo;.&rsquo; <br>
(ACK), or &lsquo;none&rsquo; if no flags are set. Data-seqno
describes the portion of sequence space covered by the data
in this packet (see example below). Ack is sequence number
of the <br>
next data expected the other direction on this connection.
Window is the number of bytes of receive buffer space
available the other direction on this connection. Urg
indicates <br>
there is &lsquo;urgent&rsquo; data in the packet. Options
are tcp options enclosed in angle brackets (e.g., &lt;mss
1024&gt;).</p>

<p style="margin-top: 1em">Src, dst and flags are always
present. The other fields depend on the contents of the
packet&rsquo;s tcp protocol header and are output only if
appropriate.</p>

<p style="margin-top: 1em">Here is the opening portion of
an rlogin from host rtsg to host csam. <br>
rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096
&lt;mss 1024&gt; <br>
csam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win
4096 &lt;mss 1024&gt; <br>
rtsg.1023 &gt; csam.login: . ack 1 win 4096 <br>
rtsg.1023 &gt; csam.login: P 1:2(1) ack 1 win 4096 <br>
csam.login &gt; rtsg.1023: . ack 2 win 4096 <br>
rtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096 <br>
csam.login &gt; rtsg.1023: P 1:2(1) ack 21 win 4077 <br>
csam.login &gt; rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
<br>
csam.login &gt; rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1
<br>
The first line says that tcp port 1023 on rtsg sent a packet
to port login on csam. The S indicates that the SYN flag was
set. The packet sequence number was 768512 and it con&acirc;
<br>
tained no data. (The notation is
&lsquo;first:last(nbytes)&rsquo; which means &lsquo;sequence
numbers first up to but not including last which is nbytes
bytes of user data&rsquo;.) There was no piggy- <br>
backed ack, the available receive window was 4096 bytes and
there was a max-segment-size option requesting an mss of
1024 bytes.</p>

<p style="margin-top: 1em">Csam replies with a similar
packet except it includes a piggy-backed ack for
rtsg&rsquo;s SYN. Rtsg then acks csam&rsquo;s SYN. The
&lsquo;.&rsquo; means the ACK flag was set. The packet
contained no <br>
data so there is no data sequence number. Note that the ack
sequence number is a small integer (1). The first time
tcpdump sees a tcp &lsquo;conversation&rsquo;, it prints the
sequence <br>
number from the packet. On subsequent packets of the
conversation, the difference between the current
packet&rsquo;s sequence number and this initial sequence
number is printed. This <br>
means that sequence numbers after the first can be
interpreted as relative byte positions in the
conversation&rsquo;s data stream (with the first data byte
each direction being &lsquo;1&rsquo;). <br>
&lsquo;-S&rsquo; will override this feature, causing the
original sequence numbers to be output.</p>

<p style="margin-top: 1em">On the 6th line, rtsg sends csam
19 bytes of data (bytes 2 through 20 in the rtsg &acirc;
csam side of the conversation). The PUSH flag is set in the
packet. On the 7th line, csam <br>
says it&rsquo;s received data sent by rtsg up to but not
including byte 21. Most of this data is apparently sitting
in the socket buffer since csam&rsquo;s receive window has
gotten 19 <br>
bytes smaller. Csam also sends one byte of data to rtsg in
this packet. On the 8th and 9th lines, csam sends two bytes
of urgent, pushed data to rtsg.</p>

<p style="margin-top: 1em">If the snapshot was small enough
that tcpdump didn&rsquo;t capture the full TCP header, it
interprets as much of the header as it can and then reports
&lsquo;&lsquo;[|tcp]&rsquo;&rsquo; to indicate the <br>
remainder could not be interpreted. If the header contains a
bogus option (one with a length that&rsquo;s either too
small or beyond the end of the header), tcpdump reports it
as <br>
&lsquo;&lsquo;[bad opt]&rsquo;&rsquo; and does not interpret
any further options (since it&rsquo;s impossible to tell
where they start). If the header length indicates options
are present but the IP datagram <br>
length is not long enough for the options to actually be
there, tcpdump reports it as &lsquo;&lsquo;[bad hdr
length]&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">Capturing TCP packets with
particular flag combinations (SYN-ACK, URG-ACK, etc.)</p>

<p style="margin-top: 1em">There are 8 bits in the control
bits section of the TCP header:</p>

<p style="margin-top: 1em">CWR | ECE | URG | ACK | PSH |
RST | SYN | FIN</p>

<p style="margin-top: 1em">Let&rsquo;s assume that we want
to watch packets used in establishing a TCP connection.
Recall that TCP uses a 3-way handshake protocol when it
initializes a new connection; the con&acirc; <br>
nection sequence with regard to the TCP control bits is</p>

<p style="margin-top: 1em">1) Caller sends SYN <br>
2) Recipient responds with SYN, ACK <br>
3) Caller sends ACK</p>

<p style="margin-top: 1em">Now we&rsquo;re interested in
capturing packets that have only the SYN bit set (Step 1).
Note that we don&rsquo;t want packets from step 2 (SYN-ACK),
just a plain initial SYN. What we need <br>
is a correct filter expression for tcpdump.</p>

<p style="margin-top: 1em">Recall the structure of a TCP
header without options:</p>

<p style="margin-top: 1em">0 15 31 <br>

-----------------------------------------------------------------
<br>
| source port | destination port | <br>

-----------------------------------------------------------------
<br>
| sequence number | <br>

-----------------------------------------------------------------
<br>
| acknowledgment number | <br>

-----------------------------------------------------------------
<br>
| HL | rsvd |C|E|U|A|P|R|S|F| window size | <br>

-----------------------------------------------------------------
<br>
| TCP checksum | urgent pointer | <br>

-----------------------------------------------------------------</p>

<p style="margin-top: 1em">A TCP header usually holds 20
octets of data, unless options are present. The first line
of the graph contains octets 0 - 3, the second line shows
octets 4 - 7 etc.</p>

<p style="margin-top: 1em">Starting to count with 0, the
relevant TCP control bits are contained in octet 13:</p>

<p style="margin-top: 1em">0 7| 15| 23| 31 <br>

----------------|---------------|---------------|----------------
<br>
| HL | rsvd |C|E|U|A|P|R|S|F| window size | <br>

----------------|---------------|---------------|----------------
<br>
| | 13th octet | | |</p>

<p style="margin-top: 1em">Let&rsquo;s have a closer look
at octet no. 13:</p>

<p style="margin-top: 1em">| | <br>
|---------------| <br>
|C|E|U|A|P|R|S|F| <br>
|---------------| <br>
|7 5 3 0|</p>

<p style="margin-top: 1em">These are the TCP control bits
we are interested in. We have numbered the bits in this
octet from 0 to 7, right to left, so the PSH bit is bit
number 3, while the URG bit is <br>
number 5.</p>

<p style="margin-top: 1em">Recall that we want to capture
packets with only SYN set. Let&rsquo;s see what happens to
octet 13 if a TCP datagram arrives with the SYN bit set in
its header:</p>

<p style="margin-top: 1em">|C|E|U|A|P|R|S|F| <br>
|---------------| <br>
|0 0 0 0 0 0 1 0| <br>
|---------------| <br>
|7 6 5 4 3 2 1 0|</p>

<p style="margin-top: 1em">Looking at the control bits
section we see that only bit number 1 (SYN) is set.</p>

<p style="margin-top: 1em">Assuming that octet number 13 is
an 8-bit unsigned integer in network byte order, the binary
value of this octet is</p>

<p style="margin-top: 1em">00000010</p>

<p style="margin-top: 1em">and its decimal representation
is</p>

<p style="margin-top: 1em">7 6 5 4 3 2 1 0 <br>
0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2 = 2</p>

<p style="margin-top: 1em">We&rsquo;re almost done, because
now we know that if only SYN is set, the value of the 13th
octet in the TCP header, when interpreted as a 8-bit
unsigned integer in network byte order, <br>
must be exactly 2.</p>

<p style="margin-top: 1em">This relationship can be
expressed as <br>
tcp[13] == 2</p>

<p style="margin-top: 1em">We can use this expression as
the filter for tcpdump in order to watch packets which have
only SYN set: <br>
tcpdump -i xl0 tcp[13] == 2</p>

<p style="margin-top: 1em">The expression says &quot;let
the 13th octet of a TCP datagram have the decimal value
2&quot;, which is exactly what we want.</p>

<p style="margin-top: 1em">Now, let&rsquo;s assume that we
need to capture SYN packets, but we don&rsquo;t care if ACK
or any other TCP control bit is set at the same time.
Let&rsquo;s see what happens to octet 13 when a <br>
TCP datagram with SYN-ACK set arrives:</p>

<p style="margin-top: 1em">|C|E|U|A|P|R|S|F| <br>
|---------------| <br>
|0 0 0 1 0 0 1 0| <br>
|---------------| <br>
|7 6 5 4 3 2 1 0|</p>

<p style="margin-top: 1em">Now bits 1 and 4 are set in the
13th octet. The binary value of octet 13 is</p>

<p style="margin-top: 1em">00010010</p>

<p style="margin-top: 1em">which translates to decimal</p>

<p style="margin-top: 1em">7 6 5 4 3 2 1 0 <br>
0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2 = 18</p>

<p style="margin-top: 1em">Now we can&rsquo;t just use
&rsquo;tcp[13] == 18&rsquo; in the tcpdump filter
expression, because that would select only those packets
that have SYN-ACK set, but not those with only SYN set. <br>
Remember that we don&rsquo;t care if ACK or any other
control bit is set as long as SYN is set.</p>

<p style="margin-top: 1em">In order to achieve our goal, we
need to logically AND the binary value of octet 13 with some
other value to preserve the SYN bit. We know that we want
SYN to be set in any <br>
case, so we&rsquo;ll logically AND the value in the 13th
octet with the binary value of a SYN:</p>

<p style="margin-top: 1em">00010010 SYN-ACK 00000010 SYN
<br>
AND 00000010 (we want SYN) AND 00000010 (we want SYN) <br>
-------- -------- <br>
= 00000010 = 00000010</p>

<p style="margin-top: 1em">We see that this AND operation
delivers the same result regardless whether ACK or another
TCP control bit is set. The decimal representation of the
AND value as well as the <br>
result of this operation is 2 (binary 00000010), so we know
that for packets with SYN set the following relation must
hold true:</p>

<p style="margin-top: 1em">( ( value of octet 13 ) AND ( 2
) ) == ( 2 )</p>

<p style="margin-top: 1em">This points us to the tcpdump
filter expression <br>
tcpdump -i xl0 &rsquo;tcp[13] &amp; 2 == 2&rsquo;</p>

<p style="margin-top: 1em">Some offsets and field values
may be expressed as names rather than as numeric values. For
example tcp[13] may be replaced with tcp[tcpflags]. The
following TCP flag field values <br>
are also available: tcp-fin, tcp-syn, tcp-rst, tcp-push,
tcp-act, tcp-urg.</p>

<p style="margin-top: 1em">This can be demonstrated as:
<br>
tcpdump -i xl0 &rsquo;tcp[tcpflags] &amp; tcp-push !=
0&rsquo;</p>

<p style="margin-top: 1em">Note that you should use single
quotes or a backslash in the expression to hide the AND
(&rsquo;&amp;&rsquo;) special character from the shell.</p>

<p style="margin-top: 1em">UDP Packets</p>

<p style="margin-top: 1em">UDP format is illustrated by
this rwho packet: <br>
actinide.who &gt; broadcast.who: udp 84 <br>
This says that port who on host actinide sent a udp datagram
to port who on host broadcast, the Internet broadcast
address. The packet contained 84 bytes of user data.</p>

<p style="margin-top: 1em">Some UDP services are recognized
(from the source or destination port number) and the higher
level protocol information printed. In particular, Domain
Name service requests <br>
(RFC-1034/1035) and Sun RPC calls (RFC-1050) to NFS.</p>

<p style="margin-top: 1em">UDP Name Server Requests</p>

<p style="margin-top: 1em">(N.B.:The following description
assumes familiarity with the Domain Service protocol
described in RFC-1035. If you are not familiar with the
protocol, the following description <br>
will appear to be written in greek.)</p>

<p style="margin-top: 1em">Name server requests are
formatted as <br>
src &gt; dst: id op? flags qtype qclass name (len) <br>
h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu.
(37) <br>
Host h2opolo asked the domain server on helios for an
address record (qtype=A) associated with the name
ucbvax.berkeley.edu. The query id was &lsquo;3&rsquo;. The
&lsquo;+&rsquo; indicates the recur&acirc; <br>
sion desired flag was set. The query length was 37 bytes,
not including the UDP and IP protocol headers. The query
operation was the normal one, Query, so the op field was
<br>
omitted. If the op had been anything else, it would have
been printed between the &lsquo;3&rsquo; and the
&lsquo;+&rsquo;. Similarly, the qclass was the normal one,
C_IN, and omitted. Any other <br>
qclass would have been printed immediately after the
&lsquo;A&rsquo;.</p>

<p style="margin-top: 1em">A few anomalies are checked and
may result in extra fields enclosed in square brackets: If a
query contains an answer, authority records or additional
records section, ancount, <br>
nscount, or arcount are printed as &lsquo;[na]&rsquo;,
&lsquo;[nn]&rsquo; or &lsquo;[nau]&rsquo; where n is the
appropriate count. If any of the response bits are set (AA,
RA or rcode) or any of the &lsquo;must be <br>
zero&rsquo; bits are set in bytes two and three,
&lsquo;[b2&amp;3=x]&rsquo; is printed, where x is the hex
value of header bytes two and three.</p>

<p style="margin-top: 1em">UDP Name Server Responses</p>

<p style="margin-top: 1em">Name server responses are
formatted as <br>
src &gt; dst: id op rcode flags a/n/au type class data (len)
<br>
helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3
(273) <br>
helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97) <br>
In the first example, helios responds to query id 3 from
h2opolo with 3 answer records, 3 name server records and 7
additional records. The first answer record is type A <br>
(address) and its data is internet address 128.32.137.3. The
total size of the response was 273 bytes, excluding UDP and
IP headers. The op (Query) and response code (NoError) <br>
were omitted, as was the class (C_IN) of the A record.</p>

<p style="margin-top: 1em">In the second example, helios
responds to query 2 with a response code of non-existent
domain (NXDomain) with no answers, one name server and no
authority records. The &lsquo;*&rsquo; indi&acirc; <br>
cates that the authoritative answer bit was set. Since there
were no answers, no type, class or data were printed.</p>

<p style="margin-top: 1em">Other flag characters that might
appear are &lsquo;-&rsquo; (recursion available, RA, not
set) and &lsquo;|&rsquo; (truncated message, TC, set). If
the &lsquo;question&rsquo; section doesn&rsquo;t contain
exactly one <br>
entry, &lsquo;[nq]&rsquo; is printed.</p>

<p style="margin-top: 1em">SMB/CIFS decoding</p>

<p style="margin-top: 1em">tcpdump now includes fairly
extensive SMB/CIFS/NBT decoding for data on UDP/137, UDP/138
and TCP/139. Some primitive decoding of IPX and NetBEUI SMB
data is also done.</p>

<p style="margin-top: 1em">By default a fairly minimal
decode is done, with a much more detailed decode done if -v
is used. Be warned that with -v a single SMB packet may take
up a page or more, so only <br>
use -v if you really want all the gory details.</p>

<p style="margin-top: 1em">For information on SMB packet
formats and what all the fields mean see www.cifs.org or the
pub/samba/specs/ directory on your favorite samba.org mirror
site. The SMB patches <br>
were written by Andrew Tridgell (tridge@samba.org).</p>

<p style="margin-top: 1em">NFS Requests and Replies</p>

<p style="margin-top: 1em">Sun NFS (Network File System)
requests and replies are printed as: <br>
src.xid &gt; dst.nfs: len op args <br>
src.nfs &gt; dst.xid: reply stat len op results <br>
sushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165 <br>
wrl.nfs &gt; sushi.6709: reply ok 40 readlink
&quot;../var&quot; <br>
sushi.201b &gt; wrl.nfs: <br>
144 lookup fh 9,74/4096.6878 &quot;xcolors&quot; <br>
wrl.nfs &gt; sushi.201b: <br>
reply ok 128 lookup fh 9,74/4134.3150 <br>
In the first line, host sushi sends a transaction with id
6709 to wrl (note that the number following the src host is
a transaction id, not the source port). The request was 112
<br>
bytes, excluding the UDP and IP headers. The operation was a
readlink (read symbolic link) on file handle (fh)
21,24/10.731657119. (If one is lucky, as in this case, the
file <br>
handle can be interpreted as a major,minor device number
pair, followed by the inode number and generation number.)
Wrl replies &lsquo;ok&rsquo; with the contents of the
link.</p>

<p style="margin-top: 1em">In the third line, sushi asks
wrl to lookup the name &lsquo;xcolors&rsquo; in directory
file 9,74/4096.6878. Note that the data printed depends on
the operation type. The format is <br>
intended to be self explanatory if read in conjunction with
an NFS protocol spec.</p>

<p style="margin-top: 1em">If the -v (verbose) flag is
given, additional information is printed. For example: <br>
sushi.1372a &gt; wrl.nfs: <br>
148 read fh 21,11/12.195 8192 bytes @ 24576 <br>
wrl.nfs &gt; sushi.1372a: <br>
reply ok 1472 read REG 100664 ids 417/0 sz 29388 <br>
(-v also prints the IP header TTL, ID, length, and
fragmentation fields, which have been omitted from this
example.) In the first line, sushi asks wrl to read 8192
bytes from <br>
file 21,11/12.195, at byte offset 24576. Wrl replies
&lsquo;ok&rsquo;; the packet shown on the second line is the
first fragment of the reply, and hence is only 1472 bytes
long (the other <br>
bytes will follow in subsequent fragments, but these
fragments do not have NFS or even UDP headers and so might
not be printed, depending on the filter expression used).
Because <br>
the -v flag is given, some of the file attributes (which are
returned in addition to the file data) are printed: the file
type (&lsquo;&lsquo;REG&rsquo;&rsquo;, for regular file),
the file mode (in <br>
octal), the uid and gid, and the file size.</p>

<p style="margin-top: 1em">If the -v flag is given more
than once, even more details are printed.</p>

<p style="margin-top: 1em">Note that NFS requests are very
large and much of the detail won&rsquo;t be printed unless
snaplen is increased. Try using &lsquo;-s 192&rsquo; to
watch NFS traffic.</p>

<p style="margin-top: 1em">NFS reply packets do not
explicitly identify the RPC operation. Instead, tcpdump
keeps track of &lsquo;&lsquo;recent&rsquo;&rsquo; requests,
and matches them to the replies using the transaction ID.
<br>
If a reply does not closely follow the corresponding
request, it might not be parsable.</p>

<p style="margin-top: 1em">AFS Requests and Replies</p>

<p style="margin-top: 1em">Transarc AFS (Andrew File
System) requests and replies are printed as:</p>

<p style="margin-top: 1em">src.sport &gt; dst.dport: rx
packet-type <br>
src.sport &gt; dst.dport: rx packet-type service call
call-name args <br>
src.sport &gt; dst.dport: rx packet-type service reply
call-name args <br>
elvis.7001 &gt; pike.afsfs: <br>
rx data fs call rename old fid 536876964/1/1
&quot;.newsrc.new&quot; <br>
new fid 536876964/1/1 &quot;.newsrc&quot; <br>
pike.afsfs &gt; elvis.7001: rx data fs reply rename <br>
In the first line, host elvis sends a RX packet to pike.
This was a RX data packet to the fs (fileserver) service,
and is the start of an RPC call. The RPC call was a rename,
<br>
with the old directory file id of 536876964/1/1 and an old
filename of &lsquo;.newsrc.new&rsquo;, and a new directory
file id of 536876964/1/1 and a new filename of
&lsquo;.newsrc&rsquo;. The host pike <br>
responds with a RPC reply to the rename call (which was
successful, because it was a data packet and not an abort
packet).</p>

<p style="margin-top: 1em">In general, all AFS RPCs are
decoded at least by RPC call name. Most AFS RPCs have at
least some of the arguments decoded (generally only the
&lsquo;interesting&rsquo; arguments, for some <br>
definition of interesting).</p>

<p style="margin-top: 1em">The format is intended to be
self-describing, but it will probably not be useful to
people who are not familiar with the workings of AFS and
RX.</p>

<p style="margin-top: 1em">If the -v (verbose) flag is
given twice, acknowledgement packets and additional header
information is printed, such as the RX call ID, call number,
sequence number, serial num&acirc; <br>
ber, and the RX packet flags.</p>

<p style="margin-top: 1em">If the -v flag is given twice,
additional information is printed, such as the RX call ID,
serial number, and the RX packet flags. The MTU negotiation
information is also printed <br>
from RX ack packets.</p>

<p style="margin-top: 1em">If the -v flag is given three
times, the security index and service id are printed.</p>

<p style="margin-top: 1em">Error codes are printed for
abort packets, with the exception of Ubik beacon packets
(because abort packets are used to signify a yes vote for
the Ubik protocol).</p>

<p style="margin-top: 1em">Note that AFS requests are very
large and many of the arguments won&rsquo;t be printed
unless snaplen is increased. Try using &lsquo;-s 256&rsquo;
to watch AFS traffic.</p>

<p style="margin-top: 1em">AFS reply packets do not
explicitly identify the RPC operation. Instead, tcpdump
keeps track of &lsquo;&lsquo;recent&rsquo;&rsquo; requests,
and matches them to the replies using the call number and
<br>
service ID. If a reply does not closely follow the
corresponding request, it might not be parsable.</p>

<p style="margin-top: 1em">KIP AppleTalk (DDP in UDP)</p>

<p style="margin-top: 1em">AppleTalk DDP packets
encapsulated in UDP datagrams are de-encapsulated and dumped
as DDP packets (i.e., all the UDP header information is
discarded). The file /etc/atalk.names <br>
is used to translate AppleTalk net and node numbers to
names. Lines in this file have the form <br>
number name</p>

<p style="margin-top: 1em">1.254 ether <br>
16.1 icsd-net <br>
1.254.110 ace <br>
The first two lines give the names of AppleTalk networks.
The third line gives the name of a particular host (a host
is distinguished from a net by the 3rd octet in the number -
<br>
a net number must have two octets and a host number must
have three octets.) The number and name should be separated
by whitespace (blanks or tabs). The /etc/atalk.names file
<br>
may contain blank lines or comment lines (lines starting
with a &lsquo;#&rsquo;).</p>

<p style="margin-top: 1em">AppleTalk addresses are printed
in the form <br>
net.host.port</p>

<p style="margin-top: 1em">144.1.209.2 &gt;
icsd-net.112.220 <br>
office.2 &gt; icsd-net.112.220 <br>
jssmag.149.235 &gt; icsd-net.2 <br>
(If the /etc/atalk.names doesn&rsquo;t exist or
doesn&rsquo;t contain an entry for some AppleTalk host/net
number, addresses are printed in numeric form.) In the first
example, NBP (DDP <br>
port 2) on net 144.1 node 209 is sending to whatever is
listening on port 220 of net icsd node 112. The second line
is the same except the full name of the source node is known
<br>
(&lsquo;office&rsquo;). The third line is a send from port
235 on net jssmag node 149 to broadcast on the icsd-net NBP
port (note that the broadcast address (255) is indicated by
a net name <br>
with no host number - for this reason it&rsquo;s a good idea
to keep node names and net names distinct in
/etc/atalk.names).</p>

<p style="margin-top: 1em">NBP (name binding protocol) and
ATP (AppleTalk transaction protocol) packets have their
contents interpreted. Other protocols just dump the protocol
name (or number if no name <br>
is registered for the protocol) and packet size.</p>

<p style="margin-top: 1em">NBP packets are formatted like
the following examples: <br>
icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190:
&quot;=:LaserWriter@*&quot; <br>
jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190:
&quot;RM1140:LaserWriter@*&quot; 250 <br>
techpit.2 &gt; icsd-net.112.220: nbp-reply 190:
&quot;techpit:LaserWriter@*&quot; 186 <br>
The first line is a name lookup request for laserwriters
sent by net icsd host 112 and broadcast on net jssmag. The
nbp id for the lookup is 190. The second line shows a reply
<br>
for this request (note that it has the same id) from host
jssmag.209 saying that it has a laserwriter resource named
&quot;RM1140&quot; registered on port 250. The third line is
another <br>
reply to the same request saying host techpit has
laserwriter &quot;techpit&quot; registered on port 186.</p>

<p style="margin-top: 1em">ATP packet formatting is
demonstrated by the following example: <br>
jssmag.209.165 &gt; helios.132: atp-req 12266&lt;0-7&gt;
0xae030001 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512)
0xae040000 <br>
jssmag.209.165 &gt; helios.132: atp-req 12266&lt;3,5&gt;
0xae030001 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512)
0xae040000 <br>
jssmag.209.165 &gt; helios.132: atp-rel 12266&lt;0-7&gt;
0xae030001 <br>
jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt;
0xae030002 <br>
Jssmag.209 initiates transaction id 12266 with host helios
by requesting up to 8 packets (the
&lsquo;&lt;0-7&gt;&rsquo;). The hex number at the end of the
line is the value of the &lsquo;userdata&rsquo; <br>
field in the request.</p>

<p style="margin-top: 1em">Helios responds with 8 512-byte
packets. The &lsquo;:digit&rsquo; following the transaction
id gives the packet sequence number in the transaction and
the number in parens is the amount of <br>
data in the packet, excluding the atp header. The
&lsquo;*&rsquo; on packet 7 indicates that the EOM bit was
set.</p>

<p style="margin-top: 1em">Jssmag.209 then requests that
packets 3 &amp; 5 be retransmitted. Helios resends them then
jssmag.209 releases the transaction. Finally, jssmag.209
initiates the next request. The <br>
&lsquo;*&rsquo; on the request indicates that XO
(&lsquo;exactly once&rsquo;) was not set.</p>

<p style="margin-top: 1em">IP Fragmentation</p>

<p style="margin-top: 1em">Fragmented Internet datagrams
are printed as <br>
(frag id:size@offset+) <br>
(frag id:size@offset) <br>
(The first form indicates there are more fragments. The
second indicates this is the last fragment.)</p>

<p style="margin-top: 1em">Id is the fragment id. Size is
the fragment size (in bytes) excluding the IP header. Offset
is this fragment&rsquo;s offset (in bytes) in the original
datagram.</p>

<p style="margin-top: 1em">The fragment information is
output for each fragment. The first fragment contains the
higher level protocol header and the frag info is printed
after the protocol info. Frag&acirc; <br>
ments after the first contain no higher level protocol
header and the frag info is printed after the source and
destination addresses. For example, here is part of an ftp
from <br>
arizona.edu to lbl-rtsg.arpa over a CSNET connection that
doesn&rsquo;t appear to handle 576 byte datagrams: <br>
arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win
4096 (frag 595a:328@0+) <br>
arizona &gt; rtsg: (frag 595a:204@328) <br>
rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560 <br>
There are a couple of things to note here: First, addresses
in the 2nd line don&rsquo;t include port numbers. This is
because the TCP protocol information is all in the first
frag&acirc; <br>
ment and we have no idea what the port or sequence numbers
are when we print the later fragments. Second, the tcp
sequence information in the first line is printed as if
there <br>
were 308 bytes of user data when, in fact, there are 512
bytes (308 in the first frag and 204 in the second). If you
are looking for holes in the sequence space or trying to
<br>
match up acks with packets, this can fool you.</p>

<p style="margin-top: 1em">A packet with the IP don&rsquo;t
fragment flag is marked with a trailing (DF).</p>

<p style="margin-top: 1em">Timestamps</p>

<p style="margin-top: 1em">By default, all output lines are
preceded by a timestamp. The timestamp is the current clock
time in the form <br>
hh:mm:ss.frac <br>
and is as accurate as the kernel&rsquo;s clock. The
timestamp reflects the time the kernel first saw the packet.
No attempt is made to account for the time lag between when
the Eth&acirc; <br>
ernet interface removed the packet from the wire and when
the kernel serviced the &lsquo;new packet&rsquo;
interrupt.</p>

<p style="margin-top: 1em">SEE ALSO <br>
stty(1), pcap(3PCAP), bpf(4), nit(4P), pcap-savefile(5),
pcap-filter(7), pcap-tstamp-type(7)</p>


<p style="margin-top: 1em">http://www.iana.org/assignments/media-types/application/vnd.tcpdump.pcap</p>

<p style="margin-top: 1em">AUTHORS <br>
The original authors are:</p>

<p style="margin-top: 1em">Van Jacobson, Craig Leres and
Steven McCanne, all of the Lawrence Berkeley National
Laboratory, University of California, Berkeley, CA.</p>

<p style="margin-top: 1em">It is currently being maintained
by tcpdump.org.</p>

<p style="margin-top: 1em">The current version is available
via http:</p>

<p style="margin-top: 1em">http://www.tcpdump.org/</p>

<p style="margin-top: 1em">The original distribution is
available via anonymous ftp:</p>


<p style="margin-top: 1em">ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z</p>

<p style="margin-top: 1em">IPv6/IPsec support is added by
WIDE/KAME project. This program uses Eric Young&rsquo;s
SSLeay library, under specific configurations.</p>

<p style="margin-top: 1em">BUGS <br>
Please send problems, bugs, questions, desirable
enhancements, patches etc. to:</p>


<p style="margin-top: 1em">tcpdump-workers@lists.tcpdump.org</p>

<p style="margin-top: 1em">NIT doesn&rsquo;t let you watch
your own outbound traffic, BPF will. We recommend that you
use the latter.</p>

<p style="margin-top: 1em">On Linux systems with 2.0[.x]
kernels:</p>

<p style="margin-top: 1em">packets on the loopback device
will be seen twice;</p>

<p style="margin-top: 1em">packet filtering cannot be done
in the kernel, so that all packets must be copied from the
kernel in order to be filtered in user mode;</p>

<p style="margin-top: 1em">all of a packet, not just the
part that&rsquo;s within the snapshot length, will be copied
from the kernel (the 2.0[.x] packet capture mechanism, if
asked to copy only part of a <br>
packet to userland, will not report the true length of the
packet; this would cause most IP packets to get an error
from tcpdump);</p>

<p style="margin-top: 1em">capturing on some PPP devices
won&rsquo;t work correctly.</p>

<p style="margin-top: 1em">We recommend that you upgrade to
a 2.2 or later kernel.</p>

<p style="margin-top: 1em">Some attempt should be made to
reassemble IP fragments or, at least to compute the right
length for the higher level protocol.</p>

<p style="margin-top: 1em">Name server inverse queries are
not dumped correctly: the (empty) question section is
printed rather than real query in the answer section. Some
believe that inverse queries are <br>
themselves a bug and prefer to fix the program generating
them rather than tcpdump.</p>

<p style="margin-top: 1em">A packet trace that crosses a
daylight savings time change will give skewed time stamps
(the time change is ignored).</p>

<p style="margin-top: 1em">Filter expressions on fields
other than those in Token Ring headers will not correctly
handle source-routed Token Ring packets.</p>

<p style="margin-top: 1em">Filter expressions on fields
other than those in 802.11 headers will not correctly handle
802.11 data packets with both To DS and From DS set.</p>

<p style="margin-top: 1em">ip6 proto should chase header
chain, but at this moment it does not. ip6 protochain is
supplied for this behavior.</p>

<p style="margin-top: 1em">Arithmetic expression against
transport layer headers, like tcp[0], does not work against
IPv6 packets. It only looks at IPv4 packets.</p>

<p style="margin-top: 1em">12 July 2012 TCPDUMP(8)</p>
<hr>
</body>
</html>
