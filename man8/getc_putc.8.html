<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:11:28 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>getc_putc(8) System Manager&rsquo;s Manual
getc_putc(8)</p>

<p style="margin-top: 1em">NAME <br>
getc_putc - program to test hard drive performance.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
getc_putc [-d dir] [-s size(KiB)] [-m machine-name] [-u
uid-to-use:gid-to-use] [-g gid-to-use]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This manual page documents briefly the getc_putc,
program.</p>

<p style="margin-top: 1em">This is a simple adjunct to the
bonnie++ benchmark. It is used to test various ways of doing
IO one byte at a time, usually you don&rsquo;t need to do
enough of this for it to be a <br>
performance issue for it to matter much which way you do it.
But sometimes it&rsquo;s necessary (for example whan parsing
IO from a terminal and then launching another process which
<br>
will take over all IO, such as a simple shell).</p>

<p style="margin-top: 1em">The real benefits of this are to
help settle some arguements about the performance of such
things, and to educate novices about how bad per-byte IO
really is.</p>

<p style="margin-top: 1em">OPTIONS <br>
For getc_putc every option is of the form of a hyphen
followed by a letter and then the next parameter contains
the value.</p>

<p style="margin-top: 1em">-d the directory to use for the
tests.</p>

<p style="margin-top: 1em">-s the size of the file for byte
IO performance measured in kilobytes. NB You can specify the
size in mega-bytes if you add &rsquo;m&rsquo; to the end of
the number.</p>

<p style="margin-top: 1em">The default for this test is to
test with a 40MiB file. Of the file only 1/32 of it will be
used for write() and read() system calls (anything else
takes too long), and <br>
only 1/4 of it will be used for locked getc() and
putc().</p>

<p style="margin-top: 1em">-m name of the machine - for
display purposes only.</p>

<p style="margin-top: 1em">-u user-id to use. When running
as root specify the UID to use for the tests. It is not
recommended to use root, so if you really want to run as
root then use -u root. <br>
Also if you want to specify the group to run as then use the
user:group format. If you specify a user by name but no
group then the primary group of that user will be <br>
chosen. If you specify a user by number and no group then
the group will be nogroup.</p>

<p style="margin-top: 1em">-g group-id to use. Same as
using :group for the -u parameter, just a different way to
specify it for compatibility with other programs.</p>

<p style="margin-top: 1em">-q quiet mode. If specified then
some of the extra informational messages will be suppressed.
Also the csv data will be the only output on standard out
and the plain text <br>
data will be on standard error. This means you can run
getc_putc -q &gt;&gt; file.csv to record your csv data.</p>

<p style="margin-top: 1em">OUTPUT <br>
The primary output is plain-text in 80 columns which is
designed to fit well when pasted into email and which will
work well with Braille displays.</p>

<p style="margin-top: 1em">The second type of output is CSV
(Comma Seperated Values). This can easily be imported into
any spread-sheet or database program.</p>

<p style="margin-top: 1em">For every test the result is a
speed in KiB/s. I do not display the CPU time because it
presumably is 99% of the power of a single CPU (or something
very close to that).</p>

<p style="margin-top: 1em">AUTHOR <br>
This program, it&rsquo;s manual page, and the Debian package
were written by Russell Coker
&lt;russell@coker.com.au&gt;.</p>

<p style="margin-top: 1em">The documentation, the Perl
scripts, and all the code for testing the creation of
thousands of files was written by Russell Coker, but the
entire package is under joint copyright <br>
with Tim Bray.</p>

<p style="margin-top: 1em">SIGNALS <br>
Handles SIGINT and does a cleanup (which may take some
time), a second SIGINT or a SIGQUIT will cause it to
immidiately die.</p>

<p style="margin-top: 1em">SIGXCPU and SIGXFSZ act like
SIGINT.</p>

<p style="margin-top: 1em">Ignores SIGHUP.</p>

<p style="margin-top: 1em">AVAILABILITY <br>
The source is available from
http://www.coker.com.au/bonnie++ .</p>

<p style="margin-top: 1em">See
http://etbe.coker.com.au/category/benchmark for further
information.</p>

<p style="margin-top: 1em">SEE ALSO <br>
bonnie++(8), zcav(8)</p>
 
<p style="margin-top: 1em">getc_putc(8)</p>
<hr>
</body>
</html>
