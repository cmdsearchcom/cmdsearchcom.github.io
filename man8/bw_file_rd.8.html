<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:09:12 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>BW_FILE_RD(8) LMBENCH BW_FILE_RD(8)</p>

<p style="margin-top: 1em">NAME <br>
bw_file_rd - time the reading and summing of a file</p>

<p style="margin-top: 1em">SYNOPSIS <br>
bw_file_rd [ -P &lt;parallelism&gt; ] [ -W &lt;warmups&gt; ]
[ -N &lt;repetitions&gt; ] size file</p>

<p style="margin-top: 1em">DESCRIPTION <br>
bw_file_rd times the read of the specified file in 64KB
blocks. Each block is summed up as a seried of 4 byte
integers in an unrolled loop. Results are reported in
megabytes <br>
read per second.</p>

<p style="margin-top: 1em">The data is not accessed in the
user program; the benchmark relies on the operating systems
read interface to have actually moved the data. Systems that
implement page flipping <br>
may fool this benchmark.</p>

<p style="margin-top: 1em">The benchmark is intended to be
used on a file that is in memory, i.e., the benchmark is a
reread benchmark. Other file benchmarking can be done with
lmdd(8).</p>

<p style="margin-top: 1em">The size specification may end
with &lsquo;&lsquo;k&rsquo;&rsquo; or
&lsquo;&lsquo;m&rsquo;&rsquo; to mean kilobytes (* 1024) or
megabytes (* 1024 * 1024).</p>

<p style="margin-top: 1em">OUTPUT <br>
Output format is &quot;%0.2f %.2f0, megabytes,
megabytes_per_second, i.e.,</p>

<p style="margin-top: 1em">8.00 25.33</p>

<p style="margin-top: 1em">MEMORY UTILIZATION <br>
This benchmark can move up to three times the requested
memory. Most Unix systems implement the read system call as
a bcopy from kernel space to user space. Bcopy will use 2-3
<br>
times as much memory bandwidth: there is one read from the
source and a write to the destionation. The write usually
results in a cache line read and then a write back of the
<br>
cache line at some later point. Memory utilization might be
reduced by 1/3 if the processor architecture implemented
&lsquo;&lsquo;load cache line&rsquo;&rsquo; and
&lsquo;&lsquo;store cache line&rsquo;&rsquo; instructions
<br>
(as well as
&lsquo;&lsquo;getcachelinesize&rsquo;&rsquo;).</p>

<p style="margin-top: 1em">ACKNOWLEDGEMENT <br>
Funding for the development of this tool was provided by Sun
Microsystems Computer Corporation.</p>

<p style="margin-top: 1em">SEE ALSO <br>
lmbench(8).</p>

<p style="margin-top: 1em">AUTHOR <br>
Carl Staelin and Larry McVoy</p>

<p style="margin-top: 1em">Comments, suggestions, and bug
reports are always welcome.</p>

<p style="margin-top: 1em">(c)1994 Larry McVoy $Date$
BW_FILE_RD(8)</p>
<hr>
</body>
</html>
