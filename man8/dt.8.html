<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:10:37 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>dt(1) General Commands Manual dt(1)</p>

<p style="margin-top: 1em">NAME <br>
dt - Data Test Program</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dt [options]</p>

<p style="margin-top: 1em">EXTREME WARNING!!! <br>
Use of this program is almost guaranteed to find problems
and cause your schedules to slip. If you are afraid to find
bugs or otherwise break your system, then please do not use
<br>
this program for testing. You can pay now or pay later, but
you&rsquo;ve been warned!</p>

<p style="margin-top: 1em">DESCRIPTION <br>
dt is a generic data test program used to verify the proper
operation of peripherals and I/O sub-systems, and for
obtaining performance information. Since verification of
data is <br>
performed, dt can be thought of as a generic diagnostic
tool.</p>

<p style="margin-top: 1em">Although the original design
goals of being a generic test tool were accomplished, it
quickly become evident that device specific tests, such as
terminals, and different program&acirc; <br>
ming interfaces such as memory mapped files and POSIX
asynchronous I/O API&rsquo;s were necessary. Therefore,
special options were added to enable these test modes and to
specify nec&acirc; <br>
essary test parameters.</p>

<p style="margin-top: 1em">dt command lines are similar to
the dd program, which is popular on most UNIX systems. dt
contains numerous options to provide user control of most
test parameters so customized <br>
tests can be written easily and quickly by specifying simple
command line options. Since the exit status of the program
always reflects the completion status of a test, scripts
<br>
can easily detect failures to perform automatic regression
tests.</p>

<p style="margin-top: 1em">dt has been used to successfully
test disks, tapes, serial lines, parallel lines, pipes &amp;
FIFO&rsquo;s, memory mapped files, and POSIX Asynchronous
I/O. In fact, dt can be used with <br>
any device that supports the standard open, read, write, and
close system calls. Special support is necessary for some
devices, such as serial lines, for setting up the speed,
<br>
parity, data bits, etc, but dt&rsquo;s design provides easy
addition of this setup.</p>

<p style="margin-top: 1em">Most tests can be initiated by a
simple dt command line, and lots of I/O can be initiated
quickly using multiple processes and/or POSIX AIO, for those
operating systems supporing <br>
AIO. More complex tests are normally initiated by writing
shell scripts and using dt in conjunction with other tools,
such as scu (SCSI Command Utility). Several shell scripts
<br>
for testing disks, tapes, and serial lines are also supplied
with this kit which can used as templates for developing
other specialized test scripts.</p>

<p style="margin-top: 1em">Specific system features are now
being added to dt so more extensive testing can be
accomplished. The program has been restructured to allow
easy inclusion of new device specific <br>
tests by dispatching to test functions through a function
lookup table. This table gets setup automatically, based on
options enabled, or via the device type &quot;dtype=&quot;
option.</p>

<p style="margin-top: 1em">WARNING: dt does not perform any
sanity checking of the output device specified. This means
if you are running as root on Unix and you specify a raw
disk device, dt will over&acirc; <br>
write existing file systems, so please be careful! I HATE TO
ADMIT, I&rsquo;VE DONE THIS MYSELF!</p>

<p style="margin-top: 1em">Operating Systems Supported <br>
dt is conditionalized to run on AIX, HP-UX, SUN, ULTRIX,
OSF, QNX, SCO Unixware, Windows, and Linux operating
systems. Porting is simple for OSes with POSIX APIs.</p>

<p style="margin-top: 1em">Test Uses <br>
Those people with an imagination will find many uses for dt,
but I&rsquo;ll list a few I&rsquo;ve used it for, just to
whet your appetite:</p>

<p style="margin-top: 1em">&Acirc;&middot; Testing of tape
devices using different block sizes to determine the best
blocking factor for optimum performance and capacity. This
is very important for streaming tapes <br>
devices.</p>

<p style="margin-top: 1em">&Acirc;&middot; Write tapes to
end of tape, to determine the total tape capacity. This
gives the total data capacity of tapes, after inter-record
gaps, preamble/postambles, or pad blocks <br>
are written on the tape.</p>

<p style="margin-top: 1em">&Acirc;&middot; Read existing
tapes with data comparison disabled, to determine the amount
of data on the tape. This is useful to determine how much
disk space is required to read in a <br>
tape, or to simply verify the tape can be read without
errors.</p>

<p style="margin-top: 1em">&Acirc;&middot; Reading/writing
an entire tape to ensure device drivers properly sense and
handle end of tape error conditions.</p>

<p style="margin-top: 1em">&Acirc;&middot; Write a tape and
ensure it can be read on another tape drive to test drive
compatibility (also referred to as transportability).</p>

<p style="margin-top: 1em">&Acirc;&middot; Read multiple
tape files to ensure file marks and end of tape are reported
and handled properly by tape drivers.</p>

<p style="margin-top: 1em">&Acirc;&middot; I/O to disks
using the raw device interface, to determine the optimum
performance of the controller. This usually gives a good
indication of how well the controller cache <br>
or read-ahead improves I/O performance for sequential or
random file access.</p>

<p style="margin-top: 1em">&Acirc;&middot; I/O to disk
files through the file system, to determine the affect the
buffer cache has on write and read performance. You must
know the characteristics of your O/S&rsquo;s buf&acirc; <br>
fer cache to select file sizes to either get optimum
performance from the cache, or to defeat the affect of the
buffer cache.</p>

<p style="margin-top: 1em">&Acirc;&middot; Reading/writing
of entire disks, to ensure the media capacity and end of
media error handling is properly reported by device
drivers.</p>

<p style="margin-top: 1em">&Acirc;&middot; Test memory
mapped files to compare I/O performance against raw and file
system I/O. Typically, memory mapped I/O approaches the raw
device performance.</p>

<p style="margin-top: 1em">&Acirc;&middot; Testing I/O to
files on NFS mounted file systems. This will give you a good
indication of your ethernet performance to remote files.</p>

<p style="margin-top: 1em">&Acirc;&middot; Writing/reading
pipes &amp; FIFO&rsquo;s to verify pipe operation and
performance.</p>

<p style="margin-top: 1em">&Acirc;&middot; Initiating
multiple processes to test optimizations of buffer cache,
device drivers, and/or intelligent controllers. This is also
useful to test multiple device access and <br>
for loading the I/O sub-system.</p>

<p style="margin-top: 1em">&Acirc;&middot; Force I/O at
different memory boundaries to test low level driver
handling. Using the align option, you can set memory
alignment for testing specialized device driver DMA <br>
code. This is very useful when developing new I/O
sub-systems.</p>

<p style="margin-top: 1em">&Acirc;&middot; Do loopback
testing of parallel or serial lines on either the same
system of different systems. This is a useful compatibility
test when running different machines running <br>
different operating systems.</p>

<p style="margin-top: 1em">&Acirc;&middot; Enable POSIX
Asynchronous I/O to verify proper operation of this API and
to determine performance gains (over standard synchronous
I/O). This is also useful for queuing <br>
multiple I/O requests to drivers and for testing SCSI tag
queuing and RAID configurations.</p>

<p style="margin-top: 1em">&Acirc;&middot; Specify variable
record options for testing variable tape devices.</p>

<p style="margin-top: 1em">&Acirc;&middot; On Tru64 cluster
systems, distributed lock manager (DLM) options can be used
to control access to shared devices or files.</p>

<p style="margin-top: 1em">&Acirc;&middot; Also available
on Tru64 UNIX is the ability to use Extended Error
Information (EEI) to detect and recover from SCSI bus/device
resets (tape is repositioned for continuing <br>
the test).</p>

<p style="margin-top: 1em">&Acirc;&middot; Monitor slow or
no I/O progress.</p>

<p style="margin-top: 1em">&Acirc;&middot; Execute a
trigger when failures occur.</p>

<p style="margin-top: 1em">Program Options <br>
This section describes program options and and special notes
related to each. The dt help file provides a summary of the
options, and the default value of most options.</p>

<p style="margin-top: 1em">Input File if= Option <br>
This option specifies the input file to open for reads. The
device is opened read-only so devices which only permit or
support read access, e.g., parallel input devices, can be
<br>
opened successfully.</p>

<p style="margin-top: 1em">Special Notes:</p>

<p style="margin-top: 1em">&Acirc;&middot; Data read is
automatically verified with the default data pattern, unless
you disable this action via the &quot;disable=compare&quot;
option.</p>

<p style="margin-top: 1em">&Acirc;&middot; Extra pad bytes
of sizeof(int), are allocated at the end of data buffers,
initialized with the inverted data pattern, and then
verified after each read request to ensure <br>
the end of data buffers didn&rsquo;t get overwritten by file
system and/or device drivers. This extra check has found
problems with flushing DMA FIFO&rsquo;s on several
machines.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">if=filename <br>
The input file to read.</p>

<p style="margin-top: 1em">Output File of= Option <br>
This option specifies the output file to open for writes.
After the write portion of the test, the device is closed
(to reposition to start of file or to rewind the tape), re-
<br>
opened, and then a read verification pass is performed. If
you wish to prevent the read verify pass, you must specify
the &quot;disable=verify&quot; option.</p>

<p style="margin-top: 1em">Special Notes:</p>

<p style="margin-top: 1em">&Acirc;&middot; Terminal devices
are closed between passes so previously set terminal
characteristics don&rsquo;t get reset. This also caused a
race condition when doing loopback testing with <br>
two processes.</p>

<p style="margin-top: 1em">&Acirc;&middot; When testing
terminal (serial) devices, modem control is disabled (via
setting CLOCAL) to prevent tests from hanging. If the
&quot;enable=modem&quot; option is specified, then
CLO&acirc; <br>
CAL is reset, hangup on close HUPCL is set, and testing will
not preceed until carrier or DSR is detected. This code is
not fully tested, but this description accurately <br>
describes the code.</p>

<p style="margin-top: 1em">&Acirc;&middot; At the present
time, tapes are rewound by closing the device, so you must
specify the rewind device during testing if the read verify
pass is being performed. This <br>
restriction will probably change in the next release since
magtape control commands will be supported (tape specific
tests as well).</p>

<p style="margin-top: 1em">&Acirc;&middot; O_CREAT open
flag is cleared to prevent accidently creating files in this
directory when not specifying the correct device name (very
easy to do when running tests as <br>
super-user &rsquo;root&rsquo;).</p>

<p style="margin-top: 1em">&Acirc;&middot; When writing to
raw disks on Tru64 UNIX, if the disk was previously labeled,
you must issue the &quot;disklabel -z&quot; command to
destroy the label block or else you cannot write <br>
to this area of this disk (block 0). Failure to do this
results in the error &quot;Read-only file system&quot;
(errno=EROFS) being returned on write requests.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">of=filename <br>
The output file to write.</p>

<p style="margin-top: 1em">Pattern File pf= Option <br>
This option specifies a pattern file to use for the data
pattern during testing. This option overrides the
&quot;pattern=&quot; option and allows you to specify
specialized patterns. The <br>
only restriction to this option is that the entire file must
fit in memory. A buffer is allocated to read the entire
pattern file into memory before testing starts so
performance <br>
is not affected by reading the pattern file.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">pf=filename <br>
The data pattern file to use.</p>

<p style="margin-top: 1em">Block Size bs= Option <br>
This option specifies the block size, in bytes, to use
during testing. At the present time, this option sets both
the input and output block sizes. At the time I originally
wrote <br>
this program, I didn&rsquo;t have the need for seperate
block sizes, but this may change in a future release where
I&rsquo;ll add back the &quot;ibs=&quot; and
&quot;obs=&quot; options available with dd.</p>

<p style="margin-top: 1em">Special Notes:</p>

<p style="margin-top: 1em">&Acirc;&middot; When enabling
variable length records via the &quot;min=&quot; option,
this also sets the maximum record size to be
written/read.</p>

<p style="margin-top: 1em">&Acirc;&middot; For memory
mapped files, the block size be a multiple of the system
dependent page size (normally 4k or 8k bytes).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">bs=value <br>
The block size to read/write.</p>

<p style="margin-top: 1em">Log File log[tu]= Options <br>
This option specifies the log file to redirect all program
output to. This is done by re-opening the standard error
stream (stderr) to the specifed log file. Since all output
<br>
from dt is directed to stderr, library functions such as
perror() also write to this log file.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; A seperate
buffer is allocated for the stderr stream, and this stream
is set buffered so timing isn&rsquo;t affected by program
output.</p>

<p style="margin-top: 1em">&Acirc;&middot; When starting
multiple processes via the &quot;procs=&quot; option, all
output is directed to the same log file. The output from
each process is identified by the process ID (PID) <br>
as part of the message (errors &amp; statistics).</p>

<p style="margin-top: 1em">&Acirc;&middot; logt=filename
will truncate the existing log file.</p>

<p style="margin-top: 1em">&Acirc;&middot; logu=filename
will create unique log files with multiple processes
(w/pid).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">log[tu]=filename <br>
The log file name to write.</p>

<p style="margin-top: 1em">Special format keywords are now
expanded when part of the log file name, so unique names can
be created for each test:</p>

<p style="margin-top: 1em">Log File Format Keywords:</p>

<p style="margin-top: 1em">%iodir The I/O direction.</p>

<p style="margin-top: 1em">%iotype <br>
The I/O type.</p>

<p style="margin-top: 1em">%host The host name.</p>

<p style="margin-top: 1em">%pid The process ID.</p>

<p style="margin-top: 1em">%user The user name.</p>

<p style="margin-top: 1em">Example: <br>
log=dt_%host_%user_%iodir_%iotype-%pid.log</p>

<p style="margin-top: 1em">Please see the DiskTests.ksh
script for examples of using this.</p>

<p style="margin-top: 1em">POSIX Asynchronous I/O aios=
Option <br>
This option enables and controls the number of POSIX
Asychronous I/O requests used by the program.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The default is
to queue up to 8 requests.</p>

<p style="margin-top: 1em">&Acirc;&middot; The system limit
for AIO on Tru64 UNIX is dynamic, and can be queried by
using the &quot;sysconfig -q rt&quot; command.</p>

<p style="margin-top: 1em">&Acirc;&middot; You can use the
&quot;enable=aio&quot; option to enable AIO and use the
default request limit.</p>

<p style="margin-top: 1em">&Acirc;&middot; AIO is only
supported for character devices and is disabled for
terminals. On Tru64 UNIX, you can alter the Makefile and
link against libaio.a, which allows AIO with any <br>
device/file by mimic&rsquo;ing AIO using POSIX threads.</p>

<p style="margin-top: 1em">&Acirc;&middot; AIO requests can
be cancelled on Tru64 UNIX, so queuing many requests to
1/2in tape devices will probably result in running off the
end of the tape reel. This is not a <br>
problem for cartridge tapes.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">aios=value <br>
Set number of AIO&rsquo;s to queue.</p>

<p style="margin-top: 1em">Keepalive Alarm Time alarm=
Option <br>
Keepalive Message *keepalive= Options <br>
These options control a user defined message that will be
emitted during the test. The user defines how often to
display the keepalive message, via the
&quot;alarm=time&quot; option, and <br>
the format of the message(s), via the
&quot;*keepalive=string&quot; options. The normal
&quot;keepalive=&quot; option defines the script emitted
during the test, while &quot;pkeepalive=&quot; is the per
pass <br>
message string, and &quot;tkeepalive=&quot; is the totals
message string (overriding what dt normally displays). For a
full description of the message control strings see the
UserGuide.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">alarm=time <br>
The keepalive alarm time.</p>

<p style="margin-top: 1em">keepalive=string <br>
The keepalive message string.</p>

<p style="margin-top: 1em">pkeepalive=str <br>
The pass keepalive msg string.</p>

<p style="margin-top: 1em">tkeepalive=str <br>
The totals keepalive msg string.</p>

<p style="margin-top: 1em">Keepalive Message Format Control
<br>
The keepalive string is free format like a printf(), with
the following format control strings:</p>

<p style="margin-top: 1em">Keepalive Format Control:</p>

<p style="margin-top: 1em">%b The bytes read or
written.</p>

<p style="margin-top: 1em">%B Total bytes read and
written.</p>

<p style="margin-top: 1em">%c Record count for this
pass.</p>

<p style="margin-top: 1em">%C Total records for this
test.</p>

<p style="margin-top: 1em">%d The device name.</p>

<p style="margin-top: 1em">%D The real device name.</p>

<p style="margin-top: 1em">%e The number of errors.</p>

<p style="margin-top: 1em">%E The error limit.</p>

<p style="margin-top: 1em">%f The files read or
written.</p>

<p style="margin-top: 1em">%F Total files read and
written.</p>

<p style="margin-top: 1em">%h The host name.</p>

<p style="margin-top: 1em">%H The full host name.</p>

<p style="margin-top: 1em">%k The kilobytes this pass.</p>

<p style="margin-top: 1em">%K Total kilobytes for this
test.</p>

<p style="margin-top: 1em">%l Blocks read or written.</p>

<p style="margin-top: 1em">%L Total blocks read and
written.</p>

<p style="margin-top: 1em">%m The megabytes this pass.</p>

<p style="margin-top: 1em">%M Total megabytes for this
test.</p>

<p style="margin-top: 1em">%p The pass count.</p>

<p style="margin-top: 1em">%P The pass limit.</p>

<p style="margin-top: 1em">%r Records read this pass.</p>

<p style="margin-top: 1em">%R Total records read this
test.</p>

<p style="margin-top: 1em">%s The seconds this pass.</p>

<p style="margin-top: 1em">%S The total seconds this
test.</p>

<p style="margin-top: 1em">%t The pass elapsed time.</p>

<p style="margin-top: 1em">%T The total elapsed time.</p>

<p style="margin-top: 1em">%i The I/O mode (read/write)</p>

<p style="margin-top: 1em">%u The user (login) name.</p>

<p style="margin-top: 1em">%w Records written this
pass.</p>

<p style="margin-top: 1em">%W Total records written this
test.</p>

<p style="margin-top: 1em">Performance Keywords:</p>

<p style="margin-top: 1em">%bps The bytes per second.</p>

<p style="margin-top: 1em">%lbps Logical blocks per
second.</p>

<p style="margin-top: 1em">%kbps Kilobytes per second.</p>

<p style="margin-top: 1em">%mbps The megabytes per
second.</p>

<p style="margin-top: 1em">%iops The I/O&rsquo;s per
second.</p>

<p style="margin-top: 1em">%spio The seconds per I/O.</p>

<p style="margin-top: 1em">Lowercase means per pass stats,
while uppercase means total stats.</p>

<p style="margin-top: 1em">Default: <br>
%d Stats: mode %i, blocks %l, %m Mbytes, pass %p/%P, elapsed
%t</p>

<p style="margin-top: 1em">or if pass statistics summary is
disabled: <br>
%d Stats: mode %i, blocks %L, %M Mbytes, pass %p/%P, elapsed
%T</p>

<p style="margin-top: 1em">Here&rsquo;s an example used by
Hazards&rsquo; diskdt process: <br>
keepalive=&quot;count = %C; e = %e; t = %S; IOpS = %IOPS;
SpIO = %SPIO&quot; <br>
tkeepalive=&quot;STAT +RawMbytes %MBPS +RawReads %R
+RawWrites %W&quot;;</p>

<p style="margin-top: 1em">Buffer Alignment align= Option
<br>
This option controls the alignment of the normally page
aligned data buffer allocated. This option is often useful
for testing certain DMA boundary conditions not easily
repro&acirc; <br>
duced otherwise. The rotate option automatically adjust the
data buffer pointer by (0, 1, 2, 3, ...) for each I/O
request to ensure various boundaries are fully tested.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">align=offset <br>
Set offset within page aligned buffer.</p>

<p style="margin-top: 1em">align=rotate <br>
Rotate data address through sizeof(ptr).</p>

<p style="margin-top: 1em">File Disposition dispose= Option
<br>
This option controls the disposition of test files created
on file systems. By default, the test file created is
deleted before exiting, but sometimes you may wish to keep
this <br>
file for further examination, for use as a pattern file, or
simply for the read verify pass of another test (e.g.,
reading the file via memory map API).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">dispose=mode <br>
Set file dispose to: {delete, keep, or keeponerror}.</p>

<p style="margin-top: 1em">Dump Data Limit dlimit= Option
<br>
This option allows you to specify the dump data limit used
when data compare errors occur. The default dump data limit
is 64 bytes.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">dlimit=value <br>
Sets the data dump limit to value.</p>

<p style="margin-top: 1em">Device Size dsize= Option <br>
This option allows you to specify the device block size
used. On Tru64 Unix, the device block size is obatined
automatically by an OS specific IOCTL. For all other
systems, ran&acirc; <br>
dom access devices default to 512 byte blocks. You&rsquo;ll
likely use this option with C/DVD&rsquo;s, since their
default block size to 2048 bytes per block.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">dsize=value <br>
Set the device block (sector) size.</p>

<p style="margin-top: 1em">Device Type dtype= Option <br>
Input Device Type idtype= Option <br>
Output Device Type odtype= Option <br>
These options provide a method to inform dt of the type of
device test to be performed. Without this knowledge, only
generic testing is possible.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; On Tru64 UNIX
systems, these options are not necessary, since this
information is obtained via the DECIOCGET or DEVGETINFO
IOCTL&rsquo;s.</p>

<p style="margin-top: 1em">&Acirc;&middot; Although the
program accepts a large number of device types, as shown
below, specific tests only exists for &quot;disk&quot;,
&quot;tape&quot;, &quot;fifo&quot;, and &quot;terminal&quot;
device types. Others may <br>
be added in the future.</p>

<p style="margin-top: 1em">&Acirc;&middot; In the case of
&quot;disk&quot; device type, reports the relative block
number when read, write, or data compare errors occur.</p>

<p style="margin-top: 1em">&Acirc;&middot; Also for
&quot;disk&quot; devices, will automatically determine the
disk capacity if a data or record limit is not specified.
This is done via a series of seek/read requests.</p>

<p style="margin-top: 1em">&Acirc;&middot; On each
operating system supported, string compares are done on well
known device names to automatically select the device type.
For example on QNX, &quot;/dev/hd&quot; for disk, <br>
&quot;/dev/tp&quot; for tapes, and &quot;/dev/ser&quot; for
serial lines.</p>

<p style="margin-top: 1em">&Acirc;&middot; The device type
gets displayed in the total statictics.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">dtype=string <br>
Sets the device type.</p>

<p style="margin-top: 1em">idtype=string <br>
Sets the input device type.</p>

<p style="margin-top: 1em">odtype=string <br>
Sets the output device type.</p>

<p style="margin-top: 1em">The Valid Device Types Are:</p>

<p style="margin-top: 1em">audio comm disk graphics</p>

<p style="margin-top: 1em">memory mouse network fifo</p>

<p style="margin-top: 1em">pipe printer processor
socket</p>

<p style="margin-top: 1em">special streams tape
terminal</p>

<p style="margin-top: 1em">unknown</p>

<p style="margin-top: 1em">Note: Although dt does not
provide specific test support for each of the devices shown
above, its&rsquo; design makes it easy to add new device
specific tests. Specific support exists <br>
for disk, fifo, pipe, tape, and terminals. Support for
&quot;ptys&quot; may be added in the future as well.</p>

<p style="margin-top: 1em">Error Limit errors= Option <br>
This option controls the maximum number of errors tolerated
before the program exits.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The default
error limit is 1.</p>

<p style="margin-top: 1em">&Acirc;&middot; All errors have
a time stamp associated with them, which are useful for
characterizing intermittent error conditions.</p>

<p style="margin-top: 1em">&Acirc;&middot; The error limit
is adjusted for read, write, or data compare failures. This
limit is not enforced when flushing data, or for certain AIO
wait operations which are consid&acirc; <br>
ered non-fatal (perhaps this will change).</p>

<p style="margin-top: 1em">&Acirc;&middot; A future release
may support an &quot;onerr=&quot; option to control the
action of errors (e.g., loop, ignore (continue), or
exit).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">errors=value <br>
The number of errors to tolerate.</p>

<p style="margin-top: 1em">File Limit files= Option <br>
This option controls the number of tape files to process
with tape devices.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; During the write
pass, a tape file mark is written after each file. After all
files are written, 1 or 2 file marks will be written
automatically by the tape driver when <br>
the device is closed.</p>

<p style="margin-top: 1em">&Acirc;&middot; During reads,
each file is expected to be terminated by a file mark and
read() system calls are expected to return a value of
denoting the end of file. When reading past <br>
all tapes files, an errno of ENOSPC is expected to flag the
end of media condition.</p>

<p style="margin-top: 1em">&Acirc;&middot; Writing tape
file marks is currently not supported on the QNX Operating
System. The release I currently have does not support the
mtio commands, and unfortunately the <br>
POSIX standard does define this interface (the mtio
interface appears to be a UNIX specific standard). Multiple
tape files can still be read on QNX systems however.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">files=value <br>
Set number of tape files to process.</p>

<p style="margin-top: 1em">Terminal Flow Control flow=
Option <br>
This option specifies the terminal flow control to use
during testing.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The default flow
control is &quot;xon_xoff&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; When using
XON/XOFF flow control, you must make sure these byte codes
(Ctrl/Q = XON = &rsquo; 21&rsquo;, Ctrl/S = XOFF = &rsquo;
23), since the program does not filter these out
automati&acirc; <br>
cally. Also be aware of terminal servers (e.g., LAT), or
modems (e.g., DF296) which may eat these characters.</p>

<p style="margin-top: 1em">&Acirc;&middot; Some serial
lines do support clear-to-send (CTS) or request-to-send
(RTS) modem signals. For example on Alpha Flamingo machines,
only one port (/dev/tty00) supports full <br>
modem control, while the alternate console port (/dev/tty01)
does not. Therefore, if running loopback between both ports,
you can not use flow control, the test will hang <br>
waiting for these signals to transition (at least, I think
this is the case).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">flow=type <br>
Set flow to: none, cts_rts, or xon_xoff.</p>

<p style="margin-top: 1em">History history= Option <br>
This option sets the number of I/O history entries to
record. During failures, the history is dumped, which can be
helpful when troubleshooting failures.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">history=value <br>
Set the number of history request entries.</p>

<p style="margin-top: 1em">History Data Size hdsize= Option
<br>
When I/O history is enabled, this option controls how many
data bytes are saved for each I/O.</p>

<p style="margin-top: 1em">Syntax: <br>
hdsize=value Set the history data size (bytes to save).
Default hdsize=32 (set to 0 to disable copy)</p>

<p style="margin-top: 1em">Record Increment incr= Option
<br>
This option controls the bytes incremented when testing
variable length records. After each record, this increment
value (default 1), is added to the last record size
(starting <br>
at &quot;min=&quot;, up to the maximum record size
&quot;max=&quot;).</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; If variable
length record testing is enabled on fixed block disks and
this option is omitted, then &quot;incr=&quot; defaults to
512 bytes.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">incr=value <br>
Set number of record bytes to increment.</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">incr=variable <br>
Enables variable I/O request sizes.</p>

<p style="margin-top: 1em">I/O Direction iodir= Option <br>
This option allows you to control the I/O direction with
random access devices. The default direction is forward.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">iodir=direction <br>
Set I/O direction to: {forward or reverse}.</p>

<p style="margin-top: 1em">I/O Mode iomode= Option <br>
This option controls the I/O mode used, either copy, test,
or verify modes. The copy option was added to do a byte for
byte copy between devices, while skipping bad blocks and
<br>
keeping file offsets on both disks in sync. I&rsquo;ve used
this option to (mostly) recover my system disk which
developed bad blocks which could not be re-assigned. A
verify operation <br>
automatically occurs after the copy, which is real handy for
unreliable diskettes.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">iomode=mode <br>
Set I/O mode to: {copy, test, or verify}.</p>

<p style="margin-top: 1em">IOT Pass iotpass= Option <br>
This option is used to specify the IOT pass number. When
multiple passes occur, dt factors in the pass count to
generate unique data during each pass. For example, the IOT
seed <br>
is normally 0x01010101, and will be multiplied by the pass
specified, useful for re-reading previously written IOT data
patterns.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">iotpass=value <br>
Set the IOT pattern for specified pass.</p>

<p style="margin-top: 1em">IOT Seed iotseed= Option <br>
This option is used to specify the last IOT pattern seed dt
used. When multiple passes occur, dt now factors in the pass
count to generate unique data during each pass. For
exam&acirc; <br>
ple, the IOT seed is normally 0x01010101, but this is now
multiplied by the pass count for uniqueness.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">iotseed=value <br>
Set the IOT pattern block seed value.</p>

<p style="margin-top: 1em">I/O Type iotype= Option <br>
This option controls the type of I/O performed, either
random or sequential. The default is to do sequential
I/O.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The random
number generator used is chosen by defines: RAND48 to select
srand48()/lrand48(), RANDOM to select srandom()/random(),
and if neither are defined, <br>
srand()/rand() gets used by default. Refer to your system
literature or manual pages to determine which functions are
supported.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">iotype=type <br>
Set I/O type to: {random or sequential}.</p>

<p style="margin-top: 1em">The seeks are limited to the
data limited specified or calculated from other options on
the dt command line. If data limits are not specified, seeks
are limited to the size of <br>
existing files, or to the entire media for disk devices
(calculated automatically by dt). If the data limits exceed
the capacity of the media/partition/file under test, a
prema&acirc; <br>
ture end-of-file will be encountered on reads or writes, but
this is treated as a warning (expected), and not as an
error.</p>

<p style="margin-top: 1em">Minimum Record Size min= Option
<br>
This option controls the minimum record size to start at
when testing variable length records.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; By default,
tests using fixed length records of block size
&quot;bs=&quot; bytes.</p>

<p style="margin-top: 1em">&Acirc;&middot; This option, in
conjuntion with the &quot;max=&quot; and &quot;incr=&quot;
control variable length record sizes.</p>

<p style="margin-top: 1em">&Acirc;&middot; If variable
length record testing is enabled on fixed block disks and
this option is omitted, then &quot;min=&quot; defaults to
512 bytes.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">min=value <br>
Set the minumum record size to transfer.</p>

<p style="margin-top: 1em">Maxmimum Record Size max= Option
<br>
The option controls the maximum record size during variable
length record testing.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; If the
&quot;min=&quot; option is specified, and this option is
omitted, then the maximum record size is set to the block
size &quot;bs=&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; This option, in
conjuntion with the &quot;min=&quot; and &quot;incr=&quot;
control variable length record sizes.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">max=value <br>
Set the maximum record size to transfer.</p>

<p style="margin-top: 1em">Logical Block Address lba=
Option <br>
This option sets the starting logical block address used
with the &quot;lbdata&quot; option. When specified, the
logical block data &quot;enable=lbdata&quot; option is
automatically enabled.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">lba=value Set starting block
used w/lbdata option.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; Please do not
confuse this option with the disks&rsquo; real logical block
address. See &rsquo;s &quot;seek=&quot; or
&quot;position=&quot; options to set the starting file
position.</p>

<p style="margin-top: 1em">&Acirc;&middot; Also note that
doesn&rsquo;t know about disk partitions, so any position
specified is relative to the start of the partition
used.</p>

<p style="margin-top: 1em">Logical Block Size lbs= Option
<br>
This option sets the starting logical block size used with
the lbdata option. When specified, the logical block data
(enable=lbdata) option is automatically enabled.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">lbs=value <br>
Set logical block size for lbdata option.</p>

<p style="margin-top: 1em">Data Limit limit= Option <br>
This option specifies the number of data bytes to transfer
during each write and/or read pass for the test.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; You must specify
either a data limit, record limit, or files limit to
initiate a test, unless the device type is &quot;disk&quot;,
in which case dt will automatically determine the <br>
disk capacity.</p>

<p style="margin-top: 1em">&Acirc;&middot; When specifying
a runtime via the &quot;runtime=&quot; option, the data
limit controls how many bytes to process for each pass
(write and/or read pass).</p>

<p style="margin-top: 1em">&Acirc;&middot; If you specify a
infinite &quot;limit=inf&quot; value, each pass will
continue until the end of media or file is reached.</p>

<p style="margin-top: 1em">&Acirc;&middot; When the
&quot;step=value&quot; option is used, limit controls the
maximum offset stepped to.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">limit=value <br>
The number of bytes to transfer.</p>

<p style="margin-top: 1em">Munsa (DLM) munsa= Option <br>
This option is used on Tru64 Cluster systems to specify
various distributed lock manager (DLM) options with devices
or files.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">munsa=string <br>
Set munsa to: cr, cw, pr, pw, ex.</p>

<p style="margin-top: 1em">MUNSA Lock Options:</p>

<p style="margin-top: 1em">cr Concurrent Read (permits read
access, cr/pr/cw by others)</p>

<p style="margin-top: 1em">pr Protected Read (permits cr/pr
read access to all, no write)</p>

<p style="margin-top: 1em">cw Concurrent Write (permits
write and cr access to resource by all)</p>

<p style="margin-top: 1em">pw Protected Write (permits
write access, cr by others)</p>

<p style="margin-top: 1em">ex Exclusive Mode (permits
read/write access, no access to others)</p>

<p style="margin-top: 1em">For more details, please refer
to the dlm(4) reference page.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; MUNSA is an
obsolete Tru64 Cluster term which meant MUltiple Node
Simultaneous Access. The new term is DAIO for Direct Access
I/O. Finally, the last term used is DRD for <br>
Distributed Request Dispatcher.</p>

<p style="margin-top: 1em">Common Open Flags flags= Option
<br>
Output Open Flags oflags= Option <br>
These options are used to specify various POSIX compliant
open flags, and system specific flags, to test the affect of
these open modes.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; Each operating
system has different flags, which can be queried by
reviewing the help text (dt help).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">flags=flags <br>
Set open flags: {excl,sync,...}.</p>

<p style="margin-top: 1em">oflags=flags <br>
Set output flags: {append,trunc,...}.</p>

<p style="margin-top: 1em">On Child Error oncerr= Option
<br>
This option allows you to control the action taken by dt
when a child process exits with an error. By default, the
action is continue, which allows all child processes to run
to <br>
completion. If the child error action is set to abort, then
dt aborts all child processes if any child process exits
with an error status.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">oncerr={abort|continue} <br>
Set child error action.</p>

<p style="margin-top: 1em">No Progress Time noprogt= Option
<br>
This option allows you to specify a time (in seconds) to
report when I/O is not making progress. This option is used
in conjunction with the &quot;alarm=&quot; option to
periodically check <br>
for an report when I/O is taking too long. This is
especially useful during controller failover type
testing.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">noprogt=value <br>
Set the no progress time (in seconds).</p>

<p style="margin-top: 1em">No Progress Time Trigger
noprogtt= Option <br>
This option allows you to specify a time (in seconds) when
to initiate the no-progress time trigger script. Note: This
option has no effect, unless the noprogt= option is <br>
enabled.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">noprogtt=value <br>
Set the no progress time trigger (in seconds).</p>

<p style="margin-top: 1em">No Time notime= Option <br>
This option allows you to disable timing of certain
operations (system calls), when the no-progress options is
enabled. Valid optype&rsquo;s are: open close read write
ioctl fsync <br>
msync aiowait</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; This option has
no effect, unless the option is enabled.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">notime=optype <br>
Disable timing of specified operation type.</p>

<p style="margin-top: 1em">Terminal Parity Setting parity=
Option <br>
This option specifies the terminal parity setting to use
during testing.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">parity=string <br>
Set parity to: even, odd, or none.</p>

<p style="margin-top: 1em">parity=string <br>
(QNX) Set parity to: even, odd, mark, space, or none.</p>

<p style="margin-top: 1em">Pass Limit passes= Option <br>
This option controls the number of passes to perform for
each test.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The default is
to perform 1 pass.</p>

<p style="margin-top: 1em">&Acirc;&middot; When using the
&quot;of=&quot; option, each write/read combination is
considered a single pass.</p>

<p style="margin-top: 1em">&Acirc;&middot; When multiple
passes are specified, a different data pattern is used for
each pass, unless the user specified a data pattern or
pattern file. [ Please keep this in mind <br>
when using the &quot;dispose=keep&quot; option, since using
this same file for a subsequent read verify pass, will
report comparison errors... I&rsquo;ve burnt myself this
way. :-( ]</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">passes=value <br>
The number of passes to perform.</p>

<p style="margin-top: 1em">Data Pattern pattern= Option
<br>
This option specifies a 32 bit hexadecimal data pattern to
be used for the data pattern. dt has 12 built-in patterns,
which it alternates through when running multiple passes.
<br>
The default data patterns are:</p>

<p style="margin-top: 1em">0x39c39c39, 0x00ff00ff,
0x0f0f0f0f, 0xc6dec6de, 0x6db6db6d, 0x00000000, 0xffffffff,
0xaaaaaaaa, 0x33333333, 0x26673333, 0x66673326,
0x71c7c71c</p>

<p style="margin-top: 1em">You can also specify the special
keyword &quot;incr=&quot; to use an incrementing data
pattern, or specify a character string (normally contained
within single or double quotes).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">pattern=value <br>
The 32 bit hex data pattern to use.</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">pattern=iot <br>
Use DJ&rsquo;s IOT test pattern.</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">pattern=incr <br>
Use an incrementing data pattern.</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">pattern=string <br>
The string to use for the data pattern.</p>

<p style="margin-top: 1em">File Position position= Option
<br>
This option specifies a byte offset to seek to prior to
starting each pass of each test.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">position=offset <br>
Position to offset before testing.</p>

<p style="margin-top: 1em">Prefix prefix= Option <br>
This option allows the user to define a free format prefix
string which is written at the beginning of each block. It
is used to generate uniqueness useful when data corruption
<br>
occur. Certain format control strings are interpreted as
shown below.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">prefix=string <br>
The data pattern prefix string.</p>

<p style="margin-top: 1em">The prefix format controls
permitted are:</p>

<p style="margin-top: 1em">Prefix Format Control:</p>

<p style="margin-top: 1em">%d The device name.</p>

<p style="margin-top: 1em">%D The real device name.</p>

<p style="margin-top: 1em">%h The host name.</p>

<p style="margin-top: 1em">%H The full host name.</p>

<p style="margin-top: 1em">%p The process ID.</p>

<p style="margin-top: 1em">%P The parent PID.</p>

<p style="margin-top: 1em">%u = The user name.</p>

<p style="margin-top: 1em">Example: <br>
prefix=&quot;%u@%h (pid %p)&quot;</p>

<p style="margin-top: 1em">Multiple Processes procs= Option
<br>
This option specifies the number of processes to initiate
performing the same test. This option allows an easy method
for initiating multiple I/O requests to a single device or
<br>
file system.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The per process
limit on Tru64 UNIX is 64, and can be queried by using the
&quot;sysconfig -q proc&quot; command.</p>

<p style="margin-top: 1em">&Acirc;&middot; Spawning many
processes can render your system useless, well at least very
slow, and consumes large amounts of swap space (make sure
you have plenty!).</p>

<p style="margin-top: 1em">&Acirc;&middot; The parent
process simply monitors (waits for) all child prcoesses.</p>

<p style="margin-top: 1em">&Acirc;&middot; When writing to
a file system, the process ID (PID) is appended to the file
name specified with the &quot;of=&quot; option to create
unique file names. If no pattern is specified, <br>
each process is started with a unique data pattern.
Subsequent passes cycle through the 12 internal data
patterns. Use &quot;disable=unique&quot; to avoid this
behaviour.</p>

<p style="margin-top: 1em">&Acirc;&middot; The spawn()
facility, used to execute on a different node, is not
implemented on the QNX Operating System at this time.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">procs=value <br>
The number of processes to create.</p>

<p style="margin-top: 1em">Set Queue Depth qdepth= Option
<br>
This option is currently only implemented on HP-UX. It allow
you to set the queue depth of the device under test,
overriding its&rsquo; default. Note: The settings is sticky
<br>
(retained).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">qdepth=value <br>
Set the queue depth to specified value.</p>

<p style="margin-top: 1em">Random I/O Offset Alignment
wralign= Option <br>
This option is used when performing random I/O, to align
each random block offset to a particular alignment, for
example 32K.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">ralign=value <br>
The random I/O offset alignment.</p>

<p style="margin-top: 1em">Random I/O Data Limit rlimit=
Option <br>
This option is used with random I/O to specify the number of
bytes to limit random I/O between (starting from block to
this range). This option is independent of the data limit
<br>
option.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">rlimit=value <br>
The random I/O data byte limit.</p>

<p style="margin-top: 1em">Random Seed Value rseed= Option
<br>
This options sets the seed to initialize the random number
generator with, when doing random I/O. When selecting random
I/O, the total statistics displays the random seed used <br>
during that test. This option can be used to repeat the
random I/O sequence of a test.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">rseed=value <br>
The random seed to initialize with.</p>

<p style="margin-top: 1em">Record Limit records= Option
<br>
This option controls the number of records to process for
each write and/or read pass of each test. The
&quot;count=&quot; option is an alias for this option
(supported for dd compatibil&acirc; <br>
ity).</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; You must specify
either a data limit, record limit, or files limit to
initiate a test, unless the device type is &quot;disk&quot;,
in which case dt will automatically determine the <br>
disk capacity.</p>

<p style="margin-top: 1em">&Acirc;&middot; When specifying
a runtime via the &quot;runtime=&quot; option, the record
limit controls how many records process for each pass (write
and/or read pass).</p>

<p style="margin-top: 1em">&Acirc;&middot; If you specify a
infinite &quot;records=Inf&quot; value, each pass will
continue until the end of media or file is reached.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">records=value <br>
The number of records to process.</p>

<p style="margin-top: 1em">Run Time runtime= Option <br>
This option controls how long the total test should run.
When used in conjunction with a data limit or record limit,
multiple passes will be performed until the runtime limit
<br>
expires. A later section entitled &quot;Time Input
Parameters&quot;, describes the shorthand notation for time
values.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">runtime=time <br>
The number of seconds to execute.</p>

<p style="margin-top: 1em">Retry Delay retry_delay= Option
<br>
This option controls the number of seconds to delay between
reads performed after a data corruption. (see enable=retryDC
option)</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">retry_delay=value <br>
Delay before retrying operation. (Def: 5)</p>

<p style="margin-top: 1em">Slice slice= Option <br>
This option is used with random access devices. This option
is used in conjunction with the &quot;slices=value&quot;
option, which divides the media into slices (see below),
then <br>
&quot;slice=value&quot; defines the slice to do testing to.
Since dt does the calculations, this simplifies simultaneous
testing from multiple hosts to shared storage (usually a
multi-ini&acirc; <br>
tiator test requrement).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">slice=value <br>
The specific disk slice to test.</p>

<p style="margin-top: 1em">Slices slices= Option <br>
This option is used with random access devices. This option
divides the media into slices. Each slice contains a
different range of blocks to operate on in a separate
process. If <br>
no pattern is specified, then each slice is started with a
unique data pattern. Subsequent passes alternate through
dt&rsquo;s 12 internal patterns.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">slices=value <br>
The number of disk slices to test.</p>

<p style="margin-top: 1em">Note: This option can be used in
conjuntion with multiple processes and/or asynchronous I/O
options to generate a heavy I/O load, great for stress
testing!</p>

<p style="margin-top: 1em">Record Skip skip= Option <br>
This option specifies the numer of records to skip prior to
starting each write and/or read pass of each test. The skips
are accomplished by reading records.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">skip=value <br>
The number of records to skip past.</p>

<p style="margin-top: 1em">Record Seek seek= Option <br>
This option specifies the number of records to seek past
prior to starting each write and/or read test. The seeks are
accomplished by lseek()&rsquo;ing past records, which is
much <br>
faster than skipping when using random access devices.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">seek=value <br>
The number of records to seek past.</p>

<p style="margin-top: 1em">Data Step step= Option <br>
This option is used to specify non-sequential I/O requests
to random access devices. Normally, dt does sequential read
&amp; writes, but this option specifies that step bytes to
be <br>
seeked past after each request.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;limit=value&quot; option can be used to set the
maximum offset.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">step=value <br>
The number of bytes seeked after I/O.</p>

<p style="margin-top: 1em">Terminal Speed speed= Option
<br>
This option specifies the terminal speed (baud rate) to
setup prior to initiating the test. Although dt supports all
valid baud rates, some speeds may not be supported by all
<br>
serial line drivers, and in some cases, specifying higher
speeds may result in hardware errors (e.g., silo overflow,
framing error, and/or hardware/software overrun errors). The
<br>
valid speeds accepted by dt are:</p>

<p style="margin-top: 1em">0 50 75 110 134 150</p>

<p style="margin-top: 1em">200 300 600 1200 1800 2400</p>

<p style="margin-top: 1em">4800 9600 19200 38400 57600
115200</p>

<p style="margin-top: 1em">Although a baud rate of zero is
accepted, this is done mainly for testing purposes (some
systems use zero to hangup modems). The higher baud rates
are only valid on systems which <br>
define the Bxxxxx speeds in termios.h.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The default
speed is 9600 baud.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">speed=value <br>
The tty speed (baud rate) to use.</p>

<p style="margin-top: 1em">Terminal Read Timeout timeout=
Option <br>
This option specifies the timeout to use, in 10ths of a
second, when testing terminal line interfaces. This is the
timeout used between each character after the first
character <br>
is received, which may prevent tests from hanging when a
character is garbled and lost.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The default
terminal timeout is 3 seconds.</p>

<p style="margin-top: 1em">&Acirc;&middot; The default
timeout is automatically adjusted for slow baud rates.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">timeout=value <br>
The tty read timeout in .10 seconds.</p>

<p style="margin-top: 1em">Terminal Read Minimum ttymin=
Option <br>
This option specifies the minmum number of characers to
read, sets the VMIN tty attribute.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The tty VMIN
field normally gets sets to the value of the block size
().</p>

<p style="margin-top: 1em">&Acirc;&middot; Note that on
some systems, the VMIN field is an unsigned char, so the
maximum value is 255.</p>

<p style="margin-top: 1em">&Acirc;&middot; On QNX, this
field is an unsigned short, so a maximum of 65535 is
valid.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">ttymin=value <br>
The tty read minimum count (sets vmin).</p>

<p style="margin-top: 1em">Trigger Action trigger= Option
<br>
This option specifies a trigger action to take whenever an
error occurs and/or when the no-progress time has been
exceeded (see &quot;enable=noprog&quot;). It&rsquo;s main
purpose is for trig&acirc; <br>
gering an anlyzer and/or stopping I/O by some means (panic,
etc) when trouble-shooting.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">trigger=type The trigger to
execute during errors.</p>

<p style="margin-top: 1em">Trigger Types:</p>

<p style="margin-top: 1em">br Execute a bus reset.</p>

<p style="margin-top: 1em">bdr Execute a bus device
reset.</p>

<p style="margin-top: 1em">seek Issue a seek to the failing
lba.</p>

<p style="margin-top: 1em">cmd:string <br>
Execute command with these args: string dname op dsize
offset position lba errno</p>

<p style="margin-top: 1em">The first three options require
Scu in your PATH.</p>

<p style="margin-top: 1em">When specifying the
&quot;cmd:&quot; type, which invokes a program/script, the
following arguments are passed on the command line: <br>
Format: cmd dname op dsize offset position lba errno
noprogtime</p>

<p style="margin-top: 1em">Where: <br>
dname = The device/file name. <br>
op = open/close/read/write/miscompare/noprog <br>
dsize = The device block size. <br>
offset = The current file offset. <br>
position = The failing offset within block. <br>
lba = The logical block address (relative for FS). <br>
errno = The error number on syscall errors. <br>
noprogtime = The no-progress time (in seconds).</p>

<p style="margin-top: 1em">Multiple Volumes volumes= Option
<br>
Multi-Volume Records vrecords= Option <br>
These options are used with removal media devices, to define
how many volumes and records on the last volume to process
(i.e., tapes, etc). By using these options, you do not <br>
have to guess at a data limit or record limit, to overflow
onto subsequent volumes. These options automatically sets
the &quot;enable=multi&quot; option.</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">volumes=value <br>
The number of volumes to process.</p>

<p style="margin-top: 1em">vrecords=value <br>
The record limit for the last volume.</p>

<p style="margin-top: 1em">Enable enable= and Disable
disable= Options <br>
These options are used to either enable or disable program
flags which either alter default test modes, test actions,
or provide additional debugging information. You can specify
<br>
a single flag or multiple flags each seperated by a comma
(e.g., &quot;enable=aio,debug,dump&quot;).</p>

<p style="margin-top: 1em">Syntax:</p>

<p style="margin-top: 1em">enable=flag Enable one or more
of the flags below.</p>

<p style="margin-top: 1em">disable=flag Disable one or more
of the flags below.</p>

<p style="margin-top: 1em">The flags which can be enabled
or disabled are described below.</p>

<p style="margin-top: 1em">POSIX Asynchronous I/O aio Flag
<br>
This flag is used to control use of POSIX Asynchronous I/O
during testing, rather than the synchronous I/O read() and
write() system calls.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; Beware, you may
need to rebuild on new versions of Tru64 Unix due to POSIX
changes and/or AIO library changes between major
releases.</p>

<p style="margin-top: 1em">&Acirc;&middot; Reference the
&quot;aios=&quot; option, for more special notes.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">aio POSIX Asynchronous
I/O.(Default: disabled)</p>

<p style="margin-top: 1em">Reporting Close Errors cerror
Flag <br>
This flag controls where close errors are reported as an
error or a failure. When disabled, close errors are reported
as a warning. This flag is meant to be used as a workaround
<br>
for device drivers which improperly return failures when
closing the device. Many system utilities ignore close
failures, but when testing terminals and tapes, the close
status <br>
us very important. For example with tapes, the close
reflects the status of writing filemarks (which also flush
buffered data), and the rewind status.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">cerrors <br>
Report close errors. (Default: enabled)</p>

<p style="margin-top: 1em">Data Comparison compare Flag
<br>
This flag disables data verification during the read pass of
tests. This flag should be disabled to read to end of
file/media to obtain maximum capacity statistics, or to
obtain <br>
maximum performance statistics (less overhead).</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">compare <br>
Data comparison. (Default: enabled)</p>

<p style="margin-top: 1em">Core Dump on Errors coredump
Flag <br>
This flag controls whether a core file is generated, via
abort(), when dt is exiting with a failure status code. This
is mainly used for program debug, and is not of much
inter&acirc; <br>
est to normal users. When testing multiple processes, via
fork(), this is useful if your OS debugger does not support
debugging child processes.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">coredump <br>
Core dump on errors. (Default: disabled)</p>

<p style="margin-top: 1em">Diagnostic Logging diag Flag
<br>
This option is only valid on Tru64 Unix. When enabled, error
messages get logged to the binary error logger. This is
useful to correlate device error entries with test failures.
<br>
Please note, the logging only occurs when running as
superuser (API restriction, not mine!).</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">diag Log diagnostic msgs.
(Default: disabled)</p>

<p style="margin-top: 1em">Debug Output debug Flag <br>
Verbose Debug Output Debug Flag <br>
Random I/O Debug Output rdebug Flag <br>
These flags enable two different levels of debug, which are
useful when trouble-shooting certain problems (i.e., what is
dt doing to cause this failure?). Both flags can be
spec&acirc; <br>
ified for full debug output.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">debug Debug output. (Default:
disabled)</p>

<p style="margin-top: 1em">Debug Verbose debug output.
(Default: disabled)</p>

<p style="margin-top: 1em">edebug End of file debug.
(Default: disabled)</p>

<p style="margin-top: 1em">rdebug Random debug output.
(Default: disabled)</p>

<p style="margin-top: 1em">tdebug Timer debug output.
(Default: disabled)</p>

<p style="margin-top: 1em">Dump Data Buffer dump Flag <br>
This flag controls dumping of the data buffer during data
comparision failures. If a pattern file is being used, then
the pattern buffer is also dumped for easy comparision
pur&acirc; <br>
poses. To prevent too many bytes from being dumped, esp.
when using large block sizes, dumping is limited to 512
bytes of data (was 64, recently increased).</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; When the failure
occurs within the first 64 bytes of the buffer, dumping
starts at the beginning of the buffer.</p>

<p style="margin-top: 1em">&Acirc;&middot; When the failure
occurs at some offset within the data buffer, then dumping
starts at (data limit/2) bytes prior to the failing byte to
provide context.</p>

<p style="margin-top: 1em">&Acirc;&middot; The start of the
failing data is marked by an asterisk &rsquo;*&rsquo;.</p>

<p style="margin-top: 1em">&Acirc;&middot; You can use the
option to override the default dump limit.</p>

<p style="margin-top: 1em">&Acirc;&middot; Buffer addresses
are displayed for detection of memory boundary problems.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">dump Dump data buffer. (Default:
enabled)</p>

<p style="margin-top: 1em">Tape EEI Reporting eei Flag <br>
This option controls the reporting of Extended Error
Information (EEI) on Tru64 UNIX systems, for tape devices
when errors occur. The standard tape information available
from mt <br>
is reported, along with the EEI status, CAM status, and SCSI
request sense data. This is excellent information to help
diagnose tape failures. (thank-you John Meneghini!)</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">eei Tape EEI reporting.
(Default: enabled)</p>

<p style="margin-top: 1em">Flush Terminal I/O Queues flush
Flag <br>
This flag controls whether the terminal I/O queues get
flushed before each test begins. This must be done to ensure
no residual characters are left in the queues from a prior
<br>
test, or else data verification errors will be reported.
Residual characters may also be left from a previous
XOFF&rsquo;ed terminal state (output was suspended).</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">flush Flush tty I/O queues.
(Default: enabled)</p>

<p style="margin-top: 1em">History Dumping hdump Flag <br>
This flag controls dumping the history entries at the end of
a test. Normally dt only dumps the history during errors,
but this option when enabled, dumps the history when
exit&acirc; <br>
ing. This is useful if you are timing I/O&rsquo;s, or wish
to see the LBA&rsquo;s I/O went to, etc.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">hdump History dump. (Default:
disabled)</p>

<p style="margin-top: 1em">History Timing htiming Flag <br>
This flag controls the timing of history entries. Please be
aware, that enabling timing of each I/O will impact your
overall test performance, as an extra system call is used to
<br>
obtain system time.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">htiming <br>
History timing. (Default: disabled)</p>

<p style="margin-top: 1em">Log File Header header Flag <br>
When a log file is specified, dt automatically writes the
command line and dt version information at the beginning of
the log file. This option allows you to control whether this
<br>
header should be written.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">header Log file header.
(Default: enabled)</p>

<p style="margin-top: 1em">Loop On Error looponerror Flag
<br>
This flag controls lopping on data corruption rereads. This
can be helpful in capturing the failing read request on an
analyzer.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; Also see
&quot;retry_delay=value&quot; and retryDC flag control.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">looponerror <br>
Loop on error. (Default: disabled)</p>

<p style="margin-top: 1em">Logical Block Data Mode lbdata
Flag <br>
This option enables a feature called logical block data
mode. This feature allows reading/writing of a 4-byte
(32-bit) logical block address at the beginning of each data
block <br>
tested. The block number is stored using SCSI byte ordering
(big-endian), which matches what the SCSI Write Same
w/lbdata option uses, so dt can verify this pattern,
generated by <br>
scu&rsquo;s &quot;write same&quot; command.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The starting
logical block address defaults to 0, unless overridden with
the &quot;lba=&quot; option.</p>

<p style="margin-top: 1em">&Acirc;&middot; The logical
block size defaults to 512 bytes, unless overridden with the
&quot;lbs=&quot; option.</p>

<p style="margin-top: 1em">&Acirc;&middot; The logical
block address is always inserted started at the beginning of
each data block.</p>

<p style="margin-top: 1em">&Acirc;&middot; Enabling this
feature will degrade performance statistics (slightly).</p>

<p style="margin-top: 1em">Enable Loopback Mode loopback
Flag <br>
This flag specifies that either the input or output file
should be used in a loopback mode. In loopback mode, dt
forks(), and makes the child process the reader, while the
parent <br>
process becomes the writer. In previous versions of dt, you
had to specify both the same input and output file to enable
loopback mode. When specifying this flag, dt automati&acirc;
<br>
cally duplicates the input or output device, which is a
little cleaner than the old method (which still works).</p>

<p style="margin-top: 1em">Some people may argue that dt
should automatically enable loopback mode when a single
terminal or FIFO device is detected. The rationale behind
not doing this is described below:</p>

<p style="margin-top: 1em">&Acirc;&middot; You may wish to
have another process as reader and/or writer (which also
includes another program, not necessarily ).</p>

<p style="margin-top: 1em">&Acirc;&middot; You may wish to
perform device loopback between two systems (e.g., to verify
the terminal drivers of two operating systems are
compatible).</p>

<p style="margin-top: 1em">&Acirc;&middot; A goal of is to
force (hardcode) actions or options to make the program more
flexible. A minimum of validity checking is done to avoid
being too restrictive, although <br>
hooks exists to do this.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The read verify
flag is automatically disabled.</p>

<p style="margin-top: 1em">&Acirc;&middot; This mode is
most useful with terminal devices and/or FIFO&rsquo;s (named
pipes).</p>

<p style="margin-top: 1em">Microsecond Delays microdelay
Flag <br>
This flag tells dt that delay values, i.e.
&quot;sdelay=&quot; and others, should be executed using
microsecond intervals, rather the second intervals.
(thank-you George Bittner for imple&acirc; <br>
menting this support!)</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">microdelay <br>
Microsecond delays. (Default: disabled)</p>

<p style="margin-top: 1em">Memory Mapped I/O mmap Flag <br>
This flag controls whether the memory mapped API is used for
testing. This test mode is currently supported on SUN/OS,
Tru64 UNIX, and Linux operating systems.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The block size
specified &quot;bs=&quot; be a multiple of the system
dependent page size (normally 4k or 8k).</p>

<p style="margin-top: 1em">&Acirc;&middot; An msync() is
done after writing and prior to closing to force modified
pages to permanent storage. It may be useful to add an
option to inhibit this action at some point, <br>
but my testing was specifically to time mmap performance.
Obviously, invalidating the memory mapped pages, kind of
defeats the purpose of using memory mapped files in the <br>
first place.</p>

<p style="margin-top: 1em">&Acirc;&middot; Specifying
multiple passes when doing a read verify test, gives you a
good indication of the system paging utilization on
successive passes.</p>

<p style="margin-top: 1em">&Acirc;&middot; Memory mapping
large data files (many megabytes) may exhaust certain system
resources. On an early version of SUN/OS V4.0?, I could hang
my system by gobbling up all of <br>
physical memory and forcing paging (this was certainly a bug
which has probably been corrected since then).</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">mmap Memory mapped I/O.
(Default: disabled)</p>

<p style="margin-top: 1em">Test Modem Lines modem Flag <br>
This flag controls the testing of terminal modem lines.
Normally, dt disables modem control, via setting CLOCAL, to
prevent tests from hanging. When this flag is enabled, dt
<br>
enables modem control, via clearing CLOCAL, and then
monitoring the modem signals looking for either carrier
detect (CD) or dataset ready (DSR) before allowing the test
to start.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; The program does
not contain modem signal monitoring functions for the all
operating systems. The functions in are specific to Tru64
UNIX and ULTRIX systems, but these can <br>
be used as templates for other operating systems.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">modem Test modem tty lines.
(Default: disabled)</p>

<p style="margin-top: 1em">Multiple Volumes multi Flag <br>
This flag controls whether multiple volumes are used during
testing. When this flag is enabled, if the data limit or
record count specified does not fit on the current loaded
<br>
media, the user is prompted to insert the next media to
continue testing. Although this is used mostly with tape
devices, it can be used with any removeable media.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">multi Multiple volumes.
(Default: disabled)</p>

<p style="margin-top: 1em">No I/O Progress noprog Flag <br>
This flag controls whether dt will check for slow or no I/O
progress during testing.</p>

<p style="margin-top: 1em">Special Notes Enabling this flag
will do nothing by itself. The &quot;alarm=&quot; option
specifies the frequency of how often dt checks for no
progress.</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;noprogt=secs&quot; option specified the no I/O
progress time.</p>

<p style="margin-top: 1em">&Acirc;&middot; If
&quot;noprogt=&quot; is omitted, it defaults to the
&quot;alarm&quot; time value.</p>

<p style="margin-top: 1em">&Acirc;&middot; The noprog flag
is implicitly enabled by the &quot;noprogt=value&quot;
option.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">noprog No progress check.
(Default: disabled)</p>

<p style="margin-top: 1em">Prefill prefill Flag <br>
This flag controls the buffer prefill normally performed
prior to reads. Normally, dt prefills the buffer with the
inverted data pattern (1st four bytes). This, of course,
<br>
ensures the data is overwritten with data read, but also
imposes overhead not always desirable.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; When IOT pattern
is used, this flag is automatically enabled, since IOT
blocks are unique.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">prefill <br>
Prefill read buffer. (Default: enabled)</p>

<p style="margin-top: 1em">Control Per Pass Statistics
pstats Flag <br>
This flag controls whether the per pass statistics are
displayed. If this flag is disabled, a single summary line
is still displayed per pass and the total statistics are
still <br>
displayed in the full format.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">pstats Per pass statistics.
(Default: enabled)</p>

<p style="margin-top: 1em">Read After Write raw Flag <br>
This flag controls whether a read-after-write will be
performed. Sorry, raw does not mean character device
interface. Normally dt performs a write pass, followed by a
read pass. <br>
When this flag is enabled the read/verify is done
immediately after the write.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">raw Read after write. (Default:
disabled)</p>

<p style="margin-top: 1em">Tape Reset Handling resets Flag
<br>
This option is used during SCSI bus and device reset
testing, to reposition the tape position (tapes rewind on
resets), and to continue testing. This option is only
enabled for <br>
Tru64 UNIX systems (currently), since this option requires
reset detection from EEI status, and tape position
information from the CAM tape driver (although dt also
maintains the <br>
tape position as a sanity check against the drivers&rsquo;
data)</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">resets Tape reset handling.
(Default: disabled)</p>

<p style="margin-top: 1em">Retry Data Corruptions retryDC
Flag <br>
This flag controls whether a data corruption retry is
performed. A second read is done to re-read the data, with
direct I/O for file systems, and the data is compared
against the <br>
previous read data, and the expected data. If the reread
data matches the expected data, then dt assumes a &quot;read
failure&quot; occurred, otherwise if the reread data matches
the pre&acirc; <br>
vious read, dt assumes a &quot;write failure&quot; (the data
was written incorrectly).</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">retryDC <br>
Retry data corruptions.(Default: enabled)</p>

<p style="margin-top: 1em">Control Program Statistics stats
Flag <br>
This flag controls whether any statistics get displayed
(both pass and total statistics). Disabling this flag also
disabled the pass statistics described above.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">stats Display statistics.
(Default: enabled)</p>

<p style="margin-top: 1em">Table(sysinfo) timing table Flag
<br>
On Tru64 UNIX systems, this option enables additional timing
information which gets reported as part of the statistics
display. (thanks to Jeff Detjen for adding this
support!)</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">table Table(sysinfo) timing.
(Default: disabled)</p>

<p style="margin-top: 1em">System Log syslog Flag <br>
This flag controls logging startup/finish and errors being
logged to the system logger. This can be helpful when
correlating dt&rsquo;s errors with system (driver/file
system) error <br>
messages.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">syslog Log errors to syslog.
(Default: disabled)</p>

<p style="margin-top: 1em">Timestamp Blocks timestamp Flag
<br>
This flag controls whether blocks are timestamped when
written. The timestamp is skipped during data comparisions,
but is displayed if any remaining data is incorrect.</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; When IOT or
lbdata patterns are used, the block number is overwritten by
the timestamp.</p>

<p style="margin-top: 1em">&Acirc;&middot; This flag is a
stop-gap, until block tagging (w/more information) is
implemented.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">timestamp <br>
Timestamp each block. (Default: disabled)</p>

<p style="margin-top: 1em">Unique Pattern unqiue Flag <br>
This flag controls whether multiple process, get a unqiue
data pattern. This affects processes started with the
&quot;slices=&quot; or the &quot;procs=&quot; options. This
only affects the procs= <br>
option when writing to a regular file.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">unique Unique pattern. (Default:
enabled)</p>

<p style="margin-top: 1em">Verbose Output verbose Flag <br>
This flag controls certain informational program messages
such as reading and writing partial records. If you find
these messages undesirable, then they can be turned off by
dis&acirc; <br>
abling this flag.</p>

<p style="margin-top: 1em">But beware, partial reads or
writes of disk records if not at EOF is usually a
problem!</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">verbose <br>
Verbose output. (Default: enabled)</p>

<p style="margin-top: 1em">Verify Data verify Flag <br>
This flag controls whether the read verify pass is performed
automatically after the write pass. Ordinarily, when
specifying an output device via the &quot;of=&quot; option,
a read verify <br>
pass is done to read and perform a data comparision. If you
only wish to write the data, and omit the data verification
read pass, then di able this flag.</p>

<p style="margin-top: 1em">Flag:</p>

<p style="margin-top: 1em">verify Verify data written.
(Default: enabled)</p>

<p style="margin-top: 1em">Special Notes</p>

<p style="margin-top: 1em">&Acirc;&middot; If you
don&rsquo;t plan to ever read the data being written,
perhaps for performance reasons, specifying
&quot;disable=compare&quot; prevents the data buffer from
being initialized with a <br>
data pattern.</p>

<p style="margin-top: 1em">&Acirc;&middot; This verify
option has no affect when reading a device. You must disable
data comparsions via &quot;disable=compare&quot;.</p>

<p style="margin-top: 1em">Program Delays <br>
dt allows you to specify various delays to use at certain
points of the test. These delays are useful to slow down I/O
requests or to prevent race conditions when testing
termi&acirc; <br>
nals devices with multiple processes, or are useful for low
level driver debugging. All delay values are in seconds,
unless you specify &quot;enable=microdelay&quot;, to enable
micro-sec&acirc; <br>
ond delays.</p>

<p style="margin-top: 1em">Close File cdelay= Delay <br>
This delay, when enabled, is performed prior to closing a
file descriptor.</p>

<p style="margin-top: 1em">Delay</p>

<p style="margin-top: 1em">cdelay=value <br>
Delay before closing the file. (Def: 0)</p>

<p style="margin-top: 1em">End of Test edelay= Delay <br>
This delay, when enabled, is used to delay after closing a
device, but prior to re-opening the device between multiple
passes.</p>

<p style="margin-top: 1em">Delay:</p>

<p style="margin-top: 1em">edelay=value <br>
Delay between multiple passes. (Def: 0)</p>

<p style="margin-top: 1em">Read Record rdelay= Delay <br>
This delay, when enabled, is used prior to issuing each read
request (both synchronous read()&rsquo;s and asynchronous
aio_read()&rsquo;s).</p>

<p style="margin-top: 1em">Delay:</p>

<p style="margin-top: 1em">rdelay=value <br>
Delay before reading each record. (Def: 0)</p>

<p style="margin-top: 1em">Start Test sdelay= Delay <br>
This delay, when enabled, is used prior to starting the
test. When testing terminal devices, when not in self
loopback mode, the writing process (the parent)
automatically delays <br>
1 second, to allow the reading process (the child) to
startup and setup its&rsquo; terminal characteristics. If
this delay did not occur prior to the first write, the
reader may not <br>
have its&rsquo; terminal characteristics (flow, parity,
&amp; speed) setup yet, and may inadvertantly flush the
writers data or receive garbled data.</p>

<p style="margin-top: 1em">Delay:</p>

<p style="margin-top: 1em">sdelay=value <br>
Delay before starting the test. (Def: 0)</p>

<p style="margin-top: 1em">Child Terminate tdelay= Delay
<br>
This delay is used by child processes before exiting, to
give the parent process sufficient time to cleanup and wait
for the child. This is necessary since if the child exits
<br>
first, a SIGCHLD signal may force the parent to it&rsquo;s
termination signal handler before it&rsquo;s ready to. This
is a very simplistic approach to prevent this parent/child
race condi&acirc; <br>
tion and is only currently used by the child for terminal
loopback testing.</p>

<p style="margin-top: 1em">Delay:</p>

<p style="margin-top: 1em">tdelay=value <br>
Delay before child terminates. (Def: 1)</p>

<p style="margin-top: 1em">Write Record wdelay= Delay <br>
This delay, when enabled, is used prior to issuing each
write request (both synchronous write()&rsquo;s and
asynchronous aio_write()&rsquo;s).</p>

<p style="margin-top: 1em">Delay:</p>

<p style="margin-top: 1em">wdelay=value <br>
Delay before writing each record. (Def: 0)</p>

<p style="margin-top: 1em">Numeric Input Parameters <br>
For any options accepting numeric input, the string entered
may contain any combination of the following characters:</p>

<p style="margin-top: 1em">Special Characters:</p>

<p style="margin-top: 1em">w words (4 bytes)</p>

<p style="margin-top: 1em">q quadwords (8 bytes)</p>

<p style="margin-top: 1em">b blocks (512 bytes)</p>

<p style="margin-top: 1em">k kilobytes (1024 bytes)</p>

<p style="margin-top: 1em">m megabytes (1048576 bytes)</p>

<p style="margin-top: 1em">p page size (8192 bytes)</p>

<p style="margin-top: 1em">g gigabytes (1073741824
bytes)</p>

<p style="margin-top: 1em">t terabytes (1099511627776
bytes)</p>

<p style="margin-top: 1em">inf or INF <br>
infinity (18446744073709551615 bytes)</p>

<p style="margin-top: 1em">Arithmetic Characters:</p>

<p style="margin-top: 1em">+ addition</p>

<p style="margin-top: 1em">- subtraction</p>

<p style="margin-top: 1em">* or x multiplication</p>

<p style="margin-top: 1em">/ division</p>

<p style="margin-top: 1em">% remainder</p>

<p style="margin-top: 1em">Bitwise Characters:</p>

<p style="margin-top: 1em">~ complement of value</p>

<p style="margin-top: 1em">&gt;&gt; shift bits right</p>

<p style="margin-top: 1em">&lt;&lt; shift bits left</p>

<p style="margin-top: 1em">&amp; bitwise &rsquo;and&rsquo;
operation</p>

<p style="margin-top: 1em">| bitwise &rsquo;or&rsquo;
operation</p>

<p style="margin-top: 1em">^ bitwise exclusive
&rsquo;or&rsquo;</p>

<p style="margin-top: 1em">The default base for numeric
input is decimal, but you can override this default by
specifying 0x or 0X for hexadecimal coversions, or a leading
zero &rsquo;0&rsquo; for octal conversions.</p>

<p style="margin-top: 1em">NOTE: Certain values will vary
depending on the operating system and/or machine you are
running on. For example, the page size is system dependent,
and the value for Infinity is <br>
the largest value that will fit into an unsigned long long
(value shown above is for 64-bit systems), or double for
systems which don&rsquo;t support &quot;long
long&quot;.)</p>

<p style="margin-top: 1em">Time Input Parameters <br>
When specifying the run time &quot;runtime=&quot; option,
the time string entered may contain any combination of the
following characters:</p>

<p style="margin-top: 1em">Time Input:</p>

<p style="margin-top: 1em">d days (86400 seconds)</p>

<p style="margin-top: 1em">h hours (3600 seconds)</p>

<p style="margin-top: 1em">m minutes (60 seconds)</p>

<p style="margin-top: 1em">s seconds (the default)</p>

<p style="margin-top: 1em">Arithmetic characters are
permitted, and implicit addition is performed on strings of
the form &rsquo;1d5h10m30s&rsquo;.</p>

<p style="margin-top: 1em">Future Enhancements <br>
Initially dt was written to be a generic test tool, designed
to test any device, and although that was (mostly)
accomplished, device specific tests needed to be and were
devel&acirc; <br>
oped, based on the device type detected or specified by the
&quot;dtype=&quot; option if not determined
automatically.</p>

<p style="margin-top: 1em">Some of the features requested
include:</p>

<p style="margin-top: 1em">&Acirc;&middot; Support for an
initialization file () to setup frequent or common test
parameters.</p>

<p style="margin-top: 1em">&Acirc;&middot; Develop
corruption analysis logic. What is this? Folks familiar with
HP&rsquo;s Hazard know how valuable this is: data re-read
logic, I/O history, metadata prowlers, and <br>
detailed analysis of expected and received data. A lot of
work is involved here, especially with file system prowlers,
which are responsible for converting file system <br>
data structures to physical underlying LBA&rsquo;s, to help
identify bad data in analyzer traces.</p>

<p style="margin-top: 1em">&Acirc;&middot; Improved file
system testing. Although not developed as a file system
exerciser, many folks use it this way. Multiple processes
creating unique data files generates a data <br>
load, but many file system specific features, such as
truncating files, file locking, creating lots of metadata
(via subdirectories), and many more are not tested well.
<br>
Major effort here!</p>

<p style="margin-top: 1em">&Acirc;&middot; Supporting
multiple devices in one invocation (perhaps a comma
separated list). Although multiple processes or threads
could accomplish this, it does add complexity <br>
requiring locking and switching to reentrant library
API&rsquo;s, and the savings is shared code is minimal (I
think) since most of the address space is data buffers.</p>

<p style="margin-top: 1em">&Acirc;&middot; Multiple threads
for I/O is likely to be implemented one day. The reason I
haven&rsquo;t rushed this I/O method, is because POSIX AIO
provides my need, and most modern day OS&rsquo;s <br>
now support POSIX AIO. Interestingly enough, the Linux AIO
is implemented via POSIX threads! Threads are interesting to
overcome OS&rsquo;s with a process limit, and threads <br>
(should) reduce system resources.</p>

<p style="margin-top: 1em">&Acirc;&middot; Incorporate SCSI
library to implement bus/target/lun reset triggers, etc.</p>

<p style="margin-top: 1em">&Acirc;&middot; Interactive
interface to keep the device open, like does, to allow more
creative tests, especially for tapes and tape libraries
(although most use for disk testing).</p>

<p style="margin-top: 1em">&Acirc;&middot; Add output
formats to allow statistics to be imported to tools such as
MS Excel, etc.</p>

<p style="margin-top: 1em">&Acirc;&middot; GUI front-end?
Might be nice, but not necessary for test automation.
Volunteers?</p>

<p style="margin-top: 1em">&Acirc;&middot; Port to VMS?
There&rsquo;s a need, so given the time, this will likely
happen.</p>

<p style="margin-top: 1em">&Acirc;&middot; Native Windows?
Mostly there, thanks to the HP Hazard India team, but
unfortuanatly I no longer have a Windows development
environment, so I cannot supply updates. The <br>
code needs a few tweaks for file system testing, ported for
raw I/O testing initially.</p>

<p style="margin-top: 1em">&Acirc;&middot; iozone supplies
many of the features above, so you may wish to consider this
tool too. It&rsquo;s difficult, if not impossible, to supply
sufficient features for everyones test <br>
needs!</p>

<p style="margin-top: 1em">Final Comments <br>
I&rsquo;m happy to report that is getting wide spread use
all over the world! Storage groups, terminal/lat groups,
Q/A, developers, and other peripheral qualification groups
are using <br>
as part of their testing. I guess maybe this will be my
(computer) legacy?</p>

<p style="margin-top: 1em">Anyways, I hope you find as
useful as I have. This is usually one of the first tools I
port to a new operating system, since it&rsquo;s an
excellent diagnostic and performance tool (it <br>
gives me a warm and fuzzy feeling ).</p>

<p style="margin-top: 1em">AUTHOR <br>
Written by Robin Miller &lt;robin dot miller at netapp dot
com&gt;</p>

<p style="margin-top: 1em">dt version 16.20 27 Jul 2009
dt(1)</p>
<hr>
</body>
</html>
