<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:17:53 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>ZEBRASRV(8) Commands ZEBRASRV(8)</p>

<p style="margin-top: 1em">NAME <br>
zebrasrv - Zebra Server</p>

<p style="margin-top: 1em">SYNOPSIS <br>
zebrasrv [-install] [-installa] [-remove] [-a file] [-v
level] [-l file] [-u uid] [-c config] [-f vconfig] [-C
fname] [-t minutes] [-k kilobytes] [-d daemon] [-w dir] <br>
[-p pidfile] [-ziDST1] [listener-spec...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Zebra is a high-performance, general-purpose structured text
indexing and retrieval engine. It reads structured records
in a variety of input formats (e.g. email, XML, MARC) and
<br>
allows access to them through exact boolean search
expressions and relevance-ranked free-text queries.</p>

<p style="margin-top: 1em">zebrasrv is the Z39.50 and SRU
frontend server for the Zebra search engine and indexer.</p>

<p style="margin-top: 1em">On Unix you can run the zebrasrv
server from the command line - and put it in the background.
It may also operate under the inet daemon. On WIN32 you can
run the server as a <br>
console application or as a WIN32 Service.</p>

<p style="margin-top: 1em">OPTIONS <br>
The options for zebrasrv are the same as those for
YAZ&rsquo; yaz-ztest. Option -c specifies a Zebra
configuration file - if omitted zebra.cfg is read.</p>

<p style="margin-top: 1em">-a file <br>
Specify a file for dumping PDUs (for diagnostic purposes).
The special name - (dash) sends output to stderr.</p>

<p style="margin-top: 1em">-S <br>
Don&rsquo;t fork or make threads on connection requests.
This is good for debugging, but not recommended for real
operation: Although the server is asynchronous and
non-blocking, <br>
it can be nice to keep a software malfunction (okay then, a
crash) from affecting all current users. The server can only
accept a single connection in this mode.</p>

<p style="margin-top: 1em">-1 <br>
Like -S but after one session the server exits. This mode is
for debugging only.</p>

<p style="margin-top: 1em">-T <br>
Operate the server in threaded mode. The server creates a
thread for each connection rather than a fork a process.
Only available on UNIX systems that offers POSIX
threads.</p>

<p style="margin-top: 1em">-s <br>
Use the SR protocol (obsolete).</p>

<p style="margin-top: 1em">-z <br>
Use the Z39.50 protocol (default). This option and -s
complement each other. You can use both multiple times on
the same command line, between listener-specifications (see
<br>
below). This way, you can set up the server to listen for
connections in both protocols concurrently, on different
local ports.</p>

<p style="margin-top: 1em">-l file <br>
Specify an output file for the diagnostic messages. The
default is to write this information to stderr</p>

<p style="margin-top: 1em">-c config-file <br>
Read configuration information from config-file. The default
configuration is ./zebra.cfg</p>

<p style="margin-top: 1em">-f vconfig <br>
This specifies an XML file that describes one or more YAZ
frontend virtual servers. See section VIRTUAL HOSTS for
details.</p>

<p style="margin-top: 1em">-C fname <br>
Sets SSL certificate file name for server (PEM).</p>

<p style="margin-top: 1em">-v level <br>
The log level. Use a comma-separated list of members of the
set {fatal,debug,warn,log,malloc,all,none}.</p>

<p style="margin-top: 1em">-u uid <br>
Set user ID. Sets the real UID of the server process to that
of the given user. It&rsquo;s useful if you aren&rsquo;t
comfortable with having the server run as root, but you need
to <br>
start it as such to bind a privileged port.</p>

<p style="margin-top: 1em">-w working-directory <br>
The server changes to this working directory during before
listening on incoming connections. This option is useful
when the server is operating from the inetd daemon (see <br>
-i).</p>

<p style="margin-top: 1em">-p pidfile <br>
Specifies that the server should write its Process ID to
file given by pidfile. A typical location would be
/var/run/zebrasrv.pid.</p>

<p style="margin-top: 1em">-i <br>
Use this to make the the server run from the inetd server
(UNIX only). Make sure you use the logfile option -l in
conjunction with this mode and specify the -l option before
<br>
any other options.</p>

<p style="margin-top: 1em">-D <br>
Use this to make the server put itself in the background and
run as a daemon. If neither -i nor -D is given, the server
starts in the foreground.</p>

<p style="margin-top: 1em">-install <br>
Use this to install the server as an NT service (Windows
NT/2000/XP only). Control the server by going to the
Services in the Control Panel.</p>

<p style="margin-top: 1em">-installa <br>
Use this to install and activate the server as an NT service
(Windows NT/2000/XP only). Control the server by going to
the Services in the Control Panel.</p>

<p style="margin-top: 1em">-remove <br>
Use this to remove the server from the NT services (Windows
NT/2000/XP only).</p>

<p style="margin-top: 1em">-t minutes <br>
Idle session timeout, in minutes. Default is 60 minutes.</p>

<p style="margin-top: 1em">-k size <br>
Maximum record size/message size, in kilobytes. Default is
1024 KB (1 MB).</p>

<p style="margin-top: 1em">-d daemon <br>
Set name of daemon to be used in hosts access file. See
hosts_access(5) and tcpd(8).</p>

<p style="margin-top: 1em">A listener-address consists of
an optional transport mode followed by a colon (:) followed
by a listener address. The transport mode is either a file
system socket unix, a SSL <br>
TCP/IP socket ssl, or a plain TCP/IP socket tcp
(default).</p>

<p style="margin-top: 1em">For TCP, an address has the
form</p>

<p style="margin-top: 1em">hostname | IP-number [:
portnumber]</p>

<p style="margin-top: 1em">The port number defaults to 210
(standard Z39.50 port) for privileged users (root), and 9999
for normal users. The special hostname &quot;@&quot; is
mapped to the address INADDR_ANY, which <br>
causes the server to listen on any local interface.</p>

<p style="margin-top: 1em">The default behavior for
zebrasrv - if started as non-privileged user - is to
establish a single TCP/IP listener, for the Z39.50 protocol,
on port 9999.</p>

<p style="margin-top: 1em">zebrasrv @ <br>
zebrasrv tcp:some.server.name.org:1234 <br>
zebrasrv ssl:@:3000</p>

<p style="margin-top: 1em">To start the server listening on
the registered port for Z39.50, or on a filesystem socket,
and to drop root privileges once the ports are bound,
execute the server like this <br>
from a root shell:</p>

<p style="margin-top: 1em">zebrasrv -u daemon @ <br>
zebrasrv -u daemon tcp:@:210 <br>
zebrasrv -u daemon unix:/some/file/system/socket</p>

<p style="margin-top: 1em">Here daemon is an existing user
account, and the unix socket /some/file/system/socket is
readable and writable for the daemon account.</p>

<p style="margin-top: 1em">Z39.50 PROTOCOL SUPPORT AND
BEHAVIOR <br>
Z39.50 Initialization <br>
During initialization, the server will negotiate to version
3 of the Z39.50 protocol, and the option bits for Search,
Present, Scan, NamedResultSets, and concurrentOperations
<br>
will be set, if requested by the client. The maximum PDU
size is negotiated down to a maximum of 1 MB by default.</p>

<p style="margin-top: 1em">Z39.50 Search <br>
The supported query type are 1 and 101. All operators are
currently supported with the restriction that only proximity
units of type &quot;word&quot; are supported for the
proximity <br>
operator. Queries can be arbitrarily complex. Named result
sets are supported, and result sets can be used as operands
without limitations. Searches may span multiple
databases.</p>

<p style="margin-top: 1em">The server has full support for
piggy-backed retrieval (see also the following section).</p>

<p style="margin-top: 1em">Z39.50 Present <br>
The present facility is supported in a standard fashion. The
requested record syntax is matched against the ones
supported by the profile of each record retrieved. If no
record <br>
syntax is given, SUTRS is the default. The requested element
set name, again, is matched against any provided by the
relevant record profiles.</p>

<p style="margin-top: 1em">Z39.50 Scan <br>
The attribute combinations provided with the
termListAndStartPoint are processed in the same way as
operands in a query (see above). Currently, only the term
and the <br>
globalOccurrences are returned with the termInfo
structure.</p>

<p style="margin-top: 1em">Z39.50 Sort <br>
Z39.50 specifies three different types of sort criteria. Of
these Zebra supports the attribute specification type in
which case the use attribute specifies the &quot;Sort
register&quot;. <br>
Sort registers are created for those fields that are of type
&quot;sort&quot; in the default.idx file. The corresponding
character mapping file in default.idx specifies the ordinal
of each <br>
character used in the actual sort.</p>

<p style="margin-top: 1em">Z39.50 allows the client to
specify sorting on one or more input result sets and one
output result set. Zebra supports sorting on one result set
only which may or may not be the <br>
same as the output result set.</p>

<p style="margin-top: 1em">Z39.50 Close <br>
If a Close PDU is received, the server will respond with a
Close PDU with reason=FINISHED, no matter which protocol
version was negotiated during initialization. If the
protocol <br>
version is 3 or more, the server will generate a Close PDU
under certain circumstances, including a session timeout (60
minutes by default), and certain kinds of protocol errors.
<br>
Once a Close PDU has been sent, the protocol association is
considered broken, and the transport connection will be
closed immediately upon receipt of further data, or
following <br>
a short timeout.</p>

<p style="margin-top: 1em">Z39.50 Explain <br>
Zebra maintains a &quot;classic&quot; Z39.50 Explain[1]
database on the side. This database is called IR-Explain-1
and can be searched using the attribute set exp-1.</p>

<p style="margin-top: 1em">The records in the explain
database are of type grs.sgml. The root element for the
Explain grs.sgml records is explain, thus explain.abs is
used for indexing.</p>

<p style="margin-top: 1em">Note <br>
Zebra must be able to locate explain.abs in order to index
the Explain records properly. Zebra will work without it but
the information will not be searchable.</p>

<p style="margin-top: 1em">THE SRU SERVER <br>
In addition to Z39.50, Zebra supports the more recent and
web-friendly IR protocol SRU[2]. SRU can be carried over
SOAP or a REST-like protocol that uses HTTP GET or POST to
<br>
request search responses. The request itself is made of
parameters such as query, startRecord, maximumRecords and
recordSchema; the response is an XML document containing
<br>
hit-count, result-set records, diagnostics, etc. SRU can be
thought of as a re-casting of Z39.50 semantics in
web-friendly terms; or as a standardisation of the ad-hoc
query <br>
parameters used by search engines such as Google and
AltaVista; or as a superset of A9&rsquo;s OpenSearch (which
it predates).</p>

<p style="margin-top: 1em">Zebra supports Z39.50, SRUGET,
SRU POST, SRU SOAP (SRW) - on the same port, recognising
what protocol is used by each incoming requests and handling
them accordingly. This is a <br>
achieved through the use of Deep Magic; civilians are warned
not to stand too close.</p>

<p style="margin-top: 1em">Running zebrasrv as an SRU
Server <br>
Because Zebra supports all protocols on one port, it would
seem to follow that the SRU server is run in the same way as
the Z39.50 server, as described above. This is true, but
<br>
only in an uninterestingly vacuous way: a Zebra server run
in this manner will indeed recognise and accept SRU
requests; but since it doesn&rsquo;t know how to handle the
CQL queries <br>
that these protocols use, all it can do is send failure
responses.</p>

<p style="margin-top: 1em">Note <br>
It is possible to cheat, by having SRU search Zebra with a
PQF query instead of CQL, using the x-pquery parameter
instead of query. This is a non-standard extension of CQL,
<br>
and a very naughty thing to do, but it does give you a way
to see Zebra serving SRU &lsquo;&lsquo;right out of the
box&rsquo;&rsquo;. If you start your favourite Zebra server
in the usual way, on <br>
port 9999, then you can send your web browser to:</p>


<p style="margin-top: 1em">http://localhost:9999/Default?version=1.1
<br>
&amp;operation=searchRetrieve <br>
&amp;x-pquery=mineral <br>
&amp;startRecord=1 <br>
&amp;maximumRecords=1</p>

<p style="margin-top: 1em">This will display the
XML-formatted SRU response that includes the first record in
the result-set found by the query mineral. (For clarity, the
SRU URL is shown here broken <br>
across lines, but the lines should be joined together to
make single-line URL for the browser to submit.)</p>

<p style="margin-top: 1em">In order to turn on
Zebra&rsquo;s support for CQL queries, it&rsquo;s necessary
to have the YAZ generic front-end (which Zebra uses)
translate them into the Z39.50 Type-1 query format that <br>
is used internally. And to do this, the generic
front-end&rsquo;s own configuration file must be used. See
the section called &acirc;YAZ SERVER VIRTUAL HOSTS&acirc;;
the salient point for SRU <br>
support is that zebrasrv must be started with the -f
frontendConfigFile option rather than the -c zebraConfigFile
option, and that the front-end configuration file must
include <br>
both a reference to the Zebra configuration file and the
CQL-to-PQF translator configuration file.</p>

<p style="margin-top: 1em">A minimal front-end
configuration file that does this would read as follows:</p>

<p style="margin-top: 1em">&lt;yazgfs&gt; <br>
&lt;server&gt; <br>
&lt;config&gt;zebra.cfg&lt;/config&gt; <br>
&lt;cql2rpn&gt;../../tab/pqf.properties&lt;/cql2rpn&gt; <br>
&lt;/server&gt; <br>
&lt;/yazgfs&gt;</p>

<p style="margin-top: 1em">The &lt;config&gt; element
contains the name of the Zebra configuration file that was
previously specified by the -c command-line argument, and
the &lt;cql2rpn&gt; element contains the name <br>
of the CQL properties file specifying how various CQL
indexes, relations, etc. are translated into Type-1
queries.</p>

<p style="margin-top: 1em">A zebra server running with such
a configuration can then be queried using proper, conformant
SRU URLs with CQL queries:</p>


<p style="margin-top: 1em">http://localhost:9999/Default?version=1.1
<br>
&amp;operation=searchRetrieve <br>
&amp;query=title=utah and description=epicent* <br>
&amp;startRecord=1 <br>
&amp;maximumRecords=1</p>

<p style="margin-top: 1em">SRU PROTOCOL SUPPORT AND
BEHAVIOR <br>
Zebra running as an SRU server supports SRU version 1.1,
including CQL version 1.1. In particular, it provides
support for the following elements of the protocol.</p>

<p style="margin-top: 1em">SRU Search and Retrieval <br>
Zebra supports the searchRetrieve operation.</p>

<p style="margin-top: 1em">One of the great strengths of
SRU is that it mandates a standard query language, CQL, and
that all conforming implementations can therefore be trusted
to correctly interpret the <br>
same queries. It is with some shame, then, that we admit
that Zebra also supports an additional query language, our
own Prefix Query Format (PQF[3]). A PQF query is submitted
by <br>
using the extension parameter x-pquery, in which case the
query parameter must be omitted, which makes the request not
valid SRU. Please feel free to use this facility within <br>
your own applications; but be aware that it is not only
non-standard SRU but not even syntactically valid, since it
omits the mandatory query parameter.</p>

<p style="margin-top: 1em">SRU Scan <br>
Zebra supports scan operation. Scanning using CQL syntax is
the default, where the standard scanClause parameter is
used.</p>

<p style="margin-top: 1em">In addition, a mutant form of
SRU scan is supported, using the non-standard x-pScanClause
parameter in place of the standard scanClause to scan on a
PQF query clause.</p>

<p style="margin-top: 1em">SRU Explain <br>
Zebra supports explain.</p>

<p style="margin-top: 1em">The ZeeRex record explaining a
database may be requested either with a fully fledged SRU
request (with operation=explain and version-number
specified) or with a simple HTTP GET <br>
at the server&rsquo;s basename. The ZeeRex record returned
in response is the one embedded in the YAZ Frontend Server
configuration file that is described in the the section
called <br>
&acirc;YAZ SERVER VIRTUAL HOSTS&acirc;.</p>

<p style="margin-top: 1em">Unfortunately, the data found in
the CQL-to-PQF text file must be added by hand-craft into
the explain section of the YAZ Frontend Server configuration
file to be able to provide <br>
a suitable explain record. Too bad, but this is all extreme
new alpha stuff, and a lot of work has yet to be done ..</p>

<p style="margin-top: 1em">There is no linkage whatsoever
between the Z39.50 explain model and the SRU explain
response (well, at least not implemented in Zebra, that is
..). Zebra does not provide a means <br>
using Z39.50 to obtain the ZeeRex record.</p>

<p style="margin-top: 1em">Other SRU operations <br>
In the Z39.50 protocol, Initialization, Present, Sort and
Close are separate operations. In SRU, however, these
operations do not exist.</p>

<p style="margin-top: 1em">&Acirc;&middot; SRU has no
explicit initialization handshake phase, but commences
immediately with searching, scanning and explain
operations.</p>

<p style="margin-top: 1em">&Acirc;&middot; Neither does SRU
have a close operation, since the protocol is stateless and
each request is self-contained. (It is true that multiple
SRU request/response pairs may be <br>
implemented as multiple HTTP request/response pairs over a
single persistent TCP/IP connection; but the closure of that
connection is not a protocol-level operation.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Retrieval in SRU
is part of the searchRetrieve operation, in which a search
is submitted and the response includes a subset of the
records in the result set. There is no <br>
direct analogue of Z39.50&rsquo;s Present operation which
requests records from an established result set. In SRU,
this is achieved by sending a subsequent searchRetrieve
request <br>
with the query cql.resultSetId=id where id is the identifier
of the previously generated result-set.</p>

<p style="margin-top: 1em">&Acirc;&middot; Sorting in CQL
is done within the searchRetrieve operation - in v1.1, by an
explicit sort parameter, but the forthcoming v1.2 or v2.0
will most likely use an extension of the <br>
query language, CQL sorting[4].</p>

<p style="margin-top: 1em">It can be seen, then, that while
Zebra operating as an SRU server does not provide the same
set of operations as when operating as a Z39.50 server, it
does provide equivalent <br>
functionality.</p>

<p style="margin-top: 1em">SRU EXAMPLES <br>
Surf into http://localhost:9999 to get an explain response,
or use</p>


<p style="margin-top: 1em">http://localhost:9999/?version=1.1&amp;operation=explain</p>

<p style="margin-top: 1em">See number of hits for a
query</p>


<p style="margin-top: 1em">http://localhost:9999/?version=1.1&amp;operation=searchRetrieve
<br>
&amp;query=text=(plant%20and%20soil)</p>

<p style="margin-top: 1em">Fetch record 5-7 in Dublin Core
format</p>


<p style="margin-top: 1em">http://localhost:9999/?version=1.1&amp;operation=searchRetrieve
<br>
&amp;query=text=(plant%20and%20soil) <br>

&amp;startRecord=5&amp;maximumRecords=2&amp;recordSchema=dc</p>

<p style="margin-top: 1em">Even search using PQF queries
using the extended naughty parameterx-pquery</p>


<p style="margin-top: 1em">http://localhost:9999/?version=1.1&amp;operation=searchRetrieve
<br>
&amp;x-pquery=@attr%201=text%20@and%20plant%20soil</p>

<p style="margin-top: 1em">Or scan indexes using the
extended extremely naughty parameterx-pScanClause</p>


<p style="margin-top: 1em">http://localhost:9999/?version=1.1&amp;operation=scan
<br>
&amp;x-pScanClause=@attr%201=text%20something</p>

<p style="margin-top: 1em">Don&rsquo;t do this in
production code! But it&rsquo;s a great fast debugging
aid.</p>

<p style="margin-top: 1em">YAZ SERVER VIRTUAL HOSTS <br>
The Virtual hosts mechanism allows a YAZ frontend server to
support multiple backends. A backend is selected on the
basis of the TCP/IP binding (port+listening address) and/or
<br>
the virtual host.</p>

<p style="margin-top: 1em">A backend can be configured to
execute in a particular working directory. Or the YAZ
frontend may perform CQL[5] to RPN conversion, thus allowing
traditional Z39.50 backends to <br>
be offered as a SRU[2] service. SRU Explain information for
a particular backend may also be specified.</p>

<p style="margin-top: 1em">For the HTTP protocol, the
virtual host is specified in the Host header. For the Z39.50
protocol, the virtual host is specified as in the Initialize
Request in the OtherInfo, OID <br>
1.2.840.10003.10.1000.81.1.</p>

<p style="margin-top: 1em">Note <br>
Not all Z39.50 clients allows the VHOST information to be
set. For those the selection of the backend must rely on the
TCP/IP information alone (port and address).</p>

<p style="margin-top: 1em">The YAZ frontend server uses XML
to describe the backend configurations. Command-line option
-f specifies filename of the XML configuration.</p>

<p style="margin-top: 1em">The configuration uses the root
element yazgfs. This element includes a list of listen
elements, followed by one or more server elements.</p>

<p style="margin-top: 1em">The listen describes listener
(transport end point), such as TCP/IP, Unix file socket or
SSL server. Content for a listener:</p>

<p style="margin-top: 1em">CDATA (required) <br>
The CDATA for the listen element holds the listener string,
such as tcp:@:210, tcp:server1:2100, etc.</p>

<p style="margin-top: 1em">attribute id (optional) <br>
identifier for this listener. This may be referred to from
server sections.</p>

<p style="margin-top: 1em">Note <br>
We expect more information to be added for the listen
section in a future version, such as CERT file for SSL
servers.</p>

<p style="margin-top: 1em">The server describes a server
and the parameters for this server type. Content for a
server:</p>

<p style="margin-top: 1em">attribute id (optional) <br>
Identifier for this server. Currently not used for anything,
but it might be for logging purposes.</p>

<p style="margin-top: 1em">attribute listenref (optional)
<br>
Specifies listener for this server. If this attribute is not
given, the server is accessible from all listener. In order
for the server to be used for real, however, the <br>
virtual host must match (if specified in the
configuration).</p>

<p style="margin-top: 1em">element config (optional) <br>
Specifies the server configuration. This is equivalent to
the config specified using command line option -c.</p>

<p style="margin-top: 1em">element directory (optional)
<br>
Specifies a working directory for this backend server. If
specified, the YAZ frontend changes current working
directory to this directory whenever a backend of this type
is <br>
started (backend handler bend_start), stopped (backend
handler hand_stop) and initialized (bend_init).</p>

<p style="margin-top: 1em">element host (optional) <br>
Specifies the virtual host for this server. If this is
specified a client must specify this host string in order to
use this backend.</p>

<p style="margin-top: 1em">element cql2rpn (optional) <br>
Specifies a filename that includes CQL[5] to RPN conversion
for this backend server. See CQL[5] section in YAZ manual.
If given, the backend server will only &quot;see&quot; a
<br>
Type-1/RPN query.</p>

<p style="margin-top: 1em">element explain (optional) <br>
Specifies SRU[2] ZeeRex content for this server - copied
verbatim to the client. As things are now, some of the
Explain content seems redundant because host information,
etc. <br>
is also stored elsewhere.</p>

<p style="margin-top: 1em">The format of the Explain record
is described in detail, with examples, on the file at the
ZeeRex[6] web-site.</p>

<p style="margin-top: 1em">The XML below configures a
server that accepts connections from two ports, TCP/IP port
9900 and a local UNIX file socket. We name the TCP/IP server
public and the other server <br>
internal.</p>

<p style="margin-top: 1em">&lt;yazgfs&gt; <br>
&lt;listen
id=&quot;public&quot;&gt;tcp:@:9900&lt;/listen&gt; <br>
&lt;listen
id=&quot;internal&quot;&gt;unix:/var/tmp/socket&lt;/listen&gt;
<br>
&lt;server id=&quot;server1&quot;&gt; <br>
&lt;host&gt;server1.mydomain&lt;/host&gt; <br>
&lt;directory&gt;/var/www/s1&lt;/directory&gt; <br>
&lt;config&gt;config.cfg&lt;/config&gt; <br>
&lt;/server&gt; <br>
&lt;server id=&quot;server2&quot;&gt; <br>
&lt;host&gt;server2.mydomain&lt;/host&gt; <br>
&lt;directory&gt;/var/www/s2&lt;/directory&gt; <br>
&lt;config&gt;config.cfg&lt;/config&gt; <br>
&lt;cql2rpn&gt;../etc/pqf.properties&lt;/cql2rpn&gt; <br>
&lt;explain
xmlns=&quot;http://explain.z3950.org/dtd/2.0/&quot;&gt; <br>
&lt;serverInfo&gt; <br>
&lt;host&gt;server2.mydomain&lt;/host&gt; <br>
&lt;port&gt;9900&lt;/port&gt; <br>
&lt;database&gt;a&lt;/database&gt; <br>
&lt;/serverInfo&gt; <br>
&lt;/explain&gt; <br>
&lt;/server&gt; <br>
&lt;server id=&quot;server3&quot;
listenref=&quot;internal&quot;&gt; <br>
&lt;directory&gt;/var/www/s3&lt;/directory&gt; <br>
&lt;config&gt;config.cfg&lt;/config&gt; <br>
&lt;/server&gt; <br>
&lt;/yazgfs&gt;</p>

<p style="margin-top: 1em">There are three configured
backend servers. The first two servers, &quot;server1&quot;
and &quot;server2&quot;, can be reached by both listener
addresses - since no listenref attribute is specified. <br>
In order to distinguish between the two a virtual host has
been specified for each of server in the host elements.</p>

<p style="margin-top: 1em">For &quot;server2&quot; elements
for CQL[5] to RPN conversion is supported and explain
information has been added (a short one here to keep the
example small).</p>

<p style="margin-top: 1em">The third server,
&quot;server3&quot; can only be reached via listener
&quot;internal&quot;.</p>

<p style="margin-top: 1em">SEE ALSO <br>
zebraidx(1)</p>

<p style="margin-top: 1em">NOTES <br>
1. Z39.50 Explain <br>
http://www.loc.gov/z3950/agency/markup/07.html</p>

<p style="margin-top: 1em">2. SRU <br>
http://www.loc.gov/standards/sru/</p>

<p style="margin-top: 1em">3. PQF <br>
http://www.indexdata.com/yaz/doc/tools.html#PQF</p>

<p style="margin-top: 1em">4. CQL sorting <br>
http://zing.z3950.org/cql/sorting.html</p>

<p style="margin-top: 1em">5. CQL <br>
http://www.loc.gov/standards/sru/cql/</p>

<p style="margin-top: 1em">6. ZeeRex <br>
http://explain.z3950.org/</p>

<p style="margin-top: 1em">zebra 2.0.59 10/24/2014
ZEBRASRV(8)</p>
<hr>
</body>
</html>
