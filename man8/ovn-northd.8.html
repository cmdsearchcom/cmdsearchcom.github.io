<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:14:15 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>ovn-northd(8) Open vSwitch Manual ovn-northd(8)</p>

<p style="margin-top: 1em">NAME <br>
ovn-northd - Open Virtual Network central control daemon</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ovn-northd [options]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
ovn-northd is a centralized daemon responsible for
translating the high-level OVN configuration into logical
configuration consumable by daemons such as ovn-controller.
It trans&acirc; <br>
lates the logical network configuration in terms of
conventional network concepts, taken from the OVN Northbound
Database (see ovn-nb(5)), into logical datapath flows in the
OVN <br>
Southbound Database (see ovn-sb(5)) below it.</p>

<p style="margin-top: 1em">CONFIGURATION <br>
ovn-northd requires a connection to the Northbound and
Southbound databases. The defaults are ovnnb_db.sock and
ovnsb_db.sock respectively in the local Open vSwitch&acirc;s
&quot;run&quot; <br>
directory. This may be overridden with the following
commands:</p>

<p style="margin-top: 1em">&Acirc;&middot;
--ovnnb-db=database</p>

<p style="margin-top: 1em">The database containing the OVN
Northbound Database.</p>

<p style="margin-top: 1em">&Acirc;&middot;
--ovnsb-db=database</p>

<p style="margin-top: 1em">The database containing the OVN
Southbound Database.</p>

<p style="margin-top: 1em">The database argument must take
one of the following forms:</p>

<p style="margin-top: 1em">&Acirc;&middot; ssl:ip:port</p>

<p style="margin-top: 1em">The specified SSL port on the
host at the given ip, which must be expressed as an IP
address (not a DNS name) in IPv4 or IPv6 address format. If
ip is an IPv6 <br>
address, then wrap ip with square brackets, e.g.:
ssl:[::1]:6640. The --private-key, --certificate, and
--ca-cert options are mandatory when this form is used.</p>

<p style="margin-top: 1em">&Acirc;&middot; tcp:ip:port</p>

<p style="margin-top: 1em">Connect to the given TCP port on
ip, where ip can be IPv4 or IPv6 address. If ip is an IPv6
address, then wrap ip with square brackets, e.g.:
tcp:[::1]:6640.</p>

<p style="margin-top: 1em">&Acirc;&middot; unix:file</p>

<p style="margin-top: 1em">On POSIX, connect to the Unix
domain server socket named file.</p>

<p style="margin-top: 1em">On Windows, connect to a
localhost TCP port whose value is written in file.</p>

<p style="margin-top: 1em">RUNTIME MANAGEMENT COMMANDS <br>
ovs-appctl can send commands to a running ovn-northd
process. The currently supported commands are described
below.</p>

<p style="margin-top: 1em">exit Causes ovn-northd to
gracefully terminate.</p>

<p style="margin-top: 1em">LOGICAL FLOW TABLE STRUCTURE
<br>
One of the main purposes of ovn-northd is to populate the
Logical_Flow table in the OVN_Southbound database. This
section describes how ovn-northd does this for switch and
router <br>
logical datapaths.</p>

<p style="margin-top: 1em">Logical Switch Datapaths <br>
Ingress Table 0: Admission Control and Ingress Port Security
- L2</p>

<p style="margin-top: 1em">Ingress table 0 contains these
logical flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 100
flows to drop packets with VLAN tags or multicast Ethernet
source addresses.</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 50
flows that implement ingress port security for each enabled
logical port. For logical ports on which port security is
enabled, these match the inport <br>
and the valid eth.src address(es) and advance only those
packets to the next flow table. For logical ports on which
port security is not enabled, these advance all <br>
packets that match the inport.</p>

<p style="margin-top: 1em">There are no flows for disabled
logical ports because the default-drop behavior of logical
flow tables causes packets that ingress from them to be
dropped.</p>

<p style="margin-top: 1em">Ingress Table 1: Ingress Port
Security - IP</p>

<p style="margin-top: 1em">Ingress table 1 contains these
logical flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; For each element
in the port security set having one or more IPv4 or IPv6
addresses (or both),</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 90 flow
to allow IPv4 traffic if it has IPv4 addresses which match
the inport, valid eth.src and valid ip4.src address(es).</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 90 flow
to allow IPv4 DHCP discovery traffic if it has a valid
eth.src. This is necessary since DHCP discovery messages are
sent from the unspeci&acirc; <br>
fied IPv4 address (0.0.0.0) since the IPv4 address has not
yet been assigned.</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 90 flow
to allow IPv6 traffic if it has IPv6 addresses which match
the inport, valid eth.src and valid ip6.src address(es).</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 90 flow
to allow IPv6 DAD (Duplicate Address Detection) traffic if
it has a valid eth.src. This is is necessary since DAD
include requires joining <br>
an multicast group and sending neighbor solicitations for
the newly assigned address. Since no address is yet
assigned, these are sent from the unspecified <br>
IPv6 address (::).</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 80 flow
to drop IP (both IPv4 and IPv6) traffic which match the
inport and valid eth.src.</p>

<p style="margin-top: 1em">&Acirc;&middot; One priority-0
fallback flow that matches all packets and advances to the
next table.</p>

<p style="margin-top: 1em">Ingress Table 2: Ingress Port
Security - Neighbor discovery</p>

<p style="margin-top: 1em">Ingress table 2 contains these
logical flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; For each element
in the port security set,</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 90 flow
to allow ARP traffic which match the inport and valid
eth.src and arp.sha. If the element has one or more IPv4
addresses, then it also <br>
matches the valid arp.spa.</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 90 flow
to allow IPv6 Neighbor Solicitation and Advertisement
traffic which match the inport, valid eth.src and
nd.sll/nd.tll. If the element has <br>
one or more IPv6 addresses, then it also matches the valid
nd.target address(es) for Neighbor Advertisement
traffic.</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority 80 flow
to drop ARP and IPv6 Neighbor Solicitation and Advertisement
traffic which match the inport and valid eth.src.</p>

<p style="margin-top: 1em">&Acirc;&middot; One priority-0
fallback flow that matches all packets and advances to the
next table.</p>

<p style="margin-top: 1em">Ingress Table 3: from-lport
Pre-ACLs</p>

<p style="margin-top: 1em">This table prepares flows for
possible stateful ACL processing in ingress table ACLs. It
contains a priority-0 flow that simply moves traffic to the
next table. If stateful ACLs <br>
are used in the logical datapath, a priority-100 flow is
added that sets a hint (with reg0[0] = 1; next;) for table
Pre-stateful to send IP packets to the connection tracker
<br>
before eventually advancing to ingress table ACLs.</p>

<p style="margin-top: 1em">Ingress Table 4: Pre-LB</p>

<p style="margin-top: 1em">This table prepares flows for
possible stateful load balancing processing in ingress table
LB and Stateful. It contains a priority-0 flow that simply
moves traffic to the next <br>
table. If load balancing rules with virtual IP addresses
(and ports) are configured in OVN_Northbound database for a
logical switch datapath, a priority-100 flow is added for
<br>
each configured virtual IP address VIP with a match ip
&amp;&amp; ip4.dst == VIP <br>
that sets an action reg0[0] = 1; next; to act as a hint for
table Pre-stateful to send IP packets to the connection
tracker for packet de-fragmentation before eventually
advanc&acirc; <br>
ing to ingress table LB.</p>

<p style="margin-top: 1em">Ingress Table 5:
Pre-stateful</p>

<p style="margin-top: 1em">This table prepares flows for
all possible stateful processing in next tables. It contains
a priority-0 flow that simply moves traffic to the next
table. A priority-100 flow <br>
sends the packets to connection tracker based on a hint
provided by the previous tables (with a match for reg0[0] ==
1) by using the ct_next; action.</p>

<p style="margin-top: 1em">Ingress table 6: from-lport
ACLs</p>

<p style="margin-top: 1em">Logical flows in this table
closely reproduce those in the ACL table in the
OVN_Northbound database for the from-lport direction. The
priority values from the ACL table have a <br>
limited range and have 1000 added to them to leave room for
OVN default flows at both higher and lower priorities.</p>

<p style="margin-top: 1em">&Acirc;&middot; allow ACLs
translate into logical flows with the next; action. If there
are any stateful ACLs on this datapath, then allow ACLs
translate to ct_commit; next; (which <br>
acts as a hint for the next tables to commit the connection
to conntrack),</p>

<p style="margin-top: 1em">&Acirc;&middot; allow-related
ACLs translate into logical flows with the
ct_commit(ct_label=0/1); next; actions for new connections
and reg0[1] = 1; next; for existing connections.</p>

<p style="margin-top: 1em">&Acirc;&middot; Other ACLs
translate to drop; for new or untracked connections and
ct_commit(ct_label=1/1); for known connections. Setting
ct_label marks a connection as one that <br>
was previously allowed, but should no longer be allowed due
to a policy change.</p>

<p style="margin-top: 1em">This table also contains a
priority 0 flow with action next;, so that ACLs allow
packets by default. If the logical datapath has a statetful
ACL, the following flows will also be <br>
added:</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-1
flow that sets the hint to commit IP traffic to the
connection tracker (with action reg0[1] = 1; next;). This is
needed for the default allow policy <br>
because, while the initiator&acirc;s direction may not have
any stateful rules, the server&acirc;s may and then its
return traffic would not be known and marked as invalid.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-65535
flow that allows any traffic in the reply direction for a
connection that has been committed to the connection tracker
(i.e., established flows), <br>
as long as the committed flow does not have ct_label.blocked
set. We only handle traffic in the reply direction here
because we want all packets going in the <br>
request direction to still go through the flows that
implement the currently defined policy based on ACLs. If a
connection is no longer allowed by policy, <br>
ct_label.blocked will get set and packets in the reply
direction will no longer be allowed, either.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-65535
flow that allows any traffic that is considered related to a
committed flow in the connection tracker (e.g., an ICMP Port
Unreachable from a non- <br>
listening UDP port), as long as the committed flow does not
have ct_label.blocked set.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-65535
flow that drops all traffic marked by the connection tracker
as invalid.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-65535
flow that drops all trafic in the reply direction with
ct_label.blocked set meaning that the connection should no
longer be allowed due to a policy <br>
change. Packets in the request direction are skipped here to
let a newly created ACL re-allow this connection.</p>

<p style="margin-top: 1em">Ingress Table 7: from-lport QoS
marking</p>

<p style="margin-top: 1em">Logical flows in this table
closely reproduce those in the QoS table in the
OVN_Northbound database for the from-lport direction.</p>

<p style="margin-top: 1em">&Acirc;&middot; For every
qos_rules for every logical switch a flow will be added at
priorities mentioned in the QoS table.</p>

<p style="margin-top: 1em">&Acirc;&middot; One priority-0
fallback flow that matches all packets and advances to the
next table.</p>

<p style="margin-top: 1em">Ingress Table 8: LB</p>

<p style="margin-top: 1em">It contains a priority-0 flow
that simply moves traffic to the next table. For established
connections a priority 100 flow matches on ct.est &amp;&amp;
!ct.rel &amp;&amp; !ct.new &amp;&amp; !ct.inv and <br>
sets an action reg0[2] = 1; next; to act as a hint for table
Stateful to send packets through connection tracker to NAT
the packets. (The packet will automatically get DNATed to
<br>
the same IP address as the first packet in that
connection.)</p>

<p style="margin-top: 1em">Ingress Table 9: Stateful</p>

<p style="margin-top: 1em">&Acirc;&middot; For all the
configured load balancing rules for a switch in
OVN_Northbound database that includes a L4 port PORT of
protocol P and IPv4 address VIP, a priority-120 <br>
flow that matches on ct.new &amp;&amp; ip &amp;&amp; ip4.dst
== VIP &amp;&amp; P &amp;&amp; P.dst == PORT <br>
with an action of ct_lb(args), where args contains comma
separated IPv4 addresses (and optional port numbers) to load
balance to.</p>

<p style="margin-top: 1em">&Acirc;&middot; For all the
configured load balancing rules for a switch in
OVN_Northbound database that includes just an IP address VIP
to match on, a priority-110 flow that <br>
matches on ct.new &amp;&amp; ip &amp;&amp; ip4.dst == VIP
with an action of ct_lb(args), where args contains comma
separated IPv4 addresses.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-100
flow commits packets to connection tracker using ct_commit;
next; action based on a hint provided by the previous tables
(with a match for reg0[1] == <br>
1).</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-100
flow sends the packets to connection tracker using ct_lb; as
the action based on a hint provided by the previous tables
(with a match for reg0[2] == <br>
1).</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
flow that simply moves traffic to the next table.</p>

<p style="margin-top: 1em">Ingress Table 10: ARP/ND
responder</p>

<p style="margin-top: 1em">This table implements ARP/ND
responder in a logical switch for known IPs. The advantage
of the ARP responder flow is to limit ARP broadcasts by
locally responding to ARP requests <br>
without the need to send to other hypervisors. One common
case is when the inport is a logical port associated with a
VIF and the broadcast is responded to on the local
hypervi&acirc; <br>
sor rather than broadcast across the whole network and
responded to by the destination VM. This behavior is proxy
ARP.</p>

<p style="margin-top: 1em">ARP requests arrive from VMs
from a logical switch inport of type default. For this case,
the logical switch proxy ARP rules can be for other VMs or
logical router ports. Logical <br>
switch proxy ARP rules may be programmed both for mac
binding of IP addresses on other logical switch VIF ports
(which are of the default logical switch port type,
representing <br>
connectivity to VMs or containers), and for mac binding of
IP addresses on logical switch router type ports,
representing their logical router port peers. In order to
support <br>
proxy ARP for logical router ports, an IP address must be
configured on the logical switch router type port, with the
same value as the peer logical router port. The configured
<br>
MAC addresses must match as well. When a VM sends an ARP
request for a distributed logical router port and if the
peer router type port of the attached logical switch does
not <br>
have an IP address configured, the ARP request will be
broadcast on the logical switch. One of the copies of the
ARP request will go through the logical switch router type
port <br>
to the logical router datapath, where the logical router ARP
responder will generate a reply. The MAC binding of a
distributed logical router, once learned by an associated
VM, <br>
is used for all that VM&acirc;s communication needing
routing. Hence, the action of a VM re-arping for the mac
binding of the logical router port should be rare.</p>

<p style="margin-top: 1em">Logical switch ARP responder
proxy ARP rules can also be hit when receiving ARP requests
externally on a L2 gateway port. In this case, the
hypervisor acting as an L2 gateway, <br>
responds to the ARP request on behalf of a destination
VM.</p>

<p style="margin-top: 1em">Note that ARP requests received
from localnet or vtep logical inports can either go directly
to VMs, in which case the VM responds or can hit an ARP
responder for a logical <br>
router port if the packet is used to resolve a logical
router port next hop address. In either case, logical switch
ARP responder rules will not be hit. It contains these
logical <br>
flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority-100
flows to skip the ARP responder if inport is of type
localnet or vtep and advances directly to the next table.
ARP requests sent to localnet or vtep <br>
ports can be received by multiple hypervisors. Now, because
the same mac binding rules are downloaded to all
hypervisors, each of the multiple hypervisors will <br>
respond. This will confuse L2 learning on the source of the
ARP requests. ARP requests received on an inport of type
router are not expected to hit any logical <br>
switch ARP responder flows. However, no skip flows are
installed for these packets, as there would be some
additional flow cost for this and the value appears
lim&acirc; <br>
ited.</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority-50
flows that match ARP requests to each known IP address A of
every logical switch port, and respond with ARP replies
directly with corresponding Ethernet <br>
address E:</p>

<p style="margin-top: 1em">eth.dst = eth.src; <br>
eth.src = E; <br>
arp.op = 2; /* ARP reply. */ <br>
arp.tha = arp.sha; <br>
arp.sha = E; <br>
arp.tpa = arp.spa; <br>
arp.spa = A; <br>
outport = inport; <br>
flags.loopback = 1; <br>
output;</p>

<p style="margin-top: 1em">These flows are omitted for
logical ports (other than router ports) that are down.</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority-50
flows that match IPv6 ND neighbor solicitations to each
known IP address A (and A&acirc;s solicited node address) of
every logical switch port, and respond <br>
with neighbor advertisements directly with corresponding
Ethernet address E:</p>

<p style="margin-top: 1em">nd_na { <br>
eth.src = E; <br>
ip6.src = A; <br>
nd.target = A; <br>
nd.tll = E; <br>
outport = inport; <br>
flags.loopback = 1; <br>
output; <br>
};</p>

<p style="margin-top: 1em">These flows are omitted for
logical ports (other than router ports) that are down.</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority-100
flows with match criteria like the ARP and ND flows above,
except that they only match packets from the inport that
owns the IP addresses in question, <br>
with action next;. These flows prevent OVN from replying to,
for example, an ARP request emitted by a VM for its own IP
address. A VM only makes this kind of <br>
request to attempt to detect a duplicate IP address
assignment, so sending a reply will prevent the VM from
accepting the IP address that it owns.</p>

<p style="margin-top: 1em">In place of next;, it would be
reasonable to use drop; for the flows&acirc; actions. If
everything is working as it is configured, then this would
produce equivalent <br>
results, since no host should reply to the request. But
ARPing for one&acirc;s own IP address is intended to detect
situations where the network is not working as config&acirc;
<br>
ured, so dropping the request would frustrate that
intent.</p>

<p style="margin-top: 1em">&Acirc;&middot; One priority-0
fallback flow that matches all packets and advances to the
next table.</p>

<p style="margin-top: 1em">Ingress Table 11: DHCP option
processing</p>

<p style="margin-top: 1em">This table adds the DHCPv4
options to a DHCPv4 packet from the logical ports configured
with IPv4 address(es) and DHCPv4 options, and similarly for
DHCPv6 options.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-100
logical flow is added for these logical ports which matches
the IPv4 packet with udp.src = 68 and udp.dst = 67 and
applies the action put_dhcp_opts <br>
and advances the packet to the next table.</p>

<p style="margin-top: 1em">reg0[3] = put_dhcp_opts(offer_ip
= ip, options...); <br>
next;</p>

<p style="margin-top: 1em">For DHCPDISCOVER and
DHCPREQUEST, this transforms the packet into a DHCP reply,
adds the DHCP offer IP ip and options to the packet, and
stores 1 into reg0[3]. For <br>
other kinds of packets, it just stores 0 into reg0[3].
Either way, it continues to the next table.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-100
logical flow is added for these logical ports which matches
the IPv6 packet with udp.src = 546 and udp.dst = 547 and
applies the action <br>
put_dhcpv6_opts and advances the packet to the next
table.</p>

<p style="margin-top: 1em">reg0[3] =
put_dhcpv6_opts(ia_addr = ip, options...); <br>
next;</p>

<p style="margin-top: 1em">For DHCPv6
Solicit/Request/Confirm packets, this transforms the packet
into a DHCPv6 Advertise/Reply, adds the DHCPv6 offer IP ip
and options to the packet, and <br>
stores 1 into reg0[3]. For other kinds of packets, it just
stores 0 into reg0[3]. Either way, it continues to the next
table.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
flow that matches all packets to advances to table 11.</p>

<p style="margin-top: 1em">Ingress Table 12: DHCP
responses</p>

<p style="margin-top: 1em">This table implements DHCP
responder for the DHCP replies generated by the previous
table.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority 100
logical flow is added for the logical ports configured with
DHCPv4 options which matches IPv4 packets with udp.src == 68
&amp;&amp; udp.dst == 67 &amp;&amp; reg0[3] <br>
== 1 and responds back to the inport after applying these
actions. If reg0[3] is set to 1, it means that the action
put_dhcp_opts was successful.</p>

<p style="margin-top: 1em">eth.dst = eth.src; <br>
eth.src = E; <br>
ip4.dst = A; <br>
ip4.src = S; <br>
udp.src = 67; <br>
udp.dst = 68; <br>
outport = P; <br>
flags.loopback = 1; <br>
output;</p>

<p style="margin-top: 1em">where E is the server MAC
address and S is the server IPv4 address defined in the
DHCPv4 options and A is the IPv4 address defined in the
logical port&acirc;s addresses <br>
column.</p>

<p style="margin-top: 1em">(This terminates ingress packet
processing; the packet does not go to the next ingress
table.)</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority 100
logical flow is added for the logical ports configured with
DHCPv6 options which matches IPv6 packets with udp.src ==
546 &amp;&amp; udp.dst == 547 &amp;&amp; <br>
reg0[3] == 1 and responds back to the inport after applying
these actions. If reg0[3] is set to 1, it means that the
action put_dhcpv6_opts was successful.</p>

<p style="margin-top: 1em">eth.dst = eth.src; <br>
eth.src = E; <br>
ip6.dst = A; <br>
ip6.src = S; <br>
udp.src = 547; <br>
udp.dst = 546; <br>
outport = P; <br>
flags.loopback = 1; <br>
output;</p>

<p style="margin-top: 1em">where E is the server MAC
address and S is the server IPv6 LLA address generated from
the server_id defined in the DHCPv6 options and A is the
IPv6 address defined <br>
in the logical port&acirc;s addresses column.</p>

<p style="margin-top: 1em">(This terminates packet
processing; the packet does not go on the next ingress
table.)</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
flow that matches all packets to advances to table 12.</p>

<p style="margin-top: 1em">Ingress Table 13 Destination
Lookup</p>

<p style="margin-top: 1em">This table implements switching
behavior. It contains these logical flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-100
flow that outputs all packets with an Ethernet broadcast or
multicast eth.dst to the MC_FLOOD multicast group, which
ovn-northd populates with all <br>
enabled logical ports.</p>

<p style="margin-top: 1em">&Acirc;&middot; One priority-50
flow that matches each known Ethernet address against
eth.dst and outputs the packet to the single associated
output port.</p>

<p style="margin-top: 1em">For the Ethernet address on a
logical switch port of type router, when that logical switch
port&acirc;s addresses column is set to router and the
connected logical router <br>
port specifies a redirect-chassis:</p>

<p style="margin-top: 1em">&Acirc;&middot; The flow for the
connected logical router port&acirc;s Ethernet address is
only programmed on the redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the logical
router has rules specified in nat with external_mac, then
those addresses are also used to populate the switch&acirc;s
destination lookup on the <br>
chassis where logical_port is resident.</p>

<p style="margin-top: 1em">&Acirc;&middot; One priority-0
fallback flow that matches all packets and outputs them to
the MC_UNKNOWN multicast group, which ovn-northd populates
with all enabled logical ports <br>
that accept unknown destination packets. As a small
optimization, if no logical ports accept unknown destination
packets, ovn-northd omits this multicast group and <br>
logical flow.</p>

<p style="margin-top: 1em">Egress Table 0: Pre-LB</p>

<p style="margin-top: 1em">This table is similar to ingress
table Pre-LB. It contains a priority-0 flow that simply
moves traffic to the next table. If any load balancing rules
exist for the datapath, a <br>
priority-100 flow is added with a match of ip and action of
reg0[0] = 1; next; to act as a hint for table Pre-stateful
to send IP packets to the connection tracker for packet de-
<br>
fragmentation.</p>

<p style="margin-top: 1em">Egress Table 1: to-lport
Pre-ACLs</p>

<p style="margin-top: 1em">This is similar to ingress table
Pre-ACLs except for to-lport traffic.</p>

<p style="margin-top: 1em">Egress Table 2: Pre-stateful</p>

<p style="margin-top: 1em">This is similar to ingress table
Pre-stateful.</p>

<p style="margin-top: 1em">Egress Table 3: LB</p>

<p style="margin-top: 1em">This is similar to ingress table
LB.</p>

<p style="margin-top: 1em">Egress Table 4: to-lport
ACLs</p>

<p style="margin-top: 1em">This is similar to ingress table
ACLs except for to-lport ACLs.</p>

<p style="margin-top: 1em">Egress Table 5: to-lport QoS
marking</p>

<p style="margin-top: 1em">This is similar to ingress table
QoS marking except for to-lport qos rules.</p>

<p style="margin-top: 1em">Egress Table 6: Stateful</p>

<p style="margin-top: 1em">This is similar to ingress table
Stateful except that there are no rules added for load
balancing new connections.</p>

<p style="margin-top: 1em">Also a priority 34000 logical
flow is added for each logical port which has DHCPv4 options
defined to allow the DHCPv4 reply packet and which has
DHCPv6 options defined to allow <br>
the DHCPv6 reply packet from the Ingress Table 12: DHCP
responses.</p>

<p style="margin-top: 1em">Egress Table 7: Egress Port
Security - IP</p>

<p style="margin-top: 1em">This is similar to the port
security logic in table Ingress Port Security - IP except
that outport, eth.dst, ip4.dst and ip6.dst are checked
instead of inport, eth.src, ip4.src <br>
and ip6.src</p>

<p style="margin-top: 1em">Egress Table 8: Egress Port
Security - L2</p>

<p style="margin-top: 1em">This is similar to the ingress
port security logic in ingress table Admission Control and
Ingress Port Security - L2, but with important differences.
Most obviously, outport and <br>
eth.dst are checked instead of inport and eth.src. Second,
packets directed to broadcast or multicast eth.dst are
always accepted instead of being subject to the port
security <br>
rules; this is implemented through a priority-100 flow that
matches on eth.mcast with action output;. Finally, to ensure
that even broadcast and multicast packets are not
deliv&acirc; <br>
ered to disabled logical ports, a priority-150 flow for each
disabled logical outport overrides the priority-100 flow
with a drop; action.</p>

<p style="margin-top: 1em">Logical Router Datapaths <br>
Logical router datapaths will only exist for Logical_Router
rows in the OVN_Northbound database that do not have enabled
set to false</p>

<p style="margin-top: 1em">Ingress Table 0: L2 Admission
Control</p>

<p style="margin-top: 1em">This table drops packets that
the router shouldn&acirc;t see at all based on their
Ethernet headers. It contains the following flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; Priority-100
flows to drop packets with VLAN tags or multicast Ethernet
source addresses.</p>

<p style="margin-top: 1em">&Acirc;&middot; For each enabled
router port P with Ethernet address E, a priority-50 flow
that matches inport == P &amp;&amp; (eth.mcast || eth.dst ==
E), with action next;.</p>

<p style="margin-top: 1em">For the gateway port on a
distributed logical router (where one of the logical router
ports specifies a redirect-chassis), the above flow matching
eth.dst == E is <br>
only programmed on the gateway port instance on the
redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; For each
dnat_and_snat NAT rule on a distributed router that
specifies an external Ethernet address E, a priority-50 flow
that matches inport == GW &amp;&amp; eth.dst == E, <br>
where GW is the logical router gateway port, with action
next;.</p>

<p style="margin-top: 1em">This flow is only programmed on
the gateway port instance on the chassis where the
logical_port specified in the NAT rule resides.</p>

<p style="margin-top: 1em">Other packets are implicitly
dropped.</p>

<p style="margin-top: 1em">Ingress Table 1: IP Input</p>

<p style="margin-top: 1em">This table is the core of the
logical router datapath functionality. It contains the
following flows to implement very basic IP host
functionality.</p>

<p style="margin-top: 1em">&Acirc;&middot; L3 admission
control: A priority-100 flow drops packets that match any of
the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; ip4.src[28..31]
== 0xe (multicast source)</p>

<p style="margin-top: 1em">&Acirc;&middot; ip4.src ==
255.255.255.255 (broadcast source)</p>

<p style="margin-top: 1em">&Acirc;&middot; ip4.src ==
127.0.0.0/8 || ip4.dst == 127.0.0.0/8 (localhost source or
destination)</p>

<p style="margin-top: 1em">&Acirc;&middot; ip4.src ==
0.0.0.0/8 || ip4.dst == 0.0.0.0/8 (zero network source or
destination)</p>

<p style="margin-top: 1em">&Acirc;&middot; ip4.src or
ip6.src is any IP address owned by the router, unless the
packet was recirculated due to egress loopback as indicated
by REGBIT_EGRESS_LOOPBACK.</p>

<p style="margin-top: 1em">&Acirc;&middot; ip4.src is the
broadcast address of any IP network known to the router.</p>

<p style="margin-top: 1em">&Acirc;&middot; ICMP echo reply.
These flows reply to ICMP echo requests received for the
router&acirc;s IP address. Let A be an IP address owned by a
router port. Then, for each A that <br>
is an IPv4 address, a priority-90 flow matches on ip4.dst ==
A and icmp4.type == 8 &amp;&amp; icmp4.code == 0 (ICMP echo
request). For each A that is an IPv6 address, a <br>
priority-90 flow matches on ip6.dst == A and icmp6.type ==
128 &amp;&amp; icmp6.code == 0 (ICMPv6 echo request). The
port of the router that receives the echo request does <br>
not matter. Also, the ip.ttl of the echo request packet is
not checked, so it complies with RFC 1812, section 4.2.2.9.
Flows for ICMPv4 echo requests use the fol&acirc; <br>
lowing actions:</p>

<p style="margin-top: 1em">ip4.dst &lt;-&gt; ip4.src; <br>
ip.ttl = 255; <br>
icmp4.type = 0; <br>
flags.loopback = 1; <br>
next;</p>

<p style="margin-top: 1em">Flows for ICMPv6 echo requests
use the following actions:</p>

<p style="margin-top: 1em">ip6.dst &lt;-&gt; ip6.src; <br>
ip.ttl = 255; <br>
icmp6.type = 129; <br>
flags.loopback = 1; <br>
next;</p>

<p style="margin-top: 1em">&Acirc;&middot; Reply to ARP
requests.</p>

<p style="margin-top: 1em">These flows reply to ARP
requests for the router&acirc;s own IP address. For each
router port P that owns IP address A and Ethernet address E,
a priority-90 flow matches <br>
inport == P &amp;&amp; arp.op == 1 &amp;&amp; arp.tpa == A
(ARP request) with the following actions:</p>

<p style="margin-top: 1em">eth.dst = eth.src; <br>
eth.src = E; <br>
arp.op = 2; /* ARP reply. */ <br>
arp.tha = arp.sha; <br>
arp.sha = E; <br>
arp.tpa = arp.spa; <br>
arp.spa = A; <br>
outport = P; <br>
flags.loopback = 1; <br>
output;</p>

<p style="margin-top: 1em">For the gateway port on a
distributed logical router (where one of the logical router
ports specifies a redirect-chassis), the above flows are
only programmed on <br>
the gateway port instance on the redirect-chassis. This
behavior avoids generation of multiple ARP responses from
different chassis, and allows upstream MAC learn&acirc; <br>
ing to point to the redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; These flows
reply to ARP requests for the virtual IP addresses
configured in the router for DNAT or load balancing. For a
configured DNAT IP address or a load bal&acirc; <br>
ancer VIP A, for each router port P with Ethernet address E,
a priority-90 flow matches inport == P &amp;&amp; arp.op ==
1 &amp;&amp; arp.tpa == A (ARP request) with the following
<br>
actions:</p>

<p style="margin-top: 1em">eth.dst = eth.src; <br>
eth.src = E; <br>
arp.op = 2; /* ARP reply. */ <br>
arp.tha = arp.sha; <br>
arp.sha = E; <br>
arp.tpa = arp.spa; <br>
arp.spa = A; <br>
outport = P; <br>
flags.loopback = 1; <br>
output;</p>

<p style="margin-top: 1em">For the gateway port on a
distributed logical router with NAT (where one of the
logical router ports specifies a redirect-chassis):</p>

<p style="margin-top: 1em">&Acirc;&middot; If the
corresponding NAT rule cannot be handled in a distributed
manner, then this flow is only programmed on the gateway
port instance on the redirect-chas&acirc; <br>
sis. This behavior avoids generation of multiple ARP
responses from different chassis, and allows upstream MAC
learning to point to the redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the
corresponding NAT rule can be handled in a distributed
manner, then this flow is only programmed on the gateway
port instance where the logical_port <br>
specified in the NAT rule resides.</p>

<p style="margin-top: 1em">Some of the actions are
different for this case, using the external_mac specified in
the NAT rule rather than the gateway port&acirc;s Ethernet
address E:</p>

<p style="margin-top: 1em">eth.src = external_mac; <br>
arp.sha = external_mac;</p>

<p style="margin-top: 1em">This behavior avoids generation
of multiple ARP responses from different chassis, and allows
upstream MAC learning to point to the correct chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; ARP reply
handling. This flow uses ARP replies to populate the logical
router&acirc;s ARP table. A priority-90 flow with match
arp.op == 2 has actions put_arp(inport, <br>
arp.spa, arp.sha);.</p>

<p style="margin-top: 1em">&Acirc;&middot; Reply to IPv6
Neighbor Solicitations. These flows reply to Neighbor
Solicitation requests for the router&acirc;s own IPv6
address and populate the logical router&acirc;s mac <br>
binding table. For each router port P that owns IPv6 address
A, solicited node address S, and Ethernet address E, a
priority-90 flow matches inport == P &amp;&amp; nd_ns
&amp;&amp; <br>
ip6.dst == {A, E} &amp;&amp; nd.target == A with the
following actions:</p>

<p style="margin-top: 1em">put_nd(inport, ip6.src, nd.sll);
<br>
nd_na { <br>
eth.src = E; <br>
ip6.src = A; <br>
nd.target = A; <br>
nd.tll = E; <br>
outport = inport; <br>
flags.loopback = 1; <br>
output; <br>
};</p>

<p style="margin-top: 1em">For the gateway port on a
distributed logical router (where one of the logical router
ports specifies a redirect-chassis), the above flows
replying to IPv6 Neighbor <br>
Solicitations are only programmed on the gateway port
instance on the redirect-chassis. This behavior avoids
generation of multiple replies from different chassis, <br>
and allows upstream MAC learning to point to the
redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; IPv6 neighbor
advertisement handling. This flow uses neighbor
advertisements to populate the logical router&acirc;s mac
binding table. A priority-90 flow with match nd_na <br>
has actions put_nd(inport, nd.target, nd.tll);.</p>

<p style="margin-top: 1em">&Acirc;&middot; IPv6 neighbor
solicitation for non-hosted addresses handling. This flow
uses neighbor solicitations to populate the logical
router&acirc;s mac binding table (ones that <br>
were directed at the logical router would have matched the
priority-90 neighbor solicitation flow already). A
priority-80 flow with match nd_ns has actions <br>
put_nd(inport, ip6.src, nd.sll);.</p>

<p style="margin-top: 1em">&Acirc;&middot; UDP port
unreachable. Priority-80 flows generate ICMP port
unreachable messages in reply to UDP datagrams directed to
the router&acirc;s IP address. The logical router <br>
doesn&acirc;t accept any UDP traffic so it always generates
such a reply.</p>

<p style="margin-top: 1em">These flows should not match IP
fragments with nonzero offset.</p>

<p style="margin-top: 1em">Details TBD. Not yet
implemented.</p>

<p style="margin-top: 1em">&Acirc;&middot; TCP reset.
Priority-80 flows generate TCP reset messages in reply to
TCP datagrams directed to the router&acirc;s IP address. The
logical router doesn&acirc;t accept any TCP <br>
traffic so it always generates such a reply.</p>

<p style="margin-top: 1em">These flows should not match IP
fragments with nonzero offset.</p>

<p style="margin-top: 1em">Details TBD. Not yet
implemented.</p>

<p style="margin-top: 1em">&Acirc;&middot; Protocol
unreachable. Priority-70 flows generate ICMP protocol
unreachable messages in reply to packets directed to the
router&acirc;s IP address on IP protocols other <br>
than UDP, TCP, and ICMP.</p>

<p style="margin-top: 1em">These flows should not match IP
fragments with nonzero offset.</p>

<p style="margin-top: 1em">Details TBD. Not yet
implemented.</p>

<p style="margin-top: 1em">&Acirc;&middot; Drop other IP
traffic to this router. These flows drop any other traffic
destined to an IP address of this router that is not already
handled by one of the flows <br>
above, which amounts to ICMP (other than echo requests) and
fragments with nonzero offsets. For each IP address A owned
by the router, a priority-60 flow matches <br>
ip4.dst == A and drops the traffic. An exception is made and
the above flow is not added if the router port&acirc;s own
IP address is used to SNAT packets passing through <br>
that router.</p>

<p style="margin-top: 1em">The flows above handle all of
the traffic that might be directed to the router itself. The
following flows (with lower priorities) handle the remaining
traffic, potentially for <br>
forwarding:</p>

<p style="margin-top: 1em">&Acirc;&middot; Drop Ethernet
local broadcast. A priority-50 flow with match eth.bcast
drops traffic destined to the local Ethernet broadcast
address. By definition this traffic <br>
should not be forwarded.</p>

<p style="margin-top: 1em">&Acirc;&middot; ICMP time
exceeded. For each router port P, whose IP address is A, a
priority-40 flow with match inport == P &amp;&amp; ip.ttl ==
{0, 1} &amp;&amp; !ip.later_frag matches packets <br>
whose TTL has expired, with the following actions to send an
ICMP time exceeded reply:</p>

<p style="margin-top: 1em">icmp4 { <br>
icmp4.type = 11; /* Time exceeded. */ <br>
icmp4.code = 0; /* TTL exceeded in transit. */ <br>
ip4.dst = ip4.src; <br>
ip4.src = A; <br>
ip.ttl = 255; <br>
next; <br>
};</p>

<p style="margin-top: 1em">Not yet implemented.</p>

<p style="margin-top: 1em">&Acirc;&middot; TTL discard. A
priority-30 flow with match ip.ttl == {0, 1} and actions
drop; drops other packets whose TTL has expired, that should
not receive a ICMP error reply <br>
(i.e. fragments with nonzero offset).</p>

<p style="margin-top: 1em">&Acirc;&middot; Next table. A
priority-0 flows match all packets that aren&acirc;t already
handled and uses actions next; to feed them to the next
table.</p>

<p style="margin-top: 1em">Ingress Table 2: DEFRAG</p>

<p style="margin-top: 1em">This is to send packets to
connection tracker for tracking and defragmentation. It
contains a priority-0 flow that simply moves traffic to the
next table. If load balancing rules <br>
with virtual IP addresses (and ports) are configured in
OVN_Northbound database for a Gateway router, a priority-100
flow is added for each configured virtual IP address VIP
with <br>
a match ip &amp;&amp; ip4.dst == VIP that sets an action
ct_next; to send IP packets to the connection tracker for
packet de-fragmentation and tracking before sending it to
the next ta&acirc; <br>
ble.</p>

<p style="margin-top: 1em">Ingress Table 3: UNSNAT</p>

<p style="margin-top: 1em">This is for already established
connections&acirc; reverse traffic. i.e., SNAT has already
been done in egress pipeline and now the packet has entered
the ingress pipeline as part of a <br>
reply. It is unSNATted here.</p>

<p style="margin-top: 1em">Ingress Table 3: UNSNAT on
Gateway Routers</p>

<p style="margin-top: 1em">&Acirc;&middot; If the Gateway
router has been configured to force SNAT any previously
DNATted packets to B, a priority-110 flow matches ip
&amp;&amp; ip4.dst == B with an action ct_snat; <br>
next;.</p>

<p style="margin-top: 1em">If the Gateway router has been
configured to force SNAT any previously load-balanced
packets to B, a priority-100 flow matches ip &amp;&amp;
ip4.dst == B with an action <br>
ct_snat; next;.</p>

<p style="margin-top: 1em">For each NAT configuration in
the OVN Northbound database, that asks to change the source
IP address of a packet from A to B, a priority-90 flow
matches ip &amp;&amp; <br>
ip4.dst == B with an action ct_snat; next;.</p>

<p style="margin-top: 1em">A priority-0 logical flow with
match 1 has actions next;.</p>

<p style="margin-top: 1em">Ingress Table 3: UNSNAT on
Distributed Routers</p>

<p style="margin-top: 1em">&Acirc;&middot; For each
configuration in the OVN Northbound database, that asks to
change the source IP address of a packet from A to B, a
priority-100 flow matches ip &amp;&amp; ip4.dst <br>
== B &amp;&amp; inport == GW, where GW is the logical router
gateway port, with an action ct_snat; next;.</p>

<p style="margin-top: 1em">If the NAT rule cannot be
handled in a distributed manner, then the priority-100 flow
above is only programmed on the redirect-chassis.</p>

<p style="margin-top: 1em">For each configuration in the
OVN Northbound database, that asks to change the source IP
address of a packet from A to B, a priority-50 flow matches
ip &amp;&amp; ip4.dst <br>
== B with an action REGBIT_NAT_REDIRECT = 1; next;. This
flow is for east/west traffic to a NAT destination IPv4
address. By setting the REGBIT_NAT_REDIRECT flag, <br>
in the ingress table Gateway Redirect this will trigger a
redirect to the instance of the gateway port on the
redirect-chassis.</p>

<p style="margin-top: 1em">A priority-0 logical flow with
match 1 has actions next;.</p>

<p style="margin-top: 1em">Ingress Table 4: DNAT</p>

<p style="margin-top: 1em">Packets enter the pipeline with
destination IP address that needs to be DNATted from a
virtual IP address to a real IP address. Packets in the
reverse direction needs to be unD&acirc; <br>
NATed.</p>

<p style="margin-top: 1em">Ingress Table 4: DNAT on Gateway
Routers</p>

<p style="margin-top: 1em">&Acirc;&middot; For all the
configured load balancing rules for Gateway router in
OVN_Northbound database that includes a L4 port PORT of
protocol P and IPv4 address VIP, a prior&acirc; <br>
ity-120 flow that matches on ct.new &amp;&amp; ip &amp;&amp;
ip4.dst == VIP &amp;&amp; P &amp;&amp; P.dst == PORT <br>
with an action of ct_lb(args), where args contains comma
separated IPv4 addresses (and optional port numbers) to load
balance to. If the Gateway router is config&acirc; <br>
ured to force SNAT any load-balanced packets, the above
action will be replaced by flags.force_snat_for_lb = 1;
ct_lb(args);.</p>

<p style="margin-top: 1em">&Acirc;&middot; For all the
configured load balancing rules for Gateway router in
OVN_Northbound database that includes a L4 port PORT of
protocol P and IPv4 address VIP, a prior&acirc; <br>
ity-120 flow that matches on ct.est &amp;&amp; ip &amp;&amp;
ip4.dst == VIP &amp;&amp; P &amp;&amp; P.dst == PORT <br>
with an action of ct_dnat;. If the Gateway router is
configured to force SNAT any load-balanced packets, the
above action will be replaced by <br>
flags.force_snat_for_lb = 1; ct_dnat;.</p>

<p style="margin-top: 1em">&Acirc;&middot; For all the
configured load balancing rules for Gateway router in
OVN_Northbound database that includes just an IP address VIP
to match on, a priority-110 flow that <br>
matches on ct.new &amp;&amp; ip &amp;&amp; ip4.dst == VIP
with an action of ct_lb(args), where args contains comma
separated IPv4 addresses. If the Gateway router is
configured to <br>
force SNAT any load-balanced packets, the above action will
be replaced by flags.force_snat_for_lb = 1;
ct_lb(args);.</p>

<p style="margin-top: 1em">&Acirc;&middot; For all the
configured load balancing rules for Gateway router in
OVN_Northbound database that includes just an IP address VIP
to match on, a priority-110 flow that <br>
matches on ct.est &amp;&amp; ip &amp;&amp; ip4.dst == VIP
with an action of ct_dnat;. If the Gateway router is
configured to force SNAT any load-balanced packets, the
above action <br>
will be replaced by flags.force_snat_for_lb = 1;
ct_dnat;.</p>

<p style="margin-top: 1em">&Acirc;&middot; For each
configuration in the OVN Northbound database, that asks to
change the destination IP address of a packet from A to B, a
priority-100 flow matches ip &amp;&amp; <br>
ip4.dst == A with an action flags.loopback = 1; ct_dnat(B);.
If the Gateway router is configured to force SNAT any DNATed
packet, the above action will be replaced <br>
by flags.force_snat_for_dnat = 1; flags.loopback = 1;
ct_dnat(B);.</p>

<p style="margin-top: 1em">&Acirc;&middot; For all IP
packets of a Gateway router, a priority-50 flow with an
action flags.loopback = 1; ct_dnat;.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
logical flow with match 1 has actions next;.</p>

<p style="margin-top: 1em">Ingress Table 4: DNAT on
Distributed Routers</p>

<p style="margin-top: 1em">On distributed routers, the DNAT
table only handles packets with destination IP address that
needs to be DNATted from a virtual IP address to a real IP
address. The unDNAT pro&acirc; <br>
cessing in the reverse direction is handled in a separate
table in the egress pipeline.</p>

<p style="margin-top: 1em">&Acirc;&middot; For each
configuration in the OVN Northbound database, that asks to
change the destination IP address of a packet from A to B, a
priority-100 flow matches ip &amp;&amp; <br>
ip4.dst == B &amp;&amp; inport == GW, where GW is the
logical router gateway port, with an action ct_dnat(B);.</p>

<p style="margin-top: 1em">If the NAT rule cannot be
handled in a distributed manner, then the priority-100 flow
above is only programmed on the redirect-chassis.</p>

<p style="margin-top: 1em">For each configuration in the
OVN Northbound database, that asks to change the destination
IP address of a packet from A to B, a priority-50 flow
matches ip &amp;&amp; <br>
ip4.dst == B with an action REGBIT_NAT_REDIRECT = 1; next;.
This flow is for east/west traffic to a NAT destination IPv4
address. By setting the REGBIT_NAT_REDIRECT <br>
flag, in the ingress table Gateway Redirect this will
trigger a redirect to the instance of the gateway port on
the redirect-chassis.</p>

<p style="margin-top: 1em">A priority-0 logical flow with
match 1 has actions next;.</p>

<p style="margin-top: 1em">Ingress Table 5: IP Routing</p>

<p style="margin-top: 1em">A packet that arrives at this
table is an IP packet that should be routed to the address
in ip4.dst or ip6.dst. This table implements IP routing,
setting reg0 (or xxreg0 for <br>
IPv6) to the next-hop IP address (leaving ip4.dst or
ip6.dst, the packet&acirc;s final destination, unchanged)
and advances to the next table for ARP resolution. It also
sets reg1 (or <br>
xxreg1) to the IP address owned by the selected router port
(ingress table ARP Request will generate an ARP request, if
needed, with reg0 as the target protocol address and reg1
<br>
as the source protocol address).</p>

<p style="margin-top: 1em">This table contains the
following logical flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; For distributed
logical routers where one of the logical router ports
specifies a redirect-chassis, a priority-300 logical flow
with match REGBIT_NAT_REDIRECT == 1 <br>
has actions ip.ttl--; next;. The outport will be set later
in the Gateway Redirect table.</p>

<p style="margin-top: 1em">&Acirc;&middot; IPv4 routing
table. For each route to IPv4 network N with netmask M, on
router port P with IP address A and Ethernet address E, a
logical flow with match ip4.dst == <br>
N/M, whose priority is the number of 1-bits in M, has the
following actions:</p>

<p style="margin-top: 1em">ip.ttl--; <br>
reg0 = G; <br>
reg1 = A; <br>
eth.src = E; <br>
outport = P; <br>
flags.loopback = 1; <br>
next;</p>

<p style="margin-top: 1em">(Ingress table 1 already
verified that ip.ttl--; will not yield a TTL exceeded
error.)</p>

<p style="margin-top: 1em">If the route has a gateway, G is
the gateway IP address. Instead, if the route is from a
configured static route, G is the next hop IP address. Else
it is ip4.dst.</p>

<p style="margin-top: 1em">&Acirc;&middot; IPv6 routing
table. For each route to IPv6 network N with netmask M, on
router port P with IP address A and Ethernet address E, a
logical flow with match in CIDR <br>
notation ip6.dst == N/M, whose priority is the integer value
of M, has the following actions:</p>

<p style="margin-top: 1em">ip.ttl--; <br>
xxreg0 = G; <br>
xxreg1 = A; <br>
eth.src = E; <br>
outport = P; <br>
flags.loopback = 1; <br>
next;</p>

<p style="margin-top: 1em">(Ingress table 1 already
verified that ip.ttl--; will not yield a TTL exceeded
error.)</p>

<p style="margin-top: 1em">If the route has a gateway, G is
the gateway IP address. Instead, if the route is from a
configured static route, G is the next hop IP address. Else
it is ip6.dst.</p>

<p style="margin-top: 1em">If the address A is in the
link-local scope, the route will be limited to sending on
the ingress port.</p>

<p style="margin-top: 1em">Ingress Table 6: ARP/ND
Resolution</p>

<p style="margin-top: 1em">Any packet that reaches this
table is an IP packet whose next-hop IPv4 address is in reg0
or IPv6 address is in xxreg0. (ip4.dst or ip6.dst contains
the final destination.) This <br>
table resolves the IP address in reg0 (or xxreg0) into an
output port in outport and an Ethernet address in eth.dst,
using the following flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; For distributed
logical routers where one of the logical router ports
specifies a redirect-chassis, a priority-200 logical flow
with match REGBIT_NAT_REDIRECT == 1 <br>
has actions eth.dst = E; next;, where E is the ethernet
address of the router&acirc;s distributed gateway port.</p>

<p style="margin-top: 1em">&Acirc;&middot; Static MAC
bindings. MAC bindings can be known statically based on data
in the OVN_Northbound database. For router ports connected
to logical switches, MAC bindings <br>
can be known statically from the addresses column in the
Logical_Switch_Port table. For router ports connected to
other logical routers, MAC bindings can be known <br>
statically from the mac and networks column in the
Logical_Router_Port table.</p>

<p style="margin-top: 1em">For each IPv4 address A whose
host is known to have Ethernet address E on router port P, a
priority-100 flow with match outport === P &amp;&amp; reg0
== A has actions <br>
eth.dst = E; next;.</p>

<p style="margin-top: 1em">For each IPv6 address A whose
host is known to have Ethernet address E on router port P, a
priority-100 flow with match outport === P &amp;&amp; xxreg0
== A has actions <br>
eth.dst = E; next;.</p>

<p style="margin-top: 1em">For each logical router port
with an IPv4 address A and a mac address of E that is
reachable via a different logical router port P, a
priority-100 flow with match <br>
outport === P &amp;&amp; reg0 == A has actions eth.dst = E;
next;.</p>

<p style="margin-top: 1em">For each logical router port
with an IPv6 address A and a mac address of E that is
reachable via a different logical router port P, a
priority-100 flow with match <br>
outport === P &amp;&amp; xxreg0 == A has actions eth.dst =
E; next;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Dynamic MAC
bindings. These flows resolve MAC-to-IP bindings that have
become known dynamically through ARP or neighbor discovery.
(The ingress table ARP Request <br>
will issue an ARP or neighbor solicitation request for cases
where the binding is not yet known.)</p>

<p style="margin-top: 1em">A priority-0 logical flow with
match ip4 has actions get_arp(outport, reg0); next;.</p>

<p style="margin-top: 1em">A priority-0 logical flow with
match ip6 has actions get_nd(outport, xxreg0); next;.</p>

<p style="margin-top: 1em">Ingress Table 7: Gateway
Redirect</p>

<p style="margin-top: 1em">For distributed logical routers
where one of the logical router ports specifies a
redirect-chassis, this table redirects certain packets to
the distributed gateway port instance <br>
on the redirect-chassis. This table has the following
flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-200
logical flow with match REGBIT_NAT_REDIRECT == 1 has actions
outport = CR; next;, where CR is the chassisredirect port
representing the instance of <br>
the logical router distributed gateway port on the
redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-150
logical flow with match outport == GW &amp;&amp; eth.dst ==
00:00:00:00:00:00 has actions outport = CR; next;, where GW
is the logical router distributed <br>
gateway port and CR is the chassisredirect port representing
the instance of the logical router distributed gateway port
on the redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; For each NAT
rule in the OVN Northbound database that can be handled in a
distributed manner, a priority-100 logical flow with match
ip4.src == B &amp;&amp; outport == GW, <br>
where GW is the logical router distributed gateway port,
with actions next;.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-50
logical flow with match outport == GW has actions outport =
CR; next;, where GW is the logical router distributed
gateway port and CR is the chas&acirc; <br>
sisredirect port representing the instance of the logical
router distributed gateway port on the redirect-chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
logical flow with match 1 has actions next;.</p>

<p style="margin-top: 1em">Ingress Table 8: ARP Request</p>

<p style="margin-top: 1em">In the common case where the
Ethernet destination has been resolved, this table outputs
the packet. Otherwise, it composes and sends an ARP request.
It holds the following flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; Unknown MAC
address. A priority-100 flow with match eth.dst ==
00:00:00:00:00:00 has the following actions:</p>

<p style="margin-top: 1em">arp { <br>
eth.dst = ff:ff:ff:ff:ff:ff; <br>
arp.spa = reg1; <br>
arp.tpa = reg0; <br>
arp.op = 1; /* ARP request. */ <br>
output; <br>
};</p>

<p style="margin-top: 1em">(Ingress table IP Routing
initialized reg1 with the IP address owned by outport and
reg0 with the next-hop IP address)</p>

<p style="margin-top: 1em">The IP packet that triggers the
ARP request is dropped.</p>

<p style="margin-top: 1em">&Acirc;&middot; Known MAC
address. A priority-0 flow with match 1 has actions
output;.</p>

<p style="margin-top: 1em">Egress Table 0: UNDNAT</p>

<p style="margin-top: 1em">This is for already established
connections&acirc; reverse traffic. i.e., DNAT has already
been done in ingress pipeline and now the packet has entered
the egress pipeline as part of a <br>
reply. For NAT on a distributed router, it is unDNATted
here. For Gateway routers, the unDNAT processing is carried
out in the ingress DNAT table.</p>

<p style="margin-top: 1em">&Acirc;&middot; For each
configuration in the OVN Northbound database that asks to
change the destination IP address of a packet from an IP
address of A to B, a priority-100 flow <br>
matches ip &amp;&amp; ip4.src == B &amp;&amp; outport == GW,
where GW is the logical router gateway port, with an action
ct_dnat;.</p>

<p style="margin-top: 1em">If the NAT rule cannot be
handled in a distributed manner, then the priority-100 flow
above is only programmed on the redirect-chassis.</p>

<p style="margin-top: 1em">If the NAT rule can be handled
in a distributed manner, then there is an additional action
eth.src = EA;, where EA is the ethernet address associated
with the IP <br>
address A in the NAT rule. This allows upstream MAC learning
to point to the correct chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
logical flow with match 1 has actions next;.</p>

<p style="margin-top: 1em">Egress Table 1: SNAT</p>

<p style="margin-top: 1em">Packets that are configured to
be SNATed get their source IP address changed based on the
configuration in the OVN Northbound database.</p>

<p style="margin-top: 1em">Egress Table 1: SNAT on Gateway
Routers</p>

<p style="margin-top: 1em">&Acirc;&middot; If the Gateway
router in the OVN Northbound database has been configured to
force SNAT a packet (that has been previously DNATted) to B,
a priority-100 flow matches <br>
flags.force_snat_for_dnat == 1 &amp;&amp; ip with an action
ct_snat(B);.</p>

<p style="margin-top: 1em">If the Gateway router in the OVN
Northbound database has been configured to force SNAT a
packet (that has been previously load-balanced) to B, a
priority-100 flow <br>
matches flags.force_snat_for_lb == 1 &amp;&amp; ip with an
action ct_snat(B);.</p>

<p style="margin-top: 1em">For each configuration in the
OVN Northbound database, that asks to change the source IP
address of a packet from an IP address of A or to change the
source IP <br>
address of a packet that belongs to network A to B, a flow
matches ip &amp;&amp; ip4.src == A with an action
ct_snat(B);. The priority of the flow is calculated based on
<br>
the mask of A, with matches having larger masks getting
higher priorities.</p>

<p style="margin-top: 1em">A priority-0 logical flow with
match 1 has actions next;.</p>

<p style="margin-top: 1em">Egress Table 1: SNAT on
Distributed Routers</p>

<p style="margin-top: 1em">&Acirc;&middot; For each
configuration in the OVN Northbound database, that asks to
change the source IP address of a packet from an IP address
of A or to change the source IP <br>
address of a packet that belongs to network A to B, a flow
matches ip &amp;&amp; ip4.src == A &amp;&amp; outport == GW,
where GW is the logical router gateway port, with an action
<br>
ct_snat(B);. The priority of the flow is calculated based on
the mask of A, with matches having larger masks getting
higher priorities.</p>

<p style="margin-top: 1em">If the NAT rule cannot be
handled in a distributed manner, then the flow above is only
programmed on the redirect-chassis.</p>

<p style="margin-top: 1em">If the NAT rule can be handled
in a distributed manner, then there is an additional action
eth.src = EA;, where EA is the ethernet address associated
with the IP <br>
address A in the NAT rule. This allows upstream MAC learning
to point to the correct chassis.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
logical flow with match 1 has actions next;.</p>

<p style="margin-top: 1em">Egress Table 2: Egress
Loopback</p>

<p style="margin-top: 1em">For distributed logical routers
where one of the logical router ports specifies a
redirect-chassis.</p>

<p style="margin-top: 1em">Earlier in the ingress pipeline,
some east-west traffic was redirected to the chassisredirect
port, based on flows in the UNSNAT and DNAT ingress tables
setting the REG&acirc; <br>
BIT_NAT_REDIRECT flag, which then triggered a match to a
flow in the Gateway Redirect ingress table. The intention
was not to actually send traffic out the distributed gateway
<br>
port instance on the redirect-chassis. This traffic was sent
to the distributed gateway port instance in order for DNAT
and/or SNAT processing to be applied.</p>

<p style="margin-top: 1em">While UNDNAT and SNAT processing
have already occurred by this point, this traffic needs to
be forced through egress loopback on this distributed
gateway port instance, in order <br>
for UNSNAT and DNAT processing to be applied, and also for
IP routing and ARP resolution after all of the NAT
processing, so that the packet can be forwarded to the
destination.</p>

<p style="margin-top: 1em">This table has the following
flows:</p>

<p style="margin-top: 1em">&Acirc;&middot; For each NAT
rule in the OVN Northbound database on a distributed router,
a priority-100 logical flow with match ip4.dst == E
&amp;&amp; outport == GW, where E is the <br>
external IP address specified in the NAT rule, and GW is the
logical router distributed gateway port, with the following
actions:</p>

<p style="margin-top: 1em">clone { <br>
ct_clear; <br>
inport = outport; <br>
outport = &quot;&quot;; <br>
flags = 0; <br>
flags.loopback = 1; <br>
reg0 = 0; <br>
reg1 = 0; <br>
... <br>
reg9 = 0; <br>
REGBIT_EGRESS_LOOPBACK = 1; <br>
next(pipeline=ingress, table=0); <br>
};</p>

<p style="margin-top: 1em">flags.loopback is set since
in_port is unchanged and the packet may return back to that
port after NAT processing. REGBIT_EGRESS_LOOPBACK is set to
indicate that <br>
egress loopback has occurred, in order to skip the source IP
address check against the router address.</p>

<p style="margin-top: 1em">&Acirc;&middot; A priority-0
logical flow with match 1 has actions next;.</p>

<p style="margin-top: 1em">Egress Table 3: Delivery</p>

<p style="margin-top: 1em">Packets that reach this table
are ready for delivery. It contains priority-100 logical
flows that match packets on each enabled logical router
port, with action output;.</p>

<p style="margin-top: 1em">Open vSwitch 2.7.0 ovn-northd
ovn-northd(8)</p>
<hr>
</body>
</html>
