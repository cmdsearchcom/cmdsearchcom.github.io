<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>ovn-northd(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ovn-northd(8)</td>
    <td class="head-vol">Open vSwitch Manual</td>
    <td class="head-rtitle">ovn-northd(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
ovn-northd - Open Virtual Network central control daemon
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>ovn-northd</b> [<i>options</i>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>ovn-northd</b> is a centralized daemon responsible for translating the
  high-level OVN configuration into logical configuration consumable by daemons
  such as <b>ovn-controller</b> It translates the logical network configuration
  in terms of conventional network concepts, taken from the OVN Northbound
  Database (see <b>ovn-nb</b>(5)), into logical datapath flows in the OVN
  Southbound Database (see <b>ovn-sb</b>(5)) below it
<h1 class="Sh" title="Sh" id="CONFIGURATION"><a class="selflink" href="#CONFIGURATION">CONFIGURATION</a></h1>
<b>ovn-northd</b> requires a connection to the Northbound and Southbound
  databases The defaults are <b>ovnnb_dbsock</b> and <b>ovnsb_dbsock</b>
  respectively in the local Open vSwitch&#x2019;s &quot;run&quot; directory This
  may be overridden with the following commands:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>--ovnnb-db=</b><i>database</i><b></b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The database containing the OVN Northbound Database</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>--ovnsb-db=</b><i>database</i><b></b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The database containing the OVN Southbound Database</dd>
</dl>
</div>
<div class="Pp"></div>
The <i>database</i> argument must take one of the following forms:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>ssl:</b><i>ip</i><b>:</b><i>port</i><b></b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The specified SSL <i>port</i> on the host at the given
      <i>ip</i>, which must be expressed as an IP address (not a DNS name) in
      IPv4 or IPv6 address format If <i>ip</i> is an IPv6 address, then wrap
      <i>ip</i> with square brackets, eg: <b>ssl:[::1]:6640</b> The
      <b>--private-key</b>, <b>--certificate</b>, and <b>--ca-cert</b> options
      are mandatory when this form is used</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>tcp:</b><i>ip</i><b>:</b><i>port</i><b></b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Connect to the given TCP <i>port</i> on <i>ip</i>, where
      <i>ip</i> can be IPv4 or IPv6 address If <i>ip</i> is an IPv6 address,
      then wrap <i>ip</i> with square brackets, eg: <b>tcp:[::1]:6640</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>unix:</b><i>file</i><b></b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">On POSIX, connect to the Unix domain server socket named
      <i>file</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">On Windows, connect to a localhost TCP port whose value is
      written in <i>file</i></dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="RUNTIME_MANAGEMENT_COMMANDS"><a class="selflink" href="#RUNTIME_MANAGEMENT_COMMANDS">RUNTIME
  MANAGEMENT COMMANDS</a></h1>
<b>ovs-appctl</b> can send commands to a running <b>ovn-northd</b> process The
  currently supported commands are described below
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>exit</b></dt>
  <dd class="It-tag">Causes <b>ovn-northd</b> to gracefully terminate</dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="LOGICAL_FLOW_TABLE_STRUCTURE"><a class="selflink" href="#LOGICAL_FLOW_TABLE_STRUCTURE">LOGICAL
  FLOW TABLE STRUCTURE</a></h1>
One of the main purposes of <b>ovn-northd</b> is to populate the
  <b>Logical_Flow</b> table in the <b>OVN_Southbound</b> database This section
  describes how <b>ovn-northd</b> does this for switch and router logical
  datapaths
<h2 class="Ss" title="Ss" id="Logical_Switch_Datapaths"><a class="selflink" href="#Logical_Switch_Datapaths">Logical
  Switch Datapaths</a></h2>
<div style="margin-left: -0.15in;"><i>Ingress Table 0: Admission Control and
  Ingress Port Security - L2</i></div>
<div class="Pp"></div>
Ingress table 0 contains these logical flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 100 flows to drop packets with VLAN tags or
      multicast Ethernet source addresses</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 50 flows that implement ingress port security for
      each enabled logical port For logical ports on which port security is
      enabled, these match the <b>inport</b> and the valid <b>ethsrc</b>
      address(es) and advance only those packets to the next flow table For
      logical ports on which port security is not enabled, these advance all
      packets that match the <b>inport</b></dd>
</dl>
</div>
<div class="Pp"></div>
There are no flows for disabled logical ports because the default-drop behavior
  of logical flow tables causes packets that ingress from them to be dropped
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 1: Ingress Port Security -
  IP</i></div>
<div class="Pp"></div>
Ingress table 1 contains these logical flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each element in the port security set having one or
      more IPv4 or IPv6 addresses (or both),</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 90 flow to allow IPv4 traffic if it has IPv4
      addresses which match the <b>inport</b>, valid <b>ethsrc</b> and valid
      <b>ip4src</b> address(es)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 90 flow to allow IPv4 DHCP discovery traffic if it
      has a valid <b>ethsrc</b> This is necessary since DHCP discovery messages
      are sent from the unspecified IPv4 address (0000) since the IPv4 address
      has not yet been assigned</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 90 flow to allow IPv6 traffic if it has IPv6
      addresses which match the <b>inport</b>, valid <b>ethsrc</b> and valid
      <b>ip6src</b> address(es)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 90 flow to allow IPv6 DAD (Duplicate Address
      Detection) traffic if it has a valid <b>ethsrc</b> This is is necessary
      since DAD include requires joining an multicast group and sending neighbor
      solicitations for the newly assigned address Since no address is yet
      assigned, these are sent from the unspecified IPv6 address (::)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 80 flow to drop IP (both IPv4 and IPv6) traffic
      which match the <b>inport</b> and valid <b>ethsrc</b></dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">One priority-0 fallback flow that matches all packets and
      advances to the next table</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 2: Ingress Port Security -
  Neighbor discovery</i></div>
<div class="Pp"></div>
Ingress table 2 contains these logical flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each element in the port security set,</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 90 flow to allow ARP traffic which match the
      <b>inport</b> and valid <b>ethsrc</b> and <b>arpsha</b> If the element has
      one or more IPv4 addresses, then it also matches the valid
    <b>arpspa</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 90 flow to allow IPv6 Neighbor Solicitation and
      Advertisement traffic which match the <b>inport</b>, valid <b>ethsrc</b>
      and <b>ndsll</b>/<b>ndtll</b> If the element has one or more IPv6
      addresses, then it also matches the valid <b>ndtarget</b> address(es) for
      Neighbor Advertisement traffic</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority 80 flow to drop ARP and IPv6 Neighbor Solicitation
      and Advertisement traffic which match the <b>inport</b> and valid
      <b>ethsrc</b></dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">One priority-0 fallback flow that matches all packets and
      advances to the next table</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 3: <b>from-lport</b>
  Pre-ACLs</i></div>
<div class="Pp"></div>
This table prepares flows for possible stateful ACL processing in ingress table
  <b>ACLs</b> It contains a priority-0 flow that simply moves traffic to the
  next table If stateful ACLs are used in the logical datapath, a priority-100
  flow is added that sets a hint (with <b>reg0[0] = 1; next;</b>) for table
  <b>Pre-stateful</b> to send IP packets to the connection tracker before
  eventually advancing to ingress table <b>ACLs</b>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 4: Pre-LB</i></div>
<div class="Pp"></div>
This table prepares flows for possible stateful load balancing processing in
  ingress table <b>LB</b> and <b>Stateful</b> It contains a priority-0 flow that
  simply moves traffic to the next table If load balancing rules with virtual IP
  addresses (and ports) are configured in <b>OVN_Northbound</b> database for a
  logical switch datapath, a priority-100 flow is added for each configured
  virtual IP address <i>VIP</i> with a match <b>ip &amp;&amp; ip4dst ==
  </b><i>VIP</i> <b></b> <b></b> that sets an action <b>reg0[0] = 1; next;</b>
  to act as a hint for table <b>Pre-stateful</b> to send IP packets to the
  connection tracker for packet de-fragmentation before eventually advancing to
  ingress table <b>LB</b>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 5: Pre-stateful</i></div>
<div class="Pp"></div>
This table prepares flows for all possible stateful processing in next tables It
  contains a priority-0 flow that simply moves traffic to the next table A
  priority-100 flow sends the packets to connection tracker based on a hint
  provided by the previous tables (with a match for <b>reg0[0] == 1</b>) by
  using the <b>ct_next;</b> action
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress table 6: <b>from-lport</b>
  ACLs</i></div>
<div class="Pp"></div>
Logical flows in this table closely reproduce those in the <b>ACL</b> table in
  the <b>OVN_Northbound</b> database for the <b>from-lport</b> direction The
  <b>priority</b> values from the <b>ACL</b> table have a limited range and have
  1000 added to them to leave room for OVN default flows at both higher and
  lower priorities
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>allow</b> ACLs translate into logical flows with the
      <b>next;</b> action If there are any stateful ACLs on this datapath, then
      <b>allow</b> ACLs translate to <b>ct_commit; next;</b> (which acts as a
      hint for the next tables to commit the connection to conntrack),</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>allow-related</b> ACLs translate into logical flows with
      the <b>ct_commit(ct_label=0/1); next;</b> actions for new connections and
      <b>reg0[1] = 1; next;</b> for existing connections</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Other ACLs translate to <b>drop;</b> for new or untracked
      connections and <b>ct_commit(ct_label=1/1);</b> for known connections
      Setting <b>ct_label</b> marks a connection as one that was previously
      allowed, but should no longer be allowed due to a policy change</dd>
</dl>
</div>
<div class="Pp"></div>
This table also contains a priority 0 flow with action <b>next;</b>, so that
  ACLs allow packets by default If the logical datapath has a statetful ACL, the
  following flows will also be added:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-1 flow that sets the hint to commit IP traffic
      to the connection tracker (with action <b>reg0[1] = 1; next;</b>) This is
      needed for the default allow policy because, while the initiator&#x2019;s
      direction may not have any stateful rules, the server&#x2019;s may and
      then its return traffic would not be known and marked as invalid</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-65535 flow that allows any traffic in the reply
      direction for a connection that has been committed to the connection
      tracker (ie, established flows), as long as the committed flow does not
      have <b>ct_labelblocked</b> set We only handle traffic in the reply
      direction here because we want all packets going in the request direction
      to still go through the flows that implement the currently defined policy
      based on ACLs If a connection is no longer allowed by policy,
      <b>ct_labelblocked</b> will get set and packets in the reply direction
      will no longer be allowed, either</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-65535 flow that allows any traffic that is
      considered related to a committed flow in the connection tracker (eg, an
      ICMP Port Unreachable from a non-listening UDP port), as long as the
      committed flow does not have <b>ct_labelblocked</b> set</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-65535 flow that drops all traffic marked by the
      connection tracker as invalid</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-65535 flow that drops all trafic in the reply
      direction with <b>ct_labelblocked</b> set meaning that the connection
      should no longer be allowed due to a policy change Packets in the request
      direction are skipped here to let a newly created ACL re-allow this
      connection</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 7: <b>from-lport</b> QoS
  marking</i></div>
<div class="Pp"></div>
Logical flows in this table closely reproduce those in the <b>QoS</b> table in
  the <b>OVN_Northbound</b> database for the <b>from-lport</b> direction
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For every qos_rules for every logical switch a flow will be
      added at priorities mentioned in the QoS table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">One priority-0 fallback flow that matches all packets and
      advances to the next table</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 8: LB</i></div>
<div class="Pp"></div>
It contains a priority-0 flow that simply moves traffic to the next table For
  established connections a priority 100 flow matches on <b>ctest &amp;&amp;
  !ctrel &amp;&amp; !ctnew &amp;&amp;</b> <b>!ctinv</b> and sets an action
  <b>reg0[2] = 1; next;</b> to act as a hint for table <b>Stateful</b> to send
  packets through connection tracker to NAT the packets (The packet will
  automatically get DNATed to the same IP address as the first packet in that
  connection)
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 9: Stateful</i></div>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For all the configured load balancing rules for a switch in
      <b>OVN_Northbound</b> database that includes a L4 port <i>PORT</i> of
      protocol <i>P</i> and IPv4 address <i>VIP</i>, a priority-120 flow that
      matches on <b>ctnew &amp;&amp; ip &amp;&amp; ip4dst == </b><i>VIP</i>
      <i></i> <b>&amp;&amp; </b><i>P</i><b> &amp;&amp; </b><i>P</i><b>dst ==
      </b> <i>PORT</i> <i></i><b></b> with an action of
      <b>ct_lb(</b><i>args</i><b>)</b>, where <i>args</i> contains comma
      separated IPv4 addresses (and optional port numbers) to load balance
    to</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For all the configured load balancing rules for a switch in
      <b>OVN_Northbound</b> database that includes just an IP address <i>VIP</i>
      to match on, a priority-110 flow that matches on <b>ctnew &amp;&amp; ip
      &amp;&amp; ip4dst == </b> <i>VIP</i><b></b> with an action of
      <b>ct_lb(</b> <i>args</i><b>)</b>, where <i>args</i> contains comma
      separated IPv4 addresses</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-100 flow commits packets to connection tracker
      using <b>ct_commit; next;</b> action based on a hint provided by the
      previous tables (with a match for <b>reg0[1] == 1</b>)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-100 flow sends the packets to connection tracker
      using <b>ct_lb;</b> as the action based on a hint provided by the previous
      tables (with a match for <b>reg0[2] == 1</b>)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 flow that simply moves traffic to the next
      table</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 10: ARP/ND
  responder</i></div>
<div class="Pp"></div>
This table implements ARP/ND responder in a logical switch for known IPs The
  advantage of the ARP responder flow is to limit ARP broadcasts by locally
  responding to ARP requests without the need to send to other hypervisors One
  common case is when the inport is a logical port associated with a VIF and the
  broadcast is responded to on the local hypervisor rather than broadcast across
  the whole network and responded to by the destination VM This behavior is
  proxy ARP
<div class="Pp"></div>
ARP requests arrive from VMs from a logical switch inport of type default For
  this case, the logical switch proxy ARP rules can be for other VMs or logical
  router ports Logical switch proxy ARP rules may be programmed both for mac
  binding of IP addresses on other logical switch VIF ports (which are of the
  default logical switch port type, representing connectivity to VMs or
  containers), and for mac binding of IP addresses on logical switch router type
  ports, representing their logical router port peers In order to support proxy
  ARP for logical router ports, an IP address must be configured on the logical
  switch router type port, with the same value as the peer logical router port
  The configured MAC addresses must match as well When a VM sends an ARP request
  for a distributed logical router port and if the peer router type port of the
  attached logical switch does not have an IP address configured, the ARP
  request will be broadcast on the logical switch One of the copies of the ARP
  request will go through the logical switch router type port to the logical
  router datapath, where the logical router ARP responder will generate a reply
  The MAC binding of a distributed logical router, once learned by an associated
  VM, is used for all that VM&#x2019;s communication needing routing Hence, the
  action of a VM re-arping for the mac binding of the logical router port should
  be rare
<div class="Pp"></div>
Logical switch ARP responder proxy ARP rules can also be hit when receiving ARP
  requests externally on a L2 gateway port In this case, the hypervisor acting
  as an L2 gateway, responds to the ARP request on behalf of a destination VM
<div class="Pp"></div>
Note that ARP requests received from <b>localnet</b> or <b>vtep</b> logical
  inports can either go directly to VMs, in which case the VM responds or can
  hit an ARP responder for a logical router port if the packet is used to
  resolve a logical router port next hop address In either case, logical switch
  ARP responder rules will not be hit It contains these logical flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority-100 flows to skip the ARP responder if inport is
      of type <b>localnet</b> or <b>vtep</b> and advances directly to the next
      table ARP requests sent to <b>localnet</b> or <b>vtep</b> ports can be
      received by multiple hypervisors Now, because the same mac binding rules
      are downloaded to all hypervisors, each of the multiple hypervisors will
      respond This will confuse L2 learning on the source of the ARP requests
      ARP requests received on an inport of type <b>router</b> are not expected
      to hit any logical switch ARP responder flows However, no skip flows are
      installed for these packets, as there would be some additional flow cost
      for this and the value appears limited</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority-50 flows that match ARP requests to each known IP
      address <i>A</i> of every logical switch port, and respond with ARP
      replies directly with corresponding Ethernet address <i>E</i>:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ethdst = ethsrc;</b>
<div>&#x00A0;</div>
<b>ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>arpop = 2; /* ARP reply */</b>
<div>&#x00A0;</div>
<b>arptha = arpsha;</b>
<div>&#x00A0;</div>
<b>arpsha = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>arptpa = arpspa;</b>
<div>&#x00A0;</div>
<b>arpspa = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>outport = inport;</b>
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>output;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">These flows are omitted for logical ports (other than
      router ports) that are down</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority-50 flows that match IPv6 ND neighbor solicitations
      to each known IP address <i>A</i> (and <i>A</i>&#x2019;s solicited node
      address) of every logical switch port, and respond with neighbor
      advertisements directly with corresponding Ethernet address <i>E</i>:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>nd_na {</b>
<div>&#x00A0;</div>
<b>    ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>    ip6src = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>    ndtarget = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>    ndtll = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>    outport = inport;</b>
<div>&#x00A0;</div>
<b>    flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>    output;</b>
<div>&#x00A0;</div>
<b>};</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">These flows are omitted for logical ports (other than
      router ports) that are down</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority-100 flows with match criteria like the ARP and ND
      flows above, except that they only match packets from the <b>inport</b>
      that owns the IP addresses in question, with action <b>next;</b> These
      flows prevent OVN from replying to, for example, an ARP request emitted by
      a VM for its own IP address A VM only makes this kind of request to
      attempt to detect a duplicate IP address assignment, so sending a reply
      will prevent the VM from accepting the IP address that it owns</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In place of <b>next;</b>, it would be reasonable to use
      <b>drop;</b> for the flows&#x2019; actions If everything is working as it
      is configured, then this would produce equivalent results, since no host
      should reply to the request But ARPing for one&#x2019;s own IP address is
      intended to detect situations where the network is not working as
      configured, so dropping the request would frustrate that intent</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">One priority-0 fallback flow that matches all packets and
      advances to the next table</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 11: DHCP option
  processing</i></div>
<div class="Pp"></div>
This table adds the DHCPv4 options to a DHCPv4 packet from the logical ports
  configured with IPv4 address(es) and DHCPv4 options, and similarly for DHCPv6
  options
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-100 logical flow is added for these logical
      ports which matches the IPv4 packet with <b>udpsrc</b> = 68 and
      <b>udpdst</b> = 67 and applies the action <b>put_dhcp_opts</b> and
      advances the packet to the next table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>reg0[3] = put_dhcp_opts(offer_ip = </b><i>ip</i><b></b>, <i>options</i><b></b>);
<div>&#x00A0;</div>
<b>next;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For DHCPDISCOVER and DHCPREQUEST, this transforms the
      packet into a DHCP reply, adds the DHCP offer IP <i>ip</i> and options to
      the packet, and stores 1 into reg0[3] For other kinds of packets, it just
      stores 0 into reg0[3] Either way, it continues to the next table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-100 logical flow is added for these logical
      ports which matches the IPv6 packet with <b>udpsrc</b> = 546 and
      <b>udpdst</b> = 547 and applies the action <b>put_dhcpv6_opts</b> and
      advances the packet to the next table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>reg0[3] = put_dhcpv6_opts(ia_addr = </b><i>ip</i><b></b>, <i>options</i><b></b>);
<div>&#x00A0;</div>
<b>next;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For DHCPv6 Solicit/Request/Confirm packets, this transforms
      the packet into a DHCPv6 Advertise/Reply, adds the DHCPv6 offer IP
      <i>ip</i> and options to the packet, and stores 1 into reg0[3] For other
      kinds of packets, it just stores 0 into reg0[3] Either way, it continues
      to the next table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 flow that matches all packets to advances to
      table 11</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 12: DHCP responses</i></div>
<div class="Pp"></div>
This table implements DHCP responder for the DHCP replies generated by the
  previous table
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority 100 logical flow is added for the logical ports
      configured with DHCPv4 options which matches IPv4 packets with <b>udpsrc
      == 68</b> <b>&amp;&amp; udpdst == 67 &amp;&amp; reg0[3] == 1</b> and
      responds back to the <b>inport</b> after applying these actions If
      <b>reg0[3]</b> is set to 1, it means that the action <b>put_dhcp_opts</b>
      was successful</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ethdst = ethsrc;</b>
<div>&#x00A0;</div>
<b>ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>ip4dst = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>ip4src = </b><i>S</i><b></b>;
<div>&#x00A0;</div>
<b>udpsrc = 67;</b>
<div>&#x00A0;</div>
<b>udpdst = 68;</b>
<div>&#x00A0;</div>
<b>outport = </b><i>P</i><b></b>;
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>output;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">where <i>E</i> is the server MAC address and <i>S</i> is
      the server IPv4 address defined in the DHCPv4 options and <i>A</i> is the
      IPv4 address defined in the logical port&#x2019;s addresses column</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">(This terminates ingress packet processing; the packet does
      not go to the next ingress table)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority 100 logical flow is added for the logical ports
      configured with DHCPv6 options which matches IPv6 packets with <b>udpsrc
      == 546</b> <b>&amp;&amp; udpdst == 547 &amp;&amp; reg0[3] == 1</b> and
      responds back to the <b>inport</b> after applying these actions If
      <b>reg0[3]</b> is set to 1, it means that the action
      <b>put_dhcpv6_opts</b> was successful</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ethdst = ethsrc;</b>
<div>&#x00A0;</div>
<b>ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>ip6dst = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>ip6src = </b><i>S</i><b></b>;
<div>&#x00A0;</div>
<b>udpsrc = 547;</b>
<div>&#x00A0;</div>
<b>udpdst = 546;</b>
<div>&#x00A0;</div>
<b>outport = </b><i>P</i><b></b>;
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>output;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">where <i>E</i> is the server MAC address and <i>S</i> is
      the server IPv6 LLA address generated from the <b>server_id</b> defined in
      the DHCPv6 options and <i>A</i> is the IPv6 address defined in the logical
      port&#x2019;s addresses column</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">(This terminates packet processing; the packet does not go
      on the next ingress table)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 flow that matches all packets to advances to
      table 12</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 13 Destination
  Lookup</i></div>
<div class="Pp"></div>
This table implements switching behavior It contains these logical flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-100 flow that outputs all packets with an
      Ethernet broadcast or multicast <b>ethdst</b> to the <b>MC_FLOOD</b>
      multicast group, which <b>ovn-northd</b> populates with all enabled
      logical ports</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">One priority-50 flow that matches each known Ethernet
      address against <b>ethdst</b> and outputs the packet to the single
      associated output port</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For the Ethernet address on a logical switch port of type
      <b>router</b>, when that logical switch port&#x2019;s <b>addresses</b>
      column is set to <b>router</b> and the connected logical router port
      specifies a <b>redirect-chassis</b>:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The flow for the connected logical router port&#x2019;s
      Ethernet address is only programmed on the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the logical router has rules specified in <b>nat</b>
      with <b>external_mac</b>, then those addresses are also used to populate
      the switch&#x2019;s destination lookup on the chassis where
      <b>logical_port</b> is resident</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">One priority-0 fallback flow that matches all packets and
      outputs them to the <b>MC_UNKNOWN</b> multicast group, which
      <b>ovn-northd</b> populates with all enabled logical ports that accept
      unknown destination packets As a small optimization, if no logical ports
      accept unknown destination packets, <b>ovn-northd</b> omits this multicast
      group and logical flow</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 0: Pre-LB</i></div>
<div class="Pp"></div>
This table is similar to ingress table <b>Pre-LB</b> It contains a priority-0
  flow that simply moves traffic to the next table If any load balancing rules
  exist for the datapath, a priority-100 flow is added with a match of <b>ip</b>
  and action of <b>reg0[0] = 1;</b> <b>next;</b> to act as a hint for table
  <b>Pre-stateful</b> to send IP packets to the connection tracker for packet
  de-fragmentation
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 1: <b>to-lport</b>
  Pre-ACLs</i></div>
<div class="Pp"></div>
This is similar to ingress table <b>Pre-ACLs</b> except for <b>to-lport</b>
  traffic
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 2: Pre-stateful</i></div>
<div class="Pp"></div>
This is similar to ingress table <b>Pre-stateful</b>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 3: LB</i></div>
<div class="Pp"></div>
This is similar to ingress table <b>LB</b>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 4: <b>to-lport</b>
  ACLs</i></div>
<div class="Pp"></div>
This is similar to ingress table <b>ACLs</b> except for <b>to-lport</b> ACLs
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 5: <b>to-lport</b> QoS
  marking</i></div>
<div class="Pp"></div>
This is similar to ingress table <b>QoS marking</b> except for <b>to-lport</b>
  qos rules
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 6: Stateful</i></div>
<div class="Pp"></div>
This is similar to ingress table <b>Stateful</b> except that there are no rules
  added for load balancing new connections
<div class="Pp"></div>
Also a priority 34000 logical flow is added for each logical port which has
  DHCPv4 options defined to allow the DHCPv4 reply packet and which has DHCPv6
  options defined to allow the DHCPv6 reply packet from the <b>Ingress Table 12:
  DHCP responses</b>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 7: Egress Port Security -
  IP</i></div>
<div class="Pp"></div>
This is similar to the port security logic in table <b>Ingress Port Security -
  IP</b> except that <b>outport</b>, <b>ethdst</b>, <b>ip4dst</b> and
  <b>ip6dst</b> are checked instead of <b>inport</b>, <b>ethsrc</b>,
  <b>ip4src</b> and <b>ip6src</b>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 8: Egress Port Security -
  L2</i></div>
<div class="Pp"></div>
This is similar to the ingress port security logic in ingress table <b>Admission
  Control and Ingress Port Security - L2</b>, but with important differences
  Most obviously, <b>outport</b> and <b>ethdst</b> are checked instead of
  <b>inport</b> and <b>ethsrc</b> Second, packets directed to broadcast or
  multicast <b>ethdst</b> are always accepted instead of being subject to the
  port security rules; this is implemented through a priority-100 flow that
  matches on <b>ethmcast</b> with action <b>output;</b> Finally, to ensure that
  even broadcast and multicast packets are not delivered to disabled logical
  ports, a priority-150 flow for each disabled logical <b>outport</b> overrides
  the priority-100 flow with a <b>drop;</b> action
<h2 class="Ss" title="Ss" id="Logical_Router_Datapaths"><a class="selflink" href="#Logical_Router_Datapaths">Logical
  Router Datapaths</a></h2>
Logical router datapaths will only exist for <b>Logical_Router</b> rows in the
  <b>OVN_Northbound</b> database that do not have <b>enabled</b> set to
  <b>false</b>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 0: L2 Admission
  Control</i></div>
<div class="Pp"></div>
This table drops packets that the router shouldn&#x2019;t see at all based on
  their Ethernet headers It contains the following flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Priority-100 flows to drop packets with VLAN tags or
      multicast Ethernet source addresses</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each enabled router port <i>P</i> with Ethernet address
      <i>E</i>, a priority-50 flow that matches <b>inport ==</b>
      <b></b><i>P</i><b> &amp;&amp; (ethmcast || ethdst ==</b>
      <b></b><i>E</i><b></b>), with action <b>next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For the gateway port on a distributed logical router (where
      one of the logical router ports specifies a <b>redirect-chassis</b>), the
      above flow matching <b>ethdst == </b><i>E</i><b></b> is only programmed on
      the gateway port instance on the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each <b>dnat_and_snat</b> NAT rule on a distributed
      router that specifies an external Ethernet address <i>E</i>, a priority-50
      flow that matches <b>inport == </b><i>GW</i><b></b> <b>&amp;&amp; ethdst
      == </b> <i>E</i><b></b>, where <i>GW</i> is the logical router gateway
      port, with action <b>next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This flow is only programmed on the gateway port instance
      on the chassis where the <b>logical_port</b> specified in the NAT rule
      resides</dd>
</dl>
</div>
<div class="Pp"></div>
Other packets are implicitly dropped
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 1: IP Input</i></div>
<div class="Pp"></div>
This table is the core of the logical router datapath functionality It contains
  the following flows to implement very basic IP host functionality
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">L3 admission control: A priority-100 flow drops packets
      that match any of the following:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>ip4src[2831] == 0xe</b> (multicast source)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>ip4src == 255255255255</b> (broadcast source)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>ip4src == 127000/8 || ip4dst == 127000/8</b> (localhost
      source or destination)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>ip4src == 0000/8 || ip4dst == 0000/8</b> (zero network
      source or destination)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>ip4src</b> or <b>ip6src</b> is any IP address owned by
      the router, unless the packet was recirculated due to egress loopback as
      indicated by <b>REGBIT_EGRESS_LOOPBACK</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>ip4src</b> is the broadcast address of any IP network
      known to the router</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">ICMP echo reply These flows reply to ICMP echo requests
      received for the router&#x2019;s IP address Let <i>A</i> be an IP address
      owned by a router port Then, for each <i>A</i> that is an IPv4 address, a
      priority-90 flow matches on <b>ip4dst == </b><i>A</i><b></b> and
      <b>icmp4type == 8 &amp;&amp; icmp4code == 0</b> (ICMP echo request) For
      each <i>A</i> that is an IPv6 address, a priority-90 flow matches on
      <b>ip6dst == </b> <i>A</i><b></b> and <b>icmp6type == 128 &amp;&amp;
      icmp6code == 0</b> (ICMPv6 echo request) The port of the router that
      receives the echo request does not matter Also, the <b>ipttl</b> of the
      echo request packet is not checked, so it complies with RFC 1812, section
      4229 Flows for ICMPv4 echo requests use the following actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ip4dst &lt;-&gt; ip4src;</b>
<div>&#x00A0;</div>
<b>ipttl = 255;</b>
<div>&#x00A0;</div>
<b>icmp4type = 0;</b>
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>next;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Flows for ICMPv6 echo requests use the following
    actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ip6dst &lt;-&gt; ip6src;</b>
<div>&#x00A0;</div>
<b>ipttl = 255;</b>
<div>&#x00A0;</div>
<b>icmp6type = 129;</b>
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>next;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Reply to ARP requests</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">These flows reply to ARP requests for the router&#x2019;s
      own IP address For each router port <i>P</i> that owns IP address <i>A</i>
      and Ethernet address <i>E</i>, a priority-90 flow matches <b>inport ==
      </b> <i>P</i><b> &amp;&amp; arpop == 1 &amp;&amp;</b> <b>arptpa ==
      </b><i>A</i> <b></b> (ARP request) with the following actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ethdst = ethsrc;</b>
<div>&#x00A0;</div>
<b>ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>arpop = 2; /* ARP reply */</b>
<div>&#x00A0;</div>
<b>arptha = arpsha;</b>
<div>&#x00A0;</div>
<b>arpsha = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>arptpa = arpspa;</b>
<div>&#x00A0;</div>
<b>arpspa = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>outport = </b><i>P</i><b></b>;
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>output;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For the gateway port on a distributed logical router (where
      one of the logical router ports specifies a <b>redirect-chassis</b>), the
      above flows are only programmed on the gateway port instance on the
      <b>redirect-chassis</b> This behavior avoids generation of multiple ARP
      responses from different chassis, and allows upstream MAC learning to
      point to the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">These flows reply to ARP requests for the virtual IP
      addresses configured in the router for DNAT or load balancing For a
      configured DNAT IP address or a load balancer VIP <i>A</i>, for each
      router port <i>P</i> with Ethernet address <i>E</i>, a priority-90 flow
      matches <b>inport == </b><i>P</i><b> &amp;&amp; arpop == 1 &amp;&amp;</b>
      <b>arptpa == </b><i>A</i><b></b> (ARP request) with the following
    actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ethdst = ethsrc;</b>
<div>&#x00A0;</div>
<b>ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>arpop = 2; /* ARP reply */</b>
<div>&#x00A0;</div>
<b>arptha = arpsha;</b>
<div>&#x00A0;</div>
<b>arpsha = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>arptpa = arpspa;</b>
<div>&#x00A0;</div>
<b>arpspa = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>outport = </b><i>P</i><b></b>;
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>output;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For the gateway port on a distributed logical router with
      NAT (where one of the logical router ports specifies a
      <b>redirect-chassis</b>):</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the corresponding NAT rule cannot be handled in a
      distributed manner, then this flow is only programmed on the gateway port
      instance on the <b>redirect-chassis</b> This behavior avoids generation of
      multiple ARP responses from different chassis, and allows upstream MAC
      learning to point to the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the corresponding NAT rule can be handled in a
      distributed manner, then this flow is only programmed on the gateway port
      instance where the <b>logical_port</b> specified in the NAT rule
    resides</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Some of the actions are different for this case, using the
      <b>external_mac</b> specified in the NAT rule rather than the gateway
      port&#x2019;s Ethernet address <i>E</i>:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ethsrc = </b><i>external_mac</i><b></b>;
<div>&#x00A0;</div>
<b>arpsha = </b><i>external_mac</i><b></b>;
<div>&#x00A0;</div>
<b>            </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This behavior avoids generation of multiple ARP responses
      from different chassis, and allows upstream MAC learning to point to the
      correct chassis</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">ARP reply handling This flow uses ARP replies to populate
      the logical router&#x2019;s ARP table A priority-90 flow with match
      <b>arpop</b> <b>== 2</b> has actions <b>put_arp(inport, arpspa,</b>
      <b>arpsha);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Reply to IPv6 Neighbor Solicitations These flows reply to
      Neighbor Solicitation requests for the router&#x2019;s own IPv6 address
      and populate the logical router&#x2019;s mac binding table For each router
      port <i>P</i> that owns IPv6 address <i>A</i>, solicited node address
      <i>S</i>, and Ethernet address <i>E</i>, a priority-90 flow matches
      <b>inport == </b> <i>P</i><b> &amp;&amp; nd_ns &amp;&amp;</b> <b>ip6dst ==
      {</b> <i>A</i><b>, </b><i>E</i><b>} &amp;&amp; ndtarget</b> <b>==
      </b><i>A</i> <b></b> with the following actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>put_nd(inport, ip6src, ndsll);</b>
<div>&#x00A0;</div>
<b>nd_na {</b>
<div>&#x00A0;</div>
<b>    ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>    ip6src = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>    ndtarget = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>    ndtll = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>    outport = inport;</b>
<div>&#x00A0;</div>
<b>    flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>    output;</b>
<div>&#x00A0;</div>
<b>};</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For the gateway port on a distributed logical router (where
      one of the logical router ports specifies a <b>redirect-chassis</b>), the
      above flows replying to IPv6 Neighbor Solicitations are only programmed on
      the gateway port instance on the <b>redirect-chassis</b> This behavior
      avoids generation of multiple replies from different chassis, and allows
      upstream MAC learning to point to the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">IPv6 neighbor advertisement handling This flow uses
      neighbor advertisements to populate the logical router&#x2019;s mac
      binding table A priority-90 flow with match <b>nd_na</b> has actions
      <b>put_nd(inport, ndtarget, ndtll);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">IPv6 neighbor solicitation for non-hosted addresses
      handling This flow uses neighbor solicitations to populate the logical
      router&#x2019;s mac binding table (ones that were directed at the logical
      router would have matched the priority-90 neighbor solicitation flow
      already) A priority-80 flow with match <b>nd_ns</b> has actions
      <b>put_nd(inport, ip6src, ndsll);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UDP port unreachable Priority-80 flows generate ICMP port
      unreachable messages in reply to UDP datagrams directed to the
      router&#x2019;s IP address The logical router doesn&#x2019;t accept any
      UDP traffic so it always generates such a reply</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">These flows should not match IP fragments with nonzero
      offset</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Details TBD Not yet implemented</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">TCP reset Priority-80 flows generate TCP reset messages in
      reply to TCP datagrams directed to the router&#x2019;s IP address The
      logical router doesn&#x2019;t accept any TCP traffic so it always
      generates such a reply</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">These flows should not match IP fragments with nonzero
      offset</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Details TBD Not yet implemented</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Protocol unreachable Priority-70 flows generate ICMP
      protocol unreachable messages in reply to packets directed to the
      router&#x2019;s IP address on IP protocols other than UDP, TCP, and
    ICMP</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">These flows should not match IP fragments with nonzero
      offset</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Details TBD Not yet implemented</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Drop other IP traffic to this router These flows drop any
      other traffic destined to an IP address of this router that is not already
      handled by one of the flows above, which amounts to ICMP (other than echo
      requests) and fragments with nonzero offsets For each IP address <i>A</i>
      owned by the router, a priority-60 flow matches <b>ip4dst ==
      </b><i>A</i><b></b> and drops the traffic An exception is made and the
      above flow is not added if the router port&#x2019;s own IP address is used
      to SNAT packets passing through that router</dd>
</dl>
</div>
<div class="Pp"></div>
The flows above handle all of the traffic that might be directed to the router
  itself The following flows (with lower priorities) handle the remaining
  traffic, potentially for forwarding:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Drop Ethernet local broadcast A priority-50 flow with match
      <b>ethbcast</b> drops traffic destined to the local Ethernet broadcast
      address By definition this traffic should not be forwarded</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">ICMP time exceeded For each router port <i>P</i>, whose IP
      address is <i>A</i>, a priority-40 flow with match <b>inport</b> <b>==
      </b> <i>P</i><b> &amp;&amp; ipttl == {0, 1} &amp;&amp;</b>
      <b>!iplater_frag</b> matches packets whose TTL has expired, with the
      following actions to send an ICMP time exceeded reply:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>icmp4 {</b>
<div>&#x00A0;</div>
<b>    icmp4type = 11; /* Time exceeded */</b>
<div>&#x00A0;</div>
<b>    icmp4code = 0;  /* TTL exceeded in transit */</b>
<div>&#x00A0;</div>
<b>    ip4dst = ip4src;</b>
<div>&#x00A0;</div>
<b>    ip4src = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>    ipttl = 255;</b>
<div>&#x00A0;</div>
<b>    next;</b>
<div>&#x00A0;</div>
<b>};</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Not yet implemented</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">TTL discard A priority-30 flow with match <b>ipttl ==
      {0,</b> <b>1}</b> and actions <b>drop;</b> drops other packets whose TTL
      has expired, that should not receive a ICMP error reply (ie fragments with
      nonzero offset)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Next table A priority-0 flows match all packets that
      aren&#x2019;t already handled and uses actions <b>next;</b> to feed them
      to the next table</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 2: DEFRAG</i></div>
<div class="Pp"></div>
This is to send packets to connection tracker for tracking and defragmentation
  It contains a priority-0 flow that simply moves traffic to the next table If
  load balancing rules with virtual IP addresses (and ports) are configured in
  <b>OVN_Northbound</b> database for a Gateway router, a priority-100 flow is
  added for each configured virtual IP address <i>VIP</i> with a match <b>ip
  &amp;&amp;</b> <b>ip4dst == </b><i>VIP</i><b></b> that sets an action
  <b>ct_next;</b> to send IP packets to the connection tracker for packet
  de-fragmentation and tracking before sending it to the next table
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 3: UNSNAT</i></div>
<div class="Pp"></div>
This is for already established connections&#x2019; reverse traffic ie, SNAT has
  already been done in egress pipeline and now the packet has entered the
  ingress pipeline as part of a reply It is unSNATted here
<div class="Pp"></div>
Ingress Table 3: UNSNAT on Gateway Routers
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the Gateway router has been configured to force SNAT any
      previously DNATted packets to <i>B</i>, a priority-110 flow matches <b>ip
      &amp;&amp; ip4dst == </b> <i>B</i><b></b> with an action <b>ct_snat;
      next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the Gateway router has been configured to force SNAT any
      previously load-balanced packets to <i>B</i>, a priority-100 flow matches
      <b>ip &amp;&amp; ip4dst == </b><i>B</i><b></b> with an action <b>ct_snat;
      next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each NAT configuration in the OVN Northbound database,
      that asks to change the source IP address of a packet from <i>A</i> to
      <i>B</i>, a priority-90 flow matches <b>ip &amp;&amp;</b> <b>ip4dst ==
      </b> <i>B</i><b></b> with an action <b>ct_snat; next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
Ingress Table 3: UNSNAT on Distributed Routers
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database, that
      asks to change the source IP address of a packet from <i>A</i> to
      <i>B</i>, a priority-100 flow matches <b>ip &amp;&amp;</b> <b>ip4dst ==
      </b> <i>B</i><b> &amp;&amp; inport == </b><i>GW</i><b></b>, where
      <i>GW</i> is the logical router gateway port, with an action <b>ct_snat;
      next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the NAT rule cannot be handled in a distributed manner,
      then the priority-100 flow above is only programmed on the
      <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database, that
      asks to change the source IP address of a packet from <i>A</i> to
      <i>B</i>, a priority-50 flow matches <b>ip &amp;&amp;</b> <b>ip4dst ==
      </b> <i>B</i><b></b> with an action <b>REGBIT_NAT_REDIRECT = 1; next;</b>
      This flow is for east/west traffic to a NAT destination IPv4 address By
      setting the <b>REGBIT_NAT_REDIRECT</b> flag, in the ingress table
      <b>Gateway Redirect</b> this will trigger a redirect to the instance of
      the gateway port on the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 4: DNAT</i></div>
<div class="Pp"></div>
Packets enter the pipeline with destination IP address that needs to be DNATted
  from a virtual IP address to a real IP address Packets in the reverse
  direction needs to be unDNATed
<div class="Pp"></div>
Ingress Table 4: DNAT on Gateway Routers
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For all the configured load balancing rules for Gateway
      router in <b>OVN_Northbound</b> database that includes a L4 port
      <i>PORT</i> of protocol <i>P</i> and IPv4 address <i>VIP</i>, a
      priority-120 flow that matches on <b>ctnew &amp;&amp; ip &amp;&amp; ip4dst
      == </b> <i>VIP</i><b></b> <b>&amp;&amp; </b><i>P</i><b> &amp;&amp;
      </b><i>P</i> <b>dst == </b><i>PORT</i> <i></i><b></b> with an action of
      <b>ct_lb(</b><i>args</i><b>)</b>, where <i>args</i> contains comma
      separated IPv4 addresses (and optional port numbers) to load balance to If
      the Gateway router is configured to force SNAT any load-balanced packets,
      the above action will be replaced by <b>flagsforce_snat_for_lb = 1;</b>
      <b>ct_lb(</b><i>args</i><b>);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For all the configured load balancing rules for Gateway
      router in <b>OVN_Northbound</b> database that includes a L4 port
      <i>PORT</i> of protocol <i>P</i> and IPv4 address <i>VIP</i>, a
      priority-120 flow that matches on <b>ctest &amp;&amp; ip &amp;&amp; ip4dst
      == </b> <i>VIP</i><b></b> <b>&amp;&amp; </b><i>P</i><b> &amp;&amp;
      </b><i>P</i> <b>dst == </b><i>PORT</i> <i></i><b></b> with an action of
      <b>ct_dnat;</b> If the Gateway router is configured to force SNAT any
      load-balanced packets, the above action will be replaced by
      <b>flagsforce_snat_for_lb = 1; ct_dnat;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For all the configured load balancing rules for Gateway
      router in <b>OVN_Northbound</b> database that includes just an IP address
      <i>VIP</i> to match on, a priority-110 flow that matches on <b>ctnew
      &amp;&amp; ip &amp;&amp; ip4dst ==</b> <b></b><i>VIP</i><b></b> with an
      action of <b>ct_lb(</b><i>args</i><b>)</b>, where <i>args</i> contains
      comma separated IPv4 addresses If the Gateway router is configured to
      force SNAT any load-balanced packets, the above action will be replaced by
      <b>flagsforce_snat_for_lb = 1;</b> <b>ct_lb(</b><i>args</i><b>);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For all the configured load balancing rules for Gateway
      router in <b>OVN_Northbound</b> database that includes just an IP address
      <i>VIP</i> to match on, a priority-110 flow that matches on <b>ctest
      &amp;&amp; ip &amp;&amp; ip4dst ==</b> <b></b><i>VIP</i><b></b> with an
      action of <b>ct_dnat;</b> If the Gateway router is configured to force
      SNAT any load-balanced packets, the above action will be replaced by
      <b>flagsforce_snat_for_lb = 1; ct_dnat;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database, that
      asks to change the destination IP address of a packet from <i>A</i> to
      <i>B</i>, a priority-100 flow matches <b>ip &amp;&amp;</b> <b>ip4dst ==
      </b> <i>A</i><b></b> with an action <b>flagsloopback = 1;
      ct_dnat(</b><i>B</i> <b>);</b> If the Gateway router is configured to
      force SNAT any DNATed packet, the above action will be replaced by
      <b>flagsforce_snat_for_dnat = 1; flagsloopback = 1;</b>
      <b>ct_dnat(</b><i>B</i> <b>);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For all IP packets of a Gateway router, a priority-50 flow
      with an action <b>flagsloopback = 1; ct_dnat;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
Ingress Table 4: DNAT on Distributed Routers
<div class="Pp"></div>
On distributed routers, the DNAT table only handles packets with destination IP
  address that needs to be DNATted from a virtual IP address to a real IP
  address The unDNAT processing in the reverse direction is handled in a
  separate table in the egress pipeline
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database, that
      asks to change the destination IP address of a packet from <i>A</i> to
      <i>B</i>, a priority-100 flow matches <b>ip &amp;&amp;</b> <b>ip4dst ==
      </b> <i>B</i><b> &amp;&amp; inport == </b><i>GW</i><b></b>, where
      <i>GW</i> is the logical router gateway port, with an action
      <b>ct_dnat(</b> <i>B</i><b>);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the NAT rule cannot be handled in a distributed manner,
      then the priority-100 flow above is only programmed on the
      <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database, that
      asks to change the destination IP address of a packet from <i>A</i> to
      <i>B</i>, a priority-50 flow matches <b>ip &amp;&amp;</b> <b>ip4dst ==
      </b> <i>B</i><b></b> with an action <b>REGBIT_NAT_REDIRECT = 1; next;</b>
      This flow is for east/west traffic to a NAT destination IPv4 address By
      setting the <b>REGBIT_NAT_REDIRECT</b> flag, in the ingress table
      <b>Gateway Redirect</b> this will trigger a redirect to the instance of
      the gateway port on the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 5: IP Routing</i></div>
<div class="Pp"></div>
A packet that arrives at this table is an IP packet that should be routed to the
  address in <b>ip4dst</b> or <b>ip6dst</b> This table implements IP routing,
  setting <b>reg0</b> (or <b>xxreg0</b> for IPv6) to the next-hop IP address
  (leaving <b>ip4dst</b> or <b>ip6dst</b>, the packet&#x2019;s final
  destination, unchanged) and advances to the next table for ARP resolution It
  also sets <b>reg1</b> (or <b>xxreg1</b>) to the IP address owned by the
  selected router port (ingress table <b>ARP Request</b> will generate an ARP
  request, if needed, with <b>reg0</b> as the target protocol address and
  <b>reg1</b> as the source protocol address)
<div class="Pp"></div>
This table contains the following logical flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For distributed logical routers where one of the logical
      router ports specifies a <b>redirect-chassis</b>, a priority-300 logical
      flow with match <b>REGBIT_NAT_REDIRECT == 1</b> has actions <b>ipttl--;
      next;</b> The <b>outport</b> will be set later in the Gateway Redirect
      table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">IPv4 routing table For each route to IPv4 network <i>N</i>
      with netmask <i>M</i>, on router port <i>P</i> with IP address <i>A</i>
      and Ethernet address <i>E</i>, a logical flow with match <b>ip4dst ==</b>
      <b></b><i>N</i><b>/</b><i>M</i><b></b>, whose priority is the number of
      1-bits in <i>M</i>, has the following actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ipttl--;</b>
<div>&#x00A0;</div>
<b>reg0 = </b><i>G</i><b></b>;
<div>&#x00A0;</div>
<b>reg1 = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>outport = </b><i>P</i><b></b>;
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>next;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">(Ingress table 1 already verified that <b>ipttl--;</b> will
      not yield a TTL exceeded error)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the route has a gateway, <i>G</i> is the gateway IP
      address Instead, if the route is from a configured static route, <i>G</i>
      is the next hop IP address Else it is <b>ip4dst</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">IPv6 routing table For each route to IPv6 network <i>N</i>
      with netmask <i>M</i>, on router port <i>P</i> with IP address <i>A</i>
      and Ethernet address <i>E</i>, a logical flow with match in CIDR notation
      <b>ip6dst == </b><i>N</i><b>/</b><i>M</i><b></b>, whose priority is the
      integer value of <i>M</i>, has the following actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>ipttl--;</b>
<div>&#x00A0;</div>
<b>xxreg0 = </b><i>G</i><b></b>;
<div>&#x00A0;</div>
<b>xxreg1 = </b><i>A</i><b></b>;
<div>&#x00A0;</div>
<b>ethsrc = </b><i>E</i><b></b>;
<div>&#x00A0;</div>
<b>outport = </b><i>P</i><b></b>;
<div>&#x00A0;</div>
<b>flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>next;</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">(Ingress table 1 already verified that <b>ipttl--;</b> will
      not yield a TTL exceeded error)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the route has a gateway, <i>G</i> is the gateway IP
      address Instead, if the route is from a configured static route, <i>G</i>
      is the next hop IP address Else it is <b>ip6dst</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the address <i>A</i> is in the link-local scope, the
      route will be limited to sending on the ingress port</dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 6: ARP/ND
  Resolution</i></div>
<div class="Pp"></div>
Any packet that reaches this table is an IP packet whose next-hop IPv4 address
  is in <b>reg0</b> or IPv6 address is in <b>xxreg0</b> (<b>ip4dst</b> or
  <b>ip6dst</b> contains the final destination) This table resolves the IP
  address in <b>reg0</b> (or <b>xxreg0</b>) into an output port in
  <b>outport</b> and an Ethernet address in <b>ethdst</b>, using the following
  flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For distributed logical routers where one of the logical
      router ports specifies a <b>redirect-chassis</b>, a priority-200 logical
      flow with match <b>REGBIT_NAT_REDIRECT == 1</b> has actions <b>ethdst =
      </b> <i>E</i><b>; next;</b>, where <i>E</i> is the ethernet address of the
      router&#x2019;s distributed gateway port</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Static MAC bindings MAC bindings can be known statically
      based on data in the <b>OVN_Northbound</b> database For router ports
      connected to logical switches, MAC bindings can be known statically from
      the <b>addresses</b> column in the <b>Logical_Switch_Port</b> table For
      router ports connected to other logical routers, MAC bindings can be known
      statically from the <b>mac</b> and <b>networks</b> column in the
      <b>Logical_Router_Port</b> table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each IPv4 address <i>A</i> whose host is known to have
      Ethernet address <i>E</i> on router port <i>P</i>, a priority-100 flow
      with match <b>outport === </b><i>P</i><b></b> <b>&amp;&amp; reg0 ==
      </b><i>A</i><b></b> has actions <b>ethdst = </b><i>E</i><b>;
    next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each IPv6 address <i>A</i> whose host is known to have
      Ethernet address <i>E</i> on router port <i>P</i>, a priority-100 flow
      with match <b>outport === </b><i>P</i><b></b> <b>&amp;&amp; xxreg0 ==
      </b><i>A</i><b></b> has actions <b>ethdst = </b><i>E</i><b>;
    next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each logical router port with an IPv4 address <i>A</i>
      and a mac address of <i>E</i> that is reachable via a different logical
      router port <i>P</i>, a priority-100 flow with match <b>outport ===
      </b><i>P</i><b> &amp;&amp; reg0 ==</b> <b></b><i>A</i><b></b> has actions
      <b>ethdst = </b><i>E</i><b>;</b> <b>next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each logical router port with an IPv6 address <i>A</i>
      and a mac address of <i>E</i> that is reachable via a different logical
      router port <i>P</i>, a priority-100 flow with match <b>outport ===
      </b><i>P</i><b> &amp;&amp; xxreg0 ==</b> <b></b><i>A</i><b></b> has
      actions <b>ethdst = </b><i>E</i><b>;</b> <b>next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Dynamic MAC bindings These flows resolve MAC-to-IP bindings
      that have become known dynamically through ARP or neighbor discovery (The
      ingress table <b>ARP Request</b> will issue an ARP or neighbor
      solicitation request for cases where the binding is not yet known)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>ip4</b> has actions
      <b>get_arp(outport, reg0); next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>ip6</b> has actions
      <b>get_nd(outport, xxreg0); next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 7: Gateway
  Redirect</i></div>
<div class="Pp"></div>
For distributed logical routers where one of the logical router ports specifies
  a <b>redirect-chassis</b>, this table redirects certain packets to the
  distributed gateway port instance on the <b>redirect-chassis</b> This table
  has the following flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-200 logical flow with match
      <b>REGBIT_NAT_REDIRECT == 1</b> has actions <b>outport = </b><i>CR</i><b>;
      next;</b>, where <i>CR</i> is the <b>chassisredirect</b> port representing
      the instance of the logical router distributed gateway port on the
      <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-150 logical flow with match <b>outport ==
      </b><i>GW</i><b> &amp;&amp;</b> <b>ethdst == 00:00:00:00:00:00</b> has
      actions <b>outport = </b><i>CR</i><b>; next;</b>, where <i>GW</i> is the
      logical router distributed gateway port and <i>CR</i> is the
      <b>chassisredirect</b> port representing the instance of the logical
      router distributed gateway port on the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each NAT rule in the OVN Northbound database that can
      be handled in a distributed manner, a priority-100 logical flow with match
      <b>ip4src == </b><i>B</i><b> &amp;&amp;</b> <b>outport ==
      </b><i>GW</i><b></b>, where <i>GW</i> is the logical router distributed
      gateway port, with actions <b>next;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-50 logical flow with match <b>outport ==
      </b><i>GW</i> <b></b> has actions <b>outport = </b><i>CR</i><b>;
      next;</b>, where <i>GW</i> is the logical router distributed gateway port
      and <i>CR</i> is the <b>chassisredirect</b> port representing the instance
      of the logical router distributed gateway port on the
      <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Ingress Table 8: ARP Request</i></div>
<div class="Pp"></div>
In the common case where the Ethernet destination has been resolved, this table
  outputs the packet Otherwise, it composes and sends an ARP request It holds
  the following flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Unknown MAC address A priority-100 flow with match
      <b>ethdst ==</b> <b>00:00:00:00:00:00</b> has the following actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>arp {</b>
<div>&#x00A0;</div>
<b>    ethdst = ff:ff:ff:ff:ff:ff;</b>
<div>&#x00A0;</div>
<b>    arpspa = reg1;</b>
<div>&#x00A0;</div>
<b>    arptpa = reg0;</b>
<div>&#x00A0;</div>
<b>    arpop = 1;  /* ARP request */</b>
<div>&#x00A0;</div>
<b>    output;</b>
<div>&#x00A0;</div>
<b>};</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">(Ingress table <b>IP Routing</b> initialized <b>reg1</b>
      with the IP address owned by <b>outport</b> and <b>reg0</b> with the
      next-hop IP address)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The IP packet that triggers the ARP request is dropped</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Known MAC address A priority-0 flow with match <b>1</b> has
      actions <b>output;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 0: UNDNAT</i></div>
<div class="Pp"></div>
This is for already established connections&#x2019; reverse traffic ie, DNAT has
  already been done in ingress pipeline and now the packet has entered the
  egress pipeline as part of a reply For NAT on a distributed router, it is
  unDNATted here For Gateway routers, the unDNAT processing is carried out in
  the ingress DNAT table
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database that
      asks to change the destination IP address of a packet from an IP address
      of <i>A</i> to <i>B</i>, a priority-100 flow matches <b>ip &amp;&amp;
      ip4src == </b> <i>B</i><b></b> <b>&amp;&amp; outport ==
      </b><i>GW</i><b></b>, where <i>GW</i> is the logical router gateway port,
      with an action <b>ct_dnat;</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the NAT rule cannot be handled in a distributed manner,
      then the priority-100 flow above is only programmed on the
      <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the NAT rule can be handled in a distributed manner,
      then there is an additional action <b>ethsrc = </b><i>EA</i><b>;</b>,
      where <i>EA</i> is the ethernet address associated with the IP address
      <i>A</i> in the NAT rule This allows upstream MAC learning to point to the
      correct chassis</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 1: SNAT</i></div>
<div class="Pp"></div>
Packets that are configured to be SNATed get their source IP address changed
  based on the configuration in the OVN Northbound database
<div class="Pp"></div>
Egress Table 1: SNAT on Gateway Routers
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the Gateway router in the OVN Northbound database has
      been configured to force SNAT a packet (that has been previously DNATted)
      to <i>B</i>, a priority-100 flow matches <b>flagsforce_snat_for_dnat == 1
      &amp;&amp; ip</b> with an action <b>ct_snat(</b><i>B</i><b>);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the Gateway router in the OVN Northbound database has
      been configured to force SNAT a packet (that has been previously
      load-balanced) to <i>B</i>, a priority-100 flow matches
      <b>flagsforce_snat_for_lb == 1 &amp;&amp; ip</b> with an action
      <b>ct_snat(</b> <i>B</i><b>);</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database, that
      asks to change the source IP address of a packet from an IP address of
      <i>A</i> or to change the source IP address of a packet that belongs to
      network <i>A</i> to <i>B</i>, a flow matches <b>ip &amp;&amp; ip4src ==
      </b> <i>A</i><b></b> with an action <b>ct_snat(</b><i>B</i><b>);</b> The
      priority of the flow is calculated based on the mask of <i>A</i>, with
      matches having larger masks getting higher priorities</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
Egress Table 1: SNAT on Distributed Routers
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each configuration in the OVN Northbound database, that
      asks to change the source IP address of a packet from an IP address of
      <i>A</i> or to change the source IP address of a packet that belongs to
      network <i>A</i> to <i>B</i>, a flow matches <b>ip &amp;&amp; ip4src ==
      </b> <i>A</i><b> &amp;&amp;</b> <b>outport == </b><i>GW</i><b></b>, where
      <i>GW</i> is the logical router gateway port, with an action
      <b>ct_snat(</b> <i>B</i><b>);</b> The priority of the flow is calculated
      based on the mask of <i>A</i>, with matches having larger masks getting
      higher priorities</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the NAT rule cannot be handled in a distributed manner,
      then the flow above is only programmed on the <b>redirect-chassis</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the NAT rule can be handled in a distributed manner,
      then there is an additional action <b>ethsrc = </b><i>EA</i><b>;</b>,
      where <i>EA</i> is the ethernet address associated with the IP address
      <i>A</i> in the NAT rule This allows upstream MAC learning to point to the
      correct chassis</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 2: Egress Loopback</i></div>
<div class="Pp"></div>
For distributed logical routers where one of the logical router ports specifies
  a <b>redirect-chassis</b>
<div class="Pp"></div>
Earlier in the ingress pipeline, some east-west traffic was redirected to the
  <b>chassisredirect</b> port, based on flows in the <b>UNSNAT</b> and
  <b>DNAT</b> ingress tables setting the <b>REGBIT_NAT_REDIRECT</b> flag, which
  then triggered a match to a flow in the <b>Gateway Redirect</b> ingress table
  The intention was not to actually send traffic out the distributed gateway
  port instance on the <b>redirect-chassis</b> This traffic was sent to the
  distributed gateway port instance in order for DNAT and/or SNAT processing to
  be applied
<div class="Pp"></div>
While UNDNAT and SNAT processing have already occurred by this point, this
  traffic needs to be forced through egress loopback on this distributed gateway
  port instance, in order for UNSNAT and DNAT processing to be applied, and also
  for IP routing and ARP resolution after all of the NAT processing, so that the
  packet can be forwarded to the destination
<div class="Pp"></div>
This table has the following flows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For each NAT rule in the OVN Northbound database on a
      distributed router, a priority-100 logical flow with match <b>ip4dst ==
      </b> <i>E</i><b> &amp;&amp;</b> <b>outport == </b><i>GW</i><b></b>, where
      <i>E</i> is the external IP address specified in the NAT rule, and
      <i>GW</i> is the logical router distributed gateway port, with the
      following actions:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
<b></b>
<div>&#x00A0;</div>
<b>clone {</b>
<div>&#x00A0;</div>
<b>    ct_clear;</b>
<div>&#x00A0;</div>
<b>    inport = outport;</b>
<div>&#x00A0;</div>
<b>    outport = &quot;&quot;;</b>
<div>&#x00A0;</div>
<b>    flags = 0;</b>
<div>&#x00A0;</div>
<b>    flagsloopback = 1;</b>
<div>&#x00A0;</div>
<b>    reg0 = 0;</b>
<div>&#x00A0;</div>
<b>    reg1 = 0;</b>
<div>&#x00A0;</div>
<b>    </b>
<div>&#x00A0;</div>
<b>    reg9 = 0;</b>
<div>&#x00A0;</div>
<b>    REGBIT_EGRESS_LOOPBACK = 1;</b>
<div>&#x00A0;</div>
<b>    next(pipeline=ingress, table=0);</b>
<div>&#x00A0;</div>
<b>};</b>
<div>&#x00A0;</div>
<b>        </b>
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>flagsloopback</b> is set since in_port is unchanged and
      the packet may return back to that port after NAT processing
      <b>REGBIT_EGRESS_LOOPBACK</b> is set to indicate that egress loopback has
      occurred, in order to skip the source IP address check against the router
      address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A priority-0 logical flow with match <b>1</b> has actions
      <b>next;</b></dd>
</dl>
</div>
<div class="Pp"></div>
<div style="margin-left: -0.15in;"><i>Egress Table 3: Delivery</i></div>
<div class="Pp"></div>
Packets that reach this table are ready for delivery It contains priority-100
  logical flows that match packets on each enabled logical router port, with
  action <b>output;</b></div>
<table class="foot">
  <tr>
    <td class="foot-date">ovn-northd</td>
    <td class="foot-os">Open vSwitch 270</td>
  </tr>
</table>
</body>
</html>
