<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:12:27 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>iptables-extensions(8) iptables 1.4.21
iptables-extensions(8)</p>

<p style="margin-top: 1em">NAME <br>
iptables-extensions &acirc; list of extensions in the
standard iptables distribution</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ip6tables [-m name [module-options...]] [-j target-name
[target-options...]</p>

<p style="margin-top: 1em">iptables [-m name
[module-options...]] [-j target-name [target-options...]</p>

<p style="margin-top: 1em">MATCH EXTENSIONS <br>
iptables can use extended packet matching modules with the
-m or --match options, followed by the matching module name;
after these, various extra command line options become <br>
available, depending on the specific module. You can specify
multiple extended match modules in one line, and you can use
the -h or --help options after the module has been <br>
specified to receive help specific to that module. The
extended match modules are evaluated in the order they are
specified in the rule.</p>

<p style="margin-top: 1em">If the -p or --protocol was
specified and if and only if an unknown option is
encountered, iptables will try load a match module of the
same name as the protocol, to try making <br>
the option available.</p>

<p style="margin-top: 1em">addrtype <br>
This module matches packets based on their address type.
Address types are used within the kernel networking stack
and categorize addresses into various groups. The exact
defi&acirc; <br>
nition of that group depends on the specific layer three
protocol.</p>

<p style="margin-top: 1em">The following address types are
possible:</p>

<p style="margin-top: 1em">UNSPEC an unspecified address
(i.e. 0.0.0.0)</p>

<p style="margin-top: 1em">UNICAST <br>
an unicast address</p>

<p style="margin-top: 1em">LOCAL a local address</p>

<p style="margin-top: 1em">BROADCAST <br>
a broadcast address</p>

<p style="margin-top: 1em">ANYCAST <br>
an anycast packet</p>

<p style="margin-top: 1em">MULTICAST <br>
a multicast address</p>

<p style="margin-top: 1em">BLACKHOLE <br>
a blackhole address</p>

<p style="margin-top: 1em">UNREACHABLE <br>
an unreachable address</p>

<p style="margin-top: 1em">PROHIBIT <br>
a prohibited address</p>

<p style="margin-top: 1em">THROW FIXME</p>

<p style="margin-top: 1em">NAT FIXME</p>

<p style="margin-top: 1em">XRESOLVE</p>

<p style="margin-top: 1em">[!] --src-type type <br>
Matches if the source address is of given type</p>

<p style="margin-top: 1em">[!] --dst-type type <br>
Matches if the destination address is of given type</p>

<p style="margin-top: 1em">--limit-iface-in <br>
The address type checking can be limited to the interface
the packet is coming in. This option is only valid in the
PREROUTING, INPUT and FORWARD chains. It cannot be <br>
specified with the --limit-iface-out option.</p>

<p style="margin-top: 1em">--limit-iface-out <br>
The address type checking can be limited to the interface
the packet is going out. This option is only valid in the
POSTROUTING, OUTPUT and FORWARD chains. It cannot be <br>
specified with the --limit-iface-in option.</p>

<p style="margin-top: 1em">ah (IPv6-specific) <br>
This module matches the parameters in Authentication header
of IPsec packets.</p>

<p style="margin-top: 1em">[!] --ahspi spi[:spi] <br>
Matches SPI.</p>

<p style="margin-top: 1em">[!] --ahlen length <br>
Total length of this header in octets.</p>

<p style="margin-top: 1em">--ahres <br>
Matches if the reserved field is filled with zero.</p>

<p style="margin-top: 1em">ah (IPv4-specific) <br>
This module matches the SPIs in Authentication header of
IPsec packets.</p>

<p style="margin-top: 1em">[!] --ahspi spi[:spi]</p>

<p style="margin-top: 1em">bpf <br>
Match using Linux Socket Filter. Expects a BPF program in
decimal format. This is the format generated by the
nfbpf_compile utility.</p>

<p style="margin-top: 1em">--bytecode code <br>
Pass the BPF byte code format (described in the example
below).</p>

<p style="margin-top: 1em">The code format is similar to
the output of the tcpdump -ddd command: one line that stores
the number of instructions, followed by one line for each
instruction. Instruction <br>
lines follow the pattern &rsquo;u16 u8 u8 u32&rsquo; in
decimal notation. Fields encode the operation, jump offset
if true, jump offset if false and generic multiuse field
&rsquo;K&rsquo;. Comments are <br>
not supported.</p>

<p style="margin-top: 1em">For example, to read only
packets matching &rsquo;ip proto 6&rsquo;, insert the
following, without the comments or trailing whitespace:</p>

<p style="margin-top: 1em">4 # number of instructions <br>
48 0 0 9 # load byte ip-&gt;proto <br>
21 0 1 6 # jump equal IPPROTO_TCP <br>
6 0 0 1 # return pass (non-zero) <br>
6 0 0 0 # return fail (zero)</p>

<p style="margin-top: 1em">You can pass this filter to the
bpf match with the following command:</p>

<p style="margin-top: 1em">iptables -A OUTPUT -m bpf
--bytecode &rsquo;4,48 0 0 9,21 0 1 6,6 0 0 1,6 0 0 0&rsquo;
-j ACCEPT</p>

<p style="margin-top: 1em">Or instead, you can invoke the
nfbpf_compile utility.</p>

<p style="margin-top: 1em">iptables -A OUTPUT -m bpf
--bytecode &quot;&lsquo;nfbpf_compile RAW &rsquo;ip proto
6&rsquo;&lsquo;&quot; -j ACCEPT</p>

<p style="margin-top: 1em">You may want to learn more about
BPF from FreeBSD&rsquo;s bpf(4) manpage.</p>

<p style="margin-top: 1em">cgroup <br>
[!] --cgroup fwid <br>
Match corresponding cgroup for this packet.</p>

<p style="margin-top: 1em">Can be used to assign particular
firewall policies for aggregated task/jobs on the system.
This allows for more fine-grained firewall policies that
only match for a subset <br>
of the system&rsquo;s processes. fwid is the maker set
through the net_cls cgroup&rsquo;s id.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">iptables -A OUTPUT -p tcp
--sport 80 -m cgroup ! --cgroup 1 -j DROP</p>

<p style="margin-top: 1em">Available since Linux 3.14.</p>

<p style="margin-top: 1em">cluster <br>
Allows you to deploy gateway and back-end load-sharing
clusters without the need of load-balancers.</p>

<p style="margin-top: 1em">This match requires that all the
nodes see the same packets. Thus, the cluster match decides
if this node has to handle a packet given the following
options:</p>

<p style="margin-top: 1em">--cluster-total-nodes num <br>
Set number of total nodes in cluster.</p>

<p style="margin-top: 1em">[!] --cluster-local-node num
<br>
Set the local node number ID.</p>

<p style="margin-top: 1em">[!] --cluster-local-nodemask
mask <br>
Set the local node number ID mask. You can use this option
instead of --cluster-local-node.</p>

<p style="margin-top: 1em">--cluster-hash-seed value <br>
Set seed value of the Jenkins hash.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">iptables -A PREROUTING -t mangle
-i eth1 -m cluster --cluster-total-nodes 2
--cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j
MARK --set-mark 0xffff</p>

<p style="margin-top: 1em">iptables -A PREROUTING -t mangle
-i eth2 -m cluster --cluster-total-nodes 2
--cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j
MARK --set-mark 0xffff</p>

<p style="margin-top: 1em">iptables -A PREROUTING -t mangle
-i eth1 -m mark ! --mark 0xffff -j DROP</p>

<p style="margin-top: 1em">iptables -A PREROUTING -t mangle
-i eth2 -m mark ! --mark 0xffff -j DROP</p>

<p style="margin-top: 1em">And the following commands to
make all nodes see the same packets:</p>

<p style="margin-top: 1em">ip maddr add 01:00:5e:00:01:01
dev eth1</p>

<p style="margin-top: 1em">ip maddr add 01:00:5e:00:01:02
dev eth2</p>

<p style="margin-top: 1em">arptables -A OUTPUT -o eth1
--h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:01</p>

<p style="margin-top: 1em">arptables -A INPUT -i eth1
--h-length 6 --destination-mac 01:00:5e:00:01:01 -j mangle
--mangle-mac-d 00:zz:yy:xx:5a:27</p>

<p style="margin-top: 1em">arptables -A OUTPUT -o eth2
--h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:02</p>

<p style="margin-top: 1em">arptables -A INPUT -i eth2
--h-length 6 --destination-mac 01:00:5e:00:01:02 -j mangle
--mangle-mac-d 00:zz:yy:xx:5a:27</p>

<p style="margin-top: 1em">NOTE: the arptables commands
above use mainstream syntax. If you are using arptables-jf
included in some RedHat, CentOS and Fedora versions, you
will hit syntax errors. There&acirc; <br>
fore, you&rsquo;ll have to adapt these to the arptables-jf
syntax to get them working.</p>

<p style="margin-top: 1em">In the case of TCP connections,
pickup facility has to be disabled to avoid marking TCP ACK
packets coming in the reply direction as valid.</p>

<p style="margin-top: 1em">echo 0 &gt;
/proc/sys/net/netfilter/nf_conntrack_tcp_loose</p>

<p style="margin-top: 1em">comment <br>
Allows you to add comments (up to 256 characters) to any
rule.</p>

<p style="margin-top: 1em">--comment comment</p>

<p style="margin-top: 1em">Example: <br>
iptables -A INPUT -i eth1 -m comment --comment &quot;my
local LAN&quot;</p>

<p style="margin-top: 1em">connbytes <br>
Match by how many bytes or packets a connection (or one of
the two flows constituting the connection) has transferred
so far, or by average bytes per packet.</p>

<p style="margin-top: 1em">The counters are 64-bit and are
thus not expected to overflow ;)</p>

<p style="margin-top: 1em">The primary use is to detect
long-lived downloads and mark them to be scheduled using a
lower priority band in traffic control.</p>

<p style="margin-top: 1em">The transferred bytes per
connection can also be viewed through &lsquo;conntrack
-L&lsquo; and accessed via ctnetlink.</p>

<p style="margin-top: 1em">NOTE that for connections which
have no accounting information, the match will always return
false. The &quot;net.netfilter.nf_conntrack_acct&quot;
sysctl flag controls whether new connec&acirc; <br>
tions will be byte/packet counted. Existing connection flows
will not be gaining/losing a/the accounting structure when
be sysctl flag is flipped.</p>

<p style="margin-top: 1em">[!] --connbytes from[:to] <br>
match packets from a connection whose packets/bytes/average
packet size is more than FROM and less than TO
bytes/packets. if TO is omitted only FROM check is done.
&quot;!&quot; is <br>
used to match packets not falling in the range.</p>

<p style="margin-top: 1em">--connbytes-dir
{original|reply|both} <br>
which packets to consider</p>

<p style="margin-top: 1em">--connbytes-mode
{packets|bytes|avgpkt} <br>
whether to check the amount of packets, number of bytes
transferred or the average size (in bytes) of all packets
received so far. Note that when &quot;both&quot; is used
together <br>
with &quot;avgpkt&quot;, and data is going (mainly) only in
one direction (for example HTTP), the average packet size
will be about half of the actual data packets.</p>

<p style="margin-top: 1em">Example: <br>
iptables .. -m connbytes --connbytes 10000:100000
--connbytes-dir both --connbytes-mode bytes ...</p>

<p style="margin-top: 1em">connlabel <br>
Module matches or adds connlabels to a connection.
connlabels are similar to connmarks, except labels are
bit-based; i.e. all labels may be attached to a flow at the
same time. <br>
Up to 128 unique labels are currently supported.</p>

<p style="margin-top: 1em">[!] --label name <br>
matches if label name has been set on a connection. Instead
of a name (which will be translated to a number, see EXAMPLE
below), a number may be used instead. Using a <br>
number always overrides connlabel.conf.</p>

<p style="margin-top: 1em">--set if the label has not been
set on the connection, set it. Note that setting a label can
fail. This is because the kernel allocates the conntrack
label storage area when <br>
the connection is created, and it only reserves the amount
of memory required by the ruleset that exists at the time
the connection is created. In this case, the match <br>
will fail (or succeed, in case --label option was
negated).</p>

<p style="margin-top: 1em">This match depends on
libnetfilter_conntrack 1.0.4 or later. Label translation is
done via the /etc/xtables/connlabel.conf configuration
file.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">0 eth0-in <br>
1 eth0-out <br>
2 ppp-in <br>
3 ppp-out <br>
4 bulk-traffic <br>
5 interactive</p>

<p style="margin-top: 1em">connlimit <br>
Allows you to restrict the number of parallel connections to
a server per client IP address (or client address
block).</p>

<p style="margin-top: 1em">--connlimit-upto n <br>
Match if the number of existing connections is below or
equal n.</p>

<p style="margin-top: 1em">--connlimit-above n <br>
Match if the number of existing connections is above n.</p>

<p style="margin-top: 1em">--connlimit-mask prefix_length
<br>
Group hosts using the prefix length. For IPv4, this must be
a number between (including) 0 and 32. For IPv6, between 0
and 128. If not specified, the maximum prefix length <br>
for the applicable protocol is used.</p>

<p style="margin-top: 1em">--connlimit-saddr <br>
Apply the limit onto the source group. This is the default
if --connlimit-daddr is not specified.</p>

<p style="margin-top: 1em">--connlimit-daddr <br>
Apply the limit onto the destination group.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># allow 2 telnet connections per
client host <br>
iptables -A INPUT -p tcp --syn --dport 23 -m connlimit
--connlimit-above 2 -j REJECT</p>

<p style="margin-top: 1em"># you can also match the other
way around: <br>
iptables -A INPUT -p tcp --syn --dport 23 -m connlimit
--connlimit-upto 2 -j ACCEPT</p>

<p style="margin-top: 1em"># limit the number of parallel
HTTP requests to 16 per class C sized source network (24 bit
netmask) <br>
iptables -p tcp --syn --dport 80 -m connlimit
--connlimit-above 16 --connlimit-mask 24 -j REJECT</p>

<p style="margin-top: 1em"># limit the number of parallel
HTTP requests to 16 for the link local network <br>
(ipv6) ip6tables -p tcp --syn --dport 80 -s fe80::/64 -m
connlimit --connlimit-above 16 --connlimit-mask 64 -j
REJECT</p>

<p style="margin-top: 1em"># Limit the number of
connections to a particular host: <br>
ip6tables -p tcp --syn --dport 49152:65535 -d 2001:db8::1 -m
connlimit --connlimit-above 100 -j REJECT</p>

<p style="margin-top: 1em">connmark <br>
This module matches the netfilter mark field associated with
a connection (which can be set using the CONNMARK target
below).</p>

<p style="margin-top: 1em">[!] --mark value[/mask] <br>
Matches packets in connections with the given mark value (if
a mask is specified, this is logically ANDed with the mark
before the comparison).</p>

<p style="margin-top: 1em">conntrack <br>
This module, when combined with connection tracking, allows
access to the connection tracking state for this
packet/connection.</p>

<p style="margin-top: 1em">[!] --ctstate statelist <br>
statelist is a comma separated list of the connection states
to match. Possible states are listed below.</p>

<p style="margin-top: 1em">[!] --ctproto l4proto <br>
Layer-4 protocol to match (by number or name)</p>

<p style="margin-top: 1em">[!] --ctorigsrc
address[/mask]</p>

<p style="margin-top: 1em">[!] --ctorigdst
address[/mask]</p>

<p style="margin-top: 1em">[!] --ctreplsrc
address[/mask]</p>

<p style="margin-top: 1em">[!] --ctrepldst address[/mask]
<br>
Match against original/reply source/destination address</p>

<p style="margin-top: 1em">[!] --ctorigsrcport
port[:port]</p>

<p style="margin-top: 1em">[!] --ctorigdstport
port[:port]</p>

<p style="margin-top: 1em">[!] --ctreplsrcport
port[:port]</p>

<p style="margin-top: 1em">[!] --ctrepldstport port[:port]
<br>
Match against original/reply source/destination port
(TCP/UDP/etc.) or GRE key. Matching against port ranges is
only supported in kernel versions above 2.6.38.</p>

<p style="margin-top: 1em">[!] --ctstatus statelist <br>
statuslist is a comma separated list of the connection
statuses to match. Possible statuses are listed below.</p>

<p style="margin-top: 1em">[!] --ctexpire time[:time] <br>
Match remaining lifetime in seconds against given value or
range of values (inclusive)</p>

<p style="margin-top: 1em">--ctdir {ORIGINAL|REPLY} <br>
Match packets that are flowing in the specified direction.
If this flag is not specified at all, matches packets in
both directions.</p>

<p style="margin-top: 1em">States for --ctstate:</p>

<p style="margin-top: 1em">INVALID <br>
The packet is associated with no known connection.</p>

<p style="margin-top: 1em">NEW The packet has started a new
connection or otherwise associated with a connection which
has not seen packets in both directions.</p>

<p style="margin-top: 1em">ESTABLISHED <br>
The packet is associated with a connection which has seen
packets in both directions.</p>

<p style="margin-top: 1em">RELATED <br>
The packet is starting a new connection, but is associated
with an existing connection, such as an FTP data transfer or
an ICMP error.</p>

<p style="margin-top: 1em">UNTRACKED <br>
The packet is not tracked at all, which happens if you
explicitly untrack it by using -j CT --notrack in the raw
table.</p>

<p style="margin-top: 1em">SNAT A virtual state, matching
if the original source address differs from the reply
destination.</p>

<p style="margin-top: 1em">DNAT A virtual state, matching
if the original destination differs from the reply
source.</p>

<p style="margin-top: 1em">Statuses for --ctstatus:</p>

<p style="margin-top: 1em">NONE None of the below.</p>

<p style="margin-top: 1em">EXPECTED <br>
This is an expected connection (i.e. a conntrack helper set
it up).</p>

<p style="margin-top: 1em">SEEN_REPLY <br>
Conntrack has seen packets in both directions.</p>

<p style="margin-top: 1em">ASSURED <br>
Conntrack entry should never be early-expired.</p>

<p style="margin-top: 1em">CONFIRMED <br>
Connection is confirmed: originating packet has left
box.</p>

<p style="margin-top: 1em">cpu <br>
[!] --cpu number <br>
Match cpu handling this packet. cpus are numbered from 0 to
NR_CPUS-1 Can be used in combination with RPS (Remote Packet
Steering) or multiqueue NICs to spread network <br>
traffic on different queues.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">iptables -t nat -A PREROUTING -p
tcp --dport 80 -m cpu --cpu 0 -j REDIRECT --to-port 8080</p>

<p style="margin-top: 1em">iptables -t nat -A PREROUTING -p
tcp --dport 80 -m cpu --cpu 1 -j REDIRECT --to-port 8081</p>

<p style="margin-top: 1em">Available since Linux
2.6.36.</p>

<p style="margin-top: 1em">dccp <br>
[!] --source-port,--sport port[:port]</p>

<p style="margin-top: 1em">[!] --destination-port,--dport
port[:port]</p>

<p style="margin-top: 1em">[!] --dccp-types mask <br>
Match when the DCCP packet type is one of
&rsquo;mask&rsquo;. &rsquo;mask&rsquo; is a comma-separated
list of packet types. Packet types are: REQUEST RESPONSE
DATA ACK DATAACK CLOSEREQ CLOSE <br>
RESET SYNC SYNCACK INVALID.</p>

<p style="margin-top: 1em">[!] --dccp-option number <br>
Match if DCCP option set.</p>

<p style="margin-top: 1em">devgroup <br>
Match device group of a packets incoming/outgoing
interface.</p>

<p style="margin-top: 1em">[!] --src-group name <br>
Match device group of incoming device</p>

<p style="margin-top: 1em">[!] --dst-group name <br>
Match device group of outgoing device</p>

<p style="margin-top: 1em">dscp <br>
This module matches the 6 bit DSCP field within the TOS
field in the IP header. DSCP has superseded TOS within the
IETF.</p>

<p style="margin-top: 1em">[!] --dscp value <br>
Match against a numeric (decimal or hex) value [0-63].</p>

<p style="margin-top: 1em">[!] --dscp-class class <br>
Match the DiffServ class. This value may be any of the BE,
EF, AFxx or CSx classes. It will then be converted into its
according numeric value.</p>

<p style="margin-top: 1em">dst (IPv6-specific) <br>
This module matches the parameters in Destination Options
header</p>

<p style="margin-top: 1em">[!] --dst-len length <br>
Total length of this header in octets.</p>

<p style="margin-top: 1em">--dst-opts
type[:length][,type[:length]...] <br>
numeric type of option and the length of the option data in
octets.</p>

<p style="margin-top: 1em">ecn <br>
This allows you to match the ECN bits of the IPv4/IPv6 and
TCP header. ECN is the Explicit Congestion Notification
mechanism as specified in RFC3168</p>

<p style="margin-top: 1em">[!] --ecn-tcp-cwr <br>
This matches if the TCP ECN CWR (Congestion Window Received)
bit is set.</p>

<p style="margin-top: 1em">[!] --ecn-tcp-ece <br>
This matches if the TCP ECN ECE (ECN Echo) bit is set.</p>

<p style="margin-top: 1em">[!] --ecn-ip-ect num <br>
This matches a particular IPv4/IPv6 ECT (ECN-Capable
Transport). You have to specify a number between
&lsquo;0&rsquo; and &lsquo;3&rsquo;.</p>

<p style="margin-top: 1em">esp <br>
This module matches the SPIs in ESP header of IPsec
packets.</p>

<p style="margin-top: 1em">[!] --espspi spi[:spi]</p>

<p style="margin-top: 1em">eui64 (IPv6-specific) <br>
This module matches the EUI-64 part of a stateless
autoconfigured IPv6 address. It compares the EUI-64 derived
from the source MAC address in Ethernet frame with the lower
64 <br>
bits of the IPv6 source address. But
&quot;Universal/Local&quot; bit is not compared. This module
doesn&rsquo;t match other link layer frame, and is only
valid in the PREROUTING, INPUT and FOR&acirc; <br>
WARD chains.</p>

<p style="margin-top: 1em">frag (IPv6-specific) <br>
This module matches the parameters in Fragment header.</p>

<p style="margin-top: 1em">[!] --fragid id[:id] <br>
Matches the given Identification or range of it.</p>

<p style="margin-top: 1em">[!] --fraglen length <br>
This option cannot be used with kernel version 2.6.10 or
later. The length of Fragment header is static and this
option doesn&rsquo;t make sense.</p>

<p style="margin-top: 1em">--fragres <br>
Matches if the reserved fields are filled with zero.</p>

<p style="margin-top: 1em">--fragfirst <br>
Matches on the first fragment.</p>

<p style="margin-top: 1em">--fragmore <br>
Matches if there are more fragments.</p>

<p style="margin-top: 1em">--fraglast <br>
Matches if this is the last fragment.</p>

<p style="margin-top: 1em">hashlimit <br>
hashlimit uses hash buckets to express a rate limiting match
(like the limit match) for a group of connections using a
single iptables rule. Grouping can be done per-hostgroup
<br>
(source and/or destination address) and/or per-port. It
gives you the ability to express &quot;N packets per time
quantum per group&quot; or &quot;N bytes per seconds&quot;
(see below for some exam&acirc; <br>
ples).</p>

<p style="margin-top: 1em">A hash limit option
(--hashlimit-upto, --hashlimit-above) and --hashlimit-name
are required.</p>

<p style="margin-top: 1em">--hashlimit-upto
amount[/second|/minute|/hour|/day] <br>
Match if the rate is below or equal to amount/quantum. It is
specified either as a number, with an optional time quantum
suffix (the default is 3/hour), or as amountb/sec&acirc;
<br>
ond (number of bytes per second).</p>

<p style="margin-top: 1em">--hashlimit-above
amount[/second|/minute|/hour|/day] <br>
Match if the rate is above amount/quantum.</p>

<p style="margin-top: 1em">--hashlimit-burst amount <br>
Maximum initial number of packets to match: this number gets
recharged by one every time the limit specified above is not
reached, up to this number; the default is 5. <br>
When byte-based rate matching is requested, this option
specifies the amount of bytes that can exceed the given
rate. This option should be used with caution -- if the <br>
entry expires, the burst value is reset too.</p>

<p style="margin-top: 1em">--hashlimit-mode
{srcip|srcport|dstip|dstport},... <br>
A comma-separated list of objects to take into
consideration. If no --hashlimit-mode option is given,
hashlimit acts like limit, but at the expensive of doing the
hash <br>
housekeeping.</p>

<p style="margin-top: 1em">--hashlimit-srcmask prefix <br>
When --hashlimit-mode srcip is used, all source addresses
encountered will be grouped according to the given prefix
length and the so-created subnet will be subject to <br>
hashlimit. prefix must be between (inclusive) 0 and 32. Note
that --hashlimit-srcmask 0 is basically doing the same thing
as not specifying srcip for --hashlimit-mode, but <br>
is technically more expensive.</p>

<p style="margin-top: 1em">--hashlimit-dstmask prefix <br>
Like --hashlimit-srcmask, but for destination addresses.</p>

<p style="margin-top: 1em">--hashlimit-name foo <br>
The name for the /proc/net/ipt_hashlimit/foo entry.</p>

<p style="margin-top: 1em">--hashlimit-htable-size buckets
<br>
The number of buckets of the hash table</p>

<p style="margin-top: 1em">--hashlimit-htable-max entries
<br>
Maximum entries in the hash.</p>

<p style="margin-top: 1em">--hashlimit-htable-expire msec
<br>
After how many milliseconds do hash entries expire.</p>

<p style="margin-top: 1em">--hashlimit-htable-gcinterval
msec <br>
How many milliseconds between garbage collection
intervals.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">matching on source host <br>
&quot;1000 packets per second for every host in
192.168.0.0/16&quot; =&gt; -s 192.168.0.0/16
--hashlimit-mode srcip --hashlimit-upto 1000/sec</p>

<p style="margin-top: 1em">matching on source port <br>
&quot;100 packets per second for every service of
192.168.1.1&quot; =&gt; -s 192.168.1.1 --hashlimit-mode
srcport --hashlimit-upto 100/sec</p>

<p style="margin-top: 1em">matching on subnet <br>
&quot;10000 packets per minute for every /28 subnet (groups
of 8 addresses) in 10.0.0.0/8&quot; =&gt; -s 10.0.0.0/8
--hashlimit-mask 28 --hashlimit-upto 10000/min</p>

<p style="margin-top: 1em">matching bytes per second <br>
&quot;flows exceeding 512kbyte/s&quot; =&gt;
--hashlimit-mode srcip,dstip,srcport,dstport
--hashlimit-above 512kb/s</p>

<p style="margin-top: 1em">matching bytes per second <br>
&quot;hosts that exceed 512kbyte/s, but permit up to
1Megabytes without matching&quot; --hashlimit-mode dstip
--hashlimit-above 512kb/s --hashlimit-burst 1mb</p>

<p style="margin-top: 1em">hbh (IPv6-specific) <br>
This module matches the parameters in Hop-by-Hop Options
header</p>

<p style="margin-top: 1em">[!] --hbh-len length <br>
Total length of this header in octets.</p>

<p style="margin-top: 1em">--hbh-opts
type[:length][,type[:length]...] <br>
numeric type of option and the length of the option data in
octets.</p>

<p style="margin-top: 1em">helper <br>
This module matches packets related to a specific
conntrack-helper.</p>

<p style="margin-top: 1em">[!] --helper string <br>
Matches packets related to the specified
conntrack-helper.</p>

<p style="margin-top: 1em">string can be &quot;ftp&quot;
for packets related to a ftp-session on default port. For
other ports append -portnr to the value, ie.
&quot;ftp-2121&quot;.</p>

<p style="margin-top: 1em">Same rules apply for other
conntrack-helpers.</p>

<p style="margin-top: 1em">hl (IPv6-specific) <br>
This module matches the Hop Limit field in the IPv6
header.</p>

<p style="margin-top: 1em">[!] --hl-eq value <br>
Matches if Hop Limit equals value.</p>

<p style="margin-top: 1em">--hl-lt value <br>
Matches if Hop Limit is less than value.</p>

<p style="margin-top: 1em">--hl-gt value <br>
Matches if Hop Limit is greater than value.</p>

<p style="margin-top: 1em">icmp (IPv4-specific) <br>
This extension can be used if &lsquo;--protocol icmp&rsquo;
is specified. It provides the following option:</p>

<p style="margin-top: 1em">[!] --icmp-type
{type[/code]|typename} <br>
This allows specification of the ICMP type, which can be a
numeric ICMP type, type/code pair, or one of the ICMP type
names shown by the command <br>
iptables -p icmp -h</p>

<p style="margin-top: 1em">icmp6 (IPv6-specific) <br>
This extension can be used if &lsquo;--protocol
ipv6-icmp&rsquo; or &lsquo;--protocol icmpv6&rsquo; is
specified. It provides the following option:</p>

<p style="margin-top: 1em">[!] --icmpv6-type
type[/code]|typename <br>
This allows specification of the ICMPv6 type, which can be a
numeric ICMPv6 type, type and code, or one of the ICMPv6
type names shown by the command <br>
ip6tables -p ipv6-icmp -h</p>

<p style="margin-top: 1em">iprange <br>
This matches on a given arbitrary range of IP addresses.</p>

<p style="margin-top: 1em">[!] --src-range from[-to] <br>
Match source IP in the specified range.</p>

<p style="margin-top: 1em">[!] --dst-range from[-to] <br>
Match destination IP in the specified range.</p>

<p style="margin-top: 1em">ipv6header (IPv6-specific) <br>
This module matches IPv6 extension headers and/or upper
layer header.</p>

<p style="margin-top: 1em">--soft Matches if the packet
includes any of the headers specified with --header.</p>

<p style="margin-top: 1em">[!] --header header[,header...]
<br>
Matches the packet which EXACTLY includes all specified
headers. The headers encapsulated with ESP header are out of
scope. Possible header types can be:</p>

<p style="margin-top: 1em">hop|hop-by-hop <br>
Hop-by-Hop Options header</p>

<p style="margin-top: 1em">dst Destination Options
header</p>

<p style="margin-top: 1em">route Routing header</p>

<p style="margin-top: 1em">frag Fragment header</p>

<p style="margin-top: 1em">auth Authentication header</p>

<p style="margin-top: 1em">esp Encapsulating Security
Payload header</p>

<p style="margin-top: 1em">none No Next header which
matches 59 in the &rsquo;Next Header field&rsquo; of IPv6
header or any IPv6 extension headers</p>

<p style="margin-top: 1em">proto which matches any upper
layer protocol header. A protocol name from /etc/protocols
and numeric value also allowed. The number 255 is equivalent
to proto.</p>

<p style="margin-top: 1em">ipvs <br>
Match IPVS connection properties.</p>

<p style="margin-top: 1em">[!] --ipvs <br>
packet belongs to an IPVS connection</p>

<p style="margin-top: 1em">Any of the following options
implies --ipvs (even negated)</p>

<p style="margin-top: 1em">[!] --vproto protocol <br>
VIP protocol to match; by number or name, e.g.
&quot;tcp&quot;</p>

<p style="margin-top: 1em">[!] --vaddr address[/mask] <br>
VIP address to match</p>

<p style="margin-top: 1em">[!] --vport port <br>
VIP port to match; by number or name, e.g.
&quot;http&quot;</p>

<p style="margin-top: 1em">--vdir {ORIGINAL|REPLY} <br>
flow direction of packet</p>

<p style="margin-top: 1em">[!] --vmethod {GATE|IPIP|MASQ}
<br>
IPVS forwarding method used</p>

<p style="margin-top: 1em">[!] --vportctl port <br>
VIP port of the controlling connection to match, e.g. 21 for
FTP</p>

<p style="margin-top: 1em">length <br>
This module matches the length of the layer-3 payload (e.g.
layer-4 packet) of a packet against a specific value or
range of values.</p>

<p style="margin-top: 1em">[!] --length length[:length]</p>

<p style="margin-top: 1em">limit <br>
This module matches at a limited rate using a token bucket
filter. A rule using this extension will match until this
limit is reached. It can be used in combination with the
<br>
LOG target to give limited logging, for example.</p>

<p style="margin-top: 1em">xt_limit has no negation support
- you will have to use -m hashlimit ! --hashlimit rate in
this case whilst omitting --hashlimit-mode.</p>

<p style="margin-top: 1em">--limit
rate[/second|/minute|/hour|/day] <br>
Maximum average matching rate: specified as a number, with
an optional &lsquo;/second&rsquo;, &lsquo;/minute&rsquo;,
&lsquo;/hour&rsquo;, or &lsquo;/day&rsquo; suffix; the
default is 3/hour.</p>

<p style="margin-top: 1em">--limit-burst number <br>
Maximum initial number of packets to match: this number gets
recharged by one every time the limit specified above is not
reached, up to this number; the default is 5.</p>

<p style="margin-top: 1em">mac <br>
[!] --mac-source address <br>
Match source MAC address. It must be of the form
XX:XX:XX:XX:XX:XX. Note that this only makes sense for
packets coming from an Ethernet device and entering the
PREROUT&acirc; <br>
ING, FORWARD or INPUT chains.</p>

<p style="margin-top: 1em">mark <br>
This module matches the netfilter mark field associated with
a packet (which can be set using the MARK target below).</p>

<p style="margin-top: 1em">[!] --mark value[/mask] <br>
Matches packets with the given unsigned mark value (if a
mask is specified, this is logically ANDed with the mask
before the comparison).</p>

<p style="margin-top: 1em">mh (IPv6-specific) <br>
This extension is loaded if &lsquo;--protocol ipv6-mh&rsquo;
or &lsquo;--protocol mh&rsquo; is specified. It provides the
following option:</p>

<p style="margin-top: 1em">[!] --mh-type type[:type] <br>
This allows specification of the Mobility Header(MH) type,
which can be a numeric MH type, type or one of the MH type
names shown by the command <br>
ip6tables -p mh -h</p>

<p style="margin-top: 1em">multiport <br>
This module matches a set of source or destination ports. Up
to 15 ports can be specified. A port range (port:port)
counts as two ports. It can only be used in conjunction <br>
with one of the following protocols: tcp, udp, udplite, dccp
and sctp.</p>

<p style="margin-top: 1em">[!] --source-ports,--sports
port[,port|,port:port]... <br>
Match if the source port is one of the given ports. The flag
--sports is a convenient alias for this option. Multiple
ports or port ranges are separated using a comma, <br>
and a port range is specified using a colon. 53,1024:65535
would therefore match ports 53 and all from 1024 through
65535.</p>

<p style="margin-top: 1em">[!] --destination-ports,--dports
port[,port|,port:port]... <br>
Match if the destination port is one of the given ports. The
flag --dports is a convenient alias for this option.</p>

<p style="margin-top: 1em">[!] --ports
port[,port|,port:port]... <br>
Match if either the source or destination ports are equal to
one of the given ports.</p>

<p style="margin-top: 1em">nfacct <br>
The nfacct match provides the extended accounting
infrastructure for iptables. You have to use this match
together with the standalone user-space utility
nfacct(8)</p>

<p style="margin-top: 1em">The only option available for
this match is the following:</p>

<p style="margin-top: 1em">--nfacct-name name <br>
This allows you to specify the existing object name that
will be use for accounting the traffic that this rule-set is
matching.</p>

<p style="margin-top: 1em">To use this extension, you have
to create an accounting object:</p>

<p style="margin-top: 1em">nfacct add http-traffic</p>

<p style="margin-top: 1em">Then, you have to attach it to
the accounting object via iptables:</p>

<p style="margin-top: 1em">iptables -I INPUT -p tcp --sport
80 -m nfacct --nfacct-name http-traffic</p>

<p style="margin-top: 1em">iptables -I OUTPUT -p tcp
--dport 80 -m nfacct --nfacct-name http-traffic</p>

<p style="margin-top: 1em">Then, you can check for the
amount of traffic that the rules match:</p>

<p style="margin-top: 1em">nfacct get http-traffic</p>

<p style="margin-top: 1em">{ pkts = 00000000000000000156,
bytes = 00000000000000151786 } = http-traffic;</p>

<p style="margin-top: 1em">You can obtain nfacct(8) from
http://www.netfilter.org or, alternatively, from the
git.netfilter.org repository.</p>

<p style="margin-top: 1em">osf <br>
The osf module does passive operating system fingerprinting.
This modules compares some data (Window Size, MSS, options
and their order, TTL, DF, and others) from packets with <br>
the SYN bit set.</p>

<p style="margin-top: 1em">[!] --genre string <br>
Match an operating system genre by using a passive
fingerprinting.</p>

<p style="margin-top: 1em">--ttl level <br>
Do additional TTL checks on the packet to determine the
operating system. level can be one of the following
values:</p>

<p style="margin-top: 1em">&Acirc;&middot; 0 - True IP
address and fingerprint TTL comparison. This generally works
for LANs.</p>

<p style="margin-top: 1em">&Acirc;&middot; 1 - Check if the
IP header&rsquo;s TTL is less than the fingerprint one.
Works for globally-routable addresses.</p>

<p style="margin-top: 1em">&Acirc;&middot; 2 - Do not
compare the TTL at all.</p>

<p style="margin-top: 1em">--log level <br>
Log determined genres into dmesg even if they do not match
the desired one. level can be one of the following
values:</p>

<p style="margin-top: 1em">&Acirc;&middot; 0 - Log all
matched or unknown signatures</p>

<p style="margin-top: 1em">&Acirc;&middot; 1 - Log only the
first one</p>

<p style="margin-top: 1em">&Acirc;&middot; 2 - Log all
known matched signatures</p>

<p style="margin-top: 1em">You may find something like this
in syslog:</p>

<p style="margin-top: 1em">Windows [2000:SP3:Windows XP Pro
SP1, 2000 SP3]: 11.22.33.55:4024 -&gt; 11.22.33.44:139
hops=3 Linux [2.5-2.6:] : 1.2.3.4:42624 -&gt; 1.2.3.5:22
hops=4</p>

<p style="margin-top: 1em">OS fingerprints are loadable
using the nfnl_osf program. To load fingerprints from a
file, use:</p>

<p style="margin-top: 1em">nfnl_osf -f
/usr/share/xtables/pf.os</p>

<p style="margin-top: 1em">To remove them again,</p>

<p style="margin-top: 1em">nfnl_osf -f
/usr/share/xtables/pf.os -d</p>

<p style="margin-top: 1em">The fingerprint database can be
downlaoded from
http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os .</p>

<p style="margin-top: 1em">owner <br>
This module attempts to match various characteristics of the
packet creator, for locally generated packets. This match is
only valid in the OUTPUT and POSTROUTING chains. For&acirc;
<br>
warded packets do not have any socket associated with them.
Packets from kernel threads do have a socket, but usually no
owner.</p>

<p style="margin-top: 1em">[!] --uid-owner username</p>

<p style="margin-top: 1em">[!] --uid-owner userid[-userid]
<br>
Matches if the packet socket&rsquo;s file structure (if it
has one) is owned by the given user. You may also specify a
numerical UID, or an UID range.</p>

<p style="margin-top: 1em">[!] --gid-owner groupname</p>

<p style="margin-top: 1em">[!] --gid-owner
groupid[-groupid] <br>
Matches if the packet socket&rsquo;s file structure is owned
by the given group. You may also specify a numerical GID, or
a GID range.</p>

<p style="margin-top: 1em">[!] --socket-exists <br>
Matches if the packet is associated with a socket.</p>

<p style="margin-top: 1em">physdev <br>
This module matches on the bridge port input and output
devices enslaved to a bridge device. This module is a part
of the infrastructure that enables a transparent bridging IP
<br>
firewall and is only useful for kernel versions above
version 2.5.44.</p>

<p style="margin-top: 1em">[!] --physdev-in name <br>
Name of a bridge port via which a packet is received (only
for packets entering the INPUT, FORWARD and PREROUTING
chains). If the interface name ends in a &quot;+&quot;, then
any <br>
interface which begins with this name will match. If the
packet didn&rsquo;t arrive through a bridge device, this
packet won&rsquo;t match this option, unless &rsquo;!&rsquo;
is used.</p>

<p style="margin-top: 1em">[!] --physdev-out name <br>
Name of a bridge port via which a packet is going to be sent
(for packets entering the FORWARD, OUTPUT and POSTROUTING
chains). If the interface name ends in a &quot;+&quot;, then
<br>
any interface which begins with this name will match. Note
that in the nat and mangle OUTPUT chains one cannot match on
the bridge output port, however one can in the fil&acirc;
<br>
ter OUTPUT chain. If the packet won&rsquo;t leave by a
bridge device or if it is yet unknown what the output device
will be, then the packet won&rsquo;t match this option,
unless &rsquo;!&rsquo; <br>
is used.</p>

<p style="margin-top: 1em">[!] --physdev-is-in <br>
Matches if the packet has entered through a bridge
interface.</p>

<p style="margin-top: 1em">[!] --physdev-is-out <br>
Matches if the packet will leave through a bridge
interface.</p>

<p style="margin-top: 1em">[!] --physdev-is-bridged <br>
Matches if the packet is being bridged and therefore is not
being routed. This is only useful in the FORWARD and
POSTROUTING chains.</p>

<p style="margin-top: 1em">pkttype <br>
This module matches the link-layer packet type.</p>

<p style="margin-top: 1em">[!] --pkt-type
{unicast|broadcast|multicast}</p>

<p style="margin-top: 1em">policy <br>
This modules matches the policy used by IPsec for handling a
packet.</p>

<p style="margin-top: 1em">--dir {in|out} <br>
Used to select whether to match the policy used for
decapsulation or the policy that will be used for
encapsulation. in is valid in the PREROUTING, INPUT and
FORWARD <br>
chains, out is valid in the POSTROUTING, OUTPUT and FORWARD
chains.</p>

<p style="margin-top: 1em">--pol {none|ipsec} <br>
Matches if the packet is subject to IPsec processing. --pol
none cannot be combined with --strict.</p>

<p style="margin-top: 1em">--strict <br>
Selects whether to match the exact policy or match if any
rule of the policy matches the given policy.</p>

<p style="margin-top: 1em">For each policy element that is
to be described, one can use one or more of the following
options. When --strict is in effect, at least one must be
used per element.</p>

<p style="margin-top: 1em">[!] --reqid id <br>
Matches the reqid of the policy rule. The reqid can be
specified with setkey(8) using unique:id as level.</p>

<p style="margin-top: 1em">[!] --spi spi <br>
Matches the SPI of the SA.</p>

<p style="margin-top: 1em">[!] --proto {ah|esp|ipcomp} <br>
Matches the encapsulation protocol.</p>

<p style="margin-top: 1em">[!] --mode {tunnel|transport}
<br>
Matches the encapsulation mode.</p>

<p style="margin-top: 1em">[!] --tunnel-src addr[/mask]
<br>
Matches the source end-point address of a tunnel mode SA.
Only valid with --mode tunnel.</p>

<p style="margin-top: 1em">[!] --tunnel-dst addr[/mask]
<br>
Matches the destination end-point address of a tunnel mode
SA. Only valid with --mode tunnel.</p>

<p style="margin-top: 1em">--next Start the next element in
the policy specification. Can only be used with
--strict.</p>

<p style="margin-top: 1em">quota <br>
Implements network quotas by decrementing a byte counter
with each packet. The condition matches until the byte
counter reaches zero. Behavior is reversed with negation
(i.e. the <br>
condition does not match until the byte counter reaches
zero).</p>

<p style="margin-top: 1em">[!] --quota bytes <br>
The quota in bytes.</p>

<p style="margin-top: 1em">rateest <br>
The rate estimator can match on estimated rates as collected
by the RATEEST target. It supports matching on absolute
bps/pps values, comparing two rate estimators and matching
on <br>
the difference between two rate estimators.</p>

<p style="margin-top: 1em">For a better understanding of
the available options, these are all possible
combinations:</p>

<p style="margin-top: 1em">&Acirc;&middot; rateest operator
rateest-bps</p>

<p style="margin-top: 1em">&Acirc;&middot; rateest operator
rateest-pps</p>

<p style="margin-top: 1em">&Acirc;&middot; (rateest minus
rateest-bps1) operator rateest-bps2</p>

<p style="margin-top: 1em">&Acirc;&middot; (rateest minus
rateest-pps1) operator rateest-pps2</p>

<p style="margin-top: 1em">&Acirc;&middot; rateest1
operator rateest2 rateest-bps(without rate!)</p>

<p style="margin-top: 1em">&Acirc;&middot; rateest1
operator rateest2 rateest-pps(without rate!)</p>

<p style="margin-top: 1em">&Acirc;&middot; (rateest1 minus
rateest-bps1) operator (rateest2 minus rateest-bps2)</p>

<p style="margin-top: 1em">&Acirc;&middot; (rateest1 minus
rateest-pps1) operator (rateest2 minus rateest-pps2)</p>

<p style="margin-top: 1em">--rateest-delta <br>
For each estimator (either absolute or relative mode),
calculate the difference between the estimator-determined
flow rate and the static value chosen with the BPS/PPS <br>
options. If the flow rate is higher than the specified
BPS/PPS, 0 will be used instead of a negative value. In
other words, &quot;max(0, rateest#_rate -
rateest#_bps)&quot; is used.</p>

<p style="margin-top: 1em">[!] --rateest-lt <br>
Match if rate is less than given rate/estimator.</p>

<p style="margin-top: 1em">[!] --rateest-gt <br>
Match if rate is greater than given rate/estimator.</p>

<p style="margin-top: 1em">[!] --rateest-eq <br>
Match if rate is equal to given rate/estimator.</p>

<p style="margin-top: 1em">In the so-called &quot;absolute
mode&quot;, only one rate estimator is used and compared
against a static value, while in &quot;relative mode&quot;,
two rate estimators are compared against another.</p>

<p style="margin-top: 1em">--rateest name <br>
Name of the one rate estimator for absolute mode.</p>

<p style="margin-top: 1em">--rateest1 name</p>

<p style="margin-top: 1em">--rateest2 name <br>
The names of the two rate estimators for relative mode.</p>

<p style="margin-top: 1em">--rateest-bps [value]</p>

<p style="margin-top: 1em">--rateest-pps [value]</p>

<p style="margin-top: 1em">--rateest-bps1 [value]</p>

<p style="margin-top: 1em">--rateest-bps2 [value]</p>

<p style="margin-top: 1em">--rateest-pps1 [value]</p>

<p style="margin-top: 1em">--rateest-pps2 [value] <br>
Compare the estimator(s) by bytes or packets per second, and
compare against the chosen value. See the above bullet list
for which option is to be used in which case. A <br>
unit suffix may be used - available ones are: bit,
[kmgt]bit, [KMGT]ibit, Bps, [KMGT]Bps, [KMGT]iBps.</p>

<p style="margin-top: 1em">Example: This is what can be
used to route outgoing data connections from an FTP server
over two lines based on the available bandwidth at the time
the data connection was <br>
started:</p>

<p style="margin-top: 1em"># Estimate outgoing rates</p>

<p style="margin-top: 1em">iptables -t mangle -A
POSTROUTING -o eth0 -j RATEEST --rateest-name eth0
--rateest-interval 250ms --rateest-ewma 0.5s</p>

<p style="margin-top: 1em">iptables -t mangle -A
POSTROUTING -o ppp0 -j RATEEST --rateest-name ppp0
--rateest-interval 250ms --rateest-ewma 0.5s</p>

<p style="margin-top: 1em"># Mark based on available
bandwidth</p>

<p style="margin-top: 1em">iptables -t mangle -A balance -m
conntrack --ctstate NEW -m helper --helper ftp -m rateest
--rateest-delta --rateest1 eth0 --rateest-bps1 2.5mbit
--rateest-gt --rateest2 ppp0 <br>
--rateest-bps2 2mbit -j CONNMARK --set-mark 1</p>

<p style="margin-top: 1em">iptables -t mangle -A balance -m
conntrack --ctstate NEW -m helper --helper ftp -m rateest
--rateest-delta --rateest1 ppp0 --rateest-bps1 2mbit
--rateest-gt --rateest2 eth0 <br>
--rateest-bps2 2.5mbit -j CONNMARK --set-mark 2</p>

<p style="margin-top: 1em">iptables -t mangle -A balance -j
CONNMARK --restore-mark</p>

<p style="margin-top: 1em">realm (IPv4-specific) <br>
This matches the routing realm. Routing realms are used in
complex routing setups involving dynamic routing protocols
like BGP.</p>

<p style="margin-top: 1em">[!] --realm value[/mask] <br>
Matches a given realm number (and optionally mask). If not a
number, value can be a named realm from
/etc/iproute2/rt_realms (mask can not be used in that
case).</p>

<p style="margin-top: 1em">recent <br>
Allows you to dynamically create a list of IP addresses and
then match against that list in a few different ways.</p>

<p style="margin-top: 1em">For example, you can create a
&quot;badguy&quot; list out of people attempting to connect
to port 139 on your firewall and then DROP all future
packets from them without considering them.</p>

<p style="margin-top: 1em">--set, --rcheck, --update and
--remove are mutually exclusive.</p>

<p style="margin-top: 1em">--name name <br>
Specify the list to use for the commands. If no name is
given then DEFAULT will be used.</p>

<p style="margin-top: 1em">[!] --set <br>
This will add the source address of the packet to the list.
If the source address is already in the list, this will
update the existing entry. This will always return
suc&acirc; <br>
cess (or failure if ! is passed in).</p>

<p style="margin-top: 1em">--rsource <br>
Match/save the source address of each packet in the recent
list table. This is the default.</p>

<p style="margin-top: 1em">--rdest <br>
Match/save the destination address of each packet in the
recent list table.</p>

<p style="margin-top: 1em">--mask netmask <br>
Netmask that will be applied to this recent list.</p>

<p style="margin-top: 1em">[!] --rcheck <br>
Check if the source address of the packet is currently in
the list.</p>

<p style="margin-top: 1em">[!] --update <br>
Like --rcheck, except it will update the &quot;last
seen&quot; timestamp if it matches.</p>

<p style="margin-top: 1em">[!] --remove <br>
Check if the source address of the packet is currently in
the list and if so that address will be removed from the
list and the rule will return true. If the address is <br>
not found, false is returned.</p>

<p style="margin-top: 1em">--seconds seconds <br>
This option must be used in conjunction with one of --rcheck
or --update. When used, this will narrow the match to only
happen when the address is in the list and was seen <br>
within the last given number of seconds.</p>

<p style="margin-top: 1em">--reap This option can only be
used in conjunction with --seconds. When used, this will
cause entries older than the last given number of seconds to
be purged.</p>

<p style="margin-top: 1em">--hitcount hits <br>
This option must be used in conjunction with one of --rcheck
or --update. When used, this will narrow the match to only
happen when the address is in the list and packets <br>
had been received greater than or equal to the given value.
This option may be used along with --seconds to create an
even narrower match requiring a certain number of <br>
hits within a specific time frame. The maximum value for the
hitcount parameter is given by the
&quot;ip_pkt_list_tot&quot; parameter of the xt_recent
kernel module. Exceeding this <br>
value on the command line will cause the rule to be
rejected.</p>

<p style="margin-top: 1em">--rttl This option may only be
used in conjunction with one of --rcheck or --update. When
used, this will narrow the match to only happen when the
address is in the list and the <br>
TTL of the current packet matches that of the packet which
hit the --set rule. This may be useful if you have problems
with people faking their source address in order to <br>
DoS you via this module by disallowing others access to your
site by sending bogus packets to you.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">iptables -A FORWARD -m recent
--name badguy --rcheck --seconds 60 -j DROP</p>

<p style="margin-top: 1em">iptables -A FORWARD -p tcp -i
eth0 --dport 139 -m recent --name badguy --set -j DROP</p>

<p style="margin-top: 1em">/proc/net/xt_recent/* are the
current lists of addresses and information about each entry
of each list.</p>

<p style="margin-top: 1em">Each file in
/proc/net/xt_recent/ can be read from to see the current
list or written two using the following commands to modify
the list:</p>

<p style="margin-top: 1em">echo +addr
&gt;/proc/net/xt_recent/DEFAULT <br>
to add addr to the DEFAULT list</p>

<p style="margin-top: 1em">echo -addr
&gt;/proc/net/xt_recent/DEFAULT <br>
to remove addr from the DEFAULT list</p>

<p style="margin-top: 1em">echo /
&gt;/proc/net/xt_recent/DEFAULT <br>
to flush the DEFAULT list (remove all entries).</p>

<p style="margin-top: 1em">The module itself accepts
parameters, defaults shown:</p>

<p style="margin-top: 1em">ip_list_tot=100 <br>
Number of addresses remembered per table.</p>

<p style="margin-top: 1em">ip_pkt_list_tot=20 <br>
Number of packets per address remembered.</p>

<p style="margin-top: 1em">ip_list_hash_size=0 <br>
Hash table size. 0 means to calculate it based on
ip_list_tot, default: 512.</p>

<p style="margin-top: 1em">ip_list_perms=0644 <br>
Permissions for /proc/net/xt_recent/* files.</p>

<p style="margin-top: 1em">ip_list_uid=0 <br>
Numerical UID for ownership of /proc/net/xt_recent/*
files.</p>

<p style="margin-top: 1em">ip_list_gid=0 <br>
Numerical GID for ownership of /proc/net/xt_recent/*
files.</p>

<p style="margin-top: 1em">rpfilter <br>
Performs a reverse path filter test on a packet. If a reply
to the packet would be sent via the same interface that the
packet arrived on, the packet will match. Note that, <br>
unlike the in-kernel rp_filter, packets protected by IPSec
are not treated specially. Combine this match with the
policy match if you want this. Also, packets arriving via
the <br>
loopback interface are always permitted. This match can only
be used in the PREROUTING chain of the raw or mangle
table.</p>

<p style="margin-top: 1em">--loose <br>
Used to specifiy that the reverse path filter test should
match even if the selected output device is not the expected
one.</p>

<p style="margin-top: 1em">--validmark <br>
Also use the packets&rsquo; nfmark value when performing the
reverse path route lookup.</p>

<p style="margin-top: 1em">--accept-local <br>
This will permit packets arriving from the network with a
source address that is also assigned to the local
machine.</p>

<p style="margin-top: 1em">--invert <br>
This will invert the sense of the match. Instead of matching
packets that passed the reverse path filter test, match
those that have failed it.</p>

<p style="margin-top: 1em">Example to log and drop packets
failing the reverse path filter test:</p>

<p style="margin-top: 1em">iptables -t raw -N RPFILTER</p>

<p style="margin-top: 1em">iptables -t raw -A RPFILTER -m
rpfilter -j RETURN</p>

<p style="margin-top: 1em">iptables -t raw -A RPFILTER -m
limit --limit 10/minute -j NFLOG --nflog-prefix
&quot;rpfilter drop&quot;</p>

<p style="margin-top: 1em">iptables -t raw -A RPFILTER -j
DROP</p>

<p style="margin-top: 1em">iptables -t raw -A PREROUTING -j
RPFILTER</p>

<p style="margin-top: 1em">Example to drop failed packets,
without logging:</p>

<p style="margin-top: 1em">iptables -t raw -A RPFILTER -m
rpfilter --invert -j DROP</p>

<p style="margin-top: 1em">rt (IPv6-specific) <br>
Match on IPv6 routing header</p>

<p style="margin-top: 1em">[!] --rt-type type <br>
Match the type (numeric).</p>

<p style="margin-top: 1em">[!] --rt-segsleft num[:num] <br>
Match the &lsquo;segments left&rsquo; field (range).</p>

<p style="margin-top: 1em">[!] --rt-len length <br>
Match the length of this header.</p>

<p style="margin-top: 1em">--rt-0-res <br>
Match the reserved field, too (type=0)</p>

<p style="margin-top: 1em">--rt-0-addrs addr[,addr...] <br>
Match type=0 addresses (list).</p>

<p style="margin-top: 1em">--rt-0-not-strict <br>
List of type=0 addresses is not a strict list.</p>

<p style="margin-top: 1em">sctp <br>
[!] --source-port,--sport port[:port]</p>

<p style="margin-top: 1em">[!] --destination-port,--dport
port[:port]</p>

<p style="margin-top: 1em">[!] --chunk-types {all|any|only}
chunktype[:flags] [...] <br>
The flag letter in upper case indicates that the flag is to
match if set, in the lower case indicates to match if
unset.</p>

<p style="margin-top: 1em">Chunk types: DATA INIT INIT_ACK
SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK
ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR
SHUTDOWN_COMPLETE ASCONF ASCONF_ACK <br>
FORWARD_TSN</p>

<p style="margin-top: 1em">chunk type available flags <br>
DATA I U B E i u b e <br>
ABORT T t <br>
SHUTDOWN_COMPLETE T t</p>

<p style="margin-top: 1em">(lowercase means flag should be
&quot;off&quot;, uppercase means &quot;on&quot;)</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">iptables -A INPUT -p sctp
--dport 80 -j DROP</p>

<p style="margin-top: 1em">iptables -A INPUT -p sctp
--chunk-types any DATA,INIT -j DROP</p>

<p style="margin-top: 1em">iptables -A INPUT -p sctp
--chunk-types any DATA:Be -j ACCEPT</p>

<p style="margin-top: 1em">set <br>
This module matches IP sets which can be defined by
ipset(8).</p>

<p style="margin-top: 1em">[!] --match-set setname
flag[,flag]... <br>
where flags are the comma separated list of src and/or dst
specifications and there can be no more than six of them.
Hence the command</p>

<p style="margin-top: 1em">iptables -A FORWARD -m set
--match-set test src,dst</p>

<p style="margin-top: 1em">will match packets, for which
(if the set type is ipportmap) the source address and
destination port pair can be found in the specified set. If
the set type of the speci&acirc; <br>
fied set is single dimension (for example ipmap), then the
command will match packets for which the source address can
be found in the specified set.</p>

<p style="margin-top: 1em">--return-nomatch <br>
If the --return-nomatch option is specified and the set type
supports the nomatch flag, then the matching is reversed: a
match with an element flagged with nomatch returns <br>
true, while a match with a plain element returns false.</p>

<p style="margin-top: 1em">! --update-counters <br>
If the --update-counters flag is negated, then the packet
and byte counters of the matching element in the set
won&rsquo;t be updated. Default the packet and byte counters
are <br>
updated.</p>

<p style="margin-top: 1em">! --update-subcounters <br>
If the --update-subcounters flag is negated, then the packet
and byte counters of the matching element in the member set
of a list type of set won&rsquo;t be updated. Default <br>
the packet and byte counters are updated.</p>

<p style="margin-top: 1em">[!] --packets-eq value <br>
If the packet is matched an element in the set, match only
if the packet counter of the element matches the given value
too.</p>

<p style="margin-top: 1em">--packets-lt value <br>
If the packet is matched an element in the set, match only
if the packet counter of the element is less than the given
value as well.</p>

<p style="margin-top: 1em">--packets-gt value <br>
If the packet is matched an element in the set, match only
if the packet counter of the element is greater than the
given value as well.</p>

<p style="margin-top: 1em">[!] -bytes-eq value <br>
If the packet is matched an element in the set, match only
if the byte counter of the element matches the given value
too.</p>

<p style="margin-top: 1em">--bytes-lt value <br>
If the packet is matched an element in the set, match only
if the byte counter of the element is less than the given
value as well.</p>

<p style="margin-top: 1em">--bytes-gt value <br>
If the packet is matched an element in the set, match only
if the byte counter of the element is greater than the given
value as well.</p>

<p style="margin-top: 1em">The packet and byte counters
related options and flags are ignored when the set was
defined without counter support.</p>

<p style="margin-top: 1em">The option --match-set can be
replaced by --set if that does not clash with an option of
other extensions.</p>

<p style="margin-top: 1em">Use of -m set requires that
ipset kernel support is provided, which, for standard
kernels, is the case since Linux 2.6.39.</p>

<p style="margin-top: 1em">socket <br>
This matches if an open TCP/UDP socket can be found by doing
a socket lookup on the packet. It matches if there is an
established or non-zero bound listening socket (possibly
<br>
with a non-local address). The lookup is performed using the
packet tuple of TCP/UDP packets, or the original TCP/UDP
header embedded in an ICMP/ICPMv6 error packet.</p>

<p style="margin-top: 1em">--transparent <br>
Ignore non-transparent sockets.</p>

<p style="margin-top: 1em">--nowildcard <br>
Do not ignore sockets bound to &rsquo;any&rsquo; address.
The socket match won&rsquo;t accept zero-bound listeners by
default, since then local services could intercept traffic
that would <br>
otherwise be forwarded. This option therefore has security
implications when used to match traffic being forwarded to
redirect such packets to local machine with policy <br>
routing. When using the socket match to implement fully
transparent proxies bound to non-local addresses it is
recommended to use the --transparent option instead.</p>

<p style="margin-top: 1em">Example (assuming packets with
mark 1 are delivered locally):</p>

<p style="margin-top: 1em">-t mangle -A PREROUTING -m
socket --transparent -j MARK --set-mark 1</p>

<p style="margin-top: 1em">state <br>
The &quot;state&quot; extension is a subset of the
&quot;conntrack&quot; module. &quot;state&quot; allows
access to the connection tracking state for this packet.</p>

<p style="margin-top: 1em">[!] --state state <br>
Where state is a comma separated list of the connection
states to match. Only a subset of the states unterstood by
&quot;conntrack&quot; are recognized: INVALID, ESTABLISHED,
NEW, <br>
RELATED or UNTRACKED. For their description, see the
&quot;conntrack&quot; heading in this manpage.</p>

<p style="margin-top: 1em">statistic <br>
This module matches packets based on some statistic
condition. It supports two distinct modes settable with the
--mode option.</p>

<p style="margin-top: 1em">Supported options:</p>

<p style="margin-top: 1em">--mode mode <br>
Set the matching mode of the matching rule, supported modes
are random and nth.</p>

<p style="margin-top: 1em">[!] --probability p <br>
Set the probability for a packet to be randomly matched. It
only works with the random mode. p must be within 0.0 and
1.0. The supported granularity is in 1/2147483648th <br>
increments.</p>

<p style="margin-top: 1em">[!] --every n <br>
Match one packet every nth packet. It works only with the
nth mode (see also the --packet option).</p>

<p style="margin-top: 1em">--packet p <br>
Set the initial counter value (0 &lt;= p &lt;= n-1, default
0) for the nth mode.</p>

<p style="margin-top: 1em">string <br>
This modules matches a given string by using some pattern
matching strategy. It requires a linux kernel &gt;=
2.6.14.</p>

<p style="margin-top: 1em">--algo {bm|kmp} <br>
Select the pattern matching strategy. (bm = Boyer-Moore, kmp
= Knuth-Pratt-Morris)</p>

<p style="margin-top: 1em">--from offset <br>
Set the offset from which it starts looking for any
matching. If not passed, default is 0.</p>

<p style="margin-top: 1em">--to offset <br>
Set the offset up to which should be scanned. That is, byte
offset-1 (counting from 0) is the last one that is scanned.
If not passed, default is the packet size.</p>

<p style="margin-top: 1em">[!] --string pattern <br>
Matches the given pattern.</p>

<p style="margin-top: 1em">[!] --hex-string pattern <br>
Matches the given pattern in hex notation.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># The string pattern can be used
for simple text characters. <br>
iptables -A INPUT -p tcp --dport 80 -m string --algo bm
--string &rsquo;GET /index.html&rsquo; -j LOG</p>

<p style="margin-top: 1em"># The hex string pattern can be
used for non-printable characters, like |0D 0A| or |0D0A|.
<br>
iptables -p udp --dport 53 -m string --algo bm --from 40
--to 57 --hex-string
&rsquo;|03|www|09|netfilter|03|org|00|&rsquo;</p>

<p style="margin-top: 1em">tcp <br>
These extensions can be used if &lsquo;--protocol tcp&rsquo;
is specified. It provides the following options:</p>

<p style="margin-top: 1em">[!] --source-port,--sport
port[:port] <br>
Source port or port range specification. This can either be
a service name or a port number. An inclusive range can also
be specified, using the format first:last. If the <br>
first port is omitted, &quot;0&quot; is assumed; if the last
is omitted, &quot;65535&quot; is assumed. If the first port
is greater than the second one they will be swapped. The
flag <br>
--sport is a convenient alias for this option.</p>

<p style="margin-top: 1em">[!] --destination-port,--dport
port[:port] <br>
Destination port or port range specification. The flag
--dport is a convenient alias for this option.</p>

<p style="margin-top: 1em">[!] --tcp-flags mask comp <br>
Match when the TCP flags are as specified. The first
argument mask is the flags which we should examine, written
as a comma-separated list, and the second argument comp <br>
is a comma-separated list of flags which must be set. Flags
are: SYN ACK FIN RST URG PSH ALL NONE. Hence the command
<br>
iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
<br>
will only match packets with the SYN flag set, and the ACK,
FIN and RST flags unset.</p>

<p style="margin-top: 1em">[!] --syn <br>
Only match TCP packets with the SYN bit set and the ACK,RST
and FIN bits cleared. Such packets are used to request TCP
connection initiation; for example, blocking such <br>
packets coming in an interface will prevent incoming TCP
connections, but outgoing TCP connections will be
unaffected. It is equivalent to --tcp-flags SYN,RST,ACK,FIN
<br>
SYN. If the &quot;!&quot; flag precedes the
&quot;--syn&quot;, the sense of the option is inverted.</p>

<p style="margin-top: 1em">[!] --tcp-option number <br>
Match if TCP option set.</p>

<p style="margin-top: 1em">tcpmss <br>
This matches the TCP MSS (maximum segment size) field of the
TCP header. You can only use this on TCP SYN or SYN/ACK
packets, since the MSS is only negotiated during the TCP
<br>
handshake at connection startup time.</p>

<p style="margin-top: 1em">[!] --mss value[:value] <br>
Match a given TCP MSS value or range.</p>

<p style="margin-top: 1em">time <br>
This matches if the packet arrival time/date is within a
given range. All options are optional, but are ANDed when
specified. All times are interpreted as UTC by default.</p>

<p style="margin-top: 1em">--datestart
YYYY[-MM[-DD[Thh[:mm[:ss]]]]]</p>

<p style="margin-top: 1em">--datestop
YYYY[-MM[-DD[Thh[:mm[:ss]]]]] <br>
Only match during the given time, which must be in ISO 8601
&quot;T&quot; notation. The possible time range is
1970-01-01T00:00:00 to 2038-01-19T04:17:07.</p>

<p style="margin-top: 1em">If --datestart or --datestop are
not specified, it will default to 1970-01-01 and 2038-01-19,
respectively.</p>

<p style="margin-top: 1em">--timestart hh:mm[:ss]</p>

<p style="margin-top: 1em">--timestop hh:mm[:ss] <br>
Only match during the given daytime. The possible time range
is 00:00:00 to 23:59:59. Leading zeroes are allowed (e.g.
&quot;06:03&quot;) and correctly interpreted as base-10.</p>

<p style="margin-top: 1em">[!] --monthdays day[,day...]
<br>
Only match on the given days of the month. Possible values
are 1 to 31. Note that specifying 31 will of course not
match on months which do not have a 31st day; the same <br>
goes for 28- or 29-day February.</p>

<p style="margin-top: 1em">[!] --weekdays day[,day...] <br>
Only match on the given weekdays. Possible values are Mon,
Tue, Wed, Thu, Fri, Sat, Sun, or values from 1 to 7,
respectively. You may also use two-character variants (Mo,
<br>
Tu, etc.).</p>

<p style="margin-top: 1em">--contiguous <br>
When --timestop is smaller than --timestart value, match
this as a single time period instead distinct intervals. See
EXAMPLES.</p>

<p style="margin-top: 1em">--kerneltz <br>
Use the kernel timezone instead of UTC to determine whether
a packet meets the time regulations.</p>

<p style="margin-top: 1em">About kernel timezones: Linux
keeps the system time in UTC, and always does so. On boot,
system time is initialized from a referential time source.
Where this time source has no <br>
timezone information, such as the x86 CMOS RTC, UTC will be
assumed. If the time source is however not in UTC, userspace
should provide the correct system time and timezone to <br>
the kernel once it has the information.</p>

<p style="margin-top: 1em">Local time is a feature on top
of the (timezone independent) system time. Each process has
its own idea of local time, specified via the TZ environment
variable. The kernel also <br>
has its own timezone offset variable. The TZ userspace
environment variable specifies how the UTC-based system time
is displayed, e.g. when you run date(1), or what you see on
<br>
your desktop clock. The TZ string may resolve to different
offsets at different dates, which is what enables the
automatic time-jumping in userspace. when DST changes. The
ker&acirc; <br>
nel&rsquo;s timezone offset variable is used when it has to
convert between non-UTC sources, such as FAT filesystems, to
UTC (since the latter is what the rest of the system
uses).</p>

<p style="margin-top: 1em">The caveat with the kernel
timezone is that Linux distributions may ignore to set the
kernel timezone, and instead only set the system time. Even
if a particular distribution <br>
does set the timezone at boot, it is usually does not keep
the kernel timezone offset - which is what changes on DST -
up to date. ntpd will not touch the kernel timezone, so <br>
running it will not resolve the issue. As such, one may
encounter a timezone that is always +0000, or one that is
wrong half of the time of the year. As such, using
--kerneltz is <br>
highly discouraged.</p>

<p style="margin-top: 1em">EXAMPLES. To match on weekends,
use:</p>

<p style="margin-top: 1em">-m time --weekdays Sa,Su</p>

<p style="margin-top: 1em">Or, to match (once) on a
national holiday block:</p>

<p style="margin-top: 1em">-m time --datestart 2007-12-24
--datestop 2007-12-27</p>

<p style="margin-top: 1em">Since the stop time is actually
inclusive, you would need the following stop time to not
match the first second of the new day:</p>

<p style="margin-top: 1em">-m time --datestart
2007-01-01T17:00 --datestop 2007-01-01T23:59:59</p>

<p style="margin-top: 1em">During lunch hour:</p>

<p style="margin-top: 1em">-m time --timestart 12:30
--timestop 13:30</p>

<p style="margin-top: 1em">The fourth Friday in the
month:</p>

<p style="margin-top: 1em">-m time --weekdays Fr
--monthdays 22,23,24,25,26,27,28</p>

<p style="margin-top: 1em">(Note that this exploits a
certain mathematical property. It is not possible to say
&quot;fourth Thursday OR fourth Friday&quot; in one rule. It
is possible with multiple rules, though.)</p>

<p style="margin-top: 1em">Matching across days might not
do what is expected. For instance,</p>

<p style="margin-top: 1em">-m time --weekdays Mo
--timestart 23:00 --timestop 01:00 Will match Monday, for
one hour from midnight to 1 a.m., and then again for another
hour from 23:00 onwards. If <br>
this is unwanted, e.g. if you would like &rsquo;match for
two hours from Montay 23:00 onwards&rsquo; you need to also
specify the --contiguous option in the example above.</p>

<p style="margin-top: 1em">tos <br>
This module matches the 8-bit Type of Service field in the
IPv4 header (i.e. including the &quot;Precedence&quot; bits)
or the (also 8-bit) Priority field in the IPv6 header.</p>

<p style="margin-top: 1em">[!] --tos value[/mask] <br>
Matches packets with the given TOS mark value. If a mask is
specified, it is logically ANDed with the TOS mark before
the comparison.</p>

<p style="margin-top: 1em">[!] --tos symbol <br>
You can specify a symbolic name when using the tos match for
IPv4. The list of recognized TOS names can be obtained by
calling iptables with -m tos -h. Note that this <br>
implies a mask of 0x3F, i.e. all but the ECN bits.</p>

<p style="margin-top: 1em">ttl (IPv4-specific) <br>
This module matches the time to live field in the IP
header.</p>

<p style="margin-top: 1em">[!] --ttl-eq ttl <br>
Matches the given TTL value.</p>

<p style="margin-top: 1em">--ttl-gt ttl <br>
Matches if TTL is greater than the given TTL value.</p>

<p style="margin-top: 1em">--ttl-lt ttl <br>
Matches if TTL is less than the given TTL value.</p>

<p style="margin-top: 1em">u32 <br>
U32 tests whether quantities of up to 4 bytes extracted from
a packet have specified values. The specification of what to
extract is general enough to find data at given offsets <br>
from tcp headers or payloads.</p>

<p style="margin-top: 1em">[!] --u32 tests <br>
The argument amounts to a program in a small language
described below.</p>

<p style="margin-top: 1em">tests := location &quot;=&quot;
value | tests &quot;&amp;&amp;&quot; location &quot;=&quot;
value</p>

<p style="margin-top: 1em">value := range | value
&quot;,&quot; range</p>

<p style="margin-top: 1em">range := number | number
&quot;:&quot; number</p>

<p style="margin-top: 1em">a single number, n, is
interpreted the same as n:n. n:m is interpreted as the range
of numbers &gt;=n and &lt;=m.</p>

<p style="margin-top: 1em">location := number | location
operator number</p>

<p style="margin-top: 1em">operator := &quot;&amp;&quot; |
&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; |
&quot;@&quot;</p>

<p style="margin-top: 1em">The operators &amp;, &lt;&lt;,
&gt;&gt; and &amp;&amp; mean the same as in C. The = is
really a set membership operator and the value syntax
describes a set. The @ operator is what allows moving to the
<br>
next header and is described further below.</p>

<p style="margin-top: 1em">There are currently some
artificial implementation limits on the size of the
tests:</p>

<p style="margin-top: 1em">* no more than 10 of
&quot;=&quot; (and 9 &quot;&amp;&amp;&quot;s) in the u32
argument</p>

<p style="margin-top: 1em">* no more than 10 ranges (and 9
commas) per value</p>

<p style="margin-top: 1em">* no more than 10 numbers (and 9
operators) per location</p>

<p style="margin-top: 1em">To describe the meaning of
location, imagine the following machine that interprets it.
There are three registers:</p>

<p style="margin-top: 1em">A is of type char *, initially
the address of the IP header</p>

<p style="margin-top: 1em">B and C are unsigned 32 bit
integers, initially zero</p>

<p style="margin-top: 1em">The instructions are:</p>

<p style="margin-top: 1em">number B = number;</p>

<p style="margin-top: 1em">C = (*(A+B)&lt;&lt;24) +
(*(A+B+1)&lt;&lt;16) + (*(A+B+2)&lt;&lt;8) + *(A+B+3)</p>

<p style="margin-top: 1em">&amp;number C = C &amp;
number</p>

<p style="margin-top: 1em">&lt;&lt; number C = C &lt;&lt;
number</p>

<p style="margin-top: 1em">&gt;&gt; number C = C &gt;&gt;
number</p>

<p style="margin-top: 1em">@number A = A + C; then do the
instruction number</p>

<p style="margin-top: 1em">Any access of memory outside
[skb-&gt;data,skb-&gt;end] causes the match to fail.
Otherwise the result of the computation is the final value
of C.</p>

<p style="margin-top: 1em">Whitespace is allowed but not
required in the tests. However, the characters that do occur
there are likely to require shell quoting, so it is a good
idea to enclose the argu&acirc; <br>
ments in quotes.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">match IP packets with total
length &gt;= 256</p>

<p style="margin-top: 1em">The IP header contains a total
length field in bytes 2-3.</p>

<p style="margin-top: 1em">--u32 &quot;0 &amp; 0xFFFF =
0x100:0xFFFF&quot;</p>

<p style="margin-top: 1em">read bytes 0-3</p>

<p style="margin-top: 1em">AND that with 0xFFFF (giving
bytes 2-3), and test whether that is in the range
[0x100:0xFFFF]</p>

<p style="margin-top: 1em">Example: (more realistic, hence
more complicated)</p>

<p style="margin-top: 1em">match ICMP packets with icmp
type 0</p>

<p style="margin-top: 1em">First test that it is an ICMP
packet, true iff byte 9 (protocol) = 1</p>

<p style="margin-top: 1em">--u32 &quot;6 &amp; 0xFF = 1
&amp;&amp; ...</p>

<p style="margin-top: 1em">read bytes 6-9, use &amp; to
throw away bytes 6-8 and compare the result to 1. Next test
that it is not a fragment. (If so, it might be part of such
a packet but we cannot <br>
always tell.) N.B.: This test is generally needed if you
want to match anything beyond the IP header. The last 6 bits
of byte 6 and all of byte 7 are 0 iff this is a com&acirc;
<br>
plete packet (not a fragment). Alternatively, you can allow
first fragments by only testing the last 5 bits of byte
6.</p>

<p style="margin-top: 1em">... 4 &amp; 0x3FFF = 0
&amp;&amp; ...</p>

<p style="margin-top: 1em">Last test: the first byte past
the IP header (the type) is 0. This is where we have to use
the @syntax. The length of the IP header (IHL) in 32 bit
words is stored in the <br>
right half of byte 0 of the IP header itself.</p>

<p style="margin-top: 1em">... 0 &gt;&gt; 22 &amp; 0x3C @ 0
&gt;&gt; 24 = 0&quot;</p>

<p style="margin-top: 1em">The first 0 means read bytes
0-3, &gt;&gt;22 means shift that 22 bits to the right.
Shifting 24 bits would give the first byte, so only 22 bits
is four times that plus a few <br>
more bits. &amp;3C then eliminates the two extra bits on the
right and the first four bits of the first byte. For
instance, if IHL=5, then the IP header is 20 (4 x 5) bytes
<br>
long. In this case, bytes 0-1 are (in binary) xxxx0101
yyzzzzzz, &gt;&gt;22 gives the 10 bit value xxxx0101yy and
&amp;3C gives 010100. @ means to use this number as a new
offset <br>
into the packet, and read four bytes starting from there.
This is the first 4 bytes of the ICMP payload, of which byte
0 is the ICMP type. Therefore, we simply shift the <br>
value 24 to the right to throw out all but the first byte
and compare the result with 0.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">TCP payload bytes 8-12 is any of
1, 2, 5 or 8</p>

<p style="margin-top: 1em">First we test that the packet is
a tcp packet (similar to ICMP).</p>

<p style="margin-top: 1em">--u32 &quot;6 &amp; 0xFF = 6
&amp;&amp; ...</p>

<p style="margin-top: 1em">Next, test that it is not a
fragment (same as above).</p>

<p style="margin-top: 1em">... 0 &gt;&gt; 22 &amp; 0x3C @
12 &gt;&gt; 26 &amp; 0x3C @ 8 = 1,2,5,8&quot;</p>

<p style="margin-top: 1em">0&gt;&gt;22&amp;3C as above
computes the number of bytes in the IP header. @ makes this
the new offset into the packet, which is the start of the
TCP header. The length of the TCP <br>
header (again in 32 bit words) is the left half of byte 12
of the TCP header. The 12&gt;&gt;26&amp;3C computes this
length in bytes (similar to the IP header before).
&quot;@&quot; makes this <br>
the new offset, which is the start of the TCP payload.
Finally, 8 reads bytes 8-12 of the payload and = checks
whether the result is any of 1, 2, 5 or 8.</p>

<p style="margin-top: 1em">udp <br>
These extensions can be used if &lsquo;--protocol udp&rsquo;
is specified. It provides the following options:</p>

<p style="margin-top: 1em">[!] --source-port,--sport
port[:port] <br>
Source port or port range specification. See the description
of the --source-port option of the TCP extension for
details.</p>

<p style="margin-top: 1em">[!] --destination-port,--dport
port[:port] <br>
Destination port or port range specification. See the
description of the --destination-port option of the TCP
extension for details.</p>

<p style="margin-top: 1em">unclean (IPv4-specific) <br>
This module takes no options, but attempts to match packets
which seem malformed or unusual. This is regarded as
experimental.</p>

<p style="margin-top: 1em">TARGET EXTENSIONS <br>
iptables can use extended target modules: the following are
included in the standard distribution.</p>

<p style="margin-top: 1em">AUDIT <br>
This target allows to create audit records for packets
hitting the target. It can be used to record accepted,
dropped, and rejected packets. See auditd(8) for additional
<br>
details.</p>

<p style="margin-top: 1em">--type {accept|drop|reject} <br>
Set type of audit record.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">iptables -N AUDIT_DROP</p>

<p style="margin-top: 1em">iptables -A AUDIT_DROP -j AUDIT
--type drop</p>

<p style="margin-top: 1em">iptables -A AUDIT_DROP -j
DROP</p>

<p style="margin-top: 1em">CHECKSUM <br>
This target allows to selectively work around broken/old
applications. It can only be used in the mangle table.</p>

<p style="margin-top: 1em">--checksum-fill <br>
Compute and fill in the checksum in a packet that lacks a
checksum. This is particularly useful, if you need to work
around old applications such as dhcp clients, that do <br>
not work well with checksum offloads, but don&rsquo;t want
to disable checksum offload in your device.</p>

<p style="margin-top: 1em">CLASSIFY <br>
This module allows you to set the skb-&gt;priority value
(and thus classify the packet into a specific CBQ
class).</p>

<p style="margin-top: 1em">--set-class major:minor <br>
Set the major and minor class value. The values are always
interpreted as hexadecimal even if no 0x prefix is
given.</p>

<p style="margin-top: 1em">CLUSTERIP (IPv4-specific) <br>
This module allows you to configure a simple cluster of
nodes that share a certain IP and MAC address without an
explicit load balancer in front of them. Connections are
stati&acirc; <br>
cally distributed between the nodes in this cluster.</p>

<p style="margin-top: 1em">--new Create a new ClusterIP.
You always have to set this on the first rule for a given
ClusterIP.</p>

<p style="margin-top: 1em">--hashmode mode <br>
Specify the hashing mode. Has to be one of sourceip,
sourceip-sourceport, sourceip-sourceport-destport.</p>

<p style="margin-top: 1em">--clustermac mac <br>
Specify the ClusterIP MAC address. Has to be a link-layer
multicast address</p>

<p style="margin-top: 1em">--total-nodes num <br>
Number of total nodes within this cluster.</p>

<p style="margin-top: 1em">--local-node num <br>
Local node number within this cluster.</p>

<p style="margin-top: 1em">--hash-init rnd <br>
Specify the random seed used for hash initialization.</p>

<p style="margin-top: 1em">CONNMARK <br>
This module sets the netfilter mark value associated with a
connection. The mark is 32 bits wide.</p>

<p style="margin-top: 1em">--set-xmark value[/mask] <br>
Zero out the bits given by mask and XOR value into the
ctmark.</p>

<p style="margin-top: 1em">--save-mark [--nfmask nfmask]
[--ctmask ctmask] <br>
Copy the packet mark (nfmark) to the connection mark
(ctmark) using the given masks. The new nfmark value is
determined as follows:</p>

<p style="margin-top: 1em">ctmark = (ctmark &amp; ~ctmask)
^ (nfmark &amp; nfmask)</p>

<p style="margin-top: 1em">i.e. ctmask defines what bits to
clear and nfmask what bits of the nfmark to XOR into the
ctmark. ctmask and nfmask default to 0xFFFFFFFF.</p>

<p style="margin-top: 1em">--restore-mark [--nfmask nfmask]
[--ctmask ctmask] <br>
Copy the connection mark (ctmark) to the packet mark
(nfmark) using the given masks. The new ctmark value is
determined as follows:</p>

<p style="margin-top: 1em">nfmark = (nfmark &amp; ~nfmask)
^ (ctmark &amp; ctmask);</p>

<p style="margin-top: 1em">i.e. nfmask defines what bits to
clear and ctmask what bits of the ctmark to XOR into the
nfmark. ctmask and nfmask default to 0xFFFFFFFF.</p>

<p style="margin-top: 1em">--restore-mark is only valid in
the mangle table.</p>

<p style="margin-top: 1em">The following mnemonics are
available for --set-xmark:</p>

<p style="margin-top: 1em">--and-mark bits <br>
Binary AND the ctmark with bits. (Mnemonic for --set-xmark
0/invbits, where invbits is the binary negation of
bits.)</p>

<p style="margin-top: 1em">--or-mark bits <br>
Binary OR the ctmark with bits. (Mnemonic for --set-xmark
bits/bits.)</p>

<p style="margin-top: 1em">--xor-mark bits <br>
Binary XOR the ctmark with bits. (Mnemonic for --set-xmark
bits/0.)</p>

<p style="margin-top: 1em">--set-mark value[/mask] <br>
Set the connection mark. If a mask is specified then only
those bits set in the mask are modified.</p>

<p style="margin-top: 1em">--save-mark [--mask mask] <br>
Copy the nfmark to the ctmark. If a mask is specified, only
those bits are copied.</p>

<p style="margin-top: 1em">--restore-mark [--mask mask]
<br>
Copy the ctmark to the nfmark. If a mask is specified, only
those bits are copied. This is only valid in the mangle
table.</p>

<p style="margin-top: 1em">CONNSECMARK <br>
This module copies security markings from packets to
connections (if unlabeled), and from connections back to
packets (also only if unlabeled). Typically used in
conjunction <br>
with SECMARK, it is valid in the security table (for
backwards compatibility with older kernels, it is also valid
in the mangle table).</p>

<p style="margin-top: 1em">--save If the packet has a
security marking, copy it to the connection if the
connection is not marked.</p>

<p style="margin-top: 1em">--restore <br>
If the packet does not have a security marking, and the
connection does, copy the security marking from the
connection to the packet.</p>

<p style="margin-top: 1em">CT <br>
The CT target allows to set parameters for a packet or its
associated connection. The target attaches a
&quot;template&quot; connection tracking entry to the
packet, which is then used by <br>
the conntrack core when initializing a new ct entry. This
target is thus only valid in the &quot;raw&quot; table.</p>

<p style="margin-top: 1em">--notrack <br>
Disables connection tracking for this packet.</p>

<p style="margin-top: 1em">--helper name <br>
Use the helper identified by name for the connection. This
is more flexible than loading the conntrack helper modules
with preset ports.</p>

<p style="margin-top: 1em">--ctevents event[,...] <br>
Only generate the specified conntrack events for this
connection. Possible event types are: new, related, destroy,
reply, assured, protoinfo, helper, mark (this refers to <br>
the ctmark, not nfmark), natseqinfo, secmark
(ctsecmark).</p>

<p style="margin-top: 1em">--expevents event[,...] <br>
Only generate the specified expectation events for this
connection. Possible event types are: new.</p>

<p style="margin-top: 1em">--zone id <br>
Assign this packet to zone id and only have lookups done in
that zone. By default, packets have zone 0.</p>

<p style="margin-top: 1em">--timeout name <br>
Use the timeout policy identified by name for the
connection. This is provides more flexible timeout policy
definition than global timeout values available at <br>
/proc/sys/net/netfilter/nf_conntrack_*_timeout_*.</p>

<p style="margin-top: 1em">DNAT <br>
This target is only valid in the nat table, in the
PREROUTING and OUTPUT chains, and user-defined chains which
are only called from those chains. It specifies that the
destina&acirc; <br>
tion address of the packet should be modified (and all
future packets in this connection will also be mangled), and
rules should cease being examined. It takes the following
<br>
options:</p>

<p style="margin-top: 1em">--to-destination
[ipaddr[-ipaddr]][:port[-port]] <br>
which can specify a single new destination IP address, an
inclusive range of IP addresses. Optionally a port range, if
the rule also specifies one of the following proto&acirc;
<br>
cols: tcp, udp, dccp or sctp. If no port range is specified,
then the destination port will never be modified. If no IP
address is specified then only the destination <br>
port will be modified. In Kernels up to 2.6.10 you can add
several --to-destination options. For those kernels, if you
specify more than one destination address, either <br>
via an address range or multiple --to-destination options, a
simple round-robin (one after another in cycle) load
balancing takes place between these addresses. Later <br>
Kernels (&gt;= 2.6.11-rc1) don&rsquo;t have the ability to
NAT to multiple ranges anymore.</p>

<p style="margin-top: 1em">--random <br>
If option --random is used then port mapping will be
randomized (kernel &gt;= 2.6.22).</p>

<p style="margin-top: 1em">--persistent <br>
Gives a client the same source-/destination-address for each
connection. This supersedes the SAME target. Support for
persistent mappings is available from 2.6.29-rc2.</p>

<p style="margin-top: 1em">IPv6 support available since
Linux kernels &gt;= 3.7.</p>

<p style="margin-top: 1em">DNPT (IPv6-specific) <br>
Provides stateless destination IPv6-to-IPv6 Network Prefix
Translation (as described by RFC 6296).</p>

<p style="margin-top: 1em">You have to use this target in
the mangle table, not in the nat table. It takes the
following options:</p>

<p style="margin-top: 1em">--src-pfx [prefix/length] <br>
Set source prefix that you want to translate and length</p>

<p style="margin-top: 1em">--dst-pfx [prefix/length] <br>
Set destination prefix that you want to use in the
translation and length</p>

<p style="margin-top: 1em">You have to use the SNPT target
to undo the translation. Example:</p>

<p style="margin-top: 1em">ip6tables -t mangle -I
POSTROUTING -s fd00::/64 -o vboxnet0 -j SNPT --src-pfx
fd00::/64 --dst-pfx 2001:e20:2000:40f::/64</p>

<p style="margin-top: 1em">ip6tables -t mangle -I
PREROUTING -i wlan0 -d 2001:e20:2000:40f::/64 -j DNPT
--src-pfx 2001:e20:2000:40f::/64 --dst-pfx fd00::/64</p>

<p style="margin-top: 1em">You may need to enable IPv6
neighbor proxy:</p>

<p style="margin-top: 1em">sysctl -w
net.ipv6.conf.all.proxy_ndp=1</p>

<p style="margin-top: 1em">You also have to use the NOTRACK
target to disable connection tracking for translated
flows.</p>

<p style="margin-top: 1em">DSCP <br>
This target allows to alter the value of the DSCP bits
within the TOS header of the IPv4 packet. As this
manipulates a packet, it can only be used in the mangle
table.</p>

<p style="margin-top: 1em">--set-dscp value <br>
Set the DSCP field to a numerical value (can be decimal or
hex)</p>

<p style="margin-top: 1em">--set-dscp-class class <br>
Set the DSCP field to a DiffServ class.</p>

<p style="margin-top: 1em">ECN (IPv4-specific) <br>
This target allows to selectively work around known ECN
blackholes. It can only be used in the mangle table.</p>

<p style="margin-top: 1em">--ecn-tcp-remove <br>
Remove all ECN bits from the TCP header. Of course, it can
only be used in conjunction with -p tcp.</p>

<p style="margin-top: 1em">HL (IPv6-specific) <br>
This is used to modify the Hop Limit field in IPv6 header.
The Hop Limit field is similar to what is known as TTL value
in IPv4. Setting or incrementing the Hop Limit field can
<br>
potentially be very dangerous, so it should be avoided at
any cost. This target is only valid in mangle table.</p>

<p style="margin-top: 1em">Don&rsquo;t ever set or
increment the value on packets that leave your local
network!</p>

<p style="margin-top: 1em">--hl-set value <br>
Set the Hop Limit to &lsquo;value&rsquo;.</p>

<p style="margin-top: 1em">--hl-dec value <br>
Decrement the Hop Limit &lsquo;value&rsquo; times.</p>

<p style="margin-top: 1em">--hl-inc value <br>
Increment the Hop Limit &lsquo;value&rsquo; times.</p>

<p style="margin-top: 1em">HMARK <br>
Like MARK, i.e. set the fwmark, but the mark is calculated
from hashing packet selector at choice. You have also to
specify the mark range and, optionally, the offset to start
<br>
from. ICMP error messages are inspected and used to
calculate the hashing.</p>

<p style="margin-top: 1em">Existing options are:</p>

<p style="margin-top: 1em">--hmark-tuple tuple <br>
Possible tuple members are: src meaning source address
(IPv4, IPv6 address), dst meaning destination address (IPv4,
IPv6 address), sport meaning source port (TCP, UDP, <br>
UDPlite, SCTP, DCCP), dport meaning destination port (TCP,
UDP, UDPlite, SCTP, DCCP), spi meaning Security Parameter
Index (AH, ESP), and ct meaning the usage of the con&acirc;
<br>
ntrack tuple instead of the packet selectors.</p>

<p style="margin-top: 1em">--hmark-mod value (must be &gt;
0) <br>
Modulus for hash calculation (to limit the range of possible
marks)</p>

<p style="margin-top: 1em">--hmark-offset value <br>
Offset to start marks from.</p>

<p style="margin-top: 1em">For advanced usage, instead of
using --hmark-tuple, you can specify custom <br>
prefixes and masks:</p>

<p style="margin-top: 1em">--hmark-src-prefix cidr <br>
The source address mask in CIDR notation.</p>

<p style="margin-top: 1em">--hmark-dst-prefix cidr <br>
The destination address mask in CIDR notation.</p>

<p style="margin-top: 1em">--hmark-sport-mask value <br>
A 16 bit source port mask in hexadecimal.</p>

<p style="margin-top: 1em">--hmark-dport-mask value <br>
A 16 bit destination port mask in hexadecimal.</p>

<p style="margin-top: 1em">--hmark-spi-mask value <br>
A 32 bit field with spi mask.</p>

<p style="margin-top: 1em">--hmark-proto-mask value <br>
An 8 bit field with layer 4 protocol number.</p>

<p style="margin-top: 1em">--hmark-rnd value <br>
A 32 bit random custom value to feed hash calculation.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">iptables -t mangle -A PREROUTING
-m conntrack --ctstate NEW <br>
-j HMARK --hmark-tuple ct,src,dst,proto --hmark-offset 10000
--hmark-mod 10 --hmark-rnd 0xfeedcafe</p>

<p style="margin-top: 1em">iptables -t mangle -A PREROUTING
-j HMARK --hmark-offset 10000 --hmark-tuple src,dst,proto
--hmark-mod 10 --hmark-rnd 0xdeafbeef</p>

<p style="margin-top: 1em">IDLETIMER <br>
This target can be used to identify when interfaces have
been idle for a certain period of time. Timers are
identified by labels and are created when a rule is set with
a new <br>
label. The rules also take a timeout value (in seconds) as
an option. If more than one rule uses the same timer label,
the timer will be restarted whenever any of the rules get
<br>
a hit. One entry for each timer is created in sysfs. This
attribute contains the timer remaining for the timer to
expire. The attributes are located under the xt_idletimer
<br>
class:</p>


<p style="margin-top: 1em">/sys/class/xt_idletimer/timers/&lt;label&gt;</p>

<p style="margin-top: 1em">When the timer expires, the
target module sends a sysfs notification to the userspace,
which can then decide what to do (eg. disconnect to save
power).</p>

<p style="margin-top: 1em">--timeout amount <br>
This is the time in seconds that will trigger the
notification.</p>

<p style="margin-top: 1em">--label string <br>
This is a unique identifier for the timer. The maximum
length for the label string is 27 characters.</p>

<p style="margin-top: 1em">LED <br>
This creates an LED-trigger that can then be attached to
system indicator lights, to blink or illuminate them when
certain packets pass through the system. One example might
be <br>
to light up an LED for a few minutes every time an SSH
connection is made to the local machine. The following
options control the trigger behavior:</p>

<p style="margin-top: 1em">--led-trigger-id name <br>
This is the name given to the LED trigger. The actual name
of the trigger will be prefixed with
&quot;netfilter-&quot;.</p>

<p style="margin-top: 1em">--led-delay ms <br>
This indicates how long (in milliseconds) the LED should be
left illuminated when a packet arrives before being switched
off again. The default is 0 (blink as fast as pos&acirc;
<br>
sible.) The special value inf can be given to leave the LED
on permanently once activated. (In this case the trigger
will need to be manually detached and reattached to <br>
the LED device to switch it off again.)</p>

<p style="margin-top: 1em">--led-always-blink <br>
Always make the LED blink on packet arrival, even if the LED
is already on. This allows notification of new packets even
with long delay values (which otherwise would <br>
result in a silent prolonging of the delay time.)</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">Create an LED trigger for
incoming SSH traffic: <br>
iptables -A INPUT -p tcp --dport 22 -j LED --led-trigger-id
ssh</p>

<p style="margin-top: 1em">Then attach the new trigger to
an LED: <br>
echo netfilter-ssh &gt;/sys/class/leds/ledname/trigger</p>

<p style="margin-top: 1em">LOG <br>
Turn on kernel logging of matching packets. When this option
is set for a rule, the Linux kernel will print some
information on all matching packets (like most IP/IPv6
header <br>
fields) via the kernel log (where it can be read with
dmesg(1) or read in the syslog).</p>

<p style="margin-top: 1em">This is a &quot;non-terminating
target&quot;, i.e. rule traversal continues at the next
rule. So if you want to LOG the packets you refuse, use two
separate rules with the same matching <br>
criteria, first using target LOG then DROP (or REJECT).</p>

<p style="margin-top: 1em">--log-level level <br>
Level of logging, which can be (system-specific) numeric or
a mnemonic. Possible values are (in decreasing order of
priority): emerg, alert, crit, error, warning, notice, <br>
info or debug.</p>

<p style="margin-top: 1em">--log-prefix prefix <br>
Prefix log messages with the specified prefix; up to 29
letters long, and useful for distinguishing messages in the
logs.</p>

<p style="margin-top: 1em">--log-tcp-sequence <br>
Log TCP sequence numbers. This is a security risk if the log
is readable by users.</p>

<p style="margin-top: 1em">--log-tcp-options <br>
Log options from the TCP packet header.</p>

<p style="margin-top: 1em">--log-ip-options <br>
Log options from the IP/IPv6 packet header.</p>

<p style="margin-top: 1em">--log-uid <br>
Log the userid of the process which generated the
packet.</p>

<p style="margin-top: 1em">MARK <br>
This target is used to set the Netfilter mark value
associated with the packet. It can, for example, be used in
conjunction with routing based on fwmark (needs iproute2).
If you <br>
plan on doing so, note that the mark needs to be set in the
PREROUTING chain of the mangle table to affect routing. The
mark field is 32 bits wide.</p>

<p style="margin-top: 1em">--set-xmark value[/mask] <br>
Zeroes out the bits given by mask and XORs value into the
packet mark (&quot;nfmark&quot;). If mask is omitted,
0xFFFFFFFF is assumed.</p>

<p style="margin-top: 1em">--set-mark value[/mask] <br>
Zeroes out the bits given by mask and ORs value into the
packet mark. If mask is omitted, 0xFFFFFFFF is assumed.</p>

<p style="margin-top: 1em">The following mnemonics are
available:</p>

<p style="margin-top: 1em">--and-mark bits <br>
Binary AND the nfmark with bits. (Mnemonic for --set-xmark
0/invbits, where invbits is the binary negation of
bits.)</p>

<p style="margin-top: 1em">--or-mark bits <br>
Binary OR the nfmark with bits. (Mnemonic for --set-xmark
bits/bits.)</p>

<p style="margin-top: 1em">--xor-mark bits <br>
Binary XOR the nfmark with bits. (Mnemonic for --set-xmark
bits/0.)</p>

<p style="margin-top: 1em">MASQUERADE <br>
This target is only valid in the nat table, in the
POSTROUTING chain. It should only be used with dynamically
assigned IP (dialup) connections: if you have a static IP
address, <br>
you should use the SNAT target. Masquerading is equivalent
to specifying a mapping to the IP address of the interface
the packet is going out, but also has the effect that
con&acirc; <br>
nections are forgotten when the interface goes down. This is
the correct behavior when the next dialup is unlikely to
have the same interface address (and hence any established
<br>
connections are lost anyway).</p>

<p style="margin-top: 1em">--to-ports port[-port] <br>
This specifies a range of source ports to use, overriding
the default SNAT source port-selection heuristics (see
above). This is only valid if the rule also specifies one
<br>
of the following protocols: tcp, udp, dccp or sctp.</p>

<p style="margin-top: 1em">--random <br>
Randomize source port mapping If option --random is used
then port mapping will be randomized (kernel &gt;=
2.6.21).</p>

<p style="margin-top: 1em">IPv6 support available since
Linux kernels &gt;= 3.7.</p>

<p style="margin-top: 1em">MIRROR (IPv4-specific) <br>
This is an experimental demonstration target which inverts
the source and destination fields in the IP header and
retransmits the packet. It is only valid in the INPUT,
FORWARD <br>
and PREROUTING chains, and user-defined chains which are
only called from those chains. Note that the outgoing
packets are NOT seen by any packet filtering chains,
connection <br>
tracking or NAT, to avoid loops and other problems.</p>

<p style="margin-top: 1em">NETMAP <br>
This target allows you to statically map a whole network of
addresses onto another network of addresses. It can only be
used from rules in the nat table.</p>

<p style="margin-top: 1em">--to address[/mask] <br>
Network address to map to. The resulting address will be
constructed in the following way: All &rsquo;one&rsquo; bits
in the mask are filled in from the new
&lsquo;address&rsquo;. All bits that <br>
are zero in the mask are filled in from the original
address.</p>

<p style="margin-top: 1em">IPv6 support available since
Linux kernels &gt;= 3.7.</p>

<p style="margin-top: 1em">NFLOG <br>
This target provides logging of matching packets. When this
target is set for a rule, the Linux kernel will pass the
packet to the loaded logging backend to log the packet. This
<br>
is usually used in combination with nfnetlink_log as logging
backend, which will multicast the packet through a netlink
socket to the specified multicast group. One or more <br>
userspace processes may subscribe to the group to receive
the packets. Like LOG, this is a non-terminating target,
i.e. rule traversal continues at the next rule.</p>

<p style="margin-top: 1em">--nflog-group nlgroup <br>
The netlink group (0 - 2^16-1) to which packets are (only
applicable for nfnetlink_log). The default value is 0.</p>

<p style="margin-top: 1em">--nflog-prefix prefix <br>
A prefix string to include in the log message, up to 64
characters long, useful for distinguishing messages in the
logs.</p>

<p style="margin-top: 1em">--nflog-range size <br>
The number of bytes to be copied to userspace (only
applicable for nfnetlink_log). nfnetlink_log instances may
specify their own range, this option overrides it.</p>

<p style="margin-top: 1em">--nflog-threshold size <br>
Number of packets to queue inside the kernel before sending
them to userspace (only applicable for nfnetlink_log).
Higher values result in less overhead per packet, but <br>
increase delay until the packets reach userspace. The
default value is 1.</p>

<p style="margin-top: 1em">NFQUEUE <br>
This target passes the packet to userspace using the
nfnetlink_queue handler. The packet is put into the queue
identified by its 16-bit queue number. Userspace can inspect
and <br>
modify the packet if desired. Userspace must then drop or
reinject the packet into the kernel. Please see
libnetfilter_queue for details. nfnetlink_queue was added in
Linux <br>
2.6.14. The queue-balance option was added in Linux 2.6.31,
queue-bypass in 2.6.39.</p>

<p style="margin-top: 1em">--queue-num value <br>
This specifies the QUEUE number to use. Valid queue numbers
are 0 to 65535. The default value is 0.</p>

<p style="margin-top: 1em">--queue-balance value:value <br>
This specifies a range of queues to use. Packets are then
balanced across the given queues. This is useful for
multicore systems: start multiple instances of the <br>
userspace program on queues x, x+1, .. x+n and use
&quot;--queue-balance x:x+n&quot;. Packets belonging to the
same connection are put into the same nfqueue.</p>

<p style="margin-top: 1em">--queue-bypass <br>
By default, if no userspace program is listening on an
NFQUEUE, then all packets that are to be queued are dropped.
When this option is used, the NFQUEUE rule behaves <br>
like ACCEPT instead, and the packet will move on to the next
table.</p>

<p style="margin-top: 1em">--queue-cpu-fanout <br>
Available starting Linux kernel 3.10. When used together
with --queue-balance this will use the CPU ID as an index to
map packets to the queues. The idea is that you can <br>
improve performance if there&rsquo;s a queue per CPU. This
requires --queue-balance to be specified.</p>

<p style="margin-top: 1em">NOTRACK <br>
This extension disables connection tracking for all packets
matching that rule. It is equivalent with -j CT --notrack.
Like CT, NOTRACK can only be used in the raw table.</p>

<p style="margin-top: 1em">RATEEST <br>
The RATEEST target collects statistics, performs rate
estimation calculation and saves the results for later
evaluation using the rateest match.</p>

<p style="margin-top: 1em">--rateest-name name <br>
Count matched packets into the pool referred to by name,
which is freely choosable.</p>

<p style="margin-top: 1em">--rateest-interval
amount{s|ms|us} <br>
Rate measurement interval, in seconds, milliseconds or
microseconds.</p>

<p style="margin-top: 1em">--rateest-ewmalog value <br>
Rate measurement averaging time constant.</p>

<p style="margin-top: 1em">REDIRECT <br>
This target is only valid in the nat table, in the
PREROUTING and OUTPUT chains, and user-defined chains which
are only called from those chains. It redirects the packet
to the <br>
machine itself by changing the destination IP to the primary
address of the incoming interface (locally-generated packets
are mapped to the localhost address, 127.0.0.1 for IPv4 <br>
and ::1 for IPv6).</p>

<p style="margin-top: 1em">--to-ports port[-port] <br>
This specifies a destination port or range of ports to use:
without this, the destination port is never altered. This is
only valid if the rule also specifies one of the <br>
following protocols: tcp, udp, dccp or sctp.</p>

<p style="margin-top: 1em">--random <br>
If option --random is used then port mapping will be
randomized (kernel &gt;= 2.6.22).</p>

<p style="margin-top: 1em">IPv6 support available starting
Linux kernels &gt;= 3.7.</p>

<p style="margin-top: 1em">REJECT (IPv6-specific) <br>
This is used to send back an error packet in response to the
matched packet: otherwise it is equivalent to DROP so it is
a terminating TARGET, ending rule traversal. This target
<br>
is only valid in the INPUT, FORWARD and OUTPUT chains, and
user-defined chains which are only called from those chains.
The following option controls the nature of the error <br>
packet returned:</p>

<p style="margin-top: 1em">--reject-with type <br>
The type given can be icmp6-no-route, no-route,
icmp6-adm-prohibited, adm-prohibited,
icmp6-addr-unreachable, addr-unreach, or
icmp6-port-unreachable, which return the <br>
appropriate ICMPv6 error message (icmp6-port-unreachable is
the default). Finally, the option tcp-reset can be used on
rules which only match the TCP protocol: this causes <br>
a TCP RST packet to be sent back. This is mainly useful for
blocking ident (113/tcp) probes which frequently occur when
sending mail to broken mail hosts (which won&rsquo;t <br>
accept your mail otherwise). tcp-reset can only be used with
kernel versions 2.6.14 or later.</p>

<p style="margin-top: 1em">REJECT (IPv4-specific) <br>
This is used to send back an error packet in response to the
matched packet: otherwise it is equivalent to DROP so it is
a terminating TARGET, ending rule traversal. This target
<br>
is only valid in the INPUT, FORWARD and OUTPUT chains, and
user-defined chains which are only called from those chains.
The following option controls the nature of the error <br>
packet returned:</p>

<p style="margin-top: 1em">--reject-with type <br>
The type given can be icmp-net-unreachable,
icmp-host-unreachable, icmp-port-unreachable,
icmp-proto-unreachable, icmp-net-prohibited,
icmp-host-prohibited, or <br>
icmp-admin-prohibited (*), which return the appropriate ICMP
error message (icmp-port-unreachable is the default). The
option tcp-reset can be used on rules which only <br>
match the TCP protocol: this causes a TCP RST packet to be
sent back. This is mainly useful for blocking ident
(113/tcp) probes which frequently occur when sending mail
<br>
to broken mail hosts (which won&rsquo;t accept your mail
otherwise).</p>

<p style="margin-top: 1em">(*) Using icmp-admin-prohibited
with kernels that do not support it will result in a plain
DROP instead of REJECT</p>

<p style="margin-top: 1em">SAME (IPv4-specific) <br>
Similar to SNAT/DNAT depending on chain: it takes a range of
addresses (&lsquo;--to 1.2.3.4-1.2.3.7&rsquo;) and gives a
client the same source-/destination-address for each
connection.</p>

<p style="margin-top: 1em">N.B.: The DNAT target&rsquo;s
--persistent option replaced the SAME target.</p>

<p style="margin-top: 1em">--to ipaddr[-ipaddr] <br>
Addresses to map source to. May be specified more than once
for multiple ranges.</p>

<p style="margin-top: 1em">--nodst <br>
Don&rsquo;t use the destination-ip in the calculations when
selecting the new source-ip</p>

<p style="margin-top: 1em">--random <br>
Port mapping will be forcibly randomized to avoid attacks
based on port prediction (kernel &gt;= 2.6.21).</p>

<p style="margin-top: 1em">SECMARK <br>
This is used to set the security mark value associated with
the packet for use by security subsystems such as SELinux.
It is valid in the security table (for backwards
compati&acirc; <br>
bility with older kernels, it is also valid in the mangle
table). The mark is 32 bits wide.</p>

<p style="margin-top: 1em">--selctx security_context</p>

<p style="margin-top: 1em">SET <br>
This module adds and/or deletes entries from IP sets which
can be defined by ipset(8).</p>

<p style="margin-top: 1em">--add-set setname flag[,flag...]
<br>
add the address(es)/port(s) of the packet to the set</p>

<p style="margin-top: 1em">--del-set setname flag[,flag...]
<br>
delete the address(es)/port(s) of the packet from the
set</p>

<p style="margin-top: 1em">where flag(s) are src and/or dst
specifications and there can be no more than six of
them.</p>

<p style="margin-top: 1em">--timeout value <br>
when adding an entry, the timeout value to use instead of
the default one from the set definition</p>

<p style="margin-top: 1em">--exist <br>
when adding an entry if it already exists, reset the timeout
value to the specified one or to the default from the set
definition</p>

<p style="margin-top: 1em">Use of -j SET requires that
ipset kernel support is provided, which, for standard
kernels, is the case since Linux 2.6.39.</p>

<p style="margin-top: 1em">SNAT <br>
This target is only valid in the nat table, in the
POSTROUTING and INPUT chains, and user-defined chains which
are only called from those chains. It specifies that the
source <br>
address of the packet should be modified (and all future
packets in this connection will also be mangled), and rules
should cease being examined. It takes the following
options:</p>

<p style="margin-top: 1em">--to-source
[ipaddr[-ipaddr]][:port[-port]] <br>
which can specify a single new source IP address, an
inclusive range of IP addresses. Optionally a port range, if
the rule also specifies one of the following protocols: <br>
tcp, udp, dccp or sctp. If no port range is specified, then
source ports below 512 will be mapped to other ports below
512: those between 512 and 1023 inclusive will be <br>
mapped to ports below 1024, and other ports will be mapped
to 1024 or above. Where possible, no port alteration will
occur. In Kernels up to 2.6.10, you can add several <br>
--to-source options. For those kernels, if you specify more
than one source address, either via an address range or
multiple --to-source options, a simple round-robin (one <br>
after another in cycle) takes place between these addresses.
Later Kernels (&gt;= 2.6.11-rc1) don&rsquo;t have the
ability to NAT to multiple ranges anymore.</p>

<p style="margin-top: 1em">--random <br>
If option --random is used then port mapping will be
randomized (kernel &gt;= 2.6.21).</p>

<p style="margin-top: 1em">--persistent <br>
Gives a client the same source-/destination-address for each
connection. This supersedes the SAME target. Support for
persistent mappings is available from 2.6.29-rc2.</p>

<p style="margin-top: 1em">Kernels prior to 2.6.36-rc1
don&rsquo;t have the ability to SNAT in the INPUT chain.</p>

<p style="margin-top: 1em">IPv6 support available since
Linux kernels &gt;= 3.7.</p>

<p style="margin-top: 1em">SNPT (IPv6-specific) <br>
Provides stateless source IPv6-to-IPv6 Network Prefix
Translation (as described by RFC 6296).</p>

<p style="margin-top: 1em">You have to use this target in
the mangle table, not in the nat table. It takes the
following options:</p>

<p style="margin-top: 1em">--src-pfx [prefix/length] <br>
Set source prefix that you want to translate and length</p>

<p style="margin-top: 1em">--dst-pfx [prefix/length] <br>
Set destination prefix that you want to use in the
translation and length</p>

<p style="margin-top: 1em">You have to use the DNPT target
to undo the translation. Example:</p>

<p style="margin-top: 1em">ip6tables -t mangle -I
POSTROUTING -s fd00::/64 -o vboxnet0 -j SNPT --src-pfx
fd00::/64 --dst-pfx 2001:e20:2000:40f::/64</p>

<p style="margin-top: 1em">ip6tables -t mangle -I
PREROUTING -i wlan0 -d 2001:e20:2000:40f::/64 -j DNPT
--src-pfx 2001:e20:2000:40f::/64 --dst-pfx fd00::/64</p>

<p style="margin-top: 1em">You may need to enable IPv6
neighbor proxy:</p>

<p style="margin-top: 1em">sysctl -w
net.ipv6.conf.all.proxy_ndp=1</p>

<p style="margin-top: 1em">You also have to use the NOTRACK
target to disable connection tracking for translated
flows.</p>

<p style="margin-top: 1em">TCPMSS <br>
This target allows to alter the MSS value of TCP SYN
packets, to control the maximum size for that connection
(usually limiting it to your outgoing interface&rsquo;s MTU
minus 40 for <br>
IPv4 or 60 for IPv6, respectively). Of course, it can only
be used in conjunction with -p tcp.</p>

<p style="margin-top: 1em">This target is used to overcome
criminally braindead ISPs or servers which block &quot;ICMP
Fragmentation Needed&quot; or &quot;ICMPv6 Packet Too
Big&quot; packets. The symptoms of this problem are <br>
that everything works fine from your Linux firewall/router,
but machines behind it can never exchange large packets:</p>

<p style="margin-top: 1em">1. Web browsers connect, then
hang with no data received.</p>

<p style="margin-top: 1em">2. Small mail works fine, but
large emails hang.</p>

<p style="margin-top: 1em">3. ssh works fine, but scp hangs
after initial handshaking.</p>

<p style="margin-top: 1em">Workaround: activate this option
and add a rule to your firewall configuration like:</p>

<p style="margin-top: 1em">iptables -t mangle -A FORWARD -p
tcp --tcp-flags SYN,RST SYN <br>
-j TCPMSS --clamp-mss-to-pmtu</p>

<p style="margin-top: 1em">--set-mss value <br>
Explicitly sets MSS option to specified value. If the MSS of
the packet is already lower than value, it will not be
increased (from Linux 2.6.25 onwards) to avoid more <br>
problems with hosts relying on a proper MSS.</p>

<p style="margin-top: 1em">--clamp-mss-to-pmtu <br>
Automatically clamp MSS value to (path_MTU - 40 for IPv4;
-60 for IPv6). This may not function as desired where
asymmetric routes with differing path MTU exist &acirc; the
ker&acirc; <br>
nel uses the path MTU which it would use to send packets
from itself to the source and destination IP addresses.
Prior to Linux 2.6.25, only the path MTU to the
destina&acirc; <br>
tion IP address was considered by this option; subsequent
kernels also consider the path MTU to the source IP
address.</p>

<p style="margin-top: 1em">These options are mutually
exclusive.</p>

<p style="margin-top: 1em">TCPOPTSTRIP <br>
This target will strip TCP options off a TCP packet. (It
will actually replace them by NO-OPs.) As such, you will
need to add the -p tcp parameters.</p>

<p style="margin-top: 1em">--strip-options
option[,option...] <br>
Strip the given option(s). The options may be specified by
TCP option number or by symbolic name. The list of
recognized options can be obtained by calling iptables with
<br>
-j TCPOPTSTRIP -h.</p>

<p style="margin-top: 1em">TEE <br>
The TEE target will clone a packet and redirect this clone
to another machine on the local network segment. In other
words, the nexthop must be the target, or you will have to
<br>
configure the nexthop to forward it further if so
desired.</p>

<p style="margin-top: 1em">--gateway ipaddr <br>
Send the cloned packet to the host reachable at the given IP
address. Use of 0.0.0.0 (for IPv4 packets) or :: (IPv6) is
invalid.</p>

<p style="margin-top: 1em">To forward all incoming traffic
on eth0 to an Network Layer logging box:</p>

<p style="margin-top: 1em">-t mangle -A PREROUTING -i eth0
-j TEE --gateway 2001:db8::1</p>

<p style="margin-top: 1em">TOS <br>
This module sets the Type of Service field in the IPv4
header (including the &quot;precedence&quot; bits) or the
Priority field in the IPv6 header. Note that TOS shares the
same bits as <br>
DSCP and ECN. The TOS target is only valid in the mangle
table.</p>

<p style="margin-top: 1em">--set-tos value[/mask] <br>
Zeroes out the bits given by mask (see NOTE below) and XORs
value into the TOS/Priority field. If mask is omitted, 0xFF
is assumed.</p>

<p style="margin-top: 1em">--set-tos symbol <br>
You can specify a symbolic name when using the TOS target
for IPv4. It implies a mask of 0xFF (see NOTE below). The
list of recognized TOS names can be obtained by calling <br>
iptables with -j TOS -h.</p>

<p style="margin-top: 1em">The following mnemonics are
available:</p>

<p style="margin-top: 1em">--and-tos bits <br>
Binary AND the TOS value with bits. (Mnemonic for --set-tos
0/invbits, where invbits is the binary negation of bits. See
NOTE below.)</p>

<p style="margin-top: 1em">--or-tos bits <br>
Binary OR the TOS value with bits. (Mnemonic for --set-tos
bits/bits. See NOTE below.)</p>

<p style="margin-top: 1em">--xor-tos bits <br>
Binary XOR the TOS value with bits. (Mnemonic for --set-tos
bits/0. See NOTE below.)</p>

<p style="margin-top: 1em">NOTE: In Linux kernels up to and
including 2.6.38, with the exception of longterm releases
2.6.32 (&gt;=.42), 2.6.33 (&gt;=.15), and 2.6.35 (&gt;=.14),
there is a bug whereby IPv6 TOS <br>
mangling does not behave as documented and differs from the
IPv4 version. The TOS mask indicates the bits one wants to
zero out, so it needs to be inverted before applying it to
<br>
the original TOS field. However, the aformentioned kernels
forgo the inversion which breaks --set-tos and its
mnemonics.</p>

<p style="margin-top: 1em">TPROXY <br>
This target is only valid in the mangle table, in the
PREROUTING chain and user-defined chains which are only
called from this chain. It redirects the packet to a local
socket <br>
without changing the packet header in any way. It can also
change the mark value which can then be used in advanced
routing rules. It takes three options:</p>

<p style="margin-top: 1em">--on-port port <br>
This specifies a destination port to use. It is a required
option, 0 means the new destination port is the same as the
original. This is only valid if the rule also speci&acirc;
<br>
fies -p tcp or -p udp.</p>

<p style="margin-top: 1em">--on-ip address <br>
This specifies a destination address to use. By default the
address is the IP address of the incoming interface. This is
only valid if the rule also specifies -p tcp or -p <br>
udp.</p>

<p style="margin-top: 1em">--tproxy-mark value[/mask] <br>
Marks packets with the given value/mask. The fwmark value
set here can be used by advanced routing. (Required for
transparent proxying to work: otherwise these packets <br>
will get forwarded, which is probably not what you
want.)</p>

<p style="margin-top: 1em">TRACE <br>
This target marks packets so that the kernel will log every
rule which match the packets as those traverse the tables,
chains, rules.</p>

<p style="margin-top: 1em">A logging backend, such as
nf_log_ipv4(6) or nfnetlink_log, must be loaded for this to
be visible. The packets are logged with the string prefix:
&quot;TRACE: tablename:chain&acirc; <br>
name:type:rulenum &quot; where type can be &quot;rule&quot;
for plain rule, &quot;return&quot; for implicit rule at the
end of a user defined chain and &quot;policy&quot; for the
policy of the built in chains. <br>
It can only be used in the raw table.</p>

<p style="margin-top: 1em">TTL (IPv4-specific) <br>
This is used to modify the IPv4 TTL header field. The TTL
field determines how many hops (routers) a packet can
traverse until it&rsquo;s time to live is exceeded.</p>

<p style="margin-top: 1em">Setting or incrementing the TTL
field can potentially be very dangerous, so it should be
avoided at any cost. This target is only valid in mangle
table.</p>

<p style="margin-top: 1em">Don&rsquo;t ever set or
increment the value on packets that leave your local
network!</p>

<p style="margin-top: 1em">--ttl-set value <br>
Set the TTL value to &lsquo;value&rsquo;.</p>

<p style="margin-top: 1em">--ttl-dec value <br>
Decrement the TTL value &lsquo;value&rsquo; times.</p>

<p style="margin-top: 1em">--ttl-inc value <br>
Increment the TTL value &lsquo;value&rsquo; times.</p>

<p style="margin-top: 1em">ULOG (IPv4-specific) <br>
This is the deprecated ipv4-only predecessor of the NFLOG
target. It provides userspace logging of matching packets.
When this target is set for a rule, the Linux kernel will
<br>
multicast this packet through a netlink socket. One or more
userspace processes may then subscribe to various multicast
groups and receive the packets. Like LOG, this is a
&quot;non- <br>
terminating target&quot;, i.e. rule traversal continues at
the next rule.</p>

<p style="margin-top: 1em">--ulog-nlgroup nlgroup <br>
This specifies the netlink group (1-32) to which the packet
is sent. Default value is 1.</p>

<p style="margin-top: 1em">--ulog-prefix prefix <br>
Prefix log messages with the specified prefix; up to 32
characters long, and useful for distinguishing messages in
the logs.</p>

<p style="margin-top: 1em">--ulog-cprange size <br>
Number of bytes to be copied to userspace. A value of 0
always copies the entire packet, regardless of its size.
Default is 0.</p>

<p style="margin-top: 1em">--ulog-qthreshold size <br>
Number of packet to queue inside kernel. Setting this value
to, e.g. 10 accumulates ten packets inside the kernel and
transmits them as one netlink multipart message to <br>
userspace. Default is 1 (for backwards compatibility).</p>

<p style="margin-top: 1em">iptables 1.4.21
iptables-extensions(8)</p>
<hr>
</body>
</html>
