<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>iptables-extensions(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">iptables-extensions(8)</td>
    <td class="head-vol">iptables 1.4.21</td>
    <td class="head-rtitle">iptables-extensions(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
iptables-extensions &#x2014; list of extensions in the standard iptables
  distribution
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>ip6tables</b> [<b>-m</b> <i>name</i> [<i>module-options</i>...]] [ <b>-j</b>
  <i>target-name</i> [<i>target-options</i>...]
<div class="Pp"></div>
<b>iptables</b> [<b>-m</b> <i>name</i> [<i>module-options</i>...]] [ <b>-j</b>
  <i>target-name</i> [<i>target-options</i>...]
<h1 class="Sh" title="Sh" id="MATCH_EXTENSIONS"><a class="selflink" href="#MATCH_EXTENSIONS">MATCH
  EXTENSIONS</a></h1>
iptables can use extended packet matching modules with the <b>-m</b> or
  <b>--match</b> options, followed by the matching module name; after these,
  various extra command line options become available, depending on the specific
  module. You can specify multiple extended match modules in one line, and you
  can use the <b>-h</b> or <b>--help</b> options after the module has been
  specified to receive help specific to that module. The extended match modules
  are evaluated in the order they are specified in the rule.
<div class="Pp"></div>
If the <b>-p</b> or <b>--protocol</b> was specified and if and only if an
  unknown option is encountered, iptables will try load a match module of the
  same name as the protocol, to try making the option available.
<h2 class="Ss" title="Ss" id="addrtype"><a class="selflink" href="#addrtype">addrtype</a></h2>
This module matches packets based on their <b>address type.</b> Address types
  are used within the kernel networking stack and categorize addresses into
  various groups. The exact definition of that group depends on the specific
  layer three protocol.
<div class="Pp"></div>
The following address types are possible:
<dl class="Bl-tag">
  <dt class="It-tag"><b>UNSPEC</b></dt>
  <dd class="It-tag">an unspecified address (i.e. 0.0.0.0)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>UNICAST</b></dt>
  <dd class="It-tag">an unicast address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>LOCAL</b></dt>
  <dd class="It-tag">a local address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>BROADCAST</b></dt>
  <dd class="It-tag">a broadcast address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ANYCAST</b></dt>
  <dd class="It-tag">an anycast packet</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>MULTICAST</b></dt>
  <dd class="It-tag">a multicast address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>BLACKHOLE</b></dt>
  <dd class="It-tag">a blackhole address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>UNREACHABLE</b></dt>
  <dd class="It-tag">an unreachable address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>PROHIBIT</b></dt>
  <dd class="It-tag">a prohibited address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>THROW</b></dt>
  <dd class="It-tag">FIXME</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>NAT</b></dt>
  <dd class="It-tag">FIXME</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>XRESOLVE</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--src-type</b> <i>type</i></dt>
  <dd class="It-tag">Matches if the source address is of given type</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dst-type</b> <i>type</i></dt>
  <dd class="It-tag">Matches if the destination address is of given type</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--limit-iface-in</b></dt>
  <dd class="It-tag">The address type checking can be limited to the interface
      the packet is coming in. This option is only valid in the
      <b>PREROUTING</b>, <b>INPUT</b> and <b>FORWARD</b> chains. It cannot be
      specified with the <b>--limit-iface-out</b> option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--limit-iface-out</b></dt>
  <dd class="It-tag">The address type checking can be limited to the interface
      the packet is going out. This option is only valid in the
      <b>POSTROUTING</b>, <b>OUTPUT</b> and <b>FORWARD</b> chains. It cannot be
      specified with the <b>--limit-iface-in</b> option.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ah_(IPv6-specific)"><a class="selflink" href="#ah_(IPv6-specific)">ah
  (IPv6-specific)</a></h2>
This module matches the parameters in Authentication header of IPsec packets.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ahspi</b>
    <i>spi</i>[<b>:</b><i>spi</i>]</dt>
  <dd class="It-tag">Matches SPI.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ahlen</b> <i>length</i></dt>
  <dd class="It-tag">Total length of this header in octets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ahres</b></dt>
  <dd class="It-tag">Matches if the reserved field is filled with zero.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ah_(IPv4-specific)"><a class="selflink" href="#ah_(IPv4-specific)">ah
  (IPv4-specific)</a></h2>
This module matches the SPIs in Authentication header of IPsec packets.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ahspi</b>
    <i>spi</i>[<b>:</b><i>spi</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="bpf"><a class="selflink" href="#bpf">bpf</a></h2>
Match using Linux Socket Filter. Expects a BPF program in decimal format. This
  is the format generated by the <b>nfbpf_compile</b> utility.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bytecode</b> <i>code</i></dt>
  <dd class="It-tag">Pass the BPF byte code format (described in the example
      below).</dd>
</dl>
<div class="Pp"></div>
The code format is similar to the output of the tcpdump -ddd command: one line
  that stores the number of instructions, followed by one line for each
  instruction. Instruction lines follow the pattern 'u16 u8 u8 u32' in decimal
  notation. Fields encode the operation, jump offset if true, jump offset if
  false and generic multiuse field 'K'. Comments are not supported.
<div class="Pp"></div>
For example, to read only packets matching 'ip proto 6', insert the following,
  without the comments or trailing whitespace:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">4 # number of instructions
    <div>&#x00A0;</div>
    48 0 0 9 # load byte ip-&gt;proto
    <div>&#x00A0;</div>
    21 0 1 6 # jump equal IPPROTO_TCP
    <div>&#x00A0;</div>
    6 0 0 1 # return pass (non-zero)
    <div>&#x00A0;</div>
    6 0 0 0 # return fail (zero)</dd>
</dl>
<div class="Pp"></div>
You can pass this filter to the bpf match with the following command:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A OUTPUT -m bpf --bytecode '4,48 0 0 9,21 0 1 6,6
      0 0 1,6 0 0 0' -j ACCEPT</dd>
</dl>
<div class="Pp"></div>
Or instead, you can invoke the nfbpf_compile utility.
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A OUTPUT -m bpf --bytecode &quot;`nfbpf_compile
      RAW 'ip proto 6'`&quot; -j ACCEPT</dd>
</dl>
<div class="Pp"></div>
You may want to learn more about BPF from FreeBSD's bpf(4) manpage.
<h2 class="Ss" title="Ss" id="cgroup"><a class="selflink" href="#cgroup">cgroup</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--cgroup</b> <i>fwid</i></dt>
  <dd class="It-tag">Match corresponding cgroup for this packet.
    <div style="height: 1.00em;">&#x00A0;</div>
    Can be used to assign particular firewall policies for aggregated task/jobs
      on the system. This allows for more fine-grained firewall policies that
      only match for a subset of the system's processes. fwid is the maker set
      through the net_cls cgroup's id.</dd>
</dl>
<div class="Pp"></div>
Example:
<div class="Pp"></div>
iptables -A OUTPUT -p tcp --sport 80 -m cgroup ! --cgroup 1 -j DROP
<div class="Pp"></div>
Available since Linux 3.14.
<h2 class="Ss" title="Ss" id="cluster"><a class="selflink" href="#cluster">cluster</a></h2>
Allows you to deploy gateway and back-end load-sharing clusters without the need
  of load-balancers.
<div class="Pp"></div>
This match requires that all the nodes see the same packets. Thus, the cluster
  match decides if this node has to handle a packet given the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cluster-total-nodes</b> <i>num</i></dt>
  <dd class="It-tag">Set number of total nodes in cluster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--cluster-local-node</b> <i>num</i></dt>
  <dd class="It-tag">Set the local node number ID.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--cluster-local-nodemask</b> <i>mask</i></dt>
  <dd class="It-tag">Set the local node number ID mask. You can use this option
      instead of <b>--cluster-local-node</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cluster-hash-seed</b> <i>value</i></dt>
  <dd class="It-tag">Set seed value of the Jenkins hash.</dd>
</dl>
<div class="Pp"></div>
Example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A PREROUTING -t mangle -i eth1 -m cluster
      --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed
      0xdeadbeef -j MARK --set-mark 0xffff</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A PREROUTING -t mangle -i eth2 -m cluster
      --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed
      0xdeadbeef -j MARK --set-mark 0xffff</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A PREROUTING -t mangle -i eth1 -m mark ! --mark
      0xffff -j DROP</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A PREROUTING -t mangle -i eth2 -m mark ! --mark
      0xffff -j DROP</dd>
</dl>
<div class="Pp"></div>
And the following commands to make all nodes see the same packets:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">ip maddr add 01:00:5e:00:01:01 dev eth1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">ip maddr add 01:00:5e:00:01:02 dev eth2</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">arptables -A OUTPUT -o eth1 --h-length 6 -j mangle
      --mangle-mac-s 01:00:5e:00:01:01</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">arptables -A INPUT -i eth1 --h-length 6 --destination-mac
      01:00:5e:00:01:01 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">arptables -A OUTPUT -o eth2 --h-length 6 -j mangle
      --mangle-mac-s 01:00:5e:00:01:02</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">arptables -A INPUT -i eth2 --h-length 6 --destination-mac
      01:00:5e:00:01:02 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27</dd>
</dl>
<div class="Pp"></div>
<b>NOTE</b>: the arptables commands above use mainstream syntax. If you are
  using arptables-jf included in some RedHat, CentOS and Fedora versions, you
  will hit syntax errors. Therefore, you'll have to adapt these to the
  arptables-jf syntax to get them working.
<div class="Pp"></div>
In the case of TCP connections, pickup facility has to be disabled to avoid
  marking TCP ACK packets coming in the reply direction as valid.
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">echo 0 &gt;
    /proc/sys/net/netfilter/nf_conntrack_tcp_loose</dd>
</dl>
<h2 class="Ss" title="Ss" id="comment"><a class="selflink" href="#comment">comment</a></h2>
Allows you to add comments (up to 256 characters) to any rule.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--comment</b> <i>comment</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Example:</dt>
  <dd class="It-tag">iptables -A INPUT -i eth1 -m comment --comment &quot;my
      local LAN&quot;</dd>
</dl>
<h2 class="Ss" title="Ss" id="connbytes"><a class="selflink" href="#connbytes">connbytes</a></h2>
Match by how many bytes or packets a connection (or one of the two flows
  constituting the connection) has transferred so far, or by average bytes per
  packet.
<div class="Pp"></div>
The counters are 64-bit and are thus not expected to overflow ;)
<div class="Pp"></div>
The primary use is to detect long-lived downloads and mark them to be scheduled
  using a lower priority band in traffic control.
<div class="Pp"></div>
The transferred bytes per connection can also be viewed through `conntrack -L`
  and accessed via ctnetlink.
<div class="Pp"></div>
NOTE that for connections which have no accounting information, the match will
  always return false. The &quot;net.netfilter.nf_conntrack_acct&quot; sysctl
  flag controls whether <b>new</b> connections will be byte/packet counted.
  Existing connection flows will not be gaining/losing a/the accounting
  structure when be sysctl flag is flipped.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--connbytes</b>
    <i>from</i>[<b>:</b><i>to</i>]</dt>
  <dd class="It-tag">match packets from a connection whose packets/bytes/average
      packet size is more than FROM and less than TO bytes/packets. if TO is
      omitted only FROM check is done. &quot;!&quot; is used to match packets
      not falling in the range.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--connbytes-dir</b>
    {<b>original</b>|<b>reply</b>|<b>both</b>}</dt>
  <dd class="It-tag">which packets to consider</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--connbytes-mode</b>
    {<b>packets</b>|<b>bytes</b>|<b>avgpkt</b>}</dt>
  <dd class="It-tag">whether to check the amount of packets, number of bytes
      transferred or the average size (in bytes) of all packets received so far.
      Note that when &quot;both&quot; is used together with &quot;avgpkt&quot;,
      and data is going (mainly) only in one direction (for example HTTP), the
      average packet size will be about half of the actual data packets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Example:</dt>
  <dd class="It-tag">iptables .. -m connbytes --connbytes 10000:100000
      --connbytes-dir both --connbytes-mode bytes ...</dd>
</dl>
<h2 class="Ss" title="Ss" id="connlabel"><a class="selflink" href="#connlabel">connlabel</a></h2>
Module matches or adds connlabels to a connection. connlabels are similar to
  connmarks, except labels are bit-based; i.e. all labels may be attached to a
  flow at the same time. Up to 128 unique labels are currently supported.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--label</b> <b>name</b></dt>
  <dd class="It-tag">matches if label <b>name</b> has been set on a connection.
      Instead of a name (which will be translated to a number, see EXAMPLE
      below), a number may be used instead. Using a number always overrides
      connlabel.conf.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set</b></dt>
  <dd class="It-tag">if the label has not been set on the connection, set it.
      Note that setting a label can fail. This is because the kernel allocates
      the conntrack label storage area when the connection is created, and it
      only reserves the amount of memory required by the ruleset that exists at
      the time the connection is created. In this case, the match will fail (or
      succeed, in case <b>--label</b> option was negated).</dd>
</dl>
<div class="Pp"></div>
This match depends on libnetfilter_conntrack 1.0.4 or later. Label translation
  is done via the <b>/etc/xtables/connlabel.conf</b> configuration file.
<div class="Pp"></div>
Example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <pre>
0	eth0-in
1	eth0-out
2	ppp-in
3	ppp-out
4	bulk-traffic
5	interactive
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="connlimit"><a class="selflink" href="#connlimit">connlimit</a></h2>
Allows you to restrict the number of parallel connections to a server per client
  IP address (or client address block).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--connlimit-upto</b> <i>n</i></dt>
  <dd class="It-tag">Match if the number of existing connections is below or
      equal <i>n</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--connlimit-above</b> <i>n</i></dt>
  <dd class="It-tag">Match if the number of existing connections is above
      <i>n</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--connlimit-mask</b> <i>prefix_length</i></dt>
  <dd class="It-tag">Group hosts using the prefix length. For IPv4, this must be
      a number between (including) 0 and 32. For IPv6, between 0 and 128. If not
      specified, the maximum prefix length for the applicable protocol is
    used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--connlimit-saddr</b></dt>
  <dd class="It-tag">Apply the limit onto the source group. This is the default
      if --connlimit-daddr is not specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--connlimit-daddr</b></dt>
  <dd class="It-tag">Apply the limit onto the destination group.</dd>
</dl>
<div class="Pp"></div>
Examples:
<dl class="Bl-tag">
  <dt class="It-tag"># allow 2 telnet connections per client host</dt>
  <dd class="It-tag">iptables -A INPUT -p tcp --syn --dport 23 -m connlimit
      --connlimit-above 2 -j REJECT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"># you can also match the other way around:</dt>
  <dd class="It-tag">iptables -A INPUT -p tcp --syn --dport 23 -m connlimit
      --connlimit-upto 2 -j ACCEPT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"># limit the number of parallel HTTP requests to 16 per
    class C sized source network (24 bit netmask)</dt>
  <dd class="It-tag">iptables -p tcp --syn --dport 80 -m connlimit
      --connlimit-above 16 --connlimit-mask 24 -j REJECT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"># limit the number of parallel HTTP requests to 16 for the
    link local network</dt>
  <dd class="It-tag">(ipv6) ip6tables -p tcp --syn --dport 80 -s fe80::/64 -m
      connlimit --connlimit-above 16 --connlimit-mask 64 -j REJECT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"># Limit the number of connections to a particular
    host:</dt>
  <dd class="It-tag">ip6tables -p tcp --syn --dport 49152:65535 -d 2001:db8::1
      -m connlimit --connlimit-above 100 -j REJECT</dd>
</dl>
<h2 class="Ss" title="Ss" id="connmark"><a class="selflink" href="#connmark">connmark</a></h2>
This module matches the netfilter mark field associated with a connection (which
  can be set using the <b>CONNMARK</b> target below).
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--mark</b>
    <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Matches packets in connections with the given mark value
      (if a mask is specified, this is logically ANDed with the mark before the
      comparison).</dd>
</dl>
<h2 class="Ss" title="Ss" id="conntrack"><a class="selflink" href="#conntrack">conntrack</a></h2>
This module, when combined with connection tracking, allows access to the
  connection tracking state for this packet/connection.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctstate</b> <i>statelist</i></dt>
  <dd class="It-tag"><i>statelist</i> is a comma separated list of the
      connection states to match. Possible states are listed below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctproto</b> <i>l4proto</i></dt>
  <dd class="It-tag">Layer-4 protocol to match (by number or name)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctorigsrc</b>
    <i>address</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctorigdst</b>
    <i>address</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctreplsrc</b>
    <i>address</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctrepldst</b>
    <i>address</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Match against original/reply source/destination
    address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctorigsrcport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctorigdstport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctreplsrcport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctrepldstport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag">Match against original/reply source/destination port
      (TCP/UDP/etc.) or GRE key. Matching against port ranges is only supported
      in kernel versions above 2.6.38.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctstatus</b> <i>statelist</i></dt>
  <dd class="It-tag"><i>statuslist</i> is a comma separated list of the
      connection statuses to match. Possible statuses are listed below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ctexpire</b>
    <i>time</i>[<b>:</b><i>time</i>]</dt>
  <dd class="It-tag">Match remaining lifetime in seconds against given value or
      range of values (inclusive)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ctdir</b> {<b>ORIGINAL</b>|<b>REPLY</b>}</dt>
  <dd class="It-tag">Match packets that are flowing in the specified direction.
      If this flag is not specified at all, matches packets in both
    directions.</dd>
</dl>
<div class="Pp"></div>
States for <b>--ctstate</b>:
<dl class="Bl-tag">
  <dt class="It-tag"><b>INVALID</b></dt>
  <dd class="It-tag">The packet is associated with no known connection.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>NEW</b></dt>
  <dd class="It-tag">The packet has started a new connection or otherwise
      associated with a connection which has not seen packets in both
      directions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ESTABLISHED</b></dt>
  <dd class="It-tag">The packet is associated with a connection which has seen
      packets in both directions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>RELATED</b></dt>
  <dd class="It-tag">The packet is starting a new connection, but is associated
      with an existing connection, such as an FTP data transfer or an ICMP
      error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>UNTRACKED</b></dt>
  <dd class="It-tag">The packet is not tracked at all, which happens if you
      explicitly untrack it by using -j CT --notrack in the raw table.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SNAT</b></dt>
  <dd class="It-tag">A virtual state, matching if the original source address
      differs from the reply destination.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>DNAT</b></dt>
  <dd class="It-tag">A virtual state, matching if the original destination
      differs from the reply source.</dd>
</dl>
<div class="Pp"></div>
Statuses for <b>--ctstatus</b>:
<dl class="Bl-tag">
  <dt class="It-tag"><b>NONE</b></dt>
  <dd class="It-tag">None of the below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>EXPECTED</b></dt>
  <dd class="It-tag">This is an expected connection (i.e. a conntrack helper set
      it up).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SEEN_REPLY</b></dt>
  <dd class="It-tag">Conntrack has seen packets in both directions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ASSURED</b></dt>
  <dd class="It-tag">Conntrack entry should never be early-expired.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>CONFIRMED</b></dt>
  <dd class="It-tag">Connection is confirmed: originating packet has left
    box.</dd>
</dl>
<h2 class="Ss" title="Ss" id="cpu"><a class="selflink" href="#cpu">cpu</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--cpu</b> <i>number</i></dt>
  <dd class="It-tag">Match cpu handling this packet. cpus are numbered from 0 to
      NR_CPUS-1 Can be used in combination with RPS (Remote Packet Steering) or
      multiqueue NICs to spread network traffic on different queues.</dd>
</dl>
<div class="Pp"></div>
Example:
<div class="Pp"></div>
iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 0 -j REDIRECT
  --to-port 8080
<div class="Pp"></div>
iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 1 -j REDIRECT
  --to-port 8081
<div class="Pp"></div>
Available since Linux 2.6.36.
<h2 class="Ss" title="Ss" id="dccp"><a class="selflink" href="#dccp">dccp</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--source-port</b>,<b>--sport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--destination-port</b>,<b>--dport</b>
    <i>port</i>[ <b>:</b><i>port</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dccp-types</b> <i>mask</i></dt>
  <dd class="It-tag">Match when the DCCP packet type is one of 'mask'. 'mask' is
      a comma-separated list of packet types. Packet types are: <b>REQUEST
      RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK
    INVALID</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dccp-option</b> <i>number</i></dt>
  <dd class="It-tag">Match if DCCP option set.</dd>
</dl>
<h2 class="Ss" title="Ss" id="devgroup"><a class="selflink" href="#devgroup">devgroup</a></h2>
Match device group of a packets incoming/outgoing interface.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--src-group</b> <i>name</i></dt>
  <dd class="It-tag">Match device group of incoming device</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dst-group</b> <i>name</i></dt>
  <dd class="It-tag">Match device group of outgoing device</dd>
</dl>
<h2 class="Ss" title="Ss" id="dscp"><a class="selflink" href="#dscp">dscp</a></h2>
This module matches the 6 bit DSCP field within the TOS field in the IP header.
  DSCP has superseded TOS within the IETF.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dscp</b> <i>value</i></dt>
  <dd class="It-tag">Match against a numeric (decimal or hex) value [0-63].</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dscp-class</b> <i>class</i></dt>
  <dd class="It-tag">Match the DiffServ class. This value may be any of the BE,
      EF, AFxx or CSx classes. It will then be converted into its according
      numeric value.</dd>
</dl>
<h2 class="Ss" title="Ss" id="dst_(IPv6-specific)"><a class="selflink" href="#dst_(IPv6-specific)">dst
  (IPv6-specific)</a></h2>
This module matches the parameters in Destination Options header
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dst-len</b> <i>length</i></dt>
  <dd class="It-tag">Total length of this header in octets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dst-opts</b>
    <i>type</i>[<b>:</b><i>length</i>][<b>,</b>
    <i>type</i>[<b>:</b><i>length</i>]...]</dt>
  <dd class="It-tag">numeric type of option and the length of the option data in
      octets.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ecn"><a class="selflink" href="#ecn">ecn</a></h2>
This allows you to match the ECN bits of the IPv4/IPv6 and TCP header. ECN is
  the Explicit Congestion Notification mechanism as specified in RFC3168
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ecn-tcp-cwr</b></dt>
  <dd class="It-tag">This matches if the TCP ECN CWR (Congestion Window
      Received) bit is set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ecn-tcp-ece</b></dt>
  <dd class="It-tag">This matches if the TCP ECN ECE (ECN Echo) bit is set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ecn-ip-ect</b> <i>num</i></dt>
  <dd class="It-tag">This matches a particular IPv4/IPv6 ECT (ECN-Capable
      Transport). You have to specify a number between `0' and `3'.</dd>
</dl>
<h2 class="Ss" title="Ss" id="esp"><a class="selflink" href="#esp">esp</a></h2>
This module matches the SPIs in ESP header of IPsec packets.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--espspi</b>
    <i>spi</i>[<b>:</b><i>spi</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="eui64_(IPv6-specific)"><a class="selflink" href="#eui64_(IPv6-specific)">eui64
  (IPv6-specific)</a></h2>
This module matches the EUI-64 part of a stateless autoconfigured IPv6 address.
  It compares the EUI-64 derived from the source MAC address in Ethernet frame
  with the lower 64 bits of the IPv6 source address. But
  &quot;Universal/Local&quot; bit is not compared. This module doesn't match
  other link layer frame, and is only valid in the <b>PREROUTING</b>,
  <b>INPUT</b> and <b>FORWARD</b> chains.
<h2 class="Ss" title="Ss" id="frag_(IPv6-specific)"><a class="selflink" href="#frag_(IPv6-specific)">frag
  (IPv6-specific)</a></h2>
This module matches the parameters in Fragment header.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--fragid</b>
    <i>id</i>[<b>:</b><i>id</i>]</dt>
  <dd class="It-tag">Matches the given Identification or range of it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--fraglen</b> <i>length</i></dt>
  <dd class="It-tag">This option cannot be used with kernel version 2.6.10 or
      later. The length of Fragment header is static and this option doesn't
      make sense.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fragres</b></dt>
  <dd class="It-tag">Matches if the reserved fields are filled with zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fragfirst</b></dt>
  <dd class="It-tag">Matches on the first fragment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fragmore</b></dt>
  <dd class="It-tag">Matches if there are more fragments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fraglast</b></dt>
  <dd class="It-tag">Matches if this is the last fragment.</dd>
</dl>
<h2 class="Ss" title="Ss" id="hashlimit"><a class="selflink" href="#hashlimit">hashlimit</a></h2>
<b>hashlimit</b> uses hash buckets to express a rate limiting match (like the
  <b>limit</b> match) for a group of connections using a <b>single</b> iptables
  rule. Grouping can be done per-hostgroup (source and/or destination address)
  and/or per-port. It gives you the ability to express &quot; <i>N</i> packets
  per time quantum per group&quot; or &quot; <i>N</i> bytes per seconds&quot;
  (see below for some examples).
<div class="Pp"></div>
A hash limit option ( <b>--hashlimit-upto</b>, <b>--hashlimit-above</b>) and
  <b>--hashlimit-name</b> are required.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-upto</b>
    <i>amount</i>[<b>/second</b>|<b>/minute</b>| <b>/hour</b>|<b>/day</b>]</dt>
  <dd class="It-tag">Match if the rate is below or equal to
      <i>amount</i>/quantum. It is specified either as a number, with an
      optional time quantum suffix (the default is 3/hour), or as
      <i>amount</i>b/second (number of bytes per second).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-above</b>
    <i>amount</i>[<b>/second</b>|<b>/minute</b>| <b>/hour</b>|<b>/day</b>]</dt>
  <dd class="It-tag">Match if the rate is above <i>amount</i>/quantum.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-burst</b> <i>amount</i></dt>
  <dd class="It-tag">Maximum initial number of packets to match: this number
      gets recharged by one every time the limit specified above is not reached,
      up to this number; the default is 5. When byte-based rate matching is
      requested, this option specifies the amount of bytes that can exceed the
      given rate. This option should be used with caution -- if the entry
      expires, the burst value is reset too.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-mode</b>
    {<b>srcip</b>|<b>srcport</b>|<b>dstip</b>| <b>dstport</b>}<b>,</b>...</dt>
  <dd class="It-tag">A comma-separated list of objects to take into
      consideration. If no --hashlimit-mode option is given, hashlimit acts like
      limit, but at the expensive of doing the hash housekeeping.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-srcmask</b> <i>prefix</i></dt>
  <dd class="It-tag">When --hashlimit-mode srcip is used, all source addresses
      encountered will be grouped according to the given prefix length and the
      so-created subnet will be subject to hashlimit. <i>prefix</i> must be
      between (inclusive) 0 and 32. Note that --hashlimit-srcmask 0 is basically
      doing the same thing as not specifying srcip for --hashlimit-mode, but is
      technically more expensive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-dstmask</b> <i>prefix</i></dt>
  <dd class="It-tag">Like --hashlimit-srcmask, but for destination
    addresses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-name</b> <i>foo</i></dt>
  <dd class="It-tag">The name for the /proc/net/ipt_hashlimit/foo entry.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-htable-size</b> <i>buckets</i></dt>
  <dd class="It-tag">The number of buckets of the hash table</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-htable-max</b> <i>entries</i></dt>
  <dd class="It-tag">Maximum entries in the hash.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-htable-expire</b> <i>msec</i></dt>
  <dd class="It-tag">After how many milliseconds do hash entries expire.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashlimit-htable-gcinterval</b> <i>msec</i></dt>
  <dd class="It-tag">How many milliseconds between garbage collection
    intervals.</dd>
</dl>
<div class="Pp"></div>
Examples:
<dl class="Bl-tag">
  <dt class="It-tag">matching on source host</dt>
  <dd class="It-tag">&quot;1000 packets per second for every host in
      192.168.0.0/16&quot; =&gt; -s 192.168.0.0/16 --hashlimit-mode srcip
      --hashlimit-upto 1000/sec</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">matching on source port</dt>
  <dd class="It-tag">&quot;100 packets per second for every service of
      192.168.1.1&quot; =&gt; -s 192.168.1.1 --hashlimit-mode srcport
      --hashlimit-upto 100/sec</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">matching on subnet</dt>
  <dd class="It-tag">&quot;10000 packets per minute for every /28 subnet (groups
      of 8 addresses) in 10.0.0.0/8&quot; =&gt; -s 10.0.0.0/8 --hashlimit-mask
      28 --hashlimit-upto 10000/min</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">matching bytes per second</dt>
  <dd class="It-tag">&quot;flows exceeding 512kbyte/s&quot; =&gt;
      --hashlimit-mode srcip,dstip,srcport,dstport --hashlimit-above
    512kb/s</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">matching bytes per second</dt>
  <dd class="It-tag">&quot;hosts that exceed 512kbyte/s, but permit up to
      1Megabytes without matching&quot; --hashlimit-mode dstip --hashlimit-above
      512kb/s --hashlimit-burst 1mb</dd>
</dl>
<h2 class="Ss" title="Ss" id="hbh_(IPv6-specific)"><a class="selflink" href="#hbh_(IPv6-specific)">hbh
  (IPv6-specific)</a></h2>
This module matches the parameters in Hop-by-Hop Options header
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--hbh-len</b> <i>length</i></dt>
  <dd class="It-tag">Total length of this header in octets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hbh-opts</b>
    <i>type</i>[<b>:</b><i>length</i>][<b>,</b>
    <i>type</i>[<b>:</b><i>length</i>]...]</dt>
  <dd class="It-tag">numeric type of option and the length of the option data in
      octets.</dd>
</dl>
<h2 class="Ss" title="Ss" id="helper"><a class="selflink" href="#helper">helper</a></h2>
This module matches packets related to a specific conntrack-helper.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--helper</b> <i>string</i></dt>
  <dd class="It-tag">Matches packets related to the specified
    conntrack-helper.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
string can be &quot;ftp&quot; for packets related to a ftp-session on default
  port. For other ports append -portnr to the value, ie. &quot;ftp-2121&quot;.
<div class="Pp"></div>
Same rules apply for other conntrack-helpers.</div>
<h2 class="Ss" title="Ss" id="hl_(IPv6-specific)"><a class="selflink" href="#hl_(IPv6-specific)">hl
  (IPv6-specific)</a></h2>
This module matches the Hop Limit field in the IPv6 header.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--hl-eq</b> <i>value</i></dt>
  <dd class="It-tag">Matches if Hop Limit equals <i>value</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hl-lt</b> <i>value</i></dt>
  <dd class="It-tag">Matches if Hop Limit is less than <i>value</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hl-gt</b> <i>value</i></dt>
  <dd class="It-tag">Matches if Hop Limit is greater than <i>value</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="icmp_(IPv4-specific)"><a class="selflink" href="#icmp_(IPv4-specific)">icmp
  (IPv4-specific)</a></h2>
This extension can be used if `--protocol icmp' is specified. It provides the
  following option:
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--icmp-type</b>
    {<i>type</i>[<b>/</b><i>code</i>]| <i>typename</i>}</dt>
  <dd class="It-tag">This allows specification of the ICMP type, which can be a
      numeric ICMP type, type/code pair, or one of the ICMP type names shown by
      the command
    <pre>
 iptables -p icmp -h
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="icmp6_(IPv6-specific)"><a class="selflink" href="#icmp6_(IPv6-specific)">icmp6
  (IPv6-specific)</a></h2>
This extension can be used if `--protocol ipv6-icmp' or `--protocol icmpv6' is
  specified. It provides the following option:
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--icmpv6-type</b>
    <i>type</i>[<b>/</b><i>code</i>]| <i>typename</i></dt>
  <dd class="It-tag">This allows specification of the ICMPv6 type, which can be
      a numeric ICMPv6 <i>type</i>, <i>type</i> and <i>code</i>, or one of the
      ICMPv6 type names shown by the command
    <pre>
 ip6tables -p ipv6-icmp -h
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="iprange"><a class="selflink" href="#iprange">iprange</a></h2>
This matches on a given arbitrary range of IP addresses.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--src-range</b>
    <i>from</i>[<b>-</b><i>to</i>]</dt>
  <dd class="It-tag">Match source IP in the specified range.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--dst-range</b>
    <i>from</i>[<b>-</b><i>to</i>]</dt>
  <dd class="It-tag">Match destination IP in the specified range.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ipv6header_(IPv6-specific)"><a class="selflink" href="#ipv6header_(IPv6-specific)">ipv6header
  (IPv6-specific)</a></h2>
This module matches IPv6 extension headers and/or upper layer header.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--soft</b></dt>
  <dd class="It-tag">Matches if the packet includes <b>any</b> of the headers
      specified with <b>--header</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--header</b>
    <i>header</i>[<b>,</b><i>header</i>...]</dt>
  <dd class="It-tag">Matches the packet which EXACTLY includes all specified
      headers. The headers encapsulated with ESP header are out of scope.
      Possible <i>header</i> types can be:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hop</b>|<b>hop-by-hop</b></dt>
  <dd class="It-tag">Hop-by-Hop Options header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dst</b></dt>
  <dd class="It-tag">Destination Options header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>route</b></dt>
  <dd class="It-tag">Routing header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>frag</b></dt>
  <dd class="It-tag">Fragment header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>auth</b></dt>
  <dd class="It-tag">Authentication header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>esp</b></dt>
  <dd class="It-tag">Encapsulating Security Payload header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">No Next header which matches 59 in the 'Next Header field'
      of IPv6 header or any IPv6 extension headers</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>proto</b></dt>
  <dd class="It-tag">which matches any upper layer protocol header. A protocol
      name from /etc/protocols and numeric value also allowed. The number 255 is
      equivalent to <b>proto</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ipvs"><a class="selflink" href="#ipvs">ipvs</a></h2>
Match IPVS connection properties.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ipvs</b></dt>
  <dd class="It-tag">packet belongs to an IPVS connection</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Any of the following options implies --ipvs (even
    negated)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--vproto</b> <i>protocol</i></dt>
  <dd class="It-tag">VIP protocol to match; by number or name, e.g.
      &quot;tcp&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--vaddr</b>
    <i>address</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">VIP address to match</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--vport</b> <i>port</i></dt>
  <dd class="It-tag">VIP port to match; by number or name, e.g.
    &quot;http&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vdir</b> {<b>ORIGINAL</b>|<b>REPLY</b>}</dt>
  <dd class="It-tag">flow direction of packet</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--vmethod</b>
    {<b>GATE</b>|<b>IPIP</b>|<b>MASQ</b>}</dt>
  <dd class="It-tag">IPVS forwarding method used</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--vportctl</b> <i>port</i></dt>
  <dd class="It-tag">VIP port of the controlling connection to match, e.g. 21
      for FTP</dd>
</dl>
<h2 class="Ss" title="Ss" id="length"><a class="selflink" href="#length">length</a></h2>
This module matches the length of the layer-3 payload (e.g. layer-4 packet) of a
  packet against a specific value or range of values.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--length</b>
    <i>length</i>[<b>:</b><i>length</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="limit"><a class="selflink" href="#limit">limit</a></h2>
This module matches at a limited rate using a token bucket filter. A rule using
  this extension will match until this limit is reached. It can be used in
  combination with the <b>LOG</b> target to give limited logging, for example.
<div class="Pp"></div>
xt_limit has no negation support - you will have to use -m hashlimit !
  --hashlimit <i>rate</i> in this case whilst omitting --hashlimit-mode.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--limit</b>
    <i>rate</i>[<b>/second</b>|<b>/minute</b>|<b>/hour</b>|<b>/day</b>]</dt>
  <dd class="It-tag">Maximum average matching rate: specified as a number, with
      an optional `/second', `/minute', `/hour', or `/day' suffix; the default
      is 3/hour.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--limit-burst</b> <i>number</i></dt>
  <dd class="It-tag">Maximum initial number of packets to match: this number
      gets recharged by one every time the limit specified above is not reached,
      up to this number; the default is 5.</dd>
</dl>
<h2 class="Ss" title="Ss" id="mac"><a class="selflink" href="#mac">mac</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--mac-source</b> <i>address</i></dt>
  <dd class="It-tag">Match source MAC address. It must be of the form
      XX:XX:XX:XX:XX:XX. Note that this only makes sense for packets coming from
      an Ethernet device and entering the <b>PREROUTING</b>, <b>FORWARD</b> or
      <b>INPUT</b> chains.</dd>
</dl>
<h2 class="Ss" title="Ss" id="mark"><a class="selflink" href="#mark">mark</a></h2>
This module matches the netfilter mark field associated with a packet (which can
  be set using the <b>MARK</b> target below).
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--mark</b>
    <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Matches packets with the given unsigned mark value (if a
      <i>mask</i> is specified, this is logically ANDed with the <i>mask</i>
      before the comparison).</dd>
</dl>
<h2 class="Ss" title="Ss" id="mh_(IPv6-specific)"><a class="selflink" href="#mh_(IPv6-specific)">mh
  (IPv6-specific)</a></h2>
This extension is loaded if `--protocol ipv6-mh' or `--protocol mh' is
  specified. It provides the following option:
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--mh-type</b>
    <i>type</i>[<b>:</b><i>type</i>]</dt>
  <dd class="It-tag">This allows specification of the Mobility Header(MH) type,
      which can be a numeric MH <i>type</i>, <i>type</i> or one of the MH type
      names shown by the command
    <pre>
 ip6tables -p mh -h
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="multiport"><a class="selflink" href="#multiport">multiport</a></h2>
This module matches a set of source or destination ports. Up to 15 ports can be
  specified. A port range (port:port) counts as two ports. It can only be used
  in conjunction with one of the following protocols: <b>tcp</b>, <b>udp</b>,
  <b>udplite</b>, <b>dccp</b> and <b>sctp</b>.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--source-ports</b>,<b>--sports</b>
    <i>port</i>[
    <b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...</dt>
  <dd class="It-tag">Match if the source port is one of the given ports. The
      flag <b>--sports</b> is a convenient alias for this option. Multiple ports
      or port ranges are separated using a comma, and a port range is specified
      using a colon. <b>53,1024:65535</b> would therefore match ports 53 and all
      from 1024 through 65535.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--destination-ports</b>,<b>--dports</b>
    <i>port</i>[
    <b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...</dt>
  <dd class="It-tag">Match if the destination port is one of the given ports.
      The flag <b>--dports</b> is a convenient alias for this option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ports</b>
    <i>port</i>[<b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...</dt>
  <dd class="It-tag">Match if either the source or destination ports are equal
      to one of the given ports.</dd>
</dl>
<h2 class="Ss" title="Ss" id="nfacct"><a class="selflink" href="#nfacct">nfacct</a></h2>
The nfacct match provides the extended accounting infrastructure for iptables.
  You have to use this match together with the standalone user-space utility
  <b>nfacct(8)</b>
<div class="Pp"></div>
The only option available for this match is the following:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nfacct-name</b> <i>name</i></dt>
  <dd class="It-tag">This allows you to specify the existing object name that
      will be use for accounting the traffic that this rule-set is
    matching.</dd>
</dl>
<div class="Pp"></div>
To use this extension, you have to create an accounting object:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">nfacct add http-traffic</dd>
</dl>
<div class="Pp"></div>
Then, you have to attach it to the accounting object via iptables:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -I INPUT -p tcp --sport 80 -m nfacct --nfacct-name
      http-traffic</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -I OUTPUT -p tcp --dport 80 -m nfacct
      --nfacct-name http-traffic</dd>
</dl>
<div class="Pp"></div>
Then, you can check for the amount of traffic that the rules match:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">nfacct get http-traffic</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">{ pkts = 00000000000000000156, bytes = 00000000000000151786
      } = http-traffic;</dd>
</dl>
<div class="Pp"></div>
You can obtain <b>nfacct(8)</b> from http://www.netfilter.org or, alternatively,
  from the git.netfilter.org repository.
<h2 class="Ss" title="Ss" id="osf"><a class="selflink" href="#osf">osf</a></h2>
The osf module does passive operating system fingerprinting. This modules
  compares some data (Window Size, MSS, options and their order, TTL, DF, and
  others) from packets with the SYN bit set.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--genre</b> <i>string</i></dt>
  <dd class="It-tag">Match an operating system genre by using a passive
      fingerprinting.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ttl</b> <i>level</i></dt>
  <dd class="It-tag">Do additional TTL checks on the packet to determine the
      operating system. <i>level</i> can be one of the following values:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">0 - True IP address and fingerprint TTL comparison. This
      generally works for LANs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">1 - Check if the IP header's TTL is less than the
      fingerprint one. Works for globally-routable addresses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">2 - Do not compare the TTL at all.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log</b> <i>level</i></dt>
  <dd class="It-tag">Log determined genres into dmesg even if they do not match
      the desired one. <i>level</i> can be one of the following values:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">0 - Log all matched or unknown signatures</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">1 - Log only the first one</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">2 - Log all known matched signatures</dd>
</dl>
<div class="Pp"></div>
You may find something like this in syslog:
<div class="Pp"></div>
Windows [2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024 -&gt;
  11.22.33.44:139 hops=3 Linux [2.5-2.6:] : 1.2.3.4:42624 -&gt; 1.2.3.5:22
  hops=4
<div class="Pp"></div>
OS fingerprints are loadable using the <b>nfnl_osf</b> program. To load
  fingerprints from a file, use:
<div class="Pp"></div>
<b>nfnl_osf -f /usr/share/xtables/pf.os</b>
<div class="Pp"></div>
To remove them again,
<div class="Pp"></div>
<b>nfnl_osf -f /usr/share/xtables/pf.os -d</b>
<div class="Pp"></div>
The fingerprint database can be downlaoded from
  http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os .
<h2 class="Ss" title="Ss" id="owner"><a class="selflink" href="#owner">owner</a></h2>
This module attempts to match various characteristics of the packet creator, for
  locally generated packets. This match is only valid in the OUTPUT and
  POSTROUTING chains. Forwarded packets do not have any socket associated with
  them. Packets from kernel threads do have a socket, but usually no owner.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--uid-owner</b> <i>username</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--uid-owner</b>
    <i>userid</i>[<b>-</b><i>userid</i>]</dt>
  <dd class="It-tag">Matches if the packet socket's file structure (if it has
      one) is owned by the given user. You may also specify a numerical UID, or
      an UID range.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--gid-owner</b> <i>groupname</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--gid-owner</b>
    <i>groupid</i>[<b>-</b><i>groupid</i>]</dt>
  <dd class="It-tag">Matches if the packet socket's file structure is owned by
      the given group. You may also specify a numerical GID, or a GID
    range.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--socket-exists</b></dt>
  <dd class="It-tag">Matches if the packet is associated with a socket.</dd>
</dl>
<h2 class="Ss" title="Ss" id="physdev"><a class="selflink" href="#physdev">physdev</a></h2>
This module matches on the bridge port input and output devices enslaved to a
  bridge device. This module is a part of the infrastructure that enables a
  transparent bridging IP firewall and is only useful for kernel versions above
  version 2.5.44.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--physdev-in</b> <i>name</i></dt>
  <dd class="It-tag">Name of a bridge port via which a packet is received (only
      for packets entering the <b>INPUT</b>, <b>FORWARD</b> and
      <b>PREROUTING</b> chains). If the interface name ends in a &quot;+&quot;,
      then any interface which begins with this name will match. If the packet
      didn't arrive through a bridge device, this packet won't match this
      option, unless '!' is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--physdev-out</b> <i>name</i></dt>
  <dd class="It-tag">Name of a bridge port via which a packet is going to be
      sent (for packets entering the <b>FORWARD</b>, <b>OUTPUT</b> and
      <b>POSTROUTING</b> chains). If the interface name ends in a &quot;+&quot;,
      then any interface which begins with this name will match. Note that in
      the <b>nat</b> and <b>mangle</b> <b>OUTPUT</b> chains one cannot match on
      the bridge output port, however one can in the <b>filter OUTPUT</b> chain.
      If the packet won't leave by a bridge device or if it is yet unknown what
      the output device will be, then the packet won't match this option, unless
      '!' is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--physdev-is-in</b></dt>
  <dd class="It-tag">Matches if the packet has entered through a bridge
      interface.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--physdev-is-out</b></dt>
  <dd class="It-tag">Matches if the packet will leave through a bridge
      interface.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--physdev-is-bridged</b></dt>
  <dd class="It-tag">Matches if the packet is being bridged and therefore is not
      being routed. This is only useful in the FORWARD and POSTROUTING
    chains.</dd>
</dl>
<h2 class="Ss" title="Ss" id="pkttype"><a class="selflink" href="#pkttype">pkttype</a></h2>
This module matches the link-layer packet type.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--pkt-type</b>
    {<b>unicast</b>|<b>broadcast</b>| <b>multicast</b>}</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="policy"><a class="selflink" href="#policy">policy</a></h2>
This modules matches the policy used by IPsec for handling a packet.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dir</b> {<b>in</b>|<b>out</b>}</dt>
  <dd class="It-tag">Used to select whether to match the policy used for
      decapsulation or the policy that will be used for encapsulation. <b>in</b>
      is valid in the <b>PREROUTING, INPUT and FORWARD</b> chains, <b>out</b> is
      valid in the <b>POSTROUTING, OUTPUT and FORWARD</b> chains.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pol</b> {<b>none</b>|<b>ipsec</b>}</dt>
  <dd class="It-tag">Matches if the packet is subject to IPsec processing.
      <b>--pol none</b> cannot be combined with <b>--strict</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--strict</b></dt>
  <dd class="It-tag">Selects whether to match the exact policy or match if any
      rule of the policy matches the given policy.</dd>
</dl>
<div class="Pp"></div>
For each policy element that is to be described, one can use one or more of the
  following options. When <b>--strict</b> is in effect, at least one must be
  used per element.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--reqid</b> <i>id</i></dt>
  <dd class="It-tag">Matches the reqid of the policy rule. The reqid can be
      specified with <b>setkey(8)</b> using <b>unique:id</b> as level.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--spi</b> <i>spi</i></dt>
  <dd class="It-tag">Matches the SPI of the SA.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--proto</b>
    {<b>ah</b>|<b>esp</b>|<b>ipcomp</b>}</dt>
  <dd class="It-tag">Matches the encapsulation protocol.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--mode</b>
    {<b>tunnel</b>|<b>transport</b>}</dt>
  <dd class="It-tag">Matches the encapsulation mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--tunnel-src</b>
    <i>addr</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Matches the source end-point address of a tunnel mode SA.
      Only valid with <b>--mode tunnel</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--tunnel-dst</b>
    <i>addr</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Matches the destination end-point address of a tunnel mode
      SA. Only valid with <b>--mode tunnel</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--next</b></dt>
  <dd class="It-tag">Start the next element in the policy specification. Can
      only be used with <b>--strict</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="quota"><a class="selflink" href="#quota">quota</a></h2>
Implements network quotas by decrementing a byte counter with each packet. The
  condition matches until the byte counter reaches zero. Behavior is reversed
  with negation (i.e. the condition does not match until the byte counter
  reaches zero).
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--quota</b> <i>bytes</i></dt>
  <dd class="It-tag">The quota in bytes.</dd>
</dl>
<h2 class="Ss" title="Ss" id="rateest"><a class="selflink" href="#rateest">rateest</a></h2>
The rate estimator can match on estimated rates as collected by the RATEEST
  target. It supports matching on absolute bps/pps values, comparing two rate
  estimators and matching on the difference between two rate estimators.
<div class="Pp"></div>
For a better understanding of the available options, these are all possible
  combinations:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>rateest</b> <i>operator</i> <b>rateest-bps</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>rateest</b> <i>operator</i> <b>rateest-pps</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">(<b>rateest</b> minus <b>rateest-bps1</b>) <i>operator</i>
      <b>rateest-bps2</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">(<b>rateest</b> minus <b>rateest-pps1</b>) <i>operator</i>
      <b>rateest-pps2</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>rateest1</b> <i>operator</i> <b>rateest2</b>
      <b>rateest-bps</b>(without rate!)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>rateest1</b> <i>operator</i> <b>rateest2</b>
      <b>rateest-pps</b>(without rate!)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">(<b>rateest1</b> minus <b>rateest-bps1</b>) <i>operator</i>
      ( <b>rateest2</b> minus <b>rateest-bps2</b>)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">(<b>rateest1</b> minus <b>rateest-pps1</b>) <i>operator</i>
      ( <b>rateest2</b> minus <b>rateest-pps2</b>)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-delta</b></dt>
  <dd class="It-tag">For each estimator (either absolute or relative mode),
      calculate the difference between the estimator-determined flow rate and
      the static value chosen with the BPS/PPS options. If the flow rate is
      higher than the specified BPS/PPS, 0 will be used instead of a negative
      value. In other words, &quot;max(0, rateest#_rate - rateest#_bps)&quot; is
      used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--rateest-lt</b></dt>
  <dd class="It-tag">Match if rate is less than given rate/estimator.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--rateest-gt</b></dt>
  <dd class="It-tag">Match if rate is greater than given rate/estimator.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--rateest-eq</b></dt>
  <dd class="It-tag">Match if rate is equal to given rate/estimator.</dd>
</dl>
<div class="Pp"></div>
In the so-called &quot;absolute mode&quot;, only one rate estimator is used and
  compared against a static value, while in &quot;relative mode&quot;, two rate
  estimators are compared against another.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest</b> <i>name</i></dt>
  <dd class="It-tag">Name of the one rate estimator for absolute mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest1</b> <i>name</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest2</b> <i>name</i></dt>
  <dd class="It-tag">The names of the two rate estimators for relative
    mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-bps</b> [<i>value</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-pps</b> [<i>value</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-bps1</b> [<i>value</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-bps2</b> [<i>value</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-pps1</b> [<i>value</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-pps2</b> [<i>value</i>]</dt>
  <dd class="It-tag">Compare the estimator(s) by bytes or packets per second,
      and compare against the chosen value. See the above bullet list for which
      option is to be used in which case. A unit suffix may be used - available
      ones are: bit, [kmgt]bit, [KMGT]ibit, Bps, [KMGT]Bps, [KMGT]iBps.</dd>
</dl>
<div class="Pp"></div>
Example: This is what can be used to route outgoing data connections from an FTP
  server over two lines based on the available bandwidth at the time the data
  connection was started:
<div class="Pp"></div>
# Estimate outgoing rates
<div class="Pp"></div>
iptables -t mangle -A POSTROUTING -o eth0 -j RATEEST --rateest-name eth0
  --rateest-interval 250ms --rateest-ewma 0.5s
<div class="Pp"></div>
iptables -t mangle -A POSTROUTING -o ppp0 -j RATEEST --rateest-name ppp0
  --rateest-interval 250ms --rateest-ewma 0.5s
<div class="Pp"></div>
# Mark based on available bandwidth
<div class="Pp"></div>
iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp
  -m rateest --rateest-delta --rateest1 eth0 --rateest-bps1 2.5mbit --rateest-gt
  --rateest2 ppp0 --rateest-bps2 2mbit -j CONNMARK --set-mark 1
<div class="Pp"></div>
iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp
  -m rateest --rateest-delta --rateest1 ppp0 --rateest-bps1 2mbit --rateest-gt
  --rateest2 eth0 --rateest-bps2 2.5mbit -j CONNMARK --set-mark 2
<div class="Pp"></div>
iptables -t mangle -A balance -j CONNMARK --restore-mark
<h2 class="Ss" title="Ss" id="realm_(IPv4-specific)"><a class="selflink" href="#realm_(IPv4-specific)">realm
  (IPv4-specific)</a></h2>
This matches the routing realm. Routing realms are used in complex routing
  setups involving dynamic routing protocols like BGP.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--realm</b>
    <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Matches a given realm number (and optionally mask). If not
      a number, value can be a named realm from /etc/iproute2/rt_realms (mask
      can not be used in that case).</dd>
</dl>
<h2 class="Ss" title="Ss" id="recent"><a class="selflink" href="#recent">recent</a></h2>
Allows you to dynamically create a list of IP addresses and then match against
  that list in a few different ways.
<div class="Pp"></div>
For example, you can create a &quot;badguy&quot; list out of people attempting
  to connect to port 139 on your firewall and then DROP all future packets from
  them without considering them.
<div class="Pp"></div>
<b>--set</b>, <b>--rcheck</b>, <b>--update</b> and <b>--remove</b> are mutually
  exclusive.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--name</b> <i>name</i></dt>
  <dd class="It-tag">Specify the list to use for the commands. If no name is
      given then <b>DEFAULT</b> will be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--set</b></dt>
  <dd class="It-tag">This will add the source address of the packet to the list.
      If the source address is already in the list, this will update the
      existing entry. This will always return success (or failure if <b>!</b> is
      passed in).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rsource</b></dt>
  <dd class="It-tag">Match/save the source address of each packet in the recent
      list table. This is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rdest</b></dt>
  <dd class="It-tag">Match/save the destination address of each packet in the
      recent list table.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mask</b> <i>netmask</i></dt>
  <dd class="It-tag">Netmask that will be applied to this recent list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--rcheck</b></dt>
  <dd class="It-tag">Check if the source address of the packet is currently in
      the list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--update</b></dt>
  <dd class="It-tag">Like <b>--rcheck</b>, except it will update the &quot;last
      seen&quot; timestamp if it matches.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--remove</b></dt>
  <dd class="It-tag">Check if the source address of the packet is currently in
      the list and if so that address will be removed from the list and the rule
      will return true. If the address is not found, false is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seconds</b> <i>seconds</i></dt>
  <dd class="It-tag">This option must be used in conjunction with one of
      <b>--rcheck</b> or <b>--update</b>. When used, this will narrow the match
      to only happen when the address is in the list and was seen within the
      last given number of seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--reap</b></dt>
  <dd class="It-tag">This option can only be used in conjunction with
      <b>--seconds</b>. When used, this will cause entries older than the last
      given number of seconds to be purged.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hitcount</b> <i>hits</i></dt>
  <dd class="It-tag">This option must be used in conjunction with one of
      <b>--rcheck</b> or <b>--update</b>. When used, this will narrow the match
      to only happen when the address is in the list and packets had been
      received greater than or equal to the given value. This option may be used
      along with <b>--seconds</b> to create an even narrower match requiring a
      certain number of hits within a specific time frame. The maximum value for
      the hitcount parameter is given by the &quot;ip_pkt_list_tot&quot;
      parameter of the xt_recent kernel module. Exceeding this value on the
      command line will cause the rule to be rejected.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rttl</b></dt>
  <dd class="It-tag">This option may only be used in conjunction with one of
      <b>--rcheck</b> or <b>--update</b>. When used, this will narrow the match
      to only happen when the address is in the list and the TTL of the current
      packet matches that of the packet which hit the <b>--set</b> rule. This
      may be useful if you have problems with people faking their source address
      in order to DoS you via this module by disallowing others access to your
      site by sending bogus packets to you.</dd>
</dl>
<div class="Pp"></div>
Examples:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A FORWARD -m recent --name badguy --rcheck
      --seconds 60 -j DROP</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A FORWARD -p tcp -i eth0 --dport 139 -m recent
      --name badguy --set -j DROP</dd>
</dl>
<div class="Pp"></div>
<b>/proc/net/xt_recent/*</b> are the current lists of addresses and information
  about each entry of each list.
<div class="Pp"></div>
Each file in <b>/proc/net/xt_recent/</b> can be read from to see the current
  list or written two using the following commands to modify the list:
<dl class="Bl-tag">
  <dt class="It-tag"><b>echo +</b><i>addr</i><b>
    &gt;/proc/net/xt_recent/DEFAULT</b></dt>
  <dd class="It-tag">to add <i>addr</i> to the DEFAULT list</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>echo -</b><i>addr</i><b>
    &gt;/proc/net/xt_recent/DEFAULT</b></dt>
  <dd class="It-tag">to remove <i>addr</i> from the DEFAULT list</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>echo / &gt;/proc/net/xt_recent/DEFAULT</b></dt>
  <dd class="It-tag">to flush the DEFAULT list (remove all entries).</dd>
</dl>
<div class="Pp"></div>
The module itself accepts parameters, defaults shown:
<dl class="Bl-tag">
  <dt class="It-tag"><b>ip_list_tot</b>=<i>100</i></dt>
  <dd class="It-tag">Number of addresses remembered per table.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ip_pkt_list_tot</b>=<i>20</i></dt>
  <dd class="It-tag">Number of packets per address remembered.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ip_list_hash_size</b>=<i>0</i></dt>
  <dd class="It-tag">Hash table size. 0 means to calculate it based on
      ip_list_tot, default: 512.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ip_list_perms</b>=<i>0644</i></dt>
  <dd class="It-tag">Permissions for /proc/net/xt_recent/* files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ip_list_uid</b>=<i>0</i></dt>
  <dd class="It-tag">Numerical UID for ownership of /proc/net/xt_recent/*
    files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ip_list_gid</b>=<i>0</i></dt>
  <dd class="It-tag">Numerical GID for ownership of /proc/net/xt_recent/*
    files.</dd>
</dl>
<h2 class="Ss" title="Ss" id="rpfilter"><a class="selflink" href="#rpfilter">rpfilter</a></h2>
Performs a reverse path filter test on a packet. If a reply to the packet would
  be sent via the same interface that the packet arrived on, the packet will
  match. Note that, unlike the in-kernel rp_filter, packets protected by IPSec
  are not treated specially. Combine this match with the policy match if you
  want this. Also, packets arriving via the loopback interface are always
  permitted. This match can only be used in the PREROUTING chain of the raw or
  mangle table.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--loose</b></dt>
  <dd class="It-tag">Used to specifiy that the reverse path filter test should
      match even if the selected output device is not the expected one.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--validmark</b></dt>
  <dd class="It-tag">Also use the packets' nfmark value when performing the
      reverse path route lookup.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--accept-local</b></dt>
  <dd class="It-tag">This will permit packets arriving from the network with a
      source address that is also assigned to the local machine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--invert</b></dt>
  <dd class="It-tag">This will invert the sense of the match. Instead of
      matching packets that passed the reverse path filter test, match those
      that have failed it.</dd>
</dl>
<div class="Pp"></div>
Example to log and drop packets failing the reverse path filter test:
<div style="height: 1.00em;">&#x00A0;</div>
iptables -t raw -N RPFILTER
<div style="height: 1.00em;">&#x00A0;</div>
iptables -t raw -A RPFILTER -m rpfilter -j RETURN
<div style="height: 1.00em;">&#x00A0;</div>
iptables -t raw -A RPFILTER -m limit --limit 10/minute -j NFLOG --nflog-prefix
  &quot;rpfilter drop&quot;
<div style="height: 1.00em;">&#x00A0;</div>
iptables -t raw -A RPFILTER -j DROP
<div style="height: 1.00em;">&#x00A0;</div>
iptables -t raw -A PREROUTING -j RPFILTER
<div style="height: 1.00em;">&#x00A0;</div>
Example to drop failed packets, without logging:
<div style="height: 1.00em;">&#x00A0;</div>
iptables -t raw -A RPFILTER -m rpfilter --invert -j DROP
<h2 class="Ss" title="Ss" id="rt_(IPv6-specific)"><a class="selflink" href="#rt_(IPv6-specific)">rt
  (IPv6-specific)</a></h2>
Match on IPv6 routing header
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--rt-type</b> <i>type</i></dt>
  <dd class="It-tag">Match the type (numeric).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--rt-segsleft</b>
    <i>num</i>[<b>:</b><i>num</i>]</dt>
  <dd class="It-tag">Match the `segments left' field (range).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--rt-len</b> <i>length</i></dt>
  <dd class="It-tag">Match the length of this header.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rt-0-res</b></dt>
  <dd class="It-tag">Match the reserved field, too (type=0)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rt-0-addrs</b>
    <i>addr</i>[<b>,</b><i>addr</i>...]</dt>
  <dd class="It-tag">Match type=0 addresses (list).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rt-0-not-strict</b></dt>
  <dd class="It-tag">List of type=0 addresses is not a strict list.</dd>
</dl>
<h2 class="Ss" title="Ss" id="sctp"><a class="selflink" href="#sctp">sctp</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--source-port</b>,<b>--sport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--destination-port</b>,<b>--dport</b>
    <i>port</i>[ <b>:</b><i>port</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--chunk-types</b>
    {<b>all</b>|<b>any</b>|<b>only</b>} <i>chunktype</i>[<b>:</b><i>flags</i>]
    [...]</dt>
  <dd class="It-tag">The flag letter in upper case indicates that the flag is to
      match if set, in the lower case indicates to match if unset.
    <div style="height: 1.00em;">&#x00A0;</div>
    Chunk types: DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN
      SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR
      SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN
    <div style="height: 1.00em;">&#x00A0;</div>
    chunk type available flags
    <div>&#x00A0;</div>
    DATA I U B E i u b e
    <div>&#x00A0;</div>
    ABORT T t
    <div>&#x00A0;</div>
    SHUTDOWN_COMPLETE T t
    <div style="height: 1.00em;">&#x00A0;</div>
    (lowercase means flag should be &quot;off&quot;, uppercase means
      &quot;on&quot;)</dd>
</dl>
<div class="Pp"></div>
Examples:
<div style="height: 1.00em;">&#x00A0;</div>
iptables -A INPUT -p sctp --dport 80 -j DROP
<div style="height: 1.00em;">&#x00A0;</div>
iptables -A INPUT -p sctp --chunk-types any DATA,INIT -j DROP
<div style="height: 1.00em;">&#x00A0;</div>
iptables -A INPUT -p sctp --chunk-types any DATA:Be -j ACCEPT
<h2 class="Ss" title="Ss" id="set"><a class="selflink" href="#set">set</a></h2>
This module matches IP sets which can be defined by ipset(8).
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--match-set</b> <i>setname</i>
    <i>flag</i>[<b>,</b><i>flag</i>]...</dt>
  <dd class="It-tag">where flags are the comma separated list of <b>src</b>
      and/or <b>dst</b> specifications and there can be no more than six of
      them. Hence the command</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <br/>
     iptables -A FORWARD -m set --match-set test src,dst</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">will match packets, for which (if the set type is
      ipportmap) the source address and destination port pair can be found in
      the specified set. If the set type of the specified set is single
      dimension (for example ipmap), then the command will match packets for
      which the source address can be found in the specified set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--return-nomatch</b></dt>
  <dd class="It-tag">If the <b>--return-nomatch</b> option is specified and the
      set type supports the <b>nomatch</b> flag, then the matching is reversed:
      a match with an element flagged with <b>nomatch</b> returns <b>true</b>,
      while a match with a plain element returns <b>false</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>!</b> <b>--update-counters</b></dt>
  <dd class="It-tag">If the <b>--update-counters</b> flag is negated, then the
      packet and byte counters of the matching element in the set won't be
      updated. Default the packet and byte counters are updated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>!</b> <b>--update-subcounters</b></dt>
  <dd class="It-tag">If the <b>--update-subcounters</b> flag is negated, then
      the packet and byte counters of the matching element in the member set of
      a list type of set won't be updated. Default the packet and byte counters
      are updated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--packets-eq</b> <i>value</i></dt>
  <dd class="It-tag">If the packet is matched an element in the set, match only
      if the packet counter of the element matches the given value too.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--packets-lt</b> <i>value</i></dt>
  <dd class="It-tag">If the packet is matched an element in the set, match only
      if the packet counter of the element is less than the given value as
    well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--packets-gt</b> <i>value</i></dt>
  <dd class="It-tag">If the packet is matched an element in the set, match only
      if the packet counter of the element is greater than the given value as
      well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>-bytes-eq</b> <i>value</i></dt>
  <dd class="It-tag">If the packet is matched an element in the set, match only
      if the byte counter of the element matches the given value too.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bytes-lt</b> <i>value</i></dt>
  <dd class="It-tag">If the packet is matched an element in the set, match only
      if the byte counter of the element is less than the given value as
    well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bytes-gt</b> <i>value</i></dt>
  <dd class="It-tag">If the packet is matched an element in the set, match only
      if the byte counter of the element is greater than the given value as
      well.</dd>
</dl>
<div class="Pp"></div>
The packet and byte counters related options and flags are ignored when the set
  was defined without counter support.
<div class="Pp"></div>
The option <b>--match-set</b> can be replaced by <b>--set</b> if that does not
  clash with an option of other extensions.
<div class="Pp"></div>
Use of -m set requires that ipset kernel support is provided, which, for
  standard kernels, is the case since Linux 2.6.39.
<h2 class="Ss" title="Ss" id="socket"><a class="selflink" href="#socket">socket</a></h2>
This matches if an open TCP/UDP socket can be found by doing a socket lookup on
  the packet. It matches if there is an established or non-zero bound listening
  socket (possibly with a non-local address). The lookup is performed using the
  <b>packet</b> tuple of TCP/UDP packets, or the original TCP/UDP header
  <b>embedded</b> in an ICMP/ICPMv6 error packet.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--transparent</b></dt>
  <dd class="It-tag">Ignore non-transparent sockets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nowildcard</b></dt>
  <dd class="It-tag">Do not ignore sockets bound to 'any' address. The socket
      match won't accept zero-bound listeners by default, since then local
      services could intercept traffic that would otherwise be forwarded. This
      option therefore has security implications when used to match traffic
      being forwarded to redirect such packets to local machine with policy
      routing. When using the socket match to implement fully transparent
      proxies bound to non-local addresses it is recommended to use the
      --transparent option instead.</dd>
</dl>
<div class="Pp"></div>
Example (assuming packets with mark 1 are delivered locally):
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">-t mangle -A PREROUTING -m socket --transparent -j MARK
      --set-mark 1</dd>
</dl>
<h2 class="Ss" title="Ss" id="state"><a class="selflink" href="#state">state</a></h2>
The &quot;state&quot; extension is a subset of the &quot;conntrack&quot; module.
  &quot;state&quot; allows access to the connection tracking state for this
  packet.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--state</b> <i>state</i></dt>
  <dd class="It-tag">Where state is a comma separated list of the connection
      states to match. Only a subset of the states unterstood by
      &quot;conntrack&quot; are recognized: <b>INVALID</b>, <b>ESTABLISHED</b>,
      <b>NEW</b>, <b>RELATED</b> or <b>UNTRACKED</b>. For their description, see
      the &quot;conntrack&quot; heading in this manpage.</dd>
</dl>
<h2 class="Ss" title="Ss" id="statistic"><a class="selflink" href="#statistic">statistic</a></h2>
This module matches packets based on some statistic condition. It supports two
  distinct modes settable with the <b>--mode</b> option.
<div class="Pp"></div>
Supported options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mode</b> <i>mode</i></dt>
  <dd class="It-tag">Set the matching mode of the matching rule, supported modes
      are <b>random</b> and <b>nth.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--probability</b> <i>p</i></dt>
  <dd class="It-tag">Set the probability for a packet to be randomly matched. It
      only works with the <b>random</b> mode. <i>p</i> must be within 0.0 and
      1.0. The supported granularity is in 1/2147483648th increments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--every</b> <i>n</i></dt>
  <dd class="It-tag">Match one packet every nth packet. It works only with the
      <b>nth</b> mode (see also the <b>--packet</b> option).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--packet</b> <i>p</i></dt>
  <dd class="It-tag">Set the initial counter value (0 &lt;= p &lt;= n-1, default
      0) for the <b>nth</b> mode.</dd>
</dl>
<h2 class="Ss" title="Ss" id="string"><a class="selflink" href="#string">string</a></h2>
This modules matches a given string by using some pattern matching strategy. It
  requires a linux kernel &gt;= 2.6.14.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--algo</b> {<b>bm</b>|<b>kmp</b>}</dt>
  <dd class="It-tag">Select the pattern matching strategy. (bm = Boyer-Moore,
      kmp = Knuth-Pratt-Morris)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--from</b> <i>offset</i></dt>
  <dd class="It-tag">Set the offset from which it starts looking for any
      matching. If not passed, default is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--to</b> <i>offset</i></dt>
  <dd class="It-tag">Set the offset up to which should be scanned. That is, byte
      <i>offset</i>-1 (counting from 0) is the last one that is scanned. If not
      passed, default is the packet size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--string</b> <i>pattern</i></dt>
  <dd class="It-tag">Matches the given pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--hex-string</b> <i>pattern</i></dt>
  <dd class="It-tag">Matches the given pattern in hex notation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Examples:</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"># The string pattern can be used for simple text
      characters.
    <div>&#x00A0;</div>
    iptables -A INPUT -p tcp --dport 80 -m string --algo bm --string 'GET
      /index.html' -j LOG</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"># The hex string pattern can be used for non-printable
      characters, like |0D 0A| or |0D0A|.
    <div>&#x00A0;</div>
    iptables -p udp --dport 53 -m string --algo bm --from 40 --to 57
      --hex-string '|03|www|09|netfilter|03|org|00|'</dd>
</dl>
<h2 class="Ss" title="Ss" id="tcp"><a class="selflink" href="#tcp">tcp</a></h2>
These extensions can be used if `--protocol tcp' is specified. It provides the
  following options:
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--source-port</b>,<b>--sport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag">Source port or port range specification. This can either be
      a service name or a port number. An inclusive range can also be specified,
      using the format <i>first</i><b>:</b><i>last</i>. If the first port is
      omitted, &quot;0&quot; is assumed; if the last is omitted,
      &quot;65535&quot; is assumed. If the first port is greater than the second
      one they will be swapped. The flag <b>--sport</b> is a convenient alias
      for this option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--destination-port</b>,<b>--dport</b>
    <i>port</i>[ <b>:</b><i>port</i>]</dt>
  <dd class="It-tag">Destination port or port range specification. The flag
      <b>--dport</b> is a convenient alias for this option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--tcp-flags</b> <i>mask</i> <i>comp</i></dt>
  <dd class="It-tag">Match when the TCP flags are as specified. The first
      argument <i>mask</i> is the flags which we should examine, written as a
      comma-separated list, and the second argument <i>comp</i> is a
      comma-separated list of flags which must be set. Flags are: <b>SYN ACK FIN
      RST URG PSH ALL NONE</b>. Hence the command
    <pre>
 iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
    </pre>
    will only match packets with the SYN flag set, and the ACK, FIN and RST
      flags unset.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--syn</b></dt>
  <dd class="It-tag">Only match TCP packets with the SYN bit set and the ACK,RST
      and FIN bits cleared. Such packets are used to request TCP connection
      initiation; for example, blocking such packets coming in an interface will
      prevent incoming TCP connections, but outgoing TCP connections will be
      unaffected. It is equivalent to <b>--tcp-flags SYN,RST,ACK,FIN SYN</b>. If
      the &quot;!&quot; flag precedes the &quot;--syn&quot;, the sense of the
      option is inverted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--tcp-option</b> <i>number</i></dt>
  <dd class="It-tag">Match if TCP option set.</dd>
</dl>
<h2 class="Ss" title="Ss" id="tcpmss"><a class="selflink" href="#tcpmss">tcpmss</a></h2>
This matches the TCP MSS (maximum segment size) field of the TCP header. You can
  only use this on TCP SYN or SYN/ACK packets, since the MSS is only negotiated
  during the TCP handshake at connection startup time.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--mss</b>
    <i>value</i>[<b>:</b><i>value</i>]</dt>
  <dd class="It-tag">Match a given TCP MSS value or range.</dd>
</dl>
<h2 class="Ss" title="Ss" id="time"><a class="selflink" href="#time">time</a></h2>
This matches if the packet arrival time/date is within a given range. All
  options are optional, but are ANDed when specified. All times are interpreted
  as UTC by default.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--datestart</b>
    <i>YYYY</i>[<b>-</b><i>MM</i>[<b>-</b><i>DD</i>[<b>T</b><i>hh</i>[<b>:</b><i>mm</i>[<b>:</b><i>ss</i>]]]]]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--datestop</b>
    <i>YYYY</i>[<b>-</b><i>MM</i>[<b>-</b><i>DD</i>[
    <b>T</b><i>hh</i>[<b>:</b><i>mm</i>[<b>:</b><i>ss</i>]]]]]</dt>
  <dd class="It-tag">Only match during the given time, which must be in ISO 8601
      &quot;T&quot; notation. The possible time range is 1970-01-01T00:00:00 to
      2038-01-19T04:17:07.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If --datestart or --datestop are not specified, it will
      default to 1970-01-01 and 2038-01-19, respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timestart</b>
    <i>hh</i><b>:</b><i>mm</i>[<b>:</b><i>ss</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timestop</b>
    <i>hh</i><b>:</b><i>mm</i>[<b>:</b><i>ss</i>]</dt>
  <dd class="It-tag">Only match during the given daytime. The possible time
      range is 00:00:00 to 23:59:59. Leading zeroes are allowed (e.g.
      &quot;06:03&quot;) and correctly interpreted as base-10.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--monthdays</b>
    <i>day</i>[<b>,</b><i>day</i>...]</dt>
  <dd class="It-tag">Only match on the given days of the month. Possible values
      are <b>1</b> to <b>31</b>. Note that specifying <b>31</b> will of course
      not match on months which do not have a 31st day; the same goes for 28- or
      29-day February.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--weekdays</b>
    <i>day</i>[<b>,</b><i>day</i>...]</dt>
  <dd class="It-tag">Only match on the given weekdays. Possible values are
      <b>Mon</b>, <b>Tue</b>, <b>Wed</b>, <b>Thu</b>, <b>Fri</b>, <b>Sat</b>,
      <b>Sun</b>, or values from <b>1</b> to <b>7</b>, respectively. You may
      also use two-character variants ( <b>Mo</b>, <b>Tu</b>, etc.).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--contiguous</b></dt>
  <dd class="It-tag">When <b>--timestop</b> is smaller than <b>--timestart</b>
      value, match this as a single time period instead distinct intervals. See
      EXAMPLES.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--kerneltz</b></dt>
  <dd class="It-tag">Use the kernel timezone instead of UTC to determine whether
      a packet meets the time regulations.</dd>
</dl>
<div class="Pp"></div>
About kernel timezones: Linux keeps the system time in UTC, and always does so.
  On boot, system time is initialized from a referential time source. Where this
  time source has no timezone information, such as the x86 CMOS RTC, UTC will be
  assumed. If the time source is however not in UTC, userspace should provide
  the correct system time and timezone to the kernel once it has the
  information.
<div class="Pp"></div>
Local time is a feature on top of the (timezone independent) system time. Each
  process has its own idea of local time, specified via the TZ environment
  variable. The kernel also has its own timezone offset variable. The TZ
  userspace environment variable specifies how the UTC-based system time is
  displayed, e.g. when you run date(1), or what you see on your desktop clock.
  The TZ string may resolve to different offsets at different dates, which is
  what enables the automatic time-jumping in userspace. when DST changes. The
  kernel's timezone offset variable is used when it has to convert between
  non-UTC sources, such as FAT filesystems, to UTC (since the latter is what the
  rest of the system uses).
<div class="Pp"></div>
The caveat with the kernel timezone is that Linux distributions may ignore to
  set the kernel timezone, and instead only set the system time. Even if a
  particular distribution does set the timezone at boot, it is usually does not
  keep the kernel timezone offset - which is what changes on DST - up to date.
  ntpd will not touch the kernel timezone, so running it will not resolve the
  issue. As such, one may encounter a timezone that is always +0000, or one that
  is wrong half of the time of the year. As such, <b>using --kerneltz is
  highly</b> <b>discouraged.</b>
<div class="Pp"></div>
EXAMPLES. To match on weekends, use:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">-m time --weekdays Sa,Su</dd>
</dl>
<div class="Pp"></div>
Or, to match (once) on a national holiday block:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">-m time --datestart 2007-12-24 --datestop 2007-12-27</dd>
</dl>
<div class="Pp"></div>
Since the stop time is actually inclusive, you would need the following stop
  time to not match the first second of the new day:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">-m time --datestart 2007-01-01T17:00 --datestop
      2007-01-01T23:59:59</dd>
</dl>
<div class="Pp"></div>
During lunch hour:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">-m time --timestart 12:30 --timestop 13:30</dd>
</dl>
<div class="Pp"></div>
The fourth Friday in the month:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">-m time --weekdays Fr --monthdays 22,23,24,25,26,27,28</dd>
</dl>
<div class="Pp"></div>
(Note that this exploits a certain mathematical property. It is not possible to
  say &quot;fourth Thursday OR fourth Friday&quot; in one rule. It is possible
  with multiple rules, though.)
<div class="Pp"></div>
Matching across days might not do what is expected. For instance,
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">-m time --weekdays Mo --timestart 23:00 --timestop 01:00
      Will match Monday, for one hour from midnight to 1 a.m., and then again
      for another hour from 23:00 onwards. If this is unwanted, e.g. if you
      would like 'match for two hours from Montay 23:00 onwards' you need to
      also specify the --contiguous option in the example above.</dd>
</dl>
<h2 class="Ss" title="Ss" id="tos"><a class="selflink" href="#tos">tos</a></h2>
This module matches the 8-bit Type of Service field in the IPv4 header (i.e.
  including the &quot;Precedence&quot; bits) or the (also 8-bit) Priority field
  in the IPv6 header.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--tos</b>
    <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Matches packets with the given TOS mark value. If a mask is
      specified, it is logically ANDed with the TOS mark before the
    comparison.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--tos</b> <i>symbol</i></dt>
  <dd class="It-tag">You can specify a symbolic name when using the tos match
      for IPv4. The list of recognized TOS names can be obtained by calling
      iptables with <b>-m tos -h</b>. Note that this implies a mask of 0x3F,
      i.e. all but the ECN bits.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ttl_(IPv4-specific)"><a class="selflink" href="#ttl_(IPv4-specific)">ttl
  (IPv4-specific)</a></h2>
This module matches the time to live field in the IP header.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--ttl-eq</b> <i>ttl</i></dt>
  <dd class="It-tag">Matches the given TTL value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ttl-gt</b> <i>ttl</i></dt>
  <dd class="It-tag">Matches if TTL is greater than the given TTL value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ttl-lt</b> <i>ttl</i></dt>
  <dd class="It-tag">Matches if TTL is less than the given TTL value.</dd>
</dl>
<h2 class="Ss" title="Ss" id="u32"><a class="selflink" href="#u32">u32</a></h2>
U32 tests whether quantities of up to 4 bytes extracted from a packet have
  specified values. The specification of what to extract is general enough to
  find data at given offsets from tcp headers or payloads.
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--u32</b> <i>tests</i></dt>
  <dd class="It-tag">The argument amounts to a program in a small language
      described below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">tests := location &quot;=&quot; value | tests
      &quot;&amp;&amp;&quot; location &quot;=&quot; value</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">value := range | value &quot;,&quot; range</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">range := number | number &quot;:&quot; number</dd>
</dl>
<div class="Pp"></div>
a single number, <i>n</i>, is interpreted the same as <i>n:n</i>. <i>n:m</i> is
  interpreted as the range of numbers <b>&gt;=n</b> and <b>&lt;=m</b>.
<dl class="Bl-tag">
  <dt class="It-tag">
  <div class="Pp"></div>
  </dt>
  <dd class="It-tag">location := number | location operator number</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">
  <div class="Pp"></div>
  </dt>
  <dd class="It-tag">operator := &quot;&amp;&quot; | &quot;&lt;&lt;&quot; |
      &quot;&gt;&gt;&quot; | &quot;@&quot;</dd>
</dl>
<div class="Pp"></div>
The operators <b>&amp;</b>, <b>&lt;&lt;</b>, <b>&gt;&gt;</b> and
  <b>&amp;&amp;</b> mean the same as in C. The <b>=</b> is really a set
  membership operator and the value syntax describes a set. The <b>@</b>
  operator is what allows moving to the next header and is described further
  below.
<div class="Pp"></div>
There are currently some artificial implementation limits on the size of the
  tests:
<dl class="Bl-tag">
  <dt class="It-tag"> *</dt>
  <dd class="It-tag">no more than 10 of &quot;<b>=</b>&quot; (and 9
      &quot;<b>&amp;&amp;</b>&quot;s) in the u32 argument</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> *</dt>
  <dd class="It-tag">no more than 10 ranges (and 9 commas) per value</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> *</dt>
  <dd class="It-tag">no more than 10 numbers (and 9 operators) per location</dd>
</dl>
<div class="Pp"></div>
To describe the meaning of location, imagine the following machine that
  interprets it. There are three registers:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A is of type <b>char *</b>, initially the address of the IP
      header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">B and C are unsigned 32 bit integers, initially zero</dd>
</dl>
<div class="Pp"></div>
The instructions are:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">number B = number;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">C = (*(A+B)&lt;&lt;24) + (*(A+B+1)&lt;&lt;16) +
      (*(A+B+2)&lt;&lt;8) + *(A+B+3)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">&amp;number C = C &amp; number</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">&lt;&lt; number C = C &lt;&lt; number</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">&gt;&gt; number C = C &gt;&gt; number</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">@number A = A + C; then do the instruction number</dd>
</dl>
<div class="Pp"></div>
Any access of memory outside [skb-&gt;data,skb-&gt;end] causes the match to
  fail. Otherwise the result of the computation is the final value of C.
<div class="Pp"></div>
Whitespace is allowed but not required in the tests. However, the characters
  that do occur there are likely to require shell quoting, so it is a good idea
  to enclose the arguments in quotes.
<div class="Pp"></div>
Example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">match IP packets with total length &gt;= 256</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The IP header contains a total length field in bytes
    2-3.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">--u32 &quot;<b>0 &amp; 0xFFFF = 0x100:0xFFFF</b>&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">read bytes 0-3</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">AND that with 0xFFFF (giving bytes 2-3), and test whether
      that is in the range [0x100:0xFFFF]</dd>
</dl>
<div class="Pp"></div>
Example: (more realistic, hence more complicated)
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">match ICMP packets with icmp type 0</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">First test that it is an ICMP packet, true iff byte 9
      (protocol) = 1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">--u32 &quot;<b>6 &amp; 0xFF = 1 &amp;&amp;</b> ...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">read bytes 6-9, use <b>&amp;</b> to throw away bytes 6-8
      and compare the result to 1. Next test that it is not a fragment. (If so,
      it might be part of such a packet but we cannot always tell.) N.B.: This
      test is generally needed if you want to match anything beyond the IP
      header. The last 6 bits of byte 6 and all of byte 7 are 0 iff this is a
      complete packet (not a fragment). Alternatively, you can allow first
      fragments by only testing the last 5 bits of byte 6.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <br/>
     ... <b>4 &amp; 0x3FFF = 0 &amp;&amp;</b> ...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Last test: the first byte past the IP header (the type) is
      0. This is where we have to use the @syntax. The length of the IP header
      (IHL) in 32 bit words is stored in the right half of byte 0 of the IP
      header itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <br/>
     ... <b>0 &gt;&gt; 22 &amp; 0x3C @ 0 &gt;&gt; 24 = 0</b>&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The first 0 means read bytes 0-3, <b>&gt;&gt;22</b> means
      shift that 22 bits to the right. Shifting 24 bits would give the first
      byte, so only 22 bits is four times that plus a few more bits.
      <b>&amp;3C</b> then eliminates the two extra bits on the right and the
      first four bits of the first byte. For instance, if IHL=5, then the IP
      header is 20 (4 x 5) bytes long. In this case, bytes 0-1 are (in binary)
      xxxx0101 yyzzzzzz, <b>&gt;&gt;22</b> gives the 10 bit value xxxx0101yy and
      <b>&amp;3C</b> gives 010100. <b>@</b> means to use this number as a new
      offset into the packet, and read four bytes starting from there. This is
      the first 4 bytes of the ICMP payload, of which byte 0 is the ICMP type.
      Therefore, we simply shift the value 24 to the right to throw out all but
      the first byte and compare the result with 0.</dd>
</dl>
<div class="Pp"></div>
Example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">TCP payload bytes 8-12 is any of 1, 2, 5 or 8</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">First we test that the packet is a tcp packet (similar to
      ICMP).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">--u32 &quot;<b>6 &amp; 0xFF = 6 &amp;&amp;</b> ...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Next, test that it is not a fragment (same as above).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <br/>
     ... <b>0 &gt;&gt; 22 &amp; 0x3C @ 12 &gt;&gt; 26 &amp; 0x3C @ 8 =
      1,2,5,8</b>&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>0&gt;&gt;22&amp;3C</b> as above computes the number of
      bytes in the IP header. <b>@</b> makes this the new offset into the
      packet, which is the start of the TCP header. The length of the TCP header
      (again in 32 bit words) is the left half of byte 12 of the TCP header. The
      <b>12&gt;&gt;26&amp;3C</b> computes this length in bytes (similar to the
      IP header before). &quot;@&quot; makes this the new offset, which is the
      start of the TCP payload. Finally, 8 reads bytes 8-12 of the payload and
      <b>=</b> checks whether the result is any of 1, 2, 5 or 8.</dd>
</dl>
<h2 class="Ss" title="Ss" id="udp"><a class="selflink" href="#udp">udp</a></h2>
These extensions can be used if `--protocol udp' is specified. It provides the
  following options:
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--source-port</b>,<b>--sport</b>
    <i>port</i>[<b>:</b><i>port</i>]</dt>
  <dd class="It-tag">Source port or port range specification. See the
      description of the <b>--source-port</b> option of the TCP extension for
      details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[<b>!</b>] <b>--destination-port</b>,<b>--dport</b>
    <i>port</i>[ <b>:</b><i>port</i>]</dt>
  <dd class="It-tag">Destination port or port range specification. See the
      description of the <b>--destination-port</b> option of the TCP extension
      for details.</dd>
</dl>
<h2 class="Ss" title="Ss" id="unclean_(IPv4-specific)"><a class="selflink" href="#unclean_(IPv4-specific)">unclean
  (IPv4-specific)</a></h2>
This module takes no options, but attempts to match packets which seem malformed
  or unusual. This is regarded as experimental.
<h1 class="Sh" title="Sh" id="TARGET_EXTENSIONS"><a class="selflink" href="#TARGET_EXTENSIONS">TARGET
  EXTENSIONS</a></h1>
iptables can use extended target modules: the following are included in the
  standard distribution.
<h2 class="Ss" title="Ss" id="AUDIT"><a class="selflink" href="#AUDIT">AUDIT</a></h2>
This target allows to create audit records for packets hitting the target. It
  can be used to record accepted, dropped, and rejected packets. See auditd(8)
  for additional details.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--type</b>
    {<b>accept</b>|<b>drop</b>|<b>reject</b>}</dt>
  <dd class="It-tag">Set type of audit record.</dd>
</dl>
<div class="Pp"></div>
Example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -N AUDIT_DROP</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A AUDIT_DROP -j AUDIT --type drop</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">iptables -A AUDIT_DROP -j DROP</dd>
</dl>
<h2 class="Ss" title="Ss" id="CHECKSUM"><a class="selflink" href="#CHECKSUM">CHECKSUM</a></h2>
This target allows to selectively work around broken/old applications. It can
  only be used in the mangle table.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--checksum-fill</b></dt>
  <dd class="It-tag">Compute and fill in the checksum in a packet that lacks a
      checksum. This is particularly useful, if you need to work around old
      applications such as dhcp clients, that do not work well with checksum
      offloads, but don't want to disable checksum offload in your device.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CLASSIFY"><a class="selflink" href="#CLASSIFY">CLASSIFY</a></h2>
This module allows you to set the skb-&gt;priority value (and thus classify the
  packet into a specific CBQ class).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-class</b> <i>major</i><b>:</b><i>minor</i></dt>
  <dd class="It-tag">Set the major and minor class value. The values are always
      interpreted as hexadecimal even if no 0x prefix is given.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CLUSTERIP_(IPv4-specific)"><a class="selflink" href="#CLUSTERIP_(IPv4-specific)">CLUSTERIP
  (IPv4-specific)</a></h2>
This module allows you to configure a simple cluster of nodes that share a
  certain IP and MAC address without an explicit load balancer in front of them.
  Connections are statically distributed between the nodes in this cluster.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--new</b></dt>
  <dd class="It-tag">Create a new ClusterIP. You always have to set this on the
      first rule for a given ClusterIP.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashmode</b> <i>mode</i></dt>
  <dd class="It-tag">Specify the hashing mode. Has to be one of <b>sourceip</b>,
      <b>sourceip-sourceport</b>, <b>sourceip-sourceport-destport</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clustermac</b> <i>mac</i></dt>
  <dd class="It-tag">Specify the ClusterIP MAC address. Has to be a link-layer
      multicast address</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--total-nodes</b> <i>num</i></dt>
  <dd class="It-tag">Number of total nodes within this cluster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--local-node</b> <i>num</i></dt>
  <dd class="It-tag">Local node number within this cluster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hash-init</b> <i>rnd</i></dt>
  <dd class="It-tag">Specify the random seed used for hash initialization.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CONNMARK"><a class="selflink" href="#CONNMARK">CONNMARK</a></h2>
This module sets the netfilter mark value associated with a connection. The mark
  is 32 bits wide.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-xmark</b> <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Zero out the bits given by <i>mask</i> and XOR <i>value</i>
      into the ctmark.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--save-mark</b> [<b>--nfmask</b> <i>nfmask</i>]
    [<b>--ctmask</b> <i>ctmask</i>]</dt>
  <dd class="It-tag">Copy the packet mark (nfmark) to the connection mark
      (ctmark) using the given masks. The new nfmark value is determined as
      follows:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">ctmark = (ctmark &amp; ~ctmask) ^ (nfmark &amp;
    nfmask)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">i.e. <i>ctmask</i> defines what bits to clear and
      <i>nfmask</i> what bits of the nfmark to XOR into the ctmark.
      <i>ctmask</i> and <i>nfmask</i> default to 0xFFFFFFFF.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--restore-mark</b> [<b>--nfmask</b> <i>nfmask</i>]
    [<b>--ctmask</b> <i>ctmask</i>]</dt>
  <dd class="It-tag">Copy the connection mark (ctmark) to the packet mark
      (nfmark) using the given masks. The new ctmark value is determined as
      follows:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">nfmark = (nfmark &amp; ~<i>nfmask</i>) ^ (ctmark &amp;
      <i>ctmask</i>);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">i.e. <i>nfmask</i> defines what bits to clear and
      <i>ctmask</i> what bits of the ctmark to XOR into the nfmark.
      <i>ctmask</i> and <i>nfmask</i> default to 0xFFFFFFFF.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>--restore-mark</b> is only valid in the <b>mangle</b>
      table.</dd>
</dl>
<div class="Pp"></div>
The following mnemonics are available for <b>--set-xmark</b>:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--and-mark</b> <i>bits</i></dt>
  <dd class="It-tag">Binary AND the ctmark with <i>bits</i>. (Mnemonic for
      <b>--set-xmark</b> <b>0/</b><i>invbits</i>, where <i>invbits</i> is the
      binary negation of <i>bits</i>.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--or-mark</b> <i>bits</i></dt>
  <dd class="It-tag">Binary OR the ctmark with <i>bits</i>. (Mnemonic for
      <b>--set-xmark</b> <i>bits</i><b>/</b><i>bits</i>.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xor-mark</b> <i>bits</i></dt>
  <dd class="It-tag">Binary XOR the ctmark with <i>bits</i>. (Mnemonic for
      <b>--set-xmark</b> <i>bits</i><b>/0</b>.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-mark</b> <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Set the connection mark. If a mask is specified then only
      those bits set in the mask are modified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--save-mark</b> [<b>--mask</b> <i>mask</i>]</dt>
  <dd class="It-tag">Copy the nfmark to the ctmark. If a mask is specified, only
      those bits are copied.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--restore-mark</b> [<b>--mask</b> <i>mask</i>]</dt>
  <dd class="It-tag">Copy the ctmark to the nfmark. If a mask is specified, only
      those bits are copied. This is only valid in the <b>mangle</b> table.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CONNSECMARK"><a class="selflink" href="#CONNSECMARK">CONNSECMARK</a></h2>
This module copies security markings from packets to connections (if unlabeled),
  and from connections back to packets (also only if unlabeled). Typically used
  in conjunction with SECMARK, it is valid in the <b>security</b> table (for
  backwards compatibility with older kernels, it is also valid in the
  <b>mangle</b> table).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--save</b></dt>
  <dd class="It-tag">If the packet has a security marking, copy it to the
      connection if the connection is not marked.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--restore</b></dt>
  <dd class="It-tag">If the packet does not have a security marking, and the
      connection does, copy the security marking from the connection to the
      packet.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="CT"><a class="selflink" href="#CT">CT</a></h2>
The CT target allows to set parameters for a packet or its associated
  connection. The target attaches a &quot;template&quot; connection tracking
  entry to the packet, which is then used by the conntrack core when
  initializing a new ct entry. This target is thus only valid in the
  &quot;raw&quot; table.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--notrack</b></dt>
  <dd class="It-tag">Disables connection tracking for this packet.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--helper</b> <i>name</i></dt>
  <dd class="It-tag">Use the helper identified by <i>name</i> for the
      connection. This is more flexible than loading the conntrack helper
      modules with preset ports.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ctevents</b> <i>event</i>[<b>,</b>...]</dt>
  <dd class="It-tag">Only generate the specified conntrack events for this
      connection. Possible event types are: <b>new</b>, <b>related</b>,
      <b>destroy</b>, <b>reply</b>, <b>assured</b>, <b>protoinfo</b>,
      <b>helper</b>, <b>mark</b> (this refers to the ctmark, not nfmark),
      <b>natseqinfo</b>, <b>secmark</b> (ctsecmark).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--expevents</b> <i>event</i>[<b>,</b>...]</dt>
  <dd class="It-tag">Only generate the specified expectation events for this
      connection. Possible event types are: <b>new</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zone</b> <i>id</i></dt>
  <dd class="It-tag">Assign this packet to zone <i>id</i> and only have lookups
      done in that zone. By default, packets have zone 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timeout</b> <i>name</i></dt>
  <dd class="It-tag">Use the timeout policy identified by <i>name</i> for the
      connection. This is provides more flexible timeout policy definition than
      global timeout values available at
      /proc/sys/net/netfilter/nf_conntrack_*_timeout_*.</dd>
</dl>
<h2 class="Ss" title="Ss" id="DNAT"><a class="selflink" href="#DNAT">DNAT</a></h2>
This target is only valid in the <b>nat</b> table, in the <b>PREROUTING</b> and
  <b>OUTPUT</b> chains, and user-defined chains which are only called from those
  chains. It specifies that the destination address of the packet should be
  modified (and all future packets in this connection will also be mangled), and
  rules should cease being examined. It takes the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--to-destination</b>
    [<i>ipaddr</i>[<b>-</b><i>ipaddr</i>]][
    <b>:</b><i>port</i>[<b>-</b><i>port</i>]]</dt>
  <dd class="It-tag">which can specify a single new destination IP address, an
      inclusive range of IP addresses. Optionally a port range, if the rule also
      specifies one of the following protocols: <b>tcp</b>, <b>udp</b>,
      <b>dccp</b> or <b>sctp</b>. If no port range is specified, then the
      destination port will never be modified. If no IP address is specified
      then only the destination port will be modified. In Kernels up to 2.6.10
      you can add several --to-destination options. For those kernels, if you
      specify more than one destination address, either via an address range or
      multiple --to-destination options, a simple round-robin (one after another
      in cycle) load balancing takes place between these addresses. Later
      Kernels (&gt;= 2.6.11-rc1) don't have the ability to NAT to multiple
      ranges anymore.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--random</b></dt>
  <dd class="It-tag">If option <b>--random</b> is used then port mapping will be
      randomized (kernel &gt;= 2.6.22).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--persistent</b></dt>
  <dd class="It-tag">Gives a client the same source-/destination-address for
      each connection. This supersedes the SAME target. Support for persistent
      mappings is available from 2.6.29-rc2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">IPv6 support available since Linux kernels &gt;= 3.7.</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="DNPT_(IPv6-specific)"><a class="selflink" href="#DNPT_(IPv6-specific)">DNPT
  (IPv6-specific)</a></h2>
Provides stateless destination IPv6-to-IPv6 Network Prefix Translation (as
  described by RFC 6296).
<div class="Pp"></div>
You have to use this target in the <b>mangle</b> table, not in the <b>nat</b>
  table. It takes the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--src-pfx</b> [<i>prefix/</i><i>length]</i></dt>
  <dd class="It-tag">Set source prefix that you want to translate and
    length</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dst-pfx</b> [<i>prefix/</i><i>length]</i></dt>
  <dd class="It-tag">Set destination prefix that you want to use in the
      translation and length</dd>
</dl>
<div class="Pp"></div>
You have to use the SNPT target to undo the translation. Example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">ip6tables -t mangle -I POSTROUTING -s fd00::/64 ! -o
      vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx 2001:e20:2000:40f::/64</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">ip6tables -t mangle -I PREROUTING -i wlan0 -d
      2001:e20:2000:40f::/64 -j DNPT --src-pfx 2001:e20:2000:40f::/64 --dst-pfx
      fd00::/64</dd>
</dl>
<div class="Pp"></div>
You may need to enable IPv6 neighbor proxy:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">sysctl -w net.ipv6.conf.all.proxy_ndp=1</dd>
</dl>
<div class="Pp"></div>
You also have to use the <b>NOTRACK</b> target to disable connection tracking
  for translated flows.
<h2 class="Ss" title="Ss" id="DSCP"><a class="selflink" href="#DSCP">DSCP</a></h2>
This target allows to alter the value of the DSCP bits within the TOS header of
  the IPv4 packet. As this manipulates a packet, it can only be used in the
  mangle table.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-dscp</b> <i>value</i></dt>
  <dd class="It-tag">Set the DSCP field to a numerical value (can be decimal or
      hex)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-dscp-class</b> <i>class</i></dt>
  <dd class="It-tag">Set the DSCP field to a DiffServ class.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ECN_(IPv4-specific)"><a class="selflink" href="#ECN_(IPv4-specific)">ECN
  (IPv4-specific)</a></h2>
This target allows to selectively work around known ECN blackholes. It can only
  be used in the mangle table.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ecn-tcp-remove</b></dt>
  <dd class="It-tag">Remove all ECN bits from the TCP header. Of course, it can
      only be used in conjunction with <b>-p tcp</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="HL_(IPv6-specific)"><a class="selflink" href="#HL_(IPv6-specific)">HL
  (IPv6-specific)</a></h2>
This is used to modify the Hop Limit field in IPv6 header. The Hop Limit field
  is similar to what is known as TTL value in IPv4. Setting or incrementing the
  Hop Limit field can potentially be very dangerous, so it should be avoided at
  any cost. This target is only valid in <b>mangle</b> table.
<div class="Pp"></div>
<b>Don't ever set or increment the value on packets that leave your local
  network!</b>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hl-set</b> <i>value</i></dt>
  <dd class="It-tag">Set the Hop Limit to `value'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hl-dec</b> <i>value</i></dt>
  <dd class="It-tag">Decrement the Hop Limit `value' times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hl-inc</b> <i>value</i></dt>
  <dd class="It-tag">Increment the Hop Limit `value' times.</dd>
</dl>
<h2 class="Ss" title="Ss" id="HMARK"><a class="selflink" href="#HMARK">HMARK</a></h2>
Like MARK, i.e. set the fwmark, but the mark is calculated from hashing packet
  selector at choice. You have also to specify the mark range and, optionally,
  the offset to start from. ICMP error messages are inspected and used to
  calculate the hashing.
<div class="Pp"></div>
Existing options are:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-tuple</b> tuple<i></i></dt>
  <dd class="It-tag">Possible tuple members are: <b>src</b> meaning source
      address (IPv4, IPv6 address), <b>dst</b> meaning destination address
      (IPv4, IPv6 address), <b>sport</b> meaning source port (TCP, UDP, UDPlite,
      SCTP, DCCP), <b>dport</b> meaning destination port (TCP, UDP, UDPlite,
      SCTP, DCCP), <b>spi</b> meaning Security Parameter Index (AH, ESP), and
      <b>ct</b> meaning the usage of the conntrack tuple instead of the packet
      selectors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-mod</b> <i>value (must be &gt; 0)</i></dt>
  <dd class="It-tag">Modulus for hash calculation (to limit the range of
      possible marks)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-offset</b> <i>value</i></dt>
  <dd class="It-tag">Offset to start marks from.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">For advanced usage, instead of using --hmark-tuple, you can
    specify custom</dt>
  <dd class="It-tag">prefixes and masks:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-src-prefix</b> <i>cidr</i></dt>
  <dd class="It-tag">The source address mask in CIDR notation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-dst-prefix</b> <i>cidr</i></dt>
  <dd class="It-tag">The destination address mask in CIDR notation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-sport-mask</b> <i>value</i></dt>
  <dd class="It-tag">A 16 bit source port mask in hexadecimal.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-dport-mask</b> <i>value</i></dt>
  <dd class="It-tag">A 16 bit destination port mask in hexadecimal.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-spi-mask</b> <i>value</i></dt>
  <dd class="It-tag">A 32 bit field with spi mask.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-proto-mask</b> <i>value</i></dt>
  <dd class="It-tag">An 8 bit field with layer 4 protocol number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hmark-rnd</b> <i>value</i></dt>
  <dd class="It-tag">A 32 bit random custom value to feed hash calculation.</dd>
</dl>
<div class="Pp"></div>
<i>Examples:</i>
<div class="Pp"></div>
iptables -t mangle -A PREROUTING -m conntrack --ctstate NEW
<br/>
 -j HMARK --hmark-tuple ct,src,dst,proto --hmark-offset 10000 --hmark-mod 10
  --hmark-rnd 0xfeedcafe
<div class="Pp"></div>
iptables -t mangle -A PREROUTING -j HMARK --hmark-offset 10000 --hmark-tuple
  src,dst,proto --hmark-mod 10 --hmark-rnd 0xdeafbeef
<h2 class="Ss" title="Ss" id="IDLETIMER"><a class="selflink" href="#IDLETIMER">IDLETIMER</a></h2>
This target can be used to identify when interfaces have been idle for a certain
  period of time. Timers are identified by labels and are created when a rule is
  set with a new label. The rules also take a timeout value (in seconds) as an
  option. If more than one rule uses the same timer label, the timer will be
  restarted whenever any of the rules get a hit. One entry for each timer is
  created in sysfs. This attribute contains the timer remaining for the timer to
  expire. The attributes are located under the xt_idletimer class:
<div class="Pp"></div>
/sys/class/xt_idletimer/timers/&lt;label&gt;
<div class="Pp"></div>
When the timer expires, the target module sends a sysfs notification to the
  userspace, which can then decide what to do (eg. disconnect to save power).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timeout</b> <i>amount</i></dt>
  <dd class="It-tag">This is the time in seconds that will trigger the
      notification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--label</b> <i>string</i></dt>
  <dd class="It-tag">This is a unique identifier for the timer. The maximum
      length for the label string is 27 characters.</dd>
</dl>
<h2 class="Ss" title="Ss" id="LED"><a class="selflink" href="#LED">LED</a></h2>
This creates an LED-trigger that can then be attached to system indicator
  lights, to blink or illuminate them when certain packets pass through the
  system. One example might be to light up an LED for a few minutes every time
  an SSH connection is made to the local machine. The following options control
  the trigger behavior:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--led-trigger-id</b> <i>name</i></dt>
  <dd class="It-tag">This is the name given to the LED trigger. The actual name
      of the trigger will be prefixed with &quot;netfilter-&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--led-delay</b> <i>ms</i></dt>
  <dd class="It-tag">This indicates how long (in milliseconds) the LED should be
      left illuminated when a packet arrives before being switched off again.
      The default is 0 (blink as fast as possible.) The special value <i>inf</i>
      can be given to leave the LED on permanently once activated. (In this case
      the trigger will need to be manually detached and reattached to the LED
      device to switch it off again.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--led-always-blink</b></dt>
  <dd class="It-tag">Always make the LED blink on packet arrival, even if the
      LED is already on. This allows notification of new packets even with long
      delay values (which otherwise would result in a silent prolonging of the
      delay time.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Example:</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Create an LED trigger for incoming SSH traffic:</dt>
  <dd class="It-tag">iptables -A INPUT -p tcp --dport 22 -j LED --led-trigger-id
      ssh</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Then attach the new trigger to an LED:</dt>
  <dd class="It-tag">echo netfilter-ssh
      &gt;/sys/class/leds/<i>ledname</i>/trigger</dd>
</dl>
<h2 class="Ss" title="Ss" id="LOG"><a class="selflink" href="#LOG">LOG</a></h2>
Turn on kernel logging of matching packets. When this option is set for a rule,
  the Linux kernel will print some information on all matching packets (like
  most IP/IPv6 header fields) via the kernel log (where it can be read with
  <i>dmesg(1)</i> or read in the syslog).
<div class="Pp"></div>
This is a &quot;non-terminating target&quot;, i.e. rule traversal continues at
  the next rule. So if you want to LOG the packets you refuse, use two separate
  rules with the same matching criteria, first using target LOG then DROP (or
  REJECT).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-level</b> <i>level</i></dt>
  <dd class="It-tag">Level of logging, which can be (system-specific) numeric or
      a mnemonic. Possible values are (in decreasing order of priority):
      <b>emerg</b>, <b>alert</b>, <b>crit</b>, <b>error</b>, <b>warning</b>,
      <b>notice</b>, <b>info</b> or <b>debug</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-prefix</b> <i>prefix</i></dt>
  <dd class="It-tag">Prefix log messages with the specified prefix; up to 29
      letters long, and useful for distinguishing messages in the logs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-tcp-sequence</b></dt>
  <dd class="It-tag">Log TCP sequence numbers. This is a security risk if the
      log is readable by users.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-tcp-options</b></dt>
  <dd class="It-tag">Log options from the TCP packet header.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-ip-options</b></dt>
  <dd class="It-tag">Log options from the IP/IPv6 packet header.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-uid</b></dt>
  <dd class="It-tag">Log the userid of the process which generated the
    packet.</dd>
</dl>
<h2 class="Ss" title="Ss" id="MARK"><a class="selflink" href="#MARK">MARK</a></h2>
This target is used to set the Netfilter mark value associated with the packet.
  It can, for example, be used in conjunction with routing based on fwmark
  (needs iproute2). If you plan on doing so, note that the mark needs to be set
  in the PREROUTING chain of the mangle table to affect routing. The mark field
  is 32 bits wide.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-xmark</b> <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Zeroes out the bits given by <i>mask</i> and XORs
      <i>value</i> into the packet mark (&quot;nfmark&quot;). If <i>mask</i> is
      omitted, 0xFFFFFFFF is assumed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-mark</b> <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Zeroes out the bits given by <i>mask</i> and ORs
      <i>value</i> into the packet mark. If <i>mask</i> is omitted, 0xFFFFFFFF
      is assumed.</dd>
</dl>
<div class="Pp"></div>
The following mnemonics are available:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--and-mark</b> <i>bits</i></dt>
  <dd class="It-tag">Binary AND the nfmark with <i>bits</i>. (Mnemonic for
      <b>--set-xmark</b> <b>0/</b><i>invbits</i>, where <i>invbits</i> is the
      binary negation of <i>bits</i>.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--or-mark</b> <i>bits</i></dt>
  <dd class="It-tag">Binary OR the nfmark with <i>bits</i>. (Mnemonic for
      <b>--set-xmark</b> <i>bits</i><b>/</b><i>bits</i>.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xor-mark</b> <i>bits</i></dt>
  <dd class="It-tag">Binary XOR the nfmark with <i>bits</i>. (Mnemonic for
      <b>--set-xmark</b> <i>bits</i><b>/0</b>.)</dd>
</dl>
<h2 class="Ss" title="Ss" id="MASQUERADE"><a class="selflink" href="#MASQUERADE">MASQUERADE</a></h2>
This target is only valid in the <b>nat</b> table, in the <b>POSTROUTING</b>
  chain. It should only be used with dynamically assigned IP (dialup)
  connections: if you have a static IP address, you should use the SNAT target.
  Masquerading is equivalent to specifying a mapping to the IP address of the
  interface the packet is going out, but also has the effect that connections
  are <i>forgotten</i> when the interface goes down. This is the correct
  behavior when the next dialup is unlikely to have the same interface address
  (and hence any established connections are lost anyway).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--to-ports</b> <i>port</i>[<b>-</b><i>port</i>]</dt>
  <dd class="It-tag">This specifies a range of source ports to use, overriding
      the default <b>SNAT</b> source port-selection heuristics (see above). This
      is only valid if the rule also specifies one of the following protocols:
      <b>tcp</b>, <b>udp</b>, <b>dccp</b> or <b>sctp</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--random</b></dt>
  <dd class="It-tag">Randomize source port mapping If option <b>--random</b> is
      used then port mapping will be randomized (kernel &gt;= 2.6.21).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">IPv6 support available since Linux kernels &gt;= 3.7.</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="MIRROR_(IPv4-specific)"><a class="selflink" href="#MIRROR_(IPv4-specific)">MIRROR
  (IPv4-specific)</a></h2>
This is an experimental demonstration target which inverts the source and
  destination fields in the IP header and retransmits the packet. It is only
  valid in the <b>INPUT</b>, <b>FORWARD</b> and <b>PREROUTING</b> chains, and
  user-defined chains which are only called from those chains. Note that the
  outgoing packets are <b>NOT</b> seen by any packet filtering chains,
  connection tracking or NAT, to avoid loops and other problems.
<h2 class="Ss" title="Ss" id="NETMAP"><a class="selflink" href="#NETMAP">NETMAP</a></h2>
This target allows you to statically map a whole network of addresses onto
  another network of addresses. It can only be used from rules in the <b>nat</b>
  table.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--to</b> <i>address</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Network address to map to. The resulting address will be
      constructed in the following way: All 'one' bits in the mask are filled in
      from the new `address'. All bits that are zero in the mask are filled in
      from the original address.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">IPv6 support available since Linux kernels &gt;= 3.7.</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="NFLOG"><a class="selflink" href="#NFLOG">NFLOG</a></h2>
This target provides logging of matching packets. When this target is set for a
  rule, the Linux kernel will pass the packet to the loaded logging backend to
  log the packet. This is usually used in combination with nfnetlink_log as
  logging backend, which will multicast the packet through a <i>netlink</i>
  socket to the specified multicast group. One or more userspace processes may
  subscribe to the group to receive the packets. Like LOG, this is a
  non-terminating target, i.e. rule traversal continues at the next rule.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nflog-group</b> <i>nlgroup</i></dt>
  <dd class="It-tag">The netlink group (0 - 2^16-1) to which packets are (only
      applicable for nfnetlink_log). The default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nflog-prefix</b> <i>prefix</i></dt>
  <dd class="It-tag">A prefix string to include in the log message, up to 64
      characters long, useful for distinguishing messages in the logs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nflog-range</b> <i>size</i></dt>
  <dd class="It-tag">The number of bytes to be copied to userspace (only
      applicable for nfnetlink_log). nfnetlink_log instances may specify their
      own range, this option overrides it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nflog-threshold</b> <i>size</i></dt>
  <dd class="It-tag">Number of packets to queue inside the kernel before sending
      them to userspace (only applicable for nfnetlink_log). Higher values
      result in less overhead per packet, but increase delay until the packets
      reach userspace. The default value is 1.</dd>
</dl>
<h2 class="Ss" title="Ss" id="NFQUEUE"><a class="selflink" href="#NFQUEUE">NFQUEUE</a></h2>
This target passes the packet to userspace using the <b>nfnetlink_queue</b>
  handler. The packet is put into the queue identified by its 16-bit queue
  number. Userspace can inspect and modify the packet if desired. Userspace must
  then drop or reinject the packet into the kernel. Please see
  libnetfilter_queue for details. <b>nfnetlink_queue</b> was added in Linux
  2.6.14. The <b>queue-balance</b> option was added in Linux 2.6.31,
  <b>queue-bypass</b> in 2.6.39.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--queue-num</b> <i>value</i></dt>
  <dd class="It-tag">This specifies the QUEUE number to use. Valid queue numbers
      are 0 to 65535. The default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--queue-balance</b>
    <i>value</i><b>:</b><i>value</i></dt>
  <dd class="It-tag">This specifies a range of queues to use. Packets are then
      balanced across the given queues. This is useful for multicore systems:
      start multiple instances of the userspace program on queues x, x+1, .. x+n
      and use &quot;--queue-balance <i>x</i><b>:</b><i>x+n</i>&quot;. Packets
      belonging to the same connection are put into the same nfqueue.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--queue-bypass</b></dt>
  <dd class="It-tag">By default, if no userspace program is listening on an
      NFQUEUE, then all packets that are to be queued are dropped. When this
      option is used, the NFQUEUE rule behaves like ACCEPT instead, and the
      packet will move on to the next table.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--queue-cpu-fanout</b></dt>
  <dd class="It-tag">Available starting Linux kernel 3.10. When used together
      with <b>--queue-balance</b> this will use the CPU ID as an index to map
      packets to the queues. The idea is that you can improve performance if
      there's a queue per CPU. This requires <b>--queue-balance</b> to be
      specified.</dd>
</dl>
<h2 class="Ss" title="Ss" id="NOTRACK"><a class="selflink" href="#NOTRACK">NOTRACK</a></h2>
This extension disables connection tracking for all packets matching that rule.
  It is equivalent with -j CT --notrack. Like CT, NOTRACK can only be used in
  the <b>raw</b> table.
<h2 class="Ss" title="Ss" id="RATEEST"><a class="selflink" href="#RATEEST">RATEEST</a></h2>
The RATEEST target collects statistics, performs rate estimation calculation and
  saves the results for later evaluation using the <b>rateest</b> match.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-name</b> <i>name</i></dt>
  <dd class="It-tag">Count matched packets into the pool referred to by
      <i>name</i>, which is freely choosable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-interval</b>
    <i>amount</i>{<b>s</b>|<b>ms</b>|<b>us</b>}</dt>
  <dd class="It-tag">Rate measurement interval, in seconds, milliseconds or
      microseconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rateest-ewmalog</b> <i>value</i></dt>
  <dd class="It-tag">Rate measurement averaging time constant.</dd>
</dl>
<h2 class="Ss" title="Ss" id="REDIRECT"><a class="selflink" href="#REDIRECT">REDIRECT</a></h2>
This target is only valid in the <b>nat</b> table, in the <b>PREROUTING</b> and
  <b>OUTPUT</b> chains, and user-defined chains which are only called from those
  chains. It redirects the packet to the machine itself by changing the
  destination IP to the primary address of the incoming interface
  (locally-generated packets are mapped to the localhost address, 127.0.0.1 for
  IPv4 and ::1 for IPv6).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--to-ports</b> <i>port</i>[<b>-</b><i>port</i>]</dt>
  <dd class="It-tag">This specifies a destination port or range of ports to use:
      without this, the destination port is never altered. This is only valid if
      the rule also specifies one of the following protocols: <b>tcp</b>,
      <b>udp</b>, <b>dccp</b> or <b>sctp</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--random</b></dt>
  <dd class="It-tag">If option <b>--random</b> is used then port mapping will be
      randomized (kernel &gt;= 2.6.22).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">IPv6 support available starting Linux kernels &gt;=
    3.7.</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="REJECT_(IPv6-specific)"><a class="selflink" href="#REJECT_(IPv6-specific)">REJECT
  (IPv6-specific)</a></h2>
This is used to send back an error packet in response to the matched packet:
  otherwise it is equivalent to <b>DROP</b> so it is a terminating TARGET,
  ending rule traversal. This target is only valid in the <b>INPUT</b>,
  <b>FORWARD</b> and <b>OUTPUT</b> chains, and user-defined chains which are
  only called from those chains. The following option controls the nature of the
  error packet returned:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--reject-with</b> <i>type</i></dt>
  <dd class="It-tag">The type given can be <b>icmp6-no-route</b>,
      <b>no-route</b>, <b>icmp6-adm-prohibited</b>, <b>adm-prohibited</b>,
      <b>icmp6-addr-unreachable</b>, <b>addr-unreach</b>, or
      <b>icmp6-port-unreachable</b>, which return the appropriate ICMPv6 error
      message ( <b>icmp6-port-unreachable</b> is the default). Finally, the
      option <b>tcp-reset</b> can be used on rules which only match the TCP
      protocol: this causes a TCP RST packet to be sent back. This is mainly
      useful for blocking <i>ident</i> (113/tcp) probes which frequently occur
      when sending mail to broken mail hosts (which won't accept your mail
      otherwise). <b>tcp-reset</b> can only be used with kernel versions 2.6.14
      or later.</dd>
</dl>
<h2 class="Ss" title="Ss" id="REJECT_(IPv4-specific)"><a class="selflink" href="#REJECT_(IPv4-specific)">REJECT
  (IPv4-specific)</a></h2>
This is used to send back an error packet in response to the matched packet:
  otherwise it is equivalent to <b>DROP</b> so it is a terminating TARGET,
  ending rule traversal. This target is only valid in the <b>INPUT</b>,
  <b>FORWARD</b> and <b>OUTPUT</b> chains, and user-defined chains which are
  only called from those chains. The following option controls the nature of the
  error packet returned:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--reject-with</b> <i>type</i></dt>
  <dd class="It-tag">The type given can be <b>icmp-net-unreachable</b>,
      <b>icmp-host-unreachable</b>, <b>icmp-port-unreachable</b>,
      <b>icmp-proto-unreachable</b>, <b>icmp-net-prohibited</b>,
      <b>icmp-host-prohibited</b>, or <b>icmp-admin-prohibited</b> (*), which
      return the appropriate ICMP error message ( <b>icmp-port-unreachable</b>
      is the default). The option <b>tcp-reset</b> can be used on rules which
      only match the TCP protocol: this causes a TCP RST packet to be sent back.
      This is mainly useful for blocking <i>ident</i> (113/tcp) probes which
      frequently occur when sending mail to broken mail hosts (which won't
      accept your mail otherwise).</dd>
</dl>
<div class="Pp"></div>
(*) Using icmp-admin-prohibited with kernels that do not support it will result
  in a plain DROP instead of REJECT
<h2 class="Ss" title="Ss" id="SAME_(IPv4-specific)"><a class="selflink" href="#SAME_(IPv4-specific)">SAME
  (IPv4-specific)</a></h2>
Similar to SNAT/DNAT depending on chain: it takes a range of addresses (`--to
  1.2.3.4-1.2.3.7') and gives a client the same source-/destination-address for
  each connection.
<div class="Pp"></div>
N.B.: The DNAT target's <b>--persistent</b> option replaced the SAME target.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--to</b> <i>ipaddr</i>[<b>-</b><i>ipaddr</i>]</dt>
  <dd class="It-tag">Addresses to map source to. May be specified more than once
      for multiple ranges.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nodst</b></dt>
  <dd class="It-tag">Don't use the destination-ip in the calculations when
      selecting the new source-ip</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--random</b></dt>
  <dd class="It-tag">Port mapping will be forcibly randomized to avoid attacks
      based on port prediction (kernel &gt;= 2.6.21).</dd>
</dl>
<h2 class="Ss" title="Ss" id="SECMARK"><a class="selflink" href="#SECMARK">SECMARK</a></h2>
This is used to set the security mark value associated with the packet for use
  by security subsystems such as SELinux. It is valid in the <b>security</b>
  table (for backwards compatibility with older kernels, it is also valid in the
  <b>mangle</b> table). The mark is 32 bits wide.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--selctx</b> <i>security_context</i></dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="SET"><a class="selflink" href="#SET">SET</a></h2>
This module adds and/or deletes entries from IP sets which can be defined by
  ipset(8).
<dl class="Bl-tag">
  <dt class="It-tag"><b>--add-set</b> <i>setname</i>
    <i>flag</i>[<b>,</b><i>flag</i>...]</dt>
  <dd class="It-tag">add the address(es)/port(s) of the packet to the set</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--del-set</b> <i>setname</i>
    <i>flag</i>[<b>,</b><i>flag</i>...]</dt>
  <dd class="It-tag">delete the address(es)/port(s) of the packet from the
    set</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">where <i>flag</i>(s) are <b>src</b> and/or <b>dst</b>
      specifications and there can be no more than six of them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timeout</b> <i>value</i></dt>
  <dd class="It-tag">when adding an entry, the timeout value to use instead of
      the default one from the set definition</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--exist</b></dt>
  <dd class="It-tag">when adding an entry if it already exists, reset the
      timeout value to the specified one or to the default from the set
      definition</dd>
</dl>
<div class="Pp"></div>
Use of -j SET requires that ipset kernel support is provided, which, for
  standard kernels, is the case since Linux 2.6.39.
<h2 class="Ss" title="Ss" id="SNAT"><a class="selflink" href="#SNAT">SNAT</a></h2>
This target is only valid in the <b>nat</b> table, in the <b>POSTROUTING</b> and
  <b>INPUT</b> chains, and user-defined chains which are only called from those
  chains. It specifies that the source address of the packet should be modified
  (and all future packets in this connection will also be mangled), and rules
  should cease being examined. It takes the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--to-source</b>
    [<i>ipaddr</i>[<b>-</b><i>ipaddr</i>]][<b>:</b><i>port</i>[<b>-</b><i>port</i>]]</dt>
  <dd class="It-tag">which can specify a single new source IP address, an
      inclusive range of IP addresses. Optionally a port range, if the rule also
      specifies one of the following protocols: <b>tcp</b>, <b>udp</b>,
      <b>dccp</b> or <b>sctp</b>. If no port range is specified, then source
      ports below 512 will be mapped to other ports below 512: those between 512
      and 1023 inclusive will be mapped to ports below 1024, and other ports
      will be mapped to 1024 or above. Where possible, no port alteration will
      occur. In Kernels up to 2.6.10, you can add several --to-source options.
      For those kernels, if you specify more than one source address, either via
      an address range or multiple --to-source options, a simple round-robin
      (one after another in cycle) takes place between these addresses. Later
      Kernels (&gt;= 2.6.11-rc1) don't have the ability to NAT to multiple
      ranges anymore.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--random</b></dt>
  <dd class="It-tag">If option <b>--random</b> is used then port mapping will be
      randomized (kernel &gt;= 2.6.21).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--persistent</b></dt>
  <dd class="It-tag">Gives a client the same source-/destination-address for
      each connection. This supersedes the SAME target. Support for persistent
      mappings is available from 2.6.29-rc2.</dd>
</dl>
<div class="Pp"></div>
Kernels prior to 2.6.36-rc1 don't have the ability to <b>SNAT</b> in the
  <b>INPUT</b> chain.
<dl class="Bl-tag">
  <dt class="It-tag">IPv6 support available since Linux kernels &gt;= 3.7.</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="SNPT_(IPv6-specific)"><a class="selflink" href="#SNPT_(IPv6-specific)">SNPT
  (IPv6-specific)</a></h2>
Provides stateless source IPv6-to-IPv6 Network Prefix Translation (as described
  by RFC 6296).
<div class="Pp"></div>
You have to use this target in the <b>mangle</b> table, not in the <b>nat</b>
  table. It takes the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--src-pfx</b> [<i>prefix/</i><i>length]</i></dt>
  <dd class="It-tag">Set source prefix that you want to translate and
    length</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dst-pfx</b> [<i>prefix/</i><i>length]</i></dt>
  <dd class="It-tag">Set destination prefix that you want to use in the
      translation and length</dd>
</dl>
<div class="Pp"></div>
You have to use the DNPT target to undo the translation. Example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">ip6tables -t mangle -I POSTROUTING -s fd00::/64 ! -o
      vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx 2001:e20:2000:40f::/64</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">ip6tables -t mangle -I PREROUTING -i wlan0 -d
      2001:e20:2000:40f::/64 -j DNPT --src-pfx 2001:e20:2000:40f::/64 --dst-pfx
      fd00::/64</dd>
</dl>
<div class="Pp"></div>
You may need to enable IPv6 neighbor proxy:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">sysctl -w net.ipv6.conf.all.proxy_ndp=1</dd>
</dl>
<div class="Pp"></div>
You also have to use the <b>NOTRACK</b> target to disable connection tracking
  for translated flows.
<h2 class="Ss" title="Ss" id="TCPMSS"><a class="selflink" href="#TCPMSS">TCPMSS</a></h2>
This target allows to alter the MSS value of TCP SYN packets, to control the
  maximum size for that connection (usually limiting it to your outgoing
  interface's MTU minus 40 for IPv4 or 60 for IPv6, respectively). Of course, it
  can only be used in conjunction with <b>-p tcp</b>.
<div class="Pp"></div>
This target is used to overcome criminally braindead ISPs or servers which block
  &quot;ICMP Fragmentation Needed&quot; or &quot;ICMPv6 Packet Too Big&quot;
  packets. The symptoms of this problem are that everything works fine from your
  Linux firewall/router, but machines behind it can never exchange large
  packets:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Web browsers connect, then hang with no data received.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Small mail works fine, but large emails hang.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">ssh works fine, but scp hangs after initial
    handshaking.</dd>
</dl>
<div class="Pp"></div>
Workaround: activate this option and add a rule to your firewall configuration
  like:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">
    <br/>
     iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN
    <br/>
     -j TCPMSS --clamp-mss-to-pmtu</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-mss</b> <i>value</i></dt>
  <dd class="It-tag">Explicitly sets MSS option to specified value. If the MSS
      of the packet is already lower than <i>value</i>, it will <b>not</b> be
      increased (from Linux 2.6.25 onwards) to avoid more problems with hosts
      relying on a proper MSS.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clamp-mss-to-pmtu</b></dt>
  <dd class="It-tag">Automatically clamp MSS value to (path_MTU - 40 for IPv4;
      -60 for IPv6). This may not function as desired where asymmetric routes
      with differing path MTU exist &#x2014; the kernel uses the path MTU which
      it would use to send packets from itself to the source and destination IP
      addresses. Prior to Linux 2.6.25, only the path MTU to the destination IP
      address was considered by this option; subsequent kernels also consider
      the path MTU to the source IP address.</dd>
</dl>
<div class="Pp"></div>
These options are mutually exclusive.
<h2 class="Ss" title="Ss" id="TCPOPTSTRIP"><a class="selflink" href="#TCPOPTSTRIP">TCPOPTSTRIP</a></h2>
This target will strip TCP options off a TCP packet. (It will actually replace
  them by NO-OPs.) As such, you will need to add the <b>-p tcp</b> parameters.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--strip-options</b>
    <i>option</i>[<b>,</b><i>option</i>...]</dt>
  <dd class="It-tag">Strip the given option(s). The options may be specified by
      TCP option number or by symbolic name. The list of recognized options can
      be obtained by calling iptables with <b>-j TCPOPTSTRIP -h</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="TEE"><a class="selflink" href="#TEE">TEE</a></h2>
The <b>TEE</b> target will clone a packet and redirect this clone to another
  machine on the <b>local</b> network segment. In other words, the nexthop must
  be the target, or you will have to configure the nexthop to forward it further
  if so desired.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--gateway</b> <i>ipaddr</i></dt>
  <dd class="It-tag">Send the cloned packet to the host reachable at the given
      IP address. Use of 0.0.0.0 (for IPv4 packets) or :: (IPv6) is
    invalid.</dd>
</dl>
<div class="Pp"></div>
To forward all incoming traffic on eth0 to an Network Layer logging box:
<div class="Pp"></div>
-t mangle -A PREROUTING -i eth0 -j TEE --gateway 2001:db8::1
<h2 class="Ss" title="Ss" id="TOS"><a class="selflink" href="#TOS">TOS</a></h2>
This module sets the Type of Service field in the IPv4 header (including the
  &quot;precedence&quot; bits) or the Priority field in the IPv6 header. Note
  that TOS shares the same bits as DSCP and ECN. The TOS target is only valid in
  the <b>mangle</b> table.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-tos</b> <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Zeroes out the bits given by <i>mask</i> (see NOTE below)
      and XORs <i>value</i> into the TOS/Priority field. If <i>mask</i> is
      omitted, 0xFF is assumed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--set-tos</b> <i>symbol</i></dt>
  <dd class="It-tag">You can specify a symbolic name when using the TOS target
      for IPv4. It implies a mask of 0xFF (see NOTE below). The list of
      recognized TOS names can be obtained by calling iptables with <b>-j TOS
      -h</b>.</dd>
</dl>
<div class="Pp"></div>
The following mnemonics are available:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--and-tos</b> <i>bits</i></dt>
  <dd class="It-tag">Binary AND the TOS value with <i>bits</i>. (Mnemonic for
      <b>--set-tos</b> <b>0/</b><i>invbits</i>, where <i>invbits</i> is the
      binary negation of <i>bits</i>. See NOTE below.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--or-tos</b> <i>bits</i></dt>
  <dd class="It-tag">Binary OR the TOS value with <i>bits</i>. (Mnemonic for
      <b>--set-tos</b> <i>bits</i><b>/</b><i>bits</i>. See NOTE below.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xor-tos</b> <i>bits</i></dt>
  <dd class="It-tag">Binary XOR the TOS value with <i>bits</i>. (Mnemonic for
      <b>--set-tos</b> <i>bits</i><b>/0</b>. See NOTE below.)</dd>
</dl>
<div class="Pp"></div>
NOTE: In Linux kernels up to and including 2.6.38, with the exception of
  longterm releases 2.6.32 (&gt;=.42), 2.6.33 (&gt;=.15), and 2.6.35 (&gt;=.14),
  there is a bug whereby IPv6 TOS mangling does not behave as documented and
  differs from the IPv4 version. The TOS mask indicates the bits one wants to
  zero out, so it needs to be inverted before applying it to the original TOS
  field. However, the aformentioned kernels forgo the inversion which breaks
  --set-tos and its mnemonics.
<h2 class="Ss" title="Ss" id="TPROXY"><a class="selflink" href="#TPROXY">TPROXY</a></h2>
This target is only valid in the <b>mangle</b> table, in the <b>PREROUTING</b>
  chain and user-defined chains which are only called from this chain. It
  redirects the packet to a local socket without changing the packet header in
  any way. It can also change the mark value which can then be used in advanced
  routing rules. It takes three options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--on-port</b> <i>port</i></dt>
  <dd class="It-tag">This specifies a destination port to use. It is a required
      option, 0 means the new destination port is the same as the original. This
      is only valid if the rule also specifies <b>-p tcp</b> or <b>-p
    udp</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--on-ip</b> <i>address</i></dt>
  <dd class="It-tag">This specifies a destination address to use. By default the
      address is the IP address of the incoming interface. This is only valid if
      the rule also specifies <b>-p tcp</b> or <b>-p udp</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tproxy-mark</b> <i>value</i>[<b>/</b><i>mask</i>]</dt>
  <dd class="It-tag">Marks packets with the given value/mask. The fwmark value
      set here can be used by advanced routing. (Required for transparent
      proxying to work: otherwise these packets will get forwarded, which is
      probably not what you want.)</dd>
</dl>
<h2 class="Ss" title="Ss" id="TRACE"><a class="selflink" href="#TRACE">TRACE</a></h2>
This target marks packets so that the kernel will log every rule which match the
  packets as those traverse the tables, chains, rules.
<div class="Pp"></div>
A logging backend, such as nf_log_ipv4(6) or nfnetlink_log, must be loaded for
  this to be visible. The packets are logged with the string prefix:
  &quot;TRACE: tablename:chainname:type:rulenum &quot; where type can be
  &quot;rule&quot; for plain rule, &quot;return&quot; for implicit rule at the
  end of a user defined chain and &quot;policy&quot; for the policy of the built
  in chains.
<div>&#x00A0;</div>
It can only be used in the <b>raw</b> table.
<h2 class="Ss" title="Ss" id="TTL_(IPv4-specific)"><a class="selflink" href="#TTL_(IPv4-specific)">TTL
  (IPv4-specific)</a></h2>
This is used to modify the IPv4 TTL header field. The TTL field determines how
  many hops (routers) a packet can traverse until it's time to live is exceeded.
<div class="Pp"></div>
Setting or incrementing the TTL field can potentially be very dangerous, so it
  should be avoided at any cost. This target is only valid in <b>mangle</b>
  table.
<div class="Pp"></div>
<b>Don't ever set or increment the value on packets that leave your local
  network!</b>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ttl-set</b> <i>value</i></dt>
  <dd class="It-tag">Set the TTL value to `value'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ttl-dec</b> <i>value</i></dt>
  <dd class="It-tag">Decrement the TTL value `value' times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ttl-inc</b> <i>value</i></dt>
  <dd class="It-tag">Increment the TTL value `value' times.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ULOG_(IPv4-specific)"><a class="selflink" href="#ULOG_(IPv4-specific)">ULOG
  (IPv4-specific)</a></h2>
This is the deprecated ipv4-only predecessor of the NFLOG target. It provides
  userspace logging of matching packets. When this target is set for a rule, the
  Linux kernel will multicast this packet through a <i>netlink</i> socket. One
  or more userspace processes may then subscribe to various multicast groups and
  receive the packets. Like LOG, this is a &quot;non-terminating target&quot;,
  i.e. rule traversal continues at the next rule.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ulog-nlgroup</b> <i>nlgroup</i></dt>
  <dd class="It-tag">This specifies the netlink group (1-32) to which the packet
      is sent. Default value is 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ulog-prefix</b> <i>prefix</i></dt>
  <dd class="It-tag">Prefix log messages with the specified prefix; up to 32
      characters long, and useful for distinguishing messages in the logs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ulog-cprange</b> <i>size</i></dt>
  <dd class="It-tag">Number of bytes to be copied to userspace. A value of 0
      always copies the entire packet, regardless of its size. Default is
    0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ulog-qthreshold</b> <i>size</i></dt>
  <dd class="It-tag">Number of packet to queue inside kernel. Setting this value
      to, e.g. 10 accumulates ten packets inside the kernel and transmits them
      as one netlink multipart message to userspace. Default is 1 (for backwards
      compatibility).
    <div>&#x00A0;</div>
  </dd>
</dl>
</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os">iptables 1.4.21</td>
  </tr>
</table>
</body>
</html>
