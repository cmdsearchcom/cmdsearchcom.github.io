<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:13:31 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MOUNT.CIFS(8) System Administration tools
MOUNT.CIFS(8)</p>

<p style="margin-top: 1em">NAME <br>
mount.cifs - mount using the Common Internet File System
(CIFS)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
mount.cifs {service} {mount-point} [-o options]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This tool is part of the cifs-utils suite.</p>

<p style="margin-top: 1em">mount.cifs mounts a Linux CIFS
filesystem. It is usually invoked indirectly by the mount(8)
command when using the &quot;-t cifs&quot; option. This
command only works in Linux, and the <br>
kernel must support the cifs filesystem. The CIFS protocol
is the successor to the SMB protocol and is supported by
most Windows servers and many other commercial servers and
<br>
Network Attached Storage appliances as well as by the
popular Open Source server Samba.</p>

<p style="margin-top: 1em">The mount.cifs utility attaches
the UNC name (exported network resource) specified as
service (using //server/share syntax, where
&quot;server&quot; is the server name or IP address and <br>
&quot;share&quot; is the name of the share) to the local
directory mount-point.</p>

<p style="margin-top: 1em">Options to mount.cifs are
specified as a comma-separated list of key=value pairs. It
is possible to send options other than those listed here,
assuming that the cifs filesystem <br>
kernel module (cifs.ko) supports them. Unrecognized cifs
mount options passed to the cifs vfs kernel code will be
logged to the kernel log.</p>

<p style="margin-top: 1em">mount.cifs causes the cifs vfs
to launch a thread named cifsd. After mounting it keeps
running until the mounted resource is unmounted (usually via
the umount utility).</p>

<p style="margin-top: 1em">mount.cifs -V command displays
the version of cifs mount helper.</p>

<p style="margin-top: 1em">modinfo cifs command displays
the version of cifs module.</p>

<p style="margin-top: 1em">OPTIONS <br>
username=arg <br>
specifies the username to connect as. If this is not given,
then the environment variable USER is used.</p>

<p style="margin-top: 1em">Earlier versions of mount.cifs
also allowed one to specify the username in a
&quot;user%password&quot; or &quot;workgroup/user&quot; or
&quot;workgroup/user%password&quot; to allow the password
and <br>
workgroup to be specified as part of the username. Support
for those alternate username formats is now deprecated and
should no longer be used. Users should use the discrete <br>
&quot;password=&quot; and &quot;domain=&quot; to specify
those values. While some versions of the cifs kernel module
accept &quot;user=&quot; as an abbreviation for this option,
its use can confuse the <br>
standard mount program into thinking that this is a
non-superuser mount. It is therefore recommended to use the
full &quot;username=&quot; option name.</p>

<p style="margin-top: 1em">password=arg <br>
specifies the CIFS password. If this option is not given
then the environment variable PASSWD is used. If the
password is not specified directly or indirectly via an
argument <br>
to mount, mount.cifs will prompt for a password, unless the
guest option is specified.</p>

<p style="margin-top: 1em">Note that a password which
contains the delimiter character (i.e. a comma
&Acirc;&acute;,&Acirc;&acute;) will fail to be parsed
correctly on the command line. However, the same password
defined in the <br>
PASSWD environment variable or via a credentials file (see
below) or entered at the password prompt will be read
correctly.</p>

<p style="margin-top: 1em">credentials=filename <br>
specifies a file that contains a username and/or password
and optionally the name of the workgroup. The format of the
file is:</p>

<p style="margin-top: 1em">username=value <br>
password=value <br>
domain=value</p>

<p style="margin-top: 1em">This is preferred over having
passwords in plaintext in a shared file, such as /etc/fstab.
Be sure to protect any credentials file properly.</p>

<p style="margin-top: 1em">uid=arg <br>
sets the uid that will own all files or directories on the
mounted filesystem when the server does not provide
ownership information. It may be specified as either a
username <br>
or a numeric uid. When not specified, the default is uid 0.
The mount.cifs helper must be at version 1.10 or higher to
support specifying the uid in non-numeric form. See the <br>
section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS
below for more information.</p>

<p style="margin-top: 1em">forceuid <br>
instructs the client to ignore any uid provided by the
server for files and directories and to always assign the
owner to be the value of the uid= option. See the section on
<br>
FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS below for more
information.</p>

<p style="margin-top: 1em">cruid=arg <br>
sets the uid of the owner of the credentials cache. This is
primarily useful with sec=krb5. The default is the real uid
of the process performing the mount. Setting this <br>
parameter directs the upcall to look for a credentials cache
owned by that user.</p>

<p style="margin-top: 1em">gid=arg <br>
sets the gid that will own all files or directories on the
mounted filesystem when the server does not provide
ownership information. It may be specified as either a <br>
groupname or a numeric gid. When not specified, the default
is gid 0. The mount.cifs helper must be at version 1.10 or
higher to support specifying the gid in non-numeric <br>
form. See the section on FILE AND DIRECTORY OWNERSHIP AND
PERMISSIONS below for more information.</p>

<p style="margin-top: 1em">forcegid <br>
instructs the client to ignore any gid provided by the
server for files and directories and to always assign the
owner to be the value of the gid= option. See the section on
<br>
FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS below for more
information.</p>

<p style="margin-top: 1em">port=arg <br>
sets the port number on which the client will attempt to
contact the CIFS server. If this value is specified, look
for an existing connection with this port, and use that if
<br>
one exists. If one doesn&rsquo;t exist, try to create a new
connection on that port. If that connection fails, return an
error. If this value isn&rsquo;t specified, look for an
existing <br>
connection on port 445 or 139. If no such connection exists,
try to connect on port 445 first and then port 139 if that
fails. Return an error if both fail.</p>

<p style="margin-top: 1em">servernetbiosname=arg <br>
Specify the server netbios name (RFC1001 name) to use when
attempting to setup a session to the server. Although rarely
needed for mounting to newer servers, this option is <br>
needed for mounting to some older servers (such as OS/2 or
Windows 98 and Windows ME) since when connecting over port
139 they, unlike most newer servers, do not support a <br>
default server name. A server name can be up to 15
characters long and is usually uppercased.</p>

<p style="margin-top: 1em">servern=arg <br>
Synonym for servernetbiosname.</p>

<p style="margin-top: 1em">netbiosname=arg <br>
When mounting to servers via port 139, specifies the RFC1001
source name to use to represent the client netbios machine
name when doing the RFC1001 netbios session <br>
initialize.</p>

<p style="margin-top: 1em">file_mode=arg <br>
If the server does not support the CIFS Unix extensions this
overrides the default file mode.</p>

<p style="margin-top: 1em">dir_mode=arg <br>
If the server does not support the CIFS Unix extensions this
overrides the default mode for directories.</p>

<p style="margin-top: 1em">ip=arg <br>
sets the destination IP address. This option is set
automatically if the server name portion of the requested
UNC name can be resolved so rarely needs to be specified by
the <br>
user.</p>

<p style="margin-top: 1em">domain=arg <br>
sets the domain (workgroup) of the user</p>

<p style="margin-top: 1em">guest <br>
don&Acirc;&acute;t prompt for a password</p>

<p style="margin-top: 1em">iocharset <br>
Charset used to convert local path names to and from
Unicode. Unicode is used by default for network path names
if the server supports it. If iocharset is not specified
then <br>
the nls_default specified during the local client kernel
build will be used. If server does not support Unicode, this
parameter is unused.</p>

<p style="margin-top: 1em">ro <br>
mount read-only</p>

<p style="margin-top: 1em">rw <br>
mount read-write</p>

<p style="margin-top: 1em">setuids <br>
If the CIFS Unix extensions are negotiated with the server
the client will attempt to set the effective uid and gid of
the local process on newly created files, directories, <br>
and devices (create, mkdir, mknod). If the CIFS Unix
Extensions are not negotiated, for newly created files and
directories instead of using the default uid and gid
specified <br>
on the the mount, cache the new file&Acirc;&acute;s uid and
gid locally which means that the uid for the file can change
when the inode is reloaded (or the user remounts the
share).</p>

<p style="margin-top: 1em">nosetuids <br>
The client will not attempt to set the uid and gid on on
newly created files, directories, and devices (create,
mkdir, mknod) which will result in the server setting the
uid <br>
and gid to the default (usually the server uid of the user
who mounted the share). Letting the server (rather than the
client) set the uid and gid is the default.If the CIFS <br>
Unix Extensions are not negotiated then the uid and gid for
new files will appear to be the uid (gid) of the mounter or
the uid (gid) parameter specified on the mount.</p>

<p style="margin-top: 1em">perm <br>
Client does permission checks (vfs_permission check of uid
and gid of the file against the mode and desired operation),
Note that this is in addition to the normal ACL check <br>
on the target machine done by the server software. Client
permission checking is enabled by default.</p>

<p style="margin-top: 1em">noperm <br>
Client does not do permission checks. This can expose files
on this mount to access by other users on the local client
system. It is typically only needed when the server <br>
supports the CIFS Unix Extensions but the UIDs/GIDs on the
client and server system do not match closely enough to
allow access by the user doing the mount. Note that this
<br>
does not affect the normal ACL check on the target machine
done by the server software (of the server ACL against the
user name provided at mount time).</p>

<p style="margin-top: 1em">dynperm <br>
Instructs the server to maintain ownership and permissions
in memory that can&Acirc;&acute;t be stored on the server.
This information can disappear at any time (whenever the
inode is <br>
flushed from the cache), so while this may help make some
applications work, it&Acirc;&acute;s behavior is somewhat
unreliable. See the section below on FILE AND DIRECTORY
OWNERSHIP AND <br>
PERMISSIONS for more information.</p>

<p style="margin-top: 1em">cache= <br>
Cache mode. See the section below on CACHE COHERENCY for
details. Allowed values are:</p>

<p style="margin-top: 1em">&Acirc;&middot; none: do not
cache file data at all</p>

<p style="margin-top: 1em">&Acirc;&middot; strict: follow
the CIFS/SMB2 protocol strictly</p>

<p style="margin-top: 1em">&Acirc;&middot; loose: allow
loose caching semantics</p>

<p style="margin-top: 1em">The default in kernels prior to
3.7 was &quot;loose&quot;. As of kernel 3.7 the default is
&quot;strict&quot;.</p>

<p style="margin-top: 1em">directio <br>
Do not do inode data caching on files opened on this mount.
This precludes mmaping files on this mount. In some cases
with fast networks and little or no caching benefits on <br>
the client (e.g. when the application is doing large
sequential reads bigger than page size without rereading the
same data) this can provide better performance than the <br>
default behavior which caches reads (readahead) and writes
(writebehind) through the local Linux client pagecache if
oplock (caching token) is granted and held. Note that <br>
direct allows write operations larger than page size to be
sent to the server. On some kernels this requires the
cifs.ko module to be built with the CIFS_EXPERIMENTAL <br>
configure option.</p>

<p style="margin-top: 1em">This option is will be
deprecated in 3.7. Users should use cache=none instead on
more recent kernels.</p>

<p style="margin-top: 1em">strictcache <br>
Use for switching on strict cache mode. In this mode the
client reads from the cache all the time it has Oplock Level
II, otherwise - read from the server. As for write - the
<br>
client stores a data in the cache in Exclusive Oplock case,
otherwise - write directly to the server.</p>

<p style="margin-top: 1em">This option is will be
deprecated in 3.7. Users should use cache=strict instead on
more recent kernels.</p>

<p style="margin-top: 1em">rwpidforward <br>
Forward pid of a process who opened a file to any read or
write operation on that file. This prevent applications like
WINE from failing on read and write if we use mandatory <br>
brlock style.</p>

<p style="margin-top: 1em">mapchars <br>
Translate six of the seven reserved characters (not
backslash, but including the colon, question mark, pipe,
asterik, greater than and less than characters) to the remap
<br>
range (above 0xF000), which also allows the CIFS client to
recognize files created with such characters by
Windows&Acirc;&acute;s POSIX emulation. This can also be
useful when mounting to <br>
most versions of Samba (which also forbids creating and
opening files whose names contain any of these seven
characters). This has no effect if the server does not
support <br>
Unicode on the wire. Please note that the files created with
mapchars mount option may not be accessible if the share is
mounted without that option.</p>

<p style="margin-top: 1em">nomapchars <br>
Do not translate any of these seven characters (default)</p>

<p style="margin-top: 1em">intr <br>
currently unimplemented</p>

<p style="margin-top: 1em">nointr <br>
(default) currently unimplemented</p>

<p style="margin-top: 1em">hard <br>
The program accessing a file on the cifs mounted file system
will hang when the server crashes.</p>

<p style="margin-top: 1em">soft <br>
(default) The program accessing a file on the cifs mounted
file system will not hang when the server crashes and will
return errors to the user application.</p>

<p style="margin-top: 1em">noacl <br>
Do not allow POSIX ACL operations even if server would
support them.</p>

<p style="margin-top: 1em">The CIFS client can get and set
POSIX ACLs (getfacl, setfacl) to Samba servers version
3.0.10 and later. Setting POSIX ACLs requires enabling both
CIFS_XATTR and then <br>
CIFS_POSIX support in the CIFS configuration options when
building the cifs module. POSIX ACL support can be disabled
on a per mount basis by specifying &quot;noacl&quot; on
mount.</p>

<p style="margin-top: 1em">cifsacl <br>
This option is used to map CIFS/NTFS ACLs to/from Linux
permission bits, map SIDs to/from UIDs and GIDs, and get and
set Security Descriptors.</p>

<p style="margin-top: 1em">See sections on CIFS/NTFS ACL,
SID/UID/GID MAPPING, SECURITY DESCRIPTORS for more
information.</p>

<p style="margin-top: 1em">backupuid=arg <br>
File access by this user shall be done with the backup
intent flag set. Either a name or an id must be provided as
an argument, there are no default values.</p>

<p style="margin-top: 1em">See section ACCESSING FILES WITH
BACKUP INTENT for more details</p>

<p style="margin-top: 1em">backupgid=arg <br>
File access by users who are members of this group shall be
done with the backup intent flag set. Either a name or an id
must be provided as an argument, there are no default <br>
values.</p>

<p style="margin-top: 1em">See section ACCESSING FILES WITH
BACKUP INTENT for more details</p>

<p style="margin-top: 1em">nocase <br>
Request case insensitive path name matching (case sensitive
is the default if the server suports it).</p>

<p style="margin-top: 1em">ignorecase <br>
Synonym for nocase.</p>

<p style="margin-top: 1em">sec= <br>
Security mode. Allowed values are:</p>

<p style="margin-top: 1em">&Acirc;&middot; none - attempt
to connection as a null user (no name)</p>

<p style="margin-top: 1em">&Acirc;&middot; krb5 - Use
Kerberos version 5 authentication</p>

<p style="margin-top: 1em">&Acirc;&middot; krb5i - Use
Kerberos authentication and forcibly enable packet
signing</p>

<p style="margin-top: 1em">&Acirc;&middot; ntlm - Use NTLM
password hashing</p>

<p style="margin-top: 1em">&Acirc;&middot; ntlmi - Use NTLM
password hashing and force packet signing</p>

<p style="margin-top: 1em">&Acirc;&middot; ntlmv2 - Use
NTLMv2 password hashing</p>

<p style="margin-top: 1em">&Acirc;&middot; ntlmv2i - Use
NTLMv2 password hashing and force packet signing</p>

<p style="margin-top: 1em">&Acirc;&middot; ntlmssp - Use
NTLMv2 password hashing encapsulated in Raw NTLMSSP
message</p>

<p style="margin-top: 1em">&Acirc;&middot; ntlmsspi - Use
NTLMv2 password hashing encapsulated in Raw NTLMSSP message,
and force packet signing</p>

<p style="margin-top: 1em">The default in mainline kernel
versions prior to v3.8 was sec=ntlm. In v3.8, the default
was changed to sec=ntlmssp.</p>

<p style="margin-top: 1em">If the server requires signing
during protocol negotiation, then it may be enabled
automatically. Packet signing may also be enabled
automatically if it&rsquo;s enabled in <br>
/proc/fs/cifs/SecurityFlags.</p>

<p style="margin-top: 1em">nobrl <br>
Do not send byte range lock requests to the server. This is
necessary for certain applications that break with cifs
style mandatory byte range locks (and most cifs servers do
<br>
not yet support requesting advisory byte range locks).</p>

<p style="margin-top: 1em">sfu <br>
When the CIFS Unix Extensions are not negotiated, attempt to
create device files and fifos in a format compatible with
Services for Unix (SFU). In addition retrieve bits <br>
10-12 of the mode via the SETFILEBITS extended attribute (as
SFU does). In the future the bottom 9 bits of the mode mode
also will be emulated using queries of the security <br>
descriptor (ACL). [NB: requires version 1.39 or later of the
CIFS VFS. To recognize symlinks and be able to create
symlinks in an SFU interoperable form requires version 1.40
<br>
or later of the CIFS VFS kernel module.</p>

<p style="margin-top: 1em">serverino <br>
Use inode numbers (unique persistent file identifiers)
returned by the server instead of automatically generating
temporary inode numbers on the client. Although server inode
<br>
numbers make it easier to spot hardlinked files (as they
will have the same inode numbers) and inode numbers may be
persistent (which is userful for some sofware), the server
<br>
does not guarantee that the inode numbers are unique if
multiple server side mounts are exported under a single
share (since inode numbers on the servers might not be
unique <br>
if multiple filesystems are mounted under the same shared
higher level directory). Note that not all servers support
returning server inode numbers, although those that <br>
support the CIFS Unix Extensions, and Windows 2000 and later
servers typically do support this (although not necessarily
on every local server filesystem). Parameter has no <br>
effect if the server lacks support for returning inode
numbers or equivalent. This behavior is enabled by
default.</p>

<p style="margin-top: 1em">noserverino <br>
Client generates inode numbers itself rather than using the
actual ones from the server.</p>

<p style="margin-top: 1em">See section INODE NUMBERS for
more information.</p>

<p style="margin-top: 1em">nounix <br>
Disable the CIFS Unix Extensions for this mount. This can be
useful in order to turn off multiple settings at once. This
includes POSIX acls, POSIX locks, POSIX paths, <br>
symlink support and retrieving uids/gids/mode from the
server. This can also be useful to work around a bug in a
server that supports Unix Extensions.</p>

<p style="margin-top: 1em">See section INODE NUMBERS for
more information.</p>

<p style="margin-top: 1em">nouser_xattr <br>
Do not allow getfattr/setfattr to get/set xattrs, even if
server would support it otherwise. The default is for xattr
support to be enabled.</p>

<p style="margin-top: 1em">rsize=bytes <br>
Maximum amount of data that the kernel will request in a
read request in bytes. Prior to kernel 3.2.0, the default
was 16k, and the maximum size was limited by the <br>
CIFSMaxBufSize module parameter. As of kernel 3.2.0, the
behavior varies according to whether POSIX extensions are
enabled on the mount and the server supports large POSIX
<br>
reads. If they are, then the default is 1M, and the maxmimum
is 16M. If they are not supported by the server, then the
default is 60k and the maximum is around 127k. The <br>
reason for the 60k is because it&rsquo;s the maximum size
read that windows servers can fill. Note that this value is
a maximum, and the client may settle on a smaller size to
<br>
accomodate what the server supports. In kernels prior to
3.2.0, no negotiation is performed.</p>

<p style="margin-top: 1em">wsize=bytes <br>
Maximum amount of data that the kernel will send in a write
request in bytes. Prior to kernel 3.0.0, the default and
maximum was 57344 (14 * 4096 pages). As of 3.0.0, the <br>
default depends on whether the client and server negotiate
large writes via POSIX extensions. If they do, then the
default is 1M, and the maximum allowed is 16M. If they do
<br>
not, then the default is 65536 and the maximum allowed is
131007.</p>

<p style="margin-top: 1em">Note that this value is just a
starting point for negotiation in 3.0.0 and up. The client
and server may negotiate this size downward according to the
server&rsquo;s capabilities. <br>
In kernels prior to 3.0.0, no negotiation is performed. It
can end up with an existing superblock if this value
isn&rsquo;t specified or it&rsquo;s greater or equal than
the existing <br>
one.</p>

<p style="margin-top: 1em">fsc <br>
Enable local disk caching using FS-Cache for CIFS. This
option could be useful to improve performance on a slow
link, heavily loaded server and/or network where reading
from <br>
the disk is faster than reading from the server (over the
network). This could also impact the scalability positively
as the number of calls to the server are reduced. But, <br>
be warned that local caching is not suitable for all
workloads, for e.g., read-once type workloads. So, you need
to consider carefully the situation/workload before using
<br>
this option. Currently, local disk caching is enabled for
CIFS files opened as read-only.</p>

<p style="margin-top: 1em">NOTE: This feature is available
only in the recent kernels that have been built with the
kernel config option CONFIG_CIFS_FSCACHE. You also need to
have cachefilesd daemon <br>
installed and running to make the cache operational.</p>

<p style="margin-top: 1em">multiuser <br>
Map user accesses to individual credentials when accessing
the server. By default, CIFS mounts only use a single set of
user credentials (the mount credentials) when <br>
accessing a share. With this option, the client instead
creates a new session with the server using the user&rsquo;s
credentials whenever a new user accesses the mount. Further
<br>
accesses by that user will also use those credentials.
Because the kernel cannot prompt for passwords, multiuser
mounts are limited to mounts using sec= options that
don&rsquo;t <br>
require passwords.</p>

<p style="margin-top: 1em">With this change, it&rsquo;s
feasible for the server to handle permissions enforcement,
so this option also implies &quot;noperm&quot;. Furthermore,
when unix extensions aren&rsquo;t in use and <br>
the administrator has not overriden ownership using the uid=
or gid= options, ownership of files is presented as the
current user accessing the share.</p>

<p style="margin-top: 1em">actimeo=arg <br>
The time (in seconds) that the CIFS client caches attributes
of a file or directory before it requests attribute
information from a server. During this period the changes
<br>
that occur on the server remain undetected until the client
checks the server again.</p>

<p style="margin-top: 1em">By default, the attribute cache
timeout is set to 1 second. This means more frequent
on-the-wire calls to the server to check whether attributes
have changed which could <br>
impact performance. With this option users can make a
tradeoff between performance and cache metadata correctness,
depending on workload needs. Shorter timeouts mean better
<br>
cache coherency, but frequent increased number of calls to
the server. Longer timeouts mean a reduced number of calls
to the server but looser cache coherency. The actimeo <br>
value is a positive integer that can hold values between 0
and a maximum value of 2^30 * HZ (frequency of timer
interrupt) setting.</p>

<p style="margin-top: 1em">noposixpaths <br>
If unix extensions are enabled on a share, then the client
will typically allow filenames to include any character
besides &rsquo;/&rsquo; in a pathname component, and will
use forward <br>
slashes as a pathname delimiter. This option prevents the
client from attempting to negotiate the use of posix-style
pathnames to the server.</p>

<p style="margin-top: 1em">posixpaths <br>
Inverse of noposixpaths.</p>

<p style="margin-top: 1em">prefixpath= <br>
It&rsquo;s possible to mount a subdirectory of a share. The
preferred way to do this is to append the path to the UNC
when mounting. However, it&rsquo;s also possible to do the
same by <br>
setting this option and providing the path there.</p>

<p style="margin-top: 1em">vers= <br>
SMB protocol version. Allowed values are:</p>

<p style="margin-top: 1em">&Acirc;&middot; 1.0 - The
classic CIFS/SMBv1 protocol. This is the default.</p>

<p style="margin-top: 1em">&Acirc;&middot; 2.0 - The
SMBv2.002 protocol. This was initially introduced in Windows
Vista Service Pack 1, and Windows Server 2008. Note that the
initial release version of Windows <br>
Vista spoke a slightly different dialect (2.000) that is not
supported.</p>

<p style="margin-top: 1em">&Acirc;&middot; 2.1 - The
SMBv2.1 protocol that was introduced in Microsoft Windows 7
and Windows Server 2008R2.</p>

<p style="margin-top: 1em">&Acirc;&middot; 3.0 - The
SMBv3.0 protocol that was introduced in Microsoft Windows 8
and Windows Server 2012.</p>

<p style="margin-top: 1em">Note too that while this option
governs the protocol version used, not all features of each
version are available.</p>

<p style="margin-top: 1em">--verbose <br>
Print additional debugging information for the mount. Note
that this parameter must be specified before the -o. For
example:</p>

<p style="margin-top: 1em">mount -t cifs //server/share
/mnt --verbose -o user=username</p>

<p style="margin-top: 1em">SERVICE FORMATTING AND
DELIMITERS <br>
It&Acirc;&acute;s generally preferred to use forward slashes
(/) as a delimiter in service names. They are considered to
be the &quot;universal delimiter&quot; since they are
generally not allowed to <br>
be embedded within path components on Windows machines and
the client can convert them to blackslashes (
unconditionally. Conversely, backslash characters are
allowed by POSIX <br>
to be part of a path component, and can&Acirc;&acute;t be
automatically converted in the same way.</p>

<p style="margin-top: 1em">mount.cifs will attempt to
convert backslashes to forward slashes where
it&Acirc;&acute;s able to do so, but it cannot do so in any
path component following the sharename.</p>

<p style="margin-top: 1em">INODE NUMBERS <br>
When Unix Extensions are enabled, we use the actual inode
number provided by the server in response to the POSIX calls
as an inode number.</p>

<p style="margin-top: 1em">When Unix Extensions are
disabled and &quot;serverino&quot; mount option is enabled
there is no way to get the server inode number. The client
typically maps the server-assigned &quot;UniqueID&quot; <br>
onto an inode number.</p>

<p style="margin-top: 1em">Note that the UniqueID is a
different value from the server inode number. The UniqueID
value is unique over the scope of the entire server and is
often greater than 2 power 32. <br>
This value often makes programs that are not compiled with
LFS (Large File Support), to trigger a glibc EOVERFLOW error
as this won&Acirc;&acute;t fit in the target structure
field. It is <br>
strongly recommended to compile your programs with LFS
support (i.e. with -D_FILE_OFFSET_BITS=64) to prevent this
problem. You can also use &quot;noserverino&quot; mount
option to generate <br>
inode numbers smaller than 2 power 32 on the client. But you
may not be able to detect hardlinks properly.</p>

<p style="margin-top: 1em">CACHE COHERENCY <br>
With a network filesystem such as CIFS or NFS, the client
must contend with the fact that activity on other clients or
the server could change the contents or attributes of a <br>
file without the client being aware of it. One way to deal
with such a problem is to mandate that all file accesses go
to the server directly. This is performance prohibitive <br>
however, so most protocols have some mechanism to allow the
client to cache data locally.</p>

<p style="margin-top: 1em">The CIFS protocol mandates (in
effect) that the client should not cache file data unless it
holds an opportunistic lock (aka oplock) or a lease. Both of
these entities allow the <br>
client to guarantee certain types of exclusive access to a
file so that it can access its contents without needing to
continually interact with the server. The server will call
<br>
back the client when it needs to revoke either of them and
allow the client a certain amount of time to flush any
cached data.</p>

<p style="margin-top: 1em">The cifs client uses the
kernel&rsquo;s pagecache to cache file data. Any I/O
that&rsquo;s done through the pagecache is generally
page-aligned. This can be problematic when combined with
<br>
byte-range locks as Windows&rsquo; locking is mandatory and
can block reads and writes from occurring.</p>

<p style="margin-top: 1em">cache=none means that the client
never utilizes the cache for normal reads and writes. It
always accesses the server directly to satisfy a read or
write request.</p>

<p style="margin-top: 1em">cache=strict means that the
client will attempt to follow the CIFS/SMB2 protocol
strictly. That is, the cache is only trusted when the client
holds an oplock. When the client <br>
does not hold an oplock, then the client bypasses the cache
and accesses the server directly to satisfy a read or write
request. By doing this, the client avoids problems with <br>
byte range locks. Additionally, byte range locks are cached
on the client when it holds an oplock and are
&quot;pushed&quot; to the server when that oplock is
recalled.</p>

<p style="margin-top: 1em">cache=loose allows the client to
use looser protocol semantics which can sometimes provide
better performance at the expense of cache coherency. File
access always involves the <br>
pagecache. When an oplock or lease is not held, then the
client will attempt to flush the cache soon after a write to
a file. Note that that flush does not necessarily occur <br>
before a write system call returns.</p>

<p style="margin-top: 1em">In the case of a read without
holding an oplock, the client will attempt to periodically
check the attributes of the file in order to ascertain
whether it has changed and the <br>
cache might no longer be valid. This mechanism is much like
the one that NFSv2/3 use for cache coherency, but it
particularly problematic with CIFS. Windows is quite
&quot;lazy&quot; with <br>
respect to updating the &quot;LastWriteTime&quot; field that
the client uses to verify this. The effect is that
cache=loose can cause data corruption when multiple readers
and writers are <br>
working on the same files.</p>

<p style="margin-top: 1em">Because of this, when multiple
clients are accessing the same set of files, then
cache=strict is recommended. That helps eliminate problems
with cache coherency by following the <br>
CIFS/SMB2 protocols more strictly.</p>

<p style="margin-top: 1em">Note too that no matter what
caching model is used, the client will always use the
pagecache to handle mmap&rsquo;ed files. Writes to
mmap&rsquo;ed files are only guaranteed to be flushed to
<br>
the server when msync() is called, or on close().</p>

<p style="margin-top: 1em">The default in kernels prior to
3.7 was &quot;loose&quot;. As of 3.7, the default is
&quot;strict&quot;.</p>

<p style="margin-top: 1em">CIFS/NTFS ACL, SID/UID/GID
MAPPING, SECURITY DESCRIPTORS <br>
This option is used to work with file objects which posses
Security Descriptors and CIFS/NTFS ACL instead of UID, GID,
file permission bits, and POSIX ACL as user authentication
<br>
model. This is the most common authentication model for CIFS
servers and is the one used by Windows.</p>

<p style="margin-top: 1em">Support for this requires both
CIFS_XATTR and CIFS_ACL support in the CIFS configuration
options when building the cifs module.</p>

<p style="margin-top: 1em">A CIFS/NTFS ACL is mapped to
file permission bits using an algorithm specified in the
following Microsoft TechNet document:</p>

<p style="margin-top: 1em">&Acirc;&middot;
http://technet.microsoft.com/en-us/library/bb463216.aspx</p>

<p style="margin-top: 1em">In order to map SIDs to/from
UIDs and GIDs, the following is required:</p>

<p style="margin-top: 1em">&Acirc;&middot; a kernel upcall
to the cifs.idmap utility set up via request-key.conf(5)</p>

<p style="margin-top: 1em">&Acirc;&middot; winbind support
configured via nsswitch.conf(5) and smb.conf(5)</p>

<p style="margin-top: 1em">Please refer to the respective
manpages of cifs.idmap(8) and winbindd(8) for more
information.</p>

<p style="margin-top: 1em">Security descriptors for a file
object can be retrieved and set directly using extended
attribute named system.cifs_acl. The security descriptors
presented via this interface are <br>
&quot;raw&quot; blobs of data and need a userspace utility
to either parse and format or to assemble it such as
getcifsacl(1) and setcifsacl(1) respectively.</p>

<p style="margin-top: 1em">Some of the things to consider
while using this mount option:</p>

<p style="margin-top: 1em">&Acirc;&middot; There may be an
increased latency when handling metadata due to additional
requests to get and set security descriptors.</p>

<p style="margin-top: 1em">&Acirc;&middot; The mapping
between a CIFS/NTFS ACL and POSIX file permission bits is
imperfect and some ACL information may be lost in the
translation.</p>

<p style="margin-top: 1em">&Acirc;&middot; If either upcall
to cifs.idmap is not setup correctly or winbind is not
configured and running, ID mapping will fail. In that case
uid and gid will default to either to those <br>
values of the share or to the values of uid and/or gid mount
options if specified.</p>

<p style="margin-top: 1em">ACCESSING FILES WITH BACKUP
INTENT <br>
For an user on the server, desired access to a file is
determined by the permissions and rights associated with
that file. This is typically accomplished using owenrship
and <br>
ACL. For a user who does not have access rights to a file,
it is still possible to access that file for a specific or a
targeted purpose by granting special rights. One of the <br>
specific purposes is to access a file with the intent to
either backup or restore i.e. backup intent. The right to
access a file with the backup intent can typically be
granted <br>
by making that user a part of the built-in group Backup
Operators. Thus, when this user attempts to open a file with
the backup intent, open request is sent by setting the bit
<br>
FILE_OPEN_FOR_BACKUP_INTENT as one of the CreateOptions.</p>

<p style="margin-top: 1em">As an example, on a Windows
server, a user named testuser, cannot open this file with
such a security descriptor.</p>

<p style="margin-top: 1em">REVISION:0x1 <br>
CONTROL:0x9404 <br>
OWNER:Administrator <br>
GROUP:Domain Users <br>
ACL:Administrator:ALLOWED/0x0/FULL</p>

<p style="margin-top: 1em">But the user testuser, if it
becomes part of the group Backup Operators, can open the
file with the backup intent.</p>

<p style="margin-top: 1em">Any user on the client side who
can authenticate as such a user on the server, can access
the files with the backup intent. But it is desirable and
preferable for security <br>
reasons amongst many, to restrict this special right.</p>

<p style="margin-top: 1em">The mount option backupuid is
used to restrict this special right to a user which is
specified by either a name or an id. The mount option
backupgid is used to restrict this <br>
special right to the users in a group which is specified by
either a name or an id. Only users maching either backupuid
or backupgid shall attempt to access files with backup <br>
intent. These two mount options can be used together.</p>

<p style="margin-top: 1em">FILE AND DIRECTORY OWNERSHIP AND
PERMISSIONS <br>
The core CIFS protocol does not provide unix ownership
information or mode for files and directories. Because of
this, files and directories will generally appear to be
owned by <br>
whatever values the uid= or gid= options are set, and will
have permissions set to the default file_mode and dir_mode
for the mount. Attempting to change these values via <br>
chmod/chown will return success but have no effect.</p>

<p style="margin-top: 1em">When the client and server
negotiate unix extensions, files and directories will be
assigned the uid, gid, and mode provided by the server.
Because CIFS mounts are generally <br>
single-user, and the same credentials are used no matter
what user accesses the mount, newly created files and
directories will generally be given ownership corresponding
to <br>
whatever credentials were used to mount the share.</p>

<p style="margin-top: 1em">If the uid&Acirc;&acute;s and
gid&Acirc;&acute;s being used do not match on the client and
server, the forceuid and forcegid options may be helpful.
Note however, that there is no corresponding option to <br>
override the mode. Permissions assigned to a file when
forceuid or forcegid are in effect may not reflect the the
real permissions.</p>

<p style="margin-top: 1em">When unix extensions are not
negotiated, it&Acirc;&acute;s also possible to emulate them
locally on the server using the &quot;dynperm&quot; mount
option. When this mount option is in effect, newly <br>
created files and directories will receive what appear to be
proper permissions. These permissions are not stored on the
server however and can disappear at any time in the <br>
future (subject to the whims of the kernel flushing out the
inode cache). In general, this mount option is
discouraged.</p>

<p style="margin-top: 1em">It&Acirc;&acute;s also possible
to override permission checking on the client altogether via
the noperm option. Server-side permission checks cannot be
overriden. The permission checks done <br>
by the server will always correspond to the credentials used
to mount the share, and not necessarily to the user who is
accessing the share.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The variable USER may contain the username of the person to
be used to authenticate to the server. The variable can be
used to set both username and password by using the format
<br>
username%password.</p>

<p style="margin-top: 1em">The variable PASSWD may contain
the password of the person using the client.</p>

<p style="margin-top: 1em">The variable PASSWD_FILE may
contain the pathname of a file to read the password from. A
single line of input is read and used as the password.</p>

<p style="margin-top: 1em">NOTES <br>
This command may be used only by root, unless installed
setuid, in which case the noeexec and nosuid mount flags are
enabled. When installed as a setuid program, the program
<br>
follows the conventions set forth by the mount program for
user mounts, with the added restriction that users must be
able to chdir() into the mountpoint prior to the mount in
<br>
order to be able to mount onto it.</p>

<p style="margin-top: 1em">Some samba client tools like
smbclient(8) honour client-side configuration parameters
present in smb.conf. Unlike those client tools, mount.cifs
ignores smb.conf completely.</p>

<p style="margin-top: 1em">CONFIGURATION <br>
The primary mechanism for making configuration changes and
for reading debug information for the cifs vfs is via the
Linux /proc filesystem. In the directory /proc/fs/cifs are
<br>
various configuration files and pseudo files which can
display debug information. There are additional startup
options such as maximum buffer size and number of buffers
which <br>
only may be set when the kernel cifs vfs (cifs.ko module) is
loaded. These can be seen by running the modinfo utility
against the file cifs.ko which will list the options that
<br>
may be passed to cifs during module installation (device
driver load). For more information see the kernel file
fs/cifs/README.</p>

<p style="margin-top: 1em">BUGS <br>
Mounting using the CIFS URL specification is currently not
supported.</p>

<p style="margin-top: 1em">The credentials file does not
handle usernames or passwords with leading space.</p>

<p style="margin-top: 1em">Note that the typical response
to a bug report is a suggestion to try the latest version
first. So please try doing that first, and always include
which versions you use of <br>
relevant software when reporting bugs (minimum: mount.cifs
(try mount.cifs -V), kernel (see /proc/version) and server
type you are trying to contact.</p>

<p style="margin-top: 1em">VERSION <br>
This man page is correct for version 1.74 of the cifs vfs
filesystem (roughly Linux kernel 3.0).</p>

<p style="margin-top: 1em">SEE ALSO <br>
cifs.upcall(8), getcifsacl(1), setcifsacl(1)</p>


<p style="margin-top: 1em">Documentation/filesystems/cifs.txt
and fs/cifs/README in the linux kernel source tree may
contain additional options and information.</p>

<p style="margin-top: 1em">AUTHOR <br>
Steve French</p>

<p style="margin-top: 1em">The syntax and manpage were
loosely based on that of smbmount. It was converted to
Docbook/XML by Jelmer Vernooij.</p>

<p style="margin-top: 1em">The maintainer of the Linux cifs
vfs and the userspace tool mount.cifs is Steve French. The
Linux CIFS Mailing list is the preferred place to ask
questions regarding these <br>
programs.</p>

<p style="margin-top: 1em">cifs-utils 02/07/2010
MOUNT.CIFS(8)</p>
<hr>
</body>
</html>
