<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:10:30 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DOCKER(8) SEPTEMBER 2015 DOCKER(8)</p>

<p style="margin-top: 1em">NAME <br>
dockerd - Enable daemon mode</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dockerd [--add-runtime[=[]]] [--add-registry[=[]]]
[--api-cors-header=[=API-CORS-HEADER]]
[--authorization-plugin[=[]]] [-b|--bridge[=BRIDGE]]
[--bip[=BIP]] [--block-reg&acirc; <br>
istry[=[]]] [--cgroup-parent[=[]]] [--cluster-store[=[]]]
[--cluster-advertise[=[]]] [--cluster-store-opt[=map[]]]
[--config-file[=/etc/docker/daemon.json]] [--contain&acirc;
<br>
erd[=SOCKET-PATH]] [-D|--debug]
[--default-gateway[=DEFAULT-GATEWAY]]
[--default-gateway-v6[=DEFAULT-GATEWAY-V6]]
[--default-ulimit[=[]]] [--disable-legacy-registry]
[--dns[=[]]] <br>
[--dns-opt[=[]]] [--dns-search[=[]]]
[--enable-secrets[=true]] [--exec-opt[=[]]]
[--exec-root[=/var/run/docker]] [--fixed-cidr[=FIXED-CIDR]]
[--fixed-cidr-v6[=FIXED-CIDR-V6]] <br>
[-G|--group[=docker]] [-g|--graph[=/var/lib/docker]]
[-H|--host[=[]]] [--help] [--icc[=true]]
[--insecure-registry[=[]]] [--ip[=0.0.0.0]]
[--ip-forward[=true]] [--ip-masq[=true]] <br>
[--iptables[=true]] [--ipv6] [--isolation[=default]]
[-l|--log-level[=info]] [--label[=[]]]
[--live-restore[=false]] [--log-driver[=json-file]]
[--log-opt[=map[]]] [--mtu[=0]] <br>
[--max-concurrent-downloads[=3]]
[--max-concurrent-uploads[=5]]
[-p|--pidfile[=/var/run/docker.pid]] [--raw-logs]
[--registry-mirror[=[]]]
[-s|--storage-driver[=STORAGE-DRIVER]] <br>
[--selinux-enabled] [--signature-verification]
[--storage-opt[=[]]]
[--swarm-default-advertise-addr[=IP|INTERFACE]] [--tls]
[--tlscacert[= /.docker/ca.pem]] <br>
[--tlscert[= /.docker/cert.pem]] [--tlskey[=
/.docker/key.pem]] [--tlsverify] [--userland-proxy[=true]]
[--userns-remap[=default]]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
dockerd is used for starting the Docker daemon(i.e., to
command the daemon to manage images, containers etc.) So
dockerd is a server, as a daemon.</p>

<p style="margin-top: 1em">To run the Docker daemon you can
specify dockerd. You can check the daemon options using
dockerd --help. Daemon options should be specified after the
dockerd keyword in the <br>
following format.</p>

<p style="margin-top: 1em">dockerd [OPTIONS]</p>

<p style="margin-top: 1em">OPTIONS <br>
--add-runtime=[] <br>
Set additional OCI compatible runtime.</p>

<p style="margin-top: 1em">--add-registry=[] <br>
EXPERIMENTAL Each given registry will be queried before a
public Docker registry during image pulls or searches. They
will be searched in the order given. Registry mirrors <br>
won&rsquo;t apply to them.</p>

<p style="margin-top: 1em">--api-cors-header=&quot;&quot;
<br>
Set CORS headers in the remote API. Default is cors
disabled. Give urls like &quot;
&acirc;&uml;http://foo&acirc;&copy;,
&acirc;&uml;http://bar&acirc;&copy;, ...&quot;. Give
&quot;*&quot; to allow all.</p>


<p style="margin-top: 1em">--authorization-plugin=&quot;&quot;
<br>
Set authorization plugins to load</p>

<p style="margin-top: 1em">-b, --bridge=&quot;&quot; <br>
Attach containers to a pre-existing network bridge; use
&rsquo;none&rsquo; to disable container networking</p>

<p style="margin-top: 1em">--bip=&quot;&quot; <br>
Use the provided CIDR notation address for the dynamically
created bridge (docker0); Mutually exclusive of -b</p>

<p style="margin-top: 1em">--block-registry=[] <br>
EXPERIMENTAL Prevent Docker daemon from contacting specified
registries. There are two special keywords recognized. The
first is &quot;public&quot; and represents public Docker
registry. <br>
The second is &quot;all&quot; which causes all registries
but those added with --add-registry flag to be blocked.</p>

<p style="margin-top: 1em">--cgroup-parent=&quot;&quot;
<br>
Set parent cgroup for all containers. Default is
&quot;/docker&quot; for fs cgroup driver and
&quot;system.slice&quot; for systemd cgroup driver.</p>

<p style="margin-top: 1em">--cluster-store=&quot;&quot;
<br>
URL of the distributed storage backend</p>


<p style="margin-top: 1em">--cluster-advertise=&quot;&quot;
<br>
Specifies the &rsquo;host:port&rsquo; or interface:port
combination that this particular <br>
daemon instance should use when advertising itself to the
cluster. The daemon <br>
is reached through this value.</p>


<p style="margin-top: 1em">--cluster-store-opt=&quot;&quot;
<br>
Specifies options for the Key/Value store.</p>


<p style="margin-top: 1em">--config-file=&quot;/etc/docker/daemon.json&quot;
<br>
Specifies the JSON file path to load the configuration
from.</p>

<p style="margin-top: 1em">--containerd=&quot;&quot; <br>
Path to containerd socket.</p>

<p style="margin-top: 1em">-D, --debug=true|false <br>
Enable debug mode. Default is false.</p>

<p style="margin-top: 1em">--default-gateway=&quot;&quot;
<br>
IPv4 address of the container default gateway; this address
must be part of the bridge subnet (which is defined by -b or
--bip)</p>


<p style="margin-top: 1em">--default-gateway-v6=&quot;&quot;
<br>
IPv6 address of the container default gateway</p>

<p style="margin-top: 1em">--default-ulimit=[] <br>
Default ulimits for containers.</p>


<p style="margin-top: 1em">--disable-legacy-registry=true|false
<br>
Disable contacting legacy registries</p>

<p style="margin-top: 1em">--dns=&quot;&quot; <br>
Force Docker to use specific DNS servers</p>

<p style="margin-top: 1em">--dns-opt=&quot;&quot; <br>
DNS options to use.</p>

<p style="margin-top: 1em">--dns-search=[] <br>
DNS search domains to use.</p>

<p style="margin-top: 1em">--enable-secrets=true|false <br>
Allow subscription-manager inside the containers to use
subscriptions available on the host. Default is true.</p>

<p style="margin-top: 1em">--exec-opt=[] <br>
Set runtime execution options. See RUNTIME EXECUTION
OPTIONS.</p>

<p style="margin-top: 1em">--exec-root=&quot;&quot; <br>
Path to use as the root of the Docker execution state files.
Default is /var/run/docker.</p>

<p style="margin-top: 1em">--fixed-cidr=&quot;&quot; <br>
IPv4 subnet for fixed IPs (e.g., 10.20.0.0/16); this subnet
must be nested in the bridge subnet (which is defined by -b
or --bip)</p>

<p style="margin-top: 1em">--fixed-cidr-v6=&quot;&quot;
<br>
IPv6 subnet for global IPv6 addresses (e.g.,
2a00:1450::/64)</p>

<p style="margin-top: 1em">-G, --group=&quot;&quot; <br>
Group to assign the unix socket specified by -H when running
in daemon mode. <br>
use &rsquo;&rsquo; (the empty string) to disable setting of
a group. Default is docker.</p>

<p style="margin-top: 1em">-g, --graph=&quot;&quot; <br>
Path to use as the root of the Docker runtime. Default is
/var/lib/docker.</p>

<p style="margin-top: 1em">-H,
--host=[unix:///var/run/docker.sock]: tcp://[host:port] to
bind or unix://[/path/to/socket] to use. <br>
The socket(s) to bind to in daemon mode specified using one
or more <br>
tcp://host:port, unix:///path/to/socket, fd://* or
fd://socketfd.</p>

<p style="margin-top: 1em">--help <br>
Print usage statement</p>

<p style="margin-top: 1em">--icc=true|false <br>
Allow unrestricted inter-container and Docker daemon host
communication. If disabled, containers can still be linked
together using the --link option (see docker-run(1)). <br>
Default is true.</p>

<p style="margin-top: 1em">--insecure-registry=[] <br>
Enable insecure registry communication, i.e., enable
un-encrypted and/or untrusted communication.</p>

<p style="margin-top: 1em">List of insecure registries can
contain an element with CIDR notation to specify a whole
subnet. Insecure registries accept HTTP and/or accept HTTPS
with certificates from <br>
unknown CAs.</p>

<p style="margin-top: 1em">Enabling --insecure-registry is
useful when running a local registry. However, because its
use creates security vulnerabilities it should ONLY be
enabled for testing purposes. <br>
For increased security, users should add their CA to their
system&rsquo;s list of trusted CAs instead of using
--insecure-registry.</p>

<p style="margin-top: 1em">--ip=&quot;&quot; <br>
Default IP address to use when binding container ports.
Default is 0.0.0.0.</p>

<p style="margin-top: 1em">--ip-forward=true|false <br>
Enables IP forwarding on the Docker host. The default is
true. This flag interacts with the IP forwarding setting on
your host system&rsquo;s kernel. If your system has IP
forwarding <br>
disabled, this setting enables it. If your system has IP
forwarding enabled, setting this flag to --ip-forward=false
has no effect.</p>

<p style="margin-top: 1em">This setting will also enable
IPv6 forwarding if you have both --ip-forward=true and
--fixed-cidr-v6 set. Note that this may reject Router
Advertisements and interfere with the <br>
host&rsquo;s existing IPv6 configuration. For more
information, please consult the documentation about
&quot;Advanced Networking - IPv6&quot;.</p>

<p style="margin-top: 1em">--ip-masq=true|false <br>
Enable IP masquerading for bridge&rsquo;s IP range. Default
is true.</p>

<p style="margin-top: 1em">--iptables=true|false <br>
Enable Docker&rsquo;s addition of iptables rules. Default is
true.</p>

<p style="margin-top: 1em">--ipv6=true|false <br>
Enable IPv6 support. Default is false. Docker will create an
IPv6-enabled bridge with address fe80::1 which will allow
you to create IPv6-enabled containers. Use together with
<br>
--fixed-cidr-v6 to provide globally routable IPv6 addresses.
IPv6 forwarding will be enabled if not used with
--ip-forward=false. This may collide with your host&rsquo;s
current IPv6 <br>
settings. For more information please consult the
documentation about &quot;Advanced Networking -
IPv6&quot;.</p>

<p style="margin-top: 1em">--isolation=&quot;default&quot;
<br>
Isolation specifies the type of isolation technology used by
containers. Note that the default on Windows server is
process, and the default on Windows client is hyperv. Linux
<br>
only supports default.</p>

<p style="margin-top: 1em">-l,
--log-level=&quot;debug|info|warn|error|fatal&quot; <br>
Set the logging level. Default is info.</p>

<p style="margin-top: 1em">--label=&quot;[]&quot; <br>
Set key=value labels to the daemon (displayed in docker
info)</p>

<p style="margin-top: 1em">--live-restore=false <br>
Enable live restore of running containers when the daemon
starts so that they are not restarted.</p>


<p style="margin-top: 1em">--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;
<br>
Default driver for container logs. Default is json-file.
<br>
Warning: docker logs command works only for json-file
logging driver.</p>

<p style="margin-top: 1em">--log-opt=[] <br>
Logging driver specific options.</p>

<p style="margin-top: 1em">--mtu=0 <br>
Set the containers network mtu. Default is 0.</p>

<p style="margin-top: 1em">--max-concurrent-downloads=3
<br>
Set the max concurrent downloads for each pull. Default is
3.</p>

<p style="margin-top: 1em">--max-concurrent-uploads=5 <br>
Set the max concurrent uploads for each push. Default is
5.</p>

<p style="margin-top: 1em">-p, --pidfile=&quot;&quot; <br>
Path to use for daemon PID file. Default is
/var/run/docker.pid</p>

<p style="margin-top: 1em">--raw-logs Output daemon logs in
full timestamp format without ANSI coloring. If this flag is
not set, the daemon outputs condensed, colorized logs if a
terminal is detected, or <br>
full (&quot;raw&quot;) output otherwise.</p>


<p style="margin-top: 1em">--registry-mirror=&lt;scheme&gt;://&lt;host&gt;
<br>
Prepend a registry mirror to be used for image pulls. May be
specified multiple times.</p>

<p style="margin-top: 1em">-s,
--storage-driver=&quot;&quot; <br>
Force the Docker runtime to use a specific storage
driver.</p>

<p style="margin-top: 1em">--selinux-enabled=true|false
<br>
Enable selinux support. Default is false.</p>


<p style="margin-top: 1em">--signature-verification=true|false
<br>
Enable image signature verification. Default is true.
WARNING: this option doesn&rsquo;t work <br>
with images being pulled from v1 docker registries. See
SIGNATURE VERIFICATION.</p>

<p style="margin-top: 1em">--storage-opt=[] <br>
Set storage driver options. See STORAGE DRIVER OPTIONS.</p>


<p style="margin-top: 1em">--swarm-default-advertise-addr=IP|INTERFACE
<br>
Set default address or interface for swarm to advertise as
its externally-reachable address to other cluster <br>
members. This can be a hostname, an IP address, or an
interface such as eth0. A port cannot be specified with <br>
this option.</p>

<p style="margin-top: 1em">--tls=true|false <br>
Use TLS; implied by --tlsverify. Default is false.</p>

<p style="margin-top: 1em">--tlscacert= /.docker/ca.pem
<br>
Trust certs signed only by this CA.</p>

<p style="margin-top: 1em">--tlscert= /.docker/cert.pem
<br>
Path to TLS certificate file.</p>

<p style="margin-top: 1em">--tlskey= /.docker/key.pem <br>
Path to TLS key file.</p>

<p style="margin-top: 1em">--tlsverify=true|false <br>
Use TLS and verify the remote (daemon: verify client,
client: verify daemon). <br>
Default is false.</p>

<p style="margin-top: 1em">--userland-proxy=true|false <br>
Rely on a userland proxy implementation for inter-container
and outside-to-container loopback communications. Default is
true.</p>


<p style="margin-top: 1em">--userns-remap=default|uid:gid|user:group|user|uid
<br>
Enable user namespaces for containers on the daemon.
Specifying &quot;default&quot; will cause a new user and
group to be created to handle UID and GID range remapping
for the user <br>
namespace mappings used for contained processes. Specifying
a user (or uid) and optionally a group (or gid) will cause
the daemon to lookup the user and group&rsquo;s subordinate
ID <br>
ranges for use as the user namespace mappings for contained
processes.</p>

<p style="margin-top: 1em">SIGNATURE VERIFICATION <br>
Docker supports GPG image signatures verification when
--signature-verification flag is true. This functionality
works only at pull time and for images being pulled from
docker <br>
registries version 2. You can sign an image using skopeo(1)
or atomic(1). See
&acirc;&uml;https://access.redhat.com/articles/2750891&acirc;&copy;.</p>

<p style="margin-top: 1em">STORAGE DRIVER OPTIONS <br>
Docker uses storage backends (known as
&quot;graphdrivers&quot; in the Docker internals) to create
writable containers from images. Many of these backends use
operating system level tech&acirc; <br>
nologies and can be configured.</p>

<p style="margin-top: 1em">Specify options to the storage
backend with --storage-opt flags. The backends that
currently take options are devicemapper, zfs and btrfs.
Options for devicemapper are prefixed <br>
with dm, options for zfs start with zfs and options for
btrfs start with btrfs.</p>

<p style="margin-top: 1em">Specifically for devicemapper,
the default is a &quot;loopback&quot; model which requires
no pre-configuration, but is extremely inefficient. Do not
use it in production.</p>

<p style="margin-top: 1em">To make the best use of Docker
with the devicemapper backend, you must have a recent
version of LVM. Use lvm to create a thin pool; for more
information see man lvmthin. Then, <br>
use --storage-opt dm.thinpooldev to tell the Docker engine
to use that pool for allocating images and container
snapshots.</p>

<p style="margin-top: 1em">Devicemapper options <br>
dm.thinpooldev <br>
Specifies a custom block storage device to use for the thin
pool.</p>

<p style="margin-top: 1em">If using a block device for
device mapper storage, it is best to use lvm to create and
manage the thin-pool volume. This volume is then handed to
Docker to exclusively create <br>
snapshot volumes needed for images and containers.</p>

<p style="margin-top: 1em">Managing the thin-pool outside
of Engine makes for the most feature-rich method of having
Docker utilize device mapper thin provisioning as the
backing storage for Docker con&acirc; <br>
tainers. The highlights of the lvm-based thin-pool
management feature include: automatic or interactive
thin-pool resize support, dynamically changing thin-pool
features, auto&acirc; <br>
matic thinp metadata checking when lvm activates the
thin-pool, etc.</p>

<p style="margin-top: 1em">As a fallback if no thin pool is
provided, loopback files are created. Loopback is very slow,
but can be used without any pre-configuration of storage. It
is strongly recommended <br>
that you do not use loopback in production. Ensure your
Engine daemon has a --storage-opt dm.thinpooldev argument
provided.</p>

<p style="margin-top: 1em">Example use:</p>

<p style="margin-top: 1em">$ dockerd --storage-opt
dm.thinpooldev=/dev/mapper/thin-pool</p>

<p style="margin-top: 1em">dm.basesize <br>
Specifies the size to use when creating the base device,
which limits the size of images and containers. The default
value is 10G. Note, thin devices are inherently
&quot;sparse&quot;, so <br>
a 10G device which is mostly empty doesn&rsquo;t use 10 GB
of space on the pool. However, the filesystem will use more
space for base images the larger the device is.</p>

<p style="margin-top: 1em">The base device size can be
increased at daemon restart which will allow all future
images and containers (based on those new images) to be of
the new base device size.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.basesize=50G</p>

<p style="margin-top: 1em">This will increase the base
device size to 50G. The Docker daemon will throw an error if
existing base device size is larger than 50G. A user can use
this option to expand the <br>
base device size however shrinking is not permitted.</p>

<p style="margin-top: 1em">This value affects the
system-wide &quot;base&quot; empty filesystem that may
already be initialized and inherited by pulled images.
Typically, a change to this value requires additional <br>
steps to take effect:</p>

<p style="margin-top: 1em">$ sudo service docker stop <br>
$ sudo rm -rf /var/lib/docker <br>
$ sudo service docker start</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.basesize=20G</p>

<p style="margin-top: 1em">dm.fs <br>
Specifies the filesystem type to use for the base device.
The supported options are ext4 and xfs. The default is
ext4.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.fs=xfs</p>

<p style="margin-top: 1em">dm.mkfsarg <br>
Specifies extra mkfs arguments to be used when creating the
base device.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt &quot;dm.mkfsarg=-O ^has_journal&quot;</p>

<p style="margin-top: 1em">dm.mountopt <br>
Specifies extra mount options used when mounting the thin
devices.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.mountopt=nodiscard</p>

<p style="margin-top: 1em">dm.use_deferred_removal <br>
Enables use of deferred device removal if libdm and the
kernel driver support the mechanism.</p>

<p style="margin-top: 1em">Deferred device removal means
that if device is busy when devices are being
removed/deactivated, then a deferred removal is scheduled on
device. And devices automatically go away <br>
when last user of the device exits.</p>

<p style="margin-top: 1em">For example, when a container
exits, its associated thin device is removed. If that device
has leaked into some other mount namespace and can&rsquo;t
be removed, the container exit <br>
still succeeds and this option causes the system to schedule
the device for deferred removal. It does not wait in a loop
trying to remove a busy device.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.use_deferred_removal=true</p>

<p style="margin-top: 1em">dm.use_deferred_deletion <br>
Enables use of deferred device deletion for thin pool
devices. By default, thin pool device deletion is
synchronous. Before a container is deleted, the Docker
daemon removes any <br>
associated devices. If the storage driver can not remove a
device, the container deletion fails and daemon returns.</p>

<p style="margin-top: 1em">Error deleting container: Error
response from daemon: Cannot destroy container</p>

<p style="margin-top: 1em">To avoid this failure, enable
both deferred device deletion and deferred device removal on
the daemon.</p>

<p style="margin-top: 1em">dockerd --storage-opt
dm.use_deferred_deletion=true --storage-opt
dm.use_deferred_removal=true</p>

<p style="margin-top: 1em">With these two options enabled,
if a device is busy when the driver is deleting a container,
the driver marks the device as deleted. Later, when the
device isn&rsquo;t in use, the <br>
driver deletes it.</p>

<p style="margin-top: 1em">In general it should be safe to
enable this option by default. It will help when
unintentional leaking of mount point happens across multiple
mount namespaces.</p>

<p style="margin-top: 1em">dm.loopdatasize <br>
Note: This option configures devicemapper loopback, which
should not be used in production.</p>

<p style="margin-top: 1em">Specifies the size to use when
creating the loopback file for the &quot;data&quot; device
which is used for the thin pool. The default size is 100G.
The file is sparse, so it will not ini&acirc; <br>
tially take up this much space.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.loopdatasize=200G</p>

<p style="margin-top: 1em">dm.loopmetadatasize <br>
Note: This option configures devicemapper loopback, which
should not be used in production.</p>

<p style="margin-top: 1em">Specifies the size to use when
creating the loopback file for the &quot;metadata&quot;
device which is used for the thin pool. The default size is
2G. The file is sparse, so it will not <br>
initially take up this much space.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.loopmetadatasize=4G</p>

<p style="margin-top: 1em">dm.datadev <br>
(Deprecated, use dm.thinpooldev)</p>

<p style="margin-top: 1em">Specifies a custom blockdevice
to use for data for a Docker-managed thin pool. It is better
to use dm.thinpooldev - see the documentation for it above
for discussion of the <br>
advantages.</p>

<p style="margin-top: 1em">dm.metadatadev <br>
(Deprecated, use dm.thinpooldev)</p>

<p style="margin-top: 1em">Specifies a custom blockdevice
to use for metadata for a Docker-managed thin pool. See
dm.datadev for why this is deprecated.</p>

<p style="margin-top: 1em">dm.blocksize <br>
Specifies a custom blocksize to use for the thin pool. The
default blocksize is 64K.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.blocksize=512K</p>

<p style="margin-top: 1em">dm.blkdiscard <br>
Enables or disables the use of blkdiscard when removing
devicemapper devices. This is disabled by default due to the
additional latency, but as a special case with loopback <br>
devices it will be enabled, in order to re-sparsify the
loopback file on image/container removal.</p>

<p style="margin-top: 1em">Disabling this on loopback can
lead to much faster container removal times, but it also
prevents the space used in /var/lib/docker directory from
being returned to the system for <br>
other use when containers are removed.</p>

<p style="margin-top: 1em">Example use: dockerd
--storage-opt dm.blkdiscard=false</p>

<p style="margin-top: 1em">dm.override_udev_sync_check <br>
By default, the devicemapper backend attempts to synchronize
with the udev device manager for the Linux kernel. This
option allows disabling that synchronization, to continue
<br>
even though the configuration may be buggy.</p>

<p style="margin-top: 1em">To view the udev sync support of
a Docker daemon that is using the devicemapper driver,
run:</p>

<p style="margin-top: 1em">$ docker info <br>
[...] <br>
Udev Sync Supported: true <br>
[...]</p>

<p style="margin-top: 1em">When udev sync support is true,
then devicemapper and udev can coordinate the activation and
deactivation of devices for containers.</p>

<p style="margin-top: 1em">When udev sync support is false,
a race condition occurs between the devicemapper and udev
during create and cleanup. The race condition results in
errors and failures. (For <br>
information on these failures, see</p>


<p style="margin-top: 1em">&acirc;&uml;https://github.com/docker/docker/issues/4036&acirc;&copy;)</p>

<p style="margin-top: 1em">To allow the docker daemon to
start, regardless of whether udev sync is false, set
dm.override_udev_sync_check to true:</p>

<p style="margin-top: 1em">$ dockerd --storage-opt
dm.override_udev_sync_check=true</p>

<p style="margin-top: 1em">When this value is true, the
driver continues and simply warns you the errors are
happening.</p>

<p style="margin-top: 1em">Note: The ideal is to pursue a
docker daemon and environment that does support
synchronizing with udev. For further discussion on this
topic, see</p>


<p style="margin-top: 1em">&acirc;&uml;https://github.com/docker/docker/issues/4036&acirc;&copy;.
Otherwise, set this flag for migrating existing Docker
daemons to a daemon with a supported environment.</p>

<p style="margin-top: 1em">dm.min_free_space <br>
Specifies the min free space percent in a thin pool require
for new device creation to succeed. This check applies to
both free data space as well as free metadata space. Valid
<br>
values are from 0% - 99%. Value 0% disables free space
checking logic. If user does not specify a value for this
option, the Engine uses a default value of 10%.</p>

<p style="margin-top: 1em">Whenever a new a thin pool
device is created (during docker pull or during container
creation), the Engine checks if the minimum free space is
available. If the space is unavail&acirc; <br>
able, then device creation fails and any relevant docker
operation fails.</p>

<p style="margin-top: 1em">To recover from this error, you
must create more free space in the thin pool to recover from
the error. You can create free space by deleting some images
and containers from tge <br>
thin pool. You can also add more storage to the thin
pool.</p>

<p style="margin-top: 1em">To add more space to an LVM
(logical volume management) thin pool, just add more storage
to the group container thin pool; this should automatically
resolve any errors. If your <br>
configuration uses loop devices, then stop the Engine
daemon, grow the size of loop files and restart the daemon
to resolve the issue.</p>

<p style="margin-top: 1em">Example use:: dockerd
--storage-opt dm.min_free_space=10%</p>

<p style="margin-top: 1em">dm.xfs_nospace_max_retries <br>
Specifies the maximum number of retries XFS should attempt
to complete IO when ENOSPC (no space) error is returned by
underlying storage device.</p>

<p style="margin-top: 1em">By default XFS retries
infinitely for IO to finish and this can result in
unkillable process. To change this behavior one can set
xfs_nospace_max_retries to say 0 and XFS will <br>
not retry IO after getting ENOSPC and will shutdown
filesystem.</p>

<p style="margin-top: 1em">Example use:</p>

<p style="margin-top: 1em">$ sudo dockerd --storage-opt
dm.xfs_nospace_max_retries=0</p>

<p style="margin-top: 1em">ZFS options <br>
zfs.fsname <br>
Set zfs filesystem under which docker will create its own
datasets. By default docker will pick up the zfs filesystem
where docker graph (/var/lib/docker) is located.</p>

<p style="margin-top: 1em">Example use: dockerd -s zfs
--storage-opt zfs.fsname=zroot/docker</p>

<p style="margin-top: 1em">Btrfs options <br>
btrfs.min_space <br>
Specifies the mininum size to use when creating the
subvolume which is used for containers. If user uses disk
quota for btrfs when creating or running a container with
--stor&acirc; <br>
age-opt size option, docker should ensure the size cannot be
smaller than btrfs.min_space.</p>

<p style="margin-top: 1em">Example use: docker daemon -s
btrfs --storage-opt btrfs.min_space=10G</p>

<p style="margin-top: 1em">CLUSTER STORE OPTIONS <br>
The daemon uses libkv to advertise the node within the
cluster. Some Key/Value backends support mutual TLS, and the
client TLS settings used by the daemon can be configured
<br>
using the --cluster-store-opt flag, specifying the paths to
PEM encoded files.</p>

<p style="margin-top: 1em">kv.cacertfile <br>
Specifies the path to a local file with PEM encoded CA
certificates to trust</p>

<p style="margin-top: 1em">kv.certfile <br>
Specifies the path to a local file with a PEM encoded
certificate. This certificate is used as the client cert for
communication with the Key/Value store.</p>

<p style="margin-top: 1em">kv.keyfile <br>
Specifies the path to a local file with a PEM encoded
private key. This private key is used as the client key for
communication with the Key/Value store.</p>

<p style="margin-top: 1em">Access authorization <br>
Docker&rsquo;s access authorization can be extended by
authorization plugins that your organization can purchase or
build themselves. You can install one or more authorization
plugins <br>
when you start the Docker daemon using the
--authorization-plugin=PLUGIN_ID option.</p>

<p style="margin-top: 1em">dockerd
--authorization-plugin=plugin1
--authorization-plugin=plugin2,...</p>

<p style="margin-top: 1em">The PLUGIN_ID value is either
the plugin&rsquo;s name or a path to its specification file.
The plugin&rsquo;s implementation determines whether you can
specify a name or path. Consult with <br>
your Docker administrator to get information about the
plugins available to you.</p>

<p style="margin-top: 1em">Once a plugin is installed,
requests made to the daemon through the command line or
Docker&rsquo;s remote API are allowed or denied by the
plugin. If you have multiple plugins <br>
installed, at least one must allow the request for it to
complete.</p>

<p style="margin-top: 1em">For information about how to
create an authorization plugin, see
&acirc;&uml;https://docs.docker.com/engine/extend/authorization/&acirc;&copy;
section in the Docker extend section of this
documenta&acirc; <br>
tion.</p>

<p style="margin-top: 1em">HISTORY <br>
Sept 2015, Originally compiled by Shishir Mahajan
&acirc;&uml;shishir.mahajan@redhat.com&acirc;&copy; based on
docker.com source material and internal work.</p>

<p style="margin-top: 1em">Shishir Mahajan Docker User
Manuals DOCKER(8)</p>
<hr>
</body>
</html>
