<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:17:44 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>xfs_db(8) System Manager&rsquo;s Manual xfs_db(8)</p>

<p style="margin-top: 1em">NAME <br>
xfs_db - debug an XFS filesystem</p>

<p style="margin-top: 1em">SYNOPSIS <br>
xfs_db [ -c cmd ] ... [ -i|r|x|F ] [ -f ] [ -l logdev ] [ -p
progname ] device <br>
xfs_db -V</p>

<p style="margin-top: 1em">DESCRIPTION <br>
xfs_db is used to examine an XFS filesystem. Under rare
circumstances it can also be used to modify an XFS
filesystem, but that task is normally left to xfs_repair(8)
or to <br>
scripts such as xfs_admin(8) that run xfs_db.</p>

<p style="margin-top: 1em">OPTIONS <br>
-c cmd xfs_db commands may be run interactively (the
default) or as arguments on the command line. Multiple -c
arguments may be given. The commands are run in the sequence
given, <br>
then the program exits.</p>

<p style="margin-top: 1em">-f Specifies that the filesystem
image to be processed is stored in a regular file at device
(see the mkfs.xfs(8) -d file option). This might happen if
an image copy of a <br>
filesystem has been made into an ordinary file with
xfs_copy(8).</p>

<p style="margin-top: 1em">-F Specifies that we want to
continue even if the superblock magic is not correct. For
use in xfs_metadump.</p>

<p style="margin-top: 1em">-i Allows execution on a mounted
filesystem, provided it is mounted read-only. Useful for
shell scripts which must only operate on filesystems in a
guaranteed consistent <br>
state (either unmounted or mounted read-only). These
semantics are slightly different to that of the -r
option.</p>

<p style="margin-top: 1em">-l logdev <br>
Specifies the device where the filesystems external log
resides. Only for those filesystems which use an external
log. See the mkfs.xfs(8) -l option, and refer to xfs(5) <br>
for a detailed description of the XFS log.</p>

<p style="margin-top: 1em">-p progname <br>
Set the program name to progname for prompts and some error
messages, the default value is xfs_db.</p>

<p style="margin-top: 1em">-r Open device or filename
read-only. This option is required if the filesystem is
mounted. It is only necessary to omit this flag if a command
that changes data (write, <br>
blocktrash) is to be used.</p>

<p style="margin-top: 1em">-x Specifies expert mode. This
enables the write and blocktrash commands.</p>

<p style="margin-top: 1em">-V Prints the version number and
exits.</p>

<p style="margin-top: 1em">CONCEPTS <br>
xfs_db commands can be broken up into two classes. Most
commands are for the navigation and display of data
structures in the filesystem. Other commands are for
scanning the <br>
filesystem in some way.</p>

<p style="margin-top: 1em">Commands which are used to
navigate the filesystem structure take arguments which
reflect the names of filesystem structure fields. There can
be multiple field names separated <br>
by dots when the underlying structures are nested, as in C.
The field names can be indexed (as an array index) if the
underlying field is an array. The array indices can be <br>
specified as a range, two numbers separated by a dash.</p>

<p style="margin-top: 1em">xfs_db maintains a current
address in the filesystem. The granularity of the address is
a filesystem structure. This can be a filesystem block, an
inode or quota (smaller than <br>
a filesystem block), or a directory block (could be larger
than a filesystem block). There are a variety of commands to
set the current address. Associated with the current <br>
address is the current data type, which is the structural
type of this data. Commands which follow the structure of
the filesystem always set the type as well as the address.
<br>
Commands which examine pieces of an individual file (inode)
need the current inode to be set, this is done with the
inode command.</p>

<p style="margin-top: 1em">The current address/type
information is actually maintained in a stack that can be
explicitly manipulated with the push, pop, and stack
commands. This allows for easy examina&acirc; <br>
tion of a nested filesystem structure. Also, the last
several locations visited are stored in a ring buffer which
can be manipulated with the forward, back, and ring
commands.</p>

<p style="margin-top: 1em">XFS filesystems are divided into
a small number of allocation groups. xfs_db maintains a
notion of the current allocation group which is manipulated
by some commands. The ini&acirc; <br>
tial allocation group is 0.</p>

<p style="margin-top: 1em">COMMANDS <br>
Many commands have extensive online help. Use the help
command for more details on any command.</p>

<p style="margin-top: 1em">a See the addr command.</p>

<p style="margin-top: 1em">ablock filoff <br>
Set current address to the offset filoff (a filesystem block
number) in the attribute area of the current inode.</p>

<p style="margin-top: 1em">addr [field-expression] <br>
Set current address to the value of the field-expression.
This is used to &quot;follow&quot; a reference in one
structure to the object being referred to. If no argument is
given, <br>
the current address is printed.</p>

<p style="margin-top: 1em">agf [agno] <br>
Set current address to the AGF block for allocation group
agno. If no argument is given, use the current allocation
group.</p>

<p style="margin-top: 1em">agfl [agno] <br>
Set current address to the AGFL block for allocation group
agno. If no argument is given, use the current allocation
group.</p>

<p style="margin-top: 1em">agi [agno] <br>
Set current address to the AGI block for allocation group
agno. If no argument is given, use the current allocation
group.</p>

<p style="margin-top: 1em">b See the back command.</p>

<p style="margin-top: 1em">back Move to the previous
location in the position ring.</p>

<p style="margin-top: 1em">blockfree <br>
Free block usage information collected by the last execution
of the blockget command. This must be done before another
blockget command can be given, presumably with dif&acirc;
<br>
ferent arguments than the previous one.</p>

<p style="margin-top: 1em">blockget [-npvs] [-b bno] ...
[-i ino] ... <br>
Get block usage and check filesystem consistency. The
information is saved for use by a subsequent blockuse,
ncheck, or blocktrash command.</p>

<p style="margin-top: 1em">-b is used to specify filesystem
block numbers about which verbose information should be
printed.</p>

<p style="margin-top: 1em">-i is used to specify inode
numbers about which verbose information should be
printed.</p>

<p style="margin-top: 1em">-n is used to save pathnames for
inodes visited, this is used to support the xfs_ncheck(8)
command. It also means that pathnames will be printed for
inodes that have <br>
problems. This option uses a lot of memory so is not enabled
by default.</p>

<p style="margin-top: 1em">-p causes error messages to be
prefixed with the filesystem name being processed. This is
useful if several copies of xfs_db are run in parallel.</p>

<p style="margin-top: 1em">-s restricts output to severe
errors only. This is useful if the output is too long
otherwise.</p>

<p style="margin-top: 1em">-v enables verbose output.
Messages will be printed for every block and inode
processed.</p>

<p style="margin-top: 1em">blocktrash [-z] [-o offset] [-n
count] [-x min] [-y max] [-s seed] [-0|1|2|3] [-t type] ...
<br>
Trash randomly selected filesystem metadata blocks. Trashing
occurs to randomly selected bits in the chosen blocks. This
command is available only in debugging versions <br>
of xfs_db. It is useful for testing xfs_repair(8).</p>

<p style="margin-top: 1em">-0 | -1 | -2 | -3 <br>
These are used to set the operating mode for blocktrash.
Only one can be used: -0 changed bits are cleared; -1
changed bits are set; -2 changed bits are inverted; <br>
-3 changed bits are randomized.</p>

<p style="margin-top: 1em">-n supplies the count of
block-trashings to perform (default 1).</p>

<p style="margin-top: 1em">-o supplies the bit offset at
which to start trashing the block. If the value is preceded
by a &rsquo;+&rsquo;, the trashing will start at a randomly
chosen offset that is larger <br>
than the value supplied. The default is to randomly choose
an offset anywhere in the block.</p>

<p style="margin-top: 1em">-s supplies a seed to the random
processing.</p>

<p style="margin-top: 1em">-t gives a type of blocks to be
selected for trashing. Multiple -t options may be given. If
no -t options are given then all metadata types can be
trashed.</p>

<p style="margin-top: 1em">-x sets the minimum size of bit
range to be trashed. The default value is 1.</p>

<p style="margin-top: 1em">-y sets the maximum size of bit
range to be trashed. The default value is 1024.</p>

<p style="margin-top: 1em">-z trashes the block at the top
of the stack. It is not necessary to run blockget if this
option is supplied.</p>

<p style="margin-top: 1em">blockuse [-n] [-c count] <br>
Print usage for current filesystem block(s). For each block,
the type and (if any) inode are printed.</p>

<p style="margin-top: 1em">-c specifies a count of blocks
to process. The default value is 1 (the current block
only).</p>

<p style="margin-top: 1em">-n specifies that file names
should be printed. The prior blockget command must have also
specified the -n option.</p>

<p style="margin-top: 1em">bmap [-a] [-d] [block [len]]
<br>
Show the block map for the current inode. The map display
can be restricted to an area of the file with the block and
len arguments. If block is given and len is omitted <br>
then 1 is assumed for len.</p>

<p style="margin-top: 1em">The -a and -d options are used
to select the attribute or data area of the inode, if
neither option is given then both areas are shown.</p>

<p style="margin-top: 1em">check See the blockget
command.</p>

<p style="margin-top: 1em">convert type number [type
number] ... type <br>
Convert from one address form to another. The known types,
with alternate names, are: <br>
agblock or agbno (filesystem block within an allocation
group) <br>
agino or aginode (inode number within an allocation group)
<br>
agnumber or agno (allocation group number) <br>
bboff or daddroff (byte offset in a daddr) <br>
blkoff or fsboff or agboff (byte offset in a agblock or
fsblock) <br>
byte or fsbyte (byte address in filesystem) <br>
daddr or bb (disk address, 512-byte blocks) <br>
fsblock or fsb or fsbno (filesystem block, see the fsblock
command) <br>
ino or inode (inode number) <br>
inoidx or offset (index of inode in filesystem block) <br>
inooff or inodeoff (byte offset in inode)</p>

<p style="margin-top: 1em">Only conversions that &quot;make
sense&quot; are allowed. The compound form (with more than
three arguments) is useful for conversions such as convert
agno ag agbno agb fsblock.</p>

<p style="margin-top: 1em">daddr [d] <br>
Set current address to the daddr (512 byte block) given by
d. If no value for d is given, the current address is
printed, expressed as a daddr. The type is set to data <br>
(uninterpreted).</p>

<p style="margin-top: 1em">dblock filoff <br>
Set current address to the offset filoff (a filesystem block
number) in the data area of the current inode.</p>

<p style="margin-top: 1em">debug [flagbits] <br>
Set debug option bits. These are used for debugging xfs_db.
If no value is given for flagbits, print the current debug
option bits. These are for the use of the implemen&acirc;
<br>
tor.</p>

<p style="margin-top: 1em">dquot [-g|-p|-u] id <br>
Set current address to a group, project or user quota block
for the given ID. Defaults to user quota.</p>

<p style="margin-top: 1em">echo [arg] ... <br>
Echo the arguments to the output.</p>

<p style="margin-top: 1em">f See the forward command.</p>

<p style="margin-top: 1em">forward <br>
Move forward to the next entry in the position ring.</p>

<p style="margin-top: 1em">frag [-adflqRrv] <br>
Get file fragmentation data. This prints information about
fragmentation of file data in the filesystem (as opposed to
fragmentation of freespace, for which see the freesp <br>
command). Every file in the filesystem is examined to see
how far from ideal its extent mappings are. A summary is
printed giving the totals.</p>

<p style="margin-top: 1em">-v sets verbosity, every inode
has information printed for it. The remaining options select
which inodes and extents are examined. If no options are
given then all <br>
are assumed set, otherwise just those given are enabled.</p>

<p style="margin-top: 1em">-a enables processing of
attribute data.</p>

<p style="margin-top: 1em">-d enables processing of
directory data.</p>

<p style="margin-top: 1em">-f enables processing of regular
file data.</p>

<p style="margin-top: 1em">-l enables processing of
symbolic link data.</p>

<p style="margin-top: 1em">-q enables processing of quota
file data.</p>

<p style="margin-top: 1em">-R enables processing of
realtime control file data.</p>

<p style="margin-top: 1em">-r enables processing of
realtime file data.</p>

<p style="margin-top: 1em">freesp [-bcds] [-a ag] ... [-e
i] [-h h1] ... [-m m] <br>
Summarize free space for the filesystem. The free blocks are
examined and totalled, and displayed in the form of a
histogram, with a count of extents in each range of free
<br>
extent sizes.</p>

<p style="margin-top: 1em">-a adds ag to the list of
allocation groups to be processed. If no -a options are
given then all allocation groups are processed.</p>

<p style="margin-top: 1em">-b specifies that the histogram
buckets are binary-sized, with the starting sizes being the
powers of 2.</p>

<p style="margin-top: 1em">-c specifies that freesp will
search the by-size (cnt) space Btree instead of the default
by-block (bno) space Btree.</p>

<p style="margin-top: 1em">-d specifies that every free
extent will be displayed.</p>

<p style="margin-top: 1em">-e specifies that the histogram
buckets are equal-sized, with the size specified as i.</p>

<p style="margin-top: 1em">-h specifies a starting block
number for a histogram bucket as h1. Multiple -h&rsquo;s are
given to specify the complete set of buckets.</p>

<p style="margin-top: 1em">-m specifies that the histogram
starting block numbers are powers of m. This is the general
case of -b.</p>

<p style="margin-top: 1em">-s specifies that a final
summary of total free extents, free blocks, and the average
free extent size is printed.</p>

<p style="margin-top: 1em">fsb See the fsblock command.</p>

<p style="margin-top: 1em">fsblock [fsb] <br>
Set current address to the fsblock value given by fsb. If no
value for fsb is given the current address is printed,
expressed as an fsb. The type is set to data (unin&acirc;
<br>
terpreted). XFS filesystem block numbers are computed ((agno
&lt;&lt; agshift) | agblock) where agshift depends on the
size of an allocation group. Use the convert command to <br>
convert to and from this form. Block numbers given for file
blocks (for instance from the bmap command) are in this
form.</p>

<p style="margin-top: 1em">hash string <br>
Prints the hash value of string using the hash function of
the XFS directory and attribute implementation.</p>

<p style="margin-top: 1em">help [command] <br>
Print help for one or all commands.</p>

<p style="margin-top: 1em">inode [inode#] <br>
Set the current inode number. If no inode# is given, print
the current inode number.</p>

<p style="margin-top: 1em">label [label] <br>
Set the filesystem label. The filesystem label can be used
by mount(8) instead of using a device special file. The
maximum length of an XFS label is 12 characters - use <br>
of a longer label will result in truncation and a warning
will be issued. If no label is given, the current filesystem
label is printed.</p>

<p style="margin-top: 1em">log [stop | start filename] <br>
Start logging output to filename, stop logging, or print the
current logging status.</p>

<p style="margin-top: 1em">metadump [-egow] filename <br>
Dumps metadata to a file. See xfs_metadump(8) for more
information.</p>

<p style="margin-top: 1em">ncheck [-s] [-i ino] ... <br>
Print name-inode pairs. A blockget -n command must be run
first to gather the information.</p>

<p style="margin-top: 1em">-i specifies an inode number to
be printed. If no -i options are given then all inodes are
printed.</p>

<p style="margin-top: 1em">-s specifies that only setuid
and setgid files are printed.</p>

<p style="margin-top: 1em">p See the print command.</p>

<p style="margin-top: 1em">pop Pop location from the
stack.</p>

<p style="margin-top: 1em">print [field-expression] ...
<br>
Print field values. If no argument is given, print all
fields in the current structure.</p>

<p style="margin-top: 1em">push [command] <br>
Push location to the stack. If command is supplied, set the
current location to the results of command after pushing the
old location.</p>

<p style="margin-top: 1em">q See the quit command.</p>

<p style="margin-top: 1em">quit Exit xfs_db.</p>

<p style="margin-top: 1em">ring [index] <br>
Show position ring (if no index argument is given), or move
to a specific entry in the position ring given by index.</p>

<p style="margin-top: 1em">sb [agno] <br>
Set current address to SB header in allocation group agno.
If no agno is given, use the current allocation group
number.</p>

<p style="margin-top: 1em">source source-file <br>
Process commands from source-file. source commands can be
nested.</p>

<p style="margin-top: 1em">stack View the location
stack.</p>

<p style="margin-top: 1em">type [type] <br>
Set the current data type to type. If no argument is given,
show the current data type. The possible data types are:
agf, agfl, agi, attr, bmapbta, bmapbtd, bnobt, <br>
cntbt, data, dir, dir2, dqblk, inobt, inode, log, rtbitmap,
rtsummary, sb, symlink and text. See the TYPES section below
for more information on these data types.</p>

<p style="margin-top: 1em">uuid [uuid | generate | rewrite
| restore] <br>
Set the filesystem universally unique identifier (UUID). The
filesystem UUID can be used by mount(8) instead of using a
device special file. The uuid can be set directly <br>
to the desired UUID, or it can be automatically generated
using the generate option. These options will both write the
UUID into every copy of the superblock in the <br>
filesystem. On a CRC-enabled filesystem, this will set an
incompatible superblock flag, and the filesystem will not be
mountable with older kernels. This can be reverted <br>
with the restore option, which will copy the original UUID
back into place and clear the incompatible flag as needed.
rewrite copies the current UUID from the primary <br>
superblock to all secondary copies of the superblock. If no
argument is given, the current filesystem UUID is
printed.</p>

<p style="margin-top: 1em">version [feature | versionnum
features2] <br>
Enable selected features for a filesystem (certain features
can be enabled on an unmounted filesystem, after mkfs.xfs(8)
has created the filesystem). Support for unwrit&acirc; <br>
ten extents can be enabled using the extflg option. Support
for version 2 log format can be enabled using the log2
option. Support for extended attributes can be enabled <br>
using the attr1 or attr2 option. Once enabled, extended
attributes cannot be disabled, but the user may toggle
between attr1 and attr2 at will (older kernels may not
sup&acirc; <br>
port the newer version).</p>

<p style="margin-top: 1em">If no argument is given, the
current version and feature bits are printed. With one
argument, this command will write the updated version number
into every copy of the <br>
superblock in the filesystem. If two arguments are given,
they will be used as numeric values for the versionnum and
features2 bits respectively, and their string equiva&acirc;
<br>
lent reported (but no modifications are made).</p>

<p style="margin-top: 1em">write [-c] [field value] ...
<br>
Write a value to disk. Specific fields can be set in
structures (struct mode), or a block can be set to data
values (data mode), or a block can be set to string values
<br>
(string mode, for symlink blocks). The operation happens
immediately: there is no buffering.</p>

<p style="margin-top: 1em">Struct mode is in effect when
the current type is structural, i.e. not data. For struct
mode, the syntax is &quot;write field value&quot;.</p>

<p style="margin-top: 1em">Data mode is in effect when the
current type is data. In this case the contents of the block
can be shifted or rotated left or right, or filled with a
sequence, a constant <br>
value, or a random value. In this mode write with no
arguments gives more information on the allowed
commands.</p>

<p style="margin-top: 1em">-c Skip write verifiers and CRC
recalculation; allows invalid data to be written to
disk.</p>

<p style="margin-top: 1em">TYPES <br>
This section gives the fields in each structure type and
their meanings. Note that some types of block cover multiple
actual structures, for instance directory blocks.</p>

<p style="margin-top: 1em">agf The AGF block is the header
for block allocation information; it is in the second
512-byte block of each allocation group. The following
fields are defined: <br>
magicnum AGF block magic number, 0x58414746
(&rsquo;XAGF&rsquo;). <br>
versionnum version number, currently 1. <br>
seqno sequence number starting from 0. <br>
length size in filesystem blocks of the allocation group.
All allocation groups except the last one of the filesystem
have the superblock&rsquo;s agblocks value <br>
here. <br>
bnoroot block number of the root of the Btree holding free
space information sorted by block number. <br>
cntroot block number of the root of the Btree holding free
space information sorted by block count. <br>
bnolevel number of levels in the by-block-number Btree. <br>
cntlevel number of levels in the by-block-count Btree. <br>
flfirst index into the AGFL block of the first active entry.
<br>
fllast index into the AGFL block of the last active entry.
<br>
flcount count of active entries in the AGFL block. <br>
freeblks count of blocks represented in the freespace
Btrees. <br>
longest longest free space represented in the freespace
Btrees. <br>
btreeblks number of blocks held in the AGF Btrees.</p>

<p style="margin-top: 1em">agfl The AGFL block contains
block numbers for use of the block allocator; it is in the
fourth 512-byte block of each allocation group. Each entry
in the active list is a <br>
block number within the allocation group that can be used
for any purpose if space runs low. The AGF block fields
flfirst, fllast, and flcount designate which entries <br>
are currently active. Entry space is allocated in a circular
manner within the AGFL block. Fields defined: <br>
bno array of all block numbers. Even those which are not
active are printed.</p>

<p style="margin-top: 1em">agi The AGI block is the header
for inode allocation information; it is in the third
512-byte block of each allocation group. Fields defined:
<br>
magicnum AGI block magic number, 0x58414749
(&rsquo;XAGI&rsquo;). <br>
versionnum version number, currently 1. <br>
seqno sequence number starting from 0. <br>
length size in filesystem blocks of the allocation group.
<br>
count count of inodes allocated. <br>
root block number of the root of the Btree holding inode
allocation information. <br>
level number of levels in the inode allocation Btree. <br>
freecount count of allocated inodes that are not in use.
<br>
newino last inode number allocated. <br>
dirino unused. <br>
unlinked an array of inode numbers within the allocation
group. The entries in the AGI block are the heads of lists
which run through the inode next_unlinked <br>
field. These inodes are to be unlinked the next time the
filesystem is mounted.</p>

<p style="margin-top: 1em">attr An attribute fork is
organized as a Btree with the actual data embedded in the
leaf blocks. The root of the Btree is found in block 0 of
the fork. The index (sort <br>
order) of the Btree is the hash value of the attribute name.
All the blocks contain a blkinfo structure at the beginning,
see type dir for a description. Nonleaf <br>
blocks are identical in format to those for version 1 and
version 2 directories, see type dir for a description. Leaf
blocks can refer to &quot;local&quot; or &quot;remote&quot;
attribute <br>
values. Local values are stored directly in the leaf block.
Remote values are stored in an independent block in the
attribute fork (with no structure). Leaf blocks <br>
contain the following fields: <br>
hdr header containing a blkinfo structure info (magic number
0xfbee), a count of active entries, usedbytes total bytes of
names and values, the firstused <br>
byte in the name area, holes set if the block needs
compaction, and array freemap as for dir leaf blocks. <br>
entries array of structures containing a hashval, nameidx
(index into the block of the name), and flags incomplete,
root, and local. <br>
nvlist array of structures describing the attribute names
and values. Fields always present: valuelen (length of value
in bytes), namelen, and name. Fields <br>
present for local values: value (value string). Fields
present for remote values: valueblk (fork block number of
containing the value).</p>

<p style="margin-top: 1em">bmapbt Files with many extents
in their data or attribute fork will have the extents
described by the contents of a Btree for that fork, instead
of being stored directly in <br>
the inode. Each bmap Btree starts with a root block
contained within the inode. The other levels of the Btree
are stored in filesystem blocks. The blocks are linked <br>
to sibling left and right blocks at each level, as well as
by pointers from parent to child blocks. Each block contains
the following fields: <br>
magic bmap Btree block magic number, 0x424d4150
(&rsquo;BMAP&rsquo;). <br>
level level of this block above the leaf level. <br>
numrecs number of records or keys in the block. <br>
leftsib left (logically lower) sibling block, 0 if none.
<br>
rightsib right (logically higher) sibling block, 0 if none.
<br>
recs [leaf blocks only] array of extent records. Each record
contains startoff, startblock, blockcount, and extentflag (1
if the extent is unwritten). <br>
keys [non-leaf blocks only] array of key records. These are
the first key value of each block in the level below this
one. Each record contains startoff. <br>
ptrs [non-leaf blocks only] array of child block pointers.
Each pointer is a filesystem block number to the next level
in the Btree.</p>

<p style="margin-top: 1em">bnobt There is one set of
filesystem blocks forming the by-block-number allocation
Btree for each allocation group. The root block of this
Btree is designated by the bnoroot <br>
field in the corresponding AGF block. The blocks are linked
to sibling left and right blocks at each level, as well as
by pointers from parent to child blocks. Each <br>
block has the following fields: <br>
magic BNOBT block magic number, 0x41425442
(&rsquo;ABTB&rsquo;). <br>
level level number of this block, 0 is a leaf. <br>
numrecs number of data entries in the block. <br>
leftsib left (logically lower) sibling block, 0 if none.
<br>
rightsib right (logically higher) sibling block, 0 if none.
<br>
recs [leaf blocks only] array of freespace records. Each
record contains startblock and blockcount. <br>
keys [non-leaf blocks only] array of key records. These are
the first value of each block in the level below this one.
Each record contains startblock and <br>
blockcount. <br>
ptrs [non-leaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group
to the next level in the Btree.</p>

<p style="margin-top: 1em">cntbt There is one set of
filesystem blocks forming the by-block-count allocation
Btree for each allocation group. The root block of this
Btree is designated by the cntroot <br>
field in the corresponding AGF block. The blocks are linked
to sibling left and right blocks at each level, as well as
by pointers from parent to child blocks. Each <br>
block has the following fields: <br>
magic CNTBT block magic number, 0x41425443
(&rsquo;ABTC&rsquo;). <br>
level level number of this block, 0 is a leaf. <br>
numrecs number of data entries in the block. <br>
leftsib left (logically lower) sibling block, 0 if none.
<br>
rightsib right (logically higher) sibling block, 0 if none.
<br>
recs [leaf blocks only] array of freespace records. Each
record contains startblock and blockcount. <br>
keys [non-leaf blocks only] array of key records. These are
the first value of each block in the level below this one.
Each record contains blockcount and <br>
startblock. <br>
ptrs [non-leaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group
to the next level in the Btree.</p>

<p style="margin-top: 1em">data User file blocks, and other
blocks whose type is unknown, have this type for display
purposes in xfs_db. The block data is displayed in
hexadecimal format.</p>

<p style="margin-top: 1em">dir A version 1 directory is
organized as a Btree with the directory data embedded in the
leaf blocks. The root of the Btree is found in block 0 of
the file. The index <br>
(sort order) of the Btree is the hash value of the entry
name. All the blocks contain a blkinfo structure at the
beginning with the following fields: <br>
forw next sibling block. <br>
back previous sibling block. <br>
magic magic number for this block type. <br>
The non-leaf (node) blocks have the following fields: <br>
hdr header containing a blkinfo structure info (magic number
0xfebe), the count of active entries, and the level of this
block above the leaves. <br>
btree array of entries containing hashval and before fields.
The before value is a block number within the directory file
to the child block, the hashval is <br>
the last hash value in that block. <br>
The leaf blocks have the following fields: <br>
hdr header containing a blkinfo structure info (magic number
0xfeeb), the count of active entries, namebytes (total name
string bytes), holes flag (block <br>
needs compaction), and freemap (array of base, size entries
for free regions). <br>
entries array of structures containing hashval, nameidx
(byte index into the block of the name string), and namelen.
<br>
namelist array of structures containing inumber and
name.</p>

<p style="margin-top: 1em">dir2 A version 2 directory has
four kinds of blocks. Data blocks start at offset 0 in the
file. There are two kinds of data blocks: single-block
directories have the leaf <br>
information embedded at the end of the block, data blocks in
multi-block directories do not. Node and leaf blocks start
at offset 32GiB (with either a single leaf <br>
block or the root node block). Freespace blocks start at
offset 64GiB. The node and leaf blocks form a Btree, with
references to the data in the data blocks. The <br>
freespace blocks form an index of longest free spaces within
the data blocks.</p>

<p style="margin-top: 1em">A single-block directory block
contains the following fields: <br>
bhdr header containing magic number 0x58443242
(&rsquo;XD2B&rsquo;) and an array bestfree of the longest 3
free spaces in the block (offset, length). <br>
bu array of union structures. Each element is either an
entry or a freespace. For entries, there are the following
fields: inumber, namelen, name, and <br>
tag. For freespace, there are the following fields: freetag
(0xffff), length, and tag. The tag value is the byte offset
in the block of the start of <br>
the entry it is contained in. <br>
bleaf array of leaf entries containing hashval and address.
The address is a 64-bit word offset into the file. <br>
btail tail structure containing the total count of leaf
entries and stale count of unused leaf entries. <br>
A data block contains the following fields: <br>
dhdr header containing magic number 0x58443244
(&rsquo;XD2D&rsquo;) and an array bestfree of the longest 3
free spaces in the block (offset, length). <br>
du array of union structures as for bu. <br>
Leaf blocks have two possible forms. If the Btree consists
of a single leaf then the freespace information is in the
leaf block, otherwise it is in separate blocks and <br>
the root of the Btree is a node block. A leaf block contains
the following fields: <br>
lhdr header containing a blkinfo structure info (magic
number 0xd2f1 for the single leaf case, 0xd2ff for the true
Btree case), the total count of leaf <br>
entries, and stale count of unused leaf entries. <br>
lents leaf entries, as for bleaf. <br>
lbests [single leaf only] array of values which represent
the longest freespace in each data block in the directory.
<br>
ltail [single leaf only] tail structure containing bestcount
count of lbests. <br>
A node block is identical to that for types attr and
dir.</p>

<p style="margin-top: 1em">A freespace block contains the
following fields: <br>
fhdr header containing magic number 0x58443246
(&rsquo;XD2F&rsquo;), firstdb first data block number
covered by this freespace block, nvalid number of valid
entries, and <br>
nused number of entries representing real data blocks. <br>
fbests array of values as for lbests.</p>

<p style="margin-top: 1em">dqblk The quota information is
stored in files referred to by the superblock uquotino and
pquotino fields. Each filesystem block in a quota file
contains a constant number of <br>
quota entries. The quota entry size is currently 136 bytes,
so with a 4KiB filesystem block size there are 30 quota
entries per block. The dquot command is used to <br>
locate these entries in the filesystem. The file entries are
indexed by the user or project identifier to determine the
block and offset. Each quota entry has the <br>
following fields: <br>
magic magic number, 0x4451 (&rsquo;DQ&rsquo;). <br>
version version number, currently 1. <br>
flags flags, values include 0x01 for user quota, 0x02 for
project quota. <br>
id user or project identifier. <br>
blk_hardlimit absolute limit on blocks in use. <br>
blk_softlimit preferred limit on blocks in use. <br>
ino_hardlimit absolute limit on inodes in use. <br>
ino_softlimit preferred limit on inodes in use. <br>
bcount blocks actually in use. <br>
icount inodes actually in use. <br>
itimer time when service will be refused if soft limit is
violated for inodes. <br>
btimer time when service will be refused if soft limit is
violated for blocks. <br>
iwarns number of warnings issued about inode limit
violations. <br>
bwarns number of warnings issued about block limit
violations. <br>
rtb_hardlimit absolute limit on realtime blocks in use. <br>
rtb_softlimit preferred limit on realtime blocks in use.
<br>
rtbcount realtime blocks actually in use. <br>
rtbtimer time when service will be refused if soft limit is
violated for realtime blocks. <br>
rtbwarns number of warnings issued about realtime block
limit violations.</p>

<p style="margin-top: 1em">inobt There is one set of
filesystem blocks forming the inode allocation Btree for
each allocation group. The root block of this Btree is
designated by the root field in the <br>
corresponding AGI block. The blocks are linked to sibling
left and right blocks at each level, as well as by pointers
from parent to child blocks. Each block has the <br>
following fields: <br>
magic INOBT block magic number, 0x49414254
(&rsquo;IABT&rsquo;). <br>
level level number of this block, 0 is a leaf. <br>
numrecs number of data entries in the block. <br>
leftsib left (logically lower) sibling block, 0 if none.
<br>
rightsib right (logically higher) sibling block, 0 if none.
<br>
recs [leaf blocks only] array of inode records. Each record
contains startino allocation-group relative inode number,
freecount count of free inodes in this <br>
chunk, and free bitmap, LSB corresponds to inode 0. <br>
keys [non-leaf blocks only] array of key records. These are
the first value of each block in the level below this one.
Each record contains startino. <br>
ptrs [non-leaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group
to the next level in the Btree.</p>

<p style="margin-top: 1em">inode Inodes are allocated in
&quot;chunks&quot; of 64 inodes each. Usually a chunk is
multiple filesystem blocks, although there are cases with
large filesystem blocks where a chunk <br>
is less than one block. The inode Btree (see inobt above)
refers to the inode numbers per allocation group. The inode
numbers directly reflect the location of the inode <br>
block on disk. Use the inode command to point xfs_db to a
specific inode. Each inode contains four regions: core,
next_unlinked, u, and a. core contains the fixed <br>
information. next_unlinked is separated from the core due to
journaling considerations, see type agi field unlinked. u is
a union structure that is different in size <br>
and format depending on the type and representation of the
file data (&quot;data fork&quot;). a is an optional union
structure to describe attribute data, that is different in
<br>
size, format, and location depending on the presence and
representation of attribute data, and the size of the u data
(&quot;attribute fork&quot;). xfs_db automatically selects
<br>
the proper union members based on information in the
inode.</p>

<p style="margin-top: 1em">The following are fields in the
inode core: <br>
magic inode magic number, 0x494e (&rsquo;IN&rsquo;). <br>
mode mode and type of file, as described in chmod(2),
mknod(2), and stat(2). <br>
version inode version, 1 or 2. <br>
format format of u union data (0: xfs_dev_t, 1: local file -
in-inode directory or symlink, 2: extent list, 3: Btree
root, 4: unique id [unused]). <br>
nlinkv1 number of links to the file in a version 1 inode.
<br>
nlinkv2 number of links to the file in a version 2 inode.
<br>
projid_lo owner&rsquo;s project id (low word; version 2
inode only). projid_hi owner&rsquo;s project id (high word;
version 2 inode only). <br>
uid owner&rsquo;s user id. <br>
gid owner&rsquo;s group id. <br>
atime time last accessed (seconds and nanoseconds). <br>
mtime time last modified. <br>
ctime time created or inode last modified. <br>
size number of bytes in the file. <br>
nblocks total number of blocks in the file including
indirect and attribute. <br>
extsize basic/minimum extent size for the file. <br>
nextents number of extents in the data fork. <br>
naextents number of extents in the attribute fork. <br>
forkoff attribute fork offset in the inode, in 64-bit words
from the start of u. <br>
aformat format of a data (1: local attribute data, 2: extent
list, 3: Btree root). <br>
dmevmask DMAPI event mask. <br>
dmstate DMAPI state information. <br>
newrtbm file is the realtime bitmap and is &quot;new&quot;
format. <br>
prealloc file has preallocated data space after EOF. <br>
realtime file data is in the realtime subvolume. <br>
gen inode generation number. <br>
The following fields are in the u data fork union: <br>
bmbt bmap Btree root. This looks like a bmapbtd block with
redundant information removed. <br>
bmx array of extent descriptors. <br>
dev dev_t for the block or character device. <br>
sfdir shortform (in-inode) version 1 directory. This
consists of a hdr containing the parent inode number and a
count of active entries in the directory, fol&acirc; <br>
lowed by an array list of hdr.count entries. Each such entry
contains inumber, namelen, and name string. <br>
sfdir2 shortform (in-inode) version 2 directory. This
consists of a hdr containing a count of active entries in
the directory, an i8count of entries with inum&acirc; <br>
bers that don&rsquo;t fit in a 32-bit value, and the parent
inode number, followed by an array list of hdr.count
entries. Each such entry contains namelen, a <br>
saved offset used when the directory is converted to a
larger form, a name string, and the inumber. <br>
symlink symbolic link string value. <br>
The following fields are in the a attribute fork union if it
exists: <br>
bmbt bmap Btree root, as above. <br>
bmx array of extent descriptors. <br>
sfattr shortform (in-inode) attribute values. This consists
of a hdr containing a totsize (total size in bytes) and a
count of active entries, followed by an <br>
array list of hdr.count entries. Each such entry contains
namelen, valuelen, root flag, name, and value.</p>

<p style="margin-top: 1em">log Log blocks contain the
journal entries for XFS. It&rsquo;s not useful to examine
these with xfs_db, use xfs_logprint(8) instead.</p>

<p style="margin-top: 1em">rtbitmap If the filesystem has a
realtime subvolume, then the rbmino field in the superblock
refers to a file that contains the realtime bitmap. Each bit
in the bitmap file <br>
controls the allocation of a single realtime extent (set ==
free). The bitmap is processed in 32-bit words, the LSB of a
word is used for the first extent controlled by <br>
that bitmap word. The atime field of the realtime bitmap
inode contains a counter that is used to control where the
next new realtime file will start.</p>

<p style="margin-top: 1em">rtsummary If the filesystem has
a realtime subvolume, then the rsumino field in the
superblock refers to a file that contains the realtime
summary data. The summary file contains <br>
a two-dimensional array of 16-bit values. Each value counts
the number of free extent runs (consecutive free realtime
extents) of a given range of sizes that starts in <br>
a given bitmap block. The size ranges are binary buckets
(low size in the bucket is a power of 2). There are as many
size ranges as are necessary given the size of <br>
the realtime subvolume. The first dimension is the size
range, the second dimension is the starting bitmap block
number (adjacent entries are for the same size, adja&acirc;
<br>
cent bitmap blocks).</p>

<p style="margin-top: 1em">sb There is one sb (superblock)
structure per allocation group. It is the first disk block
in the allocation group. Only the first one (block 0 of the
filesystem) is <br>
actually used; the other blocks are redundant information
for xfs_repair(8) to use if the first superblock is damaged.
Fields defined: <br>
magicnum superblock magic number, 0x58465342
(&rsquo;XFSB&rsquo;). <br>
blocksize filesystem block size in bytes. <br>
dblocks number of filesystem blocks present in the data
subvolume. <br>
rblocks number of filesystem blocks present in the realtime
subvolume. <br>
rextents number of realtime extents that rblocks contain.
<br>
uuid unique identifier of the filesystem. <br>
logstart starting filesystem block number of the log
(journal). If this value is 0 the log is
&quot;external&quot;. <br>
rootino root inode number. <br>
rbmino realtime bitmap inode number. <br>
rsumino realtime summary data inode number. <br>
rextsize realtime extent size in filesystem blocks. <br>
agblocks size of an allocation group in filesystem blocks.
<br>
agcount number of allocation groups. <br>
rbmblocks number of realtime bitmap blocks. <br>
logblocks number of log blocks (filesystem blocks). <br>
versionnum filesystem version information. This value is
currently 1, 2, 3, or 4 in the low 4 bits. If the low bits
are 4 then the other bits have additional <br>
meanings. 1 is the original value. 2 means that attributes
were used. 3 means that version 2 inodes (large link counts)
were used. 4 is the bitmask <br>
version of the version number. In this case, the other bits
are used as flags (0x0010: attributes were used, 0x0020:
version 2 inodes were used, <br>
0x0040: quotas were used, 0x0080: inode cluster alignment is
in force, 0x0100: data stripe alignment is in force, 0x0200:
the shared_vn field is used, <br>
0x1000: unwritten extent tracking is on, 0x2000: version 2
directories are in use). <br>
sectsize sector size in bytes, currently always 512. This is
the size of the superblock and the other header blocks. <br>
inodesize inode size in bytes. <br>
inopblock number of inodes per filesystem block. <br>
fname obsolete, filesystem name. <br>
fpack obsolete, filesystem pack name. <br>
blocklog log2 of blocksize. <br>
sectlog log2 of sectsize. <br>
inodelog log2 of inodesize. <br>
inopblog log2 of inopblock. <br>
agblklog log2 of agblocks (rounded up). <br>
rextslog log2 of rextents. <br>
inprogress mkfs.xfs(8) or xfs_copy(8) aborted before
completing this filesystem. <br>
imax_pct maximum percentage of filesystem space used for
inode blocks. <br>
icount number of allocated inodes. <br>
ifree number of allocated inodes that are not in use. <br>
fdblocks number of free data blocks. <br>
frextents number of free realtime extents. <br>
uquotino user quota inode number. <br>
pquotino project quota inode number; this is currently
unused. <br>
qflags quota status flags (0x01: user quota accounting is
on, 0x02: user quota limits are enforced, 0x04: quotacheck
has been run on user quotas, 0x08: project <br>
quota accounting is on, 0x10: project quota limits are
enforced, 0x20: quotacheck has been run on project quotas).
<br>
flags random flags. 0x01: only read-only mounts are allowed.
<br>
shared_vn shared version number (shared readonly
filesystems). <br>
inoalignmt inode chunk alignment in filesystem blocks. <br>
unit stripe or RAID unit. <br>
width stripe or RAID width. <br>
dirblklog log2 of directory block size (filesystem
blocks).</p>

<p style="margin-top: 1em">symlink Symbolic link blocks are
used only when the symbolic link value does not fit inside
the inode. The block content is just the string value. Bytes
past the logical end <br>
of the symbolic link value have arbitrary values.</p>

<p style="margin-top: 1em">text User file blocks, and other
blocks whose type is unknown, have this type for display
purposes in xfs_db. The block data is displayed in two
columns: Hexadecimal format <br>
and printable ASCII chars.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
Many messages can come from the check (blockget) command. If
the filesystem is completely corrupt, a core dump might be
produced instead of the message <br>
device is not a valid filesystem</p>

<p style="margin-top: 1em">If the filesystem is very large
(has many files) then check might run out of memory. In this
case the message <br>
out of memory <br>
is printed.</p>

<p style="margin-top: 1em">The following is a description
of the most likely problems and the associated messages.
Most of the diagnostics produced are only meaningful with an
understanding of the struc&acirc; <br>
ture of the filesystem.</p>

<p style="margin-top: 1em">agf_freeblks n, counted m in ag
a <br>
The freeblocks count in the allocation group header for
allocation group a doesn&rsquo;t match the number of blocks
counted free.</p>

<p style="margin-top: 1em">agf_longest n, counted m in ag a
<br>
The longest free extent in the allocation group header for
allocation group a doesn&rsquo;t match the longest free
extent found in the allocation group.</p>

<p style="margin-top: 1em">agi_count n, counted m in ag a
<br>
The allocated inode count in the allocation group header for
allocation group a doesn&rsquo;t match the number of inodes
counted in the allocation group.</p>

<p style="margin-top: 1em">agi_freecount n, counted m in ag
a <br>
The free inode count in the allocation group header for
allocation group a doesn&rsquo;t match the number of inodes
counted free in the allocation group.</p>

<p style="margin-top: 1em">block a/b expected inum 0 got i
<br>
The block number is specified as a pair (allocation group
number, block in the allocation group). The block is used
multiple times (shared), between multiple inodes. <br>
This message usually follows a message of the next type.</p>

<p style="margin-top: 1em">block a/b expected type unknown
got y <br>
The block is used multiple times (shared).</p>

<p style="margin-top: 1em">block a/b type unknown not
expected</p>

<p style="margin-top: 1em">SEE ALSO <br>
mkfs.xfs(8), xfs_admin(8), xfs_copy(8), xfs_logprint(8),
xfs_metadump(8), xfs_ncheck(8), xfs_repair(8), mount(8),
chmod(2), mknod(2), stat(2), xfs(5).</p>
 
<p style="margin-top: 1em">xfs_db(8)</p>
<hr>
</body>
</html>
