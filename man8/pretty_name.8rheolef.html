<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:14:50 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>pretty_name(8rheolef) rheolef-6.7
pretty_name(8rheolef)</p>

<p style="margin-top: 1em">NAME <br>
typename_macro, pretty_typename_macro - type demangler and
pretty printer</p>

<p style="margin-top: 1em">DESCRIPTION <br>
These preprocessor macro-definitions are usefull when
dealing with complex types as generated by imbricted
template technics: they print in clear a complex type at
run-time. <br>
typeid_name_macro obtains a human readable type in a
std::tring form by calling the system typeid function and
then a demangler. When this type is very long,
pretty_name_macro <br>
prints also it in a multi-line form with a pretty
indentation.</p>

<p style="margin-top: 1em">EXAMPLES <br>
typedef map &lt;size_t, double, less&lt;size_t&gt;,
heap_allocator&lt;pair&lt;size_t,double&gt; &gt; &gt;
map_type; <br>
cout &lt;&lt; typeid_name_macro (map_type);</p>

<p style="margin-top: 1em">IMPLEMENTATION <br>
extern std::string typeid_name (const char* name, bool
do_indent); <br>
} // namespace rheolef</p>

<p style="margin-top: 1em">/// @brief get string from a
type, with an optional pretty-printing for complex types
<br>
#define typename_macro(T)
rheolef::typeid_name(typeid(T).name(), false) <br>
#define pretty_typename_macro(T)
rheolef::typeid_name(typeid(T).name(), true)</p>

<p style="margin-top: 1em">/// @brief get string type from
a variable or expression <br>
template &lt;class T&gt; std::string typename_of (T x) {
return typename_macro(T); } <br>
template &lt;class T&gt; std::string pretty_typename_of (T
x) { return pretty_typename_macro(T); }</p>

<p style="margin-top: 1em">rheolef-6.7 rheolef-6.7
pretty_name(8rheolef)</p>
<hr>
</body>
</html>
