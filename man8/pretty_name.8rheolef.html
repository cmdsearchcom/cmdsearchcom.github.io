<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>pretty_name(8rheolef)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">pretty_name(8rheolef)</td>
    <td class="head-vol">rheolef-6.7</td>
    <td class="head-rtitle">pretty_name(8rheolef)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<b>typename_macro</b>, <b>pretty_typename_macro</b> - type demangler and pretty
  printer
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
These preprocessor macro-definitions are usefull when dealing with complex types
  as generated by imbricted template technics: they print in clear a complex
  type at run-time. <b>typeid_name_macro</b> obtains a human readable type in a
  <b>std::tring</b> form by calling the system <b>typeid</b> function and then a
  demangler. When this type is very long, <b>pretty_name_macro</b> prints also
  it in a multi-line form with a pretty indentation.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>
  typedef map &lt;size_t, double, less&lt;size_t&gt;, heap_allocator&lt;pair&lt;size_t,double&gt; &gt; &gt;  map_type;
  cout &lt;&lt; typeid_name_macro (map_type);
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="IMPLEMENTATION"><a class="selflink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<pre>
extern std::string typeid_name (const char* name, bool do_indent);
} // namespace rheolef
<div class="Pp"></div>
/// @brief get string from a type, with an optional pretty-printing for complex types
#define        typename_macro(T) rheolef::typeid_name(typeid(T).name(), false)
#define pretty_typename_macro(T) rheolef::typeid_name(typeid(T).name(), true)
<div class="Pp"></div>
/// @brief get string type from a variable or expression
template &lt;class T&gt; std::string        typename_of (T x) { return        typename_macro(T); }
template &lt;class T&gt; std::string pretty_typename_of (T x) { return pretty_typename_macro(T); }
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">rheolef-6.7</td>
    <td class="foot-os">rheolef-6.7</td>
  </tr>
</table>
</body>
</html>
