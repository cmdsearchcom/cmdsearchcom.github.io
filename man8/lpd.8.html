<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:13:03 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>LPD(8) lpd daemon LPD(8)</p>

<p style="margin-top: 1em">NAME <br>
lpd - line printer daemon</p>

<p style="margin-top: 1em">SYNOPSIS <br>
lpd [-L logfile] [-F] [-V] [-D debugopt] [-p port]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The lpd program is the printer server program of the LPRng
software suite. This software is an enhanced and modified
version of the Berkeley LPD software.</p>

<p style="margin-top: 1em">OPTIONS <br>
-L logfile <br>
specifies an alternate file to be used for logging error and
debugging messages. The syslog(8) facility is used to log
critical messages as well. Please note that you <br>
need to create the file by yourself, a &rsquo;touch&rsquo;
is sufficient. This is needed for security reasons.</p>

<p style="margin-top: 1em">-F Under normal operation, the
LPD server will run in background mode. The -F flag forces
it to run in foreground mode, where it is more easily
debugged.</p>

<p style="margin-top: 1em">-V Print program version
information.</p>

<p style="margin-top: 1em">-D debugopt <br>
Debugging is controlled using the -D option. This accepts a
comma-separated list of debugging settings. These settings
take one of two forms: facility=value , or value to <br>
set an overall default value. The available facilities can
be determined by invoking LPD with the -D= parameter.</p>

<p style="margin-top: 1em">-p port <br>
Bind to the specified port rather than port 515 specified by
RFC1179.</p>

<p style="margin-top: 1em">OPERATION <br>
Lpd is the line printer daemon (spool queue handler) and is
normally invoked at boot time from the rc(8) file; it can
also be started by a user. Note that the lpd server needs
<br>
only run on systems where actual printing or spooling is
taking place. lpr(1) and other related programs transfer
files using network facilities to the lpd.</p>

<p style="margin-top: 1em">When started, lpd reads a
configuration file to obtain basic operational parameters
and then reads the printcap(5) database information to
determine the which printers have spool <br>
queues and to start spool queue server processes. If running
as a background server, it will disconnect from its control
terminal and run in the background. It uses the system <br>
calls listen(2) and accept(2) to receive requests to print
files in the queue, transfer files to the spooling area,
display the queue, remove jobs from the queue, or perform a
<br>
spool queue control function. In each case it creates one or
more server processes to handle the request and the lpd
process will listen for more requests.</p>

<p style="margin-top: 1em">Sending the server a SIGHUP
signal causes the server to reread the various configuration
and inititialization files. This action is similar to that
of the INETD and other <br>
servers. The same action is taken when sent a reread command
by the lpc(1) program. At an interval specified by the
poll_time configuration variable, lpd will check for spool
<br>
queues with jobs and no printing activity, and start
printing.</p>

<p style="margin-top: 1em">LPD access control is done using
a rule set and match algorithm similar to a packet filter.
Each request for printing, status, or control operations is
matched against the rule <br>
set, and the first ACCEPT or REJECT value determines if the
operation can be performed. The following is a typical
permissions file: <br>
# Set default permissions <br>
DEFAULT ACCEPT <br>
# Reject any connections from outside our subnet <br>
REJECT SERVICE=X NOT IP=130.191.0.0/255.255.0.0 <br>
# Only accept Printing (P) and spooling (LPR) from <br>
# the private network, the 10.0.0.0/8 network and fw <br>
REJECT SERVICE=P,R NOT
REMOTEHOST=*.private,10.0.0.0/8,fw.astart.com <br>
# Do not accept forwarded jobs for printing <br>
REJECT SERVICE=P FORWARD <br>
# Allow only the administrators control access <br>
ACCEPT SERVICE=C,M REMOTEHOST=spooler.astart.com
USER=root,papowell <br>
ACCEPT SERVICE=C,M SERVER REMOTEUSER=root,papowell <br>
# Allow only the user on the same host who spooled job to
remove it <br>
ACCEPT SERVICE=M SAMEUSER SAMEHOST <br>
REJECT SERVICE=M,C</p>

<p style="margin-top: 1em">Permission checking is done by
using a set of keys (or fields) with associated values to
check for permission. The SERVICE key has value P for
printing (i.e.- unspooling), R for <br>
spooling (i.e.- LPR request), C and S for printer control
and status respectively (i.e.- LPC request), M for removal
(i.e.- LPRM request), Q for queue information (i.e.- LPRM
<br>
request), and so forth. The X key indicates the initial
connection to the LPD spooler, and can be used to control
connections from remote systems. The values of the USER,
HOST, <br>
and IP keys taken from the control file which is being
received or checked for permissions. The REMOTEUSER,
REMOTEHOST and REMOTEIP keys are those either sent as part
of a <br>
command, or derived from information about the current
network connection. Each line of the permissions file is
scanned for key names and values, and these are matched
against <br>
the request keys information. When all matches on a line are
made, then search terminates with the specified action
(ACCEPT/REJECT). If no match is found the default permission
<br>
value is used. The DEFAULT key is used to specify the
current default permission to be used for successful matches
or if there is no match after scanning the entire
permissions <br>
database.</p>

<p style="margin-top: 1em">The GROUP entry is used to check
that the USER name appears in a group entry in the system
user group database. For example, GROUP=student*,staff*
would check to see if any of <br>
the group name matching student* or staff* have the
specified user name in them. If a system has the netgroups
capability, a group name starting with a @ will be treated
as a <br>
netgroup name, and current user name from the job file will
be checked to see if it is in the group. Similarly, the
REMOTEGROUP entry will check a remote user name. The PORT
<br>
entry can be used to ensure that a connection to the server
originates from a specified range of ports. For more
details, see the lpd.perm(5) man page.</p>

<p style="margin-top: 1em">The permissions database is
scanned in order of the fixed file entries and then by
invoking the specified filters for each of the permissions
lists. It is recommended that the <br>
filters be placed at the end of the permissions lists. The
user name is one of the parameters passed to the filter, and
can be used to determine if a user has permissions to <br>
print a file.</p>

<p style="margin-top: 1em">Key Match Connect Job Job LPQ
LPRM LPC <br>
Spool Print <br>
SERVICE S &rsquo;X&rsquo; &rsquo;R&rsquo; &rsquo;P&rsquo;
&rsquo;Q&rsquo; &rsquo;M&rsquo; &rsquo;C,S&rsquo; <br>
USER S - JUSR JUSR JUSR JUSR JUSR <br>
HOST S RH JH JH JH JH JH <br>
GROUP S - JUSR JUSR JUSR JUSR JUSR <br>
IP IP RIP JIP JIP RIP JIP JIP <br>
PORT N PORT PORT - PORT PORT PORT <br>
REMOTEUSER S - JUSR JUSR JUSR CUSR CUSR <br>
REMOTEHOST S RH RH JH RH RH RH <br>
REMOTEGROUP S - JUSR JUSR JUSR CUSR CUSR <br>
REMOTEIP IP RIP RIP JIP RIP RIP RIP <br>
CONTROLLINE S - CL CL CL CL CL <br>
PRINTER S - PR PR PR PR PR <br>
FORWARD V - SA - - SA SA SA <br>
SAMEHOST V - SA - SA SA SA <br>
SAMEUSER V - - - SU SU SU <br>
SERVER V - SV - SV SV SV <br>
AUTH V - AU - AU AU AU <br>
AUTHTYPE S - AU - AU AU AU <br>
AUTHUSER S - AU - AU AU AU <br>
FWDUSER S - AU - AU AU AU</p>

<p style="margin-top: 1em">KEY: <br>
JH = HOST host in control file <br>
RH = REMOTEHOST connecting host name <br>
JUSR = USER user in control file <br>
CUSR = REMOTEUSER user from control request <br>
JIP= IP IP address of host in control file <br>
RIP= REMOTEIP IP address of requesting host <br>
PORT= connecting host origination port <br>
CONTROLLINE= pattern match of control line in control file
<br>
FW= IP of source of request = IP of host in control file
<br>
SA= IP of source of request = IP of host in control file
<br>
SU= user from request = user in control file <br>
SA= IP of source of request = IP of server host <br>
SV= matches if remote host is the server <br>
AU= authentication information <br>
IFIP= IP address of remote end of connection</p>

<p style="margin-top: 1em">Match: S = string with wild
card, IP = IP address[/netmask], <br>
N = low[-high] number range, V = exact value match <br>
SERVICE: &rsquo;X&rsquo; - Connection request;
&rsquo;R&rsquo; - lpr request from remote host; <br>
&rsquo;P&rsquo; - print job in queue; &rsquo;Q&rsquo; - lpq
request, &rsquo;M&rsquo; - lprm request; <br>
&rsquo;C&rsquo; - lpc spool control request; &rsquo;S&rsquo;
- lpc spool status request <br>
NOTE: when printing (P action), the remote and job check
values <br>
(i.e. - RUSR, JUSR) are identical.</p>

<p style="margin-top: 1em">The special key letter=patterns
searches the control file line starting with the (upper
case) letter, and is usually used with printing and spooling
checks. For example, C=A*,B* <br>
would check that the class information (i.e.- line in the
control file starting with C) had a value starting with A or
B.</p>

<p style="margin-top: 1em">PERMISSIONS, MULTIHOMED HOSTS,
IPV6 <br>
There is a subtle problem with names and IP addresses which
are obtained for &rsquo;multi-homed hosts&rsquo;, i.e. -
those with multiple Ethernet interfaces, and for IPV6 (IP
Version 6), <br>
in which a host can have multiple addresses, and for the
normal host which can have both a short name and a fully
qualified domain name. In addition, a host can have multiple
<br>
IP addresses, depending on the complexity of its
configuration.</p>

<p style="margin-top: 1em">The IFIP (interface IP) field
can be used to check the IP address of the origination of
the request, as reported by the information returned by the
accept() system call. Note <br>
that this information may be IPV4 or IPV6 information,
depending on the origination of the system. This information
is used by gethostbyaddr() to obtain the originating host
<br>
fully qualified domain name (FQDN) and set of IP addresses.
Note that this FQDN will be for the originating interface,
and may not be the canonical host name. Some systems <br>
which use the Domain Name Server (DNS) system may add the
canonical system name as an alias.</p>

<p style="margin-top: 1em">When performing an IP address
match, the entire list of IP addresses for a system will now
be checked. If one of these matches, then success is
reported. Similarly, the <br>
entire list of host names and aliases will be checked. If
one of these matches, then success will be reported.</p>

<p style="margin-top: 1em">In addition, when checking for
printing, if the name lookup for the host reported in the
control file fails, then we assume that the host is unknown
and all match checks for <br>
names or IP addresses will fail. You can determine if a host
has an entry by using the following check, which will reject
all requests from a remotehost which does not have a <br>
DNS entry. <br>
REJECT NOT REMOTEHOST=*</p>

<p style="margin-top: 1em">PRINTCAP DATABASE <br>
Individual printer operations are controlled by values in
the printcap database. See printcap(5) for details of the
format and content of the various entries. The following are
<br>
typical printer entries for a local and remote printer.</p>

<p style="margin-top: 1em"># main or shared printcap file -
usually /etc/printcap <br>
# remote postscript printer <br>
fullpage <br>
|postscript <br>
:lp=postscript@farside.astart.com <br>
# give access to (remote) hosts <br>
t1|postscript2 <br>
:cm=Test Printer 1 <br>
:lp=postscript2@nearside.astart.com</p>

<p style="margin-top: 1em"># local printcap file <br>
# specification for local printer on nearside <br>
t1|postscript2 <br>
:oh=nearside.astart.com <br>
:cd=/usr/spool/LPD/safe <br>
:sd=/usr/spool/LPD/t1 <br>
# <br>
# /usr/spool/LPD/t1/printcap file - <br>
t1: <br>
:lp=/dev/pr <br>
:if=/usr/lib/pr/if <br>
:of=/usr/lib/pr/if</p>

<p style="margin-top: 1em">Printcap information can be
distributed by individual files or shared using NSF, YP, or
other methods; see lpd.conf(5) for the exact details of the
location of printcap files and <br>
programs, given by the printcap_path and lpd_printcap_path
configuration information. The usual printcap configuration
is to have a main (shared) printcap database which is used
<br>
by all hosts. The printcap information is usually extremely
simple, consisting only of the printer name and host (i.e. -
fullpage printer entry).</p>

<p style="margin-top: 1em">On hosts which have printers
attached or which are to provide spooling queue directories,
more extensive printcap information is needed. In the shared
database, oh (options for <br>
specified host only) field restricts use of this entry to
the specified host. This entry can contain host specific
information, such as the location of the spool queue and/or
<br>
actual device to be used for output.</p>

<p style="margin-top: 1em">In the above example, the main
printcap file, /etc/printcap has entries for all printers.
Note that these entries do not specify the spool directories
(sd and cd fields), but <br>
this could be provided. On a host with a printer specific
information can be provided in several ways. The simplest is
to simply put an additional entry in the shared printcap
<br>
file, with the oh field set to the support host name. An
alternative would be to specify the spool directories (sd
and cd fields) in the shared information, and to put the
<br>
printer specific information in a printcap file.</p>

<p style="margin-top: 1em">In addition to the oh flag, the
server flag indicates that this entry is for a the LPD
server only. This can be used to simplify the management of
client and server entries.</p>

<p style="margin-top: 1em">The printcap information is
obtained in the following order. If the lpd_printcap_path
configuration value is nonblank then the lpd server will
process only this information <br>
otherwise it uses the printcap_path information. All client
programs use the contents of the configuration printcap_path
variable to get a list of locations of printcap files. <br>
Each of these entries in the path lists are processed, and
the printcap information is extracted. Entries which have oh
fields are only used by the specified host. The files <br>
and information is processed in linear order, later entries
overriding preceeding ones.</p>

<p style="margin-top: 1em">When processing jobs or
performing spool queue specific requests, the LPD server
will check to see if there is a printcap file in the control
directory for the spool queue and <br>
the contents will be processed. Since only the LPD server
has access to the spool and control queues, this information
is processed only by the server.</p>

<p style="margin-top: 1em">In addition to files, printcap
information can be obtained from programs or filters. For
example, the printcap_path of the form
/etc/printcap:|/usr/lib/getpr will use the <br>
contents of the /etc/printcap file, and then use the
/usr/lib/getpr program to get information about a specific
printer. When information about a particular spool queue is
<br>
needed and one or more filters are specified as the source
of printcap information, then the filter will be started and
the printer name written on its standard input. The <br>
filter must provide a printcap entry for the requested
printer on its standard output.</p>

<p style="margin-top: 1em">The filter can be used to
interface to databases or nonstandard information sources
which do not produce printcap information in an acceptable
form.</p>

<p style="margin-top: 1em">SPOOL DIRECTORY CONTENTS <br>
Each spool queue has a spool directory (sd) and optional
control directory (cd) where job and control information is
kept. Under normal operation the spool and control <br>
directories are identical, but if the spool directory is NFS
exported for use by other printer spoolers which write files
directly into the spool queue, then it is recommended <br>
that the control directory be a separate directory and not
NFS mounted. The following files are used for printer
operations. Per job entries are marked with an asterisk
(*).</p>

<p style="margin-top: 1em">File Name Dir Purpose <br>
printer CD lock file and server process PID <br>
unspooler.printer CD subserver process PID <br>
control.printer CD queue control information <br>
*hfAnnn SD job hold file <br>
*cfAnnnHOST SD job control file <br>
*dfAnnnHOST SD job data file <br>
*bfAnnn.* SD temporary files</p>

<p style="margin-top: 1em">The nnn in the file names stands
for the job number. RFC1179 requires this to be a 3 digit
number, but the longnumber printcap flag or a nonzero
longnumber configuration <br>
variable will enable 6 digit numbers.</p>

<p style="margin-top: 1em">The lock file is used to prevent
multiple job queue servers from becoming active
simultaneously, and to store the server process id. The lock
file name is the name as the <br>
printer name; all other control files have the printer name
appended as indicated above.</p>

<p style="margin-top: 1em">The printer spool control file
contains information controlling the queue operations. It
consists of a series of lines with keywords and values to
control printing, spooling, <br>
and automatic job holding operations. The following is an
example of a typical spool control file.</p>

<p style="margin-top: 1em">spooling_disabled 0 <br>
printing_disabled 1 <br>
holdall 0 <br>
redirect p1@host2 <br>
debug 10,log=/tmp/log <br>
class A</p>

<p style="margin-top: 1em">The spooling_disabled and
printing_disabled entries control spooling and printing; the
lpc enable, disable, start, and stop command alter these
values. The holdall entry will <br>
prevent jobs from being processed until released with the
lpc hold or release comands; the lpc holdall and noholdall
commands alter these values.</p>

<p style="margin-top: 1em">The redirect entry causes the
lpd server to forward jobs to the specified remote printer;
the lpc redirect command alters this field. The class field
controls the class of jobs <br>
being printed. By default, the class value is a pattern that
matches the class entry in a job file; however a entry of
the form letter=patterns will print jobs whose control <br>
file line starting with letter matches one of the patterns.
The debug line provides a set of debugging parameters for
diagnostic information for the particular spool queue.</p>

<p style="margin-top: 1em">Each print job consists of a
control file and one or more data files. Lines in the
control file file specify the job data files or parameters
for the job and the general format <br>
of the file is specified by RFC1179. Each line consists of a
flag character and a parameter; upper case and digit
characters specify options and lower case letters specify
the <br>
printing format and names of data files. The following is a
list of the control file flag characters.</p>

<p style="margin-top: 1em">A Identifier A job identifier to
be used when displaying job information and/or status. The
insertion of this line is controlled by the use_identifier
<br>
printcap/configuration variable.</p>

<p style="margin-top: 1em">C Class String to be used for
the class line on the burst page.</p>

<p style="margin-top: 1em">H Host Name. Name of the machine
where lpr was invoked.</p>

<p style="margin-top: 1em">I Indent. The number of
characters to indent the output by (in ascii).</p>

<p style="margin-top: 1em">J Job Name. String to be used
for the job name on the burst page.</p>

<p style="margin-top: 1em">L Banner user name. Information
for banner page.</p>

<p style="margin-top: 1em">P Person. Login name of the
person who invoked lpr. This is used to verify ownership by
lprm.</p>

<p style="margin-top: 1em">M Send mail to the specified
user when the current print job completes.</p>

<p style="margin-top: 1em">N File name. The original name
of a data file which is in the job.</p>

<p style="margin-top: 1em">T Title. String to be used as
the title for pr(1) when the LPR -p option was
specified.</p>

<p style="margin-top: 1em">U Unlink. Job file to remove
when printing completed.</p>

<p style="margin-top: 1em">W Width. The page width (in
characters) to used for printing.</p>

<p style="margin-top: 1em">Z zoptions. Options passed by
lpr -Zzoptions. These are passed to output filters to aid in
printing.</p>

<p style="margin-top: 1em">f Formatted File. Name of a file
to print which is already formatted.</p>

<p style="margin-top: 1em">l Like
&lsquo;&lsquo;f&rsquo;&rsquo; but passes control characters
and does not make page breaks.</p>

<p style="margin-top: 1em">p Name of a file to print using
pr(1) as a filter.</p>

<p style="margin-top: 1em">t Troff File. The file contains
troff(1) output (cat phototypesetter commands).</p>

<p style="margin-top: 1em">d DVI File. The file contains
Tex(l) output (DVI format from Stanford).</p>

<p style="margin-top: 1em">g Graph File. The file contains
data produced by plot(3X).</p>

<p style="margin-top: 1em">c Cifplot File. The file
contains data produced by cifplot.</p>

<p style="margin-top: 1em">v The file contains a raster
image.</p>

<p style="margin-top: 1em">r The file contains text data
with FORTRAN carriage control characters.</p>

<p style="margin-top: 1em">1 Troff Font R. Name of the font
file to use instead of the default. (Obsolete)</p>

<p style="margin-top: 1em">2 Troff Font I. Name of the font
file to use instead of the default. (Obsolete)</p>

<p style="margin-top: 1em">3 Troff Font B. Name of the font
file to use instead of the default. (Obsolete)</p>

<p style="margin-top: 1em">4 Troff Font S. Name of the font
file to use instead of the default. (Obsolete)</p>

<p style="margin-top: 1em">Each job in the spool queue can
have an associated job hold file which is used by the server
process to control the printing of the job. The status file
contains information <br>
controlling the job hold status and error status. The spool
server will attempt to print a job a limited number of times
before abandoning it or setting an error status in the <br>
job status file. The following is a typical job hold file.
<br>
hold 0 priority 0 active 2135 redirect remove 0 error</p>

<p style="margin-top: 1em">A nonzero hold entry will
prevent the job from being processed; the lpc hold and
release commands update this field. The priority field
overrides the normal first-in first-out <br>
printing priority; jobs with non-zero priority fields are
printed first. The lpc topq command updates this field. If
the active field is non-zero, the job is being printed by
<br>
the server with the specified process id. The redirect field
allows individual jobs to be forwarded to a different
printer; the lpc move command updates this field. Finally,
<br>
the remove and error fields are used to control printing of
problem jobs. The remove field is set when a job should be
removed; the error field records information that would <br>
prevent a job from being printed.</p>

<p style="margin-top: 1em">JOB SUBMISSION <br>
The LPR program is used to submit a job to the LPRng system.
The LPR program opens a connection to the LPD server and
then transfer the job control file and data files. The LPD
<br>
server checks to see if the remote host and user has
permissions to spool to the requested printer, and then
checks to see if the printer is accepting jobs. If both
conditions <br>
are met, the job is accepted and the control and data files
are placed in the spool directory. The LPRng software sends
the control file first, followed by the data files.</p>

<p style="margin-top: 1em">If the LPR program is acting as
a filter, it is not necessary to temporarily store the print
job on the local machine. The input data can be sent
directly to the LPD server for <br>
spooling using an implicit job size of 0 and sending data
until the connection is terminated to the server. However,
some LPD servers do not accept 0 size jobs, even though it
<br>
is specified by the RFC1179, so by default LPR will create a
temporary file. The LPR -k (seKure) option specifies this
direct transmission mode be used.</p>

<p style="margin-top: 1em">JOB TRANSMISSION <br>
When LPR is to send a job to the server, it must determine
the location of the server. It does this by examining the
values of the specified printer and host.</p>

<p style="margin-top: 1em">If the printer and host are
explicitly specified in the form pr@host then the LPR
program will send the job to the specified spool queue pr
and to the server running on host. <br>
This can be explicitly specified by the PRINTER environment
variable or by the LPR -P option.</p>

<p style="margin-top: 1em">If the printer is specified only
by a name, then the information in the printcap database is
used. The printcap entry for the printer is searched for and
the remote host and <br>
printer information extracted. The job is sent to the server
running on the specified host.</p>

<p style="margin-top: 1em">This action can be modified by
the following printcap or configuration tags.</p>

<p style="margin-top: 1em">1. default_host=host <br>
(Configuration) If there is no printcap entry for the
printer, the job is sent to the LPD server running on
host.</p>

<p style="margin-top: 1em">2. force_localhost <br>
(Configuration or printcap) If this flag is specified, then
LPR and other client programs will send the job to the
server running on the localhost. This overrides the <br>
default_host information.</p>

<p style="margin-top: 1em">FORWARDING OPERATIONS <br>
The LPD system can forward jobs from one spool directory to
another. This is controlled by the following options.</p>

<p style="margin-top: 1em">1. The forward field in the
spool control file has a value rp@rm. This can be set using
the LPC forward command.</p>

<p style="margin-top: 1em">2. The lp (line printer)
printcap entry has the form rp@rm. There is a rm (remote
machine) and optional rp (remote printer) printcap
entry.</p>

<p style="margin-top: 1em">The first of the above
conditions to be met will determine the destination. If
printing is enabled, then jobs will be forwarded to the
remote destination. Example: <br>
# using lp=rp@host <br>
test:sd=/usr/spool/test <br>
:lp=test@host <br>
test:sd=/usr/spool/test <br>
:lp=test@host%port <br>
# using :rp:rm: <br>
test:sd=/usr/spool/test <br>
:rp=test:rm=host</p>

<p style="margin-top: 1em">3. The LPD server uses the same
algorithm for sending jobs as the LPR program. A connection
is made to the remote server and the files are copied to the
server. A set of <br>
timeouts is used to control error recover and retry
operations. The printcap and configuration variables
connect_timeout, connect_interval, connect_grace, and
send_try <br>
control connecting to the remote host. A connection is
attempted to the remote server from a random port in the
range of ports specified by the originate_port variable. If
<br>
a connection is not completed within connect_timeout
seconds, the connection is aborted, and then after the
connect_interval seconds it is retried. The procedure
repeated <br>
indefinitely for printing, but only once for status or
control operations. A connect_timeout value of 0 indicates
no timeout; a value of 0 specifies infinite timeout After
<br>
a job has been successfully printed, the connection is
closed and the server waits for connect_grace seconds before
trying to reconnect.</p>

<p style="margin-top: 1em">BOUNCE QUEUES <br>
Normally job files are forwarded to a printer without
modification. The lpd_bounce flag makes the queue a bounce
queue and allows banners to be generated and data files to
<br>
passed through the appropriate format filter. The entire
output of this process is then passed to the destination
with the format specified by the bq_format option (default l
or <br>
binary). See PRINTING OPERATIONS for details about filters.
For example, the following printcap entry will filter format
f files. <br>
testbq:sd=/usr/spool/testbq: <br>
:lpd_bounce <br>
:bq_format=l <br>
:lp=final@host <br>
:if=/usr/lib/filter_for_f <br>
:mf=/usr/lib/filter_for_m <br>
:pf=/usr/lib/filter_for_pr</p>

<p style="margin-top: 1em">CHANGING FORMAT OF DATAFILES
<br>
Sometimes only the indicated format of the data files needs
to be changed. This can be done using the translate_format
option. This entry consists of pairs of lower case <br>
characters of the form SdSd...; S is the original and d is
the translated format. <br>
changeformat: <br>
:sd=/usr/spool/changeformat: <br>
:translate_format=mfpf <br>
:lp=final@host</p>

<p style="margin-top: 1em">In the example above, the m
format is processed by a filter, and then its format type is
changed to f; the p format is processed similarly. Note that
the lpr -p option specifies <br>
that the job will be processed by the /bin/pr command - the
filter must do both the pr processing and any necessary
format conversions.</p>

<p style="margin-top: 1em">LPR FILTER PROCESSING <br>
The :lpr_bounce: printcap flag will cause LPR to do bounce
queue filtering before sending the job to the remote queue.
This can have unexpected effects if the filters are not <br>
available on the local host.</p>

<p style="margin-top: 1em">A typical entry which will cause
LPR to do filtering is shown below. <br>
testbq:lpr_bounce <br>
:lp=printer@host <br>
:if=/usr/lib/filter_for_f <br>
:vf=/usr/lib/filter_for_v <br>
:mf=/usr/lib/filter_for_m <br>
:translate_format=mfvf</p>

<p style="margin-top: 1em">This entry will force LPR to run
jobs with formats f, m, and v <br>
through the appropriate filter. <br>
It will also rename the formats to the f format.</p>

<p style="margin-top: 1em">ROUTING JOBS TO PRINTERS <br>
When a job is submitted for printing, sometimes it is
desirable to have it dynamically rerouted to another spool
queue, or multiple copies send to various destination. This
can <br>
be done by using a routing_filter.</p>

<p style="margin-top: 1em">When a job is accepted by the
LPD server, part of the processing includes passing it to a
program specified by the printcap router entry. This filter
is invoked with the <br>
original control file as STDIN, and the default set of
filter options. The output of the routing filter will be a
set of directives used by LPD when forwarding the job to
<br>
another printer or in processing the job. The environment
and options flags are set as for a standard filter. (See
&quot;FILTERS&quot; for details.) Here is a sample printcap
entry: <br>
t2|Test Printer 2 <br>
:sd=/var/spool/LPD/t2 <br>
:lf=log <br>
:lp=t2@printserver <br>
:bq=t1@localhost <br>
:destinations=t1@localhost,t2@localhost <br>
:router=/usr/local/libexec/filters/router</p>

<p style="margin-top: 1em">The routing filter exit status
is used as follows: <br>
0 (JSUCC) - normal processing <br>
37 (JHOLD) - job is held <br>
any other value - job is deleted from queue</p>

<p style="margin-top: 1em">The router filter returns one or
more routing entries with the following format. Note that
entry order is not important, but each entry will end with
the &rsquo;end&rsquo; tag. dest <br>
&lt;destination queue&gt; copies &lt;number of copies to be
made&gt; X&lt;controlfile modifications&gt; end</p>

<p style="margin-top: 1em">Example of router output: <br>
dest t1@localhost <br>
copies 2 <br>
CA <br>
end <br>
dest t2@localhost <br>
CZ <br>
end</p>

<p style="margin-top: 1em">The above routing information
will have copies of the job sent to <br>
the t1 and t2 spool queue servers. If no valid routing
information <br>
is returned by the router filter the job will be sent to the
default <br>
bounce queue destination.</p>

<p style="margin-top: 1em">REFORMATING CONTROL FILES <br>
Sometimes it is desirable to reformat a control file before
sending to a remote destination. If the control_filter
printcap entry is present, then the control file is passed
<br>
through the filter. If the filter exits with status JSUCC,
then the job is process normally; status JABORT causes the
job processing to be aborted, status JREMOVE causes the job
<br>
processing to be removed, and any other status is treated as
JFAIL.</p>

<p style="margin-top: 1em">After passing the control file
through the control_filter, the LPD server will reread it,
and transfer only the data files specified in the new
control file to the destination.</p>

<p style="margin-top: 1em">SPOOL QUEUE NAME OPTION <br>
The qq printcap entry and the use_queuename configuration
entry causes the name of the spool queue to be placed in the
job control file. This value can be used by the filter to
<br>
determine how to process a job. When combined with the use
of the Bounce Queue, this can be used to reformat jobs
before sending to another printer spooler system.</p>

<p style="margin-top: 1em">PRINTING OPERATIONS <br>
When printing is enabled, the LPD server will create a spool
server process to carry out printing operations. For each
job in the queue, the spool server process will create a
<br>
subserver process to carry out the actual printing
operations. If the subserver process fails, the server
process will initiate recovery operations. Job will be
attempted to be <br>
printed until all are done or a subserver returns an ABORT
indication; the server will then terminate operations.</p>

<p style="margin-top: 1em">The server process normally
scans the queue once, at initiation; if the spool control
file is modified, usually by using the lpc command, the
spool queue is rescanned. The <br>
overall algorithm for job printing is: <br>
open the print device; <br>
send some initialization strings; <br>
send a banner to the device; <br>
send the job data files to the device; <br>
send some termination strings; <br>
close the print device;</p>

<p style="margin-top: 1em">In order to handle the various
device requirements, the subserver process in turn uses
&rsquo;filter&rsquo; programs specified in the printcap
entry to carry out the individual steps.</p>

<p style="margin-top: 1em">OF Filter <br>
The &rsquo;of&rsquo; filter is used for initialization,
banner printing and the termination strings. It has the
peculiar property of suspending itself when sent a special
escape <br>
string, allowing other filters to be used to print the
individual job files.</p>

<p style="margin-top: 1em">Data Filters <br>
Each data file in a job has format specified by a lower case
character and an associated filter specified in the printcap
file. For example, the &rsquo;g&rsquo; format is printed by
<br>
the &rsquo;gf&rsquo; filter, and so forth. By convention,
the &rsquo;if&rsquo; filter is used to print &rsquo;f&rsquo;
(ordinary text) and &rsquo;l&rsquo; (binary) format
jobs.</p>

<p style="margin-top: 1em">lp-pipe Filters <br>
If the printcap device specification has the form |program
then the output device is accessed by the specified program.
This allows the program to take care of any required <br>
initialization or communication requirements.</p>

<p style="margin-top: 1em">The following is a concise
summary of the actual algorithm used to print files. Note
that LP stands for the printer device or filter specified by
the &rsquo;lp&rsquo; printcap entry; OF <br>
stands for the &rsquo;of&rsquo; printcap filter; IF is the
default &rsquo;if&rsquo; filter; BP is the banner printing
filter; and ?F stands for the filter for data file. The
&rsquo;??&rsquo; values stand for <br>
entries from the printcap file.</p>

<p style="margin-top: 1em">LP = open( &rsquo;lp&rsquo; );
// open device, filter, or network connection <br>
OF = IF = LP; // set defaults <br>
set up accounting according to &rsquo;af&rsquo; entry; <br>
if( &rsquo;of&rsquo; ) OF = filter( &rsquo;of&rsquo; ) -&gt;
LP;// make OF filter <br>
if &rsquo;as&rsquo; then record start of job accounting
information. <br>
if &rsquo;achk&rsquo; then check for accounting limits. <br>
if( leader on open &rsquo;ld&rsquo; ) &lsquo;ld&lsquo; -&gt;
OF// send leader <br>
if( FF on open &rsquo;fo&rsquo; ) &lsquo;fo&lsquo; -&gt; OF
// send leader</p>

<p style="margin-top: 1em">// print a banner <br>
// first check to see if required <br>
// and then to see if not suppressed by printcap <br>
// or by user <br>
do_banner = <br>
(always banner &rsquo;ab&rsquo; <br>
|| (!suppress banner &rsquo;sb&rsquo; &amp;&amp; job has
banner )); <br>
if( ! header last &rsquo;hl&rsquo; &amp;&amp; do_banner ){
<br>
if( banner program &rsquo;bp&rsquo; ){ <br>
fork and exec bp to generate banner, but into temp file.
<br>
cat temp file -&gt; OF; <br>
} else { <br>
short banner info -&gt; OF; <br>
} <br>
}</p>

<p style="margin-top: 1em">// now we suspend the OF filter,
use other filters <br>
if( OF != LP ) suspend OF filter;</p>

<p style="margin-top: 1em">for each data file df in job do
<br>
// send FF between files of job <br>
if( !first job &amp;&amp; ! no FF separator &rsquo;sf&rsquo;
){ <br>
if( OF != LP ) wake up OF filter; <br>
&rsquo;ff&rsquo; -&gt; OF; <br>
if( OF != LP ) suspend OF filter; <br>
}</p>

<p style="margin-top: 1em">// get filter for job <br>
format = jobformat; <br>
if( jobformat == &rsquo;f&rsquo; or jobformat =
&rsquo;l&rsquo; ){ <br>
format = &rsquo;f&rsquo;; <br>
} <br>
filter = check pc for filter for format; <br>
?F = LP; // default - no filter <br>
if( filter ){ <br>
?F = filter( filter ) -&gt; LP; <br>
}</p>

<p style="margin-top: 1em">data file -&gt; ?F; <br>
// note: if :direct_read: flag set, filter input <br>
// is directly from the file, otherwise the <br>
// file contents are written to the filter input.</p>

<p style="margin-top: 1em">if( ?F != LP ) close( ?F ) <br>
endfor</p>

<p style="margin-top: 1em">// finish printing</p>

<p style="margin-top: 1em">if( OF != LP ) wake up OF
filter; <br>
if( header last &rsquo;hl&rsquo; &amp;&amp; do_banner ){
<br>
if( ! no FF separator &rsquo;sf&rsquo; ){ <br>
&rsquo;ff&rsquo; -&gt; OF; <br>
} <br>
if( banner program &rsquo;bp&rsquo; ){ <br>
fork and exec bp to generate banner, but into temp file.
<br>
cat temp file -&gt; OF; <br>
} else { <br>
short banner info -&gt; OF; <br>
} <br>
}</p>

<p style="margin-top: 1em">if( ff on close &rsquo;fq&rsquo;
){ <br>
&rsquo;ff&rsquo; -&gt; OF; <br>
}</p>

<p style="margin-top: 1em">if( trailer on close
&rsquo;tr&rsquo; ){ <br>
tr -&gt; OF; <br>
}</p>

<p style="margin-top: 1em">if &rsquo;ae&rsquo; then record
end of job accounting information.</p>

<p style="margin-top: 1em">if( OF != LP ) close( OF ); <br>
close( LP );</p>

<p style="margin-top: 1em">When printing or transferring a
job to a spool queue fails, it is retried the number of
times specified by the rt (or send_try ) printcap variable.
A 0 value specifies an <br>
infinite number or retries. When the retry count is
exceeded, then the send_failure_action printcap variable
determines the action to be taken. The variable can be the
values <br>
succ , fail , abort , remove , ignore , or hold , which will
cause the job to be treated as normally completed, retried,
aborted, removed, or ignored and retried at a later time
<br>
respectively. These names correspond to the JSUCC , JFAIL ,
etc. error codes returned by filters. If the variable has
the form |/filter , then the filter is run and passed the
<br>
number of attempts on the standard input. The filter must
exits with a JSUCC, JFAIL, etc., error code and the server
will take the appropriate action as listed above.</p>

<p style="margin-top: 1em">The print filters normally have
their input provided by a process via a pipe. However, if
the direct_read printcap flag is set, then the filter input
is taken directly from the <br>
job file. This is compatible with the vintage BSD method,
but loses the ability to track the job progress.</p>

<p style="margin-top: 1em">After the job print or transfer
attempt, if the job is to be removed and the printcap
variable save_on_error is true, the job will not be removed
from the spool queue but only <br>
flagged with an error. The job can then be retried at a
later time. If the job is successfully printed it is usually
removed from the spool queue. However, if the printcap <br>
variable save_when_done is true the job will merely be
marked as completed and not removed from the queue.</p>

<p style="margin-top: 1em">FILTERS <br>
As described in the previous section, filters are created to
handle output to devices or other filters. The command line
to invoke a filter is generated in the following manner.</p>

<p style="margin-top: 1em">1. The printcap entry or
configuration value defining the filter command is
obtained.</p>

<p style="margin-top: 1em">2. The file to be printed or the
banner line/file generated by the banner printer will be
written to STDIN (file descriptor 0) of the filter. The
output device (or /dev/null <br>
if this is not a printing filter) will be be STDOUT (file
descriptor 1) and STDERR (file descriptor 2) will be
connected to the error logging file. If this is a printing
<br>
filter, the error log will be determined by the :af:
printcap field and FD 3 will be opened and set to the either
the file, remote host, or input of the filter program.</p>

<p style="margin-top: 1em">3. Filter specifications
starting with ROOT will be run as root (EUID = 0). This can
be a serious security loophole and should only be used as a
last resort for specific <br>
problems.</p>

<p style="margin-top: 1em">4. The options for the filter
command line will be replaced by appropriate values. Option
specifications have the form $[0| ][-]X. The default option
expansion has the form <br>
$X -&gt; -X&rsquo;value&rsquo;; the form $0X or $(space)X
adds a space after the -X, i.e.- $0X -&gt; -X
&rsquo;value&rsquo;; the form $-X suppresses the -X, i.e. -
$-X -&gt; value. The options will be <br>
expanded as follows:</p>

<p style="margin-top: 1em">Key Value <br>
a Accounting file (printcap &rsquo;af&rsquo; entry) <br>
b Job size, i.e.- total data file size, in bytes <br>
c if binary (format &rsquo;l&rsquo;) expands to -c <br>
d Control directory <br>
e job data file <br>
f original print file name (control file N field) <br>
h Control file hostname <br>
i Control file indent (I) field <br>
j job number from control file name <br>
k Control file name <br>
l printcap Page length (pl) value <br>
m printcap Cost factor (co) value <br>
n Control file user logname (P) field <br>
p Remote Printer name for forwarded jobs <br>
r Remote Host name for forwarded jobs <br>
s printer Status file (ps) value <br>
t current time in simple format <br>
w printcap Page width (pw) value <br>
x printcap x dimension (px) value <br>
y printcap y dimension (py) value <br>
F data file format character <br>
P Printer name <br>
S printcap Comment tag (cm) value <br>
Upper Case control file line starting with letter <br>
Digit control file line starting with digit</p>

<p style="margin-top: 1em">5. The options specified by the
filter_options (for none OF filters) or of_filter_options
(for the OF filter) will be appended to the command line and
expanded. To suppress <br>
adding options, you can use the form &rsquo;-$
filter&rsquo;, i.e. - of=-$/bin/cat. If the
&rsquo;bkf&rsquo; (backwards compatible filter options)
printcap flag is set, the of filter is given the <br>
options specified by bk_of_filter_options and other filters
those by bk_filter_options. The following shows the various
combinations possible, and typical values for the <br>
options.</p>

<p style="margin-top: 1em">Options <br>
filter_options $C $F $H $J $L $P $Q $R $Z $a $c $d $e $f $h
$i $j $k $l $n $s $w $x $y $-a <br>
bk_filter_options $P $w $l $x $y $F $c $L $i $J $C $0n $0h
$-a <br>
bk_of_filter_options $w $l $x $y</p>

<p style="margin-top: 1em">6. A printing filter which
executes correctly and completely should <br>
exit with a 0 error status. <br>
A nonzero error status will be interpreted as follows: <br>
JFAIL 32 failed - retry later <br>
JABORT 33 aborted - do not try again, but keep job <br>
JREMOVE 34 failed - remove job</p>

<p style="margin-top: 1em">The JFAIL will cause the job to
be retried at a later time. A limit can be placed on the
number of retries using the :rt: or :send_try: printcap
entry. A retry value of 0 will <br>
cause infinite retries. The JABORT indicates serious
problems and will cause printing operations on the job to
stop until restarted by operator intervention. The JREMOVE
status <br>
indicates problems, and the job should be removed from the
spool queue.</p>

<p style="margin-top: 1em">The environment variables for
filters are highly restricted, due to the possibility for
abuse by users. The following variables are set:</p>

<p style="margin-top: 1em">USER and LOGNAME <br>
user name or daemon name.</p>

<p style="margin-top: 1em">LOGDIR <br>
home directory of user or daemon.</p>

<p style="margin-top: 1em">PATH from the filter_path
configuration variable.</p>

<p style="margin-top: 1em">LD_LIBRARY_PATH <br>
from the filter_ld_path configuration variable.</p>

<p style="margin-top: 1em">SHELL <br>
set to /bin/sh</p>

<p style="margin-top: 1em">IFS set to blank and tab.</p>

<p style="margin-top: 1em">TZ the TZ environment
variable.</p>

<p style="margin-top: 1em">SPOOL_DIR <br>
the spool directory for the printer</p>

<p style="margin-top: 1em">CONTROL_DIR <br>
the control directory for the printer</p>

<p style="margin-top: 1em">PRINTCAP_ENTRY <br>
the printcap entry for the printer</p>

<p style="margin-top: 1em">CONTROL <br>
the control file for the print job</p>

<p style="margin-top: 1em">pass_env environment variables
<br>
Values of environment variables listed in the pass_env
configuration variable.</p>

<p style="margin-top: 1em">ACCOUNTING <br>
The LPRng software provides several methods of performing
accounting. The printcap af (accounting field), as and ae
(accounting start and end), and achk (accounting check) <br>
provide a basic set of facilities. The af field specifies a
file, filter, or TCP network connection to an accounting
server. If af has the form |filter or |-$ filter then a <br>
filter will be started and all accounting information will
be sent to the filter. The first form passes the filter the
command line options specified by the filter_options <br>
configuration variable and the second suppresses option
passing. If af has the form host%port then a TCP connection
will be opened to the port on the specified host and <br>
accounting information sent there. All other forms will be
treated as a pathname relative to the queue spool
directory.</p>

<p style="margin-top: 1em">If af specifies a file, then the
accounting information is appended to an existing file; the
accounting file will not be created.</p>

<p style="margin-top: 1em">When af specifies a filter or
network connection and the achk flag is set, then after
writing the initial accounting information (see as printcap
field below) the server will <br>
wait for a reply of the form ACCEPT from the filter or
server. If not received, the job will not be printed.</p>

<p style="margin-top: 1em">The as (accounting start) and ae
(accounting end) fields can specify a string to be printed
or a filter. Options in the string will be expanded as for
filters, and the strings <br>
printed to either the accounting information destination. If
the as field specifies a filter, then the print server will
wait for the filter to exit before printing the job. If <br>
the exit status is 0 (successful), the job will be printed.
A non-zero JREMOVE status will remove the job, while any
other status will terminate queue printing operations. <br>
After printing the job, the ae filter will be started and
the server will wait for it to complete before printing the
next job.</p>

<p style="margin-top: 1em">The as and ae filters will have
STDOUT set to the printing device and or filter, and the
STDERR set to the error log file for the print queue, and
file descriptor 3 set to the <br>
destination specified by the af field.</p>

<p style="margin-top: 1em">As a convenience, all format
filters for printing will be started with file descriptor 3
set to the destination (file or filter) specified by the
printcap af field. This allows <br>
special filters which can query devices for page counts to
pass their information directly to an accounting program.
The descriptor will READ/WRITE, allowing filters to query
<br>
the accounting program and/or update the information
directly.</p>

<p style="margin-top: 1em">LOGGING INFORMATION <br>
In order to provide a centralized method to track job status
and information, the printcap/configuration variable
logger_destination enable the send of status and other <br>
information to a remote destination. The logger_destination
value has the form <br>
host[%port][,protocol] <br>
Examples: <br>
taco%451,UDP <br>
dickory%2001,TCP <br>
where host is the host name or IP address, port is an
optional port number, and protocol is an optional protocol
type such as UDP or TCP. The configuration variables <br>
default_logger_port and default_logger_protocol can be used
to override the default port number (2001) and protocol
(UDP) to be used if none is specified. Logging information
<br>
has the format below. <br>
IDENTIFIER jobid [PRINTER name] at timestamp STATUS | TRACE
| FILTER_STATUS PID nnn <br>
[ status information]</p>

<p style="margin-top: 1em">The status information format
consists of an identifier line, followed by a specifier of
the status type. The logging information entry is terminated
by a line with a single <br>
period on it. Lines with a starting period have the period
duplicated.</p>

<p style="margin-top: 1em">AUTHENTICATION <br>
Rather than building authentication facilties into LPRng, an
interface to authentication programs is defined, and will be
used as follows. The printcap and configuration entries <br>
auth, auth_client_filter, auth_forward, auth_forward_id,
auth_forward_filter, auth_receive_filter, and auth_server_id
entries control authentication. The auth value specifies
<br>
the type of authentication to be used for client to server
authentication. Typical values would be kerberos, md5, etc.
If the authentication type is not built-in, the client <br>
programs use the auth_client_filter program to perform
authentication. When a server gets and an authentication
request, it will use the auth_receive_filter program to
perform <br>
authentication. The auth_server_id is the remote server id
used when a client is sending jobs to the server or when the
server is originating a request. When a server forwards <br>
a request, it uses auth_forward value to determine if
authentication is to be done, and the auth_forward_id as the
destination server id.</p>

<p style="margin-top: 1em">Client To Server Authentication
<br>
1. The client will open a connection to the server and sends
a command with the following format. The REQ_SECURE field in
the command corresponds to the one-byte command type <br>
used by the LPR protocol. <br>
Commands: <br>
user <br>
Print job transfers: <br>
user controfilename</p>

<p style="margin-top: 1em">2. On reception of this command,
the server will send a one byte success code as below. An
error code may be followed by additional error information.
The values used by <br>
LPRng include: <br>
ACK_SUCCESS 0 success, no error <br>
ACK_STOP_Q 1 failed; no spooling to the remote queue <br>
ACK_RETRY 2 failed; retry later <br>
ACK_FAIL 3 failed; job rejected, no retry</p>

<p style="margin-top: 1em">3. If there is an error the
connection will be terminated. The server will then start an
authentication process, and provide the following open file
descriptors for it. The <br>
authenticator process will run as the UID of the server
(i.e.- usually daemon). <br>
FD Options Purpose <br>
0 R/W socket connection to remote host (R/W) <br>
1 W pipe or file descriptor <br>
for information for server <br>
2 W error log <br>
3 R pipe or file descriptor <br>
for responses to client</p>

<p style="margin-top: 1em">The command line arguments will
have the form: <br>
program -S -Pprinter -nuser -Rserver_user -Ttempfile</p>

<p style="margin-top: 1em">The printer and user information
will be obtained from the command line sent to the server.
The authenticator can create additional temporary or working
files with the <br>
pathnames tempfile.ext; these should be deleted after the
authentication process has been completed.</p>

<p style="margin-top: 1em">4. After receiving 1CESS, the
client starts an authenticator process, and provides the
following open file descriptors for it. The authenticator
process will run UID <br>
user. <br>
FD Options Purpose <br>
0 R/W socket connection to remote host (R/W) <br>
1 W pipe or file descriptor <br>
for responses to client <br>
2 W error log</p>

<p style="margin-top: 1em">The command line arguments will
have the form: <br>
program -C -Pprinter -nuser -Rserver_user -Ttempfile</p>

<p style="margin-top: 1em">5. The authenticator can create
additional temporary or working files with the pathnames
tempfile.ext; these will be deleted after the authentication
process has been <br>
completed. The client authenticator will be running as the
client user.</p>

<p style="margin-top: 1em">6. After exchanging
authentication information, the client authenticator will
transfer the contents of the temporary file to the server
authenticator, using FD 0. It will then <br>
wait for reply status on FD 0. If the transfer step fails,
or there is no reply status of the correct format, the
client authenticator will print any received information
<br>
on FD 1, error information on FD 2, and then exit with error
code JFAIL.</p>

<p style="margin-top: 1em">7. After receiving the files on
FD 0, the server authenticator will perform the required
authentication procedures and leave the results in tempfile.
The server authenticator <br>
will write the following to FD 1, for use by the server:
<br>
authentication_info</p>

<p style="margin-top: 1em">If the transfer step or
authentication fails, then the server will write an error
message to FD 2 and exit with error code JFAIL. The server
will use this authentication <br>
information to determine if the remote user has permission
to access the system.</p>

<p style="margin-top: 1em">8. The server authentication
process will read input from FD 3 until and end of file, and
then proceed to transfer the input to the client
authenticator. If the data transfer <br>
fails, then the process will exit with error code JFAIL,
otherwise it will exit with error code JSUCC.</p>

<p style="margin-top: 1em">9. The client authenticator will
read the status information from FD 0, and after performing
authentication will write it to FD 1. If data transfer or
authentication fails, <br>
the authenticator will write an error message to FD 2 and
exit with error code JFAIL, otherwise it will exit with
error code JSUCC.</p>

<p style="margin-top: 1em">Server to Server Authentication
<br>
The Server to Server authentication procedure is used by one
server to forward jobs or commands to another server. It
should be noted that this forwarding operation puts an <br>
implicit trust in the security of the client to server to
server chain. In the description below, src and dst are the
userid of the source and destination servers
respectively.</p>

<p style="margin-top: 1em">1. The originating host takes
the part of the client, and will transfer a job acting like
the client. The initial information transfer from the
originating (src) server will <br>
have the format: <br>
Commands: <br>
user <br>
Print job transfers: <br>
user controfilename</p>

<p style="margin-top: 1em">After receiving a 0
acknowledgment byte, the src server will invoke its
authenticator with the arguments below. The forward_user
value will default to the server_user value <br>
if not explicitly provided. <br>
program -C -Pprinter -nserver_user -Rforward_user
-Ttempfile</p>

<p style="margin-top: 1em">2. On the destination server the
authenticator is invoked with the arguments: <br>
program -S -Pprinter -nserver_user -Rforward_user
-Ttempfile</p>

<p style="margin-top: 1em">The authentication is performed
to determine that the transfer was between the two servers,
rather than the user to server.</p>

<p style="margin-top: 1em">KERBEROS AUTHENTICATION <br>
As a convenience, Kerberos 5 authentication has been built
into the LPD clients and servers. If you are not familiar
with Kerberos, then you should obtain other documentation
<br>
and/or assistance before attempting to use this. The
following facilities/configuration values are used to
support Kerberos.</p>

<p style="margin-top: 1em">A Kerberos principal is the name
used for authentication purposes by Kerberos. For example,
user principals have the form user@REALM; for example,
papowell@ASTART.COM. Services <br>
and/or servers have the form service/host@REALM; for
example, the lpd server on dickory would have the form: <br>
lpr/astart2.astart.com@ASTART.COM</p>

<p style="margin-top: 1em">User to server authentication
process will use the user&rsquo;s principal name, and
generate a service name for the server. The name generation
is controlled by the following <br>
configuration and/or printcap values.</p>

<p style="margin-top: 1em">service <br>
The name of the service to be used to identify the service.
This is usually &quot;lpr&quot;.</p>

<p style="margin-top: 1em">kerberos_keytab <br>
The location of the server keytab file. The keytab file
corresponds to the user password, and must be considered a
security risk. It should be owned by the LPD server <br>
user, and readable/writable only by the server.</p>

<p style="margin-top: 1em">kerberos_life <br>
The lifetime of the authentication ticket used by the
server. This usually defaults to 10 hours.</p>

<p style="margin-top: 1em">kerberos_renew <br>
The renewal time of the ticket.</p>

<p style="margin-top: 1em">In addition to the default
values, an explicit server principal can be specified in the
printcap file using the kerberos_server_principal This
allows cross domain authentication <br>
to be done.</p>

<p style="margin-top: 1em">When setting up Kerberos
authentication, you will need to establish principals for
each server, and to distribute and install the keytab files
on each server.</p>

<p style="margin-top: 1em">AUTHENTICATION PERMISSIONS <br>
The following permissions tags are available to check on
authentication procedures. <br>
AUTH=[NONE,USER,FWD] - authentication <br>
AUTH=NONE - no authentication <br>
AUTH=USER - authentication from a client <br>
AUTH=FWD - forwarded authentication from a lpd server <br>
AUTHTYPE=globmatch <br>
AUTHUSER=globmatch <br>
FWDUSER=globmatch</p>

<p style="margin-top: 1em">1. The AUTH tag can be used to
determine the type of authentication being done. The
AUTHTYPE tag can be used to match the authentication type
being used or requested by the <br>
client or remote server. The authentication process returns
an authentication identifier for the user; this information
can be matched by the AUTHUSER tag.</p>

<p style="margin-top: 1em">2. For a command sent from a
client or forwarded from a server, AUTHUSER matches the
auth_user_id provided for the user when sent to a server.
(This information will be <br>
forwarded by a remote server). For a forwarded command,
FWDUSER refers to the authentication information for the
server doing the forwarding.</p>

<p style="margin-top: 1em">3. For example, to reject
non-authenticated operations, the following line could be
put in the permissions file. <br>
REJECT AUTH=NONE</p>

<p style="margin-top: 1em">4. To reject server forwarded
authentication as well, we use REJECT AUTH=NONE,FWD. If a
remote server with name serverhost has id information
FFEDBEEFDEAF, then the following <br>
will accept only forwarded jobs from this server. <br>
ACCEPT FWDUSER=FFEDBEEFDEAF REMOTEHOST=serverhost <br>
REJECT AUTH=FWD</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
The lpd action can also be manipulated by using environment
variables.</p>

<p style="margin-top: 1em">LPR_TMP</p>

<p style="margin-top: 1em">Authentication <br>
MD5KEYFILE <br>
Used for md5 signated file transmission</p>

<p style="margin-top: 1em">FILES <br>
The files used by LPRng are set by values in the printer
configuration file. The following are a commonly used set of
default values. <br>
/etc/lprng/lpd.conf LPRng configuration file <br>
${HOME}/.printcap user printer description file <br>
/etc/printcap printer description file <br>
/etc/lprng/lpd.perms permissions <br>
/var/run/lprng/lpd lock file for queue control <br>
/var/spool/lpd spool directories <br>
/var/spool/lpd/QUEUE/control queue control <br>
/var/spool/lpd/QUEUE/log trace or debug log file <br>
/var/spool/lpd/QUEUE/acct accounting file <br>
/var/spool/lpd/QUEUE/status status file</p>

<p style="margin-top: 1em">SEE ALSO <br>
lpd.conf(5), lpc(8), checkpc(8), lpr(1), lpq(1), lprm(1),
printcap(5), lpd.perms(5), pr(1).</p>

<p style="margin-top: 1em">AUTHOR <br>
Patrick Powell &lt;papowell@lprng.com&gt;.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
Most of the diagnostics are self explanatory. If you are
puzzled over the exact cause of failure, set the debugging
level on (-D5) and run again. The debugging information will
<br>
help you to pinpoint the exact cause of failure.</p>

<p style="margin-top: 1em">HISTORY <br>
LPRng is a enhanced printer spooler system with
functionality similar to the Berkeley LPR software. The
LPRng developer mailing list is
lprng-devel@lists.sourceforge.net; <br>
subscribe by visiting
https://lists.sourceforge.net/lists/listinfo/lprng-devel or
sending mail to lprng-request@lists.sourceforge.net with the
word subscribe in the body. <br>
The software is available via
http://lprng.sourceforge.net</p>

<p style="margin-top: 1em">LPRng 2008-03-14 LPD(8)</p>
<hr>
</body>
</html>
