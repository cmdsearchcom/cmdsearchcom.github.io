<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>OPENSM(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">OPENSM(8)</td>
    <td class="head-vol">OpenIB Management</td>
    <td class="head-rtitle">OPENSM(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
opensm - InfiniBand subnet manager and administration (SM/SA)
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>opensm</b> [--version]] [-F | --config &lt;file_name&gt;] [-c |
  --create-config &lt;file_name&gt;] [-g | --guid &lt;GUID in hex&gt;] [-l |
  --lmc &lt;LMC&gt;] [-p | --priority &lt;PRIORITY&gt;] [--subnet_prefix
  &lt;PREFIX in hex&gt;] [--smkey &lt;SM_Key&gt;] [--sm_sl &lt;SL number&gt;]
  [-r | --reassign_lids] [-R &lt;engine name(s)&gt; | --routing_engine
  &lt;engine name(s)&gt;] [--do_mesh_analysis] [--lash_start_vl &lt;vl
  number&gt;] [-A | --ucast_cache] [-z | --connect_roots] [-M &lt;file name&gt;
  | --lid_matrix_file &lt;file name&gt;] [-U &lt;file name&gt; | --lfts_file
  &lt;file name&gt;] [-S | --sadb_file &lt;file name&gt;] [-a | --root_guid_file
  &lt;path to file&gt;] [-u | --cn_guid_file &lt;path to file&gt;] [-G |
  --io_guid_file &lt;path to file&gt;] [--port-shifting] [--scatter-ports
  &lt;random seed&gt;] [-H | --max_reverse_hops &lt;max reverse hops
  allowed&gt;] [-X | --guid_routing_order_file &lt;path to file&gt;] [-m |
  --ids_guid_file &lt;path to file&gt;] [-o | --once] [-s | --sweep
  &lt;interval&gt;] [-t | --timeout &lt;milliseconds&gt;] [--retries
  &lt;number&gt;] [--maxsmps &lt;number&gt;] [--console [off | local | socket |
  loopback]] [--console-port &lt;port&gt;] [-i | --ignore-guids
  &lt;equalize-ignore-guids-file&gt;] [-w | --hop_weights_file &lt;path to
  file&gt;] [-O | --port_search_ordering_file &lt;path to file&gt;] [-O |
  --dimn_ports_file &lt;path to file&gt;] (DEPRECATED) [-f | --log_file &lt;log
  file path&gt; ] [-L | --log_limit &lt;size in MB&gt;] [-e | --erase_log_file]
  [-P | --Pconfig &lt;partition config file&gt; ] [-N | --no_part_enforce]
  (DEPRECATED) [-Z | --part_enforce [both | in | out | off]] [-W |
  --allow_both_pkeys] [-Q | --qos [-Y | --qos_policy_file &lt;file name&gt;]]
  [--congestion-control] [--cckey &lt;key&gt;] [-y | --stay_on_fatal] [-B |
  --daemon] [-J | --pidfile &lt;file_name&gt;] [-I | --inactive] [--perfmgr]
  [--perfmgr_sweep_time_s &lt;seconds&gt;] [--prefix_routes_file &lt;path&gt;]
  [--consolidate_ipv6_snm_req] [--log_prefix &lt;prefix text&gt;]
  [--torus_config &lt;path to file&gt;] [-v | --verbose] [-V] [-D &lt;flags&gt;]
  [-d | --debug &lt;number&gt;] [-h | -? | --help]
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
opensm is an InfiniBand compliant Subnet Manager and Administration, and runs on
  top of OpenIB.
<div style="height: 1.00em;">&#x00A0;</div>
opensm provides an implementation of an InfiniBand Subnet Manager and
  Administration. Such a software entity is required to run for in order to
  initialize the InfiniBand hardware (at least one per each InfiniBand subnet).
<div style="height: 1.00em;">&#x00A0;</div>
opensm also now contains an experimental version of a performance manager as
  well.
<div style="height: 1.00em;">&#x00A0;</div>
opensm defaults were designed to meet the common case usage on clusters with up
  to a few hundred nodes. Thus, in this default mode, opensm will scan the IB
  fabric, initialize it, and sweep occasionally for changes.
<div style="height: 1.00em;">&#x00A0;</div>
opensm attaches to a specific IB port on the local machine and configures only
  the fabric connected to it. (If the local machine has other IB ports, opensm
  will ignore the fabrics connected to those other ports). If no port is
  specified, it will select the first &quot;best&quot; available port.
<div style="height: 1.00em;">&#x00A0;</div>
opensm can present the available ports and prompt for a port number to attach
  to.
<div style="height: 1.00em;">&#x00A0;</div>
By default, the run is logged to two files: /var/log/messages and
  /var/log/opensm.log. The first file will register only general major events,
  whereas the second will include details of reported errors. All errors
  reported in this second file should be treated as indicators of IB fabric
  health issues. (Note that when a fatal and non-recoverable error occurs,
  opensm will exit.) Both log files should include the message &quot;SUBNET
  UP&quot; if opensm was able to setup the subnet correctly.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag">Prints OpenSM version and exits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-F</b>, <b>--config</b> &lt;config file&gt;</dt>
  <dd class="It-tag">The name of the OpenSM config file. When not specified <b>
      /etc/rdma/opensm.conf</b> will be used (if exists).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b>, <b>--create-config</b> &lt;file name&gt;</dt>
  <dd class="It-tag">OpenSM will dump its configuration to the specified file
      and exit. This is a way to generate OpenSM configuration file
    template.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b>, <b>--guid</b> &lt;GUID in hex&gt;</dt>
  <dd class="It-tag">This option specifies the local port GUID value with which
      OpenSM should bind. OpenSM may be bound to 1 port at a time. If GUID given
      is 0, OpenSM displays a list of possible port GUIDs and waits for user
      input. Without -g, OpenSM tries to use the default port.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b>, <b>--lmc</b> &lt;LMC value&gt;</dt>
  <dd class="It-tag">This option specifies the subnet's LMC value. The number of
      LIDs assigned to each port is 2^LMC. The LMC value must be in the range
      0-7. LMC values &gt; 0 allow multiple paths between ports. LMC values &gt;
      0 should only be used if the subnet topology actually provides multiple
      paths between ports, i.e. multiple interconnects between switches. Without
      -l, OpenSM defaults to LMC = 0, which allows one path between any two
      ports.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b>, <b>--priority</b> &lt;Priority value&gt;</dt>
  <dd class="It-tag">This option specifies the SM&#x00B4;s PRIORITY. This will
      effect the handover cases, where master is chosen by priority and GUID.
      Range goes from 0 (default and lowest priority) to 15 (highest).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--subnet_prefix</b> &lt;PREFIX in hex&gt;</dt>
  <dd class="It-tag">This option specifies the subnet prefix to use on the
      fabric. The default prefix is 0xfe80000000000000. OpenMPI in particular
      requires separate fabrics plugged into different ports to have different
      prefixes or else it won't run.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--smkey</b> &lt;SM_Key value&gt;</dt>
  <dd class="It-tag">This option specifies the SM&#x00B4;s SM_Key (64 bits).
      This will effect SM authentication. Note that OpenSM version 3.2.1 and
      below used the default value '1' in a host byte order, it is fixed now but
      you may need this option to interoperate with old OpenSM running on a
      little endian machine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sm_sl</b> &lt;SL number&gt;</dt>
  <dd class="It-tag">This option sets the SL to use for communication with the
      SM/SA. Defaults to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b>, <b>--reassign_lids</b></dt>
  <dd class="It-tag">This option causes OpenSM to reassign LIDs to all end
      nodes. Specifying -r on a running subnet may disrupt subnet traffic.
      Without -r, OpenSM attempts to preserve existing LID assignments resolving
      multiple use of same LID.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b>, <b>--routing_engine</b> &lt;Routing engine
    names&gt;</dt>
  <dd class="It-tag">This option chooses routing engine(s) to use instead of Min
      Hop algorithm (default). Multiple routing engines can be specified
      separated by commas so that specific ordering of routing algorithms will
      be tried if earlier routing engines fail. If all configured routing
      engines fail, OpenSM will always attempt to route with Min Hop unless
      'no_fallback' is included in the list of routing engines. Supported
      engines: minhop, updn, dnup, file, ftree, lash, dor, torus-2QoS, dfsssp,
      sssp.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--do_mesh_analysis</b></dt>
  <dd class="It-tag">This option enables additional analysis for the lash
      routing engine to precondition switch port assignments in regular
      cartesian meshes which may reduce the number of SLs required to give a
      deadlock free routing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lash_start_vl</b> &lt;vl number&gt;</dt>
  <dd class="It-tag">This option sets the starting VL to use for the lash
      routing algorithm. Defaults to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b>, <b>--ucast_cache</b></dt>
  <dd class="It-tag">This option enables unicast routing cache and prevents
      routing recalculation (which is a heavy task in a large cluster) when
      there was no topology change detected during the heavy sweep, or when the
      topology change does not require new routing calculation, e.g. when one or
      more CAs/RTRs/leaf switches going down, or one or more of these nodes
      coming back after being down. A very common case that is handled by the
      unicast routing cache is host reboot, which otherwise would cause two full
      routing recalculations: one when the host goes down, and the other when
      the host comes back online.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-z</b>, <b>--connect_roots</b></dt>
  <dd class="It-tag">This option enforces routing engines (up/down and fat-tree)
      to make connectivity between root switches and in this way to be fully IBA
      compliant. In many cases this can violate &quot;pure&quot; deadlock free
      algorithm, so use it carefully.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b>, <b>--lid_matrix_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">This option specifies the name of the lid matrix dump file
      from where switch lid matrices (min hops tables will be loaded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-U</b>, <b>--lfts_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">This option specifies the name of the LFTs file from where
      switch forwarding tables will be loaded when using &quot;file&quot;
      routing engine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b>, <b>--sadb_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">This option specifies the name of the SA DB dump file from
      where SA database will be loaded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b>, <b>--root_guid_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">Set the root nodes for the Up/Down or Fat-Tree routing
      algorithm to the guids provided in the given file (one to a line).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u</b>, <b>--cn_guid_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">Set the compute nodes for the Fat-Tree or DFSSSP/SSSP
      routing algorithms to the port GUIDs provided in the given file (one to a
      line).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-G</b>, <b>--io_guid_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">Set the I/O nodes for the Fat-Tree or DFSSSP/SSSP routing
      algorithms to the port GUIDs provided in the given file (one to a line).
    <div>&#x00A0;</div>
    In the case of Fat-Tree routing:
    <div>&#x00A0;</div>
    I/O nodes are non-CN nodes allowed to use up to max_reverse_hops switches
      the wrong way around to improve connectivity.
    <div>&#x00A0;</div>
    In the case of (DF)SSSP routing:
    <div>&#x00A0;</div>
    Providing guids of compute and/or I/O nodes will ensure that paths towards
      those nodes are as much separated as possible within their node category,
      i.e., I/O traffic will not share the same link if multiple links are
      available.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--port-shifting</b></dt>
  <dd class="It-tag">This option enables a feature called <b>port shifting</b>.
      In some fabrics, particularly cluster environments, routes commonly align
      and congest with other routes due to algorithmically unchanging traffic
      patterns. This routing option will &quot;shift&quot; routing around in an
      attempt to alleviate this problem.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--scatter-ports</b> &lt;random seed&gt;</dt>
  <dd class="It-tag">This option is used to randomize port selection in routing
      rather than using a round-robin algorithm (which is the default). Value
      supplied with option is used as a random seed. If value is 0, which is the
      default, the scatter ports option is disabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-H</b>, <b>--max_reverse_hops</b> &lt;max reverse hops
    allowed&gt;</dt>
  <dd class="It-tag">Set the maximum number of reverse hops an I/O node is
      allowed to make. A reverse hop is the use of a switch the wrong way
      around.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m</b>, <b>--ids_guid_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">Name of the map file with set of the IDs which will be used
      by Up/Down routing algorithm instead of node GUIDs (format: &lt;guid&gt;
      &lt;id&gt; per line).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-X</b>, <b>--guid_routing_order_file</b> &lt;file
    name&gt;</dt>
  <dd class="It-tag">Set the order port guids will be routed for the MinHop and
      Up/Down routing algorithms to the guids provided in the given file (one to
      a line).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b>, <b>--once</b></dt>
  <dd class="It-tag">This option causes OpenSM to configure the subnet once,
      then exit. Ports remain in the ACTIVE state.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b>, <b>--sweep</b> &lt;interval value&gt;</dt>
  <dd class="It-tag">This option specifies the number of seconds between subnet
      sweeps. Specifying -s 0 disables sweeping. Without -s, OpenSM defaults to
      a sweep interval of 10 seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b>, <b>--timeout</b> &lt;value&gt;</dt>
  <dd class="It-tag">This option specifies the time in milliseconds used for
      transaction timeouts. Timeout values should be &gt; 0. Without -t, OpenSM
      defaults to a timeout value of 200 milliseconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--retries</b> &lt;number&gt;</dt>
  <dd class="It-tag">This option specifies the number of retries used for
      transactions. Without --retries, OpenSM defaults to 3 retries for
      transactions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maxsmps</b> &lt;number&gt;</dt>
  <dd class="It-tag">This option specifies the number of VL15 SMP MADs allowed
      on the wire at any one time. Specifying --maxsmps 0 allows unlimited
      outstanding SMPs. Without --maxsmps, OpenSM defaults to a maximum of 4
      outstanding SMPs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--console [off | local | loopback | socket]</b></dt>
  <dd class="It-tag">This option brings up the OpenSM console (default off).
      Note, loopback and socket open a socket which can be connected to WITHOUT
      CREDENTIALS. Loopback is safer if access to your SM host is controlled.
      tcp_wrappers (hosts.[allow|deny]) is used with loopback and socket.
      loopback and socket will only be available if OpenSM was built with
      --enable-console-loopback (default yes) and --enable-console-socket
      (default no) respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--console-port</b> &lt;port&gt;</dt>
  <dd class="It-tag">Specify an alternate telnet port for the socket console
      (default 10000). Note that this option only appears if OpenSM was built
      with --enable-console-socket.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b>, <b>--ignore-guids</b>
    &lt;equalize-ignore-guids-file&gt;</dt>
  <dd class="It-tag">This option provides the means to define a set of ports (by
      node guid and port number) that will be ignored by the link load
      equalization algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b>, <b>--hop_weights_file</b> &lt;path to
    file&gt;</dt>
  <dd class="It-tag">This option provides weighting factors per port
      representing a hop cost in computing the lid matrix. The file consists of
      lines containing a switch port GUID (specified as a 64 bit hex number,
      with leading 0x), output port number, and weighting factor. Any port not
      listed in the file defaults to a weighting factor of 1. Lines starting
      with # are comments. Weights affect only the output route from the port,
      so many useful configurations will require weights to be specified in
      pairs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-O</b>, <b>--port_search_ordering_file</b> &lt;path to
    file&gt;</dt>
  <dd class="It-tag">This option tweaks the routing. It suitable for two cases:
      1. While using DOR routing algorithm. This option provides a mapping
      between hypercube dimensions and ports on a per switch basis for the DOR
      routing engine. The file consists of lines containing a switch node GUID
      (specified as a 64 bit hex number, with leading 0x) followed by a list of
      non-zero port numbers, separated by spaces, one switch per line. The order
      for the port numbers is in one to one correspondence to the dimensions.
      Ports not listed on a line are assigned to the remaining dimensions, in
      port order. Anything after a # is a comment. 2. While using general
      routing algorithm. This option provides the order of the ports that would
      be chosen for routing, from each switch rather than searching for an
      appropriate port from port 1 to N. The file consists of lines containing a
      switch node GUID (specified as a 64 bit hex number, with leading 0x)
      followed by a list of non-zero port numbers, separated by spaces, one
      switch per line. In case of DOR, the order for the port numbers is in one
      to one correspondence to the dimensions. Ports not listed on a line are
      assigned to the remaining dimensions, in port order. Anything after a # is
      a comment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-O</b>, <b>--dimn_ports_file</b> &lt;path to file&gt;
    <b>(DEPRECATED)</b></dt>
  <dd class="It-tag">This is a deprecated flag. Please use
      <b>--port_search_ordering_file</b> instead. This option provides a mapping
      between hypercube dimensions and ports on a per switch basis for the DOR
      routing engine. The file consists of lines containing a switch node GUID
      (specified as a 64 bit hex number, with leading 0x) followed by a list of
      non-zero port numbers, separated by spaces, one switch per line. The order
      for the port numbers is in one to one correspondence to the dimensions.
      Ports not listed on a line are assigned to the remaining dimensions, in
      port order. Anything after a # is a comment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b>, <b>--honor_guid2lid</b></dt>
  <dd class="It-tag">This option forces OpenSM to honor the guid2lid file, when
      it comes out of Standby state, if such file exists under OSM_CACHE_DIR,
      and is valid. By default, this is FALSE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b>, <b>--log_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">This option defines the log to be the given file. By
      default, the log goes to /var/log/opensm.log. For the log to go to
      standard output use -f stdout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b>, <b>--log_limit</b> &lt;size in MB&gt;</dt>
  <dd class="It-tag">This option defines maximal log file size in MB. When
      specified the log file will be truncated upon reaching this limit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b>, <b>--erase_log_file</b></dt>
  <dd class="It-tag">This option will cause deletion of the log file (if it
      previously exists). By default, the log file is accumulative.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b>, <b>--Pconfig</b> &lt;partition config
    file&gt;</dt>
  <dd class="It-tag">This option defines the optional partition configuration
      file. The default name is <b>/etc/rdma/partitions.conf</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--prefix_routes_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">Prefix routes control how the SA responds to path record
      queries for off-subnet DGIDs. By default, the SA fails such queries. The
      <b>PREFIX ROUTES</b> section below describes the format of the
      configuration file. The default path is
      <b>/etc/rdma/prefix-routes.conf</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Q</b>, <b>--qos</b></dt>
  <dd class="It-tag">This option enables QoS setup. It is disabled by
    default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Y</b>, <b>--qos_policy_file</b> &lt;file name&gt;</dt>
  <dd class="It-tag">This option defines the optional QoS policy file. The
      default name is <b>/etc/rdma/qos-policy.conf</b>. See
      QoS_management_in_OpenSM.txt in opensm doc for more information on
      configuring QoS policy via this file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--congestion_control</b></dt>
  <dd class="It-tag">(EXPERIMENTAL) This option enables congestion control
      configuration. It is disabled by default. See config file for congestion
      control configuration options. <b>--cc_key</b> &lt;key&gt; (EXPERIMENTAL)
      This option configures the CCkey to use when configuring congestion
      control. Note that this option does not configure a new CCkey into
      switches and CAs. Defaults to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b>, <b>--no_part_enforce</b>
    <b>(DEPRECATED)</b></dt>
  <dd class="It-tag">This is a deprecated flag. Please use <b>--part_enforce</b>
      instead. This option disables partition enforcement on switch external
      ports.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Z</b>, <b>--part_enforce</b> [both | in | out |
    off]</dt>
  <dd class="It-tag">This option indicates the partition enforcement type (for
      switches). Enforcement type can be inbound only (in), outbound only (out),
      both or disabled (off). Default is both.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-W</b>, <b>--allow_both_pkeys</b></dt>
  <dd class="It-tag">This option indicates whether both full and limited
      membership on the same partition can be configured in the PKeyTable.
      Default is not to allow both pkeys.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-y</b>, <b>--stay_on_fatal</b></dt>
  <dd class="It-tag">This option will cause SM not to exit on fatal
      initialization issues: if SM discovers duplicated guids or a 12x link with
      lane reversal badly configured. By default, the SM will exit on these
      errors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B</b>, <b>--daemon</b></dt>
  <dd class="It-tag">Run in daemon mode - OpenSM will run in the
    background.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-J</b>, <b>--pidfile &lt;file_name&gt;</b></dt>
  <dd class="It-tag">Makes the SM write its own PID to the specified file when
      started in daemon mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b>, <b>--inactive</b></dt>
  <dd class="It-tag">Start SM in inactive rather than init SM state. This option
      can be used in conjunction with the perfmgr so as to run a standalone
      performance manager without SM/SA. However, this is NOT currently
      implemented in the performance manager.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--perfmgr</b></dt>
  <dd class="It-tag">Enable the perfmgr. Only takes effect if --enable-perfmgr
      was specified at configure time. See performance-manager-HOWTO.txt in
      opensm doc for more information on running perfmgr.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--perfmgr_sweep_time_s</b> &lt;seconds&gt;</dt>
  <dd class="It-tag">Specify the sweep time for the performance manager in
      seconds (default is 180 seconds). Only takes effect if --enable-perfmgr
      was specified at configure time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--consolidate_ipv6_snm_req</b></dt>
  <dd class="It-tag">Use shared MLID for IPv6 Solicited Node Multicast groups
      per MGID scope and P_Key.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log_prefix</b> &lt;prefix text&gt;</dt>
  <dd class="It-tag">This option specifies the prefix to the syslog messages
      from OpenSM. A suitable prefix can be used to identify the IB subnet in
      syslog messages when two or more instances of OpenSM run in a single node
      to manage multiple fabrics. For example, in a dual-fabric (or dual-rail)
      IB cluster, the prefix for the first fabric could be &quot;mpi&quot; and
      the other fabric could be &quot;storage&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--torus_config</b> &lt;path to torus-2QoS config
    file&gt;</dt>
  <dd class="It-tag">This option defines the file name for the extra
      configuration information needed for the torus-2QoS routing engine. The
      default name is <b>/etc/rdma/torus-2QoS.conf</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b>, <b>--verbose</b></dt>
  <dd class="It-tag">This option increases the log verbosity level. The -v
      option may be specified multiple times to further increase the verbosity
      level. See the -D option for more information about log verbosity.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag">This option sets the maximum verbosity level and forces log
      flushing. The -V option is equivalent to &#x00B4;-D 0xFF -d 2&#x00B4;. See
      the -D option for more information about log verbosity.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b> &lt;value&gt;</dt>
  <dd class="It-tag">This option sets the log verbosity level. A flags field
      must follow the -D option. A bit set/clear in the flags enables/disables a
      specific log level as follows:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     BIT LOG LEVEL ENABLED
    <br/>
     ---- -----------------
    <br/>
     0x01 - ERROR (error messages)
    <br/>
     0x02 - INFO (basic messages, low volume)
    <br/>
     0x04 - VERBOSE (interesting stuff, moderate volume)
    <br/>
     0x08 - DEBUG (diagnostic, high volume)
    <br/>
     0x10 - FUNCS (function entry/exit, very high volume)
    <br/>
     0x20 - FRAMES (dumps all SMP and GMP frames)
    <br/>
     0x40 - ROUTING (dump FDB routing information)
    <br/>
     0x80 - SYS (syslog at LOG_INFO level in addition to OpenSM logging)
    <div style="height: 1.00em;">&#x00A0;</div>
    Without -D, OpenSM defaults to ERROR + INFO (0x3). Specifying -D 0 disables
      all messages. Specifying -D 0xFF enables all messages (see -V). High
      verbosity levels may require increasing the transaction timeout with the
      -t option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b>, <b>--debug</b> &lt;value&gt;</dt>
  <dd class="It-tag">This option specifies a debug option. These options are not
      normally needed. The number following -d selects the debug option to
      enable as follows:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     OPT Description
    <br/>
     --- -----------------
    <br/>
     -d0 - Ignore other SM nodes
    <br/>
     -d1 - Force single threaded dispatching
    <br/>
     -d2 - Force log flushing after each log message
    <br/>
     -d3 - Disable multicast support</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>, <b>--help</b>, <b>-?</b></dt>
  <dd class="It-tag">Display this usage info then exit.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="ENVIRONMENT_VARIABLES"><a class="selflink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
The following environment variables control opensm behavior:
<div style="height: 1.00em;">&#x00A0;</div>
OSM_TMP_DIR - controls the directory in which the temporary files generated by
  opensm are created. These files are: opensm-subnet.lst, opensm.fdbs, and
  opensm.mcfdbs. By default, this directory is /var/log.
<div style="height: 1.00em;">&#x00A0;</div>
OSM_CACHE_DIR - opensm stores certain data to the disk such that subsequent runs
  are consistent. The default directory used is /var/cache/opensm. The following
  files are included in it:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 guid2lid - stores the LID range assigned to each GUID
<br/>
 guid2mkey - stores the MKey previously assiged to each GUID
<br/>
 neighbors - stores a map of the GUIDs at either end of each link
<br/>
 in the fabric
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
When opensm receives a HUP signal, it starts a new heavy sweep as if a trap was
  received or a topology change was found.
<div class="Pp"></div>
Also, SIGUSR1 can be used to trigger a reopen of /var/log/opensm.log for
  logrotate purposes.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="PARTITION_CONFIGURATION"><a class="selflink" href="#PARTITION_CONFIGURATION">PARTITION
  CONFIGURATION</a></h1>
The default name of OpenSM partitions configuration file is
  <b>/etc/rdma/partitions.conf</b>. The default may be changed by using the
  --Pconfig (-P) option with OpenSM.
<div style="height: 1.00em;">&#x00A0;</div>
The default partition will be created by OpenSM unconditionally even when
  partition configuration file does not exist or cannot be accessed.
<div style="height: 1.00em;">&#x00A0;</div>
The default partition has P_Key value 0x7fff. OpenSM&#x00B4;s port will always
  have full membership in default partition. All other end ports will have full
  membership if the partition configuration file is not found or cannot be
  accessed, or limited membership if the file exists and can be accessed but
  there is no rule for the Default partition.
<div style="height: 1.00em;">&#x00A0;</div>
Effectively, this amounts to the same as if one of the following rules below
  appear in the partition configuration file.
<div style="height: 1.00em;">&#x00A0;</div>
In the case of no rule for the Default partition:
<div style="height: 1.00em;">&#x00A0;</div>
Default=0x7fff : ALL=limited, SELF=full ;
<div style="height: 1.00em;">&#x00A0;</div>
In the case of no partition configuration file or file cannot be accessed:
<div style="height: 1.00em;">&#x00A0;</div>
Default=0x7fff : ALL=full ;
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
File Format
<div style="height: 1.00em;">&#x00A0;</div>
Comments:
<div style="height: 1.00em;">&#x00A0;</div>
Line content followed after &#x00B4;#&#x00B4; character is comment and ignored
  by parser.
<div style="height: 1.00em;">&#x00A0;</div>
General file format:
<div style="height: 1.00em;">&#x00A0;</div>
&lt;Partition Definition&gt;:[&lt;newline&gt;]&lt;Partition Properties&gt;;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Partition Definition:
<br/>
 [PartitionName][=PKey][,ipoib_bc_flags][,defmember=full|limited]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 PartitionName - string, will be used with logging. When
<br/>
 omitted, empty string will be used.
<br/>
 PKey - P_Key value for this partition. Only low 15
<br/>
 bits will be used. When omitted will be
<br/>
 autogenerated.
<br/>
 ipoib_bc_flags - used to indicate/specify IPoIB capability of
<br/>
 this partition.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 defmember=full|limited|both - specifies default membership for
<br/>
 port guid list. Default is limited.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 ipoib_bc_flags:
<br/>
 ipoib_flag|[mgroup_flag]*
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 ipoib_flag:
<br/>
 ipoib - indicates that this partition may be used for
<br/>
 IPoIB, as a result the IPoIB broadcast group will
<br/>
 be created with the mgroup_flag flags given,
<br/>
 if any.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Partition Properties:
<br/>
 [&lt;Port list&gt;|&lt;MCast Group&gt;]* | &lt;Port list&gt;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Port list:
<br/>
 &lt;Port Specifier&gt;[,&lt;Port Specifier&gt;]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Port Specifier:
<br/>
 &lt;PortGUID&gt;[=[full|limited|both]]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 PortGUID - GUID of partition member EndPort.
<br/>
 Hexadecimal numbers should start from
<br/>
 0x, decimal numbers are accepted too.
<br/>
 full, limited, - indicates full and/or limited membership for
<br/>
 both this port. When omitted (or unrecognized)
<br/>
 limited membership is assumed. Both
<br/>
 indicates both full and limited membership
<br/>
 for this port.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 MCast Group:
<br/>
 mgid=gid[,mgroup_flag]*&lt;newline&gt;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 - gid specified is verified to be a Multicast
<br/>
 address. IP groups are verified to match
<br/>
 the rate and mtu of the broadcast group.
<br/>
 The P_Key bits of the mgid for IP groups are
<br/>
 verified to either match the P_Key specified
<br/>
 in by &quot;Partition Definition&quot; or if they are
<br/>
 0x0000 the P_Key will be copied into those
<br/>
 bits.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 mgroup_flag:
<br/>
 rate=&lt;val&gt; - specifies rate for this MC group
<br/>
 (default is 3 (10GBps))
<br/>
 mtu=&lt;val&gt; - specifies MTU for this MC group
<br/>
 (default is 4 (2048))
<br/>
 sl=&lt;val&gt; - specifies SL for this MC group
<br/>
 (default is 0)
<br/>
 scope=&lt;val&gt; - specifies scope for this MC group
<br/>
 (default is 2 (link local)). Multiple scope
<br/>
 settings are permitted for a partition.
<br/>
 NOTE: This overwrites the scope nibble of the
<br/>
 specified mgid. Furthermore specifying
<br/>
 multiple scope settings will result in
<br/>
 multiple MC groups being created.
<br/>
 Q_Key=&lt;val&gt; - specifies the Q_Key for this MC group
<br/>
 (default: 0x0b1b for IP groups, 0 for other
<br/>
 groups)
<br/>
 WARNING: changing this for the broadcast
<br/>
 group may break IPoIB on client
<br/>
 nodes!!
<br/>
 TClass=&lt;val&gt; - specifies tclass for this MC group
<br/>
 (default is 0)
<br/>
 FlowLabel=&lt;val&gt; - specifies FlowLabel for this MC group
<br/>
 (default is 0)
<div style="height: 1.00em;">&#x00A0;</div>
Note that values for rate, mtu, and scope, for both partitions and multicast
  groups, should be specified as defined in the IBTA specification (for example,
  mtu=4 for 2048).
<div style="height: 1.00em;">&#x00A0;</div>
There are several useful keywords for PortGUID definition:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 - 'ALL' means all end ports in this subnet.
<br/>
 - 'ALL_CAS' means all Channel Adapter end ports in this subnet.
<br/>
 - 'ALL_SWITCHES' means all Switch end ports in this subnet.
<br/>
 - 'ALL_ROUTERS' means all Router end ports in this subnet.
<br/>
 - 'SELF' means subnet manager's port.
<div style="height: 1.00em;">&#x00A0;</div>
Empty list means no ports in this partition.
<div style="height: 1.00em;">&#x00A0;</div>
Notes:
<div style="height: 1.00em;">&#x00A0;</div>
White space is permitted between delimiters ('=', ',',':',';').
<div style="height: 1.00em;">&#x00A0;</div>
PartitionName does not need to be unique, PKey does need to be unique. If PKey
  is repeated then those partition configurations will be merged and first
  PartitionName will be used (see also next note).
<div style="height: 1.00em;">&#x00A0;</div>
It is possible to split partition configuration in more than one definition, but
  then PKey should be explicitly specified (otherwise different PKey values will
  be generated for those definitions).
<div style="height: 1.00em;">&#x00A0;</div>
Examples:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Default=0x7fff : ALL, SELF=full ;
<br/>
 Default=0x7fff : ALL, ALL_SWITCHES=full, SELF=full ;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 NewPartition , ipoib : 0x123456=full, 0x3456789034=limi, 0x2134af2306 ;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 YetAnotherOne = 0x300 : SELF=full ;
<br/>
 YetAnotherOne = 0x300 : ALL=limited ;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 ShareIO = 0x80 , defmember=full : 0x123451, 0x123452;
<br/>
 # 0x123453, 0x123454 will be limited
<br/>
 ShareIO = 0x80 : 0x123453, 0x123454, 0x123455=full;
<br/>
 # 0x123456, 0x123457 will be limited
<br/>
 ShareIO = 0x80 : defmember=limited : 0x123456, 0x123457, 0x123458=full;
<br/>
 ShareIO = 0x80 , defmember=full : 0x123459, 0x12345a;
<br/>
 ShareIO = 0x80 , defmember=full : 0x12345b, 0x12345c=limited, 0x12345d;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 # multicast groups added to default
<br/>
 Default=0x7fff,ipoib:
<br/>
 mgid=ff12:401b::0707,sl=1 # random IPv4 group
<br/>
 mgid=ff12:601b::16 # MLDv2-capable routers
<br/>
 mgid=ff12:401b::16 # IGMP
<br/>
 mgid=ff12:601b::2 # All routers
<br/>
 mgid=ff12::1,sl=1,Q_Key=0xDEADBEEF,rate=3,mtu=2 # random group
<br/>
 ALL=full;
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
Note:
<div style="height: 1.00em;">&#x00A0;</div>
The following rule is equivalent to how OpenSM used to run prior to the
  partition manager:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Default=0x7fff,ipoib:ALL=full;
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="QOS_CONFIGURATION"><a class="selflink" href="#QOS_CONFIGURATION">QOS
  CONFIGURATION</a></h1>
There are a set of QoS related low-level configuration parameters. All these
  parameter names are prefixed by &quot;qos_&quot; string. Here is a full list
  of these parameters:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 qos_max_vls - The maximum number of VLs that will be on the subnet
<br/>
 qos_high_limit - The limit of High Priority component of VL
<br/>
 Arbitration table (IBA 7.6.9)
<br/>
 qos_vlarb_low - Low priority VL Arbitration table (IBA 7.6.9)
<br/>
 template
<br/>
 qos_vlarb_high - High priority VL Arbitration table (IBA 7.6.9)
<br/>
 template
<br/>
 Both VL arbitration templates are pairs of
<br/>
 VL and weight
<br/>
 qos_sl2vl - SL2VL Mapping table (IBA 7.6.6) template. It is
<br/>
 a list of VLs corresponding to SLs 0-15 (Note
<br/>
 that VL15 used here means drop this SL)
<div style="height: 1.00em;">&#x00A0;</div>
Typical default values (hard-coded in OpenSM initialization) are:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 qos_max_vls 15
<br/>
 qos_high_limit 0
<br/>
 qos_vlarb_low 0:0,1:4,2:4,3:4,4:4,5:4,6:4,7:4,8:4,9:4,10:4,11:4,12:4,13:4,14:4
<br/>
 qos_vlarb_high 0:4,1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0
<br/>
 qos_sl2vl 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,7
<div style="height: 1.00em;">&#x00A0;</div>
The syntax is compatible with rest of OpenSM configuration options and values
  may be stored in OpenSM config file (cached options file).
<div style="height: 1.00em;">&#x00A0;</div>
In addition to the above, we may define separate QoS configuration parameters
  sets for various target types. As targets, we currently support CAs, routers,
  switch external ports, and switch's enhanced port 0. The names of such
  specialized parameters are prefixed by &quot;qos_&lt;type&gt;_&quot; string.
  Here is a full list of the currently supported sets:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 qos_ca_ - QoS configuration parameters set for CAs.
<br/>
 qos_rtr_ - parameters set for routers.
<br/>
 qos_sw0_ - parameters set for switches' port 0.
<br/>
 qos_swe_ - parameters set for switches' external ports.
<div style="height: 1.00em;">&#x00A0;</div>
Examples:
<br/>
 qos_sw0_max_vls=2
<br/>
 qos_ca_sl2vl=0,1,2,3,5,5,5,12,12,0,
<br/>
 qos_swe_high_limit=0
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="PREFIX_ROUTES"><a class="selflink" href="#PREFIX_ROUTES">PREFIX
  ROUTES</a></h1>
Prefix routes control how the SA responds to path record queries for off-subnet
  DGIDs. By default, the SA fails such queries. Note that IBA does not specify
  how the SA should obtain off-subnet path record information. The prefix routes
  configuration is meant as a stop-gap until the specification is completed.
<div class="Pp"></div>
Each line in the configuration file is a 64-bit prefix followed by a 64-bit
  GUID, separated by white space. The GUID specifies the router port on the
  local subnet that will handle the prefix. Blank lines are ignored, as is
  anything between a <b>#</b> character and the end of the line. The prefix and
  GUID are both in hex, the leading 0x is optional. Either, or both, can be
  wild-carded by specifying an asterisk instead of an explicit prefix or GUID.
<div class="Pp"></div>
When responding to a path record query for an off-subnet DGID, opensm searches
  for the first prefix match in the configuration file. Therefore, the order of
  the lines in the configuration file is important: a wild-carded prefix at the
  beginning of the configuration file renders all subsequent lines useless. If
  there is no match, then opensm fails the query. It is legal to repeat prefixes
  in the configuration file, opensm will return the path to the first available
  matching router. A configuration file with a single line where both prefix and
  GUID are wild-carded means that a path record query specifying any off-subnet
  DGID should return a path to the first available router. This configuration
  yields the same behavior formerly achieved by compiling opensm with
  -DROUTER_EXP which has been obsoleted.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="MKEY_CONFIGURATION"><a class="selflink" href="#MKEY_CONFIGURATION">MKEY
  CONFIGURATION</a></h1>
OpenSM supports configuring a single management key (MKey) for use across the
  subnet.
<div style="height: 1.00em;">&#x00A0;</div>
The following configuration options are available:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 m_key - the 64-bit MKey to be used on the subnet
<br/>
 (IBA 14.2.4)
<br/>
 m_key_protection_level - the numeric value of the MKey ProtectBits
<br/>
 (IBA 14.2.4.1)
<br/>
 m_key_lease_period - the number of seconds a CA will wait for a
<br/>
 response from the SM before resetting the
<br/>
 protection level to 0 (IBA 14.2.4.2).
<div style="height: 1.00em;">&#x00A0;</div>
OpenSM will configure all ports with the MKey specified by m_key, defaulting to
  a value of 0. A m_key value of 0 disables MKey protection on the subnet.
  Switches and HCAs with a non-zero MKey will not accept requests to change
  their configuration unless the request includes the proper MKey.
<div style="height: 1.00em;">&#x00A0;</div>
MKey Protection Levels
<div style="height: 1.00em;">&#x00A0;</div>
MKey protection levels modify how switches and CAs respond to SMPs lacking a
  valid MKey. OpenSM will configure each port's ProtectBits to support the level
  defined by the m_key_protection_level parameter. If no parameter is specified,
  OpenSM defaults to operating at protection level 0.
<div style="height: 1.00em;">&#x00A0;</div>
There are currently 4 protection levels defined by the IBA:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 0 - Queries return valid data, including MKey. Configuration changes
<br/>
 are not allowed unless the request contains a valid MKey.
<br/>
 1 - Like level 0, but the MKey is set to 0 (0x00000000) in queries,
<br/>
 unless the request contains a valid MKey.
<br/>
 2 - Neither queries nor configuration changes are allowed, unless the
<br/>
 request contains a valid MKey.
<br/>
 3 - Identical to 2. Maintained for backwards compatibility.
<div style="height: 1.00em;">&#x00A0;</div>
MKey Lease Period
<div style="height: 1.00em;">&#x00A0;</div>
InfiniBand supports a MKey lease timeout, which is intended to allow
  administrators or a new SM to recover/reset lost MKeys on a fabric.
<div style="height: 1.00em;">&#x00A0;</div>
If MKeys are enabled on the subnet and a switch or CA receives a request that
  requires a valid MKey but does not contain one, it warns the SM by sending a
  trap (Bad M_Key, Trap 256). If the MKey lease period is non-zero, it also
  starts a countdown timer for the time specified by the lease period. If a SM
  (or other agent) responds with the correct MKey, the timer is stopped and
  reset. Should the timer reach zero, the switch or CA will reset its MKey
  protection level to 0, exposing the MKey and allowing recovery.
<div style="height: 1.00em;">&#x00A0;</div>
OpenSM will initialize all ports to use a mkey lease period of the number of
  seconds specified in the config file. If no mkey_lease_period is specified, a
  default of 0 will be used.
<div style="height: 1.00em;">&#x00A0;</div>
OpenSM normally quickly responds to all Bad_M_Key traps, resetting the lease
  timers. Additionally, OpenSM's subnet sweeps will also cancel any running
  timers. For maximum protection against accidentally-exposed MKeys, the MKey
  lease time should be a few multiples of the subnet sweep time. If OpenSM
  detects at startup that your sweep interval is greater than your MKey lease
  period, it will reset the lease period to be greater than the sweep interval.
  Similarly, if sweeping is disabled at startup, it will be re-enabled with an
  interval less than the Mkey lease period.
<div style="height: 1.00em;">&#x00A0;</div>
If OpenSM is required to recover a subnet for which it is missing mkeys, it must
  do so one switch level at a time. As such, the total time to recover the
  subnet may be as long as the mkey lease period multiplied by the maximum
  number of hops between the SM and an endpoint, plus one.
<div style="height: 1.00em;">&#x00A0;</div>
MKey Effects on Diagnostic Utilities
<div style="height: 1.00em;">&#x00A0;</div>
Setting a MKey may have a detrimental effect on diagnostic software run on the
  subnet, unless your diagnostic software is able to retrieve MKeys from the SA
  or can be explicitly configured with the proper MKey. This is particularly
  true at protection level 2, where CAs will ignore queries for management
  information that do not contain the proper MKey.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="ROUTING"><a class="selflink" href="#ROUTING">ROUTING</a></h1>
OpenSM now offers nine routing engines:
<div style="height: 1.00em;">&#x00A0;</div>
1. Min Hop Algorithm - based on the minimum hops to each node where the path
  length is optimized.
<div style="height: 1.00em;">&#x00A0;</div>
2. UPDN Unicast routing algorithm - also based on the minimum hops to each node,
  but it is constrained to ranking rules. This algorithm should be chosen if the
  subnet is not a pure Fat Tree, and deadlock may occur due to a loop in the
  subnet.
<div style="height: 1.00em;">&#x00A0;</div>
3. DNUP Unicast routing algorithm - similar to UPDN but allows routing in
  fabrics which have some CA nodes attached closer to the roots than some switch
  nodes.
<div style="height: 1.00em;">&#x00A0;</div>
4. Fat Tree Unicast routing algorithm - this algorithm optimizes routing for
  congestion-free &quot;shift&quot; communication pattern. It should be chosen
  if a subnet is a symmetrical or almost symmetrical fat-tree of various types,
  not just K-ary-N-Trees: non-constant K, not fully staffed, any Constant
  Bisectional Bandwidth (CBB) ratio. Similar to UPDN, Fat Tree routing is
  constrained to ranking rules.
<div style="height: 1.00em;">&#x00A0;</div>
5. LASH unicast routing algorithm - uses Infiniband virtual layers (SL) to
  provide deadlock-free shortest-path routing while also distributing the paths
  between layers. LASH is an alternative deadlock-free topology-agnostic routing
  algorithm to the non-minimal UPDN algorithm avoiding the use of a potentially
  congested root node.
<div style="height: 1.00em;">&#x00A0;</div>
6. DOR Unicast routing algorithm - based on the Min Hop algorithm, but avoids
  port equalization except for redundant links between the same two switches.
  This provides deadlock free routes for hypercubes when the fabric is cabled as
  a hypercube and for meshes when cabled as a mesh (see details below).
<div style="height: 1.00em;">&#x00A0;</div>
7. Torus-2QoS unicast routing algorithm - a DOR-based routing algorithm
  specialized for 2D/3D torus topologies. Torus-2QoS provides deadlock-free
  routing while supporting two quality of service (QoS) levels. In addition it
  is able to route around multiple failed fabric links or a single failed fabric
  switch without introducing deadlocks, and without changing path SL values
  granted before the failure.
<div style="height: 1.00em;">&#x00A0;</div>
8. DFSSSP unicast routing algorithm - a deadlock-free
  single-source-shortest-path routing, which uses the SSSP algorithm (see
  algorithm 9.) as the base to optimize link utilization and uses Infiniband
  virtual lanes (SL) to provide deadlock-freedom.
<div style="height: 1.00em;">&#x00A0;</div>
9. SSSP unicast routing algorithm - a single-source-shortest-path routing
  algorithm, which globally balances the number of routes per link to optimize
  link utilization. This routing algorithm has no restrictions in terms of the
  underlying topology.
<div style="height: 1.00em;">&#x00A0;</div>
OpenSM also supports a file method which can load routes from a table. See
  &#x00B4;Modular Routing Engine&#x00B4; for more information on this.
<div style="height: 1.00em;">&#x00A0;</div>
The basic routing algorithm is comprised of two stages:
<div style="height: 1.00em;">&#x00A0;</div>
1. MinHop matrix calculation
<br/>
 How many hops are required to get from each port to each LID ?
<br/>
 The algorithm to fill these tables is different if you run standard (min hop)
  or Up/Down.
<br/>
 For standard routing, a &quot;relaxation&quot; algorithm is used to propagate
  min hop from every destination LID through neighbor switches
<br/>
 For Up/Down routing, a BFS from every target is used. The BFS tracks link
  direction (up or down) and avoid steps that will perform up after a down step
  was used.
<div style="height: 1.00em;">&#x00A0;</div>
2. Once MinHop matrices exist, each switch is visited and for each target LID a
  decision is made as to what port should be used to get to that LID.
<br/>
 This step is common to standard and Up/Down routing. Each port has a counter
  counting the number of target LIDs going through it.
<br/>
 When there are multiple alternative ports with same MinHop to a LID, the one
  with less previously assigned LIDs is selected.
<br/>
 If LMC &gt; 0, more checks are added: Within each group of LIDs assigned to
  same target port,
<br/>
 a. use only ports which have same MinHop
<br/>
 b. first prefer the ones that go to different systemImageGuid (then the
  previous LID of the same LMC group)
<br/>
 c. if none - prefer those which go through another NodeGuid
<br/>
 d. fall back to the number of paths method (if all go to same node).
<div style="height: 1.00em;">&#x00A0;</div>
Effect of Topology Changes
<div style="height: 1.00em;">&#x00A0;</div>
OpenSM will preserve existing routing in any case where there is no change in
  the fabric switches unless the -r (--reassign_lids) option is specified.
<div style="height: 1.00em;">&#x00A0;</div>
-r
<div>&#x00A0;</div>
--reassign_lids
<br/>
 This option causes OpenSM to reassign LIDs to all
<br/>
 end nodes. Specifying -r on a running subnet
<br/>
 may disrupt subnet traffic.
<br/>
 Without -r, OpenSM attempts to preserve existing
<br/>
 LID assignments resolving multiple use of same LID.
<div style="height: 1.00em;">&#x00A0;</div>
If a link is added or removed, OpenSM does not recalculate the routes that do
  not have to change. A route has to change if the port is no longer UP or no
  longer the MinHop. When routing changes are performed, the same algorithm for
  balancing the routes is invoked.
<div style="height: 1.00em;">&#x00A0;</div>
In the case of using the file based routing, any topology changes are currently
  ignored The 'file' routing engine just loads the LFTs from the file specified,
  with no reaction to real topology. Obviously, this will not be able to recheck
  LIDs (by GUID) for disconnected nodes, and LFTs for non-existent switches will
  be skipped. Multicast is not affected by 'file' routing engine (this uses min
  hop tables).
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
Min Hop Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
The Min Hop algorithm is invoked by default if no routing algorithm is
  specified. It can also be invoked by specifying '-R minhop'.
<div style="height: 1.00em;">&#x00A0;</div>
The Min Hop algorithm is divided into two stages: computation of min-hop tables
  on every switch and LFT output port assignment. Link subscription is also
  equalized with the ability to override based on port GUID. The latter is
  supplied by:
<div style="height: 1.00em;">&#x00A0;</div>
-i &lt;equalize-ignore-guids-file&gt;
<div>&#x00A0;</div>
--ignore-guids &lt;equalize-ignore-guids-file&gt;
<br/>
 This option provides the means to define a set of ports
<br/>
 (by guid) that will be ignored by the link load
<br/>
 equalization algorithm. Note that only endports (CA,
<br/>
 switch port 0, and router ports) and not switch external
<br/>
 ports are supported.
<div style="height: 1.00em;">&#x00A0;</div>
LMC awareness routes based on (remote) system or switch basis.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
Purpose of UPDN Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
The UPDN algorithm is designed to prevent deadlocks from occurring in loops of
  the subnet. A loop-deadlock is a situation in which it is no longer possible
  to send data between any two hosts connected through the loop. As such, the
  UPDN routing algorithm should be used if the subnet is not a pure Fat Tree,
  and one of its loops may experience a deadlock (due, for example, to high
  pressure).
<div style="height: 1.00em;">&#x00A0;</div>
The UPDN algorithm is based on the following main stages:
<div style="height: 1.00em;">&#x00A0;</div>
1. Auto-detect root nodes - based on the CA hop length from any switch in the
  subnet, a statistical histogram is built for each switch (hop num vs number of
  occurrences). If the histogram reflects a specific column (higher than others)
  for a certain node, then it is marked as a root node. Since the algorithm is
  statistical, it may not find any root nodes. The list of the root nodes found
  by this auto-detect stage is used by the ranking process stage.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Note 1: The user can override the node list manually.
<br/>
 Note 2: If this stage cannot find any root nodes, and the user did
<br/>
 not specify a guid list file, OpenSM defaults back to the
<br/>
 Min Hop routing algorithm.
<div style="height: 1.00em;">&#x00A0;</div>
2. Ranking process - All root switch nodes (found in stage 1) are assigned a
  rank of 0. Using the BFS algorithm, the rest of the switch nodes in the subnet
  are ranked incrementally. This ranking aids in the process of enforcing rules
  that ensure loop-free paths.
<div style="height: 1.00em;">&#x00A0;</div>
3. Min Hop Table setting - after ranking is done, a BFS algorithm is run from
  each (CA or switch) node in the subnet. During the BFS process, the FDB table
  of each switch node traversed by BFS is updated, in reference to the starting
  node, based on the ranking rules and guid values.
<div style="height: 1.00em;">&#x00A0;</div>
At the end of the process, the updated FDB tables ensure loop-free paths through
  the subnet.
<div style="height: 1.00em;">&#x00A0;</div>
Note: Up/Down routing does not allow LID routing communication between switches
  that are located inside spine &quot;switch systems&quot;. The reason is that
  there is no way to allow a LID route between them that does not break the
  Up/Down rule. One ramification of this is that you cannot run SM on switches
  other than the leaf switches of the fabric.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
UPDN Algorithm Usage
<div style="height: 1.00em;">&#x00A0;</div>
Activation through OpenSM
<div style="height: 1.00em;">&#x00A0;</div>
Use '-R updn' option (instead of old '-u') to activate the UPDN algorithm. Use
  '-a &lt;root_guid_file&gt;' for adding an UPDN guid file that contains the
  root nodes for ranking. If the `-a' option is not used, OpenSM uses its
  auto-detect root nodes algorithm.
<div style="height: 1.00em;">&#x00A0;</div>
Notes on the guid list file:
<div style="height: 1.00em;">&#x00A0;</div>
1. A valid guid file specifies one guid in each line. Lines with an invalid
  format will be discarded.
<div>&#x00A0;</div>
2. The user should specify the root switch guids. However, it is also possible
  to specify CA guids; OpenSM will use the guid of the switch (if it exists)
  that connects the CA to the subnet as a root node.
<div style="height: 1.00em;">&#x00A0;</div>
Purpose of DNUP Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
The DNUP algorithm is designed to serve a similar purpose to UPDN. However it is
  intended to work in network topologies which are unsuited to UPDN due to nodes
  being connected closer to the roots than some of the switches. An example
  would be a fabric which contains nodes and uplinks connected to the same
  switch. The operation of DNUP is the same as UPDN with the exception of the
  ranking process. In DNUP all switch nodes are ranked based solely on their
  distance from CA Nodes, all switch nodes directly connected to at least one CA
  are assigned a value of 1 all other switch nodes are assigned a value of one
  more than the minimum rank of all neighbor switch nodes.
<div style="height: 1.00em;">&#x00A0;</div>
Fat-tree Routing Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
The fat-tree algorithm optimizes routing for &quot;shift&quot; communication
  pattern. It should be chosen if a subnet is a symmetrical or almost
  symmetrical fat-tree of various types. It supports not just K-ary-N-Trees, by
  handling for non-constant K, cases where not all leafs (CAs) are present, any
  CBB ratio. As in UPDN, fat-tree also prevents credit-loop-deadlocks.
<div style="height: 1.00em;">&#x00A0;</div>
If the root guid file is not provided ('-a' or '--root_guid_file' options), the
  topology has to be pure fat-tree that complies with the following rules:
<br/>
 - Tree rank should be between two and eight (inclusively)
<br/>
 - Switches of the same rank should have the same number
<br/>
 of UP-going port groups*, unless they are root switches,
<br/>
 in which case the shouldn't have UP-going ports at all.
<br/>
 - Switches of the same rank should have the same number
<br/>
 of DOWN-going port groups, unless they are leaf switches.
<br/>
 - Switches of the same rank should have the same number
<br/>
 of ports in each UP-going port group.
<br/>
 - Switches of the same rank should have the same number
<br/>
 of ports in each DOWN-going port group.
<br/>
 - All the CAs have to be at the same tree level (rank).
<div style="height: 1.00em;">&#x00A0;</div>
If the root guid file is provided, the topology doesn't have to be pure
  fat-tree, and it should only comply with the following rules:
<br/>
 - Tree rank should be between two and eight (inclusively)
<br/>
 - All the Compute Nodes** have to be at the same tree level (rank).
<br/>
 Note that non-compute node CAs are allowed here to be at different
<br/>
 tree ranks.
<div style="height: 1.00em;">&#x00A0;</div>
* ports that are connected to the same remote switch are referenced as
  &#x00B4;port group&#x00B4;.
<div style="height: 1.00em;">&#x00A0;</div>
** list of compute nodes (CNs) can be specified by &#x00B4;-u&#x00B4; or
  &#x00B4;--cn_guid_file&#x00B4; OpenSM options.
<div style="height: 1.00em;">&#x00A0;</div>
Topologies that do not comply cause a fallback to min hop routing. Note that
  this can also occur on link failures which cause the topology to no longer be
  &quot;pure&quot; fat-tree.
<div style="height: 1.00em;">&#x00A0;</div>
Note that although fat-tree algorithm supports trees with non-integer CBB ratio,
  the routing will not be as balanced as in case of integer CBB ratio. In
  addition to this, although the algorithm allows leaf switches to have any
  number of CAs, the closer the tree is to be fully populated, the more
  effective the &quot;shift&quot; communication pattern will be. In general,
  even if the root list is provided, the closer the topology to a pure and
  symmetrical fat-tree, the more optimal the routing will be.
<div style="height: 1.00em;">&#x00A0;</div>
The algorithm also dumps compute node ordering file (opensm-ftree-ca-order.dump)
  in the same directory where the OpenSM log resides. This ordering file
  provides the CN order that may be used to create efficient communication
  pattern, that will match the routing tables.
<div style="height: 1.00em;">&#x00A0;</div>
Routing between non-CN nodes
<div style="height: 1.00em;">&#x00A0;</div>
The use of the cn_guid_file option allows non-CN nodes to be located on
  different levels in the fat tree. In such case, it is not guaranteed that the
  Fat Tree algorithm will route between two non-CN nodes. To solve this problem,
  a list of non-CN nodes can be specified by &#x00B4;-G&#x00B4; or
  &#x00B4;--io_guid_file&#x00B4; option. Theses nodes will be allowed to use
  switches the wrong way round a specific number of times (specified by
  &#x00B4;-H&#x00B4; or &#x00B4;--max_reverse_hops&#x00B4;. With the proper
  max_reverse_hops and io_guid_file values, you can ensure full connectivity in
  the Fat Tree.
<div style="height: 1.00em;">&#x00A0;</div>
Please note that using max_reverse_hops creates routes that use the switch in a
  counter-stream way. This option should never be used to connect nodes with
  high bandwidth traffic between them ! It should only be used to allow
  connectivity for HA purposes or similar. Also having routes the other way
  around can in theory cause credit loops.
<div style="height: 1.00em;">&#x00A0;</div>
Use these options with extreme care !
<div style="height: 1.00em;">&#x00A0;</div>
Activation through OpenSM
<div style="height: 1.00em;">&#x00A0;</div>
Use '-R ftree' option to activate the fat-tree algorithm. Use '-a
  &lt;root_guid_file&gt;' to provide root nodes for ranking. If the `-a' option
  is not used, routing algorithm will detect roots automatically. Use '-u
  &lt;root_cn_file&gt;' to provide the list of compute nodes. If the `-u' option
  is not used, all the CAs are considered as compute nodes.
<div style="height: 1.00em;">&#x00A0;</div>
Note: LMC &gt; 0 is not supported by fat-tree routing. If this is specified, the
  default routing algorithm is invoked instead.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
LASH Routing Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
LASH is an acronym for LAyered SHortest Path Routing. It is a deterministic
  shortest path routing algorithm that enables topology agnostic deadlock-free
  routing within communication networks.
<div style="height: 1.00em;">&#x00A0;</div>
When computing the routing function, LASH analyzes the network topology for the
  shortest-path routes between all pairs of sources / destinations and groups
  these paths into virtual layers in such a way as to avoid deadlock.
<div style="height: 1.00em;">&#x00A0;</div>
Note LASH analyzes routes and ensures deadlock freedom between switch pairs. The
  link from HCA between and switch does not need virtual layers as deadlock will
  not arise between switch and HCA.
<div style="height: 1.00em;">&#x00A0;</div>
In more detail, the algorithm works as follows:
<div style="height: 1.00em;">&#x00A0;</div>
1) LASH determines the shortest-path between all pairs of source / destination
  switches. Note, LASH ensures the same SL is used for all SRC/DST - DST/SRC
  pairs and there is no guarantee that the return path for a given DST/SRC will
  be the reverse of the route SRC/DST.
<div style="height: 1.00em;">&#x00A0;</div>
2) LASH then begins an SL assignment process where a route is assigned to a
  layer (SL) if the addition of that route does not cause deadlock within that
  layer. This is achieved by maintaining and analysing a channel dependency
  graph for each layer. Once the potential addition of a path could lead to
  deadlock, LASH opens a new layer and continues the process.
<div style="height: 1.00em;">&#x00A0;</div>
3) Once this stage has been completed, it is highly likely that the first layers
  processed will contain more paths than the latter ones. To better balance the
  use of layers, LASH moves paths from one layer to another so that the number
  of paths in each layer averages out.
<div style="height: 1.00em;">&#x00A0;</div>
Note, the implementation of LASH in opensm attempts to use as few layers as
  possible. This number can be less than the number of actual layers available.
<div style="height: 1.00em;">&#x00A0;</div>
In general LASH is a very flexible algorithm. It can, for example, reduce to
  Dimension Order Routing in certain topologies, it is topology agnostic and
  fares well in the face of faults.
<div style="height: 1.00em;">&#x00A0;</div>
It has been shown that for both regular and irregular topologies, LASH
  outperforms Up/Down. The reason for this is that LASH distributes the traffic
  more evenly through a network, avoiding the bottleneck issues related to a
  root node and always routes shortest-path.
<div style="height: 1.00em;">&#x00A0;</div>
The algorithm was developed by Simula Research Laboratory.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
Use '-R lash -Q ' option to activate the LASH algorithm.
<div style="height: 1.00em;">&#x00A0;</div>
Note: QoS support has to be turned on in order that SL/VL mappings are used.
<div style="height: 1.00em;">&#x00A0;</div>
Note: LMC &gt; 0 is not supported by the LASH routing. If this is specified, the
  default routing algorithm is invoked instead.
<div style="height: 1.00em;">&#x00A0;</div>
For open regular cartesian meshes the DOR algorithm is the ideal routing
  algorithm. For toroidal meshes on the other hand there are routing loops that
  can cause deadlocks. LASH can be used to route these cases. The performance of
  LASH can be improved by preconditioning the mesh in cases where there are
  multiple links connecting switches and also in cases where the switches are
  not cabled consistently. An option exists for LASH to do this. To invoke this
  use '-R lash -Q --do_mesh_analysis'. This will add an additional phase that
  analyses the mesh to try to determine the dimension and size of a mesh. If it
  determines that the mesh looks like an open or closed cartesian mesh it
  reorders the ports in dimension order before the rest of the LASH algorithm
  runs.
<div style="height: 1.00em;">&#x00A0;</div>
DOR Routing Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
The Dimension Order Routing algorithm is based on the Min Hop algorithm and so
  uses shortest paths. Instead of spreading traffic out across different paths
  with the same shortest distance, it chooses among the available shortest paths
  based on an ordering of dimensions. Each port must be consistently cabled to
  represent a hypercube dimension or a mesh dimension. Alternatively, the -O
  option can be used to assign a custom mapping between the ports on a given
  switch, and the associated dimension. Paths are grown from a destination back
  to a source using the lowest dimension (port) of available paths at each step.
  This provides the ordering necessary to avoid deadlock. When there are
  multiple links between any two switches, they still represent only one
  dimension and traffic is balanced across them unless port equalization is
  turned off. In the case of hypercubes, the same port must be used throughout
  the fabric to represent the hypercube dimension and match on both ends of the
  cable, or the -O option used to accomplish the alignment. In the case of
  meshes, the dimension should consistently use the same pair of ports, one port
  on one end of the cable, and the other port on the other end, continuing along
  the mesh dimension, or the -O option used as an override.
<div style="height: 1.00em;">&#x00A0;</div>
Use '-R dor' option to activate the DOR algorithm.
<div style="height: 1.00em;">&#x00A0;</div>
DFSSSP and SSSP Routing Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
The (Deadlock-Free) Single-Source-Shortest-Path routing algorithm is designed to
  optimize link utilization thru global balancing of routes, while supporting
  arbitrary topologies. The DFSSSP routing algorithm uses Infiniband virtual
  lanes (SL) to provide deadlock-freedom.
<div style="height: 1.00em;">&#x00A0;</div>
The DFSSSP algorithm consists of five major steps:
<div>&#x00A0;</div>
1) It discovers the subnet and models the subnet as a directed multigraph in
  which each node represents a node of the physical network and each edge
  represents one direction of the full-duplex links used to connect the nodes.
<div>&#x00A0;</div>
2) A loop, which iterates over all CA and switches of the subnet, will perform
  three steps to generate the linear forwarding tables for each switch:
<div>&#x00A0;</div>
2.1) use Dijkstra's algorithm to find the shortest path from all nodes to the
  current selected destination;
<div>&#x00A0;</div>
2.2) update the egde weights in the graph, i.e. add the number of routes, which
  use a link to reach the destination, to the link/edge;
<div>&#x00A0;</div>
2.3) update the LFT of each switch with the outgoing port which was used in the
  current step to route the traffic to the destination node.
<div>&#x00A0;</div>
3) After the number of available virtual lanes or layers in the subnet is
  detected and a channel dependency graph is initialized for each layer, the
  algorithm will put each possible route of the subnet into the first layer.
<div>&#x00A0;</div>
4) A loop iterates over all channel dependency graphs (CDG) and performs the
  following substeps:
<div>&#x00A0;</div>
4.1) search for a cycle in the current CDG;
<div>&#x00A0;</div>
4.2) when a cycle is found, i.e. a possible deadlock is present, one edge is
  selected and all routes, which induced this egde, are moved to the &quot;next
  higher&quot; virtual layer (CDG[i+1]);
<div>&#x00A0;</div>
4.3) the cycle search is continued until all cycles are broken and routes are
  moved &quot;up&quot;.
<div>&#x00A0;</div>
5) When the number of needed layers does not exceeds the number of available
  SL/VL to remove all cycles in all CDGs, the rounting is deadlock-free and an
  relation table is generated, which contains the assignment of routes from
  source to destination to a SL
<div style="height: 1.00em;">&#x00A0;</div>
Note on SSSP:
<div>&#x00A0;</div>
This algorithm does not perform the steps 3)-5) and can not be considered to be
  deadlock-free for all topologies. But on the one hand, you can choose this
  algorithm for really large networks (5,000+ CAs and deadlock-free by design)
  to reduce the runtime of the algorithm. On the other hand, you might use the
  SSSP routing algorithm as an alternative, when all deadlock-free routing
  algorithms fail to route the network for whatever reason. In the last case,
  SSSP was designed to deliver an equal or higher bandwidth due to better
  congestion avoidance than the Min Hop routing algorithm.
<div style="height: 1.00em;">&#x00A0;</div>
Notes for usage:
<div>&#x00A0;</div>
a) running DFSSSP: '-R dfsssp -Q'
<div>&#x00A0;</div>
a.1) QoS has to be configured to equally spread the load on the available SL or
  virtual lanes
<div>&#x00A0;</div>
a.2) applications must perform a path record query to get path SL for each
  route, which the application will use to transmite packages
<div>&#x00A0;</div>
b) running SSSP: '-R sssp'
<div>&#x00A0;</div>
c) both algorithms support LMC &gt; 0
<div style="height: 1.00em;">&#x00A0;</div>
Hints for optimizing I/O traffic:
<div>&#x00A0;</div>
Having more nodes (I/O and compute) connected to a switch than incoming links
  can result in a 'bad' routing of the I/O traffic as long as (DF)SSSP routing
  is not aware of the dedicated I/O nodes, i.e., in the following network
  configuration CN1-CN3 might send all I/O traffic via Link2 to IO1,IO2:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 CN1 Link1 IO1
<div>&#x00A0;</div>
<br/>
 \ /----\ /
<div>&#x00A0;</div>
<br/>
 CN2 -- Switch1 Switch2 -- CN4
<div>&#x00A0;</div>
<br/>
 / \----/ \
<div>&#x00A0;</div>
<br/>
 CN3 Link2 IO2
<div style="height: 1.00em;">&#x00A0;</div>
To prevent this from happening (DF)SSSP can use both the compute node guid file
  and the I/O guid file specified by the &#x00B4;-u&#x00B4; or
  &#x00B4;--cn_guid_file&#x00B4; and &#x00B4;-G&#x00B4; or
  &#x00B4;--io_guid_file&#x00B4; options (similar to the Fat-Tree routing). This
  ensures that traffic towards compute nodes and I/O nodes is balanced
  separately and therefore distributed as much as possible across the available
  links. Port GUIDs, as listed by ibstat, must be specified (not Node GUIDs).
<div>&#x00A0;</div>
The priority for the optimization is as follows:
<div>&#x00A0;</div>
<br/>
 compute nodes -&gt; I/O nodes -&gt; other nodes
<div>&#x00A0;</div>
Possible use case szenarios:
<div>&#x00A0;</div>
a) neither &#x00B4;-u&#x00B4; nor &#x00B4;-G&#x00B4; are specified: all nodes a
  treated as &#x00B4;other nodes&#x00B4; and therefore balanced equally;
<div>&#x00A0;</div>
b) &#x00B4;-G&#x00B4; is specified: traffic towards I/O nodes will be balanced
  optimally;
<div>&#x00A0;</div>
c) the system has three node types, such as login/admin, compute and I/O, but
  the balancing focus should be I/O, then one has to use &#x00B4;-u&#x00B4; and
  &#x00B4;-G&#x00B4; with I/O guids listed in cn_guid_file and compute node
  guids listed in io_guid_file;
<div>&#x00A0;</div>
d) ...
<div style="height: 1.00em;">&#x00A0;</div>
Torus-2QoS Routing Algorithm
<div style="height: 1.00em;">&#x00A0;</div>
Torus-2QoS is routing algorithm designed for large-scale 2D/3D torus fabrics;
  see torus-2QoS(8) for full documentation.
<div style="height: 1.00em;">&#x00A0;</div>
Use '-R torus-2QoS -Q' or '-R torus-2QoS,no_fallback -Q' to activate the
  torus-2QoS algorithm.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
Routing References
<div style="height: 1.00em;">&#x00A0;</div>
To learn more about deadlock-free routing, see the article &quot;Deadlock Free
  Message Routing in Multiprocessor Interconnection Networks&quot; by William J
  Dally and Charles L Seitz (1985).
<div style="height: 1.00em;">&#x00A0;</div>
To learn more about the up/down algorithm, see the article &quot;Effective
  Strategy to Compute Forwarding Tables for InfiniBand Networks&quot; by Jose
  Carlos Sancho, Antonio Robles, and Jose Duato at the Universidad Politecnica
  de Valencia.
<div style="height: 1.00em;">&#x00A0;</div>
To learn more about LASH and the flexibility behind it, the requirement for
  layers, performance comparisons to other algorithms, see the following
  articles:
<div style="height: 1.00em;">&#x00A0;</div>
&quot;Layered Routing in Irregular Networks&quot;, Lysne et al, IEEE
  Transactions on Parallel and Distributed Systems, VOL.16, No12, December 2005.
<div style="height: 1.00em;">&#x00A0;</div>
&quot;Routing for the ASI Fabric Manager&quot;, Solheim et al. IEEE
  Communications Magazine, Vol.44, No.7, July 2006.
<div style="height: 1.00em;">&#x00A0;</div>
&quot;Layered Shortest Path (LASH) Routing in Irregular System Area
  Networks&quot;, Skeie et al. IEEE Computer Society Communication Architecture
  for Clusters 2002.
<div style="height: 1.00em;">&#x00A0;</div>
To learn more about the DFSSSP and SSSP routing algorithm, see the articles:
<div>&#x00A0;</div>
J. Domke, T. Hoefler and W. Nagel: Deadlock-Free Oblivious Routing for Arbitrary
  Topologies, In Proceedings of the 25th IEEE International Parallel &amp;
  Distributed Processing Symposium (IPDPS 2011)
<div>&#x00A0;</div>
T. Hoefler, T. Schneider and A. Lumsdaine: Optimized Routing for Large-Scale
  InfiniBand Networks, In 17th Annual IEEE Symposium on High Performance
  Interconnects (HOTI 2009)
<div style="height: 1.00em;">&#x00A0;</div>
Modular Routine Engine
<div style="height: 1.00em;">&#x00A0;</div>
Modular routing engine structure allows for the ease of &quot;plugging&quot; new
  routing modules.
<div style="height: 1.00em;">&#x00A0;</div>
Currently, only unicast callbacks are supported. Multicast can be added later.
<div style="height: 1.00em;">&#x00A0;</div>
One existing routing module is up-down &quot;updn&quot;, which may be activated
  with '-R updn' option (instead of old '-u').
<div style="height: 1.00em;">&#x00A0;</div>
General usage is: $ opensm -R 'module-name'
<div style="height: 1.00em;">&#x00A0;</div>
There is also a trivial routing module which is able to load LFT tables from a
  file.
<div style="height: 1.00em;">&#x00A0;</div>
Main features:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 - this will load switch LFTs and/or LID matrices (min hops tables)
<br/>
 - this will load switch LFTs according to the path entries introduced
<br/>
 in the file
<br/>
 - no additional checks will be performed (such as &quot;is port
  connected&quot;,
<br/>
 etc.)
<br/>
 - in case when fabric LIDs were changed this will try to reconstruct
<br/>
 LFTs correctly if endport GUIDs are represented in the file
<br/>
 (in order to disable this, GUIDs may be removed from the file
<br/>
 or zeroed)
<div style="height: 1.00em;">&#x00A0;</div>
The file format is compatible with output of 'ibroute' util and for whole fabric
  can be generated with dump_lfts.sh script.
<div style="height: 1.00em;">&#x00A0;</div>
To activate file based routing module, use:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 opensm -R file -U /path/to/lfts_file
<div style="height: 1.00em;">&#x00A0;</div>
If the lfts_file is not found or is in error, the default routing algorithm is
  utilized.
<div style="height: 1.00em;">&#x00A0;</div>
The ability to dump switch lid matrices (aka min hops tables) to file and later
  to load these is also supported.
<div style="height: 1.00em;">&#x00A0;</div>
The usage is similar to unicast forwarding tables loading from a lfts file
  (introduced by 'file' routing engine), but new lid matrix file name should be
  specified by -M or --lid_matrix_file option. For example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 opensm -R file -M ./opensm-lid-matrix.dump
<div style="height: 1.00em;">&#x00A0;</div>
The dump file is named &#x00B4;opensm-lid-matrix.dump&#x00B4; and will be
  generated in standard opensm dump directory (/var/log by default) when
  OSM_LOG_ROUTING logging flag is set.
<div style="height: 1.00em;">&#x00A0;</div>
When routing engine 'file' is activated, but the lfts file is not specified or
  not cannot be open default lid matrix algorithm will be used.
<div style="height: 1.00em;">&#x00A0;</div>
There is also a switch forwarding tables dumper which generates a file
  compatible with dump_lfts.sh output. This file can be used as input for
  forwarding tables loading by 'file' routing engine. Both or one of options -U
  and -M can be specified together with &#x00B4;-R file&#x00B4;.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="PER_MODULE_LOGGING_CONFIGURATION"><a class="selflink" href="#PER_MODULE_LOGGING_CONFIGURATION">PER
  MODULE LOGGING CONFIGURATION</a></h1>
To enable per module logging, configure per_module_logging_file to the per
  module logging config file name in the opensm options file. To disable,
  configure per_module_logging_file to (null) there.
<div style="height: 1.00em;">&#x00A0;</div>
The per module logging config file format is a set of lines with module name and
  logging level as follows:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 &lt;module name&gt;&lt;separator&gt;&lt;logging level&gt;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 &lt;module name&gt; is the file name including .c
<br/>
 &lt;separator&gt; is either = , space, or tab
<br/>
 &lt;logging level&gt; is the same levels as used in the coarse/overall
<br/>
 logging as follows:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 BIT LOG LEVEL ENABLED
<br/>
 ---- -----------------
<br/>
 0x01 - ERROR (error messages)
<br/>
 0x02 - INFO (basic messages, low volume)
<br/>
 0x04 - VERBOSE (interesting stuff, moderate volume)
<br/>
 0x08 - DEBUG (diagnostic, high volume)
<br/>
 0x10 - FUNCS (function entry/exit, very high volume)
<br/>
 0x20 - FRAMES (dumps all SMP and GMP frames)
<br/>
 0x40 - ROUTING (dump FDB routing information)
<br/>
 0x80 - SYS (syslog at LOG_INFO level in addition to OpenSM logging)
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/etc/rdma/opensm.conf</b></dt>
  <dd class="It-tag">default OpenSM config file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/etc/rdma/ib-node-name-map</b></dt>
  <dd class="It-tag">default node name map file. See ibnetdiscover for more
      information on format.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/etc/rdma/partitions.conf</b></dt>
  <dd class="It-tag">default partition config file
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/etc/rdma/qos-policy.conf</b></dt>
  <dd class="It-tag">default QOS policy config file
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/etc/rdma/prefix-routes.conf</b></dt>
  <dd class="It-tag">default prefix routes file
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/etc/rdma/per-module-logging.conf</b></dt>
  <dd class="It-tag">default per module logging config file
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/etc/rdma/torus-2QoS.conf</b></dt>
  <dd class="It-tag">default torus-2QoS config file
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">Hal Rosenstock</dt>
  <dd class="It-tag">&lt;<i>hal@mellanox.com</i>&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Sasha Khapyorsky</dt>
  <dd class="It-tag">&lt;<i>sashak@voltaire.com</i>&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Eitan Zahavi</dt>
  <dd class="It-tag">&lt;<i>eitan@mellanox.co.il</i>&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Yevgeny Kliteynik</dt>
  <dd class="It-tag">&lt;<i>kliteyn@mellanox.co.il</i>&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Thomas Sodring</dt>
  <dd class="It-tag">&lt;<i>tsodring@simula.no</i>&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Ira Weiny</dt>
  <dd class="It-tag">&lt;<i>weiny2@llnl.gov</i>&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Dale Purdy</dt>
  <dd class="It-tag">&lt;<i>purdy@sgi.com</i>&gt;
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
torus-2QoS(8), torus-2QoS.conf(5).</div>
<table class="foot">
  <tr>
    <td class="foot-date">Sept 15, 2014</td>
    <td class="foot-os">OpenIB</td>
  </tr>
</table>
</body>
</html>
