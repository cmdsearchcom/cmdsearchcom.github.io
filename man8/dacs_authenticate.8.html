<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:10:01 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DACS_AUTHENTICATE(8) DACS Web Services Manual
DACS_AUTHENTICATE(8)</p>

<p style="margin-top: 1em">NAME <br>
dacs_authenticate - DACS authentication service</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dacs_authenticate [dacsoptions[1]]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This web service is part of the DACS suite.</p>

<p style="margin-top: 1em">The dacs_authenticate web
service is an authentication &quot;driver&quot; for DACS.
When it receives a request to authenticate a user, it
usually invokes one or more authentication <br>
modules, depending on its configuration. Successful
authentication assigns a DACS user identity to the user and
roles modules may be invoked to determine the roles with
which the <br>
identity is associated; DACS credentials are generated and
returned to the user. The caller of dacs_authenticate can be
redirected to a configured URL, called the <br>
post-authentication handler (or just the handler), depending
on whether authentication fails or succeeds.</p>

<p style="margin-top: 1em">General DACS configuration
directives are discussed in dacs.conf(5)[2]. Configuration
directives specific to authentication are described
here.</p>

<p style="margin-top: 1em">DACS expressions are described
in dacs.exprs(5)[3].</p>

<p style="margin-top: 1em">dacs_authenticate might be
called from an HTML form (see the distribution&rsquo;s
html/examples[4] directory for examples of simple login
pages), directly through a link on a web page, <br>
indirectly by DACS HTTP Authentication[5], or from
middleware.</p>

<p style="margin-top: 1em">Command line authentication
functionality is provided by dacsauth(1)[6]. Other
authentication mechanisms are provided by
dacs_auth_agent(8)[7], dacs_auth_transfer(8)[8], and <br>
dacscookie(1)[9].</p>

<p style="margin-top: 1em">Authentication <br>
Authentication is the procedure by which a claimed identity
is confirmed. Following successful authentication, DACS
credentials may be created that represent the identity. For
<br>
maximum convenience and interoperability in a web
environment, DACS credentials are usually encapsulated
within an HTTP cookie and transmitted over a TCP/IP
connection secured by <br>
SSL/TLS. Any secure method of transporting credentials can
be used instead, however, such as the value of an HTTP
extension-header entity-header field in a request message
sent <br>
over a VPN.</p>

<p style="margin-top: 1em">While dacs_authenticate provides
powerful and flexible ways to combine and compose a variety
of authentication methods, most DACS jurisdictions will
configure only one method, or <br>
perhaps just a few methods, in simple ways.</p>

<p style="margin-top: 1em">To help integrate DACS
seamlessly within a web site, dacs_authenticate allows
handlers to be configured. Handlers allow various exceptions
to be caught and processed so that an <br>
appropriate flow of control can occur. For example, if
authentication succeeds the user can be redirected to a
specific page, including the one originally requested before
the <br>
exception occurred.</p>

<p style="margin-top: 1em">Authentication succeeds (and the
user is authenticated) if and only if:</p>

<p style="margin-top: 1em">&Acirc;&middot; at least one
Auth clause[10] has been configured,</p>

<p style="margin-top: 1em">&Acirc;&middot; the semantics of
all CONTROL[11] directives satisfy the requirements for
success,</p>

<p style="margin-top: 1em">&Acirc;&middot; the DACS
username[12] arrived at is syntactically valid, and</p>

<p style="margin-top: 1em">&Acirc;&middot; the
identity&rsquo;s access has not been revoked or denied (see
dacs.acls(5)[13]).</p>

<p style="margin-top: 1em">An incorrect password, for
instance, is not considered to be an error; it will cause
its Auth clause to fail but depending on the control
directives that have been configured, <br>
the user may still be successfully authenticated by some
other Auth clause. True errors are fatal and cause
dacs_authenticate to terminate without issuing credentials
and <br>
possibly without invoking a handler.</p>

<p style="margin-top: 1em">If a DACS identity
reauthenticates, the user agent is expected to replace the
old credentials with new ones; if re-authentication fails
(e.g., the password is incorrect), the old <br>
credentials should continue to exist. If a user establishes
multiple concurrent identities, the user agent is expected
to send all credentials with each service request in <br>
accordance with the relevant standards. This is standard
behaviour for most common web browsers.</p>

<p style="margin-top: 1em">As an efficiency measure, the
authentication architecture allows an authentication module
to return roles.</p>

<p style="margin-top: 1em">Names <br>
Please refer to dacs(1)[14] for details about naming.</p>

<p style="margin-top: 1em">Credentials and Cookies <br>
DACS credentials are cryptographically protected XML
documents (credentials.dtd[15]). They have been carefully
designed to make it extremely difficult for an attacker to
<br>
generate valid credentials, modify captured credentials to
impersonate another user, or obtain greater access rights
without being detected. DACS is careful to not produce <br>
log information or error messages that might benefit an
attacker.</p>

<p style="margin-top: 1em">User agents and other software
outside of DACS do not need to decrypt the credentials and
do not possess the required encryption key.</p>

<p style="margin-top: 1em">New credentials are created and
returned to the user after successful authentication. The
lifetime of each set of credentials is independently
configurable, but they are <br>
intended to be fairly transitory. If a user reauthenticates,
new credentials different than previous credentials might
well be returned (e.g., with different roles).</p>

<p style="margin-top: 1em">DACS does not verify that a
user&rsquo;s browser is configured to accept cookies - this
is the responsibility of the DACS administrator (by
supplying client-side code to test that <br>
cookies have been enabled, for instance). Failure to accept
cookies may cause some features to be unavailable or work
incorrectly. Also note that despite what DACS (or any <br>
other program) tells a browser about the lifetime of an HTTP
cookie, browsers may be configured to impose a shorter
lifetime and can delete a cookie at any time. (Aside: <br>
Firefox 2.0.0.3 appears to show cookies that have been
deleted.)</p>

<p style="margin-top: 1em">Security <br>
&Acirc;&middot; For DACS to operate securely, communication
between a user (or middleware) and dacs_authenticate, which
may include information such as passwords, must only be <br>
transmitted over a secure connection (SSL/TLS).</p>

<p style="margin-top: 1em">&Acirc;&middot; Communication
between dacs_authenticate (and dacsauth) and an external
(not built-in) authentication module may include information
such as passwords and therefore <br>
should only be transmitted over a secure connection
(SSL/TLS) or in a way that is not subject to eavesdropping
or attack.</p>

<p style="margin-top: 1em">&Acirc;&middot; For DACS to
operate securely, regardless of how they are obtained, DACS
credentials must only be transmitted over a secure
connection (SSL/TLS) so that they cannot <br>
easily be captured and reused by an attacker.</p>

<p style="margin-top: 1em">&Acirc;&middot; It is unwise to
configure both SSL/TLS and non-SSL/TLS communication.
Besides providing an avenue for attack, it may cause DACS to
behave strangely (e.g., infinite <br>
loops may occur because cookies obtained over an SSL/TLS
connection are not subsequently forwarded over a non-SSL/TLS
connection).</p>

<p style="margin-top: 1em">&Acirc;&middot; The apparent IP
address of an authenticated user, as provided by the web
server, is stored in credentials. DACS can be configured to
consider credentials to be valid <br>
only for requests that come from that address (refer to the
VERIFY_IP[16] configuration directive), making it more
difficult for an attacker to replay captured <br>
credentials.</p>

<p style="margin-top: 1em">In some environments this
constraint is a good idea, but in general it is of dubious
value so enable it with care. Where a user is behind a
firewall or router that <br>
has multiple IP addresses, successive service requests might
legitimately not appear to be coming from the same address
and some requests would be denied if this <br>
constraint were enabled. In situations where credentials are
being forwarded between web services they might be rejected.
In the case of dial-up Internet access, a <br>
user might be issued credentials, lose the connection, and
be assigned a different IP address upon reconnecting; the
user would be forced to reauthenticate. Also, <br>
more than one user may be associated with a particular IP
address, as when a Network Address Translation (NAT)
facility such as natd(8)[17] is used, so the check does <br>
not guarantee uniqueness.</p>

<p style="margin-top: 1em">&Acirc;&middot; Information
associated with a user&rsquo;s browser can be included in
credentials created for that user to make it difficult to
reuse captured credentials with a different <br>
browser. Please refer to VERIFY_UA[18] for details.</p>

<p style="margin-top: 1em">&Acirc;&middot; Credentials have
a limit on their lifetime that is independent of the
lifetime of the HTTP cookie that contains them; that is,
credentials can expire without their <br>
cookie having expired, and vice versa. Expired credentials
are recognized and will not be used by DACS. Refer to the
AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS[19] <br>
configuration directive for details.</p>

<p style="margin-top: 1em">&Acirc;&middot; Passwords do not
appear in any credentials and are not stored once the user
has been authenticated.</p>

<p style="margin-top: 1em">&Acirc;&middot; It is forbidden
to submit multiple credentials for the same identity to DACS
and such a request will trigger an error.</p>

<p style="margin-top: 1em">All DACS jurisdictions within
the same federation share an algorithm and key to encrypt
and decrypt credentials. A cryptographically secure,
symmetric encryption function, <br>
Rijndael (the Advanced Encryption Standard[20] (AES)
algorithm and Federal Information Processing Standard[21]),
is used. The same 128 bit key is used by all DACS <br>
jurisdictions. AES also supports 192 and 256 bit key lengths
and either can be configured at build-time.</p>

<p style="margin-top: 1em">A cryptographically secure
message authentication code (MAC) is used to detect
modification of credentials. A key different from the
encryption key is used. The Keyed-Hash <br>
Message Authentication Code (HMAC, FIPS 198[22], RFC
2104[23], RFC 4635[24], RFC 4868[25]), is employed using the
160-bit NIST[26] secure hash standard, SHA-1 (FIPS <br>
180-1[27], RFC 4634[28], RFC 6234[29]). In addition to
SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 (FIPS
180-4[30]) can be used, although they must be configured at
<br>
build-time.</p>

<p style="margin-top: 1em">The AES key length and HMAC
digest algorithm used by a federation can be changed at any
time, perhaps forcing some users to reauthenticate, but the
same key length and digest <br>
algorithm must be used throughout a federation.</p>

<p style="margin-top: 1em">Security <br>
DACS can be configured to use the less secure but
widely-used and somewhat more efficient MD5 algorithm[31]
instead, although it is deprecated and it will eventually be
<br>
removed.</p>

<p style="margin-top: 1em">The Netscape HTTP Cookies
Specification[32] defines the syntax and semantics of the
HTTP response header that a web server sends to a client;
this syntax is used by default, <br>
but the COOKIE_SYNTAX[33] argument can be used to request a
different syntax. The Netscape format is as follows:</p>

<p style="margin-top: 1em">Set-Cookie: NAME=VALUE;
expires=DATE; path=PATH; domain=DOMAIN_NAME; secure</p>

<p style="margin-top: 1em">DACS formulates these response
headers as follows.</p>

<p style="margin-top: 1em">The NAME attribute of an
authentication cookie returned to the user (e.g., by
dacs_authenticate) has the following default format:</p>


<p style="margin-top: 1em">DACS:federation-name::[jurisdiction-name]:[username]</p>

<p style="margin-top: 1em">where federation-name is the
official name assigned to the federation for which the
cookie is valid, jurisdiction-name is the name of the
authenticating jurisdiction, and <br>
username is the authenticated name of the user. If the
jurisdiction-name is omitted, the username must also be
omitted. Semicolons, commas, and whitespace within the name
<br>
must be URL-style encoded. Colons are not allowed in any of
the name components. Here is an example of a cookie
name:</p>


<p style="margin-top: 1em">DACS:EXAMPLE::METALOGIC:rick@example.com</p>

<p style="margin-top: 1em">DACS can also return HTTP
cookies for other purposes. The NAME attribute of these
cookies has the same format as an authentication cookie but
is followed by a colon and a <br>
keyword; e.g., DACS:EXAMPLE:::SELECTED.</p>

<p style="margin-top: 1em">The default format of the NAME
attribute can be overridden through the
COOKIE_NAME_TERMINATORS[34] directive.</p>

<p style="margin-top: 1em">The VALUE attribute of a cookie
is a printable text encoding of credentials.</p>

<p style="margin-top: 1em">Security <br>
&Acirc;&middot; Although DACS performs validity tests on
cookie names, middleware should not rely on cookie names for
any purpose. An apparently valid DACS cookie can easily be
<br>
crafted with any value. Also, an apparently legitimate
cookie might convey expired or otherwise invalid
credentials. Middleware should use <br>
dacs_current_credentials(8)[35] to validate an
authentication cookie and not trust cookie names.</p>

<p style="margin-top: 1em">&Acirc;&middot; No expires
attribute is set; this will cause the cookie to be
automatically deleted by a conforming browser when the
user&rsquo;s browser session ends and not made <br>
persistent (i.e., not stored on disk for use in a subsequent
browser session), closing a potential security hole.</p>

<p style="margin-top: 1em">&Acirc;&middot; By default, the
value of the path attribute is &quot;/&quot;, meaning the
cookie will be sent with every request to the domain that
created the cookie, whether it is for a <br>
DACS-wrapped service request or not. The COOKIE_PATH[36]
configuration directive can specify an alternative value.
Using a more restricted path can potentially <br>
improve security. All of the jurisdiction&rsquo;s
DACS-wrapped services must appear under that path, of
course, or the cookie will not be sent; ideally, no non-DACS
wrapped <br>
service would appear under that path.</p>

<p style="margin-top: 1em">The value of the domain
attribute associated with the cookie is dependent on the
uniform domain name scheme chosen for the jurisdictions. The
value will be configured to be <br>
the most specific tail string that tail matches all
participating domain names. For example, if the uniform
domain name scheme has hostnames of the form
xxx.example.com, <br>
yyy.example.com, and zzz.example.com, then the value of the
attribute will be example.com. This will ensure that the
user agent sends the cookie with any service request <br>
directed to a hostname ending in example.com.</p>

<p style="margin-top: 1em">Tip <br>
The HTTP cookie specifications appear to say that a cookie
having a domain attribute of example.com should not be sent
to a host of the same name, yet both Mozilla and IE <br>
(and perhaps other browsers) do just that. Without this
behaviour, it would not be possible to use a single domain
name with multiple DACS jurisdictions below it; that <br>
is, given domain=example.com, it is expected that
jurisdictions can be identified by URI path prefixes such as
example.com/metalogic, example.com/test, and so on.</p>

<p style="margin-top: 1em">When operating securely (see the
SECURE_MODE[37] directive in dacs.conf(5)[2]) or when an
authentication request is sent over SSL/TLS, the secure
attribute will be present so <br>
that the cookie will only be transmitted if the
communications channel with the host is a secure one. At
present, browsers define this to mean that secure cookies
will only <br>
be sent to HTTPS (HTTP over SSL/TLS) servers.</p>

<p style="margin-top: 1em">Web Service Arguments <br>
In addition to the standard CGI arguments[38],
dacs_authenticate understands the following CGI arguments.
Some arguments are optional, while others are required
depending on the <br>
authentication configuration. An invalid argument value will
usually cause authentication to fail immediately.
Unrecognized arguments are ignored.</p>

<p style="margin-top: 1em">AUTH_ID <br>
This optional argument is used with the user_sufficient
keyword (refer to the CONTROL[11] directive).</p>

<p style="margin-top: 1em">AUTH_PROMPT_VAR_PREFIX <br>
Reserved for use by local_pam_authenticate[39].</p>

<p style="margin-top: 1em">AUTH_TRANSID <br>
Reserved for use by local_pam_authenticate[39].</p>

<p style="margin-top: 1em">AUTHORIZATION <br>
Used internally with HTTP Authentication[5].</p>

<p style="margin-top: 1em">AUXILIARY <br>
This argument can be used to pass additional authentication
material to authentication modules. A compile-time maximum
length of 128 characters is imposed.</p>

<p style="margin-top: 1em">COOKIE_SYNTAX <br>
By default, the de facto standard Netscape HTTP Cookies
Specification[32] syntax is followed when cookies are
created (COOKIE_SYNTAX=COOKIE_NETSCAPE). The value <br>
COOKIE_EXT_NETSCAPE selects an &quot;extended&quot; Netscape
spec syntax (it is not the Netscape syntax but it is not
fully RFC 2109 compliant either); instead of using the
expires <br>
attribute it will use the Max-Age attribute as defined in
RFC 2109[40], RFC 2965[41], and RFC 6265[42]. Attribute
values are not quoted and there is no support for the <br>
Comment field. Parameter values COOKIE_RFC2109,
COOKIE_RFC2965, and COOKIE_RFC6265 are recognized but not
implemented.</p>

<p style="margin-top: 1em">Note <br>
RFC 2109[40], RFC 2965[41], and RFC 6265[42] forbid the
following characters from appearing within an HTTP
cookie&rsquo;s NAME attribute:</p>

<p style="margin-top: 1em">( ) &lt; &gt; @ , ; :
&nbsp;&quot; / [ ] ? = { }</p>

<p style="margin-top: 1em">Additionally, the space, tab,
and all US-ASCII control characters (octets 0 - 31) and DEL
(127) are disallowed (refer to the definition of a token in
RFC 2616[43], S2.2). <br>
By default, DACS currently follows the original Netscape
spec syntax in this respect and produces cookies that are
invalid according to RFC 2109, RFC 2965, and RFC 6265 <br>
because colons are used within cookie names[44]. While this
limitation does not appear to cause problems for web
browsers in practice, it may be noteworthy for users of <br>
some cookie handling APIs. When necessary, the cookie name
format can be customized using the
COOKIE_NAME_TERMINATORS[34] directive.</p>

<p style="margin-top: 1em">DACS_AUTH_SUCCESS_HANDLER <br>
This argument provides a way for the caller to specify where
the user agent should be redirected after successful
authentication, regardless of whether authentication <br>
handlers are configured or enabled. If its value is
DACS_ERROR_URL and an argument by that name is present, the
user agent will be redirected to the value of that argument;
<br>
otherwise, the user agent will be redirected to the value of
DACS_AUTH_SUCCESS_HANDLER. The DACS_ERROR_URL is passed to
this web service by dacs_acs(8)[45] as part of an <br>
authentication workflow initiated by a request that is
denied because no credentials were supplied; DACS_ERROR_URL
should not be generated by any non-DACS software.</p>

<p style="margin-top: 1em">DACS_BROWSER <br>
If an argument named DACS_BROWSER is present and has the
value 1, it signifies that the request is coming from a
browser rather than middleware. If the request comes from a
<br>
browser, DACS will return a cookie using the Set-Cookie HTTP
response header, otherwise it will not.</p>

<p style="margin-top: 1em">DACS_DEBUG <br>
If this argument is present, the web service will produce
more detailed log information.</p>

<p style="margin-top: 1em">ENABLE_AUTH_HANDLERS <br>
The jurisdiction&rsquo;s authentication handler directives
are honoured if and only if this argument is present and has
the value 1.</p>

<p style="margin-top: 1em">OPERATION <br>
This is used with the identity selection mechanism described
by dacs_select_credentials(8)[46]. If the value of this
parameter is SELECT and authentication is successful, any
<br>
currently selected credentials are deselected and the new
credentials are selected.</p>

<p style="margin-top: 1em">PASSWORD <br>
This argument is the password that corresponds to USERNAME.
A compile-time maximum length of 128 characters is
imposed.</p>

<p style="margin-top: 1em">USERNAME <br>
This argument, which is almost always required, is the name
provided by the user and is usually the name being
authenticated. It will not necessarily be the same as the
final <br>
DACS username. For example, if the value of USERNAME is not
a syntactically valid DACS username (see dacs(1)[12]), the
authentication procedure must transform it into <br>
something acceptable (using the strtr()[47] function, for
instance; see dacs.exprs(5)[3]). A compile-time maximum
length of 64 characters is imposed.</p>

<p style="margin-top: 1em">WWW_AUTHENTICATE <br>
Reserved for internal use by HTTP Authentication[5].</p>

<p style="margin-top: 1em">Auth Clause Directives <br>
Each Auth clause in a DACS configuration file contains
directives that describe a procedure for authenticating
users. Some of these directives are common to all
authentication <br>
modules, while others are understood only by a certain
module; for example, LDAP_USERNAME_URL[48] is only
meaningful to the local_ldap_authenticate[49] module. The
<br>
general-purpose OPTION[50] directive may sometimes be used
to specify an argument to an authentication module.</p>

<p style="margin-top: 1em">Important <br>
The order in which the Auth clauses appear is significant.
See the CONTROL[11] directive.</p>

<p style="margin-top: 1em">Every Auth element must have an
id attribute. Its value is merely a label (an alphabetic
followed by zero or more alphanumerics, hyphens, and
underscores) that allows the clause <br>
to be referenced. Each id attribute value must be unique
(case-sensitively) within the Jurisdiction section that
contains it.</p>

<p style="margin-top: 1em">The following configuration
directives are recognized by dacs_authenticate within any
Auth clause (see dacs.conf(5)[51] for general information
about directives).</p>

<p style="margin-top: 1em">Auth Clause Common Directives
Index:</p>

<p style="margin-top: 1em">1. CONTROL (Required1)</p>

<p style="margin-top: 1em">2. CREDENTIALS_LIFETIME_SECS
(Optional1)</p>

<p style="margin-top: 1em">3. EXIT* (Optional1)</p>

<p style="margin-top: 1em">4. EXPR (Optional1)</p>

<p style="margin-top: 1em">5. FLAGS (Optional1)</p>

<p style="margin-top: 1em">6. INIT* (Optional1)</p>

<p style="margin-top: 1em">7. OPTION (Optional)</p>

<p style="margin-top: 1em">8. OPTION* (Optional)</p>

<p style="margin-top: 1em">9. PASSWORD_AUDIT (Optional)</p>

<p style="margin-top: 1em">10. PREDICATE (Optional1)</p>

<p style="margin-top: 1em">11. STYLE (Required1)</p>

<p style="margin-top: 1em">12. URL (Optional1)</p>

<p style="margin-top: 1em">13. URL* (Optional1)</p>

<p style="margin-top: 1em">CONTROL (Required1) <br>
This directive specifies a PAM-like control keyword that
determines what will happen if the authentication module
succeeds or fails; see pam(3)[52] and the X/Open Single <br>
Sign-On Service (XSSO) preliminary specification[53] (page
30), from which the description of these directives was
adapted. Although this control mechanism allows for rather
<br>
complicated authentication sequences to be described, in
practice jurisdictions tend to construct fairly simple
configurations. Most processing errors (other than errors
<br>
encountered by a module) are considered fatal.</p>

<p style="margin-top: 1em">The first Auth clause that
appears after configuration merging (see dacs.conf(5)[54])
is the &quot;top&quot; or first module in the stack, the
next one is the second module in the <br>
stack, and so on.</p>

<p style="margin-top: 1em">The value of this directive is a
case-insensitive keyword that can be abbreviated up to the
indicated minimum:</p>

<p style="margin-top: 1em">&Acirc;&middot; require[d]</p>

<p style="margin-top: 1em">&Acirc;&middot; requisite</p>

<p style="margin-top: 1em">&Acirc;&middot; opt[ional]</p>

<p style="margin-top: 1em">&Acirc;&middot; suff[icient]</p>

<p style="margin-top: 1em">&Acirc;&middot;
user_suff[icient]</p>

<p style="margin-top: 1em">For example, the keywords
require and required are equivalent.</p>

<p style="margin-top: 1em">The control flow of
authentication module processing is as follows:</p>

<p style="margin-top: 1em">1. If a requisite module fails,
authentication fails and dacs_authenticate stops processing
the module stack, returning the error reported by the
requisite module;</p>

<p style="margin-top: 1em">2. If all requisite and required
modules in the stack succeed, then authentication succeeds
(any errors reported by optional, sufficient, and
user_sufficient modules are <br>
ignored);</p>

<p style="margin-top: 1em">3. If one or more required
modules fail, then the error value from the first required
module that failed is returned; unlike failure of a
requisite module, processing <br>
continues;</p>

<p style="margin-top: 1em">4. If none of the modules in the
stack are designated as required or requisite, then
dacs_authenticate requires that at least one optional,
sufficient, or user_sufficient <br>
module succeed. If all fail, then the error value from the
first module in the stack is returned;</p>

<p style="margin-top: 1em">5. The first exception to the
above is caused by the sufficient keyword. If a module that
is designated as sufficient succeeds, then dacs_authenticate
immediately returns <br>
success (all subsequent modules are ignored, even required
and requisite ones), given that all prior required and
requisite modules have also succeeded. If a prior <br>
required module failed, then the error value from that
module is returned;</p>

<p style="margin-top: 1em">6. The second exception to the
above involves the user_sufficient keyword, which enables at
most one user_sufficient Auth clause and disables all other
user_sufficient and <br>
sufficient Auth clauses. This control simplifies configuring
user-selectable authentication methods. Note that this
mechanism will necessarily reveal additional <br>
information about a jurisdiction&rsquo;s authentication
configuration.</p>

<p style="margin-top: 1em">If the AUTH_ID argument is not
given, then all Auth clauses with the user_sufficient
control are disabled - none of their directives are
evaluated - and any sufficient <br>
controlled clauses are processed normally. If the AUTH_ID is
present, then only an Auth clause with a user_sufficient
control and an exactly matching id attribute is <br>
used. There can be at most one such Auth clause; all other
Auth clauses having a user_sufficient or sufficient control
is disabled. In all other respects, an enabled <br>
user_sufficient Auth clause is processed as for the
sufficient control;</p>

<p style="margin-top: 1em">7. If an error occurs while
processing a directive, then dacs_authenticate fails
immediately.</p>

<p style="margin-top: 1em">CREDENTIALS_LIFETIME_SECS
(Optional1) <br>
The lifetime, in seconds, of credentials returned after
successful authentication. This overrides the general
directive of the same name, and may in turn be overridden by
<br>
setting the variable ${Auth::CREDENTIALS_LIFETIME_SECS}.
Authentication will fail if this value is invalid.</p>

<p style="margin-top: 1em">EXIT* (Optional1) <br>
If authentication is successful, this expression is
evaluated immediately after the module&rsquo;s
authentication processing is executed (but refer to the
FLAGS directive).</p>

<p style="margin-top: 1em">EXPR (Optional1) <br>
This directive, which is required when STYLE is expr, gives
an expression that is evaluated to decide whether to grant
credentials and the DACS identity to use. See <br>
Authenticating Using an Expression[55].</p>

<p style="margin-top: 1em">FLAGS (Optional1) <br>
This directive gives control flags that are interpreted by
dacs_authenticate. Each directive consists of a
whitespace-separated list of values.</p>

<p style="margin-top: 1em">The only value currently
recognized is the keyword ident.</p>

<p style="margin-top: 1em">Important <br>
If there is more than one Auth clause, the ident flag should
ordinarily be specified in at least one of them to indicate
that the username returned by the module, if <br>
authentication is successful, is to become the
&quot;current&quot; username. Those Auth clauses without the
ident flag will not change the current username. After the
last Auth <br>
clause is processed, the current username is used in the
resulting credentials.</p>

<p style="margin-top: 1em">The ${Auth::CURRENT_USERNAME}
variable (see below) is updated only if there is exactly one
Auth clause or if the ident flag is given. This update
occurs immediately prior <br>
to execution of any EXIT* directive.</p>

<p style="margin-top: 1em">If ident is not specified in any
successfully processed Auth clause (i.e., one where
authentication succeeds), the username returned by the last
successfully processed <br>
clause is used. If the ident flag is specified in one or
more successfully processed clauses, the username returned
by the last such module will be used.</p>

<p style="margin-top: 1em">INIT* (Optional1) <br>
The given expression is evaluated immediately prior to the
URL* and EXPR expressions, all of which are evaluated before
a module&rsquo;s authentication processing is invoked.</p>

<p style="margin-top: 1em">OPTION (Optional) <br>
The directive value is a name=value pair that may be
interpreted by dacs_authenticate or the authentication
module specified by the Auth clause. It causes a variable
called <br>
name to be put into the Options namespace, which only exists
within the context of the Auth clause containing this
OPTION. The variables in this namespace are passed as <br>
arguments to the authentication module. Whitespace may not
precede or follow the &rsquo;=&rsquo; and any quotes around
the value are considered to be part of the value. A given
name may <br>
not be specified more than once within a particular Auth
clause. The Options namespace is initialized with USERNAME,
PASSWORD, AUXILIARY, DACS_JURISDICTION, and DACS_VERSION
<br>
variables. If these variables are specified by an OPTION,
the argument ordinarily used will be overridden.</p>

<p style="margin-top: 1em">For example, this directive
causes SAMBA_PORT=139 to be passed as a POST method
parameter:</p>

<p style="margin-top: 1em">OPTION
&quot;SAMBA_PORT=139&quot;</p>

<p style="margin-top: 1em">OPTION* (Optional) <br>
The given expression is evaluated before the module is
called, and after all OPTION directives and all OPTION*
directives that appear earlier. The value of the expression
<br>
must be a name=value pair, as with the OPTION directive, and
overrides any name in the Options namespace.</p>

<p style="margin-top: 1em">PASSWORD_AUDIT (Optional) <br>
This directive is used to audit password-type arguments
passed to authentication modules by dacs_authenticate,
regardless of the authentication method, against the
criteria <br>
selected by the specified constraint string, which is in the
format used by PASSWORD_CONSTRAINTS[56]. If any password
does not meet the requirements, a log message will be <br>
emitted (which does not include the password itself). The
message will be tagged as audit and sensitive; please refer
to the LOG_FILTER[57] directive. This feature can be <br>
used to notify the administrator about weak passwords.</p>

<p style="margin-top: 1em">The directive value can be a
variable name, which is matched exactly against the PASSWORD
or AUXILIARY arguments, or a keyword in one of the OPTION
directives within the same <br>
clause. In this form, the PASSWORD_CONSTRAINTS directive
must be configured and its value is used as the constraint.
In the second form, the directive value is a variable <br>
name as in the first form, followed by spaces or tabs,
followed by the constraint string to use in the syntax of
PASSWORD_CONSTRAINTS. Consider the following directives:</p>

<p style="margin-top: 1em">PASSWORD_CONSTRAINTS
&quot;8L,1C,1P&quot;</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;auth1&quot;&gt; <br>
URL
&quot;https://foo.example.com/cgi-bin/dacs/local_woof_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
PASSWORD_AUDIT &quot;PASSWORD 10L&quot; <br>
PASSWORD_AUDIT &quot;AUXILIARY&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">Here, the PASSWORD argument must
be at least ten characters long but AUXILIARY must only be
eight characters long and include an upper case character
and punctuation.</p>

<p style="margin-top: 1em">Note <br>
Not all authentication modules require a PASSWORD argument,
such as local_cas_authenticate[58] in its interactive mode.
This directive is ignored if the argument is not <br>
passed to the module.</p>

<p style="margin-top: 1em">PREDICATE (Optional1) <br>
If provided, this expression is evaluated before any other
authentication module processing is done. If there is an
evaluation error or it returns False (zero or the empty <br>
string), processing continues just as if the module were run
and indicated that authentication failed. Otherwise,
processing of the clause continues normally.</p>

<p style="margin-top: 1em">This directive provides a way to
effectively enable or disable a module based on run time
context. This can be used to configure layered
authentication or risk-based <br>
authentication because a predicate can examine various
aspects of an authentication request, such as the USERNAME,
current date and time, IP address from where the request
<br>
originates, and so on.</p>

<p style="margin-top: 1em">STYLE (Required1) <br>
Each authentication module implements one or more
authentication styles. The value of the STYLE directive is a
comma-separated list of case-insensitive style names and
style <br>
options; the order is insignificant. No whitespace is
allowed. Keywords can be abbreviated up to the indicated
minimum.</p>

<p style="margin-top: 1em">cas <br>
This style selects username/password authentication using
the Central Authentication Service (CAS)[59] protocol
through the local_cas_authenticate[58] authentication <br>
module.</p>

<p style="margin-top: 1em">cert[ificate] <br>
An X.509 client certificate, obtained from the SSL/TLS
layer, will be provided for authentication. The request must
be sent using SSL/TLS and the client certificate must <br>
be provided by Apache through the SSL_CLIENT_CERT
environment variable.</p>

<p style="margin-top: 1em">digest <br>
This selects the RFC 2617[60] Digest Access Authentication
scheme as implemented by DACS in conjunction with the
local_apache_authenticate[61] authentication module. See
<br>
HTTP Authentication[5].</p>

<p style="margin-top: 1em">expr <br>
No authentication module will be used; expression
evaluation[55] will be used instead.</p>

<p style="margin-top: 1em">infocard <br>
A self-issued or managed Information Card[62] (InfoCard)
must be provided for authentication. To be recognized, the
InfoCard must have been previously registered at this <br>
jurisdiction using dacsinfocard(1)[63],
dacs_infocard(8)[64], or dacs_managed_infocard(8)[65]. This
style is implemented by the local_infocard_authenticate[66]
<br>
authentication module.</p>

<p style="margin-top: 1em">managed_infocard <br>
A managed Information Card[62] (InfoCard) must be provided
for authentication. To be recognized, the InfoCard must have
been previously registered at this jurisdiction <br>
using dacs_managed_infocard(8)[65]. This style is
implemented by the local_infocard_authenticate[66]
authentication module.</p>

<p style="margin-top: 1em">nat[ive] <br>
The user is expected to have already authenticated through
the web server&rsquo;s native authentication mechanism
(e.g., HTTP Basic or Digest authentication, RFC 2617[60]);
<br>
DACS will import this identity without any additional
requirements. The AUTH_TYPE environment variable but be
available and have the value Basic or Digest (case <br>
insensitive), and the REMOTE_USER environment variable must
be set.</p>

<p style="margin-top: 1em">pass[word] <br>
passwd <br>
The username must be provided through a USERNAME argument
and the password must accompany the authentication request
through a PASSWORD argument.</p>

<p style="margin-top: 1em">prompt[ed] <br>
A dialog-based interaction will be conducted, such as one
based on Pluggable Authentication Modules (PAM). See
local_pam_authenticate[39].</p>

<p style="margin-top: 1em">selfissued_infocard <br>
A self-issued Information Card[62] (InfoCard) must be
provided for authentication. To be recognized, the InfoCard
must have been previously registered at this <br>
jurisdiction using dacsinfocard(1)[63] or
dacs_infocard(8)[64]. This style is implemented by the
local_infocard_authenticate[66] authentication module.</p>

<p style="margin-top: 1em">simple <br>
This style of authentication merely requires a recognized
username, provided through a USERNAME argument and therefore
offers little security. Still, it can be used in <br>
appropriate situations to authenticate a user that can
provide a valid account name, which might be a membership
number or randomly generated (and perhaps hard to guess)
<br>
username. If a PASSWORD argument is provided, it is logged
as sensitive data, much as an anonymous FTP password might
be logged. This style is implemented by the <br>
local_simple_authenticate[67] authentication module.</p>

<p style="margin-top: 1em">tgma <br>
Experimental. This interactive style of authentication
requires only USERNAME and JURISDICTION arguments to be
selected by the user. Refer to the TGMA authentication <br>
module for details.</p>

<p style="margin-top: 1em">This style is implemented by the
local_tgma_authenticate[68] authentication module.</p>

<p style="margin-top: 1em">set_roles <br>
If the authentication module returns roles, this style
modifier says that they should override any other roles
currently in effect and no roles module should be executed.
<br>
This option may appear at most once among all Auth clauses
and only if add_roles[69] is not used.</p>

<p style="margin-top: 1em">add_roles <br>
If the authentication module returns roles, this style
modifier says that they should be appended to any other
roles currently in effect. Any configured roles modules <br>
will still be executed. This option may be repeated in other
Auth clauses but may not appear if the set_roles[70] option
also appears.</p>

<p style="margin-top: 1em">URL (Optional1) <br>
URL* (Optional1) <br>
Exactly one of these two directives must be specified,
except when STYLE is expr, where neither directive is used.
These directives specify the URL to be used to invoke the
<br>
authentication module. Use of an absolute URL is
recommended.</p>

<p style="margin-top: 1em">The difference between the two
directives is that the value of URL* is an expression that
is evaluated immediately before the module is invoked to
determine the URL to be <br>
used.</p>

<p style="margin-top: 1em">In the current implementation,
the standard set of modules must run within the context of a
DACS jurisdiction. This is not an architectural limitation,
however.</p>

<p style="margin-top: 1em">Tip <br>
Some authentication modules are available as built-in
components of dacs_authenticate and dacsauth. These modules
are identified by specific relative URLs. A module&rsquo;s
<br>
description will provide its built-in name when this
capability is available. The built-in capability will
automatically be provided if the module has been enabled at
<br>
build-time.</p>

<p style="margin-top: 1em">Although it will be more
efficient (and possibly more secure) to use a built-in
module, they are executed on the same host as
dacs_authenticate thereby giving up some <br>
flexibility because access control rules are not applied to
them (other than the one for dacs_authenticate), and
dacs_authenticate may need to be executed setuid root or
<br>
setgid www so that it can access password files. When an
external module is used, it is subject to normal DACS access
control rules. In contrast to a built-in module, the <br>
additional level of indirection makes it simple to
substitute a custom version of an external module. The same
comments apply to dacsauth.</p>

<p style="margin-top: 1em">Here is an example of a
configuration that will authenticate using Unix user names
and passwords:</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;passwd&quot;&gt; <br>
URL
&quot;https://foo.example.com:8443/cgi-bin/dacs/local_unix_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">In the following example,
dacs_authenticate will first try to authenticate using a
Unix login name and password; if that fails, it will then
try a DACS account name and password.</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;passwd&quot;&gt; <br>
URL
&quot;https://foo.example.com:8443/cgi-bin/dacs/local_unix_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;passwd2&quot;&gt; <br>
URL
&quot;https://foo2.example.com/cgi-bin/dacs/local_passwd_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">The preceding example can be
changed to try authenticating using a DACS account name and
password if and only if the AUXILIARY argument has the value
&quot;guest&quot; (which might have <br>
been provided when the user selected a button on a login
form):</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;passwd&quot;&gt; <br>
URL
&quot;https://foo.example.com:8443/cgi-bin/dacs/local_unix_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
PREDICATE &rsquo;${Args::AUXILIARY} ne
&quot;guest&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;passwd2&quot;&gt; <br>
URL
&quot;https://foo2.example.com/cgi-bin/dacs/local_passwd_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
PREDICATE &rsquo;${Args::AUXILIARY} eq
&quot;guest&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">In this example, a jurisdiction
offers users a choice from among three authentication
methods: a Googleaccount, a Windows NTLM account, or a DACS
password-based account. The <br>
jurisdiction&rsquo;s login form would be written to provide
the appropriate AUTH_ID argument for the corresponding
method;</p>

<p style="margin-top: 1em"># For AUTH_ID=google <br>
&lt;Auth id=&quot;google&quot;&gt; <br>
URL &quot;local_http_authenticate&quot; <br>
STYLE &quot;password&quot; <br>
CONTROL &quot;user_sufficient&quot; <br>
OPTION
&rsquo;AUTH_URL=&quot;https://www.google.com/accounts/ClientLogin&quot;&rsquo;
<br>
OPTION &rsquo;AUTH_METHOD=POST&rsquo; <br>
OPTION &rsquo;USERNAME_PARAMETER=&quot;Email&quot;&rsquo;
<br>
OPTION &rsquo;PASSWORD_PARAMETER=&quot;Passwd&quot;&rsquo;
<br>
OPTION &rsquo;service=xapi&rsquo; <br>
OPTION &quot;source=DSS-DACS-1.4&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em"># For AUTH_ID=ntlm <br>
&lt;Auth id=&quot;ntlm&quot;&gt; <br>
URL &quot;local__ntlm_authenticate&quot; <br>
STYLE &quot;password&quot; <br>
CONTROL &quot;user_sufficient&quot; <br>
OPTION
&rsquo;SAMBA_SERVER=&quot;samba.example.com&quot;&rsquo;
<br>
OPTION &rsquo;SAMBA_PORT=&quot;139&quot;&rsquo; <br>
EXIT*
&rsquo;${Auth::CURRENT_USERNAME}=strtr(${Auth::CURRENT_USERNAME},
&quot;a-z&quot;, &quot;A-Z&quot;)&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em"># For AUTH_ID=passwd <br>
&lt;Auth id=&quot;passwd&quot;&gt; <br>
URL &quot;local_passwd_authenticate&quot; <br>
STYLE &quot;password&quot; <br>
CONTROL &quot;user_sufficient&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">Initialization and the Auth
Namespace <br>
dacs_authenticate uses a variable namespace called Auth to
make authentication-related context available to its
configuration directives (see dacs.exprs(5)[71]). Aspects of
<br>
dacs_authenticate&rsquo;s behaviour can be controlled by
modifying these variables. This namespace disappears when
dacs_authenticate terminates. The next section describes how
these <br>
variables are used.</p>

<p style="margin-top: 1em">Additionally, all environment
variables are accessible through the Env namespace (e.g.,
${Env::REMOTE_ADDR}) during authentication processing.</p>

<p style="margin-top: 1em">Authentication Clause Control
Flow <br>
Auth clauses are processed in the order in which they appear
in the configuration file, subject to the semantics of the
CONTROL directives.</p>

<p style="margin-top: 1em">dacs_authenticate is typically
configured so that the last thing it does is to redirect its
caller to an appropriate web page. If authentication is
successful, any <br>
AUTH_SUCCESS[72] expression is evaluated and the
AUTH_SUCCESS_HANDLER[73] directive is consulted; if
authentication fails, the AUTH_ERROR_HANDLER[74] and
AUTH_FAIL_DELAY_SECS[75] <br>
directives are used. This behaviour is partially under the
control of the caller through the
DACS_AUTH_SUCCESS_HANDLER[76] and ENABLE_AUTH_HANDLERS[77]
arguments, however.</p>

<p style="margin-top: 1em">Tip <br>
To redirect the newly authenticated user to a web page based
on the user&rsquo;s identity, jurisdiction, roles, or other
contextual state, configure AUTH_SUCCESS_HANDLER to specify
<br>
the URL of a DACS-wrapped CGI program. After examining
environment variables automatically passed to it by DACS or
its query arguments, this program can emit an appropriate
<br>
redirect. To test this, configure:</p>

<p style="margin-top: 1em">AUTH_SUCCESS_HANDLER &quot;url
/cgi-bin/dacs/dacs_prenv&quot;</p>

<p style="margin-top: 1em">(making sure that
dacs_prenv(8)[78] has been installed) and examine the
information that is available.</p>

<p style="margin-top: 1em">An Auth clause is processed in a
sequence of steps, and with various hooks to provide
fine-grained control. Only advanced DACS administrators
usually need to be concerned with <br>
this level of detail.</p>

<p style="margin-top: 1em">Before the first clause is
examined, the variable ${Auth::CURRENT_USERNAME} is set to
the empty string; this variable is automatically updated by
dacs_authenticate. The contents <br>
of the Args, DACS, Conf, and Env namespaces[71] are made
available to all expressions evaluated during authentication
module processing. Processing of each Auth clause is <br>
performed in the following sequence:</p>

<p style="margin-top: 1em">1. If the clause has a PREDICATE
directive, it is evaluated in the current context. If the
value is not True (including cases where the expression was
invalid), processing of <br>
the clause terminates immediately with the same result as if
its authentication had been unsuccessful.</p>

<p style="margin-top: 1em">2. If a variable named
${Auth::ABORT} has the value yes (case insensitive),
authentication terminates. If the variable
${Auth::MODULE_SKIP} has the value yes (case insensitive),
<br>
processing of the clause terminates immediately with the
same result as if its authentication had been
unsuccessful.</p>

<p style="margin-top: 1em">3. If the clause has an INIT*
directive, it is evaluated; if an error occurs,
authentication terminates.</p>

<p style="margin-top: 1em">4. If the clause has a URL
directive, it names the authentication module to be invoked
(or is the name of a built-in module).</p>

<p style="margin-top: 1em">If the URL* directive is used
instead, it is evaluated to obtain the URL to be invoked; if
an error occurs, authentication terminates.</p>

<p style="margin-top: 1em">5. If a variable named
${Auth::ABORT} has the value yes (case insensitive),
authentication terminates. If the variable
${Auth::MODULE_SKIP} has the value yes (case insensitive),
<br>
processing of the clause terminates immediately with the
same result as if its authentication had been
unsuccessful.</p>

<p style="margin-top: 1em">6. If the clause&rsquo;s STYLE
is expr, the EXPR directive is evaluated and is expected to
either return False or a valid DACS username. If the
expression&rsquo;s value is False, processing <br>
of the clause terminates immediately with the same result as
if its authentication had been unsuccessful; if its value is
an invalid username, authentication terminates, <br>
otherwise the module is deemed to have been successful. If
an error occurs, authentication terminates.</p>

<p style="margin-top: 1em">If the clause&rsquo;s STYLE is
not expr, the authentication module is invoked.</p>

<p style="margin-top: 1em">7. If an error occurs while
executing the authentication module, authentication
terminates. If the authentication module does not
authenticate the user, the CONTROL directive <br>
determines whether authentication fails or continues.</p>

<p style="margin-top: 1em">The username passed to the
module, or returned by the module, becomes the tentative
DACS username and the variable ${Auth::CURRENT_USERNAME} is
set to it. If the variable <br>
${Auth::ROLES} is set to a valid role descriptor, it becomes
the current tentative roles for the user.</p>

<p style="margin-top: 1em">8. The expression given by the
EXIT* directive, if any, is evaluated. If an error occurs,
authentication terminates. The expression may update
${Auth::CURRENT_USERNAME}. For <br>
instance, the directive:</p>

<p style="margin-top: 1em">EXIT*
&rsquo;${Auth::CURRENT_USERNAME}=&quot;bobo&quot;&rsquo;</p>

<p style="margin-top: 1em">completely ignores the username
returned by the module and simply assigns one, while this
directive:</p>

<p style="margin-top: 1em">EXIT*
&rsquo;${Auth::CURRENT_USERNAME} =
strtr(${Auth::CURRENT_USERNAME}, &quot;A-Z&quot;,
&quot;a-z&quot;)&rsquo;</p>

<p style="margin-top: 1em">converts all upper case
characters in the username returned by the module to their
lower case equivalents.</p>

<p style="margin-top: 1em">9. If a variable named
${Auth::ABORT} has the value yes (case insensitive),
authentication terminates despite success of the module. If
the variable ${Auth::MODULE_SKIP} has the <br>
value yes (case insensitive), processing of the clause
terminates immediately with the same result as if its
authentication had been unsuccessful.</p>

<p style="margin-top: 1em">The value of
${Auth::CURRENT_USERNAME} when the last module has been
processed is the username that will be assigned to a
successfully authenticated user. If set, the value of <br>
${Auth::CREDENTIALS_LIFETIME_SECS} will be used as the
lifetime of the generated credentials; if not set, the value
returned by the last successful authentication module is
used <br>
(typically that of the module&rsquo;s
CREDENTIALS_LIFETIME_SECS directive), if available, or the
jurisdiction&rsquo;s CREDENTIALS_LIFETIME_SECS
directive&rsquo;s value.</p>

<p style="margin-top: 1em">Authenticating Using an
Expression <br>
Rather than using an authentication module, the expr style
of authentication involves evaluating an expression. The
value of the expression is the DACS username to associate
with <br>
the user. If no value is returned, an invalid value is
returned, or an error occurs, the Auth clause fails.</p>

<p style="margin-top: 1em">Here is a simple example that is
unlikely to be used in practice. If the PASSWORD argument is
&quot;xyzzy&quot;, then authentication will succeed and the
user will be assigned the DACS <br>
username bobo.</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;expr1&quot;&gt; <br>
STYLE &quot;expr&quot; <br>
CONTROL &quot;sufficient&quot; <br>
EXPR &rsquo;${Args::PASSWORD} eq &quot;xyzzy&quot; ?
&quot;bobo&quot; : &quot;&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">This example illustrates how an
expression can be used to read a password (its hex-encoded
SHA-256 hash, actually) from a file and compare it with the
one provided in the service <br>
request. Each user has his own password file that consists
of a single line of text containing the hash. If a username
is given that does not have a corresponding password file,
<br>
or if the hash of the provided password does not match the
stored one, the Auth clause will fail, otherwise the given
username is returned as the authenticated name.</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;expr5&quot;&gt; <br>
STYLE &quot;expr&quot; <br>
EXPR &rsquo;${pwd} =
get(&quot;/usr/local/dacs/pwd/pwd.&quot; .
${Args::USERNAME}); digest(${Args::PASSWORD}, 0, sha256) eq
decode(hex, ${pwd}) ? ${Args::USERNAME} :
&quot;&quot;&rsquo; <br>
CONTROL &quot;sufficient&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">The expression can also assign a
valid role string to ${Auth::ROLES} to establish roles for
the user (in conjunction with the add_roles[69] or
set_roles[70] style modifier):</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;expr2&quot;&gt; <br>
STYLE &quot;expr,add_roles&quot; <br>
CONTROL &quot;sufficient&quot; <br>
EXPR &rsquo;${Auth::ROLES}=&quot;foo,bar&quot;;
${Args::PASSWORD} eq &quot;xyzzy&quot; ? &quot;bobo&quot; :
&quot;&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">This style of authentication can
be a useful alternative to the cert style with the
local_cert_authenticate module. If the client has provided
an X.509 certificate that has been <br>
adequately verified by the web server, then in many cases
all that remains to be done is to assign a syntactically
valid DACS username to the client. Environment variables[79]
<br>
created by mod_ssl[80] can be referenced as
${Auth::ssl_variable_name}. Something such as the following
might be suitable:</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;expr3&quot;&gt; <br>
STYLE &quot;expr&quot; <br>
CONTROL &quot;sufficient&quot; <br>
EXPR &rsquo;${Auth::SSL_CLIENT_VERIFY} eq
&quot;SUCCESS&quot; and <br>
${Auth::SSL_CLIENT_S_DN_Email:ei} ?
${Auth::SSL_CLIENT_S_DN_Email:i} : &quot;&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">Another application of this
style of authentication is where it is the location of the
user that is important rather than the user&rsquo;s identity
per se. For example, if a system <br>
administrator needs to restrict access to a web server to
the hosts in a lab or desktops in a group of offices (that
presumably share a subnet) but does not require individual
<br>
users to authenticate, a configuration like the following
might be adequate:</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;expr4&quot;&gt; <br>
STYLE &quot;expr&quot; <br>
CONTROL &quot;sufficient&quot; <br>
EXPR &rsquo;${Auth::CURRENT_USERNAME} =
&quot;user-${Env::REMOTE_ADDR}&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">A user would not provide a
username or a password; by simply clicking on a link that
invokes dacs_authenticate, a user from the computer with IP
address 10.0.0.213 (for example) <br>
would be assigned the identity user-10.0.0.213. Access
control rules could be expressed in terms of those
identities or the corresponding IP addresses.</p>

<p style="margin-top: 1em">Middleware Support <br>
As with most DACS web services, the FORMAT argument can be
used to request a particular type of output (see
dacs.services(8)[81]) from dacs_authenticate. If any XML
type is <br>
specified, the reply from dacs_authenticate will conform to
the DTD dacs_auth_reply.dtd[82]. The reply indicates whether
the user has been successfully authenticated or not. If <br>
authentication was successful, a description of the new
credentials is returned as a dacs_current_credentials
element, (as described by dacs_current_credentials.dtd[83]).
If <br>
authentication was unsuccessful because of a transient error
condition, a reason may optionally be provided.</p>

<p style="margin-top: 1em">Security <br>
This reason is solely used to inform the user; it should not
reveal any details that might compromise security.</p>

<p style="margin-top: 1em">Authentication modules return an
auth_reply.dtd[84] document to dacs_authenticate.</p>

<p style="margin-top: 1em">Authentication Modules <br>
Important <br>
DACS provides a set of authentication modules. At the time
DACS is compiled, some standard modules are enabled by
default while others needed must be specifically enabled
<br>
(see dacs.install(7)[85]). You should not enable
authentication modules that you do not plan to use.</p>

<p style="margin-top: 1em">Security <br>
&Acirc;&middot; As a security measure, these modules should
be executable only by dacs_authenticate, which is the
default.</p>

<p style="margin-top: 1em">&Acirc;&middot; By default,
access control rules are configured to restrict access to
all authentication and roles modules. This prevents an
attacker from calling an authentication <br>
module directly in an attempt to guess account names,
passwords, and so on.</p>

<p style="margin-top: 1em">&Acirc;&middot; Modules may need
to be installed setuid or setgid as appropriate so that it
is possible for them to read the password files that they
require or obtain encryption keys.</p>

<p style="margin-top: 1em">&Acirc;&middot; Modules may need
to be installed setuid or setgid, and never run as the UID
of a less-privileged user, so that it is impossible to
circumvent the module&rsquo;s functionality <br>
(e.g., by attaching to the running module with a
debugger).</p>

<p style="margin-top: 1em">Each authentication module is
called with the following arguments. Authentication modules
are always invoked using the POST method.</p>

<p style="margin-top: 1em">AUXILIARY <br>
The value of the AUXILIARY argument to dacs_authenticate if
one was given, otherwise the empty string.</p>

<p style="margin-top: 1em">DACS_JURISDICTION <br>
The value of the DACS_JURISDICTION argument to
dacs_authenticate.</p>

<p style="margin-top: 1em">DACS_VERSION <br>
The DACS_VERSION_NUMBER for this version of
dacs_authenticate.</p>

<p style="margin-top: 1em">PASSWORD <br>
The value of the PASSWORD argument to dacs_authenticate if
one was given, otherwise the empty string.</p>

<p style="margin-top: 1em">USERNAME <br>
The value of the USERNAME argument to dacs_authenticate.</p>

<p style="margin-top: 1em">Directives <br>
Each directive in the Auth section being processed and its
value is passed.</p>

<p style="margin-top: 1em">SSL/TLS environment variables
<br>
Each SSL/TLS environment variable passed to
dacs_authenticate is passed.</p>

<p style="margin-top: 1em">Transaction state data <br>
With respect to the prompted style of authentication,
transaction state variables are passed. <br>
Ordinarily, a particular argument may not appear more than
once.</p>

<p style="margin-top: 1em">Authentication Module Index:</p>

<p style="margin-top: 1em">1. local_apache_authenticate:
Password-protected accounts maintained by Apache
utilities</p>

<p style="margin-top: 1em">2. local_cas_authenticate:
Central Authentication Service (CAS)</p>

<p style="margin-top: 1em">3. local_cert_authenticate:
SSL-based X.509 client certificates</p>

<p style="margin-top: 1em">4. local_grid_authenticate:
Grid-based one-time passwords</p>

<p style="margin-top: 1em">5. local_http_authenticate:
Generic authentication via HTTP</p>

<p style="margin-top: 1em">6. local_infocard_authenticate:
Information Card-based accounts and identities</p>

<p style="margin-top: 1em">7. local_ldap_authenticate:
Lightweight Directory Access Protocol (LDAP) / Microsoft
Active Directory</p>

<p style="margin-top: 1em">8. local_native_authenticate:
Importing an identity established by Apache</p>

<p style="margin-top: 1em">9. local_ntlm_authenticate:
Microsoft Windows NT LAN Manager usernames and passwords</p>

<p style="margin-top: 1em">10. local_pam_authenticate:
Pluggable Authentication Modules (PAM)</p>

<p style="margin-top: 1em">11. local_passwd_authenticate:
Password-protected DACS accounts</p>

<p style="margin-top: 1em">12. local_simple_authenticate:
Account name without a password</p>

<p style="margin-top: 1em">13. local_tgma_authenticate:
Time-Gated Mutual Authentication (experimental)</p>

<p style="margin-top: 1em">14. local_token_authenticate:
One-time passwords, two-factor authentication</p>

<p style="margin-top: 1em">15. local_unix_authenticate:
Unix usernames and passwords</p>

<p style="margin-top: 1em">local_apache_authenticate <br>
The local_apache_authenticate module is used to authenticate
against password files used by the Apache mod_auth[86],
mod_auth_digest[87], or mod_auth_dbm[88] modules. These <br>
password files are managed by Apache&rsquo;s
htpasswd(1)[89], htdigest(1)[90], and htdbm(1)[91]
utilities, respectively. An administrator can configure DACS
to use an existing <br>
htpasswd file, for instance, and so avoid dealing with
creating and managing a duplicate set of usernames and
passwords.</p>

<p style="margin-top: 1em">If HTTP Basic authentication
(RFC 2617[60]) is used, the STYLE should be password. If
Digest authentication is used, because no password is passed
to DACS, the STYLE for this <br>
module should be configured as digest.</p>

<p style="margin-top: 1em">The following configuration
options are recognized by this module. They should be
provided using the OPTION directive.</p>

<p style="margin-top: 1em">AUTH_MODULE <br>
This must be &quot;mod_auth&quot; (or &quot;htpasswd&quot;),
&quot;mod_auth_digest&quot; (or &quot;htdigest&quot;), or
&quot;mod_auth_dbm&quot; (or &quot;htdbm&quot;), depending
on which module&rsquo;s authentication method is to be <br>
used. This value is case-insensitive.</p>

<p style="margin-top: 1em">AUTH_FILE <br>
This is the absolute pathname of the flat-file or database
file to use.</p>

<p style="margin-top: 1em">Note <br>
This pathname is resolved on the host that runs this module.
This should eventually be extended to accept a DACS virtual
filestore URI.</p>

<p style="margin-top: 1em">DBM_TYPE <br>
Required only in conjunction with mod_auth_dbm
compatibility, this argument identifies the database format
of AUTH_FILE. The names &quot;sdbm&quot; (not yet
implemented), &quot;gdbm&quot;, <br>
&quot;ndbm&quot;, and &quot;db&quot; are recognized,
although not all types may be available on a particular
platform.</p>

<p style="margin-top: 1em">Notes <br>
&Acirc;&middot; This module does not rely on any Apache
module (other than mod_auth_dacs).</p>

<p style="margin-top: 1em">&Acirc;&middot; This module does
not require any Apache configuration with respect to
authentication; only DACS needs to be configured.</p>

<p style="margin-top: 1em">&Acirc;&middot; It is not
necessary to use DACS&rsquo;s HTTP Authentication[5] feature
in order to use this module. For example, using HTTP Basic
authentication (RFC 2617[60]), the <br>
USERNAME and PASSWORD arguments can be submitted from a
site&rsquo;s login page and verified by this module against
an htpasswd file.</p>

<p style="margin-top: 1em">&Acirc;&middot; htpasswd allows
plaintext passwords to be stored in a password file,
although httpd apparently restricts the use of these
passwords. This module imposes no such <br>
restrictions. Under normal circumstances passwords should
not be stored in plaintext form.</p>

<p style="margin-top: 1em">&Acirc;&middot; The major
difference between this module and
local_native_authenticate[92] is that the latter
&quot;imports&quot; an identity already established by an
Apache authentication <br>
module, whereas this module authenticates using information
that can also be used by Apache and which is administered
using Apache utiltities.</p>

<p style="margin-top: 1em">&Acirc;&middot; DACS will access
Apache password files in read-only mode only; DACS never
modifies those files.</p>

<p style="margin-top: 1em">&Acirc;&middot; Some platforms
may not support all possible DBM-type databases and some
types of database may not have been configured at
build-time.</p>

<p style="margin-top: 1em">Here is an example configuration
that uses an htpasswd-managed file for authentication:</p>

<p style="margin-top: 1em">HTTP_AUTH_ENABLE &quot;yes&quot;
<br>
HTTP_AUTH &quot;Basic</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;apache-htpasswd&quot;&gt; <br>
URL
&quot;https://example.com/cgi-bin/dacs/local_apache_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
OPTION
&quot;AUTH_FILE=/usr/local/apache2/conf/passwords&quot; <br>
OPTION &quot;AUTH_MODULE=mod_auth&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">If the passwords were kept in a
Berkeley DB database instead, the configuration might look
like:</p>

<p style="margin-top: 1em">HTTP_AUTH_ENABLE &quot;yes&quot;
<br>
HTTP_AUTH &quot;Basic</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;apache-htpasswd&quot;&gt; <br>
URL
&quot;https://example.com/cgi-bin/dacs/local_apache_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
OPTION
&quot;AUTH_FILE=/usr/local/apache2/conf/passwords.db&quot;
<br>
OPTION &quot;AUTH_MODULE=mod_auth_dbm&quot; <br>
OPTION &quot;DBM_TYPE=db&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">This example configuration is
similar; the difference is that the username and password
obtained through HTTP Basic authentication are verified
against a Unix account:</p>

<p style="margin-top: 1em">HTTP_AUTH_ENABLE &quot;yes&quot;
<br>
HTTP_AUTH &quot;Basic</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;basic&quot;&gt; <br>
URL
&quot;https://example.com/cgi-bin/dacs/local_unix_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">This example configures HTTP
Digest authentication and references an htdigest-managed
file:</p>

<p style="margin-top: 1em">HTTP_AUTH_ENABLE &quot;yes&quot;
<br>
HTTP_AUTH &quot;Digest</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;apache-htdigest&quot;&gt; <br>
URL &quot;apache&quot; <br>
STYLE &quot;digest&quot; <br>
CONTROL &quot;sufficient&quot; <br>
OPTION
&quot;AUTH_FILE=/usr/local/apache2/conf/passwords.digest&quot;
<br>
OPTION &quot;AUTH_MODULE=mod_auth_digest&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_apache_authenticate or just apache.</p>

<p style="margin-top: 1em">local_cas_authenticate <br>
This module coordinates with a specified Central
Authentication Service (CAS)[93] server to authenticate a
user that is purportedly known to that server. The module
<br>
implements the client side of the CAS 2.0 Protocol[94] and
can be used in two different modes: interactive and
non-interactive.</p>

<p style="margin-top: 1em">Interactive mode is employed if
neither a USERNAME nor a PASSWORD argument is given to
dacs_authenticate. When dacs_authenticate is called, whether
directly or as the result <br>
of redirection after access was denied to an unauthenticated
user, it redirects the user to a CAS login page. After
successful CAS authentication (which may return a ticket
<br>
granting cookie to the user&rsquo;s browser), CAS redirects
the user to dacs_authenticate, passing it the CAS session
ticket as an argument called ticket. After successfully <br>
validating the session ticket at the CAS server, DACS
authentication succeeds.</p>

<p style="margin-top: 1em">Security <br>
When interactive mode is used, DACS does not see the
username and password, only CAS does. The username is
obtained by the module as part of the session ticket
validation <br>
protocol. This mode of operation is similar to, but simpler
than, the OpenID[95] Authentication protocol.</p>

<p style="margin-top: 1em">A variant of this flow of
control can occur if the user has authenticated against the
CAS server outside of DACS and therefore holds a ticket
granting cookie. This cookie <br>
will automatically be sent by the user&rsquo;s browser when
it is redirected to the CAS server; as a result, the CAS
server may not prompt the user to authenticate.</p>

<p style="margin-top: 1em">In non-interactive mode, both a
USERNAME and a PASSWORD argument are passed to
dacs_authenticate. This module will use these arguments to
authenticate the user against the <br>
CAS server. In this mode, no ticket granting cookie will be
returned to the user. This mode can be used with the DACS
HTTP authentication[5] feature.</p>

<p style="margin-top: 1em">The STYLE should be configured
as cas for this module.</p>

<p style="margin-top: 1em">The following module-specific
OPTION directive value is understood:</p>

<p style="margin-top: 1em">CAS_SERVER_URI (Required1) <br>
This is the URI of the CAS server to authenticate against.
For example, dacs.conf might contain authentication
configuration similar to the following:</p>

<p style="margin-top: 1em">&lt;Auth id=&quot;CAS&quot;&gt;
<br>
URL &quot;cas&quot; <br>
STYLE &quot;cas&quot; <br>
CONTROL &quot;sufficient&quot; <br>
OPTION
&quot;CAS_SERVER_URI=https://cas.example.com/castest&quot;
<br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">The module recognizes the
following arguments (which are automatically passed to it as
necessary by dacs_authenticate):</p>

<p style="margin-top: 1em">CAS_TICKET (Required1-C) <br>
This is the session ticket returned by CAS via a callback to
dacs_authenticate (i.e., the ticket argument).</p>

<p style="margin-top: 1em">CAS_REDIRECT_ARGS (Optional1)
<br>
These are additional arguments to dacs_authenticate that
must be provided when CAS performs its callback to
dacs_authenticate to preserve user preferences. The <br>
DACS_BROWSER, FORMAT, DACS_ERROR_URL, and
ENABLE_AUTH_HANDLERS arguments may be forwarded in this
way.</p>

<p style="margin-top: 1em">CAS_SERVER_URI (Required1-C)
<br>
This argument has the value specified in the Auth
clause&rsquo;s OPTION directive. Note that HTTP redirects
are not handled in this context, so invoking GET on
CAS_SERVER_URI <br>
must return a valid document.</p>

<p style="margin-top: 1em">Note <br>
The local_cas_authenticate module extends the response of
the validate service of the CAS protocol to allow a role
descriptor string (role_string) to be returned. If <br>
authentication succeeds, the standard service returns the
following text: yes0sername</p>

<p style="margin-top: 1em">An invalid role string is
discarded. If these roles should be used, it will be
necessary to use either the set_roles[70] or add_roles[69]
style modifier with the <br>
STYLE[96] directive.</p>

<p style="margin-top: 1em">Tip <br>
The authentication procedure described by the CAS protocol
is notable because the authentication material provided by
the user in interactive mode does not flow through <br>
DACS; in particular, DACS does not see a user&rsquo;s
password when this module is used. This may be an important
consideration in some environments.</p>

<p style="margin-top: 1em">Because the protocol implemented
by this module is general purpose and relatively simple,
writing middleware that implements a subset of the
server-side CAS protocol to <br>
interface with this module may be a sensible solution for
DACS administrators who require a CAS-like control flow but
do not want to use actual CAS server-side software. <br>
The user would be redirected to the middleware component by
local_cas_authenticate to perform the /login service; then
it would prompt and authenticate the user, and <br>
redirect the user to a URL provided to it by
local_cas_authenticate; then local_cas_authenticate would
call the middleware component directly, this time to perform
the <br>
/validate service. The usual flow of control within DACS
would follow.</p>

<p style="margin-top: 1em">A simple script for testing and
working with local_cas_authenticate is available in
src/cas_middleware_test.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_cas_authenticate or just cas.</p>

<p style="margin-top: 1em">local_cert_authenticate <br>
The local_cert_authenticate module authenticates a user that
supplies an acceptable X.509 client certificate via SSL/TLS.
Apache must be appropriately configured to request <br>
and verify client certificates, check for revocation, and so
on (see SSLVerifyClient[97] and related directives). As part
of the SSL/TLS protocol, Apache&rsquo;s mod_ssl[80] module
<br>
verifies that the client possesses the private key that
corresponds to the client certificate. Apache will usually
be configured to verify the correctness and suitability of
<br>
the client certificate. Apache directives such as
SSLRequire[98] might be used, for example.</p>

<p style="margin-top: 1em">The STYLE should be configured
as certificate for this module.</p>

<p style="margin-top: 1em">The verification of the client
certificate done by Apache may be sufficient, in which case
the only remaining configuration task for the Auth clause is
to assign a username <br>
and possibly extract role information from the certificate;
it may impose additional tests on the certificate, however,
by inspecting its fields. If verification beyond the <br>
ability of mod_ssl[80] is required, or if it needs to be
performed on a system other than where the web server is
running, local_cert_authenticate can execute an external
<br>
program to decide whether the client certificate is suitable
for authentication. This program is currently limited to
OpenSSL[99] but this may be generalized in future <br>
versions.</p>

<p style="margin-top: 1em">To ensure that
local_cert_authenticate is able to obtain information
contained within the client certificate, Apache must be
configured so that StdEnvVars and ExportCertData <br>
are enabled in an appropriate SSLOptions[100] directive,
such as the following:</p>

<p style="margin-top: 1em">SSLOptions +StdEnvVars
+ExportCertData</p>

<p style="margin-top: 1em">The following configuration
directives are specific to this module:</p>

<p style="margin-top: 1em">CERT_CA_PATH (Required1) <br>
This is the absolute pathname of a directory that contains
trusted certificates. Refer to the -CApath argument to
OpenSSL&rsquo;s verify command.</p>

<p style="margin-top: 1em">CERT_DUMP_CLIENT (Optional1)
<br>
If configured, this gives the absolute pathname of a file to
which the client certificate is to be written in PEM format.
The file is created or truncated, as necessary. <br>
This is useful for debugging purposes.</p>

<p style="margin-top: 1em">CERT_NAME_ATTR (Optional1) <br>
If this directive is configured, it gives the name of an
SSL/TLS environment variable[79]. The value of that variable
is used as a key for the certnamemap item type <br>
(which must also be configured); the key&rsquo;s value
becomes the username returned by the module (if the
environment variable is not found or the lookup is
unsuccessful, the <br>
module will fail to authenticate the user). If the module is
not fully configured for this lookup, the value of the
USERNAME is returned by the module.</p>

<p style="margin-top: 1em">To illustrate this, consider the
following configuration:</p>

<p style="margin-top: 1em">VFS
&quot;[certmap]dacs-kwv-fs:/usr/local/dacs/federations/certnamemap&quot;</p>

<p style="margin-top: 1em">&lt;Auth id=&quot;cert&quot;&gt;
<br>
URL
&quot;https://example.com/cgi-bin/dacs/local_cert_authenticate&quot;
<br>
STYLE &quot;cert&quot; <br>
CONTROL &quot;sufficient&quot; <br>
CERT_CA_PATH &quot;/usr/local/apache2/conf/ssl.crt&quot;
<br>
CERT_NAME_ATTR &quot;SSL_CLIENT_S_DN_CN&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">with the file
/usr/local/dacs/federations/certnamemap containing the two
lines:</p>

<p style="margin-top: 1em">Clark Kent:superman <br>
Bruce Wayne:batman</p>

<p style="margin-top: 1em">Given the configuration above,
if the value of the SSL_CLIENT_S_DN_CN environment variable
is &quot;Clark Kent&quot;, the username returned by the
module will be &quot;superman&quot;.</p>

<p style="margin-top: 1em">As with any module, an
expression can be used within an Auth clause to modify or
override the value returned by a module.</p>

<p style="margin-top: 1em">CERT_OPENSSL_PATH (Optional1)
<br>
This is the absolute pathname of the openssl program. If not
provided, a build-time value is used (OPENSSL_PATH).</p>

<p style="margin-top: 1em">Security <br>
The lifetime of credentials obtained through the local
authentication service may be independent of the validity
period of the certificate presented for authentication. <br>
It is therefore possible for the certificate to expire
before the DACS credentials. The local authentication
service might take this into consideration before granting
<br>
access and when computing a lifetime for the resulting DACS
credentials.</p>

<p style="margin-top: 1em">local_grid_authenticate <br>
This module works in concert with the dacsgrid(1)[101]
utility to provide users with one-time passwords. It is also
an approximation of the &quot;something you have&quot;
factor of <br>
two-factor authentication.</p>

<p style="margin-top: 1em">The STYLE should be configured
as password for this module.</p>

<p style="margin-top: 1em">Please refer to dacsgrid(1)[101]
for a complete description.</p>

<p style="margin-top: 1em">In addition to the usual
USERNAME argument, the module requires the PASSWORD argument
to be the user&rsquo;s response to the challenge and the
AUXILIARY argument to be the encoded <br>
challenge. The latter two arguments must be produced by
dacsgrid(1)[101].</p>

<p style="margin-top: 1em">The following OPTION directive
values are understood:</p>

<p style="margin-top: 1em">AUTH_GRID_CHALLENGE_SECS
(Optional1) <br>
The number of seconds between when a challenge is created
and when it expires, overriding the default value. This
value should be relatively small, at most on the order <br>
of a few tens of seconds. If this module runs on a host
other than the one running dacs_authenticate, the two system
clocks must be suitably synchronized.</p>

<p style="margin-top: 1em">AUTH_GRID_LIFETIME_SECS
(Optional1) <br>
The length of time, in seconds, for which a grid is valid.
After this period, all authentication against a grid will
fail.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_grid_authenticate or just grid.</p>

<p style="margin-top: 1em">local_http_authenticate <br>
This module authenticates by invoking a given
(non-interactive) web service with specified arguments. If
the web service reports success by returning HTTP status
code 200 <br>
(see RFC 2616[43], Section 10), then the module succeeds,
otherwise it fails. No session is established with the web
service and no additional requests are made to it.</p>

<p style="margin-top: 1em">In its simple (default) mode of
operation, any output returned by the web service is
discarded, including cookies. The web service is used solely
to determine whether a <br>
username/password is correct. In its alternate mode, the web
service can return a document that specifies a replacement
username, lifetime of generated credentials, and a <br>
role string.</p>

<p style="margin-top: 1em">This module can be used to
authenticate against any existing web service that follows
the expected protocol, or provide a way to add a new, custom
authentication method to <br>
DACS.</p>

<p style="margin-top: 1em">The STYLE should be configured
as password for this module.</p>

<p style="margin-top: 1em">The following OPTION directive
values are understood:</p>

<p style="margin-top: 1em">AUTH_URL (Required1) <br>
The URL of the web service to invoke, which need not be
DACS-wrapped. It may use either the http or https scheme. No
DACS credentials will be sent with the request.</p>

<p style="margin-top: 1em">AUTH_METHOD (Optional1) <br>
The HTTP method to use to invoke AUTH_URL. The default is
POST. Keep in mind that if query arguments are present (or
if the GET method is used) they may appear in log <br>
files.</p>

<p style="margin-top: 1em">PASSWORD_PARAMETER (Optional1)
<br>
The name of the argument by which PASSWORD is passed to the
web service. The default is PASSWORD.</p>

<p style="margin-top: 1em">USERNAME_PARAMETER (Optional1)
<br>
The name of the argument by which USERNAME is passed to the
web service. The default is USERNAME.</p>

<p style="margin-top: 1em">USE_AUTH_REPLY (Optional1) <br>
The default behaviour is to ignore any document that is
returned by the web service. If this option is
&quot;yes&quot; or &quot;on&quot;, however, the web service
must return a syntactically <br>
valid auth_reply.dtd[84] document. For authentication to
succeed, the document must indicate successful
authentication. The contents of a valid document will
provide the <br>
username (overriding USERNAME), and, optionally, the
lifetime of the credentials and a role string. If the STYLE
directive does not include an add_roles[69] or <br>
set_roles[70] modifier, the role string will be ignored.
This capability allows a generic web service to be called
with arbitrary arguments to dynamically authenticate a <br>
user, and set an identity and roles. The returned values
must be valid.</p>

<p style="margin-top: 1em">Any other OPTION directive
values are simply passed to the invoked web service,
including any duplicate argument names.</p>

<p style="margin-top: 1em">For Google[102] account
authentication[103], for instance, the following
configuration might be used:</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;google&quot;&gt; <br>
URL &quot;local_http_authenticate&quot; <br>
STYLE &quot;password&quot; <br>
CONTROL &quot;required&quot; <br>
OPTION
&rsquo;AUTH_URL=&quot;https://www.google.com/accounts/ClientLogin&quot;&rsquo;
<br>
OPTION &rsquo;USERNAME_PARAMETER=Email&rsquo; <br>
OPTION &rsquo;PASSWORD_PARAMETER=Passwd&rsquo; <br>
OPTION &rsquo;service=xapi&rsquo; <br>
OPTION &quot;source=DSS-DACS-1.4&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">This web service returns an HTTP
status code of 200 if the correct username and password are
given (i.e., login succeeded), and 403 if login fails. If
ClientLogin fails and <br>
requests a CAPTCHA challenge the request will not be passed
back to the user.</p>

<p style="margin-top: 1em">Note <br>
One of the reasons for inclusion of this module is to
support reuse of accounts widely used by the public.
Googleprovides exactly the right interface needed by systems
<br>
such as DACS. As of 20-April-2012, Google has officially
deprecated ClientLogin. Accounts provided by eBay[104]and
Yahoo![105], for instance, do not appear to be directly <br>
usable in this way. In some cases, dacs_auth_transfer(8)[8]
may be a better approach than this module.</p>

<p style="margin-top: 1em">The following outlines a trivial
example of authentication using the USE_AUTH_REPLY
directive. Assume that the following shell script can be
invoked as <br>
http://example.com/cgi-bin/myauth:</p>

<p style="margin-top: 1em">#! /bin/sh</p>

<p style="margin-top: 1em">/bin/cat &lt;&lt;HERE</p>

<p style="margin-top: 1em">&lt;?xml version=&quot;1.0&quot;
encoding=&quot;US-ASCII&quot;?&gt; <br>
&lt;!DOCTYPE auth_reply SYSTEM
&quot;http://example.com/dacs/dtd-xsd/auth_reply.dtd&quot;&gt;
<br>
&lt;auth_reply&gt; <br>
&lt;ok username=&quot;guest&quot;&gt; <br>
&lt;roles_reply&gt; <br>
&lt;ok
roles=&quot;bigwheel,mediumwheel,littlewheel&quot;/&gt; <br>
&lt;/roles_reply&gt; <br>
&lt;/ok&gt; <br>
&lt;/auth_reply&gt; <br>
HERE</p>

<p style="margin-top: 1em">exit 0</p>

<p style="margin-top: 1em">Also assume the following Auth
clause has been configured:</p>

<p style="margin-top: 1em">&lt;Auth id=&quot;http&quot;&gt;
<br>
URL &quot;local_http_authenticate&quot; <br>
STYLE &quot;password,set_roles&quot; <br>
CONTROL &quot;required&quot; <br>
OPTION
&rsquo;AUTH_URL=&quot;http://example.com/cgi-bin/myauth&quot;&rsquo;
<br>
OPTION &rsquo;AUTH_METHOD=GET&rsquo; <br>
OPTION &rsquo;USE_AUTH_REPLY=&quot;YES&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">Invoking this URL will always
successfully authenticate any user and issue credentials for
the identity JUR1:guest with roles
bigwheel,mediumwheel,littlewheel:</p>


<p style="margin-top: 1em">https://example.com/cgi-bin/dacs/dacs_authenticate?USERNAME=alice&amp;PASSWORD=test&amp;DACS_JURISDICTION=JUR1</p>

<p style="margin-top: 1em">This expression[3] is
equivalent:</p>

<p style="margin-top: 1em">% dacsexpr -e
&rsquo;dacsauth(&quot;-m http passwd,set_roles suff
-OAUTH_URL=http://bsd9.dss.ca/cgi-bin/dacs/http_auth
-OAUTH_METHOD=GET -OUSE_AUTH_REPLY=yes -u test -p
test&quot;)&rsquo; <br>

{&quot;result&quot;,1,&quot;identity&quot;,&quot;DSS::BSD9:guest&quot;,&quot;roles&quot;,&quot;bigwheel,mediumwheel,littlewheel&quot;}</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_http_authenticate or just http.</p>

<p style="margin-top: 1em">local_infocard_authenticate <br>
Deprecated <br>
In early 2011, Microsoft announced[106] that it would not
support CardSpace[107] (aka, Infocards and Information
Cards) starting with Windows 8[108]. CardSpace has been <br>
the most widely available identity selector for using
Information Cards.</p>

<p style="margin-top: 1em">The implementation of Infocards
support within DACS remains in the code base and is
documented, but is no longer being actively tested and
maintained (neither are the <br>
demos). Support for Information Cards within DACS will
likely be removed eventually. You may notice that other
Infocard and CardSpace related projects have been <br>
terminated and their web pages are out of date or no longer
available.</p>

<p style="margin-top: 1em">References: On the Demise of
CardSpace[109]; Open Cardspace opportunity[110]; Personal
Reflections on the CardSpace Journey[111]; From CardSpace to
Verified Claims[112]; <br>
Change will come: the present is untenable[113]; The Clay
Feet of Giants?[114]; RIP, Windows CardSpace. Hello,
U-Prove[115]; and U-Prove[116].</p>

<p style="margin-top: 1em">The local_infocard_authenticate
module performs DACS authentication using an Information
Card[62] (InfoCard) previously registered at the
jurisdiction. Self-issued InfoCards <br>
are registered using dacs_infocard(8)[64] or
dacsinfocard(1)[63]. Managed InfoCards are also supported,
provided they have been registered using
dacs_managed_infocard(8)[65] <br>
and include a dacs_identity claim in the DACS namespace.
DACS aims to conform to Identity Selector Interoperability
Profile (ISIP) 1.5[117].</p>

<p style="margin-top: 1em">A DACS role descriptor
string[118] can be associated with a managed InfoCard
through the dacs_roles claim name in the DACS namespace (see
dacs_infocard(8)[119]. These roles <br>
can be associated with new credentials via the add_roles[69]
and set_roles[70] modifiers.</p>

<p style="margin-top: 1em">Security <br>
At present, to be valid for authentication, the
dacs_identity claim value must specify a user at the current
jurisdiction; that is, it cannot specify an identity at a
<br>
jurisdiction other than the one where authentication is
being performed.</p>

<p style="margin-top: 1em">The authentication style
infocard causes the module to accept either type of InfoCard
- the type of InfoCard actually used will be available in
the resulting credentials. The <br>
styles managed_infocard and selfissued_infocard tell the
module to limit authentication to managed InfoCards or
self-issued InfoCards, respectively. When invoked as a web
<br>
service, local_infocard_authenticate understands an optional
argument, TYPE, that may have the value
&quot;selfissued&quot; or &quot;managed&quot; to restrict
authentication to the corresponding <br>
InfoCard type; the default behaviour accepts either type of
InfoCard.</p>

<p style="margin-top: 1em">Tip <br>
The expression-based authentication style[120], which does
not call this module, provides an alternative way to support
InfoCard-based authentication. It is somewhat more <br>
complicated to use, however, and may require a small amount
of programming.</p>

<p style="margin-top: 1em">For additional information about
InfoCards, please refer to:</p>

<p style="margin-top: 1em">&Acirc;&middot;
dacs_managed_infocard(8)[121], dacs.conf(5)[122] (the
INFOCARD_ prefixed directives), dacs_mex(8)[123], and
dacs_sts(8)[124].</p>

<p style="margin-top: 1em">&Acirc;&middot; Using InfoCards
With DACS[125], Distributed Systems Software (July,
2009).</p>

<p style="margin-top: 1em">&Acirc;&middot; Identity
Selector Interoperability Profile specification and
companion guides[126] (August, 2008).</p>

<p style="margin-top: 1em">&Acirc;&middot; Introducing
Windows CardSpace[127] (April, 2006).</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_infocard_authenticate or just infocard.</p>

<p style="margin-top: 1em">local_ldap_authenticate <br>
The local_ldap_authenticate module performs DACS
authentication using the Lightweight Directory Access
Protocol, also known as LDAP, (see RFC 2251[128], RFC
2252[129], RFC <br>
2253[130], RFC 3377[131], and many others). This form of
authentication can be used with Microsoft&rsquo;s Active
Directory (ADS)[132]. OpenLDAP[133] is used to supply LDAP
client <br>
support.</p>

<p style="margin-top: 1em">The STYLE should be configured
as password for this module.</p>

<p style="margin-top: 1em">In general, authentication using
LDAP is challenging because an LDAP name (a distinguished
name, or DN) is typically long and often has a site-specific
structure. For this <br>
reason, this module often requires more local expertise for
configuring and testing than other DACS authentication
modules. At least a basic familiarity with LDAP will be <br>
required to configure this module.</p>

<p style="margin-top: 1em">The module implements two
different approaches to authentication:</p>

<p style="margin-top: 1em">1. In the direct method, which
is the simpler and more efficient approach, the USERNAME
argument is directly mapped to the corresponding DN. The
module binds to that DN <br>
using the given PASSWORD. If the bind operation succeeds,
the user has been authenticated.</p>

<p style="margin-top: 1em">2. When the simpler method is
not possible, the indirect method can be used to bind to the
directory as an LDAP administrator (or an identity with the
ability to search the <br>
appropriate portion of the directory tree) and perform an
LDAP search operation for a directory entry having an
attribute that matches the USERNAME argument. If the <br>
search returns exactly one entry, it binds to that
entry&rsquo;s DN using the PASSWORD argument; if the bind
operation succeeds, the user has been authenticated.</p>

<p style="margin-top: 1em">Regardless of the approach,
after successful authentication it may be necessary to map
the USERNAME or the DN into a valid DACS username.</p>

<p style="margin-top: 1em">The following configuration
directives are specific to this module:</p>

<p style="margin-top: 1em">LDAP_ADMIN_PASSWORD (Optional1)
<br>
This is the password for the LDAP administrator account that
corresponds to LDAP_ADMIN_URL.</p>

<p style="margin-top: 1em">LDAP_ADMIN_URL (Required1-C)
<br>
If the indirect method is used, this directive is required.
This value is a URI like LDAP_USERNAME_URL except that it
identifies the LDAP directory&rsquo;s administrator. <br>
Example:</p>

<p style="margin-top: 1em">LDAP_ADMIN_URL <br>
&quot;ldap://example.com/cn=Administrator, cn=Users,
dc=example, dc=com&quot;</p>

<p style="margin-top: 1em">LDAP_BIND_METHOD (Required1-C)
<br>
This directive tells the module to use the direct method,
indirect method, or both methods (case insensitive). When
both are used, the indirect method is attempted only <br>
if the direct method fails.</p>

<p style="margin-top: 1em">LDAP_ROLES_SELECTOR* (Optional)
<br>
Since LDAP directory operations are usually relatively
expensive, this module can return role information for the
authenticated user, avoiding a second LDAP operation <br>
during Roles clause processing. Roles are typically
extracted from information in the user&rsquo;s directory
entry. Each occurrence of this directive specifies an
expression <br>
that is evaluated by iterating through each attribute of the
entry and making the attribute name (${LDAP::attrname}) and
its value (${LDAP::attrvalue}) available. All of <br>
the entry&rsquo;s attribute names and values are made
available within the LDAP namespace. If the result of the
expression is a valid role string (which excludes the empty
<br>
string, &quot;&quot;), it is added to the list of roles.</p>

<p style="margin-top: 1em">An example:</p>

<p style="margin-top: 1em">LDAP_ROLES_SELECTOR*
&rsquo;&quot;${LDAP::attrname}&quot; eq &quot;memberOf&quot;
? strtr(ldap(rdn_attrvalue, ldap(dn_index,
&quot;${LDAP::attrvalue}&quot;, 1)), &quot; &quot;,
&quot;_&quot;) : &quot;&quot;&rsquo;</p>

<p style="margin-top: 1em">For each instance of the
entry&rsquo;s memberOf attribute, this expression selects
the least significant (left-most) component of the attribute
value (a DN) using ldap()[134] <br>
and converts spaces to underscores. If the user&rsquo;s
entry contains:</p>

<p style="margin-top: 1em">memberOf: CN=Domain
Guests,CN=Users,DC=example,DC=com <br>
memberOf: CN=Guests,CN=Builtin,DC=example,DC=com</p>

<p style="margin-top: 1em">the resulting roles would be
Domain_Guests and Guests.</p>

<p style="margin-top: 1em">Note <br>
These roles are discarded unless the STYLE[96] directive for
this module allows the roles to be incorporated into the
user&rsquo;s credentials.</p>

<p style="margin-top: 1em">LDAP_SEARCH_FILTER (Required1-C)
<br>
If the indirect method is used, either this directive or
LDAP_SEARCH_FILTER* (but not both) must be configured. This
search filter is used to select the unique directory <br>
entry that corresponds to this user.</p>

<p style="margin-top: 1em">LDAP_SEARCH_FILTER*
(Required1-C) <br>
If the indirect method is used, either this directive or
LDAP_SEARCH_FILTER (but not both) must be configured. This
search filter is used to select the unique directory <br>
entry that corresponds to this user. This directive is
exactly like LDAP_SEARCH_FILTER except that it is evaluated
just before it is used, allowing various elements of <br>
the execution context to appear in the string. Example:</p>

<p style="margin-top: 1em">LDAP_SEARCH_FILTER*
&rsquo;&quot;(sAMAccountName=${Args::USERNAME})&quot;&rsquo;</p>

<p style="margin-top: 1em">LDAP_SEARCH_ROOT_DN
(Required1-C) <br>
This is the root DN at which the indirect method should
begin searching for user entries.</p>

<p style="margin-top: 1em">LDAP_TIMEOUT_SECS (Optional1)
<br>
This is a maximum time limit, in seconds, for any individual
LDAP read or search operation performed by the module. If
not specified, there will not be an <br>
application-specified time limit.</p>

<p style="margin-top: 1em">LDAP_USERNAME_EXPR* (Optional1)
<br>
If authentication succeeds, this directive is evaluated to
yield the DACS username returned to dacs_authenticate. All
of the entry&rsquo;s attribute names and values are made
<br>
available within the LDAP namespace. If unspecified, the
value of the USERNAME parameter is returned. Example:</p>

<p style="margin-top: 1em">LDAP_USERNAME_EXPR*
&rsquo;&quot;${LDAP::sAMAccountName}&quot;&rsquo;</p>

<p style="margin-top: 1em">LDAP_USERNAME_URL (Optional1)
<br>
If the direct method is used, either this directive or
LDAP_USERNAME_URL*[135] (but not both) must be configured.
This directive identifies both the LDAP server to use <br>
and the user being authenticated. The value of this
directive is a URI (see RFC 2396[136] and RFC 3986[137])
that gives the name of the LDAP server to contact to <br>
authenticate the user (as the scheme and authority part of
the URI) and the DN for the user (as the path part of the
URI). The scheme must be either ldap or ldaps (case <br>
insensitive). If no port number is specified, 389 is used
with the former scheme and 636 with the latter.</p>

<p style="margin-top: 1em">LDAP_USERNAME_URL <br>
&rsquo;&quot;ldap://example.com/cn=Auggie%20Doggie,
cn=Users, dc=example, dc=com&quot;&rsquo;</p>

<p style="margin-top: 1em">Security <br>
The ldaps scheme is not implemented. Communication between
this module and the LDAP server should use a secure channel
or at least not be snoopable.</p>

<p style="margin-top: 1em">LDAP_USERNAME_URL* (Optional1)
<br>
If the direct method is used, either this directive or
LDAP_USERNAME_URL (but not both) must be configured. This
directive is exactly like LDAP_USERNAME_URL except that <br>
it is evaluated just before it is used, allowing various
elements of the execution context to appear in the string.
Example:</p>

<p style="margin-top: 1em">LDAP_USERNAME_URL* <br>
&rsquo;&quot;ldap://example.com/cn=${Args::USERNAME},
cn=Users, dc=example, dc=com&quot;&rsquo;</p>

<p style="margin-top: 1em">Tip <br>
Before using LDAP authentication with DACS, you should first
make sure that your LDAP server is functioning as you expect
and that the host that will run the <br>
local_ldap_authenticate module can communicate with the LDAP
server.</p>

<p style="margin-top: 1em">One way to do this is to use the
ldapsearch(1)[138] command (found in the clients/tools
directory of the OpenLDAP distribution) to bind to the
directory and perform some <br>
searches. You should run this command on the same machine
that will be running DACS&rsquo;s LDAP authentication module
(local_ldap_authenticate). Some of the information that <br>
you obtain from this exercise may be helpful when you
configure DACS to use this form of authentication.</p>

<p style="margin-top: 1em">Here are some examples to try -
you must adapt the names for your environment:</p>

<p style="margin-top: 1em">% ./ldapsearch -h
win2k.example.com -x -b &quot;dc=example,dc=com&quot; -D
&quot;CN=Administrator,CN=Users,DC=example,DC=com&quot; -W
-LLL <br>
% ./ldapsearch -h win2k.example.com -x -b
&quot;dc=example,dc=com&quot; -D &quot;CN=Auggie
Doggie,CN=Users,DC=example,DC=com&quot; -W -LLL <br>
% ./ldapsearch -h win2k.example.com -x -b
&quot;dc=example,dc=com&quot; -D
&quot;CN=Administrator,CN=Users,DC=example,DC=com&quot; -W
-LLL &quot;(cn=Administrator)&quot; memberOf <br>
% ./ldapsearch -h win2k.example.com -x -b
&quot;dc=example,dc=com&quot; -D
&quot;CN=Administrator,CN=Users,DC=example,DC=com&quot; -W
-LLL &quot;(sAMAccountName=auggie)&quot;</p>

<p style="margin-top: 1em">In these examples, the LDAP
server runs on a host named win2k.example.com (so change
win2k.example.com, example, and com), and it expects a user
named &quot;Auggie Doggie&quot; to <br>
exist and have the account name &quot;auggie&quot; (again,
change to names that exist in your LDAP directory). You
should be prompted for the LDAP password (in Windows, that
will <br>
be the login password) for either Administrator or a user
named &quot;Auggie Doggie&quot;, depending on the argument
that follows the -D flag.</p>

<p style="margin-top: 1em">The following configuration
illustrates authentication using this module:</p>

<p style="margin-top: 1em">&lt;Auth id=&quot;ldap&quot;&gt;
<br>
URL
&quot;https://example.com/cgi-bin/dacs/local_ldap_authenticate&quot;
<br>
STYLE &quot;password,add_roles&quot; <br>
CONTROL &quot;required&quot; <br>
LDAP_BIND_METHOD &quot;direct&quot; <br>
LDAP_USERNAME_URL*
&rsquo;&quot;ldap://windows.example.com/cn=&quot; .
encode(url, ${Args::USERNAME}) .
&quot;,cn=Users,dc=example,dc=com&quot;&rsquo; <br>
LDAP_USERNAME_EXPR*
&rsquo;&quot;${LDAP::sAMAccountName}&quot;&rsquo; <br>
LDAP_ROLES_SELECTOR* &rsquo;&quot;${LDAP::attrname}&quot; eq
&quot;memberOf&quot; ? strtr(ldap(rdn_attrvalue,
ldap(dn_index, &quot;${LDAP::attrvalue}&quot;, 1)), &quot;
&quot;, &quot;_&quot;) : 0&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">Here, the LDAP authentication
module will construct a DN by plugging the user-provided
USERNAME argument into the template and binding to that DN
with the PASSWORD argument. <br>
If successful, the DACS username will be the value of the
user&rsquo;s entry&rsquo;s sAMAccountName attribute, and
roles will extracted from the entry&rsquo;s memberOf
attribute values, as <br>
described above.</p>

<p style="margin-top: 1em">Note <br>
In Windows, the SAM-Account-Name Active Directory attribute
value (sAMAccountName) need not be the same as the
entry&rsquo;s Common Name; for instance, the former might be
<br>
&quot;doggie&quot; and the latter &quot;CN=Auggie
Doggie&quot;. The sAMAccountName must not exceed 20
characters in length and must be unique within the domain.
It is composed of printable <br>
characters other than the following: &nbsp;</p>

<p style="margin-top: 1em">/ [ ] : ; | = , + * ? &lt; &gt;
@ &quot;</p>

<p style="margin-top: 1em">The userPrincipalName attribute
value is a user account name (or &quot;user login
name&quot;) that is unique within its domain and a domain
name identifying the domain in which the <br>
user account is located. The format is the same as a
domain-name based email address; e.g.,
doggie@example.com.</p>

<p style="margin-top: 1em">local_native_authenticate <br>
The local_native_authenticate module transfers a
user&rsquo;s current, context-dependent web server identity
to a DACS identity. The web server will most likely have
used HTTP <br>
Basic or Digest authentication (RFC 2617[60]). The user,
having already been authenticated by the web server at a
particular jurisdiction, will automatically be given DACS
<br>
credentials associated with that jurisdiction and typically
having the same username.</p>

<p style="margin-top: 1em">The STYLE should be configured
as native for this module.</p>

<p style="margin-top: 1em">This method of authentication
also depends on a CGI helper program (autologin(8)[139]) and
appropriate configuration of Apache authentication. The
general idea is that the <br>
helper program must be executable only by users that have
been properly authenticated by the web server (by any Apache
method and using any Apache authentication module). The <br>
helper program then invokes dacs_authenticate with
appropriate arguments; if this module has been enabled and
accepts its arguments, the user will be given DACS
credentials.</p>

<p style="margin-top: 1em">There are no directives or
options specific to this module.</p>

<p style="margin-top: 1em">local_ntlm_authenticate <br>
The local_ntlm_authenticate module authenticates users
through Windows NT LAN Manager using the NTLM protocol
[1[140], 2[141]]. This module, which makes use of Samba[142]
<br>
libraries, provides Windows NTLM authentication[143] based
on a username and password. The module does not need to be
(and will not usually be) executed on the host running <br>
Windows.</p>

<p style="margin-top: 1em">The STYLE should be configured
as password for this module.</p>

<p style="margin-top: 1em">The following OPTION directive
values are understood:</p>

<p style="margin-top: 1em">SAMBA_SERVER (Required1) <br>
The domain name or IP address in standard dot notation of
the Windows system providing NTLM authentication.</p>

<p style="margin-top: 1em">SAMBA_PORT (Optional1) <br>
The port number to use on SAMBA_SERVER. The default is 0,
which tells Samba to use a sequence of default ports until
one works.</p>

<p style="margin-top: 1em">SAMBA_DOMAIN (Optional1) <br>
The domain name to use on SAMBA_SERVER. The default is
&quot;&quot;.</p>

<p style="margin-top: 1em">The module-specific option
SAMBA_SERVER must be given to provide the domain name of the
host providing the NTLM authentication. The module-specific
options SAMBA_DOMAIN and <br>
SAMBA_PORT, which are optional, can be used to override the
default port(s) used by Samba to contact SAMBA_SERVER.</p>

<p style="margin-top: 1em">The following illustrates how
this module might be configured:</p>

<p style="margin-top: 1em">&lt;Auth id=&quot;ntlm&quot;&gt;
<br>
URL
&quot;https://example.com/cgi-bin/dacs/local_ntlm_authenticate&quot;
<br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
OPTION &rsquo;SAMBA_SERVER=&quot;10.0.0.123&quot;&rsquo;
<br>
OPTION &rsquo;SAMBA_PORT=&quot;139&quot;&rsquo; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">Here, dacs_authenticate will
invoke the NTLM authentication module at the given URL. That
module will try to authenticate the username and password
given to it by asking the <br>
NTLM service at port 139 on the Windows system at
10.0.0.213.</p>

<p style="margin-top: 1em">There are no directives specific
to this module.</p>

<p style="margin-top: 1em">Security <br>
Attacks against some versions of NTLM have been
identified[144]. Communication between this module and the
NTLM service should use a secure channel or at least not be
<br>
snoopable.</p>

<p style="margin-top: 1em">Tip <br>
&Acirc;&middot; A built-in version of this module can be
selected by using the URL local_ntlm_authenticate or just
ntlm.</p>

<p style="margin-top: 1em">&Acirc;&middot; Before
attempting to use this module, it may save a lot of time and
aggravation if you first check that it is possible to
authenticate against NTLM, from the machine <br>
on which you intend to run this module, using a
username/password combination that you know is correct. If
you are not able to successfully authenticate in this way,
<br>
obviously you will not have any luck with the DACS
module.</p>

<p style="margin-top: 1em">To test whether it is possible
to authenticate using a particular username and password,
you may be able to use smbclient(1)[145]. For example, if
C:red is a <br>
network shared folder or HPLaserJ-PS is a shared printer on
the Windows machine on which you want to perform
authentication, to authenticate as the Administrator try
<br>
something like:</p>

<p style="margin-top: 1em">% smbclient //mywinhost/shared
-U Administrator</p>

<p style="margin-top: 1em">or to authenticate as the user
bob, try:</p>

<p style="margin-top: 1em">% smbclient
//mywinhost/HPLaserJ-PS -U bob</p>

<p style="margin-top: 1em">Replace mywinhost with the name
of your Windows machine. You should be prompted for the
account&rsquo;s password. If smbclient successfully connects
and establishes a <br>
session using the username and password you provide, then
this module should also be able to authenticate that user,
otherwise you should see an error message.</p>

<p style="margin-top: 1em">Before you have configured DACS,
you can test NTLM authentication from the command line using
dacsauth(1)[6]. For example, try something like:</p>

<p style="margin-top: 1em">% dacsauth -m ntlm passwd suff
-OSAMBA_SERVER=&quot;windows.example.com&quot; -prompt -u
bob</p>

<p style="margin-top: 1em">Change &quot;bob&quot; to the
username you want to authenticate and
&quot;windows.example.com&quot; to the domain name of the
Windows machine where the user&rsquo;s account is. You may
also <br>
need to specify SAMBA_PORT if a non-standard port is being
used. You will be prompted for the password for the
user&rsquo;s account The program&rsquo;s exit status
indicates <br>
success (&quot;ok&quot; is exit status 0) or failure (exit
status 1). Repeat this with an invalid password to make sure
that it fails.</p>

<p style="margin-top: 1em">After you have configured DACS,
there is another method of testing local_ntlm_authenticate
from the command line. Set the environment variable
QUERY_STRING (using <br>
your preferred shell&rsquo;s syntax) to something like
this:</p>

<p style="margin-top: 1em">% export
QUERY_STRING=&quot;USERNAME=bob&amp;PASSWORD=test&amp;DACS_JURISDICTION=Test
&amp;SAMBA_SERVER=windows.example.com&quot;</p>

<p style="margin-top: 1em">Change &quot;bob&quot; to the
username you want to authenticate, &quot;test&quot; to the
password for that username, &quot;Test&quot; to the name of
the DACS jurisdiction that will perform the <br>
authentication, and &quot;windows.example.com&quot; to the
domain name of the Windows machine where the user&rsquo;s
account is. You may also need to specify SAMBA_PORT. Then
from <br>
the distribution&rsquo;s src directory:</p>

<p style="margin-top: 1em">% ./local_ntlm_auth -uj Test</p>

<p style="margin-top: 1em">Use the -u, -uj, or -us flag to
specify a jurisdiction that you have configured (see
dacs(1)[146]). The output, an XML document, indicates
success (&quot;ok&quot;, exit status <br>
0) or failure (&quot;failed&quot;, exit status 1). Repeat
this with an invalid password to make sure that it fails.
When you are done, remember to delete the QUERY_STRING <br>
environment variable.</p>

<p style="margin-top: 1em">local_pam_authenticate <br>
This module makes a local or remote Pluggable Authentication
Modules (PAM) infrastructure available for authentication.
PAM authenticates a user that is known to the <br>
PAM-capable operating system (i.e., a user with an existing
account) through one or more PAM authentication service
modules that have been configured by the system <br>
administrator. Other PAM operations, such as password
management, are currently unsupported by DACS. Please refer
to X/Open Single Sign-On Service (XSSO) -- Pluggable <br>
Authentication[53] for additional information about PAM.</p>

<p style="margin-top: 1em">Notes <br>
&Acirc;&middot; The PAM-based infrastructure described here
was mainly developed to allow a system&rsquo;s PAM
authentication services to be used for DACS web-based
authentication. See <br>
src/pamd.c for architectural details.</p>

<p style="margin-top: 1em">Although a prototype has been
developed, no &quot;native&quot; PAM authentication module
for DACS is distributed. Such a module might be used to
provide Unix services with DACS <br>
authentication and access control functionality,
conceptually allowing dacsauth(1)[6] or dacscheck(1)[147] to
be used by them. For instance, configuration for ftp <br>
authentication that normally uses pam_unix.so might be
replaced by a reference to the module, leveraging any
password style of DACS authentication, such as <br>
local_ldap_authenticate[49].</p>

<p style="margin-top: 1em">&Acirc;&middot; By default, the
pamd server uses &quot;dacs&quot; as the name of the PAM
service policy (see pam_start(3)[148]). Some systems may
revert to a default policy (such as &quot;other&quot;) <br>
if no &quot;dacs&quot; policy is defined. A policy name can
be specified as a pamd argument.</p>

<p style="margin-top: 1em">There is a huge selection of
open source and vendor-supplied PAM authentication modules
for a wide variety of platforms, including some that provide
functionality similar to <br>
that of DACS authentication modules [GNU/Linux[149],
FreeBSD[150], macOS[151]]. For example, pam_unix(8)[152]
performs essentially the same authentication function as
<br>
local_unix_authenticate[153], except that the latter is not
interactive (it does not prompt).</p>

<p style="margin-top: 1em">The STYLE should be configured
as prompted for this module.</p>

<p style="margin-top: 1em">Note <br>
While this authentication module has been tested with only a
few PAM authentication service modules, in theory it should
work with any conformant PAM authentication <br>
module. If this module is used, the current implementation
does not allow any other authentication modules to be
configured for the jurisdiction; this can be partially <br>
ameliorated by configuring PAM to try multiple PAM modules
(yes, writing &quot;PAM modules&quot; might be incorrect in
the same way that &quot;ATM[154] machine&quot; is).</p>

<p style="margin-top: 1em">Important <br>
The local_pam_authenticate module depends on functionality
provided by pamd(8)[155] running on a PAM-capable system,
which does not need to be the same host where <br>
local_pam_authenticate is run. The local_pam_authenticate
module establishes connections with pamd, which interacts
with the pam(3)[52] library. Unlike the other DACS <br>
authentication styles, authentication using the prompted
style may involve more than one request to
dacs_authenticate, each of which supplies additional
authentication <br>
material.</p>

<p style="margin-top: 1em">The prompted authentication
style implements a session between the user and the PAM
library that consists of a sequence of operations that
comprise a PAM transaction. For <br>
each operation, dacs_authenticate (via
local_pam_authenticate and pamd) supplies the PAM library
with authentication material (either initial data or data
requested by <br>
the PAM library from the previous operation), determines if
authentication has succeeded or failed, or whether the user
must be prompted for additional data. If the PAM <br>
library requires additional data, the user is prompted for
it, and the response is submitted to dacs_authenticate in
the transaction&rsquo;s next operation.</p>

<p style="margin-top: 1em">If PAM requires information from
the user, local_pam_authenticate can be configured to prompt
for it using one of three methods. The first method is used
if the Auth clause <br>
has an OPTION directive that configures PAM_HANDLER_URL; the
user will be redirected to this URL. The other possibilities
are selected by the FORMAT argument (see <br>
dacs.services(8)[81]). If any XML type is specified, the
reply from dacs_authenticate will conform to the DTD
dacs_auth_reply.dtd[82]. If HTML is specified and PAM <br>
authentication requires additional information from the
user, dacs_authenticate will return a rudimentary HTML form
that must be completed and submitted by the user. For <br>
example, if pam_unix is configured, dacs_authenticate may
emit a web page that prompts for a username (if none was
provided with the initial invocation of dacs_authenticate),
<br>
and after that form has been submitted by the user emit a
web page that prompts for a password.</p>

<p style="margin-top: 1em">If PAM_HANDLER_URL is
configured, the handler to which the administrator redirects
users has complete control over user prompting. In most
implementations, the handler will <br>
emit a web page that includes a form element, with
appropriate inputs and hidden variables, which is submitted
to the web service named in the service argument (see
below). <br>
The handler is required to obtain values for a set of
requested variables and submit them to a given URL
(dacs_authenticate). Each variable has a type, an optional
<br>
descriptive text label, and a name. The value of
PAM_HANDLER_URL may either be an absolute URL or a web
service name, beginning with a &rsquo;/&rsquo;, that is
interpreted relative to <br>
the current jurisdiction (i.e., the dacs_url[156] is
prepended). Query arguments may be included, provided none
of the argument names used by dacs_authenticate, described
<br>
below, are duplicated.</p>

<p style="margin-top: 1em">The pamd server requires the
handler to respond within 60 seconds (configured at compile
time). The local_pam_authenticate module requires pamd to
respond to the initial <br>
request with the first prompt within 20 seconds (configured
at compile time). Should the handler encounter a serious
error, it can simply terminate; this will cause pamd to <br>
eventually time out, which will abort the PAM
transaction.</p>

<p style="margin-top: 1em">Security <br>
The handler does not have to be DACS-wrapped, but ideally it
should be. If it is, don&rsquo;t forget to add an access
control rule to grant access to any user that might <br>
authenticate through local_pam_authenticate.</p>

<p style="margin-top: 1em">This &quot;prompter&quot;
service might be configured as follows:</p>

<p style="margin-top: 1em">OPTION
&quot;PAM_HANDLER_URL=/dacs_pam_handler&quot;</p>

<p style="margin-top: 1em">This will be expanded into a URL
that looks something like
https://example.com/cgi-bin/dacs/dacs_pam_handler. When a
user is redirected to this handler, dacs_authenticate <br>
adds the following query arguments:</p>

<p style="margin-top: 1em">&Acirc;&middot; service: This is
the URL of the dacs_authenticate service to which the
handler must submit the requested values. This URL will not
include any query arguments. Because <br>
private information, such as a password, may be present, it
will typically use the https scheme. The handler should use
the POST method to invoke service.</p>

<p style="margin-top: 1em">&Acirc;&middot; CSS_PATH: This
is the path configured for HTML stylesheets.</p>

<p style="margin-top: 1em">&Acirc;&middot; AUTH_TRANSID:
This is the unique transaction identifier for this PAM
interaction. As part of a single authentication transaction,
the handler may be called several times <br>
with the same AUTH_TRANSID. The handler is not required to
retain state between these calls, but it may do so. The
handler must pass this argument when calling service. <br>
Although the lifetime of this identifier is relatively
brief, it should be kept private by the handler.</p>

<p style="margin-top: 1em">&Acirc;&middot;
auth_prompt_var_prefix: Each requested value will be
identified by an argument to service having this prefix,
with a positive integer (int, which is assigned consecutive
<br>
integers starting with 1) appended. For instance, if
auth_prompt_var_prefix is &quot;AUTH_PROMPT_VAR&quot;, then
the handler must submit the requested values as
AUTH_PROMPT_VAR1, <br>
AUTH_PROMPT_VAR2, and so on. The first absent int value
signals the end of the variable argument list.</p>

<p style="margin-top: 1em">&Acirc;&middot; TYPEint: This is
the type (&quot;text&quot;, &quot;password&quot;, or
&quot;error&quot;) of the variable numbered int. The
password type indicates the value should not be displayed
during user input.</p>

<p style="margin-top: 1em">&Acirc;&middot; LABELint: This
argument, which is optional, indicates a label that might be
displayed beside the user prompt (e.g.,
&quot;Username?&quot;) for variable int.</p>

<p style="margin-top: 1em">&Acirc;&middot; NAMEint: If this
argument is not present for a given int, then no value is
required for this variable - presumably LABELint is
informational. If NAMEint is present, it <br>
gives the name of the variable to use when the handler
submits the value. For example, suppose the handler is
called with arguments TYPE2 as &quot;text&quot;, LABEL2 as
&quot;Login:&quot;, <br>
and NAME2 as &quot;AUTH_PROMPT_VAR2&quot;. This asks the
handler to prompt for text input labeled &quot;Login:&quot;.
If the user submits the value &quot;Auggie&quot;, then
included with the arguments <br>
to service there should be a variable named AUTH_PROMPT_VAR2
with the value &quot;Auggie&quot;.</p>

<p style="margin-top: 1em">Any other arguments to the
handler should be forwarded to service verbatim. Such
arguments include DACS_VERSION, DACS_JURISDICTION,
DACS_BROWSER, and ENABLE_AUTH_HANDLERS.</p>

<p style="margin-top: 1em">Note <br>
For testing purposes, it may be helpful to set
PAM_HANDLER_URL to dacs_prenv, which will display the
arguments passed to the handler and other context. The DACS
<br>
distribution includes an example handler,
html/handlers/dacs_pam_handler.</p>

<p style="margin-top: 1em">If an HTML form is emitted, its
appearance can be customized somewhat through the default
stylesheet local_pam_authenticate.css[157]. The content of
the generated web page <br>
can be customized through the local_pam_authenticate VFS
item type. The following items relative to that item type
are emitted if they exist:</p>

<p style="margin-top: 1em">&Acirc;&middot; header: Initial
HTML to emit instead of the default.</p>

<p style="margin-top: 1em">&Acirc;&middot; prologue: HTML
to emit immediately after the header.</p>

<p style="margin-top: 1em">&Acirc;&middot; instructions:
HTML to emit immediately after the prologue and before the
form.</p>

<p style="margin-top: 1em">&Acirc;&middot; form: Additional
HTML to emit within the form.</p>

<p style="margin-top: 1em">&Acirc;&middot; epilogue: HTML
to emit immediately after the form.</p>

<p style="margin-top: 1em">&Acirc;&middot; trailer: Final
HTML to emit instead of the default.</p>

<p style="margin-top: 1em">For example, consider the
configuration directive:</p>

<p style="margin-top: 1em">VFS
&quot;[local_pam_authenticate]dacs-fs:${Conf::DACS_HOME}/pam_auth&quot;</p>

<p style="margin-top: 1em">Here, pam_auth is the directory
${Conf::DACS_HOME}/pam_auth. If files named header and
trailer exist in that directory, they are expected to
contain the initial and final <br>
HTML content, respectively. These files consist of text and
HTML markup but are not complete HTML documents.</p>

<p style="margin-top: 1em">Customization of the HTML form
is possible using configuration variables:</p>

<p style="margin-top: 1em">&Acirc;&middot;
prompt_submit_label: the text label to put in the
form&rsquo;s submit button.</p>

<p style="margin-top: 1em">For example, the submit
button&rsquo;s text can be specified using the
directive:</p>

<p style="margin-top: 1em">EVAL
${Conf::prompt_submit_label} = &quot; Continue &quot;</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_pam_authenticate or just pam.</p>

<p style="margin-top: 1em">local_passwd_authenticate <br>
The local_passwd_authenticate module provides support for
DACS identities, strictly private to DACS, through
password-protected accounts (similar to what Apache&rsquo;s
<br>
mod_auth[86] and mod_auth_dbm[88] modules do, along with the
htpasswd(1)[89] utility). A secure hash of a password is
stored rather than the plaintext password itself. <br>
Several hashing methods are available (see
PASSWORD_DIGEST[158]).</p>

<p style="margin-top: 1em">The local_passwd_authenticate
module performs authentication by consulting the USERNAME
and PASSWORD parameters and comparing them to the
information previously stored by the <br>
administrator.</p>

<p style="margin-top: 1em">Security <br>
This module always requires the PASSWORD argument and will
not accept the empty string as a password value (even if
that actually is the password). Use <br>
local_simple_authenticate[67] for password-less
accounts.</p>

<p style="margin-top: 1em">The STYLE should be configured
as password for this module.</p>

<p style="margin-top: 1em">The dacspasswd(1)[159] utility
is used to manage these accounts. The item type is
&quot;passwds&quot;.</p>

<p style="margin-top: 1em">The following example
configuration, which reflects typical usage, maintains user
and password information in a plain text file named
/usr/local/dacs/federations/passwd.</p>

<p style="margin-top: 1em">VFS
&quot;[passwds]dacs-kwv-fs:/usr/local/dacs/federations/passwd&quot;</p>

<p style="margin-top: 1em">There are no directives or
options specific to this module.</p>

<p style="margin-top: 1em">Note <br>
The name &quot;local_passwd_authenticate&quot; may be a
little confusing because there are other modules that
implement some form of password-based authentication. This
module <br>
might more appropriately be called
&quot;local_dacspasswd_authenticate&quot;.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_passwd_authenticate or just passwd.</p>

<p style="margin-top: 1em">local_simple_authenticate <br>
The local_simple_authenticate module supports DACS
identities, strictly private to DACS, through accounts that
are not password-protected. The local_simple_authenticate
<br>
module performs authentication by looking up an account
named by the USERNAME argument. In typical use, the username
will be an email address, account or membership number, <br>
or random character string.</p>

<p style="margin-top: 1em">Security <br>
This form of authentication is inherently insecure because
no password is provided. It is only appropriate when the
consequences of a valid account name being guessed or <br>
misappropriated are of little concern, such as for
restricted guest accounts. Administrators should not assume
that using difficult-to-guess account names with this <br>
module offers much security. Keep in mind that depending on
the larger context of how these identities are used, these
usernames may be publicly visible.</p>

<p style="margin-top: 1em">The STYLE should be configured
as simple for this module.</p>

<p style="margin-top: 1em">The dacspasswd(1)[159] utility
is used to manage these accounts. The item type is
&quot;simple&quot;.</p>

<p style="margin-top: 1em">The following example
configuration, which reflects typical usage, maintains user
account information in a plain text file named
/usr/local/dacs/federations/simple_accounts.</p>

<p style="margin-top: 1em">VFS
&quot;[simple]dacs-kwv-fs:/usr/local/dacs/federations/simple_accounts&quot;</p>

<p style="margin-top: 1em">Note <br>
Although it is possible to combine password-protected
accounts and password-less accounts in the same VFS object
(i.e., with the item types passwds and simple pointing to
<br>
the same file or database), putting them in separate objects
is recommended.</p>

<p style="margin-top: 1em">There are no directives or
options specific to this module.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_simple_authenticate or just simple.</p>

<p style="margin-top: 1em">local_tgma_authenticate <br>
Experimental. The local_tgma_authenticate module, together
with a TGMA server and client validator software, implements
strong, interactive mutual authentication without the <br>
user having to input a password. The local_tgma_authenticate
module supports DACS identities that are strictly private to
DACS.</p>

<p style="margin-top: 1em">The user begins the
authentication procedure by using a simple sign-on page to
submit an identity (USERNAME and JURISDICTION). A password
is not normally required. A special <br>
web-based utility returns a new web page to the user that
displays instructions and another form that the user must
submit when she is ready to complete the procedure. Next,
<br>
and within a configurable window of time, the user must
prove his ownership of the identity by executing a secure
validation protocol. The validation protocol is conducted
<br>
from a device, such as a smart phone or tablet, which runs
the custom validator app and has been configured with
account information for the user&rsquo;s identity at the
<br>
jurisdiction.</p>

<p style="margin-top: 1em">This authentication module sends
an authentication request message to a TGMA server. The TGMA
server executes an authentication protocol with a
user&rsquo;s validator and returns <br>
the result to the module. The TGMA server is a light-weight
daemon that may serve one or more jurisdictions. The mutual
authentication protocol, based on Secure Remote <br>
Password authentication (RFC 2945[160], RFC 5054[161]),
verifies the user&rsquo;s identity using account information
available to the module, TGMA server, and the validator. The
<br>
user&rsquo;s validator confirms the identity of the TGMA
server, and indirectly, the jurisdiction. Communication
between the TGMA server and the module may use TCP, SSL, or
UDP, <br>
depending on configuration. Likewise, communication between
the TGMA server and a validator may also use TCP, SSL, or
UDP. Choice of the networking protocol will depend on <br>
security, performance, and connectivity dependencies. An
instance of the TGMA server must have network connectivity
with both users&rsquo; validator devices and instances of
this <br>
authentication module. In a larger organization it will
likely run on a firewall or DMZ-located server.</p>

<p style="margin-top: 1em">The STYLE should be configured
as tgma for this module.</p>

<p style="margin-top: 1em">local_token_authenticate <br>
This module works in concert with the dacstoken(1)[162]
utility to support one-time passwords. Two-factor
authentication, a strong authentication method, is supported
by <br>
combining hardware token-based one-time passwords
(&quot;something you have&quot;) with a PIN (a password,
&quot;something you know&quot;). Software-based clients may
also be used. The <br>
implementation follows RFC 4226[163], which has been adopted
by OATH[164], and other standards. Please refer to
dacstoken(1)[162] for complete details.</p>

<p style="margin-top: 1em">The STYLE should be configured
as password for this module.</p>

<p style="margin-top: 1em">In addition to the usual
USERNAME argument, the module requires the PASSWORD argument
to be the next one-time password (e.g., the value produced
by the user&rsquo;s hardware <br>
token). If the user&rsquo;s DACS account has a PIN
associated with it, the PIN must be passed as the AUXILIARY
argument. The PIN referred to here is the one managed by
dacstoken, <br>
not a PIN that may be entered into the token device to
unlock it.</p>

<p style="margin-top: 1em">One-time password generation
depends on a secret that is shared between the client and
DACS, and a non-repeating value that may be based on
synchronized counters or clocks. <br>
The client&rsquo;s token can become unsynchronized with the
server&rsquo;s state. This can happen for many reasons, such
as if a password is generated by the device but not used, if
a <br>
password or PIN is typed incorrectly, or because of a
configuration error. The method can tolerate a configurable
deviation of the client&rsquo;s token from the
server&rsquo;s state; <br>
that is, provided the client&rsquo;s password falls within a
window of N from the one expected by DACS, DACS will accept
the client&rsquo;s token. For counter-based tokens, only the
<br>
&quot;forward&quot; side of the window is examined, so DACS
can &quot;catch up&quot; to the client.</p>

<p style="margin-top: 1em">If the user&rsquo;s password
does not fall within the window, it is deemed to have become
unsynchronized with local_token_authenticate and
authentication will fail. The user can <br>
attempt to resynchronize by entering a sequence of passwords
as PASSWORD, using a comma to separate them. Three
consecutive, valid passwords are required (this number can
be <br>
configured at build time). If the account has a PIN, it must
be provided to enable synchronization. If synchronization
succeeds, the user&rsquo;s account information is corrected
<br>
and the module also reports successful authentication. If
synchronization fails, the module also fails and a DACS
administrator must be contacted to resynchronize the
token.</p>

<p style="margin-top: 1em">Note <br>
The token value must be entered exactly as it is displayed
on the token. Leading zeroes must be typed, for example, and
no spaces or punctuation are allowed. Whenever <br>
authentication fails, the user must obtain a new password
from the token.</p>

<p style="margin-top: 1em">The following OPTION directive
value is understood:</p>

<p style="margin-top: 1em">ACCEPT_WINDOW (Optional1) <br>
The (non-negative) size of the acceptance window for
one-time passwords, overriding the default. If the size is
zero, DACS will only consider a match with the expected <br>
password and will not try to match the user&rsquo;s password
against &quot;nearby&quot; passwords. With some modes of
operation, only forward matches are allowed.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_token_authenticate or just token.</p>

<p style="margin-top: 1em">local_unix_authenticate <br>
The local_unix_authenticate module implements native Unix
username/password authentication, allowing a user having a
pre-existing Unix account to be authenticated by DACS <br>
using the username and password for that account. Normally,
the user&rsquo;s hashed password is compared to the string
obtained by hashing the PASSWORD argument. But because some
<br>
platforms do not make stored passwords available to
applications (most notably macOS), a second algorithm can be
used; if it is enabled and the pam(3)[165] library is <br>
available, a simple PAM policy is used to validate the
plaintext password provided.</p>

<p style="margin-top: 1em">In the password comparison
algorithm, the getpwnam(3)[166] library function is passed
the USERNAME parameter given to dacs_authenticate. It can be
configured for systems with <br>
or without shadow passwords. On some Unix systems, when the
yp(8)[167] password database is enabled, the
getpwnam(3)[166] function will use the YP map
&quot;passwd.byname&quot; if the <br>
requested password entry is not found in the local database.
If the account information is obtained, the PASSWORD
parameter is validated.</p>

<p style="margin-top: 1em">In the PAM-based algorithm, the
USERNAME and PASSWORD parameters given to dacs_authenticate
are passed to the PAM module (e.g., pam_unix(8)[152]) that
has been configured by <br>
an administrator. This method is separate and much simpler
than what is provided by local_pam_authenticate[39]. To help
protect against misconfiguration, any unexpected <br>
behaviour by PAM will cause authentication to fail. For
example, the password prompt string produced by PAM must
match &quot;Password:&quot;, ignoring trailing spaces;
currently, this <br>
default can only be changed at compile time.</p>

<p style="margin-top: 1em">The STYLE should be configured
as password for this module.</p>

<p style="margin-top: 1em">The following OPTION directive
values are understood:</p>

<p style="margin-top: 1em">PAM_SERVICE (Optional1) <br>
This is the name of the PAM service policy to use. If
unspecified, a compile-time default (DEFAULT_PAM_SERVICE,
set to &quot;dacs-unix-auth&quot;) is used. The name of the
service <br>
policy will usually identify a file (for instance,
/etc/pam.d/dacs-unix-auth) that might simply contain
something like:</p>

<p style="margin-top: 1em">auth required pam_unix.so
no_warn</p>

<p style="margin-top: 1em">An existing policy file may be
available or it may be necessary to create one. On macOS,
for example, /etc/pam.d/chkpasswd contains the following
entry, which is <br>
sufficient for password validation:</p>

<p style="margin-top: 1em">auth required
pam_opendirectory.so</p>

<p style="margin-top: 1em">To use that file with this
module, the following DACS configuration directive would be
placed in the appropriate Auth clause:</p>

<p style="margin-top: 1em">OPTION
&quot;PAM_SERVICE=chkpasswd&quot;</p>

<p style="margin-top: 1em">See pam_start(3)[148] and
pam.conf(5)[168].</p>

<p style="margin-top: 1em">Depending on the operating
system, PAM modules might be found in /usr/lib,
/usr/lib/pam, or /lib/security.</p>

<p style="margin-top: 1em">It is possible to configure the
PAM service policy to use a password-based &quot;auth&quot;
facility other than the Unix password module, but do so with
care.</p>

<p style="margin-top: 1em">USE_PAM (Optional1) <br>
If &quot;yes&quot; or &quot;on&quot;, only use the PAM-based
algorithm, if &quot;no&quot; or &quot;off&quot;, do not use
the PAM-based algorithm, and if &quot;both&quot;,
&quot;try&quot;, or unspecified, use the PAM-based method
<br>
only if the password comparison algorithm is unavailable.
These string values are case insensitive.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_unix_authenticate or just unix. If the
built-in version is used, dacs_authenticate must be setuid
<br>
root, and if the web-based version is used,
local_unix_authenticate must be setuid root, so that the
shadow password file can be read and/or the PAM module used.
<br>
Authentication using this module will fail if it does not
execute with sufficient priviledges.</p>

<p style="margin-top: 1em">Note <br>
On platforms where encrypted passwords are unavailable, such
as macOS, authentication will always fail unless the
PAM-based algorithm is available and enabled.</p>

<p style="margin-top: 1em">Roles <br>
Each user authenticated by DACS may be associated with one
or more roles. The syntax of roles and role descriptors[14]
is described elsewhere. Role-based group membership is <br>
discussed in dacs.groups(5)[169]. Configuration of a Roles
clause is optional and if none are specified, an empty role
descriptor string will be used. If more than one Roles <br>
clause is configured, their role strings are concatenated
(duplicates are not removed). If a roles service fails, it
is treated as if it returned no roles and processing <br>
continues normally.</p>

<p style="margin-top: 1em">Like authentication, a modular
mechanism is used to find the roles with which a user is
associated. A roles module, analogous to an authentication
module, can be called by <br>
dacs_authenticate to return roles. A roles service returns a
roles_reply element (see roles_reply.dtd[170]).</p>

<p style="margin-top: 1em">Each Roles element must have an
id attribute. Its value is merely a label (an alphabetic
followed by zero or more alphanumerics, hyphens, and
underscores) that allows the clause <br>
to be referenced. The id attribute values must be unique
(case-sensitively) within the clause&rsquo;s Jurisdiction
section.</p>

<p style="margin-top: 1em">Note <br>
A maximum limit is imposed on the length of a role
descriptor string. Please refer to the
ROLE_STRING_MAX_LENGTH[171] directive.</p>

<p style="margin-top: 1em">Roles Clause Directives <br>
The roles directives are largely analogous to the
authentication directives.</p>

<p style="margin-top: 1em">When evaluation of the Roles
clauses begins, several variables are available in the Auth
namespace to reflect the outcome of authentication. These
variables may be useful when <br>
determining the user&rsquo;s roles: DACS_USERNAME,
DACS_IDENTITY, DACS_JURISDICTION, and DACS_VERSION.</p>

<p style="margin-top: 1em">Roles Clause Directives
Index:</p>

<p style="margin-top: 1em">1. EXIT* (Optional1)</p>

<p style="margin-top: 1em">2. EXPR (Optional1)</p>

<p style="margin-top: 1em">3. INIT* (Optional1)</p>

<p style="margin-top: 1em">4. OPTION (Optional)</p>

<p style="margin-top: 1em">5. OPTION* (Optional)</p>

<p style="margin-top: 1em">6. PREDICATE (Optional1)</p>

<p style="margin-top: 1em">7. URL (Optional1)</p>

<p style="margin-top: 1em">8. URL* (Optional1)</p>

<p style="margin-top: 1em">URL (Optional1) <br>
URL* (Optional1) <br>
Exactly one of these two directives must be specified,
unless EXPR is specified, in which case neither URL nor URL*
may be specified. These directives specify the URL to be
<br>
used to invoke the roles module (or is the name of a
built-in module). The difference between the two directives
is that the value of URL* is an expression that is evaluated
<br>
to determine the URL to be used; this evaluation occurs
immediately before the module is invoked.</p>

<p style="margin-top: 1em">INIT* (Optional1) <br>
An expression can be specified that is to be evaluated
immediately prior to the URL* and EXPR expressions, all of
which are evaluated before a module is invoked.</p>

<p style="margin-top: 1em">EXIT* (Optional1) <br>
If authentication is successful, this expression is
evaluated immediately after the module is executed or EXPR
evaluated.</p>

<p style="margin-top: 1em">EXPR (Optional1) <br>
This directive gives an expression that is evaluated to
obtain roles instead of invoking a roles module. Please
refer to Advanced Techniques.</p>

<p style="margin-top: 1em">OPTION (Optional) <br>
Similar to the Auth clause&rsquo;s OPTION[50] directive,
this is used to pass an argument to the roles module. A
given name may not be specified more than once within a
particular <br>
Roles clause. The Options namespace is initialized with
DACS_USERNAME, DACS_JURISDICTION, and DACS_VERSION
variables. If these are specified by an OPTION, the argument
<br>
ordinarily used will be overridden.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">OPTION
&quot;PASSWORD=bobo&quot;</p>

<p style="margin-top: 1em">causes PASSWORD=bobo to be
passed as a POST method parameter.</p>

<p style="margin-top: 1em">OPTION* (Optional) <br>
The given expression is evaluated before the module is
called, and after all OPTION directives and all OPTION*
directives that appear earlier. The value of the expression
<br>
must be a name=value pair, as with the OPTION directive, and
overrides any name in the Options namespace.</p>

<p style="margin-top: 1em">PREDICATE (Optional1) <br>
If provided, this expression is evaluated before any other
roles module processing is done. If there is an evaluation
error or it returns False (zero or the empty string), <br>
processing of the clause terminates and the next Roles
clause, if any, is processed. Otherwise, processing of the
clause continues normally.</p>

<p style="margin-top: 1em">Roles Clause Control Flow <br>
If authentication succeeds, Roles clauses are processed in
which they appear, but only if set_roles[70] has not been
specified for some authentication module&rsquo;s STYLE.</p>

<p style="margin-top: 1em">A Roles clause is processed in a
sequence of steps, and with various hooks to provide
fine-grained control. Before the first clause is examined,
the variables <br>
${Auth::CURRENT_ROLES} and ${Auth::LAST_ROLES} are
initialized to the role string, if any, obtained during
authentication module processing. Processing of each Roles
clause <br>
proceeds as follows:</p>

<p style="margin-top: 1em">1. If the clause has a PREDICATE
directive, it is evaluated in the current context. If the
value is not True the clause is not evaluated further. No
variables are updated. If <br>
the expression was invalid, processing of roles is
terminated.</p>

<p style="margin-top: 1em">2. If the clause has an INIT*
directive, it is evaluated; if an error occurs, processing
of roles is terminated.</p>

<p style="margin-top: 1em">3. If the clause has a URL*
directive, it is evaluated to obtain the URL of the DACS
roles service to be invoked; if an error occurs, processing
of roles is terminated. If the <br>
clause has an EXPR* directive, it is evaluated to obtain the
role string; if an error occurs during evaluation it is
treated as if the expression returned the empty string.</p>

<p style="margin-top: 1em">4. If a roles service has been
specified, it is invoked. If an error occurs, roles
processing continues as if the module returned the empty
string for the role string.</p>

<p style="margin-top: 1em">5. The variable
${Auth::LAST_ROLES} is set to the roles string returned by
the module or expression.</p>

<p style="margin-top: 1em">6. If the clause has an EXIT*
directive, it is evaluated; if an error occurs, processing
of roles is terminated. The value of ${Auth::LAST_ROLES}
becomes the role string <br>
returned by the clause.</p>

<p style="margin-top: 1em">7. The role string returned by
the clause is appended to the variable
${Auth::CURRENT_ROLES}.</p>

<p style="margin-top: 1em">The value of
${Auth::CURRENT_ROLES} when the last module has been
processed is the roles string that will be used in the
generated credentials.</p>

<p style="margin-top: 1em">Tip <br>
Some roles modules are available as built-in components of
dacs_authenticate. These modules are identified by specific
relative URLs; a module&rsquo;s description will provide its
<br>
built-in name when this capability is available. The
built-in capability will automatically be provided if the
module has been enabled at build-time. The same applies for
<br>
dacsauth.</p>

<p style="margin-top: 1em">Although it will be more
efficient (and possibly more secure) to use a built-in
module, they are executed on the same host as
dacs_authenticate (thereby giving up some <br>
flexibility), access control rules are not applied to them
(other than the one for dacs_authenticate), and
dacs_authenticate may need to be executed setuid (probably
as root) <br>
or setgid (as www, for example) so that it can access
password files.</p>

<p style="margin-top: 1em">Roles Modules <br>
If and only if authentication succeeds, DACS can request the
user&rsquo;s role descriptor from the jurisdiction. Roles
modules are always invoked using the POST method and are
passed <br>
the following arguments:</p>

<p style="margin-top: 1em">DACS_USERNAME <br>
The username component of the user&rsquo;s DACS
identity.</p>

<p style="margin-top: 1em">DACS_JURISDICTION <br>
The name of the jurisdiction that authenticated
DACS_USERNAME.</p>

<p style="margin-top: 1em">DACS_VERSION <br>
The DACS_VERSION_NUMBER for this version of
dacs_authenticate.</p>

<p style="margin-top: 1em">OPTION directives <br>
For each OPTION directive[172] or OPTION* directive[173] in
the Roles section being processed, the variable name and its
value are passed. <br>
Any of the standard web service arguments will also be
accepted; anything else will be ignored.</p>

<p style="margin-top: 1em">Roles modules return an
roles_reply.dtd[170] document to dacs_authenticate.</p>

<p style="margin-top: 1em">Note <br>
Although there is a roles module for obtaining LDAP or ADS
roles, you may also get them by authenticating through
local_ldap_authenticate[49] or by using a Roles clause with
<br>
an appropriate EXPR directive.</p>

<p style="margin-top: 1em">Roles Module Index:</p>

<p style="margin-top: 1em">1. local_roles: Private DACS
roles</p>

<p style="margin-top: 1em">2. local_ldap_roles: Roles
imported from an LDAP/ADS directory</p>

<p style="margin-top: 1em">3. local_unix_roles: Roles
imported from Unix group membership</p>

<p style="margin-top: 1em">local_roles <br>
This roles service consults a private list to obtain a
username-to-roles mapping using DACS virtual storage (the
item type is &quot;roles&quot;). The following example
configuration, <br>
which reflects typical usage, maintains mappings in a plain
text file named /usr/local/dacs/federations/roles.</p>

<p style="margin-top: 1em">VFS
&quot;[roles]dacs-kwv-fs:/usr/local/dacs/federations/roles&quot;</p>

<p style="margin-top: 1em">The file
/usr/local/dacs/federations/roles might look something like
this:</p>

<p style="margin-top: 1em">admin:dacs,admin <br>
rick:metalogic,guests <br>
bobo:staff,users <br>
auggie:staff,users</p>

<p style="margin-top: 1em">Here, user auggie is associated
with the roles staff and users.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_roles or just roles.</p>

<p style="margin-top: 1em">local_ldap_roles <br>
This roles service returns roles derived from the attributes
of a user&rsquo;s LDAP/ADS directory entry. This module is
based on local_ldap_authenticate[49]; please consult the
<br>
description and examples presented with that authentication
module for additional information.</p>

<p style="margin-top: 1em">Note <br>
The user need not have been authenticated by LDAP/ADS for
this module to be used. For example, the user can be
authenticated on a Unix system but his roles can come from
<br>
LDAP/ADS.</p>

<p style="margin-top: 1em">The following configuration
directives are recognized by this module. They function
identically to the directives of the same name used by
local_ldap_authenticate[49], so for <br>
the most part their descriptions will not be repeated
here.</p>

<p style="margin-top: 1em">Note <br>
These module directives must be passed using either
OPTION[172] or OPTION*[173] directives. Ensure that the
option value is properly quoted.</p>

<p style="margin-top: 1em">LDAP_BIND_METHOD (Required1-C)
<br>
This tells the module how to find the user&rsquo;s entry in
the directory.</p>

<p style="margin-top: 1em">LDAP_USERNAME_URL (Optional1)
<br>
LDAP_USERNAME_URL* (Optional1) <br>
With the direct method, one of these options is used to name
the user&rsquo;s entry as a URI.</p>

<p style="margin-top: 1em">LDAP_ADMIN_URL (Required1-C)
<br>
If the indirect method is used, this option is required.
This value is a URI like LDAP_USERNAME_URL except that it
identifies the LDAP administrator within the directory.</p>

<p style="margin-top: 1em">LDAP_ADMIN_PASSWORD (Optional1)
<br>
This is the password for the LDAP administrator account that
corresponds to LDAP_ADMIN_URL.</p>

<p style="margin-top: 1em">LDAP_SEARCH_ROOT_DN
(Required1-C) <br>
This is the root DN at which the indirect method should
begin searching for user entries.</p>

<p style="margin-top: 1em">LDAP_SEARCH_FILTER (Required1-C)
<br>
LDAP_SEARCH_FILTER* (Required1-C) <br>
If the indirect method is used, either this option or
LDAP_SEARCH_FILTER* (but not both) must be configured. This
search filter is used to select the unique directory <br>
entry that corresponds to this user. The LDAP_SEARCH_FILTER*
option is exactly like LDAP_SEARCH_FILTER except that it is
evaluated just before it is used, allowing <br>
various elements of the execution context to appear in the
string. The DACS username obtained from the preceding
authentication phase can be referenced as <br>
${Args::DACS_USERNAME}.</p>

<p style="margin-top: 1em">LDAP_USERNAME_EXPR* (Optional1)
<br>
This option is evaluated to yield a username that can be
referenced by the LDAP_ROLES_SELECTOR* option as
${LDAP::USERNAME}.</p>

<p style="margin-top: 1em">LDAP_ROLES_SELECTOR* (Optional)
<br>
Each occurrence of this directive specifies an expression
that is evaluated by iterating through each attribute of the
entry and making the attribute name <br>
(${LDAP::attrname}) and its value (${LDAP::attrvalue})
available. All of the entry&rsquo;s attribute names and
values are made available within the LDAP namespace. If the
<br>
result of the expression is a valid role string (which
excludes the empty string, &quot;&quot;), it is added to the
list of roles.</p>

<p style="margin-top: 1em">LDAP_TIMEOUT_SECS (Optional1)
<br>
This is a maximum time limit, in seconds, for any individual
LDAP read or search operation performed by the module. If
not specified, there will not be an <br>
application-specified time limit.</p>

<p style="margin-top: 1em">Here is an example that binds to
the directory on x.example.com as the administrator,
searches for the entry for the account of the authenticated
user, and assigns the user a <br>
role from the attribute value of each memberOf attribute in
the entry:</p>

<p style="margin-top: 1em">&lt;Roles
id=&quot;ldap_roles&quot;&gt; <br>
URL
&quot;http://example.com/cgi-bin/dacs/local_ldap_roles&quot;
<br>
OPTION &quot;LDAP_BIND_METHOD=indirect&quot; <br>
OPTION
&rsquo;LDAP_ADMIN_URL=&quot;ldap://x.example.com/CN=Administrator,CN=Users,DC=example,DC=com&quot;&rsquo;
<br>
OPTION
&rsquo;LDAP_ADMIN_PASSWORD=&quot;secretpassword&quot;&rsquo;</p>

<p style="margin-top: 1em">OPTION
&rsquo;LDAP_SEARCH_ROOT_DN=&quot;cn=Users,dc=example,dc=com&quot;&rsquo;
<br>
OPTION
&rsquo;LDAP_SEARCH_FILTER*=&acute;&quot;(sAMAccountName=${Args::DACS_USERNAME})&quot;&acute;&rsquo;</p>

<p style="margin-top: 1em">OPTION
&rsquo;LDAP_ROLES_SELECTOR*=&acute;&quot;${LDAP::attrname}&quot;
eq &quot;memberOf&quot; ? strtr(ldap(rdn_attrvalue,
ldap(dn_index, &quot;${LDAP::attrvalue}&quot;, 1)), &quot;
&quot;, &quot;_&quot;) : &quot;&quot;&acute;&rsquo; <br>
&lt;/Roles&gt;</p>

<p style="margin-top: 1em">For example, the resulting role
string might look like:</p>


<p style="margin-top: 1em">DnsAdmins,Print_Operators,Domain_Admins,Administrators</p>

<p style="margin-top: 1em">local_unix_roles <br>
This roles service returns the Unix group membership
associated with an authenticated username; that it, the
resulting list of roles is the same as would be obtained if
the <br>
user ran the Unix groups(1)[174].</p>

<p style="margin-top: 1em">Note <br>
The user need not have been authenticated as this username
on the Unix system where this service is run.</p>

<p style="margin-top: 1em">Tip <br>
A built-in version of this module can be selected by using
the URL local_unix_roles or just unix.</p>

<p style="margin-top: 1em">Related Services <br>
The dacs_current_credentials(8)[35] web service displays
elements of each set of credentials sent with the request.
The dacs_signout(8)[175] service is typically called from a
<br>
browser to cause one or more cookies (each representing a
DACS identity) to be deleted. Cookies are automatically
deleted when a browser terminates, but it is sometimes
useful to <br>
explicitly logoff.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
The program exits 0 if everything was fine, 1 if an error
occurred.</p>

<p style="margin-top: 1em">NOTES <br>
A separate but similar mechanism called &quot;affiliated
DACS federations&quot; supports cross-federation single
sign-on; see dacs_auth_transfer(8)[8].</p>

<p style="margin-top: 1em">dacs_authenticate could be
modified to temporarily disable an account after some number
of unsuccessful login attempts over a certain time period.
The flip side of such a feature <br>
is that it could be used in a denial of service attack.
Rather than disabling an account, a designated administrator
might receive an email notification or a console message
<br>
might be logged.</p>

<p style="margin-top: 1em">It might be worthwhile to
include a rule-based mechanism, called after the user has
been identified but before credentials are returned, to
decide whether authentication should <br>
be permitted. This might be used, for example, to restrict a
particular user to login from a specified IP address or
range of addresses, or limit the time of day at which login
<br>
is allowed.</p>

<p style="margin-top: 1em">BUGS <br>
It would be nice to provide assistance to programs that
generate login pages. Composing modules should be easier, to
make multi-factor authentication more accessible.</p>

<p style="margin-top: 1em">SEE ALSO <br>
dacsauth(1)[6], dacscred(1)[176], dacscookie(1)[9],
dacs.exprs(5)[3], dacs_autologin_ssl(8)[177],
autologin(8)[139], dacs_auth_agent(8)[7],
dacs_auth_transfer(8)[8], <br>
dacs_current_credentials(8)[35],
dacs_select_credentials(8)[46], dacs_signout(8)[175],
pamd(8)[155]</p>

<p style="margin-top: 1em">AUTHOR <br>
Distributed Systems Software (www.dss.ca[178])</p>

<p style="margin-top: 1em">COPYING <br>
Copyright2003-2016 Distributed Systems Software. See the
LICENSE[179] file that accompanies the distribution for
licensing information.</p>

<p style="margin-top: 1em">NOTES <br>
1. dacsoptions <br>
http://dacs.dss.ca/man/dacs.1.html#dacsoptions</p>

<p style="margin-top: 1em">2. dacs.conf(5) <br>
http://dacs.dss.ca/man/dacs.conf.5.html</p>

<p style="margin-top: 1em">3. dacs.exprs(5) <br>
http://dacs.dss.ca/man/dacs.exprs.5.html</p>

<p style="margin-top: 1em">4. html/examples <br>
http://dacs.dss.ca/man//examples</p>

<p style="margin-top: 1em">5. HTTP Authentication <br>

http://dacs.dss.ca/man/dacs_acs.8.html#http_authentication</p>

<p style="margin-top: 1em">6. dacsauth(1) <br>
http://dacs.dss.ca/man/dacsauth.1.html</p>

<p style="margin-top: 1em">7. dacs_auth_agent(8) <br>
http://dacs.dss.ca/man/dacs_auth_agent.8.html</p>

<p style="margin-top: 1em">8. dacs_auth_transfer(8) <br>
http://dacs.dss.ca/man/dacs_auth_transfer.8.html</p>

<p style="margin-top: 1em">9. dacscookie(1) <br>
http://dacs.dss.ca/man/dacscookie.1.html</p>

<p style="margin-top: 1em">10. Auth clause <br>
http://dacs.dss.ca/man/#auth_clause</p>

<p style="margin-top: 1em">11. CONTROL <br>
http://dacs.dss.ca/man/#CONTROL</p>

<p style="margin-top: 1em">12. username <br>
http://dacs.dss.ca/man/dacs.1.html#dacs_identity</p>

<p style="margin-top: 1em">13. dacs.acls(5) <br>
http://dacs.dss.ca/man/dacs.acls.5.html#revocation_list</p>

<p style="margin-top: 1em">14. dacs(1) <br>
http://dacs.dss.ca/man/dacs.1.html#naming</p>

<p style="margin-top: 1em">15. credentials.dtd <br>
http://dacs.dss.ca/man/../dtd-xsd/credentials.dtd</p>

<p style="margin-top: 1em">16. VERIFY_IP <br>
http://dacs.dss.ca/man/dacs.conf.5.html#VERIFY_IP</p>

<p style="margin-top: 1em">17. natd(8) <br>

http://www.freebsd.org/cgi/man.cgi?query=natd&amp;apropos=0&amp;sektion=8&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">18. VERIFY_UA <br>
http://dacs.dss.ca/man/dacs.conf.5.html#VERIFY_UA</p>

<p style="margin-top: 1em">19.
AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS <br>

http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS</p>

<p style="margin-top: 1em">20. Advanced Encryption Standard
<br>

https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</p>

<p style="margin-top: 1em">21. Federal Information
Processing Standard <br>

http://www.nist.gov/itl/fips.cfhttp://www.nist.gov/itl/fips.cfm</p>

<p style="margin-top: 1em">22. FIPS 198 <br>

http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf</p>

<p style="margin-top: 1em">23. RFC 2104 <br>
http://www.rfc-editor.org/rfc/rfc2104.txt</p>

<p style="margin-top: 1em">24. RFC 4635 <br>
http://www.rfc-editor.org/rfc/rfc4635.txt</p>

<p style="margin-top: 1em">25. RFC 4868 <br>
http://www.rfc-editor.org/rfc/rfc4868.txt</p>

<p style="margin-top: 1em">26. NIST <br>
http://www.nist.gov/</p>

<p style="margin-top: 1em">27. FIPS 180-1 <br>
http://www.itl.nist.gov/fipspubs/fip180-1.htm</p>

<p style="margin-top: 1em">28. RFC 4634 <br>
http://www.rfc-editor.org/rfc/rfc4634.txt</p>

<p style="margin-top: 1em">29. RFC 6234 <br>
http://www.rfc-editor.org/rfc/rfc6234.txt</p>

<p style="margin-top: 1em">30. FIPS 180-4 <br>

http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf</p>

<p style="margin-top: 1em">31. MD5 algorithm <br>
http://www.rfc-editor.org/rfc/rfc1321.txt</p>

<p style="margin-top: 1em">32. Netscape HTTP Cookies
Specification <br>

http://web.archive.org/web/20070805052634/http://wp.netscape.com/newsref/std/cookie_spec.html</p>

<p style="margin-top: 1em">33. COOKIE_SYNTAX <br>
http://dacs.dss.ca/man/#COOKIE_SYNTAX</p>

<p style="margin-top: 1em">34. COOKIE_NAME_TERMINATORS <br>

http://dacs.dss.ca/man/dacs.conf.5.html#COOKIE_NAME_TERMINATORS</p>

<p style="margin-top: 1em">35. dacs_current_credentials(8)
<br>
http://dacs.dss.ca/man/dacs_current_credentials.8.html</p>

<p style="margin-top: 1em">36. COOKIE_PATH <br>
http://dacs.dss.ca/man/dacs.conf.5.html#COOKIE_PATH</p>

<p style="margin-top: 1em">37. SECURE_MODE <br>
http://dacs.dss.ca/man/dacs.conf.5.html#SECURE_MODE</p>

<p style="margin-top: 1em">38. standard CGI arguments <br>

http://dacs.dss.ca/man/dacs.services.8.html#standard_cgi_args</p>

<p style="margin-top: 1em">39. local_pam_authenticate <br>
http://dacs.dss.ca/man/#local_pam_authenticate</p>

<p style="margin-top: 1em">40. RFC 2109 <br>
http://www.rfc-editor.org/rfc/rfc2109.txt</p>

<p style="margin-top: 1em">41. RFC 2965 <br>
http://www.rfc-editor.org/rfc/rfc2965.txt</p>

<p style="margin-top: 1em">42. RFC 6265 <br>
http://www.rfc-editor.org/rfc/rfc6265.txt</p>

<p style="margin-top: 1em">43. RFC 2616 <br>
http://www.rfc-editor.org/rfc/rfc2616.txt</p>

<p style="margin-top: 1em">44. colons are used within
cookie names <br>
http://dacs.dss.ca/man/#cookie-name-syntax</p>

<p style="margin-top: 1em">45. dacs_acs(8) <br>
http://dacs.dss.ca/man/dacs_acs.8.html</p>

<p style="margin-top: 1em">46. dacs_select_credentials(8)
<br>
http://dacs.dss.ca/man/dacs_select_credentials.8.html</p>

<p style="margin-top: 1em">47. strtr() <br>
http://dacs.dss.ca/man/dacs.exprs.5.html#strtr</p>

<p style="margin-top: 1em">48. LDAP_USERNAME_URL <br>
http://dacs.dss.ca/man/#LDAP_USERNAME_URL</p>

<p style="margin-top: 1em">49. local_ldap_authenticate <br>
http://dacs.dss.ca/man/#local_ldap_authenticate</p>

<p style="margin-top: 1em">50. OPTION <br>
http://dacs.dss.ca/man/#OPTION</p>

<p style="margin-top: 1em">51. dacs.conf(5) <br>
http://dacs.dss.ca/man/dacs.conf.5.html#auth_clause</p>

<p style="margin-top: 1em">52. pam(3) <br>

http://www.freebsd.org/cgi/man.cgi?query=pam&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">53. X/Open Single Sign-On
Service (XSSO) preliminary specification <br>
http://www.opengroup.org/pubs/catalog/p702.htm</p>

<p style="margin-top: 1em">54. dacs.conf(5) <br>
http://dacs.dss.ca/man/dacs.conf.5.html#merging</p>

<p style="margin-top: 1em">55. Authenticating Using an
Expression <br>
http://dacs.dss.ca/man/#expr</p>

<p style="margin-top: 1em">56. PASSWORD_CONSTRAINTS <br>

http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_CONSTRAINTS</p>

<p style="margin-top: 1em">57. LOG_FILTER <br>
http://dacs.dss.ca/man/dacs.conf.5.html#LOG_FILTER</p>

<p style="margin-top: 1em">58. local_cas_authenticate <br>
http://dacs.dss.ca/man/#local_cas_authenticate</p>

<p style="margin-top: 1em">59. Central Authentication
Service (CAS) <br>

https://en.wikipedia.org/wiki/Central_Authentication_Service</p>

<p style="margin-top: 1em">60. RFC 2617 <br>
http://www.rfc-editor.org/rfc/rfc2617.txt</p>

<p style="margin-top: 1em">61. local_apache_authenticate
<br>
http://dacs.dss.ca/man/#local_apache_authenticate</p>

<p style="margin-top: 1em">62. Information Card <br>
http://en.wikipedia.org/wiki/Information_Card</p>

<p style="margin-top: 1em">63. dacsinfocard(1) <br>
http://dacs.dss.ca/man/dacsinfocard.1.html</p>

<p style="margin-top: 1em">64. dacs_infocard(8) <br>
http://dacs.dss.ca/man/dacs_infocard.8.html</p>

<p style="margin-top: 1em">65. dacs_managed_infocard(8)
<br>
http://dacs.dss.ca/man/dacs_managed_infocard.8.html</p>

<p style="margin-top: 1em">66. local_infocard_authenticate
<br>
http://dacs.dss.ca/man/#local_infocard_authenticate</p>

<p style="margin-top: 1em">67. local_simple_authenticate
<br>
http://dacs.dss.ca/man/#local_simple_authenticate</p>

<p style="margin-top: 1em">68. local_tgma_authenticate <br>
http://dacs.dss.ca/man/#local_tgma_authenticate</p>

<p style="margin-top: 1em">69. add_roles <br>
http://dacs.dss.ca/man/#add_roles</p>

<p style="margin-top: 1em">70. set_roles <br>
http://dacs.dss.ca/man/#set_roles</p>

<p style="margin-top: 1em">71. dacs.exprs(5) <br>
http://dacs.dss.ca/man/dacs.exprs.5.html#variables</p>

<p style="margin-top: 1em">72. AUTH_SUCCESS <br>
http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_SUCCESS</p>

<p style="margin-top: 1em">73. AUTH_SUCCESS_HANDLER <br>

http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_SUCCESS_HANDLER</p>

<p style="margin-top: 1em">74. AUTH_ERROR_HANDLER <br>

http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_ERROR_HANDLER</p>

<p style="margin-top: 1em">75. AUTH_FAIL_DELAY_SECS <br>

http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_FAIL_DELAY_SECS</p>

<p style="margin-top: 1em">76. DACS_AUTH_SUCCESS_HANDLER
<br>
http://dacs.dss.ca/man/#DACS_AUTH_SUCCESS_HANDLER</p>

<p style="margin-top: 1em">77. ENABLE_AUTH_HANDLERS <br>
http://dacs.dss.ca/man/#ENABLE_AUTH_HANDLERS</p>

<p style="margin-top: 1em">78. dacs_prenv(8) <br>
http://dacs.dss.ca/man/dacs_prenv.8.html</p>

<p style="margin-top: 1em">79. Environment variables <br>

http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#envvars</p>

<p style="margin-top: 1em">80. mod_ssl <br>
http://httpd.apache.org/docs-2.2/mod/mod_ssl.html</p>

<p style="margin-top: 1em">81. dacs.services(8) <br>
http://dacs.dss.ca/man/dacs.services.8.html#FORMAT</p>

<p style="margin-top: 1em">82. dacs_auth_reply.dtd <br>
http://dacs.dss.ca/man/../dtd-xsd/dacs_auth_reply.dtd</p>

<p style="margin-top: 1em">83. dacs_current_credentials.dtd
<br>

http://dacs.dss.ca/man/../dtd-xsd/dacs_current_credentials.dtd</p>

<p style="margin-top: 1em">84. auth_reply.dtd <br>
http://dacs.dss.ca/man/../dtd-xsd/auth_reply.dtd</p>

<p style="margin-top: 1em">85. dacs.install(7) <br>
http://dacs.dss.ca/man//man/dacs.install.7.html</p>

<p style="margin-top: 1em">86. mod_auth <br>
http://httpd.apache.org/docs-2.2/mod/mod_auth.html</p>

<p style="margin-top: 1em">87. mod_auth_digest <br>

http://httpd.apache.org/docs-2.2/mod/mod_auth_digest.html</p>

<p style="margin-top: 1em">88. mod_auth_dbm <br>
http://httpd.apache.org/docs-2.2/mod/mod_auth_dbm.html</p>

<p style="margin-top: 1em">89. htpasswd(1) <br>
http://httpd.apache.org/docs/2.2/programs/htpasswd.html</p>

<p style="margin-top: 1em">90. htdigest(1) <br>
http://httpd.apache.org/docs/2.2/programs/htdigest.html</p>

<p style="margin-top: 1em">91. htdbm(1) <br>
http://httpd.apache.org/docs/2.2/programs/htdbm.html</p>

<p style="margin-top: 1em">92. local_native_authenticate
<br>
http://dacs.dss.ca/man/#local_native_authenticate</p>

<p style="margin-top: 1em">93. Central Authentication
Service (CAS) <br>
http://www.jasig.org/cas</p>

<p style="margin-top: 1em">94. CAS 2.0 Protocol <br>
http://www.jasig.org/cas/protocol</p>

<p style="margin-top: 1em">95. OpenID <br>
http://openid.net/</p>

<p style="margin-top: 1em">96. STYLE <br>
http://dacs.dss.ca/man/#STYLE</p>

<p style="margin-top: 1em">97. SSLVerifyClient <br>

http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#sslverifyclient</p>

<p style="margin-top: 1em">98. SSLRequire <br>

http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#sslrequire</p>

<p style="margin-top: 1em">99. OpenSSL <br>
http://www.openssl.org</p>

<p style="margin-top: 1em">00. SSLOptions <br>

http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#ssloptions</p>

<p style="margin-top: 1em">01. dacsgrid(1) <br>
http://dacs.dss.ca/man/dacsgrid.1.html</p>

<p style="margin-top: 1em">02. Google <br>
http://www.google.com</p>

<p style="margin-top: 1em">03. account authentication <br>

http://code.google.com/apis/accounts/AuthForInstalledApps.html</p>

<p style="margin-top: 1em">04. eBay <br>
http://developer.ebay.com/developercenter/rest/</p>

<p style="margin-top: 1em">05. Yahoo! <br>
http://developer.yahoo.com/auth/</p>

<p style="margin-top: 1em">06. announced <br>

http://blogs.msdn.com/b/card/archive/2011/02/15/beyond-windows-cardspace.aspx</p>

<p style="margin-top: 1em">07. CardSpace <br>
http://en.wikipedia.org/wiki/Windows_CardSpace</p>

<p style="margin-top: 1em">08. Windows 8 <br>

http://en.wikipedia.org/wiki/List_of_features_removed_in_Windows_8</p>

<p style="margin-top: 1em">09. On the Demise of CardSpace
<br>

http://upon2020.com/blog/2011/03/on-the-demise-of-cardspace/</p>

<p style="margin-top: 1em">10. Open Cardspace opportunity
<br>

http://blogs.law.harvard.edu/doc/2011/02/16/open-cardspace-opportunity/</p>

<p style="margin-top: 1em">11. Personal Reflections on the
CardSpace Journey <br>
http://self-issued.info/?p=458</p>

<p style="margin-top: 1em">12. From CardSpace to Verified
Claims <br>
http://www.identityblog.com/?p=1164</p>

<p style="margin-top: 1em">13. Change will come: the
present is untenable <br>
http://www.identityblog.com/?p=1165</p>

<p style="margin-top: 1em">14. The Clay Feet of Giants?
<br>
http://www.identityblog.com/?p=1167</p>

<p style="margin-top: 1em">15. RIP, Windows CardSpace.
Hello, U-Prove <br>

http://www.zdnet.com/blog/microsoft/rip-windows-cardspace-hello-u-prove/8717</p>

<p style="margin-top: 1em">16. U-Prove <br>
http://research.microsoft.com/en-us/projects/u-prove/</p>

<p style="margin-top: 1em">17. Identity Selector
Interoperability Profile (ISIP) 1.5 <br>

http://download.microsoft.com/download/1/1/a/11ac6505-e4c0-4e05-987c-6f1d31855cd2/Identity_Selector_Interoperability_Profile_V1.5.pdf</p>

<p style="margin-top: 1em">18. role descriptor string <br>
http://dacs.dss.ca/man/dacs.1.html#roles</p>

<p style="margin-top: 1em">19. dacs_infocard(8) <br>

http://dacs.dss.ca/man/dacs_infocard.8.html#about_claims</p>

<p style="margin-top: 1em">20. expression-based
authentication style <br>

http://dacs.dss.ca/man//man/dacs_authenticate.8.html#expr</p>

<p style="margin-top: 1em">21. dacs_managed_infocard(8)
<br>

http://dacs.dss.ca/man//man/dacs_managed_infocard.8.html</p>

<p style="margin-top: 1em">22. dacs.conf(5) <br>

http://dacs.dss.ca/man//man/dacs.conf.5.html#INFOCARD_prefixed</p>

<p style="margin-top: 1em">23. dacs_mex(8) <br>
http://dacs.dss.ca/man//man/dacs_mex.8.html</p>

<p style="margin-top: 1em">24. dacs_sts(8) <br>
http://dacs.dss.ca/man//man/dacs_sts.8.html</p>

<p style="margin-top: 1em">25. Using InfoCards With DACS
<br>
http://dacs.dss.ca/man/using-infocards-with-dacs.html</p>

<p style="margin-top: 1em">26. Identity Selector
Interoperability Profile specification and companion guides
<br>

http://www.microsoft.com/downloads/details.aspx?FamilyID=b94817fc-3991-4dd0-8e85-b73e626f6764&amp;DisplayLang=en</p>

<p style="margin-top: 1em">27. Introducing Windows
CardSpace <br>
http://msdn.microsoft.com/en-us/library/aa480189.aspx</p>

<p style="margin-top: 1em">28. RFC 2251 <br>
http://www.faqs.org/rfcs/rfc2251.html</p>

<p style="margin-top: 1em">29. RFC 2252 <br>
http://www.faqs.org/rfcs/rfc2252.html</p>

<p style="margin-top: 1em">30. RFC 2253 <br>
http://www.faqs.org/rfcs/rfc2253.html</p>

<p style="margin-top: 1em">31. RFC 3377 <br>
http://www.faqs.org/rfcs/rfc3377.html</p>

<p style="margin-top: 1em">32. Active Directory (ADS) <br>

http://www.microsoft.com/windows2000/technologies/directory/ad/default.asp</p>

<p style="margin-top: 1em">33. OpenLDAP <br>
http://www.openldap.org</p>

<p style="margin-top: 1em">34. ldap() <br>
http://dacs.dss.ca/man/dacs.exprs.5.html#ldap</p>

<p style="margin-top: 1em">35. LDAP_USERNAME_URL* <br>
http://dacs.dss.ca/man/#LDAP_USERNAME_URL*</p>

<p style="margin-top: 1em">36. RFC 2396 <br>
http://www.faqs.org/rfcs/rfc2396.html</p>

<p style="margin-top: 1em">37. RFC 3986 <br>
http://www.rfc-editor.org/rfc/rfc3986.txt</p>

<p style="margin-top: 1em">38. ldapsearch(1) <br>

http://www.openldap.org/software/man.cgi?query=ldapsearch&amp;apropos=0&amp;sektion=0&amp;manpath=OpenLDAP+2.4-Release&amp;format=html</p>

<p style="margin-top: 1em">39. autologin(8) <br>
http://dacs.dss.ca/man/autologin.8.html</p>

<p style="margin-top: 1em">40. 1 <br>
http://curl.haxx.se/rfc/ntlm.html</p>

<p style="margin-top: 1em">41. 2 <br>

http://msdn.microsoft.com/en-us/library/cc236621%28PROT.10%29.aspx</p>

<p style="margin-top: 1em">42. Samba <br>
http://www.samba.org</p>

<p style="margin-top: 1em">43. NTLM authentication <br>
https://en.wikipedia.org/wiki/NTLM</p>

<p style="margin-top: 1em">44. have been identified <br>
http://support.microsoft.com/kb/2793313</p>

<p style="margin-top: 1em">45. smbclient(1) <br>

http://www.samba.org/samba/docs/man/manpages-3/smbclient.1.html</p>

<p style="margin-top: 1em">46. dacs(1) <br>
http://dacs.dss.ca/man/dacs.1.html</p>

<p style="margin-top: 1em">47. dacscheck(1) <br>
http://dacs.dss.ca/man/dacscheck.1.html</p>

<p style="margin-top: 1em">48. pam_start(3) <br>

http://www.freebsd.org/cgi/man.cgi?query=pam_start&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">49. GNU/Linux <br>
http://www.kernel.org/pub/linux/libs/pam/modules.html</p>

<p style="margin-top: 1em">50. FreeBSD <br>

http://www.freebsd.org/doc/en_US.ISO8859-1/articles/pam/pam-freebsd-modules.html</p>

<p style="margin-top: 1em">51. macOS <br>

https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/pam.3.html</p>

<p style="margin-top: 1em">52. pam_unix(8) <br>

http://www.freebsd.org/cgi/man.cgi?query=pam_unix&amp;apropos=0&amp;sektion=8&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">53. local_unix_authenticate <br>
http://dacs.dss.ca/man/#local_unix_authenticate</p>

<p style="margin-top: 1em">54. ATM <br>
https://en.wikipedia.org/wiki/Cash_machine</p>

<p style="margin-top: 1em">55. pamd(8) <br>
http://dacs.dss.ca/man/pamd.8.html</p>

<p style="margin-top: 1em">56. dacs_url <br>
http://dacs.dss.ca/man/dacs.groups.5.html#group_syntax</p>

<p style="margin-top: 1em">57. local_pam_authenticate.css
<br>
http://dacs.dss.ca/man//css/local_pam_authenticate.css</p>

<p style="margin-top: 1em">58. PASSWORD_DIGEST <br>
http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_DIGEST</p>

<p style="margin-top: 1em">59. dacspasswd(1) <br>
http://dacs.dss.ca/man/dacspasswd.1.html</p>

<p style="margin-top: 1em">60. RFC 2945 <br>
http://www.rfc-editor.org/rfc/rfc2945.txt</p>

<p style="margin-top: 1em">61. RFC 5054 <br>
http://www.rfc-editor.org/rfc/rfc5054.txt</p>

<p style="margin-top: 1em">62. dacstoken(1) <br>
http://dacs.dss.ca/man/dacstoken.1.html</p>

<p style="margin-top: 1em">63. RFC 4226 <br>
http://www.rfc-editor.org/rfc/rfc4226.txt</p>

<p style="margin-top: 1em">64. OATH <br>
http://www.openauthentication.org</p>

<p style="margin-top: 1em">65. pam(3) <br>

http://www.freebsd.org/cgi/man.cgi?query=pam&amp;apropos=0&amp;sekti
on=0&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">66. getpwnam(3) <br>

http://www.freebsd.org/cgi/man.cgi?query=getpwnam&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">67. yp(8) <br>

http://www.freebsd.org/cgi/man.cgi?query=yp&amp;apropos=0&amp;sektion=8&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">68. pam.conf(5) <br>

http://www.freebsd.org/cgi/man.cgi?query=pam.conf&amp;apropos=0&amp;sektion=5&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">69. dacs.groups(5) <br>
http://dacs.dss.ca/man/dacs.groups.5.html</p>

<p style="margin-top: 1em">70. roles_reply.dtd <br>
http://dacs.dss.ca/man/../dtd-xsd/roles_reply.dtd</p>

<p style="margin-top: 1em">71. ROLE_STRING_MAX_LENGTH <br>

http://dacs.dss.ca/man/dacs.conf.5.html#ROLE_STRING_MAX_LENGTH</p>

<p style="margin-top: 1em">72. OPTION directive <br>
http://dacs.dss.ca/man/#r_OPTION</p>

<p style="margin-top: 1em">73. OPTION* directive <br>
http://dacs.dss.ca/man/#r_OPTION*</p>

<p style="margin-top: 1em">74. groups(1) <br>

http://www.freebsd.org/cgi/man.cgi?query=groups&amp;apropos=0&amp;sektion=1&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">75. dacs_signout(8) <br>
http://dacs.dss.ca/man/dacs_signout.8.html</p>

<p style="margin-top: 1em">76. dacscred(1) <br>
http://dacs.dss.ca/man/dacscred.1.html</p>

<p style="margin-top: 1em">77. dacs_autologin_ssl(8) <br>
http://dacs.dss.ca/man/dacs_autologin_ssl.8.html</p>

<p style="margin-top: 1em">78. www.dss.ca <br>
http://www.dss.ca</p>

<p style="margin-top: 1em">79. LICENSE <br>
http://dacs.dss.ca/man/../misc/LICENSE</p>

<p style="margin-top: 1em">DACS 1.4.38a 01/12/2017
DACS_AUTHENTICATE(8)</p>
<hr>
</body>
</html>
