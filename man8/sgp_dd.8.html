<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:15:51 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>SGP_DD(8) SG3_UTILS SGP_DD(8)</p>

<p style="margin-top: 1em">NAME <br>
sgp_dd - copy data to and from files and devices, especially
SCSI devices</p>

<p style="margin-top: 1em">SYNOPSIS <br>
sgp_dd [bs=BS] [count=COUNT] [ibs=BS] [if=IFILE]
[iflag=FLAGS] [obs=BS] [of=OFILE] [oflag=FLAGS] [seek=SEEK]
[skip=SKIP] [--help] [--version]</p>

<p style="margin-top: 1em">[bpt=BPT] [coe=0|1]
[cdbsz=6|10|12|16] [deb=VERB] [dio=0|1] [sync=0|1] [thr=THR]
[time=0|1] [verbose=VERB]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Copy data to and from any files. Specialised for
&quot;files&quot; that are Linux SCSI generic (sg) and raw
devices. Similar syntax and semantics to dd(1) but does not
perform any conver&acirc; <br>
sions. Uses POSIX threads to increase the amount of
parallelism. This improves speed in some cases.</p>

<p style="margin-top: 1em">The first group in the synopsis
above are &quot;standard&quot; Unix dd(1) operands. The
second group are extra options added by this utility. Both
groups are defined below.</p>

<p style="margin-top: 1em">OPTIONS <br>
bpt=BPT <br>
each IO transaction will be made using BPT blocks (or less
if near the end of the copy). Default is 128 for block sizes
less that 2048 bytes, otherwise the default is 32. <br>
So for bs=512 the reads and writes will each convey 64 KiB
of data by default (less if near the end of the transfer or
memory restrictions). When cd/dvd drives are <br>
accessed, the block size is typically 2048 bytes and bpt
defaults to 32 which again implies 64 KiB transfers.</p>

<p style="margin-top: 1em">bs=BS where BS must be the block
size of the physical device. Note that this differs from
dd(1) which permits &rsquo;bs&rsquo; to be an integral
multiple of the actual device block size. <br>
Default is 512 which is usually correct for disks but
incorrect for cdroms (which normally have 2048 byte
blocks).</p>

<p style="margin-top: 1em">cdbsz=6 | 10 | 12 | 16 <br>
size of SCSI READ and/or WRITE commands issued on sg device
names. Default is 10 byte SCSI command blocks (unless
calculations indicate that a 4 byte block number may be <br>
exceeded, in which case it defaults to 16 byte SCSI
commands).</p>

<p style="margin-top: 1em">coe=0 | 1 <br>
set to 1 for continue on error. Only applies to errors on sg
devices. Thus errors on other files will stop sgp_dd.
Default is 0 which implies stop on any error. See the <br>
&rsquo;coe&rsquo; flag for more information.</p>

<p style="margin-top: 1em">count=COUNT <br>
copy COUNT blocks from IFILE to OFILE. Default is the
minimum (of IFILE and OFILE) number of blocks that sg
devices report from SCSI READ CAPACITY commands or that
block <br>
devices (or their partitions) report. Normal files are not
probed for their size. If skip=SKIP or skip=SEEK are given
and the count is deduced (i.e. not explicitly given) <br>
then that count is scaled back so that the copy will not
overrun the device. If the file name is a block device
partition and COUNT is not given then the size of the
par&acirc; <br>
tition rather than the size of the whole device is used. If
COUNT is not given and cannot be deduced then an error
message is issued and no copy takes place.</p>

<p style="margin-top: 1em">deb=VERB <br>
outputs debug information. If VERB is 0 (default) then there
is minimal debug information and as VERB increases so does
the amount of debug (max debug output when VERB is <br>
9).</p>

<p style="margin-top: 1em">dio=0 | 1 <br>
default is 0 which selects indirect IO. Value of 1 attempts
direct IO which, if not available, falls back to indirect IO
and notes this at completion. If direct IO is <br>
selected and /proc/scsi/sg/allow_dio has the value of 0 then
a warning is issued (and indirect IO is performed) For finer
grain control use &rsquo;iflag=dio&rsquo; or
&rsquo;oflag=dio&rsquo;.</p>

<p style="margin-top: 1em">ibs=BS if given must be the same
as BS given to &rsquo;bs=&rsquo; option.</p>

<p style="margin-top: 1em">if=IFILE <br>
read from IFILE instead of stdin. If IFILE is
&rsquo;-&rsquo; then stdin is read. Starts reading at the
beginning of IFILE unless SKIP is given.</p>

<p style="margin-top: 1em">iflag=FLAGS <br>
where FLAGS is a comma separated list of one or more flags
outlined below. These flags are associated with IFILE and
are ignored when IFILE is stdin.</p>

<p style="margin-top: 1em">obs=BS if given must be the same
as BS given to &rsquo;bs=&rsquo; option.</p>

<p style="margin-top: 1em">of=OFILE <br>
write to OFILE instead of stdout. If OFILE is
&rsquo;-&rsquo; then writes to stdout. If OFILE is /dev/null
then no actual writes are performed. If OFILE is
&rsquo;.&rsquo; (period) then it is <br>
treated the same way as /dev/null (this is a shorthand
notation). If OFILE exists then it is _not_ truncated; it is
overwritten from the start of OFILE unless <br>
&rsquo;oflag=append&rsquo; or SEEK is given.</p>

<p style="margin-top: 1em">oflag=FLAGS <br>
where FLAGS is a comma separated list of one or more flags
outlined below. These flags are associated with OFILE and
are ignored when OFILE is /dev/null, &rsquo;.&rsquo;
(period), or <br>
stdout.</p>

<p style="margin-top: 1em">seek=SEEK <br>
start writing SEEK bs-sized blocks from the start of OFILE.
Default is block 0 (i.e. start of file).</p>

<p style="margin-top: 1em">skip=SKIP <br>
start reading SKIP bs-sized blocks from the start of IFILE.
Default is block 0 (i.e. start of file).</p>

<p style="margin-top: 1em">sync=0 | 1 <br>
when 1, does SYNCHRONIZE CACHE command on OFILE at the end
of the transfer. Only active when OFILE is a sg device file
name.</p>

<p style="margin-top: 1em">thr=THR <br>
where THR is the number or worker threads (default 4) that
attempt to copy in parallel. Minimum is 1 and maximum is
16.</p>

<p style="margin-top: 1em">time=0 | 1 <br>
when 1, the transfer is timed and throughput calculation is
performed, outputting the results (to stderr) at completion.
When 0 (default) no timing is performed.</p>

<p style="margin-top: 1em">verbose=VERB <br>
increase verbosity. Same as deb=VERB. Added for
compatibility with sg_dd and sgm_dd.</p>

<p style="margin-top: 1em">--help outputs usage message and
exits.</p>

<p style="margin-top: 1em">--version <br>
outputs version number information and exits.</p>

<p style="margin-top: 1em">FLAGS <br>
Here is a list of flags and their meanings:</p>

<p style="margin-top: 1em">append causes the O_APPEND flag
to be added to the open of OFILE. For normal files this will
lead to data appended to the end of any existing data.
Cannot be used together with <br>
the seek=SEEK option as they conflict. The default action of
this utility is to overwrite any existing data from the
beginning of the file or, if SEEK is given, starting <br>
at block SEEK. Note that attempting to &rsquo;append&rsquo;
to a device file (e.g. a disk) will usually be ignored or
may cause an error to be reported.</p>

<p style="margin-top: 1em">coe continue on error. When
given with &rsquo;iflag=&rsquo;, an error that is detected
in a single SCSI command (typically &rsquo;bpt&rsquo;
blocks) is noted (by an error message sent to stderr), <br>
then zeros are substituted into the buffer for the
corresponding write operation and the copy continues. Note
that the sg_dd utility is more sophisticated in such error
<br>
situations when &rsquo;iflag=coe&rsquo;. When given with
&rsquo;oflag=&rsquo;, any error reported by a SCSI WRITE
command is reported to stderr and the copy continues (as if
nothing went wrong).</p>

<p style="margin-top: 1em">dio request the sg device node
associated with this flag does direct IO. If direct IO is
not available, falls back to indirect IO and notes this at
completion. If direct IO <br>
is selected and /proc/scsi/sg/allow_dio has the value of 0
then a warning is issued (and indirect IO is performed).</p>

<p style="margin-top: 1em">direct causes the O_DIRECT flag
to be added to the open of IFILE and/or OFILE. This flag
requires some memory alignment on IO. Hence user memory
buffers are aligned to the page <br>
size. Has no effect on sg, normal or raw files.</p>

<p style="margin-top: 1em">dpo set the DPO bit (disable
page out) in SCSI READ and WRITE commands. Not supported for
6 byte cdb variants of READ and WRITE. Indicates that data
is unlikely to be required <br>
to stay in device (e.g. disk) cache. May speed media copy
and/or cause a media copy to have less impact on other
device users.</p>

<p style="margin-top: 1em">dsync causes the O_SYNC flag to
be added to the open of IFILE and/or OFILE. The
&rsquo;d&rsquo; is prepended to lower confusion with the
&rsquo;sync=0|1&rsquo; option which has another action (i.e.
a <br>
synchronisation to media at the end of the transfer).</p>

<p style="margin-top: 1em">excl causes the O_EXCL flag to
be added to the open of IFILE and/or OFILE.</p>

<p style="margin-top: 1em">fua causes the FUA (force unit
access) bit to be set in SCSI READ and/or WRITE commands.
This only has effect with sg devices. The 6 byte variants of
the SCSI READ and WRITE <br>
commands do not support the FUA bit. Only active for sg
device file names.</p>

<p style="margin-top: 1em">null has no affect, just a
placeholder.</p>

<p style="margin-top: 1em">RETIRED OPTIONS <br>
Here are some retired options that are still present:</p>

<p style="margin-top: 1em">coe=0 | 1 <br>
continue on error is 0 (off) by default. When it is 1, it is
equivalent to &rsquo;iflag=coe oflag=coe&rsquo; described in
the FLAGS section above. Similar to
&rsquo;conv=noerror,sync&rsquo; in <br>
dd(1) utility. Default is 0 which implies stop on error.
More advanced coe=1 processing on reads is performed by the
sg_dd utility.</p>

<p style="margin-top: 1em">fua=0 | 1 | 2 | 3 <br>
force unit access bit. When 3, fua is set on both IFILE and
OFILE; when 2, fua is set on IFILE;, when 1, fua is set on
OFILE; when 0 (default), fua is cleared on both. See <br>
the &rsquo;fua&rsquo; flag.</p>

<p style="margin-top: 1em">NOTES <br>
A raw device must be bound to a block device prior to using
sgp_dd. See raw(8) for more information about binding raw
devices. To be safe, the sg device mapping to SCSI block
<br>
devices should be checked with &rsquo;cat
/proc/scsi/scsi&rsquo; before use.</p>

<p style="margin-top: 1em">Raw device partition information
can often be found with fdisk(8) [the &quot;-ul&quot;
argument is useful in this respect].</p>

<p style="margin-top: 1em">Various numeric arguments (e.g.
SKIP) may include multiplicative suffixes or be given in
hexadecimal. See the &quot;NUMERIC ARGUMENTS&quot; section
in the sg3_utils(8) man page.</p>

<p style="margin-top: 1em">The COUNT, SKIP and SEEK
arguments can take 64 bit values (i.e. very big numbers).
Other values are limited to what can fit in a signed 32 bit
number.</p>

<p style="margin-top: 1em">Data usually gets to the user
space in a 2 stage process: first the SCSI adapter DMAs into
kernel buffers and then the sg driver copies this data into
user memory (write opera&acirc; <br>
tions reverse this sequence). This is called &quot;indirect
IO&quot; and there is a &rsquo;dio&rsquo; option to select
&quot;direct IO&quot; which will DMA directly into user
memory. Due to some issues &quot;direct <br>
IO&quot; is disabled in the sg driver and needs a
configuration change to activate it.</p>

<p style="margin-top: 1em">All informative, warning and
error output is sent to stderr so that dd&rsquo;s output
file can be stdout and remain unpolluted. If no options are
given, then the usage message is out&acirc; <br>
put and nothing else happens.</p>

<p style="margin-top: 1em">Why use sgp_dd? Because in some
cases it is twice as fast as dd (mainly with sg devices, raw
devices give some improvement). Another reason is that big
copies fill the block <br>
device caches which has a negative impact on other machine
activity.</p>

<p style="margin-top: 1em">SIGNALS <br>
The signal handling has been borrowed from dd: SIGINT,
SIGQUIT and SIGPIPE output the number of remaining blocks to
be transferred and the records in + out counts; then they
have <br>
their default action. SIGUSR1 causes the same information to
be output yet the copy continues. All output caused by
signals is sent to stderr.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Looks quite similar in usage to dd:</p>

<p style="margin-top: 1em">sgp_dd if=/dev/sg0 of=t bs=512
count=1MB</p>

<p style="margin-top: 1em">This will copy 1 million 512
byte blocks from the device associated with /dev/sg0 (which
should have 512 byte blocks) to a file called t. Assuming
/dev/sda and /dev/sg0 are the <br>
same device then the above is equivalent to:</p>

<p style="margin-top: 1em">dd if=/dev/sda of=t bs=512
count=1000000</p>

<p style="margin-top: 1em">although dd&rsquo;s speed may
improve if bs was larger and count was correspondingly
scaled. Using a raw device to do something similar on a ATA
disk:</p>

<p style="margin-top: 1em">raw /dev/raw/raw1 /dev/hda <br>
sgp_dd if=/dev/raw/raw1 of=t bs=512 count=1MB</p>

<p style="margin-top: 1em">To copy a SCSI disk partition to
an ATA disk partition:</p>

<p style="margin-top: 1em">raw /dev/raw/raw2 /dev/hda3 <br>
sgp_dd if=/dev/sg0 skip=10123456 of=/dev/raw/raw2 bs=512</p>

<p style="margin-top: 1em">This assumes a valid partition
is found on the SCSI disk at the given skip block address
(past the 5 GB point of that disk) and that the partition
goes to the end of the SCSI <br>
disk. An explicit count is probably a safer option.</p>

<p style="margin-top: 1em">To do a fast copy from one SCSI
disk to another one with similar geometry (stepping over
errors on the source disk):</p>

<p style="margin-top: 1em">sgp_dd if=/dev/sg0 of=/dev/sg1
bs=512 coe=1</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The exit status of sgp_dd is 0 when it is successful.
Otherwise see the sg3_utils(8) man page. Since this utility
works at a higher level than individual commands, and there
are <br>
&rsquo;coe&rsquo; and &rsquo;retries&rsquo; flags,
individual SCSI command failures do not necessary cause the
process to exit.</p>

<p style="margin-top: 1em">AUTHORS <br>
Written by Douglas Gilbert and Peter Allworth.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to &lt;dgilbert at interlog dot com&gt;.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 2000-2012 Douglas Gilbert <br>
This software is distributed under the GPL version 2. There
is NO warranty; not even for MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.</p>

<p style="margin-top: 1em">SEE ALSO <br>
A simpler, non-threaded version of this utility but with
more advanced &quot;continue on error&quot; logic is called
sg_dd and is also found in the sg3_utils package. The
lmbench package <br>
contains lmdd which is also interesting. raw(8), dd(1)</p>

<p style="margin-top: 1em">sg3_utils-1.35 November 2012
SGP_DD(8)</p>
<hr>
</body>
</html>
