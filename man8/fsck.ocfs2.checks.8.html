<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:11:17 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>fsck.ocfs2.checks(8) OCFS2 Manual Pages
fsck.ocfs2.checks(8)</p>

<p style="margin-top: 1em">NAME <br>
fsck.ocfs2.checks - Consistency checks that fsck.ocfs2(8)
performs and its means for fixing inconsistencies.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
fsck.ocfs2(8) is used to check an OCFS2 file system. It
performs many consistency checks and will offer to fix
faults that it finds. This man page lists the problems it
may <br>
find and describes their fixes. The problems are indexed by
the error number that fsck.ocfs2(8) emits when it describes
the problem and asks if it should be fixed.</p>

<p style="margin-top: 1em">The prompts are constructed such
that answering &rsquo;no&rsquo; results in no changes to the
file system. This may result in errors later on that stop
fsck.ocfs2(8) from proceeding.</p>

<p style="margin-top: 1em">CHECKS <br>
EB_BLKNO <br>
Extent blocks contain a record of the disk block where they
are located. An extent block was found at a block that
didn&rsquo;t match its recorded location.</p>

<p style="margin-top: 1em">Answering yes will update the
data structure in the extent block to reflect its real
location on disk.</p>

<p style="margin-top: 1em">EB_GEN <br>
Extent blocks are created with a generation number to match
the generation number of the volume at the time of creation.
An extent block was found which contains a generation <br>
number that doesn&rsquo;t match.</p>

<p style="margin-top: 1em">Answering yes implies that the
generation number is correct and that the extent block is
from a previous file system. The extent block will be
ignored and the file that contains <br>
it will lose the data it referenced.</p>

<p style="margin-top: 1em">EB_GEN_FIX <br>
Extent blocks are created with a generation number to match
the generation number of the volume at the time of creation.
An extent block was found which contains a generation <br>
number that doesn&rsquo;t match.</p>

<p style="margin-top: 1em">Answering yes implies that the
generation number in the extent block is incorrect and that
the extent block is valid. The generation number in the
block is updated to match the <br>
generation number in the volume.</p>

<p style="margin-top: 1em">EXTENT_MARKED_UNWRITTEN <br>
An extent record has the UNWRITTEN flag set, but the
filesystem feature set does not include unwritten
extents.</p>

<p style="margin-top: 1em">Answering yes clears the
UNWRITTEN flag. This is safe to do; as the feature is
disabled anyway.</p>

<p style="margin-top: 1em">EXTENT_MARKED_REFCOUNTED <br>
An extent record has the REFCOUNTED flag set, but neither
the filesystem nor the file has the REFCOUNTED flag set.</p>

<p style="margin-top: 1em">Answering yes clears the
REFCOUNTED flag.</p>

<p style="margin-top: 1em">EXTENT_BLKNO_UNALIGNED <br>
The block that marks the start of an extent should always
fall on the start of a cluster. An extent was found that
starts part-way into a cluster.</p>

<p style="margin-top: 1em">Answering yes moves the start of
the extent back to the start of the addressed cluster. This
may add data to the middle of the file that contains this
extent.</p>

<p style="margin-top: 1em">EXTENT_CLUSTERS_OVERRUN <br>
An extent was found which claims to contain clusters which
are beyond the end of the volume.</p>

<p style="margin-top: 1em">Answering yes clamps the extent
to the end of the volume. This may result in a reduced file
size for the file that contains the extent, but it
couldn&rsquo;t have addressed those <br>
final clusters anyway. One can imagine this problem arising
if there are problems shrinking a volume.</p>

<p style="margin-top: 1em">EXTENT_EB_INVALID <br>
Deep extent trees are built by forming a tree out of extent
blocks. An extent tree references an invalid extent
block.</p>

<p style="margin-top: 1em">Answering yes stops the tree
from referencing the invalid extent block. This may truncate
data from the file which contains the tree.</p>

<p style="margin-top: 1em">EXTENT_LIST_DEPTH <br>
Extent lists contain a record of their depth in the tree. An
extent list was found whose recorded depth doesn&rsquo;t
match the position they have in the tree.</p>

<p style="margin-top: 1em">Answering yes updates the depth
field in the list to match the tree on disk.</p>

<p style="margin-top: 1em">EXTENT_LIST_COUNT <br>
The number of entries in an extent list is bounded by either
the size of the inode or the size of the block which
contains it. An extent list was found which claims to have
more <br>
entries than would fit in its container.</p>

<p style="margin-top: 1em">Answering yes updates the count
field in the extent list to match the container. Answering
no to this question may stop further fixes from being done
because the count value can <br>
not be trusted.</p>

<p style="margin-top: 1em">EXTENT_LIST_FREE <br>
The number of free entries in an extent list must be less
than the total number of entries in the list. A list was
found which claims to have more free entries than possible
<br>
entries.</p>

<p style="margin-top: 1em">Answering yes sets the number of
free entries in the list equal to the total possible
entries.</p>

<p style="margin-top: 1em">EXTENT_BLKNO_RANGE <br>
An extent record was found which references a block which
can not be referenced by an extent. The referenced block is
either very early in the volume, and thus reserved, or <br>
beyond the end of the volume.</p>

<p style="margin-top: 1em">Answering yes removes this
extent record from the tree. This may remove data from the
file which owns the tree but any such data was
inaccessible.</p>

<p style="margin-top: 1em">CHAIN_CPG <br>
The bitmap inode indicates a different clusters per group
than the group descriptor. This value is typically static
and only modified by tunefs during volume resize and that
too <br>
only on volumes having only one cluster group.</p>

<p style="margin-top: 1em">Answering yes updates the
clusters per group on the bitmap inode to the corresponding
value in the group descriptor.</p>

<p style="margin-top: 1em">SUPERBLOCK_CLUSTERS <br>
The super block indicates a different total clusters value
than the global bitmap. This is only possible due to a
failed volume resize operation.</p>

<p style="margin-top: 1em">Answering yes updates the total
clusters in the super block to the value specified in the
global bitmap.</p>

<p style="margin-top: 1em">FIXED_CHAIN_CLUSTERS <br>
The global bitmap inode was repaired, resulting in a change
to the total cluster count of the filesystem.</p>

<p style="margin-top: 1em">Answering yes updates the total
clusters in the super block to the value specified in the
global bitmap.</p>

<p style="margin-top: 1em">GROUP_UNEXPECTED_DESC <br>
The group descriptors that make up the global bitmap chain
allocator reside at predictable locations on disk. A group
descriptor was found in the global bitmap allocator which
<br>
isn&rsquo;t at one of these locations and so shouldn&rsquo;t
be in the allocator.</p>

<p style="margin-top: 1em">Answering yes removes this
descriptor from the global bitmap allocator.</p>

<p style="margin-top: 1em">GROUP_EXPECTED_DESC <br>
The group descriptors that make up the global bitmap chain
allocator reside at predictable locations on disk. A group
descriptor at one of these locations was not linked into
<br>
the global bitmap allocator.</p>

<p style="margin-top: 1em">Answering yes will relink this
group into the allocator.</p>

<p style="margin-top: 1em">GROUP_GEN <br>
A group descriptor was found with a generation number that
doesn&rsquo;t match the generation number of the volume.</p>

<p style="margin-top: 1em">Answering yes sets the group
descriptor&rsquo;s generation equal to the generation number
in the volume.</p>

<p style="margin-top: 1em">GROUP_PARENT <br>
Group descriptors contain a pointer to the allocator inode
which contains the chain they belong to. A group descriptor
was found in an allocator inode that doesn&rsquo;t match the
<br>
descriptor&rsquo;s parent pointer.</p>

<p style="margin-top: 1em">Answering yes updates the group
descriptor&rsquo;s parent pointer to match the inode it
resides in.</p>

<p style="margin-top: 1em">GROUP_DUPLICATE <br>
Group descriptors contain a pointer to the allocator inode
which contains the chain they belong to. A group descriptor
was found in two allocator inodes so it may be
duplicated.</p>

<p style="margin-top: 1em">Answering yes removes the group
descriptor from current allocator inode.</p>

<p style="margin-top: 1em">GROUP_BLKNO <br>
Group descriptors have a field which records their block
location on disk. A group descriptor was found at a given
location but is recorded as being located somewhere
else.</p>

<p style="margin-top: 1em">Answering yes updates the group
descriptor&rsquo;s recorded location to match where it
actually is found on disk.</p>

<p style="margin-top: 1em">GROUP_CHAIN <br>
Group descriptors are found in a number of different
singly-linked chains in an allocator inode. A group
descriptor records the chain number that it is linked in. A
group <br>
descriptor was found whose chain field doesn&rsquo;t match
the chain it was found in.</p>

<p style="margin-top: 1em">Answering yes sets the group
descriptor&rsquo;s chain field to match the chain it is
found in.</p>

<p style="margin-top: 1em">GROUP_FREE_BITS <br>
A group descriptor records the number of bits in its bitmap
that are free. A group descriptor was found which claims to
have more free bits than are valid in its bitmap.</p>

<p style="margin-top: 1em">Answering yes decreases the
number of recorded free bits so that it equals the total
number of bits in the group descriptor&rsquo;s bitmap.</p>

<p style="margin-top: 1em">GROUP_CHAIN_LOOP <br>
A chain may loop if the next field of the group descriptor
points to one of the previous group descriptors in the
chain. This causes the ocfs2 code, both user space and
kernel <br>
module to loop forever.</p>

<p style="margin-top: 1em">Answering yes breaks the loop at
an optimum location so that all the existing group
descriptors are in the chain. However, it cannot re-connect
stray group descriptors and must <br>
rely on the rest of the fsck code to fix it.</p>

<p style="margin-top: 1em">CHAIN_COUNT <br>
The chain list embedded in an inode is limited by the block
size and the number of bytes consumed by the rest of the
inode. A chain list header was found which claimed that <br>
there are more entries in the list then could fit in the
inode.</p>

<p style="margin-top: 1em">Answering yes resets the
header&rsquo;s cl_count member to the maximum size allowed
by the block size after accounting for the space consumed by
the inode.</p>

<p style="margin-top: 1em">CHAIN_NEXT_FREE <br>
This is identical to CHAIN_COUNT except that it is testing
and fixing the pointer to the next free list entry recorded
in the cl_next_free_rec member instead of the total number
<br>
of entries.</p>

<p style="margin-top: 1em">CHAIN_EMPTY <br>
Chain entries need to be packed such that there are no
chains without descriptors found before the chain that is
marked as free by the chain header. A chain without
descriptors <br>
was found found before that chain that was marked free.</p>

<p style="margin-top: 1em">Answering yes will remove the
unused chain and shift the remaining chains forward in the
list.</p>

<p style="margin-top: 1em">CHAIN_I_CLUSTERS <br>
Chain allocator inodes have an i_clusters value that
represents the number of clusters used by the allocator. An
inode was found whose i_clusters value doesn&rsquo;t match
the number <br>
of clusters its chains cover.</p>

<p style="margin-top: 1em">Answering yes updates i_clusters
in the inode to reflect what was actually found by walking
the chain.</p>

<p style="margin-top: 1em">CHAIN_I_SIZE <br>
Chain allocator inodes multiply the number of bytes per
cluster by the their i_clusters value and store it in
i_size. An inode was found which didn&rsquo;t have the
correct value in <br>
its i_size.</p>

<p style="margin-top: 1em">Answering yes updates i_size to
be the product of i_clusters and the cluster size. Nothing
else uses this value, and previous versions of tools
didn&rsquo;t calculate it properly, so <br>
don&rsquo;t be too worried if this error appears.</p>

<p style="margin-top: 1em">CHAIN_GROUP_BITS <br>
The inode that contains an embedded chain list has fields
which record the total number of bits covered by the chain
as well as the amount free. These fields didn&rsquo;t match
what <br>
was found in the chain.</p>

<p style="margin-top: 1em">Answering yes updates the fields
in the inode to reflect what was actually found by walking
the chain.</p>

<p style="margin-top: 1em">CHAIN_HEAD_LINK_RANGE <br>
The header that starts a chain tried to reference a group
descriptor at a block number that couldn&rsquo;t be
valid.</p>

<p style="margin-top: 1em">Answering yes will clear the
reference to this invalid block and truncate the chain that
it started.</p>

<p style="margin-top: 1em">CHAIN_LINK_GEN <br>
A reference was made to a group descriptor whose generation
number doesn&rsquo;t match the generation of the volume.</p>

<p style="margin-top: 1em">Answering yes to this question
implies that the group descriptor is invalid and the chain
is truncated at the point that it referred to this invalid
group descriptor. Answering <br>
no to this question considers the group descriptor as valid
and its generation may be fixed.</p>

<p style="margin-top: 1em">CHAIN_LINK_MAGIC <br>
Chains are built by chain headers and group descriptors
which are linked together by block references. A reference
was made to a group descriptor at a given block but a valid
<br>
group descriptor signature wasn&rsquo;t found at that
block.</p>

<p style="margin-top: 1em">Answering yes clears the
reference to this invalid block and truncates the chain at
the point of the reference.</p>

<p style="margin-top: 1em">CHAIN_LINK_RANGE <br>
Chains are built by chain headers and group descriptors
which are linked together by block references. A reference a
block was found which can&rsquo;t possibly be valid because
it was <br>
either too small or extended beyond the volume.</p>

<p style="margin-top: 1em">Answering yes truncates the
chain in question by zeroing the invalid block reference.
This shortens the chain in question and could result in more
fixes later if the part of the <br>
chain that couldn&rsquo;t be referenced was valid at some
point.</p>

<p style="margin-top: 1em">CHAIN_BITS <br>
A chain&rsquo;s header contains members which record the
total number of bits in the chain as well as the number of
bits that are free. After walking through a chain it was
found that <br>
the number of bits recorded in its header don&rsquo;t match
what was found by totalling up the group descriptors.</p>

<p style="margin-top: 1em">Answering yes updates the
c_total and c_free members of the header to reflect what was
found in the group descriptors in the chain.</p>

<p style="margin-top: 1em">DISCONTIG_BG_DEPTH <br>
A discontiguous block group has an extent list which records
all the clusters allocated to it. Discontiguous block groups
only support extent lists with a tree depth of 0. A <br>
block group claims to have a tree depth greater than 0.</p>

<p style="margin-top: 1em">Answering yes will set the tree
depth of the extent list to 0.</p>

<p style="margin-top: 1em">DISCONTIG_BG_COUNT <br>
A discontiguous block group has an extent list which records
all the clusters allocated to it. A block group claims to
have more records than can actually fit.</p>

<p style="margin-top: 1em">Answering yes will set the
record count to the maximum possible.</p>

<p style="margin-top: 1em">DISCONTIG_BG_REC_RANGE <br>
Block groups set aside clusters to be used for metadata. A
discontiguous block group claims to contain clusters beyond
the end of the volume.</p>

<p style="margin-top: 1em">Answering yes will remove the
block group.</p>

<p style="margin-top: 1em">DISCONTIG_BG_CORRUPT_LEAVES <br>
A discontiguous block group has an extent list which records
all the clusters allocated to it. A group has more than one
extent claiming to have an impossible number of clus&acirc;
<br>
ters.</p>

<p style="margin-top: 1em">Answering yes will remove the
block group.</p>

<p style="margin-top: 1em">DISCONTIG_BG_CLUSTERS <br>
Extent records in a discontiguous block group were found
having more clusters allocated then a block group can
have.</p>

<p style="margin-top: 1em">Answering yes will remove the
block group.</p>

<p style="margin-top: 1em">DISCONTIG_BG_LESS_CLUSTERS <br>
Extent records in a discontiguous block group were found
having less clusters allocated then a block group can
have.</p>

<p style="margin-top: 1em">Answering yes will remove the
block group.</p>

<p style="margin-top: 1em">DISCONTIG_BG_NEXT_FREE_REC <br>
A discontiguous block group has an extent list which records
all the clusters allocated to it. A group was found with
fewer filled in extents than it claims to have. The filled
<br>
in extents describe a complete and correct group.</p>

<p style="margin-top: 1em">Answering yes will set the used
extent count to the number of filled extents.</p>

<p style="margin-top: 1em">DISCONTIG_BG_LIST_CORRUPT <br>
A discontiguous block group has an extent list which records
all the clusters allocated to it. The group claims to have
more extents than is possible, and the existing extents <br>
contain errors.</p>

<p style="margin-top: 1em">Answering yes will remove the
block group.</p>

<p style="margin-top: 1em">DISCONTIG_BG_REC_CORRUPT <br>
A discontiguous block group has a extent list which records
all the clusters allocated to it. A group was found with one
extent claiming too many clusters but the sum of the <br>
remaining extents are equal to the total clusters a group
must have.</p>

<p style="margin-top: 1em">Answering yes will remove the
block group.</p>

<p style="margin-top: 1em">DISCONTIG_BG_LEAF_CLUSTERS <br>
A discontiguous block group has a extent list which records
all the clusters allocated to it. A group was found with one
extent claiming too many clusters, but the remaining <br>
extents are correct.</p>

<p style="margin-top: 1em">Answering yes will set the
number of the clusters on the broken extent to the
difference between the total clusters a group must have and
the sum of the remaining extents.</p>

<p style="margin-top: 1em">INODE_ALLOC_REPAIR <br>
The inode allocator did not accurately reflect the set of
inodes that are free and in use in the volume.</p>

<p style="margin-top: 1em">Answering yes will update the
inode allocator bitmaps. Each bit that doesn&rsquo;t match
the state of its inode will be inverted.</p>

<p style="margin-top: 1em">INODE_SUBALLOC <br>
Each inode records the node whose allocator is responsible
for the inode. An inode was found in a given node&rsquo;s
allocator but the inode itself claimed to belong to a
different <br>
node.</p>

<p style="margin-top: 1em">Answering yes will correct the
inode to point to the node&rsquo;s allocator that it belongs
to.</p>

<p style="margin-top: 1em">LALLOC_SIZE <br>
Each node has a local allocator contained in a block that is
used to allocate clusters in batches. A node&rsquo;s local
allocator claims to reflect more bytes than are possible for
<br>
the volume&rsquo;s block size.</p>

<p style="margin-top: 1em">Answering yes decreases the
local allocator&rsquo;s size to reflect the volume&rsquo;s
block size.</p>

<p style="margin-top: 1em">LALLOC_NZ_USED <br>
A given node&rsquo;s local allocator isn&rsquo;t in use but
it claims to have bits in use in its bitmap.</p>

<p style="margin-top: 1em">Answering yes zeros this used
field.</p>

<p style="margin-top: 1em">LALLOC_NZ_BM <br>
A given node&rsquo;s local allocator isn&rsquo;t in use but
it has a field which records the bitmap as starting at a
non-zero cluster offset.</p>

<p style="margin-top: 1em">Answering yes zeros the bm_off
field.</p>

<p style="margin-top: 1em">LALLOC_BM_OVERRUN <br>
Each local allocator contains a reference to the first
cluster that its bitmap addresses. A given local allocator
was found which references a starting cluster that is beyond
<br>
the end of the volume.</p>

<p style="margin-top: 1em">Answering yes resets the given
local allocator. No allocated data will be lost.</p>

<p style="margin-top: 1em">LALLOC_BM_SIZE <br>
The given local allocator claims to cover more bits than are
possible for the size in bytes of its bitmap.</p>

<p style="margin-top: 1em">Answering yes decreases the
number of bits the allocator covers to reflect the size in
bytes of the bitmap and resets the allocator. No allocated
data will be lost.</p>

<p style="margin-top: 1em">LALLOC_BM_STRADDLE <br>
The given local allocator claims to cover a region of
clusters which extents beyond the end of the volume.</p>

<p style="margin-top: 1em">Answering yes resets the given
local allocator. No allocated data will be lost.</p>

<p style="margin-top: 1em">LALLOC_USED_OVERRUN <br>
The given local allocator claims to have more bits in use
than it has total bits in its bitmap.</p>

<p style="margin-top: 1em">Answering yes decreases the
number of bits used so that it equals the total number of
available bits.</p>

<p style="margin-top: 1em">LALLOC_CLEAR <br>
A local allocator inode was found to have problems. This
gives the operator a chance to just reset the local
allocator inode.</p>

<p style="margin-top: 1em">Answering yes clears the local
allocator. No information is lost but the global bitmap
allocator may need to be updated to reflect clusters that
were reserved for the local <br>
allocator but were free.</p>

<p style="margin-top: 1em">DEALLOC_COUNT <br>
The given truncate log inode contains a count that is
greater than the value that is possible given the size of
the inode.</p>

<p style="margin-top: 1em">Answering yes resets the count
value to the possible maximum.</p>

<p style="margin-top: 1em">DEALLOC_USED <br>
The given truncate log inode claims to have more records in
use than it is possible to store in the inode.</p>

<p style="margin-top: 1em">Answering yes resets the record
of the number used to the maximum value possible.</p>

<p style="margin-top: 1em">TRUNCATE_REC_START_RANGE <br>
A truncate record was found which claims to start at a
cluster that is beyond the number of clusters in the
volume.</p>

<p style="margin-top: 1em">Answering yes will clear the
truncate record. This may result in previously freed space
being marked as allocated. This will be fixed up later as
the allocator is updated to <br>
match what is used by the file system.</p>

<p style="margin-top: 1em">TRUNCATE_REC_WRAP <br>
Clusters are recorded as 32bit values. A truncate record was
found which claims to have enough clusters to cause this
value to wrap. This could never be the case and is a sure
<br>
sign of corruption.</p>

<p style="margin-top: 1em">Answering yes will clear the
truncate record. This may result in previously freed space
being marked as allocated. This will be fixed up later as
the allocator is updated to <br>
match what is used by the file system.</p>

<p style="margin-top: 1em">TRUNCATE_REC_RANGE <br>
A truncate record was found which claims to reference a
region of clusters which partially extends beyond the number
of clusters in the volume.</p>

<p style="margin-top: 1em">Answering yes will clear the
truncate record. This may result in previously freed space
being marked as allocated. This will be fixed up later as
the allocator is updated to <br>
match what is used by the file system.</p>

<p style="margin-top: 1em">INODE_GEN <br>
Inodes are created with a generation number to match the
generation number of the volume at the time of creation. An
Inode was found which contains a generation number that <br>
doesn&rsquo;t match.</p>

<p style="margin-top: 1em">Answering yes implies that the
generation number is correct and that the inode is from a
previous file system. The inode will be recorded as
free.</p>

<p style="margin-top: 1em">INODE_GEN_FIX <br>
Inodes are created with a generation number to match the
generation number of the volume at the time of creation. An
inode was found which contains a generation number that <br>
doesn&rsquo;t match.</p>

<p style="margin-top: 1em">Answering yes implies that the
generation number in the inode is incorrect and that the
inode is valid. The generation number in the inode is
updated to match the generation <br>
number in the volume.</p>

<p style="margin-top: 1em">INODE_BLKNO <br>
Inodes contain a field that must match the block that they
reside in. An inode was found at a block that doesn&rsquo;t
match the field in the inode.</p>

<p style="margin-top: 1em">Answering yes updates the field
to match the inode&rsquo;s position on disk.</p>

<p style="margin-top: 1em">ROOT_NOTDIR <br>
The super block contains a reference to the inode that
contains the root directory. This block was found to contain
an inode that isn&rsquo;t a directory.</p>

<p style="margin-top: 1em">Answering yes clears this inode.
The operator will be asked to recreate the root directory at
a point in the near future.</p>

<p style="margin-top: 1em">INODE_NZ_DTIME <br>
Inodes contain a field describing the time at which they
were deleted. This can not be set for an inode that is still
in use. An inode was found which is in use but which
con&acirc; <br>
tains a non-zero dtime.</p>

<p style="margin-top: 1em">Answering yes implies that the
inode is still valid and resets its dtime to zero.</p>

<p style="margin-top: 1em">LINK_FAST_DATA <br>
The target name for a symbolic link is stored either as file
contents for that inode or in the inode structure itself on
disk. Only small destination names are stored in the <br>
inode structure. The i_blocks field of the inode indicates
that the name is stored in the inode when it is zero. An
inode was found that has both i_blocks set to zero and file
<br>
contents.</p>

<p style="margin-top: 1em">Answering yes clears the inode
and so deletes the link.</p>

<p style="margin-top: 1em">LINK_NULLTERM <br>
The targets of links on disk must be null terminated. A link
was found whose target wasn&rsquo;t null terminated.</p>

<p style="margin-top: 1em">Answering yes clears the inode
and so deletes the link.</p>

<p style="margin-top: 1em">LINK_SIZE <br>
The size of a link on disk must match the length of its
target string. A link was found whose size does not.</p>

<p style="margin-top: 1em">Answering yes updates the
link&rsquo;s size to reflect the length of its target
string.</p>

<p style="margin-top: 1em">LINK_BLOCKS <br>
Links can not be sparse. There must be exactly as many
blocks allocated as are needed to cover its size. A link was
found which doesn&rsquo;t have enough blocks allocated to
cover <br>
its size.</p>

<p style="margin-top: 1em">Answering yes clears the
link&rsquo;s inode thus deleting the link.</p>

<p style="margin-top: 1em">DIR_ZERO <br>
Directories must at least contain a block that has the
&quot;.&quot; and &quot;..&quot; entries. A directory was
found which doesn&rsquo;t contain any blocks.</p>

<p style="margin-top: 1em">Answering yes to this question
clears the directory&rsquo;s inode thus deleting the
directory.</p>

<p style="margin-top: 1em">INODE_SIZE <br>
Certain inodes record the size of the data they reference in
an i_size field. This can be the number of bytes in a file,
directory, or symlink target which are stored in data <br>
mapped by extents of clusters. This error occurs when the
extent lists are walked and the amount of data found does
not match what is stored in i_size.</p>

<p style="margin-top: 1em">Answering yes to this question
updates the inode&rsquo;s i_size to match the amount of data
referenced by the extent lists. It is vitally important that
i_size matches the extent <br>
lists and so answering yes is strongly encouraged.</p>

<p style="margin-top: 1em">INODE_SPARSE_SIZE <br>
Certain inodes record the size of the data they reference in
an i_size field. This can be the number of bytes in a file,
directory, or symlink target which are stored in data <br>
mapped by extents of clusters. This error occurs when a
sparse inode was found that had data allocated past its
i_size.</p>

<p style="margin-top: 1em">Answering yes to this question
will update the inode&rsquo;s i_size to cover all of its
allocated storage. It is vitally important that i_size
matches the extent lists and so answer&acirc; <br>
ing yes is strongly encouraged.</p>

<p style="margin-top: 1em">INODE_INLINE_SIZE <br>
Inodes can only fit a certain amount of inline data. This
inode has its data inline but claims an i_size larger than
will actually fit.</p>

<p style="margin-top: 1em">Answering yes to this question
updates the inode&rsquo;s i_size to the maximum available
inline space.</p>

<p style="margin-top: 1em">INODE_CLUSTERS <br>
Inodes contain a record of how many clusters are allocated
to them. An inode was found whose recorded number of
clusters doesn&rsquo;t match the number of blocks that were
found asso&acirc; <br>
ciated with the inode.</p>

<p style="margin-top: 1em">Answering yes resets the
inode&rsquo;s number of clusters to reflect the number of
blocks that were associated with the file.</p>

<p style="margin-top: 1em">INODE_SPARSE_CLUSTERS <br>
Inodes contain a record of how many clusters are allocated
to them. An sparse inode was found whose recorded number of
clusters doesn&rsquo;t match the number of blocks that were
<br>
found associated with the inode.</p>

<p style="margin-top: 1em">Answering yes resets the
inode&rsquo;s number of clusters to reflect the number of
blocks that were associated with the file.</p>

<p style="margin-top: 1em">INODE_INLINE_CLUSTERS <br>
Inlined inode should not have allocated clusters. An inode
who has inline data flag set was found with clusters
allocated.</p>

<p style="margin-top: 1em">Answering yes resets the
inode&rsquo;s number of clusters to zero.</p>

<p style="margin-top: 1em">LALLOC_REPAIR <br>
An active local allocator did not accurately reflect the set
of clusters that are free and in use in its region.</p>

<p style="margin-top: 1em">Answering yes will update the
local allocator bitmap. Each bit that doesn&rsquo;t match
the use of its cluster will be inverted.</p>

<p style="margin-top: 1em">LALLOC_USED <br>
A local allocator records the number of bits that are used
in its bitmap. An allocator was found whose used value
doesn&rsquo;t reflect the number of bits that are set in its
bitmap.</p>

<p style="margin-top: 1em">Answering yes sets the used
value to match the number of bits set in the
allocator&rsquo;s bitmap.</p>

<p style="margin-top: 1em">CLUSTER_ALLOC_BIT <br>
A specific cluster&rsquo;s use didn&rsquo;t match the
setting of its bit in the cluster allocator.</p>

<p style="margin-top: 1em">Answering yes will invert the
bit in the allocator to match the use of the cluster --
either allocated and in use or free.</p>

<p style="margin-top: 1em">REFCOUNT_FLAG_INVALID <br>
Refcount file can only exist in a volume with refcount
supported, Fsck has found that a file in a non-refcount
volume has refcount flag set.</p>

<p style="margin-top: 1em">Answering yes remove this flag
from the file.</p>

<p style="margin-top: 1em">REFCOUNT_LOC_INVALID <br>
Refcount loc can only be valid if the file has refcount flag
set. Fsck has found that a file has refcount loc while it
does&rsquo;t have refcount flag set.</p>

<p style="margin-top: 1em">Answering yes reset refcount loc
to zero for the file.</p>

<p style="margin-top: 1em">RB_BLKNO <br>
refcount blocks contain a record of the disk block where
they are located. An refcount block was found at a block
that didn&rsquo;t match its recorded location.</p>

<p style="margin-top: 1em">Answering yes will update the
data structure in the refcount block to reflect its real
location on disk.</p>

<p style="margin-top: 1em">RB_GEN <br>
Refcount blocks are created with a generation number to
match the generation number of the volume at the time of
creation. An refcount block was found which contains a
genera&acirc; <br>
tion number that doesn&rsquo;t match.</p>

<p style="margin-top: 1em">Answering yes implies that the
generation number is correct and that the refcount block is
from a previous file system. The refcount block will be
removed and the file that uses <br>
it will lose the refcounted information, but it may be
regenerated later.</p>

<p style="margin-top: 1em">RB_GEN_FIX <br>
Refcount blocks are created with a generation number to
match the generation number of the volume at the time of
creation. An refcount block was found which contains a
genera&acirc; <br>
tion number that doesn&rsquo;t match.</p>

<p style="margin-top: 1em">Answering yes implies that the
generation number in the refcount block is incorrect and
that the refcount block is valid. The generation number in
the block is updated to match <br>
the generation number in the volume.</p>

<p style="margin-top: 1em">RB_PARENT <br>
refcount blocks contain a record of the parent this disk
block belongs to. An refcount block was found storing a
wrong parent location.</p>

<p style="margin-top: 1em">Answering yes will update the
data structure in the refcount block to reflect its
parent&rsquo;s real location on disk.</p>

<p style="margin-top: 1em">REFCOUNT_LIST_COUNT <br>
The number of entries in a refcount list is bounded by the
size of the block which contains it. An refcount list was
found which claims to have more entries than would fit in
<br>
its container.</p>

<p style="margin-top: 1em">Answering yes updates the count
field in the refcount list to match the container. Answering
no to this question may stop further fixes from being done
because the count value <br>
can not be trusted.</p>

<p style="margin-top: 1em">REFCOUNT_LIST_USED <br>
The number of free entries in a refcount list must be less
than the total number of entries in the list. A list was
found which claims to have more free entries than possible
<br>
entries.</p>

<p style="margin-top: 1em">Answering yes sets the number of
free entries in the list equal to the total possible
entries.</p>

<p style="margin-top: 1em">REFCOUNT_CLUSTER_RANGE <br>
A refcount record was found which references a cluster which
can not be referenced by a refcount. The referenced cluster
is either very early in the volume, and thus reserved, <br>
or beyond the end of the volume.</p>

<p style="margin-top: 1em">Answering yes removes this
refcount record from the tree.</p>

<p style="margin-top: 1em">REFCOUNT_CLUSTER_COLLISION <br>
A refcount record was found which references a cluster which
has a collision with the previous valid refcount record.</p>

<p style="margin-top: 1em">Answering yes removes this
refcount record from the tree.</p>

<p style="margin-top: 1em">REFCOUNT_LIST_EMPTY <br>
A refcount list was found which has no refcount record in
it. It is normally caused by a corrupted refcount
record.</p>

<p style="margin-top: 1em">Answering yes removes this
refcount block from the tree. It will be re-generated in
refcounted extent records handler if all the other
information is sane.</p>

<p style="margin-top: 1em">REFCOUNT_BLOCK_INVALID <br>
Refcount block stores the refcount record for physical
clusters of a file. It is found refering an invalid refcount
block.</p>

<p style="margin-top: 1em">Answering yes remove this
refcount block.</p>

<p style="margin-top: 1em">REFCOUNT_CLUSTERS <br>
Refcount tree contains a record of how many clusters are
allocated to them. A tree was found whose recorded number of
clusters doesn&rsquo;t match the number of blocks that were
found <br>
associated with it.</p>

<p style="margin-top: 1em">Answering yes resets the number
of clusters to reflect the real number of clusters that were
associated with the tree.</p>

<p style="margin-top: 1em">REFCOUNT_ROOT_BLOCK_INVALID <br>
Root refcount block is the root of the refcount record for a
file. It is found refering an invalid refcount block.</p>

<p style="margin-top: 1em">Answering yes remove this
refcount block and clear refcount flag from this file.</p>

<p style="margin-top: 1em">REFCOUNT_REC_REDUNDANT <br>
Refcount record is used to store the refcount for physical
clusters. Some refcount record is found to have no physical
clusters corresponding to it.</p>

<p style="margin-top: 1em">Answering yes remove the
refcount record.</p>

<p style="margin-top: 1em">REFCOUNT_COUNT_INVALID <br>
Refcount record is used to store the refcount for physical
clusters. A record record is found whichs claims the wrong
refcount for some physical clusters.</p>

<p style="margin-top: 1em">Answering yes update the
corresponding refcount record.</p>

<p style="margin-top: 1em">REFCOUNT_COUNT <br>
Refcount tree contains a record of how many files refering
to this tree. A tree was found whose recorded number of
files doesn&rsquo;t match the real files refering to the
tree.</p>

<p style="margin-top: 1em">Answering yes resets the number
of files to reflect the real number of files that were
associated with the tree.</p>

<p style="margin-top: 1em">DUP_CLUSTERS_SYSFILE_CLONE <br>
A system file inode claims clusters that are also claimed by
another inode. ocfs2 does not allow this. System files may
be cloned but may not be deleted. Allocation system <br>
files may not be cloned or deleted.</p>

<p style="margin-top: 1em">Answering yes will copy the data
of this inode to newly allocated extents. This will break
the claim on the overcommitted clusters.</p>

<p style="margin-top: 1em">DUP_CLUSTERS_CLONE <br>
An inode claims clusters that are also claimed by another
inode. ocfs2 does not allow this.</p>

<p style="margin-top: 1em">Answering yes will copy the data
of this inode to newly allocated extents. This will break
the claim on the overcommitted clusters.</p>

<p style="margin-top: 1em">DUP_CLUSTERS_DELETE <br>
An inode claims clusters that are also claimed by another
inode. ocfs2 does not allow this.</p>

<p style="margin-top: 1em">Answering yes will remove this
inode, thus breaking its claim on the overcommitted
clusters.</p>

<p style="margin-top: 1em">DUP_CLUSTERS_ADD_REFCOUNT <br>
An inode claims clusters that are also claimed by another
inode. ocfs2 does not allow this.</p>

<p style="margin-top: 1em">Answering yes will try to add a
refcount record for all these inodes, so that they will
share the cluster.</p>

<p style="margin-top: 1em">DIRENT_DOTTY_DUP <br>
There can be only one instance of both the &quot;.&quot; and
&quot;..&quot; entries in a directory. A directory entry was
found which duplicated one of these entries.</p>

<p style="margin-top: 1em">Answering yes will remove the
duplicate directory entry.</p>

<p style="margin-top: 1em">DIRENT_NOT_DOTTY <br>
The first and second directory entries in a directory must
be &quot;.&quot; and &quot;..&quot; respectively. One of
these directory entries was found to not match these
rules.</p>

<p style="margin-top: 1em">Answering yes will force the
directory entry to be either &quot;.&quot; or
&quot;..&quot;. This might consume otherwise valid entries
and cause some files to appear in lost+found.</p>

<p style="margin-top: 1em">DIRENT_DOT_INODE <br>
The inode field of the &quot;.&quot; directory entry must
refer to the directory inode that contains the given
directory block. A &quot;.&quot; entry was found which
doesn&rsquo;t do so.</p>

<p style="margin-top: 1em">Answering yes sets the directory
entry&rsquo;s inode reference to the parent directory that
contains the entry.</p>

<p style="margin-top: 1em">DIRENT_DOT_EXCESS <br>
A &quot;.&quot; directory entry was found whose lengths
exceeds the amount required for the single dot in the
name.</p>

<p style="margin-top: 1em">Answering yes creates another
empty directory entry in this excess space.</p>

<p style="margin-top: 1em">DIRENT_ZERO <br>
A directory entry was found with a zero length name.</p>

<p style="margin-top: 1em">Answering yes clears the
directory entry so its space can be reused.</p>

<p style="margin-top: 1em">DIRENT_NAME_CHARS <br>
Directory entries can not contain either the NULL character
(ASCII 0) or the forward slash (ASCII 47). A directory entry
was found which contains either.</p>

<p style="margin-top: 1em">Answering yes will change each
instance of these forbidden characters into a period (ASCII
46).</p>

<p style="margin-top: 1em">DIRENT_INODE_RANGE <br>
Each directory entry contains a inode field which the
entry&rsquo;s name corresponds to. An entry was found which
referenced an inode number that is invalid for the current
volume.</p>

<p style="margin-top: 1em">Answering yes clears this entry
so its space can be reused. If the entry once corresponded
to a real inode and was corrupted this inode may appear in
lost+found.</p>

<p style="margin-top: 1em">DIRENT_INODE_FREE <br>
Each directory entry contains a inode field which the
entry&rsquo;s name corresponds to. An entry was found which
referenced an inode number that isn&rsquo;t in use.</p>

<p style="margin-top: 1em">Answering yes clears this
directory entry.</p>

<p style="margin-top: 1em">DIRENT_TYPE <br>
Each directory entry contains a field which describes the
type of file that the entry refers to. An entry was found
whose type doesn&rsquo;t match the inode it is referring
to.</p>

<p style="margin-top: 1em">Answering yes resets the
entry&rsquo;s type to match the target inode.</p>

<p style="margin-top: 1em">DIR_PARENT_DUP <br>
Each directory can only be pointed to by one directory entry
in a parent directory. A directory entry was found which was
the second entry to point to a given directory inode.</p>

<p style="margin-top: 1em">Answering yes clears this entry
which was the second to refer to a given directory. This
reflects the policy that hard links to directories are not
allowed.</p>

<p style="margin-top: 1em">DIRENT_DUPLICATE <br>
File names within a directory must be unique. A file name
occurred in more than one directory entry in a given
directory.</p>

<p style="margin-top: 1em">Answering yes renames the
duplicate entry to a name that doesn&rsquo;t collide with
recent entries and is unlikely to collide with future
entries in the directory.</p>

<p style="margin-top: 1em">DIRENT_LENGTH <br>
There are very few directory entry lengths that are valid.
The lengths must be greater than the minimum required to
record a single character directory, be rounded to 12 bytes,
<br>
be within the amount of space remaining in a directory
block, and be properly rounded for the size of the name of
the directory entry. An entry was found which didn&rsquo;t
meet these <br>
criteria.</p>

<p style="margin-top: 1em">Answering yes will try to repair
the directory entry. This runs a very good chance of
invalidating all the entries in the directory block.
Orphaned inodes may appear in <br>
lost+found.</p>

<p style="margin-top: 1em">DIR_TRAILER_INODE <br>
A directory block trailer is a fake directory entry at the
end of the block. The trailer has compatibility fields for
when it is viewed as a directory entry. The inode field <br>
must be zero.</p>

<p style="margin-top: 1em">Answering yes will set the inode
field to zero.</p>

<p style="margin-top: 1em">DIR_TRAILER_NAME_LEN <br>
A directory block trailer is a fake directory entry at the
end of the block. The trailer has compatibility fields for
when it is viewed as a directory entry. The name length <br>
field must be zero.</p>

<p style="margin-top: 1em">Answering yes will set the name
length field to zero.</p>

<p style="margin-top: 1em">DIR_TRAILER_REC_LEN <br>
A directory block trailer is a fake directory entry at the
end of the block. The trailer has compatibility fields for
when it is viewed as a directory entry. The record length
<br>
field must be equal to the size of the trailer.</p>

<p style="margin-top: 1em">Answering yes will set the
record length field to the size of the trailer.</p>

<p style="margin-top: 1em">DIR_TRAILER_BLKNO <br>
A directory block trailer is a fake directory entry at the
end of the block. The self-referential block number is
incorrect.</p>

<p style="margin-top: 1em">Answering yes will set the block
number to the correct block on disk.</p>

<p style="margin-top: 1em">DIR_TRAILER_PARENT_INODE <br>
A directory block trailer is a fake directory entry at the
end of the block. It has a pointer to the directory inode it
belongs to. This pointer is incorrect.</p>

<p style="margin-top: 1em">Answering yes will set the
parent inode pointer to the inode referencing this directory
block.</p>

<p style="margin-top: 1em">ROOT_DIR_MISSING <br>
The super block contains a reference to the inode that
serves as the root directory. This reference points to an
inode that isn&rsquo;t in use.</p>

<p style="margin-top: 1em">Answering yes will create a new
inode and update the super block to refer to this inode as
the root directory.</p>

<p style="margin-top: 1em">LOSTFOUND_MISSING <br>
The super block contains a reference to the inode that
serves as the lost+found directory. This reference points to
an inode that isn&rsquo;t in use.</p>

<p style="margin-top: 1em">Answering yes will create a new
lost+found directory in the root directory.</p>

<p style="margin-top: 1em">DIR_NOT_CONNECTED <br>
Every directory in the file system should be reachable by a
directory entry in its parent directory. This is verified by
walking every directory in the system. A directory <br>
inode was found during this walk which doesn&rsquo;t have a
parent directory entry.</p>

<p style="margin-top: 1em">Answering yes moves this
directory entry into the lost+found directory and gives it a
name based on its inode number.</p>

<p style="margin-top: 1em">DIR_DOTDOT <br>
A directory inode&rsquo;s &quot;..&quot; directory entry
must refer to the parent directory. A directory was found
whose &quot;..&quot; doesn&rsquo;t refer to its parent.</p>

<p style="margin-top: 1em">Answering yes will read the
directory block for the given directory and update its
&quot;..&quot; entry to reflect its parent.</p>

<p style="margin-top: 1em">INODE_NOT_CONNECTED <br>
Most all inodes in the system should be referenced by a
directory entry. An inode was found which isn&rsquo;t
referred to by any directory entry.</p>

<p style="margin-top: 1em">Answering yes moves this inode
into the lost+found directory and gives it a name based on
its inode number.</p>

<p style="margin-top: 1em">INODE_COUNT <br>
Each inode records the number of directory entries that
refer to it. An inode was found whose recorded count
doesn&rsquo;t match the number of entries that refer to
it.</p>

<p style="margin-top: 1em">Answering yes sets the
inode&rsquo;s count to match the number of referring
directory entries.</p>

<p style="margin-top: 1em">INODE_ORPHANED <br>
While files are being deleted they are placed in an internal
directory. If the machine crashes while this is taking place
the files will be left in this directory. Fsck has <br>
found an inode in this directory and would like to finish
the job of truncating and removing it.</p>

<p style="margin-top: 1em">Answering yes removes the file
data associated with the inode and frees the inode.</p>

<p style="margin-top: 1em">RECOVER_BACKUP_SUPERBLOCK <br>
When fsck.ocfs2 successfully uses the specified backup
superblock, it provides the user with this option to
overwrite the existing superblock with that backup.</p>

<p style="margin-top: 1em">Answering yes will refresh the
superblock from the backup. Answering no will only disable
the copying of the backup superblock and will not effect the
remaining fsck.ocfs2 pro&acirc; <br>
cessing.</p>

<p style="margin-top: 1em">ORPHAN_DIR_MISSING <br>
While files are being deleted they are placed in an internal
directory, named orphan directory. If an orphan directory
does not exist, an OCFS2 volume cannot be mounted
success&acirc; <br>
fully. Fsck has found the orphan directory is missing and
would like to create it for future use.</p>

<p style="margin-top: 1em">Answering yes creates the orphan
directory in the system directory.</p>

<p style="margin-top: 1em">JOURNAL_FILE_INVALID <br>
OCFS2 uses JDB for journalling and some journal files exist
in the system directory. Fsck has found some journal files
that are invalid.</p>

<p style="margin-top: 1em">Answering yes to this question
will regenerate the invalid journal files.</p>

<p style="margin-top: 1em">JOURNAL_UNKNOWN_FEATURE <br>
Fsck has found some journal files with unknown features.
Other journals on the filesystem have only known features,
so this is likely a corruption. If you think your filesystem
<br>
may be newer than this version of fsck.ocfs2, say N here and
grab the latest version of fsck.ocfs2.</p>

<p style="margin-top: 1em">Answering yes resets the journal
features to match other journals.</p>

<p style="margin-top: 1em">JOURNAL_MISSING_FEATURE <br>
Fsck has found some journal files have features that are not
set on all journal files. All journals on filesystem should
have the same set of features.</p>

<p style="margin-top: 1em">Answering yes will set all
journals to the union of set features.</p>

<p style="margin-top: 1em">JOURNAL_TOO_SMALL <br>
Fsck has found some journal files are too small.</p>

<p style="margin-top: 1em">Answering yes extends these
journals.</p>

<p style="margin-top: 1em">RECOVER_CLUSTER_INFO <br>
The currently active cluster stack is different than the one
the filesystem is configured for. Thus, fsck.ocfs2 cannot
determine whether the filesystem is mounted on an another
<br>
node or not. The recommended solution is to exit and run
fsck.ocfs2 on this device from a node that has the
appropriate active cluster stack. However, you can proceed
with the <br>
fsck if you are sure that the volume is not in use on any
node.</p>

<p style="margin-top: 1em">Answering yes reconfigures the
filesystem to use the current cluster stack. DANGER: YOU
MUST BE ABSOLUTELY SURE THAT NO OTHER NODE IS USING THIS
FILESYSTEM BEFORE CONTINUING. <br>
OTHERWISE, YOU CAN CORRUPT THE FILESYSTEM AND LOSE DATA.</p>

<p style="margin-top: 1em">INLINE_DATA_FLAG_INVALID <br>
Inline file can only exist in a volume with inline
supported, Fsck has found that a file in a non-inline volume
has inline flag set.</p>

<p style="margin-top: 1em">Answering yes remove this flag
from the file.</p>

<p style="margin-top: 1em">INLINE_DATA_COUNT_INVALID <br>
For an inline file, there is a limit for
id2.id_data.id_count. Fsck has found that this value
isn&rsquo;t right.</p>

<p style="margin-top: 1em">Answering yes change this value
to the right number.</p>

<p style="margin-top: 1em">XATTR_BLOCK_INVALID <br>
Extended attributes are stored off an extended attribute
block referenced by the inode. This inode references an
invalid extended attribute block.</p>

<p style="margin-top: 1em">Answering yes will remove this
block.</p>

<p style="margin-top: 1em">XATTR_COUNT_INVALID <br>
The count of extended attributes in an inode, block, or
bucket does not match the number of entries found by
fsck.</p>

<p style="margin-top: 1em">Answering yes will change this
to the correct count.</p>

<p style="margin-top: 1em">XATTR_ENTRY_INVALID <br>
An extended attribute entry points to already used
space.</p>

<p style="margin-top: 1em">Answering yes will remove this
entry.</p>

<p style="margin-top: 1em">XATTR_NAME_OFFSET_INVALID <br>
The name_offset field of an extended attribute entry is not
correct. Without a correct name_offset field, the entry
cannot be used.</p>

<p style="margin-top: 1em">Answering yes will remove this
entry.</p>

<p style="margin-top: 1em">XATTR_VALUE_INVALID <br>
The value region of an extended attribute points to already
used space.</p>

<p style="margin-top: 1em">Answering yes will remove this
entry.</p>

<p style="margin-top: 1em">XATTR_LOCATION_INVALID <br>
The xe_local field and xe_value_size field of an extended
attribute entry does not match. So the entry cannot be
used.</p>

<p style="margin-top: 1em">Answering yes will remove this
entry.</p>

<p style="margin-top: 1em">XATTR_HASH_INVALID <br>
Extended attributes use a hash of their name for lookup
purposes. The name_hash of this extended attribute entry is
not correct.</p>

<p style="margin-top: 1em">Answering yes will change this
to the correct hash.</p>

<p style="margin-top: 1em">XATTR_FREE_START_INVALID <br>
Extended attributes use free_start to indicate the offset of
the free space in inode, block, or bucket. The free_start
field of this object is not correct.</p>

<p style="margin-top: 1em">Answering yes will change this
to the correct offset.</p>

<p style="margin-top: 1em">XATTR_VALUE_LEN_INVALID <br>
Extended attributes use name_value_len to store the total
length of all entry&rsquo;s name and value in inode, block
or bucket. the name_value_len filed of this object is not
correct.</p>

<p style="margin-top: 1em">Answering yes will change this
to the correct value.</p>

<p style="margin-top: 1em">XATTR_BUCKET_COUNT_INVALID <br>
The count of extended attributes bucket pointed by one
extent record does not match the number of buckets found by
fsck.</p>

<p style="margin-top: 1em">Answering yes will change this
to the correct count.</p>

<p style="margin-top: 1em">QMAGIC_INVALID <br>
The magic number in the header of quota file does not match
the proper number.</p>

<p style="margin-top: 1em">Answering yes will make fsck use
values in the quota file header anyway.</p>

<p style="margin-top: 1em">QTREE_BLK_INVALID <br>
Block with references to other blocks with quota data is
corrupted.</p>

<p style="margin-top: 1em">Answering yes will make fsck use
references in the block.</p>

<p style="margin-top: 1em">DQBLK_INVALID <br>
The structure with quota limits was found in a corrupted
block.</p>

<p style="margin-top: 1em">Answering yes will use the
values of limits for the user / group.</p>

<p style="margin-top: 1em">DUP_DQBLK_INVALID <br>
The structure with quota limits was found in a corrupted
block and fsck has already found quota limits for this user
/ group.</p>

<p style="margin-top: 1em">Answering yes will use new
values of limits for the user / group.</p>

<p style="margin-top: 1em">DUP_DQBLK_VALID <br>
The structure with quota limits was found in a correct block
but fsck has already found quota limits for this user /
group.</p>

<p style="margin-top: 1em">Answering yes will use new
values of limits for the user / group.</p>

<p style="margin-top: 1em">IV_DX_TREE <br>
A directory index was found on an inode but that feature is
not enabled on the file system.</p>

<p style="margin-top: 1em">Answering yes will truncate the
invalid index.</p>

<p style="margin-top: 1em">DX_LOOKUP_FAILED <br>
A directory entry is missing an entry in the directory
index. The missing index entry will cause lookups on this
name to fail.</p>

<p style="margin-top: 1em">Answering yes will rebuild the
directory index, restoring the missing entry.</p>

<p style="margin-top: 1em">NO_HOLES <br>
A metadata structure encountered a hole where it should not.
Examples of such structures are directories, refcount trees,
dx_trees etc.</p>

<p style="margin-top: 1em">Answering yes will remove the
hole by updating the offset to the expected value.</p>

<p style="margin-top: 1em">EXTENT_OVERLAP <br>
The extents of the file overlap, which means there could be
two or more possible data for a particular offset for the
file.</p>

<p style="margin-top: 1em">Answering yes will serialize the
extents.</p>

<p style="margin-top: 1em">DX_TREE_CORRUPT <br>
The index tree of the directory is corrupt.</p>

<p style="margin-top: 1em">Answering yes will rebuild the
directory index, in pass 2.</p>

<p style="margin-top: 1em">DX_TREE_MISSING <br>
The index of this directory is missing.</p>

<p style="margin-top: 1em">Answering yes will rebuild the
directory index.</p>

<p style="margin-top: 1em">BAD_CRC32 <br>
The metadata block has a bad CRC32, which means either the
block or the crc32 field is corrupted.</p>

<p style="margin-top: 1em">Answering yes will recalculate
the CRC32.</p>

<p style="margin-top: 1em">SEE ALSO <br>
debugfs.ocfs2(8) fsck.ocfs2(8) mkfs.ocfs2(8) mount.ocfs2(8)
mounted.ocfs2(8) o2cluster(8) o2image(8) o2info(1)
tunefs.ocfs2(8)</p>

<p style="margin-top: 1em">AUTHORS <br>
Oracle Corporation.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 2004, 2012 Oracle. All rights
reserved.</p>

<p style="margin-top: 1em">Version 1.8.4 January 2012
fsck.ocfs2.checks(8)</p>
<hr>
</body>
</html>
