<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>fsck.ocfs2.checks(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">fsck.ocfs2.checks(8)</td>
    <td class="head-vol">OCFS2 Manual Pages</td>
    <td class="head-rtitle">fsck.ocfs2.checks(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
fsck.ocfs2.checks - Consistency checks that <b>fsck.ocfs2(8)</b> performs and
  its means for fixing inconsistencies.
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>fsck.ocfs2(8)</b> is used to check an OCFS2 file system. It performs many
  consistency checks and will offer to fix faults that it finds. This man page
  lists the problems it may find and describes their fixes. The problems are
  indexed by the error number that <b>fsck.ocfs2(8)</b> emits when it describes
  the problem and asks if it should be fixed.
<div style="height: 1.00em;">&#x00A0;</div>
The prompts are constructed such that answering 'no' results in no changes to
  the file system. This may result in errors later on that stop
  <b>fsck.ocfs2(8)</b> from proceeding.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="CHECKS"><a class="selflink" href="#CHECKS">CHECKS</a></h1>
<h2 class="Ss" title="Ss" id="EB_BLKNO"><a class="selflink" href="#EB_BLKNO">EB_BLKNO</a></h2>
Extent blocks contain a record of the disk block where they are located. An
  extent block was found at a block that didn't match its recorded location.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will update the data structure in the extent block to reflect its
  real location on disk.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EB_GEN"><a class="selflink" href="#EB_GEN">EB_GEN</a></h2>
Extent blocks are created with a generation number to match the generation
  number of the volume at the time of creation. An extent block was found which
  contains a generation number that doesn't match.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes implies that the generation number is correct and that the extent
  block is from a previous file system. The extent block will be ignored and the
  file that contains it will lose the data it referenced.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EB_GEN_FIX"><a class="selflink" href="#EB_GEN_FIX">EB_GEN_FIX</a></h2>
Extent blocks are created with a generation number to match the generation
  number of the volume at the time of creation. An extent block was found which
  contains a generation number that doesn't match.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes implies that the generation number in the extent block is
  incorrect and that the extent block is valid. The generation number in the
  block is updated to match the generation number in the volume.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_MARKED_UNWRITTEN"><a class="selflink" href="#EXTENT_MARKED_UNWRITTEN">EXTENT_MARKED_UNWRITTEN</a></h2>
An extent record has the UNWRITTEN flag set, but the filesystem feature set does
  not include unwritten extents.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the UNWRITTEN flag. This is safe to do; as the feature is
  disabled anyway.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_MARKED_REFCOUNTED"><a class="selflink" href="#EXTENT_MARKED_REFCOUNTED">EXTENT_MARKED_REFCOUNTED</a></h2>
An extent record has the REFCOUNTED flag set, but neither the filesystem nor the
  file has the REFCOUNTED flag set.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the REFCOUNTED flag.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_BLKNO_UNALIGNED"><a class="selflink" href="#EXTENT_BLKNO_UNALIGNED">EXTENT_BLKNO_UNALIGNED</a></h2>
The block that marks the start of an extent should always fall on the start of a
  cluster. An extent was found that starts part-way into a cluster.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes moves the start of the extent back to the start of the addressed
  cluster. This may add data to the middle of the file that contains this
  extent.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_CLUSTERS_OVERRUN"><a class="selflink" href="#EXTENT_CLUSTERS_OVERRUN">EXTENT_CLUSTERS_OVERRUN</a></h2>
An extent was found which claims to contain clusters which are beyond the end of
  the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clamps the extent to the end of the volume. This may result in a
  reduced file size for the file that contains the extent, but it couldn't have
  addressed those final clusters anyway. One can imagine this problem arising if
  there are problems shrinking a volume.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_EB_INVALID"><a class="selflink" href="#EXTENT_EB_INVALID">EXTENT_EB_INVALID</a></h2>
Deep extent trees are built by forming a tree out of extent blocks. An extent
  tree references an invalid extent block.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes stops the tree from referencing the invalid extent block. This may
  truncate data from the file which contains the tree.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_LIST_DEPTH"><a class="selflink" href="#EXTENT_LIST_DEPTH">EXTENT_LIST_DEPTH</a></h2>
Extent lists contain a record of their depth in the tree. An extent list was
  found whose recorded depth doesn't match the position they have in the tree.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the depth field in the list to match the tree on disk.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_LIST_COUNT"><a class="selflink" href="#EXTENT_LIST_COUNT">EXTENT_LIST_COUNT</a></h2>
The number of entries in an extent list is bounded by either the size of the
  inode or the size of the block which contains it. An extent list was found
  which claims to have more entries than would fit in its container.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the count field in the extent list to match the container.
  Answering no to this question may stop further fixes from being done because
  the count value can not be trusted.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_LIST_FREE"><a class="selflink" href="#EXTENT_LIST_FREE">EXTENT_LIST_FREE</a></h2>
The number of free entries in an extent list must be less than the total number
  of entries in the list. A list was found which claims to have more free
  entries than possible entries.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes sets the number of free entries in the list equal to the total
  possible entries.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_BLKNO_RANGE"><a class="selflink" href="#EXTENT_BLKNO_RANGE">EXTENT_BLKNO_RANGE</a></h2>
An extent record was found which references a block which can not be referenced
  by an extent. The referenced block is either very early in the volume, and
  thus reserved, or beyond the end of the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes removes this extent record from the tree. This may remove data
  from the file which owns the tree but any such data was inaccessible.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_CPG"><a class="selflink" href="#CHAIN_CPG">CHAIN_CPG</a></h2>
The bitmap inode indicates a different clusters per group than the group
  descriptor. This value is typically static and only modified by tunefs during
  volume resize and that too only on volumes having only one cluster group.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the clusters per group on the bitmap inode to the
  corresponding value in the group descriptor.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="SUPERBLOCK_CLUSTERS"><a class="selflink" href="#SUPERBLOCK_CLUSTERS">SUPERBLOCK_CLUSTERS</a></h2>
The super block indicates a different total clusters value than the global
  bitmap. This is only possible due to a failed volume resize operation.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the total clusters in the super block to the value
  specified in the global bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="FIXED_CHAIN_CLUSTERS"><a class="selflink" href="#FIXED_CHAIN_CLUSTERS">FIXED_CHAIN_CLUSTERS</a></h2>
The global bitmap inode was repaired, resulting in a change to the total cluster
  count of the filesystem.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the total clusters in the super block to the value
  specified in the global bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_UNEXPECTED_DESC"><a class="selflink" href="#GROUP_UNEXPECTED_DESC">GROUP_UNEXPECTED_DESC</a></h2>
The group descriptors that make up the global bitmap chain allocator reside at
  predictable locations on disk. A group descriptor was found in the global
  bitmap allocator which isn't at one of these locations and so shouldn't be in
  the allocator.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes removes this descriptor from the global bitmap allocator.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_EXPECTED_DESC"><a class="selflink" href="#GROUP_EXPECTED_DESC">GROUP_EXPECTED_DESC</a></h2>
The group descriptors that make up the global bitmap chain allocator reside at
  predictable locations on disk. A group descriptor at one of these locations
  was not linked into the global bitmap allocator.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will relink this group into the allocator.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_GEN"><a class="selflink" href="#GROUP_GEN">GROUP_GEN</a></h2>
A group descriptor was found with a generation number that doesn't match the
  generation number of the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes sets the group descriptor's generation equal to the generation
  number in the volume.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_PARENT"><a class="selflink" href="#GROUP_PARENT">GROUP_PARENT</a></h2>
Group descriptors contain a pointer to the allocator inode which contains the
  chain they belong to. A group descriptor was found in an allocator inode that
  doesn't match the descriptor's parent pointer.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the group descriptor's parent pointer to match the inode
  it resides in.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_DUPLICATE"><a class="selflink" href="#GROUP_DUPLICATE">GROUP_DUPLICATE</a></h2>
Group descriptors contain a pointer to the allocator inode which contains the
  chain they belong to. A group descriptor was found in two allocator inodes so
  it may be duplicated.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes removes the group descriptor from current allocator inode.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_BLKNO"><a class="selflink" href="#GROUP_BLKNO">GROUP_BLKNO</a></h2>
Group descriptors have a field which records their block location on disk. A
  group descriptor was found at a given location but is recorded as being
  located somewhere else.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the group descriptor's recorded location to match where it
  actually is found on disk.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_CHAIN"><a class="selflink" href="#GROUP_CHAIN">GROUP_CHAIN</a></h2>
Group descriptors are found in a number of different singly-linked chains in an
  allocator inode. A group descriptor records the chain number that it is linked
  in. A group descriptor was found whose chain field doesn't match the chain it
  was found in.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes sets the group descriptor's chain field to match the chain it is
  found in.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_FREE_BITS"><a class="selflink" href="#GROUP_FREE_BITS">GROUP_FREE_BITS</a></h2>
A group descriptor records the number of bits in its bitmap that are free. A
  group descriptor was found which claims to have more free bits than are valid
  in its bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes decreases the number of recorded free bits so that it equals the
  total number of bits in the group descriptor's bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="GROUP_CHAIN_LOOP"><a class="selflink" href="#GROUP_CHAIN_LOOP">GROUP_CHAIN_LOOP</a></h2>
A chain may loop if the next field of the group descriptor points to one of the
  previous group descriptors in the chain. This causes the ocfs2 code, both user
  space and kernel module to loop forever.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes breaks the loop at an optimum location so that all the existing
  group descriptors are in the chain. However, it cannot re-connect stray group
  descriptors and must rely on the rest of the fsck code to fix it.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_COUNT"><a class="selflink" href="#CHAIN_COUNT">CHAIN_COUNT</a></h2>
The chain list embedded in an inode is limited by the block size and the number
  of bytes consumed by the rest of the inode. A chain list header was found
  which claimed that there are more entries in the list then could fit in the
  inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the header's cl_count member to the maximum size allowed by
  the block size after accounting for the space consumed by the inode.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_NEXT_FREE"><a class="selflink" href="#CHAIN_NEXT_FREE">CHAIN_NEXT_FREE</a></h2>
This is identical to CHAIN_COUNT except that it is testing and fixing the
  pointer to the next free list entry recorded in the cl_next_free_rec member
  instead of the total number of entries.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_EMPTY"><a class="selflink" href="#CHAIN_EMPTY">CHAIN_EMPTY</a></h2>
Chain entries need to be packed such that there are no chains without
  descriptors found before the chain that is marked as free by the chain header.
  A chain without descriptors was found found before that chain that was marked
  free.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the unused chain and shift the remaining chains
  forward in the list.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_I_CLUSTERS"><a class="selflink" href="#CHAIN_I_CLUSTERS">CHAIN_I_CLUSTERS</a></h2>
Chain allocator inodes have an i_clusters value that represents the number of
  clusters used by the allocator. An inode was found whose i_clusters value
  doesn't match the number of clusters its chains cover.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates i_clusters in the inode to reflect what was actually found
  by walking the chain.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_I_SIZE"><a class="selflink" href="#CHAIN_I_SIZE">CHAIN_I_SIZE</a></h2>
Chain allocator inodes multiply the number of bytes per cluster by the their
  i_clusters value and store it in i_size. An inode was found which didn't have
  the correct value in its i_size.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates i_size to be the product of i_clusters and the cluster
  size. Nothing else uses this value, and previous versions of tools didn't
  calculate it properly, so don't be too worried if this error appears.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_GROUP_BITS"><a class="selflink" href="#CHAIN_GROUP_BITS">CHAIN_GROUP_BITS</a></h2>
The inode that contains an embedded chain list has fields which record the total
  number of bits covered by the chain as well as the amount free. These fields
  didn't match what was found in the chain.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the fields in the inode to reflect what was actually found
  by walking the chain.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_HEAD_LINK_RANGE"><a class="selflink" href="#CHAIN_HEAD_LINK_RANGE">CHAIN_HEAD_LINK_RANGE</a></h2>
The header that starts a chain tried to reference a group descriptor at a block
  number that couldn't be valid.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will clear the reference to this invalid block and truncate the
  chain that it started.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_LINK_GEN"><a class="selflink" href="#CHAIN_LINK_GEN">CHAIN_LINK_GEN</a></h2>
A reference was made to a group descriptor whose generation number doesn't match
  the generation of the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes to this question implies that the group descriptor is invalid and
  the chain is truncated at the point that it referred to this invalid group
  descriptor. Answering no to this question considers the group descriptor as
  valid and its generation may be fixed.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_LINK_MAGIC"><a class="selflink" href="#CHAIN_LINK_MAGIC">CHAIN_LINK_MAGIC</a></h2>
Chains are built by chain headers and group descriptors which are linked
  together by block references. A reference was made to a group descriptor at a
  given block but a valid group descriptor signature wasn't found at that block.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the reference to this invalid block and truncates the chain
  at the point of the reference.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_LINK_RANGE"><a class="selflink" href="#CHAIN_LINK_RANGE">CHAIN_LINK_RANGE</a></h2>
Chains are built by chain headers and group descriptors which are linked
  together by block references. A reference a block was found which can't
  possibly be valid because it was either too small or extended beyond the
  volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes truncates the chain in question by zeroing the invalid block
  reference. This shortens the chain in question and could result in more fixes
  later if the part of the chain that couldn't be referenced was valid at some
  point.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CHAIN_BITS"><a class="selflink" href="#CHAIN_BITS">CHAIN_BITS</a></h2>
A chain's header contains members which record the total number of bits in the
  chain as well as the number of bits that are free. After walking through a
  chain it was found that the number of bits recorded in its header don't match
  what was found by totalling up the group descriptors.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the c_total and c_free members of the header to reflect
  what was found in the group descriptors in the chain.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_DEPTH"><a class="selflink" href="#DISCONTIG_BG_DEPTH">DISCONTIG_BG_DEPTH</a></h2>
A discontiguous block group has an extent list which records all the clusters
  allocated to it. Discontiguous block groups only support extent lists with a
  tree depth of 0. A block group claims to have a tree depth greater than 0.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the tree depth of the extent list to 0.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_COUNT"><a class="selflink" href="#DISCONTIG_BG_COUNT">DISCONTIG_BG_COUNT</a></h2>
A discontiguous block group has an extent list which records all the clusters
  allocated to it. A block group claims to have more records than can actually
  fit.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the record count to the maximum possible.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_REC_RANGE"><a class="selflink" href="#DISCONTIG_BG_REC_RANGE">DISCONTIG_BG_REC_RANGE</a></h2>
Block groups set aside clusters to be used for metadata. A discontiguous block
  group claims to contain clusters beyond the end of the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the block group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_CORRUPT_LEAVES"><a class="selflink" href="#DISCONTIG_BG_CORRUPT_LEAVES">DISCONTIG_BG_CORRUPT_LEAVES</a></h2>
A discontiguous block group has an extent list which records all the clusters
  allocated to it. A group has more than one extent claiming to have an
  impossible number of clusters.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the block group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_CLUSTERS"><a class="selflink" href="#DISCONTIG_BG_CLUSTERS">DISCONTIG_BG_CLUSTERS</a></h2>
Extent records in a discontiguous block group were found having more clusters
  allocated then a block group can have.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the block group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_LESS_CLUSTERS"><a class="selflink" href="#DISCONTIG_BG_LESS_CLUSTERS">DISCONTIG_BG_LESS_CLUSTERS</a></h2>
Extent records in a discontiguous block group were found having less clusters
  allocated then a block group can have.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the block group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_NEXT_FREE_REC"><a class="selflink" href="#DISCONTIG_BG_NEXT_FREE_REC">DISCONTIG_BG_NEXT_FREE_REC</a></h2>
A discontiguous block group has an extent list which records all the clusters
  allocated to it. A group was found with fewer filled in extents than it claims
  to have. The filled in extents describe a complete and correct group.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the used extent count to the number of filled extents.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_LIST_CORRUPT"><a class="selflink" href="#DISCONTIG_BG_LIST_CORRUPT">DISCONTIG_BG_LIST_CORRUPT</a></h2>
A discontiguous block group has an extent list which records all the clusters
  allocated to it. The group claims to have more extents than is possible, and
  the existing extents contain errors.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the block group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_REC_CORRUPT"><a class="selflink" href="#DISCONTIG_BG_REC_CORRUPT">DISCONTIG_BG_REC_CORRUPT</a></h2>
A discontiguous block group has a extent list which records all the clusters
  allocated to it. A group was found with one extent claiming too many clusters
  but the sum of the remaining extents are equal to the total clusters a group
  must have.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the block group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DISCONTIG_BG_LEAF_CLUSTERS"><a class="selflink" href="#DISCONTIG_BG_LEAF_CLUSTERS">DISCONTIG_BG_LEAF_CLUSTERS</a></h2>
A discontiguous block group has a extent list which records all the clusters
  allocated to it. A group was found with one extent claiming too many clusters,
  but the remaining extents are correct.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the number of the clusters on the broken extent to the
  difference between the total clusters a group must have and the sum of the
  remaining extents.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_ALLOC_REPAIR"><a class="selflink" href="#INODE_ALLOC_REPAIR">INODE_ALLOC_REPAIR</a></h2>
The inode allocator did not accurately reflect the set of inodes that are free
  and in use in the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will update the inode allocator bitmaps. Each bit that doesn't
  match the state of its inode will be inverted.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_SUBALLOC"><a class="selflink" href="#INODE_SUBALLOC">INODE_SUBALLOC</a></h2>
Each inode records the node whose allocator is responsible for the inode. An
  inode was found in a given node's allocator but the inode itself claimed to
  belong to a different node.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will correct the inode to point to the node's allocator that it
  belongs to.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_SIZE"><a class="selflink" href="#LALLOC_SIZE">LALLOC_SIZE</a></h2>
Each node has a local allocator contained in a block that is used to allocate
  clusters in batches. A node's local allocator claims to reflect more bytes
  than are possible for the volume's block size.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes decreases the local allocator's size to reflect the volume's block
  size.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_NZ_USED"><a class="selflink" href="#LALLOC_NZ_USED">LALLOC_NZ_USED</a></h2>
A given node's local allocator isn't in use but it claims to have bits in use in
  its bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes zeros this used field.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_NZ_BM"><a class="selflink" href="#LALLOC_NZ_BM">LALLOC_NZ_BM</a></h2>
A given node's local allocator isn't in use but it has a field which records the
  bitmap as starting at a non-zero cluster offset.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes zeros the bm_off field.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_BM_OVERRUN"><a class="selflink" href="#LALLOC_BM_OVERRUN">LALLOC_BM_OVERRUN</a></h2>
Each local allocator contains a reference to the first cluster that its bitmap
  addresses. A given local allocator was found which references a starting
  cluster that is beyond the end of the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the given local allocator. No allocated data will be lost.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_BM_SIZE"><a class="selflink" href="#LALLOC_BM_SIZE">LALLOC_BM_SIZE</a></h2>
The given local allocator claims to cover more bits than are possible for the
  size in bytes of its bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes decreases the number of bits the allocator covers to reflect the
  size in bytes of the bitmap and resets the allocator. No allocated data will
  be lost.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_BM_STRADDLE"><a class="selflink" href="#LALLOC_BM_STRADDLE">LALLOC_BM_STRADDLE</a></h2>
The given local allocator claims to cover a region of clusters which extents
  beyond the end of the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the given local allocator. No allocated data will be lost.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_USED_OVERRUN"><a class="selflink" href="#LALLOC_USED_OVERRUN">LALLOC_USED_OVERRUN</a></h2>
The given local allocator claims to have more bits in use than it has total bits
  in its bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes decreases the number of bits used so that it equals the total
  number of available bits.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_CLEAR"><a class="selflink" href="#LALLOC_CLEAR">LALLOC_CLEAR</a></h2>
A local allocator inode was found to have problems. This gives the operator a
  chance to just reset the local allocator inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the local allocator. No information is lost but the global
  bitmap allocator may need to be updated to reflect clusters that were reserved
  for the local allocator but were free.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DEALLOC_COUNT"><a class="selflink" href="#DEALLOC_COUNT">DEALLOC_COUNT</a></h2>
The given truncate log inode contains a count that is greater than the value
  that is possible given the size of the inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the count value to the possible maximum.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DEALLOC_USED"><a class="selflink" href="#DEALLOC_USED">DEALLOC_USED</a></h2>
The given truncate log inode claims to have more records in use than it is
  possible to store in the inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the record of the number used to the maximum value
  possible.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="TRUNCATE_REC_START_RANGE"><a class="selflink" href="#TRUNCATE_REC_START_RANGE">TRUNCATE_REC_START_RANGE</a></h2>
A truncate record was found which claims to start at a cluster that is beyond
  the number of clusters in the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will clear the truncate record. This may result in previously
  freed space being marked as allocated. This will be fixed up later as the
  allocator is updated to match what is used by the file system.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="TRUNCATE_REC_WRAP"><a class="selflink" href="#TRUNCATE_REC_WRAP">TRUNCATE_REC_WRAP</a></h2>
Clusters are recorded as 32bit values. A truncate record was found which claims
  to have enough clusters to cause this value to wrap. This could never be the
  case and is a sure sign of corruption.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will clear the truncate record. This may result in previously
  freed space being marked as allocated. This will be fixed up later as the
  allocator is updated to match what is used by the file system.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="TRUNCATE_REC_RANGE"><a class="selflink" href="#TRUNCATE_REC_RANGE">TRUNCATE_REC_RANGE</a></h2>
A truncate record was found which claims to reference a region of clusters which
  partially extends beyond the number of clusters in the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will clear the truncate record. This may result in previously
  freed space being marked as allocated. This will be fixed up later as the
  allocator is updated to match what is used by the file system.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_GEN"><a class="selflink" href="#INODE_GEN">INODE_GEN</a></h2>
Inodes are created with a generation number to match the generation number of
  the volume at the time of creation. An Inode was found which contains a
  generation number that doesn't match.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes implies that the generation number is correct and that the inode
  is from a previous file system. The inode will be recorded as free.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_GEN_FIX"><a class="selflink" href="#INODE_GEN_FIX">INODE_GEN_FIX</a></h2>
Inodes are created with a generation number to match the generation number of
  the volume at the time of creation. An inode was found which contains a
  generation number that doesn't match.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes implies that the generation number in the inode is incorrect and
  that the inode is valid. The generation number in the inode is updated to
  match the generation number in the volume.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_BLKNO"><a class="selflink" href="#INODE_BLKNO">INODE_BLKNO</a></h2>
Inodes contain a field that must match the block that they reside in. An inode
  was found at a block that doesn't match the field in the inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the field to match the inode's position on disk.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="ROOT_NOTDIR"><a class="selflink" href="#ROOT_NOTDIR">ROOT_NOTDIR</a></h2>
The super block contains a reference to the inode that contains the root
  directory. This block was found to contain an inode that isn't a directory.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears this inode. The operator will be asked to recreate the root
  directory at a point in the near future.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_NZ_DTIME"><a class="selflink" href="#INODE_NZ_DTIME">INODE_NZ_DTIME</a></h2>
Inodes contain a field describing the time at which they were deleted. This can
  not be set for an inode that is still in use. An inode was found which is in
  use but which contains a non-zero dtime.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes implies that the inode is still valid and resets its dtime to
  zero.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LINK_FAST_DATA"><a class="selflink" href="#LINK_FAST_DATA">LINK_FAST_DATA</a></h2>
The target name for a symbolic link is stored either as file contents for that
  inode or in the inode structure itself on disk. Only small destination names
  are stored in the inode structure. The i_blocks field of the inode indicates
  that the name is stored in the inode when it is zero. An inode was found that
  has both i_blocks set to zero and file contents.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the inode and so deletes the link.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LINK_NULLTERM"><a class="selflink" href="#LINK_NULLTERM">LINK_NULLTERM</a></h2>
The targets of links on disk must be null terminated. A link was found whose
  target wasn't null terminated.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the inode and so deletes the link.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LINK_SIZE"><a class="selflink" href="#LINK_SIZE">LINK_SIZE</a></h2>
The size of a link on disk must match the length of its target string. A link
  was found whose size does not.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the link's size to reflect the length of its target
  string.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LINK_BLOCKS"><a class="selflink" href="#LINK_BLOCKS">LINK_BLOCKS</a></h2>
Links can not be sparse. There must be exactly as many blocks allocated as are
  needed to cover its size. A link was found which doesn't have enough blocks
  allocated to cover its size.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the link's inode thus deleting the link.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_ZERO"><a class="selflink" href="#DIR_ZERO">DIR_ZERO</a></h2>
Directories must at least contain a block that has the &quot;.&quot; and
  &quot;..&quot; entries. A directory was found which doesn't contain any
  blocks.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes to this question clears the directory's inode thus deleting the
  directory.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_SIZE"><a class="selflink" href="#INODE_SIZE">INODE_SIZE</a></h2>
Certain inodes record the size of the data they reference in an i_size field.
  This can be the number of bytes in a file, directory, or symlink target which
  are stored in data mapped by extents of clusters. This error occurs when the
  extent lists are walked and the amount of data found does not match what is
  stored in i_size.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes to this question updates the inode's i_size to match the amount of
  data referenced by the extent lists. It is vitally important that i_size
  matches the extent lists and so answering yes is strongly encouraged.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_SPARSE_SIZE"><a class="selflink" href="#INODE_SPARSE_SIZE">INODE_SPARSE_SIZE</a></h2>
Certain inodes record the size of the data they reference in an i_size field.
  This can be the number of bytes in a file, directory, or symlink target which
  are stored in data mapped by extents of clusters. This error occurs when a
  sparse inode was found that had data allocated past its i_size.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes to this question will update the inode's i_size to cover all of
  its allocated storage. It is vitally important that i_size matches the extent
  lists and so answering yes is strongly encouraged.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_INLINE_SIZE"><a class="selflink" href="#INODE_INLINE_SIZE">INODE_INLINE_SIZE</a></h2>
Inodes can only fit a certain amount of inline data. This inode has its data
  inline but claims an i_size larger than will actually fit.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes to this question updates the inode's i_size to the maximum
  available inline space.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_CLUSTERS"><a class="selflink" href="#INODE_CLUSTERS">INODE_CLUSTERS</a></h2>
Inodes contain a record of how many clusters are allocated to them. An inode was
  found whose recorded number of clusters doesn't match the number of blocks
  that were found associated with the inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the inode's number of clusters to reflect the number of
  blocks that were associated with the file.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_SPARSE_CLUSTERS"><a class="selflink" href="#INODE_SPARSE_CLUSTERS">INODE_SPARSE_CLUSTERS</a></h2>
Inodes contain a record of how many clusters are allocated to them. An sparse
  inode was found whose recorded number of clusters doesn't match the number of
  blocks that were found associated with the inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the inode's number of clusters to reflect the number of
  blocks that were associated with the file.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_INLINE_CLUSTERS"><a class="selflink" href="#INODE_INLINE_CLUSTERS">INODE_INLINE_CLUSTERS</a></h2>
Inlined inode should not have allocated clusters. An inode who has inline data
  flag set was found with clusters allocated.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the inode's number of clusters to zero.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_REPAIR"><a class="selflink" href="#LALLOC_REPAIR">LALLOC_REPAIR</a></h2>
An active local allocator did not accurately reflect the set of clusters that
  are free and in use in its region.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will update the local allocator bitmap. Each bit that doesn't
  match the use of its cluster will be inverted.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LALLOC_USED"><a class="selflink" href="#LALLOC_USED">LALLOC_USED</a></h2>
A local allocator records the number of bits that are used in its bitmap. An
  allocator was found whose used value doesn't reflect the number of bits that
  are set in its bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes sets the used value to match the number of bits set in the
  allocator's bitmap.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="CLUSTER_ALLOC_BIT"><a class="selflink" href="#CLUSTER_ALLOC_BIT">CLUSTER_ALLOC_BIT</a></h2>
A specific cluster's use didn't match the setting of its bit in the cluster
  allocator.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will invert the bit in the allocator to match the use of the
  cluster -- either allocated and in use or free.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_FLAG_INVALID"><a class="selflink" href="#REFCOUNT_FLAG_INVALID">REFCOUNT_FLAG_INVALID</a></h2>
Refcount file can only exist in a volume with refcount supported, Fsck has found
  that a file in a non-refcount volume has refcount flag set.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes remove this flag from the file.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_LOC_INVALID"><a class="selflink" href="#REFCOUNT_LOC_INVALID">REFCOUNT_LOC_INVALID</a></h2>
Refcount loc can only be valid if the file has refcount flag set. Fsck has found
  that a file has refcount loc while it does't have refcount flag set.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes reset refcount loc to zero for the file.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="RB_BLKNO"><a class="selflink" href="#RB_BLKNO">RB_BLKNO</a></h2>
refcount blocks contain a record of the disk block where they are located. An
  refcount block was found at a block that didn't match its recorded location.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will update the data structure in the refcount block to reflect
  its real location on disk.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="RB_GEN"><a class="selflink" href="#RB_GEN">RB_GEN</a></h2>
Refcount blocks are created with a generation number to match the generation
  number of the volume at the time of creation. An refcount block was found
  which contains a generation number that doesn't match.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes implies that the generation number is correct and that the
  refcount block is from a previous file system. The refcount block will be
  removed and the file that uses it will lose the refcounted information, but it
  may be regenerated later.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="RB_GEN_FIX"><a class="selflink" href="#RB_GEN_FIX">RB_GEN_FIX</a></h2>
Refcount blocks are created with a generation number to match the generation
  number of the volume at the time of creation. An refcount block was found
  which contains a generation number that doesn't match.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes implies that the generation number in the refcount block is
  incorrect and that the refcount block is valid. The generation number in the
  block is updated to match the generation number in the volume.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="RB_PARENT"><a class="selflink" href="#RB_PARENT">RB_PARENT</a></h2>
refcount blocks contain a record of the parent this disk block belongs to. An
  refcount block was found storing a wrong parent location.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will update the data structure in the refcount block to reflect
  its parent's real location on disk.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_LIST_COUNT"><a class="selflink" href="#REFCOUNT_LIST_COUNT">REFCOUNT_LIST_COUNT</a></h2>
The number of entries in a refcount list is bounded by the size of the block
  which contains it. An refcount list was found which claims to have more
  entries than would fit in its container.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes updates the count field in the refcount list to match the
  container. Answering no to this question may stop further fixes from being
  done because the count value can not be trusted.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_LIST_USED"><a class="selflink" href="#REFCOUNT_LIST_USED">REFCOUNT_LIST_USED</a></h2>
The number of free entries in a refcount list must be less than the total number
  of entries in the list. A list was found which claims to have more free
  entries than possible entries.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes sets the number of free entries in the list equal to the total
  possible entries.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_CLUSTER_RANGE"><a class="selflink" href="#REFCOUNT_CLUSTER_RANGE">REFCOUNT_CLUSTER_RANGE</a></h2>
A refcount record was found which references a cluster which can not be
  referenced by a refcount. The referenced cluster is either very early in the
  volume, and thus reserved, or beyond the end of the volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes removes this refcount record from the tree.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_CLUSTER_COLLISION"><a class="selflink" href="#REFCOUNT_CLUSTER_COLLISION">REFCOUNT_CLUSTER_COLLISION</a></h2>
A refcount record was found which references a cluster which has a collision
  with the previous valid refcount record.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes removes this refcount record from the tree.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_LIST_EMPTY"><a class="selflink" href="#REFCOUNT_LIST_EMPTY">REFCOUNT_LIST_EMPTY</a></h2>
A refcount list was found which has no refcount record in it. It is normally
  caused by a corrupted refcount record.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes removes this refcount block from the tree. It will be re-generated
  in refcounted extent records handler if all the other information is sane.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_BLOCK_INVALID"><a class="selflink" href="#REFCOUNT_BLOCK_INVALID">REFCOUNT_BLOCK_INVALID</a></h2>
Refcount block stores the refcount record for physical clusters of a file. It is
  found refering an invalid refcount block.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes remove this refcount block.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_CLUSTERS"><a class="selflink" href="#REFCOUNT_CLUSTERS">REFCOUNT_CLUSTERS</a></h2>
Refcount tree contains a record of how many clusters are allocated to them. A
  tree was found whose recorded number of clusters doesn't match the number of
  blocks that were found associated with it.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the number of clusters to reflect the real number of
  clusters that were associated with the tree.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_ROOT_BLOCK_INVALID"><a class="selflink" href="#REFCOUNT_ROOT_BLOCK_INVALID">REFCOUNT_ROOT_BLOCK_INVALID</a></h2>
Root refcount block is the root of the refcount record for a file. It is found
  refering an invalid refcount block.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes remove this refcount block and clear refcount flag from this file.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_REC_REDUNDANT"><a class="selflink" href="#REFCOUNT_REC_REDUNDANT">REFCOUNT_REC_REDUNDANT</a></h2>
Refcount record is used to store the refcount for physical clusters. Some
  refcount record is found to have no physical clusters corresponding to it.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes remove the refcount record.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_COUNT_INVALID"><a class="selflink" href="#REFCOUNT_COUNT_INVALID">REFCOUNT_COUNT_INVALID</a></h2>
Refcount record is used to store the refcount for physical clusters. A record
  record is found whichs claims the wrong refcount for some physical clusters.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes update the corresponding refcount record.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="REFCOUNT_COUNT"><a class="selflink" href="#REFCOUNT_COUNT">REFCOUNT_COUNT</a></h2>
Refcount tree contains a record of how many files refering to this tree. A tree
  was found whose recorded number of files doesn't match the real files refering
  to the tree.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the number of files to reflect the real number of files
  that were associated with the tree.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DUP_CLUSTERS_SYSFILE_CLONE"><a class="selflink" href="#DUP_CLUSTERS_SYSFILE_CLONE">DUP_CLUSTERS_SYSFILE_CLONE</a></h2>
A system file inode claims clusters that are also claimed by another inode.
  ocfs2 does not allow this. System files may be cloned but may not be deleted.
  Allocation system files may not be cloned or deleted.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will copy the data of this inode to newly allocated extents. This
  will break the claim on the overcommitted clusters.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DUP_CLUSTERS_CLONE"><a class="selflink" href="#DUP_CLUSTERS_CLONE">DUP_CLUSTERS_CLONE</a></h2>
An inode claims clusters that are also claimed by another inode. ocfs2 does not
  allow this.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will copy the data of this inode to newly allocated extents. This
  will break the claim on the overcommitted clusters.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DUP_CLUSTERS_DELETE"><a class="selflink" href="#DUP_CLUSTERS_DELETE">DUP_CLUSTERS_DELETE</a></h2>
An inode claims clusters that are also claimed by another inode. ocfs2 does not
  allow this.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove this inode, thus breaking its claim on the
  overcommitted clusters.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DUP_CLUSTERS_ADD_REFCOUNT"><a class="selflink" href="#DUP_CLUSTERS_ADD_REFCOUNT">DUP_CLUSTERS_ADD_REFCOUNT</a></h2>
An inode claims clusters that are also claimed by another inode. ocfs2 does not
  allow this.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will try to add a refcount record for all these inodes, so that
  they will share the cluster.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_DOTTY_DUP"><a class="selflink" href="#DIRENT_DOTTY_DUP">DIRENT_DOTTY_DUP</a></h2>
There can be only one instance of both the &quot;.&quot; and &quot;..&quot;
  entries in a directory. A directory entry was found which duplicated one of
  these entries.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the duplicate directory entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_NOT_DOTTY"><a class="selflink" href="#DIRENT_NOT_DOTTY">DIRENT_NOT_DOTTY</a></h2>
The first and second directory entries in a directory must be &quot;.&quot; and
  &quot;..&quot; respectively. One of these directory entries was found to not
  match these rules.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will force the directory entry to be either &quot;.&quot; or
  &quot;..&quot;. This might consume otherwise valid entries and cause some
  files to appear in lost+found.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_DOT_INODE"><a class="selflink" href="#DIRENT_DOT_INODE">DIRENT_DOT_INODE</a></h2>
The inode field of the &quot;.&quot; directory entry must refer to the directory
  inode that contains the given directory block. A &quot;.&quot; entry was found
  which doesn't do so.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes sets the directory entry's inode reference to the parent directory
  that contains the entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_DOT_EXCESS"><a class="selflink" href="#DIRENT_DOT_EXCESS">DIRENT_DOT_EXCESS</a></h2>
A &quot;.&quot; directory entry was found whose lengths exceeds the amount
  required for the single dot in the name.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes creates another empty directory entry in this excess space.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_ZERO"><a class="selflink" href="#DIRENT_ZERO">DIRENT_ZERO</a></h2>
A directory entry was found with a zero length name.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears the directory entry so its space can be reused.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_NAME_CHARS"><a class="selflink" href="#DIRENT_NAME_CHARS">DIRENT_NAME_CHARS</a></h2>
Directory entries can not contain either the NULL character (ASCII 0) or the
  forward slash (ASCII 47). A directory entry was found which contains either.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will change each instance of these forbidden characters into a
  period (ASCII 46).
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_INODE_RANGE"><a class="selflink" href="#DIRENT_INODE_RANGE">DIRENT_INODE_RANGE</a></h2>
Each directory entry contains a inode field which the entry's name corresponds
  to. An entry was found which referenced an inode number that is invalid for
  the current volume.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears this entry so its space can be reused. If the entry once
  corresponded to a real inode and was corrupted this inode may appear in
  lost+found.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_INODE_FREE"><a class="selflink" href="#DIRENT_INODE_FREE">DIRENT_INODE_FREE</a></h2>
Each directory entry contains a inode field which the entry's name corresponds
  to. An entry was found which referenced an inode number that isn't in use.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears this directory entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_TYPE"><a class="selflink" href="#DIRENT_TYPE">DIRENT_TYPE</a></h2>
Each directory entry contains a field which describes the type of file that the
  entry refers to. An entry was found whose type doesn't match the inode it is
  referring to.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the entry's type to match the target inode.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_PARENT_DUP"><a class="selflink" href="#DIR_PARENT_DUP">DIR_PARENT_DUP</a></h2>
Each directory can only be pointed to by one directory entry in a parent
  directory. A directory entry was found which was the second entry to point to
  a given directory inode.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes clears this entry which was the second to refer to a given
  directory. This reflects the policy that hard links to directories are not
  allowed.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_DUPLICATE"><a class="selflink" href="#DIRENT_DUPLICATE">DIRENT_DUPLICATE</a></h2>
File names within a directory must be unique. A file name occurred in more than
  one directory entry in a given directory.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes renames the duplicate entry to a name that doesn't collide with
  recent entries and is unlikely to collide with future entries in the
  directory.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIRENT_LENGTH"><a class="selflink" href="#DIRENT_LENGTH">DIRENT_LENGTH</a></h2>
There are very few directory entry lengths that are valid. The lengths must be
  greater than the minimum required to record a single character directory, be
  rounded to 12 bytes, be within the amount of space remaining in a directory
  block, and be properly rounded for the size of the name of the directory
  entry. An entry was found which didn't meet these criteria.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will try to repair the directory entry. This runs a very good
  chance of invalidating all the entries in the directory block. Orphaned inodes
  may appear in lost+found.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_TRAILER_INODE"><a class="selflink" href="#DIR_TRAILER_INODE">DIR_TRAILER_INODE</a></h2>
A directory block trailer is a fake directory entry at the end of the block. The
  trailer has compatibility fields for when it is viewed as a directory entry.
  The inode field must be zero.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the inode field to zero.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_TRAILER_NAME_LEN"><a class="selflink" href="#DIR_TRAILER_NAME_LEN">DIR_TRAILER_NAME_LEN</a></h2>
A directory block trailer is a fake directory entry at the end of the block. The
  trailer has compatibility fields for when it is viewed as a directory entry.
  The name length field must be zero.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the name length field to zero.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_TRAILER_REC_LEN"><a class="selflink" href="#DIR_TRAILER_REC_LEN">DIR_TRAILER_REC_LEN</a></h2>
A directory block trailer is a fake directory entry at the end of the block. The
  trailer has compatibility fields for when it is viewed as a directory entry.
  The record length field must be equal to the size of the trailer.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the record length field to the size of the trailer.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_TRAILER_BLKNO"><a class="selflink" href="#DIR_TRAILER_BLKNO">DIR_TRAILER_BLKNO</a></h2>
A directory block trailer is a fake directory entry at the end of the block. The
  self-referential block number is incorrect.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the block number to the correct block on disk.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_TRAILER_PARENT_INODE"><a class="selflink" href="#DIR_TRAILER_PARENT_INODE">DIR_TRAILER_PARENT_INODE</a></h2>
A directory block trailer is a fake directory entry at the end of the block. It
  has a pointer to the directory inode it belongs to. This pointer is incorrect.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set the parent inode pointer to the inode referencing this
  directory block.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="ROOT_DIR_MISSING"><a class="selflink" href="#ROOT_DIR_MISSING">ROOT_DIR_MISSING</a></h2>
The super block contains a reference to the inode that serves as the root
  directory. This reference points to an inode that isn't in use.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will create a new inode and update the super block to refer to
  this inode as the root directory.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="LOSTFOUND_MISSING"><a class="selflink" href="#LOSTFOUND_MISSING">LOSTFOUND_MISSING</a></h2>
The super block contains a reference to the inode that serves as the lost+found
  directory. This reference points to an inode that isn't in use.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will create a new lost+found directory in the root directory.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_NOT_CONNECTED"><a class="selflink" href="#DIR_NOT_CONNECTED">DIR_NOT_CONNECTED</a></h2>
Every directory in the file system should be reachable by a directory entry in
  its parent directory. This is verified by walking every directory in the
  system. A directory inode was found during this walk which doesn't have a
  parent directory entry.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes moves this directory entry into the lost+found directory and gives
  it a name based on its inode number.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DIR_DOTDOT"><a class="selflink" href="#DIR_DOTDOT">DIR_DOTDOT</a></h2>
A directory inode's &quot;..&quot; directory entry must refer to the parent
  directory. A directory was found whose &quot;..&quot; doesn't refer to its
  parent.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will read the directory block for the given directory and update
  its &quot;..&quot; entry to reflect its parent.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_NOT_CONNECTED"><a class="selflink" href="#INODE_NOT_CONNECTED">INODE_NOT_CONNECTED</a></h2>
Most all inodes in the system should be referenced by a directory entry. An
  inode was found which isn't referred to by any directory entry.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes moves this inode into the lost+found directory and gives it a name
  based on its inode number.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_COUNT"><a class="selflink" href="#INODE_COUNT">INODE_COUNT</a></h2>
Each inode records the number of directory entries that refer to it. An inode
  was found whose recorded count doesn't match the number of entries that refer
  to it.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes sets the inode's count to match the number of referring directory
  entries.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INODE_ORPHANED"><a class="selflink" href="#INODE_ORPHANED">INODE_ORPHANED</a></h2>
While files are being deleted they are placed in an internal directory. If the
  machine crashes while this is taking place the files will be left in this
  directory. Fsck has found an inode in this directory and would like to finish
  the job of truncating and removing it.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes removes the file data associated with the inode and frees the
  inode.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="RECOVER_BACKUP_SUPERBLOCK"><a class="selflink" href="#RECOVER_BACKUP_SUPERBLOCK">RECOVER_BACKUP_SUPERBLOCK</a></h2>
When <i>fsck.ocfs2</i> successfully uses the specified backup superblock, it
  provides the user with this option to overwrite the existing superblock with
  that backup.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will refresh the superblock from the backup. Answering no will
  only disable the copying of the backup superblock and will not effect the
  remaining <i>fsck.ocfs2</i> processing.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="ORPHAN_DIR_MISSING"><a class="selflink" href="#ORPHAN_DIR_MISSING">ORPHAN_DIR_MISSING</a></h2>
While files are being deleted they are placed in an internal directory, named
  orphan directory. If an orphan directory does not exist, an OCFS2 volume
  cannot be mounted successfully. Fsck has found the orphan directory is missing
  and would like to create it for future use.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes creates the orphan directory in the system directory.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="JOURNAL_FILE_INVALID"><a class="selflink" href="#JOURNAL_FILE_INVALID">JOURNAL_FILE_INVALID</a></h2>
OCFS2 uses JDB for journalling and some journal files exist in the system
  directory. Fsck has found some journal files that are invalid.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes to this question will regenerate the invalid journal files.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="JOURNAL_UNKNOWN_FEATURE"><a class="selflink" href="#JOURNAL_UNKNOWN_FEATURE">JOURNAL_UNKNOWN_FEATURE</a></h2>
Fsck has found some journal files with unknown features. Other journals on the
  filesystem have only known features, so this is likely a corruption. If you
  think your filesystem may be newer than this version of fsck.ocfs2, say N here
  and grab the latest version of fsck.ocfs2.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes resets the journal features to match other journals.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="JOURNAL_MISSING_FEATURE"><a class="selflink" href="#JOURNAL_MISSING_FEATURE">JOURNAL_MISSING_FEATURE</a></h2>
Fsck has found some journal files have features that are not set on all journal
  files. All journals on filesystem should have the same set of features.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will set all journals to the union of set features.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="JOURNAL_TOO_SMALL"><a class="selflink" href="#JOURNAL_TOO_SMALL">JOURNAL_TOO_SMALL</a></h2>
Fsck has found some journal files are too small.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes extends these journals.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="RECOVER_CLUSTER_INFO"><a class="selflink" href="#RECOVER_CLUSTER_INFO">RECOVER_CLUSTER_INFO</a></h2>
The currently active cluster stack is different than the one the filesystem is
  configured for. Thus, fsck.ocfs2 cannot determine whether the filesystem is
  mounted on an another node or not. The recommended solution is to exit and run
  fsck.ocfs2 on this device from a node that has the appropriate active cluster
  stack. However, you can proceed with the fsck if you are sure that the volume
  is not in use on any node.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes reconfigures the filesystem to use the current cluster stack.
  DANGER: YOU MUST BE ABSOLUTELY SURE THAT NO OTHER NODE IS USING THIS
  FILESYSTEM BEFORE CONTINUING. OTHERWISE, YOU CAN CORRUPT THE FILESYSTEM AND
  LOSE DATA.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INLINE_DATA_FLAG_INVALID"><a class="selflink" href="#INLINE_DATA_FLAG_INVALID">INLINE_DATA_FLAG_INVALID</a></h2>
Inline file can only exist in a volume with inline supported, Fsck has found
  that a file in a non-inline volume has inline flag set.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes remove this flag from the file.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="INLINE_DATA_COUNT_INVALID"><a class="selflink" href="#INLINE_DATA_COUNT_INVALID">INLINE_DATA_COUNT_INVALID</a></h2>
For an inline file, there is a limit for id2.id_data.id_count. Fsck has found
  that this value isn't right.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes change this value to the right number.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_BLOCK_INVALID"><a class="selflink" href="#XATTR_BLOCK_INVALID">XATTR_BLOCK_INVALID</a></h2>
Extended attributes are stored off an extended attribute block referenced by the
  inode. This inode references an invalid extended attribute block.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove this block.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_COUNT_INVALID"><a class="selflink" href="#XATTR_COUNT_INVALID">XATTR_COUNT_INVALID</a></h2>
The count of extended attributes in an inode, block, or bucket does not match
  the number of entries found by fsck.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will change this to the correct count.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_ENTRY_INVALID"><a class="selflink" href="#XATTR_ENTRY_INVALID">XATTR_ENTRY_INVALID</a></h2>
An extended attribute entry points to already used space.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove this entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_NAME_OFFSET_INVALID"><a class="selflink" href="#XATTR_NAME_OFFSET_INVALID">XATTR_NAME_OFFSET_INVALID</a></h2>
The name_offset field of an extended attribute entry is not correct. Without a
  correct name_offset field, the entry cannot be used.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove this entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_VALUE_INVALID"><a class="selflink" href="#XATTR_VALUE_INVALID">XATTR_VALUE_INVALID</a></h2>
The value region of an extended attribute points to already used space.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove this entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_LOCATION_INVALID"><a class="selflink" href="#XATTR_LOCATION_INVALID">XATTR_LOCATION_INVALID</a></h2>
The xe_local field and xe_value_size field of an extended attribute entry does
  not match. So the entry cannot be used.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove this entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_HASH_INVALID"><a class="selflink" href="#XATTR_HASH_INVALID">XATTR_HASH_INVALID</a></h2>
Extended attributes use a hash of their name for lookup purposes. The name_hash
  of this extended attribute entry is not correct.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will change this to the correct hash.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_FREE_START_INVALID"><a class="selflink" href="#XATTR_FREE_START_INVALID">XATTR_FREE_START_INVALID</a></h2>
Extended attributes use free_start to indicate the offset of the free space in
  inode, block, or bucket. The free_start field of this object is not correct.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will change this to the correct offset.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_VALUE_LEN_INVALID"><a class="selflink" href="#XATTR_VALUE_LEN_INVALID">XATTR_VALUE_LEN_INVALID</a></h2>
Extended attributes use name_value_len to store the total length of all entry's
  name and value in inode, block or bucket. the name_value_len filed of this
  object is not correct.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will change this to the correct value.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="XATTR_BUCKET_COUNT_INVALID"><a class="selflink" href="#XATTR_BUCKET_COUNT_INVALID">XATTR_BUCKET_COUNT_INVALID</a></h2>
The count of extended attributes bucket pointed by one extent record does not
  match the number of buckets found by fsck.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will change this to the correct count.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="QMAGIC_INVALID"><a class="selflink" href="#QMAGIC_INVALID">QMAGIC_INVALID</a></h2>
The magic number in the header of quota file does not match the proper number.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will make fsck use values in the quota file header anyway.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="QTREE_BLK_INVALID"><a class="selflink" href="#QTREE_BLK_INVALID">QTREE_BLK_INVALID</a></h2>
Block with references to other blocks with quota data is corrupted.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will make fsck use references in the block.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DQBLK_INVALID"><a class="selflink" href="#DQBLK_INVALID">DQBLK_INVALID</a></h2>
The structure with quota limits was found in a corrupted block.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will use the values of limits for the user / group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DUP_DQBLK_INVALID"><a class="selflink" href="#DUP_DQBLK_INVALID">DUP_DQBLK_INVALID</a></h2>
The structure with quota limits was found in a corrupted block and fsck has
  already found quota limits for this user / group.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will use new values of limits for the user / group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DUP_DQBLK_VALID"><a class="selflink" href="#DUP_DQBLK_VALID">DUP_DQBLK_VALID</a></h2>
The structure with quota limits was found in a correct block but fsck has
  already found quota limits for this user / group.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will use new values of limits for the user / group.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="IV_DX_TREE"><a class="selflink" href="#IV_DX_TREE">IV_DX_TREE</a></h2>
A directory index was found on an inode but that feature is not enabled on the
  file system.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will truncate the invalid index.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DX_LOOKUP_FAILED"><a class="selflink" href="#DX_LOOKUP_FAILED">DX_LOOKUP_FAILED</a></h2>
A directory entry is missing an entry in the directory index. The missing index
  entry will cause lookups on this name to fail.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will rebuild the directory index, restoring the missing entry.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="NO_HOLES"><a class="selflink" href="#NO_HOLES">NO_HOLES</a></h2>
A metadata structure encountered a hole where it should not. Examples of such
  structures are directories, refcount trees, dx_trees etc.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will remove the hole by updating the offset to the expected value.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="EXTENT_OVERLAP"><a class="selflink" href="#EXTENT_OVERLAP">EXTENT_OVERLAP</a></h2>
The extents of the file overlap, which means there could be two or more possible
  data for a particular offset for the file.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will serialize the extents.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DX_TREE_CORRUPT"><a class="selflink" href="#DX_TREE_CORRUPT">DX_TREE_CORRUPT</a></h2>
The index tree of the directory is corrupt.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will rebuild the directory index, in pass 2.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="DX_TREE_MISSING"><a class="selflink" href="#DX_TREE_MISSING">DX_TREE_MISSING</a></h2>
The index of this directory is missing.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will rebuild the directory index.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="BAD_CRC32"><a class="selflink" href="#BAD_CRC32">BAD_CRC32</a></h2>
The metadata block has a bad CRC32, which means either the block or the crc32
  field is corrupted.
<div style="height: 1.00em;">&#x00A0;</div>
Answering yes will recalculate the CRC32.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>debugfs.ocfs2(8)</b> <b>fsck.ocfs2(8)</b> <b>mkfs.ocfs2(8)</b>
  <b>mount.ocfs2(8)</b> <b>mounted.ocfs2(8)</b> <b>o2cluster(8)</b>
  <b>o2image(8)</b> <b>o2info(1)</b> <b>tunefs.ocfs2(8)</b>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Oracle Corporation.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright &#x00A9; 2004, 2012 Oracle. All rights reserved.</div>
<table class="foot">
  <tr>
    <td class="foot-date">January 2012</td>
    <td class="foot-os">Version 1.8.4</td>
  </tr>
</table>
</body>
</html>
