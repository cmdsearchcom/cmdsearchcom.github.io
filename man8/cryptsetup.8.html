<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:09:49 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CRYPTSETUP(8) Maintenance Commands CRYPTSETUP(8)</p>

<p style="margin-top: 1em">NAME <br>
cryptsetup - manage plain dm-crypt and LUKS encrypted
volumes</p>

<p style="margin-top: 1em">SYNOPSIS <br>
cryptsetup &lt;options&gt; &lt;action&gt; &lt;action
args&gt;</p>

<p style="margin-top: 1em">DESCRIPTION <br>
cryptsetup is used to conveniently setup dm-crypt managed
device-mapper mappings. These include plain dm-crypt volumes
and LUKS volumes. The difference is that LUKS uses a
meta&acirc; <br>
data header and can hence offer more features than plain
dm-crypt. On the other hand, the header is visible and
vulnerable to damage.</p>

<p style="margin-top: 1em">In addition, cryptsetup provides
limited support for the use of historic loopaes volumes and
for TrueCrypt compatible volumes.</p>

<p style="margin-top: 1em">PLAIN DM-CRYPT OR LUKS? <br>
Unless you understand the cryptographic background well, use
LUKS. With plain dm-crypt there are a number of possible
user errors that massively decrease security. While LUKS
<br>
cannot fix them all, it can lessen the impact for many of
them.</p>

<p style="margin-top: 1em">WARNINGS <br>
A lot of good information on the risks of using encrypted
storage, on handling problems and on security aspects can be
found in the Cryptsetup FAQ. Read it. Nonetheless, some <br>
risks deserve to be mentioned here.</p>

<p style="margin-top: 1em">Backup: Storage media die.
Encryption has no influence on that. Backup is mandatory for
encrypted data as well, if the data has any worth. See the
Cryptsetup FAQ for advice on <br>
how to do backup of an encrypted volume.</p>

<p style="margin-top: 1em">Character encoding: If you enter
a passphrase with special symbols, the passphrase can change
depending character encoding. Keyboard settings can also
change, which can make <br>
blind input hard or impossible. For example, switching from
some ASCII 8-bit variant to UTF-8 can lead to a different
binary encoding and hence different passphrase seen by <br>
cryptsetup, even if what you see on the terminal is exactly
the same. It is therefore highly recommended to select
passphrase characters only from 7-bit ASCII, as the encoding
<br>
for 7-bit ASCII stays the same for all ASCII variants and
UTF-8.</p>

<p style="margin-top: 1em">LUKS header: If the header of a
LUKS volume gets damaged, all data is permanently lost
unless you have a header-backup. If a key-slot is damaged,
it can only be restored from a <br>
header-backup or if another active key-slot with known
passphrase is undamaged. Damaging the LUKS header is
something people manage to do with surprising frequency.
This risk is <br>
the result of a trade-off between security and safety, as
LUKS is designed for fast and secure wiping by just
overwriting header and key-slot area.</p>

<p style="margin-top: 1em">Previously used partitions: If a
partition was previously used, it is a very good idea to
wipe filesystem signatures, data, etc. before creating a
LUKS or plain dm-crypt con&acirc; <br>
tainer on it. For a quick removal of filesystem signatures,
use &quot;wipefs&quot;. Take care though that this may not
remove everything. In particular md (RAID) signatures at the
end of <br>
a device may survive. It also does not remove data. For a
full wipe, overwrite the whole partition before container
creation. If you do not know how to to that, the cryptsetup
<br>
FAQ describes several options.</p>

<p style="margin-top: 1em">BASIC COMMANDS <br>
The following are valid actions for all supported device
types.</p>

<p style="margin-top: 1em">open &lt;device&gt; &lt;name&gt;
--type &lt;device_type&gt;</p>

<p style="margin-top: 1em">Opens (creates a mapping with)
&lt;name&gt; backed by device &lt;device&gt;.</p>

<p style="margin-top: 1em">Device type can be plain, luks
(default), loopaes or tcrypt.</p>

<p style="margin-top: 1em">For backward compatibility there
are open command aliases:</p>

<p style="margin-top: 1em">create (argument-order
&lt;name&gt; &lt;device&gt;): open --type plain <br>
plainOpen: open --type plain <br>
luksOpen: open --type luks <br>
loopaesOpen: open --type loopaes <br>
tcryptOpen: open --type tcrypt</p>

<p style="margin-top: 1em">&lt;options&gt; are type
specific and are described below for individual device
types. For create, the order of the &lt;name&gt; and
&lt;device&gt; options is inverted for historical rea&acirc;
<br>
sons, all other aliases use the standard &lt;device&gt;
&lt;name&gt; order.</p>

<p style="margin-top: 1em">close &lt;name&gt;</p>

<p style="margin-top: 1em">Removes the existing mapping
&lt;name&gt; and wipes the key from kernel memory.</p>

<p style="margin-top: 1em">For backward compatibility there
are close command aliases: remove, plainClose, luksClose,
loopaesClose, tcryptClose (all behaves exactly the same,
device type is deter&acirc; <br>
mined automatically from active device).</p>

<p style="margin-top: 1em">status &lt;name&gt;</p>

<p style="margin-top: 1em">Reports the status for the
mapping &lt;name&gt;.</p>

<p style="margin-top: 1em">resize &lt;name&gt;</p>

<p style="margin-top: 1em">Resizes an active mapping
&lt;name&gt;.</p>

<p style="margin-top: 1em">If --size (in sectors) is not
specified, the size of the underlying block device is used.
Note that this does not change the raw device geometry, it
just changes how many <br>
sectors of the raw device are represented in the mapped
device.</p>

<p style="margin-top: 1em">PLAIN MODE <br>
Plain dm-crypt encrypts the device sector-by-sector with a
single, non-salted hash of the passphrase. No checks are
performed, no metadata is used. There is no formatting
opera&acirc; <br>
tion. When the raw device is mapped (opened), the usual
device operations can be used on the mapped device,
including filesystem creation. Mapped devices usually reside
in <br>
/dev/mapper/&lt;name&gt;.</p>

<p style="margin-top: 1em">The following are valid plain
device type actions:</p>

<p style="margin-top: 1em">open --type plain &lt;device&gt;
&lt;name&gt; <br>
create &lt;name&gt; &lt;device&gt; (OBSOLETE syntax)</p>

<p style="margin-top: 1em">Opens (creates a mapping with)
&lt;name&gt; backed by device &lt;device&gt;.</p>

<p style="margin-top: 1em">&lt;options&gt; can be [--hash,
--cipher, --verify-passphrase, --key-file, --keyfile-offset,
--key-size, --offset, --skip, --size, --readonly, --shared,
--allow-discards]</p>

<p style="margin-top: 1em">Example: &rsquo;cryptsetup open
--type plain /dev/sda10 e1&rsquo; maps the raw encrypted
device /dev/sda10 to the mapped (decrypted) device
/dev/mapper/e1, which can then be mounted, <br>
fsck-ed or have a filesystem created on it.</p>

<p style="margin-top: 1em">LUKS EXTENSION <br>
LUKS, the Linux Unified Key Setup, is a standard for disk
encryption. It adds a standardized header at the start of
the device, a key-slot area directly behind the header and
<br>
the bulk data area behind that. The whole set is called a
&rsquo;LUKS container&rsquo;. The device that a LUKS
container resides on is called a &rsquo;LUKS device&rsquo;.
For most purposes both terms <br>
can be used interchangeably. But note that when the LUKS
header is at a nonzero offset in a device, then the device
is not a LUKS device anymore, but has a LUKS container
stored <br>
in it at an offset.</p>

<p style="margin-top: 1em">LUKS can manage multiple
passphrases that can be individually revoked or changed and
that can be securely scrubbed from persistent media due to
the use of anti-forensic stripes. <br>
Passphrases are protected against brute-force and dictionary
attacks by PBKDF2, which implements hash iteration and
salting in one function.</p>

<p style="margin-top: 1em">Each passphrase, also called a
key in this document, is associated with one of 8 key-slots.
Key operations that do not specify a slot affect the first
slot that matches the sup&acirc; <br>
plied passphrase or the first empty slot if a new passphrase
is added.</p>

<p style="margin-top: 1em">The &lt;device&gt; parameter can
be also specified by a LUKS UUID in the format
UUID=&lt;uuid&gt;. Translation to real device name uses
symlinks in /dev/disk/by-uuid directory.</p>

<p style="margin-top: 1em">To specify a detached header,
the --header parameter can be used in all LUKS commands and
always takes precedence over positional &lt;device&gt;
parameter.</p>

<p style="margin-top: 1em">The following are valid LUKS
actions:</p>

<p style="margin-top: 1em">luksFormat &lt;device&gt;
[&lt;key file&gt;]</p>

<p style="margin-top: 1em">Initializes a LUKS partition and
sets the initial passphrase (for key-slot 0), either via
prompting or via &lt;key file&gt;. Note that if the second
argument is present, then <br>
the passphrase is taken from the file given there, without
the need to use the --key-file option. Also note that for
both forms of reading the passphrase from file you can <br>
give &rsquo;-&rsquo; as file name, which results in the
passphrase being read from stdin and the safety-question
being skipped.</p>

<p style="margin-top: 1em">You can only call luksFormat on
a LUKS device that is not mapped.</p>

<p style="margin-top: 1em">&lt;options&gt; can be [--hash,
--cipher, --verify-passphrase, --key-size, --key-slot,
--key-file (takes precedence over optional second argument),
--keyfile-offset, --key&acirc; <br>
file-size, --use-random | --use-urandom, --uuid,
--master-key-file, --iter-time, --header,
--force-password].</p>

<p style="margin-top: 1em">WARNING: Doing a luksFormat on
an existing LUKS container will make all data the old
container permanently irretrievable, unless you have a
header backup.</p>

<p style="margin-top: 1em">open --type luks &lt;device&gt;
&lt;name&gt; <br>
luksOpen &lt;device&gt; &lt;name&gt; (old syntax)</p>

<p style="margin-top: 1em">Opens the LUKS device
&lt;device&gt; and sets up a mapping &lt;name&gt; after
successful verification of the supplied passphrase. If the
passphrase is not supplied via --key-file, <br>
the command prompts for it interactively.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --keyfile-offset, --keyfile-size, --readonly,
--test-passphrase, --allow-discards, --header, --key-slot,
--master-key-file].</p>

<p style="margin-top: 1em">luksSuspend &lt;name&gt;</p>

<p style="margin-top: 1em">Suspends an active device (all
IO operations will blocked and accesses to the device will
wait indefinitely) and wipes the encryption key from kernel
memory. Needs kernel <br>
2.6.19 or later.</p>

<p style="margin-top: 1em">After this operation you have to
use luksResume to reinstate the encryption key and unblock
the device or close to remove the mapped device.</p>

<p style="margin-top: 1em">WARNING: never suspend the
device on which the cryptsetup binary resides.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--header].</p>

<p style="margin-top: 1em">luksResume &lt;name&gt;</p>

<p style="margin-top: 1em">Resumes a suspended device and
reinstates the encryption key. Prompts interactively for a
passphrase if --key-file is not given.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --keyfile-size, --header]</p>

<p style="margin-top: 1em">luksAddKey &lt;device&gt;
[&lt;key file with new key&gt;]</p>

<p style="margin-top: 1em">adds a new passphrase. An
existing passphrase must be supplied interactively or via
--key-file. The new passphrase to be added can be specified
interactively or read from <br>
the file given as positional argument.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --keyfile-offset, --keyfile-size,
--new-keyfile-offset, --new-keyfile-size, --key-slot,
--master-key-file, --iter-time, --force-password, <br>
--header].</p>

<p style="margin-top: 1em">luksRemoveKey &lt;device&gt;
[&lt;key file with passphrase to be removed&gt;]</p>

<p style="margin-top: 1em">Removes the supplied passphrase
from the LUKS device. The passphrase to be removed can be
specified interactively, as positional argument or via
--key-file.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --keyfile-offset, --keyfile-size, --header]</p>

<p style="margin-top: 1em">WARNING: If you read the
passphrase from stdin (without further argument or with
&rsquo;-&rsquo; as argument to --key-file), batch-mode (-q)
will be implicitely switched on and no <br>
warning will be given when you remove the last remaining
passphrase from a LUKS container. Removing the last
passphrase makes the LUKS container permanently
inaccessible.</p>

<p style="margin-top: 1em">luksChangeKey &lt;device&gt;
[&lt;new key file&gt;]</p>

<p style="margin-top: 1em">Changes an existing passphrase.
The passphrase to be changed must be supplied interactively
or via --key-file. The new passphrase can be supplied
interactively or in a <br>
file given as positional argument.</p>

<p style="margin-top: 1em">If a key-slot is specified (via
--key-slot), the passphrase for that key-slot must be given
and the new passphrase will overwrite the specified
key-slot. If no key-slot is <br>
specified and there is still a free key-slot, then the new
passphrase will be put into a free key-slot before the
key-slot containing the old passphrase is purged. If <br>
there is no free key-slot, then the key-slot with the old
passphrase is overwritten directly.</p>

<p style="margin-top: 1em">WARNING: If a key-slot is
overwritten, a media failure during this operation can cause
the overwrite to fail after the old passphrase has been
wiped and make the LUKS con&acirc; <br>
tainer inaccessible.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --keyfile-offset, --keyfile-size,
--new-keyfile-offset, --new-keyfile-size, --key-slot,
--force-password, --header].</p>

<p style="margin-top: 1em">luksKillSlot &lt;device&gt;
&lt;key slot number&gt;</p>

<p style="margin-top: 1em">Wipe the key-slot number &lt;key
slot&gt; from the LUKS device. Except running in batch-mode
(-q) a remaining passphrase must be supplied, either
interactively or via --key- <br>
file. This command can remove the last remaining key-slot,
but requires an interactive confirmation when doing so.
Removing the last passphrase makes a LUKS container <br>
permanently inaccessible.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --keyfile-offset, --keyfile-size,
--header].</p>

<p style="margin-top: 1em">WARNING: If you read the
passphrase from stdin (without further argument or with
&rsquo;-&rsquo; as argument to --key-file), batch-mode (-q)
will be implicitly switched on and no <br>
warning will be given when you remove the last remaining
passphrase from a LUKS container. Removing the last
passphrase makes the LUKS container permanently
inaccessible.</p>

<p style="margin-top: 1em">NOTE: If there is no passphrase
provided (on stdin or through --key-file argument) and
batch-mode (-q) is active, the key-slot is removed without
any other warning.</p>

<p style="margin-top: 1em">erase &lt;device&gt; <br>
luksErase &lt;device&gt;</p>

<p style="margin-top: 1em">Erase all keyslots and make the
LUKS container permanently inaccessible. You do not need to
provide any password for this operation.</p>

<p style="margin-top: 1em">WARNING: This operation is
irreversible.</p>

<p style="margin-top: 1em">luksUUID &lt;device&gt;</p>

<p style="margin-top: 1em">Print the UUID of a LUKS device.
<br>
Set new UUID if --uuid option is specified.</p>

<p style="margin-top: 1em">isLuks &lt;device&gt;</p>

<p style="margin-top: 1em">Returns true, if &lt;device&gt;
is a LUKS device, false otherwise. Use option -v to get
human-readable feedback. &rsquo;Command successful.&rsquo;
means the device is a LUKS device.</p>

<p style="margin-top: 1em">luksDump &lt;device&gt;</p>

<p style="margin-top: 1em">Dump the header information of a
LUKS device.</p>

<p style="margin-top: 1em">If the --dump-master-key option
is used, the LUKS device master key is dumped instead of the
keyslot info. Beware that the master key cannot be changed
and can be used to <br>
decrypt the data stored in the LUKS container without a
passphrase and even without the LUKS header. This means that
if the master key is compromised, the whole device has <br>
to be erased to prevent further access. Use this option
carefully.</p>

<p style="margin-top: 1em">In order to dump the master key,
a passphrase has to be supplied, either interactively or via
--key-file.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--dump-master-key, --key-file, --keyfile-offset,
--keyfile-size, --header].</p>

<p style="margin-top: 1em">WARNING: If --dump-master-key is
used with --key-file and the argument to --key-file is
&rsquo;-&rsquo;, no validation question will be asked and no
warning given.</p>

<p style="margin-top: 1em">luksHeaderBackup &lt;device&gt;
--header-backup-file &lt;file&gt;</p>

<p style="margin-top: 1em">Stores a binary backup of the
LUKS header and keyslot area. <br>
Note: Using &rsquo;-&rsquo; as filename writes the header
backup to a file named &rsquo;-&rsquo;.</p>

<p style="margin-top: 1em">WARNING: This backup file and a
passphrase valid at the time of backup allows decryption of
the LUKS data area, even if the passphrase was later changed
or removed from <br>
the LUKS device. Also note that with a header backup you
lose the ability to securely wipe the LUKS device by just
overwriting the header and key-slots. You either need to
<br>
securely erase all header backups in addition or overwrite
the encrypted data area as well. The second option is less
secure, as some sectors can survive, e.g. due to <br>
defect management.</p>

<p style="margin-top: 1em">luksHeaderRestore &lt;device&gt;
--header-backup-file &lt;file&gt;</p>

<p style="margin-top: 1em">Restores a binary backup of the
LUKS header and keyslot area from the specified file. <br>
Note: Using &rsquo;-&rsquo; as filename reads the header
backup from a file named &rsquo;-&rsquo;.</p>

<p style="margin-top: 1em">WARNING: Header and keyslots
will be replaced, only the passphrases from the backup will
work afterwards.</p>

<p style="margin-top: 1em">This command requires that the
master key size and data offset of the LUKS header already
on the device and of the header backup match. Alternatively,
if there is no LUKS <br>
header on the device, the backup will also be written to
it.</p>

<p style="margin-top: 1em">loop-AES EXTENSION <br>
cryptsetup supports mapping loop-AES encrypted partition
using a compatibility mode.</p>

<p style="margin-top: 1em">open --type loopaes
&lt;device&gt; &lt;name&gt; --key-file &lt;keyfile&gt; <br>
loopaesOpen &lt;device&gt; &lt;name&gt; --key-file
&lt;keyfile&gt; (old syntax)</p>

<p style="margin-top: 1em">Opens the loop-AES
&lt;device&gt; and sets up a mapping &lt;name&gt;.</p>

<p style="margin-top: 1em">If the key file is encrypted
with GnuPG, then you have to use --key-file=- and decrypt it
before use, e.g. like this: <br>
gpg --decrypt &lt;keyfile&gt; | cryptsetup loopaesOpen
--key-file=- &lt;device&gt; &lt;name&gt;</p>

<p style="margin-top: 1em">WARNING: The loop-AES extension
cannot use direct input of key file on real terminal because
the keys are separated by end-of-line and only part of the
multi-key file <br>
would be read. <br>
If you need it in script, just use the pipe redirection:
<br>
echo $keyfile | cryptsetup loopaesOpen --key-file=-
&lt;device&gt; &lt;name&gt;</p>

<p style="margin-top: 1em">Use --keyfile-size to specify
the proper key length if needed.</p>

<p style="margin-top: 1em">Use --offset to specify device
offset. Note that the units need to be specified in number
of 512 byte sectors.</p>

<p style="margin-top: 1em">Use --skip to specify the IV
offset. If the original device used an offset and but did
not use it in IV sector calculations, you have to explicitly
use --skip 0 in addi&acirc; <br>
tion to the offset parameter.</p>

<p style="margin-top: 1em">Use --hash to override the
default hash function for passphrase hashing (otherwise it
is detected according to key size).</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --key-size, --offset, --skip, --hash,
--readonly, --allow-discards].</p>

<p style="margin-top: 1em">See also section 7 of the FAQ
and http://loop-aes.sourceforge.net for more information
regarding loop-AES.</p>

<p style="margin-top: 1em">TCRYPT (TrueCrypt-compatible and
VeraCrypt) EXTENSION <br>
cryptsetup supports mapping of TrueCrypt, tcplay or
VeraCrypt (with --veracrypt option) encrypted partition
using a native Linux kernel API. Header formatting and
TCRYPT header <br>
change is not supported, cryptsetup never changes TCRYPT
header on-device.</p>

<p style="margin-top: 1em">TCRYPT extension requires kernel
userspace crypto API to be available (introduced in Linux
kernel 2.6.38). If you are configuring kernel yourself,
enable &quot;User-space interface <br>
for symmetric key cipher algorithms&quot; in
&quot;Cryptographic API&quot; section
(CRYPTO_USER_API_SKCIPHER .config option).</p>

<p style="margin-top: 1em">Because TCRYPT header is
encrypted, you have to always provide valid passphrase and
keyfiles.</p>

<p style="margin-top: 1em">Cryptsetup should recognize all
header variants, except legacy cipher chains using LRW
encryption mode with 64 bits encryption block (namely
Blowfish in LRW mode is not recog&acirc; <br>
nized, this is limitation of kernel crypto API).</p>

<p style="margin-top: 1em">To recognize VeraCrypt device
use --veracrypt option. VeraCrypt is just extension of
TrueCrypt header with increased iteration count so unlocking
can take quite a lot of time <br>
(in comparison with TCRYPT device).</p>

<p style="margin-top: 1em">NOTE: Activation with tcryptOpen
is supported only for cipher chains using LRW or XTS
encryption modes.</p>

<p style="margin-top: 1em">The tcryptDump command should
work for all recognized TCRYPT devices and doesn&rsquo;t
require superuser privilege.</p>

<p style="margin-top: 1em">To map system device (device
with boot loader where the whole encrypted system resides)
use --tcrypt-system option. You can use partition device as
the parameter (parameter must <br>
be real partition device, not image in file), then only this
partition is mapped.</p>

<p style="margin-top: 1em">If you have whole TCRYPT device
as a file image and you want to map multiple partition
encrypted with system encryption, please create loopback
mapping with partitions first <br>
(losetup -P, see losetup(8) man page for more info), and use
loop partition as the device parameter.</p>

<p style="margin-top: 1em">If you use whole base device as
parameter, one device for the whole system encryption is
mapped. This mode is available only for backward
compatibility with older cryptsetup ver&acirc; <br>
sions which mapped TCRYPT system encryption using whole
device.</p>

<p style="margin-top: 1em">To use hidden header (and map
hidden device, if available), use --tcrypt-hidden
option.</p>

<p style="margin-top: 1em">To explicitly use backup
(secondary) header, use --tcrypt-backup option.</p>

<p style="margin-top: 1em">NOTE: There is no protection for
a hidden volume if the outer volume is mounted. The reason
is that if there were any protection, it would require some
metadata describing what <br>
to protect in the outer volume and the hidden volume would
become detectable.</p>

<p style="margin-top: 1em">open --type tcrypt
&lt;device&gt; &lt;name&gt; <br>
tcryptOpen &lt;device&gt; &lt;name&gt; (old syntax)</p>

<p style="margin-top: 1em">Opens the TCRYPT (a
TrueCrypt-compatible) &lt;device&gt; and sets up a mapping
&lt;name&gt;.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--key-file, --tcrypt-hidden, --tcrypt-system,
--tcrypt-backup, --readonly, --test-passphrase,
--allow-discards].</p>

<p style="margin-top: 1em">The keyfile parameter allows
combination of file content with the passphrase and can be
repeated. Note that using keyfiles is compatible with TCRYPT
and is different from <br>
LUKS keyfile logic.</p>

<p style="margin-top: 1em">WARNING: Option --allow-discards
cannot be combined with option --tcrypt-hidden. For normal
mapping it can cause destruction of hidden volume (hidden
volume appears as <br>
unused space for outer volume so this space can be
discarded).</p>

<p style="margin-top: 1em">tcryptDump &lt;device&gt;</p>

<p style="margin-top: 1em">Dump the header information of a
TCRYPT device.</p>

<p style="margin-top: 1em">If the --dump-master-key option
is used, the TCRYPT device master key is dumped instead of
TCRYPT header info. Beware that the master key (or
concatenated master keys if <br>
cipher chain is used) can be used to decrypt the data stored
in the TCRYPT container without a passphrase. This means
that if the master key is compromised, the whole <br>
device has to be erased to prevent further access. Use this
option carefully.</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--dump-master-key, --key-file, --tcrypt-hidden,
--tcrypt-system, --tcrypt-backup].</p>

<p style="margin-top: 1em">The keyfile parameter allows
combination of file content with the passphrase and can be
repeated.</p>

<p style="margin-top: 1em">See also
http://www.truecrypt.org for more information regarding
TrueCrypt.</p>

<p style="margin-top: 1em">Please note that cryptsetup does
not use TrueCrypt code, please report all problems related
to this compatibility extension to cryptsetup project.</p>

<p style="margin-top: 1em">MISCELLANEOUS <br>
repair &lt;device&gt;</p>

<p style="margin-top: 1em">Tries to repair the device
metadata if possible. Currently supported only for LUKS
device type.</p>

<p style="margin-top: 1em">This command is useful to fix
some known benign LUKS metadata header corruptions. Only
basic corruptions of unused keyslot are fixable. This
command will only change the <br>
LUKS header, not any key-slot data.</p>

<p style="margin-top: 1em">WARNING: Always create a binary
backup of the original header before calling this
command.</p>

<p style="margin-top: 1em">benchmark &lt;options&gt;</p>

<p style="margin-top: 1em">Benchmarks ciphers and KDF (key
derivation function). Without parameters it tries to measure
few common configurations.</p>

<p style="margin-top: 1em">To benchmark other ciphers or
modes, you need to specify --cipher and --key-size options
or --hash for KDF test.</p>

<p style="margin-top: 1em">NOTE: This benchmark is using
memory only and is only informative. You cannot directly
predict real storage encryption speed from it.</p>

<p style="margin-top: 1em">For testing block ciphers, this
benchmark requires kernel userspace crypto API to be
available (introduced in Linux kernel 2.6.38). If you are
configuring kernel your&acirc; <br>
self, enable &quot;User-space interface for symmetric key
cipher algorithms&quot; in &quot;Cryptographic API&quot;
section (CRYPTO_USER_API_SKCIPHER .config option).</p>

<p style="margin-top: 1em">&lt;options&gt; can be
[--cipher, --key-size, --hash].</p>

<p style="margin-top: 1em">OPTIONS <br>
--verbose, -v <br>
Print more information on command execution.</p>

<p style="margin-top: 1em">--debug <br>
Run in debug mode with full diagnostic logs. Debug output
lines are always prefixed by &rsquo;#&rsquo;.</p>

<p style="margin-top: 1em">--hash, -h &lt;hash-spec&gt;
<br>
Specifies the passphrase hash for open (for plain and
loopaes device types).</p>

<p style="margin-top: 1em">Specifies the hash used in the
LUKS key setup scheme and volume key digest for luksFormat.
The specified hash is used as hash-parameter for PBKDF2 and
for the AF splitter.</p>

<p style="margin-top: 1em">The specified hash name is
passed to the compiled-in crypto backend. Different backends
may support different hashes. For luksFormat, the hash
algorithm must provide at <br>
least 160 bits of output, which excludes, e.g., MD5. Do not
use a non-crypto hash like &quot;crc32&quot; as this breaks
security.</p>

<p style="margin-top: 1em">Values compatible with old
version of cryptsetup are &quot;ripemd160&quot; for open
--type plain and &quot;sha1&quot; for luksFormat.</p>

<p style="margin-top: 1em">Use cryptsetup --help to show
the defaults.</p>

<p style="margin-top: 1em">--cipher, -c &lt;cipher-spec&gt;
<br>
Set the cipher specification string.</p>

<p style="margin-top: 1em">cryptsetup --help shows the
compiled-in defaults. The current default in the distributed
sources is &quot;aes-cbc-essiv:sha256&quot; for plain
dm-crypt and &quot;aes-xts-plain64&quot; for <br>
LUKS.</p>

<p style="margin-top: 1em">If a hash is part of the cipher
specification, then it is used as part of the IV generation.
For example, ESSIV needs a hash function, while
&quot;plain64&quot; does not and hence <br>
none is specified.</p>

<p style="margin-top: 1em">For XTS mode you can optionally
set a key size of 512 bits with the -s option. Key size for
XTS mode is twice that for other modes for the same security
level.</p>

<p style="margin-top: 1em">XTS mode requires kernel 2.6.24
or later and plain64 requires kernel 2.6.33 or later. More
information can be found in the FAQ.</p>

<p style="margin-top: 1em">--verify-passphrase, -y <br>
When interactively asking for a passphrase, ask for it twice
and complain if both inputs do not match. Advised when
creating a regular mapping for the first time, or when <br>
running luksFormat. Ignored on input from file or stdin.</p>

<p style="margin-top: 1em">--key-file, -d name <br>
Read the passphrase from file.</p>

<p style="margin-top: 1em">If the name given is
&quot;-&quot;, then the passphrase will be read from stdin.
In this case, reading will not stop at newline
characters.</p>

<p style="margin-top: 1em">With LUKS, passphrases supplied
via --key-file are always the existing passphrases requested
by a command, except in the case of luksFormat where
--key-file is equivalent <br>
to the positional key file argument.</p>

<p style="margin-top: 1em">If you want to set a new
passphrase via key file, you have to use a positional
argument to luksAddKey.</p>

<p style="margin-top: 1em">See section NOTES ON PASSPHRASE
PROCESSING for more information.</p>

<p style="margin-top: 1em">--keyfile-offset value <br>
Skip value bytes at the beginning of the key file. Works
with all commands that accepts key files.</p>

<p style="margin-top: 1em">--keyfile-size, -l value <br>
Read a maximum of value bytes from the key file. Default is
to read the whole file up to the compiled-in maximum that
can be queried with --help. Supplying more data than <br>
the compiled-in maximum aborts the operation.</p>

<p style="margin-top: 1em">This option is useful to cut
trailing newlines, for example. If --keyfile-offset is also
given, the size count starts after the offset. Works with
all commands that <br>
accepts key files.</p>

<p style="margin-top: 1em">--new-keyfile-offset value <br>
Skip value bytes at the start when adding a new passphrase
from key file with luksAddKey.</p>

<p style="margin-top: 1em">--new-keyfile-size value <br>
Read a maximum of value bytes when adding a new passphrase
from key file with luksAddKey. Default is to read the whole
file up to the compiled-in maximum length that can <br>
be queried with --help. Supplying more than the compiled in
maximum aborts the operation. When --new-keyfile-offset is
also given, reading starts after the offset.</p>

<p style="margin-top: 1em">--master-key-file <br>
Use a master key stored in a file.</p>

<p style="margin-top: 1em">For luksFormat this allows
creating a LUKS header with this specific master key. If the
master key was taken from an existing LUKS header and all
other parameters are the <br>
same, then the new header decrypts the data encrypted with
the header the master key was taken from.</p>

<p style="margin-top: 1em">WARNING: If you create your own
master key, you need to make sure to do it right. Otherwise
you can end up with a low-entropy or otherwise partially
predictable master key <br>
which will compromise security.</p>

<p style="margin-top: 1em">For luksAddKey this allows
adding a new passphrase without having to know an exiting
one.</p>

<p style="margin-top: 1em">For open this allows one to open
the LUKS device without giving a passphrase.</p>

<p style="margin-top: 1em">--dump-master-key <br>
For luksDump this option includes the master key in the
displayed information. Use with care, as the master key can
be used to bypass the passphrases, see also option <br>
--master-key-file.</p>

<p style="margin-top: 1em">--use-random</p>

<p style="margin-top: 1em">--use-urandom <br>
For luksFormat these options define which kernel random
number generator will be used to create the master key
(which is a long-term key).</p>

<p style="margin-top: 1em">See NOTES ON RANDOM NUMBER
GENERATORS for more information. Use cryptsetup --help to
show the compiled-in default random number generator.</p>

<p style="margin-top: 1em">WARNING: In a low-entropy
situation (e.g. in an embedded system), both selections are
problematic. Using /dev/urandom can lead to weak keys. Using
/dev/random can block <br>
a long time, potentially forever, if not enough entropy can
be harvested by the kernel.</p>

<p style="margin-top: 1em">--key-slot, -S &lt;0-7&gt; <br>
For LUKS operations that add key material, this options
allows you to specify which key slot is selected for the new
key. This option can be used for luksFormat, and luk&acirc;
<br>
sAddKey. <br>
In addition, for open, this option selects a specific
key-slot to compare the passphrase against. If the given
passphrase would only match a different key-slot, the
oper&acirc; <br>
ation fails.</p>

<p style="margin-top: 1em">--key-size, -s &lt;bits&gt; <br>
Sets key size in bits. The argument has to be a multiple of
8. The possible key-sizes are limited by the cipher and mode
used.</p>

<p style="margin-top: 1em">See /proc/crypto for more
information. Note that key-size in /proc/crypto is stated in
bytes.</p>

<p style="margin-top: 1em">This option can be used for open
--type plain or luksFormat. All other LUKS actions will use
the key-size specified in the LUKS header. Use cryptsetup
--help to show the <br>
compiled-in defaults.</p>

<p style="margin-top: 1em">--size, -b &lt;number of 512
byte sectors&gt; <br>
Force the size of the underlying device in sectors of 512
bytes. This option is only relevant for the open and resize
actions.</p>

<p style="margin-top: 1em">--offset, -o &lt;number of 512
byte sectors&gt; <br>
Start offset in the backend device in 512-byte sectors. This
option is only relevant for the open action with plain or
loopaes device types.</p>

<p style="margin-top: 1em">--skip, -p &lt;number of 512
byte sectors&gt; <br>
Start offset used in IV calculation in 512-byte sectors (how
many sectors of the encrypted data to skip at the
beginning). This option is only relevant for the open <br>
action with plain or loopaes device types.</p>

<p style="margin-top: 1em">Hence, if --offset n, and --skip
s, sector n (the first sector of encrypted device) will get
a sector number of s for the IV calculation.</p>

<p style="margin-top: 1em">--readonly, -r <br>
set up a read-only mapping.</p>

<p style="margin-top: 1em">--shared <br>
Creates an additional mapping for one common ciphertext
device. Arbitrary mappings are supported. This option is
only relevant for the open --type plain action. Use <br>
--offset, --size and --skip to specify the mapped area.</p>

<p style="margin-top: 1em">--iter-time, -i &lt;number of
milliseconds&gt; <br>
The number of milliseconds to spend with PBKDF2 passphrase
processing. This option is only relevant for LUKS operations
that set or change passphrases, such as luksFormat <br>
or luksAddKey. Specifying 0 as parameter selects the
compiled-in default.</p>

<p style="margin-top: 1em">--batch-mode, -q <br>
Suppresses all confirmation questions. Use with care!</p>

<p style="margin-top: 1em">If the -y option is not
specified, this option also switches off the passphrase
verification for luksFormat.</p>

<p style="margin-top: 1em">--timeout, -t &lt;number of
seconds&gt; <br>
The number of seconds to wait before timeout on passphrase
input via terminal. It is relevant every time a passphrase
is asked, for example for open, luksFormat or luksAd&acirc;
<br>
dKey. It has no effect if used in conjunction with
--key-file. <br>
This option is useful when the system should not stall if
the user does not input a passphrase, e.g. during boot. The
default is a value of 0 seconds, which means to wait <br>
forever.</p>

<p style="margin-top: 1em">--tries, -T <br>
How often the input of the passphrase shall be retried. This
option is relevant every time a passphrase is asked, for
example for open, luksFormat or luksAddKey. The <br>
default is 3 tries.</p>

<p style="margin-top: 1em">--align-payload &lt;number of
512 byte sectors&gt; <br>
Align payload at a boundary of value 512-byte sectors. This
option is relevant for luksFormat.</p>

<p style="margin-top: 1em">If not specified, cryptsetup
tries to use the topology info provided by kernel for the
underlying device to get optimal alignment. If not available
(or the calculated <br>
value is a multiple of the default) data is by default
aligned to a 1MiB boundary (i.e. 2048 512-byte sectors).</p>

<p style="margin-top: 1em">For a detached LUKS header this
option specifies the offset on the data device. See also the
--header option.</p>

<p style="margin-top: 1em">--uuid=UUID <br>
Use the provided UUID for the luksFormat command instead of
generating new one. Changes the existing UUID when used with
the luksUUID command.</p>

<p style="margin-top: 1em">The UUID must be provided in the
standard UUID format, e.g.
12345678-1234-1234-1234-123456789abc.</p>

<p style="margin-top: 1em">--allow-discards <br>
Allow the use of discard (TRIM) requests for device. This
option is only relevant for open action.</p>

<p style="margin-top: 1em">WARNING: This command can have a
negative security impact because it can make
filesystem-level operations visible on the physical device.
For example, information leaking <br>
filesystem type, used space, etc. may be extractable from
the physical device if the discarded blocks can be located
later. If in doubt, do not use it.</p>

<p style="margin-top: 1em">A kernel version of 3.1 or later
is needed. For earlier kernels this option is ignored.</p>

<p style="margin-top: 1em">--perf-same_cpu_crypt <br>
Perform encryption using the same cpu that IO was submitted
on. The default is to use an unbound workqueue so that
encryption work is automatically balanced between <br>
available CPUs. This option is only relevant for open
action.</p>

<p style="margin-top: 1em">NOTE: This option is available
only for low-level dm-crypt performance tuning, use only if
you need a change to default dm-crypt behaviour. Needs
kernel 4.0 or later.</p>

<p style="margin-top: 1em">--perf-submit_from_crypt_cpus
<br>
Disable offloading writes to a separate thread after
encryption. There are some situations where offloading write
bios from the encryption threads to a single thread <br>
degrades performance significantly. The default is to
offload write bios to the same thread. This option is only
relevant for open action.</p>

<p style="margin-top: 1em">NOTE: This option is available
only for low-level dm-crypt performance tuning, use only if
you need a change to default dm-crypt behaviour. Needs
kernel 4.0 or later.</p>

<p style="margin-top: 1em">--test-passphrase <br>
Do not activate device, just verify passphrase. This option
is only relevant for open action (the device mapping name is
not mandatory if this option is used).</p>

<p style="margin-top: 1em">--header &lt;device or file
storing the LUKS header&gt; <br>
Use a detached (separated) metadata device or file where the
LUKS header is stored. This options allows one to store
ciphertext and LUKS header on different devices.</p>

<p style="margin-top: 1em">This option is only relevant for
LUKS devices and can be used with the luksFormat, open,
luksSuspend, luksResume, status and resize commands.</p>

<p style="margin-top: 1em">For luksFormat with a file name
as argument to --header, it has to exist and be large enough
to contain the LUKS header. See the cryptsetup FAQ for
header size calcula&acirc; <br>
tion.</p>

<p style="margin-top: 1em">For other commands that change
the LUKS header (e.g. luksAddKey), specify the device or
file with the LUKS header directly as the LUKS device.</p>

<p style="margin-top: 1em">If used with luksFormat, the
--align-payload option is taken as absolute sector alignment
on ciphertext device and can be zero.</p>

<p style="margin-top: 1em">WARNING: There is no check
whether the ciphertext device specified actually belongs to
the header given. In fact you can specify an arbitrary
device as the ciphertext <br>
device for open with the --header option. Use with care.</p>

<p style="margin-top: 1em">--force-password <br>
Do not use password quality checking for new LUKS
passwords.</p>

<p style="margin-top: 1em">This option applies only to
luksFormat, luksAddKey and luksChangeKey and is ignored if
cryptsetup is built without password quality checking
support.</p>

<p style="margin-top: 1em">For more info about password
quality check, see manual page for pwquality.conf(5) and
passwdqc.conf(5).</p>

<p style="margin-top: 1em">--version <br>
Show the program version.</p>

<p style="margin-top: 1em">--usage <br>
Show short option help.</p>

<p style="margin-top: 1em">--help, -? <br>
Show help text and default parameters.</p>

<p style="margin-top: 1em">RETURN CODES <br>
Cryptsetup returns 0 on success and a non-zero value on
error.</p>

<p style="margin-top: 1em">Error codes are: 1 wrong
parameters, 2 no permission (bad passphrase), 3 out of
memory, 4 wrong device specified, 5 device already exists or
device is busy.</p>

<p style="margin-top: 1em">NOTES ON PASSPHRASE PROCESSING
FOR PLAIN MODE <br>
Note that no iterated hashing or salting is done in plain
mode. If hashing is done, it is a single direct hash. This
means that low-entropy passphrases are easy to attack in
<br>
plain mode.</p>

<p style="margin-top: 1em">From a terminal: The passphrase
is read until the first newline, i.e. &rsquo;0. The input
without the newline character is processed with the default
hash or the hash specified with <br>
--hash. The hash result will be truncated to the key size of
the used cipher, or the size specified with -s.</p>

<p style="margin-top: 1em">From stdin: Reading will
continue until a newline (or until the maximum input size is
reached), with the trailing newline stripped. The maximum
input size is defined by the same <br>
compiled-in default as for the maximum key file size and can
be overwritten using --keyfile-size option.</p>

<p style="margin-top: 1em">The data read will be hashed
with the default hash or the hash specified with --hash. The
hash result will be truncated to the key size of the used
cipher, or the size specified <br>
with -s.</p>

<p style="margin-top: 1em">Note that if --key-file=- is
used for reading the key from stdin, trailing newlines are
not stripped from the input.</p>

<p style="margin-top: 1em">If &quot;plain&quot; is used as
argument to --hash, the input data will not be hashed.
Instead, it will be zero padded (if shorter than the key
size) or truncated (if longer than the key <br>
size) and used directly as the binary key. This is useful
for directly specifying a binary key. No warning will be
given if the amount of data read from stdin is less than the
<br>
key size.</p>

<p style="margin-top: 1em">From a key file: It will be
truncated to the key size of the used cipher or the size
given by -s and directly used as binary key.</p>

<p style="margin-top: 1em">WARNING: The --hash argument is
being ignored. The --hash option is usable only for stdin
input in plain mode.</p>

<p style="margin-top: 1em">If the key file is shorter than
the key, cryptsetup will quit with an error. The maximum
input size is defined by the same compiled-in default as for
the maximum key file size <br>
and can be overwritten using --keyfile-size option.</p>

<p style="margin-top: 1em">NOTES ON PASSPHRASE PROCESSING
FOR LUKS <br>
LUKS uses PBKDF2 to protect against dictionary attacks and
to give some protection to low-entropy passphrases (see RFC
2898 and the cryptsetup FAQ).</p>

<p style="margin-top: 1em">From a terminal: The passphrase
is read until the first newline and then processed by PBKDF2
without the newline character.</p>

<p style="margin-top: 1em">From stdin: LUKS will read
passphrases from stdin up to the first newline character or
the compiled-in maximum key file length. If --keyfile-size
is given, it is ignored.</p>

<p style="margin-top: 1em">From key file: The complete
keyfile is read up to the compiled-in maximum size. Newline
characters do not terminate the input. The --keyfile-size
option can be used to limit what <br>
is read.</p>

<p style="margin-top: 1em">Passphrase processing: Whenever
a passphrase is added to a LUKS header (luksAddKey,
luksFormat), the user may specify how much the time the
passphrase processing should consume. <br>
The time is used to determine the iteration count for PBKDF2
and higher times will offer better protection for
low-entropy passphrases, but open will take longer to
complete. For <br>
passphrases that have entropy higher than the used key
length, higher iteration times will not increase
security.</p>

<p style="margin-top: 1em">The default setting of one
second is sufficient for most practical cases. The only
exception is a low-entropy passphrase used on a device with
a slow CPU, as this will result in <br>
a low iteration count. On a slow device it may be advisable
to increase the iteration time using the --iter-time option
in order to obtain a higher iteration count. This does <br>
slow down all later luksOpen operations accordingly.</p>

<p style="margin-top: 1em">INCOHERENT BEHAVIOR FOR INVALID
PASSPHRASES/KEYS <br>
LUKS checks for a valid passphrase when an encrypted
partition is unlocked. The behavior of plain dm-crypt is
different. It will always decrypt with the passphrase given.
If the <br>
given passphrase is wrong, the device mapped by plain
dm-crypt will essentially still contain encrypted data and
will be unreadable.</p>

<p style="margin-top: 1em">NOTES ON SUPPORTED CIPHERS,
MODES, HASHES AND KEY SIZES <br>
The available combinations of ciphers, modes, hashes and key
sizes depend on kernel support. See /proc/crypto for a list
of available options. You might need to load additional <br>
kernel crypto modules in order to get more options.</p>

<p style="margin-top: 1em">For the --hash option, if the
crypto backend is libgcrypt, then all algorithms supported
by the gcrypt library are available. For other crypto
backends some algorithms may be <br>
missing.</p>

<p style="margin-top: 1em">NOTES ON PASSPHRASES <br>
Mathematics can&rsquo;t be bribed. Make sure you keep your
passphrases safe. There are a few nice tricks for
constructing a fallback, when suddenly out of the blue, your
brain refuses <br>
to cooperate. These fallbacks need LUKS, as it&rsquo;s only
possible with LUKS to have multiple passphrases. Still, if
your attacker model does not prevent it, storing your
passphrase <br>
in a sealed envelope somewhere may be a good idea as
well.</p>

<p style="margin-top: 1em">NOTES ON RANDOM NUMBER
GENERATORS <br>
Random Number Generators (RNG) used in cryptsetup are always
the kernel RNGs without any modifications or additions to
data stream produced.</p>

<p style="margin-top: 1em">There are two types of
randomness cryptsetup/LUKS needs. One type (which always
uses /dev/urandom) is used for salts, the AF splitter and
for wiping deleted keyslots.</p>

<p style="margin-top: 1em">The second type is used for the
volume (master) key. You can switch between using
/dev/random and /dev/urandom here, see --use-random and
--use-urandom options. Using /dev/ran&acirc; <br>
dom on a system without enough entropy sources can cause
luksFormat to block until the requested amount of random
data is gathered. In a low-entropy situation (embedded
system), <br>
this can take a very long time and potentially forever. At
the same time, using /dev/urandom in a low-entropy situation
will produce low-quality keys. This is a serious problem,
<br>
but solving it is out of scope for a mere man-page. See
urandom(4) for more information.</p>

<p style="margin-top: 1em">NOTES ON LOOPBACK DEVICE USE
<br>
Cryptsetup is usually used directly on a block device (disk
partition or LVM volume). However, if the device argument is
a file, cryptsetup tries to allocate a loopback device <br>
and map it into this file. This mode requires Linux kernel
2.6.25 or more recent which supports the loop autoclear flag
(loop device is cleared on last close automatically). Of
<br>
course, you can always map a file to a loop-device manually.
See the cryptsetup FAQ for an example.</p>

<p style="margin-top: 1em">When device mapping is active,
you can see the loop backing file in the status command
output. Also see losetup(8).</p>

<p style="margin-top: 1em">DEPRECATED ACTIONS <br>
The reload action is no longer supported. Please use
dmsetup(8) if you need to directly manipulate with the
device mapping table.</p>

<p style="margin-top: 1em">The luksDelKey was replaced with
luksKillSlot.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs, including ones in the documentation, on the
cryptsetup mailing list at &lt;dm-crypt@saout.de&gt; or in
the &rsquo;Issues&rsquo; section on LUKS website. Please
attach the output of <br>
the failed command with the --debug option added.</p>

<p style="margin-top: 1em">AUTHORS <br>
cryptsetup originally written by Jana Saout
&lt;jana@saout.de&gt; <br>
The LUKS extensions and original man page were written by
Clemens Fruhwirth &lt;clemens@endorphin.org&gt;. <br>
Man page extensions by Milan Broz
&lt;gmazyland@gmail.com&gt;. <br>
Man page rewrite and extension by Arno Wagner
&lt;arno@wagner.name&gt;.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 2004 Jana Saout <br>
Copyright &Acirc;&copy; 2004-2006 Clemens Fruhwirth <br>
Copyright &Acirc;&copy; 2009-2015 Red Hat, Inc. <br>
Copyright &Acirc;&copy; 2009-2015 Milan Broz <br>
Copyright &Acirc;&copy; 2012-2014 Arno Wagner</p>

<p style="margin-top: 1em">This is free software; see the
source for copying conditions. There is NO warranty; not
even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.</p>

<p style="margin-top: 1em">SEE ALSO <br>
The LUKS website at
https://gitlab.com/cryptsetup/cryptsetup/</p>

<p style="margin-top: 1em">The cryptsetup FAQ, contained in
the distribution package and online at
https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions</p>

<p style="margin-top: 1em">The cryptsetup mailing list and
list archive, see FAQ entry 1.6.</p>

<p style="margin-top: 1em">The LUKS on-disk format
specification available at
https://gitlab.com/cryptsetup/cryptsetup/wikis/Specification</p>

<p style="margin-top: 1em">cryptsetup December 2013
CRYPTSETUP(8)</p>
<hr>
</body>
</html>
