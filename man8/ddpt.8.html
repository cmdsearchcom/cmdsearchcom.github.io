<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>DDPT(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DDPT(8)</td>
    <td class="head-vol">DDPT</td>
    <td class="head-rtitle">DDPT(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
ddpt - copies data between files and storage devices. Support for devices that
  understand the SCSI command set.
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>ddpt</b> [ <i>bpt=BPT[,OBPC]</i>] [<i>bs=BS</i>]
  [<i>cdbsz=</i>{6|10|12|16|32}] [ <i>coe=</i>{0|1}] [<i>coe_limit=CL</i>]
  [<i>conv=CONVS</i>] [ <i>count=COUNT</i>] [ <i>delay=MS[,W_MS]</i>]
  [<i>ibs=IBS</i>] [ <i>id_usage=LIU</i>] <i>if=IFILE</i> [ <i>iflag=FLAGS</i>]
  [ <i>intio=</i>{0|1}] [<i>iseek=SKIP</i>] [<i>ito=ITO</i>] [
  <i>list_id=LID</i>] [ <i>obs=OBS</i>] [<i>of=OFILE</i>] [<i>of2=OFILE2</i>] [
  <i>oflag=FLAGS</i>] [<i>oseek=SEEK</i>] [<i>prio=PRIO</i>] [
  <i>protect=RDP[,WRP]</i>] [ <i>retries=RETR</i>] [<i>rtf=RTF</i>] [
  <i>rtype=RTYPE</i>] [ <i>seek=SEEK</i>] [<i>skip=SKIP</i>]
  [<i>status=STAT</i>] [ <i>to=TO</i>] [<i>verbose=VERB</i>] [<i>--help</i>]
  [<i>--odx</i>] [ <i>--verbose</i>] [<i>--version</i>] [<i>--wscan</i>]
  [<i>--xcopy</i>]
<div class="Pp"></div>
For comparison here is the synopsis for GNU's dd command:
<div class="Pp"></div>
<b>dd</b> [ <i>bs=BS</i>] [<i>cbs=CBS</i>] [<i>conv=CONVS</i>]
  [<i>count=COUNT</i>] [ <i>ibs=IBS</i>] [<i>if=IFILE</i>] [<i>iflag=FLAGS</i>]
  [ <i>obs=OBS</i>] [ <i>of=OFILE</i>] [<i>oflag=FLAGS</i>] [<i>seek=SEEK</i>]
  [<i>skip=SKIP</i>] [ <i>status=STAT</i>] [<i>--help</i>] [<i>--version</i>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Copies data between files or simply reads data from a file. This utility is
  specialized for &quot;files&quot; that are storage devices, especially those
  that can use the SCSI command sets (e.g. SATA and SAS disks). It can issue
  SCSI commands in pass-through (&quot;pt&quot;) mode. Similar syntax and
  semantics to the Unix <b>dd(1)</b> command.
<div class="Pp"></div>
For comparison, the SYNOPSIS section above shows both the <b>ddpt</b> command
  line options followed by GNU's <b>dd(1)</b> command line options. Broadly
  speaking ddpt can be considered a super-set of dd. See the section on DD
  DIFFERENCES for significant differences between ddpt and dd.
<div class="Pp"></div>
This utility either does direct copies, based on read-write sequences, or
  offloaded copies. In an offloaded copy the data being copied does not
  necessarily pass through the memory of the the machine originating the copy
  operation; this can save a significant amount of time and lessen CPU usage.
<div class="Pp"></div>
When doing a direct copy, this utility breaks the copy into segments since
  computer RAM is typically a scarce resource. First it reads in <i>BPT*IBS</i>
  bytes from <i>IFILE</i> (or less if near the end of the copy) into a copy
  buffer. In the absence of the various options and conditions that bypass the
  write operation, the copy buffer is then written out to <i>OFILE</i>. The copy
  process continues working its way along <i>IFILE</i> and <i>OFILE</i> until
  either <i>COUNT</i> is exhausted, an end of file is detected, or an error
  occurs. If <i>IBS</i> and <i>OBS</i> are different, ddpt restricts the value
  of <i>OBS</i> such that the copy buffer is an integral number of output blocks
  (i.e. ((( <i>IBS * BPT</i>) % <i>OBS</i>) == 0) ). In the following
  descriptions, &quot;segment&quot; refers to all or part of a copy buffer.
<div class="Pp"></div>
The term &quot;pt device&quot; is used for a pass-through device to which SCSI
  commands like READ(10), WRITE(10) or POPULATE TOKEN may be sent. A pt device
  may only be able to process SCSI commands in which case the &quot;pt&quot;
  flag is assumed. The ability to recognize such a pt only device may vary
  depending on the operating system (e.g. in Linux /dev/sg2 and /dev/bsg/3:0:1:0
  are recognized). However if a device can process either normal UNIX read()/
  write() calls or pass-through SCSI commands then the default is to use UNIX
  read()/write() calls. That default can be overridden by using the
  &quot;pt&quot; flag (e.g. &quot;if=/dev/sdc iflag=pt&quot;). When pt access is
  specified any partition information is <b>ignored.</b> So &quot;if=/dev/sdc2
  iflag=pt skip=3&quot; will start at logical block address 3 of '/dev/sdc'. As
  a protection measure ddpt will only accept that if the force flag is also
  given (i.e. 'iflag=pt,force').
<div class="Pp"></div>
This utility supports two types of offloaded copies. Both are based on the
  EXTENDED COPY (XCOPY or xcopy) family of SCSI commands. The first uses the
  XCOPY(LID1) command to do a disk to disk copy. LID1 stands for List IDentifier
  length of 1 byte and the command is described in the SPC-4 drafts and the
  earlier SPC-3 and SPC-2 standards. Recent SPC-4 drafts have added the
  XCOPY(LID4) sub-family of copy offloaded commands. There is a subset of
  XCOPY(LID4), specialized for offloaded disk to disk copies, that is known by
  the market name: ODX. In the descriptions below &quot;xcopy&quot; refers to
  copies based on XCOPY(LID1) while &quot;odx&quot; refers to either full or
  partial ODX copies. See the XCOPY and ODX sections below for more information.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
The dd-like options with the name=value syntax are listed first, sorted by name.
  Following that, options starting with &quot;-&quot; are listed.
<dl class="Bl-tag">
  <dt class="It-tag"><b>bpt</b>=<i>BPT[,OBPC]</i></dt>
  <dd class="It-tag">where <i>BPT</i> is Blocks Per Transfer. A direct copy is
      made up of multiple transfers, each first reading <i>BPT</i> input blocks
      (i.e. <i>BPT * IBS</i> bytes) from <i>IFILE</i> into the copy buffer and
      then from that copy buffer writing <i>(BPT * IBS) / OBS</i> output blocks
      to <i>OFILE</i>. This continues until the copy is finished, with the last
      transfer being potentially shorter. The default <i>BPT</i> value varies
      depending on <i>IBS</i>. When <i>IBS</i> &lt; 8, <i>BPT</i> is 8192; when
      <i>IBS</i> &lt; 64, <i>BPT</i> is 1024; when <i>IBS</i> &lt; 1024,
      <i>BPT</i> is 128; when <i>IBS</i> &lt; 8192, <i>BPT</i> is 16; when
      <i>IBS</i> &lt; 32768, <i>BPT</i> is 4; else <i>BPT</i> defaults to 1. If
      <i>BPT</i> is given as 0 it is treated as the default value. For
      &quot;bs=512&quot;, <i>BPT</i> defaults to 128 so that 64 KiB (or less) is
      read from <i>IFILE</i> into the copy buffer. This option is treated
      differently in ODX and is typically only needed for testing; see ODX
      section.
    <div>&#x00A0;</div>
    The optional <i>OBPC</i> (Output Blocks Per Check) argument controls
      controls the granularity of sparse writes, write sparing and trim checks.
      The default granularity is the size of the copy buffer (i.e. <i>BPT *
      IBS</i> bytes). That can be reduced by specifying <i>OBPC</i>. The finest
      granularity is when <i>OBPC</i> is 1 which implies the unit of each check
      is <i>OBS</i> bytes. When <i>OBPC</i> is 0, or not given, the default
      granularity is used. Large <i>OBPC</i> values are rounded down so that
      <i>OBPC*OBS</i> does not exceed the size of the copy buffer.
    <div>&#x00A0;</div>
    odx: may be used to limit the data represented by each ROD. Mainly for
      testing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bs</b>=<i>BS</i></dt>
  <dd class="It-tag">where <i>BS</i> is the <i>IFILE</i> and <i>OFILE</i> block
      size in bytes. Conflicts with either the &quot;ibs=&quot; or
      &quot;obs=&quot; options. The value of <i>BS</i> is placed in <i>IBS</i>
      and <i>OBS</i>. If <i>IFILE</i> or <i>OFILE</i> is a &quot;pt&quot; device
      then <i>BS</i> <b>must</b> be the logical block size of the device. See
      the DD DIFFERENCES section below. The default is 512 bytes; note that
      newer disks use 4096 byte blocks with perhaps larger block sizes coming in
      the future. CD/DVD/BD media use a logical block size of 2048 bytes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cdbsz</b>={6|10|12|16|32}</dt>
  <dd class="It-tag">size of SCSI READ and/or WRITE commands issued to pt
      devices. The default is 10 byte SCSI command blocks unless calculations
      indicate that a 4 byte block number may be exceeded or <i>BPT</i> is
      greater than 16 bits (i.e. more than 65535 blocks), in which case it
      defaults to 16 byte SCSI commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>coe</b>={0|1}</dt>
  <dd class="It-tag">set to 1 for continue on error. Applies to errors on input
      and output for pt devices but only on input from block devices or regular
      files. Errors on other files will stop ddpt. Default is 0 which implies
      stop on any error. See the 'coe' flag for more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>coe_limit</b>=<i>CL</i></dt>
  <dd class="It-tag">where <i>CL</i> is the maximum number of consecutive bad
      blocks stepped over due to &quot;coe=1&quot; on reads before the copy
      terminates. The default is 0 which is implies no limit. This option is
      meant to stop the copy soon after unrecorded media is detected while still
      offering &quot;continue on error&quot; capability for infrequent, randomly
      distributed errors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>conv</b>=<i>CONVS</i></dt>
  <dd class="It-tag">see the CONVERSIONS section below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>count</b>=<i>COUNT</i></dt>
  <dd class="It-tag">copy <i>COUNT</i> input blocks from <i>IFILE</i> to
      <i>OFILE</i>. If this option is not given (or <i>COUNT</i> is '-1') then
      the <i>COUNT</i> may be deduced from either <i>IFILE</i> or <i>OFILE</i>.
      See the COUNT section below.
    <div>&#x00A0;</div>
    odx: if a gather list is given to <i>skip=SKIP</i> or a scatter list is
      given to <i>seek=SEEK</i> then typically <i>count=COUNT</i> should not be
      supplied. This is because a scatter gather list implies a transfer count.
      If both are given then ddpt will exit if they are unequal, the force
      option can be used to override this action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>delay</b>=<i>MS[,W_MS]</i></dt>
  <dd class="It-tag">after each segment is copied (typically every (<i>IBS</i> *
      <i>BPT</i>) bytes) a delay (sleep) of <i>MS</i> milliseconds is performed.
      The default value for <i>MS</i> is 0 which implies no delay. If
      <i>W_MS</i> is given and greater than 0 (its default value) then there is
      an additional delay of <i>W_MS</i> milliseconds associated with each
      actual write operation that is performed. If <i>MS</i> is greater than 0
      then there is not a delay before the first copy segment (or after the
      last); if <i>W_MS</i> is greater than 0 then there is not a delay before
      the first write segment. These delays can be used for a bandwidth
      limiting.
    <div>&#x00A0;</div>
    odx: the <i>MS</i> delay is implemented in the same fashion after each ROD
      is copied, apart from the last. If <i>W_MS</i> is greater than 0 then that
      delay occurs before each WUT command, apart from the first.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ibs</b>=<i>IBS</i></dt>
  <dd class="It-tag">where <i>IBS</i> is the <i>IFILE</i> block size in bytes.
      The default value is <i>BS</i> or its default (512). Conflicts the
      &quot;bs=&quot; option (i.e. giving both &quot;bs=512 ibs=512&quot; is
      considered a syntax error).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>id_usage</b>=<i>LIU</i></dt>
  <dd class="It-tag">xcopy: SCSI EXTENDED COPY parameter list LIST ID USAGE
      field is set to <i>LIU</i>. The default value is 0 or 2 . <i>LIU</i> can
      be a number between 0 and 3 inclusive or a string. The strings can be
      either: 'hold' for 0, 'discard' for 2 or 'disable' for 3.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>if</b>=<i>IFILE</i></dt>
  <dd class="It-tag">read from <i>IFILE</i>. This option must be given (apart
      from one odx case). If <i>IFILE</i> is '-' then stdin is read. Starts
      reading at the beginning of <i>IFILE</i> unless <i>SKIP</i> is given.
    <div>&#x00A0;</div>
    odx: the <i>rtf=RTF</i> option may replace the <i>if=IFILE</i> option as
      input. See the ODX section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iflag</b>=<i>FLAGS</i></dt>
  <dd class="It-tag">where <i>FLAGS</i> is a comma separated list of one or more
      flags outlined in the FLAGS section below. These flags are associated with
      <i>IFILE</i> and are mostly ignored when <i>IFILE</i> is stdin.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>intio</b>={0|1}</dt>
  <dd class="It-tag">set to 1 for allow signals (SIGINT, SIGPIPE and SIGUSR1 (or
      SIGINFO)) to be received during IO from <i>IFILE</i> or IO to <i>OFILE</i>
      or <i>OFILE2</i>. Default is 0 which causes these signals to be masked
      during IO operations with a check for signals prior each IO. As long as IO
      operations don't lock up (e.g. SCSI READ and WRITE commands) the default
      is the safer option. Even if IO operations do lock up it is best to let
      the kernel take care of that.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iseek</b>=<i>SKIP</i></dt>
  <dd class="It-tag">start reading <i>SKIP</i> blocks (each of <i>IBS</i> bytes)
      from the start of <i>IFILE</i>. Default is block 0 (i.e. start of file).
      This option is a synonym for <i>skip=SKIP</i>, see its description.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ito</b>=<i>ITO</i></dt>
  <dd class="It-tag">odx: <i>ITO</i> is the inactivity timeout whose units are
      seconds. The default value is 0 which means the copy manager will take the
      default inactivity timeout value from the Block Device ROD Token Limits
      descriptor in the Third Party Copy VPD page. <i>ITO</i> is ignored if it
      it exceeds the maximum inactivity timeout value in the same descriptor
      (unless the force flag is given).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>list_id</b>=<i>LID</i></dt>
  <dd class="It-tag"><i>LID</i> is the xcopy LIST IDENTIFIER field. It is used
      to associate an originating xcopy command with follow-up commands such as
      RECEIVE ROD TOKEN INFORMATION. If given, the <i>LID</i> should not clash
      with any other xcopy <i>LID</i> currently in use on this I_T nexus.
    <div>&#x00A0;</div>
    xcopy: <i>LID</i> is a 1 byte (8 bit) value whose default value is 1 or, if
      id_usage=disable, 0 . <i>LID</i> must not exceed 255.
    <div>&#x00A0;</div>
    odx: <i>LID</i> is a 4 byte (32 bit) value whose default value is 257 (i.e.
      0x101) and, if a second default is needed, 258 (0x102) is used. If a clash
      is detected on the default list identifier value then the next higher
      value is tried (stopping after 10 attempts).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>obs</b>=<i>OBS</i></dt>
  <dd class="It-tag">where <i>OBS</i> is the <i>OFILE</i> block size in bytes.
      The default value is <i>BS</i> or its default (512). Conflicts the
      &quot;bs=&quot; option (e.g. giving both &quot;bs=512 obs=512&quot; is
      considered a syntax error). If <i>OBS</i> is given then it has the
      following restriction: the integer expression ((( <i>IBS</i> * <i>BPT</i>)
      % <i>OBS</i>) == 0) must be true. Stated another way: the copy buffer size
      must be an integral multiple of <i>OBS</i>. If <i>of2=OFILE2</i> is given
      then <i>OBS</i> is its block size as well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>of</b>=<i>OFILE</i></dt>
  <dd class="It-tag">write to <i>OFILE</i>. The default value is /dev/null . If
      <i>OFILE</i> is '-' then writes to stdout. If <i>OFILE</i> is /dev/null
      then no actual writes are performed. If <i>OFILE</i> is '.' (period) then
      it is treated the same way as /dev/null . If <i>OFILE</i> exists then it
      is _not_ truncated unless &quot;oflag=trunc&quot; is given. See section on
      DD DIFFERENCES.
    <div>&#x00A0;</div>
    odx: if this option ( <i>of=OFILE</i>) is not given and the <i>rtf=RTF</i>
      option is given then the <i>RTF</i> file may be thought of as receiving
      the output in the form of one or more ROD Tokens. See the ODX
    section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>of2</b>=<i>OFILE2</i></dt>
  <dd class="It-tag">write output to <i>OFILE2</i>. The default action is not to
      do this additional write (i.e. when this option is not given).
      <i>OFILE2</i> is assumed to be a regular file or a fifo (i.e. a named
      pipe). <i>OFILE2</i> is opened for writing and is created if necessary. If
      <i>OFILE2</i> is a fifo (named pipe) then some other command should be
      consuming that data (e.g. 'md5sum OFILE2'), otherwise this utility will
      block. The write to <i>OFILE2</i> occurs before the write to <i>OFILE</i>
      and prior to sparse writing and write sparing logic. So everything read is
      written to <i>OFILE2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>oflag</b>=<i>FLAGS</i></dt>
  <dd class="It-tag">where <i>FLAGS</i> is a comma separated list of one or more
      flags outlined in the FLAGS section. These flags are associated with
      <i>OFILE</i> and are ignored when <i>OFILE</i> is /dev/null, '.' (period),
      or stdout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>oseek</b>=<i>SEEK</i></dt>
  <dd class="It-tag">start writing <i>SEEK</i> blocks (each of <i>OBS</i> bytes)
      from the start of <i>OFILE</i>. Default is block 0 (i.e. start of file).
      This option is a synonym for <i>seek=SEEK</i>, see its description.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>prio</b>=<i>PRIO</i></dt>
  <dd class="It-tag">xcopy: SCSI EXTENDED COPY parameter list PRIORITY field is
      set to <i>PRIO</i>. The default value is 1 .</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>protect</b>=<i>RDP[,WRP]</i></dt>
  <dd class="It-tag">where <i>RDP</i> is the RDPROTECT field in SCSI READ
      commands and <i>WRP</i> is the WRPROTECT field in SCSI WRITE commands. The
      default value for both is 0 which implies no additional protection
      information will be transferred. Both <i>RDP</i> and <i>WRP</i> can be
      from 0 to 7. If <i>RDP</i> is greater than 0 then <i>IFILE</i> must be a
      pt device. If <i>WRP</i> is greater than 0 then <i>OFILE</i> must be a pt
      device. See the PROTECTION INFORMATION section below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>retries</b>=<i>RETR</i></dt>
  <dd class="It-tag">sometimes retries at the host are useful, for example when
      there is a transport error. When <i>RETR</i> is greater than zero then
      SCSI READs and WRITEs are retried on error, <i>RETR</i> times. Default
      value is zero. Only applies to errors on pt devices.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rtf</b>=<i>RTF</i></dt>
  <dd class="It-tag">odx: where <i>RTF</i> is a filename. One or more ROD tokens
      are written to <i>RTF</i> during a read to tokens variant or a full copy
      variant. One or more ROD tokens are read from <i>RTF</i> during a write
      from token variant. This option is not required on a full copy variant.
      ROD Tokens are 512 bytes long and an extra 8 byte (big-endian) integer
      containing the 'number of bytes represented' is placed after each ROD
      Token if rtf_len is given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rtype</b>=<i>RTYPE</i></dt>
  <dd class="It-tag">odx: where <i>RTYPE</i> is the ROD Type. The default value
      (0) indicates that the copy manager (in the source) decides. <i>RTYPE</i>
      can be a decimal number, a hex number (prefixed by 0x or with a
      &quot;h&quot; appended) or one of &quot;pit-def&quot;,
      &quot;pit-vuln&quot;, &quot;pit-pers&quot;, &quot;pit-any&quot; or
      &quot;zero&quot;. The final truncated word can be spelt out (e.g.
      &quot;pit-vulnerable&quot;). The &quot;pit-&quot; prefix is a shortening
      of &quot;point in time&quot; copy. The &quot;zero&quot; causes a special
      Block device zero Token to be created.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>seek</b>=<i>SEEK</i></dt>
  <dd class="It-tag">start writing <i>SEEK</i> blocks (each of <i>OBS</i> bytes)
      from the start of <i>OFILE</i>. Default is block 0 (i.e. start of file).
      The <i>SEEK</i> value may exceed the number of <i>OBS</i>-sized blocks in
      <i>OFILE</i>.
    <div>&#x00A0;</div>
    odx: <i>SEEK</i> can be a scatter list: comma separated, in the form
      seek=A1,N1[,A2,N2...] . The scatter list may alternatively be read from a
      file using this form: seek=@&lt;filename&gt; or read from stdin using this
      form: seek=- (or seek=@-) . A&lt;n&gt; and N&lt;n&gt; are decimal
      (optionally with a suffix multiplier) unless a hex indication is given.
      Hex values are indicated by either a leading &quot;0x&quot; or a trailing
      &quot;h&quot;. The address (i.e. A&lt;n&gt;) is a 64 bit unsigned integer
      while the number of blocks (i.e. N&lt;n&gt;) is a 32 bit integer. Thus for
      a block size of 512 bytes, a single scatter gather list element cannot
      exceed 4 TB ((2**32 - 1) * 512). Note that <i>COUNT</i> is a 64 bit
      unsigned integer and thus does not have this restriction. There can be no
      more than 128 scatter list elements.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>skip</b>=<i>SKIP</i></dt>
  <dd class="It-tag">start reading <i>SKIP</i> blocks (each of <i>IBS</i> bytes)
      from the start of <i>IFILE</i>. Default is block 0 (i.e. start of file).
      The <i>SKIP</i> value must be less than the number of <i>IBS</i>-sized
      blocks in <i>IFILE</i>.
    <div>&#x00A0;</div>
    odx: <i>SKIP</i> can be a gather list: comma separated, in the form
      skip=A1,N1[,A2,N2...] . The gather list may alternatively be read from a
      file using this form: skip=@&lt;filename&gt; or read from stdin using this
      form: skip=- . See the odx section of the <i>seek=SEEK</i> option for
      further details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>status</b>=<i>STAT</i></dt>
  <dd class="It-tag">the <i>STAT</i> value of 'noxfer' suppresses the throughput
      speed and the copy time reporting at the end of the copy. A <i>STAT</i>
      value of 'none' additionally suppresses the records in and out reporting
      after the copy. So 'status=none' makes ddpt act like a traditional Unix
      command in which &quot;no news is good news&quot;. The default action of
      ddpt is to show the throughput (in megabytes per second) and the time
      taken to do the copy after the &quot;records in&quot; and &quot;records
      out&quot; lines at the end of the copy. As a convenience the value 'null'
      is accepted for <i>STAT</i> and does nothing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>to</b>=<i>TO</i></dt>
  <dd class="It-tag">odx, xcopy: where <i>TO</i> is am xcopy originating command
      timeout in seconds. The default value is 0 which is converted internally
      to 600 seconds (10 minutes). Best to set this timeout value well above the
      expected copy time. In a odx full copy this timeout is applied to both the
      POPULATE TOKEN and WRITE USING TOKEN commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verbose</b>=<i>VERB</i></dt>
  <dd class="It-tag">as <i>VERB</i> increases so does the amount of debug
      reporting sent to stderr. Default value is zero which yields the minimum
      amount of debug reporting. A value of 1 reports extra information that is
      not repetitive. A value 2 reports cdbs and responses for SCSI commands
      that are not repetitive (i.e. other that READ and WRITE). Error processing
      is not considered repetitive. Values of 3 and 4 yield reporting for all
      SCSI commands, plus Unix read() and write() calls, so there can be a lot
      of output. If <i>VERB</i> is &quot;-1&quot; then reporting that would have
      been sent to stderr is redirected to /dev/null essentially throwing it
      away.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>, <b>--help</b></dt>
  <dd class="It-tag">reports usage message then exits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b>, <b>--odx</b></dt>
  <dd class="It-tag">indicates to this utility that one of the four odx variants
      is requested. See ODX section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b>, <b>--verbose</b></dt>
  <dd class="It-tag">equivalent of <i>verbose=1</i>. If <i>--verbose</i> appears
      twice then that is equivalent to <i>verbose=2</i>. Also <i>-vv</i> is
      equivalent to <i>verbose=2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b>, <b>--version</b></dt>
  <dd class="It-tag">reports version number information then exits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b>, <b>--wscan</b></dt>
  <dd class="It-tag">this option is available in Windows only. It lists storage
      device names and the corresponding volumes, if any. When used twice it
      adds the &quot;bus type&quot; of the closest transport (e.g. a SATA disk
      in a USB connected enclosure has bus type USB). When used three times a
      SCSI adapter scan is added. When used four times only a SCSI adapter scan
      is shown. See EXAMPLES section below and the README.win32 file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b>, <b>--xcopy</b></dt>
  <dd class="It-tag">this option will attempt to call the SCSI EXTENDED
      COPY(LID1) command. In the absence of another indication the xcopy command
      will be sent to the destination (i.e. <i>OFILE</i>). See the section on
      ENVIRONMENT VARIABLES below.</dd>
</dl>
<h1 class="Sh" title="Sh" id="COUNT"><a class="selflink" href="#COUNT">COUNT</a></h1>
When the <i>count=COUNT</i> option is not given (or <i>COUNT</i> is '-1') then
  an attempt is made to deduce <i>COUNT</i> as follows.
<div class="Pp"></div>
When both or either <i>IFILE</i> and <i>OFILE</i> are block devices, then the
  minimum size, expressed in units of input blocks, is used. When both or either
  <i>IFILE</i> and <i>OFILE</i> are pass-through devices, then the minimum size,
  expressed in units of input blocks, is used.
<div class="Pp"></div>
If a regular file is used as input, its size, expressed in units of input blocks
  (and rounded up if necessary) is used. Note that the rounding up of the
  deduced <i>COUNT</i> may result in a partial read of the last input block and
  a corresponding partial write to <i>OFILE</i> if it is a regular file. After a
  regular file to regular file copy the length of <i>OFILE</i> will be the same
  as <i>IFILE</i> unless <i>OFILE</i> existed and its length was already greater
  than that of <i>IFILE</i>. To get a copy like the standard Unix cp command,
  use oflag=trunc with ddpt.
<div class="Pp"></div>
The size of pt devices is deduced from the SCSI READ CAPACITY command. Block
  device sizes (or their partition sizes) are obtained from the operating
  system, if available.
<div class="Pp"></div>
If <i>skip=SKIP</i> or <i>skip=SEEK</i> are given and the <i>COUNT</i> is
  deduced (i.e. not explicitly given) then that size is scaled back so that the
  copy will not overrun the file or device.
<div class="Pp"></div>
If <i>COUNT</i> is not given and <i>IFILE</i> is a fifo (and stdin is treated as
  a fifo) then <i>IFILE</i> is read until an EOF is detected. If <i>COUNT</i> is
  not given and <i>IFILE</i> is a /dev/zero (or equivalent) then zeros are read
  until an error occurs (e.g. file system full).
<div class="Pp"></div>
If <i>COUNT</i> is not given and cannot be deduced then an error message is
  issued and no copy takes place.
<h1 class="Sh" title="Sh" id="CONVERSIONS"><a class="selflink" href="#CONVERSIONS">CONVERSIONS</a></h1>
One or more conversions can be given to the &quot;conv=&quot; option. If more
  than one is given, they should be comma separated. ddpt does not perform the
  traditional dd conversions (e.g. ASCII to EBCDIC). Recently added conversions
  inherited from GNU's dd overlap somewhat with the some of ddpt flags.
<dl class="Bl-tag">
  <dt class="It-tag">fdatasync</dt>
  <dd class="It-tag">equivalent to &quot;oflag=fdatasync&quot;. Flushes data
      associated with the <i>OFILE</i> to storage at the end of the copy. This
      conversion is for compatibility with GNU's dd.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fsync</dt>
  <dd class="It-tag">equivalent to &quot;oflag=fsync&quot;. Flushes data and
      meta-data associated with the <i>OFILE</i> to storage at the end of the
      copy. This conversion</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">no_del_tkn</dt>
  <dd class="It-tag">equivalent to &quot;oflag=no_del_tkn&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">noerror</dt>
  <dd class="It-tag">this conversion is very close to &quot;iflag=coe&quot; and
      is treated as such. See the &quot;coe&quot; flag. Note that an error on a
      block device or regular file <i>OFILE</i> will stop the copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">notrunc</dt>
  <dd class="It-tag">this conversion is accepted for compatibility with dd and
      ignored since the default action of this utility is not to truncate
      <i>OFILE</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">null</dt>
  <dd class="It-tag">has no affect, just a placeholder.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">resume</dt>
  <dd class="It-tag">See &quot;resume&quot; in the FLAGS sections for more
      information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rtf_len</dt>
  <dd class="It-tag">equivalent to &quot;oflag=rtf_len&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sparing</dt>
  <dd class="It-tag">See &quot;sparing&quot; in the FLAGS sections for more
      information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sparse</dt>
  <dd class="It-tag">FreeBSD's dd supports &quot;conv=sparse&quot; and now GNU's
      dd does as well so the same syntax is supported in ddpt. See
      &quot;sparse&quot; in the FLAGS sections for more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sync</dt>
  <dd class="It-tag">is ignored by ddpt. With dd it means supply zero fill
      (rather than skip) and is typically used like this
      &quot;conv=noerror,sync&quot; to have the same functionality as ddpt's
      &quot;iflag=coe&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">trunc</dt>
  <dd class="It-tag">if <i>OFILE</i> is a regular file then truncate it prior to
      starting the copy. See &quot;trunc&quot; in the FLAGS section.</dd>
</dl>
<h1 class="Sh" title="Sh" id="FLAGS"><a class="selflink" href="#FLAGS">FLAGS</a></h1>
A list of flags and their meanings follow. The flag name is followed by one or
  two indications in square brackets. The first indication is either
  &quot;[i]&quot;, &quot;[o]&quot; or &quot;[io]&quot; indicating this flag is
  active for the <i>IFILE</i>, <i>OFILE</i> or both the <i>IFILE</i> and the
  <i>OFILE</i>. The second indication contains some combination of
  &quot;reg&quot;, &quot;blk&quot; &quot;pt&quot;, &quot;odx&quot;, or
  &quot;xcopy&quot;. These indicate whether the flag applies to a regular file,
  a block device (accessed via Unix read() and write() commands, a pass-through
  device, an ODX offloaded copy or a XCOPY(LID1) offloaded copy respectively.
  Other special file types that are sometimes referred to are &quot;fifo&quot;
  and &quot;tape&quot;.
<dl class="Bl-tag">
  <dt class="It-tag">append [o] [reg], [io] [odx]</dt>
  <dd class="It-tag">causes the O_APPEND flag to be added to the open of
      <i>OFILE</i>. For regular files this will lead to data being appended to
      the end of any existing data. Conflicts the <i>seek=SEEK</i> option. The
      default action of this utility is to overwrite any existing data from the
      beginning of <i>OFILE</i> or, if <i>SEEK</i> is given, starting at block
      <i>SEEK</i>. Note that attempting to 'append' to a device file (e.g. a
      disk) will usually be ignored or may cause an error to be reported.
    <div>&#x00A0;</div>
    odx: if the <i>rtf=RTF</i> option is given, <i>RTF</i> exists, is a regular
      file and this utility wants to write to <i>RTF</i> then new ROD Tokens are
      appended to <i>RTF</i>. The default action is to truncate <i>RTF</i>
      before new ROD Tokens are written to it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">block [io] [pt]</dt>
  <dd class="It-tag">pass-through file opens are non-blocking by default and may
      report the pt device is busy. Use this flag to open blocking so utility
      may wait until another process locking (or with an exclusive open) is
      complete before continuing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cat [io] [xcopy]</dt>
  <dd class="It-tag">xcopy: set CAT (residual data handling) bit in EXTENDED
      COPY(LID1) parameter list segment descriptor header. May appear in either
      flag list when xcopy is being used. Works with the PAD bit for handling
      residual data on the destination side. See the XCOPY section below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">coe [io] [pt], [i] [reg,blk]</dt>
  <dd class="It-tag">continue on error. 'iflag=coe oflag=coe' and 'coe=1' are
      equivalent. Errors occurring on output regular or block files will stop
      ddpt. Error messages are sent to stderr. This flag is similar to
      'conv=noerror,sync' in the <b>dd(1)</b> utility. Unrecovered errors are
      counted and reported in the summary at the end of the copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This paragraph concerns coe on pt devices. A medium,
      hardware or blank check error during a read operation will will cause the
      following: first re-read blocks prior to the bad block, then try to
      recover the bad block (supplying zeros if that fails), and finally re-read
      the blocks after the bad block. A medium, hardware or blank check error
      while writing is reported but otherwise ignored. SCSI disks may
      automatically try and remap faulty sectors (see the AWRE and ARRE in the
      read write error recovery mode page (the sdparm utility can access these
      attributes)). If bad LBAs are reported by the pass-through then the LBA of
      the lowest and highest bad block is also reported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This paragraph concerns coe on input regular files and
      block devices. When a EIO or EREMOTEIO error is detected on a normal
      segment read then the segment is re-read one block (i.e. <i>IBS</i> bytes)
      at a time. Any block that yields a EIO or EREMOTEIO error is replaced by
      zeros. Any other error, a short read or an end of file will terminate the
      copy, usually after the data that has been read is written to the output
      file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dc [io] [blk,pt]</dt>
  <dd class="It-tag">xcopy: set DC (destination counter) bit in EXTENDED
      COPY(LID1) parameter list segment descriptor header. May appear in either
      flag list when xcopy is being used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">direct [io] [reg,blk]</dt>
  <dd class="It-tag">causes the O_DIRECT flag to be added to the open of
      <i>IFILE</i> and/or <i>OFILE</i>. This flag requires some memory alignment
      on IO. Hence user memory buffers are aligned to the page size. May have no
      effect on pt devices. This flag will bypass caching/buffering normally
      done by block layer. Beware of data coherency issues if the same locations
      have been recently accessed via the block layer in its normal mode (i.e.
      non-direct). See open(2) man page.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dpo [io] [pt]</dt>
  <dd class="It-tag">set the DPO bit (disable page out) in SCSI READ and WRITE
      commands. Not supported for 6 byte cdb variants of READ and WRITE.
      Indicates that data is unlikely to be required to stay in device (e.g.
      disk) cache. May speed media copy and/or cause a media copy to have less
      impact on other device users.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">errblk [i] [pt] [experimental]</dt>
  <dd class="It-tag">attempts to create or append to a file called
      &quot;errblk.txt&quot; in the current directory the logical block
      addresses of blocks that cannot be read. The first (appended) line is
      &quot;# start &lt;timestamp&gt;&quot;. That is followed by the LBAs in hex
      (and prefixed with &quot;0x&quot;) of any block that cannot be read, one
      LBA per line. If the sense data does not correctly identify the LBA of the
      first error in the range it was asked to read then a LBA range is reported
      in the form of the lowest and the highest LBA in the range separated by a
      &quot;-&quot;. At the end of the copy a line with &quot;# stop
      &lt;timestamp&gt;&quot; is appended to &quot;errblk.txt&quot;. Typically
      used with &quot;coe&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">excl [io] [reg,blk]</dt>
  <dd class="It-tag">causes the O_EXCL flag to be added to the open of
      <i>IFILE</i> and/or <i>OFILE</i>. See open(2) man page.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fdatasync [o] [reg,blk]</dt>
  <dd class="It-tag">Flushes data associated with the <i>OFILE</i> to storage at
      the end of the copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">flock [io] [reg,blk,pt]</dt>
  <dd class="It-tag">after opening the associated file (i.e. <i>IFILE</i> and/or
      <i>OFILE</i>) an attempt is made to get an advisory exclusive lock with
      the flock() system call. The flock arguments are &quot;FLOCK_EX |
      FLOCK_NB&quot; which will cause the lock to be taken if available else a
      &quot;temporarily unavailable&quot; error is generated. An exit status of
      90 is produced in the latter case and no copy is done. See flock(2) man
      page.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">force [io] [pt] [xcopy,odx]</dt>
  <dd class="It-tag">override difference between given block size and the block
      size found by the SCSI READ CAPACITY command. Use the given block size.
      Without this flag the copy would not be performed. pt access to what
      appears to be a block partition is aborted in version 0.92; that can be
      overridden by the force flag. For related reasons the 'norcap' flag
      requires this flag when applied to a block device accessed via pt.
    <div>&#x00A0;</div>
    xcopy and odx: various limits imposed by associated VPD pages or the RECEIVE
      COPY OPERATING PARAMETERS command can be overridden (i.e. exceeded) if
      this flag is given. Note that the copy manager will probably object.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fsync [o] [reg,blk]</dt>
  <dd class="It-tag">Flushes data and metadata (describing the file) associated
      with the <i>OFILE</i> to storage at the end of the copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fua [io] [pt]</dt>
  <dd class="It-tag">causes the FUA (force unit access) bit to be set in SCSI
      READ and/or WRITE commands. The 6 byte variants of the SCSI READ and WRITE
      commands do not support the FUA bit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fua_nv [io] [pt]</dt>
  <dd class="It-tag">causes the FUA_NV (force unit access non-volatile cache)
      bit to be set in SCSI READ and/or WRITE commands. This only has an effect
      with pt devices. The 6 byte variants of the SCSI READ and WRITE commands
      do not support the FUA_NV bit. The FUA_NV bit was made obsolete in SBC-3
      revision 35d.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ignoreew [o] [tape]</dt>
  <dd class="It-tag">ignore the early warning indication (of end of tape) when
      writing to tape. See TAPE section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">immed [io] [odx]</dt>
  <dd class="It-tag">sets the IMMED bit in the POPULATE TOKEN (when [i]) or
      WRITE USING TOKEN (when [o]) command. That command should return status
      promptly after starting the data transfer. The RECEIVE ROD TOKEN
      INFORMATION command is then used to poll for completion. SCSI command
      timeouts should not be exceeded, even for very large RODs, if this flag is
      used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">nocache [io] [reg,blk]</dt>
  <dd class="It-tag">use posix_fadvise(POSIX_FADV_DONTNEED) to advise
      corresponding file there is no need to fill the file buffer with recently
      read or written blocks. If used with &quot;iflag=&quot; it will increase
      the read ahead on <i>IFILE</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">no_del_tkn [o] [odx]</dt>
  <dd class="It-tag">will clear the DEL_TKN bit on the last WRITE USING TOKEN
      command of each ROD Token in a odx full copy. In a large odx full copy
      several ROD Tokens may be used (one after the other). The default action
      is to set the DEL_TKN bit on the last WUT command of each ROD. Either way
      it should not make much difference because the copy manager deletes a ROD
      Token after a copy is completed. The copy manager will also
      delete/invalidate a ROD Token if the inactivity timeout is reached.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">nofm [o] [tape]</dt>
  <dd class="It-tag">no File Mark (FM) on close when writing to tape. See TAPE
      section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">nopad [o] [tape]</dt>
  <dd class="It-tag">when the block to be written to a tape drive contains less
      than <i>OBS</i> bytes, then this option causes the partial block to be
      written as is. The default action for a tape in this case is to pad the
      block. See TAPE section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">norcap [io] [pt]</dt>
  <dd class="It-tag">do not perform SCSI READ CAPACITY command on the
      corresponding pt device. If used on block device accessed via pt then
      'force' flag is also required. This is to warn about using pt access on
      what may be a block device partition.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">nowrite [o] [reg,blk,pt]</dt>
  <dd class="It-tag">bypass writes to <i>OFILE</i>. The &quot;records out&quot;
      count is not incremented. <i>OFILE</i> is still opened but
      &quot;oflag=trunc&quot; if given is ignored. Also the ftruncate call
      associated with the sparse flag is ignored (i.e. bypassed). Commands such
      as trim and SCSI SYNCHRONIZE CACHE are still sent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">null [io]</dt>
  <dd class="It-tag">has no affect, just a placeholder.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">odx [io] [odx]</dt>
  <dd class="It-tag">indicates to this utility that one of the four variants of
      an odx copy is requested. Using any of the <i>--odx</i>, <i>rtf=RTF</i> or
      <i>rtype=RTYPE</i> options also indicates that odx is requested. See the
      ODX section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pad [o] [reg,blk,pt], [io] [xcopy]</dt>
  <dd class="It-tag">when the block to be written (typically the last block)
      contains less than <i>OBS</i> bytes, then this option causes the block to
      be padded with zeros (i.e. bytes of binary zero). The default action for a
      regular file and a fifo is to do a partial write. The default action of a
      block and a pt device is to ignore the partial write. The default action
      of a tape is to pad, so this flag is not needed (see the nopad flag).
    <div>&#x00A0;</div>
    xcopy: sets the PAD bit in the CSCD descriptor of the associated
      <i>IFILE</i> or <i>OFILE</i>. Is associated with residual data handling
      and works together with the cat flag. See the XCOPY section below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">prealloc [o] [reg]</dt>
  <dd class="It-tag">use the fallocate() call prior to starting a copy to set
      <i>OFILE</i> to its expected size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pt [io] [blk,pt]</dt>
  <dd class="It-tag">causes a device to be accessed in &quot;pt&quot; mode. In
      &quot;pt&quot; mode SCSI READ and WRITE commands are sent to access blocks
      rather than standard UNIX read() and write() commands. The &quot;pt&quot;
      mode may be implicit if the device is only capable of passing through SCSI
      commands (e.g. the /dev/sg* and some /dev/bsg/* devices in Linux). This
      flag is needed for device nodes that can be accessed both via standard
      UNIX read() and write() commands as well as SCSI commands. Such devices
      default standard UNIX read() and write() commands in the absence of this
      flag.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rarc [i] [pt]</dt>
  <dd class="It-tag">bit set in READ(10, 12, 16 and 32) to suppress RAID rebuild
      functions when a bad (or recovered after difficulties) block is
    detected.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">resume [o] [reg]</dt>
  <dd class="It-tag">when a copy is interrupted (e.g. with Control-C from the
      keyboard) then using the same invocation again with the addition of
      &quot;oflag=resume&quot; will attempt to restart the copy from the point
      of the interrupt (or just before that point). It is harmless to use
      &quot;oflag=resume&quot; when <i>OFILE</i> doesn't exist or is zero
      length. If the length of <i>OFILE</i> is greater than or equal to the
      length implied by a ddpt invocation that includes &quot;oflag=resume&quot;
      then no further data is copied.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">self [io] [pt]</dt>
  <dd class="It-tag">used together with trim flag to do a self trim (trim of
      segments of a pt device that contain all zeros). If <i>OFILE</i> is not
      given, then it is set to the same as <i>IFILE</i>. If <i>SEEK</i> is not
      given it set to the same value as <i>SKIP</i> (possibly adjusted if
      <i>IBS</i> and <i>OBS</i> are different). Implicitly sets
      &quot;nowrite&quot; flag.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sparing [o] [reg,blk,pt]</dt>
  <dd class="It-tag">during the copy each <i>IBS</i> * <i>BPT</i> byte segment
      is read from <i>IFILE</i> into a buffer. Then, instead of writing that
      buffer to <i>OFILE</i>, the corresponding segment is read from
      <i>OFILE</i> into another buffer. If the two buffers are different, the
      former buffer is written to the <i>OFILE</i>. If the two buffers compare
      equal then the write to <i>OFILE</i> is not performed. Write sparing is
      useful when a write operation is significantly slower than a read. Under
      some conditions flash memory devices have slow writes plus an upper limit
      on the number of times the same cell can be rewritten. The granularity of
      the comparison can be reduced from the default <i>IBS</i> * <i>BPT</i>
      byte segment with the the <i>OBPC</i> value given to the &quot;bpt=&quot;
      option. The finest granularity is when <i>OBPC</i> is 1 which implies
      <i>OBS</i> bytes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sparse [o] [reg,blk,pt]</dt>
  <dd class="It-tag">after each <i>IBS</i> * <i>BPT</i> byte segment is read
      from <i>IFILE</i>, it is checked to see if it is all zeros. If so, that
      segment is not written to <i>OFILE</i>. See the section on SPARSE WRITES
      below. The granularity of the zero comparison can be reduced from the
      default <i>IBS</i> * <i>BPT</i> byte segment with the <i>OBPC</i> value
      given to the &quot;bpt=&quot; option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ssync [o] [pt]</dt>
  <dd class="It-tag">if <i>OFILE</i> is in &quot;pt&quot; mode then the SCSI
      SYNCHRONIZE CACHE command is sent to <i>OFILE</i> at the end of the
    copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">strunc [o] [reg]</dt>
  <dd class="It-tag">perform a sparse copy with a ftruncate system call to
      extend the length of the <i>OFILE</i> if required. See the sparse flag and
      the section on SPARSE WRITES below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sync [io] [reg,blk]</dt>
  <dd class="It-tag">causes the O_SYNC flag to be added to the open of
      <i>IFILE</i> and/or <i>OFILE</i>. See open(2) man page.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rtf_len [io] [odx]</dt>
  <dd class="It-tag">odx: with the 'read to tokens' variant, after 512 bytes of
      each ROD Token are written to <i>IRTF</i> an additional 8 byte (big
      endian) integer is written. That integer is the number of bytes the
      associated ROD represents. The draft standards say for standard ROD types
      the ROD Token holds this value. However vendor specific ROD types may be
      used or the vendors may choose not to comply. Either way the 'write from
      tokens' variant needs to know the size of the ROD it is writing from.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">trim [io] [pt] [experimental]</dt>
  <dd class="It-tag">similar logic to the &quot;sparse&quot; option. However
      instead of skipping segments that are full of zeros a &quot;trim&quot;
      command is sent to <i>OFILE</i>. Usually set as an oflag argument but for
      self trim can be used as an iflag argument (e.g.
      &quot;iflag=self,trim&quot;). Depending on the usage this may require the
      device to support &quot;deterministic read zero after trim&quot;. See the
      TRIM, UNMAP AND WRITE SAME section below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">trunc [o] [reg]</dt>
  <dd class="It-tag">if <i>OFILE</i> is a regular file then it is truncated
      prior to starting the copy. If <i>SEEK</i> is not given or 0 then
      <i>OFILE</i> is truncated to zero length; when <i>SEEK</i> is larger than
      zero the truncation takes place at file byte pointer <i>SEEK*OBS</i>.
      Ignored if &quot;oflag=append&quot;. Conflicts with
      &quot;oflag=sparing&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">unmap [io] [pt]</dt>
  <dd class="It-tag">same as the trim flag.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">xcopy [io] [pt]</dt>
  <dd class="It-tag">invoke SCSI XCOPY(LID1) logic and send the XCOPY command to
      the either <i>IFILE</i> or <i>OFILE</i> depending on which flag this
      called. If both are given (i.e. an invocation including 'iflag=xcopy
      oflag=xcopy') then send the XCOPY(LID1) to <i>OFILE</i>.</dd>
</dl>
<h1 class="Sh" title="Sh" id="XCOPY"><a class="selflink" href="#XCOPY">XCOPY</a></h1>
This section describes XCOPY(LID1) support with this utility. For ODX support
  (XCOPY(LID4) subset) see the ODX section.
<div class="Pp"></div>
A device (logical unit (LU)) that supports XCOPY operations should set the 3PC
  field (3PC stands for Third Party Copy) in its standard INQUIRY response. That
  is not checked when this utility does an xcopy operation but if it fails, that
  is one thing that the user may want to check.
<div class="Pp"></div>
If the xcopy starts and fails while underway, then 'sg_copy_results -s' may be
  useful to view the copy status. It might also be used from a different process
  with the same I_T nexus (i.e. the same machine) to check status during an
  xcopy operation.
<div class="Pp"></div>
The <i>pad</i> and <i>cat</i> flags control the handling of residual data. As
  the data can be specified either in terms of source or target block size and
  both might have different block sizes residual data is likely to happen in
  these cases. If both block sizes are identical these bits have no effect as
  residual data will not occur.
<div class="Pp"></div>
If neither of these flags are set, the EXTENDED COPY command will be aborted
  with additional sense 'UNEXPECTED INEXACT SEGMENT'.
<div class="Pp"></div>
If only the <i>cat</i> flag is set the residual data will be retained and made
  available for subsequent segment descriptors. Residual data will be discarded
  for the last segment descriptor.
<div class="Pp"></div>
If the <i>pad</i> flag is set for the source descriptor only, any residual data
  for both source or destination will be discarded.
<div class="Pp"></div>
If the <i>pad</i> flag is set for the target descriptor only any residual source
  data will be handled as if the <i>cat</i> flag is set, but any residual
  destination data will be padded to make a whole block transfer.
<div class="Pp"></div>
If the <i>pad</i> flag is set for both source and target any residual source
  data will be discarded, and any residual destination data will be padded.
<div class="Pp"></div>
There is a web page discussing ddpt, XCOPY and ODX at
  http://sg.danny.cz/sg/ddpt_xcopy_odx.html
<h1 class="Sh" title="Sh" id="ODX"><a class="selflink" href="#ODX">ODX</a></h1>
This section describes ODX support (an XCOPY(LID4) subset) for this utility. ODX
  descriptions use the following command name abbreviations: PT for the POPULATE
  TOKEN command, RRTI for the READ ROD TOKEN INFORMATION command, and WUT for
  the WRITE USING TOKEN command.
<div class="Pp"></div>
A device (logical unit (LU)) that supports ODX operations is required to set the
  3PC field (3PC stands for Third Party Copy) in its standard INQUIRY response
  and support the Third Party Copy VPD page. If this utility generates errors
  noting the absence of these then the device in question probably does not
  support ODX.
<div class="Pp"></div>
There a four variants of ODX supported by ddpt:
<div>&#x00A0;</div>
<br/>
 <b>full copy</b> : ddpt --odx if=/dev/sg3 bs=512 of=/dev/sg4
<div>&#x00A0;</div>
<br/>
 <b>zero output blocks</b> : ddpt if=/dev/null rtype=zero bs=512 of=/dev/sg4
<div>&#x00A0;</div>
<br/>
 <b>read to tokens</b> : ddpt if=/dev/sg3 bs=512 skip=@gath.lst rtf=a.rt
<div>&#x00A0;</div>
<br/>
 <b>write from tokens</b> : ddpt rtf=a.rt bs=512 of=/dev/sg4 seek=@scat.lst
<div class="Pp"></div>
The full copy will call PT and WUT commands repeatedly until the copy is
  complete. More precisely the full copy will make the largest single call to PT
  allowed by the input's Third Party Copy VPD page (and, if given, allowed by
  the <i>BPT</i> argument in the <i>bpt=BPT[,OBPC]</i> option). Then one or more
  WUT calls are made to write out from the ROD created by the PT step. The
  largest single WUT call is constrained by the output's Third Party Copy VPD
  page (and, if given, allowed by the <i>OBPC</i> argument in the
  <i>bpt=BPT[,OBPC]</i> option). This sequence continues until the requested
  copy is complete.
<div class="Pp"></div>
The zero output blocks variant is a special case of the full copy in which only
  WUT calls are made. ODX defines a special ROD Token to zero blocks. That
  special ROD Token has a fixed pattern (shown in SBC-3) and does not need to be
  created by a PT command like normal ROD Tokens.
<div class="Pp"></div>
The read to tokens and the write from tokens variants are designed to be the
  read (input) and write (output) sides respectively of a network copy. Each can
  run on different machines by sending the <i>RTF</i> file from the machine
  doing the read to the machine doing the write. The read to tokens will make
  one or more PT calls and output the resulting ROD Tokens to the <i>RTF</i>
  file. <i>RTF</i> might be a regular file or a named pipe.
<div class="Pp"></div>
All four variants can have the immed flag set. Then the PT and/or WUT commands
  are issued with the IMMED bit set and the RRTI command is used to poll for
  completion. The delay between the polls is as suggested by the RRTI command
  (or if no suggestion is made, 500 milliseconds). Either iflag=immed,
  oflag=immed or both can be given but are only effective if the corresponding
  <i>IFILE</i> or <i>OFILE</i> sends a PT or WUT command.
<div class="Pp"></div>
Typically there is no need to give the <i>list_id=LID</i> option. If this option
  is not given then 257 is chosen. If that is busy then 258 is tried. That
  continues until a usable <i>LID</i> is found or 10 <i>LID</i>s have been
  tried. In the latter case ddpt exits with status of 55 (operation in
  progress). If the user gives <i>list_id=LID</i> option and <i>LID</i> is busy
  then ddpt exits with exit status 55.
<div class="Pp"></div>
If the block size of the input and output are different (i.e. <i>IBS</i> is not
  equal to <i>OBS</i>) then one must be a multiple of the other. So an input
  block size of 512 bytes and an output block size of 4096 bytes (or vice versa)
  is acceptable.
<div class="Pp"></div>
The four ODX variants are distinguished as follows: if <i>OFILE</i> is a
  pass-through device, if=/dev/null (or equivalent) and rtype=zero then the zero
  output blocks variant is selected. If both <i>IFILE</i> and <i>OFILE</i> are
  pass-through devices and there is some indication of an ODX request (e.g. the
  <i>--odx</i> option), then the full copy variant is selected. The read to
  tokens and the write from token variants are indicated by the absence of
  either a <i>of=OFILE</i> or a <i>if=IFILE</i> option, respectively, plus the
  presence of a <i>rtf=RTF</i> option.
<div class="Pp"></div>
The helper utility ddptctl contains options to issue a single PT, RRTI, WUT or
  COPY OPERATION ABORT command. It can also issue a series of polling RRTI
  commands. It can decode information in ROD Tokens (which is not as informative
  as it should be) and print the number of blocks and block size of a disk, plus
  protection information if available. See ddptctl.
<div class="Pp"></div>
There is a web page discussing ddpt, XCOPY and ODX at
  http://sg.danny.cz/sg/ddpt_xcopy_odx.html
<h1 class="Sh" title="Sh" id="SPARSE_WRITES"><a class="selflink" href="#SPARSE_WRITES">SPARSE
  WRITES</a></h1>
Bypassing writes of blocks full of zeros can save a lot of IO. However with
  regular files, bypassed writes at the end of the copy can lead to an
  <i>OFILE</i> which is shorter than it would have been without sparse writes.
  This can lead to integrity checking programs like md5sum and sha1sum
  generating different values.
<div class="Pp"></div>
This utility has two ways of handling this file length problem: writing the last
  block (even if it is full of zeros) or using the ftruncate system call. A
  third approach is to ignore the problem (i.e. leaving <i>OFILE</i> shorter).
  The ftruncate approach is used when &quot;oflag=strunc&quot; while the last
  block is written when &quot;oflag=sparse&quot;. To ignore the file length
  issue use &quot;oflag=sparse,sparse&quot;. Note that if <i>OFILE</i>'s length
  is already correct or longer than required, no action is taken.
<div class="Pp"></div>
The support for sparse writing of regular files may depend on the OS, the file
  system and the settings of <i>OFILE</i>. POSIX makes few guarantees when the
  ftruncate system call is used to extend a file's length, as may occur when
  &quot;oflag=strunc&quot;. Further, primitive file systems like VFAT may not
  accept sparse writes or simulate the effect by writing blocks of zeros. The
  latter approach will defeat any sparse writing performance gain.
<h1 class="Sh" title="Sh" id="TRIM,_UNMAP_AND_WRITE_SAME"><a class="selflink" href="#TRIM,_UNMAP_AND_WRITE_SAME">TRIM,
  UNMAP AND WRITE SAME</a></h1>
This is a new storage feature often associated with Solid State Disks (SSDs) or
  disk arrays with &quot;thin provisioning&quot;. In the ATA command set (ACS-2)
  the relevant command is DATA SET MANAGEMENT with the TRIM bit set. In the SCSI
  command set (SBC-3) it is either the UNMAP or WRITE SAME command. Note there
  is no TRIM command however the term is frequently used in the technical press.
<div class="Pp"></div>
Trim is a way of telling a storage device that blocks are no longer needed.
  Keeping the pool of unwritten blocks large is important for the write
  performance of SSDs and the thrifty use of real storage in thin provisioned
  arrays. Currently file systems in recent OSes may issue trims associated with
  file deletes. The trim option in ddpt may be useful when a partition or a
  whole SSD is to be &quot;deleted&quot;. Note that ddpt is bypassing file
  systems in that it only offers trim on pass-through (pt) devices.
<div class="Pp"></div>
This utility issues SCSI commands to pt devices and for &quot;trim&quot;
  currently issues a SCSI WRITE SAME(16) command with the UNMAP bit set. If the
  pt device is a SSD with a ATA interface then recent versions of Linux will
  translate the SCSI WRITE SAME to the ATA DATA SET MANAGEMENT command with the
  TRIM bit set. The maximum size of each &quot;trim&quot; command sent is the
  size of the copy buffer (i.e. <i>IBS</i> * <i>BPT</i> bytes). And that maximum
  can be reduced with the <i>OBPC</i> argument of the &quot;bpt=&quot; option.
<div class="Pp"></div>
The trim can be used various ways. One way is a copy where the copy buffer (or
  some part of it) is checked for zeros as is done by the sparse oflag. When a
  zero segment is found, a trim &quot;command&quot; is sent to the <i>OFILE</i>.
  For example:
<div class="Pp"></div>
<br/>
 ddpt if=dsk.img bs=512 of=/dev/sdc oflag=pt,trim
<div class="Pp"></div>
The copy buffer is 64 KiB (since <i>BPT</i> and <i>OBPC</i> default to 128 when
  &quot;bs=512&quot;) and it is checked for all zeros. If it is all zeros then a
  trim command is sent to the corresponding location of /dev/sdc which is
  accessed via the pt interface. If it is not all zeros then a SCSI WRITE
  command is sent. Another way is to trim all or part of a disk. To trim a whole
  disk (i.e. deleting all its data):
<div class="Pp"></div>
<br/>
 ddpt if=/dev/zero bs=512 of=/dev/sdc oflag=pt,trim
<div class="Pp"></div>
A third way is to &quot;self-trim&quot; which is to only trim those parts of a
  disk that contain segments full of zeros:
<div class="Pp"></div>
<br/>
 ddpt if=/dev/sdc skip=0x2300 bs=512 iflag=pt,self,trim count=0x1234f0
<div class="Pp"></div>
The &quot;self&quot; oflag automatically sets up the output side of the copy to
  send trim commands (if required) back the the same device (i.e. /dev/sdc). If
  this example was self-trimming a partition then the partition would start at
  LBA 0x2300 and be 0x1234f0 blocks long.
<div class="Pp"></div>
Some random product examples: the Intel X25-M G2 SSDs have trim with recent
  firmware and they do deterministic read zero after trim. The Seagate Pulsar
  SSD has an ATA interface which supports the deterministic reads of zero after
  the DATA SET MANAGEMENT command with the TRIM option.
<h1 class="Sh" title="Sh" id="DD_DIFFERENCES"><a class="selflink" href="#DD_DIFFERENCES">DD
  DIFFERENCES</a></h1>
dd defaults &quot;if=&quot; and &quot;of=&quot; to stdin and stdout
  respectively. This follows Unix filter conventions. However since dd and ddpt
  are often used to read binary data for timing purposes, having to supply
  &quot;of=/dev/null&quot; can be easily forgotten. Without it dd will typically
  spew binary data on the console. So ddpt has changed its defaults: the
  &quot;if= <i>IFILE</i>&quot; is now mandatory for direct copies and to read
  from stdin &quot;if=-&quot; can be used; &quot;of= <i>OFILE</i>&quot; remains
  optional but its default changes to &quot;/dev/null&quot; (or &quot;NUL&quot;
  in Windows). To send output to stdout ddpt accepts &quot;of=-&quot;.
<div class="Pp"></div>
dd truncates <i>OFILE</i> unless &quot;conv=notrunc&quot; is given. When dd
  truncates, it truncates to zero length unless <i>SEEK</i> is greater than
  zero. ddpt does not truncate <i>OFILE</i> by default. If <i>OFILE</i> exists
  it will be overwritten. The overwrite starts at block zero unless <i>SEEK</i>
  or &quot;oflag=append&quot; is given. If <i>OFILE</i> is a regular file then
  &quot;oflag=trunc&quot; (or &quot;conv=trunc&quot;) will truncate <i>OFILE</i>
  prior to the copy.
<div class="Pp"></div>
Numeric arguments to ddpt can be given in hexadecimal, either with a leading
  &quot;0x&quot; or &quot;0X&quot; or with a trailing &quot;h&quot;. Note that
  dd accepts &quot;0x123&quot; but interprets it as &quot;0 * 123&quot; (i.e.
  zero). ddpt will also interpret &quot;x&quot; as multiplies unless the left
  operand is zero (e.g. &quot;0x123&quot;). So both dd and ddpt will interpret
  &quot;skip=2x123&quot; as &quot;skip=246&quot;.
<div class="Pp"></div>
Terabyte size disks make it impractical to copy all the data into a buffer
  before writing it out. Therefore both dd and ddpt read a relatively small
  amount of data into a copy (or transfer) buffer then write it out to the
  destination, repeating this process until the <i>COUNT</i> is exhausted.
<div class="Pp"></div>
A major difference in ddpt is the addition of <i>BPT</i> to control the size of
  the copy buffer. With dd, <i>IBS</i> is the size of the copy buffer and the
  unit of <i>SKIP</i> and <i>COUNT</i>. With ddpt, <i>IBS</i> * <i>BPT</i> is
  the size of the copy buffer and <i>IBS</i> is the unit of <i>SKIP</i> and
  <i>COUNT</i>. This allows ddpt to have its <i>IBS</i> set to the logical block
  size of <i>IFILE</i> without unduly restricting the size of the copy buffer.
  And setting <i>IBS</i> (and <i>OBS</i> for <i>OFILE</i>) accurately is
  required when the pass-through interface is used since with the SCSI READ and
  WRITE commands the logical block size is implicit.
<div class="Pp"></div>
The way dd handles its copy buffer (outlined in SUSv4 description of dd) is
  relatively complex, especially when <i>IBS</i> and <i>OBS</i> are different
  sizes. The restriction that ddpt places on <i>IBS</i> and <i>OBS</i> ( i.e.
  ((( <i>IBS * BPT</i>) % <i>OBS</i>) == 0) ) means that a single copy buffer
  can be used since its size is a multiple of both <i>IBS</i> and <i>OBS</i>.
  Being able to precisely define the copy buffer size in ddpt makes sparse
  writing, write sparing and trim operations simpler to define and the user to
  control.
<div class="Pp"></div>
ddpt does not support dd's &quot;cbs=&quot; option (conversion block size). If
  the &quot;cbs=&quot; option is given to ddpt then it is ignored.
<div class="Pp"></div>
ddpt adds two types of disk to disk, offloaded copies: XCOPY(LID1) first
  introduced in SPC-2 (standardized in 2001), and ODX which is a subset of
  XCOPY(LID4) first introduced in SPC-4 draft (revision 34, 2012).
<h1 class="Sh" title="Sh" id="PROTECTION_INFORMATION"><a class="selflink" href="#PROTECTION_INFORMATION">PROTECTION
  INFORMATION</a></h1>
This section is about protection information which is typically an extra 8 bytes
  associated with each logical block. Those 8 byte are divided into 3 fields:
  logical block guard (16 bit (2 byte) CRC), logical block application tag (2
  bytes) and the logical block reference tag (4 bytes). The acronym DIF is
  sometimes used for protection information.
<div class="Pp"></div>
The feature to read and/or write protection information by using the
  <i>protect=RDP[,WRP]</i> option is currently experimental. It should be used
  with care and may not &quot;play well&quot; with some other features such as
  write sparing and sparse writing. It should be used to copy user data plus the
  associated protection information to or from a regular file. It could also be
  used for a device to device copy assuming the &quot;pt&quot; interface is used
  for both. Also only modern SCSI disks support protection information.
<div class="Pp"></div>
When <i>RDP</i> or <i>WRP</i> is greater than 0 then a copy with associated
  protection information is active. In this state <i>IBS</i> and <i>OBS</i> must
  be the same and equal to the logical block size of the device(s) formatted
  with protection information. If a SCSI disk with 512 byte logical block size
  has protection information then the actual number of bytes transferred for
  each logical block is typically 520 bytes. For such a disk <i>BS=512</i> is
  required even when additional protection information is being transferred.
<h1 class="Sh" title="Sh" id="MULTIPLIERS"><a class="selflink" href="#MULTIPLIERS">MULTIPLIERS</a></h1>
By default numeric arguments to options are assumed to be decimal. Almost all
  numeric arguments to options (e.g. <i>COUNT</i> in the <i>count=COUNT</i>
  option) may include one of these multiplicative suffixes: c C *1; w W *2; b B
  *512; k K KiB *1,024; KB *1,000; m M MiB *1,048,576; MB *1,000,000 . This
  pattern continues for &quot;G&quot;, &quot;T&quot; and &quot;P&quot;. The
  latter two suffixes can only be used for 64 bit values. Some numeric arguments
  are limited to 32 bit values (e.g. <i>BS</i>in the <i>bs=BS</i> option). Also
  a suffix of the form &quot;x&lt;n&gt;&quot; multiplies the leading number by
  &lt;n&gt;; however the combinations &quot;0x&quot; and &quot;0X&quot; are
  treated differently, see the next paragraph. These multiplicative suffixes are
  compatible with GNU's dd command (since 2002) which claims compliance with the
  SI and with IEC 60027-2 standards.
<div class="Pp"></div>
Alternatively numerical values can be given in hexadecimal indicated by either a
  leading &quot;0x&quot; or &quot;0X&quot;, or by a trailing &quot;h&quot; or
  &quot;H&quot;. When hex numbers are given, suffix multipliers cannot be used.
<div class="Pp"></div>
If a numeric argument is required to fit in 32 bits and is too large then an
  error is reported. Usually negative numbers are not permitted but
  &quot;count=-1&quot; is a special case and means &quot;all available&quot;;
  &quot;verbose=-1&quot; is another special case.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
A partial write is a write to the <i>OFILE</i> of less than <i>OBS</i> bytes.
  This typically occurs at the end of a copy. dd can do partial writes. ddpt
  does partial writes to regular files and fifos (including stdout). However
  ddpt ignores partial writes when <i>OFILE</i> is a block device or a pt
  device. When ddpt ignores a partial write, it sends a warning to the console
  (stderr).
<div class="Pp"></div>
At the end of the copy two lines are reported to the console:
<div>&#x00A0;</div>
<br/>
 &lt;in_full&gt;+&lt;in_partial&gt; records in
<div>&#x00A0;</div>
<br/>
 &lt;out_full&gt;+&lt;out_partial&gt; records out
<div class="Pp"></div>
The &quot;records in&quot; line is the number of full input blocks (each of
  <i>IBS</i> bytes) that have been read plus the number of partial blocks (
  usually less than <i>IBS</i> bytes) that have been read. Following the lead of
  dd when 'iflag=coe' is active a block that cannot be read (and has zeros
  substituted for its output) is regarded as a partial read. The &quot;records
  out&quot; line is the number of full output blocks (each of <i>OBS</i> bytes)
  that have been written plus the number of partial blocks (usually less than
  <i>OBS</i> bytes) that have been written.
<div class="Pp"></div>
Block devices (e.g. /dev/sda and /dev/hda) can be given for <i>IFILE</i>. If
  neither 'iflag=direct' nor 'iflag=pt' is given then normal block IO involving
  buffering and caching is performed. If 'iflag=direct' is given then the
  buffering and caching is bypassed (this is applicable to both SCSI devices and
  ATA disks). When 'iflag=pt' is given SCSI commands are sent to the device
  which bypasses most of the actions performed by the block layer. The same
  applies for block devices given for <i>OFILE</i>.
<div class="Pp"></div>
All informative, warning and error reports are sent to stderr so that dd's
  output file can be stdout and remain unpolluted. If no options are given, then
  no copying (nor reading) takes place and a brief message is sent to stderr
  inviting the user to invoke ddpt again but with '--help' option to get the
  usage message.
<div class="Pp"></div>
Disk partition information can often be found with <b>fdisk(8)</b> [the
  &quot;-ul&quot; argument is useful in this respect]. Also <b>parted(8)</b> can
  be used like this: 'parted /dev/sda unit s print' .
<div class="Pp"></div>
For pt devices this utility issues SCSI READ and WRITE (SBC) commands which are
  appropriate for disks and reading from CD/DVD/BD drives. Those commands are
  not formatted correctly for tape drives so ddpt cannot be used on tape drives
  via a pt device. If the largest block address of the requested transfer
  exceeds a 32 bit block number (i.e 0xffffffff) then a warning is issued and
  the pt device is accessed via SCSI READ(16) and WRITE(16) commands.
<div class="Pp"></div>
<b>The attributes of a block device (e.g. partitions) are ignored when the</b>
  <b>pt flag is used.</b> Hence the whole device is read (rather than just the
  second partition) by this invocation:
<div class="Pp"></div>
<br/>
 ddpt if=/dev/sdb2 iflag=pt of=t bs=512
<div class="Pp"></div>
Assuming /dev/sdb and /dev/sg2 refer to the same device, then after the
  following two invocations, the contents of the files &quot;t&quot;,
  &quot;tt&quot; and &quot;ttt&quot; should be same:
<div class="Pp"></div>
<br/>
 ddpt if=/dev/sdb of=tt bs=512
<div class="Pp"></div>
<br/>
 ddpt if=/dev/sg2 of=ttt bs=512
<div class="Pp"></div>
The SCSI READ(32) and WRITE(32) commands are restricted to media that is
  formatted with protection type 2. This is a T10 restriction.
<h1 class="Sh" title="Sh" id="SIGNALS"><a class="selflink" href="#SIGNALS">SIGNALS</a></h1>
The signal handling has been borrowed from GNU's dd: SIGINT, SIGQUIT and SIGPIPE
  report the number of remaining blocks to be transferred and the records in +
  out counts; then they have their default action. SIGUSR1 (or SIGINFO) causes
  the same information to be output and the copy continues. All output caused by
  signals is sent to stderr.
<div class="Pp"></div>
Like GNU's dd, ddpt respects the signal disposition of &quot;ignored&quot;
  (SIG_IGN) set by the shell, script or other program that invokes ddpt. So in
  that case it will ignore such signals. Further dd ignores SIGUSR1 if the
  environment variable POSIXLY_CORRECT is set because POSIX defines dd will only
  act on SIGINFO (and Linux has no such signal); ddpt ignores the
  POSIXLY_CORRECT environment variable. As recommended by Susv3, ddpt does not
  expect the signal (blocking) mask to be blocking SIGUSR1 (SIGINFO), SIGINT or
  SIGPIPE on entry.
<div class="Pp"></div>
Unix system calls that do IO can be interrupted by signal processing, typically
  returning an EINTR error number. The dd utility (and many other Unix
  utilities) restart the IO operation that was interrupted. While this will work
  most of the time for disk IO it is problematic for tape drives because the
  implicit position pointer on the tape may have moved. So the default (i.e.
  &quot;intio=0&quot;) in this utility is to mask those signals during IO
  operations and only check them prior to starting an IO operation. Most low
  level IO (e.g. using SCSI command to write to a disk) will timeout if there is
  a low level error. However NFS (the Network File System) will potentially wait
  for a long time (e.g. expecting a network problem will soon be fixed) and in
  this case using &quot;intio=1&quot; may be best.
<h1 class="Sh" title="Sh" id="TAPE"><a class="selflink" href="#TAPE">TAPE</a></h1>
There is support for copies to and from tape drives in Linux. Only the st driver
  device names can be used (e.g. /dev/st0 and /dev/nst2). Hence use of Linux
  pass-through device names (e.g. /dev/sg2) for tape drives is not supported. On
  Debian-based distributions, it is suggested that the mt-st package is
  installed as it provides a more fully-featured version of the &quot;mt&quot;
  tape control program.
<div class="Pp"></div>
Tape drives can operate in fixed- or variable-length block modes. In
  variable-block mode, each write to the tape writes a single block of that
  size. In fixed-block mode, each write to the tape must be a multiple of the
  previously-selected block size.
<div class="Pp"></div>
The block size/mode can be set with the mt command prior to invoking ddpt. For
  example:
<div>&#x00A0;</div>
<br/>
 # mt -f /dev/nst0 setblk 0
<div>&#x00A0;</div>
sets variable-block mode, and
<div>&#x00A0;</div>
<br/>
 # mt -f /dev/nst0 setblk 32768
<div>&#x00A0;</div>
sets fixed-block mode with block size 32768 bytes.
<div class="Pp"></div>
Note that some tape drives support only fixed-block mode, and possibly even only
  one block size. (For example, QIC-150 tapes use a fixed block size of 512
  bytes.) There may also be restrictions on the block size, e.g. it may have to
  be even.
<div class="Pp"></div>
When using ddpt to write to tape, if the final read from the input is less than
  <i>OBS</i>, it is padded to <i>OBS</i> bytes before writing to tape to ensure
  that all blocks of the tape file are the same length. Having a shorter final
  block would fail if the drive is in fixed-block mode, and could create
  interchange problems. It is common to expect all blocks in a file on tape to
  be the same length. However, to tell ddpt to not pad the final block, use
  'oflag=nopad'.
<div class="Pp"></div>
The st tape driver normally writes a filemark when the file (e.g. /dev/nst0) is
  closed. To not have the filemark written, use 'oflag=nofm'. One use case for
  that might be if using ddpt several times in succession to append more data to
  the same file on tape. In that case it is probably desirable to write the
  filemark at the end of the sequence. So either omit 'oflag=nofm' on the last
  ddpt invocation, or manually write a filemark using mt after ddpt exits:
<div>&#x00A0;</div>
<br/>
 # mt -f /dev/nst0 weof 1
<div class="Pp"></div>
For reading from an unknown tape where the block size(s) is not known, read in
  variable-block mode specifying a large <i>IBS</i>. The st driver returns a
  smaller amount of data if the size of the block read is smaller. Thus a
  command like:
<div>&#x00A0;</div>
<br/>
 # ddpt if=/dev/nst0 of=output.bin bs=262144
<div>&#x00A0;</div>
should read the file from tape regardless of the block size used (assuming no
  blocks are larger than 256KB). ddpt's verbose option will display what the
  actual block size(s) is.
<h1 class="Sh" title="Sh" id="ENVIRONMENT_VARIABLES"><a class="selflink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
If the command line invocation of an xcopy does not explicitly (and
  unambiguously) indicate whether the XCOPY SCSI command should be sent to
  <i>IFILE</i> (i.e. the source) or <i>OFILE</i> (i.e. the destination) then a
  check is made for the presence of the XCOPY_TO_SRC and XCOPY_TO_DST
  environment variables. If either one exists (but not both) then it indicates
  where the SCSI XCOPY command will be sent. By default the XCOPY command is
  sent to <i>OFILE</i>.
<div class="Pp"></div>
The ODX write from tokens variant is very complex to implement if the amount of
  data held in each ROD is not known. The value should be found in the
  &quot;number of bytes represented&quot; field in the ROD Token but that is not
  well supported yet by vendors. So for such case that number can be appended as
  a big endian 8 byte integer following each ROD Token in the <i>RTF</i> file.
  The <i>conv=rtf_len</i> will cause that length to be appended. Specifying that
  option on each read to tokens and write from tokens invocation can be a
  nuisance. Setting the environment variable ODX_RTF_LEN will cause this utility
  to act as if the <i>conv=rtf_len</i> option has been given.
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
To aid scripts that call ddpt, the exit status is set to indicate success (0) or
  failure (1 or more). Note that some of the lower values correspond to the SCSI
  sense key values. The exit status values are:
<dl class="Bl-tag">
  <dt class="It-tag"><b>0</b></dt>
  <dd class="It-tag">success</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>1</b></dt>
  <dd class="It-tag">syntax error. Either illegal command line options, options
      with bad arguments or a combination of options that is not permitted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>2</b></dt>
  <dd class="It-tag">the device reports that it is not ready for the operation
      requested. The device may be in the process of becoming ready (e.g.
      spinning up but not at speed) so the utility may work after a wait.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>3</b></dt>
  <dd class="It-tag">the device reports a medium or hardware error (or a blank
      check). For example an attempt to read a corrupted block on a disk will
      yield this value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>5</b></dt>
  <dd class="It-tag">the device reports an &quot;illegal request&quot; with an
      additional sense code other than &quot;invalid operation code&quot;. This
      is often a supported command with a field set requesting an unsupported
      capability.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>6</b></dt>
  <dd class="It-tag">the device reports a &quot;unit attention&quot; condition.
      This usually indicates that something unrelated to the requested command
      has occurred (e.g. a device reset) potentially before the current SCSI
      command was sent. The requested command has not been executed by the
      device. Note that unit attention conditions are usually only reported once
      by a device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>9</b></dt>
  <dd class="It-tag">the device reports an illegal request with an additional
      sense code of &quot;invalid operation code&quot; which means that it
      doesn't support the requested command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>11</b></dt>
  <dd class="It-tag">the device reports an aborted command. In some cases
      aborted commands can be retried immediately (e.g. if the transport aborted
      the command due to congestion).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>15</b></dt>
  <dd class="It-tag">the utility is unable to open, close or use the given
      <i>IFILE</i> or <i>OFILE</i>. The given file name could be incorrect or
      there may be permission problems. Adding the <i>-v</i> option may give
      more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>20</b></dt>
  <dd class="It-tag">the device reports it has a check condition but &quot;no
      sense&quot;. It is unlikely that this value will occur as an exit
    status.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>21</b></dt>
  <dd class="It-tag">the device reports a &quot;recovered error&quot;. The
      requested command was successful. Most likely a utility will report a
      recovered error to stderr and continue, probably leaving the utility with
      an exit status of 0 .</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>33</b></dt>
  <dd class="It-tag">the command sent to device has timed out. This occurs in
      Linux only; in other ports a command timeout will appear as a transport
      (or OS) error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>51</b></dt>
  <dd class="It-tag">a command received 'illegal field in parameter list'. This
      may occur with an odx copy if some combination of parameters is illegal or
      not supported (e.g. iflag=immed)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>55</b></dt>
  <dd class="It-tag">a command received 'operation in progress'. This may occur
      with an odx copy when the given <i>LID</i> is already being used by
      another process (e.g. also using odx) on the same machine. Choose another
      <i>LID</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>70</b></dt>
  <dd class="It-tag">a command received 'invalid token operation, cause not
      reportable'. This may occur with an odx operation when the given ROD Token
      is invalid. One reason for that may be the inactivity timeout has been
      reached and the copy manager has cancelled the ROD Token.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>71-89</b></dt>
  <dd class="It-tag">these status values provide more information than exit
      status 70. See SPC-4 ASC and ASCQ assignments (currently in Annex F.2),
      specifically the entries for asc=23h . For example exit status 72
      corresponds to asc=23h, ascq=2h which implies the odx copy manager does
      not support copies between LUs in different targets. That is optional; an
      odx copy manager is required to support copies between LUs (that are block
      devices) in the same target.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>90</b></dt>
  <dd class="It-tag">the flock flag has been given on a device and some other
      process holds the advisory exclusive lock.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>97</b></dt>
  <dd class="It-tag">the response to a SCSI command failed sanity checks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>98</b></dt>
  <dd class="It-tag">the device reports it has a check condition but the error
      doesn't fit into any of the above categories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>99</b></dt>
  <dd class="It-tag">any errors that can't be categorized into values 1 to 98
      may yield this value. This includes transport and operating system errors
      after the command has been sent to the device.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
The examples in this page use Linux device names. For suitable device names in
  other supported Operating Systems see this web page:
  http://sg.danny.cz/sg/device_name.html . The sg3_utils(8) man page in the
  sg3_utils package also covers device naming.
<div class="Pp"></div>
ddpt usage looks quite similar to dd:
<div class="Pp"></div>
<br/>
 ddpt if=/dev/sg0 of=t bs=512 count=1MB
<div class="Pp"></div>
This will copy 1 million 512 byte blocks from the device associated with
  /dev/sg0 (which should have 512 byte blocks) to a file called t. Assuming
  /dev/sda and /dev/sg0 are the same device then the above is equivalent to:
<div class="Pp"></div>
<br/>
 dd if=/dev/sda iflag=direct of=t bs=512 count=1000000
<div class="Pp"></div>
although dd's speed may improve if bs was larger and count was suitably reduced.
  The use of the 'iflag=direct' option bypasses the buffering and caching that
  is usually done on a block device.
<div class="Pp"></div>
The dd command's bs argument can be thought of as roughly equivalent to ddpt's
  bs*bpt . dd almost assumes buffering on a block device and will work as long
  as bs is a multiple of the actual logical block size. Since ddpt can work at a
  lower level in some cases the bs argument must be a disk's actual logical
  block size. Thus the bpt argument was introduced to make the copy more
  efficient. So these two invocations are roughly equivalent:
<div class="Pp"></div>
<br/>
 dd if=/dev/sda of=t bs=8k count=64
<div>&#x00A0;</div>
<br/>
 ddpt if=/dev/sda of=t bs=512 bpt=16 count=1k
<div class="Pp"></div>
In both cases the total number of bytes moved is bs*count . And that will be
  done by reading 8k (8192 bytes) into a buffer then writing out that buffer to
  the file t. The read write sequence continues until the count is complete or
  an error occurs.
<div class="Pp"></div>
The 'of2=' option can save time when the input would otherwise need to be read
  twice. For example, to copy data and take a md5sum of it without needing to
  re-read the data:
<div class="Pp"></div>
<br/>
 mkfifo fif
<div>&#x00A0;</div>
<br/>
 md5sum fif &amp;
<div>&#x00A0;</div>
<br/>
 ddpt if=/dev/sg3 iflag=coe of=sg3.img oflag=sparse of2=fif bs=512
<div class="Pp"></div>
This will image /dev/sg3 (e.g. an unmounted disk) and place the contents in the
  (sparse) file sg3.img . Without re-reading the data it will also perform a
  md5sum calculation on the image.
<div class="Pp"></div>
Now we use sparse writing logic to get some idea of how many blocks on a disk
  are full of zeros. After a SCSI FORMAT UNIT command or an ATA SECURITY ERASE
  command a disk may be all zeros.
<div class="Pp"></div>
<br/>
 ddpt if=/dev/sdc bs=512 oflag=sparse
<div class="Pp"></div>
Since no &quot;of=&quot; option is given, output goes to /dev/null so nothing is
  actually written so the &quot;records out&quot; will be zero. However there
  will be a count of &quot;records in&quot; and &quot;bypassed records
  out&quot;. If /dev/sdc is full of zeros then &quot;records in&quot; and
  &quot;bypassed records out&quot; will be the same. Since the &quot;bpt=&quot;
  option is not given it defaults to &quot;bpt=128,128&quot; so the copy buffer
  will be 64 KiB and the sparse check for zeros will be done with 64 KiB (128
  block) granularity.
<div class="Pp"></div>
For examples of the trim and self,trim options see the section above on TRIM,
  UNMAP AND WRITE SAME.
<div class="Pp"></div>
Following is an example run on a Windows OS using the '--wscan' option which
  shows the available device names (e.g. PD1) and the associated volume name(s):
<div class="Pp"></div>
<br/>
 ddpt -w
<div>&#x00A0;</div>
PD0 [C] FUJITSU MHY2160BH 0000
<div>&#x00A0;</div>
PD1 [DF] WD 2500BEV External 1.05 WD-WXE90
<div>&#x00A0;</div>
CDROM0 [E] MATSHITA DVD/CDRW UJDA775 CB03
<div class="Pp"></div>
So, for example, volumes D: and F: reside on PhysicalDisk1 (abbreviated to
  &quot;PD1&quot;) which is manufactured by WD (Western Digital).
<div class="Pp"></div>
Further examples can be found on this web page: http://sg.danny.cz/sg/ddpt.html
  . There is a text file containing examples called ddpt_examples.txt in the
  &quot;doc&quot; directory of this package's distribution tarball.
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Written by Doug Gilbert
<h1 class="Sh" title="Sh" id="REPORTING_BUGS"><a class="selflink" href="#REPORTING_BUGS">REPORTING
  BUGS</a></h1>
Report bugs to &lt;dgilbert at interlog dot com&gt;.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright &#x00A9; 2008-2014 Douglas Gilbert
<div>&#x00A0;</div>
This software is distributed under the GPL version 2. There is NO warranty; not
  even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
This utility has a companion/helper utility called <b>ddptctl(8)</b>
<div>&#x00A0;</div>
There is a web page discussing ddpt at http://sg.danny.cz/sg/ddpt.html
<div class="Pp"></div>
The lmbench package contains <b>lmdd</b> which is also interesting. For moving
  data to and from tapes see <b>dt</b> which is found at
  http://www.scsifaq.org/RMiller_Tools/index.html
<div class="Pp"></div>
To change mode parameters that effect a SCSI device's caching and error recovery
  see <b>sdparm(sdparm)</b>
<div class="Pp"></div>
To verify the data on the media or to verify it against some other copy of the
  data see <b>sg_verify(sg3_utils)</b>
<div class="Pp"></div>
To scan and repair disk partitions see TestDisk (testdisk).
<div class="Pp"></div>
Additional references: <b>dd(1), open(2), flock(2),
  sg_xcopy,sg_copy_results,</b> <b>sg_dd(sg3_utils)</b></div>
<table class="foot">
  <tr>
    <td class="foot-date">April 2014</td>
    <td class="foot-os">ddpt-0.94</td>
  </tr>
</table>
</body>
</html>
