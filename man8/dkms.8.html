<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 19:10:20 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DKMS(8) System Manager&rsquo;s Manual DKMS(8)</p>

<p style="margin-top: 1em">NAME <br>
dkms - Dynamic Kernel Module Support</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dkms [action] [options] [module/module-version]
[/path/to/source-tree] [/path/to/tarball.tar]
[/path/to/driver.rpm]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
dkms is a framework which allows kernel modules to be
dynamically built for each kernel on your system in a
simplified and organized fashion.</p>

<p style="margin-top: 1em">ACTIONS <br>
add [module/module-version] [/path/to/source-tree]
[/path/to/tarball.tar]</p>

<p style="margin-top: 1em">Adds a module/module-version
combination to the tree for builds and installs. If
module/module-version, -m module/module-version, or -m
module -v version are passed as <br>
options, this command requires source in
/usr/src/&lt;module&gt;-&lt;module-version&gt;/ as well as a
properly formatted dkms.conf file. If /path/to/source-tree
is passed as an option, <br>
and source-tree contains a dkms.conf file, it will copy
/path/to/source-tree to /usr/src/module-module-version. If
/path/to/tarball.tar is passed, this command behaves like
<br>
the ldtarball command.</p>

<p style="margin-top: 1em">remove [module/module-version]
[-k kernel/arch] [--all]</p>

<p style="margin-top: 1em">Removes a module/version or
module/version/kernel/arch combination from the tree. If the
module is currently installed, it first uninstalls it and if
applicable, will <br>
replace it with its original_module. Use the --all option in
order to remove all instances for every kernel at once.</p>

<p style="margin-top: 1em">build [module/module-version]
[-k kernel/arch]</p>

<p style="margin-top: 1em">Builds the specified
module/version combo for the specified kernel/arch. If the
-k option is not specified it builds for the currently
running kernel and arch.. All builds <br>
occur in the directory
/var/lib/dkms/&lt;module&gt;/&lt;module-version&gt;/build/.
If the module/module-version combo has not been added, dkms
will try to add it, and in that case build <br>
can take the same arguments that add can.</p>

<p style="margin-top: 1em">install [module/module-version]
[-k kernel/arch] [/path/to/driver.rpm]</p>

<p style="margin-top: 1em">Installs a built module/version
combo onto the kernel it was built for. If the kernel option
is not specified it assumes the currently running kernel. If
the module has not <br>
been built, dkms will try to build it. If the module has not
been added, dkms will try to add it. In both cases, the
install command can then take the same arguments as the <br>
build or add commands. If you pass a .rpm file, dkms will
try to install that file with rpm -Uvh , and it will perform
an autoinstall action to mesure that everything is <br>
built for your kernel if the RPM installed sucessfully.</p>

<p style="margin-top: 1em">uninstall
[module/module-version] [-k kernel/arch]</p>

<p style="margin-top: 1em">Uninstalls an installed
module/module-version combo from the kernel/arch passed in
the -k option, or the current kernel if the -k option was
not passed. upon. After unin&acirc; <br>
stall completion, the driver will be left in the built
state. To completely remove a driver, the remove action
should be utilized.</p>

<p style="margin-top: 1em">match [--templatekernel
kernel/arch] [-k kernel/arch]</p>

<p style="margin-top: 1em">Match installs modules onto the
specified kernel by looking at the configuration of the
specified templatekernel. Every module that is installed on
the templatekernel within <br>
dkms is then installed on that specified kernel.</p>

<p style="margin-top: 1em">mkdriverdisk [-d distro] [-r
release] [--media mediatype] [-k kernel/arch]
[module/version]</p>

<p style="margin-top: 1em">Creates a floppy driver disk
image for use when updated drivers are needed to install an
OS. Currently, the supported distributions are redhat, suse
and UnitedLinux. For Red <br>
Hat driver disks, necessary driver disk files are looked for
in the redhat_driver_disk subdirectory of your module source
directory. You must specify the distro while using <br>
this action. Driver disks can be made for single kernels or
can be made to support multiple kernels. To create a driver
disk image with modules for multiple kernels, just <br>
specify multiple -k parameters on the command line (-k
kernel1/arch1 -k kernel2/arch2).</p>

<p style="margin-top: 1em">Red Hat began supporting
multi-arched driver disks in RHEL3. To force creation of a
driver disk with arch information, specify -d redhat2 or if
you specify multiple archi&acirc; <br>
tectures on the command-line and use -d redhat , DKMS will
create a version 2 driver disk. By specifying -d redhat1 ,
you can force a version 1 driver disk image.</p>

<p style="margin-top: 1em">Note that redhat1 driver disks
actually supported multiple architectures when the second
arch was i386 and the kernel module was for the BOOT kernel.
DKMS allows for this, <br>
and as such you can create a redhat1 style driver disk if
the only other arch is i386 and the kernel name ends in
BOOT.</p>

<p style="margin-top: 1em">Red Hat introduced DDv3 starting
with RHEL6. To create Red Hat DDv3, specify -d redhat3 and
specify the specfile to use with --spec=specfile. If no
specfile is specified, <br>
DKMS will use /etc/dkms/template-dkms-redhat-kmod.spec</p>

<p style="margin-top: 1em">See
http://people.redhat.com/dledford for more information on
the Red Hat driver disk standards and which files are
necessary to make a driver disk.</p>

<p style="margin-top: 1em">Fedora Core 5 and higher, RHEL5
and higher require DKMS version 2.0.14 or higher to generate
a proper driver disk image.</p>

<p style="margin-top: 1em">For suse/UnitedLinux driver
disks, /usr/share/YaST2/modules/Vendor.ycp will also be
copied to the driver disk; no other files are needed.
However, for these distros, you <br>
must specify a -r release. For SuSE 9.1, it would be -d suse
-r 9.1. For SLES9, it would be -d suse -r sles9.</p>

<p style="margin-top: 1em">By default the disk image it
creates is 1440 (k) in size. This can be overridden by
specifying a different --size #### which should should be
given as a number in kilobytes <br>
divisible by 20.</p>

<p style="margin-top: 1em">You may have more content than
will fit on a floppy. Therefore, DKMS can now generate image
files of different types. --media floppy (default) to
generate a floppy disk <br>
image, or --media iso to generate a CD-ROM ISO file, or
--media tar to generate a tar file.</p>

<p style="margin-top: 1em">You may copy the floppy or ISO
image file to a USB key to be used with OS installer.</p>

<p style="margin-top: 1em">mktarball
[module/module-version] [-k kernel/arch] [--archive
/path/to/tarball.tar] [--source-only] [--binaries-only]</p>

<p style="margin-top: 1em">Creates a tarball archive for
the specified module/version of all files in the DKMS tree
for that module/version combination. This includes the
source and any built modules <br>
for kernels in the tree (as specified). Otherwise, you can
specify a singular kernel to archive only, or multiple
kernels to archive (-k kernel1/arch1 -k kernel2/arch2). <br>
Optionally, you can use --archive to specify the file that
you would like to save this tarball to. You can also specify
--binaries-only if you want the resultant tarball not <br>
to include the module source. Likewise, --source-only can be
used to specify that no prebuilt binaries should be included
in the tarball. In general, mktarball is great for <br>
systems management purposes as you can build your driver on
just one system and then use ldtarball on all of your other
systems to get the same built modules loaded without <br>
having to wait for anything to compile.</p>

<p style="margin-top: 1em">ldtarball</p>

<p style="margin-top: 1em">This takes a tarball made from
the mktarball command and loads it into your DKMS tree. This
will leave any newly added modules in the built state and
dkms install should <br>
then be called to install any of them. If files already
exist where ldtarball is attempting to place them, it will
warn and not copy over them. The --force option should be
<br>
used to override this.</p>

<p style="margin-top: 1em">mkrpm [module/module-version]
[-k kernel/arch] [--source-only] [--binaries-only]</p>

<p style="margin-top: 1em">This action allows you to create
an RPM package for a specified module / version. It uses a
template .spec file found in
/etc/dkms/template-dkms-mkrpm.spec as the basis for <br>
the RPM. Alternatively, if DKMS finds a file called
/usr/src/&lt;module&gt;-&lt;module-version&gt;/&lt;module&gt;-dkms-mkrpm.spec
it will use that .spec file instead. In general, a DKMS
tar&acirc; <br>
ball is placed inside the contents of this RPM, and the RPM
itself calls various DKMS commands to load this tarball,
build and install modules on the end user&rsquo;s system. If
<br>
you do not want your RPM to contain any prebuilt binaries,
be sure to specify --source-only in the mkrpm command.</p>

<p style="margin-top: 1em">mkdeb [module/module-version]
[-k kernel/arch] [--binaries-only] [--source-only]</p>

<p style="margin-top: 1em">This action allows you to create
a debian binary package for a specified module / version. It
uses a template debian directory found in
/etc/dkms/template-dkms-mkdeb as the <br>
basis for the package. Alternatively, if DKMS finds a file
called
/usr/src/&lt;module&gt;-&lt;module-version&gt;/&lt;module&gt;-dkms-mkdeb
it will use that folder instead. In general, a DKMS <br>
tarball is placed inside the contents of this package, and
the package itself calls various DKMS commands to load this
tarball, build and install modules on the end user&rsquo;s
<br>
system. If you do not want your debian package to contain
any prebuilt binaries, be sure to specify --source-only in
the mkdeb command.</p>

<p style="margin-top: 1em">mkbmdeb [module/module-version]
[-k kernel/arch]</p>

<p style="margin-top: 1em">Creates a Debian binary package
containing just the binary modules in the /lib/modules
installation path. This package does not depend on dkms and
does not require a <br>
toolchain to be installed on the target host. Useful if you
want to have a package to install on hosts identical to the
build system without installing the full toolchain on <br>
them. It uses a template debian directory found in
/etc/dkms/template-dkms-mkbmdeb as the basis for the
package.</p>

<p style="margin-top: 1em">mkdsc [module/module-version]
[-k kernel/arch] [--binaries-only] [--source-only]</p>

<p style="margin-top: 1em">This action allows you to create
a debian source package for a specified module / version. It
will create a .tar.gz, and a .dsc. All options supported by
mkdeb are sup&acirc; <br>
ported by it. The main difference in it&rsquo;s usage is
that it will look in /etc/dkms/template-dkms-mkdsc as the
basis for the package. Alternatively, if DKMS finds a file
<br>
called
/usr/src/&lt;module&gt;-&lt;module-version&gt;/&lt;module&gt;-dkms-mkdsc
it will use that folder instead. If you do not want your
debian source package to contain any prebuilt binaries, <br>
be sure to specify --source-only in the mkdsc command.</p>

<p style="margin-top: 1em">mkkmp [module/module-version]
[--spec specfile]</p>

<p style="margin-top: 1em">This action allows you to create
an Kernel Module Package source RPM for a specified module /
version. It uses the .spec file specified by --spec=specfile
else $mod&acirc; <br>
ule-kmp.spec as the basis for the RPM. The generated source
RPM may then be built using SuSE&rsquo;s build.rpm or
Fedora/RHEL&rsquo;s mock chroot environments. See
http://ker&acirc; <br>
neldrivers.org/ for more details on KMPs.</p>

<p style="margin-top: 1em">status [module/module-version]
[-k kernel/arch]</p>

<p style="margin-top: 1em">Returns the current status of
modules, versions and kernels within the tree as well as
whether they have been added, built or installed. Status can
be shown for just a cer&acirc; <br>
tain module, a certain kernel, a module/version combination
or a module/version/kernel combination.</p>

<p style="margin-top: 1em">autoinstall</p>

<p style="margin-top: 1em">Attempt to install the latest
revision of all modules that have been installed for other
kernel revisions. dkms_autoinstaller is a stub that uses
this action to perform its <br>
work.</p>

<p style="margin-top: 1em">OPTIONS <br>
-m &lt;module&gt;/&lt;module-version&gt; <br>
The name of the module and module version you wnat to
operate on. The -m part of this option is optional, and can
be omitted in virtually all circumstances.</p>

<p style="margin-top: 1em">-v &lt;module-version&gt; <br>
The version of the module to execute the specified action
upon. This option only has to be specified if you pass a -m
option without a &lt;module-version&gt; component of its
<br>
own.</p>

<p style="margin-top: 1em">-k
&lt;kernel-version&gt;/&lt;arch&gt; <br>
The kernel and arch to perform the action upon. You can
specify multiple kernel version/arch pairs on the command
line by repeating the -k argument with a different
ker&acirc; <br>
nel version and arch. However, not all actions support
multiple kernel versions (it will error out in this case).
The arch part can be omitted, and DKMS will assume you <br>
want it to be the arch of the currently running system.</p>

<p style="margin-top: 1em">-a, --arch <br>
The system architecture to perform the action upon. It is
optional if you pass it as part of the -k option. If not
specified, it assumes the arch of the currently running <br>
system (&lsquo;uname -m&lsquo;). You can specify multiple
arch parameters on the same command line by repeating the -a
argument with a different arch name. When multiple
architec&acirc; <br>
tures are specified, there must be a 1:1 relationship
between -k arguments to -a arguments. DKMS will then assume
the first -a argument aligns with the first -k kernel <br>
and so on for the second, third, etc.</p>

<p style="margin-top: 1em">For example, if you were to
specify: -k kernel1 -k kernel2 -a i386 -k kernel3 -a i686 -a
x86_64, DKMS would process this as: kernel1-i386,
kernel2-i686, kernel3-x86_64.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Quiet.</p>

<p style="margin-top: 1em">-V, --version <br>
Prints the currently installed version of dkms and
exits.</p>

<p style="margin-top: 1em">-c &lt;dkms.conf-location&gt;
<br>
The location of the dkms.conf file. This is needed for the
add action and if not specified, it is assumed to be located
in /usr/src/&lt;module&gt;-&lt;module-version&gt;/. See
below <br>
for more information on the format of dkms.conf.</p>

<p style="margin-top: 1em">-d, --distro <br>
The distribution being used. This is only currently needed
for mkdriverdisk. The supported distros are redhat, suse and
UnitedLinux. See the sections on mkdriverdisk <br>
and mkkmp for more information.</p>

<p style="margin-top: 1em">-r, --release <br>
The release being used. This is only currently used for
mkdriverdisk and is only used for suse or UnitedLinux
distros (eg. -r 9.1). It is used in the internal makeup of
<br>
the driverdisk.</p>

<p style="margin-top: 1em">--size The size of the driver
disk image to be created. By default, this value is set at
1440. Any different size should be given as an integer value
only, should be divisible <br>
by 20 and should represent the number of kilobytes of the
image size you desire.</p>

<p style="margin-top: 1em">--config
&lt;kernel-.config-location&gt; <br>
During a build this option is used to specify an alternate
location for the kernel .config file which was used to
compile that kernel. Normally, dkms uses the Red Hat <br>
standard location and config filenames located in
/usr/src/linux-&lt;kernel&gt;/configs/. If the config for
the kernel that you are building a module for is not located
here or <br>
does not have the expected name in this location, you will
need to tell dkms where the necessary .config can be found
so that your kernel can be properly prepared for the <br>
module build.</p>

<p style="margin-top: 1em">--archive
&lt;tarball-location&gt; <br>
This option is used during a ldtarball action to specify the
location of the tarball you wish to load into your DKMS
tree. You only have to specify the --archive part of <br>
this option if &lt;tarball-location&gt; does not already
exist as a file.</p>

<p style="margin-top: 1em">--templatekernel
&lt;kernel-version&gt; <br>
This option is required for the action: match. Match will
look at the templatekernel specified and install all of the
same module/version combinations on the other ker&acirc;
<br>
nel.</p>

<p style="margin-top: 1em">--force <br>
This option can be used in conjunction with ldtarball to
force copying over of extant files.</p>

<p style="margin-top: 1em">--binaries-only <br>
This option can be used in conjunction with mktarball in
order to create a DKMS tarball which does not contain the
source for the module within it. This can be helpful in <br>
reducing the size of the tarball if you know that the system
which this tarball will be loaded upon already has the
source installed. In order to load a tarball made as <br>
binaries-only you must have the module source in that
systems DKMS tree. If you do not, DKMS will refuse to load a
binaries-only tarball.</p>

<p style="margin-top: 1em">--source-only <br>
This option can be used in conjunction with mktarball or
mkrpm or mkdeb in order to create a DKMS tarball which does
not contain any prebuilt kernel module binaries within <br>
it. This is helpful if you simply want to easily tar up your
source but don&rsquo;t want anything prebuilt within it.
Likewise, if you are using mkrpm but do not want the RPM
<br>
you create to have any prebuilt modules within it, passing
this option will keep its internal DKMS tarball from
containing any prebuilt modules.</p>

<p style="margin-top: 1em">--all This option can be used to
automatically specify all relevant kernels/arches for a
module/module-version. This is useful for things like remove
, mktarball , etc. This <br>
saves the trouble of having to actually specify -k kernel1
-a arch1 -k kernel2 -a arch2 for every kernel you have built
your module for.</p>

<p style="margin-top: 1em">--no-prepare-kernel <br>
This option keeps DKMS from first preparing your kernel
before building a module for it. Generally, this option
should not be used so as to ensure that modules are
com&acirc; <br>
piled correctly.</p>

<p style="margin-top: 1em">--no-clean-kernel <br>
This option keeps DKMS from cleaning your kernel source tree
after a build.</p>

<p style="margin-top: 1em">--no-depmod <br>
This option prevents DKMS from running the depmod command
during install and uninstall which will avoid
(re)calculating module dependencies and thereby save
time.</p>

<p style="margin-top: 1em">--kernelsourcedir
&lt;kernel-source-directory-location&gt; <br>
Using this option you can specify the location of your
kernel source directory. Most likely you will not need to
set this if your kernel source is accessible via <br>
/lib/modules/$kernel_version/build.</p>

<p style="margin-top: 1em">--directive
&lt;&quot;cli-directive=cli-value&quot;&gt; <br>
Using this option, you can specify additional directives
from the command line. The --directive option can be used
multiple times on the same command-line to specify
mul&acirc; <br>
tiple additional command line directives.</p>

<p style="margin-top: 1em">--rpm_safe_upgrade <br>
This flag should be used when packaging DKMS enabled modules
in RPMs. It should be specified during both the add and
remove actions in the RPM spec to ensure that DKMS <br>
and RPM behave correctly in all scenarios when upgrading
between various versions of a dkms enabled module RPM
package. See the sample.spec file for an example or read
<br>
more in the section below on Creating RPMs Which Utilize
DKMS.</p>

<p style="margin-top: 1em">--spec specfile <br>
This option is used by the mkkmp action to specify which RPM
spec file to use when generating the KMP. specfile will be
sought in the module source directory.</p>

<p style="margin-top: 1em">--dkmstree path/to/place <br>
Provides a destination tree for building and installing
modules to. Useful in cases that you don&rsquo;t want to
contaminate a system when using solely for building.</p>

<p style="margin-top: 1em">--sourcetree path/to/place <br>
Provides a location to build a DKMS package from. Useful for
systems that you may not have root access, but would still
like to be able to build DKMS packages.</p>

<p style="margin-top: 1em">--installtree path/to/place <br>
Provides a location to place modules when a dkms install
command is issued.</p>

<p style="margin-top: 1em">--legacy-postinst=[0|1] <br>
Includes a legacy postinstall script so that a DEB or RPM
built by DKMS can be used on versions prior than DKMS 2.1.
This option currently defaults to 1.</p>

<p style="margin-top: 1em">--dkmsframework path/to/file
<br>
A supplemental configuration file to the system-wide dkms
framework, typically located in /etc/dkms/framework.conf.
All option that are normally provided on a command <br>
line can be provided in this file.</p>

<p style="margin-top: 1em">-j number <br>
Run no more than number jobs in parallel; see the -j option
of make(1). Defaults to the number of CPUs in the system,
detected by nproc(1). Specify 0 to impose no limit <br>
on the number of parallel jobs.</p>

<p style="margin-top: 1em">ORIGINAL MODULES <br>
During the first install of a module for a
&lt;kernelversion&gt;, dkms will search
/lib/modules/&lt;kernelversion&gt; for a pre-existing module
of the same name. If one is found, it will <br>
automatically be saved as an &quot;original_module&quot; so
that if the newer module is later removed, dkms will put the
original module back in its place. Currently, DKMS searches
for <br>
these original modules with first preference going to
modules located in
/lib/modules/&lt;kernelversion&gt;/updates/ followed by
$DEST_MODULE_LOCATION (as specified in dkms.conf ). If <br>
one cannot be found in either location, a find will be used
to locate one for that kernel. If none are found, then
during a later uninstall, your kernel will not have that
mod&acirc; <br>
ule replaced.</p>

<p style="margin-top: 1em">If more than one is found, then
the first one located (by preference indicated above) will
be considered the &quot;original_module&quot;. As well, all
copies of the same-named module will <br>
be removed from your kernel tree and placed into
/var/lib/dkms/&lt;module&gt;/original_module/$kernelver/collisions
so that they can be *manually* accessible later. DKMS will
never <br>
actually do anything with the modules found underneath the
/collisions directory, and they will be stored there until
you manually delete them.</p>

<p style="margin-top: 1em">DKMS.CONF <br>
When performing an add , a proper dkms.conf file must be
found. A properly formatted conf file is essential for
communicating to dkms how and where the module should be
<br>
installed. While not all the directives are required,
providing as many as possible helps to limit any ambiguity.
Note that the dkms.conf is really only a shell-script of
vari&acirc; <br>
able definitions which are then sourced in by the dkms
executable (of the format, DIRECTIVE=&quot;directive text
goes here&quot;). As well, the directives are case-sensitive
and should be <br>
given in ALL CAPS.</p>

<p style="margin-top: 1em">It is important to understand
that many of the DKMS directives are arrays whose index
values are tied together. These array associations can be
considered families, and there <br>
are currently four such families of directive arrays.
MAKE[#] and MAKE_MATCH[#] make up one family. PATCH[#] and
PATCH_MATCH[#] make up the second family. The third and <br>
largest family consists of BUILT_MODULE_NAME[#],
BUILT_MODULE_LOCATION[#], DEST_MODULE_NAME[#],
DEST_MODULE_LOCATION[#], MODULES_CONF_ALIAS_TYPE[#],
MODULES_CONF_OBSOLETES[#], <br>
MODULES_CONF_OBSOLETE_ONLY[#] and STRIP[#]. The fourth
family is made up of only MODULES_CONF[#]. When indexing
these arrays when creating your dkms.conf, each family
should <br>
start at index value 0.</p>

<p style="margin-top: 1em">MAKE[#]= <br>
The MAKE directive array tells DKMS which make command
should be used for building your module. The default make
command should be put into MAKE[0]. Other entries in the
<br>
MAKE array will only be used if their corresponding entry in
MAKE_MATCH[#] matches, as a regular expression (using
egrep), the kernel that the module is being built for. <br>
Note that if no value is placed in MAKE_MATCH[#] for any
MAKE[#] where # &gt; 0, then that MAKE directive is ignored.
MAKE_MATCH[0] is optional and if it is populated, it <br>
will be used to determine if MAKE[0] should be used to build
the module for that kernel. If multiple MAKE_MATCH
directives match against the kernel being built for, the
<br>
last matching MAKE[#] will be used to build your module. If
no MAKE directive is specified or if no MAKE_MATCH matches
the kernel being built for, DKMS will attempt to use <br>
a generic MAKE command to build your module.</p>

<p style="margin-top: 1em">KERNELRELEASE will be
automatically appended to MAKE[#]. If you want to suppress
this behavior, you can quote the make command:
&rsquo;make&rsquo;.</p>

<p style="margin-top: 1em">MAKE_MATCH[#]= <br>
See the above entry on MAKE[#] directives. This array should
be populated with regular expressions which, when matched
against the kernel being built for, will tell DKMS <br>
to use the corresponding make command in the MAKE[#]
directive array to build your module.</p>

<p style="margin-top: 1em">BUILT_MODULE_NAME[#]= <br>
This directive gives the name of the module just after it is
built. If your DKMS module package contains more than one
module to install, this is a required directive for <br>
all of the modules. This directive should explicitly not
contain any trailing &quot;.o&quot; or &quot;.ko&quot;. Note
that for each module within a dkms package, the numeric
value of # must <br>
be the same for each of BUILT_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION and that the numbering should start at
0 (eg. BUILT_MOD&acirc; <br>
ULE_NAME[0]=&quot;qla2200&quot;
BUILT_MODULE_NAME[1]=&quot;qla2300&quot;).</p>

<p style="margin-top: 1em">BUILT_MODULE_LOCATION[#]= <br>
This directive tells DKMS where to find your built module
after it has been built. This pathname should be given
relative to the root directory of your source files <br>
(where your dkms.conf file can be found). If unset, DKMS
expects to find your BUILT_MODULE_NAME[#] in the root
directory of your source files. Note that for each module
<br>
within a dkms package, the numeric value of # must be the
same for each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION,
DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the <br>
numbering should start at 0 (eg.
BUILT_MODULE_LOCATION[0]=&quot;some/dir/&quot;
BUILT_MODULE_LOCATION[1]=&quot;other/dir/&quot;).</p>

<p style="margin-top: 1em">DEST_MODULE_NAME[#]= <br>
This directive can be used to specify the name of the module
as it should be installed. This will rename the module from
BUILT_MODULE_NAME[#] to DEST_MODULE_NAME[#]. <br>
This directive should explicitly not contain any trailing
&quot;.o&quot; or &quot;.ko&quot;. If unset, it is assumed
to be the same value as BUILT_MODULE_NAME[#]. Note that for
each module <br>
within a dkms package, the numeric value of # must be the
same for each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION,
DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the <br>
numbering should start at 0 (eg.
DEST_MODULE_NAME[0]=&quot;qla2200_6x&quot;
DEST_MODULE_NAME[1]=&quot;qla2300_6x&quot;).</p>

<p style="margin-top: 1em">DEST_MODULE_LOCATION[#]= <br>
This directive specifies the destination where a module
should be installed to, once compiled. It also is used for
finding original_modules. This is a required direc&acirc;
<br>
tive, except as noted below. This directive must start with
the text &quot;/kernel&quot; which is in reference to
/lib/modules/&lt;kernelversion&gt;/kernel. Note that for
each module <br>
within a dkms package, the numeric value of # must be the
same for each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION,
DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the <br>
numbering should start at 0 (eg.
DEST_MODULE_LOCATION[0]=&quot;/kernel/drivers/something/&quot;
DEST_MODULE_LOCATION[1]=&quot;/kernel/drivers/other/&quot;).</p>

<p style="margin-top: 1em">DEST_MODULE_LOCATION is ignored
on Fedora Core 6 and higher, Red Hat Enterprise Linux 5 and
higher, Novell SuSE Linux Enterprise Server 10 and higher,
Novell SuSE Linux <br>
10.0 and higher, and Ubuntu. Instead, the proper
distribution-specific directory is used.</p>

<p style="margin-top: 1em">MODULES_CONF_ALIAS_TYPE[#]= <br>
This directive array specifies how your modules should be
aliased in /etc/modules.conf when your module is installed.
This is done in an intelligent fashion so if DKMS <br>
detects an already existing reference in modules.conf, it
won&rsquo;t add a new line. If it is not detected, it will
add it to the modules.conf as the last alias number for <br>
that alias type (eg. if
MODULES_CONF_ALIAS_TYPE=&quot;scsi_hostadapter&quot;, no
alias currently exists for that module and the last
scsi_hostadapter reference is 6, then your mod&acirc; <br>
ule will be added as &quot;scsi_hostadapter7&quot;). Common
values for this directive include: scsi_hostadapter ,
sound-slot- and eth. Note that the numeric value of # is
tied to <br>
the index of BUILD_MODULE_NAME, BUILT_MODULE_LOCATION,
DEST_MODULE_NAME and DEST_MODULE_LOCATION. The index is also
tied to MODULES_CONF_OBSOLETES.</p>

<p style="margin-top: 1em">MODULES_CONF_OBSOLETES[#]= <br>
This directive array tells DKMS what modules.conf alias
references are obsoleted by the module you are installing.
If your module obsoletes more than one module, this <br>
directive should be a comma-delimited list of those modules
that are obsoleted (eg. for megaraid2,
MODULES_CONF_OBSOLETES[0]=&quot;megaraid,megaraid_2002&quot;).
When you are <br>
installing your module, DKMS ensures that any entries in
/etc/modules.conf with the same MODULES_CONF_ALIAS_TYPE are
changed over to the new module name. When you are <br>
uninstalling your module, depending on the modules in your
/lib/modules tree, DKMS will take different actions. If you
kernel has an original_module, then modules.conf <br>
will not be touched and the non-obsolete reference will
remain. If the kernel does not have an original_module but
does have one of the obsolete modules, it will replace <br>
those references with the first obsolete module name in the
comma-delimited list that is also in that kernel (thus, your
obsolete list should be prioritized from left to <br>
right). If no original_module or obsolete modules are found
within the kernel, the alias entry is removed all-together.
Note that the numeric value of # is tied to the <br>
index of BUILD_MODULE_NAME, BUILT_MODULE_LOCATION,
DEST_MODULE_NAME and DEST_MODULE_LOCATION. The index is also
tied to MODULES_CONF_ALIAS_TYPE.</p>

<p style="margin-top: 1em">MODULES_CONF_OBSOLETE_ONLY[#]=
<br>
If set to yes , this directive will tell DKMS to only modify
/etc/modules.conf if it finds within it an obsolete
reference as specified in the corresponding value of
MOD&acirc; <br>
ULES_CONF_OBSOLETES[#] array directive.</p>

<p style="margin-top: 1em">STRIP[#]= <br>
By default strip is considered to be &quot;yes&quot;. If set
to &quot;no&quot;, DKMS will not run strip -g against your
built module to remove debug symbols from it. STRIP[0] is
used as the <br>
default for any unset entries in the STRIP array.</p>

<p style="margin-top: 1em">PACKAGE_NAME= <br>
This directive is used to give the name associated with the
entire package of modules. This is the same name that is
used with the -m option when building, adding, etc. <br>
and may not necessarily be the same as the MODULE_NAME. This
directive must be present in every dkms.conf.</p>

<p style="margin-top: 1em">PACKAGE_VERSION= <br>
This directive is used to give the version associated with
the entire package of modules being installed within that
dkms package. This directive must be present in every <br>
dkms.conf.</p>

<p style="margin-top: 1em">CLEAN= CLEAN specifies the make
clean command to be used to clean up both before and after
building the module. If unset, it is assumed to be
&quot;make clean&quot;.</p>

<p style="margin-top: 1em">REMAKE_INITRD= <br>
This directive specifies whether your initrd should be
remade after the module is installed onto the kernel. Any
text after the first character is ignored and if the <br>
first character is not a &quot;y&quot; or a &quot;Y&quot;,
it is assumed that REMAKE_INITRD=&quot;no&quot;.</p>

<p style="margin-top: 1em">UDEV_TRIGGER= <br>
This optional directive specifies, if the udev daemon will
be get a trigger event after the module is installed for
your currently running kernel. Because this udev trig&acirc;
<br>
ger might have some unfriendly side effects on some Linux
Systems, you can now disable this trigger, if your driver
does not need it anyway. UDEV_TRIGGER=yes is assumed <br>
as the default, although this directive may not be given.
This ensures backward compatibility to older DKMS releases.
Any text after the first character is ignored and if <br>
the first character is not a &quot;n&quot; or a
&quot;N&quot;, it is assumed that
UDEV_TRIGGER=&quot;yes&quot;.</p>

<p style="margin-top: 1em">MODULES_CONF[#]= <br>
This directive array specifies what static configuration
text lines need to be added into /etc/modules.conf for your
module. See the section on MODULES.CONF CHANGES for <br>
more information regarding the implications of modifying
/etc/modules.conf</p>

<p style="margin-top: 1em">OBSOLETE_BY= <br>
This directive allows you to specify a kernel version that
obsoletes the necessity for this particular DKMS module.
This can be specified as a particular upstream kernel <br>
or an ABI bump of a kernel. For example, &quot;2.6.24&quot;
would be an upstream kernel and &quot;2.6.24-16&quot; would
represent an ABI bump for a kernel. Both are valid in this
area.</p>

<p style="margin-top: 1em">Please avoid the use of
OBSOLETE_BY wherever possible. It&rsquo;s use indicates a
lack of proper module versioning using MODULE_VERSION() tags
in the module source itself. It <br>
is better to fix the MODULE_VERSION() tags than use
OBSOLETE_BY. This also introduces a implicit
distribution/version dependency on the package, as the value
of OBSO&acirc; <br>
LETE_BY is meaningful only in the context of a single
distribution/version.</p>

<p style="margin-top: 1em">If you feel you must use it,
please use as such in dkms.conf:</p>

<p style="margin-top: 1em">ubuntu_804=&quot;Ubuntu <br>
8.04&quot; <br>
if [ -x /usr/bin/lsb_release ]; then <br>
if [ &quot;$(/usr/bin/lsb_release -sir)&quot; ==
&quot;${ubuntu_804}&quot; ]; then <br>
OBSOLETE_BY=&quot;2.6.25&quot; <br>
fi <br>
fi</p>

<p style="margin-top: 1em">PATCH[#]= <br>
Use the PATCH directive array to specify patches which
should be applied to your source before a build occurs. All
patches are expected to be in -p1 format and are <br>
applied with the patch -p1 command. Each directive should
specify the filename of the patch to apply, and all patches
must be located in the patches subdirectory of your <br>
source directory (
/usr/src/&lt;module&gt;-&lt;module-version&gt;/patches/ ).
If any patch fails to apply, the build will be halted and
the rejections can be inspected in <br>
/var/lib/dkms/&lt;module&gt;/&lt;module-version&gt;/build/.
If a PATCH should only be applied conditionally, the
PATCH_MATCH[#] array should be used, and a corresponding
regular <br>
expression should be placed in PATCH_MATCH[#] which will
alert dkms to only use that PATCH[#] if the regular
expression matches the kernel which the module is currently
<br>
being built for.</p>

<p style="margin-top: 1em">PATCH_MATCH[#]= <br>
See the above description for PATCH[#] directives. If you
only want a patch applied in certain scenarios, the
PATCH_MATCH array should be utilized by giving a regular
<br>
expression which matches the kernels you intend the
corresponding PATCH[#] to be applied to before building that
module.</p>

<p style="margin-top: 1em">AUTOINSTALL= <br>
If this directive is set to yes then the service
/etc/rc.d/init.d/dkms_autoinstaller will automatically try
to install this module on any kernel you boot into. See the
<br>
section on dkms_autoinstaller for more information.</p>

<p style="margin-top: 1em">BUILD_DEPENDS[#]= <br>
This optional directive is an array that allows you to
specify other modules as dependencies for your module. Each
array element should be the PACKAGE_NAME of another
mod&acirc; <br>
ule that is managed by dkms. Do not specify a version or
architecture in the dependency. Note that this directive is
only advisory; missing or broken dependencies cause <br>
non-fatal warnings.</p>

<p style="margin-top: 1em">BUILD_EXCLUSIVE_KERNEL= <br>
This optional directive allows you to specify a regular
expression which defines the subset of kernels which DKMS is
allowed to build your module for. If the kernel being <br>
built for does not match against this regular expression,
the dkms build will error out. For example, if you set it as
=&quot;^2.4.*&quot;, your module would not be built for 2.6
<br>
kernels.</p>

<p style="margin-top: 1em">BUILD_EXCLUSIVE_ARCH= <br>
This optional directive functions very similarly to
BUILD_EXCLUSIVE_KERNEL except that it matches against the
kernel architecture. For example, if you set it to
=&quot;i.86&quot;, <br>
your module would not be built for ia32e, x86_64, amd64,
s390, etc.</p>

<p style="margin-top: 1em">POST_ADD= <br>
The name of the script to be run after an add is performed.
The path should be given relative to the root directory of
your source.</p>

<p style="margin-top: 1em">POST_BUILD= <br>
The name of the script to be run after a build is performed.
The path should be given relative to the root directory of
your source.</p>

<p style="margin-top: 1em">POST_INSTALL= <br>
The name of the script to be run after an install is
performed. The path should be given relative to the root
directory of your source.</p>

<p style="margin-top: 1em">POST_REMOVE= <br>
The name of the script to be run after a remove is
performed. The path should be given relative to the root
directory of your source.</p>

<p style="margin-top: 1em">PRE_BUILD= <br>
The name of the script to be run before a build is
performed. The path should be given relative to the root
directory of your source.</p>

<p style="margin-top: 1em">PRE_INSTALL= <br>
The name of the script to be run before an install is
performed. The path should be given relative to the root
directory of your source. If the script exits with a <br>
non-zero value, the install will be aborted. This is
typically used to perform a custom version comparison.</p>

<p style="margin-top: 1em">DKMS.CONF VARIABLES <br>
Within your dkms.conf file, you can use certain variables
which will be replaced at run-time with their values.</p>

<p style="margin-top: 1em">$kernelver <br>
This variable can be used within a directive definition and
during use, the actual kernel version in question will be
substituted in its place. This is especially useful <br>
in MAKE commands when specifying which INCLUDE statements
should be used when compiling your module (eg.
MAKE=&quot;make all INCLUDEDIR=/lib/modules/${ker&acirc;
<br>
nelver}/build/include&quot;).</p>

<p style="margin-top: 1em">$dkms_tree <br>
See the section on /etc/dkms/framework.conf for more
information. This variable represents the location of the
DKMS tree on the local system. By default this is <br>
/var/lib/dkms , but this value should not be hard-coded into
a dkms.conf in the event that the local user has changed it
on their system.</p>

<p style="margin-top: 1em">$source_tree <br>
See the section on /etc/dkms/framework.conf for more
information. This variable represents the location where
DKMS keeps source on the local system. By default this is
<br>
/usr/src , but this value should not be hard-coded into a
dkms.conf in the event that the local user has changed it on
their system.</p>

<p style="margin-top: 1em">$kernel_source_dir <br>
This variable holds the value of the location of your kernel
source directory. Usually, this will be
/lib/modules/$kernelver/build , unless otherwise specified
with the <br>
--kernelsourcedir option.</p>

<p style="margin-top: 1em">DKMS.CONF OVERRIDES <br>
You can override the module-provided dkms.conf files. Every
time after a dkms.conf file is read, dkms will look for and
read the following files in order:</p>

<p style="margin-top: 1em">/etc/dkms/&lt;module&gt;.conf
<br>
/etc/dkms/&lt;module&gt;-&lt;module-version&gt;.conf <br>

/etc/dkms/&lt;module&gt;-&lt;module-version&gt;-&lt;kernel&gt;.conf
<br>

/etc/dkms/&lt;module&gt;-&lt;module-version&gt;-&lt;kernel&gt;-&lt;arch&gt;.conf</p>

<p style="margin-top: 1em">You can use these files to
override settings in the module-provided dkms.conf
files.</p>

<p style="margin-top: 1em">/etc/dkms/framework.conf <br>
This configuration file controls how the overall DKMS
framework handles. It is sourced in every time the dkms
command is run. Mainly it can currently be used to set
different <br>
default values for the variables. $dkms_tree , $source_tree
and $install_tree which control where DKMS looks for its
framework. The $symlink_modules variable controls wheter
<br>
binary modules are copied to /lib/modules or if only
symlinks are created there. Note that these variables can
also be manipulated on the command line with --dkmstree,
--source&acirc; <br>
tree, --installtree and --symlink-modules options.</p>

<p style="margin-top: 1em">The $autoinstall_all_kernels
variable is used by the common postinst for DKMS modules. It
controls if the build should be done for all installed
kernels or only for the current <br>
and latest installed kernel. It has no command line
equivalent.</p>

<p style="margin-top: 1em">dkms_autoinstaller <br>
This boot-time service automatically installs any module
which has AUTOINSTALL=&quot;yes&quot; set in its dkms.conf
file. The service works quite simply and if multiple
versions of a mod&acirc; <br>
ule are in your system&rsquo;s DKMS tree, it will not do
anything and instead explain that manual intervention is
required.</p>

<p style="margin-top: 1em">MODULES.CONF / MODPROBE.CONF
CHANGES <br>
Changes that your module will make to /etc/modules.conf or
/etc/modprobe.conf should be specified with the
MODULES_CONF_ALIAS_TYPE[#] , the MODULES_CONF_OBSOLETES[#]
and the MOD&acirc; <br>
ULES_CONF[#] directive arrays. These arrays should also be
used even if your distro uses /etc/sysconfig/kernel to track
kernel modules.</p>

<p style="margin-top: 1em">When the first module is
installed upon the first kernel within the user&rsquo;s
system, these entries in MODULES_CONF[#] are automatically
added to /etc/modules.conf and if <br>
REMAKE_INITRD is specified, then the user&rsquo;s initrd is
then remade. Subsequently, as your modules are then later
removed from the user&rsquo;s system, until the final
module/version <br>
combination is removed from the final kernel version, those
references in modules.conf will remain. Once the last
module/version combination is removed, those references are
<br>
then removed.</p>

<p style="margin-top: 1em">As modules/versions are removed
and initrds are remade, one of three things will happen if
you have specified a MODULES_CONF_ALIAS_TYPE. If no
original_module exists for that <br>
kernel, and no MODULES_CONF_OBSOLETES modules are found in
that kernel too, the modules.conf alias references will
temporarily be removed so that the initrd will successfully
<br>
remake. Once the initrd is remade, however; those references
are then automatically put back into modules.conf (unless
you are removing the last instance of the module on the <br>
last kernel). However, if no original_module exists, but
there is an OBSOLETE module found within that kernel, the
alias reference is temporarily shifted to point to the
OBSO&acirc; <br>
LETE module so that the initrd can be remade. After it is
remade, it then automatically puts back the alias reference
(unless you are removing the last instance of the module on
<br>
the last kernel). Lastly, if an original_module does exist
for the kernel version, then modules.conf is not touched and
all references persist (even if you are removing the last
<br>
instance of the module on the last kernel).</p>

<p style="margin-top: 1em">Certain module installations
might not only require adding references to modules.conf but
also require removing conflicting references that might
exist in the user&rsquo;s system. If <br>
this is the case, the MODULES_CONF_OBSOLETES[#] directive
should be utilized to remove these references. More
information about this directive can be found in the
DKMS.CONF sec&acirc; <br>
tion of this man page.</p>

<p style="margin-top: 1em">Note that the end state of your
modules.conf file very much depends on what kernel modules
exist in the final kernel you remove your DKMS module from.
This is an imperfect sys&acirc; <br>
tem caused by the fact that there is only one modules.conf
file for every kernel on your system even though various
kernels use different modules. In a perfect world, there
<br>
would be one modules.conf file for every kernel (just like
System.map).</p>

<p style="margin-top: 1em">CREATING RPMS WHICH UTILIZE DKMS
<br>
See the sample.spec file packaged with DKMS as an example
for what your RPM spec file might look like. Creating RPMs
which utilize dkms is a fairly straight-forward process.
<br>
The RPM need only to install the source into
/usr/src/&lt;module&gt;-&lt;module-version&gt;/ and then
employ dkms itself to do all the work of installation. As
such, the RPM should first <br>
untar the source into this directory. From here, within the
RPM .spec file, a dkms add should be called (remember to use
the --rpm_safe_upgrade flag during the add) followed by <br>
a dkms build followed by a dkms install. Your dkms.conf file
should be placed within the
/usr/src/&lt;module&gt;-&lt;module-version&gt;/
directory.</p>

<p style="margin-top: 1em">Under the removal parts of the
.spec file, all that needs to be called is a: dkms remove -m
&lt;module&gt; -v &lt;module-version&gt; --all
--rpm_safe_upgrade. Use of the --rpm_safe_upgrade <br>
flag is imperative for making sure DKMS and RPM play nicely
together in all scenarios of using the -Uvh flag with RPM to
upgrade dkms enabled packages. It will only function if <br>
used during both the add and remove actions within the same
RPM spec file. Its use makes sure that when upgrading
between different releases of an RPM for the same
&lt;module-ver&acirc; <br>
sion&gt;, DKMS does not do anything dumb (eg. it ensures a
smooth upgrade from megaraid-2.09-5.noarch.rpm to
megaraid-2.09-6.noarch.rpm).</p>

<p style="margin-top: 1em">It should be noted that a binary
RPM which contains source is not a traditional practice.
However, given the benefits of dkms it hopefully will become
so. As the RPM created <br>
which utilizes dkms is not architecture specific, BuildArch:
noarch should be specified in the .spec file to indicate
that the package can work regardless of the system
architec&acirc; <br>
ture. Also note that DKMS RPM upgrades (-U option) will
automatically work because of the structure of the dkms
tree.</p>

<p style="margin-top: 1em">Lastly, as a matter of
convention, you should name your RPM:
&lt;package&gt;-&lt;version&gt;-&lt;rpm-version&gt;dkms.noarch.rpm.
The word dkms as part of the rpm-version signifies that the
RPM <br>
works within the DKMS framework.</p>

<p style="margin-top: 1em">AUTHOR <br>
Gary Lerhaupt</p>

<p style="margin-top: 1em">WEBPAGE <br>
https://github.com/dell-oss/dkms</p>

<p style="margin-top: 1em">WHITE-PAPERS <br>
http://linux.dell.com/dkms/dkms-ols2004.pdf</p>


<p style="margin-top: 1em">http://www.dell.com/downloads/global/power/1q04-ler.pdf</p>


<p style="margin-top: 1em">http://www.linuxjournal.com/article.php?sid=6896</p>

<p style="margin-top: 1em">MAILING-LIST <br>
dkms-devel@dell.com
http://lists.us.dell.com/mailman/listinfo/dkms-devel</p>

<p style="margin-top: 1em">REFERENCES <br>
Kernel Module Packages http://kerneldrivers.org</p>

<p style="margin-top: 1em">Novell Kernel Module Packages
http://www.suse.de/~agruen/KMPM</p>

<p style="margin-top: 1em">Fedora Kernel Module Packages
http://fedoraproject.org/wiki/Extras/KernelModuleProposal</p>

<p style="margin-top: 1em">Version 2.0.20 June 2008
DKMS(8)</p>
<hr>
</body>
</html>
