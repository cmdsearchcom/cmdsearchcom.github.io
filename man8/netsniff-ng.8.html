<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>NETSNIFF-NG(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">NETSNIFF-NG(8)</td>
    <td class="head-vol">netsniff-ng toolkit</td>
    <td class="head-rtitle">NETSNIFF-NG(8)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
netsniff-ng - the packet sniffing beast
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>netsniff-ng</b> { [<i>options</i>] [<i>filter-expression</i>] }
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
netsniff-ng is a fast, minimal tool to analyze network packets, capture pcap
  files, replay pcap files, and redirect traffic between interfaces with the
  help of zero-copy packet(7) sockets. netsniff-ng uses both Linux specific
  RX_RING and TX_RING interfaces to perform zero-copy. This is to avoid copy and
  system call overhead between kernel and user address space. When we started
  working on netsniff-ng, the pcap(3) library did not use this zero-copy
  facility.
<div class="Pp"></div>
netsniff-ng is Linux specific, meaning there is no support for other operating
  systems. Therefore we can keep the code footprint quite minimal and to the
  point. Linux packet(7) sockets and its RX_RING and TX_RING interfaces bypass
  the normal packet processing path through the networking stack. This is the
  fastest capturing or transmission performance one can get from user space out
  of the box, without having to load unsupported or non-mainline third-party
  kernel modules. We explicitly refuse to build netsniff-ng on top of
  ntop/PF_RING. Not because we do not like it (we do find it interesting), but
  because of the fact that it is not part of the mainline kernel. Therefore, the
  ntop project has to maintain and sync out-of-tree drivers to adapt them to
  their DNA. Eventually, we went for untainted Linux kernel, since its code has
  a higher rate of review, maintenance, security and bug fixes.
<div class="Pp"></div>
netsniff-ng also supports early packet filtering in the kernel. It has support
  for low-level and high-level packet filters that are translated into Berkeley
  Packet Filter instructions.
<div class="Pp"></div>
netsniff-ng can capture pcap files in several different pcap formats that are
  interoperable with other tools. It has different pcap I/O methods supported
  (scatter-gather, mmap(2), read(2), and write(2)) for efficient to-disc
  capturing. netsniff-ng is also able to rotate pcap files based on data size or
  time intervals, thus, making it a useful backend tool for subsequent traffic
  analysis.
<div class="Pp"></div>
netsniff-ng itself also supports analysis, replaying, and dumping of raw 802.11
  frames. For online or offline analysis, netsniff-ng has a built-in packet
  dissector for the current 802.3 (Ethernet), 802.11* (WLAN), ARP, MPLS, 802.1Q
  (VLAN), 802.1QinQ, LLDP, IPv4, IPv6, ICMPv4, ICMPv6, IGMP, TCP and UDP,
  including GeoIP location analysis. Since netsniff-ng does not establish any
  state or perform reassembly during packet dissection, its memory footprint is
  quite low, thus, making netsniff-ng quite efficient for offline analysis of
  large pcap files as well.
<div class="Pp"></div>
Note that netsniff-ng is currently not multithreaded. However, this does not
  prevent you from starting multiple netsniff-ng instances that are pinned to
  different, non-overlapping CPUs and f.e. have different BPF filters attached.
  Likely that at some point in time your harddisc might become a bottleneck
  assuming you do not rotate such pcaps in ram (and from there periodically
  scheduled move to slower medias). You can then use mergecap(1) to transform
  all pcaps into a single large pcap. Thus, netsniff-ng then works multithreaded
  eventually.
<div class="Pp"></div>
netsniff-ng can also be used to debug netlink traffic.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<h2 class="Ss" title="Ss" id="-i_&lt;dev|pcap|-&gt;,_-d_&lt;dev|pcap|-&gt;,_--in_&lt;dev|pcap|-&gt;,_--dev_&lt;dev|pcap|-&gt;"><a class="selflink" href="#-i_&lt;dev|pcap|-&gt;,_-d_&lt;dev|pcap|-&gt;,_--in_&lt;dev|pcap|-&gt;,_--dev_&lt;dev|pcap|-&gt;">-i
  &lt;dev|pcap|-&gt;, -d &lt;dev|pcap|-&gt;, --in &lt;dev|pcap|-&gt;, --dev
  &lt;dev|pcap|-&gt;</a></h2>
Defines an input device. This can either be a networking device, a pcap file or
  stdin (&#x201C;-&#x201D;). In case of a pcap file, the pcap type
  (&#x201C;-D&#x201D; option) is determined automatically by the pcap file
  magic. In case of stdin, it is assumed that the input stream is a pcap file.
<h2 class="Ss" title="Ss" id="-o_&lt;dev|pcap|dir|cfg|-&gt;,_--out_&lt;dev|pcap|dir|cfg|-&gt;"><a class="selflink" href="#-o_&lt;dev|pcap|dir|cfg|-&gt;,_--out_&lt;dev|pcap|dir|cfg|-&gt;">-o
  &lt;dev|pcap|dir|cfg|-&gt;, --out &lt;dev|pcap|dir|cfg|-&gt;</a></h2>
Defines the output device. This can either be a networking device, a pcap file,
  a folder, a trafgen(8) configuration file or stdout (&#x201C;-&#x201D;). In
  the case of a pcap file that should not have the default pcap type
  (0xa1b2c3d4), the additional option &#x201C;-T&#x201D; must be provided. If a
  directory is given, then, instead of a single pcap file, multiple pcap files
  are generated with rotation based on maximum file size or a given interval
  (&#x201C;-F&#x201D; option). A trafgen configuration file can currently only
  be specified if the input device is a pcap file. If stdout is given as a
  device, then a trafgen configuration will be written to stdout if the input
  device is a pcap file, or a pcap file if the input device is a networking
  device.
<h2 class="Ss" title="Ss" id="-C_&lt;id&gt;,_--fanout-group_&lt;id&gt;"><a class="selflink" href="#-C_&lt;id&gt;,_--fanout-group_&lt;id&gt;">-C
  &lt;id&gt;, --fanout-group &lt;id&gt;</a></h2>
If multiple netsniff-ng instances are being started that all have the same
  packet fanout group id, then the ingress network traffic being captured is
  being distributed/load-balanced among these group participants. This gives a
  much better scaling than running multiple netsniff-ng processes without a
  fanout group parameter in parallel, but only with a BPF filter attached as a
  packet would otherwise need to be delivered to all such capturing processes,
  instead of only once to such a fanout member. Naturally, each fanout member
  can have its own BPF filters attached.
<h2 class="Ss" title="Ss" id="-K_&lt;hash|lb|cpu|rnd|roll|qm&gt;,_--fanout-type_&lt;hash|lb|cpu|rnd|roll|qm&gt;"><a class="selflink" href="#-K_&lt;hash|lb|cpu|rnd|roll|qm&gt;,_--fanout-type_&lt;hash|lb|cpu|rnd|roll|qm&gt;">-K
  &lt;hash|lb|cpu|rnd|roll|qm&gt;, --fanout-type
  &lt;hash|lb|cpu|rnd|roll|qm&gt;</a></h2>
This parameter specifies the fanout discipline, in other words, how the captured
  network traffic is dispatched to the fanout group members. Options are to
  distribute traffic by the packet hash (&#x201C;hash&#x201D;), in a round-robin
  manner (&#x201C;lb&#x201D;), by CPU the packet arrived on
  (&#x201C;cpu&#x201D;), by random (&#x201C;rnd&#x201D;), by rolling over
  sockets (&#x201C;roll&#x201D;) which means if one socket's queue is full, we
  move on to the next one, or by NIC hardware queue mapping
  (&#x201C;qm&#x201D;).
<h2 class="Ss" title="Ss" id="-L_&lt;defrag|roll&gt;,_--fanout-opts_&lt;defrag|roll&gt;"><a class="selflink" href="#-L_&lt;defrag|roll&gt;,_--fanout-opts_&lt;defrag|roll&gt;">-L
  &lt;defrag|roll&gt;, --fanout-opts &lt;defrag|roll&gt;</a></h2>
Defines some auxillary fanout options to be used in addition to a given fanout
  type. These options apply to any fanout type. In case of
  &#x201C;defrag&#x201D;, the kernel is being told to defragment packets before
  delivering to user space, and &#x201C;roll&#x201D; provides the same roll-over
  option as the &#x201C;roll&#x201D; fanout type, so that on any different
  fanout type being used (e.g. &#x201C;qm&#x201D;) the socket may temporarily
  roll over to the next fanout group member in case the original one's queue is
  full.
<h2 class="Ss" title="Ss" id="-f,_--filter_&lt;bpf-file|expr&gt;"><a class="selflink" href="#-f,_--filter_&lt;bpf-file|expr&gt;">-f,
  --filter &lt;bpf-file|expr&gt;</a></h2>
Specifies to not dump all traffic, but to filter the network packet haystack. As
  a filter, either a bpfc(8) compiled file can be passed as a parameter or a
  tcpdump(1)-like filter expression in quotes. For details regarding the
  bpf-file have a look at bpfc(8), for details regarding a tcpdump(1)-like
  filter have a look at section &#x201C;filter example&#x201D; or at
  pcap-filter(7). A filter expression may also be passed to netsniff-ng without
  option &#x201C;-f&#x201D; in case there is no subsequent option following
  after the command-line filter expression.
<h2 class="Ss" title="Ss" id="-t,_--type_&lt;type&gt;"><a class="selflink" href="#-t,_--type_&lt;type&gt;">-t,
  --type &lt;type&gt;</a></h2>
This defines some sort of filtering mechanisms in terms of addressing. Possible
  values for type are &#x201C;host&#x201D; (to us), &#x201C;broadcast&#x201D;
  (to all), &#x201C;multicast&#x201D; (to group), &#x201C;others&#x201D;
  (promiscuous mode) or &#x201C;outgoing&#x201D; (from us).
<h2 class="Ss" title="Ss" id="-F,_--interval_&lt;size|time&gt;"><a class="selflink" href="#-F,_--interval_&lt;size|time&gt;">-F,
  --interval &lt;size|time&gt;</a></h2>
If the output device is a folder, with &#x201C;-F&#x201D;, it is possible to
  define the pcap file rotation interval either in terms of size or time. Thus,
  when the interval limit has been reached, a new pcap file will be started. As
  size parameter, the following values are accepted
  &#x201C;&lt;num&gt;KiB/MiB/GiB&#x201D;; As time parameter, it can be
  &#x201C;&lt;num&gt;s/sec/min/hrs&#x201D;.
<h2 class="Ss" title="Ss" id="-J,_--jumbo-support"><a class="selflink" href="#-J,_--jumbo-support">-J,
  --jumbo-support</a></h2>
By default, in pcap replay or redirect mode, netsniff-ng's ring buffer frames
  are a fixed size of 2048 bytes. This means that if you are expecting jumbo
  frames or even super jumbo frames to pass through your network, then you need
  to enable support for that by using this option. However, this has the
  disadvantage of performance degradation and a bigger memory footprint for the
  ring buffer. Note that this doesn't affect (pcap) capturing mode, since
  tpacket in version 3 is used!
<h2 class="Ss" title="Ss" id="-R,_--rfraw"><a class="selflink" href="#-R,_--rfraw">-R,
  --rfraw</a></h2>
In case the input or output networking device is a wireless device, it is
  possible with netsniff-ng to turn this into monitor mode and create a
  mon&lt;X&gt; device that netsniff-ng will be listening on instead of
  wlan&lt;X&gt;, for instance. This enables netsniff-ng to analyze, dump, or
  even replay raw 802.11 frames.
<h2 class="Ss" title="Ss" id="-n_&lt;0|uint&gt;,_--num_&lt;0|uint&gt;"><a class="selflink" href="#-n_&lt;0|uint&gt;,_--num_&lt;0|uint&gt;">-n
  &lt;0|uint&gt;, --num &lt;0|uint&gt;</a></h2>
Process a number of packets and then exit. If the number of packets is 0, then
  this is equivalent to infinite packets resp. processing until interrupted.
  Otherwise, a number given as an unsigned integer will limit processing.
<h2 class="Ss" title="Ss" id="-P_&lt;name&gt;,_--prefix_&lt;name&gt;"><a class="selflink" href="#-P_&lt;name&gt;,_--prefix_&lt;name&gt;">-P
  &lt;name&gt;, --prefix &lt;name&gt;</a></h2>
When dumping pcap files into a folder, a file name prefix can be defined with
  this option. If not otherwise specified, the default prefix is
  &#x201C;dump-&#x201D; followed by a Unix timestamp. Use &#x201C;--prefex
  &quot;&quot;&#x201D; to set filename as seconds since the Unix Epoch e.g.
  1369179203.pcap
<h2 class="Ss" title="Ss" id="-T_&lt;pcap-magic&gt;,_--magic_&lt;pcap-magic&gt;"><a class="selflink" href="#-T_&lt;pcap-magic&gt;,_--magic_&lt;pcap-magic&gt;">-T
  &lt;pcap-magic&gt;, --magic &lt;pcap-magic&gt;</a></h2>
Specify a pcap type for storage. Different pcap types with their various meta
  data capabilities are shown with option &#x201C;-D&#x201D;. If not otherwise
  specified, the pcap-magic 0xa1b2c3d4, also known as a standard tcpdump-capable
  pcap format, is used. Pcap files with swapped endianness are also supported.
<h2 class="Ss" title="Ss" id="-D,_--dump-pcap-types"><a class="selflink" href="#-D,_--dump-pcap-types">-D,
  --dump-pcap-types</a></h2>
Dump all available pcap types with their capabilities and magic numbers that can
  be used with option &#x201C;-T&#x201D; to stdout and exit.
<h2 class="Ss" title="Ss" id="-B,_--dump-bpf"><a class="selflink" href="#-B,_--dump-bpf">-B,
  --dump-bpf</a></h2>
If a Berkeley Packet Filter is given, for example via option &#x201C;-f&#x201D;,
  then dump the BPF disassembly to stdout during ring setup. This only serves
  for informative or verification purposes.
<h2 class="Ss" title="Ss" id="-r,_--rand"><a class="selflink" href="#-r,_--rand">-r,
  --rand</a></h2>
If the input and output device are both networking devices, then this option
  will randomize packet order in the output ring buffer.
<h2 class="Ss" title="Ss" id="-M,_--no-promisc"><a class="selflink" href="#-M,_--no-promisc">-M,
  --no-promisc</a></h2>
The networking interface will not be put into promiscuous mode. By default,
  promiscuous mode is turned on.
<h2 class="Ss" title="Ss" id="-A,_--no-sock-mem"><a class="selflink" href="#-A,_--no-sock-mem">-A,
  --no-sock-mem</a></h2>
On startup and shutdown, netsniff-ng tries to increase socket read and write
  buffers if appropriate. This option will prevent netsniff-ng from doing so.
<h2 class="Ss" title="Ss" id="-m,_--mmap"><a class="selflink" href="#-m,_--mmap">-m,
  --mmap</a></h2>
Use mmap(2) as pcap file I/O. This is the default when replaying pcap files.
<h2 class="Ss" title="Ss" id="-G,_--sg"><a class="selflink" href="#-G,_--sg">-G,
  --sg</a></h2>
Use scatter-gather as pcap file I/O. This is the default when capturing pcap
  files.
<h2 class="Ss" title="Ss" id="-c,_--clrw"><a class="selflink" href="#-c,_--clrw">-c,
  --clrw</a></h2>
Use slower read(2) and write(2) I/O. This is not the default case anywhere, but
  in some situations it could be preferred as it has a lower latency on
  write-back to disc.
<h2 class="Ss" title="Ss" id="-S_&lt;size&gt;,_--ring-size_&lt;size&gt;"><a class="selflink" href="#-S_&lt;size&gt;,_--ring-size_&lt;size&gt;">-S
  &lt;size&gt;, --ring-size &lt;size&gt;</a></h2>
Manually define the RX_RING resp. TX_RING size in
  &#x201C;&lt;num&gt;KiB/MiB/GiB&#x201D;. By default, the size is determined
  based on the network connectivity rate.
<h2 class="Ss" title="Ss" id="-k_&lt;uint&gt;,_--kernel-pull_&lt;uint&gt;"><a class="selflink" href="#-k_&lt;uint&gt;,_--kernel-pull_&lt;uint&gt;">-k
  &lt;uint&gt;, --kernel-pull &lt;uint&gt;</a></h2>
Manually define the interval in micro-seconds where the kernel should be
  triggered to batch process the ring buffer frames. By default, it is every
  10us, but it can manually be prolonged, for instance.
<h2 class="Ss" title="Ss" id="-b_&lt;cpu&gt;,_--bind-cpu_&lt;cpu&gt;"><a class="selflink" href="#-b_&lt;cpu&gt;,_--bind-cpu_&lt;cpu&gt;">-b
  &lt;cpu&gt;, --bind-cpu &lt;cpu&gt;</a></h2>
Pin netsniff-ng to a specific CPU and also pin resp. migrate the NIC's IRQ CPU
  affinity to this CPU. This option should be preferred in combination with
  &#x201C;-s&#x201D; in case a middle to high packet rate is expected.
<h2 class="Ss" title="Ss" id="-u_&lt;uid&gt;,_--user_&lt;uid&gt;_resp._-g_&lt;gid&gt;,_--group_&lt;gid&gt;"><a class="selflink" href="#-u_&lt;uid&gt;,_--user_&lt;uid&gt;_resp._-g_&lt;gid&gt;,_--group_&lt;gid&gt;">-u
  &lt;uid&gt;, --user &lt;uid&gt; resp. -g &lt;gid&gt;, --group
  &lt;gid&gt;</a></h2>
After ring setup drop privileges to a non-root user/group combination.
<h2 class="Ss" title="Ss" id="-H,_--prio-high"><a class="selflink" href="#-H,_--prio-high">-H,
  --prio-high</a></h2>
Set this process as a high priority process in order to achieve a higher
  scheduling rate resp. CPU time. This is however not the default setting, since
  it could lead to starvation of other processes, for example low priority
  kernel threads.
<h2 class="Ss" title="Ss" id="-Q,_--notouch-irq"><a class="selflink" href="#-Q,_--notouch-irq">-Q,
  --notouch-irq</a></h2>
Do not reassign the NIC's IRQ CPU affinity settings.
<h2 class="Ss" title="Ss" id="-s,_--silent"><a class="selflink" href="#-s,_--silent">-s,
  --silent</a></h2>
Do not enter the packet dissector at all and do not print any packet information
  to the terminal. Just shut up and be silent. This option should be preferred
  in combination with pcap recording or replay, since it will not flood your
  terminal which causes a significant performance degradation.
<h2 class="Ss" title="Ss" id="-q,_--less"><a class="selflink" href="#-q,_--less">-q,
  --less</a></h2>
Print a less verbose one-line information for each packet to the terminal.
<h2 class="Ss" title="Ss" id="-X,_--hex"><a class="selflink" href="#-X,_--hex">-X,
  --hex</a></h2>
Only dump packets in hex format to the terminal.
<h2 class="Ss" title="Ss" id="-l,_--ascii"><a class="selflink" href="#-l,_--ascii">-l,
  --ascii</a></h2>
Only display ASCII printable characters.
<h2 class="Ss" title="Ss" id="-U,_--update"><a class="selflink" href="#-U,_--update">-U,
  --update</a></h2>
If geographical IP location is used, the built-in database update mechanism will
  be invoked to get Maxmind's latest database. To configure search locations for
  databases, the file /etc/netsniff-ng/geoip.conf contains possible addresses.
  Thus, to save bandwidth or for mirroring of Maxmind's databases (to bypass
  their traffic limit policy), different hosts or IP addresses can be placed
  into geoip.conf, separated by a newline.
<h2 class="Ss" title="Ss" id="-V,_--verbose"><a class="selflink" href="#-V,_--verbose">-V,
  --verbose</a></h2>
Be more verbose during startup i.e. show detailed ring setup information.
<h2 class="Ss" title="Ss" id="-v,_--version"><a class="selflink" href="#-v,_--version">-v,
  --version</a></h2>
Show version information and exit.
<h2 class="Ss" title="Ss" id="-h,_--help"><a class="selflink" href="#-h,_--help">-h,
  --help</a></h2>
Show user help and exit.
<h1 class="Sh" title="Sh" id="USAGE_EXAMPLE"><a class="selflink" href="#USAGE_EXAMPLE">USAGE
  EXAMPLE</a></h1>
<h2 class="Ss" title="Ss" id="netsniff-ng"><a class="selflink" href="#netsniff-ng">netsniff-ng</a></h2>
The most simple command is to just run &#x201C;netsniff-ng&#x201D;. This will
  start listening on all available networking devices in promiscuous mode and
  dump the packet dissector output to the terminal. No files will be recorded.
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_eth0_--out_dump.pcap_-s_-T_0xa1e2cb12_-b_0_tcp_or_udp"><a class="selflink" href="#netsniff-ng_--in_eth0_--out_dump.pcap_-s_-T_0xa1e2cb12_-b_0_tcp_or_udp">netsniff-ng
  --in eth0 --out dump.pcap -s -T 0xa1e2cb12 -b 0 tcp or udp</a></h2>
Capture TCP or UDP traffic from the networking device eth0 into the pcap file
  named dump.pcap, which has netsniff-ng specific pcap extensions (see
  &#x201C;netsniff-ng -D&#x201D; for capabilities). Also, do not print the
  content to the terminal and pin the process and NIC IRQ affinity to CPU 0. The
  pcap write method is scatter-gather I/O.
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_wlan0_--rfraw_--out_dump.pcap_--silent_--bind-cpu_0"><a class="selflink" href="#netsniff-ng_--in_wlan0_--rfraw_--out_dump.pcap_--silent_--bind-cpu_0">netsniff-ng
  --in wlan0 --rfraw --out dump.pcap --silent --bind-cpu 0</a></h2>
Put the wlan0 device into monitoring mode and capture all raw 802.11 frames into
  the file dump.pcap. Do not dissect and print the content to the terminal and
  pin the process and NIC IRQ affinity to CPU 0. The pcap write method is
  scatter-gather I/O.
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_dump.pcap_--mmap_--out_eth0_-k1000_--silent_--bind-cpu_0"><a class="selflink" href="#netsniff-ng_--in_dump.pcap_--mmap_--out_eth0_-k1000_--silent_--bind-cpu_0">netsniff-ng
  --in dump.pcap --mmap --out eth0 -k1000 --silent --bind-cpu 0</a></h2>
Replay the pcap file dump.pcap which is read through mmap(2) I/O and send the
  packets out via the eth0 networking device. Do not dissect and print the
  content to the terminal and pin the process and NIC IRQ affinity to CPU 0.
  Also, trigger the kernel every 1000us to traverse the TX_RING instead of every
  10us. Note that the pcap magic type is detected automatically from the pcap
  file header.
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_eth0_--out_eth1_--silent_--bind-cpu_0_--type_host_-r"><a class="selflink" href="#netsniff-ng_--in_eth0_--out_eth1_--silent_--bind-cpu_0_--type_host_-r">netsniff-ng
  --in eth0 --out eth1 --silent --bind-cpu 0 --type host -r</a></h2>
Redirect network traffic from the networking device eth0 to eth1 for traffic
  that is destined for our host, thus ignore broadcast, multicast and
  promiscuous traffic. Randomize the order of packets for the outgoing device
  and do not print any packet contents to the terminal. Also, pin the process
  and NIC IRQ affinity to CPU 0.
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_team0_--out_/opt/probe/_-s_-m_--interval_100MiB_-b_0"><a class="selflink" href="#netsniff-ng_--in_team0_--out_/opt/probe/_-s_-m_--interval_100MiB_-b_0">netsniff-ng
  --in team0 --out /opt/probe/ -s -m --interval 100MiB -b 0</a></h2>
Capture on an aggregated team0 networking device and dump packets into multiple
  pcap files that are split into 100MiB each. Use mmap(2) I/O as a pcap write
  method, support for super jumbo frames is built-in (does not need to be
  configured here), and do not print the captured data to the terminal. Pin
  netsniff-ng and NIC IRQ affinity to CPU 0. The default pcap magic type is
  0xa1b2c3d4 (tcpdump-capable pcap).
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_vlan0_--out_dump.pcap_-c_-u_`id_-u_bob`_-g_`id_-g_bob`"><a class="selflink" href="#netsniff-ng_--in_vlan0_--out_dump.pcap_-c_-u_`id_-u_bob`_-g_`id_-g_bob`">netsniff-ng
  --in vlan0 --out dump.pcap -c -u `id -u bob` -g `id -g bob`</a></h2>
Capture network traffic on device wlan0 into a pcap file called dump.pcap by
  using normal read(2), write(2) I/O for the pcap file (slower but less
  latency). Also, after setting up the RX_RING for capture, drop privileges from
  root to the user and group &#x201C;bob&#x201D;. Invoke the packet dissector
  and print packet contents to the terminal for further analysis.
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_any_--filter_http.bpf_-B_--ascii_-V"><a class="selflink" href="#netsniff-ng_--in_any_--filter_http.bpf_-B_--ascii_-V">netsniff-ng
  --in any --filter http.bpf -B --ascii -V</a></h2>
Capture from all available networking interfaces and install a low-level filter
  that was previously compiled by bpfc(8) into http.bpf in order to filter HTTP
  traffic. Super jumbo frame support is automatically enabled and only print
  human readable packet data to the terminal, and also be more verbose during
  setup phase. Moreover, dump a BPF disassembly of http.bpf.
<h2 class="Ss" title="Ss" id="netsniff-ng_--in_dump.pcap_--out_dump.cfg_--silent"><a class="selflink" href="#netsniff-ng_--in_dump.pcap_--out_dump.cfg_--silent">netsniff-ng
  --in dump.pcap --out dump.cfg --silent</a></h2>
Convert the pcap file dump.pcap into a trafgen(8) configuration file dump.cfg.
  Do not print pcap contents to the terminal.
<h2 class="Ss" title="Ss" id="netsniff-ng_-i_dump.pcap_-f_beacon.bpf_-o_-"><a class="selflink" href="#netsniff-ng_-i_dump.pcap_-f_beacon.bpf_-o_-">netsniff-ng
  -i dump.pcap -f beacon.bpf -o -</a></h2>
Convert the pcap file dump.pcap into a trafgen(8) configuration file and write
  it to stdout. However, do not dump all of its content, but only the one that
  passes the low-level filter for raw 802.11 from beacon.bpf. The BPF engine
  here is invoked in user space inside of netsniff-ng, so Linux extensions are
  not available.
<h2 class="Ss" title="Ss" id="cat_foo.pcap_|_netsniff-ng_-i_-_-o_-"><a class="selflink" href="#cat_foo.pcap_|_netsniff-ng_-i_-_-o_-">cat
  foo.pcap | netsniff-ng -i - -o -</a></h2>
Read a pcap file from stdin and convert it into a trafgen(8) configuration file
  to stdout.
<h2 class="Ss" title="Ss" id="modprobe_nlmon"><a class="selflink" href="#modprobe_nlmon">modprobe
  nlmon</a></h2>
<h2 class="Ss" title="Ss" id="ip_link_add_type_nlmon"><a class="selflink" href="#ip_link_add_type_nlmon">ip
  link add type nlmon</a></h2>
<h2 class="Ss" title="Ss" id="ip_link_set_nlmon0_up"><a class="selflink" href="#ip_link_set_nlmon0_up">ip
  link set nlmon0 up</a></h2>
<h2 class="Ss" title="Ss" id="netsniff-ng_-i_nlmon0_-o_dump.pcap_-s"><a class="selflink" href="#netsniff-ng_-i_nlmon0_-o_dump.pcap_-s">netsniff-ng
  -i nlmon0 -o dump.pcap -s</a></h2>
<h2 class="Ss" title="Ss" id="ip_link_set_nlmon0_down"><a class="selflink" href="#ip_link_set_nlmon0_down">ip
  link set nlmon0 down</a></h2>
<h2 class="Ss" title="Ss" id="ip_link_del_dev_nlmon0"><a class="selflink" href="#ip_link_del_dev_nlmon0">ip
  link del dev nlmon0</a></h2>
<h2 class="Ss" title="Ss" id="rmmod_nlmon"><a class="selflink" href="#rmmod_nlmon">rmmod
  nlmon</a></h2>
In this example, netlink traffic is being captured. If not already done, a
  netlink monitoring device needs to be set up before it can be used to capture
  netlink socket buffers (iproute2's ip(1) commands are given for nlmon device
  setup and teardown). netsniff-ng can then make use of the nlmon device as an
  input device. In this example a pcap file with netlink traffic is being
  recorded.
<h2 class="Ss" title="Ss" id="netsniff-ng_--fanout-group_1_--fanout-type_cpu_--fanout-opts_defrag_--bind-cpu_0_--notouch-irq_--silent_--in_em1_--out_/var/cap/cpu0/_--interval_120sec"><a class="selflink" href="#netsniff-ng_--fanout-group_1_--fanout-type_cpu_--fanout-opts_defrag_--bind-cpu_0_--notouch-irq_--silent_--in_em1_--out_/var/cap/cpu0/_--interval_120sec">netsniff-ng
  --fanout-group 1 --fanout-type cpu --fanout-opts defrag --bind-cpu 0
  --notouch-irq --silent --in em1 --out /var/cap/cpu0/ --interval
  120sec</a></h2>
<h2 class="Ss" title="Ss" id="netsniff-ng_--fanout-group_1_--fanout-type_cpu_--fanout-opts_defrag_--bind-cpu_1_--notouch-irq_--silent_--in_em1_--out_/var/cap/cpu1/_--interval_120sec"><a class="selflink" href="#netsniff-ng_--fanout-group_1_--fanout-type_cpu_--fanout-opts_defrag_--bind-cpu_1_--notouch-irq_--silent_--in_em1_--out_/var/cap/cpu1/_--interval_120sec">netsniff-ng
  --fanout-group 1 --fanout-type cpu --fanout-opts defrag --bind-cpu 1
  --notouch-irq --silent --in em1 --out /var/cap/cpu1/ --interval
  120sec</a></h2>
Starts two netsniff-ng fanout instances. Both are assigned into the same fanout
  group membership and traffic is splitted among them by incoming cpu.
  Furthermore, the kernel is supposed to defragment possible incoming fragments.
  First instance is assigned to CPU 0 and the second one to CPU 1, IRQ bindings
  are not altered as they might have been adapted to this scenario by the user
  a-priori, and traffic is captured on interface em1, and written out in 120
  second intervals as pcap files into /var/cap/cpu0/. Tools like mergecap(1)
  will be able to merge the cpu0/1 split back together if needed.
<h1 class="Sh" title="Sh" id="CONFIG_FILES"><a class="selflink" href="#CONFIG_FILES">CONFIG
  FILES</a></h1>
Files under /etc/netsniff-ng/ can be modified to extend netsniff-ng's
  functionality:
<div class="Pp"></div>
<br/>
 * oui.conf - OUI/MAC vendor database
<br/>
 * ether.conf - Ethernet type descriptions
<br/>
 * tcp.conf - TCP port/services map
<br/>
 * udp.conf - UDP port/services map
<br/>
 * geoip.conf - GeoIP database mirrors
<h1 class="Sh" title="Sh" id="FILTER_EXAMPLE"><a class="selflink" href="#FILTER_EXAMPLE">FILTER
  EXAMPLE</a></h1>
netsniff-ng supports both, low-level and high-level filters that are attached to
  its packet(7) socket. Low-level filters are described in the bpfc(8) man page.
<div class="Pp"></div>
Low-level filters can be used with netsniff-ng in the following way:
<div class="Pp"></div>
<br/>
 1. bpfc foo &gt; bar
<br/>
 2. netsniff-ng -f bar
<div class="Pp"></div>
Here, foo is the bpfc program that will be translated into a netsniff-ng
  readable &#x201C;opcodes&#x201D; file and passed to netsniff-ng through the -f
  option.
<div class="Pp"></div>
Similarly, high-level filter can be either passed through the -f option, e.g. -f
  &quot;tcp or udp&quot; or at the end of all options without the
  &#x201C;-f&#x201D;.
<div class="Pp"></div>
The filter syntax is the same as in tcpdump(8), which is described in the man
  page pcap-filter(7). Just to quote some examples from pcap-filter(7):
<h2 class="Ss" title="Ss" id="host_sundown"><a class="selflink" href="#host_sundown">host
  sundown</a></h2>
To select all packets arriving at or departing from sundown.
<h2 class="Ss" title="Ss" id="host_helios_and_ot_or_ace_)"><a class="selflink" href="#host_helios_and_ot_or_ace_)">host
  helios and hot or ace )</a></h2>
To select traffic between helios and either hot or ace.
<h2 class="Ss" title="Ss" id="ip_host_ace_and_not_helios"><a class="selflink" href="#ip_host_ace_and_not_helios">ip
  host ace and not helios</a></h2>
To select all IP packets between ace and any host except helios.
<h2 class="Ss" title="Ss" id="net_ucb-ether"><a class="selflink" href="#net_ucb-ether">net
  ucb-ether</a></h2>
To select all traffic between local hosts and hosts at Berkeley.
<h2 class="Ss" title="Ss" id="gateway_snup_and_(port_ftp_or_ftp-data)"><a class="selflink" href="#gateway_snup_and_(port_ftp_or_ftp-data)">gateway
  snup and (port ftp or ftp-data)</a></h2>
To select all FTP traffic through Internet gateway snup.
<h2 class="Ss" title="Ss" id="ip_and_not_net_localnet"><a class="selflink" href="#ip_and_not_net_localnet">ip
  and not net localnet</a></h2>
To select traffic neither sourced from, nor destined for, local hosts. If you
  have a gateway to another network, this traffic should never make it onto your
  local network.
<h2 class="Ss" title="Ss" id="tcp[tcpflags]_&amp;_(tcp-syn|tcp-fin)_!=_0_and_not_src_and_dst_net_localnet"><a class="selflink" href="#tcp[tcpflags]_&amp;_(tcp-syn|tcp-fin)_!=_0_and_not_src_and_dst_net_localnet">tcp[tcpflags]
  &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet</a></h2>
To select the start and end packets (the SYN and FIN packets) of each TCP
  conversation that involve a non-local host.
<h2 class="Ss" title="Ss" id="tcp_port_80_and_(((ip[2:2]_-_((ip[0]&amp;0xf)&lt;&lt;2))_-_((tcp[12]&amp;0xf0)&gt;&gt;2))_!=_0)"><a class="selflink" href="#tcp_port_80_and_(((ip[2:2]_-_((ip[0]&amp;0xf)&lt;&lt;2))_-_((tcp[12]&amp;0xf0)&gt;&gt;2))_!=_0)">tcp
  port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) -
  ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)</a></h2>
To select all IPv4 HTTP packets to and from port 80, that is to say, print only
  packets that contain data, not, for example, SYN and FIN packets and ACK-only
  packets. (IPv6 is left as an exercise for the reader.)
<h2 class="Ss" title="Ss" id="gateway_snup_and_ip[2:2]_&gt;_576"><a class="selflink" href="#gateway_snup_and_ip[2:2]_&gt;_576">gateway
  snup and ip[2:2] &gt; 576</a></h2>
To select IP packets longer than 576 bytes sent through gateway snup.
<h2 class="Ss" title="Ss" id="ether[0]_&amp;_1_=_0_and_ip[16]_&gt;=_224"><a class="selflink" href="#ether[0]_&amp;_1_=_0_and_ip[16]_&gt;=_224">ether[0]
  &amp; 1 = 0 and ip[16] &gt;= 224</a></h2>
To select IP broadcast or multicast packets that were not sent via Ethernet
  broadcast or multicast.
<h2 class="Ss" title="Ss" id="icmp[icmptype]_!=_icmp-echo_and_icmp[icmptype]_!=_icmp-echoreply"><a class="selflink" href="#icmp[icmptype]_!=_icmp-echo_and_icmp[icmptype]_!=_icmp-echoreply">icmp[icmptype]
  != icmp-echo and icmp[icmptype] != icmp-echoreply</a></h2>
To select all ICMP packets that are not echo requests or replies (that is to
  say, not &quot;ping&quot; packets).
<h1 class="Sh" title="Sh" id="PCAP_FORMATS:"><a class="selflink" href="#PCAP_FORMATS:">PCAP
  FORMATS:</a></h1>
netsniff-ng supports a couple of pcap formats, visible through ``netsniff-ng
  -D'':
<h2 class="Ss" title="Ss" id="tcpdump-capable_pcap_(default)"><a class="selflink" href="#tcpdump-capable_pcap_(default)">tcpdump-capable
  pcap (default)</a></h2>
Pcap magic number is encoded as 0xa1b2c3d4 resp. 0xd4c3b2a1. As packet meta data
  this format contains the timeval in microseconds, the original packet length
  and the captured packet length.
<h2 class="Ss" title="Ss" id="tcpdump-capable_pcap_with_ns_resolution"><a class="selflink" href="#tcpdump-capable_pcap_with_ns_resolution">tcpdump-capable
  pcap with ns resolution</a></h2>
Pcap magic number is encoded as 0xa1b23c4d resp. 0x4d3cb2a1. As packet meta data
  this format contains the timeval in nanoseconds, the original packet length
  and the captured packet length.
<h2 class="Ss" title="Ss" id="Alexey_Kuznetzov's_pcap"><a class="selflink" href="#Alexey_Kuznetzov's_pcap">Alexey
  Kuznetzov's pcap</a></h2>
Pcap magic number is encoded as 0xa1b2cd34 resp. 0x34cdb2a1. As packet meta data
  this format contains the timeval in microseconds, the original packet length,
  the captured packet length, the interface index (sll_ifindex), the packet's
  protocol (sll_protocol), and the packet type (sll_pkttype).
<h2 class="Ss" title="Ss" id="netsniff-ng_pcap"><a class="selflink" href="#netsniff-ng_pcap">netsniff-ng
  pcap</a></h2>
Pcap magic number is encoded as 0xa1e2cb12 resp. 0x12cbe2a1. As packet meta data
  this format contains the timeval in nanoseconds, the original packet length,
  the captured packet length, the timestamp hw/sw source, the interface index
  (sll_ifindex), the packet's protocol (sll_protocol), the packet type
  (sll_pkttype) and the hardware type (sll_hatype).
<div class="Pp"></div>
For further implementation details or format support in your application, have a
  look at pcap_io.h.
<h1 class="Sh" title="Sh" id="NOTE"><a class="selflink" href="#NOTE">NOTE</a></h1>
For introducing bit errors, delays with random variation and more while
  replaying pcaps, make use of tc(8) with its disciplines such as netem.
<div class="Pp"></div>
netsniff-ng does only some basic, architecture generic tuning on startup. If you
  are considering to do high performance capturing, you need to carefully tune
  your machine, both hardware and software. Simply letting netsniff-ng run
  without thinking about your underlying system might not necessarily give you
  the desired performance. Note that tuning your system is always a tradeoff and
  fine-grained balancing act (throughput versus latency). You should know what
  you are doing!
<div class="Pp"></div>
One recommendation for software-based tuning is tuned(8). Besides that, there
  are many other things to consider. Just to throw you a few things that you
  might want to look at: NAPI networking drivers, tickless kernel, I/OAT DMA
  engine, Direct Cache Access, RAM-based file systems, multi-queues, and many
  more things. Also, you might want to read the kernel's
  Documentation/networking/scaling.txt file regarding technologies such as RSS,
  RPS, RFS, aRFS and XPS. Also check your ethtool(8) settings, for example
  regarding offloading or Ethernet pause frames.
<div class="Pp"></div>
Moreover, to get a deeper understanding of netsniff-ng internals and how it
  interacts with the Linux kernel, the kernel documentation under
  Documentation/networking/{packet_mmap.txt, filter.txt, multiqueue.txt} might
  be of interest.
<div class="Pp"></div>
How do you sniff in a switched environment? I rudely refer to dSniff's
  documentation that says:
<div class="Pp"></div>
The easiest route is simply to impersonate the local gateway, stealing client
  traffic en route to some remote destination. Of course, the traffic must be
  forwarded by your attacking machine, either by enabling kernel IP forwarding
  or with a userland program that accomplishes the same (fragrouter -B1).
<div class="Pp"></div>
Several people have reportedly destroyed connectivity on their LAN to the
  outside world by ARP spoofing the gateway, and forgetting to enable IP
  forwarding on the attacking machine. Do not do this. You have been warned.
<div class="Pp"></div>
A safer option than ARP spoofing would be to use a &quot;port mirror&quot;
  function if your switch hardware supports it and if you have access to the
  switch.
<div class="Pp"></div>
If you do not need to dump all possible traffic, you have to consider running
  netsniff-ng with a BPF filter for the ingress path. For that purpose, read the
  bpfc(8) man page.
<div class="Pp"></div>
Also, to aggregate multiple NICs that you want to capture on, you should
  consider using team devices, further explained in libteam resp. teamd(8).
<div class="Pp"></div>
The following netsniff-ng pcap magic numbers are compatible with other tools, at
  least tcpdump or Wireshark:
<div class="Pp"></div>
<br/>
 0xa1b2c3d4 (tcpdump-capable pcap)
<br/>
 0xa1b23c4d (tcpdump-capable pcap with ns resolution)
<br/>
 0xa1b2cd34 (Alexey Kuznetzov's pcap)
<div class="Pp"></div>
Pcap files with different meta data endianness are supported by netsniff-ng as
  well.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
When replaying pcap files, the timing information from the pcap packet header is
  currently ignored.
<div class="Pp"></div>
Also, when replaying pcap files, demultiplexing traffic among multiple
  networking interfaces does not work. Currently, it is only sent via the
  interface that is given by the --out parameter.
<div class="Pp"></div>
When performing traffic capture on the Ethernet interface, the pcap file is
  created and packets are received but without a 802.1Q header. When one uses
  tshark, all headers are visible, but netsniff-ng removes 802.1Q headers. Is
  that normal behavior?
<div class="Pp"></div>
Yes and no. The way VLAN headers are handled in PF_PACKET sockets by the kernel
  is somewhat &#x201C;problematic&#x201D; [1]. The problem in the Linux kernel
  is that some drivers already handle VLANs, others do not. Those who handle it
  can have different implementations, such as hardware acceleration and so on.
  So in some cases the VLAN tag is even stripped before entering the protocol
  stack, in some cases probably not. The bottom line is that a &quot;hack&quot;
  was introduced in PF_PACKET so that a VLAN ID is visible in some helper data
  structure that is accessible from the RX_RING.
<div class="Pp"></div>
Then it gets really messy in the user space to artificially put the VLAN header
  back into the right place. Not to mention the resulting performance
  implications on all of libpcap(3) tools since parts of the packet need to be
  copied for reassembly via memmove(3).
<div class="Pp"></div>
A user reported the following, just to demonstrate this mess: some tests were
  made with two machines, and it seems that results depend on the driver ...
<div class="Pp"></div>
<br/>
 AR8131:
<br/>
 ethtool -k eth0 gives &quot;rx-vlan-offload: on&quot;
<br/>
 - wireshark gets the vlan header
<br/>
 - netsniff-ng doesn't get the vlan header
<br/>
 ethtool -K eth0 rxvlan off
<br/>
 - wireshark gets a QinQ header even though noone sent QinQ
<br/>
 - netsniff-ng gets the vlan header
<div class="Pp"></div>
<br/>
 RTL8111/8168B:
<br/>
 ethtool -k eth0 gives &quot;rx-vlan-offload: on&quot;
<br/>
 - wireshark gets the vlan header
<br/>
 - netsniff-ng doesn't get the vlan header
<br/>
 ethtool -K eth0 rxvlan off
<br/>
 - wireshark gets the vlan header
<br/>
 - netsniff-ng doesn't get the vlan header
<div class="Pp"></div>
Even if we agreed on doing the same workaround as libpcap, we still will not be
  able to see QinQ, for instance, due to the fact that only one VLAN tag is
  stored in the kernel helper data structure. We think that there should be a
  good consensus on the kernel space side about what gets transferred to
  userland first.
<div class="Pp"></div>
Update (28.11.2012): the Linux kernel and also bpfc(8) has built-in support for
  hardware accelerated VLAN filtering, even though tags might not be visible in
  the payload itself as reported here. However, the filtering for VLANs works
  reliable if your NIC supports it. See bpfc(8) for an example.
<div class="Pp"></div>
<br/>
 [1] http://lkml.indiana.edu/hypermail/linux/kernel/0710.3/3816.html
<h1 class="Sh" title="Sh" id="LEGAL"><a class="selflink" href="#LEGAL">LEGAL</a></h1>
netsniff-ng is licensed under the GNU GPL version 2.0.
<h1 class="Sh" title="Sh" id="HISTORY"><a class="selflink" href="#HISTORY">HISTORY</a></h1>
<b>netsniff-ng</b> was originally written for the netsniff-ng toolkit by Daniel
  Borkmann. Bigger contributions were made by Emmanuel Roullit, Markus Amend,
  Tobias Klauser and Christoph Jaeger. It is currently maintained by Tobias
  Klauser &lt;tklauser@distanz.ch&gt; and Daniel Borkmann
  &lt;dborkma@tik.ee.ethz.ch&gt;.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>trafgen</b>(8), <b>mausezahn</b>(8), <b>ifpps</b>(8), <b>bpfc</b>(8),
  <b>flowtop</b>(8), <b>astraceroute</b>(8), <b>curvetun</b>(8)
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Manpage was written by Daniel Borkmann.
<h1 class="Sh" title="Sh" id="COLOPHON"><a class="selflink" href="#COLOPHON">COLOPHON</a></h1>
This page is part of the Linux netsniff-ng toolkit project. A description of the
  project, and information about reporting bugs, can be found at
  http://netsniff-ng.org/.</div>
<table class="foot">
  <tr>
    <td class="foot-date">03 March 2013</td>
    <td class="foot-os">Linux</td>
  </tr>
</table>
</body>
</html>
