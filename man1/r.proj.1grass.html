<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>r.proj(1grass)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">r.proj(1grass)</td>
    <td class="head-vol">Grass User's Manual</td>
    <td class="head-rtitle">r.proj(1grass)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<i></i><b>r.proj</b> - Re-projects a raster map from given location to the
  current location.
<h1 class="Sh" title="Sh" id="KEYWORDS"><a class="selflink" href="#KEYWORDS">KEYWORDS</a></h1>
raster, projection, transformation, import
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>r.proj</b>
<div>&#x00A0;</div>
<b>r.proj --help</b>
<div>&#x00A0;</div>
<b>r.proj</b> [-<b>lnpg</b>] <b>location</b>=<i>name</i>
  [<b>mapset</b>=<i>name</i>] [ <b>input</b>=<i>name</i>]
  [<b>dbase</b>=<i>path</i>] [ <b>output</b>=<i>name</i>]
  [<b>method</b>=<i>string</i>] [ <b>memory</b>=<i>integer</i>]
  [<b>resolution</b>= <i>float</i>] [--<b>overwrite</b>] [--<b>help</b>]
  [--<b>verbose</b>] [-- <b>quiet</b>] [--<b>ui</b>]
<h2 class="Ss" title="Ss" id="Flags:"><a class="selflink" href="#Flags:">Flags:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    List raster maps in input mapset and exit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Do not perform region cropping optimization</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Print input map&#x2019;s bounds in the current projection and exit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Print input map&#x2019;s bounds in the current projection and exit (shell
      style)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--overwrite</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Allow output files to overwrite existing files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Print usage summary</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbose</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Verbose module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quiet</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Quiet module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ui</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Force launching GUI dialog</dd>
</dl>
<h2 class="Ss" title="Ss" id="Parameters:"><a class="selflink" href="#Parameters:">Parameters:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>location</b>=<i>name</i> <b>[required]</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Location containing input raster map
    <div>&#x00A0;</div>
    Location name (not location path)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mapset</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Mapset containing input raster map
    <div>&#x00A0;</div>
    Default: name of current mapset</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>input</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name of input raster map to re-project</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dbase</b>=<i>path</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Path to GRASS database of input location
    <div>&#x00A0;</div>
    Default: path to the current GRASS GIS database</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>output</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name for output raster map (default: same as &#x2019;input&#x2019;)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>method</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Interpolation method to use
    <div>&#x00A0;</div>
    Options: <i>nearest, bilinear, bicubic, lanczos, bilinear_f, bicubic_f,
      lanczos_f</i>
    <div>&#x00A0;</div>
    Default: <i>nearest</i>
    <div>&#x00A0;</div>
     <b>nearest</b>: nearest neighbor
    <div>&#x00A0;</div>
     <b>bilinear</b>: bilinear interpolation
    <div>&#x00A0;</div>
     <b>bicubic</b>: bicubic interpolation
    <div>&#x00A0;</div>
     <b>lanczos</b>: lanczos filter
    <div>&#x00A0;</div>
     <b>bilinear_f</b>: bilinear interpolation with fallback
    <div>&#x00A0;</div>
     <b>bicubic_f</b>: bicubic interpolation with fallback
    <div>&#x00A0;</div>
     <b>lanczos_f</b>: lanczos filter with fallback</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>memory</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Maximum memory to be used (in MB)
    <div>&#x00A0;</div>
    Cache size for raster rows
    <div>&#x00A0;</div>
    Default: <i>300</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>resolution</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Resolution of output raster map</dd>
</dl>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>r.proj</i> projects a raster map in a specified mapset of a specified
  location from the projection of the input location to a raster map in the
  current location. The projection information is taken from the current
  PROJ_INFO files, as set and viewed with <i>g.proj</i>.
<h2 class="Ss" title="Ss" id="Introduction"><a class="selflink" href="#Introduction">Introduction</a></h2>
<h2 class="Ss" title="Ss" id="Map_projections"><a class="selflink" href="#Map_projections">Map
  projections</a></h2>
Map projections are a method of representing information from a curved surface
  (usually a spheroid) in two dimensions, typically to allow indexing through
  cartesian coordinates. There are a wide variety of projections, with common
  ones divided into a number of classes, including cylindrical and
  pseudo-cylindrical, conic and pseudo-conic, and azimuthal methods, each of
  which may be conformal, equal-area, or neither.
<div class="Pp"></div>
The particular projection chosen depends on the purpose of the project, and the
  size, shape and location of the area of interest. For example, normal
  cylindrical projections are good for maps which are of greater extent
  east-west than north-south and in equatorial regions, while conic projections
  are better in mid-latitudes; transverse cylindrical projections are used for
  maps which are of greater extent north-south than east-west; azimuthal
  projections are used for polar regions. Oblique versions of any of these may
  also be used. Conformal projections preserve angular relationships, and better
  preserve arc-length, while equal-area projections are more appropriate for
  statistical studies and work in which the amount of material is important.
<div class="Pp"></div>
Projections are defined by precise mathematical relations, so the method of
  projecting coordinates from a geographic reference frame (latitude-longitude)
  into a projected cartesian reference frame (eg metres) is governed by these
  equations. Inverse projections can also be achieved. The public-domain Unix
  software package <i>PROJ.4</i> [1] has been designed to perform these
  transformations, and the user&#x2019;s manual contains a detailed description
  of over 100 useful projections. This also includes a programmers library of
  the projection methods to support other software development.
<div class="Pp"></div>
Thus, converting a vector map - in which objects are located with arbitrary
  spatial precision - from one projection into another is usually accomplished
  by a simple two-step process: first the location of all the points in the map
  are converted from the source through an inverse projection into
  latitude-longitude, and then through a forward projection into the target. (Of
  course the procedure will be one-step if either the source or target is in
  geographic coordinates.)
<div class="Pp"></div>
Converting a raster map, or image, between different projections, however,
  involves additional considerations. A raster may be considered to represent a
  sampling of a process at a regular, ordered set of locations. The set of
  locations that lie at the intersections of a cartesian grid in one projection
  will not, in general, coincide with the sample points in another projection.
  Thus, the conversion of raster maps involves an interpolation step in which
  the values of points at intermediate locations relative to the source grid are
  estimated.
<h2 class="Ss" title="Ss" id="Projecting_vector_maps_within_the_GRASS_GIS"><a class="selflink" href="#Projecting_vector_maps_within_the_GRASS_GIS">Projecting
  vector maps within the GRASS GIS</a></h2>
GIS data capture, import and transfer often requires a projection step, since
  the source or client will frequently be in a different projection to the
  working projection.
<div class="Pp"></div>
In some cases it is convenient to do the conversion outside the package, prior
  to import or after export, using software such as <i>PROJ.4</i>&#x2019;s
  <i>cs2cs</i> [1]. This is an easy method for converting an ASCII file
  containing a list of coordinate points, since there is no topology to be
  preserved and <i>cs2cs</i> can be used to process simple lists using a
  one-line command. The <i>m.proj</i> module provides a handy front end to
  cs2cs.
<div class="Pp"></div>
Vector maps is generally more complex, as parts of the data stored in the files
  will describe topology, and not just coordinates. In GRASS GIS the
  <i>v.proj</i> module is provided to reproject vector maps, transferring
  topology and attributes as well as node coordinates. This program uses the
  projection definition and parameters which are stored in the PROJ_INFO and
  PROJ_UNITS files in the PERMANENT mapset directory for every GRASS location.
<h2 class="Ss" title="Ss" id="Design_of_r.proj"><a class="selflink" href="#Design_of_r.proj">Design
  of r.proj</a></h2>
As discussed briefly above, the fundamental step in re-projecting a raster is
  resampling the source grid at locations corresponding to the intersections of
  a grid in the target projection. The basic procedure for accomplishing this,
  therefore, is as follows:
<div class="Pp"></div>
<i>r.proj</i> converts a map to a new geographic projection. It reads a map from
  a different location, projects it and write it out to the current location.
  The projected data is resampled with one of four different methods: nearest
  neighbor, bilinear, bicubic iterpolation or lanczos.
<div class="Pp"></div>
The <b>method=nearest</b> method, which performs a nearest neighbor assignment,
  is the fastest of the three resampling methods. It is primarily used for
  categorical data such as a land use classification, since it will not change
  the values of the data cells. The <b>method=bilinear</b> method determines the
  new value of the cell based on a weighted distance average of the 4
  surrounding cells in the input map. The <b>method=bicubic</b> method
  determines the new value of the cell based on a weighted distance average of
  the 16 surrounding cells in the input map. The <b>method=lanzcos</b> method
  determines the new value of the cell based on a weighted distance average of
  the 25 surrounding cells in the input map. Compared to bicubic, lanczos puts a
  higher weight on cells close to the center and a lower weight on cells away
  from the center, resulting in slightly better contrast.
<div class="Pp"></div>
The bilinear, bicubic and lanczos interpolation methods are most appropriate for
  continuous data and cause some smoothing. The amount of smoothing decreases
  from bilinear to bicubic to lanczos. These options should not be used with
  categorical data, since the cell values will be altered.
<div class="Pp"></div>
In the bilinear, bicubic and lanczos methods, if any of the surrounding cells
  used to interpolate the new cell value are null, the resulting cell will be
  null, even if the nearest cell is not null. This will cause some thinning
  along null borders, such as the coasts of land areas in a DEM. The bilinear_f,
  bicubic_f and lanczos_f interpolation methods can be used if thinning along
  null edges is not desired. These methods &quot;fall back&quot; to simpler
  interpolation methods along null borders. That is, from lanczos to bicubic to
  bilinear to nearest.
<div class="Pp"></div>
If nearest neighbor assignment is used, the output map has the same raster
  format as the input map. If any of the interpolations is used, the output map
  is written as floating point.
<div class="Pp"></div>
Note that, following normal GRASS conventions, the coverage and resolution of
  the resulting grid is set by the current region settings, which may be
  adjusted using <i>g.region</i>. The target raster will be relatively unbiased
  for all cases if its grid has a similar resolution to the source, so that the
  resampling/interpolation step is only a local operation. If the resolution is
  changed significantly, then the behaviour of the generalisation or refinement
  will depend on the model of the process being represented. This will be very
  different for categorical versus numerical data. Note that three methods for
  the local interpolation step are provided.
<div class="Pp"></div>
<i>r.proj</i> supports general datum transformations, making use of the
  <i>PROJ.4</i> co-ordinate system translation library.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
If <b>output</b> is not specified it is set to be the same as input map name.
<div>&#x00A0;</div>
If <b>mapset</b> is not specified, its name is assumed to be the same as the
  current mapset&#x2019;s name.
<div>&#x00A0;</div>
If <b>dbase</b> is not specified it is assumed to be the current database. The
  user only has to specify <b>dbase</b> if the source location is stored in
  another separate GRASS database.
<div class="Pp"></div>
To avoid excessive time consumption when reprojecting a map the region and
  resolution of the target location should be set appropriately beforehand.
<div class="Pp"></div>
A simple way to do this is to check the projected bounds of the input map in the
  current location&#x2019;s projection using the <b>-p</b> flag. The <b>-g</b>
  flag reports the same thing, but in a form which can be directly cut and
  pasted into a <i>g.region</i> command. After setting the region in that way
  you might check the cell resolution with &quot; <i>g.region -p</i>&quot; then
  snap it to a regular grid with <i>g.region</i>&#x2019;s <b>-a</b> flag. E.g.
  g.region -a res=5 -p. Note that this is just a rough guide.
<div class="Pp"></div>
A more involved, but more accurate, way to do this is to generate a vector
  &quot;box&quot; map of the region in the source location using <i>v.in.region
  -d</i>. This &quot;box&quot; map is then reprojected into the target location
  with <i>v.proj</i>. Next the region in the target location is set to the
  extent of the new vector map with <i>g.region</i> along with the desired
  raster resolution ( <i>g.region -m</i> can be used in Latitude/Longitude
  locations to measure the geodetic length of a pixel). <i>r.proj</i> is then
  run for the raster map the user wants to reproject. In this case a little
  preparation goes a long way.
<div class="Pp"></div>
When reprojecting whole-world maps the user should disable map-trimming with the
  <b>-n</b> flag. Trimming is not useful here because the module has the whole
  map in memory anyway. Besides that, world &quot;edges&quot; are hard (or
  impossible) to find in projections other than latitude-longitude so results
  may be odd with trimming.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<h2 class="Ss" title="Ss" id="Inline_method"><a class="selflink" href="#Inline_method">Inline
  method</a></h2>
With GRASS running in the destination location use the <b>-g</b> flag to show
  the input map&#x2019;s bounds once projected into the current working
  projection, then use that to set the region bounds before performing the
  reprojection:
<div>&#x00A0;</div>
<pre>
# calculate where output map will be
r.proj input=elevation location=ll_wgs84 mapset=user1 -p
Source cols: 8162
Source rows: 12277
Local north: -4265502.30382993
Local south: -4473453.15255565
Local west: 14271663.19157564
Local east: 14409956.2693866
# same calculation, but in a form which can be cut and pasted into a g.region call
r.proj input=elevation location=ll_wgs84 mapset=user1 -g
n=-4265502.30382993 s=-4473453.15255565 w=14271663.19157564 e=14409956.2693866 rows=12277 cols=8162
g.region n=-4265502.30382993 s=-4473453.15255565 \
  w=14271663.19157564 e=14409956.2693866 rows=12277 cols=8162 -p
projection: 99 (Mercator)
zone:       0
datum:      wgs84
ellipsoid:  wgs84
north:      -4265502.30382993
south:      -4473453.15255565
west:       14271663.19157564
east:       14409956.2693866
nsres:      16.93824621
ewres:      16.94352828
rows:       12277
cols:       8162
cells:      100204874
# round resolution to something cleaner
g.region res=17 -a -p
projection: 99 (Mercator)
zone:       0
datum:      wgs84
ellipsoid:  wgs84
north:      -4265487
south:      -4473465
west:       14271653
east:       14409965
nsres:      17
ewres:      17
rows:       12234
cols:       8136
cells:      99535824
# finally, perform the reprojection
r.proj input=elevation location=ll_wgs84 mapset=user1 memory=800
</pre>
<h2 class="Ss" title="Ss" id="v.in.region_method"><a class="selflink" href="#v.in.region_method">v.in.region
  method</a></h2>
<pre>
# In the source location, use v.in.region to generate a bounding box around the
# region of interest:
v.in.region -d output=bounds type=area
# Now switch to the target location and import the vector bounding box
# (you can run v.proj -l to get a list of vector maps in the source location):
v.proj input=bounds location=source_location_name output=bounds_reprojected
# Set the region in the target location with that of the newly-imported vector
# bounds map, and align the resolution to the desired cell resolution of the
# final, reprojected raster map:
g.region vector=bounds_reprojected res=5 -a
# Now reproject the raster into the target location
r.proj input=elevation.dem output=elevation.dem.reproj \
location=source_location_name mapset=PERMANENT res=5 method=bicubic
</pre>
<h1 class="Sh" title="Sh" id="REFERENCES"><a class="selflink" href="#REFERENCES">REFERENCES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>1</b></dt>
  <dd class="It-tag">Evenden, G.I. (1990) Cartographic projection procedures for
      the UNIX environment - a user&#x2019;s manual. USGS Open-File Report
      90-284 (OF90-284.pdf) See also there: Interim Report and 2nd Interim
      Report on Release 4, Evenden 1994).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>2</b></dt>
  <dd class="It-tag">Richards, John A. (1993), Remote Sensing Digital Image
      Analysis, Springer-Verlag, Berlin, 2nd edition.</dd>
</dl>
<div class="Pp"></div>
PROJ 4: Projection/datum support library.
<div class="Pp"></div>
<b>Further reading</b>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">ASPRS Grids and Datum</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Projections Transform List (PROJ.4)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">MapRef - The Collection of Map Projections and Reference
      Systems for Europe</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Information and Service System for European Coordinate
      Reference Systems - CRS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Cartographical Map Projections by Carlos A. Furuti</dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i></i> <i>g.region,</i> <i>g.proj,</i> <i>i.rectify,</i> <i>m.proj,</i>
  <i>r.support,</i> <i>r.stats,</i> <i>v.proj,</i> <i>v.in.region</i> <i></i>
<div class="Pp"></div>
The &#x2019;gdalwarp&#x2019; and &#x2019;gdal_translate&#x2019; utilities are
  available from the GDAL project.
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Martin Schroeder, University of Heidelberg, Germany
<div>&#x00A0;</div>
Man page text from S.J.D. Cox, AGCRC, CSIRO Exploration &amp; Mining, Nedlands,
  WA
<div>&#x00A0;</div>
Updated by Morten Hulden
<div>&#x00A0;</div>
Datum transformation support and cleanup by Paul Kelly
<div class="Pp"></div>
<i>Last changed: $Date: 2016-01-29 10:29:57 +0100 (Fri, 29 Jan 2016) $</i>
<h1 class="Sh" title="Sh" id="SOURCE_CODE"><a class="selflink" href="#SOURCE_CODE">SOURCE
  CODE</a></h1>
Available at: r.proj source code (history)
<div class="Pp"></div>
Main index | Raster index | Topics index | Keywords index | Graphical index |
  Full index
<div class="Pp"></div>
&#x00A9; 2003-2016 GRASS Development Team, GRASS GIS 7.2.0 Reference
  Manual</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os">GRASS 7.2.0</td>
  </tr>
</table>
</body>
</html>
