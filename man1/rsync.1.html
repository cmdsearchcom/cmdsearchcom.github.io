<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:36:15 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>rsync(1) rsync(1)</p>

<p style="margin-top: 1em">NAME <br>
rsync - a fast, versatile, remote (and local) file-copying
tool</p>

<p style="margin-top: 1em">SYNOPSIS <br>
Local: rsync [OPTION...] SRC... [DEST]</p>

<p style="margin-top: 1em">Access via remote shell: <br>
Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST] <br>
Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</p>

<p style="margin-top: 1em">Access via rsync daemon: <br>
Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST] <br>
rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
<br>
Push: rsync [OPTION...] SRC... [USER@]HOST::DEST <br>
rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</p>

<p style="margin-top: 1em">Usages with just one SRC arg and
no DEST arg will list the source files instead of
copying.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Rsync is a fast and extraordinarily versatile file copying
tool. It can copy locally, to/from another host over any
remote shell, or to/from a remote rsync daemon. It offers a
<br>
large number of options that control every aspect of its
behavior and permit very flexible specification of the set
of files to be copied. It is famous for its delta-transfer
<br>
algorithm, which reduces the amount of data sent over the
network by sending only the differences between the source
files and the existing files in the destination. Rsync is
<br>
widely used for backups and mirroring and as an improved
copy command for everyday use.</p>

<p style="margin-top: 1em">Rsync finds files that need to
be transferred using a &quot;quick check&quot; algorithm (by
default) that looks for files that have changed in size or
in last-modified time. Any changes <br>
in the other preserved attributes (as requested by options)
are made on the destination file directly when the quick
check indicates that the file&acirc;s data does not need to
be <br>
updated.</p>

<p style="margin-top: 1em">Some of the additional features
of rsync are:</p>

<p style="margin-top: 1em">o support for copying links,
devices, owners, groups, and permissions</p>

<p style="margin-top: 1em">o exclude and exclude-from
options similar to GNU tar</p>

<p style="margin-top: 1em">o a CVS exclude mode for
ignoring the same files that CVS would ignore</p>

<p style="margin-top: 1em">o can use any transparent remote
shell, including ssh or rsh</p>

<p style="margin-top: 1em">o does not require super-user
privileges</p>

<p style="margin-top: 1em">o pipelining of file transfers
to minimize latency costs</p>

<p style="margin-top: 1em">o support for anonymous or
authenticated rsync daemons (ideal for mirroring)</p>

<p style="margin-top: 1em">GENERAL <br>
Rsync copies files either to or from a remote host, or
locally on the current host (it does not support copying
files between two remote hosts).</p>

<p style="margin-top: 1em">There are two different ways for
rsync to contact a remote system: using a remote-shell
program as the transport (such as ssh or rsh) or contacting
an rsync daemon directly via <br>
TCP. The remote-shell transport is used whenever the source
or destination path contains a single colon (:) separator
after a host specification. Contacting an rsync daemon <br>
directly happens when the source or destination path
contains a double colon (::) separator after a host
specification, OR when an rsync:// URL is specified (see
also the &quot;USING <br>
RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION&quot;
section for an exception to this latter rule).</p>

<p style="margin-top: 1em">As a special case, if a single
source arg is specified without a destination, the files are
listed in an output format similar to &quot;ls -l&quot;.</p>

<p style="margin-top: 1em">As expected, if neither the
source or destination path specify a remote host, the copy
occurs locally (see also the --list-only option).</p>

<p style="margin-top: 1em">Rsync refers to the local side
as the &quot;client&quot; and the remote side as the
&quot;server&quot;. Don&acirc;t confuse &quot;server&quot;
with an rsync daemon -- a daemon is always a server, but a
server can <br>
be either a daemon or a remote-shell spawned process.</p>

<p style="margin-top: 1em">SETUP <br>
See the file README for installation instructions.</p>

<p style="margin-top: 1em">Once installed, you can use
rsync to any machine that you can access via a remote shell
(as well as some that you can access using the rsync
daemon-mode protocol). For remote <br>
transfers, a modern rsync uses ssh for its communications,
but it may have been configured to use a different remote
shell by default, such as rsh or remsh.</p>

<p style="margin-top: 1em">You can also specify any remote
shell you like, either by using the -e command line option,
or by setting the RSYNC_RSH environment variable.</p>

<p style="margin-top: 1em">Note that rsync must be
installed on both the source and destination machines.</p>

<p style="margin-top: 1em">USAGE <br>
You use rsync in the same way you use rcp. You must specify
a source and a destination, one of which may be remote.</p>

<p style="margin-top: 1em">Perhaps the best way to explain
the syntax is with some examples:</p>

<p style="margin-top: 1em">rsync -t *.c foo:src/</p>

<p style="margin-top: 1em">This would transfer all files
matching the pattern *.c from the current directory to the
directory src on the machine foo. If any of the files
already exist on the remote system <br>
then the rsync remote-update protocol is used to update the
file by sending only the differences. See the tech report
for details.</p>

<p style="margin-top: 1em">rsync -avz foo:src/bar
/data/tmp</p>

<p style="margin-top: 1em">This would recursively transfer
all files from the directory src/bar on the machine foo into
the /data/tmp/bar directory on the local machine. The files
are transferred in &quot;ar&acirc; <br>
chive&quot; mode, which ensures that symbolic links,
devices, attributes, permissions, ownerships, etc. are
preserved in the transfer. Additionally, compression will be
used to <br>
reduce the size of data portions of the transfer.</p>

<p style="margin-top: 1em">rsync -avz foo:src/bar/
/data/tmp</p>

<p style="margin-top: 1em">A trailing slash on the source
changes this behavior to avoid creating an additional
directory level at the destination. You can think of a
trailing / on a source as meaning <br>
&quot;copy the contents of this directory&quot; as opposed
to &quot;copy the directory by name&quot;, but in both cases
the attributes of the containing directory are transferred
to the containing <br>
directory on the destination. In other words, each of the
following commands copies the files in the same way,
including their setting of the attributes of /dest/foo:</p>

<p style="margin-top: 1em">rsync -av /src/foo /dest <br>
rsync -av /src/foo/ /dest/foo</p>

<p style="margin-top: 1em">Note also that host and module
references don&acirc;t require a trailing slash to copy the
contents of the default directory. For example, both of
these copy the remote directory&acirc;s <br>
contents into &quot;/dest&quot;:</p>

<p style="margin-top: 1em">rsync -av host: /dest <br>
rsync -av host::module /dest</p>

<p style="margin-top: 1em">You can also use rsync in
local-only mode, where both the source and destination
don&acirc;t have a &acirc;:&acirc; in the name. In this case
it behaves like an improved copy command.</p>

<p style="margin-top: 1em">Finally, you can list all the
(listable) modules available from a particular rsync daemon
by leaving off the module name:</p>

<p style="margin-top: 1em">rsync
somehost.mydomain.com::</p>

<p style="margin-top: 1em">See the following section for
more details.</p>

<p style="margin-top: 1em">ADVANCED USAGE <br>
The syntax for requesting multiple files from a remote host
is done by specifying additional remote-host args in the
same style as the first, or with the hostname omitted. For
<br>
instance, all these work:</p>

<p style="margin-top: 1em">rsync -av host:file1 :file2
host:file{3,4} /dest/ <br>
rsync -av host::modname/file{1,2} host::modname/file3 /dest/
<br>
rsync -av host::modname/file1 ::modname/file{3,4}</p>

<p style="margin-top: 1em">Older versions of rsync required
using quoted spaces in the SRC, like these examples:</p>

<p style="margin-top: 1em">rsync -av host:&rsquo;dir1/file1
dir2/file2&rsquo; /dest <br>
rsync host::&rsquo;modname/dir1/file1
modname/dir2/file2&rsquo; /dest</p>

<p style="margin-top: 1em">This word-splitting still works
(by default) in the latest rsync, but is not as easy to use
as the first method.</p>

<p style="margin-top: 1em">If you need to transfer a
filename that contains whitespace, you can either specify
the --protect-args (-s) option, or you&acirc;ll need to
escape the whitespace in a way that the <br>
remote shell will understand. For instance:</p>

<p style="margin-top: 1em">rsync -av
host:&rsquo;file&nbsp;name&nbsp;with&nbsp;spaces&rsquo;
/dest</p>

<p style="margin-top: 1em">CONNECTING TO AN RSYNC DAEMON
<br>
It is also possible to use rsync without a remote shell as
the transport. In this case you will directly connect to a
remote rsync daemon, typically using TCP port 873. (This
<br>
obviously requires the daemon to be running on the remote
system, so refer to the STARTING AN RSYNC DAEMON TO ACCEPT
CONNECTIONS section below for information on that.)</p>

<p style="margin-top: 1em">Using rsync in this way is the
same as using it with a remote shell except that:</p>

<p style="margin-top: 1em">o you either use a double colon
:: instead of a single colon to separate the hostname from
the path, or you use an rsync:// URL.</p>

<p style="margin-top: 1em">o the first word of the
&quot;path&quot; is actually a module name.</p>

<p style="margin-top: 1em">o the remote daemon may print a
message of the day when you connect.</p>

<p style="margin-top: 1em">o if you specify no path name on
the remote daemon then the list of accessible paths on the
daemon will be shown.</p>

<p style="margin-top: 1em">o if you specify no local
destination then a listing of the specified files on the
remote daemon is provided.</p>

<p style="margin-top: 1em">o you must not specify the --rsh
(-e) option.</p>

<p style="margin-top: 1em">An example that copies all the
files in a remote module named &quot;src&quot;:</p>

<p style="margin-top: 1em">rsync -av host::src /dest</p>

<p style="margin-top: 1em">Some modules on the remote
daemon may require authentication. If so, you will receive a
password prompt when you connect. You can avoid the password
prompt by setting the envi&acirc; <br>
ronment variable RSYNC_PASSWORD to the password you want to
use or using the --password-file option. This may be useful
when scripting rsync.</p>

<p style="margin-top: 1em">WARNING: On some systems
environment variables are visible to all users. On those
systems using --password-file is recommended.</p>

<p style="margin-top: 1em">You may establish the connection
via a web proxy by setting the environment variable
RSYNC_PROXY to a hostname:port pair pointing to your web
proxy. Note that your web proxy&acirc;s <br>
configuration must support proxy connections to port
873.</p>

<p style="margin-top: 1em">You may also establish a daemon
connection using a program as a proxy by setting the
environment variable RSYNC_CONNECT_PROG to the commands you
wish to run in place of making a <br>
direct socket connection. The string may contain the escape
&quot;%H&quot; to represent the hostname specified in the
rsync command (so use &quot;%%&quot; if you need a single
&quot;%&quot; in your string). <br>
For example:</p>

<p style="margin-top: 1em">export
RSYNC_CONNECT_PROG=&rsquo;ssh proxyhost nc %H 873&rsquo;
<br>
rsync -av targethost1::module/src/ /dest/ <br>
rsync -av rsync:://targethost2/module/src/ /dest/</p>

<p style="margin-top: 1em">The command specified above uses
ssh to run nc (netcat) on a proxyhost, which forwards all
data to port 873 (the rsync daemon) on the targethost
(%H).</p>

<p style="margin-top: 1em">USING RSYNC-DAEMON FEATURES VIA
A REMOTE-SHELL CONNECTION <br>
It is sometimes useful to use various features of an rsync
daemon (such as named modules) without actually allowing any
new socket connections into a system (other than what is
<br>
already required to allow remote-shell access). Rsync
supports connecting to a host using a remote shell and then
spawning a single-use &quot;daemon&quot; server that expects
to read its <br>
config file in the home dir of the remote user. This can be
useful if you want to encrypt a daemon-style
transfer&acirc;s data, but since the daemon is started up
fresh by the remote <br>
user, you may not be able to use features such as chroot or
change the uid used by the daemon. (For another way to
encrypt a daemon transfer, consider using ssh to tunnel a
<br>
local port to a remote machine and configure a normal rsync
daemon on that remote host to only allow connections from
&quot;localhost&quot;.)</p>

<p style="margin-top: 1em">From the user&acirc;s
perspective, a daemon transfer via a remote-shell connection
uses nearly the same command-line syntax as a normal
rsync-daemon transfer, with the only exception <br>
being that you must explicitly set the remote shell program
on the command-line with the --rsh=COMMAND option. (Setting
the RSYNC_RSH in the environment will not turn on this <br>
functionality.) For example:</p>

<p style="margin-top: 1em">rsync -av --rsh=ssh host::module
/dest</p>

<p style="margin-top: 1em">If you need to specify a
different remote-shell user, keep in mind that the user@
prefix in front of the host is specifying the rsync-user
value (for a module that requires <br>
user-based authentication). This means that you must give
the &acirc;-l user&acirc; option to ssh when specifying the
remote-shell, as in this example that uses the short version
of the <br>
--rsh option:</p>

<p style="margin-top: 1em">rsync -av -e &quot;ssh -l
ssh-user&quot; rsync-user@host::module /dest</p>

<p style="margin-top: 1em">The &quot;ssh-user&quot; will be
used at the ssh level; the &quot;rsync-user&quot; will be
used to log-in to the &quot;module&quot;.</p>

<p style="margin-top: 1em">STARTING AN RSYNC DAEMON TO
ACCEPT CONNECTIONS <br>
In order to connect to an rsync daemon, the remote system
needs to have a daemon already running (or it needs to have
configured something like inetd to spawn an rsync daemon for
<br>
incoming connections on a particular port). For full
information on how to start a daemon that will handling
incoming socket connections, see the rsyncd.conf(5) man page
-- that <br>
is the config file for the daemon, and it contains the full
details for how to run the daemon (including stand-alone and
inetd configurations).</p>

<p style="margin-top: 1em">If you&acirc;re using one of the
remote-shell transports for the transfer, there is no need
to manually start an rsync daemon.</p>

<p style="margin-top: 1em">SORTED TRANSFER ORDER <br>
Rsync always sorts the specified filenames into its internal
transfer list. This handles the merging together of the
contents of identically named directories, makes it easy to
<br>
remove duplicate filenames, and may confuse someone when the
files are transferred in a different order than what was
given on the command-line.</p>

<p style="margin-top: 1em">If you need a particular file to
be transferred prior to another, either separate the files
into different rsync calls, or consider using
--delay-updates (which doesn&acirc;t affect <br>
the sorted transfer order, but does make the final
file-updating phase happen much more rapidly).</p>

<p style="margin-top: 1em">EXAMPLES <br>
Here are some examples of how I use rsync.</p>

<p style="margin-top: 1em">To backup my wife&acirc;s home
directory, which consists of large MS Word files and mail
folders, I use a cron job that runs</p>

<p style="margin-top: 1em">rsync -Cavz .
arvidsjaur:backup</p>

<p style="margin-top: 1em">each night over a PPP connection
to a duplicate directory on my machine
&quot;arvidsjaur&quot;.</p>

<p style="margin-top: 1em">To synchronize my samba source
trees I use the following Makefile targets:</p>

<p style="margin-top: 1em">get: <br>
rsync -avuzb --exclude &rsquo;*~&rsquo; samba:samba/ . <br>
put: <br>
rsync -Cavuzb . samba:samba/ <br>
sync: get put</p>

<p style="margin-top: 1em">this allows me to sync with a
CVS directory at the other end of the connection. I then do
CVS operations on the remote machine, which saves a lot of
time as the remote CVS proto&acirc; <br>
col isn&acirc;t very efficient.</p>

<p style="margin-top: 1em">I mirror a directory between my
&quot;old&quot; and &quot;new&quot; ftp sites with the
command:</p>

<p style="margin-top: 1em">rsync -az -e ssh --delete
~ftp/pub/samba nimbus:&quot;~ftp/pub/tridge&quot;</p>

<p style="margin-top: 1em">This is launched from cron every
few hours.</p>

<p style="margin-top: 1em">OPTIONS SUMMARY <br>
Here is a short summary of the options available in rsync.
Please refer to the detailed description below for a
complete description.</p>

<p style="margin-top: 1em">-v, --verbose increase verbosity
<br>
-q, --quiet suppress non-error messages <br>
--no-motd suppress daemon-mode MOTD (see caveat) <br>
-c, --checksum skip based on checksum, not mod-time &amp;
size <br>
-a, --archive archive mode; equals -rlptgoD (no -H,-A,-X)
<br>
--no-OPTION turn off an implied OPTION (e.g. --no-D) <br>
-r, --recursive recurse into directories <br>
-R, --relative use relative path names <br>
--no-implied-dirs don&rsquo;t send implied dirs with
--relative <br>
-b, --backup make backups (see --suffix &amp; --backup-dir)
<br>
--backup-dir=DIR make backups into hierarchy based in DIR
<br>
--suffix=SUFFIX backup suffix (default ~ w/o --backup-dir)
<br>
-u, --update skip files that are newer on the receiver <br>
--inplace update destination files in-place <br>
--append append data onto shorter files <br>
--append-verify --append w/old data in file checksum <br>
-d, --dirs transfer directories without recursing <br>
-l, --links copy symlinks as symlinks <br>
-L, --copy-links transform symlink into referent file/dir
<br>
--copy-unsafe-links only &quot;unsafe&quot; symlinks are
transformed <br>
--safe-links ignore symlinks that point outside the tree
<br>
-k, --copy-dirlinks transform symlink to dir into referent
dir <br>
-K, --keep-dirlinks treat symlinked dir on receiver as dir
<br>
-H, --hard-links preserve hard links <br>
-p, --perms preserve permissions <br>
-E, --executability preserve executability <br>
--chmod=CHMOD affect file and/or directory permissions <br>
-A, --acls preserve ACLs (implies -p) <br>
-X, --xattrs preserve extended attributes <br>
-o, --owner preserve owner (super-user only) <br>
-g, --group preserve group <br>
--devices preserve device files (super-user only) <br>
--copy-devices copy device contents as regular file <br>
--specials preserve special files <br>
-D same as --devices --specials <br>
-t, --times preserve modification times <br>
-O, --omit-dir-times omit directories from --times <br>
--super receiver attempts super-user activities <br>
--fake-super store/recover privileged attrs using xattrs
<br>
-S, --sparse handle sparse files efficiently <br>
-n, --dry-run perform a trial run with no changes made <br>
-W, --whole-file copy files whole (w/o delta-xfer algorithm)
<br>
-x, --one-file-system don&rsquo;t cross filesystem
boundaries <br>
-B, --block-size=SIZE force a fixed checksum block-size <br>
-e, --rsh=COMMAND specify the remote shell to use <br>
--rsync-path=PROGRAM specify the rsync to run on remote
machine <br>
--existing skip creating new files on receiver <br>
--ignore-existing skip updating files that exist on receiver
<br>
--remove-source-files sender removes synchronized files
(non-dir) <br>
--del an alias for --delete-during <br>
--delete delete extraneous files from dest dirs <br>
--delete-before receiver deletes before xfer, not during
<br>
--delete-during receiver deletes during the transfer <br>
--delete-delay find deletions during, delete after <br>
--delete-after receiver deletes after transfer, not during
<br>
--delete-excluded also delete excluded files from dest dirs
<br>
--ignore-errors delete even if there are I/O errors <br>
--force force deletion of dirs even if not empty <br>
--max-delete=NUM don&rsquo;t delete more than NUM files <br>
--max-size=SIZE don&rsquo;t transfer any file larger than
SIZE <br>
--min-size=SIZE don&rsquo;t transfer any file smaller than
SIZE <br>
--partial keep partially transferred files <br>
--partial-dir=DIR put a partially transferred file into DIR
<br>
--delay-updates put all updated files into place at end <br>
-m, --prune-empty-dirs prune empty directory chains from
file-list <br>
--numeric-ids don&rsquo;t map uid/gid values by user/group
name <br>
--timeout=SECONDS set I/O timeout in seconds <br>
--contimeout=SECONDS set daemon connection timeout in
seconds <br>
-I, --ignore-times don&rsquo;t skip files that match size
and time <br>
--size-only skip files that match in size <br>
--modify-window=NUM compare mod-times with reduced accuracy
<br>
-T, --temp-dir=DIR create temporary files in directory DIR
<br>
-y, --fuzzy find similar file for basis if no dest file <br>
--compare-dest=DIR also compare received files relative to
DIR <br>
--copy-dest=DIR ... and include copies of unchanged files
<br>
--link-dest=DIR hardlink to files in DIR when unchanged <br>
-z, --compress compress file data during the transfer <br>
--compress-level=NUM explicitly set compression level <br>
--skip-compress=LIST skip compressing files with suffix in
LIST <br>
-C, --cvs-exclude auto-ignore files in the same way CVS does
<br>
-f, --filter=RULE add a file-filtering RULE <br>
-F same as --filter=&rsquo;dir-merge /.rsync-filter&rsquo;
<br>
repeated: --filter=&rsquo;- .rsync-filter&rsquo; <br>
--exclude=PATTERN exclude files matching PATTERN <br>
--exclude-from=FILE read exclude patterns from FILE <br>
--include=PATTERN don&rsquo;t exclude files matching PATTERN
<br>
--include-from=FILE read include patterns from FILE <br>
--files-from=FILE read list of source-file names from FILE
<br>
-0, --from0 all *from/filter files are delimited by 0s <br>
-s, --protect-args no space-splitting; wildcard chars only
<br>
--address=ADDRESS bind address for outgoing socket to daemon
<br>
--port=PORT specify double-colon alternate port number <br>
--sockopts=OPTIONS specify custom TCP options <br>
--blocking-io use blocking I/O for the remote shell <br>
--stats give some file-transfer stats <br>
-8, --8-bit-output leave high-bit chars unescaped in output
<br>
-h, --human-readable output numbers in a human-readable
format <br>
--progress show progress during transfer <br>
-P same as --partial --progress <br>
-i, --itemize-changes output a change-summary for all
updates <br>
--out-format=FORMAT output updates using the specified
FORMAT <br>
--log-file=FILE log what we&rsquo;re doing to the specified
FILE <br>
--log-file-format=FMT log updates using the specified FMT
<br>
--password-file=FILE read daemon-access password from FILE
<br>
--list-only list the files instead of copying them <br>
--bwlimit=KBPS limit I/O bandwidth; KBytes per second <br>
--write-batch=FILE write a batched update to FILE <br>
--only-write-batch=FILE like --write-batch but w/o updating
dest <br>
--read-batch=FILE read a batched update from FILE <br>
--protocol=NUM force an older protocol version to be used
<br>
--iconv=CONVERT_SPEC request charset conversion of filenames
<br>
--checksum-seed=NUM set block/file checksum seed (advanced)
<br>
-4, --ipv4 prefer IPv4 <br>
-6, --ipv6 prefer IPv6 <br>
--version print version number <br>
(-h) --help show this help (see below for -h comment)</p>

<p style="margin-top: 1em">Rsync can also be run as a
daemon, in which case the following options are
accepted:</p>

<p style="margin-top: 1em">--daemon run as an rsync daemon
<br>
--address=ADDRESS bind to the specified address <br>
--bwlimit=KBPS limit I/O bandwidth; KBytes per second <br>
--config=FILE specify alternate rsyncd.conf file <br>
--no-detach do not detach from the parent <br>
--port=PORT listen on alternate port number <br>
--log-file=FILE override the &quot;log file&quot; setting
<br>
--log-file-format=FMT override the &quot;log format&quot;
setting <br>
--sockopts=OPTIONS specify custom TCP options <br>
-v, --verbose increase verbosity <br>
-4, --ipv4 prefer IPv4 <br>
-6, --ipv6 prefer IPv6 <br>
-h, --help show this help (if used after --daemon)</p>

<p style="margin-top: 1em">OPTIONS <br>
Rsync accepts both long (double-dash + word) and short
(single-dash + letter) options. The full list of the
available options are described below. If an option can be
specified <br>
in more than one way, the choices are comma-separated. Some
options only have a long variant, not a short. If the option
takes a parameter, the parameter is only listed after <br>
the long variant, even though it must also be specified for
the short. When specifying a parameter, you can either use
the form --option=param or replace the &acirc;=&acirc; with
white&acirc; <br>
space. The parameter may need to be quoted in some manner
for it to survive the shell&acirc;s command-line parsing.
Keep in mind that a leading tilde (~) in a filename is
substituted <br>
by your shell, so --option=~/foo will not change the tilde
into your home directory (remove the &acirc;=&acirc; for
that).</p>

<p style="margin-top: 1em">--help Print a short help page
describing the options available in rsync and exit. For
backward-compatibility with older versions of rsync, the
help will also be output if you <br>
use the -h option without any other args.</p>

<p style="margin-top: 1em">--version <br>
print the rsync version number and exit.</p>

<p style="margin-top: 1em">-v, --verbose <br>
This option increases the amount of information you are
given during the transfer. By default, rsync works silently.
A single -v will give you information about what <br>
files are being transferred and a brief summary at the end.
Two -v options will give you information on what files are
being skipped and slightly more information at the <br>
end. More than two -v options should only be used if you are
debugging rsync.</p>

<p style="margin-top: 1em">Note that the names of the
transferred files that are output are done using a default
--out-format of &quot;%n%L&quot;, which tells you just the
name of the file and, if the item is <br>
a link, where it points. At the single -v level of
verbosity, this does not mention when a file gets its
attributes changed. If you ask for an itemized list of
changed <br>
attributes (either --itemize-changes or adding
&quot;%i&quot; to the --out-format setting), the output (on
the client) increases to mention all items that are changed
in any way. <br>
See the --out-format option for more details.</p>

<p style="margin-top: 1em">-q, --quiet <br>
This option decreases the amount of information you are
given during the transfer, notably suppressing information
messages from the remote server. This option is useful <br>
when invoking rsync from cron.</p>

<p style="margin-top: 1em">--no-motd <br>
This option affects the information that is output by the
client at the start of a daemon transfer. This suppresses
the message-of-the-day (MOTD) text, but it also <br>
affects the list of modules that the daemon sends in
response to the &quot;rsync host::&quot; request (due to a
limitation in the rsync protocol), so omit this option if
you want to <br>
request the list of modules from the daemon.</p>

<p style="margin-top: 1em">-I, --ignore-times <br>
Normally rsync will skip any files that are already the same
size and have the same modification timestamp. This option
turns off this &quot;quick check&quot; behavior, causing all
<br>
files to be updated.</p>

<p style="margin-top: 1em">--size-only <br>
This modifies rsync&acirc;s &quot;quick check&quot;
algorithm for finding files that need to be transferred,
changing it from the default of transferring files with
either a changed size <br>
or a changed last-modified time to just looking for files
that have changed in size. This is useful when starting to
use rsync after using another mirroring system which <br>
may not preserve timestamps exactly.</p>

<p style="margin-top: 1em">--modify-window <br>
When comparing two timestamps, rsync treats the timestamps
as being equal if they differ by no more than the
modify-window value. This is normally 0 (for an exact
match), <br>
but you may find it useful to set this to a larger value in
some situations. In particular, when transferring to or from
an MS Windows FAT filesystem (which represents <br>
times with a 2-second resolution), --modify-window=1 is
useful (allowing times to differ by up to 1 second).</p>

<p style="margin-top: 1em">-c, --checksum <br>
This changes the way rsync checks if the files have been
changed and are in need of a transfer. Without this option,
rsync uses a &quot;quick check&quot; that (by default)
checks <br>
if each file&acirc;s size and time of last modification
match between the sender and receiver. This option changes
this to compare a 128-bit checksum for each file that has a
<br>
matching size. Generating the checksums means that both
sides will expend a lot of disk I/O reading all the data in
the files in the transfer (and this is prior to any <br>
reading that will be done to transfer changed files), so
this can slow things down significantly.</p>

<p style="margin-top: 1em">The sending side generates its
checksums while it is doing the file-system scan that builds
the list of the available files. The receiver generates its
checksums when it <br>
is scanning for changed files, and will checksum any file
that has the same size as the corresponding sender&acirc;s
file: files with either a changed size or a changed
check&acirc; <br>
sum are selected for transfer.</p>

<p style="margin-top: 1em">Note that rsync always verifies
that each transferred file was correctly reconstructed on
the receiving side by checking a whole-file checksum that is
generated as the <br>
file is transferred, but that automatic after-the-transfer
verification has nothing to do with this option&acirc;s
before-the-transfer &quot;Does this file need to be
updated?&quot; <br>
check.</p>

<p style="margin-top: 1em">For protocol 30 and beyond
(first supported in 3.0.0), the checksum used is MD5. For
older protocols, the checksum used is MD4.</p>

<p style="margin-top: 1em">-a, --archive <br>
This is equivalent to -rlptgoD. It is a quick way of saying
you want recursion and want to preserve almost everything
(with -H being a notable omission). The only excep&acirc;
<br>
tion to the above equivalence is when --files-from is
specified, in which case -r is not implied.</p>

<p style="margin-top: 1em">Note that -a does not preserve
hardlinks, because finding multiply-linked files is
expensive. You must separately specify -H.</p>

<p style="margin-top: 1em">--no-OPTION <br>
You may turn off one or more implied options by prefixing
the option name with &quot;no-&quot;. Not all options may be
prefixed with a &quot;no-&quot;: only options that are
implied by other <br>
options (e.g. --no-D, --no-perms) or have different defaults
in various circumstances (e.g. --no-whole-file,
--no-blocking-io, --no-dirs). You may specify either the
<br>
short or the long option name after the &quot;no-&quot;
prefix (e.g. --no-R is the same as --no-relative).</p>

<p style="margin-top: 1em">For example: if you want to use
-a (--archive) but don&acirc;t want -o (--owner), instead of
converting -a into -rlptgD, you could specify -a --no-o (or
-a --no-owner).</p>

<p style="margin-top: 1em">The order of the options is
important: if you specify --no-r -a, the -r option would end
up being turned on, the opposite of -a --no-r. Note also
that the side-effects <br>
of the --files-from option are NOT positional, as it affects
the default state of several options and slightly changes
the meaning of -a (see the --files-from option for <br>
more details).</p>

<p style="margin-top: 1em">-r, --recursive <br>
This tells rsync to copy directories recursively. See also
--dirs (-d).</p>

<p style="margin-top: 1em">Beginning with rsync 3.0.0, the
recursive algorithm used is now an incremental scan that
uses much less memory than before and begins the transfer
after the scanning of <br>
the first few directories have been completed. This
incremental scan only affects our recursion algorithm, and
does not change a non-recursive transfer. It is also only
<br>
possible when both ends of the transfer are at least version
3.0.0.</p>

<p style="margin-top: 1em">Some options require rsync to
know the full file list, so these options disable the
incremental recursion mode. These include: --delete-before,
--delete-after, <br>
--prune-empty-dirs, and --delay-updates. Because of this,
the default delete mode when you specify --delete is now
--delete-during when both ends of the connection are at <br>
least 3.0.0 (use --del or --delete-during to request this
improved deletion mode explicitly). See also the
--delete-delay option that is a better choice than using
<br>
--delete-after.</p>

<p style="margin-top: 1em">Incremental recursion can be
disabled using the --no-inc-recursive option or its shorter
--no-i-r alias.</p>

<p style="margin-top: 1em">-R, --relative <br>
Use relative paths. This means that the full path names
specified on the command line are sent to the server rather
than just the last parts of the filenames. This is
par&acirc; <br>
ticularly useful when you want to send several different
directories at the same time. For example, if you used this
command:</p>

<p style="margin-top: 1em">rsync -av /foo/bar/baz.c
remote:/tmp/</p>

<p style="margin-top: 1em">... this would create a file
named baz.c in /tmp/ on the remote machine. If instead you
used</p>

<p style="margin-top: 1em">rsync -avR /foo/bar/baz.c
remote:/tmp/</p>

<p style="margin-top: 1em">then a file named
/tmp/foo/bar/baz.c would be created on the remote machine,
preserving its full path. These extra path elements are
called &quot;implied directories&quot; (i.e. <br>
the &quot;foo&quot; and the &quot;foo/bar&quot; directories
in the above example).</p>

<p style="margin-top: 1em">Beginning with rsync 3.0.0,
rsync always sends these implied directories as real
directories in the file list, even if a path element is
really a symlink on the sending <br>
side. This prevents some really unexpected behaviors when
copying the full path of a file that you didn&acirc;t
realize had a symlink in its path. If you want to duplicate
a <br>
server-side symlink, include both the symlink via its path,
and referent directory via its real path. If you&acirc;re
dealing with an older rsync on the sending side, you may
<br>
need to use the --no-implied-dirs option.</p>

<p style="margin-top: 1em">It is also possible to limit the
amount of path information that is sent as implied
directories for each path you specify. With a modern rsync
on the sending side (begin&acirc; <br>
ning with 2.6.7), you can insert a dot and a slash into the
source path, like this:</p>

<p style="margin-top: 1em">rsync -avR /foo/./bar/baz.c
remote:/tmp/</p>

<p style="margin-top: 1em">That would create /tmp/bar/baz.c
on the remote machine. (Note that the dot must be followed
by a slash, so &quot;/foo/.&quot; would not be abbreviated.)
For older rsync versions, <br>
you would need to use a chdir to limit the source path. For
example, when pushing files:</p>

<p style="margin-top: 1em">(cd /foo; rsync -avR bar/baz.c
remote:/tmp/)</p>

<p style="margin-top: 1em">(Note that the parens put the
two commands into a sub-shell, so that the &quot;cd&quot;
command doesn&acirc;t remain in effect for future commands.)
If you&acirc;re pulling files from an older <br>
rsync, use this idiom (but only for a non-daemon
transfer):</p>

<p style="margin-top: 1em">rsync -avR --rsync-path=&quot;cd
/foo; rsync&quot; remote:bar/baz.c /tmp/</p>

<p style="margin-top: 1em">--no-implied-dirs <br>
This option affects the default behavior of the --relative
option. When it is specified, the attributes of the implied
directories from the source names are not included <br>
in the transfer. This means that the corresponding path
elements on the destination system are left unchanged if
they exist, and any missing implied directories are
cre&acirc; <br>
ated with default attributes. This even allows these implied
path elements to have big differences, such as being a
symlink to a directory on the receiving side.</p>

<p style="margin-top: 1em">For instance, if a command-line
arg or a files-from entry told rsync to transfer the file
&quot;path/foo/file&quot;, the directories &quot;path&quot;
and &quot;path/foo&quot; are implied when --rela&acirc; <br>
tive is used. If &quot;path/foo&quot; is a symlink to
&quot;bar&quot; on the destination system, the receiving
rsync would ordinarily delete &quot;path/foo&quot;, recreate
it as a directory, and <br>
receive the file into the new directory. With
--no-implied-dirs, the receiving rsync updates
&quot;path/foo/file&quot; using the existing path elements,
which means that the file <br>
ends up being created in &quot;path/bar&quot;. Another way
to accomplish this link preservation is to use the
--keep-dirlinks option (which will also affect symlinks to
directories <br>
in the rest of the transfer).</p>

<p style="margin-top: 1em">When pulling files from an rsync
older than 3.0.0, you may need to use this option if the
sending side has a symlink in the path you request and you
wish the implied <br>
directories to be transferred as normal directories.</p>

<p style="margin-top: 1em">-b, --backup <br>
With this option, preexisting destination files are renamed
as each file is transferred or deleted. You can control
where the backup file goes and what (if any) suffix <br>
gets appended using the --backup-dir and --suffix
options.</p>

<p style="margin-top: 1em">Note that if you don&acirc;t
specify --backup-dir, (1) the --omit-dir-times option will
be implied, and (2) if --delete is also in effect (without
--delete-excluded), rsync will <br>
add a &quot;protect&quot; filter-rule for the backup suffix
to the end of all your existing excludes (e.g. -f &quot;P
*~&quot;). This will prevent previously backed-up files from
being <br>
deleted. Note that if you are supplying your own filter
rules, you may need to manually insert your own
exclude/protect rule somewhere higher up in the list so that
it <br>
has a high enough priority to be effective (e.g., if your
rules specify a trailing inclusion/exclusion of
&acirc;*&acirc;, the auto-added rule would never be
reached).</p>

<p style="margin-top: 1em">--backup-dir=DIR <br>
In combination with the --backup option, this tells rsync to
store all backups in the specified directory on the
receiving side. This can be used for incremental backups.
<br>
You can additionally specify a backup suffix using the
--suffix option (otherwise the files backed up in the
specified directory will keep their original filenames).</p>

<p style="margin-top: 1em">Note that if you specify a
relative path, the backup directory will be relative to the
destination directory, so you probably want to specify
either an absolute path or a <br>
path that starts with &quot;../&quot;. If an rsync daemon is
the receiver, the backup dir cannot go outside the
module&acirc;s path hierarchy, so take extra care not to
delete it or copy <br>
into it.</p>

<p style="margin-top: 1em">--suffix=SUFFIX <br>
This option allows you to override the default backup suffix
used with the --backup (-b) option. The default suffix is a
~ if no --backup-dir was specified, otherwise it <br>
is an empty string.</p>

<p style="margin-top: 1em">-u, --update <br>
This forces rsync to skip any files which exist on the
destination and have a modified time that is newer than the
source file. (If an existing destination file has a <br>
modification time equal to the source file&acirc;s, it will
be updated if the sizes are different.)</p>

<p style="margin-top: 1em">Note that this does not affect
the copying of symlinks or other special files. Also, a
difference of file format between the sender and receiver is
always considered to <br>
be important enough for an update, no matter what date is on
the objects. In other words, if the source has a directory
where the destination has a file, the transfer <br>
would occur regardless of the timestamps.</p>

<p style="margin-top: 1em">This option is a transfer rule,
not an exclude, so it doesn&acirc;t affect the data that
goes into the file-lists, and thus it doesn&acirc;t affect
deletions. It just limits the <br>
files that the receiver requests to be transferred.</p>

<p style="margin-top: 1em">--inplace <br>
This option changes how rsync transfers a file when its data
needs to be updated: instead of the default method of
creating a new copy of the file and moving it into place
<br>
when it is complete, rsync instead writes the updated data
directly to the destination file.</p>

<p style="margin-top: 1em">This has several effects:</p>

<p style="margin-top: 1em">o Hard links are not broken.
This means the new data will be visible through other hard
links to the destination file. Moreover, attempts to copy
differing source <br>
files onto a multiply-linked destination file will result in
a &quot;tug of war&quot; with the destination data changing
back and forth.</p>

<p style="margin-top: 1em">o In-use binaries cannot be
updated (either the OS will prevent this from happening, or
binaries that attempt to swap-in their data will misbehave
or crash).</p>

<p style="margin-top: 1em">o The file&acirc;s data will be
in an inconsistent state during the transfer and will be
left that way if the transfer is interrupted or if an update
fails.</p>

<p style="margin-top: 1em">o A file that rsync cannot write
to cannot be updated. While a super user can update any
file, a normal user needs to be granted write permission for
the open of the <br>
file for writing to be successful.</p>

<p style="margin-top: 1em">o The efficiency of
rsync&acirc;s delta-transfer algorithm may be reduced if
some data in the destination file is overwritten before it
can be copied to a position later in <br>
the file. This does not apply if you use --backup, since
rsync is smart enough to use the backup file as the basis
file for the transfer.</p>

<p style="margin-top: 1em">WARNING: you should not use this
option to update files that are being accessed by others, so
be careful when choosing to use this for a copy.</p>

<p style="margin-top: 1em">This option is useful for
transferring large files with block-based changes or
appended data, and also on systems that are disk bound, not
network bound. It can also help <br>
keep a copy-on-write filesystem snapshot from diverging the
entire contents of a file that only has minor changes.</p>

<p style="margin-top: 1em">The option implies --partial
(since an interrupted transfer does not delete the file),
but conflicts with --partial-dir and --delay-updates. Prior
to rsync 2.6.4 <br>
--inplace was also incompatible with --compare-dest and
--link-dest.</p>

<p style="margin-top: 1em">--append <br>
This causes rsync to update a file by appending data onto
the end of the file, which presumes that the data that
already exists on the receiving side is identical with the
<br>
start of the file on the sending side. If a file needs to be
transferred and its size on the receiver is the same or
longer than the size on the sender, the file is <br>
skipped. This does not interfere with the updating of a
file&acirc;s non-content attributes (e.g. permissions,
ownership, etc.) when the file does not need to be
transferred, <br>
nor does it affect the updating of any non-regular files.
Implies --inplace, but does not conflict with --sparse
(since it is always extending a file&acirc;s length).</p>

<p style="margin-top: 1em">--append-verify <br>
This works just like the --append option, but the existing
data on the receiving side is included in the full-file
checksum verification step, which will cause a file to <br>
be resent if the final verification step fails (rsync uses a
normal, non-appending --inplace transfer for the
resend).</p>

<p style="margin-top: 1em">Note: prior to rsync 3.0.0, the
--append option worked like --append-verify, so if you are
interacting with an older rsync (or the transfer is using a
protocol prior to <br>
30), specifying either append option will initiate an
--append-verify transfer.</p>

<p style="margin-top: 1em">-d, --dirs <br>
Tell the sending side to include any directories that are
encountered. Unlike --recursive, a directory&acirc;s
contents are not copied unless the directory name specified
is <br>
&quot;.&quot; or ends with a trailing slash (e.g.
&quot;.&quot;, &quot;dir/.&quot;, &quot;dir/&quot;, etc.).
Without this option or the --recursive option, rsync will
skip all directories it encounters (and <br>
output a message to that effect for each one). If you
specify both --dirs and --recursive, --recursive takes
precedence.</p>

<p style="margin-top: 1em">The --dirs option is implied by
the --files-from option or the --list-only option (including
an implied --list-only usage) if --recursive wasn&acirc;t
specified (so that direc&acirc; <br>
tories are seen in the listing). Specify --no-dirs (or
--no-d) if you want to turn this off.</p>

<p style="margin-top: 1em">There is also a
backward-compatibility helper option, --old-dirs (or
--old-d) that tells rsync to use a hack of &quot;-r
--exclude=&acirc;/*/*&acirc;&quot; to get an older rsync to
list a sin&acirc; <br>
gle directory without recursing.</p>

<p style="margin-top: 1em">-l, --links <br>
When symlinks are encountered, recreate the symlink on the
destination.</p>

<p style="margin-top: 1em">-L, --copy-links <br>
When symlinks are encountered, the item that they point to
(the referent) is copied, rather than the symlink. In older
versions of rsync, this option also had the <br>
side-effect of telling the receiving side to follow
symlinks, such as symlinks to directories. In a modern rsync
such as this one, you&acirc;ll need to specify
--keep-dirlinks <br>
(-K) to get this extra behavior. The only exception is when
sending files to an rsync that is too old to understand -K
-- in that case, the -L option will still have the <br>
side-effect of -K on that older receiving rsync.</p>

<p style="margin-top: 1em">--copy-unsafe-links <br>
This tells rsync to copy the referent of symbolic links that
point outside the copied tree. Absolute symlinks are also
treated like ordinary files, and so are any sym&acirc; <br>
links in the source path itself when --relative is used.
This option has no additional effect if --copy-links was
also specified.</p>

<p style="margin-top: 1em">--safe-links <br>
This tells rsync to ignore any symbolic links which point
outside the copied tree. All absolute symlinks are also
ignored. Using this option in conjunction with --relative
<br>
may give unexpected results.</p>

<p style="margin-top: 1em">-k, --copy-dirlinks <br>
This option causes the sending side to treat a symlink to a
directory as though it were a real directory. This is useful
if you don&acirc;t want symlinks to non-directories to <br>
be affected, as they would be using --copy-links.</p>

<p style="margin-top: 1em">Without this option, if the
sending side has replaced a directory with a symlink to a
directory, the receiving side will delete anything that is
in the way of the new sym&acirc; <br>
link, including a directory hierarchy (as long as --force or
--delete is in effect).</p>

<p style="margin-top: 1em">See also --keep-dirlinks for an
analogous option for the receiving side.</p>

<p style="margin-top: 1em">--copy-dirlinks applies to all
symlinks to directories in the source. If you want to follow
only a few specified symlinks, a trick you can use is to
pass them as addi&acirc; <br>
tional source args with a trailing slash, using --relative
to make the paths match up right. For example:</p>

<p style="margin-top: 1em">rsync -r --relative src/./
src/./follow-me/ dest/</p>

<p style="margin-top: 1em">This works because rsync calls
lstat(2) on the source arg as given, and the trailing slash
makes lstat(2) follow the symlink, giving rise to a
directory in the file-list <br>
which overrides the symlink found during the scan of
&quot;src/./&quot;.</p>

<p style="margin-top: 1em">-K, --keep-dirlinks <br>
This option causes the receiving side to treat a symlink to
a directory as though it were a real directory, but only if
it matches a real directory from the sender. With&acirc;
<br>
out this option, the receiver&acirc;s symlink would be
deleted and replaced with a real directory.</p>

<p style="margin-top: 1em">For example, suppose you
transfer a directory &quot;foo&quot; that contains a file
&quot;file&quot;, but &quot;foo&quot; is a symlink to
directory &quot;bar&quot; on the receiver. Without
--keep-dirlinks, the <br>
receiver deletes symlink &quot;foo&quot;, recreates it as a
directory, and receives the file into the new directory.
With --keep-dirlinks, the receiver keeps the symlink and
&quot;file&quot; <br>
ends up in &quot;bar&quot;.</p>

<p style="margin-top: 1em">One note of caution: if you use
--keep-dirlinks, you must trust all the symlinks in the
copy! If it is possible for an untrusted user to create
their own symlink to any <br>
directory, the user could then (on a subsequent copy)
replace the symlink with a real directory and affect the
content of whatever directory the symlink references. For
<br>
backup copies, you are better off using something like a
bind mount instead of a symlink to modify your receiving
hierarchy.</p>

<p style="margin-top: 1em">See also --copy-dirlinks for an
analogous option for the sending side.</p>

<p style="margin-top: 1em">-H, --hard-links <br>
This tells rsync to look for hard-linked files in the source
and link together the corresponding files on the
destination. Without this option, hard-linked files in the
<br>
source are treated as though they were separate files.</p>

<p style="margin-top: 1em">This option does NOT necessarily
ensure that the pattern of hard links on the destination
exactly matches that on the source. Cases in which the
destination may end up <br>
with extra hard links include the following:</p>

<p style="margin-top: 1em">o If the destination contains
extraneous hard-links (more linking than what is present in
the source file list), the copying algorithm will not break
them explicitly. <br>
However, if one or more of the paths have content
differences, the normal file-update process will break those
extra links (unless you are using the --inplace <br>
option).</p>

<p style="margin-top: 1em">o If you specify a --link-dest
directory that contains hard links, the linking of the
destination files against the --link-dest files can cause
some paths in the des&acirc; <br>
tination to become linked together due to the --link-dest
associations.</p>

<p style="margin-top: 1em">Note that rsync can only detect
hard links between files that are inside the transfer set.
If rsync updates a file that has extra hard-link connections
to files outside <br>
the transfer, that linkage will be broken. If you are
tempted to use the --inplace option to avoid this breakage,
be very careful that you know how your files are being <br>
updated so that you are certain that no unintended changes
happen due to lingering hard links (and see the --inplace
option for more caveats).</p>

<p style="margin-top: 1em">If incremental recursion is
active (see --recursive), rsync may transfer a missing
hard-linked file before it finds that another link for that
contents exists elsewhere in <br>
the hierarchy. This does not affect the accuracy of the
transfer (i.e. which files are hard-linked together), just
its efficiency (i.e. copying the data for a new, early <br>
copy of a hard-linked file that could have been found later
in the transfer in another member of the hard-linked set of
files). One way to avoid this inefficiency is to <br>
disable incremental recursion using the --no-inc-recursive
option.</p>

<p style="margin-top: 1em">-p, --perms <br>
This option causes the receiving rsync to set the
destination permissions to be the same as the source
permissions. (See also the --chmod option for a way to
modify what <br>
rsync considers to be the source permissions.)</p>

<p style="margin-top: 1em">When this option is off,
permissions are set as follows:</p>

<p style="margin-top: 1em">o Existing files (including
updated files) retain their existing permissions, though the
--executability option might change just the execute
permission for the file.</p>

<p style="margin-top: 1em">o New files get their
&quot;normal&quot; permission bits set to the source
file&acirc;s permissions masked with the receiving
directory&acirc;s default permissions (either the receiving
<br>
process&acirc;s umask, or the permissions specified via the
destination directory&acirc;s default ACL), and their
special permission bits disabled except in the case where a
<br>
new directory inherits a setgid bit from its parent
directory.</p>

<p style="margin-top: 1em">Thus, when --perms and
--executability are both disabled, rsync&acirc;s behavior is
the same as that of other file-copy utilities, such as cp(1)
and tar(1).</p>

<p style="margin-top: 1em">In summary: to give destination
files (both old and new) the source permissions, use
--perms. To give new files the destination-default
permissions (while leaving exist&acirc; <br>
ing files unchanged), make sure that the --perms option is
off and use --chmod=ugo=rwX (which ensures that all
non-masked bits get enabled). If you&acirc;d care to make
this <br>
latter behavior easier to type, you could define a popt
alias for it, such as putting this line in the file ~/.popt
(the following defines the -Z option, and includes <br>
--no-g to use the default group of the destination dir):</p>

<p style="margin-top: 1em">rsync alias -Z --no-p --no-g
--chmod=ugo=rwX</p>

<p style="margin-top: 1em">You could then use this new
option in a command such as this one:</p>

<p style="margin-top: 1em">rsync -avZ src/ dest/</p>

<p style="margin-top: 1em">(Caveat: make sure that -a does
not follow -Z, or it will re-enable the two
&quot;--no-*&quot; options mentioned above.)</p>

<p style="margin-top: 1em">The preservation of the
destination&acirc;s setgid bit on newly-created directories
when --perms is off was added in rsync 2.6.7. Older rsync
versions erroneously preserved the <br>
three special permission bits for newly-created files when
--perms was off, while overriding the destination&acirc;s
setgid bit setting on a newly-created directory. Default
<br>
ACL observance was added to the ACL patch for rsync 2.6.7,
so older (or non-ACL-enabled) rsyncs use the umask even if
default ACLs are present. (Keep in mind that it is <br>
the version of the receiving rsync that affects these
behaviors.)</p>

<p style="margin-top: 1em">-E, --executability <br>
This option causes rsync to preserve the executability (or
non-executability) of regular files when --perms is not
enabled. A regular file is considered to be executable <br>
if at least one &acirc;x&acirc; is turned on in its
permissions. When an existing destination file&acirc;s
executability differs from that of the corresponding source
file, rsync modifies <br>
the destination file&acirc;s permissions as follows:</p>

<p style="margin-top: 1em">o To make a file non-executable,
rsync turns off all its &acirc;x&acirc; permissions.</p>

<p style="margin-top: 1em">o To make a file executable,
rsync turns on each &acirc;x&acirc; permission that has a
corresponding &acirc;r&acirc; permission enabled.</p>

<p style="margin-top: 1em">If --perms is enabled, this
option is ignored.</p>

<p style="margin-top: 1em">-A, --acls <br>
This option causes rsync to update the destination ACLs to
be the same as the source ACLs. The option also implies
--perms.</p>

<p style="margin-top: 1em">The source and destination
systems must have compatible ACL entries for this option to
work properly. See the --fake-super option for a way to
backup and restore ACLs <br>
that are not compatible.</p>

<p style="margin-top: 1em">-X, --xattrs <br>
This option causes rsync to update the destination extended
attributes to be the same as the source ones.</p>

<p style="margin-top: 1em">For systems that support
extended-attribute namespaces, a copy being done by a
super-user copies all namespaces except system.*. A normal
user only copies the user.* <br>
namespace. To be able to backup and restore non-user
namespaces as a normal user, see the --fake-super
option.</p>

<p style="margin-top: 1em">Note that this option does not
copy rsyncs special xattr values (e.g. those used by
--fake-super) unless you repeat the option (e.g. -XX). This
&quot;copy all xattrs&quot; mode <br>
cannot be used with --fake-super.</p>

<p style="margin-top: 1em">--chmod <br>
This option tells rsync to apply one or more comma-separated
&quot;chmod&quot; modes to the permission of the files in
the transfer. The resulting value is treated as though it
<br>
were the permissions that the sending side supplied for the
file, which means that this option can seem to have no
effect on existing files if --perms is not enabled.</p>

<p style="margin-top: 1em">In addition to the normal
parsing rules specified in the chmod(1) manpage, you can
specify an item that should only apply to a directory by
prefixing it with a &acirc;D&acirc;, or <br>
specify an item that should only apply to a file by
prefixing it with a &acirc;F&acirc;. For example, the
following will ensure that all directories get marked
set-gid, that no files <br>
are other-writable, that both are user-writable and
group-writable, and that both have consistent executability
across all bits:</p>

<p style="margin-top: 1em">--chmod=Dg+s,ug+w,Fo-w,+X</p>

<p style="margin-top: 1em">It is also legal to specify
multiple --chmod options, as each additional option is just
appended to the list of changes to make.</p>

<p style="margin-top: 1em">See the --perms and
--executability options for how the resulting permission
value can be applied to the files in the transfer.</p>

<p style="margin-top: 1em">-o, --owner <br>
This option causes rsync to set the owner of the destination
file to be the same as the source file, but only if the
receiving rsync is being run as the super-user (see <br>
also the --super and --fake-super options). Without this
option, the owner of new and/or transferred files are set to
the invoking user on the receiving side.</p>

<p style="margin-top: 1em">The preservation of ownership
will associate matching names by default, but may fall back
to using the ID number in some circumstances (see also the
--numeric-ids option <br>
for a full discussion).</p>

<p style="margin-top: 1em">-g, --group <br>
This option causes rsync to set the group of the destination
file to be the same as the source file. If the receiving
program is not running as the super-user (or if <br>
--no-super was specified), only groups that the invoking
user on the receiving side is a member of will be preserved.
Without this option, the group is set to the default <br>
group of the invoking user on the receiving side.</p>

<p style="margin-top: 1em">The preservation of group
information will associate matching names by default, but
may fall back to using the ID number in some circumstances
(see also the --numeric-ids <br>
option for a full discussion).</p>

<p style="margin-top: 1em">--devices <br>
This option causes rsync to transfer character and block
device files to the remote system to recreate these devices.
This option has no effect if the receiving rsync is <br>
not run as the super-user (see also the --super and
--fake-super options).</p>

<p style="margin-top: 1em">--specials <br>
This option causes rsync to transfer special files such as
named sockets and fifos.</p>

<p style="margin-top: 1em">-D The -D option is equivalent
to --devices --specials.</p>

<p style="margin-top: 1em">-t, --times <br>
This tells rsync to transfer modification times along with
the files and update them on the remote system. Note that if
this option is not used, the optimization that <br>
excludes files that have not been modified cannot be
effective; in other words, a missing -t or -a will cause the
next transfer to behave as if it used -I, causing all <br>
files to be updated (though rsync&acirc;s delta-transfer
algorithm will make the update fairly efficient if the files
haven&acirc;t actually changed, you&acirc;re much better off
using -t).</p>

<p style="margin-top: 1em">-O, --omit-dir-times <br>
This tells rsync to omit directories when it is preserving
modification times (see --times). If NFS is sharing the
directories on the receiving side, it is a good idea to <br>
use -O. This option is inferred if you use --backup without
--backup-dir.</p>

<p style="margin-top: 1em">--super <br>
This tells the receiving side to attempt super-user
activities even if the receiving rsync wasn&acirc;t run by
the super-user. These activities include: preserving users
via <br>
the --owner option, preserving all groups (not just the
current user&acirc;s groups) via the --groups option, and
copying devices via the --devices option. This is useful for
<br>
systems that allow such activities without being the
super-user, and also for ensuring that you will get errors
if the receiving side isn&acirc;t being run as the
super-user. <br>
To turn off super-user activities, the super-user can use
--no-super.</p>

<p style="margin-top: 1em">--fake-super <br>
When this option is enabled, rsync simulates super-user
activities by saving/restoring the privileged attributes via
special extended attributes that are attached to each <br>
file (as needed). This includes the file&acirc;s owner and
group (if it is not the default), the file&acirc;s device
info (device &amp; special files are created as empty text
files), <br>
and any permission bits that we won&acirc;t allow to be set
on the real file (e.g. the real file gets u-s,g-s,o-t for
safety) or that would limit the owner&acirc;s access (since
the <br>
real super-user can always access/change a file, the files
we create can always be accessed/changed by the creating
user). This option also handles ACLs (if --acls was <br>
specified) and non-user extended attributes (if --xattrs was
specified).</p>

<p style="margin-top: 1em">This is a good way to backup
data without using a super-user, and to store ACLs from
incompatible systems.</p>

<p style="margin-top: 1em">The --fake-super option only
affects the side where the option is used. To affect the
remote side of a remote-shell connection, specify an rsync
path:</p>

<p style="margin-top: 1em">rsync -av
--rsync-path=&quot;rsync --fake-super&quot; /src/
host:/dest/</p>

<p style="margin-top: 1em">Since there is only one
&quot;side&quot; in a local copy, this option affects both
the sending and receiving of files. You&acirc;ll need to
specify a copy using &quot;localhost&quot; if you need <br>
to avoid this, possibly using the &quot;lsh&quot; shell
script (from the support directory) as a substitute for an
actual remote shell (see --rsh).</p>

<p style="margin-top: 1em">This option is overridden by
both --super and --no-super.</p>

<p style="margin-top: 1em">See also the &quot;fake
super&quot; setting in the daemon&acirc;s rsyncd.conf
file.</p>

<p style="margin-top: 1em">-S, --sparse <br>
Try to handle sparse files efficiently so they take up less
space on the destination. Conflicts with --inplace because
it&acirc;s not possible to overwrite data in a sparse <br>
fashion.</p>

<p style="margin-top: 1em">-n, --dry-run <br>
This makes rsync perform a trial run that doesn&acirc;t make
any changes (and produces mostly the same output as a real
run). It is most commonly used in combination with the <br>
-v, --verbose and/or -i, --itemize-changes options to see
what an rsync command is going to do before one actually
runs it.</p>

<p style="margin-top: 1em">The output of --itemize-changes
is supposed to be exactly the same on a dry run and a
subsequent real run (barring intentional trickery and system
call failures); if it <br>
isn&acirc;t, that&acirc;s a bug. Other output should be
mostly unchanged, but may differ in some areas. Notably, a
dry run does not send the actual data for file transfers, so
<br>
--progress has no effect, the &quot;bytes sent&quot;,
&quot;bytes received&quot;, &quot;literal data&quot;, and
&quot;matched data&quot; statistics are too small, and the
&quot;speedup&quot; value is equivalent to a run <br>
where no file transfers were needed.</p>

<p style="margin-top: 1em">-W, --whole-file <br>
With this option rsync&acirc;s delta-transfer algorithm is
not used and the whole file is sent as-is instead. The
transfer may be faster if this option is used when the
band&acirc; <br>
width between the source and destination machines is higher
than the bandwidth to disk (especially when the
&quot;disk&quot; is actually a networked filesystem). This
is the <br>
default when both the source and destination are specified
as local paths, but only if no batch-writing option is in
effect.</p>

<p style="margin-top: 1em">-x, --one-file-system <br>
This tells rsync to avoid crossing a filesystem boundary
when recursing. This does not limit the user&acirc;s ability
to specify items to copy from multiple filesystems, just
<br>
rsync&acirc;s recursion through the hierarchy of each
directory that the user specified, and also the analogous
recursion on the receiving side during deletion. Also keep
in <br>
mind that rsync treats a &quot;bind&quot; mount to the same
device as being on the same filesystem.</p>

<p style="margin-top: 1em">If this option is repeated,
rsync omits all mount-point directories from the copy.
Otherwise, it includes an empty directory at each
mount-point it encounters (using the <br>
attributes of the mounted directory because those of the
underlying mount-point directory are inaccessible).</p>

<p style="margin-top: 1em">If rsync has been told to
collapse symlinks (via --copy-links or --copy-unsafe-links),
a symlink to a directory on another device is treated like a
mount-point. Symlinks <br>
to non-directories are unaffected by this option.</p>

<p style="margin-top: 1em">--existing,
--ignore-non-existing <br>
This tells rsync to skip creating files (including
directories) that do not exist yet on the destination. If
this option is combined with the --ignore-existing option,
no <br>
files will be updated (which can be useful if all you want
to do is delete extraneous files).</p>

<p style="margin-top: 1em">This option is a transfer rule,
not an exclude, so it doesn&acirc;t affect the data that
goes into the file-lists, and thus it doesn&acirc;t affect
deletions. It just limits the <br>
files that the receiver requests to be transferred.</p>

<p style="margin-top: 1em">--ignore-existing <br>
This tells rsync to skip updating files that already exist
on the destination (this does not ignore existing
directories, or nothing would get done). See also
--existing.</p>

<p style="margin-top: 1em">This option is a transfer rule,
not an exclude, so it doesn&acirc;t affect the data that
goes into the file-lists, and thus it doesn&acirc;t affect
deletions. It just limits the <br>
files that the receiver requests to be transferred.</p>

<p style="margin-top: 1em">This option can be useful for
those doing backups using the --link-dest option when they
need to continue a backup run that got interrupted. Since a
--link-dest run is <br>
copied into a new directory hierarchy (when it is used
properly), using --ignore existing will ensure that the
already-handled files don&acirc;t get tweaked (which avoids
a <br>
change in permissions on the hard-linked files). This does
mean that this option is only looking at the existing files
in the destination hierarchy itself.</p>

<p style="margin-top: 1em">--remove-source-files <br>
This tells rsync to remove from the sending side the files
(meaning non-directories) that are a part of the transfer
and have been successfully duplicated on the receiving <br>
side.</p>

<p style="margin-top: 1em">Note that you should only use
this option on source files that are quiescent. If you are
using this to move files that show up in a particular
directory over to another <br>
host, make sure that the finished files get renamed into the
source directory, not directly written into it, so that
rsync can&acirc;t possibly transfer a file that is not yet
<br>
fully written. If you can&acirc;t first write the files into
a different directory, you should use a naming idiom that
lets rsync avoid transferring files that are not yet
fin&acirc; <br>
ished (e.g. name the file &quot;foo.new&quot; when it is
written, rename it to &quot;foo&quot; when it is done, and
then use the option --exclude=&rsquo;*.new&rsquo; for the
rsync transfer).</p>

<p style="margin-top: 1em">--delete <br>
This tells rsync to delete extraneous files from the
receiving side (ones that aren&acirc;t on the sending side),
but only for the directories that are being synchronized.
You <br>
must have asked rsync to send the whole directory (e.g.
&quot;dir&quot; or &quot;dir/&quot;) without using a
wildcard for the directory&acirc;s contents (e.g.
&quot;dir/*&quot;) since the wildcard is <br>
expanded by the shell and rsync thus gets a request to
transfer individual files, not the files&acirc; parent
directory. Files that are excluded from the transfer are
also <br>
excluded from being deleted unless you use the
--delete-excluded option or mark the rules as only matching
on the sending side (see the include/exclude modifiers in
the <br>
FILTER RULES section).</p>

<p style="margin-top: 1em">Prior to rsync 2.6.7, this
option would have no effect unless --recursive was enabled.
Beginning with 2.6.7, deletions will also occur when --dirs
(-d) is enabled, but <br>
only for directories whose contents are being copied.</p>

<p style="margin-top: 1em">This option can be dangerous if
used incorrectly! It is a very good idea to first try a run
using the --dry-run option (-n) to see what files are going
to be deleted.</p>

<p style="margin-top: 1em">If the sending side detects any
I/O errors, then the deletion of any files at the
destination will be automatically disabled. This is to
prevent temporary filesystem fail&acirc; <br>
ures (such as NFS errors) on the sending side from causing a
massive deletion of files on the destination. You can
override this with the --ignore-errors option.</p>

<p style="margin-top: 1em">The --delete option may be
combined with one of the --delete-WHEN options without
conflict, as well as --delete-excluded. However, if none of
the --delete-WHEN options <br>
are specified, rsync will choose the --delete-during
algorithm when talking to rsync 3.0.0 or newer, and the
--delete-before algorithm when talking to an older rsync.
See <br>
also --delete-delay and --delete-after.</p>

<p style="margin-top: 1em">--delete-before <br>
Request that the file-deletions on the receiving side be
done before the transfer starts. See --delete (which is
implied) for more details on file-deletion.</p>

<p style="margin-top: 1em">Deleting before the transfer is
helpful if the filesystem is tight for space and removing
extraneous files would help to make the transfer possible.
However, it does <br>
introduce a delay before the start of the transfer, and this
delay might cause the transfer to timeout (if --timeout was
specified). It also forces rsync to use the old, <br>
non-incremental recursion algorithm that requires rsync to
scan all the files in the transfer into memory at once (see
--recursive).</p>

<p style="margin-top: 1em">--delete-during, --del <br>
Request that the file-deletions on the receiving side be
done incrementally as the transfer happens. The
per-directory delete scan is done right before each
directory is <br>
checked for updates, so it behaves like a more efficient
--delete-before, including doing the deletions prior to any
per-directory filter files being updated. This option <br>
was first added in rsync version 2.6.4. See --delete (which
is implied) for more details on file-deletion.</p>

<p style="margin-top: 1em">--delete-delay <br>
Request that the file-deletions on the receiving side be
computed during the transfer (like --delete-during), and
then removed after the transfer completes. This is
use&acirc; <br>
ful when combined with --delay-updates and/or --fuzzy, and
is more efficient than using --delete-after (but can behave
differently, since --delete-after computes the dele&acirc;
<br>
tions in a separate pass after all updates are done). If the
number of removed files overflows an internal buffer, a
temporary file will be created on the receiving side <br>
to hold the names (it is removed while open, so you
shouldn&acirc;t see it during the transfer). If the creation
of the temporary file fails, rsync will try to fall back to
<br>
using --delete-after (which it cannot do if --recursive is
doing an incremental scan). See --delete (which is implied)
for more details on file-deletion.</p>

<p style="margin-top: 1em">--delete-after <br>
Request that the file-deletions on the receiving side be
done after the transfer has completed. This is useful if you
are sending new per-directory merge files as a part <br>
of the transfer and you want their exclusions to take effect
for the delete phase of the current transfer. It also forces
rsync to use the old, non-incremental recursion <br>
algorithm that requires rsync to scan all the files in the
transfer into memory at once (see --recursive). See --delete
(which is implied) for more details on file-dele&acirc; <br>
tion.</p>

<p style="margin-top: 1em">--delete-excluded <br>
In addition to deleting the files on the receiving side that
are not on the sending side, this tells rsync to also delete
any files on the receiving side that are excluded <br>
(see --exclude). See the FILTER RULES section for a way to
make individual exclusions behave this way on the receiver,
and for a way to protect files from <br>
--delete-excluded. See --delete (which is implied) for more
details on file-deletion.</p>

<p style="margin-top: 1em">--ignore-errors <br>
Tells --delete to go ahead and delete files even when there
are I/O errors.</p>

<p style="margin-top: 1em">--force <br>
This option tells rsync to delete a non-empty directory when
it is to be replaced by a non-directory. This is only
relevant if deletions are not active (see --delete for <br>
details).</p>

<p style="margin-top: 1em">Note for older rsync versions:
--force used to still be required when using --delete-after,
and it used to be non-functional unless the --recursive
option was also <br>
enabled.</p>

<p style="margin-top: 1em">--max-delete=NUM <br>
This tells rsync not to delete more than NUM files or
directories. If that limit is exceeded, a warning is output
and rsync exits with an error code of 25 (new for <br>
3.0.0).</p>

<p style="margin-top: 1em">Also new for version 3.0.0, you
may specify --max-delete=0 to be warned about any extraneous
files in the destination without removing any of them. Older
clients inter&acirc; <br>
preted this as &quot;unlimited&quot;, so if you don&acirc;t
know what version the client is, you can use the less
obvious --max-delete=-1 as a backward-compatible way to
specify that no <br>
deletions be allowed (though older versions didn&acirc;t
warn when the limit was exceeded).</p>

<p style="margin-top: 1em">--max-size=SIZE <br>
This tells rsync to avoid transferring any file that is
larger than the specified SIZE. The SIZE value can be
suffixed with a string to indicate a size multiplier, and
may <br>
be a fractional value (e.g.
&quot;--max-size=1.5m&quot;).</p>

<p style="margin-top: 1em">This option is a transfer rule,
not an exclude, so it doesn&acirc;t affect the data that
goes into the file-lists, and thus it doesn&acirc;t affect
deletions. It just limits the <br>
files that the receiver requests to be transferred.</p>

<p style="margin-top: 1em">The suffixes are as follows:
&quot;K&quot; (or &quot;KiB&quot;) is a kibibyte (1024),
&quot;M&quot; (or &quot;MiB&quot;) is a mebibyte
(1024*1024), and &quot;G&quot; (or &quot;GiB&quot;) is a
gibibyte (1024*1024*1024). If you want <br>
the multiplier to be 1000 instead of 1024, use
&quot;KB&quot;, &quot;MB&quot;, or &quot;GB&quot;. (Note:
lower-case is also accepted for all values.) Finally, if the
suffix ends in either &quot;+1&quot; or <br>
&quot;-1&quot;, the value will be offset by one byte in the
indicated direction.</p>

<p style="margin-top: 1em">Examples: --max-size=1.5mb-1 is
1499999 bytes, and --max-size=2g+1 is 2147483649 bytes.</p>

<p style="margin-top: 1em">--min-size=SIZE <br>
This tells rsync to avoid transferring any file that is
smaller than the specified SIZE, which can help in not
transferring small, junk files. See the --max-size option
<br>
for a description of SIZE and other information.</p>

<p style="margin-top: 1em">-B, --block-size=BLOCKSIZE <br>
This forces the block size used in rsync&acirc;s
delta-transfer algorithm to a fixed value. It is normally
selected based on the size of each file being updated. See
the tech&acirc; <br>
nical report for details.</p>

<p style="margin-top: 1em">-e, --rsh=COMMAND <br>
This option allows you to choose an alternative remote shell
program to use for communication between the local and
remote copies of rsync. Typically, rsync is configured <br>
to use ssh by default, but you may prefer to use rsh on a
local network.</p>

<p style="margin-top: 1em">If this option is used with
[user@]host::module/path, then the remote shell COMMAND will
be used to run an rsync daemon on the remote host, and all
data will be transmit&acirc; <br>
ted through that remote shell connection, rather than
through a direct socket connection to a running rsync daemon
on the remote host. See the section &quot;USING RSYNC-DAEMON
<br>
FEATURES VIA A REMOTE-SHELL CONNECTION&quot; above.</p>

<p style="margin-top: 1em">Command-line arguments are
permitted in COMMAND provided that COMMAND is presented to
rsync as a single argument. You must use spaces (not tabs or
other whitespace) to <br>
separate the command and args from each other, and you can
use single- and/or double-quotes to preserve spaces in an
argument (but not backslashes). Note that doubling a <br>
single-quote inside a single-quoted string gives you a
single-quote; likewise for double-quotes (though you need to
pay attention to which quotes your shell is parsing and <br>
which quotes rsync is parsing). Some examples:</p>

<p style="margin-top: 1em">-e &rsquo;ssh -p 2234&rsquo;
<br>
-e &rsquo;ssh -o &quot;ProxyCommand nohup ssh firewall nc
-w1 %h %p&quot;&rsquo;</p>

<p style="margin-top: 1em">(Note that ssh users can
alternately customize site-specific connect options in their
.ssh/config file.)</p>

<p style="margin-top: 1em">You can also choose the remote
shell program using the RSYNC_RSH environment variable,
which accepts the same range of values as -e.</p>

<p style="margin-top: 1em">See also the --blocking-io
option which is affected by this option.</p>

<p style="margin-top: 1em">--rsync-path=PROGRAM <br>
Use this to specify what program is to be run on the remote
machine to start-up rsync. Often used when rsync is not in
the default remote-shell&acirc;s path (e.g. <br>
--rsync-path=/usr/local/bin/rsync). Note that PROGRAM is run
with the help of a shell, so it can be any program, script,
or command sequence you&acirc;d care to run, so long as <br>
it does not corrupt the standard-in &amp; standard-out that
rsync is using to communicate.</p>

<p style="margin-top: 1em">One tricky example is to set a
different default directory on the remote machine for use
with the --relative option. For instance:</p>

<p style="margin-top: 1em">rsync -avR --rsync-path=&quot;cd
/a/b &amp;&amp; rsync&quot; host:c/d /e/</p>

<p style="margin-top: 1em">-C, --cvs-exclude <br>
This is a useful shorthand for excluding a broad range of
files that you often don&acirc;t want to transfer between
systems. It uses a similar algorithm to CVS to determine if
a <br>
file should be ignored.</p>

<p style="margin-top: 1em">The exclude list is initialized
to exclude the following items (these initial items are
marked as perishable -- see the FILTER RULES section):</p>

<p style="margin-top: 1em">RCS SCCS CVS CVS.adm RCSLOG
cvslog.* tags TAGS .make.state .nse_depinfo *~ #* .#* ,* _$*
*$ *.old *.bak *.BAK *.orig *.rej .del-* *.a *.olb *.o *.obj
*.so *.exe *.Z <br>
*.elc *.ln core .svn/ .git/ .hg/ .bzr/</p>

<p style="margin-top: 1em">then, files listed in a
$HOME/.cvsignore are added to the list and any files listed
in the CVSIGNORE environment variable (all cvsignore names
are delimited by white&acirc; <br>
space).</p>

<p style="margin-top: 1em">Finally, any file is ignored if
it is in the same directory as a .cvsignore file and matches
one of the patterns listed therein. Unlike rsync&acirc;s
filter/exclude files, <br>
these patterns are split on whitespace. See the cvs(1)
manual for more information.</p>

<p style="margin-top: 1em">If you&acirc;re combining -C
with your own --filter rules, you should note that these CVS
excludes are appended at the end of your own rules,
regardless of where the -C was <br>
placed on the command-line. This makes them a lower priority
than any rules you specified explicitly. If you want to
control where these CVS excludes get inserted into <br>
your filter rules, you should omit the -C as a command-line
option and use a combination of --filter=:C and --filter=-C
(either on your command-line or by putting the
&quot;:C&quot; <br>
and &quot;-C&quot; rules into a filter file with your other
rules). The first option turns on the per-directory scanning
for the .cvsignore file. The second option does a one-time
<br>
import of the CVS excludes mentioned above.</p>

<p style="margin-top: 1em">-f, --filter=RULE <br>
This option allows you to add rules to selectively exclude
certain files from the list of files to be transferred. This
is most useful in combination with a recursive <br>
transfer.</p>

<p style="margin-top: 1em">You may use as many --filter
options on the command line as you like to build up the list
of files to exclude. If the filter contains whitespace, be
sure to quote it so <br>
that the shell gives the rule to rsync as a single argument.
The text below also mentions that you can use an underscore
to replace the space that separates a rule from <br>
its arg.</p>

<p style="margin-top: 1em">See the FILTER RULES section for
detailed information on this option.</p>

<p style="margin-top: 1em">-F The -F option is a shorthand
for adding two --filter rules to your command. The first
time it is used is a shorthand for this rule:</p>

<p style="margin-top: 1em">--filter=&rsquo;dir-merge
/.rsync-filter&rsquo;</p>

<p style="margin-top: 1em">This tells rsync to look for
per-directory .rsync-filter files that have been sprinkled
through the hierarchy and use their rules to filter the
files in the transfer. If <br>
-F is repeated, it is a shorthand for this rule:</p>

<p style="margin-top: 1em">--filter=&rsquo;exclude
.rsync-filter&rsquo;</p>

<p style="margin-top: 1em">This filters out the
.rsync-filter files themselves from the transfer.</p>

<p style="margin-top: 1em">See the FILTER RULES section for
detailed information on how these options work.</p>

<p style="margin-top: 1em">--exclude=PATTERN <br>
This option is a simplified form of the --filter option that
defaults to an exclude rule and does not allow the full
rule-parsing syntax of normal filter rules.</p>

<p style="margin-top: 1em">See the FILTER RULES section for
detailed information on this option.</p>

<p style="margin-top: 1em">--exclude-from=FILE <br>
This option is related to the --exclude option, but it
specifies a FILE that contains exclude patterns (one per
line). Blank lines in the file and lines starting with
&acirc;;&acirc; <br>
or &acirc;#&acirc; are ignored. If FILE is -, the list will
be read from standard input.</p>

<p style="margin-top: 1em">--include=PATTERN <br>
This option is a simplified form of the --filter option that
defaults to an include rule and does not allow the full
rule-parsing syntax of normal filter rules.</p>

<p style="margin-top: 1em">See the FILTER RULES section for
detailed information on this option.</p>

<p style="margin-top: 1em">--include-from=FILE <br>
This option is related to the --include option, but it
specifies a FILE that contains include patterns (one per
line). Blank lines in the file and lines starting with
&acirc;;&acirc; <br>
or &acirc;#&acirc; are ignored. If FILE is -, the list will
be read from standard input.</p>

<p style="margin-top: 1em">--files-from=FILE <br>
Using this option allows you to specify the exact list of
files to transfer (as read from the specified FILE or - for
standard input). It also tweaks the default behavior <br>
of rsync to make transferring just the specified files and
directories easier:</p>

<p style="margin-top: 1em">o The --relative (-R) option is
implied, which preserves the path information that is
specified for each item in the file (use --no-relative or
--no-R if you want to <br>
turn that off).</p>

<p style="margin-top: 1em">o The --dirs (-d) option is
implied, which will create directories specified in the list
on the destination rather than noisily skipping them (use
--no-dirs or --no-d <br>
if you want to turn that off).</p>

<p style="margin-top: 1em">o The --archive (-a)
option&acirc;s behavior does not imply --recursive (-r), so
specify it explicitly, if you want it.</p>

<p style="margin-top: 1em">o These side-effects change the
default state of rsync, so the position of the --files-from
option on the command-line has no bearing on how other
options are parsed <br>
(e.g. -a works the same before or after --files-from, as
does --no-R and all other options).</p>

<p style="margin-top: 1em">The filenames that are read from
the FILE are all relative to the source dir -- any leading
slashes are removed and no &quot;..&quot; references are
allowed to go higher than the <br>
source dir. For example, take this command:</p>

<p style="margin-top: 1em">rsync -a --files-from=/tmp/foo
/usr remote:/backup</p>

<p style="margin-top: 1em">If /tmp/foo contains the string
&quot;bin&quot; (or even &quot;/bin&quot;), the /usr/bin
directory will be created as /backup/bin on the remote host.
If it contains &quot;bin/&quot; (note the trailing <br>
slash), the immediate contents of the directory would also
be sent (without needing to be explicitly mentioned in the
file -- this began in version 2.6.4). In both cases, <br>
if the -r option was enabled, that dir&acirc;s entire
hierarchy would also be transferred (keep in mind that -r
needs to be specified explicitly with --files-from, since it
is <br>
not implied by -a). Also note that the effect of the
(enabled by default) --relative option is to duplicate only
the path info that is read from the file -- it does not <br>
force the duplication of the source-spec path (/usr in this
case).</p>

<p style="margin-top: 1em">In addition, the --files-from
file can be read from the remote host instead of the local
host if you specify a &quot;host:&quot; in front of the file
(the host must match one end of <br>
the transfer). As a short-cut, you can specify just a prefix
of &quot;:&quot; to mean &quot;use the remote end of the
transfer&quot;. For example:</p>

<p style="margin-top: 1em">rsync -a
--files-from=:/path/file-list src:/ /tmp/copy</p>

<p style="margin-top: 1em">This would copy all the files
specified in the /path/file-list file that was located on
the remote &quot;src&quot; host.</p>

<p style="margin-top: 1em">If the --iconv and
--protect-args options are specified and the --files-from
filenames are being sent from one host to another, the
filenames will be translated from the <br>
sending host&acirc;s charset to the receiving host&acirc;s
charset.</p>

<p style="margin-top: 1em">NOTE: sorting the list of files
in the --files-from input helps rsync to be more efficient,
as it will avoid re-visiting the path elements that are
shared between adjacent <br>
entries. If the input is not sorted, some path elements
(implied directories) may end up being scanned multiple
times, and rsync will eventually unduplicate them after <br>
they get turned into file-list elements.</p>

<p style="margin-top: 1em">-0, --from0 <br>
This tells rsync that the rules/filenames it reads from a
file are terminated by a null (&acirc; &acirc;) character,
not a NL, CR, or CR+LF. This affects --exclude-from, <br>
--include-from, --files-from, and any merged files specified
in a --filter rule. It does not affect --cvs-exclude (since
all names read from a .cvsignore file are split <br>
on whitespace).</p>

<p style="margin-top: 1em">-s, --protect-args <br>
This option sends all filenames and most options to the
remote rsync without allowing the remote shell to interpret
them. This means that spaces are not split in names, <br>
and any non-wildcard special characters are not translated
(such as ~, $, ;, &amp;, etc.). Wildcards are expanded on
the remote host by rsync (instead of the shell doing
it).</p>

<p style="margin-top: 1em">If you use this option with
--iconv, the args related to the remote side will also be
translated from the local to the remote character-set. The
translation happens <br>
before wild-cards are expanded. See also the --files-from
option.</p>

<p style="margin-top: 1em">-T, --temp-dir=DIR <br>
This option instructs rsync to use DIR as a scratch
directory when creating temporary copies of the files
transferred on the receiving side. The default behavior is
to <br>
create each temporary file in the same directory as the
associated destination file.</p>

<p style="margin-top: 1em">This option is most often used
when the receiving disk partition does not have enough free
space to hold a copy of the largest file in the transfer. In
this case (i.e. <br>
when the scratch directory is on a different disk
partition), rsync will not be able to rename each received
temporary file over the top of the associated destination
<br>
file, but instead must copy it into place. Rsync does this
by copying the file over the top of the destination file,
which means that the destination file will contain <br>
truncated data during this copy. If this were not done this
way (even if the destination file were first removed, the
data locally copied to a temporary file in the des&acirc;
<br>
tination directory, and then renamed into place) it would be
possible for the old file to continue taking up disk space
(if someone had it open), and thus there might not <br>
be enough room to fit the new version on the disk at the
same time.</p>

<p style="margin-top: 1em">If you are using this option for
reasons other than a shortage of disk space, you may wish to
combine it with the --delay-updates option, which will
ensure that all copied <br>
files get put into subdirectories in the destination
hierarchy, awaiting the end of the transfer. If you
don&acirc;t have enough room to duplicate all the arriving
files on the <br>
destination partition, another way to tell rsync that you
aren&acirc;t overly concerned about disk space is to use the
--partial-dir option with a relative path; because this <br>
tells rsync that it is OK to stash off a copy of a single
file in a subdir in the destination hierarchy, rsync will
use the partial-dir as a staging area to bring over the <br>
copied file, and then rename it into place from there.
(Specifying a --partial-dir with an absolute path does not
have this side-effect.)</p>

<p style="margin-top: 1em">-y, --fuzzy <br>
This option tells rsync that it should look for a basis file
for any destination file that is missing. The current
algorithm looks in the same directory as the destina&acirc;
<br>
tion file for either a file that has an identical size and
modified-time, or a similarly-named file. If found, rsync
uses the fuzzy basis file to try to speed up the <br>
transfer.</p>

<p style="margin-top: 1em">Note that the use of the
--delete option might get rid of any potential fuzzy-match
files, so either use --delete-after or specify some filename
exclusions if you need to <br>
prevent this.</p>

<p style="margin-top: 1em">--compare-dest=DIR <br>
This option instructs rsync to use DIR on the destination
machine as an additional hierarchy to compare destination
files against doing transfers (if the files are missing <br>
in the destination directory). If a file is found in DIR
that is identical to the sender&acirc;s file, the file will
NOT be transferred to the destination directory. This is
<br>
useful for creating a sparse backup of just files that have
changed from an earlier backup.</p>

<p style="margin-top: 1em">Beginning in version 2.6.4,
multiple --compare-dest directories may be provided, which
will cause rsync to search the list in the order specified
for an exact match. If a <br>
match is found that differs only in attributes, a local copy
is made and the attributes updated. If a match is not found,
a basis file from one of the DIRs will be <br>
selected to try to speed up the transfer.</p>

<p style="margin-top: 1em">If DIR is a relative path, it is
relative to the destination directory. See also --copy-dest
and --link-dest.</p>

<p style="margin-top: 1em">--copy-dest=DIR <br>
This option behaves like --compare-dest, but rsync will also
copy unchanged files found in DIR to the destination
directory using a local copy. This is useful for doing <br>
transfers to a new destination while leaving existing files
intact, and then doing a flash-cutover when all files have
been successfully transferred.</p>

<p style="margin-top: 1em">Multiple --copy-dest directories
may be provided, which will cause rsync to search the list
in the order specified for an unchanged file. If a match is
not found, a basis <br>
file from one of the DIRs will be selected to try to speed
up the transfer.</p>

<p style="margin-top: 1em">If DIR is a relative path, it is
relative to the destination directory. See also
--compare-dest and --link-dest.</p>

<p style="margin-top: 1em">--link-dest=DIR <br>
This option behaves like --copy-dest, but unchanged files
are hard linked from DIR to the destination directory. The
files must be identical in all preserved attributes <br>
(e.g. permissions, possibly ownership) in order for the
files to be linked together. An example:</p>

<p style="margin-top: 1em">rsync -av
--link-dest=$PWD/prior_dir host:src_dir/ new_dir/</p>

<p style="margin-top: 1em">If file&acirc;s aren&acirc;t
linking, double-check their attributes. Also check if some
attributes are getting forced outside of rsync&acirc;s
control, such a mount option that squishes <br>
root to a single user, or mounts a removable drive with
generic ownership (such as OS X&acirc;s &quot;Ignore
ownership on this volume&quot; option).</p>

<p style="margin-top: 1em">Beginning in version 2.6.4,
multiple --link-dest directories may be provided, which will
cause rsync to search the list in the order specified for an
exact match. If a <br>
match is found that differs only in attributes, a local copy
is made and the attributes updated. If a match is not found,
a basis file from one of the DIRs will be <br>
selected to try to speed up the transfer.</p>

<p style="margin-top: 1em">This option works best when
copying into an empty destination hierarchy, as rsync treats
existing files as definitive (so it never looks in the
link-dest dirs when a des&acirc; <br>
tination file already exists), and as malleable (so it might
change the attributes of a destination file, which affects
all the hard-linked versions).</p>

<p style="margin-top: 1em">Note that if you combine this
option with --ignore-times, rsync will not link any files
together because it only links identical files together as a
substitute for trans&acirc; <br>
ferring the file, never as an additional check after the
file is updated.</p>

<p style="margin-top: 1em">If DIR is a relative path, it is
relative to the destination directory. See also
--compare-dest and --copy-dest.</p>

<p style="margin-top: 1em">Note that rsync versions prior
to 2.6.1 had a bug that could prevent --link-dest from
working properly for a non-super-user when -o was specified
(or implied by -a). You <br>
can work-around this bug by avoiding the -o option when
sending to an old rsync.</p>

<p style="margin-top: 1em">-z, --compress <br>
With this option, rsync compresses the file data as it is
sent to the destination machine, which reduces the amount of
data being transmitted -- something that is useful <br>
over a slow connection.</p>

<p style="margin-top: 1em">Note that this option typically
achieves better compression ratios than can be achieved by
using a compressing remote shell or a compressing transport
because it takes <br>
advantage of the implicit information in the matching data
blocks that are not explicitly sent over the connection.</p>

<p style="margin-top: 1em">See the --skip-compress option
for the default list of file suffixes that will not be
compressed.</p>

<p style="margin-top: 1em">--compress-level=NUM <br>
Explicitly set the compression level to use (see --compress)
instead of letting it default. If NUM is non-zero, the
--compress option is implied.</p>

<p style="margin-top: 1em">--skip-compress=LIST <br>
Override the list of file suffixes that will not be
compressed. The LIST should be one or more file suffixes
(without the dot) separated by slashes (/).</p>

<p style="margin-top: 1em">You may specify an empty string
to indicate that no file should be skipped.</p>

<p style="margin-top: 1em">Simple character-class matching
is supported: each must consist of a list of letters inside
the square brackets (e.g. no special classes, such as
&quot;[:alpha:]&quot;, are sup&acirc; <br>
ported, and &acirc;-&acirc; has no special meaning).</p>

<p style="margin-top: 1em">The characters asterisk (*) and
question-mark (?) have no special meaning.</p>

<p style="margin-top: 1em">Here&acirc;s an example that
specifies 6 suffixes to skip (since 1 of the 5 rules matches
2 suffixes):</p>


<p style="margin-top: 1em">--skip-compress=gz/jpg/mp[34]/7z/bz2</p>

<p style="margin-top: 1em">The default list of suffixes
that will not be compressed is this (in this version of
rsync):</p>

<p style="margin-top: 1em">7z avi bz2 deb gz iso jpeg jpg
mov mp3 mp4 ogg rpm tbz tgz z zip</p>

<p style="margin-top: 1em">This list will be replaced by
your --skip-compress list in all but one situation: a copy
from a daemon rsync will add your skipped suffixes to its
list of non-compressing <br>
files (and its list may be configured to a different
default).</p>

<p style="margin-top: 1em">--numeric-ids <br>
With this option rsync will transfer numeric group and user
IDs rather than using user and group names and mapping them
at both ends.</p>

<p style="margin-top: 1em">By default rsync will use the
username and groupname to determine what ownership to give
files. The special uid 0 and the special group 0 are never
mapped via user/group <br>
names even if the --numeric-ids option is not specified.</p>

<p style="margin-top: 1em">If a user or group has no name
on the source system or it has no match on the destination
system, then the numeric ID from the source system is used
instead. See also the <br>
comments on the &quot;use chroot&quot; setting in the
rsyncd.conf manpage for information on how the chroot
setting affects rsync&acirc;s ability to look up the names
of the users and <br>
groups and what you can do about it.</p>

<p style="margin-top: 1em">--timeout=TIMEOUT <br>
This option allows you to set a maximum I/O timeout in
seconds. If no data is transferred for the specified time
then rsync will exit. The default is 0, which means no <br>
timeout.</p>

<p style="margin-top: 1em">--contimeout <br>
This option allows you to set the amount of time that rsync
will wait for its connection to an rsync daemon to succeed.
If the timeout is reached, rsync exits with an <br>
error.</p>

<p style="margin-top: 1em">--address <br>
By default rsync will bind to the wildcard address when
connecting to an rsync daemon. The --address option allows
you to specify a specific IP address (or hostname) to <br>
bind to. See also this option in the --daemon mode
section.</p>

<p style="margin-top: 1em">--port=PORT <br>
This specifies an alternate TCP port number to use rather
than the default of 873. This is only needed if you are
using the double-colon (::) syntax to connect with an <br>
rsync daemon (since the URL syntax has a way to specify the
port as a part of the URL). See also this option in the
--daemon mode section.</p>

<p style="margin-top: 1em">--sockopts <br>
This option can provide endless fun for people who like to
tune their systems to the utmost degree. You can set all
sorts of socket options which may make transfers faster <br>
(or slower!). Read the man page for the setsockopt() system
call for details on some of the options you may be able to
set. By default no special socket options are set. <br>
This only affects direct socket connections to a remote
rsync daemon. This option also exists in the --daemon mode
section.</p>

<p style="margin-top: 1em">--blocking-io <br>
This tells rsync to use blocking I/O when launching a remote
shell transport. If the remote shell is either rsh or remsh,
rsync defaults to using blocking I/O, otherwise <br>
it defaults to using non-blocking I/O. (Note that ssh
prefers non-blocking I/O.)</p>

<p style="margin-top: 1em">-i, --itemize-changes <br>
Requests a simple itemized list of the changes that are
being made to each file, including attribute changes. This
is exactly the same as specifying --out-format=&rsquo;%i
<br>
%n%L&rsquo;. If you repeat the option, unchanged files will
also be output, but only if the receiving rsync is at least
version 2.6.7 (you can use -vv with older versions of <br>
rsync, but that also turns on the output of other verbose
messages).</p>

<p style="margin-top: 1em">The &quot;%i&quot; escape has a
cryptic output that is 11 letters long. The general format
is like the string YXcstpoguax, where Y is replaced by the
type of update being done, X <br>
is replaced by the file-type, and the other letters
represent attributes that may be output if they are being
modified.</p>

<p style="margin-top: 1em">The update types that replace
the Y are as follows:</p>

<p style="margin-top: 1em">o A &lt; means that a file is
being transferred to the remote host (sent).</p>

<p style="margin-top: 1em">o A &gt; means that a file is
being transferred to the local host (received).</p>

<p style="margin-top: 1em">o A c means that a local
change/creation is occurring for the item (such as the
creation of a directory or the changing of a symlink,
etc.).</p>

<p style="margin-top: 1em">o A h means that the item is a
hard link to another item (requires --hard-links).</p>

<p style="margin-top: 1em">o A . means that the item is not
being updated (though it might have attributes that are
being modified).</p>

<p style="margin-top: 1em">o A * means that the rest of the
itemized-output area contains a message (e.g.
&quot;deleting&quot;).</p>

<p style="margin-top: 1em">The file-types that replace the
X are: f for a file, a d for a directory, an L for a
symlink, a D for a device, and a S for a special file (e.g.
named sockets and fifos).</p>

<p style="margin-top: 1em">The other letters in the string
above are the actual letters that will be output if the
associated attribute for the item is being updated or a
&quot;.&quot; for no change. Three <br>
exceptions to this are: (1) a newly created item replaces
each letter with a &quot;+&quot;, (2) an identical item
replaces the dots with spaces, and (3) an unknown attribute
<br>
replaces each letter with a &quot;?&quot; (this can happen
when talking to an older rsync).</p>

<p style="margin-top: 1em">The attribute that is associated
with each letter is as follows:</p>

<p style="margin-top: 1em">o A c means either that a
regular file has a different checksum (requires --checksum)
or that a symlink, device, or special file has a changed
value. Note that if <br>
you are sending files to an rsync prior to 3.0.1, this
change flag will be present only for checksum-differing
regular files.</p>

<p style="margin-top: 1em">o A s means the size of a
regular file is different and will be updated by the file
transfer.</p>

<p style="margin-top: 1em">o A t means the modification
time is different and is being updated to the sender&acirc;s
value (requires --times). An alternate value of T means that
the modification <br>
time will be set to the transfer time, which happens when a
file/symlink/device is updated without --times and when a
symlink is changed and the receiver can&acirc;t set <br>
its time. (Note: when using an rsync 3.0.0 client, you might
see the s flag combined with t instead of the proper T flag
for this time-setting failure.)</p>

<p style="margin-top: 1em">o A p means the permissions are
different and are being updated to the sender&acirc;s value
(requires --perms).</p>

<p style="margin-top: 1em">o An o means the owner is
different and is being updated to the sender&acirc;s value
(requires --owner and super-user privileges).</p>

<p style="margin-top: 1em">o A g means the group is
different and is being updated to the sender&acirc;s value
(requires --group and the authority to set the group).</p>

<p style="margin-top: 1em">o The u slot is reserved for
future use.</p>

<p style="margin-top: 1em">o The a means that the ACL
information changed.</p>

<p style="margin-top: 1em">o The x means that the extended
attribute information changed.</p>

<p style="margin-top: 1em">One other output is possible:
when deleting files, the &quot;%i&quot; will output the
string &quot;*deleting&quot; for each item that is being
removed (assuming that you are talking to a <br>
recent enough rsync that it logs deletions instead of
outputting them as a verbose message).</p>

<p style="margin-top: 1em">--out-format=FORMAT <br>
This allows you to specify exactly what the rsync client
outputs to the user on a per-update basis. The format is a
text string containing embedded single-character <br>
escape sequences prefixed with a percent (%) character. A
default format of &quot;%n%L&quot; is assumed if -v is
specified (which reports the name of the file and, if the
item is <br>
a link, where it points). For a full list of the possible
escape characters, see the &quot;log format&quot; setting in
the rsyncd.conf manpage.</p>

<p style="margin-top: 1em">Specifying the --out-format
option will mention each file, dir, etc. that gets updated
in a significant way (a transferred file, a recreated
symlink/device, or a touched <br>
directory). In addition, if the itemize-changes escape (%i)
is included in the string (e.g. if the --itemize-changes
option was used), the logging of names increases to <br>
mention any item that is changed in any way (as long as the
receiving side is at least 2.6.4). See the --itemize-changes
option for a description of the output of
&quot;%i&quot;.</p>

<p style="margin-top: 1em">Rsync will output the out-format
string prior to a file&acirc;s transfer unless one of the
transfer-statistic escapes is requested, in which case the
logging is done at the end <br>
of the file&acirc;s transfer. When this late logging is in
effect and --progress is also specified, rsync will also
output the name of the file being transferred prior to its
<br>
progress information (followed, of course, by the out-format
output).</p>

<p style="margin-top: 1em">--log-file=FILE <br>
This option causes rsync to log what it is doing to a file.
This is similar to the logging that a daemon does, but can
be requested for the client side and/or the server <br>
side of a non-daemon transfer. If specified as a client
option, transfer logging will be enabled with a default
format of &quot;%i %n%L&quot;. See the --log-file-format
option if <br>
you wish to override this.</p>

<p style="margin-top: 1em">Here&acirc;s a example command
that requests the remote side to log what is happening:</p>

<p style="margin-top: 1em">rsync -av
--rsync-path=&quot;rsync --log-file=/tmp/rlog&quot; src/
dest/</p>

<p style="margin-top: 1em">This is very useful if you need
to debug why a connection is closing unexpectedly.</p>

<p style="margin-top: 1em">--log-file-format=FORMAT <br>
This allows you to specify exactly what per-update logging
is put into the file specified by the --log-file option
(which must also be specified for this option to have <br>
any effect). If you specify an empty string, updated files
will not be mentioned in the log file. For a list of the
possible escape characters, see the &quot;log format&quot;
set&acirc; <br>
ting in the rsyncd.conf manpage.</p>

<p style="margin-top: 1em">The default FORMAT used if
--log-file is specified and this option is not is &acirc;%i
%n%L&acirc;.</p>

<p style="margin-top: 1em">--stats <br>
This tells rsync to print a verbose set of statistics on the
file transfer, allowing you to tell how effective
rsync&acirc;s delta-transfer algorithm is for your data.</p>

<p style="margin-top: 1em">The current statistics are as
follows:</p>

<p style="margin-top: 1em">o Number of files is the count
of all &quot;files&quot; (in the generic sense), which
includes directories, symlinks, etc.</p>

<p style="margin-top: 1em">o Number of files transferred is
the count of normal files that were updated via
rsync&acirc;s delta-transfer algorithm, which does not
include created dirs, symlinks, etc.</p>

<p style="margin-top: 1em">o Total file size is the total
sum of all file sizes in the transfer. This does not count
any size for directories or special files, but does include
the size of <br>
symlinks.</p>

<p style="margin-top: 1em">o Total transferred file size is
the total sum of all files sizes for just the transferred
files.</p>

<p style="margin-top: 1em">o Literal data is how much
unmatched file-update data we had to send to the receiver
for it to recreate the updated files.</p>

<p style="margin-top: 1em">o Matched data is how much data
the receiver got locally when recreating the updated
files.</p>

<p style="margin-top: 1em">o File list size is how big the
file-list data was when the sender sent it to the receiver.
This is smaller than the in-memory size for the file list
due to some <br>
compressing of duplicated data when rsync sends the
list.</p>

<p style="margin-top: 1em">o File list generation time is
the number of seconds that the sender spent creating the
file list. This requires a modern rsync on the sending side
for this to be <br>
present.</p>

<p style="margin-top: 1em">o File list transfer time is the
number of seconds that the sender spent sending the file
list to the receiver.</p>

<p style="margin-top: 1em">o Total bytes sent is the count
of all the bytes that rsync sent from the client side to the
server side.</p>

<p style="margin-top: 1em">o Total bytes received is the
count of all non-message bytes that rsync received by the
client side from the server side. &quot;Non-message&quot;
bytes means that we don&acirc;t <br>
count the bytes for a verbose message that the server sent
to us, which makes the stats more consistent.</p>

<p style="margin-top: 1em">-8, --8-bit-output <br>
This tells rsync to leave all high-bit characters unescaped
in the output instead of trying to test them to see if
they&acirc;re valid in the current locale and escaping the
<br>
invalid ones. All control characters (but never tabs) are
always escaped, regardless of this option&acirc;s
setting.</p>

<p style="margin-top: 1em">The escape idiom that started in
2.6.7 is to output a literal backslash ( and a hash (#),
followed by exactly 3 octal digits. For example, a newline
would output as <br>
&quot; <br>
-h, --human-readable <br>
Output numbers in a more human-readable format. This makes
big numbers output using larger units, with a K, M, or G
suffix. If this option was specified once, these <br>
units are K (1000), M (1000*1000), and G (1000*1000*1000);
if the option is repeated, the units are powers of 1024
instead of 1000.</p>

<p style="margin-top: 1em">--partial <br>
By default, rsync will delete any partially transferred file
if the transfer is interrupted. In some circumstances it is
more desirable to keep partially transferred <br>
files. Using the --partial option tells rsync to keep the
partial file which should make a subsequent transfer of the
rest of the file much faster.</p>

<p style="margin-top: 1em">--partial-dir=DIR <br>
A better way to keep partial files than the --partial option
is to specify a DIR that will be used to hold the partial
data (instead of writing it out to the destination <br>
file). On the next transfer, rsync will use a file found in
this dir as data to speed up the resumption of the transfer
and then delete it after it has served its pur&acirc; <br>
pose.</p>

<p style="margin-top: 1em">Note that if --whole-file is
specified (or implied), any partial-dir file that is found
for a file that is being updated will simply be removed
(since rsync is sending <br>
files without using rsync&acirc;s delta-transfer
algorithm).</p>

<p style="margin-top: 1em">Rsync will create the DIR if it
is missing (just the last dir -- not the whole path). This
makes it easy to use a relative path (such as
&quot;--partial-dir=.rsync-partial&quot;) <br>
to have rsync create the partial-directory in the
destination file&acirc;s directory when needed, and then
remove it again when the partial file is deleted.</p>

<p style="margin-top: 1em">If the partial-dir value is not
an absolute path, rsync will add an exclude rule at the end
of all your existing excludes. This will prevent the sending
of any par&acirc; <br>
tial-dir files that may exist on the sending side, and will
also prevent the untimely deletion of partial-dir items on
the receiving side. An example: the above --par&acirc; <br>
tial-dir option would add the equivalent of &quot;-f
&rsquo;-p .rsync-partial/&rsquo;&quot; at the end of any
other filter rules.</p>

<p style="margin-top: 1em">If you are supplying your own
exclude rules, you may need to add your own
exclude/hide/protect rule for the partial-dir because (1)
the auto-added rule may be ineffective <br>
at the end of your other rules, or (2) you may wish to
override rsync&acirc;s exclude choice. For instance, if you
want to make rsync clean-up any left-over partial-dirs that
<br>
may be lying around, you should specify --delete-after and
add a &quot;risk&quot; filter rule, e.g. -f &rsquo;R
.rsync-partial/&rsquo;. (Avoid using --delete-before or
--delete-during unless <br>
you don&acirc;t need rsync to use any of the left-over
partial-dir data during the current run.)</p>

<p style="margin-top: 1em">IMPORTANT: the --partial-dir
should not be writable by other users or it is a security
risk. E.g. AVOID &quot;/tmp&quot;.</p>

<p style="margin-top: 1em">You can also set the partial-dir
value the RSYNC_PARTIAL_DIR environment variable. Setting
this in the environment does not force --partial to be
enabled, but rather it <br>
affects where partial files go when --partial is specified.
For instance, instead of using --partial-dir=.rsync-tmp
along with --progress, you could set RSYNC_PAR&acirc; <br>
TIAL_DIR=.rsync-tmp in your environment and then just use
the -P option to turn on the use of the .rsync-tmp dir for
partial transfers. The only times that the --partial <br>
option does not look for this environment value are (1) when
--inplace was specified (since --inplace conflicts with
--partial-dir), and (2) when --delay-updates was spec&acirc;
<br>
ified (see below).</p>

<p style="margin-top: 1em">For the purposes of the
daemon-config&acirc;s &quot;refuse options&quot; setting,
--partial-dir does not imply --partial. This is so that a
refusal of the --partial option can be used to <br>
disallow the overwriting of destination files with a partial
transfer, while still allowing the safer idiom provided by
--partial-dir.</p>

<p style="margin-top: 1em">--delay-updates <br>
This option puts the temporary file from each updated file
into a holding directory until the end of the transfer, at
which time all the files are renamed into place in <br>
rapid succession. This attempts to make the updating of the
files a little more atomic. By default the files are placed
into a directory named &quot;.~tmp~&quot; in each
file&acirc;s <br>
destination directory, but if you&acirc;ve specified the
--partial-dir option, that directory will be used instead.
See the comments in the --partial-dir section for a
discus&acirc; <br>
sion of how this &quot;.~tmp~&quot; dir will be excluded
from the transfer, and what you can do if you want rsync to
cleanup old &quot;.~tmp~&quot; dirs that might be lying
around. Conflicts <br>
with --inplace and --append.</p>

<p style="margin-top: 1em">This option uses more memory on
the receiving side (one bit per file transferred) and also
requires enough free disk space on the receiving side to
hold an additional copy <br>
of all the updated files. Note also that you should not use
an absolute path to --partial-dir unless (1) there is no
chance of any of the files in the transfer having the <br>
same name (since all the updated files will be put into a
single directory if the path is absolute) and (2) there are
no mount points in the hierarchy (since the delayed <br>
updates will fail if they can&acirc;t be renamed into
place).</p>

<p style="margin-top: 1em">See also the
&quot;atomic-rsync&quot; perl script in the
&quot;support&quot; subdir for an update algorithm that is
even more atomic (it uses --link-dest and a parallel
hierarchy of files).</p>

<p style="margin-top: 1em">-m, --prune-empty-dirs <br>
This option tells the receiving rsync to get rid of empty
directories from the file-list, including nested directories
that have no non-directory children. This is useful <br>
for avoiding the creation of a bunch of useless directories
when the sending rsync is recursively scanning a hierarchy
of files using include/exclude/filter rules.</p>

<p style="margin-top: 1em">Note that the use of transfer
rules, such as the --min-size option, does not affect what
goes into the file list, and thus does not leave directories
empty, even if none <br>
of the files in a directory match the transfer rule.</p>

<p style="margin-top: 1em">Because the file-list is
actually being pruned, this option also affects what
directories get deleted when a delete is active. However,
keep in mind that excluded files <br>
and directories can prevent existing items from being
deleted due to an exclude both hiding source files and
protecting destination files. See the perishable filter-rule
<br>
option for how to avoid this.</p>

<p style="margin-top: 1em">You can prevent the pruning of
certain empty directories from the file-list by using a
global &quot;protect&quot; filter. For instance, this option
would ensure that the directory <br>
&quot;emptydir&quot; was kept in the file-list:</p>

<p style="margin-top: 1em">--filter &acirc;protect
emptydir/&acirc;</p>

<p style="margin-top: 1em">Here&acirc;s an example that
copies all .pdf files in a hierarchy, only creating the
necessary destination directories to hold the .pdf files,
and ensures that any superfluous <br>
files and directories in the destination are removed (note
the hide filter of non-directories being used instead of an
exclude):</p>

<p style="margin-top: 1em">rsync -avm --del
--include=&acirc;*.pdf&acirc; -f &acirc;hide,! */&acirc;
src/ dest</p>

<p style="margin-top: 1em">If you didn&acirc;t want to
remove superfluous destination files, the more time-honored
options of &quot;--include=&rsquo;*/&rsquo;
--exclude=&rsquo;*&rsquo;&quot; would work fine in place of
the hide-filter (if <br>
that is more natural to you).</p>

<p style="margin-top: 1em">--progress <br>
This option tells rsync to print information showing the
progress of the transfer. This gives a bored user something
to watch. Implies --verbose if it wasn&acirc;t already <br>
specified.</p>

<p style="margin-top: 1em">While rsync is transferring a
regular file, it updates a progress line that looks like
this:</p>

<p style="margin-top: 1em">782448 63% 110.64kB/s
0:00:04</p>

<p style="margin-top: 1em">In this example, the receiver
has reconstructed 782448 bytes or 63% of the sender&acirc;s
file, which is being reconstructed at a rate of 110.64
kilobytes per second, and the <br>
transfer will finish in 4 seconds if the current rate is
maintained until the end.</p>

<p style="margin-top: 1em">These statistics can be
misleading if rsync&acirc;s delta-transfer algorithm is in
use. For example, if the sender&acirc;s file consists of the
basis file followed by additional <br>
data, the reported rate will probably drop dramatically when
the receiver gets to the literal data, and the transfer will
probably take much longer to finish than the <br>
receiver estimated as it was finishing the matched part of
the file.</p>

<p style="margin-top: 1em">When the file transfer finishes,
rsync replaces the progress line with a summary line that
looks like this:</p>

<p style="margin-top: 1em">1238099 100% 146.38kB/s 0:00:08
(xfer#5, to-check=169/396)</p>

<p style="margin-top: 1em">In this example, the file was
1238099 bytes long in total, the average rate of transfer
for the whole file was 146.38 kilobytes per second over the
8 seconds that it took <br>
to complete, it was the 5th transfer of a regular file
during the current rsync session, and there are 169 more
files for the receiver to check (to see if they are <br>
up-to-date or not) remaining out of the 396 total files in
the file-list.</p>

<p style="margin-top: 1em">-P The -P option is equivalent
to --partial --progress. Its purpose is to make it much
easier to specify these two options for a long transfer that
may be interrupted.</p>

<p style="margin-top: 1em">--password-file <br>
This option allows you to provide a password in a file for
accessing an rsync daemon. The file must not be world
readable. It should contain just the password as the <br>
first line of the file (all other lines are ignored).</p>

<p style="margin-top: 1em">This option does not supply a
password to a remote shell transport such as ssh; to learn
how to do that, consult the remote shell&acirc;s
documentation. When accessing an rsync <br>
daemon using a remote shell as the transport, this option
only comes into effect after the remote shell finishes its
authentication (i.e. if you have also specified a <br>
password in the daemon&acirc;s config file).</p>

<p style="margin-top: 1em">--list-only <br>
This option will cause the source files to be listed instead
of transferred. This option is inferred if there is a single
source arg and no destination specified, so its <br>
main uses are: (1) to turn a copy command that includes a
destination arg into a file-listing command, or (2) to be
able to specify more than one source arg (note: be sure <br>
to include the destination). Caution: keep in mind that a
source arg with a wild-card is expanded by the shell into
multiple args, so it is never safe to try to list such <br>
an arg without using this option. For example:</p>

<p style="margin-top: 1em">rsync -av --list-only foo*
dest/</p>

<p style="margin-top: 1em">Compatibility note: when
requesting a remote listing of files from an rsync that is
version 2.6.3 or older, you may encounter an error if you
ask for a non-recursive <br>
listing. This is because a file listing implies the --dirs
option w/o --recursive, and older rsyncs don&acirc;t have
that option. To avoid this problem, either specify the <br>
--no-dirs option (if you don&acirc;t need to expand a
directory&acirc;s content), or turn on recursion and exclude
the content of subdirectories: -r
--exclude=&rsquo;/*/*&rsquo;.</p>

<p style="margin-top: 1em">--bwlimit=KBPS <br>
This option allows you to specify a maximum transfer rate in
kilobytes per second. This option is most effective when
using rsync with large files (several megabytes and <br>
up). Due to the nature of rsync transfers, blocks of data
are sent, then if rsync determines the transfer was too
fast, it will wait before sending the next data block. <br>
The result is an average transfer rate equaling the
specified limit. A value of zero specifies no limit.</p>

<p style="margin-top: 1em">--write-batch=FILE <br>
Record a file that can later be applied to another identical
destination with --read-batch. See the &quot;BATCH
MODE&quot; section for details, and also the
--only-write-batch <br>
option.</p>

<p style="margin-top: 1em">--only-write-batch=FILE <br>
Works like --write-batch, except that no updates are made on
the destination system when creating the batch. This lets
you transport the changes to the destination system <br>
via some other means and then apply the changes via
--read-batch.</p>

<p style="margin-top: 1em">Note that you can feel free to
write the batch directly to some portable media: if this
media fills to capacity before the end of the transfer, you
can just apply that <br>
partial transfer to the destination and repeat the whole
process to get the rest of the changes (as long as you
don&acirc;t mind a partially updated destination system
while the <br>
multi-update cycle is happening).</p>

<p style="margin-top: 1em">Also note that you only save
bandwidth when pushing changes to a remote system because
this allows the batched data to be diverted from the sender
into the batch file <br>
without having to flow over the wire to the receiver (when
pulling, the sender is remote, and thus can&acirc;t write
the batch).</p>

<p style="margin-top: 1em">--read-batch=FILE <br>
Apply all of the changes stored in FILE, a file previously
generated by --write-batch. If FILE is -, the batch data
will be read from standard input. See the &quot;BATCH <br>
MODE&quot; section for details.</p>

<p style="margin-top: 1em">--protocol=NUM <br>
Force an older protocol version to be used. This is useful
for creating a batch file that is compatible with an older
version of rsync. For instance, if rsync 2.6.4 is <br>
being used with the --write-batch option, but rsync 2.6.3 is
what will be used to run the --read-batch option, you should
use &quot;--protocol=28&quot; when creating the batch file
<br>
to force the older protocol version to be used in the batch
file (assuming you can&acirc;t upgrade the rsync on the
reading system).</p>

<p style="margin-top: 1em">--iconv=CONVERT_SPEC <br>
Rsync can convert filenames between character sets using
this option. Using a CONVERT_SPEC of &quot;.&quot; tells
rsync to look up the default character-set via the locale
setting. <br>
Alternately, you can fully specify what conversion to do by
giving a local and a remote charset separated by a comma in
the order --iconv=LOCAL,REMOTE, e.g. <br>
--iconv=utf8,iso88591. This order ensures that the option
will stay the same whether you&acirc;re pushing or pulling
files. Finally, you can specify either --no-iconv or a <br>
CONVERT_SPEC of &quot;-&quot; to turn off any conversion.
The default setting of this option is site-specific, and can
also be affected via the RSYNC_ICONV environment
variable.</p>

<p style="margin-top: 1em">For a list of what charset names
your local iconv library supports, you can run &quot;iconv
--list&quot;.</p>

<p style="margin-top: 1em">If you specify the
--protect-args option (-s), rsync will translate the
filenames you specify on the command-line that are being
sent to the remote host. See also the <br>
--files-from option.</p>

<p style="margin-top: 1em">Note that rsync does not do any
conversion of names in filter files (including
include/exclude files). It is up to you to ensure that
you&acirc;re specifying matching rules <br>
that can match on both sides of the transfer. For instance,
you can specify extra include/exclude rules if there are
filename differences on the two sides that need to be <br>
accounted for.</p>

<p style="margin-top: 1em">When you pass an --iconv option
to an rsync daemon that allows it, the daemon uses the
charset specified in its &quot;charset&quot; configuration
parameter regardless of the remote <br>
charset you actually pass. Thus, you may feel free to
specify just the local charset for a daemon transfer (e.g.
--iconv=utf8).</p>

<p style="margin-top: 1em">-4, --ipv4 or -6, --ipv6 <br>
Tells rsync to prefer IPv4/IPv6 when creating sockets. This
only affects sockets that rsync has direct control over,
such as the outgoing socket when directly contacting <br>
an rsync daemon. See also these options in the --daemon mode
section.</p>

<p style="margin-top: 1em">If rsync was complied without
support for IPv6, the --ipv6 option will have no effect. The
--version output will tell you if this is the case.</p>

<p style="margin-top: 1em">--checksum-seed=NUM <br>
Set the checksum seed to the integer NUM. This 4 byte
checksum seed is included in each block and file checksum
calculation. By default the checksum seed is generated by
<br>
the server and defaults to the current time() . This option
is used to set a specific checksum seed, which is useful for
applications that want repeatable block and file <br>
checksums, or in the case where the user wants a more random
checksum seed. Setting NUM to 0 causes rsync to use the
default of time() for checksum seed.</p>

<p style="margin-top: 1em">DAEMON OPTIONS <br>
The options allowed when starting an rsync daemon are as
follows:</p>

<p style="margin-top: 1em">--daemon <br>
This tells rsync that it is to run as a daemon. The daemon
you start running may be accessed using an rsync client
using the host::module or rsync://host/module/ syntax.</p>

<p style="margin-top: 1em">If standard input is a socket
then rsync will assume that it is being run via inetd,
otherwise it will detach from the current terminal and
become a background daemon. <br>
The daemon will read the config file (rsyncd.conf) on each
connect made by a client and respond to requests
accordingly. See the rsyncd.conf(5) man page for more
details.</p>

<p style="margin-top: 1em">--address <br>
By default rsync will bind to the wildcard address when run
as a daemon with the --daemon option. The --address option
allows you to specify a specific IP address (or <br>
hostname) to bind to. This makes virtual hosting possible in
conjunction with the --config option. See also the
&quot;address&quot; global option in the rsyncd.conf
manpage.</p>

<p style="margin-top: 1em">--bwlimit=KBPS <br>
This option allows you to specify a maximum transfer rate in
kilobytes per second for the data the daemon sends. The
client can still specify a smaller --bwlimit value, <br>
but their requested value will be rounded down if they try
to exceed it. See the client version of this option (above)
for some extra details.</p>

<p style="margin-top: 1em">--config=FILE <br>
This specifies an alternate config file than the default.
This is only relevant when --daemon is specified. The
default is /etc/rsyncd.conf unless the daemon is running
<br>
over a remote shell program and the remote user is not the
super-user; in that case the default is rsyncd.conf in the
current directory (typically $HOME).</p>

<p style="margin-top: 1em">--no-detach <br>
When running as a daemon, this option instructs rsync to not
detach itself and become a background process. This option
is required when running as a service on Cygwin, <br>
and may also be useful when rsync is supervised by a program
such as daemontools or AIX&acirc;s System Resource
Controller. --no-detach is also recommended when rsync is
run <br>
under a debugger. This option has no effect if rsync is run
from inetd or sshd.</p>

<p style="margin-top: 1em">--port=PORT <br>
This specifies an alternate TCP port number for the daemon
to listen on rather than the default of 873. See also the
&quot;port&quot; global option in the rsyncd.conf
manpage.</p>

<p style="margin-top: 1em">--log-file=FILE <br>
This option tells the rsync daemon to use the given log-file
name instead of using the &quot;log file&quot; setting in
the config file.</p>

<p style="margin-top: 1em">--log-file-format=FORMAT <br>
This option tells the rsync daemon to use the given FORMAT
string instead of using the &quot;log format&quot; setting
in the config file. It also enables &quot;transfer
logging&quot; unless <br>
the string is empty, in which case transfer logging is
turned off.</p>

<p style="margin-top: 1em">--sockopts <br>
This overrides the socket options setting in the rsyncd.conf
file and has the same syntax.</p>

<p style="margin-top: 1em">-v, --verbose <br>
This option increases the amount of information the daemon
logs during its startup phase. After the client connects,
the daemon&acirc;s verbosity level will be controlled by
<br>
the options that the client used and the &quot;max
verbosity&quot; setting in the module&acirc;s config
section.</p>

<p style="margin-top: 1em">-4, --ipv4 or -6, --ipv6 <br>
Tells rsync to prefer IPv4/IPv6 when creating the incoming
sockets that the rsync daemon will use to listen for
connections. One of these options may be required in older
<br>
versions of Linux to work around an IPv6 bug in the kernel
(if you see an &quot;address already in use&quot; error when
nothing else is using the port, try specifying --ipv6 or
<br>
--ipv4 when starting the daemon).</p>

<p style="margin-top: 1em">If rsync was complied without
support for IPv6, the --ipv6 option will have no effect. The
--version output will tell you if this is the case.</p>

<p style="margin-top: 1em">-h, --help <br>
When specified after --daemon, print a short help page
describing the options available for starting an rsync
daemon.</p>

<p style="margin-top: 1em">FILTER RULES <br>
The filter rules allow for flexible selection of which files
to transfer (include) and which files to skip (exclude). The
rules either directly specify include/exclude patterns <br>
or they specify a way to acquire more include/exclude
patterns (e.g. to read them from a file).</p>

<p style="margin-top: 1em">As the list of files/directories
to transfer is built, rsync checks each name to be
transferred against the list of include/exclude patterns in
turn, and the first matching pat&acirc; <br>
tern is acted on: if it is an exclude pattern, then that
file is skipped; if it is an include pattern then that
filename is not skipped; if no matching pattern is found,
then <br>
the filename is not skipped.</p>

<p style="margin-top: 1em">Rsync builds an ordered list of
filter rules as specified on the command-line. Filter rules
have the following syntax:</p>

<p style="margin-top: 1em">RULE [PATTERN_OR_FILENAME] <br>
RULE,MODIFIERS [PATTERN_OR_FILENAME]</p>

<p style="margin-top: 1em">You have your choice of using
either short or long RULE names, as described below. If you
use a short-named rule, the &acirc;,&acirc; separating the
RULE from the MODIFIERS is optional. <br>
The PATTERN or FILENAME that follows (when present) must
come after either a single space or an underscore (_). Here
are the available rule prefixes:</p>

<p style="margin-top: 1em">exclude, - specifies an exclude
pattern. <br>
include, + specifies an include pattern. <br>
merge, . specifies a merge-file to read for more rules. <br>
dir-merge, : specifies a per-directory merge-file. <br>
hide, H specifies a pattern for hiding files from the
transfer. <br>
show, S files that match the pattern are not hidden. <br>
protect, P specifies a pattern for protecting files from
deletion. <br>
risk, R files that match the pattern are not protected. <br>
clear, ! clears the current include/exclude list (takes no
arg)</p>

<p style="margin-top: 1em">When rules are being read from a
file, empty lines are ignored, as are comment lines that
start with a &quot;#&quot;.</p>

<p style="margin-top: 1em">Note that the
--include/--exclude command-line options do not allow the
full range of rule parsing as described above -- they only
allow the specification of include/exclude pat&acirc; <br>
terns plus a &quot;!&quot; token to clear the list (and the
normal comment parsing when rules are read from a file). If
a pattern does not begin with &quot;- &quot; (dash, space)
or &quot;+ &quot; (plus, <br>
space), then the rule will be interpreted as if &quot;+
&quot; (for an include option) or &quot;- &quot; (for an
exclude option) were prefixed to the string. A --filter
option, on the other hand, <br>
must always contain either a short or long rule name at the
start of the rule.</p>

<p style="margin-top: 1em">Note also that the --filter,
--include, and --exclude options take one rule/pattern each.
To add multiple ones, you can repeat the options on the
command-line, use the merge-file <br>
syntax of the --filter option, or the
--include-from/--exclude-from options.</p>

<p style="margin-top: 1em">INCLUDE/EXCLUDE PATTERN RULES
<br>
You can include and exclude files by specifying patterns
using the &quot;+&quot;, &quot;-&quot;, etc. filter rules
(as introduced in the FILTER RULES section above). The
include/exclude rules each <br>
specify a pattern that is matched against the names of the
files that are going to be transferred. These patterns can
take several forms:</p>

<p style="margin-top: 1em">o if the pattern starts with a /
then it is anchored to a particular spot in the hierarchy of
files, otherwise it is matched against the end of the
pathname. This is simi&acirc; <br>
lar to a leading ^ in regular expressions. Thus
&quot;/foo&quot; would match a name of &quot;foo&quot; at
either the &quot;root of the transfer&quot; (for a global
rule) or in the merge-file&acirc;s direc&acirc; <br>
tory (for a per-directory rule). An unqualified
&quot;foo&quot; would match a name of &quot;foo&quot;
anywhere in the tree because the algorithm is applied
recursively from the top down; it <br>
behaves as if each path component gets a turn at being the
end of the filename. Even the unanchored &quot;sub/foo&quot;
would match at any point in the hierarchy where a
&quot;foo&quot; was <br>
found within a directory named &quot;sub&quot;. See the
section on ANCHORING INCLUDE/EXCLUDE PATTERNS for a full
discussion of how to specify a pattern that matches at the
root of <br>
the transfer.</p>

<p style="margin-top: 1em">o if the pattern ends with a /
then it will only match a directory, not a regular file,
symlink, or device.</p>

<p style="margin-top: 1em">o rsync chooses between doing a
simple string match and wildcard matching by checking if the
pattern contains one of these three wildcard characters:
&acirc;*&acirc;, &acirc;?&acirc;, and &acirc;[&acirc; .</p>

<p style="margin-top: 1em">o a &acirc;*&acirc; matches any
path component, but it stops at slashes.</p>

<p style="margin-top: 1em">o use &acirc;**&acirc; to match
anything, including slashes.</p>

<p style="margin-top: 1em">o a &acirc;?&acirc; matches any
character except a slash (/).</p>

<p style="margin-top: 1em">o a &acirc;[&acirc; introduces a
character class, such as [a-z] or [[:alpha:]].</p>

<p style="margin-top: 1em">o in a wildcard pattern, a
backslash can be used to escape a wildcard character, but it
is matched literally when no wildcards are present.</p>

<p style="margin-top: 1em">o if the pattern contains a /
(not counting a trailing /) or a &quot;**&quot;, then it is
matched against the full pathname, including any leading
directories. If the pattern doesn&acirc;t <br>
contain a / or a &quot;**&quot;, then it is matched only
against the final component of the filename. (Remember that
the algorithm is applied recursively so &quot;full
filename&quot; can <br>
actually be any portion of a path from the starting
directory on down.)</p>

<p style="margin-top: 1em">o a trailing
&quot;dir_name/***&quot; will match both the directory (as
if &quot;dir_name/&quot; had been specified) and everything
in the directory (as if &quot;dir_name/**&quot; had been
specified). <br>
This behavior was added in version 2.6.7.</p>

<p style="margin-top: 1em">Note that, when using the
--recursive (-r) option (which is implied by -a), every
subcomponent of every path is visited from the top down, so
include/exclude patterns get applied <br>
recursively to each subcomponent&acirc;s full name (e.g. to
include &quot;/foo/bar/baz&quot; the subcomponents
&quot;/foo&quot; and &quot;/foo/bar&quot; must not be
excluded). The exclude patterns actually <br>
short-circuit the directory traversal stage when rsync finds
the files to send. If a pattern excludes a particular parent
directory, it can render a deeper include pattern
inef&acirc; <br>
fectual because rsync did not descend through that excluded
section of the hierarchy. This is particularly important
when using a trailing &acirc;*&acirc; rule. For instance,
this won&acirc;t <br>
work:</p>

<p style="margin-top: 1em">+
/some/path/this-file-will-not-be-found <br>
+ /file-is-included <br>
- *</p>

<p style="margin-top: 1em">This fails because the parent
directory &quot;some&quot; is excluded by the
&acirc;*&acirc; rule, so rsync never visits any of the files
in the &quot;some&quot; or &quot;some/path&quot;
directories. One solution is to <br>
ask for all directories in the hierarchy to be included by
using a single rule: &quot;+ */&quot; (put it somewhere
before the &quot;- *&quot; rule), and perhaps use the
--prune-empty-dirs option. <br>
Another solution is to add specific include rules for all
the parent dirs that need to be visited. For instance, this
set of rules works fine:</p>

<p style="margin-top: 1em">+ /some/ <br>
+ /some/path/ <br>
+ /some/path/this-file-is-found <br>
+ /file-also-included <br>
- *</p>

<p style="margin-top: 1em">Here are some examples of
exclude/include matching:</p>

<p style="margin-top: 1em">o &quot;- *.o&quot; would
exclude all names matching *.o</p>

<p style="margin-top: 1em">o &quot;- /foo&quot; would
exclude a file (or directory) named foo in the transfer-root
directory</p>

<p style="margin-top: 1em">o &quot;- foo/&quot; would
exclude any directory named foo</p>

<p style="margin-top: 1em">o &quot;- /foo/*/bar&quot; would
exclude any file named bar which is at two levels below a
directory named foo in the transfer-root directory</p>

<p style="margin-top: 1em">o &quot;- /foo/**/bar&quot;
would exclude any file named bar two or more levels below a
directory named foo in the transfer-root directory</p>

<p style="margin-top: 1em">o The combination of &quot;+
*/&quot;, &quot;+ *.c&quot;, and &quot;- *&quot; would
include all directories and C source files but nothing else
(see also the --prune-empty-dirs option)</p>

<p style="margin-top: 1em">o The combination of &quot;+
foo/&quot;, &quot;+ foo/bar.c&quot;, and &quot;- *&quot;
would include only the foo directory and foo/bar.c (the foo
directory must be explicitly included or it would be <br>
excluded by the &quot;*&quot;)</p>

<p style="margin-top: 1em">The following modifiers are
accepted after a &quot;+&quot; or &quot;-&quot;:</p>

<p style="margin-top: 1em">o A / specifies that the
include/exclude rule should be matched against the absolute
pathname of the current item. For example, &quot;-/
/etc/passwd&quot; would exclude the passwd <br>
file any time the transfer was sending files from the
&quot;/etc&quot; directory, and &quot;-/ subdir/foo&quot;
would always exclude &quot;foo&quot; when it is in a dir
named &quot;subdir&quot;, even if &quot;foo&quot; is <br>
at the root of the current transfer.</p>

<p style="margin-top: 1em">o A ! specifies that the
include/exclude should take effect if the pattern fails to
match. For instance, &quot;-! */&quot; would exclude all
non-directories.</p>

<p style="margin-top: 1em">o A C is used to indicate that
all the global CVS-exclude rules should be inserted as
excludes in place of the &quot;-C&quot;. No arg should
follow.</p>

<p style="margin-top: 1em">o An s is used to indicate that
the rule applies to the sending side. When a rule affects
the sending side, it prevents files from being transferred.
The default is for a <br>
rule to affect both sides unless --delete-excluded was
specified, in which case default rules become sender-side
only. See also the hide (H) and show (S) rules, which are
<br>
an alternate way to specify sending-side
includes/excludes.</p>

<p style="margin-top: 1em">o An r is used to indicate that
the rule applies to the receiving side. When a rule affects
the receiving side, it prevents files from being deleted.
See the s modifier <br>
for more info. See also the protect (P) and risk (R) rules,
which are an alternate way to specify receiver-side
includes/excludes.</p>

<p style="margin-top: 1em">o A p indicates that a rule is
perishable, meaning that it is ignored in directories that
are being deleted. For instance, the -C option&acirc;s
default rules that exclude things <br>
like &quot;CVS&quot; and &quot;*.o&quot; are marked as
perishable, and will not prevent a directory that was
removed on the source from being deleted on the
destination.</p>

<p style="margin-top: 1em">MERGE-FILE FILTER RULES <br>
You can merge whole files into your filter rules by
specifying either a merge (.) or a dir-merge (:) filter rule
(as introduced in the FILTER RULES section above).</p>

<p style="margin-top: 1em">There are two kinds of merged
files -- single-instance (&acirc;.&acirc;) and per-directory
(&acirc;:&acirc;). A single-instance merge file is read one
time, and its rules are incorporated into the fil&acirc;
<br>
ter list in the place of the &quot;.&quot; rule. For
per-directory merge files, rsync will scan every directory
that it traverses for the named file, merging its contents
when the file <br>
exists into the current list of inherited rules. These
per-directory rule files must be created on the sending side
because it is the sending side that is being scanned for the
<br>
available files to transfer. These rule files may also need
to be transferred to the receiving side if you want them to
affect what files don&acirc;t get deleted (see PER-DIRECTORY
<br>
RULES AND DELETE below).</p>

<p style="margin-top: 1em">Some examples:</p>

<p style="margin-top: 1em">merge /etc/rsync/default.rules
<br>
. /etc/rsync/default.rules <br>
dir-merge .per-dir-filter <br>
dir-merge,n- .non-inherited-per-dir-excludes <br>
:n- .non-inherited-per-dir-excludes</p>

<p style="margin-top: 1em">The following modifiers are
accepted after a merge or dir-merge rule:</p>

<p style="margin-top: 1em">o A - specifies that the file
should consist of only exclude patterns, with no other
rule-parsing except for in-file comments.</p>

<p style="margin-top: 1em">o A + specifies that the file
should consist of only include patterns, with no other
rule-parsing except for in-file comments.</p>

<p style="margin-top: 1em">o A C is a way to specify that
the file should be read in a CVS-compatible manner. This
turns on &acirc;n&acirc;, &acirc;w&acirc;, and
&acirc;-&acirc;, but also allows the list-clearing token (!)
to be speci&acirc; <br>
fied. If no filename is provided, &quot;.cvsignore&quot; is
assumed.</p>

<p style="margin-top: 1em">o A e will exclude the
merge-file name from the transfer; e.g. &quot;dir-merge,e
.rules&quot; is like &quot;dir-merge .rules&quot; and
&quot;- .rules&quot;.</p>

<p style="margin-top: 1em">o An n specifies that the rules
are not inherited by subdirectories.</p>

<p style="margin-top: 1em">o A w specifies that the rules
are word-split on whitespace instead of the normal
line-splitting. This also turns off comments. Note: the
space that separates the prefix <br>
from the rule is treated specially, so &quot;- foo +
bar&quot; is parsed as two rules (assuming that
prefix-parsing wasn&acirc;t also disabled).</p>

<p style="margin-top: 1em">o You may also specify any of
the modifiers for the &quot;+&quot; or &quot;-&quot; rules
(above) in order to have the rules that are read in from the
file default to having that modifier set <br>
(except for the ! modifier, which would not be useful). For
instance, &quot;merge,-/ .excl&quot; would treat the
contents of .excl as absolute-path excludes, while
&quot;dir-merge,s <br>
.filt&quot; and &quot;:sC&quot; would each make all their
per-directory rules apply only on the sending side. If the
merge rule specifies sides to affect (via the s or r
modifier or <br>
both), then the rules in the file must not specify sides
(via a modifier or a rule prefix such as hide).</p>

<p style="margin-top: 1em">Per-directory rules are
inherited in all subdirectories of the directory where the
merge-file was found unless the &acirc;n&acirc; modifier was
used. Each subdirectory&acirc;s rules are prefixed <br>
to the inherited per-directory rules from its parents, which
gives the newest rules a higher priority than the inherited
rules. The entire set of dir-merge rules are grouped <br>
together in the spot where the merge-file was specified, so
it is possible to override dir-merge rules via a rule that
got specified earlier in the list of global rules. When <br>
the list-clearing rule (&quot;!&quot;) is read from a
per-directory file, it only clears the inherited rules for
the current merge file.</p>

<p style="margin-top: 1em">Another way to prevent a single
rule from a dir-merge file from being inherited is to anchor
it with a leading slash. Anchored rules in a per-directory
merge-file are relative <br>
to the merge-file&acirc;s directory, so a pattern
&quot;/foo&quot; would only match the file &quot;foo&quot;
in the directory where the dir-merge filter file was
found.</p>

<p style="margin-top: 1em">Here&acirc;s an example filter
file which you&acirc;d specify via --filter=&quot;.
file&quot;:</p>

<p style="margin-top: 1em">merge /home/user/.global-filter
<br>
- *.gz <br>
dir-merge .rules <br>
+ *.[ch] <br>
- *.o</p>

<p style="margin-top: 1em">This will merge the contents of
the /home/user/.global-filter file at the start of the list
and also turns the &quot;.rules&quot; filename into a
per-directory filter file. All rules read <br>
in prior to the start of the directory scan follow the
global anchoring rules (i.e. a leading slash matches at the
root of the transfer).</p>

<p style="margin-top: 1em">If a per-directory merge-file is
specified with a path that is a parent directory of the
first transfer directory, rsync will scan all the parent
dirs from that starting point to <br>
the transfer directory for the indicated per-directory file.
For instance, here is a common filter (see -F):</p>

<p style="margin-top: 1em">--filter=&rsquo;:
/.rsync-filter&rsquo;</p>

<p style="margin-top: 1em">That rule tells rsync to scan
for the file .rsync-filter in all directories from the root
down through the parent directory of the transfer prior to
the start of the normal <br>
directory scan of the file in the directories that are sent
as a part of the transfer. (Note: for an rsync daemon, the
root is always the same as the module&acirc;s
&quot;path&quot;.)</p>

<p style="margin-top: 1em">Some examples of this
pre-scanning for per-directory files:</p>

<p style="margin-top: 1em">rsync -avF /src/path/ /dest/dir
<br>
rsync -av --filter=&rsquo;: ../../.rsync-filter&rsquo;
/src/path/ /dest/dir <br>
rsync -av --filter=&rsquo;: .rsync-filter&rsquo; /src/path/
/dest/dir</p>

<p style="margin-top: 1em">The first two commands above
will look for &quot;.rsync-filter&quot; in &quot;/&quot; and
&quot;/src&quot; before the normal scan begins looking for
the file in &quot;/src/path&quot; and its subdirectories.
The last <br>
command avoids the parent-dir scan and only looks for the
&quot;.rsync-filter&quot; files in each directory that is a
part of the transfer.</p>

<p style="margin-top: 1em">If you want to include the
contents of a &quot;.cvsignore&quot; in your patterns, you
should use the rule &quot;:C&quot;, which creates a
dir-merge of the .cvsignore file, but parsed in a
CVS-com&acirc; <br>
patible manner. You can use this to affect where the
--cvs-exclude (-C) option&acirc;s inclusion of the
per-directory .cvsignore file gets placed into your rules by
putting the &quot;:C&quot; <br>
wherever you like in your filter rules. Without this, rsync
would add the dir-merge rule for the .cvsignore file at the
end of all your other rules (giving it a lower priority <br>
than your command-line rules). For example:</p>

<p style="margin-top: 1em">cat &lt;&lt;EOT | rsync -avC
--filter=&rsquo;. -&rsquo; a/ b <br>
+ foo.o <br>
:C <br>
- *.old <br>
EOT <br>
rsync -avC --include=foo.o -f :C
--exclude=&rsquo;*.old&rsquo; a/ b</p>

<p style="margin-top: 1em">Both of the above rsync commands
are identical. Each one will merge all the per-directory
.cvsignore rules in the middle of the list rather than at
the end. This allows their <br>
dir-specific rules to supersede the rules that follow the :C
instead of being subservient to all your rules. To affect
the other CVS exclude rules (i.e. the default list of <br>
exclusions, the contents of $HOME/.cvsignore, and the value
of $CVSIGNORE) you should omit the -C command-line option
and instead insert a &quot;-C&quot; rule into your filter
rules; e.g. <br>
&quot;--filter=-C&quot;.</p>

<p style="margin-top: 1em">LIST-CLEARING FILTER RULE <br>
You can clear the current include/exclude list by using the
&quot;!&quot; filter rule (as introduced in the FILTER RULES
section above). The &quot;current&quot; list is either the
global list of <br>
rules (if the rule is encountered while parsing the filter
options) or a set of per-directory rules (which are
inherited in their own sub-list, so a subdirectory can use
this to <br>
clear out the parent&acirc;s rules).</p>

<p style="margin-top: 1em">ANCHORING INCLUDE/EXCLUDE
PATTERNS <br>
As mentioned earlier, global include/exclude patterns are
anchored at the &quot;root of the transfer&quot; (as opposed
to per-directory patterns, which are anchored at the
merge-file&acirc;s <br>
directory). If you think of the transfer as a subtree of
names that are being sent from sender to receiver, the
transfer-root is where the tree starts to be duplicated in
the <br>
destination directory. This root governs where patterns that
start with a / match.</p>

<p style="margin-top: 1em">Because the matching is relative
to the transfer-root, changing the trailing slash on a
source path or changing your use of the --relative option
affects the path you need to use <br>
in your matching (in addition to changing how much of the
file tree is duplicated on the destination host). The
following examples demonstrate this.</p>

<p style="margin-top: 1em">Let&acirc;s say that we want to
match two source files, one with an absolute path of
&quot;/home/me/foo/bar&quot;, and one with a path of
&quot;/home/you/bar/baz&quot;. Here is how the various
command <br>
choices differ for a 2-source transfer:</p>

<p style="margin-top: 1em">Example cmd: rsync -a /home/me
/home/you /dest <br>
+/- pattern: /me/foo/bar <br>
+/- pattern: /you/bar/baz <br>
Target file: /dest/me/foo/bar <br>
Target file: /dest/you/bar/baz</p>

<p style="margin-top: 1em">Example cmd: rsync -a /home/me/
/home/you/ /dest <br>
+/- pattern: /foo/bar (note missing &quot;me&quot;) <br>
+/- pattern: /bar/baz (note missing &quot;you&quot;) <br>
Target file: /dest/foo/bar <br>
Target file: /dest/bar/baz</p>

<p style="margin-top: 1em">Example cmd: rsync -a --relative
/home/me/ /home/you /dest <br>
+/- pattern: /home/me/foo/bar (note full path) <br>
+/- pattern: /home/you/bar/baz (ditto) <br>
Target file: /dest/home/me/foo/bar <br>
Target file: /dest/home/you/bar/baz</p>

<p style="margin-top: 1em">Example cmd: cd /home; rsync -a
--relative me/foo you/ /dest <br>
+/- pattern: /me/foo/bar (starts at specified path) <br>
+/- pattern: /you/bar/baz (ditto) <br>
Target file: /dest/me/foo/bar <br>
Target file: /dest/you/bar/baz</p>

<p style="margin-top: 1em">The easiest way to see what name
you should filter is to just look at the output when using
--verbose and put a / in front of the name (use the
--dry-run option if you&acirc;re not yet <br>
ready to copy any files).</p>

<p style="margin-top: 1em">PER-DIRECTORY RULES AND DELETE
<br>
Without a delete option, per-directory rules are only
relevant on the sending side, so you can feel free to
exclude the merge files themselves without affecting the
transfer. To <br>
make this easy, the &acirc;e&acirc; modifier adds this
exclude for you, as seen in these two equivalent
commands:</p>

<p style="margin-top: 1em">rsync -av --filter=&rsquo;:
.excl&rsquo; --exclude=.excl host:src/dir /dest <br>
rsync -av --filter=&rsquo;:e .excl&rsquo; host:src/dir
/dest</p>

<p style="margin-top: 1em">However, if you want to do a
delete on the receiving side AND you want some files to be
excluded from being deleted, you&acirc;ll need to be sure
that the receiving side knows what <br>
files to exclude. The easiest way is to include the
per-directory merge files in the transfer and use
--delete-after, because this ensures that the receiving side
gets all the <br>
same exclude rules as the sending side before it tries to
delete anything:</p>

<p style="margin-top: 1em">rsync -avF --delete-after
host:src/dir /dest</p>

<p style="margin-top: 1em">However, if the merge files are
not a part of the transfer, you&acirc;ll need to either
specify some global exclude rules (i.e. specified on the
command line), or you&acirc;ll need to main&acirc; <br>
tain your own per-directory merge files on the receiving
side. An example of the first is this (assume that the
remote .rules files exclude themselves):</p>

<p style="margin-top: 1em">rsync -av --filter=&acirc;:
.rules&acirc; --filter=&acirc;. /my/extra.rules&acirc; <br>
--delete host:src/dir /dest</p>

<p style="margin-top: 1em">In the above example the
extra.rules file can affect both sides of the transfer, but
(on the sending side) the rules are subservient to the rules
merged from the .rules files <br>
because they were specified after the per-directory merge
rule.</p>

<p style="margin-top: 1em">In one final example, the remote
side is excluding the .rsync-filter files from the transfer,
but we want to use our own .rsync-filter files to control
what gets deleted on the <br>
receiving side. To do this we must specifically exclude the
per-directory merge files (so that they don&acirc;t get
deleted) and then put rules into the local files to control
what <br>
else should not get deleted. Like one of these commands:</p>

<p style="margin-top: 1em">rsync -av --filter=&rsquo;:e
/.rsync-filter&rsquo; --delete host:src/dir /dest <br>
rsync -avFF --delete host:src/dir /dest</p>

<p style="margin-top: 1em">BATCH MODE <br>
Batch mode can be used to apply the same set of updates to
many identical systems. Suppose one has a tree which is
replicated on a number of hosts. Now suppose some changes
have <br>
been made to this source tree and those changes need to be
propagated to the other hosts. In order to do this using
batch mode, rsync is run with the write-batch option to
apply <br>
the changes made to the source tree to one of the
destination trees. The write-batch option causes the rsync
client to store in a &quot;batch file&quot; all the
information needed to <br>
repeat this operation against other, identical destination
trees.</p>

<p style="margin-top: 1em">Generating the batch file once
saves having to perform the file status, checksum, and data
block generation more than once when updating multiple
destination trees. Multicast <br>
transport protocols can be used to transfer the batch update
files in parallel to many hosts at once, instead of sending
the same data to every host individually.</p>

<p style="margin-top: 1em">To apply the recorded changes to
another destination tree, run rsync with the read-batch
option, specifying the name of the same batch file, and the
destination tree. Rsync <br>
updates the destination tree using the information stored in
the batch file.</p>

<p style="margin-top: 1em">For your convenience, a script
file is also created when the write-batch option is used: it
will be named the same as the batch file with
&quot;.sh&quot; appended. This script file con&acirc; <br>
tains a command-line suitable for updating a destination
tree using the associated batch file. It can be executed
using a Bourne (or Bourne-like) shell, optionally passing in
an <br>
alternate destination tree pathname which is then used
instead of the original destination path. This is useful
when the destination tree path on the current host differs
from <br>
the one used to create the batch file.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">$ rsync --write-batch=foo -a
host:/source/dir/ /adest/dir/ <br>
$ scp foo* remote: <br>
$ ssh remote ./foo.sh /bdest/dir/</p>

<p style="margin-top: 1em">$ rsync --write-batch=foo -a
/source/dir/ /adest/dir/ <br>
$ ssh remote rsync --read-batch=- -a /bdest/dir/ &lt;foo</p>

<p style="margin-top: 1em">In these examples, rsync is used
to update /adest/dir/ from /source/dir/ and the information
to repeat this operation is stored in &quot;foo&quot; and
&quot;foo.sh&quot;. The host &quot;remote&quot; is then <br>
updated with the batched data going into the directory
/bdest/dir. The differences between the two examples reveals
some of the flexibility you have in how you deal with <br>
batches:</p>

<p style="margin-top: 1em">o The first example shows that
the initial copy doesn&acirc;t have to be local -- you can
push or pull data to/from a remote host using either the
remote-shell syntax or rsync <br>
daemon syntax, as desired.</p>

<p style="margin-top: 1em">o The first example uses the
created &quot;foo.sh&quot; file to get the right rsync
options when running the read-batch command on the remote
host.</p>

<p style="margin-top: 1em">o The second example reads the
batch data via standard input so that the batch file
doesn&acirc;t need to be copied to the remote machine first.
This example avoids the foo.sh <br>
script because it needed to use a modified --read-batch
option, but you could edit the script file if you wished to
make use of it (just be sure that no other option is <br>
trying to use standard input, such as the
&quot;--exclude-from=-&quot; option).</p>

<p style="margin-top: 1em">Caveats:</p>

<p style="margin-top: 1em">The read-batch option expects
the destination tree that it is updating to be identical to
the destination tree that was used to create the batch
update fileset. When a differ&acirc; <br>
ence between the destination trees is encountered the update
might be discarded with a warning (if the file appears to be
up-to-date already) or the file-update may be attempted <br>
and then, if the file fails to verify, the update discarded
with an error. This means that it should be safe to re-run a
read-batch operation if the command got interrupted. If <br>
you wish to force the batched-update to always be attempted
regardless of the file&acirc;s size and date, use the -I
option (when reading the batch). If an error occurs, the
destina&acirc; <br>
tion tree will probably be in a partially updated state. In
that case, rsync can be used in its regular (non-batch) mode
of operation to fix up the destination tree.</p>

<p style="margin-top: 1em">The rsync version used on all
destinations must be at least as new as the one used to
generate the batch file. Rsync will die with an error if the
protocol version in the batch <br>
file is too new for the batch-reading rsync to handle. See
also the --protocol option for a way to have the creating
rsync generate a batch file that an older rsync can
under&acirc; <br>
stand. (Note that batch files changed format in version
2.6.3, so mixing versions older than that with newer
versions will not work.)</p>

<p style="margin-top: 1em">When reading a batch file, rsync
will force the value of certain options to match the data in
the batch file if you didn&acirc;t set them to the same as
the batch-writing command. <br>
Other options can (and should) be changed. For instance
--write-batch changes to --read-batch, --files-from is
dropped, and the --filter/--include/--exclude options are
not <br>
needed unless one of the --delete options is specified.</p>

<p style="margin-top: 1em">The code that creates the
BATCH.sh file transforms any filter/include/exclude options
into a single list that is appended as a &quot;here&quot;
document to the shell script file. An <br>
advanced user can use this to modify the exclude list if a
change in what gets deleted by --delete is desired. A normal
user can ignore this detail and just use the shell script
<br>
as an easy way to run the appropriate --read-batch command
for the batched data.</p>

<p style="margin-top: 1em">The original batch mode in rsync
was based on &quot;rsync+&quot;, but the latest version uses
a new implementation.</p>

<p style="margin-top: 1em">SYMBOLIC LINKS <br>
Three basic behaviors are possible when rsync encounters a
symbolic link in the source directory.</p>

<p style="margin-top: 1em">By default, symbolic links are
not transferred at all. A message &quot;skipping
non-regular&quot; file is emitted for any symlinks that
exist.</p>

<p style="margin-top: 1em">If --links is specified, then
symlinks are recreated with the same target on the
destination. Note that --archive implies --links.</p>

<p style="margin-top: 1em">If --copy-links is specified,
then symlinks are &quot;collapsed&quot; by copying their
referent, rather than the symlink.</p>

<p style="margin-top: 1em">Rsync can also distinguish
&quot;safe&quot; and &quot;unsafe&quot; symbolic links. An
example where this might be used is a web site mirror that
wishes to ensure that the rsync module that is <br>
copied does not include symbolic links to /etc/passwd in the
public section of the site. Using --copy-unsafe-links will
cause any links to be copied as the file they point to on
<br>
the destination. Using --safe-links will cause unsafe links
to be omitted altogether. (Note that you must specify
--links for --safe-links to have any effect.)</p>

<p style="margin-top: 1em">Symbolic links are considered
unsafe if they are absolute symlinks (start with /), empty,
or if they contain enough &quot;..&quot; components to
ascend from the directory being copied.</p>

<p style="margin-top: 1em">Here&acirc;s a summary of how
the symlink options are interpreted. The list is in order of
precedence, so if your combination of options isn&acirc;t
mentioned, use the first line that is a <br>
complete subset of your options:</p>

<p style="margin-top: 1em">--copy-links <br>
Turn all symlinks into normal files (leaving no symlinks for
any other options to affect).</p>

<p style="margin-top: 1em">--links --copy-unsafe-links <br>
Turn all unsafe symlinks into files and duplicate all safe
symlinks.</p>

<p style="margin-top: 1em">--copy-unsafe-links <br>
Turn all unsafe symlinks into files, noisily skip all safe
symlinks.</p>

<p style="margin-top: 1em">--links --safe-links <br>
Duplicate safe symlinks and skip unsafe ones.</p>

<p style="margin-top: 1em">--links <br>
Duplicate all symlinks.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
rsync occasionally produces error messages that may seem a
little cryptic. The one that seems to cause the most
confusion is &quot;protocol version mismatch -- is your
shell clean?&quot;.</p>

<p style="margin-top: 1em">This message is usually caused
by your startup scripts or remote shell facility producing
unwanted garbage on the stream that rsync is using for its
transport. The way to diag&acirc; <br>
nose this problem is to run your remote shell like this:</p>

<p style="margin-top: 1em">ssh remotehost /bin/true &gt;
out.dat</p>

<p style="margin-top: 1em">then look at out.dat. If
everything is working correctly then out.dat should be a
zero length file. If you are getting the above error from
rsync then you will probably find that <br>
out.dat contains some text or data. Look at the contents and
try to work out what is producing it. The most common cause
is incorrectly configured shell startup scripts (such as
<br>
.cshrc or .profile) that contain output statements for
non-interactive logins.</p>

<p style="margin-top: 1em">If you are having trouble
debugging filter patterns, then try specifying the -vv
option. At this level of verbosity rsync will show why each
individual file is included or <br>
excluded.</p>

<p style="margin-top: 1em">EXIT VALUES <br>
0 Success</p>

<p style="margin-top: 1em">1 Syntax or usage error</p>

<p style="margin-top: 1em">2 Protocol incompatibility</p>

<p style="margin-top: 1em">3 Errors selecting input/output
files, dirs</p>

<p style="margin-top: 1em">4 Requested action not
supported: an attempt was made to manipulate 64-bit files on
a platform that cannot support them; or an option was
specified that is supported by the <br>
client and not by the server.</p>

<p style="margin-top: 1em">5 Error starting client-server
protocol</p>

<p style="margin-top: 1em">6 Daemon unable to append to
log-file</p>

<p style="margin-top: 1em">10 Error in socket I/O</p>

<p style="margin-top: 1em">11 Error in file I/O</p>

<p style="margin-top: 1em">12 Error in rsync protocol data
stream</p>

<p style="margin-top: 1em">13 Errors with program
diagnostics</p>

<p style="margin-top: 1em">14 Error in IPC code</p>

<p style="margin-top: 1em">20 Received SIGUSR1 or
SIGINT</p>

<p style="margin-top: 1em">21 Some error returned by
waitpid()</p>

<p style="margin-top: 1em">22 Error allocating core memory
buffers</p>

<p style="margin-top: 1em">23 Partial transfer due to
error</p>

<p style="margin-top: 1em">24 Partial transfer due to
vanished source files</p>

<p style="margin-top: 1em">25 The --max-delete limit
stopped deletions</p>

<p style="margin-top: 1em">30 Timeout in data
send/receive</p>

<p style="margin-top: 1em">35 Timeout waiting for daemon
connection</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
CVSIGNORE <br>
The CVSIGNORE environment variable supplements any ignore
patterns in .cvsignore files. See the --cvs-exclude option
for more details.</p>

<p style="margin-top: 1em">RSYNC_ICONV <br>
Specify a default --iconv setting using this environment
variable. (First supported in 3.0.0.)</p>

<p style="margin-top: 1em">RSYNC_RSH <br>
The RSYNC_RSH environment variable allows you to override
the default shell used as the transport for rsync. Command
line options are permitted after the command name, <br>
just as in the -e option.</p>

<p style="margin-top: 1em">RSYNC_PROXY <br>
The RSYNC_PROXY environment variable allows you to redirect
your rsync client to use a web proxy when connecting to a
rsync daemon. You should set RSYNC_PROXY to a host&acirc;
<br>
name:port pair.</p>

<p style="margin-top: 1em">RSYNC_PASSWORD <br>
Setting RSYNC_PASSWORD to the required password allows you
to run authenticated rsync connections to an rsync daemon
without user intervention. Note that this does not <br>
supply a password to a remote shell transport such as ssh;
to learn how to do that, consult the remote shell&acirc;s
documentation.</p>

<p style="margin-top: 1em">USER or LOGNAME <br>
The USER or LOGNAME environment variables are used to
determine the default username sent to an rsync daemon. If
neither is set, the username defaults to
&quot;nobody&quot;.</p>

<p style="margin-top: 1em">HOME The HOME environment
variable is used to find the user&acirc;s default .cvsignore
file.</p>

<p style="margin-top: 1em">FILES <br>
/etc/rsyncd.conf or rsyncd.conf</p>

<p style="margin-top: 1em">SEE ALSO <br>
rsyncd.conf(5)</p>

<p style="margin-top: 1em">BUGS <br>
times are transferred as *nix time_t values</p>

<p style="margin-top: 1em">When transferring to FAT
filesystems rsync may re-sync unmodified files. See the
comments on the --modify-window option.</p>

<p style="margin-top: 1em">file permissions, devices, etc.
are transferred as native numerical values</p>

<p style="margin-top: 1em">see also the comments on the
--delete option</p>

<p style="margin-top: 1em">Please report bugs! See the web
site at http://rsync.samba.org/</p>

<p style="margin-top: 1em">VERSION <br>
This man page is current for version 3.0.9 of rsync.</p>

<p style="margin-top: 1em">INTERNAL OPTIONS <br>
The options --server and --sender are used internally by
rsync, and should never be typed by a user under normal
circumstances. Some awareness of these options may be needed
in <br>
certain scenarios, such as when setting up a login that can
only run an rsync command. For instance, the support
directory of the rsync distribution has an example script
named <br>
rrsync (for restricted rsync) that can be used with a
restricted ssh login.</p>

<p style="margin-top: 1em">CREDITS <br>
rsync is distributed under the GNU public license. See the
file COPYING for details.</p>

<p style="margin-top: 1em">A WEB site is available at
http://rsync.samba.org/. The site includes an FAQ-O-Matic
which may cover questions unanswered by this manual
page.</p>

<p style="margin-top: 1em">The primary ftp site for rsync
is ftp://rsync.samba.org/pub/rsync.</p>

<p style="margin-top: 1em">We would be delighted to hear
from you if you like this program. Please contact the
mailing-list at rsync@lists.samba.org.</p>

<p style="margin-top: 1em">This program uses the excellent
zlib compression library written by Jean-loup Gailly and
Mark Adler.</p>

<p style="margin-top: 1em">THANKS <br>
Special thanks go out to: John Van Essen, Matt McCutchen,
Wesley W. Terpstra, David Dykstra, Jos Backus, Sebastian
Krahmer, Martin Pool, and our gone-but-not-forgotten
compadre, <br>
J.W. Schultz.</p>

<p style="margin-top: 1em">Thanks also to Richard Brent,
Brendan Mackay, Bill Waite, Stephen Rothwell and David Bell.
I&acirc;ve probably missed some people, my apologies if I
have.</p>

<p style="margin-top: 1em">AUTHOR <br>
rsync was originally written by Andrew Tridgell and Paul
Mackerras. Many people have later contributed to it. It is
currently maintained by Wayne Davison.</p>

<p style="margin-top: 1em">Mailing lists for support and
development are available at http://lists.samba.org</p>

<p style="margin-top: 1em">23 Sep 2011 rsync(1)</p>
<hr>
</body>
</html>
