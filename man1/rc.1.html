<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:35:05 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>RC(1) General Commands Manual RC(1)</p>

<p style="margin-top: 1em">NAME <br>
rc - shell</p>

<p style="margin-top: 1em">SYNOPSIS <br>
rc [-deiIlnopsvx] [-c command] [arguments]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
rc is a command interpreter and programming language similar
to sh(1). It is based on the AT&amp;T Plan 9 shell of the
same name. The shell offers a C-like syntax (much more so
<br>
than the C shell), and a powerful mechanism for manipulating
variables. It is reasonably small and reasonably fast,
especially when compared to contemporary shells. Its use is
<br>
intended to be interactive, but the language lends itself
well to scripts.</p>

<p style="margin-top: 1em">OPTIONS <br>
-c If -c is present, commands are executed from the
immediately following argument. Any further arguments to rc
are placed in $*. Thus:</p>

<p style="margin-top: 1em">rc -c &rsquo;echo $*&rsquo; 1 2
3</p>

<p style="margin-top: 1em">prints out</p>

<p style="margin-top: 1em">1 2 3</p>

<p style="margin-top: 1em">-d This flag causes rc not to
ignore SIGQUIT or SIGTERM. Thus rc can be made to dump core
if sent SIGQUIT. This flag is only useful for debugging
rc.</p>

<p style="margin-top: 1em">-e If the -e flag is present,
then rc will exit if the exit status of a command is false
(nonzero). rc will not exit, however, if a conditional
fails, e.g., an if() command.</p>

<p style="margin-top: 1em">-i If the -i flag is present or
if the input to rc is from a terminal (as determined by
isatty(3)) then rc will be in interactive mode. That is, a
prompt (from $prompt(1)) <br>
will be printed before an input line is taken, and rc will
ignore SIGINT.</p>

<p style="margin-top: 1em">-I If the -I flag is present, or
if the input to rc is not from a terminal, then rc will not
be in interactive mode. No prompts will be printed, and
SIGINT will cause rc to <br>
exit.</p>

<p style="margin-top: 1em">-l If the -l flag is present, or
if rc&rsquo;s argv[0][0] is a dash (-), then rc will behave
as a login shell. That is, it will run commands from
$home/.rcrc, if this file exists, <br>
before reading any other input.</p>

<p style="margin-top: 1em">-n This flag causes rc to read
its input and parse it, but not to execute any commands.
This is useful for syntax checking on scripts. If used in
combination with the -x <br>
flag, rc will print each command as it is parsed in a form
similar to the one used for exporting functions into the
environment.</p>

<p style="margin-top: 1em">-o This flag prevents the usual
practice of trying to open /dev/null on file descriptors 0,
1, and 2, if any of those descriptors are inherited
closed.</p>

<p style="margin-top: 1em">-p This flag prevents rc from
initializing shell functions from the environment. This
allows rc to run in a protected mode, whereby it becomes
more difficult for an rc <br>
script to be subverted by placing false commands in the
environment. (Note that the presence of this flag does not
mean that it is safe to run setuid rc scripts; the <br>
usual caveats about the setuid bit still apply.)</p>

<p style="margin-top: 1em">-s This flag causes rc to read
from standard input. Any arguments are placed in $*.</p>

<p style="margin-top: 1em">-v This flag causes rc to echo
its input to standard error as it is read.</p>

<p style="margin-top: 1em">-x This flag causes rc to print
every command on standard error before it is executed. It
can be useful for debugging rc scripts.</p>

<p style="margin-top: 1em">COMMANDS <br>
A simple command is a sequence of words, separated by white
space (space and tab) characters that ends with a newline,
semicolon (;), or ampersand (&amp;). The first word of a
com&acirc; <br>
mand is the name of that command. If the name begins with /,
./, or ../, then the name is used as an absolute path name
referring to an executable file. Otherwise, the name of <br>
the command is looked up in a table of shell functions,
builtin commands, or as a file in the directories named by
$path.</p>

<p style="margin-top: 1em">Background Tasks <br>
A command ending with &amp; is run in the background; that
is, the shell returns immediately rather than waiting for
the command to complete. Background commands have /dev/null
con&acirc; <br>
nected to their standard input unless an explicit
redirection for standard input is used.</p>

<p style="margin-top: 1em">Subshells <br>
A command prefixed with an at-sign (@) is executed in a
subshell. This insulates the parent shell from the effects
of state changing operations such as a cd or a variable <br>
assignment. For example:</p>

<p style="margin-top: 1em">@ {cd ..; make}</p>

<p style="margin-top: 1em">will run make(1) in the parent
directory (..), but leaves the shell running in the current
directory.</p>

<p style="margin-top: 1em">Line continuation <br>
A long logical line may be continued over several physical
lines by terminating each line (except the last) with a
backslash (. The backslash-newline sequence is treated as a
<br>
space. A backslash is not otherwise special to rc. (In
addition, inside quotes a backslash loses its special
meaning even when it is followed by a newline.)</p>

<p style="margin-top: 1em">Quoting <br>
rc interprets several characters specially; special
characters automatically terminate words. The following
characters are special:</p>

<p style="margin-top: 1em"># ; &amp; | ^ $ = &lsquo;
&rsquo; { } ( ) &lt; &gt;</p>

<p style="margin-top: 1em">The single quote (&rsquo;)
prevents special treatment of any character other than
itself. All characters, including control characters,
newlines, and backslashes between two quote <br>
characters are treated as an uninterpreted string. A quote
character itself may be quoted by placing two quotes in a
row. The minimal sequence needed to enter the quote
charac&acirc; <br>
ter is &rsquo;&rsquo;&rsquo;&rsquo;. The empty string is
represented by &rsquo;&rsquo;. Thus:</p>

<p style="margin-top: 1em">echo &rsquo;What&rsquo;&rsquo;s
the plan, Stan?&rsquo;</p>

<p style="margin-top: 1em">prints out</p>

<p style="margin-top: 1em">What&rsquo;s the plan, Stan?</p>

<p style="margin-top: 1em">The number sign (#) begins a
comment in rc. All characters up to but not including the
next newline are ignored. Note that backslash continuation
does not work inside a com&acirc; <br>
ment, i.e., the backslash is ignored along with everything
else.</p>

<p style="margin-top: 1em">Grouping <br>
Zero or more commands may be grouped within braces
(&lsquo;&lsquo;{&rsquo;&rsquo; and
&lsquo;&lsquo;}&rsquo;&rsquo;), and are then treated as one
command. Braces do not otherwise define scope; they are used
only for command <br>
grouping. In particular, be wary of the command:</p>

<p style="margin-top: 1em">for (i) { <br>
command <br>
} | command</p>

<p style="margin-top: 1em">Since pipe binds tighter than
for, this command does not perform what the user expects it
to. Instead, enclose the whole for statement in braces:</p>

<p style="margin-top: 1em">{for (i) command} | command</p>

<p style="margin-top: 1em">Fortunately, rc&rsquo;s grammar
is simple enough that a (confident) user can understand it
by examining the skeletal yacc(1) grammar at the end of this
man page (see the section enti&acirc; <br>
tled GRAMMAR).</p>

<p style="margin-top: 1em">Input and output <br>
The standard output may be redirected to a file with</p>

<p style="margin-top: 1em">command &gt; file</p>

<p style="margin-top: 1em">and the standard input may be
taken from a file with</p>

<p style="margin-top: 1em">command &lt; file</p>

<p style="margin-top: 1em">Redirections can appear anywhere
in the line: the word following the redirection symbol is
the filename and must be quoted if it contains spaces or
other special characters. <br>
These are all equivalent.</p>

<p style="margin-top: 1em">echo 1 2 3 &gt; foo <br>
&gt; foo echo 1 2 3 <br>
echo 1 2 &gt; foo 3</p>

<p style="margin-top: 1em">File descriptors other than 0
and 1 may be specified also. For example, to redirect
standard error to a file, use:</p>

<p style="margin-top: 1em">command &gt;[2] file</p>

<p style="margin-top: 1em">In order to duplicate a file
descriptor, use &gt;[n=m]. Thus to redirect both standard
output and standard error to the same file, use</p>

<p style="margin-top: 1em">command &gt; file &gt;[2=1]</p>

<p style="margin-top: 1em">As in sh, redirections are
processed from left to right. Thus this sequence</p>

<p style="margin-top: 1em">command &gt;[2=1] &gt; file</p>

<p style="margin-top: 1em">is usually a mistake. It first
duplicates standard error to standard output; then redirects
standard output to a file, leaving standard error wherever
standard output originally <br>
was.</p>

<p style="margin-top: 1em">To close a file descriptor that
may be open, use &gt;[n=]. For example, to close file
descriptor 7:</p>

<p style="margin-top: 1em">command &gt;[7=]</p>

<p style="margin-top: 1em">Note that no spaces may appear
in these constructs:</p>

<p style="margin-top: 1em">command &gt; [2] file</p>

<p style="margin-top: 1em">would send the output of the
command to a file named [2], with the intended filename
appearing in the command&rsquo;s argument list.</p>

<p style="margin-top: 1em">In order to place the output of
a command at the end of an already existing file, use:</p>

<p style="margin-top: 1em">command &gt;&gt; file</p>

<p style="margin-top: 1em">If the file does not exist, then
it is created.</p>

<p style="margin-top: 1em">&lsquo;&lsquo;Here
documents&rsquo;&rsquo; are supported as in sh with the use
of</p>

<p style="margin-top: 1em">command &lt;&lt;
&rsquo;eof-marker&rsquo;</p>

<p style="margin-top: 1em">Subsequent lines form the
standard input of the command, till a line containing just
the marker, in this case eof-marker, is encountered.</p>

<p style="margin-top: 1em">If the end-of-file marker is
enclosed in quotes, then no variable substitution occurs
inside the here document. Otherwise, every variable is
substituted by its space-separated- <br>
list value (see Flat Lists, below), and if a ^ character
follows a variable name, it is deleted. This allows the
unambiguous use of variables adjacent to text, as in</p>

<p style="margin-top: 1em">$variable^follow</p>

<p style="margin-top: 1em">To include a literal $ in a here
document when an unquoted end-of-file marker is being used,
enter it as $$.</p>

<p style="margin-top: 1em">Additionally, rc supports
&lsquo;&lsquo;here strings&rsquo;&rsquo;, which are like
here documents, except that input is taken directly from a
string on the command line. Their use is illustrated
here:</p>

<p style="margin-top: 1em">cat &lt;&lt;&lt; &rsquo;this is
a here string&rsquo; | wc</p>

<p style="margin-top: 1em">(This feature enables rc to
export functions using here documents into the environment;
the author does not expect users to find this feature
useful.)</p>

<p style="margin-top: 1em">Pipes <br>
Two or more commands may be combined in a pipeline by
placing the vertical bar (|) between them. The standard
output (file descriptor 1) of the command on the left is
tied to <br>
the standard input (file descriptor 0) of the command on the
right. The notation |[n=m] indicates that file descriptor n
of the left process is connected to file descriptor m of
<br>
the right process. |[n] is a shorthand for |[n=0]. As an
example, to pipe the standard error of a command to wc(1),
use:</p>

<p style="margin-top: 1em">command |[2] wc</p>

<p style="margin-top: 1em">As with file redirections, no
spaces may occur in the construct specifying numbered file
descriptors.</p>

<p style="margin-top: 1em">The exit status of a pipeline is
considered true if and only if every command in the pipeline
exits true.</p>

<p style="margin-top: 1em">Commands as Arguments <br>
Some commands, like cmp(1) or diff(1), take their arguments
on the command line, and do not read input from standard
input. It is convenient sometimes to build nonlinear
pipe&acirc; <br>
lines so that a command like cmp can read the output of two
other commands at once. rc does it like this:</p>

<p style="margin-top: 1em">cmp &lt;{command}
&lt;{command}</p>

<p style="margin-top: 1em">compares the output of the two
commands in braces. Note: since this form of redirection is
implemented with some kind of pipe, and since one cannot
lseek(2) on a pipe, commands <br>
that use lseek(2) will hang. For example, some versions of
diff(1) use lseek(2) on their inputs.</p>

<p style="margin-top: 1em">Data can be sent down a pipe to
several commands using tee(1) and the output version of this
notation:</p>

<p style="margin-top: 1em">echo hi there | tee &gt;{sed
&rsquo;s/^/p1 /&rsquo;} &gt;{sed &rsquo;s/^/p2 /&rsquo;}</p>

<p style="margin-top: 1em">CONTROL STRUCTURES <br>
The following may be used for control flow in rc:</p>

<p style="margin-top: 1em">If-Else Statements <br>
if (test) { <br>
cmd <br>
} else cmd <br>
The test is executed, and if its return status is zero, the
first command is executed, otherwise the second is. Braces
are not mandatory around the commands. However, an <br>
else statement is valid only if it follows a close-brace on
the same line. Otherwise, the if is taken to be a
simple-if:</p>

<p style="margin-top: 1em">if (test) <br>
command</p>

<p style="margin-top: 1em">While and For Loops <br>
while (test) cmd <br>
rc executes the test and performs the command as long as the
test is true.</p>

<p style="margin-top: 1em">for (var in list) cmd <br>
rc sets var to each element of list (which may contain
variables and backquote substitutions) and runs cmd. If
&lsquo;&lsquo;in list&rsquo;&rsquo; is omitted, then rc will
set var to each ele&acirc; <br>
ment of $*. For example:</p>

<p style="margin-top: 1em">for (i in &lsquo;{ls -F | grep
&rsquo;&rsquo; | sed &rsquo;s///&rsquo;}) { commands }</p>

<p style="margin-top: 1em">will set $i to the name of each
file in the current directory that is executable.</p>

<p style="margin-top: 1em">Switch <br>
switch (list) { case ... } <br>
rc looks inside the braces after a switch for statements
beginning with the word case. If any of the patterns
following case match the list supplied to switch, then the
<br>
commands up until the next case statement are executed. The
metacharacters *, [ or ? should not be quoted; matching is
performed only against the strings in list, not <br>
against file names. (Matching for case statements is the
same as for the ~ command.)</p>

<p style="margin-top: 1em">Logical Operators <br>
There are a number of operators in rc which depend on the
exit status of a command.</p>

<p style="margin-top: 1em">command &amp;&amp; command</p>

<p style="margin-top: 1em">executes the first command and
then executes the second command if and only if the first
command exits with a zero exit status
(&lsquo;&lsquo;true&rsquo;&rsquo; in Unix).</p>

<p style="margin-top: 1em">command || command</p>

<p style="margin-top: 1em">executes the first command and
then executes the second command if and only if the first
command exits with a nonzero exit status
(&lsquo;&lsquo;false&rsquo;&rsquo; in Unix).</p>

<p style="margin-top: 1em">! command</p>

<p style="margin-top: 1em">negates the exit status of a
command.</p>

<p style="margin-top: 1em">PATTERN MATCHING <br>
There are two forms of pattern matching in rc. One is
traditional shell globbing. This occurs in matching for file
names in argument lists:</p>

<p style="margin-top: 1em">command argument argument
...</p>

<p style="margin-top: 1em">When the characters *, [ or ?
occur in an argument or command, rc looks at the argument as
a pattern for matching against files. (Contrary to the
behavior other shells exhibit, <br>
rc will only perform pattern matching if a metacharacter
occurs unquoted and literally in the input. Thus,</p>

<p style="margin-top: 1em">foo=&rsquo;*&rsquo; <br>
echo $foo</p>

<p style="margin-top: 1em">will always echo just a star. In
order for non-literal metacharacters to be expanded, an eval
statement must be used in order to rescan the input.)
Pattern matching occurs <br>
according to the following rules: a * matches any number
(including zero) of characters. A ? matches any single
character, and a [ followed by a number of characters
followed <br>
by a ] matches a single character in that class. The rules
for character class matching are the same as those for
ed(1), with the exception that character class negation is
<br>
achieved with the tilde (~), not the caret (^), since the
caret already means something else in rc.</p>

<p style="margin-top: 1em">rc also matches patterns against
strings with the ~ command:</p>

<p style="margin-top: 1em">~ subject pattern pattern
...</p>

<p style="margin-top: 1em">~ sets $status to zero if and
only if a supplied pattern matches any single element of the
subject list. Thus</p>

<p style="margin-top: 1em">~ foo f*</p>

<p style="margin-top: 1em">sets status to zero, while</p>

<p style="margin-top: 1em">~ (bar baz) f*</p>

<p style="margin-top: 1em">sets status to one. The null
list is matched by the null list, so</p>

<p style="margin-top: 1em">~ $foo ()</p>

<p style="margin-top: 1em">checks to see whether $foo is
empty or not. This may also be achieved by the test</p>

<p style="margin-top: 1em">~ $#foo 0</p>

<p style="margin-top: 1em">Note that inside a ~ command rc
does not match patterns against file names, so it is not
necessary to quote the characters *, [ and ?. However, rc
does expand the subject <br>
against filenames if it contains metacharacters. Thus, the
command</p>

<p style="margin-top: 1em">~ * ?</p>

<p style="margin-top: 1em">returns true if any of the files
in the current directory have a single-character name. If
the ~ command is given a list as its first argument, then a
successful match against <br>
any of the elements of that list will cause ~ to return
true. For example:</p>

<p style="margin-top: 1em">~ (foo goo zoo) z*</p>

<p style="margin-top: 1em">is true.</p>

<p style="margin-top: 1em">LISTS AND VARIABLES <br>
The primary data structure in rc is the list, which is a
sequence of words. Parentheses are used to group lists. The
empty list is represented by (). Lists have no
hierarchi&acirc; <br>
cal structure; a list inside another list is expanded so the
outer list contains all the elements of the inner list.
Thus, the following are all equivalent</p>

<p style="margin-top: 1em">one two three</p>

<p style="margin-top: 1em">(one two three)</p>

<p style="margin-top: 1em">((one) () ((two three)))</p>

<p style="margin-top: 1em">Note that the null string,
&rsquo;&rsquo;, and the null list, (), are two very
different things. Assigning the null string to a variable is
a valid operation, but it does not remove its <br>
definition.</p>

<p style="margin-top: 1em">null = &rsquo;&rsquo; empty = ()
echo $#null $#empty</p>

<p style="margin-top: 1em">produces the output</p>

<p style="margin-top: 1em">1 0</p>

<p style="margin-top: 1em">List Concatenation <br>
Two lists may be joined by the concatenation operator (^).
Concatenation works according to the following rules: if the
two lists have the same number of elements, then
concate&acirc; <br>
nation is pairwise:</p>

<p style="margin-top: 1em">echo (a- b- c-)^(1 2 3)</p>

<p style="margin-top: 1em">produces the output</p>

<p style="margin-top: 1em">a-1 b-2 c-3</p>

<p style="margin-top: 1em">Otherwise, at least one of the
lists must have a single element, and then the concatenation
is distributive:</p>

<p style="margin-top: 1em">cc -^(O g c) (malloc
alloca)^.c</p>

<p style="margin-top: 1em">has the effect of performing the
command</p>

<p style="margin-top: 1em">cc -O -g -c malloc.c
alloca.c</p>

<p style="margin-top: 1em">A single word is a list of
length one, so</p>

<p style="margin-top: 1em">echo foo^bar</p>

<p style="margin-top: 1em">produces the output</p>

<p style="margin-top: 1em">foobar</p>

<p style="margin-top: 1em">Free Carets <br>
rc inserts carets (concatenation operators) for free in
certain situations, in order to save some typing on the
user&rsquo;s behalf. For example, the above example could
also be typed <br>
in as:</p>

<p style="margin-top: 1em">opts=(O g c) files=(malloc
alloca) cc -$opts $files.c</p>

<p style="margin-top: 1em">rc takes care to insert a
free-caret between the &lsquo;&lsquo;-&rsquo;&rsquo; and
$opts, as well as between $files and .c. The rule for free
carets is as follows: if a word or keyword is immediately
<br>
followed by another word, keyword, dollar-sign or backquote,
then rc inserts a caret between them.</p>

<p style="margin-top: 1em">Variables <br>
A list may be assigned to a variable, using the
notation:</p>

<p style="margin-top: 1em">var = list</p>

<p style="margin-top: 1em">The special variable * may also
be assigned to using this notation; rc has no set
builtin.</p>

<p style="margin-top: 1em">Any non-empty sequence of
characters, except a sequence including only digits, may be
used as a variable name. Any character except = may be used,
but special characters must be <br>
quoted. All user-defined variables are exported into the
environment.</p>

<p style="margin-top: 1em">The value of a variable is
referenced with the dollar ($) operator:</p>

<p style="margin-top: 1em">$var</p>

<p style="margin-top: 1em">Any variable which has not been
assigned a value returns the null list, (), when referenced.
Multiple references are allowed:</p>

<p style="margin-top: 1em">a = foo <br>
b = a <br>
echo $ $ b</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">foo</p>

<p style="margin-top: 1em">A variable&rsquo;s definition
may also be removed by assigning the null list to a
variable:</p>

<p style="margin-top: 1em">var=()</p>

<p style="margin-top: 1em">For &lsquo;&lsquo;free
careting&rsquo;&rsquo; to work correctly, rc must make
certain assumptions about what characters may appear in a
variable name. rc assumes that a variable name consists only
of <br>
alphanumeric characters, underscore (_) and star (*). To
reference a variable with other characters in its name,
quote the variable name. Thus:</p>

<p style="margin-top: 1em">echo
$&rsquo;we$Ird:Variab!le&rsquo;</p>

<p style="margin-top: 1em">Local Variables <br>
Any number of variable assignments may be made local to a
single command by typing:</p>

<p style="margin-top: 1em">a=foo b=bar ... command</p>

<p style="margin-top: 1em">The command may be a compound
command, so for example:</p>

<p style="margin-top: 1em">path=. ifs=() { <br>
... <br>
}</p>

<p style="margin-top: 1em">sets path to . and removes ifs
for the duration of one long compound command.</p>

<p style="margin-top: 1em">Variable Subscripts <br>
Variables may be subscripted with the notation</p>

<p style="margin-top: 1em">$var(n)</p>

<p style="margin-top: 1em">where n is a list of integers
(origin 1). The opening parenthesis must immediately follow
the variable name. The list of subscripts need not be in
order or even unique. Thus,</p>

<p style="margin-top: 1em">a=(one two three) <br>
echo $a(3 3 3)</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">three three three</p>

<p style="margin-top: 1em">If n references a nonexistent
element, then $var(n) returns the null list. The notation
$n, where n is an integer, is a shorthand for $*(n). Thus,
rc&rsquo;s arguments may be <br>
referred to as $1, $2, and so on.</p>

<p style="margin-top: 1em">Note also that the list of
subscripts may be given by any of rc&rsquo;s list
operations:</p>

<p style="margin-top: 1em">$var(&lsquo;{awk
&rsquo;BEGIN{for(i=1;i&lt;=10;i++)print i;exit;
}&rsquo;})</p>

<p style="margin-top: 1em">returns the first 10 elements of
$var.</p>

<p style="margin-top: 1em">To count the number of elements
in a variable, use</p>

<p style="margin-top: 1em">$#var</p>

<p style="margin-top: 1em">This returns a single-element
list, with the number of elements in $var.</p>

<p style="margin-top: 1em">Flat Lists <br>
In order to create a single-element list from a
multi-element list, with the components space-separated, use
the dollar-caret ($^) operator:</p>

<p style="margin-top: 1em">$^var</p>

<p style="margin-top: 1em">This is useful when the normal
list concatenation rules need to be bypassed. For example,
to append a single period at the end of $path, use:</p>

<p style="margin-top: 1em">echo $^path.</p>

<p style="margin-top: 1em">For compability with the Plan 9
rc,</p>

<p style="margin-top: 1em">$&quot;var</p>

<p style="margin-top: 1em">is accepted as a synonym for
dollar-caret.</p>

<p style="margin-top: 1em">Backquote Substitution <br>
A list may be formed from the output of a command by using
backquote substitution:</p>

<p style="margin-top: 1em">&lsquo;{ command }</p>

<p style="margin-top: 1em">returns a list formed from the
standard output of the command in braces. $ifs is used to
split the output into list elements. By default, $ifs has
the value space-tab-newline. <br>
The braces may be omitted if the command is a single word.
Thus &lsquo;ls may be used instead of &lsquo;{ls}. This last
feature is useful when defining functions that expand to
useful <br>
argument lists. A frequent use is:</p>

<p style="margin-top: 1em">fn src { echo *.[chy] }</p>

<p style="margin-top: 1em">followed by</p>

<p style="margin-top: 1em">wc &lsquo;src</p>

<p style="margin-top: 1em">(This will print out a
word-count of all C source files in the current
directory.)</p>

<p style="margin-top: 1em">In order to override the value
of $ifs for a single backquote substitution, use:</p>

<p style="margin-top: 1em">&lsquo;&lsquo; (ifs-list) {
command }</p>

<p style="margin-top: 1em">$ifs will be temporarily ignored
and the command&rsquo;s output will be split as specified by
the list following the double backquote. For example:</p>

<p style="margin-top: 1em">&lsquo;&lsquo; ($nl :) {cat
/etc/passwd}</p>

<p style="margin-top: 1em">splits up /etc/passwd into
fields, assuming that $nl contains a newline as its
value.</p>

<p style="margin-top: 1em">SPECIAL VARIABLES <br>
Several variables are known to rc and are treated specially.
In the following list, &lsquo;&lsquo;default&rsquo;&rsquo;
indicates that rc gives the variable a default value on
startup; &lsquo;&lsquo;no-export&rsquo;&rsquo; <br>
indicates that the variable is never exported; and
&lsquo;&lsquo;read-only&rsquo;&rsquo; indicates that an
attempt to set the variable will silently have no
effect.</p>

<p style="margin-top: 1em">Also,
&lsquo;&lsquo;alias&rsquo;&rsquo; means that the variable is
aliased to the same name in capitals. For example, an
assignment to $cdpath causes an automatic assignment to
$CDPATH, and vice-versa. <br>
If $CDPATH is set when rc is started, its value is imported
into $cdpath. $cdpath and $path are rc lists; $CDPATH and
$PATH are colon-separated lists. Only the names spelt in
<br>
capitals are exported into the environment.</p>

<p style="margin-top: 1em">* (no-export) <br>
The argument list of rc. $1, $2, etc. are the same as $*(1),
$*(2), etc.</p>

<p style="margin-top: 1em">0 (default no-export) <br>
The variable $0 holds the value of argv[0] with which rc was
invoked. Additionally, $0 is set to the name of a function
for the duration of the execution of that func&acirc; <br>
tion, and $0 is also set to the name of the file being
interpreted for the duration of a . command. $0 is not an
element of $*, and is never treated as one.</p>

<p style="margin-top: 1em">apid (no-export) <br>
The process ID of the last process started in the
background.</p>

<p style="margin-top: 1em">apids (no-export read-only) <br>
A list whose elements are the process IDs of all background
processes which are still alive, or which have died and have
not been waited for yet.</p>

<p style="margin-top: 1em">bqstatus (no-export) <br>
The exit status of the rc forked to execute the most recent
backquote substitution. Note that, unlike $status, $bqstatus
is always a single element list (see EXIT STATUS <br>
below). For example:</p>

<p style="margin-top: 1em">echo foo |grep bar; whatis
status</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">status=(0 1)</p>

<p style="margin-top: 1em">whereas</p>

<p style="margin-top: 1em">x=&lsquo;{echo foo |grep bar};
whatis bqstatus</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">bqstatus=1</p>

<p style="margin-top: 1em">cdpath (alias) <br>
A list of directories to search for the target of a cd
command. The empty string stands for the current directory.
Note that if the $cdpath variable does not contain the <br>
current directory, then the current directory will not be
searched; this allows directory searching to begin in a
directory other than the current directory.</p>

<p style="margin-top: 1em">history <br>
$history contains the name of a file to which commands are
appended as rc reads them. This facilitates the use of a
stand-alone history program (such as history(1)) which <br>
parses the contents of the history file and presents them to
rc for reinterpretation. If $history is not set, then rc
does not append commands to any file.</p>

<p style="margin-top: 1em">home (alias) <br>
The default directory for the builtin cd command, and the
directory in which rc looks to find its initialization file,
.rcrc, if rc has been started up as a login shell.</p>

<p style="margin-top: 1em">ifs (default) <br>
The internal field separator, used for splitting up the
output of backquote commands for digestion as a list. On
startup, rc assigns the list containing the characters <br>
space, tab, and newline to $ifs.</p>

<p style="margin-top: 1em">path (alias) <br>
This is a list of directories to search in for commands. The
empty string stands for the current directory. If neither
$PATH nor $path is set at startup time, $path <br>
assumes a default value suitable for your system. This is
typically (/usr/local/bin /usr/bin /usr/ucb /bin .)</p>

<p style="margin-top: 1em">pid (default no-export) <br>
On startup, $pid is initialized to the numeric process ID of
the currently running rc.</p>

<p style="margin-top: 1em">prompt (default) <br>
This variable holds the two prompts (in list form, of
course) that rc prints. $prompt(1) is printed before each
command is read, and $prompt(2) is printed when input is
<br>
expected to continue on the next line. rc sets $prompt to
(&rsquo;; &rsquo; &rsquo;&rsquo;) by default. The reason for
this is that it enables an rc user to grab commands from
previous lines <br>
using a mouse, and to present them to rc for
re-interpretation; the semicolon prompt is simply ignored by
rc. The null $prompt(2) also has its justification: an rc
<br>
script, when typed interactively, will not leave
$prompt(2)&rsquo;s on the screen, and can therefore be
grabbed by a mouse and placed directly into a file for use
as a shell <br>
script, without further editing being necessary.</p>

<p style="margin-top: 1em">prompt (function) <br>
If this function is defined, then it gets executed every
time rc is about to print $prompt(1).</p>

<p style="margin-top: 1em">status (no-export read-only)
<br>
The exit status of the last command. If the command exited
with a numeric value, that number is the status. If the
command died with a signal, the status is the name of <br>
that signal; if a core file was created, the string
&lsquo;&lsquo;+core&rsquo;&rsquo; is appended. The value of
$status for a pipeline is a list, with one entry, as above,
for each process in <br>
the pipeline. For example, the command</p>

<p style="margin-top: 1em">ls | wc</p>

<p style="margin-top: 1em">usually sets $status to (0
0).</p>

<p style="margin-top: 1em">version (default) <br>
On startup, the first element of this list variable is
initialized to a string which identifies this version of rc.
The second element is initialized to a string which <br>
can be found by ident(1) and the what command of
sccs(1).</p>

<p style="margin-top: 1em">FUNCTIONS <br>
rc functions are identical to rc scripts, except that they
are stored in memory and are automatically exported into the
environment. A shell function is declared as:</p>

<p style="margin-top: 1em">fn name { commands }</p>

<p style="margin-top: 1em">rc scans the definition until
the close-brace, so the function can span more than one
line. The function definition may be removed by typing</p>

<p style="margin-top: 1em">fn name</p>

<p style="margin-top: 1em">(One or more names may be
specified. With an accompanying definition, all names
receive the same definition. This is sometimes useful for
assigning the same signal handler to <br>
many signals. Without a definition, all named functions are
deleted.) When a function is executed, $* is set to the
arguments to that function for the duration of the command.
<br>
Thus a reasonable definition for l, a shorthand for ls(1),
could be:</p>

<p style="margin-top: 1em">fn l { ls -FC $* }</p>

<p style="margin-top: 1em">but not</p>

<p style="margin-top: 1em">fn l { ls -FC } # WRONG</p>

<p style="margin-top: 1em">INTERRUPTS AND SIGNALS <br>
rc recognizes a number of signals, and allows the user to
define shell functions which act as signal handlers. rc by
default traps SIGINT when it is in interactive mode. <br>
SIGQUIT and SIGTERM are ignored, unless rc has been invoked
with the -d flag. However, user-defined signal handlers may
be written for these and all other signals. The way to <br>
define a signal handler is to write a function by the name
of the signal in lower case. Thus:</p>

<p style="margin-top: 1em">fn sighup { echo hangup; rm
/tmp/rc$pid.*; exit }</p>

<p style="margin-top: 1em">In addition to Unix signals, rc
recognizes the artificial signal SIGEXIT which occurs as rc
is about to exit.</p>

<p style="margin-top: 1em">In order to remove a signal
handler&rsquo;s definition, remove it as though it were a
regular function. For example:</p>

<p style="margin-top: 1em">fn sigint</p>

<p style="margin-top: 1em">returns the handler of SIGINT to
the default value. In order to ignore a signal, set the
signal handler&rsquo;s value to {}. Thus:</p>

<p style="margin-top: 1em">fn sigint {}</p>

<p style="margin-top: 1em">causes SIGINT to be ignored by
the shell. Only signals that are being ignored are passed on
to programs run by rc; signal functions are not
exported.</p>

<p style="margin-top: 1em">On System V-based Unix systems,
rc will not allow you to trap SIGCLD.</p>

<p style="margin-top: 1em">BUILTIN COMMANDS <br>
Builtin commands execute in the context of the shell, but
otherwise behave exactly like other commands. Although !, ~
and @ are not strictly speaking builtin commands, they can
<br>
usually be used as such.</p>

<p style="margin-top: 1em">. [-i] file [arg ...] <br>
Reads file as input to rc and executes its contents. With a
-i flag, input is interactive. Thus from within a shell
script,</p>

<p style="margin-top: 1em">. -i /dev/tty</p>

<p style="margin-top: 1em">does the &lsquo;&lsquo;right
thing&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">break Breaks from the innermost
for or while, as in C. It is an error to invoke break
outside of a loop. (Note that there is no break keyword
between commands in switch state&acirc; <br>
ments, unlike C.)</p>

<p style="margin-top: 1em">builtin command [arg ...] <br>
Executes the command ignoring any function definition of the
same name. This command is present to allow functions with
the same names as builtins to use the underlying <br>
builtin or binary. For example:</p>

<p style="margin-top: 1em">fn ls { builtin ls -FC $* }</p>

<p style="margin-top: 1em">is a reasonable way to pass a
default set of arguments to ls(1), whereas</p>

<p style="margin-top: 1em">fn ls { ls -FC $* } # WRONG</p>

<p style="margin-top: 1em">is a non-terminating recursion,
which will cause rc to exhaust its stack space and
(eventually) terminate if it is executed.</p>

<p style="margin-top: 1em">cd [directory] <br>
Changes the current directory to directory. The variable
$cdpath is searched for possible locations of directory,
analogous to the searching of $path for executable <br>
files. With no argument, cd changes the current directory to
$home.</p>

<p style="margin-top: 1em">echo [-n] [--] [arg ...] <br>
Prints its arguments to standard output, terminated by a
newline. Arguments are separated by spaces. If the first
argument is -n no final newline is printed. If the <br>
first argument is --, then all other arguments are echoed
literally. This is used for echoing a literal -n.</p>

<p style="margin-top: 1em">eval [list] <br>
Concatenates the elements of list with spaces and feeds the
resulting string to rc for re-scanning. This is the only
time input is rescanned in rc.</p>

<p style="margin-top: 1em">exec [arg ...] <br>
Replaces rc with the given command. If the exec contains
only redirections, then these redirections apply to the
current shell and the shell does not exit. For example,</p>

<p style="margin-top: 1em">exec &gt;[2] err.out</p>

<p style="margin-top: 1em">places further output to
standard error in the file err.out.</p>

<p style="margin-top: 1em">exit [status] <br>
Cause the current shell to exit with the given exit status.
If no argument is given, the current value of $status is
used.</p>

<p style="margin-top: 1em">limit [-h] [resource [value]]
<br>
Similar to the csh(1) limit builtin, this command operates
upon the BSD-style resource limits of a process. The -h flag
displays/alters the hard limits. The resources <br>
which can be shown or altered are cputime, filesize,
datasize, stacksize, coredumpsize, memoryuse, and, where
supported, descriptors, memoryuse, memoryrss, maxproc,
memo&acirc; <br>
rylocked, and filelocks. For example:</p>

<p style="margin-top: 1em">limit coredumpsize 0</p>

<p style="margin-top: 1em">disables core dumps. To set a
soft limit equal to the hard limit:</p>

<p style="margin-top: 1em">limit &lsquo;{limit -h
datasize}</p>

<p style="margin-top: 1em">newpgrp <br>
Puts rc into a new process group. This builtin is useful for
making rc behave like a job-control shell in a hostile
environment. One example is the NeXT Terminal pro&acirc;
<br>
gram, which implicitly assumes that each shell it forks will
put itself into a new process group.</p>

<p style="margin-top: 1em">return [n] <br>
Returns from the current function, with status n, where n is
a valid exit status, or a list of them. Thus it is legal to
have</p>

<p style="margin-top: 1em">return (sigpipe 1 2 3)</p>

<p style="margin-top: 1em">(This is commonly used to allow
a function to return with the exit status of a previously
executed pipeline of commands.) If n is omitted, then
$status is left unchanged. <br>
It is an error to invoke return when not inside a
function.</p>

<p style="margin-top: 1em">shift [n] <br>
Deletes n elements from the beginning of $* and shifts the
other elements down by n. n defaults to 1.</p>

<p style="margin-top: 1em">umask [mask] <br>
Sets the current umask (see umask(2)) to the octal mask. If
no argument is present, the current mask value is
printed.</p>

<p style="margin-top: 1em">wait [pid] <br>
Waits for process with the specified pid, which must have
been started by rc, to exit. If no pid is specified, rc
waits for all its child processes to exit.</p>

<p style="margin-top: 1em">whatis [-b] [-f] [-p] [-s] [-v]
[--] [name ...] <br>
Prints a definition of the named objects. For builtins,
builtin foo is printed; for functions, including signal
handlers, their definitions are printed; for executable <br>
files, path names are printed; and for variables, their
values are printed. The flags restrict output to builtins,
functions, executable programs, signal handlers, and <br>
variables, respectively. If no names are specified, rc lists
all objects of that type. (This is not permitted for -p.)
Without arguments, whatis is equivalent to whatis <br>
-fv, and prints the values of all shell variables and
functions.</p>

<p style="margin-top: 1em">Note that whatis output is
suitable for input to rc; by saving the output of whatis in
a file, it should be possible to recreate the state of rc by
sourcing this file with <br>
a . command. Another note: whatis -s &gt; file cannot be
used to store the state of rc&rsquo;s signal handlers in a
file, because builtins with redirections are run in a
sub&acirc; <br>
shell, and rc always restores signal handlers to their
default value after a fork().</p>

<p style="margin-top: 1em">Since whatis uses getopt(3) to
parse its arguments, you can use the special argument -- to
terminate its flags. This allows you to use names beginning
with a dash, such <br>
as the history(1) commands. For example,</p>

<p style="margin-top: 1em">whatis -- -p</p>

<p style="margin-top: 1em">EXAMPLES <br>
The shift builtin only shifts $*. This function can shift
any variable (except $lshift).</p>

<p style="margin-top: 1em">fn lshift { lshift=$*; *=$$1;
shift $lshift(2); $lshift(1)=$* }</p>

<p style="margin-top: 1em">With this definition in
place,</p>

<p style="margin-top: 1em">walrus = (shoes ships
sealing-wax cabbages kings) <br>
lshift walrus 3 <br>
whatis walrus</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">walrus=(cabbages kings)</p>

<p style="margin-top: 1em">The $^var operator flattens a
list by separating each element with a space. This function
allows the separator to be an arbitrary string.</p>

<p style="margin-top: 1em">fn lflat { <br>
lflat=$*; *=$$1 <br>
while () { <br>
echo -n $1; shift <br>
~ $#* 0 &amp;&amp; break <br>
echo -n $lflat(2) <br>
}</p>

<p style="margin-top: 1em">With this definition in
place,</p>

<p style="margin-top: 1em">hops=(uunet mcvax ukc tlg) <br>
lflat hops !</p>

<p style="margin-top: 1em">prints (with no final
newline)</p>

<p style="margin-top: 1em">uunet!mcvax!ukc!tlg</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The exit status of rc is normally the same as that of the
last command executed. If the last command was a pipeline,
rc exits 0 if every command in the pipeline did; otherwise
<br>
it exits 1.</p>

<p style="margin-top: 1em">rc can be made to exit with a
particular status using the exit builtin.</p>

<p style="margin-top: 1em">GRAMMAR <br>
Here is rc&rsquo;s grammar, edited to remove semantic
actions.</p>

<p style="margin-top: 1em">%term ANDAND BACKBACK BANG CASE
COUNT DUP ELSE END FLAT FN FOR IF IN <br>
%term OROR PIPE REDIR SUB SUBSHELL SWITCH TWIDDLE WHILE WORD
HUH</p>

<p style="margin-top: 1em">%left WHILE &rsquo;)&rsquo; ELSE
<br>
%left ANDAND OROR &rsquo;0 <br>
%left BANG SUBSHELL <br>
%left PIPE <br>
%right &rsquo;$&rsquo; <br>
%left SUB</p>

<p style="margin-top: 1em">%start rc</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">rc: line end <br>
| error end</p>

<p style="margin-top: 1em">end: END /* EOF */ |
&rsquo;0</p>

<p style="margin-top: 1em">cmdsa: cmd &rsquo;;&rsquo; | cmd
&rsquo;&amp;&rsquo;</p>

<p style="margin-top: 1em">line: cmd | cmdsa line</p>

<p style="margin-top: 1em">body: cmd | cmdsan body</p>

<p style="margin-top: 1em">cmdsan: cmdsa | cmd &rsquo;0</p>

<p style="margin-top: 1em">brace: &rsquo;{&rsquo; body
&rsquo;}&rsquo;</p>

<p style="margin-top: 1em">paren: &rsquo;(&rsquo; body
&rsquo;)&rsquo;</p>

<p style="margin-top: 1em">assign: first &rsquo;=&rsquo;
word</p>

<p style="margin-top: 1em">epilog: /* empty */ | redir
epilog</p>

<p style="margin-top: 1em">redir: DUP | REDIR word</p>

<p style="margin-top: 1em">case: CASE words &rsquo;;&rsquo;
| CASE words &rsquo;0</p>

<p style="margin-top: 1em">cbody: cmd | case cbody | cmdsan
cbody</p>

<p style="margin-top: 1em">iftail: cmd %prec ELSE <br>
| brace ELSE optnl cmd</p>

<p style="margin-top: 1em">cmd : /* empty */ %prec WHILE
<br>
| simple <br>
| brace epilog <br>
| IF paren optnl iftail <br>
| FOR &rsquo;(&rsquo; word IN words &rsquo;)&rsquo; optnl
cmd <br>
| FOR &rsquo;(&rsquo; word &rsquo;)&rsquo; optnl cmd <br>
| WHILE paren optnl cmd <br>
| SWITCH &rsquo;(&rsquo; word &rsquo;)&rsquo; optnl
&rsquo;{&rsquo; cbody &rsquo;}&rsquo; <br>
| TWIDDLE optcaret word words <br>
| cmd ANDAND optnl cmd <br>
| cmd OROR optnl cmd <br>
| cmd PIPE optnl cmd <br>
| redir cmd %prec BANG <br>
| assign cmd %prec BANG <br>
| BANG optcaret cmd <br>
| SUBSHELL optcaret cmd <br>
| FN words brace <br>
| FN words</p>

<p style="margin-top: 1em">optcaret: /* empty */ |
&rsquo;^&rsquo;</p>

<p style="margin-top: 1em">simple: first | simple word |
simple redir</p>

<p style="margin-top: 1em">first: comword | first
&rsquo;^&rsquo; sword</p>

<p style="margin-top: 1em">sword: comword | keyword</p>

<p style="margin-top: 1em">word: sword | word
&rsquo;^&rsquo; sword</p>

<p style="margin-top: 1em">comword: &rsquo;$&rsquo; sword
<br>
| &rsquo;$&rsquo; sword SUB words &rsquo;)&rsquo; <br>
| COUNT sword <br>
| FLAT sword <br>
| &rsquo;&lsquo;&rsquo; sword <br>
| &rsquo;&lsquo;&rsquo; brace <br>
| BACKBACK word brace | BACKBACK word sword <br>
| &rsquo;(&rsquo; words &rsquo;)&rsquo; <br>
| REDIR brace <br>
| WORD</p>

<p style="margin-top: 1em">keyword: FOR | IN | WHILE | IF |
SWITCH <br>
| FN | ELSE | CASE | TWIDDLE | BANG | SUBSHELL</p>

<p style="margin-top: 1em">words: /* empty */ | words
word</p>

<p style="margin-top: 1em">optnl: /* empty */ | optnl
&rsquo;0</p>

<p style="margin-top: 1em">FILES <br>
$HOME/.rcrc, /tmp/rc*, /dev/null</p>

<p style="margin-top: 1em">CREDITS <br>
rc was written by Byron Rakitzis, with valuable help from
Paul Haahr, Hugh Redelmeier and David Sanderson. The design
of this shell was copied from the rc that Tom Duff wrote at
<br>
Bell Labs.</p>

<p style="margin-top: 1em">BUGS <br>
There is a compile-time limit on the number of ; separated
commands in a line: usually 500. This is sometimes a problem
for automatically generated scripts: substituting the <br>
newline character for ; avoids the limit.</p>

<p style="margin-top: 1em">On modern systems that support
/dev/fd or /proc/self/fd, &lt;{foo} style redirection is
implemented that way. However, on older systems it is
implemented with named pipes. <br>
Allegedly, it is sometimes possible to foil rc into removing
the FIFO it places in /tmp prematurely, or it is even
possible to cause rc to hang. (The current maintainer has
<br>
never seen this, but then he doesn&rsquo;t use systems which
lack /dev/fd any more. If anybody can reproduce this
problem, please let the maintainer know.)</p>

<p style="margin-top: 1em">The echo command does not need
to be a builtin. It is one for reasons of performance and
portability (of rc scripts).</p>

<p style="margin-top: 1em">There should be a way to avoid
exporting a variable.</p>

<p style="margin-top: 1em">Extra parentheses around a ~
expression or a ! expression are a syntax error. Thus, this
code is illegal.</p>

<p style="margin-top: 1em">while ((~ $1 -*) &amp;&amp; (! ~
$1 --)) { ...</p>

<p style="margin-top: 1em">The redundant inner parentheses
must be omitted.</p>

<p style="margin-top: 1em">Variable subscripting cannot be
used in here documents.</p>

<p style="margin-top: 1em">The limit builtin silently
ignores extra arguments.</p>

<p style="margin-top: 1em">Backquote substitution never
produces empty strings - multiple consecutive occurrences of
the separator are treated the same as a single
occurrence.</p>

<p style="margin-top: 1em">ifs=! { x = &lsquo;{echo -n
a!!b}; whatis x } <br>
x=(a b) # NOT x=(a &rsquo;&rsquo; b)</p>

<p style="margin-top: 1em">Bug reports should be mailed to
<br>
&lt;toby@paccrat.org&gt;.</p>

<p style="margin-top: 1em">INCOMPATIBILITIES <br>
Here is a list of features which distinguish this
incarnation of rc from the one described in the Bell Labs
manual pages:</p>

<p style="margin-top: 1em">The Tenth Edition rc does not
have the else keyword. Instead, if is optionally followed by
an if not clause which is executed if the preceding if test
does not succeed.</p>

<p style="margin-top: 1em">Backquotes are slightly
different in Tenth Edition rc: a backquote must always be
followed by a left-brace. This restriction is not present
for single-word commands in this rc.</p>

<p style="margin-top: 1em">For . file, the Tenth Edition rc
searches $path for file. This rc does not, since it is not
considered useful.</p>

<p style="margin-top: 1em">The list flattening operator,
$^foo, is spelt $&quot;foo in those versions of the Bell
Labs rc which have it.</p>

<p style="margin-top: 1em">The following are all new with
this version of rc: The -n flag, here strings (they
facilitate exporting of functions with here documents into
the environment), the return and <br>
break keywords, the echo builtin, the bqstatus and version
variables, the support for the GNU readline(3) library, and
the support for the prompt function. This rc also sets $0
<br>
to the name of a function being executed/file being
sourced.</p>

<p style="margin-top: 1em">SEE ALSO <br>
&lsquo;&lsquo;rc &acirc; A Shell for Plan 9 and UNIX
Systems&rsquo;&rsquo;, Unix Research System, Tenth Edition,
Volume 2. (Saunders College Publishing)</p>


<p style="margin-top: 1em">http://static.tobold.org/rc/rc-duff.html,
an updated version of the above paper.</p>

<p style="margin-top: 1em">history(1)</p>

<p style="margin-top: 1em">2015-05-13 RC(1)</p>
<hr>
</body>
</html>
