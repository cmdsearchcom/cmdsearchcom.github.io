<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>RC(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">RC(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">RC(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
rc - shell
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>rc</b> [<b>-deiIlnopsvx</b>] [<b>-c</b> <i>command</i>] [<i>arguments</i>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>rc</i> is a command interpreter and programming language similar to
  <i>sh</i>(1). It is based on the AT&amp;T Plan 9 shell of the same name. The
  shell offers a C-like syntax (much more so than the C shell), and a powerful
  mechanism for manipulating variables. It is reasonably small and reasonably
  fast, especially when compared to contemporary shells. Its use is intended to
  be interactive, but the language lends itself well to scripts.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">-c</dt>
  <dd class="It-tag">If -c is present, commands are executed from the
      immediately following argument. Any further arguments to <i>rc</i> are
      placed in $*. Thus:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
rc -c 'echo $*' 1 2 3
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">prints out
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
1 2 3
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-d</dt>
  <dd class="It-tag">This flag causes <i>rc</i> not to ignore SIGQUIT or
      SIGTERM. Thus <i>rc</i> can be made to dump core if sent SIGQUIT. This
      flag is only useful for debugging <i>rc</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-e</dt>
  <dd class="It-tag">If the -e flag is present, then <i>rc</i> will exit if the
      exit status of a command is false (nonzero). <i>rc</i> will not exit,
      however, if a conditional fails, e.g., an if() command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-i</dt>
  <dd class="It-tag">If the -i flag is present or if the input to <i>rc</i> is
      from a terminal (as determined by <i>isatty</i>(3)) then <i>rc</i> will be
      in <i>interactive</i> mode. That is, a prompt (from $prompt(1)) will be
      printed before an input line is taken, and <i>rc</i> will ignore
    SIGINT.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-I</dt>
  <dd class="It-tag">If the -I flag is present, or if the input to <i>rc</i> is
      not from a terminal, then <i>rc</i> will not be in interactive mode. No
      prompts will be printed, and SIGINT will cause <i>rc</i> to exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-l</dt>
  <dd class="It-tag">If the -l flag is present, or if <i>rc</i>'s argv[0][0] is
      a dash (-), then <i>rc</i> will behave as a login shell. That is, it will
      run commands from $home/.rcrc, if this file exists, before reading any
      other input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-n</dt>
  <dd class="It-tag">This flag causes <i>rc</i> to read its input and parse it,
      but not to execute any commands. This is useful for syntax checking on
      scripts. If used in combination with the -x flag, <i>rc</i> will print
      each command as it is parsed in a form similar to the one used for
      exporting functions into the environment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-o</dt>
  <dd class="It-tag">This flag prevents the usual practice of trying to open
      /dev/null on file descriptors 0, 1, and 2, if any of those descriptors are
      inherited closed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-p</dt>
  <dd class="It-tag">This flag prevents <i>rc</i> from initializing shell
      functions from the environment. This allows <i>rc</i> to run in a
      protected mode, whereby it becomes more difficult for an <i>rc</i> script
      to be subverted by placing false commands in the environment. (Note that
      the presence of this flag does <i>not</i> mean that it is safe to run
      setuid <i>rc</i> scripts; the usual caveats about the setuid bit still
      apply.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag">This flag causes <i>rc</i> to read from standard input. Any
      arguments are placed in $*.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag">This flag causes <i>rc</i> to echo its input to standard
      error as it is read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-x</dt>
  <dd class="It-tag">This flag causes <i>rc</i> to print every command on
      standard error before it is executed. It can be useful for debugging
      <i>rc</i> scripts.</dd>
</dl>
<h1 class="Sh" title="Sh" id="COMMANDS"><a class="selflink" href="#COMMANDS">COMMANDS</a></h1>
A simple command is a sequence of words, separated by white space (space and
  tab) characters that ends with a newline, semicolon (;), or ampersand (&amp;).
  The first word of a command is the name of that command. If the name begins
  with /, ./, or ../, then the name is used as an absolute path name referring
  to an executable file. Otherwise, the name of the command is looked up in a
  table of shell functions, builtin commands, or as a file in the directories
  named by $path.
<h2 class="Ss" title="Ss" id="Background_Tasks"><a class="selflink" href="#Background_Tasks">Background
  Tasks</a></h2>
A command ending with &amp; is run in the background; that is, the shell returns
  immediately rather than waiting for the command to complete. Background
  commands have /dev/null connected to their standard input unless an explicit
  redirection for standard input is used.
<h2 class="Ss" title="Ss" id="Subshells"><a class="selflink" href="#Subshells">Subshells</a></h2>
A command prefixed with an at-sign (@) is executed in a subshell. This insulates
  the parent shell from the effects of state changing operations such as a
  <b>cd</b> or a variable assignment. For example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
@ {cd ..; make}
</pre>
<br/>
<div class="Pp"></div>
will run <i>make</i>(1) in the parent directory (..), but leaves the shell
  running in the current directory.
<h2 class="Ss" title="Ss" id="Line_continuation"><a class="selflink" href="#Line_continuation">Line
  continuation</a></h2>
A long logical line may be continued over several physical lines by terminating
  each line (except the last) with a backslash (\). The backslash-newline
  sequence is treated as a space. A backslash is not otherwise special to
  <i>rc</i>. (In addition, inside quotes a backslash loses its special meaning
  even when it is followed by a newline.)
<h2 class="Ss" title="Ss" id="Quoting"><a class="selflink" href="#Quoting">Quoting</a></h2>
<i>rc</i> interprets several characters specially; special characters
  automatically terminate words. The following characters are special:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
# ; &amp; | ^ $ = ` ' { } ( ) &lt; &gt;
</pre>
<br/>
<div class="Pp"></div>
The single quote (') prevents special treatment of any character other than
  itself. All characters, including control characters, newlines, and
  backslashes between two quote characters are treated as an uninterpreted
  string. A quote character itself may be quoted by placing two quotes in a row.
  The minimal sequence needed to enter the quote character is ''''. The empty
  string is represented by ''. Thus:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo 'What''s the plan, Stan?'
</pre>
<br/>
<div class="Pp"></div>
prints out
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
What's the plan, Stan?
</pre>
<br/>
<div class="Pp"></div>
The number sign (#) begins a comment in <i>rc</i>. All characters up to but not
  including the next newline are ignored. Note that backslash continuation does
  not work inside a comment, i.e., the backslash is ignored along with
  everything else.
<h2 class="Ss" title="Ss" id="Grouping"><a class="selflink" href="#Grouping">Grouping</a></h2>
Zero or more commands may be grouped within braces (``{'' and ``}''), and are
  then treated as one command. Braces do not otherwise define scope; they are
  used only for command grouping. In particular, be wary of the command:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
for (i) {
    command
} | command
</pre>
<br/>
<div class="Pp"></div>
Since pipe binds tighter than for, this command does not perform what the user
  expects it to. Instead, enclose the whole for statement in braces:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
{for (i) command} | command
</pre>
<br/>
<div class="Pp"></div>
Fortunately, <i>rc</i>'s grammar is simple enough that a (confident) user can
  understand it by examining the skeletal <i>yacc</i>(1) grammar at the end of
  this man page (see the section entitled <b>GRAMMAR</b>).
<h2 class="Ss" title="Ss" id="Input_and_output"><a class="selflink" href="#Input_and_output">Input
  and output</a></h2>
The standard output may be redirected to a file with
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt; file
</pre>
<br/>
<div class="Pp"></div>
and the standard input may be taken from a file with
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &lt; file
</pre>
<br/>
<div class="Pp"></div>
Redirections can appear anywhere in the line: the word following the redirection
  symbol is the filename and must be quoted if it contains spaces or other
  special characters. These are all equivalent.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo 1 2 3 &gt; foo
&gt; foo echo 1 2 3
echo 1 2 &gt; foo 3
</pre>
<br/>
<div class="Pp"></div>
File descriptors other than 0 and 1 may be specified also. For example, to
  redirect standard error to a file, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt;[2] file
</pre>
<br/>
<div class="Pp"></div>
In order to duplicate a file descriptor, use &gt;[ <i>n</i>=<i>m</i>]. Thus to
  redirect both standard output and standard error to the same file, use
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt; file &gt;[2=1]
</pre>
<br/>
<div class="Pp"></div>
As in <i>sh</i>, redirections are processed from left to right. Thus this
  sequence
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt;[2=1] &gt; file
</pre>
<br/>
<div class="Pp"></div>
is usually a mistake. It first duplicates standard error to standard output;
  then redirects standard output to a file, leaving standard error wherever
  standard output originally was.
<div class="Pp"></div>
To close a file descriptor that may be open, use &gt;[ <i>n</i>=]. For example,
  to close file descriptor 7:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt;[7=]
</pre>
<br/>
<div class="Pp"></div>
Note that no spaces may appear in these constructs:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt; [2] file
</pre>
<br/>
<div class="Pp"></div>
would send the output of the command to a file named [2], with the intended
  filename appearing in the command's argument list.
<div class="Pp"></div>
In order to place the output of a command at the end of an already existing
  file, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt;&gt; file
</pre>
<br/>
<div class="Pp"></div>
If the file does not exist, then it is created.
<div class="Pp"></div>
``Here documents'' are supported as in <i>sh</i> with the use of
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &lt;&lt; 'eof-marker'
</pre>
<br/>
<div class="Pp"></div>
Subsequent lines form the standard input of the command, till a line containing
  just the marker, in this case eof-marker, is encountered.
<div class="Pp"></div>
If the end-of-file marker is enclosed in quotes, then no variable substitution
  occurs inside the here document. Otherwise, every variable is substituted by
  its space-separated-list value (see <b>Flat Lists</b>, below), and if a ^
  character follows a variable name, it is deleted. This allows the unambiguous
  use of variables adjacent to text, as in
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$variable^follow
</pre>
<br/>
<div class="Pp"></div>
To include a literal $ in a here document when an unquoted end-of-file marker is
  being used, enter it as $$.
<div class="Pp"></div>
Additionally, <i>rc</i> supports ``here strings'', which are like here
  documents, except that input is taken directly from a string on the command
  line. Their use is illustrated here:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
cat &lt;&lt;&lt; 'this is a here string' | wc
</pre>
<br/>
<div class="Pp"></div>
(This feature enables <i>rc</i> to export functions using here documents into
  the environment; the author does not expect users to find this feature
  useful.)
<h2 class="Ss" title="Ss" id="Pipes"><a class="selflink" href="#Pipes">Pipes</a></h2>
Two or more commands may be combined in a pipeline by placing the vertical bar
  (|) between them. The standard output (file descriptor 1) of the command on
  the left is tied to the standard input (file descriptor 0) of the command on
  the right. The notation |[ <i>n</i>=<i>m</i>] indicates that file descriptor
  <i>n</i> of the left process is connected to file descriptor <i>m</i> of the
  right process. |[ <i>n</i>] is a shorthand for |[ <i>n</i>=0]. As an example,
  to pipe the standard error of a command to <i>wc</i>(1), use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command |[2] wc
</pre>
<br/>
<div class="Pp"></div>
As with file redirections, no spaces may occur in the construct specifying
  numbered file descriptors.
<div class="Pp"></div>
The exit status of a pipeline is considered true if and only if every command in
  the pipeline exits true.
<h2 class="Ss" title="Ss" id="Commands_as_Arguments"><a class="selflink" href="#Commands_as_Arguments">Commands
  as Arguments</a></h2>
Some commands, like <i>cmp</i>(1) or <i>diff</i>(1), take their arguments on the
  command line, and do not read input from standard input. It is convenient
  sometimes to build nonlinear pipelines so that a command like <i>cmp</i> can
  read the output of two other commands at once. <i>rc</i> does it like this:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
cmp &lt;{command} &lt;{command}
</pre>
<br/>
<div class="Pp"></div>
compares the output of the two commands in braces. Note: since this form of
  redirection is implemented with some kind of pipe, and since one cannot
  <i>lseek</i>(2) on a pipe, commands that use <i>lseek</i>(2) will hang. For
  example, some versions of <i>diff</i>(1) use <i>lseek</i>(2) on their inputs.
<div class="Pp"></div>
Data can be sent down a pipe to several commands using <i>tee</i>(1) and the
  output version of this notation:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo hi there | tee &gt;{sed 's/^/p1 /'} &gt;{sed 's/^/p2 /'}
</pre>
<br/>
<h1 class="Sh" title="Sh" id="CONTROL_STRUCTURES"><a class="selflink" href="#CONTROL_STRUCTURES">CONTROL
  STRUCTURES</a></h1>
The following may be used for control flow in <i>rc</i>:
<h2 class="Ss" title="Ss" id="If-Else_Statements"><a class="selflink" href="#If-Else_Statements">If-Else
  Statements</a></h2>
<div style="height: 1.00em;">&#x00A0;</div>
if ( <i>test</i>) {
<div>&#x00A0;</div>
<i> cmd</i>
<div>&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">} else <i>cmd</i></dt>
  <dd class="It-tag">The <i>test</i> is executed, and if its return status is
      zero, the first command is executed, otherwise the second is. Braces are
      not mandatory around the commands. However, an else statement is valid
      only if it follows a close-brace on the same line. Otherwise, the if is
      taken to be a simple-if:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
if (test)
    command
    </pre>
    <br/>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="While_and_For_Loops"><a class="selflink" href="#While_and_For_Loops">While
  and For Loops</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">while (<i>test</i>)<i> cmd</i></dt>
  <dd class="It-tag"><i>rc</i> executes the <i>test</i> and performs the command
      as long as the <i>test</i> is true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">for (<i>var</i> in <i>list</i>)<i> cmd</i></dt>
  <dd class="It-tag"><i>rc</i> sets <i>var</i> to each element of <i>list</i>
      (which may contain variables and backquote substitutions) and runs
      <i>cmd</i>. If ``in <i>list</i>'' is omitted, then <i>rc</i> will set
      <i>var</i> to each element of $*. For example:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
for (i in `{ls -F | grep '\*$' | sed 's/\*$//'}) { commands }
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">will set $i to the name of each file in the current
      directory that is executable.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Switch"><a class="selflink" href="#Switch">Switch</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">switch (<i>list</i>) { case<i> ...</i> }</dt>
  <dd class="It-tag"><i>rc</i> looks inside the braces after a switch for
      statements beginning with the word case. If any of the patterns following
      case match the list supplied to switch, then the commands up until the
      next case statement are executed. The metacharacters *, [ or ? should not
      be quoted; matching is performed only against the strings in <i>list</i>,
      not against file names. (Matching for case statements is the same as for
      the ~ command.)</dd>
</dl>
<h2 class="Ss" title="Ss" id="Logical_Operators"><a class="selflink" href="#Logical_Operators">Logical
  Operators</a></h2>
There are a number of operators in <i>rc</i> which depend on the exit status of
  a command.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &amp;&amp; command
</pre>
<br/>
<div class="Pp"></div>
executes the first command and then executes the second command if and only if
  the first command exits with a zero exit status (``true'' in Unix).
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command || command
</pre>
<br/>
<div class="Pp"></div>
executes the first command and then executes the second command if and only if
  the first command exits with a nonzero exit status (``false'' in Unix).
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
! command
</pre>
<br/>
<div class="Pp"></div>
negates the exit status of a command.
<h1 class="Sh" title="Sh" id="PATTERN_MATCHING"><a class="selflink" href="#PATTERN_MATCHING">PATTERN
  MATCHING</a></h1>
There are two forms of pattern matching in <i>rc</i>. One is traditional shell
  globbing. This occurs in matching for file names in argument lists:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command argument argument ...
</pre>
<br/>
<div class="Pp"></div>
When the characters *, [ or ? occur in an argument or command, <i>rc</i> looks
  at the argument as a pattern for matching against files. (Contrary to the
  behavior other shells exhibit, <i>rc</i> will only perform pattern matching if
  a metacharacter occurs unquoted and literally in the input. Thus,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
foo='*'
echo $foo
</pre>
<br/>
<div class="Pp"></div>
will always echo just a star. In order for non-literal metacharacters to be
  expanded, an eval statement must be used in order to rescan the input.)
  Pattern matching occurs according to the following rules: a * matches any
  number (including zero) of characters. A ? matches any single character, and a
  [ followed by a number of characters followed by a ] matches a single
  character in that class. The rules for character class matching are the same
  as those for <i>ed</i>(1), with the exception that character class negation is
  achieved with the tilde (~), not the caret (^), since the caret already means
  something else in <i>rc</i>.
<div class="Pp"></div>
<i>rc</i> also matches patterns against strings with the ~ command:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ subject pattern pattern ...
</pre>
<br/>
<div class="Pp"></div>
~ sets $status to zero if and only if a supplied pattern matches any single
  element of the subject list. Thus
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ foo f*
</pre>
<br/>
<div class="Pp"></div>
sets status to zero, while
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ (bar baz) f*
</pre>
<br/>
<div class="Pp"></div>
sets status to one. The null list is matched by the null list, so
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ $foo ()
</pre>
<br/>
<div class="Pp"></div>
checks to see whether $foo is empty or not. This may also be achieved by the
  test
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ $#foo 0
</pre>
<br/>
<div class="Pp"></div>
Note that inside a ~ command <i>rc</i> does not match patterns against file
  names, so it is not necessary to quote the characters *, [ and ?. However,
  <i>rc</i> does expand the subject against filenames if it contains
  metacharacters. Thus, the command
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ * ?
</pre>
<br/>
<div class="Pp"></div>
returns true if any of the files in the current directory have a
  single-character name. If the ~ command is given a list as its first argument,
  then a successful match against any of the elements of that list will cause ~
  to return true. For example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ (foo goo zoo) z*
</pre>
<br/>
<div class="Pp"></div>
is true.
<h1 class="Sh" title="Sh" id="LISTS_AND_VARIABLES"><a class="selflink" href="#LISTS_AND_VARIABLES">LISTS
  AND VARIABLES</a></h1>
The primary data structure in <i>rc</i> is the list, which is a sequence of
  words. Parentheses are used to group lists. The empty list is represented by
  (). Lists have no hierarchical structure; a list inside another list is
  expanded so the outer list contains all the elements of the inner list. Thus,
  the following are all equivalent
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
one two three
<div class="Pp"></div>
(one two three)
<div class="Pp"></div>
((one) () ((two three)))
</pre>
<br/>
<div class="Pp"></div>
Note that the null string, '', and the null list, (), are two very different
  things. Assigning the null string to a variable is a valid operation, but it
  does not remove its definition.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
null = '' empty = () echo $#null $#empty
</pre>
<br/>
<div class="Pp"></div>
produces the output
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
1 0
</pre>
<br/>
<h2 class="Ss" title="Ss" id="List_Concatenation"><a class="selflink" href="#List_Concatenation">List
  Concatenation</a></h2>
Two lists may be joined by the concatenation operator (^). Concatenation works
  according to the following rules: if the two lists have the same number of
  elements, then concatenation is pairwise:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo (a- b- c-)^(1 2 3)
</pre>
<br/>
<div class="Pp"></div>
produces the output
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a-1 b-2 c-3
</pre>
<br/>
<div class="Pp"></div>
Otherwise, at least one of the lists must have a single element, and then the
  concatenation is distributive:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
cc -^(O g c) (malloc alloca)^.c
</pre>
<br/>
<div class="Pp"></div>
has the effect of performing the command
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
cc -O -g -c malloc.c alloca.c
</pre>
<br/>
<div class="Pp"></div>
A single word is a list of length one, so
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo foo^bar
</pre>
<br/>
<div class="Pp"></div>
produces the output
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
foobar
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Free_Carets"><a class="selflink" href="#Free_Carets">Free
  Carets</a></h2>
<i>rc</i> inserts carets (concatenation operators) for free in certain
  situations, in order to save some typing on the user's behalf. For example,
  the above example could also be typed in as:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
opts=(O g c) files=(malloc alloca) cc -$opts $files.c
</pre>
<br/>
<div class="Pp"></div>
<i>rc</i> takes care to insert a free-caret between the ``-'' and $opts, as well
  as between $files and .c. The rule for free carets is as follows: if a word or
  keyword is immediately followed by another word, keyword, dollar-sign or
  backquote, then <i>rc</i> inserts a caret between them.
<h2 class="Ss" title="Ss" id="Variables"><a class="selflink" href="#Variables">Variables</a></h2>
A list may be assigned to a variable, using the notation:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
<i>var</i> = <i>list</i>
</pre>
<br/>
<div class="Pp"></div>
The special variable * may also be assigned to using this notation; <i>rc</i>
  has no <b>set</b> builtin.
<div class="Pp"></div>
Any non-empty sequence of characters, except a sequence including only digits,
  may be used as a variable name. Any character except = may be used, but
  special characters must be quoted. All user-defined variables are exported
  into the environment.
<div class="Pp"></div>
The value of a variable is referenced with the dollar ($) operator:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$ <i>var</i>
</pre>
<br/>
<div class="Pp"></div>
Any variable which has not been assigned a value returns the null list, (), when
  referenced. Multiple references are allowed:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a = foo
b = a
echo $ $ b
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
foo
</pre>
<br/>
<div class="Pp"></div>
A variable's definition may also be removed by assigning the null list to a
  variable:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
<i>var</i>=()
</pre>
<br/>
<div class="Pp"></div>
For ``free careting'' to work correctly, <i>rc</i> must make certain assumptions
  about what characters may appear in a variable name. <i>rc</i> assumes that a
  variable name consists only of alphanumeric characters, underscore (_) and
  star (*). To reference a variable with other characters in its name, quote the
  variable name. Thus:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo $'we$Ird:Variab!le'
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Local_Variables"><a class="selflink" href="#Local_Variables">Local
  Variables</a></h2>
Any number of variable assignments may be made local to a single command by
  typing:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a=foo b=bar ... command
</pre>
<br/>
<div class="Pp"></div>
The command may be a compound command, so for example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
path=. ifs=() {
    ...
}
</pre>
<br/>
<div class="Pp"></div>
sets path to . and removes ifs for the duration of one long compound command.
<h2 class="Ss" title="Ss" id="Variable_Subscripts"><a class="selflink" href="#Variable_Subscripts">Variable
  Subscripts</a></h2>
Variables may be subscripted with the notation
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$var( <i>n</i>)
</pre>
<br/>
<div class="Pp"></div>
where <i>n</i> is a list of integers (origin 1). The opening parenthesis must
  immediately follow the variable name. The list of subscripts need not be in
  order or even unique. Thus,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a=(one two three)
echo $a(3 3 3)
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
three three three
</pre>
<br/>
<div class="Pp"></div>
If <i>n</i> references a nonexistent element, then $var( <i>n</i>) returns the
  null list. The notation $ <i>n</i>, where <i>n</i> is an integer, is a
  shorthand for $*( <i>n</i>). Thus, <i>rc</i>'s arguments may be referred to as
  $1, $2, and so on.
<div class="Pp"></div>
Note also that the list of subscripts may be given by any of <i>rc</i>'s list
  operations:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$var(`{awk 'BEGIN{for(i=1;i&lt;=10;i++)print i;exit; }'})
</pre>
<br/>
<div class="Pp"></div>
returns the first 10 elements of $var.
<div class="Pp"></div>
To count the number of elements in a variable, use
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$#var
</pre>
<br/>
<div class="Pp"></div>
This returns a single-element list, with the number of elements in $var.
<h2 class="Ss" title="Ss" id="Flat_Lists"><a class="selflink" href="#Flat_Lists">Flat
  Lists</a></h2>
In order to create a single-element list from a multi-element list, with the
  components space-separated, use the dollar-caret ($^) operator:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$^var
</pre>
<br/>
<div class="Pp"></div>
This is useful when the normal list concatenation rules need to be bypassed. For
  example, to append a single period at the end of $path, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo $^path.
</pre>
<br/>
<div class="Pp"></div>
For compability with the Plan 9 rc,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$&quot;var
</pre>
<br/>
<div class="Pp"></div>
is accepted as a synonym for dollar-caret.
<h2 class="Ss" title="Ss" id="Backquote_Substitution"><a class="selflink" href="#Backquote_Substitution">Backquote
  Substitution</a></h2>
A list may be formed from the output of a command by using backquote
  substitution:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
`{ command }
</pre>
<br/>
<div class="Pp"></div>
returns a list formed from the standard output of the command in braces. $ifs is
  used to split the output into list elements. By default, $ifs has the value
  space-tab-newline. The braces may be omitted if the command is a single word.
  Thus `ls may be used instead of `{ls}. This last feature is useful when
  defining functions that expand to useful argument lists. A frequent use is:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn src { echo *.[chy] }
</pre>
<br/>
<div class="Pp"></div>
followed by
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
wc `src
</pre>
<br/>
<div class="Pp"></div>
(This will print out a word-count of all C source files in the current
  directory.)
<div class="Pp"></div>
In order to override the value of $ifs for a single backquote substitution, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
`` (ifs-list) { command }
</pre>
<br/>
<div class="Pp"></div>
$ifs will be temporarily ignored and the command's output will be split as
  specified by the list following the double backquote. For example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
`` ($nl :) {cat /etc/passwd}
</pre>
<br/>
<div class="Pp"></div>
splits up /etc/passwd into fields, assuming that $nl contains a newline as its
  value.
<h1 class="Sh" title="Sh" id="SPECIAL_VARIABLES"><a class="selflink" href="#SPECIAL_VARIABLES">SPECIAL
  VARIABLES</a></h1>
Several variables are known to <i>rc</i> and are treated specially. In the
  following list, ``default'' indicates that <i>rc</i> gives the variable a
  default value on startup; ``no-export'' indicates that the variable is never
  exported; and ``read-only'' indicates that an attempt to set the variable will
  silently have no effect.
<div class="Pp"></div>
Also, ``alias'' means that the variable is aliased to the same name in capitals.
  For example, an assignment to $cdpath causes an automatic assignment to
  $CDPATH, and vice-versa. If $CDPATH is set when <i>rc</i> is started, its
  value is imported into $cdpath. $cdpath and $path are <i>rc</i> lists; $CDPATH
  and $PATH are colon-separated lists. Only the names spelt in capitals are
  exported into the environment.
<dl class="Bl-tag">
  <dt class="It-tag">* (no-export)</dt>
  <dd class="It-tag">The argument list of <i>rc</i>. $1, $2, etc. are the same
      as $*(1), $*(2), etc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">0 (default no-export)</dt>
  <dd class="It-tag">The variable $0 holds the value of argv[0] with which
      <i>rc</i> was invoked. Additionally, $0 is set to the name of a function
      for the duration of the execution of that function, and $0 is also set to
      the name of the file being interpreted for the duration of a . command. $0
      is not an element of $*, and is never treated as one.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">apid (no-export)</dt>
  <dd class="It-tag">The process ID of the last process started in the
      background.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">apids (no-export read-only)</dt>
  <dd class="It-tag">A list whose elements are the process IDs of all background
      processes which are still alive, or which have died and have not been
      waited for yet.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">bqstatus (no-export)</dt>
  <dd class="It-tag">The exit status of the <i>rc</i> forked to execute the most
      recent backquote substitution. Note that, unlike $status, $bqstatus is
      always a single element list (see <b>EXIT STATUS</b> below). For example:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
echo foo |grep bar; whatis status
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">prints
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
status=(0 1)
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">whereas
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
x=`{echo foo |grep bar}; whatis bqstatus
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">prints
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
bqstatus=1
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cdpath (alias)</dt>
  <dd class="It-tag">A list of directories to search for the target of a
      <b>cd</b> command. The empty string stands for the current directory. Note
      that if the $cdpath variable does not contain the current directory, then
      the current directory will not be searched; this allows directory
      searching to begin in a directory other than the current directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">history</dt>
  <dd class="It-tag">$history contains the name of a file to which commands are
      appended as <i>rc</i> reads them. This facilitates the use of a
      stand-alone history program (such as <i>history</i>(1)) which parses the
      contents of the history file and presents them to <i>rc</i> for
      reinterpretation. If $history is not set, then <i>rc</i> does not append
      commands to any file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">home (alias)</dt>
  <dd class="It-tag">The default directory for the builtin <b>cd</b> command,
      and the directory in which <i>rc</i> looks to find its initialization
      file, .rcrc, if <i>rc</i> has been started up as a login shell.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifs (default)</dt>
  <dd class="It-tag">The internal field separator, used for splitting up the
      output of backquote commands for digestion as a list. On startup,
      <i>rc</i> assigns the list containing the characters space, tab, and
      newline to $ifs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">path (alias)</dt>
  <dd class="It-tag">This is a list of directories to search in for commands.
      The empty string stands for the current directory. If neither $PATH nor
      $path is set at startup time, $path assumes a default value suitable for
      your system. This is typically (/usr/local/bin /usr/bin /usr/ucb /bin
    .)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pid (default no-export)</dt>
  <dd class="It-tag">On startup, $pid is initialized to the numeric process ID
      of the currently running <i>rc</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">prompt (default)</dt>
  <dd class="It-tag">This variable holds the two prompts (in list form, of
      course) that <i>rc</i> prints. $prompt(1) is printed before each command
      is read, and $prompt(2) is printed when input is expected to continue on
      the next line. <i>rc</i> sets $prompt to ('; ' '') by default. The reason
      for this is that it enables an <i>rc</i> user to grab commands from
      previous lines using a mouse, and to present them to <i>rc</i> for
      re-interpretation; the semicolon prompt is simply ignored by <i>rc</i>.
      The null $prompt(2) also has its justification: an <i>rc</i> script, when
      typed interactively, will not leave $prompt(2)'s on the screen, and can
      therefore be grabbed by a mouse and placed directly into a file for use as
      a shell script, without further editing being necessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">prompt (function)</dt>
  <dd class="It-tag">If this function is defined, then it gets executed every
      time <i>rc</i> is about to print $prompt(1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">status (no-export read-only)</dt>
  <dd class="It-tag">The exit status of the last command. If the command exited
      with a numeric value, that number is the status. If the command died with
      a signal, the status is the name of that signal; if a core file was
      created, the string ``+core'' is appended. The value of $status for a
      pipeline is a list, with one entry, as above, for each process in the
      pipeline. For example, the command
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
ls | wc
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">usually sets $status to (0 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">version (default)</dt>
  <dd class="It-tag">On startup, the first element of this list variable is
      initialized to a string which identifies this version of <i>rc</i>. The
      second element is initialized to a string which can be found by
      <i>ident</i>(1) and the <i>what</i> command of <i>sccs</i>(1).</dd>
</dl>
<h1 class="Sh" title="Sh" id="FUNCTIONS"><a class="selflink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<i>rc</i> functions are identical to <i>rc</i> scripts, except that they are
  stored in memory and are automatically exported into the environment. A shell
  function is declared as:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn name { commands }
</pre>
<br/>
<div class="Pp"></div>
<i>rc</i> scans the definition until the close-brace, so the function can span
  more than one line. The function definition may be removed by typing
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn name
</pre>
<br/>
<div class="Pp"></div>
(One or more names may be specified. With an accompanying definition, all names
  receive the same definition. This is sometimes useful for assigning the same
  signal handler to many signals. Without a definition, all named functions are
  deleted.) When a function is executed, $* is set to the arguments to that
  function for the duration of the command. Thus a reasonable definition for l,
  a shorthand for <i>ls</i>(1), could be:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn l { ls -FC $* }
</pre>
<br/>
<div class="Pp"></div>
but not
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn l { ls -FC } # WRONG
</pre>
<br/>
<h1 class="Sh" title="Sh" id="INTERRUPTS_AND_SIGNALS"><a class="selflink" href="#INTERRUPTS_AND_SIGNALS">INTERRUPTS
  AND SIGNALS</a></h1>
<i>rc</i> recognizes a number of signals, and allows the user to define shell
  functions which act as signal handlers. <i>rc</i> by default traps SIGINT when
  it is in interactive mode. SIGQUIT and SIGTERM are ignored, unless <i>rc</i>
  has been invoked with the -d flag. However, user-defined signal handlers may
  be written for these and all other signals. The way to define a signal handler
  is to write a function by the name of the signal in lower case. Thus:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn sighup { echo hangup; rm /tmp/rc$pid.*; exit }
</pre>
<br/>
<div class="Pp"></div>
In addition to Unix signals, <i>rc</i> recognizes the artificial signal SIGEXIT
  which occurs as <i>rc</i> is about to exit.
<div class="Pp"></div>
In order to remove a signal handler's definition, remove it as though it were a
  regular function. For example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn sigint
</pre>
<br/>
<div class="Pp"></div>
returns the handler of SIGINT to the default value. In order to ignore a signal,
  set the signal handler's value to {}. Thus:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn sigint {}
</pre>
<br/>
<div class="Pp"></div>
causes SIGINT to be ignored by the shell. Only signals that are being ignored
  are passed on to programs run by <i>rc</i>; signal functions are not exported.
<div class="Pp"></div>
On System V-based Unix systems, <i>rc</i> will not allow you to trap SIGCLD.
<h1 class="Sh" title="Sh" id="BUILTIN_COMMANDS"><a class="selflink" href="#BUILTIN_COMMANDS">BUILTIN
  COMMANDS</a></h1>
Builtin commands execute in the context of the shell, but otherwise behave
  exactly like other commands. Although <b>!</b>, <b>~</b> and <b>@</b> are not
  strictly speaking builtin commands, they can usually be used as such.
<dl class="Bl-tag">
  <dt class="It-tag"><b>.</b> [<b>-i</b>] <i>file </i>[<i>arg ...</i>]</dt>
  <dd class="It-tag">Reads <i>file</i> as input to <i>rc</i> and executes its
      contents. With a -i flag, input is interactive. Thus from within a shell
      script,
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
. -i /dev/tty
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">does the ``right thing''.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>break</b></dt>
  <dd class="It-tag">Breaks from the innermost for or while, as in C. It is an
      error to invoke <b>break</b> outside of a loop. (Note that there is no
      <b>break</b> keyword between commands in switch statements, unlike
    C.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>builtin </b><i>command </i>[<i>arg ...</i>]</dt>
  <dd class="It-tag">Executes the command ignoring any function definition of
      the same name. This command is present to allow functions with the same
      names as builtins to use the underlying builtin or binary. For example:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
fn ls { builtin ls -FC $* }
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">is a reasonable way to pass a default set of arguments to
      ls(1), whereas
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
fn ls { ls -FC $* } # WRONG
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">is a non-terminating recursion, which will cause rc to
      exhaust its stack space and (eventually) terminate if it is executed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cd </b>[<i>directory</i>]</dt>
  <dd class="It-tag">Changes the current directory to <i>directory</i>. The
      variable $cdpath is searched for possible locations of <i>directory</i>,
      analogous to the searching of $path for executable files. With no
      argument, <b>cd</b> changes the current directory to $home.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>echo </b>[<b>-n</b>] [<b>--</b>] [<i>arg ...</i>]</dt>
  <dd class="It-tag">Prints its arguments to standard output, terminated by a
      newline. Arguments are separated by spaces. If the first argument is -n no
      final newline is printed. If the first argument is --, then all other
      arguments are echoed literally. This is used for echoing a literal
    -n.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>eval </b>[<i>list</i>]</dt>
  <dd class="It-tag">Concatenates the elements of <i>list</i> with spaces and
      feeds the resulting string to <i>rc</i> for re-scanning. This is the only
      time input is rescanned in <i>rc</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exec </b>[<i>arg ...</i>]</dt>
  <dd class="It-tag">Replaces <i>rc</i> with the given command. If the exec
      contains only redirections, then these redirections apply to the current
      shell and the shell does not exit. For example,
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
exec &gt;[2] err.out
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">places further output to standard error in the file
      <i>err.out</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exit </b>[<i>status</i>]</dt>
  <dd class="It-tag">Cause the current shell to exit with the given exit
      <i>status</i>. If no argument is given, the current value of $status is
      used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>limit </b>[<b>-h</b>] [<i>resource
    </i>[<i>value</i>]]</dt>
  <dd class="It-tag">Similar to the <i>csh</i>(1) <b>limit</b> builtin, this
      command operates upon the BSD-style resource limits of a process. The -h
      flag displays/alters the hard limits. The resources which can be shown or
      altered are <b>cputime</b>, <b>filesize</b>, <b>datasize</b>,
      <b>stacksize</b>, <b>coredumpsize</b>, <b>memoryuse</b>, and, where
      supported, <b>descriptors</b>, <b>memoryuse</b>, <b>memoryrss</b>,
      <b>maxproc</b>, <b>memorylocked</b>, and <b>filelocks</b>. For example:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
limit coredumpsize 0
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">disables core dumps. To set a soft limit equal to the hard
      limit:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
limit `{limit -h datasize}
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>newpgrp</b></dt>
  <dd class="It-tag">Puts <i>rc</i> into a new process group. This builtin is
      useful for making <i>rc</i> behave like a job-control shell in a hostile
      environment. One example is the NeXT Terminal program, which implicitly
      assumes that each shell it forks will put itself into a new process
    group.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>return </b>[<i>n</i>]</dt>
  <dd class="It-tag">Returns from the current function, with status <i>n</i>,
      where <i>n</i> is a valid exit status, or a list of them. Thus it is legal
      to have
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
return (sigpipe 1 2 3)
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">(This is commonly used to allow a function to return with
      the exit status of a previously executed pipeline of commands.) If
      <i>n</i> is omitted, then $status is left unchanged. It is an error to
      invoke <b>return</b> when not inside a function.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>shift </b>[<i>n</i>]</dt>
  <dd class="It-tag">Deletes <i>n</i> elements from the beginning of $* and
      shifts the other elements down by <i>n</i>. <i>n</i> defaults to 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>umask </b>[<i>mask</i>]</dt>
  <dd class="It-tag">Sets the current umask (see <i>umask</i>(2)) to the octal
      <i>mask</i>. If no argument is present, the current mask value is
    printed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>wait </b>[<i>pid</i>]</dt>
  <dd class="It-tag">Waits for process with the specified <i>pid</i>, which must
      have been started by <i>rc</i>, to exit. If no <i>pid</i> is specified,
      <i>rc</i> waits for all its child processes to exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>whatis </b>[<b>-b</b>] [<b>-f</b>] [<b>-p</b>]
    [<b>-s</b>] [ <b>-v</b>] [<b>--</b>] [<i>name ...</i>]</dt>
  <dd class="It-tag">Prints a definition of the named objects. For builtins,
      builtin <i>foo</i> is printed; for functions, including signal handlers,
      their definitions are printed; for executable files, path names are
      printed; and for variables, their values are printed. The flags restrict
      output to builtins, functions, executable programs, signal handlers, and
      variables, respectively. If no <i>name</i>s are specified, <i>rc</i> lists
      all objects of that type. (This is not permitted for -p.) Without
      arguments, whatis is equivalent to whatis -fv, and prints the values of
      all shell variables and functions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that <b>whatis</b> output is suitable for input to
      <i>rc</i>; by saving the output of <b>whatis</b> in a file, it should be
      possible to recreate the state of <i>rc</i> by sourcing this file with a .
      command. Another note: whatis -s &gt; file cannot be used to store the
      state of <i>rc</i>'s signal handlers in a file, because builtins with
      redirections are run in a subshell, and <i>rc</i> always restores signal
      handlers to their default value after a fork().</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Since <b>whatis</b> uses <i>getopt</i>(3) to parse its
      arguments, you can use the special argument -- to terminate its flags.
      This allows you to use names beginning with a dash, such as the
      <i>history</i>(1) commands. For example,
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
whatis -- -p
    </pre>
    <br/>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
The <b>shift</b> builtin only shifts $*. This function can shift any variable
  (except $lshift).
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn lshift { lshift=$*; *=$$1; shift $lshift(2); $lshift(1)=$* }
</pre>
<br/>
<div class="Pp"></div>
With this definition in place,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
walrus = (shoes ships sealing-wax cabbages kings)
lshift walrus 3
whatis walrus
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
walrus=(cabbages kings)
</pre>
<br/>
<div class="Pp"></div>
The $^var operator flattens a list by separating each element with a space. This
  function allows the separator to be an arbitrary string.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn lflat {
  lflat=$*; *=$$1
  while () {
    echo -n $1; shift
    ~ $#* 0 &amp;&amp; break
    echo -n $lflat(2)
}
</pre>
<br/>
<div class="Pp"></div>
With this definition in place,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
hops=(uunet mcvax ukc tlg)
lflat hops !
</pre>
<br/>
<div class="Pp"></div>
prints (with no final newline)
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
uunet!mcvax!ukc!tlg
</pre>
<br/>
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
The exit status of <i>rc</i> is normally the same as that of the last command
  executed. If the last command was a pipeline, <i>rc</i> exits 0 if every
  command in the pipeline did; otherwise it exits 1.
<div class="Pp"></div>
<i>rc</i> can be made to exit with a particular status using the <b>exit</b>
  builtin.
<h1 class="Sh" title="Sh" id="GRAMMAR"><a class="selflink" href="#GRAMMAR">GRAMMAR</a></h1>
Here is <i>rc</i>'s grammar, edited to remove semantic actions.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
%term ANDAND BACKBACK BANG CASE COUNT DUP ELSE END FLAT FN FOR IF IN
%term OROR PIPE REDIR SUB SUBSHELL SWITCH TWIDDLE WHILE WORD HUH
<div class="Pp"></div>
%left WHILE ')' ELSE
%left ANDAND OROR '\n'
%left BANG SUBSHELL
%left PIPE
%right '$'
%left SUB
<div class="Pp"></div>
%start rc
<div class="Pp"></div>
%%
<div class="Pp"></div>
rc: line end
	| error end
<div class="Pp"></div>
end: END /* EOF */ | '\n'
<div class="Pp"></div>
cmdsa: cmd ';' | cmd '&amp;'
<div class="Pp"></div>
line: cmd | cmdsa line
<div class="Pp"></div>
body: cmd | cmdsan body
<div class="Pp"></div>
cmdsan: cmdsa | cmd '\n'
<div class="Pp"></div>
brace: '{' body '}'
<div class="Pp"></div>
paren: '(' body ')'
<div class="Pp"></div>
assign: first '=' word
<div class="Pp"></div>
epilog: /* empty */ | redir epilog
<div class="Pp"></div>
redir: DUP | REDIR word
<div class="Pp"></div>
case: CASE words ';' | CASE words '\n'
<div class="Pp"></div>
cbody: cmd | case cbody | cmdsan cbody
<div class="Pp"></div>
iftail: cmd	%prec ELSE
	| brace ELSE optnl cmd
<div class="Pp"></div>
cmd	: /* empty */	%prec WHILE
	| simple
	| brace epilog
	| IF paren optnl iftail
	| FOR '(' word IN words ')' optnl cmd
	| FOR '(' word ')' optnl cmd
	| WHILE paren optnl cmd	
	| SWITCH '(' word ')' optnl '{' cbody '}'
	| TWIDDLE optcaret word words
	| cmd ANDAND optnl cmd
	| cmd OROR optnl cmd
 	| cmd PIPE optnl cmd
	| redir cmd	%prec BANG
	| assign cmd	%prec BANG
	| BANG optcaret cmd
	| SUBSHELL optcaret cmd
	| FN words brace
	| FN words
<div class="Pp"></div>
optcaret: /* empty */ | '^'
<div class="Pp"></div>
simple: first | simple word | simple redir
<div class="Pp"></div>
first: comword | first '^' sword
<div class="Pp"></div>
sword: comword | keyword
<div class="Pp"></div>
word: sword | word '^' sword
<div class="Pp"></div>
comword: '$' sword
	| '$' sword SUB words ')'
	| COUNT sword
	| FLAT sword
	| '`' sword
	| '`' brace
	| BACKBACK word	brace | BACKBACK word sword
	| '(' words ')'
	| REDIR brace
	| WORD
<div class="Pp"></div>
keyword: FOR | IN | WHILE | IF | SWITCH
	| FN | ELSE | CASE | TWIDDLE | BANG | SUBSHELL
<div class="Pp"></div>
words: /* empty */ | words word
<div class="Pp"></div>
optnl: /* empty */ | optnl '\n'
</pre>
<br/>
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
$HOME/.rcrc, /tmp/rc*, /dev/null
<h1 class="Sh" title="Sh" id="CREDITS"><a class="selflink" href="#CREDITS">CREDITS</a></h1>
<i>rc</i> was written by Byron Rakitzis, with valuable help from Paul Haahr,
  Hugh Redelmeier and David Sanderson. The design of this shell was copied from
  the <i>rc</i> that Tom Duff wrote at Bell Labs.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
There is a compile-time limit on the number of ; separated commands in a line:
  usually 500. This is sometimes a problem for automatically generated scripts:
  substituting the newline character for ; avoids the limit.
<div class="Pp"></div>
On modern systems that support /dev/fd or /proc/self/fd, &lt;{foo} style
  redirection is implemented that way. However, on older systems it is
  implemented with named pipes. Allegedly, it is sometimes possible to foil
  <i>rc</i> into removing the FIFO it places in /tmp prematurely, or it is even
  possible to cause <i>rc</i> to hang. (The current maintainer has never seen
  this, but then he doesn't use systems which lack /dev/fd any more. If anybody
  can reproduce this problem, please let the maintainer know.)
<div class="Pp"></div>
The <b>echo</b> command does not need to be a builtin. It is one for reasons of
  performance and portability (of <i>rc</i> scripts).
<div class="Pp"></div>
There should be a way to avoid exporting a variable.
<div class="Pp"></div>
Extra parentheses around a ~ expression or a ! expression are a syntax error.
  Thus, this code is illegal.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
while ((~ $1 -*) &amp;&amp; (! ~ $1 --)) { ...
</pre>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag">The redundant inner parentheses must be omitted.</dt>
  <dd class="It-tag"></dd>
</dl>
<div class="Pp"></div>
Variable subscripting cannot be used in here documents.
<div class="Pp"></div>
The limit builtin silently ignores extra arguments.
<div class="Pp"></div>
Backquote substitution never produces empty strings - multiple consecutive
  occurrences of the separator are treated the same as a single occurrence.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
ifs=! { x = `{echo -n a!!b}; whatis x }
x=(a b) # NOT x=(a '' b)
</pre>
<div class="Pp"></div>
<pre>
Bug reports should be mailed to
&lt;toby@paccrat.org&gt;.
</pre>
<h1 class="Sh" title="Sh" id="INCOMPATIBILITIES"><a class="selflink" href="#INCOMPATIBILITIES">INCOMPATIBILITIES</a></h1>
Here is a list of features which distinguish this incarnation of <i>rc</i> from
  the one described in the Bell Labs manual pages:
<div class="Pp"></div>
The Tenth Edition <i>rc</i> does not have the <b>else</b> keyword. Instead,
  <b>if</b> is optionally followed by an <b>if not</b> clause which is executed
  if the preceding <b>if</b> test does not succeed.
<div class="Pp"></div>
Backquotes are slightly different in Tenth Edition <i>rc</i>: a backquote must
  always be followed by a left-brace. This restriction is not present for
  single-word commands in this <i>rc</i>.
<div class="Pp"></div>
For . <i>file</i>, the Tenth Edition <i>rc</i> searches $path for <i>file</i>.
  This <i>rc</i> does not, since it is not considered useful.
<div class="Pp"></div>
The list flattening operator, $^foo, is spelt $&quot;foo in those versions of
  the Bell Labs <i>rc</i> which have it.
<div class="Pp"></div>
The following are all new with this version of <i>rc</i>: The -n flag, here
  strings (they facilitate exporting of functions with here documents into the
  environment), the <b>return</b> and <b>break</b> keywords, the <b>echo</b>
  builtin, the bqstatus and version variables, the support for the GNU
  <i>readline</i>(3) library, and the support for the prompt function. This
  <i>rc</i> also sets $0 to the name of a function being executed/file being
  sourced.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
``rc &#x2014; A Shell for Plan 9 and UNIX Systems'', Unix Research System, Tenth
  Edition, Volume 2. (Saunders College Publishing)
<div class="Pp"></div>
http://static.tobold.org/rc/rc-duff.html, an updated version of the above paper.
<div class="Pp"></div>
<i>history</i>(1)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-05-13</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
