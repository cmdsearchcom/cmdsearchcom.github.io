<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:23:45 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKEPP_COMMAND(1) Makepp MAKEPP_COMMAND(1)</p>

<p style="margin-top: 1em">NAME <br>
makepp -- Command line syntax for makepp</p>

<p style="margin-top: 1em">DESCRIPTION <br>
?: -?, A: -A, <br>
--args-file, <br>
--arguments-file, <br>
--assume-new, <br>
--assume-old, B: -b, <br>
--build-cache, <br>
--build-check, <br>
--build-check-method, C: -C, <br>
-c, D: --defer-include, <br>
--directory, <br>
--do-build, <br>
--dont-build, <br>
--dont-read, <br>
--do-read, <br>
--dry-run, <br>
--dump-makefile, <br>
--dump-makeppfile, E: -e, <br>
--environment-overrides, <br>
--env-overrides, F: -F, <br>
-f, <br>
--file, <br>
--final-rules-only, <br>
--force-copy-from-bc, <br>
--force-rescan, G: --gullible, H: -h, <br>
--help, <br>
--hybrid, <br>
--hybrid-recursion, <br>
--hybrid-recursive-make, I: -I, <br>
--implicit-load-makeppfile-only, <br>
--include, <br>
--include-dir, <br>
--in-sandbox, <br>
--inside-sandbox, J: -j, <br>
--jobs, <br>
--just-print, K: -k, <br>
--keep-going, L: --last-chance-rules, <br>
--load-makefile, <br>
--load-makeppfile, <br>
--log, <br>
--log-file, <br>
--loop, M: -m, <br>
--makefile, <br>
$MAKEFLAGS, <br>
$MAKEPP_CASE_SENSITIVE_FILENAMES, <br>
--makeppfile, <br>
$MAKEPPFLAGS, <br>
--md5-bc, <br>
--md5-check-bc, N: -n, <br>
--new-file, <br>
--no-builtin-rules, <br>
--no-cache-scaninfos, <br>
--no-implicit-load, <br>
--no-log, <br>
--no-path-executable-dependencies, <br>
--no-path-exe-dep, <br>
--no-populate-bc, <br>
--no-print-directory, <br>
--no-remake-makefiles, <br>
--no-warn, O: -o, <br>
--old-file, <br>
--out-of-sandbox, <br>
--override-signature, <br>
--override-signature-method, P: --populate-bc-only, <br>
--profile, Q: --quiet, R: -R, <br>
-r, <br>
--recon, <br>
--remove-stale, <br>
--remove-stale-files, <br>
--repository, <br>
--rm-stale, <br>
--root-dir, <br>
--root-directory, S: -s, <br>
--sandbox, <br>
--sandbox-warn, <br>
--sandbox-warning, <br>
--signature, <br>
--signature-method, <br>
--silent, <br>
--stop, <br>
--stop-after-loading, <br>
--stop-before-building, <br>
--stop-on-race, <br>
--stop-race, <br>
--symlink-in-rep-as-file, <br>
--symlink-in-repository-as-file, T: --traditional, <br>
--traditional-recursion, <br>
--traditional-recursive-make, V: -V, <br>
-v, <br>
--verbose, <br>
--version, <br>
--virtual-sandbox, W: -W, <br>
--what-if</p>

<p style="margin-top: 1em">makepp [ option ... ] [
VAR=value ] [ target ... ]</p>

<p style="margin-top: 1em">mpp [ option ... ] [ VAR=value ]
[ target ... ]</p>

<p style="margin-top: 1em">Makepp supports most of the
command line options and syntax that other makes support.
The hyphens between the words are always optional, and can
also be replaced by an <br>
underscore. You specify a list of targets to build on the
command line. If you do not specify any targets, the first
explicit target in the makefile is built.</p>

<p style="margin-top: 1em">You can assign variables on the
command line which will override any assignment or
environment variable in every Makefile loaded, e.g.,</p>

<p style="margin-top: 1em">makepp CFLAGS=-O2</p>

<p style="margin-top: 1em">Valid options are most of the
standard make options, plus a few new ones:</p>

<p style="margin-top: 1em">-A filename <br>
--args-file=filename <br>
--arguments-file=filename <br>
Read the file and parse it as possibly quoted whitespace-
and/or newline-separated options.</p>

<p style="margin-top: 1em">-b directory <br>
--build-cache=directory <br>
Specifies the path to a build cache. See makepp_build_cache
for details. The build cache must already exist; see
&quot;How to manage a build cache&quot; in
makepp_build_cache for how <br>
to make it in the first place. Build caches defined on the
command line may be overridden by a build_cache statement in
a makefile or a :build_cache rule modifier . If you <br>
work with several different builds, it may be useful to set
the environment variable &quot;MAKEPPFLAGS&quot; to contain
&quot;--buil&quot;&quot;d-cache=/path/to/build/cache&quot;
so that all of your <br>
builds will take advantage of the build cache by
default.</p>

<p style="margin-top: 1em">--build-check=method <br>
--build-check-method=method <br>
The name of a build check method to use to decide whether
files need to be rebuilt. Possible values are
&quot;target_newer&quot;, &quot;exact_match&quot;, See
makepp_build_check for <br>
information on build check methods.</p>

<p style="margin-top: 1em">-C directory <br>
--directory=directory <br>
Cd to the given directory before loading the makefile and
trying to build the targets. This is similar to specifying a
directory with &quot;-F&quot;, except that subsequent
&quot;-C&quot;, <br>
&quot;-f&quot;, &quot;-F&quot;, &quot;-I&quot; and
&quot;-R&quot; options are interpreted relative to the new
directory, rather than the old one.</p>

<p style="margin-top: 1em">-c <br>
--root-dir <br>
--root-directory <br>
Cd up to the directory containing a RootMakeppfile.</p>

<p style="margin-top: 1em">--defer-include <br>
Workaround for include statement before the rule that builds
the include file. This happens by pretending the include
statements come last in the makefile. That way the <br>
include statement is performable, but variable overrides or
modifications may still fail, in which case you should set
the problematic ones on the command line (whereas gmake <br>
ignores any variable setting from the include file that
might influence how that file itself gets built).</p>

<p style="margin-top: 1em">--dont-build=filename <br>
--do-build=filename <br>
Do not build the specified file, or, if it is a directory,
everything thereunder, even though makepp thinks it should
-- or do build, overriding the opposite specification <br>
from a higher directory. This is useful if you built a
specific file by hand using different compilation options.
Without this option, if you compile a module by hand and
<br>
then run makepp to compile the rest of the program, makepp
will also recompile the module you compiled by hand, because
makepp cannot guarantee that the build is correct if <br>
any of the files were not built under its control. With this
option, you tell makepp that you really know what you are
doing in the case of this particular file and you <br>
promise that it&rsquo;s ok not to rebuild it.</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">% cc -g -DSPECIAL_DEBUG -c x.c
-o x.o # Special compilation by hand <br>
% makepp <br>
cc -g -O2 -c x.c -o x.o # Makepp just overrode your
compilation here! <br>
cc x.o y.o -o my_program # Relinks. <br>
% cc -g -DSPECIAL_DEBUG -c x.c -o x.o # Do it again. <br>
% makepp --dont-build x.o # Tell makepp not to rebuild x.o
even if it wants to. <br>
cc x.o y.o -o my_program # Now it relinks without
recompiling.</p>

<p style="margin-top: 1em">If you want special compilation
options for just one module, it&rsquo;s often easier to edit
the makefile than to compile by hand as in this example; see
&quot;Target-specific <br>
assignments&quot; in makepp_variables for an easy way of
doing this.</p>

<p style="margin-top: 1em">If you put a RootMakeppfile(.mk)
at the root of your build system, that directory and
everything under it defaults to &quot;--do-build&quot;,
while the overall root of your file system <br>
defaults to &quot;--dont-build&quot;. That way, everything
inside your build system is built (if necessary) but nothing
outside is attempted. If, in this scenario, you want
external <br>
parts to always be built as needed, you must explicitly pick
them up with &quot;load_makefile&quot; statements in one of
the makefiles within your tree.</p>

<p style="margin-top: 1em">You may have one
RootMakeppfile(.mk) each, in separate build trees, and they
will be loaded if one tree has dependencies in another one.
But you are not allowed to have <br>
RootMakeppfile(.mk) in nested directories, avoiding funny
effects that tend to arise when you accidentally call
&quot;makepp --repository&quot; again in a subdirectory.
These effects <br>
include duplicate rules through duplicate sources, or
eternal build cache reimports because cached files have the
right signatures but the wrong relative pathes.</p>

<p style="margin-top: 1em">Override
&quot;--dont-build&quot; for the specified file or
directory. If you have a RootMakeppfile(.mk) at the root of
your build system, but you want makepp to build something
<br>
outside of your build system just this once, you must
explicitly mark it as &quot;--do-build&quot;. If you specify
&quot;--do-build&quot; for a file or directory under a
RootMakeppfile(.mk), <br>
without &quot;--dont-build&quot; for a higher directory,
then the root (and all else under it) of your build system
defaults to &quot;--dont-build&quot;.</p>

<p style="margin-top: 1em">To resolve conflicts between
&quot;--dont-build&quot; and &quot;--do-build&quot;, the one
with the most specific path takes precedence regardless of
order. If the same path is specified with <br>
both &quot;--dont-build&quot; and &quot;--do-build&quot;,
then the rightmost one wins.</p>

<p style="margin-top: 1em">The options
&quot;--dont-build&quot; and &quot;--do-build&quot; can be
dangerous if you give the wrong hints to makepp, since you
are asking makepp not to do checks it needs, to guarantee a
<br>
correct build. But since they allow greatly reducing the
number of checks, they can speed up your builds
dramatically, as explained in potentially unsafe speedup
methods.</p>

<p style="margin-top: 1em">--dont-read=filename <br>
--do-read=filename <br>
Do not read the specified file, or, if it is a directory,
everything thereunder -- or do read, overriding the opposite
specification from a higher directory. Generate an <br>
error rather than read files marked for
&quot;--dont-read&quot;. See --sandbox. The filesystem root
always defaults to readable.</p>

<p style="margin-top: 1em">--dump-makefile=filename <br>
--dump-makeppfile=filename <br>
Dump the raw contents of the makefile(s) for the current
directory (as determined by the position of this option
relative to any &quot;-C&quot; options) to filename. Include
files are <br>
interpolated, comments are stripped out and
&quot;ifdef&quot;&rsquo;s are resolved. &quot;# line
&quot;file&quot;&quot; markers are inserted as necessary.
The final value of any non-reference scalars in the <br>
makefile&rsquo;s package are printed following the
makefile.</p>

<p style="margin-top: 1em">This is useful for debugging,
but (currently) you won&rsquo;t necessarily be able use the
dump file as an equivalent makefile, for example because it
contains both the include <br>
statement and the interpolated file.</p>

<p style="margin-top: 1em">-e <br>
--env-overrides <br>
--environment-overrides <br>
Causes variables from the environment to override
definitions in the makefile. By default, assignments within
the makefile override variable values which are imported
from <br>
the environment.</p>

<p style="margin-top: 1em">-F Makeppfile <br>
--makeppfile=Makeppfile <br>
Loads the specified Makefile or, if you specify a directory,
the Makefile therein, instead of the one in the current
directory -- any target specified to the right of this <br>
option is interpreted relative to the directory containing
the Makefile. For the details of the directory case and
RootMakeppfile see the explanation at the next option.</p>

<p style="margin-top: 1em">This option can be useful if you
execute makepp from unpredictable directories. For example,
if you compile from within emacs and you have sources
scattered all over your <br>
directory tree, the current working directory for the
compilation command will be the directory the last source
file you edited was in, which may or may not be the top
level <br>
directory for your compilation. However, you can specify
your compilation command as</p>

<p style="margin-top: 1em">makepp -F
/your/source/dir/top</p>

<p style="margin-top: 1em">and this will work no matter
what your current directory is.</p>

<p style="margin-top: 1em">Because this option
doesn&rsquo;t affect the directory relative to which
subsequent &quot;-C&quot;, &quot;-f&quot;, &quot;-F&quot;,
&quot;-I&quot; and &quot;-R&quot; options are specified, you
can make targets relative to the <br>
current directory like this:</p>

<p style="margin-top: 1em">makepp -F /foo/bar -C .
mytarget</p>

<p style="margin-top: 1em">-f Makefile <br>
--file=Makefile <br>
--makefile=Makefile <br>
Loads the specified Makefile or, if you specify a directory,
the Makefile therein, instead of the one in the current
directory. If you do not specify the &quot;-f&quot; option
or the <br>
&quot;-F&quot; option, makepp looks first for a file in the
current directory (or the directory specified by the
rightmost &quot;-C&quot; option, if any) called, then
RootMakeppfile.mk, <br>
Makeppfile, then Makeppfile.mk, then makefile, then
Makefile. Multiple &quot;-F&quot; and &quot;-f&quot; options
may be specified.</p>

<p style="margin-top: 1em">The first two (RootMakeppfile)
are special (whether given explicitly or found implicitly).
There must be at most one of those two in any given build
tree on which makepp is <br>
to operate. But there may be several if you build several
disjoint trees in one go. Those two are looked for not only
in the aforementioned directory, but also upwards from <br>
there. If one is found, it is loaded before any other.</p>

<p style="margin-top: 1em">--final-rules-only <br>
Ignore the dependencies and implicit targets of the rule
unless the target is phony.</p>

<p style="margin-top: 1em">--force-copy-from-bc <br>
When using build caches, always copy files in and out of the
cache, even if the source and target are on the same
filesystem. This is mainly useful for testing (emulating)
<br>
the case in which they are not.</p>

<p style="margin-top: 1em">--force-rescan <br>
Don&rsquo;t use cached scanner results from previous
runs.</p>

<p style="margin-top: 1em">--gullible <br>
Believe that the rules create what they declare, rather than
checking. This is faster, but doesn&rsquo;t catch bugs in
rules.</p>

<p style="margin-top: 1em">-? <br>
-h <br>
--help <br>
Print out a brief summary of the options.</p>

<p style="margin-top: 1em">--hybrid <br>
--hybrid-recursion <br>
--hybrid-recursive-make <br>
This option is present to allow makepp to work with old
makefiles that use recursive make extensively, especially
multiply into the same dir. By default, recursive make is
<br>
implemented by a subprocess that communicates with the
parent process; the build is actually done by the parent
process. This allows some of makepp&rsquo;s nice features
like <br>
repositories to work with recursive make invocations.
However, this technique will not work if you load more than
one makefile from the same directory. In that case this <br>
option says to fall back to starting another independent
instance of makepp. If this fails, try
&quot;--traditional-recursive-make&quot;.</p>

<p style="margin-top: 1em">If you do use this option, you
will get log files in the each directory the fall back
occurred in. To get rid of only them use &quot;makeppclean
--logs --recurse&quot; or &quot;mppc -lr&quot;.</p>

<p style="margin-top: 1em">-I directory <br>
--include=directory <br>
--include-dir=directory <br>
Search the given directory for included makefiles.</p>

<p style="margin-top: 1em">--implicit-load-makeppfile-only
<br>
If implicit loading of makefiles is enabled, then
automatically load only a file called RootMakeppfile,
RootMakeppfile.mk, Makeppfile, or Makeppfile.mk, and not
makefile or <br>
Makefile. This is useful if makepp has dependencies that are
generated by some other flavor of make, and makepp
can&rsquo;t read that flavor&rsquo;s makefiles in general.
(You want to <br>
avoid this situation if possible, but it tends to arise
while you&rsquo;re in the process of porting a legacy build
system to makepp.) This has no effect if implicit loading is
<br>
disabled.</p>

<p style="margin-top: 1em">-j n <br>
--jobs=n <br>
Interprets the argument n as the number of shell commands
that can be executed in parallel. By default, makepp does
not execute commands in parallel.</p>

<p style="margin-top: 1em">Unlike some other versions of
make, when jobs are executed in parallel, makepp directs
their output to a file and only displays the output when the
commands have finished. <br>
This prevents output from several different commands from
being mixed together on the display, but it does mean that
you might have to wait a little longer to see the output,
<br>
and stderr messages will usually appear before stdout stuff,
differing from terminal output.</p>

<p style="margin-top: 1em">Native Windows Perls (i.e.
Strawberry and ActiveState), because they do not support the
Unix fork/exec paradigm, do not allow this option (Cygwin
works fine!). As a partial <br>
replacement, you can use the --sandbox option there, though
this is far less comfortable.</p>

<p style="margin-top: 1em">-k <br>
--keep-going <br>
Build as many files as safely possible, even if some
commands have errors. By default, makepp stops when it
encounters the first error, even if there are other files
that <br>
need to be built that don&rsquo;t depend on the erroneous
file.</p>

<p style="margin-top: 1em">--last-chance-rules <br>
Activate limited special handling for pattern rules with
&rsquo;%&rsquo; only on the target side. This is needed
because normally, unlike traditional makes, makepp
instantiates all <br>
rules with all available files from the bottom up, allowing
it to find all creatable dependencies.</p>

<p style="margin-top: 1em">--load-makefile=Makefile <br>
--load-makeppfile=Makefile <br>
Loads the specified makefile before any other makefiles,
except for RootMakeppfile, or RootMakeppfile.mk above it,
but do not consider this option for the purposes of <br>
determining the default target. If no other makefile is
specified, then one is sought using the usual rules. If the
specified makefile is the same makefile that is found <br>
using the usual rules, then this option has no effect.</p>

<p style="margin-top: 1em">--log=logfilename <br>
--log-file=logfilename <br>
Changes the name of the log file to the indicated name. By
default, the log file is called .makepp/log. This file is
readable with makepplog, mppl.</p>

<p style="margin-top: 1em">--loop <br>
--stop <br>
--stop-before-building <br>
--stop-after-loading <br>
Makepp will repeatedly stop itself (go to sleep), before it
analyzes and builds anything, for you to wake it up when you
are ready. It will tell you some commands to choose <br>
from for waking it up again. If you do it in a Shell, you
get the prompt and can then fore- or background it. If you
do it within an IDE, it&rsquo;ll just sleep, and you can
<br>
awaken it from another Shell. Depending on where you start
it, closing that window may or may not terminate makepp, so
check how to cope with this in your environment.</p>

<p style="margin-top: 1em">The intention is that you can
start makepp this way before you&rsquo;re finished editing
some files. Depending on your project structure and size,
this can allow makepp to get a <br>
headstart of many seconds worth of work by the time
you&rsquo;re done. Then every time you can edit more and
awaken it again, unless you change something in your
Makefile, which <br>
will go unnoticed until you start a new instance of makepp.
The same applies to repositories, which must never change
while makepp is running.</p>

<p style="margin-top: 1em">If you use &quot;prebuild&quot;
or &quot;$(make)&quot;, on the first round it will stop when
it gets to that point.</p>

<p style="margin-top: 1em">-m method <br>
--signature=method <br>
--signature-method=method <br>
Specifies the default signature method to use for rules
which do not have the &quot;:signature&quot; modifier in
makefiles which do not have a &quot;signature&quot;
statement. Does not override <br>
the choice made by command parsers, e.g. C/C++ compilers.
Possible values are &quot;md5&quot;, &quot;C&quot; or
&quot;c_compilation_md5&quot;, &quot;xml&quot; and
&quot;xml-space&quot;. For more details, see <br>
makepp_signatures.</p>

<p style="margin-top: 1em">--md5-bc <br>
--md5-check-bc <br>
When importing from a build cache, reject cached targets
unless the MD5_SUM is present and matches the imported
target. When populating a build cache, calculate and store
<br>
the MD5_SUM in the build info if it isn&rsquo;t there
already. This is slower and leads to more rebuilds, but it
guarantees that imported targets and build info files
correspond <br>
exactly.</p>

<p style="margin-top: 1em">-n <br>
--dry-run <br>
--just-print <br>
--recon <br>
Print out commands without actually executing them --
unreliably where commands depend on previous results. This
allows you to see what makepp will do, without actually <br>
changing any files.</p>

<p style="margin-top: 1em">More precisely, makepp executes
all recursive make commands as normal (but hopefully
you&rsquo;re not using recursive make anywhere!). Other
commands are simply printed without <br>
being executed. Even commands which are prefixed with
&quot;@&quot; or &quot;noecho&quot; are printed after the
&quot;@&quot; or &quot;noecho&quot; is stripped off. However
commands prefixed with &quot;+&quot; should be <br>
executed, but currently are not.</p>

<p style="margin-top: 1em">Warning: The commands that
makepp executes with &quot;-n&quot; are not necessarily the
same thing it will do without &quot;-n&quot;. File
signatures do not change at all with &quot;-n&quot;, which
means <br>
that makepp cannot perform exactly the same build tests that
it does when the signatures are changing. This will
occasionally make a difference if you are using MD5 <br>
signatures (which is the default for compilation commands)
or if you have shell commands that might or might not change
the date.</p>

<p style="margin-top: 1em">For example, suppose that you
generate a .h file via some sort of preprocessor. This can
happen in a lot of different ways. For concreteness, suppose
you automatically <br>
generate a list of prototypes for functions defined in each
C module (see &lt;http://cproto.sourceforge.net/&gt; for how
the &quot;cproto&quot; application works or <br>
&lt;http://www.lemoda.net/c/cfunctions/&gt; for the similar
cfunctions).</p>

<p style="margin-top: 1em">prototypes.h : *.c <br>
cproto $(CPPFLAGS) $(inputs) &gt; $(output)</p>

<p style="margin-top: 1em">Then each .c file will include
prototypes.h. The purpose of this is to maintain the forward
declarations for all functions automatically, so if you
change a function&rsquo;s <br>
signature or add a new function, you don&rsquo;t ever have
to put in forward or extern declarations anywhere. You
don&rsquo;t even have to declare the dependency of your .o
files on <br>
this one -- makepp will see the include statement and
automatically see if it needs to (re)run cproto.</p>

<p style="margin-top: 1em">Now suppose you change just one
.c file. What happens when you run makepp with
&quot;-n&quot; in this case is that it realizes that
prototypes.h needs to be remade. In all <br>
probability, remaking prototypes.h won&rsquo;t affect its
signature--the file contents will probably be identical
because no function arguments have been changed--so most of
the <br>
time, nothing that depends on prototypes.h actually has to
be recompiled. But makepp doesn&rsquo;t know that unless
it&rsquo;s actually allowed to execute the commands. So it
assumes <br>
that anything that depends on prototypes.h will also have to
be recompiled. Thus in this example, changing one .c file
will cause &quot;makepp -n&quot; to think that every single
.c <br>
file needs to be recompiled, even though most likely the
regular makepp command will actually not run all those
commands.</p>

<p style="margin-top: 1em">This situation isn&rsquo;t all
that common, and can only occur if (a) you use a signature
method that depends on file contents rather than date, as
the default compilation <br>
signature method does, or (b) if you have shell commands
that don&rsquo;t always change the date. E.g., with a
traditional implementation of make that only looks at dates
instead <br>
of file signatures, sometimes people will write commands
like this:</p>

<p style="margin-top: 1em">prototypes.h : $(wildcard *.c) #
Hacked technique not necessary for makepp <br>
cproto $(CPPFLAGS) $(inputs) &gt; junk.h <br>
if cmp -s junk.h prototypes.h; then rm junk.h; else mv
junk.h prototypes.h; fi</p>

<p style="margin-top: 1em">Thus if rerunning cproto on all
the files produces exactly the same file contents, the file
date is not updated. This will have exactly the same problem
as the above example <br>
with &quot;makepp -n&quot;: it is not known whether the date
on prototypes.h changes unless the command is actually run,
so &quot;makepp -n&quot; cannot possibly be 100% accurate.
(Note that <br>
using the traditional &quot;make -n&quot; will also have
exactly the same problem on this example.)</p>

<p style="margin-top: 1em">&quot;makepp -n&quot; should
always print out more commands than a regular invocation of
makepp, not fewer. If it prints out fewer commands, it means
that makepp does not know about <br>
some dependency; some file is changing that it is not
expecting to change on the basis of what it knows about what
files each rule affects. This means that your makefile has
<br>
a bug.</p>

<p style="margin-top: 1em">--no-cache-scaninfos <br>
Do not record the results of scanning, forcing it to be
reperformed next time makepp runs.</p>

<p style="margin-top: 1em">--no-implicit-load <br>
Don&rsquo;t automatically load makefiles from directories
referenced (see &quot;Implicit loading&quot; in
makepp_build_algorithm). By default, makepp automatically
loads a makefile from any <br>
directory that contains a dependency of some target it needs
to build, and from any directory that is scanned by a
wildcard. Sometimes, however, this causes a problem, since
<br>
makefiles need to be loaded with different command line
variables or options, and if they are implicitly loaded
before they are explicitly loaded by a recursive make <br>
invocation or the &quot;load_makefile&quot; statement,
makepp aborts with an error. You can also turn off makefile
loading on a directory-by-directory basis by using the <br>
&quot;no_implicit_load&quot; statement in one of your
makefiles.</p>

<p style="margin-top: 1em">--no-log <br>
Don&rsquo;t bother writing a detailed description of what
was done to the log file. By default, makepp writes out an
explanation of every file that it tried to build, and why it
<br>
built it or did not build it, to a file called .makepp/log,
readable with makepplog, mppl. This can be extremely
valuable for debugging a makefile--makepp tells you what it
<br>
thought all of the dependencies were, and which one(s) it
thought changed. However, it does take some extra CPU time,
and you might not want to bother.</p>

<p style="margin-top: 1em">--no-path-exe-dep <br>
--no-path-executable-dependencies <br>
Do not add implicit dependencies on executables picked up
from the command search path. If this option is specified,
then makepp assumes that any executable whose behavior <br>
might change with a new version will be specified with a
name containing a slash.</p>

<p style="margin-top: 1em">This is useful for programs such
as grep and diff, which always do basically the same thing
even if their implementation changes, though you&rsquo;re
better off using the builtin <br>
commands for grep. You may also need this for repositories
on NFS clusters, where the same commands might not have the
same timestamp everywhere, causing unnecessary <br>
rebuilds depending what machine somebody works on.</p>

<p style="margin-top: 1em">--no-populate-bc <br>
Don&rsquo;t populate the build cache, but still import from
it when possible. This is useful when the environment might
cause targets to be generated differently, but makepp <br>
doesn&rsquo;t know about such dependencies. It&rsquo;s also
useful to avoid thrashing the build cache with a huge number
of concurrent writers that might interfere with one
another.</p>

<p style="margin-top: 1em">--no-print-directory <br>
Turn off the entering or leaving directory messages.</p>

<p style="margin-top: 1em">--no-remake-makefiles <br>
Ordinarily, makepp loads each makefile in, then looks to see
whether there is a rule that specifies how to update the
makefile. If there is, and the makefile needs to be <br>
rebuilt, the command is executed, and the makefile is
reread. This often causes problems with makefiles produced
for the standard Unix make utility, because (in my <br>
experience) often the make rules for updating makefiles are
inaccurate--they frequently omit targets which are modified.
This can cause makepp to remake a lot of files <br>
unnecessarily. You can often solve this problem by simply
preventing makepp from updating the makefile automatically
(but you have to remember to update it by hand).</p>

<p style="margin-top: 1em">--no-warn <br>
Don&rsquo;t print any warning messages to stderr, only to
log file. Most warning messages are about constructs that
you might see in legacy makefiles that makepp considers <br>
dangerous, but a few of them concern possible errors in your
makefile.</p>

<p style="margin-top: 1em">-o filename <br>
--assume-old=filename <br>
--old-file=filename <br>
Pretends that the specified file has not changed, even if it
has. Any targets that depend on this file will not be
rebuilt because of this file, though they might be rebuilt
<br>
if some other dependency has also changed. The file itself
might or might not be rebuilt, depending on whether it is
out of date with respect to its dependencies. (To <br>
prevent that, use &quot;--dont-build&quot;.)</p>

<p style="margin-top: 1em">--override-signature=method <br>
--override-signature-method=method <br>
Same as &quot;--signature-method&quot;, but even overrides
the choice made by command parsers.</p>

<p style="margin-top: 1em">--out-of-sandbox=filename <br>
Generate an error rather than write files outside the
&quot;sandbox&quot;. Like --dont-build, more specific paths
override less specific paths. The filesystem root defaults
to out- <br>
of-sandbox if there are any &quot;--sandbox&quot;
options.</p>

<p style="margin-top: 1em">The purpose of the sandbox is to
enable multiple concurrent makepp processes to safely
operate on disjoint parts of the filesystem. In order for
this to work reliably, <br>
concurrent sandboxes must not overlap, and each process must
mark the sandbox of every other concurrent makepp process
for --dont-read. See partitioning into sandboxes.</p>

<p style="margin-top: 1em">--populate-bc-only <br>
Don&rsquo;t import from the build cache. This is useful when
you want to donate targets to the cache, but you don&rsquo;t
want to rely on the contents of the cache (e.g. for mission-
<br>
critical builds).</p>

<p style="margin-top: 1em">--profile <br>
Output raw timestamps before and after each action.</p>

<p style="margin-top: 1em">-R directory <br>
--repository=directory <br>
Specify the given directory as a repository (see
makepp_repositories for details). Repositories are added in
the order specified on the command line, so the first one
you <br>
specify has precedence. All files in the directory (and all
its subdirectories) are automatically linked to the current
directory (and subdirectories) if they are needed.</p>

<p style="margin-top: 1em">If you just specify a directory
after &quot;-R&quot;, its contents are linked into the
current directory. You can link its contents into any
arbitrary place in the file system by <br>
specifying the location before an equals sign, e.g, &quot;-R
subdir1/subdir2=/users/joe/joes_nifty_library&quot;.</p>

<p style="margin-top: 1em">-r <br>
--no-builtin-rules <br>
Don&rsquo;t load the default rule sets. If this option is
not specified, and the variable
&quot;makepp_no_builtin&quot; is not defined in the
makefile, then a set of rules for compiling C, <br>
C++, and Fortran code is loaded for each directory.</p>

<p style="margin-top: 1em">--rm-stale <br>
--remove-stale <br>
--remove-stale-files <br>
Ignore stale files rather then treating them as new source
files, removing them if necessary in order to prevent them
from being read by a build command. This is not the <br>
default because it deletes things, but it is often required
in order for incremental building to work properly.</p>

<p style="margin-top: 1em">For example, assume that there
is an x.c file that looks like this:</p>

<p style="margin-top: 1em">#include &quot;x.h&quot; <br>
int main() { return X; }</p>

<p style="margin-top: 1em">Consider this makefile:</p>

<p style="margin-top: 1em">$(phony default): x <br>
x.h: <br>
&amp;echo &quot;#define X 1&quot; -o $@</p>

<p style="margin-top: 1em">At some point, you change the
makefile to look like this:</p>

<p style="margin-top: 1em">CFLAGS := -Idir <br>
$(phony default): x <br>
dir/x.h: <br>
&amp;mkdir -p $(dir $@) <br>
&amp;echo &quot;#define X 2&quot; -o $@</p>

<p style="margin-top: 1em">Now if you build from clean, x
exits with status 2, but if you build while the old ./x.h
file still exists and you don&rsquo;t specify
&quot;--rm-stale&quot;, then x exits with status 1, <br>
because the include directive picks up the stale generated
header file.</p>

<p style="margin-top: 1em">If you build with
&quot;--rm-stale&quot;, then ./x.h is removed, and the
result is the same as that of a clean build, which is almost
always a good thing.</p>

<p style="margin-top: 1em">Note that if you build in a
repository, you have to give this option there first,
because the importing makepp doesn&rsquo;t know what might
be stale in the repository.</p>

<p style="margin-top: 1em">Legacy makefiles sometimes put
the rule to generate an include file after the include
statement. Mpp works around that like gmake, by reloading at
the end of the makefile if <br>
needed. But this means on a rebuild it looks stale at the
point where it is needed, and will be deleted. Therefore
this option turns off this kind of reloading.</p>

<p style="margin-top: 1em">-s <br>
--quiet <br>
--silent <br>
Don&rsquo;t echo commands and don&rsquo;t print
informational messages like &quot;Scanning&quot; or
&quot;Loading makefile&quot;.</p>

<p style="margin-top: 1em">--sandbox=directory <br>
--in-sandbox=directory <br>
--inside-sandbox=directory <br>
Restrain this instance of makepp to a subtree of a normally
bigger build tree. See partitioning into sandboxes.</p>

<p style="margin-top: 1em">--sandbox-warn <br>
--sandbox-warning <br>
Downgrade violations of &quot;in-sandbox&quot; and
&quot;dont-read&quot; to warnings instead of errors. See
partitioning into sandboxes.</p>

<p style="margin-top: 1em">--stop-race <br>
--stop-on-race <br>
Exit in error rather than only warning about a build cache
access collision that could be fixed.</p>

<p style="margin-top: 1em">--symlink-in-rep-as-file <br>
--symlink-in-repository-as-file <br>
If a repository contains a symbolic link, then by default
that symbolic link is imported as a link, which is to say
that the target of the imported link need not be identical
<br>
to the target of the symbolic link in the repository. If the
&quot;--symlink-in-repository-as-file&quot; option is
specified, then the symbolic link is imported as its target
file, <br>
which is to say that the imported link points to the same
target file as the symbolic link in the repository. This is
useful if the symbolic link in the repository was <br>
intended to have the build-time semantics of a copy.</p>

<p style="margin-top: 1em">--traditional <br>
--traditional-recursion <br>
--traditional-recursive-make <br>
This option is present to allow makepp to work with old
makefiles that use recursive make extensively, especially
with varying options. By default, recursive make is <br>
implemented by a subprocess that communicates with the
parent process; the build is actually done by the parent
process. This allows some of makepp&rsquo;s nice features
like <br>
repositories to work with recursive make invocations.
However, this technique will not work if you use different
command line options on different invocations of recursive
<br>
make. Before you use this, try
&quot;--hybrid-recursive-make&quot;.</p>


<p style="margin-top: 1em">&quot;--traditional-recursive-make&quot;
option makes makepp do recursive makes the same way as the
traditional make, allowing more makefiles to work, but then
repositories and <br>
parallel builds do not work properly. This option is rarely
needed any more, and makepp will tell you if it runs into a
construct that requires it.</p>

<p style="margin-top: 1em">If you do use this option, you
will get log files piling up in the various directories this
changes to. To get rid of only them use &quot;makeppclean
--logs --recurse&quot; or &quot;mppc <br>
-lr&quot;.</p>

<p style="margin-top: 1em">-v <br>
--verbose <br>
Verbose mode. Explains what it is trying to build, and why
each file is being built. This can be useful if you think a
file is being rebuilt too often.</p>

<p style="margin-top: 1em">This option actually takes what
would be written to the log file and displays it on the
screen. It&rsquo;s usually easier to run makepp and then
look at the output of makepplog, <br>
which allows various selections and some rewriting.</p>

<p style="margin-top: 1em">-V <br>
--version <br>
Print out the version number.</p>

<p style="margin-top: 1em">--virtual-sandbox <br>
Don&rsquo;t rewrite build infos of files that were not
created by this makepp process. See partitioning into
sandboxes.</p>

<p style="margin-top: 1em">-W filename <br>
--assume-new=filename <br>
--new-file=filename <br>
--what-if=filename <br>
Pretends the specified file has changed, so that any targets
that depend on that file will be rebuilt. The file itself is
not necessarily changed (it might or might not be <br>
rebuilt, depending on whether it is up to date with respect
to its dependencies), but everything that depends on it
thinks that it has changed. This can be useful for <br>
debugging a makefile.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
Makepp searches upwards for a file called .makepprc when
starting and again after every &quot;-C&quot; or
&quot;-c&quot; option. Each time it finds such a file, but
only once per file, it will read <br>
the file and parse it as possibly quoted options on one or
several lines. Unlike the option &quot;-A&quot;, the options
will be parsed relative to the directory where the file
resides.</p>

<p style="margin-top: 1em">Makepp looks at the following
environment variables:</p>

<p style="margin-top: 1em">$MAKEFLAGS <br>
Any flags in this environment variable are interpreted as
command line options before any explicit options. All
command line arguments are put into this variable</p>

<p style="margin-top: 1em">Note that the traditional make
also uses this variable, so if you have to use both make and
makepp, you might want to consider using
&quot;MAKEPPFLAGS&quot;.</p>

<p style="margin-top: 1em">$MAKEPPFLAGS <br>
Same as &quot;MAKEFLAGS&quot; as far as makepp is concerned.
If this variable is not blank, then &quot;MAKEFLAGS&quot; is
ignored. Sometimes this is useful instead of
&quot;MAKEFLAGS&quot; if you have <br>
to use both make and makepp, and you need to keep the
options separate.</p>


<p style="margin-top: 1em">$MAKEPP_CASE_SENSITIVE_FILENAMES
<br>
Makepp will attempt to determine whether its default
directory is case sensitive by creating a file and then
accessing it with a different case. Usually this works fine,
as <br>
long as all the files you&rsquo;re accessing are on the same
file system as your default directory, so you should rarely
need to use this option.</p>

<p style="margin-top: 1em">If this variable is present in
the environment, its value (0 or empty string for false,
anything else for true) will override makepp&rsquo;s choice.
This variable is mostly useful <br>
on Windows, if you want to override makepp&rsquo;s default
setting. If you don&rsquo;t treat filenames as case
sensitive, then makepp converts all filenames to lowercase,
which causes <br>
occasional difficulties. (E.g., emacs may will open several
buffers to the same file.)</p>

<p style="margin-top: 1em">Makepp does not currently
support a build across several file systems well, if one is
case sensitive and the other case insensitive.</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
MAKEPP_COMMAND(1)</p>
<hr>
</body>
</html>
