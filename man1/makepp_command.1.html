<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_COMMAND(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_COMMAND(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_COMMAND(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp -- Command line syntax for makepp
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>?:</b>&#x00A0;-?,&#x00A0; <b>A:</b>&#x00A0;-A,
<br/>
 --args-file,
<br/>
 --arguments-file,
<br/>
 --assume-new,
<br/>
 --assume-old,&#x00A0; <b>B:</b>&#x00A0;-b,
<br/>
 --build-cache,
<br/>
 --build-check,
<br/>
 --build-check-method,&#x00A0; <b>C:</b>&#x00A0;-C,
<br/>
 -c,&#x00A0; <b>D:</b>&#x00A0;--defer-include,
<br/>
 --directory,
<br/>
 --do-build,
<br/>
 --dont-build,
<br/>
 --dont-read,
<br/>
 --do-read,
<br/>
 --dry-run,
<br/>
 --dump-makefile,
<br/>
 --dump-makeppfile,&#x00A0; <b>E:</b>&#x00A0;-e,
<br/>
 --environment-overrides,
<br/>
 --env-overrides,&#x00A0; <b>F:</b>&#x00A0;-F,
<br/>
 -f,
<br/>
 --file,
<br/>
 --final-rules-only,
<br/>
 --force-copy-from-bc,
<br/>
 --force-rescan,&#x00A0; <b>G:</b>&#x00A0;--gullible,&#x00A0;
  <b>H:</b>&#x00A0;-h,
<br/>
 --help,
<br/>
 --hybrid,
<br/>
 --hybrid-recursion,
<br/>
 --hybrid-recursive-make,&#x00A0; <b>I:</b>&#x00A0;-I,
<br/>
 --implicit-load-makeppfile-only,
<br/>
 --include,
<br/>
 --include-dir,
<br/>
 --in-sandbox,
<br/>
 --inside-sandbox,&#x00A0; <b>J:</b>&#x00A0;-j,
<br/>
 --jobs,
<br/>
 --just-print,&#x00A0; <b>K:</b>&#x00A0;-k,
<br/>
 --keep-going,&#x00A0; <b>L:</b>&#x00A0;--last-chance-rules,
<br/>
 --load-makefile,
<br/>
 --load-makeppfile,
<br/>
 --log,
<br/>
 --log-file,
<br/>
 --loop,&#x00A0; <b>M:</b>&#x00A0;-m,
<br/>
 --makefile,
<br/>
 $MAKEFLAGS,
<br/>
 $MAKEPP_CASE_SENSITIVE_FILENAMES,
<br/>
 --makeppfile,
<br/>
 $MAKEPPFLAGS,
<br/>
 --md5-bc,
<br/>
 --md5-check-bc,&#x00A0; <b>N:</b>&#x00A0;-n,
<br/>
 --new-file,
<br/>
 --no-builtin-rules,
<br/>
 --no-cache-scaninfos,
<br/>
 --no-implicit-load,
<br/>
 --no-log,
<br/>
 --no-path-executable-dependencies,
<br/>
 --no-path-exe-dep,
<br/>
 --no-populate-bc,
<br/>
 --no-print-directory,
<br/>
 --no-remake-makefiles,
<br/>
 --no-warn,&#x00A0; <b>O:</b>&#x00A0;-o,
<br/>
 --old-file,
<br/>
 --out-of-sandbox,
<br/>
 --override-signature,
<br/>
 --override-signature-method,&#x00A0; <b>P:</b>&#x00A0;--populate-bc-only,
<br/>
 --profile,&#x00A0; <b>Q:</b>&#x00A0;--quiet,&#x00A0; <b>R:</b>&#x00A0;-R,
<br/>
 -r,
<br/>
 --recon,
<br/>
 --remove-stale,
<br/>
 --remove-stale-files,
<br/>
 --repository,
<br/>
 --rm-stale,
<br/>
 --root-dir,
<br/>
 --root-directory,&#x00A0; <b>S:</b>&#x00A0;-s,
<br/>
 --sandbox,
<br/>
 --sandbox-warn,
<br/>
 --sandbox-warning,
<br/>
 --signature,
<br/>
 --signature-method,
<br/>
 --silent,
<br/>
 --stop,
<br/>
 --stop-after-loading,
<br/>
 --stop-before-building,
<br/>
 --stop-on-race,
<br/>
 --stop-race,
<br/>
 --symlink-in-rep-as-file,
<br/>
 --symlink-in-repository-as-file,&#x00A0; <b>T:</b>&#x00A0;--traditional,
<br/>
 --traditional-recursion,
<br/>
 --traditional-recursive-make,&#x00A0; <b>V:</b>&#x00A0;-V,
<br/>
 -v,
<br/>
 --verbose,
<br/>
 --version,
<br/>
 --virtual-sandbox,&#x00A0; <b>W:</b>&#x00A0;-W,
<br/>
 --what-if
<div class="Pp"></div>
<b>makepp</b> [&#x00A0;<i>option</i>&#x00A0;...&#x00A0;]
  [&#x00A0;<i>VAR=value</i>&#x00A0;] [&#x00A0; <i>target</i>&#x00A0;...&#x00A0;]
<div class="Pp"></div>
<b>mpp</b> [&#x00A0;<i>option</i>&#x00A0;...&#x00A0;]
  [&#x00A0;<i>VAR=value</i>&#x00A0;] [&#x00A0; <i>target</i>&#x00A0;...&#x00A0;]
<div class="Pp"></div>
Makepp supports most of the command line options and syntax that other makes
  support. The hyphens between the words are always optional, and can also be
  replaced by an underscore. You specify a list of targets to build on the
  command line. If you do not specify any targets, the first explicit target in
  the makefile is built.
<div class="Pp"></div>
You can assign variables on the command line which will override any assignment
  or environment variable in every Makefile loaded, e.g.,
<div class="Pp"></div>
<pre>
    makepp CFLAGS=-O2
</pre>
<div class="Pp"></div>
Valid options are most of the standard make options, plus a few new ones:
<dl class="Bl-tag">
  <dt class="It-tag">-A <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--args-file=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--arguments-file=<i>filename</i></dt>
  <dd class="It-tag">Read the file and parse it as possibly quoted whitespace-
      and/or newline-separated options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-b <i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--build-cache=<i>directory</i></dt>
  <dd class="It-tag">Specifies the path to a build cache. See makepp_build_cache
      for details. The build cache must already exist; see &quot;How to manage a
      build cache&quot; in makepp_build_cache for how to make it in the first
      place. Build caches defined on the command line may be overridden by a
      build_cache statement in a makefile or a :build_cache rule modifier . If
      you work with several different builds, it may be useful to set the
      environment variable &quot;MAKEPPFLAGS&quot; to contain
      &quot;--buil&quot;&quot;d-cache=/path/to/build/cache&quot; so that all of
      your builds will take advantage of the build cache by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--build-check=<i>method</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--build-check-method=<i>method</i></dt>
  <dd class="It-tag">The name of a build check method to use to decide whether
      files need to be rebuilt. Possible values are &quot;target_newer&quot;,
      &quot;exact_match&quot;, See makepp_build_check for information on build
      check methods.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-C <i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--directory=<i>directory</i></dt>
  <dd class="It-tag">Cd to the given directory before loading the makefile and
      trying to build the targets. This is similar to specifying a directory
      with &quot;-F&quot;, except that subsequent &quot;-C&quot;,
      &quot;-f&quot;, &quot;-F&quot;, &quot;-I&quot; and &quot;-R&quot; options
      are interpreted relative to the new directory, rather than the old
    one.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-c</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--root-dir</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--root-directory</dt>
  <dd class="It-tag">Cd up to the directory containing a RootMakeppfile.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--defer-include</dt>
  <dd class="It-tag">Workaround for include statement before the rule that
      builds the include file. This happens by pretending the include statements
      come last in the makefile. That way the include statement is performable,
      but variable overrides or modifications may still fail, in which case you
      should set the problematic ones on the command line (whereas gmake ignores
      any variable setting from the include file that might influence how that
      file itself gets built).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--dont-build=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--do-build=<i>filename</i></dt>
  <dd class="It-tag">Do not build the specified file, or, if it is a directory,
      everything thereunder, even though makepp thinks it should -- or do build,
      overriding the opposite specification from a higher directory. This is
      useful if you built a specific file by hand using different compilation
      options. Without this option, if you compile a module by hand and then run
      makepp to compile the rest of the program, makepp will also recompile the
      module you compiled by hand, because makepp cannot guarantee that the
      build is correct if any of the files were not built under its control.
      With this option, you tell makepp that you really know what you are doing
      in the case of this particular file and you promise that it's ok not to
      rebuild it.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    % cc -g -DSPECIAL_DEBUG -c x.c -o x.o  # Special compilation by hand
    % makepp
    cc -g -O2 -c x.c -o x.o   # Makepp just overrode your compilation here!
    cc x.o y.o -o my_program  # Relinks.
    % cc -g -DSPECIAL_DEBUG -c x.c -o x.o  # Do it again.
    % makepp --dont-build x.o # Tell makepp not to rebuild x.o even if it wants to.
    cc x.o y.o -o my_program  # Now it relinks without recompiling.
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want special compilation options for just one module, it's often
      easier to edit the makefile than to compile by hand as in this example;
      see &quot;Target-specific assignments&quot; in makepp_variables for an
      easy way of doing this.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you put a <i>RootMakeppfile(.mk)</i> at the root of your build system,
      that directory and everything under it defaults to &quot;--do-build&quot;,
      while the overall root of your file system defaults to
      &quot;--dont-build&quot;. That way, everything inside your build system is
      built (if necessary) but nothing outside is attempted. If, in this
      scenario, you want external parts to always be built as needed, you must
      explicitly pick them up with &quot;load_makefile&quot; statements in one
      of the makefiles within your tree.
    <div style="height: 1.00em;">&#x00A0;</div>
    You may have one <i>RootMakeppfile(.mk)</i> each, in separate build trees,
      and they will be loaded if one tree has dependencies in another one. But
      you are not allowed to have <i>RootMakeppfile(.mk)</i> in nested
      directories, avoiding funny effects that tend to arise when you
      accidentally call &quot;makepp --repository&quot; again in a subdirectory.
      These effects include duplicate rules through duplicate sources, or
      eternal build cache reimports because cached files have the right
      signatures but the wrong relative pathes.
    <div style="height: 1.00em;">&#x00A0;</div>
    Override &quot;--dont-build&quot; for the specified file or directory. If
      you have a <i>RootMakeppfile(.mk)</i> at the root of your build system,
      but you want makepp to build something outside of your build system just
      this once, you must explicitly mark it as &quot;--do-build&quot;. If you
      specify &quot;--do-build&quot; for a file or directory under a
      <i>RootMakeppfile(.mk)</i>, without &quot;--dont-build&quot; for a higher
      directory, then the root (and all else under it) of your build system
      defaults to &quot;--dont-build&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    To resolve conflicts between &quot;--dont-build&quot; and
      &quot;--do-build&quot;, the one with the most specific path takes
      precedence regardless of order. If the same path is specified with both
      &quot;--dont-build&quot; and &quot;--do-build&quot;, then the rightmost
      one wins.
    <div style="height: 1.00em;">&#x00A0;</div>
    The options &quot;--dont-build&quot; and &quot;--do-build&quot; can be
      dangerous if you give the wrong hints to makepp, since you are asking
      makepp not to do checks it needs, to guarantee a correct build. But since
      they allow greatly reducing the number of checks, they can speed up your
      builds dramatically, as explained in potentially unsafe speedup
    methods.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--dont-read=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--do-read=<i>filename</i></dt>
  <dd class="It-tag">Do not read the specified file, or, if it is a directory,
      everything thereunder -- or do read, overriding the opposite specification
      from a higher directory. Generate an error rather than read files marked
      for &quot;--dont-read&quot;. See --sandbox. The filesystem root always
      defaults to readable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--dump-makefile=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--dump-makeppfile=<i>filename</i></dt>
  <dd class="It-tag">Dump the raw contents of the makefile(s) for the current
      directory (as determined by the position of this option relative to any
      &quot;-C&quot; options) to <i>filename</i>. Include files are
      interpolated, comments are stripped out and &quot;ifdef&quot;'s are
      resolved. &quot;# line &quot;file&quot;&quot; markers are inserted as
      necessary. The final value of any non-reference scalars in the makefile's
      package are printed following the makefile.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is useful for debugging, but (currently) you won't necessarily be able
      use the dump file as an equivalent makefile, for example because it
      contains both the include statement and the interpolated file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-e</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--env-overrides</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--environment-overrides</dt>
  <dd class="It-tag">Causes variables from the environment to override
      definitions in the makefile. By default, assignments within the makefile
      override variable values which are imported from the environment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-F <i>Makeppfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--makeppfile=<i>Makeppfile</i></dt>
  <dd class="It-tag">Loads the specified Makefile or, if you specify a
      directory, the <i>Makefile</i> therein, instead of the one in the current
      directory -- any target specified to the right of this option is
      interpreted relative to the directory containing the Makefile. For the
      details of the directory case and <i>RootMakeppfile</i> see the
      explanation at the next option.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option can be useful if you execute makepp from unpredictable
      directories. For example, if you compile from within emacs and you have
      sources scattered all over your directory tree, the current working
      directory for the compilation command will be the directory the last
      source file you edited was in, which may or may not be the top level
      directory for your compilation. However, you can specify your compilation
      command as
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    makepp -F /your/source/dir/top
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and this will work no matter what your current directory is.
    <div style="height: 1.00em;">&#x00A0;</div>
    Because this option doesn't affect the directory relative to which
      subsequent &quot;-C&quot;, &quot;-f&quot;, &quot;-F&quot;, &quot;-I&quot;
      and &quot;-R&quot; options are specified, you can make targets relative to
      the current directory like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    makepp -F /foo/bar -C . mytarget
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-f <i>Makefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--file=<i>Makefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--makefile=<i>Makefile</i></dt>
  <dd class="It-tag">Loads the specified Makefile or, if you specify a
      directory, the <i>Makefile</i> therein, instead of the one in the current
      directory. If you do not specify the &quot;-f&quot; option or the
      &quot;-F&quot; option, makepp looks first for a file in the current
      directory (or the directory specified by the rightmost &quot;-C&quot;
      option, if any) called, then <i>RootMakeppfile.mk</i>, <i>Makeppfile</i>,
      then <i>Makeppfile.mk</i>, then <i>makefile</i>, then <i>Makefile</i>.
      Multiple &quot;-F&quot; and &quot;-f&quot; options may be specified.
    <div style="height: 1.00em;">&#x00A0;</div>
    The first two ( <i>RootMakeppfile</i>) are special (whether given explicitly
      or found implicitly). There must be at most one of those two in any given
      build tree on which makepp is to operate. But there may be several if you
      build several disjoint trees in one go. Those two are looked for not only
      in the aforementioned directory, but also upwards from there. If one is
      found, it is loaded before any other.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--final-rules-only</dt>
  <dd class="It-tag">Ignore the dependencies and implicit targets of the rule
      unless the target is phony.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--force-copy-from-bc</dt>
  <dd class="It-tag">When using build caches, always copy files in and out of
      the cache, even if the source and target are on the same filesystem. This
      is mainly useful for testing (emulating) the case in which they are
    not.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--force-rescan</dt>
  <dd class="It-tag">Don't use cached scanner results from previous runs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--gullible</dt>
  <dd class="It-tag">Believe that the rules create what they declare, rather
      than checking. This is faster, but doesn't catch bugs in rules.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-?</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-h</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--help</dt>
  <dd class="It-tag">Print out a brief summary of the options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--hybrid</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--hybrid-recursion</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--hybrid-recursive-make</dt>
  <dd class="It-tag">This option is present to allow makepp to work with old
      makefiles that use recursive make extensively, especially multiply into
      the same dir. By default, recursive make is implemented by a subprocess
      that communicates with the parent process; the build is actually done by
      the parent process. This allows some of makepp's nice features like
      repositories to work with recursive make invocations. However, this
      technique will not work if you load more than one makefile from the same
      directory. In that case this option says to fall back to starting another
      independent instance of makepp. If this fails, try
      &quot;--traditional-recursive-make&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you do use this option, you will get log files in the each directory the
      fall back occurred in. To get rid of only them use &quot;makeppclean
      --logs --recurse&quot; or &quot;mppc -lr&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-I <i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--include=<i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--include-dir=<i>directory</i></dt>
  <dd class="It-tag">Search the given directory for included makefiles.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--implicit-load-makeppfile-only</dt>
  <dd class="It-tag">If implicit loading of makefiles is enabled, then
      automatically load only a file called <i>RootMakeppfile</i>,
      <i>RootMakeppfile.mk</i>, <i>Makeppfile</i>, or <i>Makeppfile.mk</i>, and
      <b>not</b> <i>makefile</i> or <i>Makefile</i>. This is useful if makepp
      has dependencies that are generated by some other flavor of make, and
      makepp can't read that flavor's makefiles in general. (You want to avoid
      this situation if possible, but it tends to arise while you're in the
      process of porting a legacy build system to makepp.) This has no effect if
      implicit loading is disabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-j <i>n</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--jobs=<i>n</i></dt>
  <dd class="It-tag">Interprets the argument <i>n</i> as the number of shell
      commands that can be executed in parallel. By default, makepp does not
      execute commands in parallel.
    <div style="height: 1.00em;">&#x00A0;</div>
    Unlike some other versions of make, when jobs are executed in parallel,
      makepp directs their output to a file and only displays the output when
      the commands have finished. This prevents output from several different
      commands from being mixed together on the display, but it does mean that
      you might have to wait a little longer to see the output, and stderr
      messages will usually appear before stdout stuff, differing from terminal
      output.
    <div style="height: 1.00em;">&#x00A0;</div>
    Native Windows Perls (i.e. Strawberry and ActiveState), because they do not
      support the Unix fork/exec paradigm, do not allow this option (Cygwin
      works fine!). As a partial replacement, you can use the --sandbox option
      there, though this is far less comfortable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-k</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--keep-going</dt>
  <dd class="It-tag">Build as many files as safely possible, even if some
      commands have errors. By default, makepp stops when it encounters the
      first error, even if there are other files that need to be built that
      don't depend on the erroneous file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--last-chance-rules</dt>
  <dd class="It-tag">Activate limited special handling for pattern rules with
      '%' only on the target side. This is needed because normally, unlike
      traditional makes, makepp instantiates all rules with all available files
      from the bottom up, allowing it to find all creatable dependencies.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--load-makefile=<i>Makefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--load-makeppfile=<i>Makefile</i></dt>
  <dd class="It-tag">Loads the specified makefile <i>before</i> any other
      makefiles, except for <i>RootMakeppfile</i>, or <i>RootMakeppfile.mk</i>
      above it, but do not consider this option for the purposes of determining
      the default target. If no other makefile is specified, then one is sought
      using the usual rules. If the specified makefile is the same makefile that
      is found using the usual rules, then this option has no effect.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--log=<i>logfilename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--log-file=<i>logfilename</i></dt>
  <dd class="It-tag">Changes the name of the log file to the indicated name. By
      default, the log file is called <i>.makepp/log</i>. This file is readable
      with makepplog, mppl.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--loop</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--stop</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--stop-before-building</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--stop-after-loading</dt>
  <dd class="It-tag">Makepp will repeatedly stop itself (go to sleep), before it
      analyzes and builds anything, for you to wake it up when you are ready. It
      will tell you some commands to choose from for waking it up again. If you
      do it in a Shell, you get the prompt and can then fore- or background it.
      If you do it within an IDE, it'll just sleep, and you can awaken it from
      another Shell. Depending on where you start it, closing that window may or
      may not terminate makepp, so check how to cope with this in your
      environment.
    <div style="height: 1.00em;">&#x00A0;</div>
    The intention is that you can start makepp this way before you're finished
      editing some files. Depending on your project structure and size, this can
      allow makepp to get a headstart of many seconds worth of work by the time
      you're done. Then every time you can edit more and awaken it again, unless
      you change something in your Makefile, which will go unnoticed until you
      start a new instance of makepp. The same applies to repositories, which
      must never change while makepp is running.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you use &quot;prebuild&quot; or &quot;$(make)&quot;, on the first round
      it will stop when it gets to that point.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-m <i>method</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--signature=<i>method</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--signature-method=<i>method</i></dt>
  <dd class="It-tag">Specifies the default signature method to use for rules
      which do not have the &quot;:signature&quot; modifier in makefiles which
      do not have a &quot;signature&quot; statement. Does not override the
      choice made by command parsers, e.g. C/C++ compilers. Possible values are
      &quot;md5&quot;, &quot;C&quot; or &quot;c_compilation_md5&quot;,
      &quot;xml&quot; and &quot;xml-space&quot;. For more details, see
      makepp_signatures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--md5-bc</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--md5-check-bc</dt>
  <dd class="It-tag">When importing from a build cache, reject cached targets
      unless the MD5_SUM is present and matches the imported target. When
      populating a build cache, calculate and store the MD5_SUM in the build
      info if it isn't there already. This is slower and leads to more rebuilds,
      but it guarantees that imported targets and build info files correspond
      exactly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-n</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--dry-run</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--just-print</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--recon</dt>
  <dd class="It-tag">Print out commands without actually executing them --
      unreliably where commands depend on previous results. This allows you to
      see what makepp will do, without actually changing any files.
    <div style="height: 1.00em;">&#x00A0;</div>
    More precisely, makepp executes all recursive make commands as normal (but
      hopefully you're not using recursive make anywhere!). Other commands are
      simply printed without being executed. Even commands which are prefixed
      with &quot;@&quot; or &quot;noecho&quot; are printed after the
      &quot;@&quot; or &quot;noecho&quot; is stripped off. However commands
      prefixed with &quot;+&quot; should be executed, but currently are not.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Warning:</b> The commands that makepp executes with &quot;-n&quot; are
      not necessarily the same thing it will do without &quot;-n&quot;. File
      signatures do not change at all with &quot;-n&quot;, which means that
      makepp cannot perform exactly the same build tests that it does when the
      signatures are changing. This will occasionally make a difference if you
      are using MD5 signatures (which is the default for compilation commands)
      or if you have shell commands that might or might not change the date.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, suppose that you generate a <i>.h</i> file via some sort of
      preprocessor. This can happen in a lot of different ways. For
      concreteness, suppose you automatically generate a list of prototypes for
      functions defined in each C module (see
      &lt;http://cproto.sourceforge.net/&gt; for how the &quot;cproto&quot;
      application works or &lt;http://www.lemoda.net/c/cfunctions/&gt; for the
      similar cfunctions).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    prototypes.h : *.c
        cproto $(CPPFLAGS) $(inputs) &gt; $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Then each <i>.c</i> file will include <i>prototypes.h</i>. The purpose of
      this is to maintain the forward declarations for all functions
      automatically, so if you change a function's signature or add a new
      function, you don't ever have to put in forward or extern declarations
      anywhere. You don't even have to declare the dependency of your .o files
      on this one -- makepp will see the include statement and automatically see
      if it needs to (re)run cproto.
    <div style="height: 1.00em;">&#x00A0;</div>
    Now suppose you change just one <i>.c</i> file. What happens when you run
      makepp with &quot;-n&quot; in this case is that it realizes that
      <i>prototypes.h</i> needs to be remade. In all probability, remaking
      <i>prototypes.h</i> won't affect its signature--the file contents will
      probably be identical because no function arguments have been changed--so
      most of the time, nothing that depends on <i>prototypes.h</i> actually has
      to be recompiled. But makepp doesn't know that unless it's actually
      allowed to execute the commands. So it assumes that anything that depends
      on <i>prototypes.h</i> will also have to be recompiled. Thus in this
      example, changing one <i>.c</i> file will cause
      &quot;makepp&#x00A0;-n&quot; to think that every single <i>.c</i> file
      needs to be recompiled, even though most likely the regular makepp command
      will actually not run all those commands.
    <div style="height: 1.00em;">&#x00A0;</div>
    This situation isn't all that common, and can only occur if (a) you use a
      signature method that depends on file contents rather than date, as the
      default compilation signature method does, or (b) if you have shell
      commands that don't always change the date. E.g., with a traditional
      implementation of make that only looks at dates instead of file
      signatures, sometimes people will write commands like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    prototypes.h : $(wildcard *.c)  # Hacked technique not necessary for makepp
        cproto $(CPPFLAGS) $(inputs) &gt; junk.h
        if cmp -s junk.h prototypes.h; then \
           rm junk.h; \
        else \
           mv junk.h prototypes.h; \
        fi
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Thus if rerunning cproto on all the files produces exactly the same file
      contents, the file date is not updated. This will have exactly the same
      problem as the above example with &quot;makepp&#x00A0;-n&quot;: it is not
      known whether the date on <i>prototypes.h</i> changes unless the command
      is actually run, so &quot;makepp&#x00A0;-n&quot; cannot possibly be 100%
      accurate. (Note that using the traditional &quot;make&#x00A0;-n&quot; will
      also have exactly the same problem on this example.)
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;makepp&#x00A0;-n&quot; should always print out more commands than a
      regular invocation of makepp, not fewer. If it prints out fewer commands,
      it means that makepp does not know about some dependency; some file is
      changing that it is not expecting to change on the basis of what it knows
      about what files each rule affects. This means that your makefile has a
      bug.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-cache-scaninfos</dt>
  <dd class="It-tag">Do not record the results of scanning, forcing it to be
      reperformed next time makepp runs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-implicit-load</dt>
  <dd class="It-tag">Don't automatically load makefiles from directories
      referenced (see &quot;Implicit loading&quot; in makepp_build_algorithm).
      By default, makepp automatically loads a makefile from any directory that
      contains a dependency of some target it needs to build, and from any
      directory that is scanned by a wildcard. Sometimes, however, this causes a
      problem, since makefiles need to be loaded with different command line
      variables or options, and if they are implicitly loaded before they are
      explicitly loaded by a recursive make invocation or the
      &quot;load_makefile&quot; statement, makepp aborts with an error. You can
      also turn off makefile loading on a directory-by-directory basis by using
      the &quot;no_implicit_load&quot; statement in one of your makefiles.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-log</dt>
  <dd class="It-tag">Don't bother writing a detailed description of what was
      done to the log file. By default, makepp writes out an explanation of
      every file that it tried to build, and why it built it or did not build
      it, to a file called <i>.makepp/log</i>, readable with makepplog, mppl.
      This can be extremely valuable for debugging a makefile--makepp tells you
      what it thought all of the dependencies were, and which one(s) it thought
      changed. However, it does take some extra CPU time, and you might not want
      to bother.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-path-exe-dep</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-path-executable-dependencies</dt>
  <dd class="It-tag">Do not add implicit dependencies on executables picked up
      from the command search path. If this option is specified, then makepp
      assumes that any executable whose behavior might change with a new version
      will be specified with a name containing a slash.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is useful for programs such as grep and diff, which always do basically
      the same thing even if their implementation changes, though you're better
      off using the builtin commands for grep. You may also need this for
      repositories on NFS clusters, where the same commands might not have the
      same timestamp everywhere, causing unnecessary rebuilds depending what
      machine somebody works on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-populate-bc</dt>
  <dd class="It-tag">Don't populate the build cache, but still import from it
      when possible. This is useful when the environment might cause targets to
      be generated differently, but makepp doesn't know about such dependencies.
      It's also useful to avoid thrashing the build cache with a huge number of
      concurrent writers that might interfere with one another.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-print-directory</dt>
  <dd class="It-tag">Turn off the entering or leaving directory messages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-remake-makefiles</dt>
  <dd class="It-tag">Ordinarily, makepp loads each makefile in, then looks to
      see whether there is a rule that specifies how to update the makefile. If
      there is, and the makefile needs to be rebuilt, the command is executed,
      and the makefile is reread. This often causes problems with makefiles
      produced for the standard Unix make utility, because (in my experience)
      often the make rules for updating makefiles are inaccurate--they
      frequently omit targets which are modified. This can cause makepp to
      remake a lot of files unnecessarily. You can often solve this problem by
      simply preventing makepp from updating the makefile automatically (but you
      have to remember to update it by hand).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-warn</dt>
  <dd class="It-tag">Don't print any warning messages to stderr, only to log
      file. Most warning messages are about constructs that you might see in
      legacy makefiles that makepp considers dangerous, but a few of them
      concern possible errors in your makefile.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-o <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--assume-old=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--old-file=<i>filename</i></dt>
  <dd class="It-tag">Pretends that the specified file has not changed, even if
      it has. Any targets that depend on this file will not be rebuilt because
      of this file, though they might be rebuilt if some other dependency has
      also changed. The file itself might or might not be rebuilt, depending on
      whether it is out of date with respect to its dependencies. (To prevent
      that, use &quot;--dont-build&quot;.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--override-signature=<i>method</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--override-signature-method=<i>method</i></dt>
  <dd class="It-tag">Same as &quot;--signature-method&quot;, but even overrides
      the choice made by command parsers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--out-of-sandbox=<i>filename</i></dt>
  <dd class="It-tag">Generate an error rather than write files outside the
      &quot;sandbox&quot;. Like --dont-build, more specific paths override less
      specific paths. The filesystem root defaults to out-of-sandbox if there
      are any &quot;--sandbox&quot; options.
    <div style="height: 1.00em;">&#x00A0;</div>
    The purpose of the sandbox is to enable multiple concurrent makepp processes
      to safely operate on disjoint parts of the filesystem. In order for this
      to work reliably, concurrent sandboxes must not overlap, and each process
      must mark the sandbox of every other concurrent makepp process for
      --dont-read. See partitioning into sandboxes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--populate-bc-only</dt>
  <dd class="It-tag">Don't import from the build cache. This is useful when you
      want to donate targets to the cache, but you don't want to rely on the
      contents of the cache (e.g. for mission-critical builds).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--profile</dt>
  <dd class="It-tag">Output raw timestamps before and after each action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-R <i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--repository=<i>directory</i></dt>
  <dd class="It-tag">Specify the given directory as a repository (see
      makepp_repositories for details). Repositories are added in the order
      specified on the command line, so the first one you specify has
      precedence. All files in the directory (and all its subdirectories) are
      automatically linked to the current directory (and subdirectories) if they
      are needed.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you just specify a directory after &quot;-R&quot;, its contents are
      linked into the current directory. You can link its contents into any
      arbitrary place in the file system by specifying the location before an
      equals sign, e.g,
      &quot;-R&#x00A0;subdir1/subdir2=/users/joe/joes_nifty_library&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-r</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--no-builtin-rules</dt>
  <dd class="It-tag">Don't load the default rule sets. If this option is not
      specified, and the variable &quot;makepp_no_builtin&quot; is not defined
      in the makefile, then a set of rules for compiling C, C++, and Fortran
      code is loaded for each directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--rm-stale</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--remove-stale</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--remove-stale-files</dt>
  <dd class="It-tag">Ignore stale files rather then treating them as new source
      files, removing them if necessary in order to prevent them from being read
      by a build command. This is not the default because it deletes things, but
      it is often required in order for incremental building to work properly.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, assume that there is an <i>x.c</i> file that looks like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    #include &quot;x.h&quot;
    int main() { return X; }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Consider this makefile:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony default): x
    x.h:
        &amp;echo &quot;#define X 1&quot; -o $@
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    At some point, you change the makefile to look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    CFLAGS := -Idir
    $(phony default): x
    dir/x.h:
        &amp;mkdir -p $(dir $@)
        &amp;echo &quot;#define X 2&quot; -o $@
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Now if you build from clean, <i>x</i> exits with status 2, but if you build
      while the old <i>./x.h</i> file still exists and you don't specify
      &quot;--rm-stale&quot;, then <i>x</i> exits with status 1, because the
      include directive picks up the stale generated header file.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you build with &quot;--rm-stale&quot;, then <i>./x.h</i> is removed, and
      the result is the same as that of a clean build, which is almost always a
      good thing.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that if you build in a repository, you have to give this option there
      first, because the importing makepp doesn't know what might be stale in
      the repository.
    <div style="height: 1.00em;">&#x00A0;</div>
    Legacy makefiles sometimes put the rule to generate an include file after
      the include statement. Mpp works around that like gmake, by reloading at
      the end of the makefile if needed. But this means on a rebuild it looks
      stale at the point where it is needed, and will be deleted. Therefore this
      option turns off this kind of reloading.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--quiet</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--silent</dt>
  <dd class="It-tag">Don't echo commands and don't print informational messages
      like &quot;Scanning&quot; or &quot;Loading makefile&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--sandbox=<i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--in-sandbox=<i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--inside-sandbox=<i>directory</i></dt>
  <dd class="It-tag">Restrain this instance of makepp to a subtree of a normally
      bigger build tree. See partitioning into sandboxes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--sandbox-warn</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--sandbox-warning</dt>
  <dd class="It-tag">Downgrade violations of &quot;in-sandbox&quot; and
      &quot;dont-read&quot; to warnings instead of errors. See partitioning into
      sandboxes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--stop-race</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--stop-on-race</dt>
  <dd class="It-tag">Exit in error rather than only warning about a build cache
      access collision that could be fixed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symlink-in-rep-as-file</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symlink-in-repository-as-file</dt>
  <dd class="It-tag">If a repository contains a symbolic link, then by default
      that symbolic link is imported as a link, which is to say that the target
      of the imported link need not be identical to the target of the symbolic
      link in the repository. If the &quot;--symlink-in-repository-as-file&quot;
      option is specified, then the symbolic link is imported as its target
      file, which is to say that the imported link points to the same target
      file as the symbolic link in the repository. This is useful if the
      symbolic link in the repository was intended to have the build-time
      semantics of a copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--traditional</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--traditional-recursion</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--traditional-recursive-make</dt>
  <dd class="It-tag">This option is present to allow makepp to work with old
      makefiles that use recursive make extensively, especially with varying
      options. By default, recursive make is implemented by a subprocess that
      communicates with the parent process; the build is actually done by the
      parent process. This allows some of makepp's nice features like
      repositories to work with recursive make invocations. However, this
      technique will not work if you use different command line options on
      different invocations of recursive make. Before you use this, try
      &quot;--hybrid-recursive-make&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;--traditional-recursive-make&quot; option makes makepp do recursive
      makes the same way as the traditional make, allowing more makefiles to
      work, but then repositories and parallel builds do not work properly. This
      option is rarely needed any more, and makepp will tell you if it runs into
      a construct that requires it.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you do use this option, you will get log files piling up in the various
      directories this changes to. To get rid of only them use &quot;makeppclean
      --logs --recurse&quot; or &quot;mppc -lr&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--verbose</dt>
  <dd class="It-tag">Verbose mode. Explains what it is trying to build, and why
      each file is being built. This can be useful if you think a file is being
      rebuilt too often.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option actually takes what would be written to the log file and
      displays it on the screen. It's usually easier to run makepp and then look
      at the output of makepplog, which allows various selections and some
      rewriting.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-V</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--version</dt>
  <dd class="It-tag">Print out the version number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--virtual-sandbox</dt>
  <dd class="It-tag">Don't rewrite build infos of files that were not created by
      this makepp process. See partitioning into sandboxes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-W <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--assume-new=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--new-file=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--what-if=<i>filename</i></dt>
  <dd class="It-tag">Pretends the specified file has changed, so that any
      targets that depend on that file will be rebuilt. The file itself is not
      necessarily changed (it might or might not be rebuilt, depending on
      whether it is up to date with respect to its dependencies), but everything
      that depends on it thinks that it has changed. This can be useful for
      debugging a makefile.</dd>
</dl>
<h1 class="Sh" title="Sh" id="ENVIRONMENT"><a class="selflink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
Makepp searches upwards for a file called <i>.makepprc</i> when starting and
  again after every &quot;-C&quot; or &quot;-c&quot; option. Each time it finds
  such a file, but only once per file, it will read the file and parse it as
  possibly quoted options on one or several lines. Unlike the option
  &quot;-A&quot;, the options will be parsed relative to the directory where the
  file resides.
<div class="Pp"></div>
Makepp looks at the following environment variables:
<dl class="Bl-tag">
  <dt class="It-tag">$MAKEFLAGS</dt>
  <dd class="It-tag">Any flags in this environment variable are interpreted as
      command line options before any explicit options. All command line
      arguments are put into this variable
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the traditional make also uses this variable, so if you have to
      use both make and makepp, you might want to consider using
      &quot;MAKEPPFLAGS&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$MAKEPPFLAGS</dt>
  <dd class="It-tag">Same as &quot;MAKEFLAGS&quot; as far as makepp is
      concerned. If this variable is not blank, then &quot;MAKEFLAGS&quot; is
      ignored. Sometimes this is useful instead of &quot;MAKEFLAGS&quot; if you
      have to use both make and makepp, and you need to keep the options
      separate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$MAKEPP_CASE_SENSITIVE_FILENAMES</dt>
  <dd class="It-tag">Makepp will attempt to determine whether its default
      directory is case sensitive by creating a file and then accessing it with
      a different case. Usually this works fine, as long as all the files you're
      accessing are on the same file system as your default directory, so you
      should rarely need to use this option.
    <div style="height: 1.00em;">&#x00A0;</div>
    If this variable is present in the environment, its value (0 or empty string
      for false, anything else for true) will override makepp's choice. This
      variable is mostly useful on Windows, if you want to override makepp's
      default setting. If you don't treat filenames as case sensitive, then
      makepp converts all filenames to lowercase, which causes occasional
      difficulties. (E.g., emacs may will open several buffers to the same
      file.)
    <div style="height: 1.00em;">&#x00A0;</div>
    Makepp does not currently support a build across several file systems well,
      if one is case sensitive and the other case insensitive.</dd>
</dl>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
