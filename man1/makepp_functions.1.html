<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_FUNCTIONS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_FUNCTIONS(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_FUNCTIONS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp_functions -- Functions in makepp
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>A:</b>&#x00A0;absolute_filename,
<br/>
 absolute_filename_nolink,
<br/>
 abspath,
<br/>
 addprefix,
<br/>
 addsuffix,
<br/>
 and,&#x00A0; <b>B:</b>&#x00A0;basename,&#x00A0; <b>C:</b>&#x00A0;call,&#x00A0;
  <b>D:</b>&#x00A0;dir,
<br/>
 dir_noslash,&#x00A0; <b>E:</b>&#x00A0;error,&#x00A0;
  <b>F:</b>&#x00A0;filesubst,
<br/>
 filter,
<br/>
 filter_out,
<br/>
 filter_out_dirs,
<br/>
 findfile,
<br/>
 find_first_upwards,
<br/>
 find_program,
<br/>
 findstring,
<br/>
 find_upwards,
<br/>
 first_available,
<br/>
 firstword,
<br/>
 foreach,&#x00A0; <b>I:</b>&#x00A0;if,
<br/>
 iftrue,
<br/>
 infer_linker,
<br/>
 infer_objects,
<br/>
 info,&#x00A0; <b>J:</b>&#x00A0;join,&#x00A0; <b>M:</b>&#x00A0;make,
<br/>
 makemap,
<br/>
 makeperl,
<br/>
 map,
<br/>
 &quot;mktemp&quot;,&#x00A0; <b>N:</b>&#x00A0;notdir,&#x00A0;
  <b>O:</b>&#x00A0;only_generated,
<br/>
 only_nontargets,
<br/>
 only_phony_targets,
<br/>
 only_stale,
<br/>
 only_targets,
<br/>
 or,
<br/>
 origin,&#x00A0; <b>P:</b>&#x00A0;patsubst,
<br/>
 perl,
<br/>
 phony,
<br/>
 prebuild,
<br/>
 print,&#x00A0; <b>R:</b>&#x00A0;realpath,
<br/>
 relative_filename,
<br/>
 relative_to,&#x00A0; <b>S:</b>&#x00A0;shell,
<br/>
 sort,
<br/>
 strip,
<br/>
 subst,
<br/>
 suffix,&#x00A0; <b>T:</b>&#x00A0;temporary,&#x00A0; <b>W:</b>&#x00A0;warning,
<br/>
 wildcard,
<br/>
 word,
<br/>
 wordlist,
<br/>
 words,&#x00A0; <b>X:</b>&#x00A0;xargs
<div class="Pp"></div>
Any expression of the format &quot;$(name)&quot;, where &quot;name&quot; is not
  the name of a variable, or
  &quot;$(name&#x00A0;arg1&#x00A0;arg2&#x00A0;arg3)&quot; is interpreted as a
  function call. The name may contain letters, underscores, or hyphens; to avoid
  confusion, you may use hyphens or underscores interchangeably, since
  internally hyphens are converted to underscores. Evaluating such an expression
  simply invokes a Perl subroutine. If &quot;name&quot; is preceded by
  &quot;&amp;&quot; it runs the builtin command or script of that name within
  the makepp process, and returns the standard output. This requires perl to be
  built for PerlIO. If the name does not name a function it is transformed to an
  invocation of call.
<div class="Pp"></div>
As with variables you have a choice of &quot;$(name ...)&quot; or &quot;${name
  ...}&quot;. If you want to embed the same parenthesis, it must be paired, the
  other doesn't matter: &quot;$(name ...(){...&quot; or &quot;${name
  ...{}(...}&quot;. (However for map and perl the first closing paren ends the
  expression.) Doubling allows the arguments to span several lines. The newlines
  are then treated as spaces, except maybe in &quot;define&quot;. There is also
  the syntax &quot;$[name ...]&quot; or $[[name ...]], which gets evaluated
  while reading the makefile, before grokking rules and other constructs.
<div class="Pp"></div>
Makepp has a number of builtin functions which may be useful. It supports almost
  all of GNU make's textual functions (see GNU make's documentation for
  details), and some of its own. You can define Perl subroutines to do whatever
  you like. See the &quot;sub&quot; statement and the section on extending
  makepp for more details.
<h2 class="Ss" title="Ss" id="Conditional_Functions"><a class="selflink" href="#Conditional_Functions">Conditional
  Functions</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">and <i>condition1[,condition2[,condition3...]]</i></dt>
  <dd class="It-tag">The and function provides a &quot;short-circuiting&quot;
      AND operation. Each argument is expanded, in order. If an argument expands
      to an empty string the processing stops and the result of the expansion is
      the empty string. If all arguments expand to a non-empty string then the
      result of the expansion is the expansion of the last argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">if <i>string, result-if-string-not-blank[,
    result-if-string-blank]</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">iftrue <i>string, result-if-string-true[,
    result-if-string-false]</i></dt>
  <dd class="It-tag">An alternative to the &quot;ifeq&quot;, etc., statements.
      If the string is not blank (i.e., the condition is true), the second
      argument (the &quot;then&quot; clause) is returned (after variable
      expansion); if the string is blank, the third argument (the
      &quot;else&quot; clause) is returned.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    CFLAGS := $(if $(filter gcc egcc, $(CC)), -g -Wall, -g)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    defines CFLAGS to be &quot;-g -Wall&quot; if the variable CC is either
      &quot;gcc&quot; or &quot;egcc&quot;, and &quot;-g&quot; otherwise. (This
      is what the default build rules do.)
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;iftrue&quot; is similar to &quot;if&quot;, except that the string 0 is
      treated as blank.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">or <i>condition1[,condition2[,condition3...]]</i></dt>
  <dd class="It-tag">The or function provides a &quot;short-circuiting&quot; OR
      operation. Each argument is expanded, in order. If an argument expands to
      a non-empty string the processing stops and the result of the expansion is
      that string. If, after all arguments are expanded, all of them are false
      (empty), then the result of the expansion is the empty string.</dd>
</dl>
<h2 class="Ss" title="Ss" id="File_and_Filename_Functions"><a class="selflink" href="#File_and_Filename_Functions">File
  and Filename Functions</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">absolute_filename <i>files</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">abspath <i>files</i></dt>
  <dd class="It-tag">Converts relative filenames into absolutes without <i>.</i>
      or <i>..</i>. For example, &quot;$(absolute_filename&#x00A0;xyz.c)&quot;
      might return &quot;/usr/src/our_project/subdir/xyz.c&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">absolute_filename_nolink <i>files</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">realpath <i>files</i></dt>
  <dd class="It-tag">Like absolute_filename, but ensures that symbolic links are
      resolved.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">basename <i>filenames</i></dt>
  <dd class="It-tag">The basename is the entire file name (with the directory),
      minus the text after and including the last period. E.g.,
      &quot;$(basename&#x00A0;myfile/version-1.0-module.c)&quot; is
      &quot;myfile/version-1.0-module&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dir <i>filenames</i></dt>
  <dd class="It-tag">Extracts the directory part of each file in the filename
      list, including the trailing slash. Returns &quot;./&quot; if there is no
      directory in the filename.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dir_noslash <i>filename</i></dt>
  <dd class="It-tag">Same as &quot;$(dir&#x00A0;)&quot; except that it doesn't
      return the trailing slash.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">filesubst <i>pattern, substitute, words</i></dt>
  <dd class="It-tag">Perform a pattern substitution on file names.	 This differs
      from patsubst in that it will perform correctly when alternate names for
      directories are given (as long as they precede the percent sign). For
      example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(filesubst ./src/%.c, %.o, $(wildcard src/*.c))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will work with filesubst but not with patsubst.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">filter_out_dirs <i>filenames</i></dt>
  <dd class="It-tag">Returns all filenames that do not refer to
    directories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">findfile <i>filename, path</i></dt>
  <dd class="It-tag">Finds a file in the specified path, or in the environment
      variable PATH if nothing is specified. This can be useful for finding
      binaries or include files. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    TCL_INCLUDE := -I$(dir_noslash $(findfile tcl.h, \
        /usr/local/stow/tcl-8.4.5-nothread/include \
        /usr/include/tcl8.4 /usr/include/tcl \
        /net/na1/tcl8.4a3/include /net/na1/tcl8.4a3/include))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This locates the file <i>tcl.h</i> by searching all of the above
      directories. The absolute path to the file is returned. Then
      &quot;$(dir_noslash&#x00A0;)&quot; extracts that directory, and it is put
      into the include path.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">find_program <i>name</i></dt>
  <dd class="It-tag">Return the first program in the list that can be found in
      the PATH. This is useful when there are multiple equivalent programs that
      may be used, and you just want to pick one of them. For example, here is
      the default definition of several common variables that makepp supplies if
      you do not put one in your makefile:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    CC = $(find_program gcc egcc pgcc c89 cc) # and more, depending on machine
    F77 = $(find_program f77 g77 fort77)
    CXX = $(find_program g++ c++ pg++ cxx CC aCC)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If none of the programs is found, &quot;$(find_program&#x00A0;)&quot;
      returns the string not-found, and logs what was not found. This usually
      won't result in a functional makefile, but it will tend to make for better
      error messages. For example, if you do something like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o : %.c
        $(CC) $(inputs) -o $(outputs)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and makepp can't find a C compiler in the list above, it will substitute
      not-found. Otherwise the shell would attempt to execute the source file
      and the resulting error message might be really strange.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">find_upwards <i>filename</i></dt>
  <dd class="It-tag">Searches for a file of the given name in the directory .,
      .., ../.., ../../.., etc., until the file is found or the root directory
      is reached or the directory is located on a different file system. (This
      last requirement is to prevent problems with automounters or hung network
      filesystems.) If you have a <i>RootMakeppfile</i>, that is also a barrier
      which prevents searching higher.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, if you have a project with many levels of subdirectories, you
      could include this common fragment in all of the makefiles (e.g., by using
      the &quot;include&quot; statement):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    TOP_LEVEL_INCLUDE_DIR := $(find_upwards includes)
                                # Searches for a directory that contains the
                                # includes subdirectory.
    %.o : %.c
        $(CC) $(CFLAGS) -I$(TOP_LEVEL_INCLUDE_DIR) -c $(input) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Another problem that &quot;find_upwards&quot; can help solve is locating the
      top-level directory of a build. Often it is useful to define a variable
      like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    TOP := ../../..
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    if you have some important information located only in the top-level
      directory. But this is hard to maintain, because the number of
      &quot;..&quot; is different for different levels of the directory tree.
      Instead, you can use &quot;find_upwards&quot; to locate a file which is
      known to be present only in the top level directory. Suppose, for example,
      that the file &quot;LICENSE&quot; is located only in the top level
      directory. Then you could do this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    TOP := $(dir_noslash $(find_upwards LICENSE))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;$(find_upwards&#x00A0;LICENSE)&quot; returns the full path of the
      license file; &quot;$(dir_noslash&#x00A0;...)&quot; strips off the
      filename, returning only the directory.
    <div style="height: 1.00em;">&#x00A0;</div>
    (Note that the &quot;include&quot; statement automatically searches upwards
      for files, so there is no need to do something like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    include $(find_upwards top_level_rules.mk)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Instead, you can just do
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    include top_level_rules.mk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and it will work just as well.)
    <div style="height: 1.00em;">&#x00A0;</div>
    If the file is not found, &quot;find_upwards&quot; will abort the build with
      an error message.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you specify more than one file, find_upwards will search for the first
      one, then the second one, and so on. In other words,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(find_upwards file1 file2)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(find_upwards file1) $(find_upwards file2)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want to look for any one of the files, then use
      &quot;find_first_upwards&quot; instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">find_first_upwards <i>file1 file2 ...</i></dt>
  <dd class="It-tag">This function behaves like &quot;find_upwards&quot; except
      that it returns the first file of any files in the list that it finds.
      Specifically, it checks the current directory for any of the files in the
      list, and returns the first file which exists or can be built. If none of
      the files exist or can be built in that directory, it checks <i>..</i>,
      then <i>../..</i>, etc., until it reaches either the root directory or a
      directory which is located on a different file system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">first_available <i>file1 file2 ...</i></dt>
  <dd class="It-tag">Return the first file in a list that exists or can be
      built. This can be useful for adapting your makefiles to work on several
      different machines or networks, where important files may be located in
      different places. For example, here's a line from one of my makefiles:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    TCL_LIB = $(first_available \
        /usr/local/stow/tcl-8.4.5-nothread/lib/libtcl8.4.so \
        /usr/lib/libtcl8.4.so /usr/lib/libtcl.so \
        /net/na1/tcl8.4a3/lib/libtcl8.4.a \
        /net/na1/tcl8.4a3/lib/libtcl8.4.sl)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This line will check for the Tcl library in all of the above places,
      stopping at the first one that it finds. The link command then includes
      $(TCL_LIB) so we get the appropriate Tcl library.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">infer_linker <i>file1 file2 ...</i></dt>
  <dd class="It-tag">Given a list of object files first build them if they have
      not been yet. Then find whether they depend on a Fortran, C++ or a C
      source and return the corresponding compiler (which better knows how to
      link than &quot;ld&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">infer_objects <i>file1 file2 ..., pattern</i></dt>
  <dd class="It-tag">
    <pre>
    $(infer_objects object1.o object2.o, *.o)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you use standard conventions regarding header file names, makepp is
      capable of guessing which &quot;.o&quot; or &quot;.lo&quot; files need to
      be linked with your program. I use this to pick out files from a library
      directory which contains modules used in many different programs. Instead
      of making a library &quot;.a&quot; file and having the linker pick out the
      relevant modules, makepp can pick out the relevant modules for you. This
      way, only the relevant modules get compiled.
    <div style="height: 1.00em;">&#x00A0;</div>
    Makepp's algorithm for inferring object dependencies depends on the
      convention that the implementation of all classes or functions defined in
      a header file &quot;xyz.h&quot; are compiled into an object file called
      &quot;xyz.o&quot; (or &quot;xyz.lo&quot;). So makepp's algorithm for
      inferring object dependencies starts with one or a few objects that we
      know have to be linked into the program. It looks at which files were
      included with &quot;#include&quot; in those sources, and tries to find
      corresponding object files for each of the include files.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;$(infer_objects&#x00A0;)&quot; needs to be mentioned in the dependency
      list of a program, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    myprog: $(infer_objects main.o another_object.o, \
                **/*.o /other/library/dirs/**/*.o)
        $(CXX) $(inputs) -o $(output) $(LIBS)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;$(infer_objects)&quot; function takes two arguments (separated by
      a comma, as shown). The first is one or a few object files that are known
      to be required (wildcards are permissible here). The second is a list of
      possible objects (normally you would use a wildcard here) that could be
      linked in if necessary. The return value from this function is a list that
      contains first all of the objects in the first argument, and then after
      those, all additional objects that were contained in the second argument
      that are required by the objects in the first argument.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, suppose &quot;main.o&quot; comes from &quot;main.cpp&quot;,
      which includes &quot;my_class.h&quot;. &quot;$(infer_objects)&quot; looks
      for files with the name &quot;my_class.o&quot;. If exactly one such file
      is found, it is added to the list. (If two object files
      &quot;my_class.o&quot; are found in different directories, a warning
      message is printed.) &quot;infer_objects&quot; also examines
      &quot;my_class.cpp&quot; to see what it includes, and what additional
      object files are implied.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">mktemp</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">mktemp <i>prefix</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">mktemp <i>prefix</i>XXX</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">mktemp /</dt>
  <dd class="It-tag">Returns an unpredictable temporary filename, which does not
      currently exist. No name pointing to the same file is returned twice, even
      with different relative paths, within one makepp run (except possibly with
      traditional recursive make, or if Perl code running within a rule action
      calls &quot;f_mktemp&quot;). At the end of the makepp run all files
      returned by this function are deleted, if they exist (again except for
      those returned by this function in Perl code running within a rule).
    <div style="height: 1.00em;">&#x00A0;</div>
    Any number of upper case &quot;X&quot;s at the end of the argument are
      replaced by that many random letters and digits. The more there are, the
      less likely this is to collide with other processes, so if you give a
      prefix like &quot; <i>/tmp/abc.</i>&quot;, you should have enough
      &quot;X&quot;s. If there is more than one X, the first character comes
      from the process id. If there are none, it is as though there were ten,
      which is supposedly enough (8.4e17 possibilities or 3.7e15 on Windows). If
      there is no argument, the prefix defaults to &quot; <i>tmp.</i>&quot; in
      the current directory.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that you don't want to give such a name as rule targets and
      dependencies. The result would be correct, but it would be recreated every
      time you run makepp.
    <div style="height: 1.00em;">&#x00A0;</div>
    Also, as it is always different, you should use this in a rule action only
      if you use &quot;:build_check ignore_action&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    TMPFILE ;= $(mktemp)        # 1 call; &quot;=&quot; would mean 3 calls: 3 files
    A-count B-count: :build_check ignore_action
        produce-As-and-Bs &gt;$(TMPFILE)
        &amp;grep -c /A/ $(TMPFILE) -o A-count
        &amp;grep -c /B/ $(TMPFILE) -o B-count
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or you should export it and let the Shell evaluate it:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    export TMPFILE ;= $(mktemp)
    A-count B-count:
        produce-As-and-Bs &gt;$$TMPFILE # makepp doesn't see the var value
        fgrep -c A $$TMPFILE &gt;A-count
        fgrep -c B $$TMPFILE &gt;B-count
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The last form repeats the previous return value, so you can use it in a
      pattern rule:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.x: %.y
        &amp;grep foo $(input) -o $(mktemp)
        &amp;sed bar $(mktemp /) -o $(output) # Operate on the output of &amp;grep
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">notdir <i>filenames</i></dt>
  <dd class="It-tag">Returns the non-directory portion of the filename(s), i.e.,
      everything after the last slash if there is one, or the whole filename
      otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">only_generated <i>filenames</i></dt>
  <dd class="It-tag">Returns only those filenames in the list that were
      generated by makepp and not since modified, according to the build info
      file.
    <div style="height: 1.00em;">&#x00A0;</div>
    This function is useful in clean target rules (though of course
      &quot;makeppclean&quot; is the preferred variant):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony clean):
        &amp;rm -f $(only_generated **/*)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">only_nontargets <i>filenames</i></dt>
  <dd class="It-tag">Returns only those filenames in the list that are not
      targets of any rule (either explicit or pattern rules). You may specify a
      wildcard (see the &quot;$(wildcard&#x00A0;)&quot; function for more
      details on makepp's wildcards). This can be used for generating a
      distribution target, for example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    .PHONY: distribution
    distribution:
        &amp;mkdir our_product-$(VERSION)
        &amp;cp $(filter-out %~, $(only_nontargets *)) our_product-$(VERSION)
        tar cf - our_product-$(VERSION) | gzip -9c &gt; our_product-$(VERSION).tar.gz
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In this case, the &quot;$(only_nontargets *)&quot; returns every file in the
      current directory that is not a target of some rule. The
      &quot;$(filter_out %~, ...)&quot; removes editor backups.
    <div style="height: 1.00em;">&#x00A0;</div>
    Similar to &quot;only_targets&quot; (see above), &quot;only_nontargets&quot;
      only knows about targets that have been defined already. This is only a
      problem if you use it to define variables with the &quot;:=&quot;
      assignment; if you use it in the dependency list or in the body of a rule,
      all other rules will already have been seen.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">only_stale <i>filenames</i></dt>
  <dd class="It-tag">Returns only those filenames in the list that were
      generated by makepp and not since modified, according to the build info
      file, but are no longer targets of any rule.
    <div style="height: 1.00em;">&#x00A0;</div>
    This function is useful for ensuring that there are no dependencies on such
      files, without forcing a clean build of all of the targets:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony flush):
        &amp;rm -f $(only_stale **/*)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Actually, it's probably better instead to write a script that calls makepp
      to generate the list of stale files, and then have that script remove all
      of the listed files that aren't currently under source control, just in
      case a generated file becomes a source file. Makepp doesn't have such a
      function built in because makepp is (and probably ought to remain)
      agnostic about source control.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">only_targets <i>filenames</i></dt>
  <dd class="It-tag">Returns only those filenames in the list that are actually
      targets of some rule (either explicit or pattern rules). You may specify
      wildcards (including makepp's special wildcard, &quot;**&quot;) in the
      filenames. (See the &quot;$(wildcard&#x00A0;)&quot; function for more
      details. This can be used for a clean target, for example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    .PHONY: clean
    clean:
        &amp;rm -f $(only_targets *)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Now if you type &quot;makepp&#x00A0;clean&quot;, it will delete everything
      it knows how to build. But don't create a clean target, use
      &quot;makeppclean&quot; instead!
    <div style="height: 1.00em;">&#x00A0;</div>
    Another place where it may be useful is to avoid including stale <i>.o</i>
      files in your build. For example, if you build a library like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    mylib.a: *.o
        &amp;rm -f $(output)
        $(AR) cr $(output) $(inputs)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and then you delete some source files but forget to delete the corresponding
      <i>.o</i> files, the <i>.o</i> files will still be around. This means they
      will still be incorporated into the library despite the fact that they are
      not useful any more. If you modify your rule like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    mylib.a: $(only_targets *.o)
        &amp;rm -f $(output)
        $(AR) cr $(output) $(inputs)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    then this problem won't occur.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that this refers only to files that are known to be targets <i>at</i>
      <i>the time you invoke</i> &quot;only-targets&quot;. If
      &quot;only_targets&quot; appears in the dependencies or actions of a rule,
      then all possible targets will be known because dependencies and actions
      are not evaluated until the rule is executed. However, if you evaluate try
      to evaluate it earlier in the makefile with a &quot;:=&quot; variable like
      this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ALL_TARGETS := $(only_targets *)
    target1: dependency1
        actions
    target2: dependency2
        actions
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    then &quot;only_targets&quot; will not know about the subsequent rules.
    <div style="height: 1.00em;">&#x00A0;</div>
    Similarly, &quot;only_targets&quot; doesn't know about targets produced in
      makefiles that are loaded with recursive make. (But you shouldn't be using
      recursive make anyway; use use the &quot;load_makefile&quot; statement, or
      implicit makefile loading instead.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">relative_filename <i>file1 file2 file3[, slash]</i></dt>
  <dd class="It-tag">Returns the name of those files relative to the current
      directory (the one the makefile is in). This can also be used to clean
      unnecessary &quot;./&quot; and other junk from the path:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    DIR := .
    SUBDIR := ..
    FNAME := $(DIR)/../otherdir/$(SUBDIR)/files
    X := $(relative_filename $(FNAME))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>slash</i> is true (usually 1) the returned filenames are guaranteed to
      contain a slash by prepending &quot;./&quot; if necessary, so that you can
      use it as an executable name without worrying about the command search
      path overriding the directory location.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the path goes by the root directory, the parent of either your home
      directory or the &quot;$(ROOT)&quot; of your build system, or on Windows a
      drive's root (depending on the environment, this also happens for
      <i>/cygdrive/c</i> or <i>/c</i>), an absolute path will be returned
      instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">relative_to <i>file1 file2 file3[, directory]</i></dt>
  <dd class="It-tag">Returns the name of those files relative to the specified
      directory. This is typically useful when for whatever reason you have to
      execute a command from a different directory (default current directory):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    source_backup.tar:
        cd .. &amp;&amp; tar cf $(relative_to $(output), ..) $(relative_to ., ..)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">suffix <i>names...</i></dt>
  <dd class="It-tag">Extracts the suffix of each file name in names. If the file
      name contains a period, the suffix is everything starting with the last
      period. Otherwise, the suffix is the empty string. This frequently means
      that the result will be empty when names is not, and if names contains
      multiple file names, the result may contain fewer file names.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(suffix src/foo.c src-1.0/bar.c hacks)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    produces the result &quot;.c .c&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">temporary <i>words</i></dt>
  <dd class="It-tag">Let makepp know that the specified targets may be removed
      by the rule that generates them. Similar to &quot;phony&quot;, except that
      makepp expects that a real file of that name will may be affected by the
      rule. A rule is not executed if only its temporary targets are
      out-of-date.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">wildcard <i>pattern</i></dt>
  <dd class="It-tag">Returns the sorted names of all files matching the given
      pattern which exist, or those files which do not yet exist but can be
      built based on the rules that makepp knows about at the point when it
      evaluates the expression. In this last point it differs from rule input
      wildcards, which apply even to files created by rules found later.
    <div style="height: 1.00em;">&#x00A0;</div>
    Makepp supports all the usual shell wildcards (&quot;*&quot;, &quot;?&quot;,
      and &quot;[]&quot;). It also has a wildcard &quot;**&quot; which matches
      any number of intervening directories. (This idea was stolen from zsh.)
      For example, &quot;**/*.c&quot; matches all the <i>.c</i> files in the
      entire source tree. &quot;objects/**/*.o&quot; matches all the <i>.o</i>
      files contained anywhere in the subdirectory <i>objects</i> or any of its
      subdirectories or any of their subdirectories. The &quot;**&quot; wildcard
      will not follow soft links to directories at any level, nor will it
      attempt to enter directories which exist but cannot be read. Also files
      and directories which exist but cannot be read will not be returned by
      &quot;$(wildcard&#x00A0;)&quot;.</dd>
</dl>
<h2 class="Ss" title="Ss" id="String_Functions"><a class="selflink" href="#String_Functions">String
  Functions</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">addprefix <i>prefix, words</i></dt>
  <dd class="It-tag">Prepends the prefix string to each of the words. This is
      mostly for GNU make compatibility; using rc-style expansion, this can be
      done in a more readable fashion like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    MODULES := a b c d
    X_OLD_STYLE := $(addprefix $(OBJDIR)/, $(addsuffix .o, $(MODULES)))
    X_NEW_STYLE := $(OBJDIR)/$(MODULES).o   # Isn't that easier to read?
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">addsuffix <i>suffix, words</i></dt>
  <dd class="It-tag">Appends the suffix string to each of the words. This is
      mostly for GNU make compatibility; using rc-style expansion, this can be
      done in a more readable fashion like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    X_OLD_STYLE := $(addsuffix .o, $(MODULES))
    X_NEW_STYLE := $(MODULES).o
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">call <i>variable[, words]... </i></dt>
  <dd class="It-tag">The function &quot;call&quot; is unique in that it can be
      used to regard <i>variable</i> as a parameterized function. You can assign
      a complex expression to <i>variable</i> and use &quot;call&quot; to expand
      its contents to different values parametrized by <i>words</i> later on. In
      other make systems, a variable that is used mainly for the purpose to be
      expanded via &quot;call&quot;, is called a <b>macro</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    During expansion of the macro, the temporary variables
      <b></b><b>$1</b><b></b>, <b></b><b>$2</b><b></b>,
      <b></b><b>&quot;...&quot;</b> <b></b> refer to the arguments given to
      &quot;call&quot; during its invocation. The variable
      <b></b><b>$0</b><b></b> will be expanded to the name of the macro (i.e.
      <i>variable</i>) that &quot;call&quot; is currently expanding.
    <div style="height: 1.00em;">&#x00A0;</div>
    There is no limit, how many arguments a macro may be &quot;call&quot;ed with
      or how many parameters a macro may expect. If you pass more arguments to
      &quot;call&quot; as the macro need, all exceeding arguments will be
      discarded. If you pass less arguments than a macro expect, all exceeding
      parameters collapse into the empty string.
    <div style="height: 1.00em;">&#x00A0;</div>
    First a simple example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    rest = $(wordlist 2, $(words $(1)),$(1))
    list = A B C D E
    butfirst := $(call rest,$(list))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here, the variable &quot;$(butfirst)&quot; will contain the list
      &quot;B&#x00A0;C&#x00A0;D&#x00A0;E&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    And now for a more complex example to show what is possible:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    rest = $(wordlist 2,$(words $(1)),${1})
    mymap = $(if $2,$(call $1,$(firstword $2)) $(call $0,$1,$(call rest,$2)))
    downcase = ${makeperl lc(&quot;$1&quot;)}
    UCWORDS = ALL THESE WORDS ARE UPCASE
    DCWORDS := $(call mymap,downcase,$(UCWORDS))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Now &quot;$(DCWORDS)&quot; contains
      &quot;all&#x00A0;these&#x00A0;words&#x00A0;are&#x00A0;upcase&quot;. By the
      way: it makes no difference, whether we access the arguments via
      <b></b><b>$1</b><b></b>, <b></b><b>&quot;${1}&quot;</b><b></b> or
      <b></b><b>&quot;$(1)&quot;</b><b></b> within a macro.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can directly use the variable as though it were a function, if there is
      no function of that name. This is internally converted to
      &quot;call&quot;, so these are equivalent:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    discussion = The $0 turned into $1 $2.
    direct = $(discussion an,argument)
    called = $(call discussion,an,argument)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It might seem debatable whether &quot;$[call]&quot; should also expand the
      macro's &quot;$[]&quot; expressions, or whether a function should always
      do the same thing, no matter how it is called. The latter was chosen,
      because with normal make syntax it would be impossible to get &quot;$[1],
      $[2]...&quot; into a variable (they'd get replaced by nothing, before the
      assignment even takes place.) Hence, if you have a macro for defining a
      rule, you want expressions like &quot;$(output)&quot; to be seen when the
      rule gets parsed, so you must protect them from &quot;call&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    define myrule
        $2: $1
            mycommand $$(input) -o $$(output)
    endef
    $[myrule myinput,myoutput]
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">filter <i>patterns, words</i></dt>
  <dd class="It-tag">Returns all words in the list that match the patterns.
      Patterns may simply be other words, or filename wildcards (i.e.,
      &quot;*&quot;, &quot;?&quot;, and &quot;[a-z]&quot; are recognized), or
      they may have a &quot;%&quot; character, which means to match any string
      at that point (same as &quot;*&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">filter_out <i>patterns, words</i></dt>
  <dd class="It-tag">Returns all words in the list that do not match the
      patterns. Patterns may simply be other words, or filename wildcards (i.e.,
      &quot;*&quot;, &quot;?&quot;, and &quot;[a-z]&quot; are recognized), or
      they may have a &quot;%&quot; character, which means to match any string
      at that point (same as &quot;*&quot;).
    <div style="height: 1.00em;">&#x00A0;</div>
    For example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    libproduction.a: $(filter_out test_*, $(wildcard *.o))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will put all <i>.o</i> files which exist or can be built, except those
      beginning with <i>test_</i>, into <i>libproduction.a</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">findstring <i>find, in</i></dt>
  <dd class="It-tag">Return <i>find</i>, if it is a substring of <i>in</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">firstword <i>words</i></dt>
  <dd class="It-tag">Return the first word.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">map <i>words, perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makemap <i>words, perlcode</i></dt>
  <dd class="It-tag">Similarly to Perl's map, applies <i>perlcode</i> to each
      word in turn and returns the results. The first variant is plain Perl
      code, while the second variant first passes the perlcode through
      Make-style variable expansion. The words are expanded in both cases.
    <div style="height: 1.00em;">&#x00A0;</div>
    The words are in $_ and are returned unless you undef $_. This is intended
      for modifications not easily handled by &quot;patsubst&quot;. Only the
      first comma is a separator, any others are considered part of the
      <i>perlcode</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # Switch words.  Double parens, to allow parens in perlcode, or use ${}:
    X = $((map $(VALUES), s/(.+)-(.+)/$2-$1/))
    # You can use make expressions, but then you must use $$ for Perl $:
    Y = $(makemap $(VALUES), tr/$(OLDCHARS)/$(NEWCHARS)/ or $$_ = 'failed')
    # You can eliminate candidates:
    Y = $(map $(VALUES), undef $_ if /no_good/)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">join <i>words1, words2</i></dt>
  <dd class="It-tag">Do a pairwise join of the first words and the second
    words.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">patsubst <i>pattern, substitute, words</i></dt>
  <dd class="It-tag">Performs a substitution on each word in the word list. A
      &quot;%&quot; character matches any string. This is best illustrated by an
      example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    OBJS = $(patsubst %.c, object_dir/%.o, $(C_SOURCES))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    takes every file in C_SOURCES and returns the name of an object file in
      object_dir. Sometimes it is more concise to use a substitution reference,
      e.g., the above could have been written as
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    OBJS = $(C_SOURCES:%.c=object_dir/%.o)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sort <i>word1 word2 word3 ...</i></dt>
  <dd class="It-tag">Sorts the words in lexical order and removes
    duplicates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">strip <i>string</i></dt>
  <dd class="It-tag">Removes leading and trailing whitespace from string and
      replaces each internal sequence of one or more whitespace characters with
      a single space. Thus, &quot;$(strip a b c )&quot; results in &quot;a b
      c&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">subst <i>from,to,text</i></dt>
  <dd class="It-tag">Performs a textual replacement on the text text: each
      occurrence of from is replaced by to. The result is substituted for the
      function call. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(subst ee,EE,feet on the street)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    substitutes the string &quot;fEEt on the strEEt&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">word <i>n,text</i></dt>
  <dd class="It-tag">Returns the <i>n</i>th word of <i>text</i>. The legitimate
      values of <i>n</i> start from 1 at the beginning or backwards from -1 at
      the end. If <i>n</i> is bigger than the number of words in <i>text</i>,
      the value is empty.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">wordlist <i>indexlist, words</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">wordlist <i>firstindex, lastindex, words</i></dt>
  <dd class="It-tag">In the first form you supply a list of indices (counting
      from 1 at the beginning or backwards from -1 at the end) to select the
      words you want. In the second form you specify the range of words you want
      returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">words <i>text</i></dt>
  <dd class="It-tag">Returns the number of words in <i>text</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Miscellaneous_Functions"><a class="selflink" href="#Miscellaneous_Functions">Miscellaneous
  Functions</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">foreach <i>var,list,text</i></dt>
  <dd class="It-tag">The first two arguments, <i>var</i> and <i>list</i>, are
      expanded before anything else is done; note that the last argument, text,
      is not expanded at the same time. Then for each word of the expanded value
      of list, the variable named by the expanded value of var is set to that
      word, and text is expanded. Presumably text contains references to that
      variable, so its expansion will be different each time.
    <div style="height: 1.00em;">&#x00A0;</div>
    This simple example sets the variable <i>files</i> to the list of all files
      in the directories in the list <i>dirs</i>:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    dirs := a b c d
    files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here text is &quot;$(wildcard $(dir)/*)&quot;. The first repetition finds
      the value &quot;a&quot; for dir, so it produces the same result as
      &quot;$(wildcard a/*)&quot;; the second repetition produces the result of
      &quot;$(wildcard b/*)&quot;; and the third, that of &quot;$(wildcard
      c/*)&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    This example has the same result (except for setting &quot;dirs&quot;) as
      the following example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    files := $(wildcard a/* b/* c/* d/*)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    When text is complicated, you can improve readability by giving it a name,
      with an additional variable:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    find_files = $(wildcard $(dir)/*)
    dirs := a b c d
    files := $(foreach dir,$(dirs),$(find_files))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here we use the variable find_files this way. We use plain &quot;=&quot; to
      define a recursively-expanding variable, so that its value contains an
      actual function call to be reexpanded under the control of foreach; a
      simply-expanded variable would not do, since wildcard would be called only
      once at the time of defining find_files.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note: Don't confuse this with the &quot;$(foreach)&quot; special
    variable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">info <i>text</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">warning <i>text</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">error <i>text</i></dt>
  <dd class="It-tag">Output text returning the nothing. The first goes to
      STDOUT, the second to STDERR, the third additionally aborts
    processing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">prebuild <i>targets</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">make <i>targets</i></dt>
  <dd class="It-tag">Returns its argument verbatim, but first builds all the
      files listed. This is useful when a given file is needed when evaluating a
      make expression. This typically happens when you have a build where the
      set of files involved is computed by some shell commands. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    file_list :
        # shell commands to compute a list of files to put into the program
    my_program : $(&amp;cat $(prebuild file_list))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you need the list in more than one rule, it would be more efficient to
      use an expand at most once variable:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    file_list ;= $(&amp;cat $(prebuild file_list))
    my_program1 : a.o $(file_list)
    my_program2 : b.o $(file_list)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If instead you specified just &quot;$(&amp;cat&#x00A0;file_list)&quot;, then
      makepp would not force file_list to be up-to-date before it executes the
      shell command. Using &quot;$(prebuild&#x00A0;)&quot; is the best way to
      solve this problem. You might be tempted to try other things, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    my_program : file_list $(&amp;cat file_list)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    but this won't work because &quot;$(&amp;cat&#x00A0;file_list)&quot; is
      evaluated before makepp attempts to build &quot;file_list&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">only_phony_targets <i>names</i></dt>
  <dd class="It-tag">Returns only those names in the list that are phony targets
      of some rule (either explicit or pattern rules). You may specify wildcards
      (including makepp's special wildcard, &quot;**&quot;) in the filenames.
      (See the &quot;$(wildcard&#x00A0;)&quot; function for more details. This
      can be used for grouping targets, for example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony tests): $(only_phony_targets */**/tests)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">origin <i>variable</i></dt>
  <dd class="It-tag">Given the name of a variable, tells you where its value
      comes from.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">perl <i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makeperl <i>perlcode</i></dt>
  <dd class="It-tag">Evaluates perlcode in a block and returns the result. The
      first variant is plain Perl code, while the second variant first passes
      the perlcode through Make-style variable expansion.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note, that, as with all functions, the function delimiter used may not
      appear within the perlcode outside of single or double quoted strings. But
      you can double it as in the last example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    VAR = 1
    VAR1 = ${perl ($VAR + 1) * 3}
    VAR2 = $(perl do { $VAR *= 3; return $VAR + 1 } if $VAR)
    VAR3 = $(makeperl $(VAR1) * 3 + $$VAR) # one Make var and one Perl var
    VAR = $((perl if( ... ) { ... }))
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">phony <i>words</i></dt>
  <dd class="It-tag">Indicates that the list of words are actually phony
      targets, and returns the list of targets. It's intended to be used like
      this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony all): my_program
    $(phony clean):
        &amp;rm -f *.o my_program
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also declare one or more targets as phony with a line like this
      anywhere in your makefile:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    .PHONY: all clean
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">print <i>text</i></dt>
  <dd class="It-tag">Outputs the text and returns it. This is mostly useful for
      debugging, when you don't understand why variable substitution has the
      result that it does. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    XYZ := $(print $(patsubst %.c, %o, $(SOURCE_FILES)))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will print out the result of the &quot;patsubst&quot; call.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    XYZ := $(patsubst %.c, %o, $(print $(SOURCE_FILES)))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will print out the last argument to the &quot;patsubst&quot; call.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">shell <i>shell-command</i></dt>
  <dd class="It-tag">Returns the output from the given shell command, with
      newlines replaced by spaces.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note, that, as with all functions, the function delimiter used may not
      appear within the shell-command outside of single or double quoted
      strings. But you can double it as in the second example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    date = $(shell date)        # better: $(perl scalar localtime)
    VAR = ${{shell f() { echo hello; }; f}}
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">xargs <i>command,arguments[,suffix[,length]]</i></dt>
  <dd class="It-tag">Returns a newline-separated list of commands that each
      begin with the specified command, and end with as many elements of the
      list as possible without going over <i>length</i> (default 1000)
      characters.
    <div style="height: 1.00em;">&#x00A0;</div>
    The purpose of this is to avoid spilling over the command length limit on
      your system. For example, if there are a lot of generated files, then you
      would probably want your clean target (which you should not have, because
      &quot;makeppclean&quot; is more efficient) to look something like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony clean):
        $(xargs $(RM), $(only_targets **/*))
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This also has the side-effect that no command whatsoever is generated if the
      list happens to be empty. But in this case it would be better to use the
      builtin &amp;rm, because the arguments to the builtin commands are only
      limited by Perl's memory:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony clean):
        &amp;rm -f $(only_targets **/*)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If a third argument is specified, then it is used to postfix each command.
      This is useful for specifying redirectors, e.g. (though here again
      &amp;echo would help):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    manifest:
        &amp;rm -f $@
        &amp;touch $@
        $(xargs echo, $(only_nontargets **/*), &gt;&gt; $@)
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
Some of this documentation is based on the GNU make documentation.
<div class="Pp"></div>
Please note that if a function gets called during makefile initialization, e.g.
  the expansion of export variables, error or warning messages will report line
  number 0.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Gary Holt (holt-makepp@gholt.net)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
