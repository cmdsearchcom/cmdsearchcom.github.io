<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:23:45 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKEPP_FUNCTIONS(1) Makepp MAKEPP_FUNCTIONS(1)</p>

<p style="margin-top: 1em">NAME <br>
makepp_functions -- Functions in makepp</p>

<p style="margin-top: 1em">DESCRIPTION <br>
A: absolute_filename, <br>
absolute_filename_nolink, <br>
abspath, <br>
addprefix, <br>
addsuffix, <br>
and, B: basename, C: call, D: dir, <br>
dir_noslash, E: error, F: filesubst, <br>
filter, <br>
filter_out, <br>
filter_out_dirs, <br>
findfile, <br>
find_first_upwards, <br>
find_program, <br>
findstring, <br>
find_upwards, <br>
first_available, <br>
firstword, <br>
foreach, I: if, <br>
iftrue, <br>
infer_linker, <br>
infer_objects, <br>
info, J: join, M: make, <br>
makemap, <br>
makeperl, <br>
map, <br>
&quot;mktemp&quot;, N: notdir, O: only_generated, <br>
only_nontargets, <br>
only_phony_targets, <br>
only_stale, <br>
only_targets, <br>
or, <br>
origin, P: patsubst, <br>
perl, <br>
phony, <br>
prebuild, <br>
print, R: realpath, <br>
relative_filename, <br>
relative_to, S: shell, <br>
sort, <br>
strip, <br>
subst, <br>
suffix, T: temporary, W: warning, <br>
wildcard, <br>
word, <br>
wordlist, <br>
words, X: xargs</p>

<p style="margin-top: 1em">Any expression of the format
&quot;$(name)&quot;, where &quot;name&quot; is not the name
of a variable, or &quot;$(name arg1 arg2 arg3)&quot; is
interpreted as a function call. The name may contain
letters, <br>
underscores, or hyphens; to avoid confusion, you may use
hyphens or underscores interchangeably, since internally
hyphens are converted to underscores. Evaluating such an
<br>
expression simply invokes a Perl subroutine. If
&quot;name&quot; is preceded by &quot;&amp;&quot; it runs
the builtin command or script of that name within the makepp
process, and returns the standard <br>
output. This requires perl to be built for PerlIO. If the
name does not name a function it is transformed to an
invocation of call.</p>

<p style="margin-top: 1em">As with variables you have a
choice of &quot;$(name ...)&quot; or &quot;${name
...}&quot;. If you want to embed the same parenthesis, it
must be paired, the other doesn&rsquo;t matter: &quot;$(name
...(){...&quot; <br>
or &quot;${name ...{}(...}&quot;. (However for map and perl
the first closing paren ends the expression.) Doubling
allows the arguments to span several lines. The newlines are
then <br>
treated as spaces, except maybe in &quot;define&quot;. There
is also the syntax &quot;$[name ...]&quot; or $[[name ...]],
which gets evaluated while reading the makefile, before
grokking rules and <br>
other constructs.</p>

<p style="margin-top: 1em">Makepp has a number of builtin
functions which may be useful. It supports almost all of GNU
make&rsquo;s textual functions (see GNU make&rsquo;s
documentation for details), and some of its <br>
own. You can define Perl subroutines to do whatever you
like. See the &quot;sub&quot; statement and the section on
extending makepp for more details.</p>

<p style="margin-top: 1em">Conditional Functions <br>
and condition1[,condition2[,condition3...]] <br>
The and function provides a &quot;short-circuiting&quot; AND
operation. Each argument is expanded, in order. If an
argument expands to an empty string the processing stops and
the <br>
result of the expansion is the empty string. If all
arguments expand to a non-empty string then the result of
the expansion is the expansion of the last argument.</p>

<p style="margin-top: 1em">if string,
result-if-string-not-blank[, result-if-string-blank] <br>
iftrue string, result-if-string-true[,
result-if-string-false] <br>
An alternative to the &quot;ifeq&quot;, etc., statements. If
the string is not blank (i.e., the condition is true), the
second argument (the &quot;then&quot; clause) is returned
(after variable <br>
expansion); if the string is blank, the third argument (the
&quot;else&quot; clause) is returned.</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">CFLAGS := $(if $(filter gcc
egcc, $(CC)), -g -Wall, -g)</p>

<p style="margin-top: 1em">defines CFLAGS to be &quot;-g
-Wall&quot; if the variable CC is either &quot;gcc&quot; or
&quot;egcc&quot;, and &quot;-g&quot; otherwise. (This is
what the default build rules do.)</p>

<p style="margin-top: 1em">&quot;iftrue&quot; is similar to
&quot;if&quot;, except that the string 0 is treated as
blank.</p>

<p style="margin-top: 1em">or
condition1[,condition2[,condition3...]] <br>
The or function provides a &quot;short-circuiting&quot; OR
operation. Each argument is expanded, in order. If an
argument expands to a non-empty string the processing stops
and the <br>
result of the expansion is that string. If, after all
arguments are expanded, all of them are false (empty), then
the result of the expansion is the empty string.</p>

<p style="margin-top: 1em">File and Filename Functions <br>
absolute_filename files <br>
abspath files <br>
Converts relative filenames into absolutes without . or ...
For example, &quot;$(absolute_filename xyz.c)&quot; might
return &quot;/usr/src/our_project/subdir/xyz.c&quot;.</p>

<p style="margin-top: 1em">absolute_filename_nolink files
<br>
realpath files <br>
Like absolute_filename, but ensures that symbolic links are
resolved.</p>

<p style="margin-top: 1em">basename filenames <br>
The basename is the entire file name (with the directory),
minus the text after and including the last period. E.g.,
&quot;$(basename myfile/version-1.0-module.c)&quot; is <br>
&quot;myfile/version-1.0-module&quot;</p>

<p style="margin-top: 1em">dir filenames <br>
Extracts the directory part of each file in the filename
list, including the trailing slash. Returns &quot;./&quot;
if there is no directory in the filename.</p>

<p style="margin-top: 1em">dir_noslash filename <br>
Same as &quot;$(dir )&quot; except that it doesn&rsquo;t
return the trailing slash.</p>

<p style="margin-top: 1em">filesubst pattern, substitute,
words <br>
Perform a pattern substitution on file names. This differs
from patsubst in that it will perform correctly when
alternate names for directories are given (as long as <br>
they precede the percent sign). For example,</p>

<p style="margin-top: 1em">$(filesubst ./src/%.c, %.o,
$(wildcard src/*.c))</p>

<p style="margin-top: 1em">will work with filesubst but not
with patsubst.</p>

<p style="margin-top: 1em">filter_out_dirs filenames <br>
Returns all filenames that do not refer to directories.</p>

<p style="margin-top: 1em">findfile filename, path <br>
Finds a file in the specified path, or in the environment
variable PATH if nothing is specified. This can be useful
for finding binaries or include files. For example,</p>

<p style="margin-top: 1em">TCL_INCLUDE := -I$(dir_noslash
$(findfile tcl.h, /usr/local/stow/tcl-8.4.5-nothread/include
/usr/include/tcl8.4 /usr/include/tcl
/net/na1/tcl8.4a3/include /net/na1/tcl8.4a3/include))</p>

<p style="margin-top: 1em">This locates the file tcl.h by
searching all of the above directories. The absolute path to
the file is returned. Then &quot;$(dir_noslash )&quot;
extracts that directory, and it is <br>
put into the include path.</p>

<p style="margin-top: 1em">find_program name <br>
Return the first program in the list that can be found in
the PATH. This is useful when there are multiple equivalent
programs that may be used, and you just want to pick <br>
one of them. For example, here is the default definition of
several common variables that makepp supplies if you do not
put one in your makefile:</p>

<p style="margin-top: 1em">CC = $(find_program gcc egcc
pgcc c89 cc) # and more, depending on machine <br>
F77 = $(find_program f77 g77 fort77) <br>
CXX = $(find_program g++ c++ pg++ cxx CC aCC)</p>

<p style="margin-top: 1em">If none of the programs is
found, &quot;$(find_program )&quot; returns the string
not-found, and logs what was not found. This usually
won&rsquo;t result in a functional makefile, but it <br>
will tend to make for better error messages. For example, if
you do something like this:</p>

<p style="margin-top: 1em">%.o : %.c <br>
$(CC) $(inputs) -o $(outputs)</p>

<p style="margin-top: 1em">and makepp can&rsquo;t find a C
compiler in the list above, it will substitute not-found.
Otherwise the shell would attempt to execute the source file
and the resulting error <br>
message might be really strange.</p>

<p style="margin-top: 1em">find_upwards filename <br>
Searches for a file of the given name in the directory .,
.., ../.., ../../.., etc., until the file is found or the
root directory is reached or the directory is located on a
<br>
different file system. (This last requirement is to prevent
problems with automounters or hung network filesystems.) If
you have a RootMakeppfile, that is also a barrier <br>
which prevents searching higher.</p>

<p style="margin-top: 1em">For example, if you have a
project with many levels of subdirectories, you could
include this common fragment in all of the makefiles (e.g.,
by using the &quot;include&quot; <br>
statement):</p>

<p style="margin-top: 1em">TOP_LEVEL_INCLUDE_DIR :=
$(find_upwards includes) <br>
# Searches for a directory that contains the <br>
# includes subdirectory.</p>

<p style="margin-top: 1em">%.o : %.c <br>
$(CC) $(CFLAGS) -I$(TOP_LEVEL_INCLUDE_DIR) -c $(input) -o
$(output)</p>

<p style="margin-top: 1em">Another problem that
&quot;find_upwards&quot; can help solve is locating the
top-level directory of a build. Often it is useful to define
a variable like this:</p>

<p style="margin-top: 1em">TOP := ../../..</p>

<p style="margin-top: 1em">if you have some important
information located only in the top-level directory. But
this is hard to maintain, because the number of
&quot;..&quot; is different for different levels of <br>
the directory tree. Instead, you can use
&quot;find_upwards&quot; to locate a file which is known to
be present only in the top level directory. Suppose, for
example, that the file <br>
&quot;LICENSE&quot; is located only in the top level
directory. Then you could do this:</p>

<p style="margin-top: 1em">TOP := $(dir_noslash
$(find_upwards LICENSE))</p>

<p style="margin-top: 1em">&quot;$(find_upwards
LICENSE)&quot; returns the full path of the license file;
&quot;$(dir_noslash ...)&quot; strips off the filename,
returning only the directory.</p>

<p style="margin-top: 1em">(Note that the
&quot;include&quot; statement automatically searches upwards
for files, so there is no need to do something like
this:</p>

<p style="margin-top: 1em">include $(find_upwards
top_level_rules.mk)</p>

<p style="margin-top: 1em">Instead, you can just do</p>

<p style="margin-top: 1em">include top_level_rules.mk</p>

<p style="margin-top: 1em">and it will work just as
well.)</p>

<p style="margin-top: 1em">If the file is not found,
&quot;find_upwards&quot; will abort the build with an error
message.</p>

<p style="margin-top: 1em">If you specify more than one
file, find_upwards will search for the first one, then the
second one, and so on. In other words,</p>

<p style="margin-top: 1em">$(find_upwards file1 file2)</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">$(find_upwards file1)
$(find_upwards file2)</p>

<p style="margin-top: 1em">If you want to look for any one
of the files, then use &quot;find_first_upwards&quot;
instead.</p>

<p style="margin-top: 1em">find_first_upwards file1 file2
... <br>
This function behaves like &quot;find_upwards&quot; except
that it returns the first file of any files in the list that
it finds. Specifically, it checks the current directory for
any <br>
of the files in the list, and returns the first file which
exists or can be built. If none of the files exist or can be
built in that directory, it checks .., then ../.., <br>
etc., until it reaches either the root directory or a
directory which is located on a different file system.</p>

<p style="margin-top: 1em">first_available file1 file2 ...
<br>
Return the first file in a list that exists or can be built.
This can be useful for adapting your makefiles to work on
several different machines or networks, where <br>
important files may be located in different places. For
example, here&rsquo;s a line from one of my makefiles:</p>

<p style="margin-top: 1em">TCL_LIB = $(first_available
/usr/local/stow/tcl-8.4.5-nothread/lib/libtcl8.4.so
/usr/lib/libtcl8.4.so /usr/lib/libtcl.so
/net/na1/tcl8.4a3/lib/libtcl8.4.a
/net/na1/tcl8.4a3/lib/libtcl8.4.sl)</p>

<p style="margin-top: 1em">This line will check for the Tcl
library in all of the above places, stopping at the first
one that it finds. The link command then includes $(TCL_LIB)
so we get the <br>
appropriate Tcl library.</p>

<p style="margin-top: 1em">infer_linker file1 file2 ...
<br>
Given a list of object files first build them if they have
not been yet. Then find whether they depend on a Fortran,
C++ or a C source and return the corresponding compiler <br>
(which better knows how to link than &quot;ld&quot;).</p>

<p style="margin-top: 1em">infer_objects file1 file2 ...,
pattern <br>
$(infer_objects object1.o object2.o, *.o)</p>

<p style="margin-top: 1em">If you use standard conventions
regarding header file names, makepp is capable of guessing
which &quot;.o&quot; or &quot;.lo&quot; files need to be
linked with your program. I use this to pick <br>
out files from a library directory which contains modules
used in many different programs. Instead of making a library
&quot;.a&quot; file and having the linker pick out the
relevant <br>
modules, makepp can pick out the relevant modules for you.
This way, only the relevant modules get compiled.</p>

<p style="margin-top: 1em">Makepp&rsquo;s algorithm for
inferring object dependencies depends on the convention that
the implementation of all classes or functions defined in a
header file &quot;xyz.h&quot; are <br>
compiled into an object file called &quot;xyz.o&quot; (or
&quot;xyz.lo&quot;). So makepp&rsquo;s algorithm for
inferring object dependencies starts with one or a few
objects that we know have to be <br>
linked into the program. It looks at which files were
included with &quot;#include&quot; in those sources, and
tries to find corresponding object files for each of the
include files.</p>

<p style="margin-top: 1em">&quot;$(infer_objects )&quot;
needs to be mentioned in the dependency list of a program,
like this:</p>

<p style="margin-top: 1em">myprog: $(infer_objects main.o
another_object.o, **/*.o /other/library/dirs/**/*.o) <br>
$(CXX) $(inputs) -o $(output) $(LIBS)</p>

<p style="margin-top: 1em">The &quot;$(infer_objects)&quot;
function takes two arguments (separated by a comma, as
shown). The first is one or a few object files that are
known to be required (wildcards are <br>
permissible here). The second is a list of possible objects
(normally you would use a wildcard here) that could be
linked in if necessary. The return value from this <br>
function is a list that contains first all of the objects in
the first argument, and then after those, all additional
objects that were contained in the second argument that <br>
are required by the objects in the first argument.</p>

<p style="margin-top: 1em">For example, suppose
&quot;main.o&quot; comes from &quot;main.cpp&quot;, which
includes &quot;my_class.h&quot;.
&quot;$(infer_objects)&quot; looks for files with the name
&quot;my_class.o&quot;. If exactly one such file is <br>
found, it is added to the list. (If two object files
&quot;my_class.o&quot; are found in different directories, a
warning message is printed.) &quot;infer_objects&quot; also
examines <br>
&quot;my_class.cpp&quot; to see what it includes, and what
additional object files are implied.</p>

<p style="margin-top: 1em">mktemp <br>
mktemp prefix <br>
mktemp prefixXXX <br>
mktemp / <br>
Returns an unpredictable temporary filename, which does not
currently exist. No name pointing to the same file is
returned twice, even with different relative paths, within
<br>
one makepp run (except possibly with traditional recursive
make, or if Perl code running within a rule action calls
&quot;f_mktemp&quot;). At the end of the makepp run all
files <br>
returned by this function are deleted, if they exist (again
except for those returned by this function in Perl code
running within a rule).</p>

<p style="margin-top: 1em">Any number of upper case
&quot;X&quot;s at the end of the argument are replaced by
that many random letters and digits. The more there are, the
less likely this is to collide with <br>
other processes, so if you give a prefix like
&quot;/tmp/abc.&quot;, you should have enough
&quot;X&quot;s. If there is more than one X, the first
character comes from the process id. If there <br>
are none, it is as though there were ten, which is
supposedly enough (8.4e17 possibilities or 3.7e15 on
Windows). If there is no argument, the prefix defaults to
&quot;tmp.&quot; in <br>
the current directory.</p>

<p style="margin-top: 1em">Note that you don&rsquo;t want
to give such a name as rule targets and dependencies. The
result would be correct, but it would be recreated every
time you run makepp.</p>

<p style="margin-top: 1em">Also, as it is always different,
you should use this in a rule action only if you use
&quot;:build_check ignore_action&quot;:</p>

<p style="margin-top: 1em">TMPFILE ;= $(mktemp) # 1 call;
&quot;=&quot; would mean 3 calls: 3 files <br>
A-count B-count: :build_check ignore_action <br>
produce-As-and-Bs &gt;$(TMPFILE) <br>
&amp;grep -c /A/ $(TMPFILE) -o A-count <br>
&amp;grep -c /B/ $(TMPFILE) -o B-count</p>

<p style="margin-top: 1em">Or you should export it and let
the Shell evaluate it:</p>

<p style="margin-top: 1em">export TMPFILE ;= $(mktemp) <br>
A-count B-count: <br>
produce-As-and-Bs &gt;$$TMPFILE # makepp doesn&rsquo;t see
the var value <br>
fgrep -c A $$TMPFILE &gt;A-count <br>
fgrep -c B $$TMPFILE &gt;B-count</p>

<p style="margin-top: 1em">The last form repeats the
previous return value, so you can use it in a pattern
rule:</p>

<p style="margin-top: 1em">%.x: %.y <br>
&amp;grep foo $(input) -o $(mktemp) <br>
&amp;sed bar $(mktemp /) -o $(output) # Operate on the
output of &amp;grep</p>

<p style="margin-top: 1em">notdir filenames <br>
Returns the non-directory portion of the filename(s), i.e.,
everything after the last slash if there is one, or the
whole filename otherwise.</p>

<p style="margin-top: 1em">only_generated filenames <br>
Returns only those filenames in the list that were generated
by makepp and not since modified, according to the build
info file.</p>

<p style="margin-top: 1em">This function is useful in clean
target rules (though of course &quot;makeppclean&quot; is
the preferred variant):</p>

<p style="margin-top: 1em">$(phony clean): <br>
&amp;rm -f $(only_generated **/*)</p>

<p style="margin-top: 1em">only_nontargets filenames <br>
Returns only those filenames in the list that are not
targets of any rule (either explicit or pattern rules). You
may specify a wildcard (see the &quot;$(wildcard )&quot;
function for <br>
more details on makepp&rsquo;s wildcards). This can be used
for generating a distribution target, for example:</p>

<p style="margin-top: 1em">.PHONY: distribution</p>

<p style="margin-top: 1em">distribution: <br>
&amp;mkdir our_product-$(VERSION) <br>
&amp;cp $(filter-out %~, $(only_nontargets *))
our_product-$(VERSION) <br>
tar cf - our_product-$(VERSION) | gzip -9c &gt;
our_product-$(VERSION).tar.gz</p>

<p style="margin-top: 1em">In this case, the
&quot;$(only_nontargets *)&quot; returns every file in the
current directory that is not a target of some rule. The
&quot;$(filter_out %~, ...)&quot; removes editor
backups.</p>

<p style="margin-top: 1em">Similar to
&quot;only_targets&quot; (see above),
&quot;only_nontargets&quot; only knows about targets that
have been defined already. This is only a problem if you use
it to define variables <br>
with the &quot;:=&quot; assignment; if you use it in the
dependency list or in the body of a rule, all other rules
will already have been seen.</p>

<p style="margin-top: 1em">only_stale filenames <br>
Returns only those filenames in the list that were generated
by makepp and not since modified, according to the build
info file, but are no longer targets of any rule.</p>

<p style="margin-top: 1em">This function is useful for
ensuring that there are no dependencies on such files,
without forcing a clean build of all of the targets:</p>

<p style="margin-top: 1em">$(phony flush): <br>
&amp;rm -f $(only_stale **/*)</p>

<p style="margin-top: 1em">Actually, it&rsquo;s probably
better instead to write a script that calls makepp to
generate the list of stale files, and then have that script
remove all of the listed files that <br>
aren&rsquo;t currently under source control, just in case a
generated file becomes a source file. Makepp doesn&rsquo;t
have such a function built in because makepp is (and
probably ought <br>
to remain) agnostic about source control.</p>

<p style="margin-top: 1em">only_targets filenames <br>
Returns only those filenames in the list that are actually
targets of some rule (either explicit or pattern rules). You
may specify wildcards (including makepp&rsquo;s special <br>
wildcard, &quot;**&quot;) in the filenames. (See the
&quot;$(wildcard )&quot; function for more details. This can
be used for a clean target, for example:</p>

<p style="margin-top: 1em">.PHONY: clean</p>

<p style="margin-top: 1em">clean: <br>
&amp;rm -f $(only_targets *)</p>

<p style="margin-top: 1em">Now if you type &quot;makepp
clean&quot;, it will delete everything it knows how to
build. But don&rsquo;t create a clean target, use
&quot;makeppclean&quot; instead!</p>

<p style="margin-top: 1em">Another place where it may be
useful is to avoid including stale .o files in your build.
For example, if you build a library like this:</p>

<p style="margin-top: 1em">mylib.a: *.o <br>
&amp;rm -f $(output) <br>
$(AR) cr $(output) $(inputs)</p>

<p style="margin-top: 1em">and then you delete some source
files but forget to delete the corresponding .o files, the
.o files will still be around. This means they will still be
incorporated into the <br>
library despite the fact that they are not useful any more.
If you modify your rule like this:</p>

<p style="margin-top: 1em">mylib.a: $(only_targets *.o)
<br>
&amp;rm -f $(output) <br>
$(AR) cr $(output) $(inputs)</p>

<p style="margin-top: 1em">then this problem won&rsquo;t
occur.</p>

<p style="margin-top: 1em">Note that this refers only to
files that are known to be targets at the time you invoke
&quot;only-targets&quot;. If &quot;only_targets&quot;
appears in the dependencies or actions of a rule, <br>
then all possible targets will be known because dependencies
and actions are not evaluated until the rule is executed.
However, if you evaluate try to evaluate it earlier in <br>
the makefile with a &quot;:=&quot; variable like this:</p>

<p style="margin-top: 1em">ALL_TARGETS := $(only_targets
*)</p>

<p style="margin-top: 1em">target1: dependency1 <br>
actions</p>

<p style="margin-top: 1em">target2: dependency2 <br>
actions</p>

<p style="margin-top: 1em">then &quot;only_targets&quot;
will not know about the subsequent rules.</p>

<p style="margin-top: 1em">Similarly,
&quot;only_targets&quot; doesn&rsquo;t know about targets
produced in makefiles that are loaded with recursive make.
(But you shouldn&rsquo;t be using recursive make anyway; use
use <br>
the &quot;load_makefile&quot; statement, or implicit
makefile loading instead.)</p>

<p style="margin-top: 1em">relative_filename file1 file2
file3[, slash] <br>
Returns the name of those files relative to the current
directory (the one the makefile is in). This can also be
used to clean unnecessary &quot;./&quot; and other junk from
the path:</p>

<p style="margin-top: 1em">DIR := . <br>
SUBDIR := .. <br>
FNAME := $(DIR)/../otherdir/$(SUBDIR)/files <br>
X := $(relative_filename $(FNAME))</p>

<p style="margin-top: 1em">If slash is true (usually 1) the
returned filenames are guaranteed to contain a slash by
prepending &quot;./&quot; if necessary, so that you can use
it as an executable name without <br>
worrying about the command search path overriding the
directory location.</p>

<p style="margin-top: 1em">If the path goes by the root
directory, the parent of either your home directory or the
&quot;$(ROOT)&quot; of your build system, or on Windows a
drive&rsquo;s root (depending on the <br>
environment, this also happens for /cygdrive/c or /c), an
absolute path will be returned instead.</p>

<p style="margin-top: 1em">relative_to file1 file2 file3[,
directory] <br>
Returns the name of those files relative to the specified
directory. This is typically useful when for whatever reason
you have to execute a command from a different <br>
directory (default current directory):</p>

<p style="margin-top: 1em">source_backup.tar: <br>
cd .. &amp;&amp; tar cf $(relative_to $(output), ..)
$(relative_to ., ..)</p>

<p style="margin-top: 1em">suffix names... <br>
Extracts the suffix of each file name in names. If the file
name contains a period, the suffix is everything starting
with the last period. Otherwise, the suffix is the empty
<br>
string. This frequently means that the result will be empty
when names is not, and if names contains multiple file
names, the result may contain fewer file names.</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">$(suffix src/foo.c src-1.0/bar.c
hacks)</p>

<p style="margin-top: 1em">produces the result &quot;.c
.c&quot;.</p>

<p style="margin-top: 1em">temporary words <br>
Let makepp know that the specified targets may be removed by
the rule that generates them. Similar to &quot;phony&quot;,
except that makepp expects that a real file of that name
will <br>
may be affected by the rule. A rule is not executed if only
its temporary targets are out-of-date.</p>

<p style="margin-top: 1em">wildcard pattern <br>
Returns the sorted names of all files matching the given
pattern which exist, or those files which do not yet exist
but can be built based on the rules that makepp knows <br>
about at the point when it evaluates the expression. In this
last point it differs from rule input wildcards, which apply
even to files created by rules found later.</p>

<p style="margin-top: 1em">Makepp supports all the usual
shell wildcards (&quot;*&quot;, &quot;?&quot;, and
&quot;[]&quot;). It also has a wildcard &quot;**&quot; which
matches any number of intervening directories. (This idea
was stolen <br>
from zsh.) For example, &quot;**/*.c&quot; matches all the
.c files in the entire source tree.
&quot;objects/**/*.o&quot; matches all the .o files
contained anywhere in the subdirectory <br>
objects or any of its subdirectories or any of their
subdirectories. The &quot;**&quot; wildcard will not follow
soft links to directories at any level, nor will it attempt
to enter <br>
directories which exist but cannot be read. Also files and
directories which exist but cannot be read will not be
returned by &quot;$(wildcard )&quot;.</p>

<p style="margin-top: 1em">String Functions <br>
addprefix prefix, words <br>
Prepends the prefix string to each of the words. This is
mostly for GNU make compatibility; using rc-style expansion,
this can be done in a more readable fashion like this:</p>

<p style="margin-top: 1em">MODULES := a b c d <br>
X_OLD_STYLE := $(addprefix $(OBJDIR)/, $(addsuffix .o,
$(MODULES))) <br>
X_NEW_STYLE := $(OBJDIR)/$(MODULES).o # Isn&rsquo;t that
easier to read?</p>

<p style="margin-top: 1em">addsuffix suffix, words <br>
Appends the suffix string to each of the words. This is
mostly for GNU make compatibility; using rc-style expansion,
this can be done in a more readable fashion like this:</p>

<p style="margin-top: 1em">X_OLD_STYLE := $(addsuffix .o,
$(MODULES)) <br>
X_NEW_STYLE := $(MODULES).o</p>

<p style="margin-top: 1em">call variable[, words]... <br>
The function &quot;call&quot; is unique in that it can be
used to regard variable as a parameterized function. You can
assign a complex expression to variable and use
&quot;call&quot; to expand <br>
its contents to different values parametrized by words later
on. In other make systems, a variable that is used mainly
for the purpose to be expanded via &quot;call&quot;, is
called a <br>
macro.</p>

<p style="margin-top: 1em">During expansion of the macro,
the temporary variables $1, $2, &quot;...&quot; refer to the
arguments given to &quot;call&quot; during its invocation.
The variable $0 will be expanded to the <br>
name of the macro (i.e. variable) that &quot;call&quot; is
currently expanding.</p>

<p style="margin-top: 1em">There is no limit, how many
arguments a macro may be &quot;call&quot;ed with or how many
parameters a macro may expect. If you pass more arguments to
&quot;call&quot; as the macro need, all <br>
exceeding arguments will be discarded. If you pass less
arguments than a macro expect, all exceeding parameters
collapse into the empty string.</p>

<p style="margin-top: 1em">First a simple example:</p>

<p style="margin-top: 1em">rest = $(wordlist 2, $(words
$(1)),$(1)) <br>
list = A B C D E <br>
butfirst := $(call rest,$(list))</p>

<p style="margin-top: 1em">Here, the variable
&quot;$(butfirst)&quot; will contain the list &quot;B C D
E&quot;.</p>

<p style="margin-top: 1em">And now for a more complex
example to show what is possible:</p>

<p style="margin-top: 1em">rest = $(wordlist 2,$(words
$(1)),${1}) <br>
mymap = $(if $2,$(call $1,$(firstword $2)) $(call
$0,$1,$(call rest,$2))) <br>
downcase = ${makeperl lc(&quot;$1&quot;)}</p>

<p style="margin-top: 1em">UCWORDS = ALL THESE WORDS ARE
UPCASE <br>
DCWORDS := $(call mymap,downcase,$(UCWORDS))</p>

<p style="margin-top: 1em">Now &quot;$(DCWORDS)&quot;
contains &quot;all these words are upcase&quot;. By the way:
it makes no difference, whether we access the arguments via
$1, &quot;${1}&quot; or &quot;$(1)&quot; within a macro.</p>

<p style="margin-top: 1em">You can directly use the
variable as though it were a function, if there is no
function of that name. This is internally converted to
&quot;call&quot;, so these are equivalent:</p>

<p style="margin-top: 1em">discussion = The $0 turned into
$1 $2. <br>
direct = $(discussion an,argument) <br>
called = $(call discussion,an,argument)</p>

<p style="margin-top: 1em">It might seem debatable whether
&quot;$[call]&quot; should also expand the macro&rsquo;s
&quot;$[]&quot; expressions, or whether a function should
always do the same thing, no matter how it is called. <br>
The latter was chosen, because with normal make syntax it
would be impossible to get &quot;$[1], $[2]...&quot; into a
variable (they&rsquo;d get replaced by nothing, before the
assignment <br>
even takes place.) Hence, if you have a macro for defining a
rule, you want expressions like &quot;$(output)&quot; to be
seen when the rule gets parsed, so you must protect them
from <br>
&quot;call&quot;:</p>

<p style="margin-top: 1em">define myrule <br>
$2: $1 <br>
mycommand $$(input) -o $$(output) <br>
endef <br>
$[myrule myinput,myoutput]</p>

<p style="margin-top: 1em">filter patterns, words <br>
Returns all words in the list that match the patterns.
Patterns may simply be other words, or filename wildcards
(i.e., &quot;*&quot;, &quot;?&quot;, and &quot;[a-z]&quot;
are recognized), or they may <br>
have a &quot;%&quot; character, which means to match any
string at that point (same as &quot;*&quot;).</p>

<p style="margin-top: 1em">filter_out patterns, words <br>
Returns all words in the list that do not match the
patterns. Patterns may simply be other words, or filename
wildcards (i.e., &quot;*&quot;, &quot;?&quot;, and
&quot;[a-z]&quot; are recognized), or they <br>
may have a &quot;%&quot; character, which means to match any
string at that point (same as &quot;*&quot;).</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">libproduction.a: $(filter_out
test_*, $(wildcard *.o))</p>

<p style="margin-top: 1em">will put all .o files which
exist or can be built, except those beginning with test_,
into libproduction.a.</p>

<p style="margin-top: 1em">findstring find, in <br>
Return find, if it is a substring of in.</p>

<p style="margin-top: 1em">firstword words <br>
Return the first word.</p>

<p style="margin-top: 1em">map words, perlcode <br>
makemap words, perlcode <br>
Similarly to Perl&rsquo;s map, applies perlcode to each word
in turn and returns the results. The first variant is plain
Perl code, while the second variant first passes the <br>
perlcode through Make-style variable expansion. The words
are expanded in both cases.</p>

<p style="margin-top: 1em">The words are in $_ and are
returned unless you undef $_. This is intended for
modifications not easily handled by &quot;patsubst&quot;.
Only the first comma is a separator, any <br>
others are considered part of the perlcode.</p>

<p style="margin-top: 1em"># Switch words. Double parens,
to allow parens in perlcode, or use ${}: <br>
X = $((map $(VALUES), s/(.+)-(.+)/$2-$1/)) <br>
# You can use make expressions, but then you must use $$ for
Perl $: <br>
Y = $(makemap $(VALUES), tr/$(OLDCHARS)/$(NEWCHARS)/ or $$_
= &rsquo;failed&rsquo;) <br>
# You can eliminate candidates: <br>
Y = $(map $(VALUES), undef $_ if /no_good/)</p>

<p style="margin-top: 1em">join words1, words2 <br>
Do a pairwise join of the first words and the second
words.</p>

<p style="margin-top: 1em">patsubst pattern, substitute,
words <br>
Performs a substitution on each word in the word list. A
&quot;%&quot; character matches any string. This is best
illustrated by an example:</p>

<p style="margin-top: 1em">OBJS = $(patsubst %.c,
object_dir/%.o, $(C_SOURCES))</p>

<p style="margin-top: 1em">takes every file in C_SOURCES
and returns the name of an object file in object_dir.
Sometimes it is more concise to use a substitution
reference, e.g., the above could have <br>
been written as</p>

<p style="margin-top: 1em">OBJS =
$(C_SOURCES:%.c=object_dir/%.o)</p>

<p style="margin-top: 1em">sort word1 word2 word3 ... <br>
Sorts the words in lexical order and removes duplicates.</p>

<p style="margin-top: 1em">strip string <br>
Removes leading and trailing whitespace from string and
replaces each internal sequence of one or more whitespace
characters with a single space. Thus, &quot;$(strip a b c
)&quot; <br>
results in &quot;a b c&quot;.</p>

<p style="margin-top: 1em">subst from,to,text <br>
Performs a textual replacement on the text text: each
occurrence of from is replaced by to. The result is
substituted for the function call. For example,</p>

<p style="margin-top: 1em">$(subst ee,EE,feet on the
street)</p>

<p style="margin-top: 1em">substitutes the string
&quot;fEEt on the strEEt&quot;.</p>

<p style="margin-top: 1em">word n,text <br>
Returns the nth word of text. The legitimate values of n
start from 1 at the beginning or backwards from -1 at the
end. If n is bigger than the number of words in text, the
<br>
value is empty.</p>

<p style="margin-top: 1em">wordlist indexlist, words <br>
wordlist firstindex, lastindex, words <br>
In the first form you supply a list of indices (counting
from 1 at the beginning or backwards from -1 at the end) to
select the words you want. In the second form you <br>
specify the range of words you want returned.</p>

<p style="margin-top: 1em">words text <br>
Returns the number of words in text.</p>

<p style="margin-top: 1em">Miscellaneous Functions <br>
foreach var,list,text <br>
The first two arguments, var and list, are expanded before
anything else is done; note that the last argument, text, is
not expanded at the same time. Then for each word of <br>
the expanded value of list, the variable named by the
expanded value of var is set to that word, and text is
expanded. Presumably text contains references to that
variable, <br>
so its expansion will be different each time.</p>

<p style="margin-top: 1em">This simple example sets the
variable files to the list of all files in the directories
in the list dirs:</p>

<p style="margin-top: 1em">dirs := a b c d <br>
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))</p>

<p style="margin-top: 1em">Here text is &quot;$(wildcard
$(dir)/*)&quot;. The first repetition finds the value
&quot;a&quot; for dir, so it produces the same result as
&quot;$(wildcard a/*)&quot;; the second repetition produces
the <br>
result of &quot;$(wildcard b/*)&quot;; and the third, that
of &quot;$(wildcard c/*)&quot;.</p>

<p style="margin-top: 1em">This example has the same result
(except for setting &quot;dirs&quot;) as the following
example:</p>

<p style="margin-top: 1em">files := $(wildcard a/* b/* c/*
d/*)</p>

<p style="margin-top: 1em">When text is complicated, you
can improve readability by giving it a name, with an
additional variable:</p>

<p style="margin-top: 1em">find_files = $(wildcard
$(dir)/*) <br>
dirs := a b c d <br>
files := $(foreach dir,$(dirs),$(find_files))</p>

<p style="margin-top: 1em">Here we use the variable
find_files this way. We use plain &quot;=&quot; to define a
recursively-expanding variable, so that its value contains
an actual function call to be reexpanded <br>
under the control of foreach; a simply-expanded variable
would not do, since wildcard would be called only once at
the time of defining find_files.</p>

<p style="margin-top: 1em">Note: Don&rsquo;t confuse this
with the &quot;$(foreach)&quot; special variable.</p>

<p style="margin-top: 1em">info text <br>
warning text <br>
error text <br>
Output text returning the nothing. The first goes to STDOUT,
the second to STDERR, the third additionally aborts
processing.</p>

<p style="margin-top: 1em">prebuild targets <br>
make targets <br>
Returns its argument verbatim, but first builds all the
files listed. This is useful when a given file is needed
when evaluating a make expression. This typically happens
<br>
when you have a build where the set of files involved is
computed by some shell commands. For example,</p>

<p style="margin-top: 1em">file_list : <br>
# shell commands to compute a list of files to put into the
program</p>

<p style="margin-top: 1em">my_program : $(&amp;cat
$(prebuild file_list))</p>

<p style="margin-top: 1em">If you need the list in more
than one rule, it would be more efficient to use an expand
at most once variable:</p>

<p style="margin-top: 1em">file_list ;= $(&amp;cat
$(prebuild file_list))</p>

<p style="margin-top: 1em">my_program1 : a.o
$(file_list)</p>

<p style="margin-top: 1em">my_program2 : b.o
$(file_list)</p>

<p style="margin-top: 1em">If instead you specified just
&quot;$(&amp;cat file_list)&quot;, then makepp would not
force file_list to be up-to-date before it executes the
shell command. Using &quot;$(prebuild )&quot; is the <br>
best way to solve this problem. You might be tempted to try
other things, like this:</p>

<p style="margin-top: 1em">my_program : file_list
$(&amp;cat file_list)</p>

<p style="margin-top: 1em">but this won&rsquo;t work
because &quot;$(&amp;cat file_list)&quot; is evaluated
before makepp attempts to build &quot;file_list&quot;.</p>

<p style="margin-top: 1em">only_phony_targets names <br>
Returns only those names in the list that are phony targets
of some rule (either explicit or pattern rules). You may
specify wildcards (including makepp&rsquo;s special
wildcard, <br>
&quot;**&quot;) in the filenames. (See the &quot;$(wildcard
)&quot; function for more details. This can be used for
grouping targets, for example:</p>

<p style="margin-top: 1em">$(phony tests):
$(only_phony_targets */**/tests)</p>

<p style="margin-top: 1em">origin variable <br>
Given the name of a variable, tells you where its value
comes from.</p>

<p style="margin-top: 1em">perl perlcode <br>
makeperl perlcode <br>
Evaluates perlcode in a block and returns the result. The
first variant is plain Perl code, while the second variant
first passes the perlcode through Make-style variable <br>
expansion.</p>

<p style="margin-top: 1em">Note, that, as with all
functions, the function delimiter used may not appear within
the perlcode outside of single or double quoted strings. But
you can double it as in the <br>
last example:</p>

<p style="margin-top: 1em">VAR = 1 <br>
VAR1 = ${perl ($VAR + 1) * 3} <br>
VAR2 = $(perl do { $VAR *= 3; return $VAR + 1 } if $VAR)
<br>
VAR3 = $(makeperl $(VAR1) * 3 + $$VAR) # one Make var and
one Perl var <br>
VAR = $((perl if( ... ) { ... }))</p>

<p style="margin-top: 1em">phony words <br>
Indicates that the list of words are actually phony targets,
and returns the list of targets. It&rsquo;s intended to be
used like this:</p>

<p style="margin-top: 1em">$(phony all): my_program</p>

<p style="margin-top: 1em">$(phony clean): <br>
&amp;rm -f *.o my_program</p>

<p style="margin-top: 1em">You can also declare one or more
targets as phony with a line like this anywhere in your
makefile:</p>

<p style="margin-top: 1em">.PHONY: all clean</p>

<p style="margin-top: 1em">print text <br>
Outputs the text and returns it. This is mostly useful for
debugging, when you don&rsquo;t understand why variable
substitution has the result that it does. For example,</p>

<p style="margin-top: 1em">XYZ := $(print $(patsubst %.c,
%o, $(SOURCE_FILES)))</p>

<p style="margin-top: 1em">will print out the result of the
&quot;patsubst&quot; call.</p>

<p style="margin-top: 1em">XYZ := $(patsubst %.c, %o,
$(print $(SOURCE_FILES)))</p>

<p style="margin-top: 1em">will print out the last argument
to the &quot;patsubst&quot; call.</p>

<p style="margin-top: 1em">shell shell-command <br>
Returns the output from the given shell command, with
newlines replaced by spaces.</p>

<p style="margin-top: 1em">Note, that, as with all
functions, the function delimiter used may not appear within
the shell-command outside of single or double quoted
strings. But you can double it as <br>
in the second example:</p>

<p style="margin-top: 1em">date = $(shell date) # better:
$(perl scalar localtime) <br>
VAR = ${{shell f() { echo hello; }; f}}</p>

<p style="margin-top: 1em">xargs
command,arguments[,suffix[,length]] <br>
Returns a newline-separated list of commands that each begin
with the specified command, and end with as many elements of
the list as possible without going over length <br>
(default 1000) characters.</p>

<p style="margin-top: 1em">The purpose of this is to avoid
spilling over the command length limit on your system. For
example, if there are a lot of generated files, then you
would probably want your <br>
clean target (which you should not have, because
&quot;makeppclean&quot; is more efficient) to look something
like this:</p>

<p style="margin-top: 1em">$(phony clean): <br>
$(xargs $(RM), $(only_targets **/*))</p>

<p style="margin-top: 1em">This also has the side-effect
that no command whatsoever is generated if the list happens
to be empty. But in this case it would be better to use the
builtin &amp;rm, because <br>
the arguments to the builtin commands are only limited by
Perl&rsquo;s memory:</p>

<p style="margin-top: 1em">$(phony clean): <br>
&amp;rm -f $(only_targets **/*)</p>

<p style="margin-top: 1em">If a third argument is
specified, then it is used to postfix each command. This is
useful for specifying redirectors, e.g. (though here again
&amp;echo would help):</p>

<p style="margin-top: 1em">manifest: <br>
&amp;rm -f $@ <br>
&amp;touch $@ <br>
$(xargs echo, $(only_nontargets **/*), &gt;&gt; $@)</p>

<p style="margin-top: 1em">Some of this documentation is
based on the GNU make documentation.</p>

<p style="margin-top: 1em">Please note that if a function
gets called during makefile initialization, e.g. the
expansion of export variables, error or warning messages
will report line number 0.</p>

<p style="margin-top: 1em">AUTHOR <br>
Gary Holt (holt-makepp@gholt.net)</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
MAKEPP_FUNCTIONS(1)</p>
<hr>
</body>
</html>
