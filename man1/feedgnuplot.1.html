<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>FEEDGNUPLOT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">FEEDGNUPLOT(1)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">FEEDGNUPLOT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
feedgnuplot - General purpose pipe-oriented plotting tool
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Simple plotting of piped data:
<div class="Pp"></div>
<pre>
 $ seq 5 | awk '{print 2*$1, $1*$1}'
 2 1
 4 4
 6 9
 8 16
 10 25
 $ seq 5 | awk '{print 2*$1, $1*$1}' |
   feedgnuplot --lines --points --legend 0 &quot;data 0&quot; --title &quot;Test plot&quot; --y2 1
               --terminal 'dumb 80,40' --exit
                                  Test plot
  10 ++------+--------+-------+-------+-------+--------+-------+------*A 25
     +       +        +       +       +       +        +       +    **#+
     |       :        :       :       :       :        : data 0+**A*** |
     |       :        :       :       :       :        :       :** #   |
   9 ++.......................................................**.##....|
     |       :        :       :       :       :        :    ** :#      |
     |       :        :       :       :       :        :  **   #       |
     |       :        :       :       :       :        :**   ##:      ++ 20
   8 ++................................................A....#..........|
     |       :        :       :       :       :      **:   #   :       |
     |       :        :       :       :       :    **  : ##    :       |
     |       :        :       :       :       :  **    :#      :       |
     |       :        :       :       :       :**      B       :       |
   7 ++......................................**......##................|
     |       :        :       :       :    ** :    ##  :       :      ++ 15
     |       :        :       :       :  **   :   #    :       :       |
     |       :        :       :       :**     : ##     :       :       |
   6 ++..............................*A.......##.......................|
     |       :        :       :    ** :     ##:        :       :       |
     |       :        :       :  **   :    #  :        :       :       |
     |       :        :       :**     :  ##   :        :       :      ++ 10
   5 ++......................**........##..............................|
     |       :        :    ** :      #B       :        :       :       |
     |       :        :  **   :    ## :       :        :       :       |
     |       :        :**     :  ##   :       :        :       :       |
   4 ++...............A.......###......................................|
     |       :      **:     ##:       :       :        :       :       |
     |       :    **  :   ##  :       :       :        :       :      ++ 5
     |       :  **    : ##    :       :       :        :       :       |
     |       :**    ##B#      :       :       :        :       :       |
   3 ++.....**..####...................................................|
     |    **####      :       :       :       :        :       :       |
     |  **## :        :       :       :       :        :       :       |
     B**     +        +       +       +       +        +       +       +
   2 A+------+--------+-------+-------+-------+--------+-------+------++ 0
     1      1.5       2      2.5      3      3.5       4      4.5      5
</pre>
<div class="Pp"></div>
Simple real-time plotting example: plot how much data is received on the wlan0
  network interface in bytes/second (uses bash, awk and Linux):
<div class="Pp"></div>
<pre>
 $ while true; do sleep 1; cat /proc/net/dev; done |
   gawk '/wlan0/ {if(b) {print $2-b; fflush()} b=$2}' |
   feedgnuplot --lines --stream --xlen 10 --ylabel 'Bytes/sec' --xlabel seconds
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This is a flexible, command-line-oriented frontend to Gnuplot. It creates plots
  from data coming in on STDIN or given in a filename passed on the commandline.
  Various data representations are supported, as is hardcopy output and
  streaming display of live data. A simple example:
<div class="Pp"></div>
<pre>
 $ seq 5 | awk '{print 2*$1, $1*$1}' | feedgnuplot
</pre>
<div class="Pp"></div>
You should see a plot with two curves. The &quot;awk&quot; command generates
  some data to plot and the &quot;feedgnuplot&quot; reads it in from STDIN and
  generates the plot. The &quot;awk&quot; invocation is just an example; more
  interesting things would be plotted in normal usage. No commandline-options
  are required for the most basic plotting. Input parsing is flexible; every
  line need not have the same number of points. New curves will be created as
  needed.
<div class="Pp"></div>
The most commonly used functionality of gnuplot is supported directly by the
  script. Anything not directly supported can still be done with options such as
  &quot;--set&quot;, &quot;--extracmds&quot; &quot;--style&quot;, etc. Arbitrary
  gnuplot commands can be passed in with &quot;--extracmds&quot;. For example,
  to turn off the grid, you can pass in &quot;--extracmds 'unset grid'&quot;.
  Commands &quot;--set&quot; and &quot;--unset&quot; exists to provide nicer
  syntax, so this is equivalent to passing &quot;--unset grid&quot;. As many of
  these options as needed can be passed in. To add arbitrary curve styles, use
  &quot;--style curveID extrastyle&quot;. Pass these more than once to affect
  more than one curve.
<div class="Pp"></div>
To apply an extra style to <i>all</i> the curves that lack an explicit
  &quot;--style&quot;, pass in &quot;--styleall extrastyle&quot;. In the most
  common case, the extra style is &quot;with something&quot;. To support this
  more simply, you can pass in &quot;--with something&quot; instead of
  &quot;--styleall 'with something'&quot;. &quot;--styleall&quot; and
  &quot;--with&quot; are mutually exclusive. Furthermore any curve-specific
  &quot;--style&quot; overrides the global &quot;--styleall&quot; or
  &quot;--with&quot; setting.
<h2 class="Ss" title="Ss" id="Data_formats"><a class="selflink" href="#Data_formats">Data
  formats</a></h2>
By default, each value present in the incoming data represents a distinct data
  point, as demonstrated in the original example above (we had 10 numbers in the
  input and 10 points in the plot). If requested, the script supports more
  sophisticated interpretation of input data
<div class="Pp"></div>
<i>Domain selection</i>
<div class="Pp"></div>
If &quot;--domain&quot; is passed in, the first value on each line of input is
  interpreted as the <i>X</i>-value for the rest of the data on that line.
  Without &quot;--domain&quot; the <i>X</i>-value is the line number, and the
  first value on a line is a plain data point like the others. Default is
  &quot;--nodomain&quot;. Thus the original example above produces 2 curves,
  with <b>1,2,3,4,5</b> as the <i>X</i>-values. If we run the same command with
  &quot;--domain&quot;:
<div class="Pp"></div>
<pre>
 $ seq 5 | awk '{print 2*$1, $1*$1}' | feedgnuplot --domain
</pre>
<div class="Pp"></div>
we get only 1 curve, with <b>2,4,6,8,10</b> as the <i>X</i>-values. As many
  points as desired can appear on a single line, but all points on a line are
  associated with the <i>X</i>-value at the start of that line.
<div class="Pp"></div>
<i>Curve indexing</i>
<div class="Pp"></div>
By default, each column represents a separate curve. This is fine unless sparse
  data is to be plotted. With the &quot;--dataid&quot; option, each point is
  represented by 2 values: a string identifying the curve, and the value itself.
  If we add &quot;--dataid&quot; to the original example:
<div class="Pp"></div>
<pre>
 $ seq 5 | awk '{print 2*$1, $1*$1}' | feedgnuplot --dataid --autolegend
</pre>
<div class="Pp"></div>
we get 5 different curves with one point in each. The first column, as produced
  by &quot;awk&quot;, is <b>2,4,6,8,10</b>. These are interpreted as the IDs of
  the curves to be plotted. The &quot;--autolegend&quot; option adds a legend
  using the given IDs to label the curves. The IDs need not be numbers; generic
  strings are accepted. As many points as desired can appear on a single line.
  &quot;--domain&quot; can be used in conjunction with &quot;--dataid&quot;.
<div class="Pp"></div>
<i>Multi-value style support</i>
<div class="Pp"></div>
Depending on how gnuplot is plotting the data, more than one value may be needed
  to represent the range of a single point. Basic 2D plots have 2 numbers
  representing each point: 1 domain and 1 range. But if plotting with
  &quot;--circles&quot;, for instance, then there's an extra range value: the
  radius. A similar situation exists with &quot;--colormap&quot; where each
  point contains the position <i>and</i> the color. There are other gnuplot
  styles that require more data (such as error bars), but none of these are
  directly supported by the script. They can still be used, however, by
  specifying the specific style with &quot;--style&quot;, and specifying how
  many values are needed for each point with &quot;--rangesizeall&quot; or
  &quot;--rangesize&quot; or &quot;--extraValuesPerPoint&quot;. Those options
  that specify the range size are required <i>only</i> for styles not explicitly
  supported by feedgnuplot; supported styles do the right thing automatically.
<div class="Pp"></div>
More examples: if making a 2d plot of y error bars where gnuplot expects a
  (x,y,ydelta) tuple for each point, you want &quot;--rangesizeall 2&quot;
  because you have one domain value (x) and 2 range values (y,ydelta). Gnuplot
  can also plot lopsided y errorbars by giving a tuple (x,y,ylow,yhigh). This is
  similar as before, but you want &quot;--rangesizeall 3&quot; instead.
<div class="Pp"></div>
<i>3D data</i>
<div class="Pp"></div>
To plot 3D data, pass in &quot;--3d&quot;. &quot;--domain&quot; MUST be given
  when plotting 3D data to avoid domain ambiguity. If 3D data is being plotted,
  there are by definition 2 domain values instead of one ( <i>Z</i> as a
  function of <i>X</i> and <i>Y</i> instead of <i>Y</i> as a function of
  <i>X</i>). Thus the first 2 values on each line are interpreted as the domain
  instead of just 1. The rest of the processing happens the same way as before.
<div class="Pp"></div>
<i>Time/date data</i>
<div class="Pp"></div>
If the input data domain is a time/date, this can be interpreted with
  &quot;--timefmt&quot;. This option takes a single argument: the format to use
  to parse the data. The format is documented in 'set timefmt' in gnuplot,
  although the common flags that &quot;strftime&quot; understands are generally
  supported. The backslash sequences in the format are <i>not</i> supported, so
  if you want a tab, put in a tab instead of \t. Whitespace in the format
  <i>is</i> supported. When this flag is given, some other options act a little
  bit differently:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--xlen&quot; is an <i>integer</i> in seconds</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--xmin&quot; and &quot;--xmax&quot; <i>must</i> use
      the format passed in to &quot;--timefmt&quot;</dd>
</dl>
<div class="Pp"></div>
Using this option changes both the way the input is parsed <i>and</i> the way
  the x-axis tics are labelled. Gnuplot tries to be intelligent in this
  labelling, but it doesn't always do what the user wants. The labelling can be
  controlled with the gnuplot &quot;set format&quot; command, which takes the
  same type of format string as &quot;--timefmt&quot;. Example:
<div class="Pp"></div>
<pre>
 $ sar 1 -1 |
   awk '$1 ~ /..:..:../ &amp;&amp; $8 ~/^[0-9\.]*$/ {print $1,$8; fflush()}' |
   feedgnuplot --stream --domain
                --lines --timefmt '%H:%M:%S'
                --set 'format x &quot;%H:%M:%S&quot;'
</pre>
<div class="Pp"></div>
This plots the 'idle' CPU consumption against time.
<div class="Pp"></div>
Note that while gnuplot supports the time/date on any axis, <i>feedgnuplot</i>
  currently supports it <i>only</i> as the x-axis domain. This may change in the
  future.
<h2 class="Ss" title="Ss" id="Real-time_streaming_data"><a class="selflink" href="#Real-time_streaming_data">Real-time
  streaming data</a></h2>
To plot real-time data, pass in the &quot;--stream [refreshperiod]&quot; option.
  Data will then be plotted as it is received. The plot will be updated every
  &quot;refreshperiod&quot; seconds. If the period isn't specified, a 1Hz
  refresh rate is used. To refresh at specific intervals indicated by the data,
  set the refreshperiod to 0 or to 'trigger'. The plot will then <i>only</i> be
  refreshed when a data line 'replot' is received. This 'replot' command works
  in both triggered and timed modes, but in triggered mode, it's the only way to
  replot. Look in &quot;Special data commands&quot; for more information.
<div class="Pp"></div>
To plot only the most recent data (instead of <i>all</i> the data), &quot;--xlen
  windowsize&quot; can be given. This will create an constantly-updating,
  scrolling view of the recent past. &quot;windowsize&quot; should be replaced
  by the desired length of the domain window to plot, in domain units (passed-in
  values if &quot;--domain&quot; or line numbers otherwise). If the domain is a
  time/date via &quot;--timefmt&quot;, then &quot;windowsize&quot; is and
  <i>integer</i> in seconds.
<div class="Pp"></div>
<i>Special data commands</i>
<div class="Pp"></div>
If we are reading streaming data, the input stream can contain special commands
  in addition to the raw data. Feedgnuplot looks for these at the start of every
  input line. If a command is detected, the rest of the line is discarded. These
  commands are
<dl class="Bl-tag">
  <dt class="It-tag">&quot;replot&quot;</dt>
  <dd class="It-tag">This command refreshes the plot right now, instead of
      waiting for the next refresh time indicated by the timer. This command
      works in addition to the timed refresh, as indicated by &quot;--stream
      [refreshperiod]&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;clear&quot;</dt>
  <dd class="It-tag">This command clears out the current data in the plot. The
      plotting process continues, however, to any data following the
      &quot;clear&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;exit&quot;</dt>
  <dd class="It-tag">This command causes feedgnuplot to exit.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Hardcopy_output"><a class="selflink" href="#Hardcopy_output">Hardcopy
  output</a></h2>
The script is able to produce hardcopy output with &quot;--hardcopy
  outputfile&quot;. The output type can be inferred from the filename, if
  <b>.ps</b>, <b>.eps</b>, <b>.pdf</b>, <b>.svg</b> or <b>.png</b> is requested.
  If any other file type is requested, &quot;--terminal&quot; <i>must</i> be
  passed in to tell gnuplot how to make the plot. If &quot;--terminal&quot; is
  passed in, then the &quot;--hardcopy&quot; argument only provides the output
  filename.
<h2 class="Ss" title="Ss" id="Self-plotting_data_files"><a class="selflink" href="#Self-plotting_data_files">Self-plotting
  data files</a></h2>
This script can be used to enable self-plotting data files. There are 2 ways of
  doing this: with a shebang (#!) or with inline perl data.
<div class="Pp"></div>
<i>Self-plotting data with a #!</i>
<div class="Pp"></div>
A self-plotting, executable data file &quot;data&quot; is formatted as
<div class="Pp"></div>
<pre>
 $ cat data
 #!/usr/bin/feedgnuplot --lines --points
 2 1
 4 4
 6 9
 8 16
 10 25
 12 36
 14 49
 16 64
 18 81
 20 100
 22 121
 24 144
 26 169
 28 196
 30 225
</pre>
<div class="Pp"></div>
This is the shebang (#!) line followed by the data, formatted as before. The
  data file can be plotted simply with
<div class="Pp"></div>
<pre>
 $ ./data
</pre>
<div class="Pp"></div>
The caveats here are that on Linux the whole #! line is limited to 127
  characters and that the full path to feedgnuplot must be given. The 127
  character limit is a serious limitation, but this can likely be resolved with
  a kernel patch. I have only tried on Linux 2.6.
<div class="Pp"></div>
<i>Self-plotting data with perl inline data</i>
<div class="Pp"></div>
Perl supports storing data and code in the same file. This can also be used to
  create self-plotting files:
<div class="Pp"></div>
<pre>
 $ cat plotdata.pl
 #!/usr/bin/perl
 use strict;
 use warnings;
 open PLOT, &quot;| feedgnuplot --lines --points&quot; or die &quot;Couldn't open plotting pipe&quot;;
 while( &lt;DATA&gt; )
 {
   my @xy = split;
   print PLOT &quot;@xy\n&quot;;
 }
 __DATA__
 2 1
 4 4
 6 9
 8 16
 10 25
 12 36
 14 49
 16 64
 18 81
 20 100
 22 121
 24 144
 26 169
 28 196
 30 225
</pre>
<div class="Pp"></div>
This is especially useful if the logged data is not in a format directly
  supported by feedgnuplot. Raw data can be stored after the __DATA__ directive,
  with a small perl script to manipulate the data into a useable format and send
  it to the plotter.
<h1 class="Sh" title="Sh" id="ARGUMENTS"><a class="selflink" href="#ARGUMENTS">ARGUMENTS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">--&quot;[no]domain&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    If enabled, the first element of each line is the domain variable. If not,
      the point index is used</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">--&quot;[no]dataid&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    If enabled, each data point is preceded by the ID of the data set that point
      corresponds to. This ID is interpreted as a string, NOT as just a number.
      If not enabled, the order of the point is used.
    <div style="height: 1.00em;">&#x00A0;</div>
    As an example, if line 3 of the input is &quot;0 9 1 20&quot; then</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--nodomain --nodataid&quot; would parse the 4 numbers
      as points in 4 different curves at x=3</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--domain --nodataid&quot; would parse the 4 numbers
      as points in 3 different curves at x=0. Here, 0 is the x-variable and
      9,1,20 are the data values</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--nodomain --dataid&quot; would parse the 4 numbers
      as points in 2 different curves at x=3. Here 0 and 1 are the data IDs and
      9 and 20 are the data values</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--domain --dataid&quot; would parse the 4 numbers as
      a single point at x=0. Here 9 is the data ID and 1 is the data value. 20
      is an extra value, so it is ignored. If another value followed 20, we'd
      get another point in curve ID 20</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--[no]3d&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Do [not] plot in 3D. This only makes sense with &quot;--domain&quot;. Each
      domain here is an (x,y) tuple</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">--&quot;timefmt [format]&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Interpret the X data as a time/date, parsed with the given format</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--colormap&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Show a colormapped xy plot. Requires extra data for the color. zmin/zmax can
      be used to set the extents of the colors. Automatically sets the
      &quot;--rangesize&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--stream [period]&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Plot the data as it comes in, in realtime. If period is given, replot every
      period seconds. If no period is given, replot at 1Hz. If the period is
      given as 0 or 'trigger', replot <i>only</i> when the incoming data
      dictates this. See the &quot;Real-time streaming data&quot; section of the
      man page.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--[no]lines&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Do [not] draw lines to connect consecutive points</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--[no]points&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Do [not] draw points</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--circles&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Plot with circles. This requires a radius be specified for each point.
      Automatically sets the &quot;--rangesize&quot;. &quot;Not&quot; supported
      for 3d plots.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--title xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Set the title of the plot</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--legend curveID legend&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Set the label for a curve plot. Use this option multiple times for multiple
      curves. With &quot;--dataid&quot;, curveID is the ID. Otherwise, it's the
      index of the curve, starting at 0</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--autolegend&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Use the curve IDs for the legend. Titles given with &quot;--legend&quot;
      override these</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--xlen xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    When using &quot;--stream&quot;, sets the size of the x-window to plot. Omit
      this or set it to 0 to plot ALL the data. Does not make sense with 3d
      plots. Implies &quot;--monotonic&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--xmin/xmax/ymin/ymax/y2min/y2max/zmin/zmax xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Set the range for the given axis. These x-axis bounds are ignored in a
      streaming plot. The y2-axis bound do not apply in 3d plots. The z-axis
      bounds apply <i>only</i> to 3d plots or colormaps.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--xlabel/ylabel/y2label/zlabel xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Label the given axis. The y2-axis label does not apply to 3d plots while the
      z-axis label applies <i>only</i> to 3d plots.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--y2 xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Plot the data specified by this curve ID on the y2 axis. Without
      &quot;--dataid&quot;, the ID is just an ordered 0-based index. Does not
      apply to 3d plots. Can be passed multiple times, or passed a
      comma-separated list. By default the y2-axis curves look the same as the
      y-axis ones. I.e. the viewer of the resulting plot has to be told which is
      which via an axes label, legend, etc. Prior to version 1.25 of feedgnuplot
      the curves plotted on the y2 axis were drawn with a thicker line. This is
      no longer the case, but that behavior can be brought back by passing
      something like
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 --y2 curveid --style curveid 'linewidth 3'
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--histogram curveID&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Set up a this specific curve to plot a histogram. The bin width is given
      with the &quot;--binwidth&quot; option (assumed 1.0 if omitted). If a
      drawing style is not specified for this curve (&quot;--curvestyle&quot;)
      or all curves (&quot;--with&quot;, &quot;--curvestyleall&quot;) then the
      default histogram style is set: filled boxes with borders. This is what
      the user generally wants. This works with &quot;--domain&quot; and/or
      &quot;--stream&quot;, but in those cases the x-value is used <i>only</i>
      to cull old data because of &quot;--xlen&quot; or &quot;--monotonic&quot;.
      I.e. the x-values are <i>not</i> drawn in any way. Can be passed multiple
      times, or passed a comma- separated list</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--binwidth width&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    The width of bins when making histograms. This setting applies to ALL
      histograms in the plot. Defaults to 1.0 if not given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--histstyle style&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Normally, histograms are generated with the 'smooth frequency' gnuplot
      style. &quot;--histstyle&quot; can be used to select different
      &quot;smooth&quot; settings (see the gnuplot &quot;help smooth&quot; page
      for more info). Allowed values are 'frequency' (the default), 'fnormal'
      (available in very recent gnuplots), 'unique', 'cumulative' and 'cnormal'.
      'fnormal' is a normalized histogram. 'unique' indicates whether a bin has
      at least one item in it: instead of counting the items, it'll always
      report 0 or 1. 'cumulative' is the integral of the 'frequency' histogram.
      'cnormal' is like 'cumulative', but rescaled to end up at 1.0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--style curveID style&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Additional styles per curve. With &quot;--dataid&quot;, curveID is the ID.
      Otherwise, it's the index of the curve, starting at 0. curveID can be a
      comma-separated list of IDs to which the given style should apply. Use
      this option multiple times for multiple curves. &quot;--styleall&quot;
      does <i>not</i> apply to curves that have a &quot;--style&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--curvestyle curveID&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Synonym for &quot;--style&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--styleall xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Additional styles for all curves that have no &quot;--style&quot;. This is
      overridden by any applicable &quot;--style&quot;. Exclusive with
      &quot;--with&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--curvestyleall xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Synonym for &quot;--styleall&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--with xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Same as &quot;--styleall&quot;, but prefixed with &quot;with&quot;. Thus
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 --with boxes
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 --styleall 'with boxes'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Exclusive with &quot;--styleall&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--extracmds xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Additional commands to pass on to gnuplot verbatim. These could contain
      extra global styles for instance. Can be passed multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--set xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Additional 'set' commands to pass on to gnuplot verbatim. &quot;--set 'a b
      c'&quot; will result in gnuplot seeing a &quot;set a b c&quot; command.
      Can be passed multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--unset xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Additional 'unset' commands to pass on to gnuplot verbatim. &quot;--unset 'a
      b c'&quot; will result in gnuplot seeing a &quot;unset a b c&quot;
      command. Can be passed multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--equation xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Gnuplot can plot both data and symbolic equations. &quot;feedgnuplot&quot;
      generally plots data, but with this option can plot symbolic equations
      <i>also</i>. This is generally intended to augment data plots, since for
      equation-only plots you don't need &quot;feedgnuplot&quot;.
      &quot;--equation&quot; can be passed multiple times for multiple
      equations. The given strings are passed to gnuplot directly without any
      thing added or removed, so styling and such should be applied in the
      string. A basic example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 seq 100 | awk '{print $1/10, $1/100}' |
   feedgnuplot --with 'lines lw 3' --domain --ymax 1
               --equation 'sin(x)/x' --equation 'cos(x)/x with lines lw 4'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here I plot the incoming data (points along a line) with the given style (a
      line with thickness 3), <i>and</i> I plot two damped sinusoids on the same
      plot. The sinusoids are not affected by &quot;feedgnuplot&quot; styling,
      so their styles are set separately, as in this example. More complicated
      example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 seq 360 | perl -nE '$th=$_/360 * 3.14*2; $c=cos($th); $s=sin($th); say &quot;$c $s&quot;' |
   feedgnuplot --domain --square
               --set parametric --set &quot;trange [0:2*3.14]&quot; --equation &quot;sin(t),cos(t)&quot;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here the data I generate is points along the unit circle. I plot these as
      points, and I <i>also</i> plot a true circle as a parametric
    equation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--square&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Plot data with aspect ratio 1. For 3D plots, this controls the aspect ratio
      for all 3 axes</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--square_xy&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    For 3D plots, set square aspect ratio for ONLY the x,y axes</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--hardcopy xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    If not streaming, output to a file specified here. Format inferred from
      filename, unless specified by &quot;--terminal&quot;. If
      &quot;--terminal&quot; is given, &quot;--hardcopy&quot; sets <i>only</i>
      the output filename.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--terminal xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    String passed to 'set terminal'. No attempts are made to validate this.
      &quot;--hardcopy&quot; sets this to some sensible defaults if
      &quot;--hardcopy&quot; is set to a filename ending in &quot;.png&quot;,
      &quot;.pdf&quot;, &quot;.ps&quot;, &quot;.eps&quot; or &quot;.svg&quot;.
      If any other file type is desired, use both &quot;--hardcopy&quot; and
      &quot;--terminal&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--maxcurves xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    The maximum allowed number of curves. This is 100 by default, but can be
      reset with this option. This exists purely to prevent perl from allocating
      all of the system's memory when reading bogus data</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--monotonic&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    If &quot;--domain&quot; is given, checks to make sure that the x- coordinate
      in the input data is monotonically increasing. If a given x-variable is in
      the past, all data currently cached for this curve is purged. Without
      &quot;--monotonic&quot;, all data is kept. Does not make sense with 3d
      plots. No &quot;--monotonic&quot; by default. The data is replotted before
      being purged</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--rangesize curveID xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    The options &quot;--rangesizeall&quot;, &quot;--rangesize&quot; and
      &quot;--extraValuesPerPoint&quot; set the number of values are needed to
      represent each point being plotted (see &quot;Multi-value style
      support&quot; above). These options are <i>only</i> needed if unknown
      styles are used, with &quot;--styleall&quot; or &quot;--with&quot; for
      instance.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;--rangesize&quot; is used to set how many values are needed to
      represent the range of a point for a particular curve. This overrides any
      defaults that may exist for this curve only.
    <div style="height: 1.00em;">&#x00A0;</div>
    With &quot;--dataid&quot;, curveID is the ID. Otherwise, it's the index of
      the curve, starting at 0. curveID can be a comma-separated list of IDs to
      which the given rangesize should apply.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--rangesizeall xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Like &quot;--rangesize&quot;, but applies to <i>all</i> the curves.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;--extraValuesPerPoint xxx&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Like &quot;--rangesizeall&quot;, but instead of overriding the default, adds
      to it. For example, if plotting non-lopsided y errorbars gnuplot wants
      (x,y,ydelta) tuples. These can be specified both with &quot;--rangesizeall
      2&quot; (because there are 2 range values) or &quot;--extraValuesPerPoint
      1&quot; (because there's 1 more value than usual).
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is <i>only</i> needed if unknown styles are used, with
      &quot;--styleall&quot; or &quot;--with&quot; for instance.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--dump&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Instead of printing to gnuplot, print to STDOUT. Very useful for debugging.
      It is possible to send the output produced this way to gnuplot
    directly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--exit&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    This controls the details of what happens when the input data is exhausted,
      or when some part of the &quot;feedgnuplot&quot; pipeline is killed. This
      option does different things depending on whether &quot;--stream&quot; is
      active, so read this closely.
    <div style="height: 1.00em;">&#x00A0;</div>
    With interactive gnuplot terminals (qt, x11, wxt), the plot windows live in
      a separate process from the main &quot;gnuplot&quot; process. It is thus
      possible for the main &quot;gnuplot&quot; process to exit, while leaving
      the plot windows up (a caveat is that such decapitated windows aren't
      interactive). To be clear, there are 3 possible states:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">Alive: &quot;feedgnuplot&quot;, &quot;gnuplot&quot; alive,
    plot window process alive, no shell prompt (shell busy with
    &quot;feedgnuplot&quot;)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Half-alive: &quot;feedgnuplot&quot;, &quot;gnuplot&quot;
    dead, plot window process alive (but non-interactive), shell prompt
    available</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Dead: &quot;feedgnuplot&quot;, &quot;gnuplot&quot; dead,
    plot window process dead, shell prompt available</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
The &quot;--exit&quot; option controls the details of this behavior. The
  possibilities are:
<dl class="Bl-tag">
  <dt class="It-tag">No &quot;--stream&quot;, input pipe is exhausted (all data
    read in)</dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">default; no &quot;--exit&quot;</dt>
  <dd class="It-tag">Alive. Need to Ctrl-C to get back into the shell</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;--exit&quot;</dt>
  <dd class="It-tag">Half-alive. Non-interactive prompt up, and the shell
      accepts new commands. Without &quot;--stream&quot; the goal is to show a
      plot, so a Dead state is not useful here.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;--stream&quot;, input pipe is exhausted (all data
    read in) or the &quot;feedgnuplot&quot; process terminated</dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">default; no &quot;--exit&quot;</dt>
  <dd class="It-tag">Alive. Need to Ctrl-C to get back into the shell</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;--exit&quot;</dt>
  <dd class="It-tag">Dead. No plot is shown, and the shell accepts new commands.
      With &quot;--stream&quot; the goal is to show a plot as the data comes in,
      which we have been doing. Now that we're done, we can clean up
    everything.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Note that one usually invokes &quot;feedgnuplot&quot; as a part of a shell
  pipeline:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 $ write_data | feedgnuplot
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
If the user terminates this pipeline with ^C, then <i>all</i> the processes in
  the pipeline receive SIGINT. This normally kills &quot;feedgnuplot&quot; and
  all its &quot;gnuplot&quot; children, and we let this happen unless
  &quot;--stream&quot; and no &quot;--exit&quot;. If &quot;--stream&quot; and no
  &quot;--exit&quot;, then we ignore the first ^C. The data feeder dies, and we
  behave as if the input data was exhausted. A second ^C kills us also.</div>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--geometry&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    If using X11, specifies the size, position of the plot window</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;--version&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Print the version and exit</dd>
</dl>
<h1 class="Sh" title="Sh" id="RECIPES"><a class="selflink" href="#RECIPES">RECIPES</a></h1>
<h2 class="Ss" title="Ss" id="Basic_plotting_of_piped_data"><a class="selflink" href="#Basic_plotting_of_piped_data">Basic
  plotting of piped data</a></h2>
<pre>
 $ seq 5 | awk '{print 2*$1, $1*$1}'
 2 1
 4 4
 6 9
 8 16
 10 25
 $ seq 5 | awk '{print 2*$1, $1*$1}' |
   feedgnuplot --lines --points --legend 0 &quot;data 0&quot; --title &quot;Test plot&quot; --y2 1
</pre>
<h2 class="Ss" title="Ss" id="Realtime_plot_of_network_throughput"><a class="selflink" href="#Realtime_plot_of_network_throughput">Realtime
  plot of network throughput</a></h2>
Looks at wlan0 on Linux.
<div class="Pp"></div>
<pre>
 $ while true; do sleep 1; cat /proc/net/dev; done |
   gawk '/wlan0/ {if(b) {print $2-b; fflush()} b=$2}' |
   feedgnuplot --lines --stream --xlen 10 --ylabel 'Bytes/sec' --xlabel seconds
</pre>
<h2 class="Ss" title="Ss" id="Realtime_plot_of_battery_charge_in_respect_to_time"><a class="selflink" href="#Realtime_plot_of_battery_charge_in_respect_to_time">Realtime
  plot of battery charge in respect to time</a></h2>
Uses the result of the &quot;acpi&quot; command.
<div class="Pp"></div>
<pre>
 $ while true; do acpi; sleep 15; done |
   perl -nE 'BEGIN{ $| = 1; } /([0-9]*)%/; say join(&quot; &quot;, time(), $1);' |
   feedgnuplot --stream --ymin 0 --ymax 100 --lines --domain --xlabel 'Time' --timefmt '%s' --ylabel &quot;Battery charge (%)&quot;
</pre>
<h2 class="Ss" title="Ss" id="Realtime_plot_of_temperatures_in_an_IBM_Thinkpad"><a class="selflink" href="#Realtime_plot_of_temperatures_in_an_IBM_Thinkpad">Realtime
  plot of temperatures in an IBM Thinkpad</a></h2>
Uses &quot;/proc/acpi/ibm/thermal&quot;, which reports temperatures at various
  locations in a Thinkpad.
<div class="Pp"></div>
<pre>
 $ while true; do cat /proc/acpi/ibm/thermal | awk '{$1=&quot;&quot;; print}' ; sleep 1; done |
   feedgnuplot --stream --xlen 100 --lines --autolegend --ymax 100 --ymin 20 --ylabel 'Temperature (deg C)'
</pre>
<h2 class="Ss" title="Ss" id="Plotting_a_histogram_of_file_sizes_in_a_directory,_granular_to_10MB"><a class="selflink" href="#Plotting_a_histogram_of_file_sizes_in_a_directory,_granular_to_10MB">Plotting
  a histogram of file sizes in a directory, granular to 10MB</a></h2>
<pre>
 $ ls -l | awk '{print $5/1e6}' |
   feedgnuplot --histogram 0
     --binwidth 10
     --ymin 0 --xlabel 'File size (MB)' --ylabel Frequency
</pre>
<h2 class="Ss" title="Ss" id="Plotting_points_on_top_of_an_existing_image"><a class="selflink" href="#Plotting_points_on_top_of_an_existing_image">Plotting
  points on top of an existing image</a></h2>
This can be done by using &quot;--equation&quot; to pass arbitrary plot input to
  gnuplot:
<div class="Pp"></div>
<pre>
 $ &lt; features_xy.data
   feedgnuplot --points --domain
     --equation '&quot;image.png&quot; binary filetype=png flipy with rgbimage'
</pre>
<div class="Pp"></div>
Here an existing image is given to gnuplot verbatim, and data to plot on top of
  it is interpreted by feedgnuplot as usual. &quot;flipy&quot; is useful here
  because usually the y axis points up, but when looking at images, this is
  usually reversed: the origin is the top-left pixel.
<h1 class="Sh" title="Sh" id="ACKNOWLEDGEMENT"><a class="selflink" href="#ACKNOWLEDGEMENT">ACKNOWLEDGEMENT</a></h1>
This program is originally based on the driveGnuPlots.pl script from Thanassis
  Tsiodras. It is available from his site at
  &lt;http://users.softlab.ece.ntua.gr/~ttsiod/gnuplotStreaming.html&gt;
<h1 class="Sh" title="Sh" id="REPOSITORY"><a class="selflink" href="#REPOSITORY">REPOSITORY</a></h1>
&lt;https://github.com/dkogan/feedgnuplot&gt;
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Dima Kogan, &quot;&lt;dima@secretsauce.net&gt;&quot;
<h1 class="Sh" title="Sh" id="LICENSE_AND_COPYRIGHT"><a class="selflink" href="#LICENSE_AND_COPYRIGHT">LICENSE
  AND COPYRIGHT</a></h1>
Copyright 2011-2012 Dima Kogan.
<div class="Pp"></div>
This program is free software; you can redistribute it and/or modify it under
  the terms of either: the GNU General Public License as published by the Free
  Software Foundation; or the Artistic License.
<div class="Pp"></div>
See http://dev.perl.org/licenses/ for more information.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-25</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
