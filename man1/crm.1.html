<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>crm(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">crm(1)</td>
    <td class="head-vol">CRM114</td>
    <td class="head-rtitle">crm(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<br/>
crm - The Controllable Regex Mutilator
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<br/>
<b>crm</b> [ <i>OPTION</i>]... <i>CRMFILE</i>
<h1 class="Sh" title="Sh" id="WARNING"><a class="selflink" href="#WARNING">WARNING</a></h1>
<br/>
This man page is taken from an older CRM114 version. It is provided as a
  convenience to Debian users and may not be up-to-date. If you would like to
  update it, please send appropriate patches to the Debian bug tracking system.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<br/>
<div class="Pp"></div>
<b>-d</b> N (<i>enter debugger after running N cycles. Omitting N means N equals
  0.</i>) <b></b>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b> (<i>do not import any environment
    variables</i>)<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b> (<i>print help text</i>)<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b> (<i>generate an execution-time-spent profile on
    exit</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b> N (<i>max program lines</i>)<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b> m (<i>mathmode (0,1 = alg/RPN only in EVAL, 2,3 =
    alg/RPN everywhere)</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b> N (<i>new feature file (.css) size is N (default
    1 meg+1 featureslots)</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b> N (<i>new feature file (.css) size is N rounded
    to 2^I+1 featureslots</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b> (<i>user trace output</i>)<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b> (<i>implementors trace output (only for the
    masochistic!)</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u</b> dir (<i>chdir to directory dir before starting
    execution</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b> (<i>print CRM114 version identification and
    exit</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b> N (<i>max data window (bytes, default 16
    megs)</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--</b> (<i>signals the end CRM114 flags; prior flags are
    not seen by the user program; subsequent args are not processed by
    CRM114</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--foo</b> (<i>creates the user variable :foo: with the
    value SET</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--x=y</b> (<i>creates the user variable :x: with the
    value y</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-{</b> stmts} (<i>execute the statements inside the {}
    brackets</i>) <b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>crmfile</b> (<i>.crm file name</i>)</dt>
  <dd class="It-tag"></dd>
</dl>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<br/>
CRM114 is a language designed to write filters in. It caters to filtering email,
  system log streams, html, and other marginally human-readable ASCII that may
  occasion to grace your computer.
<div style="height: 1.00em;">&#x00A0;</div>
CRM114's unique strengths are the data structure (everything is a string and a
  string can overlap another string), it's ability to work on truly infinitely
  long input streams, it's ability to use extremely advanced classifiers to sort
  text, and the ability to do approximate regular expressions (that is, regexes
  that don't quite match) via the TRE regex library.
<div style="height: 1.00em;">&#x00A0;</div>
CRM114 also sports a very powerful subprocess control facility, and a unique
  syntax and program structure that puts the fun back in programming (OK, you
  can run away screaming now). The syntax is declensional rather than
  positional; the type of quote marks around an argument determine what that
  argument will be used for.
<div style="height: 1.00em;">&#x00A0;</div>
The typical CRM114 program uses regex operations more often than addition (in
  fact, math was only added to TRE in the waning days of 2003, well after CRM114
  had been in daily use for over a year and a half).
<div style="height: 1.00em;">&#x00A0;</div>
In other words, crm114 is a very <b>very</b> powerful mutagenic filter that
  happens to be a programming language as well.
<div style="height: 1.00em;">&#x00A0;</div>
The filtering style of the CRM-114 discriminator is based on the fact that most
  spam, normal log file messages, or other uninteresting data is easily
  categorized by a few characteristic patterns (such as &quot;Mortgage
  leads&quot;, &quot;advertise on the internet&quot;, and &quot;mail-order toner
  cartridges&quot;.) CRM114 may also be useful to folks who are on multiple
  interlocking mailing lists.
<div style="height: 1.00em;">&#x00A0;</div>
In a bow to Unix-style flexibility, by default CRM114 reads it's input from
  standard input, and by default sends it's output to standard output. Note that
  the default action has a zero-length output. Redirection and use of other
  input or output files is possible, as well as the use of windowing, either
  delimiter-based or time-based, for real-time continuous applications.
<div style="height: 1.00em;">&#x00A0;</div>
CRM114 can be used for other than mail filtering; consider it to be a version of
  <i>grep</i> with super powers. If perl is a seventy-bladed swiss army knife,
  CRM114 is a razor-sharp katana that can talk.
<h1 class="Sh" title="Sh" id="INVOCATION"><a class="selflink" href="#INVOCATION">INVOCATION</a></h1>
<br/>
Absent the -{ program } flag, the first argument is taken to be the name of a
  file containing a crm114 program, subsequent arguments are merely supplied as
  :_argN: values. Use single quotes around commandline programs '-{ like this }'
  to prevent the shell from doing odd things to your command-line programs.
<div style="height: 1.00em;">&#x00A0;</div>
CRM114 can be directly invoked by the shell if the first line of your program
  file uses the shell standard, as in:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
#! /usr/bin/crm
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
You can use CRM114 flags on the shell-standard invocation line, and hide them
  with '--' from the program itself; '--' incidentally prevents the invoking
  user from changing any CRM114 invocation flags.
<div style="height: 1.00em;">&#x00A0;</div>
Flags should be located after any positional variables on the command line.
  Flags <i>are</i> visible as :_argN: variables, so you can create your own
  flags for your own programs (separate CRM114 and user flags with '--'). Two
  examples on how to do this:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
./foo.crm bar mugga &lt; baz  -t -w 150000
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
./foo.crm -t -w 1500000 -- bar &lt; baz mugga
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
One example on how <b>not</b> to do this:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
./foo.crm -t -w 150000 bar &lt; baz mugga
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(That's WRONG!)
<div style="height: 1.00em;">&#x00A0;</div>
You can put a list of user-settable vars on the #!/usr/bin/crm invocation line.
  CRM114 will print these out when a program is invoked directly (e.g.
  &quot;./myprog.crm -h&quot;, not &quot;crm myprog.crm -h&quot;) with the -h
  (for help) flag. (note that this works ONLY on bash on Linux- *BSD's have a
  different bash interpretation and this doesn't work)
<div style="height: 1.00em;">&#x00A0;</div>
Example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
#!/usr/bin/crm  -( var1 var2=A var2=B var2=C )
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This allows only var1 and var2 be set on the command line. If a variable is not
  assigned a value, the user can set any value desired. If the variable is
  equated to a set of values, those are the <i>only</i> values allowed.
<div style="height: 1.00em;">&#x00A0;</div>
Another example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
#!/usr/bin/crm  -( var1 var2=foo )  --
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This allows var1 to be set to any value, var2 may only be set to either foo or
  not at all, and no other variables may be set nor may invocation flags be
  changed (because of the trailing &quot;--&quot;). Since &quot;--&quot; also
  blocks '-h' for help, such programs should provide their own help facility.
<h1 class="Sh" title="Sh" id="VARIABLES"><a class="selflink" href="#VARIABLES">VARIABLES</a></h1>
<br/>
Variable names and locations start with a : , end with a : , and may contain
  only characters that have ink (i.e. the [:graph:] class) with few exceptions.
<div style="height: 1.00em;">&#x00A0;</div>
Examples :here:, :ThErE:, :every-where_0123+45%6789:,
  :this_is_a_very_very_long_var_name_that_does_not_tell_us_much:. Builtin
  variables:
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
:_nl: newline
<br/>
<div>&#x00A0;</div>
<br/>
:_ht: horizontal tab
<br/>
<div>&#x00A0;</div>
<br/>
:_bs: backspace
<br/>
<div>&#x00A0;</div>
<br/>
:_sl: a slash
<br/>
<div>&#x00A0;</div>
<br/>
:_sc: a semicolon
<br/>
<div>&#x00A0;</div>
<br/>
:_arg0: thru :_argN: command-line args, including <i>all</i> flags
<br/>
<div>&#x00A0;</div>
<br/>
:_argc: how many command line arguments there were
<br/>
<div>&#x00A0;</div>
<br/>
:_pos0: thru :_posN: positional args ('-' or '--' args deleted)
<br/>
<div>&#x00A0;</div>
<br/>
:_posc: how many positional arguments there were
<br/>
<div>&#x00A0;</div>
<br/>
:_pos_str: all positional arguments concatented
<br/>
<div>&#x00A0;</div>
<br/>
:_env_whatever: environment value 'whatever'
<br/>
<div>&#x00A0;</div>
<br/>
:_env_string: all environmental arguments concatenated
<br/>
<div>&#x00A0;</div>
<br/>
:_crm_version: the version of the CRM system
<br/>
<div>&#x00A0;</div>
<br/>
:_dw: the current data window contents
<br/>
<h1 class="Sh" title="Sh" id="VARIABLE_EXPANSION"><a class="selflink" href="#VARIABLE_EXPANSION">VARIABLE
  EXPANSION</a></h1>
<br/>
Variables are expanded by the :*: var-expansion operator, e.g. :*:_nl: expands
  to a newline character. Uninitialized vars evaluate to their text name (and
  the colons stay).
<div style="height: 1.00em;">&#x00A0;</div>
You can also use the standard constant C '\' characters, such as &quot;\n&quot;
  for newline, as well as excaped hexadecimal and octal characters like \xHH and
  \oOOO but these are constants, not variables, and cannot be redefined.
<div style="height: 1.00em;">&#x00A0;</div>
Depending on the value of &quot;math mode&quot; (flag -q). you can also use
  :#:string_or_var: to get the length of a string, and :@:string_or_var: to do
  basic mathematics and inequality testing, either only in EVALs or for all
  var-expanded expressions. See &quot;Sequence of Evaluation&quot; below for
  more details.
<h1 class="Sh" title="Sh" id="PROGRAM_BEHAVIOR"><a class="selflink" href="#PROGRAM_BEHAVIOR">PROGRAM
  BEHAVIOR</a></h1>
<br/>
Default behavior is to read all of standard input till EOF into the default data
  window (named :_dw:), then execute the program (this is overridden if first
  executable statement is a WINDOW statement).
<div style="height: 1.00em;">&#x00A0;</div>
Variables don't get their own storage unless you ISOLATE them (see below),
  instead variables are start/length pairs indexing into the default data
  window. Thus, ALTERing an unISOLATEd variable changes the value of the default
  data buffer itself. This is a great power, so use it only for good, and never
  for evil.
<h1 class="Sh" title="Sh" id="STATEMENTS_AND_STUFF"><a class="selflink" href="#STATEMENTS_AND_STUFF">STATEMENTS
  AND STUFF</a></h1>
<br/>
Statements are separated with a ';' or with a newline.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
\
<div>&#x00A0;</div>
'\' is the string-text escape character. You only <i>need</i> to escape the
  literal representation of closing delimiters inside var-expanded arguments.
<div style="height: 1.00em;">&#x00A0;</div>
You can use the classic C/C++ \-escapes, such as \n, \r, \t, \a, \b, \v, \f, \0,
  and also \xHH and \oOOO for hex and octal characters, respectively.
<div style="height: 1.00em;">&#x00A0;</div>
A '\' as the <i>last</i> character of a line means the next line is just a
  continuation of this one.
<div style="height: 1.00em;">&#x00A0;</div>
A \-escape that isn't recognized as something special isn't an error; you may
  <i>optionally</i> escape any of the delimiters &gt;, ) ] } ; / # \ and get
  just that character.
<div style="height: 1.00em;">&#x00A0;</div>
A '\' anywhere else is just a literal backslash, so the regex ([abc])\1 is
  written just that way; there is no need to double-backslash the \1 (although
  it will work if you do).
<br/>
<div>&#x00A0;</div>
<br/>
# this is a comment
<br/>
<div>&#x00A0;</div>
<br/>
# and this too \#
<br/>
<br/>
<div>&#x00A0;</div>
A comment is not a piece of preprocessor sugar -- it is a <i>statement</i> and
  ends at the newline or at &quot;\#&quot;.
<br/>
<div>&#x00A0;</div>
<br/>
insert filename
<div>&#x00A0;</div>
inserts the file verbatim at this line at compile time.
<br/>
<div>&#x00A0;</div>
<br/>
;
<div>&#x00A0;</div>
statement separator - must ALWAYS be escaped as \; unless it's inside delimiters
  or else it will mark the end of the statement.
<br/>
<div>&#x00A0;</div>
<br/>
{ and }
<div>&#x00A0;</div>
start and end blocks of statements. Must always be '\' escaped or inside
  delimiters or these will mark the start/end of a block.
<br/>
<div>&#x00A0;</div>
<br/>
noop
<div>&#x00A0;</div>
no-op statement
<br/>
<div>&#x00A0;</div>
<br/>
:label:
<div>&#x00A0;</div>
define a GOTOable label
<br/>
<div>&#x00A0;</div>
<br/>
accept
<div>&#x00A0;</div>
writes the current data window to standard output; execution continues.
<br/>
<div>&#x00A0;</div>
<br/>
alius
<div>&#x00A0;</div>
if the last bracket-group succeeded, ALIUS skips to end of {} block (a skip, not
  a FAIL); if the prior group FAILed, ALIUS does nothing. Thus, ALIUS is both an
  ELSE clause and a CASE statement.
<br/>
<div>&#x00A0;</div>
<br/>
alter (:var:) /new-val/
<div>&#x00A0;</div>
destructively change value of var to newval; (:var:) is var to change
  (var-expanded); /new-val/ is value to change to (var-expanded).
<br/>
<div>&#x00A0;</div>
<br/>
classify &lt;flags&gt; (:c1:...|...:cN:) (:stats:) [:in:] /word-pat/
<div>&#x00A0;</div>
compare the statistics of the current data window buffer with classfiles
  c1...cN.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;flags&gt; If &lt;flags&gt; is set to &lt;nocase&gt;, ignore case in
  word-pat, does not change case in hash (use tr() to do that on :in: if you
  want it).
<br/>
<div>&#x00A0;</div>
<br/>
(:c1: ... file or files to consider &quot;success&quot; files. The CLASSIFY
  succeeds if these files as a group match best. If not, the CLASSIFY does a
  FAIL.
<br/>
<div>&#x00A0;</div>
<br/>
| optional separator. Spaces on each side of the &quot; | &quot; are required.
<br/>
<div>&#x00A0;</div>
<br/>
.... :cN:) optional files to the right of &quot; | &quot; are considered as a
  group to &quot;fail&quot;. If statement fails, execution skips to end of
  enclosing {..} block, which exits with a FAIL status (see ALIUS for why this
  is useful).
<br/>
<div>&#x00A0;</div>
<br/>
(:stats:) optional var that will get a text formatted matching summary
<br/>
<div>&#x00A0;</div>
<br/>
[:in:] restrict statistical measure to the string inside :in:
<br/>
<div>&#x00A0;</div>
<br/>
/word-pat/ regex to describe what a parseable word is.
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
eval (:result:) /instring/
<div>&#x00A0;</div>
repeatedly evaluates /instring/ until it ceases to change, then places that
  result as the value of :result: . EVAL uses smart (but foolable) heuristics to
  avoid infinite loops, like evaluating a string that evaluates to a request to
  evaluate itself again. The error rate is about 1 / 2^62 and will detect chain
  groups of length 255 or less. If the instring uses math evaluation (see
  section below on math operations) and the evaluation has an inequality test,
  (&gt;, &lt; or =) then if the inequality fails, the EVAL will FAIL to the end
  of block. If the evaluation has a numeric fault (e.g. divide-by-zero) the EVAL
  will do a TRAPpable FAULT.
<br/>
<div>&#x00A0;</div>
<br/>
exit /:retval:/
<div>&#x00A0;</div>
ends program execution. If supplied, the return value is converted to an integer
  and returned as the exit code of the crm114 program. If no retval is supplied,
  the return value is 0.
<br/>
<div>&#x00A0;</div>
<br/>
fail
<div>&#x00A0;</div>
skips down to end of the current { } block and causes that block to exit with a
  FAIL status (see ALIUS for why this is useful)
<br/>
<div>&#x00A0;</div>
<br/>
fault /faultstr/
<div>&#x00A0;</div>
forces a FAULT with the given string as the reason. The fault string is
  val-expanded.
<br/>
<div>&#x00A0;</div>
<br/>
goto /:label:/
<div>&#x00A0;</div>
unconditional branch (you can use a variable as the goal, e.g. /:*:there:/ )
<br/>
<div>&#x00A0;</div>
<br/>
hash (:result:) /input/
<div>&#x00A0;</div>
compute a fast 32-bit hash of the /input/, and ALTER :result: to the hexadecimal
  hash value. HASH is <i>not</i> warranted to be constant across major releases
  of CRM114, nor is it cryptographically secure.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
(:result:) value that gets result.
<br/>
<div>&#x00A0;</div>
<br/>
/input/ string to be hashed (can contain expanded :*:vars:, defaults to the data
  window :_dw:)
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
intersect (:out:) [:var1: :var2: ...]
<div>&#x00A0;</div>
makes :out: contain the part of the data window that is the intersection of
  :var1 :var2: ... ISOLATEd vars are ignored. This only resets the value of the
  captured variable, and does NOT alter any text in the data window.
<br/>
<div>&#x00A0;</div>
<br/>
isolate (:var:) /initial-value/
<div>&#x00A0;</div>
puts :var: into a data area outside of the data buffer; subsequent changes to
  this var don't change the data buffer (though they may change the value of any
  var subsequently set inside of this var). If the var already was ISOLATED,
  this is a noop.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
(:var:) name of ISOLATEd var (var-expanded)
<br/>
<div>&#x00A0;</div>
<br/>
/initial-value/ optional initial value for :var: (var-expanded). If no value is
  supplied, the previous value is retained/copied.
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
input &lt;flags&gt; (:result:) [:filename:]
<div>&#x00A0;</div>
read in the content of filename. If no filename, then read stdin
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;byline&gt; read one line only
<br/>
<div>&#x00A0;</div>
<br/>
(:result:) var that gets the input value
<br/>
<div>&#x00A0;</div>
<br/>
[:filename:] the file to read
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
learn &lt;flags&gt; (:class:) [:in:] /word-pat/
<div>&#x00A0;</div>
learn the statistics of the :in: var (or the input window if no var) as an
  example of class :class:
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;flags&gt; can be any of &lt;nocase&gt;, &lt;refute&gt; and
  &lt;microgroom&gt;. &lt;nocase&gt;: ignore case in matching word-pat (does not
  ignore case in hash- use tr() to do that on :in: if you want it).
  &lt;refute&gt;: this is an anti-example of this class- unlearn it!
  &lt;microgroom&gt;: enable the microgroomer to purge less-important
  information automatically whenever the statistics file gets to crowded.
<br/>
<div>&#x00A0;</div>
<br/>
(:class:) name of file holding hashed results; nominal file extension is .css
<br/>
<div>&#x00A0;</div>
<br/>
[:in:] captured var containing the text to be learned (if omitted, the full
  contents of the data window is used)
<br/>
<div>&#x00A0;</div>
<br/>
/word-pat/ regex that defines a &quot;word&quot;. Things that aren't
  &quot;words&quot; are ignored.
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
liaf
<div>&#x00A0;</div>
skips UP to START of the current {} block (LIAF is FAIL spelled backwards)
<br/>
<div>&#x00A0;</div>
<br/>
match &lt;flags&gt; (:var1: ...) [:in:] /regex/
<div>&#x00A0;</div>
Attempt to match the given regex; if match succeds, variables are bound; if
  match fails, program skips to the closing '}' of this block
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;flags&gt; flags can be any of
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;absent&gt; statement succeeds if match not present
<br/>
<div>&#x00A0;</div>
<br/>
&lt;nocase&gt; ignore case when matching
<br/>
<div>&#x00A0;</div>
<br/>
&lt;fromstart&gt; start match at start of the [:in:] var
<br/>
<div>&#x00A0;</div>
<br/>
&lt;fromcurrent&gt; start match at start of previous successful match on the
  [:in:] var
<br/>
<div>&#x00A0;</div>
<br/>
&lt;fromnext&gt; start match at one character past the start of the previous
  successful match on the [:in:] var
<br/>
<div>&#x00A0;</div>
<br/>
&lt;fromend&gt; start match at one character past the end of prev. match on this
  [:in:] var
<br/>
<div>&#x00A0;</div>
<br/>
&lt;newend&gt; require match to end after end of prev. match on this [:in:] var
<br/>
<div>&#x00A0;</div>
<br/>
&lt;backwards&gt; search backward in the [:in:] variable from the last
  successful match.
<br/>
<div>&#x00A0;</div>
<br/>
&lt;nomultiline&gt; don't allow this match to span lines
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
(:var1: ...) optional variables to bind to regex result and '(' ')' subregexes
<br/>
<div>&#x00A0;</div>
<br/>
[:in:] search only in the variable specified; if omitted, :_dw: (the full input
  data window) is used
<br/>
<div>&#x00A0;</div>
<br/>
/regex/ POSIX regex (with \ escapes as needed)
<br/>
If you build CRM114 to use the GNU regex library for MATCHing, be warned that
  GNU REGEX has numerous issues. See the KNOWN_BUGS file for a detailed listing.
<br/>
<div>&#x00A0;</div>
<br/>
output &lt;flags&gt; [filename] /output-text/
<div>&#x00A0;</div>
output an arbitrary string with captured values expanded.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;flags&gt; &lt;append&gt;: append to the file (otherwise, overwrites)
<br/>
<div>&#x00A0;</div>
<br/>
[filename] filename to send output (var-expanded), default output is to stdout
<br/>
<div>&#x00A0;</div>
<br/>
/output-text/ string to output (var-expanded)
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
syscall &lt;flags&gt; (:in:) (:out:) (:status:) /command/
<div>&#x00A0;</div>
execute a shell command
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;flags&gt; can be any of &lt;keep&gt; and &lt;async&gt;. &lt;keep&gt;: keep
  this process around; if kept, then a syscall with the same :keep: var will
  continue feeding to and reading from the kept proc. &lt;async&gt;: don't wait
  for process to send an EOF; just grab what's available in the process's output
  pipe and proceed (limit per syscall is 256 Kbytes)
<br/>
<div>&#x00A0;</div>
<br/>
(:in:) var-expanded string to feed to command as input (can be null if you don't
  want to send the process something.) You <b>must</b> specify this if you want
  to specify an :out: variable.
<br/>
<div>&#x00A0;</div>
<br/>
(:out:) var-expanded varname to place results into ( <b>must</b> pre-exist, can
  be null if you don't want to read the process's output (yet, or at all). Limit
  per syscall is 256 Kbytes. You <b>must</b> specify this if you want to use the
  :status: variable)
<br/>
<div>&#x00A0;</div>
<br/>
(:status:) if you want to keep a minion proc around, or catch the exit status of
  the process, specify a var here. The minion process's PID and pipes will be
  stored here. The program can access the proc again with another syscall by
  using this var again. When the process exits, it's exit code will be stored
  here.
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
trap (:reason:) /trap_regex/
<div>&#x00A0;</div>
traps faults from both FAULT statements and program errors occurring anywhere in
  the preceding bracket-block. If no fault exists, TRAP does a SKIP to end of
  block. If there is a fault and the fault reason string matches the trap_regex,
  the fault is trapped, and execution continues with the line after the TRAP,
  otherwise the fault is passed up to the next surrounding trapped bracket
  block.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
(:reason:) the fault message that caused this FAULT. If it was a user fault,
  this is the text the user supplied in the FAULT statement.
<br/>
<div>&#x00A0;</div>
<br/>
/trap_regex/ the regex that determines what kind of faults this TRAP will
  accept. Putting a wildcard here (e.g. /.*/ means that ALL faults will be
  trapped here.
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
union (:out:) [:var1: :var2: ...]
<div>&#x00A0;</div>
makes :out: contain the union of the data window segments that contains var1,
  var2... plus any intervening text as well. Any ISOLATEd var is ignored. This
  is non-surgical, and does not alter the data window
<br/>
<div>&#x00A0;</div>
<br/>
window &lt;flags&gt; (:w-var:) (:s-var:) /cut-regex/ /add-regex/
<div>&#x00A0;</div>
window slider. This deletes to and including the cut-regex from :var: (default:
  use the data window), then reads adds from std. input till add-regex
  (inclusive).
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;flags&gt; flags can be any of
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&lt;nocase&gt; ignore case when matching cut- and add- regexes
<br/>
<div>&#x00A0;</div>
<br/>
&lt;bychar&gt; check input for add-regex every character
<br/>
<div>&#x00A0;</div>
<br/>
&lt;byline&gt; check input for add-regex every line
<br/>
<div>&#x00A0;</div>
<br/>
&lt;byeof&gt; wait for EOF to check for add-regex (extra characters are kept
  around for later)
<br/>
<div>&#x00A0;</div>
<br/>
&lt;eofends&gt; read lots of input; the input is up to the regex match OR the
  contents till EOF
<br/>
<br/>
<div>&#x00A0;</div>
<br/>
(:w-var:) what var to window
<br/>
<div>&#x00A0;</div>
<br/>
(:s-var:) what var to use for source (defaults to stdin, if you use a source var
  you <b>must</b> specify the windowed var.
<br/>
<div>&#x00A0;</div>
<br/>
/cut-regex/ var-expanded cut pattern
<br/>
<div>&#x00A0;</div>
<br/>
/add-regex/ var-expanded add pattern, if absent reads till EOF
<br/>
If both cut-regex and add-regex are omitted, and this window statement is the
  <i>first executable</i> statement in the program, then CRM114 does <i>not</i>
  wait to read a anything from standard input input before starting program
  execution.
<br/>
<h1 class="Sh" title="Sh" id="A_QUICK_REGEX_INTRO"><a class="selflink" href="#A_QUICK_REGEX_INTRO">A
  QUICK REGEX INTRO</a></h1>
<br/>
A regex is a pattern match. Do a &quot;man 7 regex&quot; for details.
<div style="height: 1.00em;">&#x00A0;</div>
Matches are, by default &quot;first starting point that matches, then longest
  match possible that can fit&quot;.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
a through z
<br/>
<div>&#x00A0;</div>
<br/>
A through Z
<br/>
<div>&#x00A0;</div>
<br/>
0 through 9
<br/>
<br/>
<div>&#x00A0;</div>
all match themselves.
<br/>
<div>&#x00A0;</div>
<br/>
most punctuation
<div>&#x00A0;</div>
matches itself, but check below!
<br/>
<div>&#x00A0;</div>
<br/>
*
<div>&#x00A0;</div>
repeat preceding 0 or more times
<br/>
<div>&#x00A0;</div>
<br/>
+
<div>&#x00A0;</div>
repeat preceding 1 or more times
<br/>
<div>&#x00A0;</div>
<br/>
?
<div>&#x00A0;</div>
repeat preceding 0 or 1 time
<br/>
<div>&#x00A0;</div>
<br/>
*?, +?, ??
<div>&#x00A0;</div>
repeat preceding, but <i>shortest</i> match that fits, given the
  already-selected start point of the regex. (only supported by TRE regex, not
  GNU regex)
<br/>
<div>&#x00A0;</div>
<br/>
[abcde]
<div>&#x00A0;</div>
any one of the letters a, b, c, d, or e
<br/>
<div>&#x00A0;</div>
<br/>
[a-q]
<div>&#x00A0;</div>
the letters a through q (just one of them)
<br/>
<div>&#x00A0;</div>
<br/>
{n,m}
<div>&#x00A0;</div>
repetition count: match the preceding at least n and no more than m times (POSIX
  restricts this to a maximum of 255 repeats)
<br/>
<div>&#x00A0;</div>
<br/>
[[:&lt;:]]
<div>&#x00A0;</div>
matches at the start of a word (GNU regex only)
<br/>
<div>&#x00A0;</div>
<br/>
[[:&gt;:]]
<div>&#x00A0;</div>
matches the end of a word (GNU regex only)
<br/>
<div>&#x00A0;</div>
<br/>
^
<div>&#x00A0;</div>
as first char of a match, matches the start of a line (ONLY in
  &lt;nomultiline&gt; matches.
<br/>
<div>&#x00A0;</div>
<br/>
$
<div>&#x00A0;</div>
as last char of a match, matches at the end of a line (ONLY in
  &lt;nomultiline&gt; matches)
<br/>
<div>&#x00A0;</div>
<br/>
.
<div>&#x00A0;</div>
(a period) matches any single character (except start-of-line or end of line
  &quot;virtual characters&quot;, but it does match a newline).
<br/>
<div>&#x00A0;</div>
<br/>
a|b
<div>&#x00A0;</div>
match a or b
<br/>
<div>&#x00A0;</div>
<br/>
(match)
<div>&#x00A0;</div>
the () go away, and the string that matched inside is available for capturing.
  Use \\( and \\) to match actual parenthesis (the first '\' tells &quot;show
  the second '\' to the regex engine, the second '\' forces a literalization
  onto the parenthesis character.
<br/>
<div>&#x00A0;</div>
<br/>
\n
<div>&#x00A0;</div>
matches the N'th parenthesized subexpression. Remember to backslash-escape the
  backslash (e.g. write this as \\1) This is only if you're using TRE, not GNU
  regex.
<br/>
The following are other POSIX expressions, which mostly do what you'd guess
  they'd do from their names.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
<div class="Pp"></div>
  [[:alnum:]]
  [[:alpha:]]
  [[:blank:]]
  [[:cntrl:]]
  [[:digit:]]
  [[:lower:]]
  [[:upper:]]
  [[:graph:]]
  [[:print:]]
  [[:punct:]]
  [[:space:]]
  [[:xdigit:]]
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
[[:graph:]] matches any character that puts ink on paper or lights a pixel.
  [[:print:]] matches any character that moves the &quot;print head&quot; or
  cursor.
<h1 class="Sh" title="Sh" id="NOTES_ON_SEQUENCE_OF_EVALUTATION"><a class="selflink" href="#NOTES_ON_SEQUENCE_OF_EVALUTATION">NOTES
  ON SEQUENCE OF EVALUTATION</a></h1>
<br/>
By default, CRM114 supports string length and mathematical evaluation only in an
  EVAL statement, although it can be set to allow these in any place where a
  var-expanded variable is allowed (see the -q flag). The default value ( zero )
  allows stringlength and math evaluation only in EVAL statements, and uses
  non-precedence (that is, strict left-to-right unless parenthesis are used)
  algebraic notation. -q 1 uses RPN instead of algebraic, again allowing
  stringlength and math evaluation only in EVAL expressions. Modes 2 and 3 allow
  stringlength and math evaluation in <i>any</i> var-expanded expression, with
  non-precedence algebraic notation and RPN notation respectively. Evaluation is
  always left-to-right; there is no precedence of operators beyond the
  sequential passes noted below. The evaluation is done in four sequential
  passes:
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
1 \-constants like \n, \o377 and \x3F are substituted
<br/>
<div>&#x00A0;</div>
<br/>
2 :*:var: variables are substituted (note the difference between a constant like
  '\n' and a variable like &quot;:*:_nl:&quot; here - constants are substituted
  first, then variables are substituted.)
<br/>
<div>&#x00A0;</div>
<br/>
3 :#:var: string-length operations are performed
<br/>
<div>&#x00A0;</div>
<br/>
4 :@:expression: mathematical expressions are performed; syntax is either RPN or
  non-precedenced (parens required) algebraic notation. Embedded non-evaluated
  strings in a mathematical expression is currently a no-no.
<div style="height: 1.00em;">&#x00A0;</div>
Allowed operators are: + - * / % &gt; &lt; = only.
<div style="height: 1.00em;">&#x00A0;</div>
Only &gt;, &lt;, and = set logical results; they also evaluate to 1 and 0 for
  continued chain operations - e.g.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
((:*:a: &gt; 3) + (:*:b: &gt; 5) + (:*:c: &gt; 9) &gt; 2)
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
is true IFF any of the following is true
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
&#x2022; a &gt; 3 and b &gt; 5
<br/>
<div>&#x00A0;</div>
<br/>
&#x2022; a &gt; 3 and c &gt; 9
<br/>
<div>&#x00A0;</div>
<br/>
&#x2022; b &gt; 5 and c &gt; 9
<br/>
<br/>
<h1 class="Sh" title="Sh" id="NOTES_ON_APPROXIMATE_REGEX_MATCHING"><a class="selflink" href="#NOTES_ON_APPROXIMATE_REGEX_MATCHING">NOTES
  ON APPROXIMATE REGEX MATCHING</a></h1>
<br/>
Only the TRE engine supports approximate matching. The GNU engine does not
  support approximate matching.
<div style="height: 1.00em;">&#x00A0;</div>
Approximate matching is specified similarly to a &quot;repetition count&quot; in
  a regular regex, using brackets. This approximation applies to the previous
  parenthesized expression (again, just like repetion counts). You can specify
  maximum total changes, and how many inserts, deletes, and substitutions you
  wish to allow. The minimum-error match is found and reported, if it exists
  within the bounds you state.
<div style="height: 1.00em;">&#x00A0;</div>
The basic syntax is:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
(text-to-match){~[maxerrs] [#maxsubsts] [+maxinserts] [-maxdeletes]}
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Note that the '~' (with an optional maxerr count) is <i>required</i> (that's how
  we know it's an approximate regex rather than just a rep-count); if you don't
  specify a max error count, you will get the best match, if you do, the match
  will have at most that many errors.
<div style="height: 1.00em;">&#x00A0;</div>
Remember that you specify the changes to the text in the <i>pattern</i>
  necessary to make it match the text in the string being searched.
<div style="height: 1.00em;">&#x00A0;</div>
You cannot use approximate regexes and backrefs (like \1) in the same regex.
  This is a limitation of in TRE at this point.
<div style="height: 1.00em;">&#x00A0;</div>
You can also use an inequality in addition to the basic syntax above:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
<pre>
(text-to-match){~[maxerrs] [basic-syntax] [nI + mD + oS &lt; K] }
</pre>
<br/>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
where n, m, and o are the costs per insertion, deletion, and substitution
  respectively, 'I', 'D', and 'S' are indicators to tell which cost goes with
  which kind of error, and K is the total cost of the errors; the cost of the
  errors is always strictly less than K. Here are some examples.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
(foobar)
<div>&#x00A0;</div>
exactly matches &quot;foobar&quot;
<br/>
<div>&#x00A0;</div>
<br/>
(foobar){~}
<div>&#x00A0;</div>
finds the closest match to &quot;foobar&quot;, with the minimum number of
  inserts, deletes, and substitutions. Always succeeds.
<br/>
<div>&#x00A0;</div>
<br/>
(foobar){~3}
<div>&#x00A0;</div>
finds the closest match to &quot;foobar&quot;, with no more than 3 inserts,
  deletes, or substitutions
<br/>
<div>&#x00A0;</div>
<br/>
(foobar){~2 +2 -1 #1)
<div>&#x00A0;</div>
find the closest match to &quot;foobar&quot;, with at most two errors total, and
  at most two inserts, one delete, and one substitution.
<br/>
<div>&#x00A0;</div>
<br/>
(foobar){~4 #1 1i + 2d &lt; 5 }
<div>&#x00A0;</div>
find the closest match to &quot;foobar&quot;, with at most four errors total, at
  most one substitution, and with the number of insertions plus 2x the number of
  deletions less than 5.
<br/>
<div>&#x00A0;</div>
<br/>
(foo){~1}(bar){~1)
<div>&#x00A0;</div>
find the closest match to &quot;foobar&quot;, with at most one error in the
  &quot;foo&quot; and one error in the &quot;bar&quot;.
<br/>
<h1 class="Sh" title="Sh" id="OVERALL_LANGUAGE_NOTES"><a class="selflink" href="#OVERALL_LANGUAGE_NOTES">OVERALL
  LANGUAGE NOTES</a></h1>
<br/>
Here's how to remember what goes where in the CRM114 language.
<div style="height: 1.00em;">&#x00A0;</div>
Unlike most computer languages, CRM114 uses inflection (or declension) rather
  than position to describe what role each part of a statement plays. The
  declensions are marked by the delimiters- the /, ( and ), &lt; and &gt;, and [
  and ].
<div style="height: 1.00em;">&#x00A0;</div>
By and large, you can mix up the arguments to each kind of statement without
  changing their meaning. Only the ACTION needs to be first. Other parts of the
  statement can occur in any order, save that multiple (paren_args) and
  /pattern_args/ must stay in their nominal order but can go anywhere in the
  statement. They do not need to be consecutive.
<div style="height: 1.00em;">&#x00A0;</div>
The parts of a CRM114 statement are:
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<br/>
ACTION the verb. This is at the start of the statement.
<br/>
<div>&#x00A0;</div>
<br/>
/pattern/ the overall pattern the verb should use, analogous to the
  &quot;subject&quot; of the statement.
<br/>
<div>&#x00A0;</div>
<br/>
&lt;flags&gt; modifies how the ACTION does the work. You'd call these
  &quot;adverbs&quot; in human languages.
<br/>
<div>&#x00A0;</div>
<br/>
(vars) what variables to use as adjuncts in the action (what would be called the
  &quot;direct objects&quot;). These can get changed when the action happens.
<br/>
<div>&#x00A0;</div>
<br/>
[limited-to] where the action is allowed to take place (think of it as the
  &quot;indirect object&quot;). These are not directly changed by the action.
<br/>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<br/>
<b>cssmerge(1)</b>, <b>cssdiff(1)</b>, <b>cssutil(1)</b>
<div style="height: 1.00em;">&#x00A0;</div>
The CRM114 homepage is at http://crm114.sf.net/ .
<h1 class="Sh" title="Sh" id="VERSION"><a class="selflink" href="#VERSION">VERSION</a></h1>
<br/>
This manpage: $Id: crm114.azm,v 1.12 2004/08/19 11:10:49 vanbaal Exp $
<div style="height: 1.00em;">&#x00A0;</div>
This manpage describes the crm114 utility as it has been described by
  QUICKREF.txt, shipped with crm114-20040212-BlameJetlag.src.tar.gz. The
  DESCRIPTION section is copy-and-pasted from INTRO.txt as distributed with the
  same source tarball.
<div style="height: 1.00em;">&#x00A0;</div>
Converted from plain ascii to zoem by Joost van Baal.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<br/>
Copyright (C) 2001, 2002, 2003, 2004 William S. Yerazunis
<div style="height: 1.00em;">&#x00A0;</div>
This program is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any later
  version.
<div style="height: 1.00em;">&#x00A0;</div>
This program is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU General Public License for more details.
<div style="height: 1.00em;">&#x00A0;</div>
You should have received a copy of the GNU General Public License along with
  this program (see COPYING); if not, check with
  http://www.gnu.org/copyleft/gpl.html or write to the Free Software Foundation,
  Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
<br/>
William S. Yerazunis. Manpage typesetting by Joost van Baal and Shalendra
  Chhabra</div>
<table class="foot">
  <tr>
    <td class="foot-date">19 Aug 2004</td>
    <td class="foot-os">crm114 20040816.BlameClockworkOrange-auto.3</td>
  </tr>
</table>
</body>
</html>
