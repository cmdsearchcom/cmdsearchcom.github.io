<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:00:59 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>crm(1) CRM114 crm(1)</p>

<p style="margin-top: 1em">NAME <br>
crm - The Controllable Regex Mutilator</p>

<p style="margin-top: 1em">SYNOPSIS <br>
crm [OPTION]... CRMFILE</p>

<p style="margin-top: 1em">WARNING <br>
This man page is taken from an older CRM114 version. It is
provided as a convenience to Debian users and may not be
up-to-date. If you would like to update it, please send <br>
appropriate patches to the Debian bug tracking system.</p>

<p style="margin-top: 1em">OPTIONS <br>
-d N (enter debugger after running N cycles. Omitting N
means N equals 0.)</p>

<p style="margin-top: 1em">-e (do not import any
environment variables)</p>

<p style="margin-top: 1em">-h (print help text)</p>

<p style="margin-top: 1em">-p (generate an
execution-time-spent profile on exit)</p>

<p style="margin-top: 1em">-P N (max program lines)</p>

<p style="margin-top: 1em">-q m (mathmode (0,1 = alg/RPN
only in EVAL, 2,3 = alg/RPN everywhere))</p>

<p style="margin-top: 1em">-s N (new feature file (.css)
size is N (default 1 meg+1 featureslots))</p>

<p style="margin-top: 1em">-S N (new feature file (.css)
size is N rounded to 2^I+1 featureslots)</p>

<p style="margin-top: 1em">-t (user trace output)</p>

<p style="margin-top: 1em">-T (implementors trace output
(only for the masochistic!))</p>

<p style="margin-top: 1em">-u dir (chdir to directory dir
before starting execution)</p>

<p style="margin-top: 1em">-v (print CRM114 version
identification and exit)</p>

<p style="margin-top: 1em">-w N (max data window (bytes,
default 16 megs))</p>

<p style="margin-top: 1em">-- (signals the end CRM114
flags; prior flags are not seen by the user program;
subsequent args are not processed by CRM114)</p>

<p style="margin-top: 1em">--foo (creates the user variable
:foo: with the value SET)</p>

<p style="margin-top: 1em">--x=y (creates the user variable
:x: with the value y)</p>

<p style="margin-top: 1em">-{ stmts} (execute the
statements inside the {} brackets)</p>

<p style="margin-top: 1em">crmfile (.crm file name)</p>

<p style="margin-top: 1em">DESCRIPTION <br>
CRM114 is a language designed to write filters in. It caters
to filtering email, system log streams, html, and other
marginally human-readable ASCII that may occasion to grace
<br>
your computer.</p>

<p style="margin-top: 1em">CRM114&rsquo;s unique strengths
are the data structure (everything is a string and a string
can overlap another string), it&rsquo;s ability to work on
truly infinitely long input streams, <br>
it&rsquo;s ability to use extremely advanced classifiers to
sort text, and the ability to do approximate regular
expressions (that is, regexes that don&rsquo;t quite match)
via the TRE regex <br>
library.</p>

<p style="margin-top: 1em">CRM114 also sports a very
powerful subprocess control facility, and a unique syntax
and program structure that puts the fun back in programming
(OK, you can run away screaming <br>
now). The syntax is declensional rather than positional; the
type of quote marks around an argument determine what that
argument will be used for.</p>

<p style="margin-top: 1em">The typical CRM114 program uses
regex operations more often than addition (in fact, math was
only added to TRE in the waning days of 2003, well after
CRM114 had been in daily use <br>
for over a year and a half).</p>

<p style="margin-top: 1em">In other words, crm114 is a very
very powerful mutagenic filter that happens to be a
programming language as well.</p>

<p style="margin-top: 1em">The filtering style of the
CRM-114 discriminator is based on the fact that most spam,
normal log file messages, or other uninteresting data is
easily categorized by a few charac&acirc; <br>
teristic patterns (such as &quot;Mortgage leads&quot;,
&quot;advertise on the internet&quot;, and &quot;mail-order
toner cartridges&quot;.) CRM114 may also be useful to folks
who are on multiple interlocking <br>
mailing lists.</p>

<p style="margin-top: 1em">In a bow to Unix-style
flexibility, by default CRM114 reads it&rsquo;s input from
standard input, and by default sends it&rsquo;s output to
standard output. Note that the default action has a <br>
zero-length output. Redirection and use of other input or
output files is possible, as well as the use of windowing,
either delimiter-based or time-based, for real-time
continuous <br>
applications.</p>

<p style="margin-top: 1em">CRM114 can be used for other
than mail filtering; consider it to be a version of grep
with super powers. If perl is a seventy-bladed swiss army
knife, CRM114 is a razor-sharp <br>
katana that can talk.</p>

<p style="margin-top: 1em">INVOCATION <br>
Absent the -{ program } flag, the first argument is taken to
be the name of a file containing a crm114 program,
subsequent arguments are merely supplied as :_argN: values.
Use <br>
single quotes around commandline programs &rsquo;-{ like
this }&rsquo; to prevent the shell from doing odd things to
your command-line programs.</p>

<p style="margin-top: 1em">CRM114 can be directly invoked
by the shell if the first line of your program file uses the
shell standard, as in:</p>

<p style="margin-top: 1em">#! /usr/bin/crm</p>

<p style="margin-top: 1em">You can use CRM114 flags on the
shell-standard invocation line, and hide them with
&rsquo;--&rsquo; from the program itself; &rsquo;--&rsquo;
incidentally prevents the invoking user from changing any
<br>
CRM114 invocation flags.</p>

<p style="margin-top: 1em">Flags should be located after
any positional variables on the command line. Flags are
visible as :_argN: variables, so you can create your own
flags for your own programs (sepa&acirc; <br>
rate CRM114 and user flags with &rsquo;--&rsquo;). Two
examples on how to do this:</p>

<p style="margin-top: 1em">./foo.crm bar mugga &lt; baz -t
-w 150000</p>

<p style="margin-top: 1em">./foo.crm -t -w 1500000 -- bar
&lt; baz mugga</p>

<p style="margin-top: 1em">One example on how not to do
this:</p>

<p style="margin-top: 1em">./foo.crm -t -w 150000 bar &lt;
baz mugga</p>

<p style="margin-top: 1em">(That&rsquo;s WRONG!)</p>

<p style="margin-top: 1em">You can put a list of
user-settable vars on the #!/usr/bin/crm invocation line.
CRM114 will print these out when a program is invoked
directly (e.g. &quot;./myprog.crm -h&quot;, not &quot;crm
<br>
myprog.crm -h&quot;) with the -h (for help) flag. (note that
this works ONLY on bash on Linux- *BSD&rsquo;s have a
different bash interpretation and this doesn&rsquo;t
work)</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">#!/usr/bin/crm -( var1 var2=A
var2=B var2=C )</p>

<p style="margin-top: 1em">This allows only var1 and var2
be set on the command line. If a variable is not assigned a
value, the user can set any value desired. If the variable
is equated to a set of val&acirc; <br>
ues, those are the only values allowed.</p>

<p style="margin-top: 1em">Another example:</p>

<p style="margin-top: 1em">#!/usr/bin/crm -( var1 var2=foo
) --</p>

<p style="margin-top: 1em">This allows var1 to be set to
any value, var2 may only be set to either foo or not at all,
and no other variables may be set nor may invocation flags
be changed (because of the <br>
trailing &quot;--&quot;). Since &quot;--&quot; also blocks
&rsquo;-h&rsquo; for help, such programs should provide
their own help facility.</p>

<p style="margin-top: 1em">VARIABLES <br>
Variable names and locations start with a : , end with a : ,
and may contain only characters that have ink (i.e. the
[:graph:] class) with few exceptions.</p>

<p style="margin-top: 1em">Examples :here:, :ThErE:,
:every-where_0123+45%6789:,
:this_is_a_very_very_long_var_name_that_does_not_tell_us_much:.
Builtin variables:</p>

<p style="margin-top: 1em">:_nl: newline <br>
:_ht: horizontal tab <br>
:_bs: backspace <br>
:_sl: a slash <br>
:_sc: a semicolon <br>
:_arg0: thru :_argN: command-line args, including all flags
<br>
:_argc: how many command line arguments there were <br>
:_pos0: thru :_posN: positional args (&rsquo;-&rsquo; or
&rsquo;--&rsquo; args deleted) <br>
:_posc: how many positional arguments there were <br>
:_pos_str: all positional arguments concatented <br>
:_env_whatever: environment value &rsquo;whatever&rsquo;
<br>
:_env_string: all environmental arguments concatenated <br>
:_crm_version: the version of the CRM system <br>
:_dw: the current data window contents</p>

<p style="margin-top: 1em">VARIABLE EXPANSION <br>
Variables are expanded by the :*: var-expansion operator,
e.g. :*:_nl: expands to a newline character. Uninitialized
vars evaluate to their text name (and the colons stay).</p>

<p style="margin-top: 1em">You can also use the standard
constant C &rsquo;&acute; characters, such as &quot;0 for
newline, as well as excaped hexadecimal and octal characters
like and O but these are constants, <br>
not variables, and cannot be redefined.</p>

<p style="margin-top: 1em">Depending on the value of
&quot;math mode&quot; (flag -q). you can also use
:#:string_or_var: to get the length of a string, and
:@:string_or_var: to do basic mathematics and inequality
<br>
testing, either only in EVALs or for all var-expanded
expressions. See &quot;Sequence of Evaluation&quot; below
for more details.</p>

<p style="margin-top: 1em">PROGRAM BEHAVIOR <br>
Default behavior is to read all of standard input till EOF
into the default data window (named :_dw:), then execute the
program (this is overridden if first executable statement
<br>
is a WINDOW statement).</p>

<p style="margin-top: 1em">Variables don&rsquo;t get their
own storage unless you ISOLATE them (see below), instead
variables are start/length pairs indexing into the default
data window. Thus, ALTERing an unISO&acirc; <br>
LATEd variable changes the value of the default data buffer
itself. This is a great power, so use it only for good, and
never for evil.</p>

<p style="margin-top: 1em">STATEMENTS AND STUFF <br>
Statements are separated with a &rsquo;;&rsquo; or with a
newline.</p>

<p style="margin-top: 1em">&rsquo;&acute; is the
string-text escape character. You only need to escape the
literal representation of closing delimiters inside
var-expanded arguments. ,</p>

<p style="margin-top: 1em">You can use the classic C/C++
&minus;escapes, such as 0 , , and also and O for hex and
octal characters, respectively.</p>

<p style="margin-top: 1em">A &rsquo;&acute; as the last
character of a line means the next line is just a
continuation of this one.</p>

<p style="margin-top: 1em">A &minus;escape that isn&rsquo;t
recognized as something special isn&rsquo;t an error; you
may optionally escape any of the delimiters &gt;, ) ] } ; /
# &nbsp;and get just that character.</p>

<p style="margin-top: 1em">A &rsquo;&acute; anywhere else
is just a literal backslash, so the regex ([abc])1 is
written just that way; there is no need to double-backslash
the 1 (although it will work if you <br>
do). <br>
# this is a comment <br>
# and this too A comment is not a piece of preprocessor
sugar -- it is a statement and ends at the newline or at
&quot; insert filename <br>
inserts the file verbatim at this line at compile time. <br>
; <br>
statement separator - must ALWAYS be escaped as ; unless
it&rsquo;s inside delimiters or else it will mark the end of
the statement. <br>
{ and } <br>
start and end blocks of statements. Must always be
&rsquo;&acute; escaped or inside delimiters or these will
mark the start/end of a block. <br>
noop <br>
no-op statement <br>
:label: <br>
define a GOTOable label <br>
accept <br>
writes the current data window to standard output; execution
continues. <br>
alius <br>
if the last bracket-group succeeded, ALIUS skips to end of
{} block (a skip, not a FAIL); if the prior group FAILed,
ALIUS does nothing. Thus, ALIUS is both an ELSE clause <br>
and a CASE statement. <br>
alter (:var:) /new-val/ <br>
destructively change value of var to newval; (:var:) is var
to change (var-expanded); /new-val/ is value to change to
(var-expanded). <br>
classify &lt;flags&gt; (:c1:...|...:cN:) (:stats:) [:in:]
/word-pat/ <br>
compare the statistics of the current data window buffer
with classfiles c1...cN.</p>

<p style="margin-top: 1em">&lt;flags&gt; If &lt;flags&gt;
is set to &lt;nocase&gt;, ignore case in word-pat, does not
change case in hash (use tr() to do that on :in: if you want
it). <br>
(:c1: ... file or files to consider &quot;success&quot;
files. The CLASSIFY succeeds if these files as a group match
best. If not, the CLASSIFY does a FAIL. <br>
| optional separator. Spaces on each side of the &quot; |
&quot; are required. <br>
.... :cN:) optional files to the right of &quot; | &quot;
are considered as a group to &quot;fail&quot;. If statement
fails, execution skips to end of enclosing {..} block, which
exits <br>
with a FAIL status (see ALIUS for why this is useful). <br>
(:stats:) optional var that will get a text formatted
matching summary <br>
[:in:] restrict statistical measure to the string inside
:in: <br>
/word-pat/ regex to describe what a parseable word is. <br>
eval (:result:) /instring/ <br>
repeatedly evaluates /instring/ until it ceases to change,
then places that result as the value of :result: . EVAL uses
smart (but foolable) heuristics to avoid infinite <br>
loops, like evaluating a string that evaluates to a request
to evaluate itself again. The error rate is about 1 / 2^62
and will detect chain groups of length 255 or less. <br>
If the instring uses math evaluation (see section below on
math operations) and the evaluation has an inequality test,
(&gt;, &lt; or =) then if the inequality fails, the EVAL
<br>
will FAIL to the end of block. If the evaluation has a
numeric fault (e.g. divide-by-zero) the EVAL will do a
TRAPpable FAULT. <br>
exit /:retval:/ <br>
ends program execution. If supplied, the return value is
converted to an integer and returned as the exit code of the
crm114 program. If no retval is supplied, the return <br>
value is 0. <br>
fail <br>
skips down to end of the current { } block and causes that
block to exit with a FAIL status (see ALIUS for why this is
useful) <br>
fault /faultstr/ <br>
forces a FAULT with the given string as the reason. The
fault string is val-expanded. <br>
goto /:label:/ <br>
unconditional branch (you can use a variable as the goal,
e.g. /:*:there:/ ) <br>
hash (:result:) /input/ <br>
compute a fast 32-bit hash of the /input/, and ALTER
:result: to the hexadecimal hash value. HASH is not
warranted to be constant across major releases of CRM114,
nor is <br>
it cryptographically secure.</p>

<p style="margin-top: 1em">(:result:) value that gets
result. <br>
/input/ string to be hashed (can contain expanded :*:vars:,
defaults to the data window :_dw:) <br>
intersect (:out:) [:var1: :var2: ...] <br>
makes :out: contain the part of the data window that is the
intersection of :var1 :var2: ... ISOLATEd vars are ignored.
This only resets the value of the captured vari&acirc; <br>
able, and does NOT alter any text in the data window. <br>
isolate (:var:) /initial-value/ <br>
puts :var: into a data area outside of the data buffer;
subsequent changes to this var don&rsquo;t change the data
buffer (though they may change the value of any var
subse&acirc; <br>
quently set inside of this var). If the var already was
ISOLATED, this is a noop.</p>

<p style="margin-top: 1em">(:var:) name of ISOLATEd var
(var-expanded) <br>
/initial-value/ optional initial value for :var:
(var-expanded). If no value is supplied, the previous value
is retained/copied. <br>
input &lt;flags&gt; (:result:) [:filename:] <br>
read in the content of filename. If no filename, then read
stdin</p>

<p style="margin-top: 1em">&lt;byline&gt; read one line
only <br>
(:result:) var that gets the input value <br>
[:filename:] the file to read <br>
learn &lt;flags&gt; (:class:) [:in:] /word-pat/ <br>
learn the statistics of the :in: var (or the input window if
no var) as an example of class :class:</p>

<p style="margin-top: 1em">&lt;flags&gt; can be any of
&lt;nocase&gt;, &lt;refute&gt; and &lt;microgroom&gt;.
&lt;nocase&gt;: ignore case in matching word-pat (does not
ignore case in hash- use tr() to do that on :in: <br>
if you want it). &lt;refute&gt;: this is an anti-example of
this class- unlearn it! &lt;microgroom&gt;: enable the
microgroomer to purge less-important information <br>
automatically whenever the statistics file gets to crowded.
<br>
(:class:) name of file holding hashed results; nominal file
extension is .css <br>
[:in:] captured var containing the text to be learned (if
omitted, the full contents of the data window is used) <br>
/word-pat/ regex that defines a &quot;word&quot;. Things
that aren&rsquo;t &quot;words&quot; are ignored. <br>
liaf <br>
skips UP to START of the current {} block (LIAF is FAIL
spelled backwards) <br>
match &lt;flags&gt; (:var1: ...) [:in:] /regex/ <br>
Attempt to match the given regex; if match succeds,
variables are bound; if match fails, program skips to the
closing &rsquo;}&rsquo; of this block</p>

<p style="margin-top: 1em">&lt;flags&gt; flags can be any
of</p>

<p style="margin-top: 1em">&lt;abstatement succeeds if
match not present <br>
&lt;noignore case when matching <br>
&lt;frstartrmatch at start of the [:in:] var <br>
&lt;frstartrmatch at start of previous successful match on
the [:in:] var <br>
&lt;frstarttmatch at one character past the start of the
previous successful match on the [:in:] var <br>
&lt;frstart&gt;match at one character past the end of prev.
match on this [:in:] var <br>
&lt;nerequire match to end after end of prev. match on this
[:in:] var <br>
&lt;basearchsbackward in the [:in:] variable from the last
successful match. <br>
&lt;nodon&rsquo;tlallow this match to span lines <br>
(:var1: ...) optional variables to bind to regex result and
&rsquo;(&rsquo; &rsquo;)&rsquo; subregexes <br>
[:in:] search only in the variable specified; if omitted,
:_dw: (the full input data window) is used <br>
/regex/ POSIX regex (with &nbsp;escapes as needed) <br>
If you build CRM114 to use the GNU regex library for
MATCHing, be warned that GNU REGEX has numerous issues. See
the KNOWN_BUGS file for a detailed listing. <br>
output &lt;flags&gt; [filename] /output-text/ <br>
output an arbitrary string with captured values
expanded.</p>

<p style="margin-top: 1em">&lt;flags&gt; &lt;append&gt;:
append to the file (otherwise, overwrites) <br>
[filename] filename to send output (var-expanded), default
output is to stdout <br>
/output-text/ string to output (var-expanded) <br>
syscall &lt;flags&gt; (:in:) (:out:) (:status:) /command/
<br>
execute a shell command</p>

<p style="margin-top: 1em">&lt;flags&gt; can be any of
&lt;keep&gt; and &lt;async&gt;. &lt;keep&gt;: keep this
process around; if kept, then a syscall with the same :keep:
var will continue feeding to and reading <br>
from the kept proc. &lt;async&gt;: don&rsquo;t wait for
process to send an EOF; just grab what&rsquo;s available in
the process&rsquo;s output pipe and proceed (limit per
syscall <br>
is 256 Kbytes) <br>
(:in:) var-expanded string to feed to command as input (can
be null if you don&rsquo;t want to send the process
something.) You must specify this if you want to spec&acirc;
<br>
ify an :out: variable. <br>
(:out:) var-expanded varname to place results into (must
pre-exist, can be null if you don&rsquo;t want to read the
process&rsquo;s output (yet, or at all). Limit per syscall
<br>
is 256 Kbytes. You must specify this if you want to use the
:status: variable) <br>
(:status:) if you want to keep a minion proc around, or
catch the exit status of the process, specify a var here.
The minion process&rsquo;s PID and pipes will be stored <br>
here. The program can access the proc again with another
syscall by using this var again. When the process exits,
it&rsquo;s exit code will be stored here. <br>
trap (:reason:) /trap_regex/ <br>
traps faults from both FAULT statements and program errors
occurring anywhere in the preceding bracket-block. If no
fault exists, TRAP does a SKIP to end of block. If <br>
there is a fault and the fault reason string matches the
trap_regex, the fault is trapped, and execution continues
with the line after the TRAP, otherwise the fault is <br>
passed up to the next surrounding trapped bracket block.</p>

<p style="margin-top: 1em">(:reason:) the fault message
that caused this FAULT. If it was a user fault, this is the
text the user supplied in the FAULT statement. <br>
/trap_regex/ the regex that determines what kind of faults
this TRAP will accept. Putting a wildcard here (e.g. /.*/
means that ALL faults will be trapped here. <br>
union (:out:) [:var1: :var2: ...] <br>
makes :out: contain the union of the data window segments
that contains var1, var2... plus any intervening text as
well. Any ISOLATEd var is ignored. This is non-surgical,
<br>
and does not alter the data window <br>
window &lt;flags&gt; (:w-var:) (:s-var:) /cut-regex/
/add-regex/ <br>
window slider. This deletes to and including the cut-regex
from :var: (default: use the data window), then reads adds
from std. input till add-regex (inclusive).</p>

<p style="margin-top: 1em">&lt;flags&gt; flags can be any
of</p>

<p style="margin-top: 1em">&lt;nocase&gt; ignore case when
matching cut- and add- regexes <br>
&lt;bychar&gt; check input for add-regex every character
<br>
&lt;byline&gt; check input for add-regex every line <br>
&lt;byeof&gt; wait for EOF to check for add-regex (extra
characters are kept around for later) <br>
&lt;eofends&gt; read lots of input; the input is up to the
regex match OR the contents till EOF <br>
(:w-var:) what var to window <br>
(:s-var:) what var to use for source (defaults to stdin, if
you use a source var you must specify the windowed var. <br>
/cut-regex/ var-expanded cut pattern <br>
/add-regex/ var-expanded add pattern, if absent reads till
EOF <br>
If both cut-regex and add-regex are omitted, and this window
statement is the first executable statement in the program,
then CRM114 does not wait to read a anything from <br>
standard input input before starting program execution.</p>

<p style="margin-top: 1em">A QUICK REGEX INTRO <br>
A regex is a pattern match. Do a &quot;man 7 regex&quot; for
details.</p>

<p style="margin-top: 1em">Matches are, by default
&quot;first starting point that matches, then longest match
possible that can fit&quot;.</p>

<p style="margin-top: 1em">a through z <br>
A through Z <br>
0 through 9 <br>
all match themselves. <br>
most punctuation <br>
matches itself, but check below! <br>
* <br>
repeat preceding 0 or more times <br>
+ <br>
repeat preceding 1 or more times <br>
? <br>
repeat preceding 0 or 1 time <br>
*?, +?, ?? <br>
repeat preceding, but shortest match that fits, given the
already-selected start point of the regex. (only supported
by TRE regex, not GNU regex) <br>
[abcde] <br>
any one of the letters a, b, c, d, or e <br>
[a-q] <br>
the letters a through q (just one of them) <br>
{n,m} <br>
repetition count: match the preceding at least n and no more
than m times (POSIX restricts this to a maximum of 255
repeats) <br>
[[:&lt;:]] <br>
matches at the start of a word (GNU regex only) <br>
[[:&gt;:]] <br>
matches the end of a word (GNU regex only) <br>
^ <br>
as first char of a match, matches the start of a line (ONLY
in &lt;nomultiline&gt; matches. <br>
$ <br>
as last char of a match, matches at the end of a line (ONLY
in &lt;nomultiline&gt; matches) <br>
. <br>
(a period) matches any single character (except
start-of-line or end of line &quot;virtual characters&quot;,
but it does match a newline). <br>
a|b <br>
match a or b <br>
(match) <br>
the () go away, and the string that matched inside is
available for capturing. Use \( and \) to match actual
parenthesis (the first &rsquo;&acute; tells &quot;show the
second &rsquo;&acute; to the <br>
regex engine, the second &rsquo;&acute; forces a
literalization onto the parenthesis character.</p>

<p style="margin-top: 1em">matches the N&rsquo;th
parenthesized subexpression. Remember to backslash-escape
the backslash (e.g. write this as \1) This is only if
you&rsquo;re using TRE, not GNU regex. <br>
The following are other POSIX expressions, which mostly do
what you&rsquo;d guess they&rsquo;d do from their names.</p>

<p style="margin-top: 1em">[[:alnum:]] <br>
[[:alpha:]] <br>
[[:blank:]] <br>
[[:cntrl:]] <br>
[[:digit:]] <br>
[[:lower:]] <br>
[[:upper:]] <br>
[[:graph:]] <br>
[[:print:]] <br>
[[:punct:]] <br>
[[:space:]] <br>
[[:xdigit:]]</p>

<p style="margin-top: 1em">[[:graph:]] matches any
character that puts ink on paper or lights a pixel.
[[:print:]] matches any character that moves the &quot;print
head&quot; or cursor.</p>

<p style="margin-top: 1em">NOTES ON SEQUENCE OF EVALUTATION
<br>
By default, CRM114 supports string length and mathematical
evaluation only in an EVAL statement, although it can be set
to allow these in any place where a var-expanded variable
<br>
is allowed (see the -q flag). The default value ( zero )
allows stringlength and math evaluation only in EVAL
statements, and uses non-precedence (that is, strict
left-to-right <br>
unless parenthesis are used) algebraic notation. -q 1 uses
RPN instead of algebraic, again allowing stringlength and
math evaluation only in EVAL expressions. Modes 2 and 3
allow <br>
stringlength and math evaluation in any var-expanded
expression, with non-precedence algebraic notation and RPN
notation respectively. Evaluation is always left-to-right;
there <br>
is no precedence of operators beyond the sequential passes
noted below. The evaluation is done in four sequential
passes:</p>

<p style="margin-top: 1em">1 &minus;constants like 0 d <br>
2 :*:var: variables are substituted (note the difference
between a constant like &rsquo;0 and a variable like
&quot;:*:_nl:&quot; here - constants are substituted first,
then variables are <br>
substituted.) <br>
3 :#:var: string-length operations are performed <br>
4 :@:expression: mathematical expressions are performed;
syntax is either RPN or non-precedenced (parens required)
algebraic notation. Embedded non-evaluated strings in a
mathe&acirc; <br>
matical expression is currently a no-no.</p>

<p style="margin-top: 1em">Allowed operators are: + - * / %
&gt; &lt; = only.</p>

<p style="margin-top: 1em">Only &gt;, &lt;, and = set
logical results; they also evaluate to 1 and 0 for continued
chain operations - e.g.</p>

<p style="margin-top: 1em">((:*:a: &gt; 3) + (:*:b: &gt; 5)
+ (:*:c: &gt; 9) &gt; 2)</p>

<p style="margin-top: 1em">is true IFF any of the following
is true</p>

<p style="margin-top: 1em">&Acirc;&middot; a &gt; 3 and b
&gt; 5 <br>
&Acirc;&middot; a &gt; 3 and c &gt; 9 <br>
&Acirc;&middot; b &gt; 5 and c &gt; 9</p>

<p style="margin-top: 1em">NOTES ON APPROXIMATE REGEX
MATCHING <br>
Only the TRE engine supports approximate matching. The GNU
engine does not support approximate matching.</p>

<p style="margin-top: 1em">Approximate matching is
specified similarly to a &quot;repetition count&quot; in a
regular regex, using brackets. This approximation applies to
the previous parenthesized expression (again, <br>
just like repetion counts). You can specify maximum total
changes, and how many inserts, deletes, and substitutions
you wish to allow. The minimum-error match is found and <br>
reported, if it exists within the bounds you state.</p>

<p style="margin-top: 1em">The basic syntax is:</p>

<p style="margin-top: 1em">(text-to-match){~[maxerrs]
[#maxsubsts] [+maxinserts] [-maxdeletes]}</p>

<p style="margin-top: 1em">Note that the &rsquo;~&rsquo;
(with an optional maxerr count) is required (that&rsquo;s
how we know it&rsquo;s an approximate regex rather than just
a rep-count); if you don&rsquo;t specify a max error count,
<br>
you will get the best match, if you do, the match will have
at most that many errors.</p>

<p style="margin-top: 1em">Remember that you specify the
changes to the text in the pattern necessary to make it
match the text in the string being searched.</p>

<p style="margin-top: 1em">You cannot use approximate
regexes and backrefs (like 1) in the same regex. This is a
limitation of in TRE at this point.</p>

<p style="margin-top: 1em">You can also use an inequality
in addition to the basic syntax above:</p>

<p style="margin-top: 1em">(text-to-match){~[maxerrs]
[basic-syntax] [nI + mD + oS &lt; K] }</p>

<p style="margin-top: 1em">where n, m, and o are the costs
per insertion, deletion, and substitution respectively,
&rsquo;I&rsquo;, &rsquo;D&rsquo;, and &rsquo;S&rsquo; are
indicators to tell which cost goes with which kind of error,
and K is <br>
the total cost of the errors; the cost of the errors is
always strictly less than K. Here are some examples.</p>

<p style="margin-top: 1em">(foobar) <br>
exactly matches &quot;foobar&quot; <br>
(foobar){~} <br>
finds the closest match to &quot;foobar&quot;, with the
minimum number of inserts, deletes, and substitutions.
Always succeeds. <br>
(foobar){~3} <br>
finds the closest match to &quot;foobar&quot;, with no more
than 3 inserts, deletes, or substitutions <br>
(foobar){~2 +2 -1 #1) <br>
find the closest match to &quot;foobar&quot;, with at most
two errors total, and at most two inserts, one delete, and
one substitution. <br>
(foobar){~4 #1 1i + 2d &lt; 5 } <br>
find the closest match to &quot;foobar&quot;, with at most
four errors total, at most one substitution, and with the
number of insertions plus 2x the number of deletions less
than <br>
5. <br>
(foo){~1}(bar){~1) <br>
find the closest match to &quot;foobar&quot;, with at most
one error in the &quot;foo&quot; and one error in the
&quot;bar&quot;.</p>

<p style="margin-top: 1em">OVERALL LANGUAGE NOTES <br>
Here&rsquo;s how to remember what goes where in the CRM114
language.</p>

<p style="margin-top: 1em">Unlike most computer languages,
CRM114 uses inflection (or declension) rather than position
to describe what role each part of a statement plays. The
declensions are marked by the <br>
delimiters- the /, ( and ), &lt; and &gt;, and [ and ].</p>

<p style="margin-top: 1em">By and large, you can mix up the
arguments to each kind of statement without changing their
meaning. Only the ACTION needs to be first. Other parts of
the statement can occur in <br>
any order, save that multiple (paren_args) and
/pattern_args/ must stay in their nominal order but can go
anywhere in the statement. They do not need to be
consecutive.</p>

<p style="margin-top: 1em">The parts of a CRM114 statement
are:</p>

<p style="margin-top: 1em">ACTION the verb. This is at the
start of the statement. <br>
/pattern/ the overall pattern the verb should use, analogous
to the &quot;subject&quot; of the statement. <br>
&lt;flags&gt; modifies how the ACTION does the work.
You&rsquo;d call these &quot;adverbs&quot; in human
languages. <br>
(vars) what variables to use as adjuncts in the action (what
would be called the &quot;direct objects&quot;). These can
get changed when the action happens. <br>
[limited-to] where the action is allowed to take place
(think of it as the &quot;indirect object&quot;). These are
not directly changed by the action.</p>

<p style="margin-top: 1em">SEE ALSO <br>
cssmerge(1), cssdiff(1), cssutil(1)</p>

<p style="margin-top: 1em">The CRM114 homepage is at
http://crm114.sf.net/ .</p>

<p style="margin-top: 1em">VERSION <br>
This manpage: $Id: crm114.azm,v 1.12 2004/08/19 11:10:49
vanbaal Exp $</p>

<p style="margin-top: 1em">This manpage describes the
crm114 utility as it has been described by QUICKREF.txt,
shipped with crm114-20040212-BlameJetlag.src.tar.gz. The
DESCRIPTION section is copy-and-pasted <br>
from INTRO.txt as distributed with the same source
tarball.</p>

<p style="margin-top: 1em">Converted from plain ascii to
zoem by Joost van Baal.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) 2001, 2002, 2003, 2004 William S.
Yerazunis</p>

<p style="margin-top: 1em">This program is free software;
you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free
Software Foundation; either ver&acirc; <br>
sion 2 of the License, or (at your option) any later
version.</p>

<p style="margin-top: 1em">This program is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. <br>
See the GNU General Public License for more details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program
(see COPYING); if not, check with
http://www.gnu.org/copyleft/gpl.html or write to the <br>
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111, USA.</p>

<p style="margin-top: 1em">AUTHOR <br>
William S. Yerazunis. Manpage typesetting by Joost van Baal
and Shalendra Chhabra</p>

<p style="margin-top: 1em">crm114
20040816.BlameClockworkOrange-auto.3 19 Aug 2004 crm(1)</p>
<hr>
</body>
</html>
