<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:38:08 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>SSH(1) BSD General Commands Manual SSH(1)</p>

<p style="margin-top: 1em">NAME <br>
ssh &acirc; OpenSSH SSH client (remote login program)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c
cipher_spec] [-D [bind_address:]port] [-E log_file] [-e
escape_char] [-F configfile] [-I pkcs11] [-i identity_file]
<br>
[-L [bind_address:]port:host:hostport] [-l login_name] [-m
mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q cipher |
cipher-auth | mac | kex | key] <br>
[-R [bind_address:]port:host:hostport] [-S ctl_path] [-W
host:port] [-w local_tun[:remote_tun]] [user@]hostname
[command]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
ssh (SSH client) is a program for logging into a remote
machine and for executing commands on a remote machine. It
is intended to replace rlogin and rsh, and provide secure
<br>
encrypted communications between two untrusted hosts over an
insecure network. X11 connections and arbitrary TCP ports
can also be forwarded over the secure channel.</p>

<p style="margin-top: 1em">ssh connects and logs into the
specified hostname (with optional user name). The user must
prove his/her identity to the remote machine using one of
several methods depending on <br>
the protocol version used (see below).</p>

<p style="margin-top: 1em">If command is specified, it is
executed on the remote host instead of a login shell.</p>

<p style="margin-top: 1em">The options are as follows:</p>

<p style="margin-top: 1em">-1 Forces ssh to try protocol
version 1 only.</p>

<p style="margin-top: 1em">-2 Forces ssh to try protocol
version 2 only.</p>

<p style="margin-top: 1em">-4 Forces ssh to use IPv4
addresses only.</p>

<p style="margin-top: 1em">-6 Forces ssh to use IPv6
addresses only.</p>

<p style="margin-top: 1em">-A Enables forwarding of the
authentication agent connection. This can also be specified
on a per-host basis in a configuration file.</p>

<p style="margin-top: 1em">Agent forwarding should be
enabled with caution. Users with the ability to bypass file
permissions on the remote host (for the agent&rsquo;s
UNIX-domain socket) can access the <br>
local agent through the forwarded connection. An attacker
cannot obtain key material from the agent, however they can
perform operations on the keys that enable them to <br>
authenticate using the identities loaded into the agent.</p>

<p style="margin-top: 1em">-a Disables forwarding of the
authentication agent connection.</p>

<p style="margin-top: 1em">-b bind_address <br>
Use bind_address on the local machine as the source address
of the connection. Only useful on systems with more than one
address.</p>

<p style="margin-top: 1em">-C Requests compression of all
data (including stdin, stdout, stderr, and data for
forwarded X11 and TCP connections). The compression
algorithm is the same used by gzip(1), <br>
and the &acirc;level&acirc; can be controlled by the
CompressionLevel option for protocol version 1. Compression
is desirable on modem lines and other slow connections, but
will only <br>
slow down things on fast networks. The default value can be
set on a host-by-host basis in the configuration files; see
the Compression option.</p>

<p style="margin-top: 1em">-c cipher_spec <br>
Selects the cipher specification for encrypting the
session.</p>

<p style="margin-top: 1em">Protocol version 1 allows
specification of a single cipher. The supported values are
&acirc;3des&acirc;, &acirc;blowfish&acirc;, and
&acirc;des&acirc;. 3des (triple-des) is an
encrypt-decrypt-encrypt triple <br>
with three different keys. It is believed to be secure.
blowfish is a fast block cipher; it appears very secure and
is much faster than 3des. des is only supported in <br>
the ssh client for interoperability with legacy protocol 1
implementations that do not support the 3des cipher. Its use
is strongly discouraged due to cryptographic weak&acirc;
<br>
nesses. The default is &acirc;3des&acirc;.</p>

<p style="margin-top: 1em">For protocol version 2,
cipher_spec is a comma-separated list of ciphers listed in
order of preference. See the Ciphers keyword in
ssh_config(5) for more information.</p>

<p style="margin-top: 1em">-D [bind_address:]port <br>
Specifies a local &acirc;dynamic&acirc; application-level
port forwarding. This works by allocating a socket to listen
to port on the local side, optionally bound to the specified
<br>
bind_address. Whenever a connection is made to this port,
the connection is forwarded over the secure channel, and the
application protocol is then used to determine where <br>
to connect to from the remote machine. Currently the SOCKS4
and SOCKS5 protocols are supported, and ssh will act as a
SOCKS server. Only root can forward privileged <br>
ports. Dynamic port forwardings can also be specified in the
configuration file.</p>

<p style="margin-top: 1em">IPv6 addresses can be specified
by enclosing the address in square brackets. Only the
superuser can forward privileged ports. By default, the
local port is bound in <br>
accordance with the GatewayPorts setting. However, an
explicit bind_address may be used to bind the connection to
a specific address. The bind_address of
&acirc;localhost&acirc; <br>
indicates that the listening port be bound for local use
only, while an empty address or &acirc;*&acirc; indicates
that the port should be available from all interfaces.</p>

<p style="margin-top: 1em">-E log_file <br>
Append debug logs to log_file instead of standard error.</p>

<p style="margin-top: 1em">-e escape_char <br>
Sets the escape character for sessions with a pty (default:
&acirc;~&acirc;). The escape character is only recognized at
the beginning of a line. The escape character followed by a
<br>
dot (&acirc;.&acirc;) closes the connection; followed by
control-Z suspends the connection; and followed by itself
sends the escape character once. Setting the character to
&acirc;none&acirc; <br>
disables any escapes and makes the session fully
transparent.</p>

<p style="margin-top: 1em">-F configfile <br>
Specifies an alternative per-user configuration file. If a
configuration file is given on the command line, the
system-wide configuration file (/etc/ssh/ssh_config) will
<br>
be ignored. The default for the per-user configuration file
is ~/.ssh/config.</p>

<p style="margin-top: 1em">-f Requests ssh to go to
background just before command execution. This is useful if
ssh is going to ask for passwords or passphrases, but the
user wants it in the back&acirc; <br>
ground. This implies -n. The recommended way to start X11
programs at a remote site is with something like ssh -f host
xterm.</p>

<p style="margin-top: 1em">If the ExitOnForwardFailure
configuration option is set to &acirc;yes&acirc;, then a
client started with -f will wait for all remote port
forwards to be successfully established before <br>
placing itself in the background.</p>

<p style="margin-top: 1em">-g Allows remote hosts to
connect to local forwarded ports.</p>

<p style="margin-top: 1em">-I pkcs11 <br>
Specify the PKCS#11 shared library ssh should use to
communicate with a PKCS#11 token providing the user&rsquo;s
private RSA key.</p>

<p style="margin-top: 1em">-i identity_file <br>
Selects a file from which the identity (private key) for
public key authentication is read. The default is
~/.ssh/identity for protocol version 1, and ~/.ssh/id_dsa,
<br>
~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 and ~/.ssh/id_rsa for
protocol version 2. Identity files may also be specified on
a per-host basis in the configuration file. It is <br>
possible to have multiple -i options (and multiple
identities specified in configuration files). ssh will also
try to load certificate information from the filename <br>
obtained by appending -cert.pub to identity filenames.</p>

<p style="margin-top: 1em">-K Enables GSSAPI-based
authentication and forwarding (delegation) of GSSAPI
credentials to the server.</p>

<p style="margin-top: 1em">-k Disables forwarding
(delegation) of GSSAPI credentials to the server.</p>

<p style="margin-top: 1em">-L
[bind_address:]port:host:hostport <br>
Specifies that the given port on the local (client) host is
to be forwarded to the given host and port on the remote
side. This works by allocating a socket to listen to <br>
port on the local side, optionally bound to the specified
bind_address. Whenever a connection is made to this port,
the connection is forwarded over the secure channel, <br>
and a connection is made to host port hostport from the
remote machine. Port forwardings can also be specified in
the configuration file. IPv6 addresses can be specified <br>
by enclosing the address in square brackets. Only the
superuser can forward privileged ports. By default, the
local port is bound in accordance with the GatewayPorts
set&acirc; <br>
ting. However, an explicit bind_address may be used to bind
the connection to a specific address. The bind_address of
&acirc;localhost&acirc; indicates that the listening port be
<br>
bound for local use only, while an empty address or
&acirc;*&acirc; indicates that the port should be available
from all interfaces.</p>

<p style="margin-top: 1em">-l login_name <br>
Specifies the user to log in as on the remote machine. This
also may be specified on a per-host basis in the
configuration file.</p>

<p style="margin-top: 1em">-M Places the ssh client into
&acirc;master&acirc; mode for connection sharing. Multiple
-M options places ssh into &acirc;master&acirc; mode with
confirmation required before slave connections are <br>
accepted. Refer to the description of ControlMaster in
ssh_config(5) for details.</p>

<p style="margin-top: 1em">-m mac_spec <br>
Additionally, for protocol version 2 a comma-separated list
of MAC (message authentication code) algorithms can be
specified in order of preference. See the MACs keyword <br>
for more information.</p>

<p style="margin-top: 1em">-N Do not execute a remote
command. This is useful for just forwarding ports (protocol
version 2 only).</p>

<p style="margin-top: 1em">-n Redirects stdin from
/dev/null (actually, prevents reading from stdin). This must
be used when ssh is run in the background. A common trick is
to use this to run X11 pro&acirc; <br>
grams on a remote machine. For example, ssh -n
shadows.cs.hut.fi emacs &amp; will start an emacs on
shadows.cs.hut.fi, and the X11 connection will be
automatically forwarded <br>
over an encrypted channel. The ssh program will be put in
the background. (This does not work if ssh needs to ask for
a password or passphrase; see also the -f option.)</p>

<p style="margin-top: 1em">-O ctl_cmd <br>
Control an active connection multiplexing master process.
When the -O option is specified, the ctl_cmd argument is
interpreted and passed to the master process. Valid <br>
commands are: &acirc;check&acirc; (check that the master
process is running), &acirc;forward&acirc; (request
forwardings without command execution), &acirc;cancel&acirc;
(cancel forwardings), &acirc;exit&acirc; (request <br>
the master to exit), and &acirc;stop&acirc; (request the
master to stop accepting further multiplexing requests).</p>

<p style="margin-top: 1em">-o option <br>
Can be used to give options in the format used in the
configuration file. This is useful for specifying options
for which there is no separate command-line flag. For full
<br>
details of the options listed below, and their possible
values, see ssh_config(5).</p>

<p style="margin-top: 1em">AddressFamily <br>
BatchMode <br>
BindAddress <br>
CanonicalDomains <br>
CanonicalizeFallbackLocal <br>
CanonicalizeHostname <br>
CanonicalizeMaxDots <br>
CanonicalizePermittedCNAMEs <br>
ChallengeResponseAuthentication <br>
CheckHostIP <br>
Cipher <br>
Ciphers <br>
ClearAllForwardings <br>
Compression <br>
CompressionLevel <br>
ConnectionAttempts <br>
ConnectTimeout <br>
ControlMaster <br>
ControlPath <br>
ControlPersist <br>
DynamicForward <br>
EscapeChar <br>
ExitOnForwardFailure <br>
ForwardAgent <br>
ForwardX11 <br>
ForwardX11Timeout <br>
ForwardX11Trusted <br>
GatewayPorts <br>
GlobalKnownHostsFile <br>
GSSAPIAuthentication <br>
GSSAPIKeyExchange <br>
GSSAPIClientIdentity <br>
GSSAPIDelegateCredentials <br>
GSSAPIRenewalForcesRekey <br>
GSSAPITrustDns <br>
GSSAPIKexAlgorithms <br>
HashKnownHosts <br>
Host <br>
HostbasedAuthentication <br>
HostKeyAlgorithms <br>
HostKeyAlias <br>
HostName <br>
IdentityFile <br>
IdentitiesOnly <br>
IPQoS <br>
KbdInteractiveAuthentication <br>
KbdInteractiveDevices <br>
KexAlgorithms <br>
LocalCommand <br>
LocalForward <br>
LogLevel <br>
MACs <br>
Match <br>
NoHostAuthenticationForLocalhost <br>
NumberOfPasswordPrompts <br>
PasswordAuthentication <br>
PermitLocalCommand <br>
PKCS11Provider <br>
Port <br>
PreferredAuthentications <br>
Protocol <br>
ProxyCommand <br>
ProxyUseFdpass <br>
PubkeyAuthentication <br>
RekeyLimit <br>
RemoteForward <br>
RequestTTY <br>
RhostsRSAAuthentication <br>
RSAAuthentication <br>
SendEnv <br>
ServerAliveInterval <br>
ServerAliveCountMax <br>
StrictHostKeyChecking <br>
TCPKeepAlive <br>
Tunnel <br>
TunnelDevice <br>
UsePrivilegedPort <br>
User <br>
UserKnownHostsFile <br>
VerifyHostKeyDNS <br>
VisualHostKey <br>
XAuthLocation</p>

<p style="margin-top: 1em">-p port <br>
Port to connect to on the remote host. This can be specified
on a per-host basis in the configuration file.</p>

<p style="margin-top: 1em">-Q cipher | cipher-auth | mac |
kex | key <br>
Queries ssh for the algorithms supported for the specified
version 2. The available features are: cipher (supported
symmetric ciphers), cipher-auth (supported symmetric <br>
ciphers that support authenticated encryption), mac
(supported message integrity codes), kex (key exchange
algorithms), key (key types).</p>

<p style="margin-top: 1em">-q Quiet mode. Causes most
warning and diagnostic messages to be suppressed.</p>

<p style="margin-top: 1em">-R
[bind_address:]port:host:hostport <br>
Specifies that the given port on the remote (server) host is
to be forwarded to the given host and port on the local
side. This works by allocating a socket to listen to <br>
port on the remote side, and whenever a connection is made
to this port, the connection is forwarded over the secure
channel, and a connection is made to host port hostport <br>
from the local machine.</p>

<p style="margin-top: 1em">Port forwardings can also be
specified in the configuration file. Privileged ports can be
forwarded only when logging in as root on the remote
machine. IPv6 addresses can <br>
be specified by enclosing the address in square
brackets.</p>

<p style="margin-top: 1em">By default, the listening socket
on the server will be bound to the loopback interface only.
This may be overridden by specifying a bind_address. An
empty bind_address, <br>
or the address &acirc;*&acirc;, indicates that the remote
socket should listen on all interfaces. Specifying a remote
bind_address will only succeed if the server&rsquo;s
GatewayPorts <br>
option is enabled (see sshd_config(5)).</p>

<p style="margin-top: 1em">If the port argument is
&acirc;0&acirc;, the listen port will be dynamically
allocated on the server and reported to the client at run
time. When used together with -O forward the <br>
allocated port will be printed to the standard output.</p>

<p style="margin-top: 1em">-S ctl_path <br>
Specifies the location of a control socket for connection
sharing, or the string &acirc;none&acirc; to disable
connection sharing. Refer to the description of ControlPath
and <br>
ControlMaster in ssh_config(5) for details.</p>

<p style="margin-top: 1em">-s May be used to request
invocation of a subsystem on the remote system. Subsystems
are a feature of the SSH2 protocol which facilitate the use
of SSH as a secure transport <br>
for other applications (eg. sftp(1)). The subsystem is
specified as the remote command.</p>

<p style="margin-top: 1em">-T Disable pseudo-tty
allocation.</p>

<p style="margin-top: 1em">-t Force pseudo-tty allocation.
This can be used to execute arbitrary screen-based programs
on a remote machine, which can be very useful, e.g. when
implementing menu ser&acirc; <br>
vices. Multiple -t options force tty allocation, even if ssh
has no local tty.</p>

<p style="margin-top: 1em">-V Display the version number
and exit.</p>

<p style="margin-top: 1em">-v Verbose mode. Causes ssh to
print debugging messages about its progress. This is helpful
in debugging connection, authentication, and configuration
problems. Multiple -v <br>
options increase the verbosity. The maximum is 3.</p>

<p style="margin-top: 1em">-W host:port <br>
Requests that standard input and output on the client be
forwarded to host on port over the secure channel. Implies
-N, -T, ExitOnForwardFailure and ClearAllForwardings. <br>
Works with Protocol version 2 only.</p>

<p style="margin-top: 1em">-w local_tun[:remote_tun] <br>
Requests tunnel device forwarding with the specified tun(4)
devices between the client (local_tun) and the server
(remote_tun).</p>

<p style="margin-top: 1em">The devices may be specified by
numerical ID or the keyword &acirc;any&acirc;, which uses
the next available tunnel device. If remote_tun is not
specified, it defaults to &acirc;any&acirc;. See <br>
also the Tunnel and TunnelDevice directives in
ssh_config(5). If the Tunnel directive is unset, it is set
to the default tunnel mode, which is
&acirc;point-to-point&acirc;.</p>

<p style="margin-top: 1em">-X Enables X11 forwarding. This
can also be specified on a per-host basis in a configuration
file.</p>

<p style="margin-top: 1em">X11 forwarding should be enabled
with caution. Users with the ability to bypass file
permissions on the remote host (for the user&rsquo;s X
authorization database) can access <br>
the local X11 display through the forwarded connection. An
attacker may then be able to perform activities such as
keystroke monitoring.</p>

<p style="margin-top: 1em">For this reason, X11 forwarding
is subjected to X11 SECURITY extension restrictions by
default. Please refer to the ssh -Y option and the
ForwardX11Trusted directive in <br>
ssh_config(5) for more information.</p>

<p style="margin-top: 1em">-x Disables X11 forwarding.</p>

<p style="margin-top: 1em">-Y Enables trusted X11
forwarding. Trusted X11 forwardings are not subjected to the
X11 SECURITY extension controls.</p>

<p style="margin-top: 1em">-y Send log information using
the syslog(3) system module. By default this information is
sent to stderr.</p>

<p style="margin-top: 1em">ssh may additionally obtain
configuration data from a per-user configuration file and a
system-wide configuration file. The file format and
configuration options are described in <br>
ssh_config(5).</p>

<p style="margin-top: 1em">AUTHENTICATION <br>
The OpenSSH SSH client supports SSH protocols 1 and 2. The
default is to use protocol 2 only, though this can be
changed via the Protocol option in ssh_config(5) or the -1
and -2 <br>
options (see above). Both protocols support similar
authentication methods, but protocol 2 is the default since
it provides additional mechanisms for confidentiality (the
traffic <br>
is encrypted using AES, 3DES, Blowfish, CAST128, or Arcfour)
and integrity (hmac-md5, hmac-sha1, hmac-sha2-256,
hmac-sha2-512, umac-64, umac-128, hmac-ripemd160). Protocol
1 lacks <br>
a strong mechanism for ensuring the integrity of the
connection.</p>

<p style="margin-top: 1em">The methods available for
authentication are: GSSAPI-based authentication, host-based
authentication, public key authentication,
challenge-response authentication, and password <br>
authentication. Authentication methods are tried in the
order specified above, though protocol 2 has a configuration
option to change the default order:
PreferredAuthentications.</p>

<p style="margin-top: 1em">Host-based authentication works
as follows: If the machine the user logs in from is listed
in /etc/hosts.equiv or /etc/ssh/shosts.equiv on the remote
machine, and the user names <br>
are the same on both sides, or if the files ~/.rhosts or
~/.shosts exist in the user&rsquo;s home directory on the
remote machine and contain a line containing the name of the
client <br>
machine and the name of the user on that machine, the user
is considered for login. Additionally, the server must be
able to verify the client&rsquo;s host key (see the
description of <br>
/etc/ssh/ssh_known_hosts and ~/.ssh/known_hosts, below) for
login to be permitted. This authentication method closes
security holes due to IP spoofing, DNS spoofing, and routing
<br>
spoofing. [Note to the administrator: /etc/hosts.equiv,
~/.rhosts, and the rlogin/rsh protocol in general, are
inherently insecure and should be disabled if security is
desired.]</p>

<p style="margin-top: 1em">Public key authentication works
as follows: The scheme is based on public-key cryptography,
using cryptosystems where encryption and decryption are done
using separate keys, and it <br>
is unfeasible to derive the decryption key from the
encryption key. The idea is that each user creates a
public/private key pair for authentication purposes. The
server knows the <br>
public key, and only the user knows the private key. ssh
implements public key authentication protocol automatically,
using one of the DSA, ECDSA, ED25519 or RSA algorithms.
Pro&acirc; <br>
tocol 1 is restricted to using only RSA keys, but protocol 2
may use any. The HISTORY section of ssl(8) contains a brief
discussion of the DSA and RSA algorithms.</p>

<p style="margin-top: 1em">The file ~/.ssh/authorized_keys
lists the public keys that are permitted for logging in.
When the user logs in, the ssh program tells the server
which key pair it would like to <br>
use for authentication. The client proves that it has access
to the private key and the server checks that the
corresponding public key is authorized to accept the
account.</p>

<p style="margin-top: 1em">The user creates his/her key
pair by running ssh-keygen(1). This stores the private key
in ~/.ssh/identity (protocol 1), ~/.ssh/id_dsa (protocol 2
DSA), ~/.ssh/id_ecdsa (protocol <br>
2 ECDSA), ~/.ssh/id_ed25519 (protocol 2 ED25519), or
~/.ssh/id_rsa (protocol 2 RSA) and stores the public key in
~/.ssh/identity.pub (protocol 1), ~/.ssh/id_dsa.pub
(protocol 2 <br>
DSA), ~/.ssh/id_ecdsa.pub (protocol 2 ECDSA),
~/.ssh/id_ed25519.pub (protocol 2 ED25519), or
~/.ssh/id_rsa.pub (protocol 2 RSA) in the user&rsquo;s home
directory. The user should then <br>
copy the public key to ~/.ssh/authorized_keys in his/her
home directory on the remote machine. The authorized_keys
file corresponds to the conventional ~/.rhosts file, and has
one <br>
key per line, though the lines can be very long. After this,
the user can log in without giving the password.</p>

<p style="margin-top: 1em">A variation on public key
authentication is available in the form of certificate
authentication: instead of a set of public/private keys,
signed certificates are used. This has <br>
the advantage that a single trusted certification authority
can be used in place of many public/private keys. See the
CERTIFICATES section of ssh-keygen(1) for more
information.</p>

<p style="margin-top: 1em">The most convenient way to use
public key or certificate authentication may be with an
authentication agent. See ssh-agent(1) for more
information.</p>

<p style="margin-top: 1em">Challenge-response
authentication works as follows: The server sends an
arbitrary &quot;challenge&quot; text, and prompts for a
response. Protocol 2 allows multiple challenges and <br>
responses; protocol 1 is restricted to just one
challenge/response. Examples of challenge-response
authentication include BSD Authentication (see
login.conf(5)) and PAM (some <br>
non-OpenBSD systems).</p>

<p style="margin-top: 1em">Finally, if other authentication
methods fail, ssh prompts the user for a password. The
password is sent to the remote host for checking; however,
since all communications are <br>
encrypted, the password cannot be seen by someone listening
on the network.</p>

<p style="margin-top: 1em">ssh automatically maintains and
checks a database containing identification for all hosts it
has ever been used with. Host keys are stored in
~/.ssh/known_hosts in the user&rsquo;s home <br>
directory. Additionally, the file /etc/ssh/ssh_known_hosts
is automatically checked for known hosts. Any new hosts are
automatically added to the user&rsquo;s file. If a
host&rsquo;s iden&acirc; <br>
tification ever changes, ssh warns about this and disables
password authentication to prevent server spoofing or
man-in-the-middle attacks, which could otherwise be used to
circum&acirc; <br>
vent the encryption. The StrictHostKeyChecking option can be
used to control logins to machines whose host key is not
known or has changed.</p>

<p style="margin-top: 1em">When the user&rsquo;s identity
has been accepted by the server, the server either executes
the given command, or logs into the machine and gives the
user a normal shell on the remote <br>
machine. All communication with the remote command or shell
will be automatically encrypted.</p>

<p style="margin-top: 1em">If a pseudo-terminal has been
allocated (normal login session), the user may use the
escape characters noted below.</p>

<p style="margin-top: 1em">If no pseudo-tty has been
allocated, the session is transparent and can be used to
reliably transfer binary data. On most systems, setting the
escape character to &acirc;none&acirc; will also <br>
make the session transparent even if a tty is used.</p>

<p style="margin-top: 1em">The session terminates when the
command or shell on the remote machine exits and all X11 and
TCP connections have been closed.</p>

<p style="margin-top: 1em">ESCAPE CHARACTERS <br>
When a pseudo-terminal has been requested, ssh supports a
number of functions through the use of an escape
character.</p>

<p style="margin-top: 1em">A single tilde character can be
sent as ~~ or by following the tilde by a character other
than those described below. The escape character must always
follow a newline to be <br>
interpreted as special. The escape character can be changed
in configuration files using the EscapeChar configuration
directive or on the command line by the -e option.</p>

<p style="margin-top: 1em">The supported escapes (assuming
the default &acirc;~&acirc;) are:</p>

<p style="margin-top: 1em">~. Disconnect.</p>

<p style="margin-top: 1em">~^Z Background ssh.</p>

<p style="margin-top: 1em">~# List forwarded
connections.</p>

<p style="margin-top: 1em">~&amp; Background ssh at logout
when waiting for forwarded connection / X11 sessions to
terminate.</p>

<p style="margin-top: 1em">~? Display a list of escape
characters.</p>

<p style="margin-top: 1em">~B Send a BREAK to the remote
system (only useful for SSH protocol version 2 and if the
peer supports it).</p>

<p style="margin-top: 1em">~C Open command line. Currently
this allows the addition of port forwardings using the -L,
-R and -D options (see above). It also allows the
cancellation of existing port- <br>
forwardings with -KL[bind_address:]port for local,
-KR[bind_address:]port for remote and -KD[bind_address:]port
for dynamic port-forwardings. !command allows the user to
<br>
execute a local command if the PermitLocalCommand option is
enabled in ssh_config(5). Basic help is available, using the
-h option.</p>

<p style="margin-top: 1em">~R Request rekeying of the
connection (only useful for SSH protocol version 2 and if
the peer supports it).</p>

<p style="margin-top: 1em">~V Decrease the verbosity
(LogLevel) when errors are being written to stderr.</p>

<p style="margin-top: 1em">~v Increase the verbosity
(LogLevel) when errors are being written to stderr.</p>

<p style="margin-top: 1em">TCP FORWARDING <br>
Forwarding of arbitrary TCP connections over the secure
channel can be specified either on the command line or in a
configuration file. One possible application of TCP
forwarding <br>
is a secure connection to a mail server; another is going
through firewalls.</p>

<p style="margin-top: 1em">In the example below, we look at
encrypting communication between an IRC client and server,
even though the IRC server does not directly support
encrypted communications. This <br>
works as follows: the user connects to the remote host using
ssh, specifying a port to be used to forward connections to
the remote server. After that it is possible to start the
<br>
service which is to be encrypted on the client machine,
connecting to the same local port, and ssh will encrypt and
forward the connection.</p>

<p style="margin-top: 1em">The following example tunnels an
IRC session from client machine &acirc;127.0.0.1&acirc;
(localhost) to remote server
&acirc;server.example.com&acirc;:</p>

<p style="margin-top: 1em">$ ssh -f -L 1234:localhost:6667
server.example.com sleep 10 <br>
$ irc -c &rsquo;#users&rsquo; -p 1234 pinky 127.0.0.1</p>

<p style="margin-top: 1em">This tunnels a connection to IRC
server &acirc;server.example.com&acirc;, joining channel
&acirc;#users&acirc;, nickname &acirc;pinky&acirc;, using
port 1234. It doesn&rsquo;t matter which port is used, as
long as it&rsquo;s <br>
greater than 1023 (remember, only root can open sockets on
privileged ports) and doesn&rsquo;t conflict with any ports
already in use. The connection is forwarded to port 6667 on
the <br>
remote server, since that&rsquo;s the standard port for IRC
services.</p>

<p style="margin-top: 1em">The -f option backgrounds ssh
and the remote command &acirc;sleep 10&acirc; is specified
to allow an amount of time (10 seconds, in the example) to
start the service which is to be tunnelled. <br>
If no connections are made within the time specified, ssh
will exit.</p>

<p style="margin-top: 1em">X11 FORWARDING <br>
If the ForwardX11 variable is set to &acirc;yes&acirc; (or
see the description of the -X, -x, and -Y options above) and
the user is using X11 (the DISPLAY environment variable is
set), the <br>
connection to the X11 display is automatically forwarded to
the remote side in such a way that any X11 programs started
from the shell (or command) will go through the encrypted
<br>
channel, and the connection to the real X server will be
made from the local machine. The user should not manually
set DISPLAY. Forwarding of X11 connections can be configured
on <br>
the command line or in configuration files.</p>

<p style="margin-top: 1em">The DISPLAY value set by ssh
will point to the server machine, but with a display number
greater than zero. This is normal, and happens because ssh
creates a &acirc;proxy&acirc; X server on <br>
the server machine for forwarding the connections over the
encrypted channel.</p>

<p style="margin-top: 1em">ssh will also automatically set
up Xauthority data on the server machine. For this purpose,
it will generate a random authorization cookie, store it in
Xauthority on the server, <br>
and verify that any forwarded connections carry this cookie
and replace it by the real cookie when the connection is
opened. The real authentication cookie is never sent to the
<br>
server machine (and no cookies are sent in the plain).</p>

<p style="margin-top: 1em">If the ForwardAgent variable is
set to &acirc;yes&acirc; (or see the description of the -A
and -a options above) and the user is using an
authentication agent, the connection to the agent is <br>
automatically forwarded to the remote side.</p>

<p style="margin-top: 1em">VERIFYING HOST KEYS <br>
When connecting to a server for the first time, a
fingerprint of the server&rsquo;s public key is presented to
the user (unless the option StrictHostKeyChecking has been
disabled). Fin&acirc; <br>
gerprints can be determined using ssh-keygen(1):</p>

<p style="margin-top: 1em">$ ssh-keygen -l -f
/etc/ssh/ssh_host_rsa_key</p>

<p style="margin-top: 1em">If the fingerprint is already
known, it can be matched and the key can be accepted or
rejected. Because of the difficulty of comparing host keys
just by looking at hex strings, <br>
there is also support to compare host keys visually, using
random art. By setting the VisualHostKey option to
&acirc;yes&acirc;, a small ASCII graphic gets displayed on
every login to a <br>
server, no matter if the session itself is interactive or
not. By learning the pattern a known server produces, a user
can easily find out that the host key has changed when a
<br>
completely different pattern is displayed. Because these
patterns are not unambiguous however, a pattern that looks
similar to the pattern remembered only gives a good
probability <br>
that the host key is the same, not guaranteed proof.</p>

<p style="margin-top: 1em">To get a listing of the
fingerprints along with their random art for all known
hosts, the following command line can be used:</p>

<p style="margin-top: 1em">$ ssh-keygen -lv -f
~/.ssh/known_hosts</p>

<p style="margin-top: 1em">If the fingerprint is unknown,
an alternative method of verification is available: SSH
fingerprints verified by DNS. An additional resource record
(RR), SSHFP, is added to a zone&acirc; <br>
file and the connecting client is able to match the
fingerprint with that of the key presented.</p>

<p style="margin-top: 1em">In this example, we are
connecting a client to a server,
&acirc;host.example.com&acirc;. The SSHFP resource records
should first be added to the zonefile for
host.example.com:</p>

<p style="margin-top: 1em">$ ssh-keygen -r
host.example.com.</p>

<p style="margin-top: 1em">The output lines will have to be
added to the zonefile. To check that the zone is answering
fingerprint queries:</p>

<p style="margin-top: 1em">$ dig -t SSHFP
host.example.com</p>

<p style="margin-top: 1em">Finally the client connects:</p>

<p style="margin-top: 1em">$ ssh -o &quot;VerifyHostKeyDNS
ask&quot; host.example.com <br>
[...] <br>
Matching host key fingerprint found in DNS. <br>
Are you sure you want to continue connecting (yes/no)?</p>

<p style="margin-top: 1em">See the VerifyHostKeyDNS option
in ssh_config(5) for more information.</p>

<p style="margin-top: 1em">SSH-BASED VIRTUAL PRIVATE
NETWORKS <br>
ssh contains support for Virtual Private Network (VPN)
tunnelling using the tun(4) network pseudo-device, allowing
two networks to be joined securely. The sshd_config(5)
configu&acirc; <br>
ration option PermitTunnel controls whether the server
supports this, and at what level (layer 2 or 3 traffic).</p>

<p style="margin-top: 1em">The following example would
connect client network 10.0.50.0/24 with remote network
10.0.99.0/24 using a point-to-point connection from 10.1.1.1
to 10.1.1.2, provided that the SSH <br>
server running on the gateway to the remote network, at
192.168.1.15, allows it.</p>

<p style="margin-top: 1em">On the client:</p>

<p style="margin-top: 1em"># ssh -f -w 0:1 192.168.1.15
true <br>
# ifconfig tun0 10.1.1.1 10.1.1.2 netmask 255.255.255.252
<br>
# route add 10.0.99.0/24 10.1.1.2</p>

<p style="margin-top: 1em">On the server:</p>

<p style="margin-top: 1em"># ifconfig tun1 10.1.1.2
10.1.1.1 netmask 255.255.255.252 <br>
# route add 10.0.50.0/24 10.1.1.1</p>

<p style="margin-top: 1em">Client access may be more finely
tuned via the /root/.ssh/authorized_keys file (see below)
and the PermitRootLogin server option. The following entry
would permit connections on <br>
tun(4) device 1 from user &acirc;jane&acirc; and on tun
device 2 from user &acirc;john&acirc;, if PermitRootLogin is
set to &acirc;forced-commands-only&acirc;:</p>


<p style="margin-top: 1em">tunnel=&quot;1&quot;,command=&quot;sh
/etc/netstart tun1&quot; ssh-rsa ... jane <br>
tunnel=&quot;2&quot;,command=&quot;sh /etc/netstart
tun2&quot; ssh-rsa ... john</p>

<p style="margin-top: 1em">Since an SSH-based setup entails
a fair amount of overhead, it may be more suited to
temporary setups, such as for wireless VPNs. More permanent
VPNs are better provided by tools <br>
such as ipsecctl(8) and isakmpd(8).</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
ssh will normally set the following environment
variables:</p>

<p style="margin-top: 1em">DISPLAY The DISPLAY variable
indicates the location of the X11 server. It is
automatically set by ssh to point to a value of the form
&acirc;hostname:n&acirc;, where &acirc;hostname&acirc; <br>
indicates the host where the shell runs, and &acirc;n&acirc;
is an integer &acirc;&yen; 1. ssh uses this special value to
forward X11 connections over the secure channel. The user
<br>
should normally not set DISPLAY explicitly, as that will
render the X11 connection insecure (and will require the
user to manually copy any required autho&acirc; <br>
rization cookies).</p>

<p style="margin-top: 1em">HOME Set to the path of the
user&rsquo;s home directory.</p>

<p style="margin-top: 1em">LOGNAME Synonym for USER; set
for compatibility with systems that use this variable.</p>

<p style="margin-top: 1em">MAIL Set to the path of the
user&rsquo;s mailbox.</p>

<p style="margin-top: 1em">PATH Set to the default PATH, as
specified when compiling ssh.</p>

<p style="margin-top: 1em">SSH_ASKPASS If ssh needs a
passphrase, it will read the passphrase from the current
terminal if it was run from a terminal. If ssh does not have
a terminal associated <br>
with it but DISPLAY and SSH_ASKPASS are set, it will execute
the program specified by SSH_ASKPASS and open an X11 window
to read the passphrase. This is par&acirc; <br>
ticularly useful when calling ssh from a .xsession or
related script. (Note that on some machines it may be
necessary to redirect the input from /dev/null to <br>
make this work.)</p>

<p style="margin-top: 1em">SSH_AUTH_SOCK Identifies the
path of a UNIX-domain socket used to communicate with the
agent.</p>

<p style="margin-top: 1em">SSH_CONNECTION Identifies the
client and server ends of the connection. The variable
contains four space-separated values: client IP address,
client port number, server IP <br>
address, and server port number.</p>

<p style="margin-top: 1em">SSH_ORIGINAL_COMMAND This
variable contains the original command line if a forced
command is executed. It can be used to extract the original
arguments.</p>

<p style="margin-top: 1em">SSH_USER_AUTH This variable
contains, for SSH2 only, a comma-separated list of
authentication methods that were successfuly used to
authenticate. When possible, these meth&acirc; <br>
ods are extended with detailed information on the credential
used.</p>

<p style="margin-top: 1em">SSH_TTY This is set to the name
of the tty (path to the device) associated with the current
shell or command. If the current session has no tty, this
variable is not <br>
set.</p>

<p style="margin-top: 1em">TZ This variable is set to
indicate the present time zone if it was set when the daemon
was started (i.e. the daemon passes the value on to new
connections).</p>

<p style="margin-top: 1em">USER Set to the name of the user
logging in.</p>

<p style="margin-top: 1em">Additionally, ssh reads
~/.ssh/environment, and adds lines of the format
&acirc;VARNAME=value&acirc; to the environment if the file
exists and users are allowed to change their environment.
<br>
For more information, see the PermitUserEnvironment option
in sshd_config(5).</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
SSH_USE_STRONG_RNG <br>
The reseeding of the OpenSSL random generator is usually
done from /dev/urandom. If the SSH_USE_STRONG_RNG
environment variable is set to value other than 0 the
OpenSSL <br>
random generator is reseeded from /dev/random. The number of
bytes read is defined by the SSH_USE_STRONG_RNG value.
Minimum is 14 bytes. This setting is not recommended <br>
on the computers without the hardware random generator
because insufficient entropy causes the connection to be
blocked until enough entropy is available.</p>

<p style="margin-top: 1em">FILES <br>
~/.rhosts <br>
This file is used for host-based authentication (see above).
On some machines this file may need to be world-readable if
the user&rsquo;s home directory is on an NFS partition, <br>
because sshd(8) reads it as root. Additionally, this file
must be owned by the user, and must not have write
permissions for anyone else. The recommended permission for
<br>
most machines is read/write for the user, and not accessible
by others.</p>

<p style="margin-top: 1em">~/.shosts <br>
This file is used in exactly the same way as .rhosts, but
allows host-based authentication without permitting login
with rlogin/rsh.</p>

<p style="margin-top: 1em">~/.ssh/ <br>
This directory is the default location for all user-specific
configuration and authentication information. There is no
general requirement to keep the entire contents of <br>
this directory secret, but the recommended permissions are
read/write/execute for the user, and not accessible by
others.</p>

<p style="margin-top: 1em">~/.ssh/authorized_keys <br>
Lists the public keys (DSA, ECDSA, ED25519, RSA) that can be
used for logging in as this user. The format of this file is
described in the sshd(8) manual page. This file <br>
is not highly sensitive, but the recommended permissions are
read/write for the user, and not accessible by others.</p>

<p style="margin-top: 1em">~/.ssh/config <br>
This is the per-user configuration file. The file format and
configuration options are described in ssh_config(5).
Because of the potential for abuse, this file must have <br>
strict permissions: read/write for the user, and not
writable by others.</p>

<p style="margin-top: 1em">~/.ssh/environment <br>
Contains additional definitions for environment variables;
see ENVIRONMENT, above.</p>

<p style="margin-top: 1em">~/.ssh/identity <br>
~/.ssh/id_dsa <br>
~/.ssh/id_ecdsa <br>
~/.ssh/id_ed25519 <br>
~/.ssh/id_rsa <br>
Contains the private key for authentication. These files
contain sensitive data and should be readable by the user
but not accessible by others (read/write/execute). ssh <br>
will simply ignore a private key file if it is accessible by
others. It is possible to specify a passphrase when
generating the key which will be used to encrypt the
sen&acirc; <br>
sitive part of this file using 3DES.</p>

<p style="margin-top: 1em">~/.ssh/identity.pub <br>
~/.ssh/id_dsa.pub <br>
~/.ssh/id_ecdsa.pub <br>
~/.ssh/id_ed25519.pub <br>
~/.ssh/id_rsa.pub <br>
Contains the public key for authentication. These files are
not sensitive and can (but need not) be readable by
anyone.</p>

<p style="margin-top: 1em">~/.ssh/known_hosts <br>
Contains a list of host keys for all hosts the user has
logged into that are not already in the systemwide list of
known host keys. See sshd(8) for further details of the <br>
format of this file.</p>

<p style="margin-top: 1em">~/.ssh/rc <br>
Commands in this file are executed by ssh when the user logs
in, just before the user&rsquo;s shell (or command) is
started. See the sshd(8) manual page for more
information.</p>

<p style="margin-top: 1em">/etc/hosts.equiv <br>
This file is for host-based authentication (see above). It
should only be writable by root.</p>

<p style="margin-top: 1em">/etc/ssh/shosts.equiv <br>
This file is used in exactly the same way as hosts.equiv,
but allows host-based authentication without permitting
login with rlogin/rsh.</p>

<p style="margin-top: 1em">/etc/ssh/ssh_config <br>
Systemwide configuration file. The file format and
configuration options are described in ssh_config(5).</p>

<p style="margin-top: 1em">/etc/ssh/ssh_host_key <br>
/etc/ssh/ssh_host_dsa_key <br>
/etc/ssh/ssh_host_ecdsa_key <br>
/etc/ssh/ssh_host_ed25519_key <br>
/etc/ssh/ssh_host_rsa_key <br>
These files contain the private parts of the host keys and
are used for host-based authentication. If protocol version
1 is used, ssh must be setuid root, since the host <br>
key is readable only by root. For protocol version 2, ssh
uses ssh-keysign(8) to access the host keys, eliminating the
requirement that ssh be setuid root when host-based <br>
authentication is used. By default ssh is not setuid
root.</p>

<p style="margin-top: 1em">/etc/ssh/ssh_known_hosts <br>
Systemwide list of known host keys. This file should be
prepared by the system administrator to contain the public
host keys of all machines in the organization. It <br>
should be world-readable. See sshd(8) for further details of
the format of this file.</p>

<p style="margin-top: 1em">/etc/ssh/sshrc <br>
Commands in this file are executed by ssh when the user logs
in, just before the user&rsquo;s shell (or command) is
started. See the sshd(8) manual page for more
information.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
ssh exits with the exit status of the remote command or with
255 if an error occurred.</p>

<p style="margin-top: 1em">IPV6 <br>
IPv6 address can be used everywhere where IPv4 address. In
all entries must be the IPv6 address enclosed in square
brackets. Note: The square brackets are metacharacters for
the <br>
shell and must be escaped in shell.</p>

<p style="margin-top: 1em">SEE ALSO <br>
scp(1), sftp(1), ssh-add(1), ssh-agent(1), ssh-keygen(1),
ssh-keyscan(1), tun(4), hosts.equiv(5), ssh_config(5),
ssh-keysign(8), sshd(8)</p>

<p style="margin-top: 1em">STANDARDS <br>
S. Lehtinen and C. Lonvick, The Secure Shell (SSH) Protocol
Assigned Numbers, RFC 4250, January 2006.</p>

<p style="margin-top: 1em">T. Ylonen and C. Lonvick, The
Secure Shell (SSH) Protocol Architecture, RFC 4251, January
2006.</p>

<p style="margin-top: 1em">T. Ylonen and C. Lonvick, The
Secure Shell (SSH) Authentication Protocol, RFC 4252,
January 2006.</p>

<p style="margin-top: 1em">T. Ylonen and C. Lonvick, The
Secure Shell (SSH) Transport Layer Protocol, RFC 4253,
January 2006.</p>

<p style="margin-top: 1em">T. Ylonen and C. Lonvick, The
Secure Shell (SSH) Connection Protocol, RFC 4254, January
2006.</p>

<p style="margin-top: 1em">J. Schlyter and W. Griffin,
Using DNS to Securely Publish Secure Shell (SSH) Key
Fingerprints, RFC 4255, January 2006.</p>

<p style="margin-top: 1em">F. Cusack and M. Forssen,
Generic Message Exchange Authentication for the Secure Shell
Protocol (SSH), RFC 4256, January 2006.</p>

<p style="margin-top: 1em">J. Galbraith and P. Remaker, The
Secure Shell (SSH) Session Channel Break Extension, RFC
4335, January 2006.</p>

<p style="margin-top: 1em">M. Bellare, T. Kohno, and C.
Namprempre, The Secure Shell (SSH) Transport Layer
Encryption Modes, RFC 4344, January 2006.</p>

<p style="margin-top: 1em">B. Harris, Improved Arcfour
Modes for the Secure Shell (SSH) Transport Layer Protocol,
RFC 4345, January 2006.</p>

<p style="margin-top: 1em">M. Friedl, N. Provos, and W.
Simpson, Diffie-Hellman Group Exchange for the Secure Shell
(SSH) Transport Layer Protocol, RFC 4419, March 2006.</p>

<p style="margin-top: 1em">J. Galbraith and R. Thayer, The
Secure Shell (SSH) Public Key File Format, RFC 4716,
November 2006.</p>

<p style="margin-top: 1em">D. Stebila and J. Green,
Elliptic Curve Algorithm Integration in the Secure Shell
Transport Layer, RFC 5656, December 2009.</p>

<p style="margin-top: 1em">A. Perrig and D. Song, Hash
Visualization: a New Technique to improve Real-World
Security, 1999, International Workshop on Cryptographic
Techniques and E-Commerce (CrypTEC &rsquo;99).</p>

<p style="margin-top: 1em">AUTHORS <br>
OpenSSH is a derivative of the original and free ssh 1.2.12
release by Tatu Ylonen. Aaron Campbell, Bob Beck, Markus
Friedl, Niels Provos, Theo de Raadt and Dug Song removed
many <br>
bugs, re-added newer features and created OpenSSH. Markus
Friedl contributed the support for SSH protocol versions 1.5
and 2.0.</p>

<p style="margin-top: 1em">BSD December 7, 2013 BSD</p>
<hr>
</body>
</html>
