<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:51 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLFAQ8(1) Perl Programmers Reference Guide
PERLFAQ8(1)</p>

<p style="margin-top: 1em">NAME <br>
perlfaq8 - System Interaction</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This section of the Perl FAQ covers questions involving
operating system interaction. Topics include interprocess
communication (IPC), control over the user-interface
(keyboard, <br>
screen and pointing devices), and most anything else not
related to data manipulation.</p>

<p style="margin-top: 1em">Read the FAQs and documentation
specific to the port of perl to your operating system (eg,
perlvms, perlplan9, ...). These should contain more detailed
information on the <br>
vagaries of your perl.</p>

<p style="margin-top: 1em">How do I find out which
operating system I&rsquo;m running under? <br>
The $^O variable ($OSNAME if you use &quot;English&quot;)
contains an indication of the name of the operating system
(not its release number) that your perl binary was built
for.</p>

<p style="margin-top: 1em">How come exec() doesn&rsquo;t
return? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">The &quot;exec&quot;
function&rsquo;s job is to turn your process into another
command and never to return. If that&rsquo;s not what you
want to do, don&rsquo;t use &quot;exec&quot;. :)</p>

<p style="margin-top: 1em">If you want to run an external
command and still keep your Perl process going, look at a
piped &quot;open&quot;, &quot;fork&quot;, or
&quot;system&quot;.</p>

<p style="margin-top: 1em">How do I do fancy stuff with the
keyboard/screen/mouse? <br>
How you access/control keyboards, screens, and pointing
devices (&quot;mice&quot;) is system-dependent. Try the
following modules:</p>

<p style="margin-top: 1em">Keyboard <br>
Term::Cap Standard perl distribution <br>
Term::ReadKey CPAN <br>
Term::ReadLine::Gnu CPAN <br>
Term::ReadLine::Perl CPAN <br>
Term::Screen CPAN</p>

<p style="margin-top: 1em">Screen <br>
Term::Cap Standard perl distribution <br>
Curses CPAN <br>
Term::ANSIColor CPAN</p>

<p style="margin-top: 1em">Mouse <br>
Tk CPAN <br>
Wx CPAN <br>
Gtk2 CPAN <br>
Qt4 kdebindings4 package</p>

<p style="margin-top: 1em">Some of these specific cases are
shown as examples in other answers in this section of the
perlfaq.</p>

<p style="margin-top: 1em">How do I print something out in
color? <br>
In general, you don&rsquo;t, because you don&rsquo;t know
whether the recipient has a color-aware display device. If
you know that they have an ANSI terminal that understands
color, you can <br>
use the Term::ANSIColor module from CPAN:</p>

<p style="margin-top: 1em">use Term::ANSIColor; <br>
print color(&quot;red&quot;), &quot;Stop!0,
color(&quot;reset&quot;); <br>
print color(&quot;green&quot;), &quot;Go!0,
color(&quot;reset&quot;);</p>

<p style="margin-top: 1em">Or like this:</p>

<p style="margin-top: 1em">use Term::ANSIColor
qw(:constants); <br>
print RED, &quot;Stop!0, RESET; <br>
print GREEN, &quot;Go!0, RESET;</p>

<p style="margin-top: 1em">How do I read just one key
without waiting for a return key? <br>
Controlling input buffering is a remarkably system-dependent
matter. On many systems, you can just use the stty command
as shown in &quot;getc&quot; in perlfunc, but as you see,
that&rsquo;s <br>
already getting you into portability snags.</p>

<p style="margin-top: 1em">open(TTY,
&quot;+&lt;/dev/tty&quot;) or die &quot;no tty: $!&quot;;
<br>
system &quot;stty cbreak &lt;/dev/tty &gt;/dev/tty
2&gt;&amp;1&quot;; <br>
$key = getc(TTY); # perhaps this works <br>
# OR ELSE <br>
sysread(TTY, $key, 1); # probably this does <br>
system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty
2&gt;&amp;1&quot;;</p>

<p style="margin-top: 1em">The Term::ReadKey module from
CPAN offers an easy-to-use interface that should be more
efficient than shelling out to stty for each key. It even
includes limited support for <br>
Windows.</p>

<p style="margin-top: 1em">use Term::ReadKey; <br>
ReadMode(&rsquo;cbreak&rsquo;); <br>
$key = ReadKey(0); <br>
ReadMode(&rsquo;normal&rsquo;);</p>

<p style="margin-top: 1em">However, using the code requires
that you have a working C compiler and can use it to build
and install a CPAN module. Here&rsquo;s a solution using the
standard POSIX module, which is <br>
already on your system (assuming your system supports
POSIX).</p>

<p style="margin-top: 1em">use HotKey; <br>
$key = readkey();</p>

<p style="margin-top: 1em">And here&rsquo;s the
&quot;HotKey&quot; module, which hides the somewhat
mystifying calls to manipulate the POSIX termios
structures.</p>

<p style="margin-top: 1em"># HotKey.pm <br>
package HotKey;</p>

<p style="margin-top: 1em">use strict; <br>
use warnings;</p>

<p style="margin-top: 1em">use parent
&rsquo;Exporter&rsquo;; <br>
our @EXPORT = qw(cbreak cooked readkey);</p>

<p style="margin-top: 1em">use POSIX qw(:termios_h); <br>
my ($term, $oterm, $echo, $noecho, $fd_stdin);</p>

<p style="margin-top: 1em">$fd_stdin = fileno(STDIN); <br>
$term = POSIX::Termios-&gt;new(); <br>
$term-&gt;getattr($fd_stdin); <br>
$oterm = $term-&gt;getlflag();</p>

<p style="margin-top: 1em">$echo = ECHO | ECHOK | ICANON;
<br>
$noecho = $oterm &amp; ~$echo;</p>

<p style="margin-top: 1em">sub cbreak { <br>
$term-&gt;setlflag($noecho); # ok, so i don&rsquo;t want
echo either <br>
$term-&gt;setcc(VTIME, 1); <br>
$term-&gt;setattr($fd_stdin, TCSANOW); <br>
}</p>

<p style="margin-top: 1em">sub cooked { <br>
$term-&gt;setlflag($oterm); <br>
$term-&gt;setcc(VTIME, 0); <br>
$term-&gt;setattr($fd_stdin, TCSANOW); <br>
}</p>

<p style="margin-top: 1em">sub readkey { <br>
my $key = &rsquo;&rsquo;; <br>
cbreak(); <br>
sysread(STDIN, $key, 1); <br>
cooked(); <br>
return $key; <br>
}</p>

<p style="margin-top: 1em">END { cooked() }</p>

<p style="margin-top: 1em">1;</p>

<p style="margin-top: 1em">How do I check whether input is
ready on the keyboard? <br>
The easiest way to do this is to read a key in nonblocking
mode with the Term::ReadKey module from CPAN, passing it an
argument of -1 to indicate not to block:</p>

<p style="margin-top: 1em">use Term::ReadKey;</p>


<p style="margin-top: 1em">ReadMode(&rsquo;cbreak&rsquo;);</p>

<p style="margin-top: 1em">if (defined (my $char =
ReadKey(-1)) ) { <br>
# input was waiting and it was $char <br>
} else { <br>
# no input was waiting <br>
}</p>

<p style="margin-top: 1em">ReadMode(&rsquo;normal&rsquo;);
# restore normal tty settings</p>

<p style="margin-top: 1em">How do I clear the screen? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">To clear the screen, you just
have to print the special sequence that tells the terminal
to clear the screen. Once you have that sequence, output it
when you want to clear the <br>
screen.</p>

<p style="margin-top: 1em">You can use the Term::ANSIScreen
module to get the special sequence. Import the
&quot;cls&quot; function (or the &quot;:screen&quot;
tag):</p>

<p style="margin-top: 1em">use Term::ANSIScreen qw(cls);
<br>
my $clear_screen = cls();</p>

<p style="margin-top: 1em">print $clear_screen;</p>

<p style="margin-top: 1em">The Term::Cap module can also
get the special sequence if you want to deal with the
low-level details of terminal control. The &quot;Tputs&quot;
method returns the string for the given <br>
capability:</p>

<p style="margin-top: 1em">use Term::Cap;</p>

<p style="margin-top: 1em">my $terminal =
Term::Cap-&gt;Tgetent( { OSPEED =&gt; 9600 } ); <br>
my $clear_string =
$terminal-&gt;Tputs(&rsquo;cl&rsquo;);</p>

<p style="margin-top: 1em">print $clear_screen;</p>

<p style="margin-top: 1em">On Windows, you can use the
Win32::Console module. After creating an object for the
output filehandle you want to affect, call the
&quot;Cls&quot; method:</p>

<p style="margin-top: 1em">Win32::Console;</p>

<p style="margin-top: 1em">my $OUT =
Win32::Console-&gt;new(STD_OUTPUT_HANDLE); <br>
my $clear_string = $OUT-&gt;Cls;</p>

<p style="margin-top: 1em">print $clear_screen;</p>

<p style="margin-top: 1em">If you have a command-line
program that does the job, you can call it in backticks to
capture whatever it outputs so you can use it later:</p>

<p style="margin-top: 1em">my $clear_string =
&lsquo;clear&lsquo;;</p>

<p style="margin-top: 1em">print $clear_string;</p>

<p style="margin-top: 1em">How do I get the screen size?
<br>
If you have Term::ReadKey module installed from CPAN, you
can use it to fetch the width and height in characters and
in pixels:</p>

<p style="margin-top: 1em">use Term::ReadKey; <br>
my ($wchar, $hchar, $wpixels, $hpixels) =
GetTerminalSize();</p>

<p style="margin-top: 1em">This is more portable than the
raw &quot;ioctl&quot;, but not as illustrative:</p>

<p style="margin-top: 1em">require
&rsquo;sys/ioctl.ph&rsquo;; <br>
die &quot;no TIOCGWINSZ &quot; unless defined
&amp;TIOCGWINSZ; <br>
open(my $tty_fh, &quot;+&lt;/dev/tty&quot;) or die &quot;No
tty: $!&quot;; <br>
unless (ioctl($tty_fh, &amp;TIOCGWINSZ,
$winsize=&rsquo;&rsquo;)) { <br>
die sprintf &quot;$0: ioctl TIOCGWINSZ (%08x: $!)0,
&amp;TIOCGWINSZ; <br>
} <br>
my ($row, $col, $xpixel, $ypixel) = unpack(&rsquo;S4&rsquo;,
$winsize); <br>
print &quot;(row,col) = ($row,$col)&quot;; <br>
print &quot; (xpixel,ypixel) = ($xpixel,$ypixel)&quot; if
$xpixel || $ypixel; <br>
print &quot;0;</p>

<p style="margin-top: 1em">How do I ask the user for a
password? <br>
(This question has nothing to do with the web. See a
different FAQ for that.)</p>

<p style="margin-top: 1em">There&rsquo;s an example of this
in &quot;crypt&quot; in perlfunc). First, you put the
terminal into &quot;no echo&quot; mode, then just read the
password normally. You may do this with an old-style <br>
&quot;ioctl()&quot; function, POSIX terminal control (see
POSIX or its documentation the Camel Book), or a call to the
stty program, with varying degrees of portability.</p>

<p style="margin-top: 1em">You can also do this for most
systems using the Term::ReadKey module from CPAN, which is
easier to use and in theory more portable.</p>

<p style="margin-top: 1em">use Term::ReadKey;</p>

<p style="margin-top: 1em">ReadMode(&rsquo;noecho&rsquo;);
<br>
my $password = ReadLine(0);</p>

<p style="margin-top: 1em">How do I read and write the
serial port? <br>
This depends on which operating system your program is
running on. In the case of Unix, the serial ports will be
accessible through files in &quot;/dev&quot;; on other
systems, device <br>
names will doubtless differ. Several problem areas common to
all device interaction are the following:</p>

<p style="margin-top: 1em">lockfiles <br>
Your system may use lockfiles to control multiple access.
Make sure you follow the correct protocol. Unpredictable
behavior can result from multiple processes reading from
<br>
one device.</p>

<p style="margin-top: 1em">open mode <br>
If you expect to use both read and write operations on the
device, you&rsquo;ll have to open it for update (see
&quot;open&quot; in perlfunc for details). You may wish to
open it without <br>
running the risk of blocking by using &quot;sysopen()&quot;
and &quot;O_RDWR|O_NDELAY|O_NOCTTY&quot; from the Fcntl
module (part of the standard perl distribution). See
&quot;sysopen&quot; in perlfunc for <br>
more on this approach.</p>

<p style="margin-top: 1em">end of line &quot; at the end of
each <br>
Some devices will be expecting a &quot; &quot; and &quot;0
are line rather than a &quot;0. In some ports of perl,
&quot; different from their usual (Unix) ASCII values of
<br>
&quot; 15&quot; and &quot; 12&quot;. You may have to give
the numeric values you want directly, using octal (&quot;
15&quot;), hex (&quot;0x0D&quot;), or as a control-character
specification (&quot; <br>
print DEV &quot;atv1 12&quot;; # wrong, for some devices
<br>
print DEV &quot;atv1 15&quot;; # right, for some devices</p>

<p style="margin-top: 1em">Even though with normal text
files a &quot;0 will do the trick, there is still no unified
scheme for terminating a line that is portable between Unix,
DOS/Win, and Macintosh, <br>
except to terminate ALL line ends with &quot; 15 12&quot;,
and strip what you don&rsquo;t need from the output. This
applies especially to socket I/O and autoflushing, discussed
next.</p>

<p style="margin-top: 1em">flushing output <br>
If you expect characters to get to your device when you
&quot;print()&quot; them, you&rsquo;ll want to autoflush
that filehandle. You can use &quot;select()&quot; and the $|
variable to control <br>
autoflushing (see &quot;$|&quot; in perlvar and
&quot;select&quot; in perlfunc, or perlfaq5, &quot;How do I
flush/unbuffer an output filehandle? Why must I do
this?&quot;):</p>

<p style="margin-top: 1em">my $old_handle =
select($dev_fh); <br>
$| = 1; <br>
select($old_handle);</p>

<p style="margin-top: 1em">You&rsquo;ll also see code that
does this without a temporary variable, as in</p>

<p style="margin-top: 1em">select((select($deb_handle), $|
= 1)[0]);</p>

<p style="margin-top: 1em">Or if you don&rsquo;t mind
pulling in a few thousand lines of code just because
you&rsquo;re afraid of a little $| variable:</p>

<p style="margin-top: 1em">use IO::Handle; <br>
$dev_fh-&gt;autoflush(1);</p>

<p style="margin-top: 1em">As mentioned in the previous
item, this still doesn&rsquo;t work when using socket I/O
between Unix and Macintosh. You&rsquo;ll need to hard code
your line terminators, in that case.</p>

<p style="margin-top: 1em">non-blocking input <br>
If you are doing a blocking &quot;read()&quot; or
&quot;sysread()&quot;, you&rsquo;ll have to arrange for an
alarm handler to provide a timeout (see &quot;alarm&quot; in
perlfunc). If you have a non-blocking <br>
open, you&rsquo;ll likely have a non-blocking read, which
means you may have to use a 4-arg &quot;select()&quot; to
determine whether I/O is ready on that device (see
&quot;select&quot; in perlfunc.</p>

<p style="margin-top: 1em">While trying to read from his
caller-id box, the notorious Jamie Zawinski
&quot;&lt;jwz@netscape.com&gt;&quot;, after much gnashing of
teeth and fighting with &quot;sysread&quot;,
&quot;sysopen&quot;, POSIX&rsquo;s <br>
&quot;tcgetattr&quot; business, and various other functions
that go bump in the night, finally came up with this:</p>

<p style="margin-top: 1em">sub open_modem { <br>
use IPC::Open2; <br>
my $stty = &lsquo;/bin/stty -g&lsquo;; <br>
open2( ODEM_IN, ODEM_OUT, &quot;cu -l$modem_device -s2400
2&gt;&amp;1&quot;); <br>
# starting cu hoses /dev/tty&rsquo;s stty settings, even
when it has <br>
# been opened on a pipe... <br>
system(&quot;/bin/stty $stty&quot;); <br>
$_ = &lt;MODEM_IN&gt;; <br>
chomp; <br>
if ( !m/^Connected/ ) { <br>
print STDERR &quot;$0: cu printed &lsquo;$_&rsquo; instead
of &lsquo;Connected&rsquo;0; <br>
} <br>
}</p>

<p style="margin-top: 1em">How do I decode encrypted
password files? <br>
You spend lots and lots of money on dedicated hardware, but
this is bound to get you talked about.</p>

<p style="margin-top: 1em">Seriously, you can&rsquo;t if
they are Unix password files--the Unix password system
employs one-way encryption. It&rsquo;s more like hashing
than encryption. The best you can do is check <br>
whether something else hashes to the same string. You
can&rsquo;t turn a hash back into the original string.
Programs like Crack can forcibly (and intelligently) try to
guess <br>
passwords, but don&rsquo;t (can&rsquo;t) guarantee quick
success.</p>

<p style="margin-top: 1em">If you&rsquo;re worried about
users selecting bad passwords, you should proactively check
when they try to change their password (by modifying
passwd(1), for example).</p>

<p style="margin-top: 1em">How do I start a process in the
background? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">There&rsquo;s not a single way
to run code in the background so you don&rsquo;t have to
wait for it to finish before your program moves on to other
tasks. Process management depends on your <br>
particular operating system, and many of the techniques are
covered in perlipc.</p>

<p style="margin-top: 1em">Several CPAN modules may be able
to help, including IPC::Open2 or IPC::Open3, IPC::Run,
Parallel::Jobs, Parallel::ForkManager, POE,
Proc::Background, and Win32::Process. There <br>
are many other modules you might use, so check those
namespaces for other options too.</p>

<p style="margin-top: 1em">If you are on a Unix-like
system, you might be able to get away with a system call
where you put an &quot;&amp;&quot; on the end of the
command:</p>

<p style="margin-top: 1em">system(&quot;cmd
&amp;&quot;)</p>

<p style="margin-top: 1em">You can also try using
&quot;fork&quot;, as described in perlfunc (although this is
the same thing that many of the modules will do for
you).</p>

<p style="margin-top: 1em">STDIN, STDOUT, and STDERR are
shared <br>
Both the main process and the backgrounded one (the
&quot;child&quot; process) share the same STDIN, STDOUT and
STDERR filehandles. If both try to access them at once,
strange things <br>
can happen. You may want to close or reopen these for the
child. You can get around this with &quot;open&quot;ing a
pipe (see &quot;open&quot; in perlfunc) but on some systems
this means that <br>
the child process cannot outlive the parent.</p>

<p style="margin-top: 1em">Signals <br>
You&rsquo;ll have to catch the SIGCHLD signal, and possibly
SIGPIPE too. SIGCHLD is sent when the backgrounded process
finishes. SIGPIPE is sent when you write to a filehandle
<br>
whose child process has closed (an untrapped SIGPIPE can
cause your program to silently die). This is not an issue
with &quot;system(&quot;cmd&amp;&quot;)&quot;.</p>

<p style="margin-top: 1em">Zombies <br>
You have to be prepared to &quot;reap&quot; the child
process when it finishes.</p>

<p style="margin-top: 1em">$SIG{CHLD} = sub { wait };</p>

<p style="margin-top: 1em">$SIG{CHLD} =
&rsquo;IGNORE&rsquo;;</p>

<p style="margin-top: 1em">You can also use a double fork.
You immediately &quot;wait()&quot; for your first child, and
the init daemon will &quot;wait()&quot; for your grandchild
once it exits.</p>

<p style="margin-top: 1em">unless ($pid = fork) { <br>
unless (fork) { <br>
exec &quot;what you really wanna do&quot;; <br>
die &quot;exec failed!&quot;; <br>
} <br>
exit 0; <br>
} <br>
waitpid($pid, 0);</p>

<p style="margin-top: 1em">See &quot;Signals&quot; in
perlipc for other examples of code to do this. Zombies are
not an issue with &quot;system(&quot;prog
&amp;&quot;)&quot;.</p>

<p style="margin-top: 1em">How do I trap control
characters/signals? <br>
You don&rsquo;t actually &quot;trap&quot; a control
character. Instead, that character generates a signal which
is sent to your terminal&rsquo;s currently foregrounded
process group, which you then <br>
trap in your process. Signals are documented in
&quot;Signals&quot; in perlipc and the section on
&quot;Signals&quot; in the Camel.</p>

<p style="margin-top: 1em">You can set the values of the
%SIG hash to be the functions you want to handle the signal.
After perl catches the signal, it looks in %SIG for a key
with the same name as the <br>
signal, then calls the subroutine value for that key.</p>

<p style="margin-top: 1em"># as an anonymous subroutine</p>

<p style="margin-top: 1em">$SIG{INT} = sub {
syswrite(STDERR, &quot;ouch0, 5 ) };</p>

<p style="margin-top: 1em"># or a reference to a
function</p>

<p style="margin-top: 1em">$SIG{INT} = ouch;</p>

<p style="margin-top: 1em"># or the name of the function as
a string</p>

<p style="margin-top: 1em">$SIG{INT} =
&quot;ouch&quot;;</p>

<p style="margin-top: 1em">Perl versions before 5.8 had in
its C source code signal handlers which would catch the
signal and possibly run a Perl function that you had set in
%SIG. This violated the rules <br>
of signal handling at that level causing perl to dump core.
Since version 5.8.0, perl looks at %SIG after the signal has
been caught, rather than while it is being caught. <br>
Previous versions of this answer were incorrect.</p>

<p style="margin-top: 1em">How do I modify the shadow
password file on a Unix system? <br>
If perl was installed correctly and your shadow library was
written properly, the &quot;getpw*()&quot; functions
described in perlfunc should in theory provide (read-only)
access to <br>
entries in the shadow password file. To change the file,
make a new shadow password file (the format varies from
system to system--see passwd(1) for specifics) and use <br>
pwd_mkdb(8) to install it (see pwd_mkdb(8) for more
details).</p>

<p style="margin-top: 1em">How do I set the time and date?
<br>
Assuming you&rsquo;re running under sufficient permissions,
you should be able to set the system-wide date and time by
running the date(1) program. (There is no way to set the
time and <br>
date on a per-process basis.) This mechanism will work for
Unix, MS-DOS, Windows, and NT; the VMS equivalent is
&quot;set time&quot;.</p>

<p style="margin-top: 1em">However, if all you want to do
is change your time zone, you can probably get away with
setting an environment variable:</p>

<p style="margin-top: 1em">$ENV{TZ} = &quot;MST7MDT&quot;;
# Unixish <br>

$ENV{&rsquo;SYS$TIMEZONE_DIFFERENTIAL&rsquo;}=&quot;-5&quot;
# vms <br>
system(&rsquo;trn&rsquo;,
&rsquo;comp.lang.perl.misc&rsquo;);</p>

<p style="margin-top: 1em">How can I sleep() or alarm() for
under a second? <br>
If you want finer granularity than the 1 second that the
&quot;sleep()&quot; function provides, the easiest way is to
use the &quot;select()&quot; function as documented in
&quot;select&quot; in perlfunc. Try <br>
the Time::HiRes and the BSD::Itimer modules (available from
CPAN, and starting from Perl 5.8 Time::HiRes is part of the
standard distribution).</p>

<p style="margin-top: 1em">How can I measure time under a
second? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">The Time::HiRes module (part of
the standard distribution as of Perl 5.8) measures time with
the &quot;gettimeofday()&quot; system call, which returns
the time in microseconds since the <br>
epoch. If you can&rsquo;t install Time::HiRes for older
Perls and you are on a Unixish system, you may be able to
call gettimeofday(2) directly. See &quot;syscall&quot; in
perlfunc.</p>

<p style="margin-top: 1em">How can I do an atexit() or
setjmp()/longjmp()? (Exception handling) <br>
You can use the &quot;END&quot; block to simulate
&quot;atexit()&quot;. Each package&rsquo;s &quot;END&quot;
block is called when the program or thread ends. See the
perlmod manpage for more details about &quot;END&quot; <br>
blocks.</p>

<p style="margin-top: 1em">For example, you can use this to
make sure your filter program managed to finish its output
without filling up the disk:</p>

<p style="margin-top: 1em">END { <br>
close(STDOUT) || die &quot;stdout close failed: $!&quot;;
<br>
}</p>

<p style="margin-top: 1em">The &quot;END&quot; block
isn&rsquo;t called when untrapped signals kill the program,
though, so if you use &quot;END&quot; blocks you should also
use</p>

<p style="margin-top: 1em">use sigtrap qw(die
normal-signals);</p>

<p style="margin-top: 1em">Perl&rsquo;s exception-handling
mechanism is its &quot;eval()&quot; operator. You can use
&quot;eval()&quot; as &quot;setjmp&quot; and
&quot;die()&quot; as &quot;longjmp&quot;. For details of
this, see the section on signals, <br>
especially the time-out handler for a blocking
&quot;flock()&quot; in &quot;Signals&quot; in perlipc or the
section on &quot;Signals&quot; in Programming Perl.</p>

<p style="margin-top: 1em">If exception handling is all
you&rsquo;re interested in, use one of the many CPAN modules
that handle exceptions, such as Try::Tiny.</p>

<p style="margin-top: 1em">If you want the
&quot;atexit()&quot; syntax (and an &quot;rmexit()&quot; as
well), try the &quot;AtExit&quot; module available from
CPAN.</p>

<p style="margin-top: 1em">Why doesn&rsquo;t my sockets
program work under System V (Solaris)? What does the error
message &quot;Protocol not supported&quot; mean? <br>
Some Sys-V based systems, notably Solaris 2.X, redefined
some of the standard socket constants. Since these were
constant across all architectures, they were often hardwired
into <br>
perl code. The proper way to deal with this is to &quot;use
Socket&quot; to get the correct values.</p>

<p style="margin-top: 1em">Note that even though SunOS and
Solaris are binary compatible, these values are different.
Go figure.</p>

<p style="margin-top: 1em">How can I call my system&rsquo;s
unique C functions from Perl? <br>
In most cases, you write an external module to do it--see
the answer to &quot;Where can I learn about linking C with
Perl? [h2xs, xsubpp]&quot;. However, if the function is a
system call, <br>
and your system supports &quot;syscall()&quot;, you can use
the &quot;syscall&quot; function (documented in
perlfunc).</p>

<p style="margin-top: 1em">Remember to check the modules
that came with your distribution, and CPAN as well--someone
may already have written a module to do it. On Windows, try
Win32::API. On Macs, try <br>
Mac::Carbon. If no module has an interface to the C
function, you can inline a bit of C in your Perl source with
Inline::C.</p>

<p style="margin-top: 1em">Where do I get the include files
to do ioctl() or syscall()? <br>
Historically, these would be generated by the h2ph tool,
part of the standard perl distribution. This program
converts cpp(1) directives in C header files to files
containing <br>
subroutine definitions, like &amp;SYS_getitimer, which you
can use as arguments to your functions. It doesn&rsquo;t
work perfectly, but it usually gets most of the job done.
Simple files <br>
like errno.h, syscall.h, and socket.h were fine, but the
hard ones like ioctl.h nearly always need to be hand-edited.
Here&rsquo;s how to install the *.ph files:</p>

<p style="margin-top: 1em">1. Become the super-user <br>
2. cd /usr/include <br>
3. h2ph *.h */*.h</p>

<p style="margin-top: 1em">If your system supports dynamic
loading, for reasons of portability and sanity you probably
ought to use h2xs (also part of the standard perl
distribution). This tool converts C <br>
header files to Perl extensions. See perlxstut for how to
get started with h2xs.</p>

<p style="margin-top: 1em">If your system doesn&rsquo;t
support dynamic loading, you still probably ought to use
h2xs. See perlxstut and ExtUtils::MakeMaker for more
information (in brief, just use make perl <br>
instead of a plain make to rebuild perl with a new static
extension).</p>

<p style="margin-top: 1em">Why do setuid perl scripts
complain about kernel problems? <br>
Some operating systems have bugs in the kernel that make
setuid scripts inherently insecure. Perl gives you a number
of options (described in perlsec) to work around such <br>
systems.</p>

<p style="margin-top: 1em">How can I open a pipe both to
and from a command? <br>
The IPC::Open2 module (part of the standard perl
distribution) is an easy-to-use approach that internally
uses &quot;pipe()&quot;, &quot;fork()&quot;, and
&quot;exec()&quot; to do the job. Make sure you read <br>
the deadlock warnings in its documentation, though (see
IPC::Open2). See &quot;Bidirectional Communication with
Another Process&quot; in perlipc and &quot;Bidirectional
Communication with <br>
Yourself&quot; in perlipc</p>

<p style="margin-top: 1em">You may also use the IPC::Open3
module (part of the standard perl distribution), but be
warned that it has a different order of arguments from
IPC::Open2 (see IPC::Open3).</p>

<p style="margin-top: 1em">Why can&rsquo;t I get the output
of a command with system()? <br>
You&rsquo;re confusing the purpose of &quot;system()&quot;
and backticks (&lsquo;&lsquo;). &quot;system()&quot; runs a
command and returns exit status information (as a 16 bit
value: the low 7 bits are the signal the <br>
process died from, if any, and the high 8 bits are the
actual exit value). Backticks (&lsquo;&lsquo;) run a command
and return what it sent to STDOUT.</p>

<p style="margin-top: 1em">my $exit_status =
system(&quot;mail-users&quot;); <br>
my $output_string = &lsquo;ls&lsquo;;</p>

<p style="margin-top: 1em">How can I capture STDERR from an
external command? <br>
There are three basic ways of running external commands:</p>

<p style="margin-top: 1em">system $cmd; # using system()
<br>
my $output = &lsquo;$cmd&lsquo;; # using backticks
(&lsquo;&lsquo;) <br>
open (my $pipe_fh, &quot;$cmd |&quot;); # using open()</p>

<p style="margin-top: 1em">With &quot;system()&quot;, both
STDOUT and STDERR will go the same place as the
script&rsquo;s STDOUT and STDERR, unless the
&quot;system()&quot; command redirects them. Backticks and
&quot;open()&quot; read only <br>
the STDOUT of your command.</p>

<p style="margin-top: 1em">You can also use the
&quot;open3()&quot; function from IPC::Open3. Benjamin
Goldberg provides some sample code:</p>

<p style="margin-top: 1em">To capture a program&rsquo;s
STDOUT, but discard its STDERR:</p>

<p style="margin-top: 1em">use IPC::Open3; <br>
use File::Spec; <br>
use Symbol qw(gensym); <br>
open(NULL, &quot;&gt;&quot;, File::Spec-&gt;devnull); <br>
my $pid = open3(gensym, H, &quot;&gt;&amp;NULL&quot;,
&quot;cmd&quot;); <br>
while( &lt;PH&gt; ) { } <br>
waitpid($pid, 0);</p>

<p style="margin-top: 1em">To capture a program&rsquo;s
STDERR, but discard its STDOUT:</p>

<p style="margin-top: 1em">use IPC::Open3; <br>
use File::Spec; <br>
use Symbol qw(gensym); <br>
open(NULL, &quot;&gt;&quot;, File::Spec-&gt;devnull); <br>
my $pid = open3(gensym, &quot;&gt;&amp;NULL&quot;, H,
&quot;cmd&quot;); <br>
while( &lt;PH&gt; ) { } <br>
waitpid($pid, 0);</p>

<p style="margin-top: 1em">To capture a program&rsquo;s
STDERR, and let its STDOUT go to our own STDERR:</p>

<p style="margin-top: 1em">use IPC::Open3; <br>
use Symbol qw(gensym); <br>
my $pid = open3(gensym, &quot;&gt;&amp;STDERR&quot;, H,
&quot;cmd&quot;); <br>
while( &lt;PH&gt; ) { } <br>
waitpid($pid, 0);</p>

<p style="margin-top: 1em">To read both a command&rsquo;s
STDOUT and its STDERR separately, you can redirect them to
temp files, let the command run, then read the temp
files:</p>

<p style="margin-top: 1em">use IPC::Open3; <br>
use Symbol qw(gensym); <br>
use IO::File; <br>
local *CATCHOUT = IO::File-&gt;new_tmpfile; <br>
local *CATCHERR = IO::File-&gt;new_tmpfile; <br>
my $pid = open3(gensym, &quot;&gt;&amp;CATCHOUT&quot;,
&quot;&gt;&amp;CATCHERR&quot;, &quot;cmd&quot;); <br>
waitpid($pid, 0); <br>
seek $_, 0, 0 for ATCHOUT, ATCHERR; <br>
while( &lt;CATCHOUT&gt; ) {} <br>
while( &lt;CATCHERR&gt; ) {}</p>

<p style="margin-top: 1em">But there&rsquo;s no real need
for both to be tempfiles... the following should work just
as well, without deadlocking:</p>

<p style="margin-top: 1em">use IPC::Open3; <br>
use Symbol qw(gensym); <br>
use IO::File; <br>
local *CATCHERR = IO::File-&gt;new_tmpfile; <br>
my $pid = open3(gensym, ATCHOUT,
&quot;&gt;&amp;CATCHERR&quot;, &quot;cmd&quot;); <br>
while( &lt;CATCHOUT&gt; ) {} <br>
waitpid($pid, 0); <br>
seek CATCHERR, 0, 0; <br>
while( &lt;CATCHERR&gt; ) {}</p>

<p style="margin-top: 1em">And it&rsquo;ll be faster, too,
since we can begin processing the program&rsquo;s stdout
immediately, rather than waiting for the program to
finish.</p>

<p style="margin-top: 1em">With any of these, you can
change file descriptors before the call:</p>

<p style="margin-top: 1em">open(STDOUT,
&quot;&gt;logfile&quot;); <br>
system(&quot;ls&quot;);</p>

<p style="margin-top: 1em">or you can use Bourne shell
file-descriptor redirection:</p>

<p style="margin-top: 1em">$output = &lsquo;$cmd
2&gt;some_file&lsquo;; <br>
open (PIPE, &quot;cmd 2&gt;some_file |&quot;);</p>

<p style="margin-top: 1em">You can also use file-descriptor
redirection to make STDERR a duplicate of STDOUT:</p>

<p style="margin-top: 1em">$output = &lsquo;$cmd
2&gt;&amp;1&lsquo;; <br>
open (PIPE, &quot;cmd 2&gt;&amp;1 |&quot;);</p>

<p style="margin-top: 1em">Note that you cannot simply open
STDERR to be a dup of STDOUT in your Perl program and avoid
calling the shell to do the redirection. This doesn&rsquo;t
work:</p>

<p style="margin-top: 1em">open(STDERR,
&quot;&gt;&amp;STDOUT&quot;); <br>
$alloutput = &lsquo;cmd args&lsquo;; # stderr still
escapes</p>

<p style="margin-top: 1em">This fails because the
&quot;open()&quot; makes STDERR go to where STDOUT was going
at the time of the &quot;open()&quot;. The backticks then
make STDOUT go to a string, but don&rsquo;t change STDERR
<br>
(which still goes to the old STDOUT).</p>

<p style="margin-top: 1em">Note that you must use Bourne
shell (sh(1)) redirection syntax in backticks, not csh(1)!
Details on why Perl&rsquo;s &quot;system()&quot; and
backtick and pipe opens all use the Bourne shell <br>
are in the versus/csh.whynot article in the &quot;Far More
Than You Ever Wanted To Know&quot; collection in
&lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; . To
capture a command&rsquo;s STDERR <br>
and STDOUT together:</p>

<p style="margin-top: 1em">$output = &lsquo;cmd
2&gt;&amp;1&lsquo;; # either with backticks <br>
$pid = open(PH, &quot;cmd 2&gt;&amp;1 |&quot;); # or with an
open pipe <br>
while (&lt;PH&gt;) { } # plus a read</p>

<p style="margin-top: 1em">To capture a command&rsquo;s
STDOUT but discard its STDERR:</p>

<p style="margin-top: 1em">$output = &lsquo;cmd
2&gt;/dev/null&lsquo;; # either with backticks <br>
$pid = open(PH, &quot;cmd 2&gt;/dev/null |&quot;); # or with
an open pipe <br>
while (&lt;PH&gt;) { } # plus a read</p>

<p style="margin-top: 1em">To capture a command&rsquo;s
STDERR but discard its STDOUT:</p>

<p style="margin-top: 1em">$output = &lsquo;cmd 2&gt;&amp;1
1&gt;/dev/null&lsquo;; # either with backticks <br>
$pid = open(PH, &quot;cmd 2&gt;&amp;1 1&gt;/dev/null
|&quot;); # or with an open pipe <br>
while (&lt;PH&gt;) { } # plus a read</p>

<p style="margin-top: 1em">To exchange a command&rsquo;s
STDOUT and STDERR in order to capture the STDERR but leave
its STDOUT to come out our old STDERR:</p>

<p style="margin-top: 1em">$output = &lsquo;cmd 3&gt;&amp;1
1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-&lsquo;; # either with
backticks <br>
$pid = open(PH, &quot;cmd 3&gt;&amp;1 1&gt;&amp;2
2&gt;&amp;3 3&gt;&amp;-|&quot;);# or with an open pipe <br>
while (&lt;PH&gt;) { } # plus a read</p>

<p style="margin-top: 1em">To read both a command&rsquo;s
STDOUT and its STDERR separately, it&rsquo;s easiest to
redirect them separately to files, and then read from those
files when the program is done:</p>

<p style="margin-top: 1em">system(&quot;program args
1&gt;program.stdout 2&gt;program.stderr&quot;);</p>

<p style="margin-top: 1em">Ordering is important in all
these examples. That&rsquo;s because the shell processes
file descriptor redirections in strictly left to right
order.</p>

<p style="margin-top: 1em">system(&quot;prog args
1&gt;tmpfile 2&gt;&amp;1&quot;); <br>
system(&quot;prog args 2&gt;&amp;1 1&gt;tmpfile&quot;);</p>

<p style="margin-top: 1em">The first command sends both
standard out and standard error to the temporary file. The
second command sends only the old standard output there, and
the old standard error shows <br>
up on the old standard out.</p>

<p style="margin-top: 1em">Why doesn&rsquo;t open() return
an error when a pipe open fails? <br>
If the second argument to a piped &quot;open()&quot;
contains shell metacharacters, perl &quot;fork()&quot;s,
then &quot;exec()&quot;s a shell to decode the
metacharacters and eventually run the desired <br>
program. If the program couldn&rsquo;t be run, it&rsquo;s
the shell that gets the message, not Perl. All your Perl
program can find out is whether the shell itself could be
successfully <br>
started. You can still capture the shell&rsquo;s STDERR and
check it for error messages. See &quot;How can I capture
STDERR from an external command?&quot; elsewhere in this
document, or use the <br>
IPC::Open3 module.</p>

<p style="margin-top: 1em">If there are no shell
metacharacters in the argument of &quot;open()&quot;, Perl
runs the command directly, without using the shell, and can
correctly report whether the command started.</p>

<p style="margin-top: 1em">What&rsquo;s wrong with using
backticks in a void context? <br>
Strictly speaking, nothing. Stylistically speaking,
it&rsquo;s not a good way to write maintainable code. Perl
has several operators for running external commands.
Backticks are one; <br>
they collect the output from the command for use in your
program. The &quot;system&quot; function is another; it
doesn&rsquo;t do this.</p>

<p style="margin-top: 1em">Writing backticks in your
program sends a clear message to the readers of your code
that you wanted to collect the output of the command. Why
send a clear message that isn&rsquo;t <br>
true?</p>

<p style="margin-top: 1em">Consider this line:</p>

<p style="margin-top: 1em">&lsquo;cat
/etc/termcap&lsquo;;</p>

<p style="margin-top: 1em">You forgot to check $? to see
whether the program even ran correctly. Even if you
wrote</p>

<p style="margin-top: 1em">print &lsquo;cat
/etc/termcap&lsquo;;</p>

<p style="margin-top: 1em">this code could and probably
should be written as</p>

<p style="margin-top: 1em">system(&quot;cat
/etc/termcap&quot;) == 0 <br>
or die &quot;cat program failed!&quot;;</p>

<p style="margin-top: 1em">which will echo the cat
command&rsquo;s output as it is generated, instead of
waiting until the program has completed to print it out. It
also checks the return value.</p>

<p style="margin-top: 1em">&quot;system&quot; also provides
direct control over whether shell wildcard processing may
take place, whereas backticks do not.</p>

<p style="margin-top: 1em">How can I call backticks without
shell processing? <br>
This is a bit tricky. You can&rsquo;t simply write the
command like this:</p>

<p style="margin-top: 1em">@ok = &lsquo;grep @opts
&rsquo;$search_string&rsquo; @filenames&lsquo;;</p>

<p style="margin-top: 1em">As of Perl 5.8.0, you can use
&quot;open()&quot; with multiple arguments. Just like the
list forms of &quot;system()&quot; and &quot;exec()&quot;,
no shell escapes happen.</p>

<p style="margin-top: 1em">open( GREP, &quot;-|&quot;,
&rsquo;grep&rsquo;, @opts, $search_string, @filenames );
<br>
chomp(@ok = &lt;GREP&gt;); <br>
close GREP;</p>

<p style="margin-top: 1em">You can also:</p>

<p style="margin-top: 1em">my @ok = (); <br>
if (open(GREP, &quot;-|&quot;)) { <br>
while (&lt;GREP&gt;) { <br>
chomp; <br>
push(@ok, $_); <br>
} <br>
close GREP; <br>
} else { <br>
exec &rsquo;grep&rsquo;, @opts, $search_string, @filenames;
<br>
}</p>

<p style="margin-top: 1em">Just as with
&quot;system()&quot;, no shell escapes happen when you
&quot;exec()&quot; a list. Further examples of this can be
found in &quot;Safe Pipe Opens&quot; in perlipc.</p>

<p style="margin-top: 1em">Note that if you&rsquo;re using
Windows, no solution to this vexing issue is even possible.
Even though Perl emulates &quot;fork()&quot;, you&rsquo;ll
still be stuck, because Windows does not have an <br>
argc/argv-style API.</p>

<p style="margin-top: 1em">Why can&rsquo;t my script read
from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?
<br>
This happens only if your perl is compiled to use stdio
instead of perlio, which is the default. Some (maybe all?)
stdios set error and eof flags that you may need to clear.
The <br>
POSIX module defines &quot;clearerr()&quot; that you can
use. That is the technically correct way to do it. Here are
some less reliable workarounds:</p>

<p style="margin-top: 1em">1. Try keeping around the
seekpointer and go there, like this:</p>

<p style="margin-top: 1em">my $where = tell($log_fh); <br>
seek($log_fh, $where, 0);</p>

<p style="margin-top: 1em">2. If that doesn&rsquo;t work,
try seeking to a different part of the file and then
back.</p>

<p style="margin-top: 1em">3. If that doesn&rsquo;t work,
try seeking to a different part of the file, reading
something, and then seeking back.</p>

<p style="margin-top: 1em">4. If that doesn&rsquo;t work,
give up on your stdio package and use sysread.</p>

<p style="margin-top: 1em">How can I convert my shell
script to perl? <br>
Learn Perl and rewrite it. Seriously, there&rsquo;s no
simple converter. Things that are awkward to do in the shell
are easy to do in Perl, and this very awkwardness is what
would <br>
make a shell-&gt;perl converter nigh-on impossible to write.
By rewriting it, you&rsquo;ll think about what you&rsquo;re
really trying to do, and hopefully will escape the
shell&rsquo;s pipeline <br>
datastream paradigm, which while convenient for some
matters, causes many inefficiencies.</p>

<p style="margin-top: 1em">Can I use perl to run a telnet
or ftp session? <br>
Try the Net::FTP, TCP::Client, and Net::Telnet modules
(available from CPAN).
&lt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&gt;
will also help for emulating the telnet <br>
protocol, but Net::Telnet is quite probably easier to
use.</p>

<p style="margin-top: 1em">If all you want to do is pretend
to be telnet but don&rsquo;t need the initial telnet
handshaking, then the standard dual-process approach will
suffice:</p>

<p style="margin-top: 1em">use IO::Socket; # new in 5.004
<br>
my $handle =
IO::Socket::INET-&gt;new(&rsquo;www.perl.com:80&rsquo;) <br>
or die &quot;can&rsquo;t connect to port 80 on www.perl.com
$!&quot;; <br>
$handle-&gt;autoflush(1); <br>
if (fork()) { # XXX: undef means failure <br>
select($handle); <br>
print while &lt;STDIN&gt;; # everything from stdin to socket
<br>
} else { <br>
print while &lt;$handle&gt;; # everything from socket to
stdout <br>
} <br>
close $handle; <br>
exit;</p>

<p style="margin-top: 1em">How can I write expect in Perl?
<br>
Once upon a time, there was a library called chat2.pl (part
of the standard perl distribution), which never really got
finished. If you find it somewhere, don&rsquo;t use it.
These <br>
days, your best bet is to look at the Expect module
available from CPAN, which also requires two other modules
from CPAN, IO::Pty and IO::Stty.</p>

<p style="margin-top: 1em">Is there a way to hide
perl&rsquo;s command line from programs such as
&quot;ps&quot;? <br>
First of all note that if you&rsquo;re doing this for
security reasons (to avoid people seeing passwords, for
example) then you should rewrite your program so that
critical information <br>
is never given as an argument. Hiding the arguments
won&rsquo;t make your program completely secure.</p>

<p style="margin-top: 1em">To actually alter the visible
command line, you can assign to the variable $0 as
documented in perlvar. This won&rsquo;t work on all
operating systems, though. Daemon programs like <br>
sendmail place their state there, as in:</p>

<p style="margin-top: 1em">$0 = &quot;orcus [accepting
connections]&quot;;</p>

<p style="margin-top: 1em">I {changed directory, modified
my environment} in a perl script. How come the change
disappeared when I exited the script? How do I get my
changes to be visible? <br>
Unix <br>
In the strictest sense, it can&rsquo;t be done--the script
executes as a different process from the shell it was
started from. Changes to a process are not reflected in its
<br>
parent--only in any children created after the change. There
is shell magic that may allow you to fake it by
&quot;eval()&quot;ing the script&rsquo;s output in your
shell; check out the <br>
comp.unix.questions FAQ for details.</p>

<p style="margin-top: 1em">How do I close a process&rsquo;s
filehandle without waiting for it to complete? <br>
Assuming your system supports such things, just send an
appropriate signal to the process (see &quot;kill&quot; in
perlfunc). It&rsquo;s common to first send a TERM signal,
wait a little bit, <br>
and then send a KILL signal to finish it off.</p>

<p style="margin-top: 1em">How do I fork a daemon process?
<br>
If by daemon process you mean one that&rsquo;s detached
(disassociated from its tty), then the following process is
reported to work on most Unixish systems. Non-Unix users
should <br>
check their Your_OS::Process module for other solutions.</p>

<p style="margin-top: 1em">&Acirc;&middot; Open /dev/tty
and use the TIOCNOTTY ioctl on it. See tty(1) for details.
Or better yet, you can just use the
&quot;POSIX::setsid()&quot; function, so you don&rsquo;t
have to worry about <br>
process groups.</p>

<p style="margin-top: 1em">&Acirc;&middot; Change directory
to /</p>

<p style="margin-top: 1em">&Acirc;&middot; Reopen STDIN,
STDOUT, and STDERR so they&rsquo;re not connected to the old
tty.</p>

<p style="margin-top: 1em">&Acirc;&middot; Background
yourself like this:</p>

<p style="margin-top: 1em">fork &amp;&amp; exit;</p>

<p style="margin-top: 1em">The Proc::Daemon module,
available from CPAN, provides a function to perform these
actions for you.</p>

<p style="margin-top: 1em">How do I find out if I&rsquo;m
running interactively or not? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">This is a difficult question to
answer, and the best answer is only a guess.</p>

<p style="margin-top: 1em">What do you really want to know?
If you merely want to know if one of your filehandles is
connected to a terminal, you can try the &quot;-t&quot; file
test:</p>

<p style="margin-top: 1em">if( -t STDOUT ) { <br>
print &quot;I&rsquo;m connected to a terminal!0; <br>
}</p>

<p style="margin-top: 1em">However, you might be out of
luck if you expect that means there is a real person on the
other side. With the Expect module, another program can
pretend to be a person. The <br>
program might even come close to passing the Turing
test.</p>

<p style="margin-top: 1em">The IO::Interactive module does
the best it can to give you an answer. Its
&quot;is_interactive&quot; function returns an output
filehandle; that filehandle points to standard output if
<br>
the module thinks the session is interactive. Otherwise, the
filehandle is a null handle that simply discards the
output:</p>

<p style="margin-top: 1em">use IO::Interactive;</p>

<p style="margin-top: 1em">print { is_interactive } &quot;I
might go to standard output!0;</p>

<p style="margin-top: 1em">This still doesn&rsquo;t
guarantee that a real person is answering your prompts or
reading your output.</p>

<p style="margin-top: 1em">If you want to know how to
handle automated testing for your distribution, you can
check the environment. The CPAN Testers, for instance, set
the value of &quot;AUTOMATED_TESTING&quot;:</p>

<p style="margin-top: 1em">unless( $ENV{AUTOMATED_TESTING}
) { <br>
print &quot;Hello interactive tester!0; <br>
}</p>

<p style="margin-top: 1em">How do I timeout a slow event?
<br>
Use the &quot;alarm()&quot; function, probably in
conjunction with a signal handler, as documented in
&quot;Signals&quot; in perlipc and the section on
&quot;Signals&quot; in the Camel. You may instead use <br>
the more flexible Sys::AlarmCall module available from
CPAN.</p>

<p style="margin-top: 1em">The &quot;alarm()&quot; function
is not implemented on all versions of Windows. Check the
documentation for your specific version of Perl.</p>

<p style="margin-top: 1em">How do I set CPU limits? <br>
(contributed by Xho)</p>

<p style="margin-top: 1em">Use the BSD::Resource module
from CPAN. As an example:</p>

<p style="margin-top: 1em">use BSD::Resource; <br>
setrlimit(RLIMIT_CPU,10,20) or die $!;</p>

<p style="margin-top: 1em">This sets the soft and hard
limits to 10 and 20 seconds, respectively. After 10 seconds
of time spent running on the CPU (not &quot;wall&quot;
time), the process will be sent a signal <br>
(XCPU on some systems) which, if not trapped, will cause the
process to terminate. If that signal is trapped, then after
10 more seconds (20 seconds in total) the process will be
<br>
killed with a non-trappable signal.</p>

<p style="margin-top: 1em">See the BSD::Resource and your
systems documentation for the gory details.</p>

<p style="margin-top: 1em">How do I avoid zombies on a Unix
system? <br>
Use the reaper code from &quot;Signals&quot; in perlipc to
call &quot;wait()&quot; when a SIGCHLD is received, or else
use the double-fork technique described in &quot;How do I
start a process in the <br>
background?&quot; in perlfaq8.</p>

<p style="margin-top: 1em">How do I use an SQL database?
<br>
The DBI module provides an abstract interface to most
database servers and types, including Oracle, DB2, Sybase,
mysql, Postgresql, ODBC, and flat files. The DBI module
accesses <br>
each database type through a database driver, or DBD. You
can see a complete list of available drivers on CPAN:
http://www.cpan.org/modules/by-module/DBD/ <br>
&lt;http://www.cpan.org/modules/by-module/DBD/&gt; . You can
read more about DBI on &lt;http://dbi.perl.org/&gt; .</p>

<p style="margin-top: 1em">Other modules provide more
specific access: Win32::ODBC, Alzabo, &quot;iodbc&quot;, and
others found on CPAN Search: &lt;http://search.cpan.org/&gt;
.</p>

<p style="margin-top: 1em">How do I make a system() exit on
control-C? <br>
You can&rsquo;t. You need to imitate the
&quot;system()&quot; call (see perlipc for sample code) and
then have a signal handler for the INT signal that passes
the signal on to the subprocess. Or <br>
you can check for it:</p>

<p style="margin-top: 1em">$rc = system($cmd); <br>
if ($rc &amp; 127) { die &quot;signal death&quot; }</p>

<p style="margin-top: 1em">How do I open a file without
blocking? <br>
If you&rsquo;re lucky enough to be using a system that
supports non-blocking reads (most Unixish systems do), you
need only to use the &quot;O_NDELAY&quot; or
&quot;O_NONBLOCK&quot; flag from the &quot;Fcntl&quot; <br>
module in conjunction with &quot;sysopen()&quot;:</p>

<p style="margin-top: 1em">use Fcntl; <br>
sysopen(my $fh, &quot;/foo/somefile&quot;,
O_WRONLY|O_NDELAY|O_CREAT, 0644) <br>
or die &quot;can&rsquo;t open /foo/somefile: $!&quot;:</p>

<p style="margin-top: 1em">How do I tell the difference
between errors from the shell and perl? <br>
(answer contributed by brian d foy)</p>

<p style="margin-top: 1em">When you run a Perl script,
something else is running the script for you, and that
something else may output error messages. The script might
emit its own warnings and error <br>
messages. Most of the time you cannot tell who said
what.</p>

<p style="margin-top: 1em">You probably cannot fix the
thing that runs perl, but you can change how perl outputs
its warnings by defining a custom warning and die
functions.</p>

<p style="margin-top: 1em">Consider this script, which has
an error you may not notice immediately.</p>

<p style="margin-top: 1em">#!/usr/locl/bin/perl</p>

<p style="margin-top: 1em">print &quot;Hello World0;</p>

<p style="margin-top: 1em">I get an error when I run this
from my shell (which happens to be bash). That may look like
perl forgot it has a &quot;print()&quot; function, but my
shebang line is not the path to perl, <br>
so the shell runs the script, and I get the error.</p>

<p style="margin-top: 1em">$ ./test <br>
./test: line 3: print: command not found</p>

<p style="margin-top: 1em">A quick and dirty fix involves a
little bit of code, but this may be all you need to figure
out the problem.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w</p>

<p style="margin-top: 1em">BEGIN { <br>
$SIG{__WARN__} = sub{ print STDERR &quot;Perl: &quot;, @_;
}; <br>
$SIG{__DIE__} = sub{ print STDERR &quot;Perl: &quot;, @_;
exit 1}; <br>
}</p>

<p style="margin-top: 1em">$a = 1 + undef; <br>
$x / 0; <br>
__END__</p>

<p style="margin-top: 1em">The perl message comes out with
&quot;Perl&quot; in front. The &quot;BEGIN&quot; block works
at compile time so all of the compilation errors and
warnings get the &quot;Perl:&quot; prefix too.</p>

<p style="margin-top: 1em">Perl: Useless use of division
(/) in void context at ./test line 9. <br>
Perl: Name &quot;main::a&quot; used only once: possible typo
at ./test line 8. <br>
Perl: Name &quot;main::x&quot; used only once: possible typo
at ./test line 9. <br>
Perl: Use of uninitialized value in addition (+) at ./test
line 8. <br>
Perl: Use of uninitialized value in division (/) at ./test
line 9. <br>
Perl: Illegal division by zero at ./test line 9. <br>
Perl: Illegal division by zero at -e line 3.</p>

<p style="margin-top: 1em">If I don&rsquo;t see that
&quot;Perl:&quot;, it&rsquo;s not from perl.</p>

<p style="margin-top: 1em">You could also just know all the
perl errors, and although there are some people who may know
all of them, you probably don&rsquo;t. However, they all
should be in the perldiag <br>
manpage. If you don&rsquo;t find the error in there, it
probably isn&rsquo;t a perl error.</p>

<p style="margin-top: 1em">Looking up every message is not
the easiest way, so let perl to do it for you. Use the
diagnostics pragma with turns perl&rsquo;s normal messages
into longer discussions on the topic.</p>

<p style="margin-top: 1em">use diagnostics;</p>

<p style="margin-top: 1em">If you don&rsquo;t get a
paragraph or two of expanded discussion, it might not be
perl&rsquo;s message.</p>

<p style="margin-top: 1em">How do I install a module from
CPAN? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">The easiest way is to have a
module also named CPAN do it for you by using the
&quot;cpan&quot; command that comes with Perl. You can give
it a list of modules to install:</p>

<p style="margin-top: 1em">$ cpan IO::Interactive
Getopt::Whatever</p>

<p style="margin-top: 1em">If you prefer
&quot;CPANPLUS&quot;, it&rsquo;s just as easy:</p>

<p style="margin-top: 1em">$ cpanp i IO::Interactive
Getopt::Whatever</p>

<p style="margin-top: 1em">If you want to install a
distribution from the current directory, you can tell
&quot;CPAN.pm&quot; to install &quot;.&quot; (the full
stop):</p>

<p style="margin-top: 1em">$ cpan .</p>

<p style="margin-top: 1em">See the documentation for either
of those commands to see what else you can do.</p>

<p style="margin-top: 1em">If you want to try to install a
distribution by yourself, resolving all dependencies on your
own, you follow one of two possible build paths.</p>

<p style="margin-top: 1em">For distributions that use
Makefile.PL:</p>

<p style="margin-top: 1em">$ perl Makefile.PL <br>
$ make test install</p>

<p style="margin-top: 1em">For distributions that use
Build.PL:</p>

<p style="margin-top: 1em">$ perl Build.PL <br>
$ ./Build test <br>
$ ./Build install</p>

<p style="margin-top: 1em">Some distributions may need to
link to libraries or other third-party code and their build
and installation sequences may be more complicated. Check
any README or INSTALL files <br>
that you may find.</p>

<p style="margin-top: 1em">What&rsquo;s the difference
between require and use? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">Perl runs &quot;require&quot;
statement at run-time. Once Perl loads, compiles, and runs
the file, it doesn&rsquo;t do anything else. The
&quot;use&quot; statement is the same as a
&quot;require&quot; run at <br>
compile-time, but Perl also calls the &quot;import&quot;
method for the loaded package. These two are the same:</p>

<p style="margin-top: 1em">use MODULE qw(import list);</p>

<p style="margin-top: 1em">BEGIN { <br>
require MODULE; <br>
MODULE-&gt;import(import list); <br>
}</p>

<p style="margin-top: 1em">However, you can suppress the
&quot;import&quot; by using an explicit, empty import list.
Both of these still happen at compile-time:</p>

<p style="margin-top: 1em">use MODULE ();</p>

<p style="margin-top: 1em">BEGIN { <br>
require MODULE; <br>
}</p>

<p style="margin-top: 1em">Since &quot;use&quot; will also
call the &quot;import&quot; method, the actual value for
&quot;MODULE&quot; must be a bareword. That is,
&quot;use&quot; cannot load files by name, although
&quot;require&quot; can:</p>

<p style="margin-top: 1em">require
&quot;$ENV{HOME}/lib/Foo.pm&quot;; # no @INC searching!</p>

<p style="margin-top: 1em">See the entry for
&quot;use&quot; in perlfunc for more details.</p>

<p style="margin-top: 1em">How do I keep my own
module/library directory? <br>
When you build modules, tell Perl where to install the
modules.</p>

<p style="margin-top: 1em">If you want to install modules
for your own use, the easiest way might be local::lib, which
you can download from CPAN. It sets various installation
settings for you, and uses <br>
those same settings within your programs.</p>

<p style="margin-top: 1em">If you want more flexibility,
you need to configure your CPAN client for your particular
situation.</p>

<p style="margin-top: 1em">For
&quot;Makefile.PL&quot;-based distributions, use the
INSTALL_BASE option when generating Makefiles:</p>

<p style="margin-top: 1em">perl Makefile.PL
INSTALL_BASE=/mydir/perl</p>

<p style="margin-top: 1em">You can set this in your
&quot;CPAN.pm&quot; configuration so modules automatically
install in your private library directory when you use the
CPAN.pm shell:</p>

<p style="margin-top: 1em">% cpan <br>
cpan&gt; o conf makepl_arg INSTALL_BASE=/mydir/perl <br>
cpan&gt; o conf commit</p>

<p style="margin-top: 1em">For &quot;Build.PL&quot;-based
distributions, use the --install_base option:</p>

<p style="margin-top: 1em">perl Build.PL --install_base
/mydir/perl</p>

<p style="margin-top: 1em">You can configure
&quot;CPAN.pm&quot; to automatically use this option
too:</p>

<p style="margin-top: 1em">% cpan <br>
cpan&gt; o conf mbuild_arg &quot;--install_base
/mydir/perl&quot; <br>
cpan&gt; o conf commit</p>

<p style="margin-top: 1em">INSTALL_BASE tells these tools
to put your modules into /mydir/perl/lib/perl5. See
&quot;How do I add a directory to my include path (@INC) at
runtime?&quot; for details on how to run your <br>
newly installed modules.</p>

<p style="margin-top: 1em">There is one caveat with
INSTALL_BASE, though, since it acts differently from the
PREFIX and LIB settings that older versions of
ExtUtils::MakeMaker advocated. INSTALL_BASE does <br>
not support installing modules for multiple versions of Perl
or different architectures under the same directory. You
should consider whether you really want that and, if you do,
<br>
use the older PREFIX and LIB settings. See the
ExtUtils::Makemaker documentation for more details.</p>

<p style="margin-top: 1em">How do I add the directory my
program lives in to the module/library search path? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">If you know the directory
already, you can add it to @INC as you would for any other
directory. You might &lt;use lib&gt; if you know the
directory at compile time:</p>

<p style="margin-top: 1em">use lib $directory;</p>

<p style="margin-top: 1em">The trick in this task is to
find the directory. Before your script does anything else
(such as a &quot;chdir&quot;), you can get the current
working directory with the &quot;Cwd&quot; module, which
<br>
comes with Perl:</p>

<p style="margin-top: 1em">BEGIN { <br>
use Cwd; <br>
our $directory = cwd; <br>
}</p>

<p style="margin-top: 1em">use lib $directory;</p>

<p style="margin-top: 1em">You can do a similar thing with
the value of $0, which holds the script name. That might
hold a relative path, but &quot;rel2abs&quot; can turn it
into an absolute path. Once you have the</p>

<p style="margin-top: 1em">BEGIN { <br>
use File::Spec::Functions qw(rel2abs); <br>
use File::Basename qw(dirname);</p>

<p style="margin-top: 1em">my $path = rel2abs( $0 ); <br>
our $directory = dirname( $path ); <br>
}</p>

<p style="margin-top: 1em">use lib $directory;</p>

<p style="margin-top: 1em">The FindBin module, which comes
with Perl, might work. It finds the directory of the
currently running script and puts it in $Bin, which you can
then use to construct the right <br>
library path:</p>

<p style="margin-top: 1em">use FindBin qw($Bin);</p>

<p style="margin-top: 1em">You can also use local::lib to
do much of the same thing. Install modules using
local::lib&rsquo;s settings then use the module in your
program:</p>

<p style="margin-top: 1em">use local::lib; # sets up a
local lib at ~/perl5</p>

<p style="margin-top: 1em">See the local::lib documentation
for more details.</p>

<p style="margin-top: 1em">How do I add a directory to my
include path (@INC) at runtime? <br>
Here are the suggested ways of modifying your include path,
including environment variables, run-time switches, and
in-code statements:</p>

<p style="margin-top: 1em">the &quot;PERLLIB&quot;
environment variable <br>
$ export PERLLIB=/path/to/my/dir <br>
$ perl program.pl</p>

<p style="margin-top: 1em">the &quot;PERL5LIB&quot;
environment variable <br>
$ export PERL5LIB=/path/to/my/dir <br>
$ perl program.pl</p>

<p style="margin-top: 1em">the &quot;perl -Idir&quot;
command line flag <br>
$ perl -I/path/to/my/dir program.pl</p>

<p style="margin-top: 1em">the &quot;lib&quot; pragma: <br>
use lib &quot;$ENV{HOME}/myown_perllib&quot;;</p>

<p style="margin-top: 1em">the local::lib module: <br>
use local::lib;</p>

<p style="margin-top: 1em">use local::lib
&quot;~/myown_perllib&quot;;</p>

<p style="margin-top: 1em">The last is particularly useful
because it knows about machine-dependent architectures. The
&quot;lib.pm&quot; pragmatic module was first included with
the 5.002 release of Perl.</p>

<p style="margin-top: 1em">What is socket.ph and where do I
get it? <br>
It&rsquo;s a Perl 4 style file defining values for system
networking constants. Sometimes it is built using h2ph when
Perl is installed, but other times it is not. Modern
programs <br>
should use &quot;use Socket;&quot; instead.</p>

<p style="margin-top: 1em">AUTHOR AND COPYRIGHT <br>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington,
and other authors as noted. All rights reserved.</p>

<p style="margin-top: 1em">This documentation is free; you
can redistribute it and/or modify it under the same terms as
Perl itself.</p>

<p style="margin-top: 1em">Irrespective of its
distribution, all code examples in this file are hereby
placed into the public domain. You are permitted and
encouraged to use this code in your own programs <br>
for fun or for profit as you see fit. A simple comment in
the code giving credit would be courteous but is not
required.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLFAQ8(1)</p>
<hr>
</body>
</html>
