<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLFAQ8(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFAQ8(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFAQ8(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlfaq8 - System Interaction
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This section of the Perl FAQ covers questions involving operating system
  interaction. Topics include interprocess communication (IPC), control over the
  user-interface (keyboard, screen and pointing devices), and most anything else
  not related to data manipulation.
<div class="Pp"></div>
Read the FAQs and documentation specific to the port of perl to your operating
  system (eg, perlvms, perlplan9, ...). These should contain more detailed
  information on the vagaries of your perl.
<h2 class="Ss" title="Ss" id="How_do_I_find_out_which_operating_system_I'm_running_under?"><a class="selflink" href="#How_do_I_find_out_which_operating_system_I'm_running_under?">How
  do I find out which operating system I'm running under?</a></h2>
The $^O variable ($OSNAME if you use &quot;English&quot;) contains an indication
  of the name of the operating system (not its release number) that your perl
  binary was built for.
<h2 class="Ss" title="Ss" id="How_come_exec()_doesn't_return?"><a class="selflink" href="#How_come_exec()_doesn't_return?">How
  come <i>exec()</i> doesn't return?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
The &quot;exec&quot; function's job is to turn your process into another command
  and never to return. If that's not what you want to do, don't use
  &quot;exec&quot;. :)
<div class="Pp"></div>
If you want to run an external command and still keep your Perl process going,
  look at a piped &quot;open&quot;, &quot;fork&quot;, or &quot;system&quot;.
<h2 class="Ss" title="Ss" id="How_do_I_do_fancy_stuff_with_the_keyboard/screen/mouse?"><a class="selflink" href="#How_do_I_do_fancy_stuff_with_the_keyboard/screen/mouse?">How
  do I do fancy stuff with the keyboard/screen/mouse?</a></h2>
How you access/control keyboards, screens, and pointing devices
  (&quot;mice&quot;) is system-dependent. Try the following modules:
<dl class="Bl-tag">
  <dt class="It-tag">Keyboard</dt>
  <dd class="It-tag">
    <pre>
    Term::Cap               Standard perl distribution
    Term::ReadKey           CPAN
    Term::ReadLine::Gnu     CPAN
    Term::ReadLine::Perl    CPAN
    Term::Screen            CPAN
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Screen</dt>
  <dd class="It-tag">
    <pre>
    Term::Cap               Standard perl distribution
    Curses                  CPAN
    Term::ANSIColor         CPAN
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Mouse</dt>
  <dd class="It-tag">
    <pre>
    Tk                      CPAN
    Wx                      CPAN
    Gtk2                    CPAN
    Qt4                     kdebindings4 package
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
Some of these specific cases are shown as examples in other answers in this
  section of the perlfaq.
<h2 class="Ss" title="Ss" id="How_do_I_print_something_out_in_color?"><a class="selflink" href="#How_do_I_print_something_out_in_color?">How
  do I print something out in color?</a></h2>
In general, you don't, because you don't know whether the recipient has a
  color-aware display device. If you know that they have an ANSI terminal that
  understands color, you can use the Term::ANSIColor module from CPAN:
<div class="Pp"></div>
<pre>
    use Term::ANSIColor;
    print color(&quot;red&quot;), &quot;Stop!\n&quot;, color(&quot;reset&quot;);
    print color(&quot;green&quot;), &quot;Go!\n&quot;, color(&quot;reset&quot;);
</pre>
<div class="Pp"></div>
Or like this:
<div class="Pp"></div>
<pre>
    use Term::ANSIColor qw(:constants);
    print RED, &quot;Stop!\n&quot;, RESET;
    print GREEN, &quot;Go!\n&quot;, RESET;
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_read_just_one_key_without_waiting_for_a_return_key?"><a class="selflink" href="#How_do_I_read_just_one_key_without_waiting_for_a_return_key?">How
  do I read just one key without waiting for a return key?</a></h2>
Controlling input buffering is a remarkably system-dependent matter. On many
  systems, you can just use the <b>stty</b> command as shown in &quot;getc&quot;
  in perlfunc, but as you see, that's already getting you into portability
  snags.
<div class="Pp"></div>
<pre>
    open(TTY, &quot;+&lt;/dev/tty&quot;) or die &quot;no tty: $!&quot;;
    system &quot;stty  cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;
    $key = getc(TTY);        # perhaps this works
    # OR ELSE
    sysread(TTY, $key, 1);    # probably this does
    system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1&quot;;
</pre>
<div class="Pp"></div>
The Term::ReadKey module from CPAN offers an easy-to-use interface that should
  be more efficient than shelling out to <b>stty</b> for each key. It even
  includes limited support for Windows.
<div class="Pp"></div>
<pre>
    use Term::ReadKey;
    ReadMode('cbreak');
    $key = ReadKey(0);
    ReadMode('normal');
</pre>
<div class="Pp"></div>
However, using the code requires that you have a working C compiler and can use
  it to build and install a CPAN module. Here's a solution using the standard
  POSIX module, which is already on your system (assuming your system supports
  POSIX).
<div class="Pp"></div>
<pre>
    use HotKey;
    $key = readkey();
</pre>
<div class="Pp"></div>
And here's the &quot;HotKey&quot; module, which hides the somewhat mystifying
  calls to manipulate the POSIX termios structures.
<div class="Pp"></div>
<pre>
    # HotKey.pm
    package HotKey;
    use strict;
    use warnings;
    use parent 'Exporter';
    our @EXPORT = qw(cbreak cooked readkey);
    use POSIX qw(:termios_h);
    my ($term, $oterm, $echo, $noecho, $fd_stdin);
    $fd_stdin = fileno(STDIN);
    $term     = POSIX::Termios-&gt;new();
    $term-&gt;getattr($fd_stdin);
    $oterm     = $term-&gt;getlflag();
    $echo     = ECHO | ECHOK | ICANON;
    $noecho   = $oterm &amp; ~$echo;
    sub cbreak {
        $term-&gt;setlflag($noecho);  # ok, so i don't want echo either
        $term-&gt;setcc(VTIME, 1);
        $term-&gt;setattr($fd_stdin, TCSANOW);
    }
    sub cooked {
        $term-&gt;setlflag($oterm);
        $term-&gt;setcc(VTIME, 0);
        $term-&gt;setattr($fd_stdin, TCSANOW);
    }
    sub readkey {
        my $key = '';
        cbreak();
        sysread(STDIN, $key, 1);
        cooked();
        return $key;
    }
    END { cooked() }
    1;
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_check_whether_input_is_ready_on_the_keyboard?"><a class="selflink" href="#How_do_I_check_whether_input_is_ready_on_the_keyboard?">How
  do I check whether input is ready on the keyboard?</a></h2>
The easiest way to do this is to read a key in nonblocking mode with the
  Term::ReadKey module from CPAN, passing it an argument of -1 to indicate not
  to block:
<div class="Pp"></div>
<pre>
    use Term::ReadKey;
    ReadMode('cbreak');
    if (defined (my $char = ReadKey(-1)) ) {
        # input was waiting and it was $char
    } else {
        # no input was waiting
    }
    ReadMode('normal');                  # restore normal tty settings
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_clear_the_screen?"><a class="selflink" href="#How_do_I_clear_the_screen?">How
  do I clear the screen?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
To clear the screen, you just have to print the special sequence that tells the
  terminal to clear the screen. Once you have that sequence, output it when you
  want to clear the screen.
<div class="Pp"></div>
You can use the Term::ANSIScreen module to get the special sequence. Import the
  &quot;cls&quot; function (or the &quot;:screen&quot; tag):
<div class="Pp"></div>
<pre>
    use Term::ANSIScreen qw(cls);
    my $clear_screen = cls();
    print $clear_screen;
</pre>
<div class="Pp"></div>
The Term::Cap module can also get the special sequence if you want to deal with
  the low-level details of terminal control. The &quot;Tputs&quot; method
  returns the string for the given capability:
<div class="Pp"></div>
<pre>
    use Term::Cap;
    my $terminal = Term::Cap-&gt;Tgetent( { OSPEED =&gt; 9600 } );
    my $clear_string = $terminal-&gt;Tputs('cl');
    print $clear_screen;
</pre>
<div class="Pp"></div>
On Windows, you can use the Win32::Console module. After creating an object for
  the output filehandle you want to affect, call the &quot;Cls&quot; method:
<div class="Pp"></div>
<pre>
    Win32::Console;
    my $OUT = Win32::Console-&gt;new(STD_OUTPUT_HANDLE);
    my $clear_string = $OUT-&gt;Cls;
    print $clear_screen;
</pre>
<div class="Pp"></div>
If you have a command-line program that does the job, you can call it in
  backticks to capture whatever it outputs so you can use it later:
<div class="Pp"></div>
<pre>
    my $clear_string = `clear`;
    print $clear_string;
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_get_the_screen_size?"><a class="selflink" href="#How_do_I_get_the_screen_size?">How
  do I get the screen size?</a></h2>
If you have Term::ReadKey module installed from CPAN, you can use it to fetch
  the width and height in characters and in pixels:
<div class="Pp"></div>
<pre>
    use Term::ReadKey;
    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
</pre>
<div class="Pp"></div>
This is more portable than the raw &quot;ioctl&quot;, but not as illustrative:
<div class="Pp"></div>
<pre>
    require 'sys/ioctl.ph';
    die &quot;no TIOCGWINSZ &quot; unless defined &amp;TIOCGWINSZ;
    open(my $tty_fh, &quot;+&lt;/dev/tty&quot;)                     or die &quot;No tty: $!&quot;;
    unless (ioctl($tty_fh, &amp;TIOCGWINSZ, $winsize='')) {
        die sprintf &quot;$0: ioctl TIOCGWINSZ (%08x: $!)\n&quot;, &amp;TIOCGWINSZ;
    }
    my ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
    print &quot;(row,col) = ($row,$col)&quot;;
    print &quot;  (xpixel,ypixel) = ($xpixel,$ypixel)&quot; if $xpixel || $ypixel;
    print &quot;\n&quot;;
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_ask_the_user_for_a_password?"><a class="selflink" href="#How_do_I_ask_the_user_for_a_password?">How
  do I ask the user for a password?</a></h2>
(This question has nothing to do with the web. See a different FAQ for that.)
<div class="Pp"></div>
There's an example of this in &quot;crypt&quot; in perlfunc). First, you put the
  terminal into &quot;no echo&quot; mode, then just read the password normally.
  You may do this with an old-style &quot;ioctl()&quot; function, POSIX terminal
  control (see POSIX or its documentation the Camel Book), or a call to the
  <b>stty</b> program, with varying degrees of portability.
<div class="Pp"></div>
You can also do this for most systems using the Term::ReadKey module from CPAN,
  which is easier to use and in theory more portable.
<div class="Pp"></div>
<pre>
    use Term::ReadKey;
    ReadMode('noecho');
    my $password = ReadLine(0);
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_read_and_write_the_serial_port?"><a class="selflink" href="#How_do_I_read_and_write_the_serial_port?">How
  do I read and write the serial port?</a></h2>
This depends on which operating system your program is running on. In the case
  of Unix, the serial ports will be accessible through files in
  &quot;/dev&quot;; on other systems, device names will doubtless differ.
  Several problem areas common to all device interaction are the following:
<dl class="Bl-tag">
  <dt class="It-tag">lockfiles</dt>
  <dd class="It-tag">Your system may use lockfiles to control multiple access.
      Make sure you follow the correct protocol. Unpredictable behavior can
      result from multiple processes reading from one device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">open mode</dt>
  <dd class="It-tag">If you expect to use both read and write operations on the
      device, you'll have to open it for update (see &quot;open&quot; in
      perlfunc for details). You may wish to open it without running the risk of
      blocking by using &quot;sysopen()&quot; and
      &quot;O_RDWR|O_NDELAY|O_NOCTTY&quot; from the Fcntl module (part of the
      standard perl distribution). See &quot;sysopen&quot; in perlfunc for more
      on this approach.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">end of line</dt>
  <dd class="It-tag">Some devices will be expecting a &quot;\r&quot; at the end
      of each line rather than a &quot;\n&quot;. In some ports of perl,
      &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix)
      ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to
      give the numeric values you want directly, using octal (&quot;\015&quot;),
      hex (&quot;0x0D&quot;), or as a control-character specification
      (&quot;\cM&quot;).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print DEV &quot;atv1\012&quot;;    # wrong, for some devices
    print DEV &quot;atv1\015&quot;;    # right, for some devices
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Even though with normal text files a &quot;\n&quot; will do the trick, there
      is still no unified scheme for terminating a line that is portable between
      Unix, DOS/Win, and Macintosh, except to terminate <i>ALL</i> line ends
      with &quot;\015\012&quot;, and strip what you don't need from the output.
      This applies especially to socket I/O and autoflushing, discussed
    next.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">flushing output</dt>
  <dd class="It-tag">If you expect characters to get to your device when you
      &quot;print()&quot; them, you'll want to autoflush that filehandle. You
      can use &quot;select()&quot; and the $| variable to control autoflushing
      (see &quot;$|&quot; in perlvar and &quot;select&quot; in perlfunc, or
      perlfaq5, &quot;How do I flush/unbuffer an output filehandle? Why must I
      do this?&quot;):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    my $old_handle = select($dev_fh);
    $| = 1;
    select($old_handle);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You'll also see code that does this without a temporary variable, as in
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    select((select($deb_handle), $| = 1)[0]);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or if you don't mind pulling in a few thousand lines of code just because
      you're afraid of a little $| variable:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use IO::Handle;
    $dev_fh-&gt;autoflush(1);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    As mentioned in the previous item, this still doesn't work when using socket
      I/O between Unix and Macintosh. You'll need to hard code your line
      terminators, in that case.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">non-blocking input</dt>
  <dd class="It-tag">If you are doing a blocking &quot;read()&quot; or
      &quot;sysread()&quot;, you'll have to arrange for an alarm handler to
      provide a timeout (see &quot;alarm&quot; in perlfunc). If you have a
      non-blocking open, you'll likely have a non-blocking read, which means you
      may have to use a 4-arg &quot;select()&quot; to determine whether I/O is
      ready on that device (see &quot;select&quot; in perlfunc.</dd>
</dl>
<div class="Pp"></div>
While trying to read from his caller-id box, the notorious Jamie Zawinski
  &quot;&lt;jwz@netscape.com&gt;&quot;, after much gnashing of teeth and
  fighting with &quot;sysread&quot;, &quot;sysopen&quot;, POSIX's
  &quot;tcgetattr&quot; business, and various other functions that go bump in
  the night, finally came up with this:
<div class="Pp"></div>
<pre>
    sub open_modem {
        use IPC::Open2;
        my $stty = `/bin/stty -g`;
        open2( \*MODEM_IN, \*MODEM_OUT, &quot;cu -l$modem_device -s2400 2&gt;&amp;1&quot;);
        # starting cu hoses /dev/tty's stty settings, even when it has
        # been opened on a pipe...
        system(&quot;/bin/stty $stty&quot;);
        $_ = &lt;MODEM_IN&gt;;
        chomp;
        if ( !m/^Connected/ ) {
            print STDERR &quot;$0: cu printed `$_' instead of `Connected'\n&quot;;
        }
    }
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_decode_encrypted_password_files?"><a class="selflink" href="#How_do_I_decode_encrypted_password_files?">How
  do I decode encrypted password files?</a></h2>
You spend lots and lots of money on dedicated hardware, but this is bound to get
  you talked about.
<div class="Pp"></div>
Seriously, you can't if they are Unix password files--the Unix password system
  employs one-way encryption. It's more like hashing than encryption. The best
  you can do is check whether something else hashes to the same string. You
  can't turn a hash back into the original string. Programs like Crack can
  forcibly (and intelligently) try to guess passwords, but don't (can't)
  guarantee quick success.
<div class="Pp"></div>
If you're worried about users selecting bad passwords, you should proactively
  check when they try to change their password (by modifying <i>passwd</i>(1),
  for example).
<h2 class="Ss" title="Ss" id="How_do_I_start_a_process_in_the_background?"><a class="selflink" href="#How_do_I_start_a_process_in_the_background?">How
  do I start a process in the background?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
There's not a single way to run code in the background so you don't have to wait
  for it to finish before your program moves on to other tasks. Process
  management depends on your particular operating system, and many of the
  techniques are covered in perlipc.
<div class="Pp"></div>
Several CPAN modules may be able to help, including IPC::Open2 or IPC::Open3,
  IPC::Run, Parallel::Jobs, Parallel::ForkManager, POE, Proc::Background, and
  Win32::Process. There are many other modules you might use, so check those
  namespaces for other options too.
<div class="Pp"></div>
If you are on a Unix-like system, you might be able to get away with a system
  call where you put an &quot;&amp;&quot; on the end of the command:
<div class="Pp"></div>
<pre>
    system(&quot;cmd &amp;&quot;)
</pre>
<div class="Pp"></div>
You can also try using &quot;fork&quot;, as described in perlfunc (although this
  is the same thing that many of the modules will do for you).
<dl class="Bl-tag">
  <dt class="It-tag">STDIN, STDOUT, and STDERR are shared</dt>
  <dd class="It-tag">Both the main process and the backgrounded one (the
      &quot;child&quot; process) share the same STDIN, STDOUT and STDERR
      filehandles. If both try to access them at once, strange things can
      happen. You may want to close or reopen these for the child. You can get
      around this with &quot;open&quot;ing a pipe (see &quot;open&quot; in
      perlfunc) but on some systems this means that the child process cannot
      outlive the parent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Signals</dt>
  <dd class="It-tag">You'll have to catch the SIGCHLD signal, and possibly
      SIGPIPE too. SIGCHLD is sent when the backgrounded process finishes.
      SIGPIPE is sent when you write to a filehandle whose child process has
      closed (an untrapped SIGPIPE can cause your program to silently die). This
      is not an issue with &quot;system(&quot;cmd&amp;&quot;)&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Zombies</dt>
  <dd class="It-tag">You have to be prepared to &quot;reap&quot; the child
      process when it finishes.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $SIG{CHLD} = sub { wait };
    $SIG{CHLD} = 'IGNORE';
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also use a double fork. You immediately &quot;wait()&quot; for your
      first child, and the init daemon will &quot;wait()&quot; for your
      grandchild once it exits.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    unless ($pid = fork) {
        unless (fork) {
            exec &quot;what you really wanna do&quot;;
            die &quot;exec failed!&quot;;
        }
        exit 0;
    }
    waitpid($pid, 0);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;Signals&quot; in perlipc for other examples of code to do this.
      Zombies are not an issue with &quot;system(&quot;prog
    &amp;&quot;)&quot;.</dd>
</dl>
<h2 class="Ss" title="Ss" id="How_do_I_trap_control_characters/signals?"><a class="selflink" href="#How_do_I_trap_control_characters/signals?">How
  do I trap control characters/signals?</a></h2>
You don't actually &quot;trap&quot; a control character. Instead, that character
  generates a signal which is sent to your terminal's currently foregrounded
  process group, which you then trap in your process. Signals are documented in
  &quot;Signals&quot; in perlipc and the section on &quot;Signals&quot; in the
  Camel.
<div class="Pp"></div>
You can set the values of the %SIG hash to be the functions you want to handle
  the signal. After perl catches the signal, it looks in %SIG for a key with the
  same name as the signal, then calls the subroutine value for that key.
<div class="Pp"></div>
<pre>
    # as an anonymous subroutine
    $SIG{INT} = sub { syswrite(STDERR, &quot;ouch\n&quot;, 5 ) };
    # or a reference to a function
    $SIG{INT} = \&amp;ouch;
    # or the name of the function as a string
    $SIG{INT} = &quot;ouch&quot;;
</pre>
<div class="Pp"></div>
Perl versions before 5.8 had in its C source code signal handlers which would
  catch the signal and possibly run a Perl function that you had set in %SIG.
  This violated the rules of signal handling at that level causing perl to dump
  core. Since version 5.8.0, perl looks at %SIG <b>after</b> the signal has been
  caught, rather than while it is being caught. Previous versions of this answer
  were incorrect.
<h2 class="Ss" title="Ss" id="How_do_I_modify_the_shadow_password_file_on_a_Unix_system?"><a class="selflink" href="#How_do_I_modify_the_shadow_password_file_on_a_Unix_system?">How
  do I modify the shadow password file on a Unix system?</a></h2>
If perl was installed correctly and your shadow library was written properly,
  the &quot;getpw*()&quot; functions described in perlfunc should in theory
  provide (read-only) access to entries in the shadow password file. To change
  the file, make a new shadow password file (the format varies from system to
  system--see <i>passwd</i>(1) for specifics) and use pwd_mkdb(8) to install it
  (see <i>pwd_mkdb</i>(8) for more details).
<h2 class="Ss" title="Ss" id="How_do_I_set_the_time_and_date?"><a class="selflink" href="#How_do_I_set_the_time_and_date?">How
  do I set the time and date?</a></h2>
Assuming you're running under sufficient permissions, you should be able to set
  the system-wide date and time by running the date(1) program. (There is no way
  to set the time and date on a per-process basis.) This mechanism will work for
  Unix, MS-DOS, Windows, and NT; the VMS equivalent is &quot;set time&quot;.
<div class="Pp"></div>
However, if all you want to do is change your time zone, you can probably get
  away with setting an environment variable:
<div class="Pp"></div>
<pre>
    $ENV{TZ} = &quot;MST7MDT&quot;;           # Unixish
    $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}=&quot;-5&quot; # vms
    system('trn', 'comp.lang.perl.misc');
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_sleep()_or_alarm()_for_under_a_second?"><a class="selflink" href="#How_can_I_sleep()_or_alarm()_for_under_a_second?">How
  can I <i>sleep()</i> or <i>alarm()</i> for under a second?</a></h2>
If you want finer granularity than the 1 second that the &quot;sleep()&quot;
  function provides, the easiest way is to use the &quot;select()&quot; function
  as documented in &quot;select&quot; in perlfunc. Try the Time::HiRes and the
  BSD::Itimer modules (available from CPAN, and starting from Perl 5.8
  Time::HiRes is part of the standard distribution).
<h2 class="Ss" title="Ss" id="How_can_I_measure_time_under_a_second?"><a class="selflink" href="#How_can_I_measure_time_under_a_second?">How
  can I measure time under a second?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
The Time::HiRes module (part of the standard distribution as of Perl 5.8)
  measures time with the &quot;gettimeofday()&quot; system call, which returns
  the time in microseconds since the epoch. If you can't install Time::HiRes for
  older Perls and you are on a Unixish system, you may be able to call
  gettimeofday(2) directly. See &quot;syscall&quot; in perlfunc.
<h2 class="Ss" title="Ss" id="How_can_I_do_an_atexit()_or_setjmp()/longjmp()?_(Exception_handling)"><a class="selflink" href="#How_can_I_do_an_atexit()_or_setjmp()/longjmp()?_(Exception_handling)">How
  can I do an <i>atexit()</i> or <i>setjmp()</i>/<i>longjmp()</i>? (Exception
  handling)</a></h2>
You can use the &quot;END&quot; block to simulate &quot;atexit()&quot;. Each
  package's &quot;END&quot; block is called when the program or thread ends. See
  the perlmod manpage for more details about &quot;END&quot; blocks.
<div class="Pp"></div>
For example, you can use this to make sure your filter program managed to finish
  its output without filling up the disk:
<div class="Pp"></div>
<pre>
    END {
        close(STDOUT) || die &quot;stdout close failed: $!&quot;;
    }
</pre>
<div class="Pp"></div>
The &quot;END&quot; block isn't called when untrapped signals kill the program,
  though, so if you use &quot;END&quot; blocks you should also use
<div class="Pp"></div>
<pre>
    use sigtrap qw(die normal-signals);
</pre>
<div class="Pp"></div>
Perl's exception-handling mechanism is its &quot;eval()&quot; operator. You can
  use &quot;eval()&quot; as &quot;setjmp&quot; and &quot;die()&quot; as
  &quot;longjmp&quot;. For details of this, see the section on signals,
  especially the time-out handler for a blocking &quot;flock()&quot; in
  &quot;Signals&quot; in perlipc or the section on &quot;Signals&quot; in
  <i>Programming Perl</i>.
<div class="Pp"></div>
If exception handling is all you're interested in, use one of the many CPAN
  modules that handle exceptions, such as Try::Tiny.
<div class="Pp"></div>
If you want the &quot;atexit()&quot; syntax (and an &quot;rmexit()&quot; as
  well), try the &quot;AtExit&quot; module available from CPAN.
<h2 class="Ss" title="Ss" id="Why_doesn't_my_sockets_program_work_under_System_V_(Solaris)?_What_does_the_error_message_&quot;Protocol_not_supported&quot;_mean?"><a class="selflink" href="#Why_doesn't_my_sockets_program_work_under_System_V_(Solaris)?_What_does_the_error_message_&quot;Protocol_not_supported&quot;_mean?">Why
  doesn't my sockets program work under System V (Solaris)? What does the error
  message &quot;Protocol not supported&quot; mean?</a></h2>
Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard
  socket constants. Since these were constant across all architectures, they
  were often hardwired into perl code. The proper way to deal with this is to
  &quot;use Socket&quot; to get the correct values.
<div class="Pp"></div>
Note that even though SunOS and Solaris are binary compatible, these values are
  different. Go figure.
<h2 class="Ss" title="Ss" id="How_can_I_call_my_system's_unique_C_functions_from_Perl?"><a class="selflink" href="#How_can_I_call_my_system's_unique_C_functions_from_Perl?">How
  can I call my system's unique C functions from Perl?</a></h2>
In most cases, you write an external module to do it--see the answer to
  &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;.
  However, if the function is a system call, and your system supports
  &quot;syscall()&quot;, you can use the &quot;syscall&quot; function
  (documented in perlfunc).
<div class="Pp"></div>
Remember to check the modules that came with your distribution, and CPAN as
  well--someone may already have written a module to do it. On Windows, try
  Win32::API. On Macs, try Mac::Carbon. If no module has an interface to the C
  function, you can inline a bit of C in your Perl source with Inline::C.
<h2 class="Ss" title="Ss" id="Where_do_I_get_the_include_files_to_do_ioctl()_or_syscall()?"><a class="selflink" href="#Where_do_I_get_the_include_files_to_do_ioctl()_or_syscall()?">Where
  do I get the include files to do <i>ioctl()</i> or <i>syscall()</i>?</a></h2>
Historically, these would be generated by the h2ph tool, part of the standard
  perl distribution. This program converts cpp(1) directives in C header files
  to files containing subroutine definitions, like &amp;SYS_getitimer, which you
  can use as arguments to your functions. It doesn't work perfectly, but it
  usually gets most of the job done. Simple files like <i>errno.h</i>,
  <i>syscall.h</i>, and <i>socket.h</i> were fine, but the hard ones like
  <i>ioctl.h</i> nearly always need to be hand-edited. Here's how to install the
  *.ph files:
<div class="Pp"></div>
<pre>
    1. Become the super-user
    2. cd /usr/include
    3. h2ph *.h */*.h
</pre>
<div class="Pp"></div>
If your system supports dynamic loading, for reasons of portability and sanity
  you probably ought to use h2xs (also part of the standard perl distribution).
  This tool converts C header files to Perl extensions. See perlxstut for how to
  get started with h2xs.
<div class="Pp"></div>
If your system doesn't support dynamic loading, you still probably ought to use
  h2xs. See perlxstut and ExtUtils::MakeMaker for more information (in brief,
  just use <b>make perl</b> instead of a plain <b>make</b> to rebuild perl with
  a new static extension).
<h2 class="Ss" title="Ss" id="Why_do_setuid_perl_scripts_complain_about_kernel_problems?"><a class="selflink" href="#Why_do_setuid_perl_scripts_complain_about_kernel_problems?">Why
  do setuid perl scripts complain about kernel problems?</a></h2>
Some operating systems have bugs in the kernel that make setuid scripts
  inherently insecure. Perl gives you a number of options (described in perlsec)
  to work around such systems.
<h2 class="Ss" title="Ss" id="How_can_I_open_a_pipe_both_to_and_from_a_command?"><a class="selflink" href="#How_can_I_open_a_pipe_both_to_and_from_a_command?">How
  can I open a pipe both to and from a command?</a></h2>
The IPC::Open2 module (part of the standard perl distribution) is an easy-to-use
  approach that internally uses &quot;pipe()&quot;, &quot;fork()&quot;, and
  &quot;exec()&quot; to do the job. Make sure you read the deadlock warnings in
  its documentation, though (see IPC::Open2). See &quot;Bidirectional
  Communication with Another Process&quot; in perlipc and &quot;Bidirectional
  Communication with Yourself&quot; in perlipc
<div class="Pp"></div>
You may also use the IPC::Open3 module (part of the standard perl distribution),
  but be warned that it has a different order of arguments from IPC::Open2 (see
  IPC::Open3).
<h2 class="Ss" title="Ss" id="Why_can't_I_get_the_output_of_a_command_with_system()?"><a class="selflink" href="#Why_can't_I_get_the_output_of_a_command_with_system()?">Why
  can't I get the output of a command with <i>system()</i>?</a></h2>
You're confusing the purpose of &quot;system()&quot; and backticks (``).
  &quot;system()&quot; runs a command and returns exit status information (as a
  16 bit value: the low 7 bits are the signal the process died from, if any, and
  the high 8 bits are the actual exit value). Backticks (``) run a command and
  return what it sent to STDOUT.
<div class="Pp"></div>
<pre>
    my $exit_status   = system(&quot;mail-users&quot;);
    my $output_string = `ls`;
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_capture_STDERR_from_an_external_command?"><a class="selflink" href="#How_can_I_capture_STDERR_from_an_external_command?">How
  can I capture STDERR from an external command?</a></h2>
There are three basic ways of running external commands:
<div class="Pp"></div>
<pre>
    system $cmd;        # using system()
    my $output = `$cmd`;        # using backticks (``)
    open (my $pipe_fh, &quot;$cmd |&quot;);    # using open()
</pre>
<div class="Pp"></div>
With &quot;system()&quot;, both STDOUT and STDERR will go the same place as the
  script's STDOUT and STDERR, unless the &quot;system()&quot; command redirects
  them. Backticks and &quot;open()&quot; read <b>only</b> the STDOUT of your
  command.
<div class="Pp"></div>
You can also use the &quot;open3()&quot; function from IPC::Open3. Benjamin
  Goldberg provides some sample code:
<div class="Pp"></div>
To capture a program's STDOUT, but discard its STDERR:
<div class="Pp"></div>
<pre>
    use IPC::Open3;
    use File::Spec;
    use Symbol qw(gensym);
    open(NULL, &quot;&gt;&quot;, File::Spec-&gt;devnull);
    my $pid = open3(gensym, \*PH, &quot;&gt;&amp;NULL&quot;, &quot;cmd&quot;);
    while( &lt;PH&gt; ) { }
    waitpid($pid, 0);
</pre>
<div class="Pp"></div>
To capture a program's STDERR, but discard its STDOUT:
<div class="Pp"></div>
<pre>
    use IPC::Open3;
    use File::Spec;
    use Symbol qw(gensym);
    open(NULL, &quot;&gt;&quot;, File::Spec-&gt;devnull);
    my $pid = open3(gensym, &quot;&gt;&amp;NULL&quot;, \*PH, &quot;cmd&quot;);
    while( &lt;PH&gt; ) { }
    waitpid($pid, 0);
</pre>
<div class="Pp"></div>
To capture a program's STDERR, and let its STDOUT go to our own STDERR:
<div class="Pp"></div>
<pre>
    use IPC::Open3;
    use Symbol qw(gensym);
    my $pid = open3(gensym, &quot;&gt;&amp;STDERR&quot;, \*PH, &quot;cmd&quot;);
    while( &lt;PH&gt; ) { }
    waitpid($pid, 0);
</pre>
<div class="Pp"></div>
To read both a command's STDOUT and its STDERR separately, you can redirect them
  to temp files, let the command run, then read the temp files:
<div class="Pp"></div>
<pre>
    use IPC::Open3;
    use Symbol qw(gensym);
    use IO::File;
    local *CATCHOUT = IO::File-&gt;new_tmpfile;
    local *CATCHERR = IO::File-&gt;new_tmpfile;
    my $pid = open3(gensym, &quot;&gt;&amp;CATCHOUT&quot;, &quot;&gt;&amp;CATCHERR&quot;, &quot;cmd&quot;);
    waitpid($pid, 0);
    seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
    while( &lt;CATCHOUT&gt; ) {}
    while( &lt;CATCHERR&gt; ) {}
</pre>
<div class="Pp"></div>
But there's no real need for <b>both</b> to be tempfiles... the following should
  work just as well, without deadlocking:
<div class="Pp"></div>
<pre>
    use IPC::Open3;
    use Symbol qw(gensym);
    use IO::File;
    local *CATCHERR = IO::File-&gt;new_tmpfile;
    my $pid = open3(gensym, \*CATCHOUT, &quot;&gt;&amp;CATCHERR&quot;, &quot;cmd&quot;);
    while( &lt;CATCHOUT&gt; ) {}
    waitpid($pid, 0);
    seek CATCHERR, 0, 0;
    while( &lt;CATCHERR&gt; ) {}
</pre>
<div class="Pp"></div>
And it'll be faster, too, since we can begin processing the program's stdout
  immediately, rather than waiting for the program to finish.
<div class="Pp"></div>
With any of these, you can change file descriptors before the call:
<div class="Pp"></div>
<pre>
    open(STDOUT, &quot;&gt;logfile&quot;);
    system(&quot;ls&quot;);
</pre>
<div class="Pp"></div>
or you can use Bourne shell file-descriptor redirection:
<div class="Pp"></div>
<pre>
    $output = `$cmd 2&gt;some_file`;
    open (PIPE, &quot;cmd 2&gt;some_file |&quot;);
</pre>
<div class="Pp"></div>
You can also use file-descriptor redirection to make STDERR a duplicate of
  STDOUT:
<div class="Pp"></div>
<pre>
    $output = `$cmd 2&gt;&amp;1`;
    open (PIPE, &quot;cmd 2&gt;&amp;1 |&quot;);
</pre>
<div class="Pp"></div>
Note that you <i>cannot</i> simply open STDERR to be a dup of STDOUT in your
  Perl program and avoid calling the shell to do the redirection. This doesn't
  work:
<div class="Pp"></div>
<pre>
    open(STDERR, &quot;&gt;&amp;STDOUT&quot;);
    $alloutput = `cmd args`;  # stderr still escapes
</pre>
<div class="Pp"></div>
This fails because the &quot;open()&quot; makes STDERR go to where STDOUT was
  going at the time of the &quot;open()&quot;. The backticks then make STDOUT go
  to a string, but don't change STDERR (which still goes to the old STDOUT).
<div class="Pp"></div>
Note that you <i>must</i> use Bourne shell (sh(1)) redirection syntax in
  backticks, not csh(1)! Details on why Perl's &quot;system()&quot; and backtick
  and pipe opens all use the Bourne shell are in the <i>versus/csh.whynot</i>
  article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in
  &lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; . To capture a command's
  STDERR and STDOUT together:
<div class="Pp"></div>
<pre>
    $output = `cmd 2&gt;&amp;1`;                       # either with backticks
    $pid = open(PH, &quot;cmd 2&gt;&amp;1 |&quot;);              # or with an open pipe
    while (&lt;PH&gt;) { }                            #    plus a read
</pre>
<div class="Pp"></div>
To capture a command's STDOUT but discard its STDERR:
<div class="Pp"></div>
<pre>
    $output = `cmd 2&gt;/dev/null`;                # either with backticks
    $pid = open(PH, &quot;cmd 2&gt;/dev/null |&quot;);       # or with an open pipe
    while (&lt;PH&gt;) { }                            #    plus a read
</pre>
<div class="Pp"></div>
To capture a command's STDERR but discard its STDOUT:
<div class="Pp"></div>
<pre>
    $output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;           # either with backticks
    $pid = open(PH, &quot;cmd 2&gt;&amp;1 1&gt;/dev/null |&quot;);  # or with an open pipe
    while (&lt;PH&gt;) { }                            #    plus a read
</pre>
<div class="Pp"></div>
To exchange a command's STDOUT and STDERR in order to capture the STDERR but
  leave its STDOUT to come out our old STDERR:
<div class="Pp"></div>
<pre>
    $output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;        # either with backticks
    $pid = open(PH, &quot;cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-|&quot;);# or with an open pipe
    while (&lt;PH&gt;) { }                            #    plus a read
</pre>
<div class="Pp"></div>
To read both a command's STDOUT and its STDERR separately, it's easiest to
  redirect them separately to files, and then read from those files when the
  program is done:
<div class="Pp"></div>
<pre>
    system(&quot;program args 1&gt;program.stdout 2&gt;program.stderr&quot;);
</pre>
<div class="Pp"></div>
Ordering is important in all these examples. That's because the shell processes
  file descriptor redirections in strictly left to right order.
<div class="Pp"></div>
<pre>
    system(&quot;prog args 1&gt;tmpfile 2&gt;&amp;1&quot;);
    system(&quot;prog args 2&gt;&amp;1 1&gt;tmpfile&quot;);
</pre>
<div class="Pp"></div>
The first command sends both standard out and standard error to the temporary
  file. The second command sends only the old standard output there, and the old
  standard error shows up on the old standard out.
<h2 class="Ss" title="Ss" id="Why_doesn't_open()_return_an_error_when_a_pipe_open_fails?"><a class="selflink" href="#Why_doesn't_open()_return_an_error_when_a_pipe_open_fails?">Why
  doesn't <i>open()</i> return an error when a pipe open fails?</a></h2>
If the second argument to a piped &quot;open()&quot; contains shell
  metacharacters, perl &quot;fork()&quot;s, then &quot;exec()&quot;s a shell to
  decode the metacharacters and eventually run the desired program. If the
  program couldn't be run, it's the shell that gets the message, not Perl. All
  your Perl program can find out is whether the shell itself could be
  successfully started. You can still capture the shell's STDERR and check it
  for error messages. See &quot;How can I capture STDERR from an external
  command?&quot; elsewhere in this document, or use the IPC::Open3 module.
<div class="Pp"></div>
If there are no shell metacharacters in the argument of &quot;open()&quot;, Perl
  runs the command directly, without using the shell, and can correctly report
  whether the command started.
<h2 class="Ss" title="Ss" id="What's_wrong_with_using_backticks_in_a_void_context?"><a class="selflink" href="#What's_wrong_with_using_backticks_in_a_void_context?">What's
  wrong with using backticks in a void context?</a></h2>
Strictly speaking, nothing. Stylistically speaking, it's not a good way to write
  maintainable code. Perl has several operators for running external commands.
  Backticks are one; they collect the output from the command for use in your
  program. The &quot;system&quot; function is another; it doesn't do this.
<div class="Pp"></div>
Writing backticks in your program sends a clear message to the readers of your
  code that you wanted to collect the output of the command. Why send a clear
  message that isn't true?
<div class="Pp"></div>
Consider this line:
<div class="Pp"></div>
<pre>
    `cat /etc/termcap`;
</pre>
<div class="Pp"></div>
You forgot to check $? to see whether the program even ran correctly. Even if
  you wrote
<div class="Pp"></div>
<pre>
    print `cat /etc/termcap`;
</pre>
<div class="Pp"></div>
this code could and probably should be written as
<div class="Pp"></div>
<pre>
    system(&quot;cat /etc/termcap&quot;) == 0
    or die &quot;cat program failed!&quot;;
</pre>
<div class="Pp"></div>
which will echo the cat command's output as it is generated, instead of waiting
  until the program has completed to print it out. It also checks the return
  value.
<div class="Pp"></div>
&quot;system&quot; also provides direct control over whether shell wildcard
  processing may take place, whereas backticks do not.
<h2 class="Ss" title="Ss" id="How_can_I_call_backticks_without_shell_processing?"><a class="selflink" href="#How_can_I_call_backticks_without_shell_processing?">How
  can I call backticks without shell processing?</a></h2>
This is a bit tricky. You can't simply write the command like this:
<div class="Pp"></div>
<pre>
    @ok = `grep @opts '$search_string' @filenames`;
</pre>
<div class="Pp"></div>
As of Perl 5.8.0, you can use &quot;open()&quot; with multiple arguments. Just
  like the list forms of &quot;system()&quot; and &quot;exec()&quot;, no shell
  escapes happen.
<div class="Pp"></div>
<pre>
    open( GREP, &quot;-|&quot;, 'grep', @opts, $search_string, @filenames );
    chomp(@ok = &lt;GREP&gt;);
    close GREP;
</pre>
<div class="Pp"></div>
You can also:
<div class="Pp"></div>
<pre>
    my @ok = ();
    if (open(GREP, &quot;-|&quot;)) {
        while (&lt;GREP&gt;) {
            chomp;
            push(@ok, $_);
        }
        close GREP;
    } else {
        exec 'grep', @opts, $search_string, @filenames;
    }
</pre>
<div class="Pp"></div>
Just as with &quot;system()&quot;, no shell escapes happen when you
  &quot;exec()&quot; a list. Further examples of this can be found in &quot;Safe
  Pipe Opens&quot; in perlipc.
<div class="Pp"></div>
Note that if you're using Windows, no solution to this vexing issue is even
  possible. Even though Perl emulates &quot;fork()&quot;, you'll still be stuck,
  because Windows does not have an argc/argv-style API.
<h2 class="Ss" title="Ss" id="Why_can't_my_script_read_from_STDIN_after_I_gave_it_EOF_(^D_on_Unix,_^Z_on_MS-DOS)?"><a class="selflink" href="#Why_can't_my_script_read_from_STDIN_after_I_gave_it_EOF_(^D_on_Unix,_^Z_on_MS-DOS)?">Why
  can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on
  MS-DOS)?</a></h2>
This happens only if your perl is compiled to use stdio instead of perlio, which
  is the default. Some (maybe all?) stdios set error and eof flags that you may
  need to clear. The POSIX module defines &quot;clearerr()&quot; that you can
  use. That is the technically correct way to do it. Here are some less reliable
  workarounds:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Try keeping around the seekpointer and go there, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    my $where = tell($log_fh);
    seek($log_fh, $where, 0);
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">If that doesn't work, try seeking to a different part of
      the file and then back.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">If that doesn't work, try seeking to a different part of
      the file, reading something, and then seeking back.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">If that doesn't work, give up on your stdio package and use
      sysread.</dd>
</dl>
<h2 class="Ss" title="Ss" id="How_can_I_convert_my_shell_script_to_perl?"><a class="selflink" href="#How_can_I_convert_my_shell_script_to_perl?">How
  can I convert my shell script to perl?</a></h2>
Learn Perl and rewrite it. Seriously, there's no simple converter. Things that
  are awkward to do in the shell are easy to do in Perl, and this very
  awkwardness is what would make a shell-&gt;perl converter nigh-on impossible
  to write. By rewriting it, you'll think about what you're really trying to do,
  and hopefully will escape the shell's pipeline datastream paradigm, which
  while convenient for some matters, causes many inefficiencies.
<h2 class="Ss" title="Ss" id="Can_I_use_perl_to_run_a_telnet_or_ftp_session?"><a class="selflink" href="#Can_I_use_perl_to_run_a_telnet_or_ftp_session?">Can
  I use perl to run a telnet or ftp session?</a></h2>
Try the Net::FTP, TCP::Client, and Net::Telnet modules (available from CPAN).
  &lt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&gt; will also help
  for emulating the telnet protocol, but Net::Telnet is quite probably easier to
  use.
<div class="Pp"></div>
If all you want to do is pretend to be telnet but don't need the initial telnet
  handshaking, then the standard dual-process approach will suffice:
<div class="Pp"></div>
<pre>
    use IO::Socket;             # new in 5.004
    my $handle = IO::Socket::INET-&gt;new('www.perl.com:80')
        or die &quot;can't connect to port 80 on www.perl.com $!&quot;;
    $handle-&gt;autoflush(1);
    if (fork()) {               # XXX: undef means failure
        select($handle);
        print while &lt;STDIN&gt;;    # everything from stdin to socket
    } else {
        print while &lt;$handle&gt;;  # everything from socket to stdout
    }
    close $handle;
    exit;
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_write_expect_in_Perl?"><a class="selflink" href="#How_can_I_write_expect_in_Perl?">How
  can I write expect in Perl?</a></h2>
Once upon a time, there was a library called <i>chat2.pl</i> (part of the
  standard perl distribution), which never really got finished. If you find it
  somewhere, <i>don't use it</i>. These days, your best bet is to look at the
  Expect module available from CPAN, which also requires two other modules from
  CPAN, IO::Pty and IO::Stty.
<h2 class="Ss" title="Ss" id="Is_there_a_way_to_hide_perl's_command_line_from_programs_such_as_&quot;ps&quot;?"><a class="selflink" href="#Is_there_a_way_to_hide_perl's_command_line_from_programs_such_as_&quot;ps&quot;?">Is
  there a way to hide perl's command line from programs such as
  &quot;ps&quot;?</a></h2>
First of all note that if you're doing this for security reasons (to avoid
  people seeing passwords, for example) then you should rewrite your program so
  that critical information is never given as an argument. Hiding the arguments
  won't make your program completely secure.
<div class="Pp"></div>
To actually alter the visible command line, you can assign to the variable $0 as
  documented in perlvar. This won't work on all operating systems, though.
  Daemon programs like sendmail place their state there, as in:
<div class="Pp"></div>
<pre>
    $0 = &quot;orcus [accepting connections]&quot;;
</pre>
<h2 class="Ss" title="Ss" id="I_{changed_directory,_modified_my_environment}_in_a_perl_script._How_come_the_change_disappeared_when_I_exited_the_script?_How_do_I_get_my_changes_to_be_visible?"><a class="selflink" href="#I_{changed_directory,_modified_my_environment}_in_a_perl_script._How_come_the_change_disappeared_when_I_exited_the_script?_How_do_I_get_my_changes_to_be_visible?">I
  {changed directory, modified my environment} in a perl script. How come the
  change disappeared when I exited the script? How do I get my changes to be
  visible?</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">Unix</dt>
  <dd class="It-tag">In the strictest sense, it can't be done--the script
      executes as a different process from the shell it was started from.
      Changes to a process are not reflected in its parent--only in any children
      created after the change. There is shell magic that may allow you to fake
      it by &quot;eval()&quot;ing the script's output in your shell; check out
      the comp.unix.questions FAQ for details.</dd>
</dl>
<h2 class="Ss" title="Ss" id="How_do_I_close_a_process's_filehandle_without_waiting_for_it_to_complete?"><a class="selflink" href="#How_do_I_close_a_process's_filehandle_without_waiting_for_it_to_complete?">How
  do I close a process's filehandle without waiting for it to complete?</a></h2>
Assuming your system supports such things, just send an appropriate signal to
  the process (see &quot;kill&quot; in perlfunc). It's common to first send a
  TERM signal, wait a little bit, and then send a KILL signal to finish it off.
<h2 class="Ss" title="Ss" id="How_do_I_fork_a_daemon_process?"><a class="selflink" href="#How_do_I_fork_a_daemon_process?">How
  do I fork a daemon process?</a></h2>
If by daemon process you mean one that's detached (disassociated from its tty),
  then the following process is reported to work on most Unixish systems.
  Non-Unix users should check their Your_OS::Process module for other solutions.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Open /dev/tty and use the TIOCNOTTY ioctl on it. See
      <i>tty</i>(1) for details. Or better yet, you can just use the
      &quot;POSIX::setsid()&quot; function, so you don't have to worry about
      process groups.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Change directory to /</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Reopen STDIN, STDOUT, and STDERR so they're not connected
      to the old tty.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Background yourself like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    fork &amp;&amp; exit;
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
The Proc::Daemon module, available from CPAN, provides a function to perform
  these actions for you.
<h2 class="Ss" title="Ss" id="How_do_I_find_out_if_I'm_running_interactively_or_not?"><a class="selflink" href="#How_do_I_find_out_if_I'm_running_interactively_or_not?">How
  do I find out if I'm running interactively or not?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
This is a difficult question to answer, and the best answer is only a guess.
<div class="Pp"></div>
What do you really want to know? If you merely want to know if one of your
  filehandles is connected to a terminal, you can try the &quot;-t&quot; file
  test:
<div class="Pp"></div>
<pre>
    if( -t STDOUT ) {
        print &quot;I'm connected to a terminal!\n&quot;;
    }
</pre>
<div class="Pp"></div>
However, you might be out of luck if you expect that means there is a real
  person on the other side. With the Expect module, another program can pretend
  to be a person. The program might even come close to passing the Turing test.
<div class="Pp"></div>
The IO::Interactive module does the best it can to give you an answer. Its
  &quot;is_interactive&quot; function returns an output filehandle; that
  filehandle points to standard output if the module thinks the session is
  interactive. Otherwise, the filehandle is a null handle that simply discards
  the output:
<div class="Pp"></div>
<pre>
    use IO::Interactive;
    print { is_interactive } &quot;I might go to standard output!\n&quot;;
</pre>
<div class="Pp"></div>
This still doesn't guarantee that a real person is answering your prompts or
  reading your output.
<div class="Pp"></div>
If you want to know how to handle automated testing for your distribution, you
  can check the environment. The CPAN Testers, for instance, set the value of
  &quot;AUTOMATED_TESTING&quot;:
<div class="Pp"></div>
<pre>
    unless( $ENV{AUTOMATED_TESTING} ) {
        print &quot;Hello interactive tester!\n&quot;;
    }
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_timeout_a_slow_event?"><a class="selflink" href="#How_do_I_timeout_a_slow_event?">How
  do I timeout a slow event?</a></h2>
Use the &quot;alarm()&quot; function, probably in conjunction with a signal
  handler, as documented in &quot;Signals&quot; in perlipc and the section on
  &quot;Signals&quot; in the Camel. You may instead use the more flexible
  Sys::AlarmCall module available from CPAN.
<div class="Pp"></div>
The &quot;alarm()&quot; function is not implemented on all versions of Windows.
  Check the documentation for your specific version of Perl.
<h2 class="Ss" title="Ss" id="How_do_I_set_CPU_limits?"><a class="selflink" href="#How_do_I_set_CPU_limits?">How
  do I set CPU limits?</a></h2>
(contributed by Xho)
<div class="Pp"></div>
Use the BSD::Resource module from CPAN. As an example:
<div class="Pp"></div>
<pre>
    use BSD::Resource;
    setrlimit(RLIMIT_CPU,10,20) or die $!;
</pre>
<div class="Pp"></div>
This sets the soft and hard limits to 10 and 20 seconds, respectively. After 10
  seconds of time spent running on the CPU (not &quot;wall&quot; time), the
  process will be sent a signal (XCPU on some systems) which, if not trapped,
  will cause the process to terminate. If that signal is trapped, then after 10
  more seconds (20 seconds in total) the process will be killed with a
  non-trappable signal.
<div class="Pp"></div>
See the BSD::Resource and your systems documentation for the gory details.
<h2 class="Ss" title="Ss" id="How_do_I_avoid_zombies_on_a_Unix_system?"><a class="selflink" href="#How_do_I_avoid_zombies_on_a_Unix_system?">How
  do I avoid zombies on a Unix system?</a></h2>
Use the reaper code from &quot;Signals&quot; in perlipc to call
  &quot;wait()&quot; when a SIGCHLD is received, or else use the double-fork
  technique described in &quot;How do I start a process in the background?&quot;
  in perlfaq8.
<h2 class="Ss" title="Ss" id="How_do_I_use_an_SQL_database?"><a class="selflink" href="#How_do_I_use_an_SQL_database?">How
  do I use an SQL database?</a></h2>
The DBI module provides an abstract interface to most database servers and
  types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files.
  The DBI module accesses each database type through a database driver, or DBD.
  You can see a complete list of available drivers on CPAN:
  http://www.cpan.org/modules/by-module/DBD/
  &lt;http://www.cpan.org/modules/by-module/DBD/&gt; . You can read more about
  DBI on &lt;http://dbi.perl.org/&gt; .
<div class="Pp"></div>
Other modules provide more specific access: Win32::ODBC, Alzabo,
  &quot;iodbc&quot;, and others found on CPAN Search:
  &lt;http://search.cpan.org/&gt; .
<h2 class="Ss" title="Ss" id="How_do_I_make_a_system()_exit_on_control-C?"><a class="selflink" href="#How_do_I_make_a_system()_exit_on_control-C?">How
  do I make a <i>system()</i> exit on control-C?</a></h2>
You can't. You need to imitate the &quot;system()&quot; call (see perlipc for
  sample code) and then have a signal handler for the INT signal that passes the
  signal on to the subprocess. Or you can check for it:
<div class="Pp"></div>
<pre>
    $rc = system($cmd);
    if ($rc &amp; 127) { die &quot;signal death&quot; }
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_open_a_file_without_blocking?"><a class="selflink" href="#How_do_I_open_a_file_without_blocking?">How
  do I open a file without blocking?</a></h2>
If you're lucky enough to be using a system that supports non-blocking reads
  (most Unixish systems do), you need only to use the &quot;O_NDELAY&quot; or
  &quot;O_NONBLOCK&quot; flag from the &quot;Fcntl&quot; module in conjunction
  with &quot;sysopen()&quot;:
<div class="Pp"></div>
<pre>
    use Fcntl;
    sysopen(my $fh, &quot;/foo/somefile&quot;, O_WRONLY|O_NDELAY|O_CREAT, 0644)
        or die &quot;can't open /foo/somefile: $!&quot;:
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_tell_the_difference_between_errors_from_the_shell_and_perl?"><a class="selflink" href="#How_do_I_tell_the_difference_between_errors_from_the_shell_and_perl?">How
  do I tell the difference between errors from the shell and perl?</a></h2>
(answer contributed by brian d foy)
<div class="Pp"></div>
When you run a Perl script, something else is running the script for you, and
  that something else may output error messages. The script might emit its own
  warnings and error messages. Most of the time you cannot tell who said what.
<div class="Pp"></div>
You probably cannot fix the thing that runs perl, but you can change how perl
  outputs its warnings by defining a custom warning and die functions.
<div class="Pp"></div>
Consider this script, which has an error you may not notice immediately.
<div class="Pp"></div>
<pre>
    #!/usr/locl/bin/perl
    print &quot;Hello World\n&quot;;
</pre>
<div class="Pp"></div>
I get an error when I run this from my shell (which happens to be bash). That
  may look like perl forgot it has a &quot;print()&quot; function, but my
  shebang line is not the path to perl, so the shell runs the script, and I get
  the error.
<div class="Pp"></div>
<pre>
    $ ./test
    ./test: line 3: print: command not found
</pre>
<div class="Pp"></div>
A quick and dirty fix involves a little bit of code, but this may be all you
  need to figure out the problem.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    BEGIN {
        $SIG{__WARN__} = sub{ print STDERR &quot;Perl: &quot;, @_; };
        $SIG{__DIE__}  = sub{ print STDERR &quot;Perl: &quot;, @_; exit 1};
    }
    $a = 1 + undef;
    $x / 0;
    __END__
</pre>
<div class="Pp"></div>
The perl message comes out with &quot;Perl&quot; in front. The &quot;BEGIN&quot;
  block works at compile time so all of the compilation errors and warnings get
  the &quot;Perl:&quot; prefix too.
<div class="Pp"></div>
<pre>
    Perl: Useless use of division (/) in void context at ./test line 9.
    Perl: Name &quot;main::a&quot; used only once: possible typo at ./test line 8.
    Perl: Name &quot;main::x&quot; used only once: possible typo at ./test line 9.
    Perl: Use of uninitialized value in addition (+) at ./test line 8.
    Perl: Use of uninitialized value in division (/) at ./test line 9.
    Perl: Illegal division by zero at ./test line 9.
    Perl: Illegal division by zero at -e line 3.
</pre>
<div class="Pp"></div>
If I don't see that &quot;Perl:&quot;, it's not from perl.
<div class="Pp"></div>
You could also just know all the perl errors, and although there are some people
  who may know all of them, you probably don't. However, they all should be in
  the perldiag manpage. If you don't find the error in there, it probably isn't
  a perl error.
<div class="Pp"></div>
Looking up every message is not the easiest way, so let perl to do it for you.
  Use the diagnostics pragma with turns perl's normal messages into longer
  discussions on the topic.
<div class="Pp"></div>
<pre>
    use diagnostics;
</pre>
<div class="Pp"></div>
If you don't get a paragraph or two of expanded discussion, it might not be
  perl's message.
<h2 class="Ss" title="Ss" id="How_do_I_install_a_module_from_CPAN?"><a class="selflink" href="#How_do_I_install_a_module_from_CPAN?">How
  do I install a module from CPAN?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
The easiest way is to have a module also named CPAN do it for you by using the
  &quot;cpan&quot; command that comes with Perl. You can give it a list of
  modules to install:
<div class="Pp"></div>
<pre>
    $ cpan IO::Interactive Getopt::Whatever
</pre>
<div class="Pp"></div>
If you prefer &quot;CPANPLUS&quot;, it's just as easy:
<div class="Pp"></div>
<pre>
    $ cpanp i IO::Interactive Getopt::Whatever
</pre>
<div class="Pp"></div>
If you want to install a distribution from the current directory, you can tell
  &quot;CPAN.pm&quot; to install &quot;.&quot; (the full stop):
<div class="Pp"></div>
<pre>
    $ cpan .
</pre>
<div class="Pp"></div>
See the documentation for either of those commands to see what else you can do.
<div class="Pp"></div>
If you want to try to install a distribution by yourself, resolving all
  dependencies on your own, you follow one of two possible build paths.
<div class="Pp"></div>
For distributions that use <i>Makefile.PL</i>:
<div class="Pp"></div>
<pre>
    $ perl Makefile.PL
    $ make test install
</pre>
<div class="Pp"></div>
For distributions that use <i>Build.PL</i>:
<div class="Pp"></div>
<pre>
    $ perl Build.PL
    $ ./Build test
    $ ./Build install
</pre>
<div class="Pp"></div>
Some distributions may need to link to libraries or other third-party code and
  their build and installation sequences may be more complicated. Check any
  <i>README</i> or <i>INSTALL</i> files that you may find.
<h2 class="Ss" title="Ss" id="What's_the_difference_between_require_and_use?"><a class="selflink" href="#What's_the_difference_between_require_and_use?">What's
  the difference between require and use?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
Perl runs &quot;require&quot; statement at run-time. Once Perl loads, compiles,
  and runs the file, it doesn't do anything else. The &quot;use&quot; statement
  is the same as a &quot;require&quot; run at compile-time, but Perl also calls
  the &quot;import&quot; method for the loaded package. These two are the same:
<div class="Pp"></div>
<pre>
    use MODULE qw(import list);
    BEGIN {
        require MODULE;
        MODULE-&gt;import(import list);
    }
</pre>
<div class="Pp"></div>
However, you can suppress the &quot;import&quot; by using an explicit, empty
  import list. Both of these still happen at compile-time:
<div class="Pp"></div>
<pre>
    use MODULE ();
    BEGIN {
        require MODULE;
    }
</pre>
<div class="Pp"></div>
Since &quot;use&quot; will also call the &quot;import&quot; method, the actual
  value for &quot;MODULE&quot; must be a bareword. That is, &quot;use&quot;
  cannot load files by name, although &quot;require&quot; can:
<div class="Pp"></div>
<pre>
    require &quot;$ENV{HOME}/lib/Foo.pm&quot;; # no @INC searching!
</pre>
<div class="Pp"></div>
See the entry for &quot;use&quot; in perlfunc for more details.
<h2 class="Ss" title="Ss" id="How_do_I_keep_my_own_module/library_directory?"><a class="selflink" href="#How_do_I_keep_my_own_module/library_directory?">How
  do I keep my own module/library directory?</a></h2>
When you build modules, tell Perl where to install the modules.
<div class="Pp"></div>
If you want to install modules for your own use, the easiest way might be
  local::lib, which you can download from CPAN. It sets various installation
  settings for you, and uses those same settings within your programs.
<div class="Pp"></div>
If you want more flexibility, you need to configure your CPAN client for your
  particular situation.
<div class="Pp"></div>
For &quot;Makefile.PL&quot;-based distributions, use the INSTALL_BASE option
  when generating Makefiles:
<div class="Pp"></div>
<pre>
    perl Makefile.PL INSTALL_BASE=/mydir/perl
</pre>
<div class="Pp"></div>
You can set this in your &quot;CPAN.pm&quot; configuration so modules
  automatically install in your private library directory when you use the
  CPAN.pm shell:
<div class="Pp"></div>
<pre>
    % cpan
    cpan&gt; o conf makepl_arg INSTALL_BASE=/mydir/perl
    cpan&gt; o conf commit
</pre>
<div class="Pp"></div>
For &quot;Build.PL&quot;-based distributions, use the --install_base option:
<div class="Pp"></div>
<pre>
    perl Build.PL --install_base /mydir/perl
</pre>
<div class="Pp"></div>
You can configure &quot;CPAN.pm&quot; to automatically use this option too:
<div class="Pp"></div>
<pre>
    % cpan
    cpan&gt; o conf mbuild_arg &quot;--install_base /mydir/perl&quot;
    cpan&gt; o conf commit
</pre>
<div class="Pp"></div>
INSTALL_BASE tells these tools to put your modules into
  <i>/mydir/perl/lib/perl5</i>. See &quot;How do I add a directory to my include
  path (@INC) at runtime?&quot; for details on how to run your newly installed
  modules.
<div class="Pp"></div>
There is one caveat with INSTALL_BASE, though, since it acts differently from
  the PREFIX and LIB settings that older versions of ExtUtils::MakeMaker
  advocated. INSTALL_BASE does not support installing modules for multiple
  versions of Perl or different architectures under the same directory. You
  should consider whether you really want that and, if you do, use the older
  PREFIX and LIB settings. See the ExtUtils::Makemaker documentation for more
  details.
<h2 class="Ss" title="Ss" id="How_do_I_add_the_directory_my_program_lives_in_to_the_module/library_search_path?"><a class="selflink" href="#How_do_I_add_the_directory_my_program_lives_in_to_the_module/library_search_path?">How
  do I add the directory my program lives in to the module/library search
  path?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
If you know the directory already, you can add it to @INC as you would for any
  other directory. You might &lt;use lib&gt; if you know the directory at
  compile time:
<div class="Pp"></div>
<pre>
    use lib $directory;
</pre>
<div class="Pp"></div>
The trick in this task is to find the directory. Before your script does
  anything else (such as a &quot;chdir&quot;), you can get the current working
  directory with the &quot;Cwd&quot; module, which comes with Perl:
<div class="Pp"></div>
<pre>
    BEGIN {
        use Cwd;
        our $directory = cwd;
    }
    use lib $directory;
</pre>
<div class="Pp"></div>
You can do a similar thing with the value of $0, which holds the script name.
  That might hold a relative path, but &quot;rel2abs&quot; can turn it into an
  absolute path. Once you have the
<div class="Pp"></div>
<pre>
    BEGIN {
        use File::Spec::Functions qw(rel2abs);
        use File::Basename qw(dirname);
        my $path   = rel2abs( $0 );
        our $directory = dirname( $path );
    }
    use lib $directory;
</pre>
<div class="Pp"></div>
The FindBin module, which comes with Perl, might work. It finds the directory of
  the currently running script and puts it in $Bin, which you can then use to
  construct the right library path:
<div class="Pp"></div>
<pre>
    use FindBin qw($Bin);
</pre>
<div class="Pp"></div>
You can also use local::lib to do much of the same thing. Install modules using
  local::lib's settings then use the module in your program:
<div class="Pp"></div>
<pre>
     use local::lib; # sets up a local lib at ~/perl5
</pre>
<div class="Pp"></div>
See the local::lib documentation for more details.
<h2 class="Ss" title="Ss" id="How_do_I_add_a_directory_to_my_include_path_(@INC)_at_runtime?"><a class="selflink" href="#How_do_I_add_a_directory_to_my_include_path_(@INC)_at_runtime?">How
  do I add a directory to my include path (@INC) at runtime?</a></h2>
Here are the suggested ways of modifying your include path, including
  environment variables, run-time switches, and in-code statements:
<dl class="Bl-tag">
  <dt class="It-tag">the &quot;PERLLIB&quot; environment variable</dt>
  <dd class="It-tag">
    <pre>
    $ export PERLLIB=/path/to/my/dir
    $ perl program.pl
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">the &quot;PERL5LIB&quot; environment variable</dt>
  <dd class="It-tag">
    <pre>
    $ export PERL5LIB=/path/to/my/dir
    $ perl program.pl
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">the &quot;perl -Idir&quot; command line flag</dt>
  <dd class="It-tag">
    <pre>
    $ perl -I/path/to/my/dir program.pl
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">the &quot;lib&quot; pragma:</dt>
  <dd class="It-tag">
    <pre>
    use lib &quot;$ENV{HOME}/myown_perllib&quot;;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">the local::lib module:</dt>
  <dd class="It-tag">
    <pre>
    use local::lib;
    use local::lib &quot;~/myown_perllib&quot;;
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
The last is particularly useful because it knows about machine-dependent
  architectures. The &quot;lib.pm&quot; pragmatic module was first included with
  the 5.002 release of Perl.
<h2 class="Ss" title="Ss" id="What_is_socket.ph_and_where_do_I_get_it?"><a class="selflink" href="#What_is_socket.ph_and_where_do_I_get_it?">What
  is socket.ph and where do I get it?</a></h2>
It's a Perl 4 style file defining values for system networking constants.
  Sometimes it is built using h2ph when Perl is installed, but other times it is
  not. Modern programs should use &quot;use Socket;&quot; instead.
<h1 class="Sh" title="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="selflink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and other authors
  as noted. All rights reserved.
<div class="Pp"></div>
This documentation is free; you can redistribute it and/or modify it under the
  same terms as Perl itself.
<div class="Pp"></div>
Irrespective of its distribution, all code examples in this file are hereby
  placed into the public domain. You are permitted and encouraged to use this
  code in your own programs for fun or for profit as you see fit. A simple
  comment in the code giving credit would be courteous but is not
  required.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
