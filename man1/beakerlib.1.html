<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:54:34 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>BEAKERLIB(1) User Contributed Perl Documentation
BEAKERLIB(1)</p>

<p style="margin-top: 1em">NAME <br>
BeakerLib - a shell-level integration testing library</p>

<p style="margin-top: 1em">DESCRIPTION <br>
BeakerLib is a shell-level integration testing library,
providing convenience functions which simplify writing,
running and analysis of integration and blackbox tests.</p>

<p style="margin-top: 1em">The essential features
include:</p>

<p style="margin-top: 1em">&Acirc;&middot; Journal -
uniform logging mechanism (logs &amp; results saved in
flexible XML format, easy to compare results &amp; generate
reports)</p>

<p style="margin-top: 1em">&Acirc;&middot; Phases - logical
grouping of test actions, clear separation of setup / test /
cleanup (preventing false fails)</p>

<p style="margin-top: 1em">&Acirc;&middot; Asserts - common
checks affecting the overall results of the individual
phases (checking for exit codes, file existence &amp;
content...)</p>

<p style="margin-top: 1em">&Acirc;&middot; Helpers -
convenience functions for common operations such as managing
services, backup &amp; restore</p>

<p style="margin-top: 1em">The main script sets the
&quot;BEAKERLIB&quot; variable and sources other scripts
where the actual functions are defined. You should source it
at the beginning of your test with:</p>

<p style="margin-top: 1em">.
/usr/share/beakerlib/beakerlib.sh</p>

<p style="margin-top: 1em">See the EXAMPLES section for
quick start inspiration.</p>

<p style="margin-top: 1em">See the BKRDOC section for more
information about Automated documentation generator for
BeakerLib tests.</p>

<p style="margin-top: 1em">FUNCTIONS <br>
Journalling <br>
rlJournalStart</p>

<p style="margin-top: 1em">Initialize the journal file.</p>

<p style="margin-top: 1em">rlJournalStart</p>

<p style="margin-top: 1em">Run on the very beginning of
your script to initialize journalling functionality.</p>

<p style="margin-top: 1em">rlJournalEnd</p>

<p style="margin-top: 1em">Summarize the test run and
upload the journal file.</p>

<p style="margin-top: 1em">rlJournalEnd</p>

<p style="margin-top: 1em">Run on the very end of your
script to print summary of the whole test run, generate
OUTPUTFILE and include journal in Beaker logs.</p>

<p style="margin-top: 1em">rlJournalPrint</p>

<p style="margin-top: 1em">Print the content of the journal
in pretty xml format.</p>

<p style="margin-top: 1em">rlJournalPrint [type]</p>

<p style="margin-top: 1em">type <br>
Can be either &rsquo;raw&rsquo; or &rsquo;pretty&rsquo;,
with the latter as a default. Raw: xml is in raw form, no
indentation etc Pretty: xml is pretty printed, indented,
with one record per line</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">&lt;?xml
version=&quot;1.0&quot;?&gt; <br>
&lt;BEAKER_TEST&gt; <br>
&lt;test_id&gt;debugging&lt;/test_id&gt; <br>
&lt;package&gt;setup&lt;/package&gt; <br>

&lt;pkgdetails&gt;setup-2.8.9-1.fc12.noarch&lt;/pkgdetails&gt;
<br>
&lt;starttime&gt;2010-02-08 15:17:47&lt;/starttime&gt; <br>
&lt;endtime&gt;2010-02-08 15:17:47&lt;/endtime&gt; <br>

&lt;testname&gt;/examples/beakerlib/Sanity/simple&lt;/testname&gt;
<br>
&lt;release&gt;Fedora release 12
(Constantine)&lt;/release&gt; <br>
&lt;hostname&gt;localhost&lt;/hostname&gt; <br>
&lt;arch&gt;i686&lt;/arch&gt; <br>
&lt;purpose&gt;PURPOSE of /examples/beakerlib/Sanity/simple
<br>
Description: Minimal BeakerLib sanity test <br>
Author: Petr Splichal
&amp;lt;psplicha@redhat.com&amp;gt;</p>

<p style="margin-top: 1em">This is a minimal sanity test
for BeakerLib. It contains a single <br>
phase with a couple of asserts. We Just check that the
&quot;setup&quot; <br>
package is installed and that there is a sane /etc/passwd
file. <br>
&lt;/purpose&gt; <br>
&lt;log&gt; <br>
&lt;phase endtime=&quot;2010-02-08 15:17:47&quot;
name=&quot;Test&quot; result=&quot;PASS&quot; <br>
score=&quot;0&quot; starttime=&quot;2010-02-08
15:17:47&quot; type=&quot;FAIL&quot;&gt; <br>
&lt;test message=&quot;Checking for the presence of setup
rpm&quot;&gt;PASS&lt;/test&gt; <br>
&lt;test message=&quot;File /etc/passwd should
exist&quot;&gt;PASS&lt;/test&gt; <br>
&lt;test message=&quot;File &rsquo;/etc/passwd&rsquo; should
contain &rsquo;root&rsquo;&quot;&gt;PASS&lt;/test&gt; <br>
&lt;/phase&gt; <br>
&lt;/log&gt; <br>
&lt;/BEAKER_TEST&gt;</p>

<p style="margin-top: 1em">rlJournalPrintText</p>

<p style="margin-top: 1em">Print the content of the journal
in pretty text format.</p>

<p style="margin-top: 1em">rlJournalPrintText
[--full-journal]</p>

<p style="margin-top: 1em">--full-journal <br>
With this option, additional items like some HW information
will be printed in the journal.</p>

<p style="margin-top: 1em">Example:</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: TEST PROTOCOL <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">:: [ LOG ] :: Test run ID :
debugging <br>
:: [ LOG ] :: Package : debugging <br>
:: [ LOG ] :: Test started : 2010-02-08 14:45:57 <br>
:: [ LOG ] :: Test finished : 2010-02-08 14:45:58 <br>
:: [ LOG ] :: Test name : <br>
:: [ LOG ] :: Distro: : Fedora release 12 (Constantine) <br>
:: [ LOG ] :: Hostname : localhost <br>
:: [ LOG ] :: Architecture : i686</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: Test description <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">PURPOSE of
/examples/beakerlib/Sanity/simple <br>
Description: Minimal BeakerLib sanity test <br>
Author: Petr Splichal &lt;psplicha@redhat.com&gt;</p>

<p style="margin-top: 1em">This is a minimal sanity test
for BeakerLib. It contains a single <br>
phase with a couple of asserts. We Just check that the
&quot;setup&quot; <br>
package is installed and that there is a sane /etc/passwd
file.</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: Test <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">:: [ PASS ] :: Checking for the
presence of setup rpm <br>
:: [ PASS ] :: File /etc/passwd should exist <br>
:: [ PASS ] :: File &rsquo;/etc/passwd&rsquo; should contain
&rsquo;root&rsquo; <br>
:: [ LOG ] :: Duration: 1s <br>
:: [ LOG ] :: Assertions: 3 good, 0 bad <br>
:: [ PASS ] :: RESULT: Test</p>

<p style="margin-top: 1em">rlGetTestState</p>

<p style="margin-top: 1em">Returns number of failed asserts
in so far, 255 if there are more then 255 failures.</p>

<p style="margin-top: 1em">rlGetTestState</p>

<p style="margin-top: 1em">rlGetPhaseState</p>

<p style="margin-top: 1em">Returns number of failed asserts
in current phase so far, 255 if there are more then 255
failures.</p>

<p style="margin-top: 1em">rlGetPhaseState</p>

<p style="margin-top: 1em">Logging <br>
rlLog</p>

<p style="margin-top: 1em">rlLogDebug</p>

<p style="margin-top: 1em">rlLogInfo</p>

<p style="margin-top: 1em">rlLogWarning</p>

<p style="margin-top: 1em">rlLogError</p>

<p style="margin-top: 1em">rlLogFatal</p>

<p style="margin-top: 1em">Create a time/priority-labelled
message in the log. There is a bunch of aliases which can
create messages formated as DEBUG/INFO/WARNING/ERROR or
FATAL (but you would probably <br>
want to use rlDie instead of the last one).</p>

<p style="margin-top: 1em">rlLog message [logfile]
[priority] [label]</p>

<p style="margin-top: 1em">message <br>
Message you want to show (use quotes when invoking).</p>

<p style="margin-top: 1em">logfile <br>
Log file. If not supplied, OUTPUTFILE is assumed.</p>

<p style="margin-top: 1em">priority <br>
Priority of the log.</p>

<p style="margin-top: 1em">label <br>
Print this text instead of time in log label.</p>

<p style="margin-top: 1em">rlDie</p>

<p style="margin-top: 1em">Create a time-labelled message
in the log, report test result, upload logs, close
unfinished phase and terminate the test.</p>

<p style="margin-top: 1em">rlDie message [file...]</p>

<p style="margin-top: 1em">message <br>
Message you want to show (use quotes when invoking) - this
option is mandatory.</p>

<p style="margin-top: 1em">file <br>
Files (logs) you want to upload as well.
&quot;rlBundleLogs&quot; will be used for it. Files which
are not readable will be excluded before calling
&quot;rlBundleLogs&quot;, so it is safe to <br>
call even with possibly not existent logs and it will
succeed.</p>

<p style="margin-top: 1em">rlBundleLogs</p>

<p style="margin-top: 1em">Create a tarball of files (e.g.
logs) and attach them to the test result.</p>

<p style="margin-top: 1em">rlBundleLogs package file
[file...]</p>

<p style="margin-top: 1em">package <br>
Name of the package. Will be used as a part of the tar-ball
name.</p>

<p style="margin-top: 1em">file <br>
File(s) to be packed and submitted.</p>

<p style="margin-top: 1em">Returns result of submiting the
tarball.</p>

<p style="margin-top: 1em">rlFileSubmit</p>

<p style="margin-top: 1em">Resolves absolute path to the
file, replaces / for - and uploads this renamed file using
rhts-submit-log. It also allows you to specify your custom
name for the uploaded file.</p>

<p style="margin-top: 1em">rlFileSubmit [-s sep]
path_to_file [required_name]</p>

<p style="margin-top: 1em">-s sep <br>
Sets separator (i.e. the replacement of the /) to sep.</p>

<p style="margin-top: 1em">path_to_file <br>
Either absolute or relative path to file. Relative path is
converted to absolute.</p>

<p style="margin-top: 1em">required_name <br>
Default behavior renames file to full_path_to_file with /
replaced for -, if this does not suit your needs, you can
specify the name using this option.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">rlFileSubmit logfile.txt -&gt;
logfile.txt cd /etc; rlFileSubmit ./passwd -&gt; etc-passwd
rlFileSubmit /etc/passwd -&gt; etc-passwd rlFileSubmit
/etc/passwd my-top-secret_file -&gt; my- <br>
top-secret-file rlFileSubmit -s &rsquo;_&rsquo; /etc/passwd
-&gt; etc_passwd</p>

<p style="margin-top: 1em">Info <br>
rlShowPackageVersion</p>

<p style="margin-top: 1em">Shows a message about version of
packages.</p>

<p style="margin-top: 1em">rlShowPackageVersion package
[package...]</p>

<p style="margin-top: 1em">package <br>
Name of a package(s) you want to log.</p>

<p style="margin-top: 1em">rlGetArch</p>

<p style="margin-top: 1em">This function is deprecated. Use
rlGetPrimaryArch or rlGetSecondaryArch instead, or use
uname. This function will be only kept for
compatibility.</p>

<p style="margin-top: 1em">Return base arch for the current
system (good when you need base arch on a multilib
system).</p>

<p style="margin-top: 1em">rlGetArch</p>

<p style="margin-top: 1em">On an i686 system you will get
i386, on a ppc64 you will get ppc.</p>

<p style="margin-top: 1em">rlGetPrimaryArch</p>

<p style="margin-top: 1em">Return primary arch for the
current system (good when you need base arch on a multilib
system).</p>

<p style="margin-top: 1em">rlGetPrimaryArch</p>

<p style="margin-top: 1em">rlGetSecondaryArch</p>

<p style="margin-top: 1em">Return base arch for the current
system (good when you need base arch on a multilib
system).</p>

<p style="margin-top: 1em">rlGetSecondaryArch</p>

<p style="margin-top: 1em">rlGetDistroRelease</p>

<p style="margin-top: 1em">rlGetDistroVariant</p>

<p style="margin-top: 1em">Return release or variant of the
distribution on the system.</p>

<p style="margin-top: 1em">rlGetDistroRelease <br>
rlGetDistroVariant</p>

<p style="margin-top: 1em">For example on the RHEL-4-AS you
will get release 4 and variant AS, on the RHEL-5-Client you
will get release 5 and variant Client.</p>

<p style="margin-top: 1em">rlShowRunningKernel</p>

<p style="margin-top: 1em">Log a message with version of
the currently running kernel.</p>

<p style="margin-top: 1em">rlShowRunningKernel</p>

<p style="margin-top: 1em">Phases <br>
rlPhaseStart</p>

<p style="margin-top: 1em">Starts a phase of a specific
type. The final phase result is based on all asserts
included in the phase. Do not forget to end phase with
&quot;rlPhaseEnd&quot; when you are done.</p>

<p style="margin-top: 1em">rlPhaseStart type [name]</p>

<p style="margin-top: 1em">type <br>
Type of the phase, one of the following:</p>

<p style="margin-top: 1em">FAIL <br>
When assert fails here, phase will report a FAIL.</p>

<p style="margin-top: 1em">WARN <br>
When assert fails here, phase will report a WARN.</p>

<p style="margin-top: 1em">name <br>
Optional name of the phase (if not provided, one will be
generated).</p>

<p style="margin-top: 1em">If all asserts included in the
phase pass, phase reports PASS.</p>

<p style="margin-top: 1em">rlPhaseEnd</p>

<p style="margin-top: 1em">End current phase, summarize
asserts included and report phase result.</p>

<p style="margin-top: 1em">rlPhaseEnd</p>

<p style="margin-top: 1em">Final phase result is based on
included asserts and phase type.</p>

<p style="margin-top: 1em">rlPhaseStartSetup</p>

<p style="margin-top: 1em">rlPhaseStartTest</p>

<p style="margin-top: 1em">rlPhaseStartCleanup</p>

<p style="margin-top: 1em">Start a phase of the specified
type: Setup -&gt; WARN, Test -&gt; FAIL, Cleanup -&gt;
WARN.</p>

<p style="margin-top: 1em">rlPhaseStartSetup [name] <br>
rlPhaseStartTest [name] <br>
rlPhaseStartCleanup [name]</p>

<p style="margin-top: 1em">name <br>
Optional name of the phase. If not specified, default
Setup/Test/Cleanup are used.</p>

<p style="margin-top: 1em">If you do not want these
shortcuts, use plain &quot;rlPhaseStart&quot; function.</p>

<p style="margin-top: 1em">Metric <br>
rlLogMetricLow</p>

<p style="margin-top: 1em">Log a metric, which should be as
low as possible to the journal. (Example: memory
consumption, run time)</p>

<p style="margin-top: 1em">rlLogMetricLow name value
[tolerance]</p>

<p style="margin-top: 1em">name <br>
Name of the metric. It has to be unique in a phase.</p>

<p style="margin-top: 1em">value <br>
Value of the metric.</p>

<p style="margin-top: 1em">tolerance <br>
It is used when comparing via rcw. It means how larger can
the second value be to not trigger a FAIL. Default is
0.2</p>

<p style="margin-top: 1em">When comparing FIRST, SECOND,
then:</p>

<p style="margin-top: 1em">FIRST &gt;= SECOND means PASS
<br>
FIRST+FIRST*tolerance &gt;= SECOND means WARN <br>
FIRST+FIRST*tolerance &lt; SECOND means FAIL</p>

<p style="margin-top: 1em">Example: Simple benchmark is
compared via this metric type in rcw. It has a tolerance of
0.2. First run had 1 second. So:</p>

<p style="margin-top: 1em">For PASS, second run has to be
better or equal to first. <br>
So any value of second or less is a PASS. <br>
For WARN, second run can be a little worse than first. <br>
Tolerance is 0.2, so anything lower than 1.2 means WARN.
<br>
For FAIL, anything worse than 1.2 means FAIL.</p>

<p style="margin-top: 1em">rlLogMetricHigh</p>

<p style="margin-top: 1em">Log a metric, which should be as
high as possible to the journal. (Example: number of
executions per second)</p>

<p style="margin-top: 1em">rlLogMetricHigh name value
[tolerance]</p>

<p style="margin-top: 1em">name <br>
Name of the metric. It has to be unique in a phase.</p>

<p style="margin-top: 1em">value <br>
Value of the metric.</p>

<p style="margin-top: 1em">tolerance <br>
It is used when comparing via rcw. It means how lower can
the second value be to not trigger a FAIL. Default is
0.2</p>

<p style="margin-top: 1em">When comparing FIRST, SECOND,
then:</p>

<p style="margin-top: 1em">FIRST &lt;= SECOND means PASS
<br>
FIRST+FIRST*tolerance &lt;= SECOND means WARN <br>
FIRST+FIRST*tolerance &gt; SECOND means FAIL</p>

<p style="margin-top: 1em">Manual Asserts <br>
rlPass</p>

<p style="margin-top: 1em">Manual assertion, asserts and
logs PASS.</p>

<p style="margin-top: 1em">rlPass comment</p>

<p style="margin-top: 1em">comment <br>
Short test summary.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS.</p>

<p style="margin-top: 1em">rlFail</p>

<p style="margin-top: 1em">Manual assertion, asserts and
logs FAIL.</p>

<p style="margin-top: 1em">rlFail comment</p>

<p style="margin-top: 1em">comment <br>
Short test summary.</p>

<p style="margin-top: 1em">Returns 1 and asserts FAIL.</p>

<p style="margin-top: 1em">Arithmetic Asserts <br>
rlAssert0</p>

<p style="margin-top: 1em">Assertion checking for the
equality of parameter to zero.</p>

<p style="margin-top: 1em">rlAssert0 comment value</p>

<p style="margin-top: 1em">comment <br>
Short test summary, e.g. &quot;Test if compilation ended
successfully&quot;.</p>

<p style="margin-top: 1em">value <br>
Integer value (usually return code of a command).</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;value == 0&quot;.</p>

<p style="margin-top: 1em">rlAssertEquals</p>

<p style="margin-top: 1em">Assertion checking for the
equality of two parameters.</p>

<p style="margin-top: 1em">rlAssertEquals comment value1
value2</p>

<p style="margin-top: 1em">comment <br>
Short test summary, e.g. &quot;Test if all 3 packages have
been downloaded&quot;.</p>

<p style="margin-top: 1em">value1 <br>
First parameter to compare, can be a number or a string</p>

<p style="margin-top: 1em">value2 <br>
Second parameter to compare, can be a number or a string</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;value1 == value2&quot;.</p>

<p style="margin-top: 1em">rlAssertNotEquals</p>

<p style="margin-top: 1em">Assertion checking for the
non-equality of two parameters.</p>

<p style="margin-top: 1em">rlAssertNotEquals comment value1
value2</p>

<p style="margin-top: 1em">comment <br>
Short test summary, e.g. &quot;Test if return code is not
139&quot;.</p>

<p style="margin-top: 1em">value1 <br>
First parameter to compare, can be a number or a string</p>

<p style="margin-top: 1em">value2 <br>
Second parameter to compare, can be a number or a string</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;value1 != value2&quot;.</p>

<p style="margin-top: 1em">rlAssertGreater</p>

<p style="margin-top: 1em">Assertion checking whether first
parameter is greater than the second one.</p>

<p style="margin-top: 1em">rlAssertGreater comment value1
value2</p>

<p style="margin-top: 1em">comment <br>
Short test summary, e.g. &quot;Test whether there are
running more instances of program.&quot;</p>

<p style="margin-top: 1em">value1 <br>
Integer value.</p>

<p style="margin-top: 1em">value2 <br>
Integer value.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;value1 &gt; value2&quot;.</p>

<p style="margin-top: 1em">rlAssertGreaterOrEqual</p>

<p style="margin-top: 1em">Assertion checking whether first
parameter is greater or equal to the second one.</p>

<p style="margin-top: 1em">rlAssertGreaterOrEqual comment
value1 value2</p>

<p style="margin-top: 1em">comment <br>
Short test summary (e.g. &quot;There should present at least
one...&quot;)</p>

<p style="margin-top: 1em">value1 <br>
Integer value.</p>

<p style="margin-top: 1em">value2 <br>
Integer value.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;value1 X= value2&quot;.</p>

<p style="margin-top: 1em">rlAssertLesser</p>

<p style="margin-top: 1em">Assertion checking whether first
parameter is lesser than the second one.</p>

<p style="margin-top: 1em">rlAssertLesser comment value1
value2</p>

<p style="margin-top: 1em">comment <br>
Short test summary, e.g. &quot;Test whether there are
running more instances of program.&quot;</p>

<p style="margin-top: 1em">value1 <br>
Integer value.</p>

<p style="margin-top: 1em">value2 <br>
Integer value.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;value1 X value2&quot;.</p>

<p style="margin-top: 1em">rlAssertLesserOrEqual</p>

<p style="margin-top: 1em">Assertion checking whether first
parameter is lesser or equal to the second one.</p>

<p style="margin-top: 1em">rlAssertLesserOrEqual comment
value1 value2</p>

<p style="margin-top: 1em">comment <br>
Short test summary (e.g. &quot;There should present at least
one...&quot;)</p>

<p style="margin-top: 1em">value1 <br>
Integer value.</p>

<p style="margin-top: 1em">value2 <br>
Integer value.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;value1 X= value2&quot;.</p>

<p style="margin-top: 1em">File Asserts <br>
rlAssertExists</p>

<p style="margin-top: 1em">Assertion checking for the
existence of a file or a directory.</p>

<p style="margin-top: 1em">rlAssertExists
file|directory</p>

<p style="margin-top: 1em">file|directory <br>
Path to the file or directory.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;file&quot; exists.</p>

<p style="margin-top: 1em">rlAssertNotExists</p>

<p style="margin-top: 1em">Assertion checking for the
non-existence of a file or a directory.</p>

<p style="margin-top: 1em">rlAssertNotExists
file|directory</p>

<p style="margin-top: 1em">file|directory <br>
Path to the file or directory.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;file&quot; does not exist.</p>

<p style="margin-top: 1em">rlAssertGrep</p>

<p style="margin-top: 1em">Assertion checking if the file
contains a pattern.</p>

<p style="margin-top: 1em">rlAssertGrep pattern file
[options]</p>

<p style="margin-top: 1em">pattern <br>
Regular expression to be searched for.</p>

<p style="margin-top: 1em">file <br>
Path to the file.</p>

<p style="margin-top: 1em">options <br>
Optional parameters to be passed to grep, default is
&quot;-q&quot;. Can be used to perform case insensitive
matches (-i), or using extended (-E) or perl (-P) regular
expressions.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;file&quot; exists and contains given
&quot;pattern&quot;.</p>

<p style="margin-top: 1em">rlAssertNotGrep</p>

<p style="margin-top: 1em">Assertion checking that the file
does not contain a pattern.</p>

<p style="margin-top: 1em">rlAssertNotGrep pattern file
[options]</p>

<p style="margin-top: 1em">pattern <br>
Regular expression to be searched for.</p>

<p style="margin-top: 1em">file <br>
Path to the file.</p>

<p style="margin-top: 1em">options <br>
Optional parameters to be passed to grep, default is
&quot;-q&quot;. Can be used to perform case insensitive
matches (-i), or using extended (-E) or perl (-P) regular
expressions.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;file&quot; exists and does not contain given
&quot;pattern&quot;.</p>

<p style="margin-top: 1em">rlAssertDiffer</p>

<p style="margin-top: 1em">Assertion checking that two
files differ (are not identical).</p>

<p style="margin-top: 1em">rlAssertDiffer file1 file2</p>

<p style="margin-top: 1em">file1 <br>
Path to first file1</p>

<p style="margin-top: 1em">file2 <br>
Path to second file</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;file1&quot; and &quot;file2&quot; differs.</p>

<p style="margin-top: 1em">rlAssertNotDiffer</p>

<p style="margin-top: 1em">Assertion checking that two
files do not differ (are identical).</p>

<p style="margin-top: 1em">rlAssertNotDiffer file1
file2</p>

<p style="margin-top: 1em">file1 <br>
Path to first file1</p>

<p style="margin-top: 1em">file2 <br>
Path to second file</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS when
&quot;file1&quot; and &quot;file2&quot; do not differ.</p>

<p style="margin-top: 1em">Run, Watch, Report <br>
rlRun</p>

<p style="margin-top: 1em">Run command with optional
comment and make sure its exit code matches
expectations.</p>

<p style="margin-top: 1em">rlRun [-t] [-l] [-c] [-s]
command [status[,status...]] [comment]</p>

<p style="margin-top: 1em">-t If specified, stdout and
stderr of the command output will be tagged with strigs
&rsquo;STDOUT: &rsquo; and &rsquo;STDERR: &rsquo;.</p>

<p style="margin-top: 1em">-l If specified, output of the
command (tagged, if -t was specified) is logged using rlLog
function. This is intended for short outputs, and therefore
only last 50 lines are <br>
logged this way. Longer outputs should be analysed
separately, or uploaded via rlFileSubmit or
rlBundleLogs.</p>

<p style="margin-top: 1em">-c Same as &quot;-l&quot;, but
only log the commands output if it failed.</p>

<p style="margin-top: 1em">-s Store stdout and stderr to a
file (mixed together, as the user would see it on a
terminal) and set $rlRun_LOG variable to name of the file.
Caller is responsible for removing <br>
the file. When -t option is used, the content of the file
becomes tagged too.</p>

<p style="margin-top: 1em">If the -s option is not used,
$rlRun_LOG is not modified and keeps its content from the
last &quot;rlRun -s&quot;.</p>

<p style="margin-top: 1em">command <br>
Command to run.</p>

<p style="margin-top: 1em">status <br>
Expected exit code(s). Optional, default 0. If you expect
more exit codes, separate them with comma (e.g.
&quot;0,1&quot; when both 0 and 1 are OK and expected), or
use from-to <br>
notation (i.e. &quot;2-5&quot; for &quot;2,3,4,5&quot;), or
combine them (e.g. &quot;2-4,26&quot; for
&quot;2,3,4,26&quot;).</p>

<p style="margin-top: 1em">comment <br>
Short summary describing the action (optional, but
recommended - explain what are you doing here).</p>

<p style="margin-top: 1em">Returns the exit code of the
command run. Asserts PASS when command&acute;s exit status
is in the list of expected exit codes.</p>

<p style="margin-top: 1em">Note:</p>

<p style="margin-top: 1em">&Acirc;&middot; The output of
rlRun is buffered when using &quot;-t&quot;, &quot;-l&quot;
or &quot;-s&quot; option (they use unix pipes, which are
buffered by nature). If you need an unbuffered output just
make sure that <br>
&quot;expect&quot; package is installed on your system (its
&quot;unbuffer&quot; tool will automatically be used to
produce unbuffered output).</p>

<p style="margin-top: 1em">&Acirc;&middot; Be aware that
there are some variables which can collide with your code
executed within rlRun. You should avoid using
__INTERNAL_rlRun_* variables.</p>

<p style="margin-top: 1em">Warning: using
&quot;unbuffer&quot; tool is now disabled because of bug
547686.</p>

<p style="margin-top: 1em">rlWatchdog</p>

<p style="margin-top: 1em">Run &quot;command&quot;. If it
does not finish in specified time, then kill it using
&quot;signal&quot;.</p>

<p style="margin-top: 1em">rlWatchdog command timeout
[signal] [callback]</p>

<p style="margin-top: 1em">command <br>
Command to run.</p>

<p style="margin-top: 1em">timeout <br>
Timeout to wait, in seconds.</p>

<p style="margin-top: 1em">signal <br>
Signal to use (optional, default KILL).</p>

<p style="margin-top: 1em">callback <br>
Callback function to be called before the signal is send
(optional, none by default). The callback function will have
one argument available -- PGID of the process group.</p>

<p style="margin-top: 1em">Returns 0 if the command ends
normally, without need to be killed.</p>

<p style="margin-top: 1em">rlReport</p>

<p style="margin-top: 1em">Report test result to the test
harness. The command to be used for reporting is set by the
respective plugin. You can also use the
$BEAKERLIB_COMMAND_REPORT_RESULT variable to <br>
use your custom command.</p>

<p style="margin-top: 1em">rlReport name result [score]
[log]</p>

<p style="margin-top: 1em">name <br>
Name of the test result.</p>

<p style="margin-top: 1em">result <br>
Result (one of PASS, WARN, FAIL). If called with something
else, will use WARN.</p>

<p style="margin-top: 1em">score <br>
Test score (optional).</p>

<p style="margin-top: 1em">log Optional log file to be
submitted instead of default &quot;OUTPUTFILE&quot;.</p>

<p style="margin-top: 1em">rlCmpVersion</p>

<p style="margin-top: 1em">Compare two given versions
composed by numbers and letters divided by dot (.),
underscore (_), or dash (-).</p>

<p style="margin-top: 1em">rlCmpVersion ver1 ver2</p>

<p style="margin-top: 1em">If ver1 = ver2, sign
&rsquo;=&rsquo; is printed to stdout and 0 is returned. If
ver1 &gt; ver2, sign &rsquo;&gt;&rsquo; is printed to stdout
and 1 is returned. If ver1 &lt; ver2, sign
&rsquo;&lt;&rsquo; is printed to stdout <br>
and 2 is returned.</p>

<p style="margin-top: 1em">rlTestVersion</p>

<p style="margin-top: 1em">Test releation between two given
versions based on given operator.</p>

<p style="margin-top: 1em">rlTestVersion ver1 op ver2</p>

<p style="margin-top: 1em">op Operator definitng the
logical expression. It can be &rsquo;=&rsquo;,
&rsquo;==&rsquo;, &rsquo;!=&rsquo;, &rsquo;&lt;&rsquo;,
&rsquo;&lt;=&rsquo;, &rsquo;=&lt;&rsquo;,
&rsquo;&gt;&rsquo;, &rsquo;&gt;=&rsquo;, or
&rsquo;=&gt;&rsquo;.</p>

<p style="margin-top: 1em">Returns 0 if the expresison ver1
op ver2 is true; 1 if the expression is false and 2 if
something went wrong.</p>

<p style="margin-top: 1em">Release Info <br>
rlIsRHEL</p>

<p style="margin-top: 1em">Check whether we&rsquo;re
running on RHEL. With given number of version as parameter
returns 0 if the particular RHEL version is running.
Multiple arguments can be passed separated <br>
with space as well as any particular release (5.1 5.2 5.3).
Each version can have a prefix consisting of
&rsquo;&lt;&rsquo;, &rsquo;&lt;=&rsquo;, &rsquo;=&rsquo;,
&rsquo;&gt;=&rsquo;, &rsquo;&gt;&rsquo;, matching whenever
the currently installed <br>
version is lesser, lesser or equal, equal, equal or greater,
greater than the version specified as argument. Note that
ie. &rsquo;=5&rsquo; (unlike just &rsquo;5&rsquo;) matches
exactly 5 (5.0), not <br>
5.N, where N &gt; 0.</p>

<p style="margin-top: 1em">rlIsRHEL</p>

<p style="margin-top: 1em">Returns 0 if we are running on
RHEL.</p>

<p style="margin-top: 1em">rlIsRHEL 4.8 5</p>

<p style="margin-top: 1em">Returns 0 if we are running RHEL
4.8 or any RHEL 5.</p>

<p style="margin-top: 1em">rlIsFedora</p>

<p style="margin-top: 1em">Check whether we&rsquo;re
running on Fedora. With given number of version as parameter
returns 0 if the particular Fedora version is running. Range
matching can be used in the form <br>
used by rlIsRHEL.</p>

<p style="margin-top: 1em">rlIsFedora</p>

<p style="margin-top: 1em">Returns 0 if we are running on
Fedora.</p>

<p style="margin-top: 1em">rlIsFedora 9 10</p>

<p style="margin-top: 1em">Returns 0 if we are running
Fedora 9 or 10.</p>

<p style="margin-top: 1em">Release Info <br>
rlIsCentOS</p>

<p style="margin-top: 1em">Check whether we&rsquo;re
running on CentOS. With given number of version as parameter
returns 0 if the particular CentOS version is running.
Multiple arguments can be passed <br>
separated with space as well as any particular release (5.1
5.2 5.3). Each version can have a prefix consisting of
&rsquo;&lt;&rsquo;, &rsquo;&lt;=&rsquo;, &rsquo;=&rsquo;,
&rsquo;&gt;=&rsquo;, &rsquo;&gt;&rsquo;, matching whenever
the currently <br>
installed version is lesser, lesser or equal, equal, equal
or greater, greater than the version specified as argument.
Note that ie. &rsquo;=5&rsquo; (unlike just &rsquo;5&rsquo;)
matches exactly 5 <br>
(5.0), not 5.N, where N &gt; 0.</p>

<p style="margin-top: 1em">rlIsCentOS</p>

<p style="margin-top: 1em">Returns 0 if we are running on
CentOS.</p>

<p style="margin-top: 1em">rlIsCentOS 7.1 6</p>

<p style="margin-top: 1em">Returns 0 if we are running
CentOS 7.1 or any CentOS 6.</p>

<p style="margin-top: 1em">Rpm Handling <br>
rlCheckRpm</p>

<p style="margin-top: 1em">Check whether a package is
installed.</p>

<p style="margin-top: 1em">rlCheckRpm name [version]
[release] [arch]</p>

<p style="margin-top: 1em">name <br>
Package name like &quot;kernel&quot;</p>

<p style="margin-top: 1em">version <br>
Package version like 2.6.25.6</p>

<p style="margin-top: 1em">release <br>
Package release like &quot;55.fc9&quot;</p>

<p style="margin-top: 1em">arch <br>
Package architucture like &quot;i386&quot;</p>

<p style="margin-top: 1em">Returns 0 if the specified
package is installed.</p>

<p style="margin-top: 1em">rlAssertRpm</p>

<p style="margin-top: 1em">Assertion making sure that a
package is installed.</p>

<p style="margin-top: 1em">rlAssertRpm name [version]
[release] [arch]&gt; <br>
rlAssertRpm --all</p>

<p style="margin-top: 1em">name <br>
Package name like &quot;kernel&quot;</p>

<p style="margin-top: 1em">version <br>
Package version like 2.6.25.6</p>

<p style="margin-top: 1em">release <br>
Package release like &quot;55.fc9&quot;</p>

<p style="margin-top: 1em">arch <br>
Package architucture like &quot;i386&quot;</p>

<p style="margin-top: 1em">--all <br>
Assert all packages listed in the $PACKAGES $REQUIRES and
$COLLECTIONS environment variables.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS if
the specified package is installed.</p>

<p style="margin-top: 1em">rlAssertNotRpm</p>

<p style="margin-top: 1em">Assertion making sure that a
package is not installed. This is just inverse of
&quot;rlAssertRpm&quot;.</p>

<p style="margin-top: 1em">rlAssertNotRpm name [version]
[release] [arch]&gt;</p>

<p style="margin-top: 1em">name <br>
Package name like &quot;kernel&quot;</p>

<p style="margin-top: 1em">version <br>
Package version like 2.6.25.6</p>

<p style="margin-top: 1em">release <br>
Package release like &quot;55.fc9&quot;</p>

<p style="margin-top: 1em">arch <br>
Package architucture like &quot;i386&quot;</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS if
the specified package is not installed.</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">Function &quot;rlAssertRpm&quot;
is useful especially in prepare phase where it causes abort
if a package is missing, while &quot;rlCheckRpm&quot; is
handy when doing something like:</p>

<p style="margin-top: 1em">if ! rlCheckRpm package; then
<br>
yum install package <br>
rlAssertRpm package <br>
fi</p>

<p style="margin-top: 1em">rlAssertBinaryOrigin</p>

<p style="margin-top: 1em">Assertion making sure that given
binary is owned by (one of) the given package(s).</p>

<p style="margin-top: 1em">rlAssertBinaryOrigin binary
package [package2 [...]] <br>
PACKAGES=... rlAssertBinaryOrigin binary</p>

<p style="margin-top: 1em">binary <br>
Binary name like &quot;ksh&quot; or &quot;/bin/ksh&quot;</p>

<p style="margin-top: 1em">package <br>
List of packages like &quot;ksh mksh&quot;. The parameter is
optional. If missing, contents of environment variable
$PACKAGES are taken into account.</p>

<p style="margin-top: 1em">Returns 0 and asserts PASS if
the specified binary belongs to (one of) the given
package(s). Returns 1 and asserts FAIL if the specified
binary does not belong to (any of) the <br>
given package(s). Returns 2 and asserts FAIL if the
specified binary is not found. Returns 3 and asserts FAIL if
no packages are given. Returns 100 and asserts FAIL if
invoked <br>
with no parameters.</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">Function
&quot;rlAssertBinaryOrigin&quot; is useful especially in
prepare phase where it causes abort if a binary is missing
or is owned by different package:</p>

<p style="margin-top: 1em">PACKAGES=mksh
rlAssertBinaryOrigin ksh <br>
or <br>
rlAssertBinaryOrigin ksh mksh</p>

<p style="margin-top: 1em">Returns true if ksh is owned by
the mksh package (in this case: /bin/ksh is a symlink
pointing to /bin/mksh).</p>

<p style="margin-top: 1em">rlGetMakefileRequires</p>

<p style="margin-top: 1em">Prints comma separated list of
requirements defined in Makefile using
&rsquo;Requires&rsquo; attribute.</p>

<p style="margin-top: 1em">Return 0 if success.</p>

<p style="margin-top: 1em">rlCheckRequirements</p>

<p style="margin-top: 1em">Check that all given
requirements are covered eigther by installed package or by
binary available in PATHs or by some package&rsquo;s
provides.</p>

<p style="margin-top: 1em">rlRun &quot;rlCheckRequirements
REQ...&quot;</p>

<p style="margin-top: 1em">REQ Requirement to be checked.
It can be package name, provides string or binary name.</p>

<p style="margin-top: 1em">Returns number of unsatisfied
requirements.</p>

<p style="margin-top: 1em">rlCheckMakefileRequires</p>

<p style="margin-top: 1em">This is just a bit smarted
wrapper of</p>

<p style="margin-top: 1em">&quot;rlCheckRequirements
$(rlGetMakefileRequires)&quot;</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">rlRun
&quot;rlCheckMakefileRequires&quot;</p>

<p style="margin-top: 1em">Return 255 if requirements could
not be retrieved, 0 if all requirements are satisfied or
number of unsatisfied requirements.</p>

<p style="margin-top: 1em">rlAssertRequired</p>

<p style="margin-top: 1em">Ensures that all Requires,
specified in beakerlib-style beaker-wizard layout Makefile,
are installed.</p>

<p style="margin-top: 1em">rlAssertRequired</p>

<p style="margin-top: 1em">Prints out a verbose list of
installed/missing packages during operation.</p>

<p style="margin-top: 1em">Returns 0 if all required
packages are installed, 1 if one or more packages are
missing or if no Makefile is present.</p>

<p style="margin-top: 1em">Getting RPMs <br>
Download methods</p>

<p style="margin-top: 1em">Functions handling rpm
downloading/installing can use more methods for actual
download of the rpm.</p>

<p style="margin-top: 1em">Currently there are two download
methonds available:</p>

<p style="margin-top: 1em">direct <br>
Use use dirct download from build system (brew).</p>

<p style="margin-top: 1em">yum Use yumdownloader.</p>

<p style="margin-top: 1em">The methods and their order are
defined by BEAKERLIB_RPM_DOWNLOAD_METHODS variable as space
separated list. By default it is &rsquo;direct yum&rsquo;.
This can be overridden by user. There <br>
may be done also additions or changes to the original value,
e.g. BEAKERLIB_RPM_DOWNLOAD_METHODS=&rsquo;yum
${BEAKERLIB_RPM_DOWNLOAD_METHODS/yum/}&rsquo;</p>

<p style="margin-top: 1em">Beakerlib is prepared for more
Koji-based sources of packages while usigng direct download
method. By default packages are fetched from Koji,
particularly from <br>
https://kojipkgs.fedoraproject.org/packages.</p>

<p style="margin-top: 1em">rlRpmInstall</p>

<p style="margin-top: 1em">Try to install specified package
from local Red Hat sources.</p>

<p style="margin-top: 1em">rlRpmInstall package version
release arch</p>

<p style="margin-top: 1em">package <br>
Package name like &quot;kernel&quot;</p>

<p style="margin-top: 1em">version <br>
Package version like 2.6.25.6</p>

<p style="margin-top: 1em">release <br>
Package release like &quot;55.fc9&quot;</p>

<p style="margin-top: 1em">arch <br>
Package arch like &quot;i386&quot;</p>

<p style="margin-top: 1em">Returns 0 if specified package
was installed succesfully.</p>

<p style="margin-top: 1em">rlRpmDownload</p>

<p style="margin-top: 1em">Try to download specified
package.</p>

<p style="margin-top: 1em">rlRpmDownload package version
release arch <br>
rlRpmDownload --source package version release <br>
rlRpmDownload N-V-R.A <br>
rlRpmDownload --source N-V-R</p>

<p style="margin-top: 1em">package <br>
Package name like &quot;kernel&quot;</p>

<p style="margin-top: 1em">version <br>
Package version like 2.6.25.6</p>

<p style="margin-top: 1em">release <br>
Package release like &quot;55.fc9&quot;</p>

<p style="margin-top: 1em">arch <br>
Package arch like &quot;i386&quot;</p>

<p style="margin-top: 1em">Returns 0 if specified package
was downloaded succesfully.</p>

<p style="margin-top: 1em">rlFetchSrcForInstalled</p>

<p style="margin-top: 1em">Tries various ways to download
source rpm for specified installed rpm.</p>

<p style="margin-top: 1em">rlFetchSrcForInstalled
package</p>

<p style="margin-top: 1em">package <br>
Installed package name like &quot;kernel&quot;. It accepts
in-direct names. Eg for the package name
&quot;krb5-libs&quot; will the function download the
&quot;krb5&quot; source rpm.</p>

<p style="margin-top: 1em">Returns 0 if the source package
was succesfully downloaded.</p>

<p style="margin-top: 1em">Mounting <br>
rlMount</p>

<p style="margin-top: 1em">Create mount point (if
neccessary) and mount a NFS share.</p>

<p style="margin-top: 1em">rlMount [-o MOUNT_OPTS] server
share mountpoint</p>

<p style="margin-top: 1em">server <br>
NFS server hostname.</p>

<p style="margin-top: 1em">share <br>
Shared directory name.</p>

<p style="margin-top: 1em">mountpoint <br>
Local mount point.</p>

<p style="margin-top: 1em">MOUNT_OPTS <br>
Mount options.</p>

<p style="margin-top: 1em">Returns 0 if mounting the share
was successful.</p>

<p style="margin-top: 1em">rlCheckMount</p>

<p style="margin-top: 1em">Check either if a directory is a
mountpoint, if it is a mountpoint to a specific server, or
if it is a mountpoint to a specific export on a specific
server and if it uses <br>
specific mount options.</p>

<p style="margin-top: 1em">rlCheckMount [-o MOUNT_OPTS]
mountpoint <br>
rlCheckMount [-o MOUNT_OPTS] server mountpoint <br>
rlCheckMount [-o MOUNT_OPTS] server share mountpoint</p>

<p style="margin-top: 1em">mountpoint <br>
Local mount point.</p>

<p style="margin-top: 1em">server <br>
NFS server hostname</p>

<p style="margin-top: 1em">share <br>
Shared directory name</p>

<p style="margin-top: 1em">MOUNT_OPTS <br>
Mount options to check (comma separated list)</p>

<p style="margin-top: 1em">With one parameter, returns 0
when specified directory exists and is a mountpoint. With
two parameters, returns 0 when specific directory exists, is
a mountpoint and an export <br>
from specific server is mounted there. With three
parameters, returns 0 if a specific shared directory is
mounted on a given server on a given mountpoint</p>

<p style="margin-top: 1em">If the -o option is provided,
returns 0 if the mountpoint uses all the given options, 2
otherwise.</p>

<p style="margin-top: 1em">rlAssertMount</p>

<p style="margin-top: 1em">Assertion making sure that given
directory is a mount point, if it is a mountpoint to a
specific server, or if it is a mountpoint to a specific
export on a specific server and if <br>
it uses specific mount options.</p>

<p style="margin-top: 1em">rlAssertMount [-o MOUNT_OPTS]
mountpoint <br>
rlAssertMount [-o MOUNT_OPTS] server mountpoint <br>
rlAssertMount [-o MOUNT_OPTS] server share mountpoint</p>

<p style="margin-top: 1em">mountpoint <br>
Local mount point.</p>

<p style="margin-top: 1em">server <br>
NFS server hostname</p>

<p style="margin-top: 1em">share <br>
Shared directory name</p>

<p style="margin-top: 1em">MOUNT_OPTS <br>
Mount options to check (comma separated list)</p>

<p style="margin-top: 1em">With one parameter, returns 0
when specified directory exists and is a mountpoint. With
two parameters, returns 0 when specific directory exists, is
a mountpoint and an export <br>
from specific server is mounted there. With three
parameters, returns 0 if a specific shared directory is
mounted on a given server on a given mountpoint. Asserts
PASS when the <br>
condition is true.</p>

<p style="margin-top: 1em">If the -o option is provided,
asserts PASS if the above conditions are met and the
mountpoint uses all the given options.</p>

<p style="margin-top: 1em">rlHash, rlUnhash</p>

<p style="margin-top: 1em">Hashes/Unhashes given
string.</p>

<p style="margin-top: 1em">rlHash [--decode] [--algorithm
HASH_ALG] --stdin|STRING <br>
rlUnhash [--algorithm HASH_ALG] --stdin|STRING</p>

<p style="margin-top: 1em">--decode <br>
Unhash given string.</p>

<p style="margin-top: 1em">--algorithm <br>
Use given hash algorithm. Currently supported algorithms:
<br>
base64 <br>
base64_ - this is standard base64 where &rsquo;=&rsquo; is
replaced by &rsquo;_&rsquo; <br>
hex</p>

<p style="margin-top: 1em">Defaults to hex. Default
algorithm can be override using global variable
rlHashAlgorithm.</p>

<p style="margin-top: 1em">--stdin <br>
Get the string from stdin.</p>

<p style="margin-top: 1em">STRING <br>
String to be hashed/unhashed.</p>

<p style="margin-top: 1em">Returns 0 if success.</p>

<p style="margin-top: 1em">Example with --clean:</p>

<p style="margin-top: 1em">hash=rlHash &quot;text&quot;</p>

<p style="margin-top: 1em">Backup and Restore <br>
rlFileBackup</p>

<p style="margin-top: 1em">Create a backup of files or
directories (recursive). Can be used multiple times to add
more files to backup. Backing up an already backed up file
overwrites the original backup.</p>

<p style="margin-top: 1em">rlFileBackup [--clean]
[--namespace name] [--missing-ok|--no-missing-ok] file
[file...]</p>

<p style="margin-top: 1em">You can use &quot;rlRun&quot;
for asserting the result but keep in mind meaning of exit
codes, especialy exit code 8, if using without --clean
option.</p>

<p style="margin-top: 1em">--clean <br>
If this option is provided (have to be first option of the
command), then file/dir backuped using this command
(provided in next options) will be (recursively) removed
before <br>
we will restore it. This option implies --missing-ok, this
can be overridden by --no-missing-ok.</p>

<p style="margin-top: 1em">--namespace name <br>
Specifies the namespace to use. Namespaces can be used to
separate backups and their restoration.</p>

<p style="margin-top: 1em">--missing-ok <br>
Do not raise an error in case of missing file to backup.</p>

<p style="margin-top: 1em">--no-missing-ok <br>
Do raise an error in case of missing file to backup. This is
useful with --clean. This behaviour can be globally set by
global variable <br>
BEAKERLIB_FILEBACKUP_MISSING_OK=false.</p>

<p style="margin-top: 1em">file <br>
Files and/or directories to be backed up.</p>

<p style="margin-top: 1em">Returns 0 if the backup was
successful. Returns 1 if parsing of parameters was not
successful. Returns 2 if no files specification was
provided. Returns 3 if BEAKERLIB_DIR <br>
variable is not set, e.g. rlJournalStart was not executed.
Returns 4 if creating of main backup destination directories
was not successful. Returns 5 if creating of file <br>
specific backup destination directories was not successful.
Returns 6 if the copy of backed up files was not successful.
Returns 7 if attributes of backedup files were not <br>
successfuly copied. Returns 8 if backed up files does not
exist. This can be suppressed based on other options.</p>

<p style="margin-top: 1em">Example with --clean:</p>

<p style="margin-top: 1em">touch cleandir/aaa <br>
rlRun &quot;rlFileBackup --clean cleandir/&quot; <br>
touch cleandir/bbb <br>
ls cleandir/ <br>
aaa bbb <br>
rlRun &quot;rlFileRestore&quot; <br>
ls cleandir/ <br>
aaa</p>

<p style="margin-top: 1em">rlFileRestore</p>

<p style="margin-top: 1em">Restore backed up files to their
original location. &quot;rlFileRestore&quot; does not remove
new files appearing after backup has been made. If you
don&rsquo;t want to leave anything behind <br>
just remove the whole original tree before running
&quot;rlFileRestore&quot;, or see &quot;--clean&quot; option
of &quot;rlFileBackup&quot;.</p>

<p style="margin-top: 1em">rlFileRestore [--namespace
name]</p>

<p style="margin-top: 1em">You can use &quot;rlRun&quot;
for asserting the result.</p>

<p style="margin-top: 1em">--namespace name <br>
Specifies the namespace to use. Namespaces can be used to
separate backups and their restoration.</p>

<p style="margin-top: 1em">Returns 0 if backup dir is found
and files are restored successfully.</p>

<p style="margin-top: 1em">Return code bits meaning XXXXX
<br>
||||| <br>
||||_ error parsing parameters <br>
|||__ could not find backup directory <br>
||___ files cleanup failed <br>
|____ files restore failed <br>
_____ no files were restored nor cleaned</p>

<p style="margin-top: 1em">Services <br>
Following routines implement comfortable way how to
start/stop system services with the possibility to restore
them to their original state after testing.</p>

<p style="margin-top: 1em">rlServiceStart</p>

<p style="margin-top: 1em">Make sure the given
&quot;service&quot; is running with fresh configuration.
(Start it if it is stopped and restart if it is already
running.) In addition, when called for the first time, <br>
the current state is saved so that the &quot;service&quot;
can be restored to its original state when testing is
finished, see &quot;rlServiceRestore&quot;.</p>

<p style="margin-top: 1em">rlServiceStart service
[service...]</p>

<p style="margin-top: 1em">service <br>
Name of the service(s) to start.</p>

<p style="margin-top: 1em">Returns number of services which
failed to start/restart; thus zero is returned when
everything is OK.</p>

<p style="margin-top: 1em">rlServiceStop</p>

<p style="margin-top: 1em">Make sure the given
&quot;service&quot; is stopped. Stop it if it is running and
do nothing when it is already stopped. In addition, when
called for the first time, the current state is <br>
saved so that the &quot;service&quot; can be restored to its
original state when testing is finished, see
&quot;rlServiceRestore&quot;.</p>

<p style="margin-top: 1em">rlServiceStop service
[service...]</p>

<p style="margin-top: 1em">service <br>
Name of the service(s) to stop.</p>

<p style="margin-top: 1em">Returns number of services which
failed to become stopped; thus zero is returned when
everything is OK.</p>

<p style="margin-top: 1em">rlServiceRestore</p>

<p style="margin-top: 1em">Restore given
&quot;service&quot; into its original state (before the
first &quot;rlServiceStart&quot; or
&quot;rlServiceStop&quot; was called).</p>

<p style="margin-top: 1em">rlServiceRestore
[service...]</p>

<p style="margin-top: 1em">service <br>
Name of the service(s) to restore to original state. All
services will be restored in reverse order if no service
name is given.</p>

<p style="margin-top: 1em">Returns number of services which
failed to get back to their original state; thus zero is
returned when everything is OK.</p>

<p style="margin-top: 1em">rlServiceEnable</p>

<p style="margin-top: 1em">Enables selected services if
needed, or does nothing if already enabled. In addition,
when called for the first time, the current state is saved
so that the &quot;service&quot; can be <br>
restored to its original state when testing is finished, see
&quot;rlServiceRestore&quot;.</p>

<p style="margin-top: 1em">rlServiceEnable service
[service...]</p>

<p style="margin-top: 1em">service <br>
Name of the service(s) to enable.</p>

<p style="margin-top: 1em">Returns number of services which
failed enablement; thus zero is returned when everything is
OK.</p>

<p style="margin-top: 1em">rlServiceDisable</p>

<p style="margin-top: 1em">Disables selected services if
needed, or does nothing if already disabled. In addition,
when called for the first time, the current state is saved
so that the &quot;service&quot; can be <br>
restored to its original state when testing is finished, see
&quot;rlServiceRestore&quot;.</p>

<p style="margin-top: 1em">rlServiceDisable service
[service...]</p>

<p style="margin-top: 1em">service <br>
Name of the service(s) to disable.</p>

<p style="margin-top: 1em">Returns number of services which
failed disablement; thus zero is returned when everything is
OK.</p>

<p style="margin-top: 1em">Sockets <br>
Following routines implement comfortable way how to
start/stop system sockets with the possibility to restore
them to their original state after testing.</p>

<p style="margin-top: 1em">rlSocketStart</p>

<p style="margin-top: 1em">Make sure the given
&quot;socket&quot; is running. (Start it if stopped, leave
it if already running.) In addition, when called for the
first time, the current state is saved so that the <br>
&quot;socket&quot; can be restored to its original state
when testing is finished, see
&quot;rlSocketRestore&quot;.</p>

<p style="margin-top: 1em">rlSocketStart socket
[socket...]</p>

<p style="margin-top: 1em">socket <br>
Name of the socket(s) to start.</p>

<p style="margin-top: 1em">Returns number of sockets which
failed to start/restart; thus zero is returned when
everything is OK.</p>

<p style="margin-top: 1em">rlSocketStop</p>

<p style="margin-top: 1em">Make sure the given
&quot;socket&quot; is stopped. Stop it if it is running and
do nothing when it is already stopped. In addition, when
called for the first time, the current state is <br>
saved so that the &quot;socket&quot; can be restored to its
original state when testing is finished, see
&quot;rlSocketRestore&quot;.</p>

<p style="margin-top: 1em">rlSocketStop socket
[socket...]</p>

<p style="margin-top: 1em">socket <br>
Name of the socket(s) to stop.</p>

<p style="margin-top: 1em">Returns number of sockets which
failed to become stopped; thus zero is returned when
everything is OK.</p>

<p style="margin-top: 1em">rlSocketRestore</p>

<p style="margin-top: 1em">Restore given &quot;socket&quot;
into its original state (before the first
&quot;rlSocketStart&quot; or &quot;rlSocketStop&quot; was
called).</p>

<p style="margin-top: 1em">Warning !!! Xinetd process [even
though it might have been used] is NOT restored. It is
recommended to call rlServiceRestore xinetd as well.</p>

<p style="margin-top: 1em">rlSocketRestore socket
[socket...]</p>

<p style="margin-top: 1em">socket <br>
Name of the socket(s) to restore to original state.</p>

<p style="margin-top: 1em">Returns number of sockets which
failed to get back to their original state; thus zero is
returned when everything is OK.</p>

<p style="margin-top: 1em">Cleanup management <br>
Cleanup management works with a so-called cleanup buffer,
which is a temporary representation of what should be run at
cleanup time, and a final cleanup script (executable), <br>
which is generated from this buffer and wraps it using
BeakerLib essentials (journal initialization, cleanup phase,
...). The cleanup script must always be updated on an atomic
<br>
basis (filesystem-wise) to allow an asynchronous execution
by a third party (ie. test watcher).</p>

<p style="margin-top: 1em">The test watcher usage is
mandatory for the cleanup management system to work properly
as it is the test watcher that executes the actual cleanup
script. Limited, catastrophe- <br>
avoiding mechanism is in place even when the test is not run
in test watcher, but that should be seen as a backup and
such situation is to be avoided whenever possible.</p>

<p style="margin-top: 1em">The cleanup script shares all
environment (variables, exported or not, and functions) with
the test itself - the cleanup append/prepend functions
&quot;sample&quot; or &quot;snapshot&quot; the <br>
environment at the time of their call, IOW any changes to
the test environment are synchronized to the cleanup script
only upon calling append/prepend. When the append/prepend
<br>
functions are called within a function which has local
variables, these will appear as global in the cleanup.</p>

<p style="margin-top: 1em">While the cleanup script
receives $PWD from the test, its working dir is set to the
initial test execution dir even if $PWD contains something
else. It is impossible to use <br>
relative paths inside cleanup reliably - certain parts of
the cleanup might have been added under different current
directories (CWDs). Therefore always use absolute paths in
<br>
append/prepend cleanup or make sure you never
&rsquo;cd&rsquo; elsewhere (ie. to a TmpDir).</p>

<p style="margin-top: 1em">rlCleanupAppend</p>

<p style="margin-top: 1em">Appends a string to the cleanup
buffer and recreates the cleanup script.</p>

<p style="margin-top: 1em">rlCleanupAppend string</p>

<p style="margin-top: 1em">Returns 0 if the operation was
successful, 1 otherwise.</p>

<p style="margin-top: 1em">rlCleanupPrepend</p>

<p style="margin-top: 1em">Prepends a string to the cleanup
buffer and recreates the cleanup script.</p>

<p style="margin-top: 1em">rlCleanupPrepend string</p>

<p style="margin-top: 1em">Returns 0 if the operation was
successful, 1 otherwise.</p>

<p style="margin-top: 1em">Time Performance <br>
rlPerfTime_RunsInTime</p>

<p style="margin-top: 1em">Measures, how many runs of some
commands can be done in specified time. This approach is
suitable for short-time running tasks (up to few seconds),
where averaging few runs is <br>
not precise. This is done several times, and the final
result is the average of all runs. It prints the number on
stdout, so it has to be captured.</p>

<p style="margin-top: 1em">rlPerfTime_RunsInTime command
[time] [runs]</p>

<p style="margin-top: 1em">command <br>
Command to run.</p>

<p style="margin-top: 1em">time <br>
Time in seconds (optional, default=30).</p>

<p style="margin-top: 1em">runs <br>
Number of averaged runs (optional, default=3).</p>

<p style="margin-top: 1em">rlPerfTime_AvgFromRuns</p>

<p style="margin-top: 1em">Measures the average time of
running some task. This approach is suitable for long-time
running tasks (tens of seconds and more), where it is
precise enough. Measured runs can be <br>
preceded by dry run, which is not measured and it&rsquo;s
purpose is to warm up various caches. It prints the number
on stdout, so it has to be captured. Or, result is then
stored in <br>
special rl_retval variable.</p>

<p style="margin-top: 1em">rlPerfTime_AvgFromRuns command
[count] [warmup]</p>

<p style="margin-top: 1em">command <br>
Command to run.</p>

<p style="margin-top: 1em">count <br>
Times to run (optional, default=3).</p>

<p style="margin-top: 1em">warmup <br>
Warm-up run, run if this option is not &quot;warmup&quot;
(optional, default=&quot;warmup&quot;)</p>

<p style="margin-top: 1em">Analyze <br>
rlDejaSum</p>

<p style="margin-top: 1em">TODO description</p>

<p style="margin-top: 1em">rlDejaSum par1 par2</p>

<p style="margin-top: 1em">par1 <br>
TODO description</p>

<p style="margin-top: 1em">par2 <br>
TODO description</p>

<p style="margin-top: 1em">Return 0 if... TODO</p>

<p style="margin-top: 1em">rlImport</p>

<p style="margin-top: 1em">Imports code provided by one or
more libraries into the test namespace. The library search
mechanism is based on Beaker test hierarchy system,
i.e.:</p>


<p style="margin-top: 1em">/component/type/test-name/test-file</p>

<p style="margin-top: 1em">When test-file calls rlImport
with &rsquo;foo/bar&rsquo; parameter, the directory path is
traversed upwards, and a check for presence of the test
/foo/Library/bar/ will be performed. This <br>
means this function needs to be called from the test
hierarchy, not e.g. the /tmp directory.</p>

<p style="margin-top: 1em">Once library is found, it is
sourced and a verifier function is called. The verifier
function is cunstructed by composing the library prefix and
LibraryLoaded. Library prefix <br>
can be defined in the library itself. If the verifier passes
the library is ready to use. Also variable
&lt;PREFIX&gt;LibraryDir is created and it points to the
library folder.</p>

<p style="margin-top: 1em">Usage:</p>

<p style="margin-top: 1em">rlImport --all <br>
rlImport LIBRARY [LIBRARY2...]</p>

<p style="margin-top: 1em">--all <br>
Read Makefile in current/original directory, pick library
requirements up and import them all.</p>

<p style="margin-top: 1em">LIBRARY <br>
Must have &rsquo;component/library&rsquo; format. Identifies
the library to import.</p>

<p style="margin-top: 1em">Returns 0 if the import of all
libraries was successful. Returns non-zero if one or more
library failed to import.</p>

<p style="margin-top: 1em">Process Synchronisation <br>
rlWaitForCmd</p>

<p style="margin-top: 1em">Pauses script execution until
command exit status is the expeced value. Logs a WARNING and
returns 1 if the command didn&rsquo;t exit successfully
before timeout elapsed or a maximum <br>
number of invocations has been reached.</p>

<p style="margin-top: 1em">rlWaitForCmd command [-p PID]
[-t time] [-m count] [-d delay] [-r retval]</p>

<p style="margin-top: 1em">command <br>
Command that will be executed until its return code is equal
0 or value speciefied as option to &lsquo;-r&rsquo;.</p>

<p style="margin-top: 1em">-t time <br>
Timeout in seconds, default=120. If the command
doesn&rsquo;t return 0 before time elapses, the command will
be killed.</p>

<p style="margin-top: 1em">-p PID <br>
PID of the process to check before running command. If the
process exits before the socket is opened, the command will
log a WARNING.</p>

<p style="margin-top: 1em">-m count <br>
Maximum number of &lsquo;command&rsquo; executions before
continuing anyway. Default is infite. Returns 1 if the
maximum was reached.</p>

<p style="margin-top: 1em">-d delay <br>
Delay between &lsquo;command&rsquo; invocations. Default
1.</p>

<p style="margin-top: 1em">-r retval <br>
Expected return value of command. Default 0.</p>

<p style="margin-top: 1em">rlWaitForFile</p>

<p style="margin-top: 1em">Pauses script execution until
specified file or directory starts existing. Returns 0 if
file started existing, 1 if timeout was reached or PID
exited. Return code is greater <br>
than 1 in case of error.</p>

<p style="margin-top: 1em">rlWaitForFile path [-p PID] [-t
time] [-d delay]</p>

<p style="margin-top: 1em">path <br>
Path to file that should start existing.</p>

<p style="margin-top: 1em">-t time <br>
Timeout in seconds (optional, default=120). If the file
isn&rsquo;t opened before the time elapses the command
returns 1.</p>

<p style="margin-top: 1em">-p PID <br>
PID of the process that should also be running. If the
process exits before the file is created, the command
returns with status code of 1.</p>

<p style="margin-top: 1em">-d delay <br>
Delay between subsequent checks for existence of file.
Default 1.</p>

<p style="margin-top: 1em">rlWaitForSocket</p>

<p style="margin-top: 1em">Pauses script execution until
socket starts listening. Returns 0 if socket started
listening, 1 if timeout was reached or PID exited. Return
code is greater than 1 in case of <br>
error.</p>

<p style="margin-top: 1em">rlWaitForSocket {port|path} [-p
PID] [-t time] [-d delay] [--close]</p>

<p style="margin-top: 1em">port|path <br>
Network port to wait for opening or a path to UNIX socket.
Regular expressions are also supported.</p>

<p style="margin-top: 1em">-t time <br>
Timeout in seconds (optional, default=120). If the socket
isn&rsquo;t opened before the time elapses the command
returns 1.</p>

<p style="margin-top: 1em">-p PID <br>
PID of the process that should also be running. If the
process exits before the socket is opened, the command
returns with status code of 1.</p>

<p style="margin-top: 1em">-d delay <br>
Delay between subsequent checks for availability of socket.
Default 1.</p>

<p style="margin-top: 1em">--close <br>
Wait for the socket to stop listening.</p>

<p style="margin-top: 1em">rlWait</p>

<p style="margin-top: 1em">Wrapper around bash builtin
&lsquo;wait&rsquo; command. See bash_builtins(1) man page.
Kills the process and all its children if the timeout
elapses.</p>

<p style="margin-top: 1em">rlWaitFor [n ...] [-s SIGNAL]
[-t time]</p>

<p style="margin-top: 1em">n List of PIDs to wait for. They
need to be background tasks of current shell. See
bash_builtins(1) section for &lsquo;wait&rsquo; command/</p>

<p style="margin-top: 1em">-t time <br>
Timeout in seconds (optional, default=30). If the wait
isn&rsquo;t successful before the time elapses then all
specified tasks are killed.</p>

<p style="margin-top: 1em">-s SIGNAL <br>
Signal used to kill the process, optional SIGTERM by
default.</p>

<p style="margin-top: 1em">Virtual X Server <br>
Functions providing simple way how to start and stop virtual
X server.</p>

<p style="margin-top: 1em">rlVirtualXStart</p>

<p style="margin-top: 1em">Start a virtual X server on a
first free display. Tries only first N displays, so you can
run out of them.</p>

<p style="margin-top: 1em">rlVirtualXStart name</p>

<p style="margin-top: 1em">name <br>
String identifying the X server.</p>

<p style="margin-top: 1em">Returns 0 when the server is
started successfully.</p>

<p style="margin-top: 1em">rlVirtualXGetDisplay</p>

<p style="margin-top: 1em">Get the DISPLAY variable for
specified virtual X server.</p>

<p style="margin-top: 1em">rlVirtualXGetDisplay name</p>

<p style="margin-top: 1em">name <br>
String identifying the X server.</p>

<p style="margin-top: 1em">Displays the number of display
where specified virtual X server is running to standard
output. Returns 0 on success.</p>

<p style="margin-top: 1em">rlVirtualXStop</p>

<p style="margin-top: 1em">Kill the specified X server.</p>

<p style="margin-top: 1em">rlVirtualXStop name</p>

<p style="margin-top: 1em">name <br>
String identifying the X server.</p>

<p style="margin-top: 1em">Returns 0 when the server is
stopped successfully.</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">Below is a simple example of
usage. Note that a lot of usefull debugging information is
reported on the DEBUG level, so you can run your test with
&quot;DEBUG=1 make run&quot; to get them.</p>

<p style="margin-top: 1em">rlVirtualXStart $TEST <br>
rlAssert0 &quot;Virtual X server started&quot; $? <br>
export DISPLAY=&quot;$( rlVirtualXGetDisplay $TEST )&quot;
<br>
# ...your test which needs X... <br>
rlVirtualXStop $TEST <br>
rlAssert0 &quot;Virtual X server killed&quot; $?</p>

<p style="margin-top: 1em">These are &quot;Requires&quot;
lines for your scripts - note different package names for
different RHEL versions:</p>

<p style="margin-top: 1em">@echo &quot;Requires:
xorg-x11-server-Xvfb&quot; &gt;&gt; $(METADATA) # RHEL-5
<br>
@echo &quot;Requires: xorg-x11-Xvfb&quot; &gt;&gt;
$(METADATA) # RHEL-4 <br>
@echo &quot;Requires: XFree86-Xvfb&quot; &gt;&gt;
$(METADATA) # RHEL-3</p>

<p style="margin-top: 1em">EXAMPLES <br>
Simple <br>
A minimal BeakerLib test can look like this:</p>

<p style="margin-top: 1em">.
/usr/share/beakerlib/beakerlib.sh</p>

<p style="margin-top: 1em">rlJournalStart <br>
rlPhaseStartTest <br>
rlAssertRpm &quot;setup&quot; <br>
rlAssertExists &quot;/etc/passwd&quot; <br>
rlAssertGrep &quot;root&quot; &quot;/etc/passwd&quot; <br>
rlPhaseEnd <br>
rlJournalEnd</p>

<p style="margin-top: 1em">Phases <br>
Here comes a bit more interesting example of a test which
sets all the recommended variables and makes use of the
phases:</p>

<p style="margin-top: 1em"># Include the BeakerLib
environment <br>
. /usr/share/beakerlib/beakerlib.sh</p>

<p style="margin-top: 1em"># Set the full test name <br>
TEST=&quot;/examples/beakerlib/Sanity/phases&quot;</p>

<p style="margin-top: 1em"># Package being tested <br>
PACKAGE=&quot;coreutils&quot;</p>

<p style="margin-top: 1em">rlJournalStart <br>
# Setup phase: Prepare test directory <br>
rlPhaseStartSetup <br>
rlAssertRpm $PACKAGE <br>
rlRun &rsquo;TmpDir=$(mktemp -d)&rsquo; 0 &rsquo;Creating
tmp directory&rsquo; # no-reboot <br>
rlRun &quot;pushd $TmpDir&quot; <br>
rlPhaseEnd</p>

<p style="margin-top: 1em"># Test phase: Testing touch, ls
and rm commands <br>
rlPhaseStartTest <br>
rlRun &quot;touch foo&quot; 0 &quot;Creating the foo test
file&quot; <br>
rlAssertExists &quot;foo&quot; <br>
rlRun &quot;ls -l foo&quot; 0 &quot;Listing the foo test
file&quot; <br>
rlRun &quot;rm foo&quot; 0 &quot;Removing the foo test
file&quot; <br>
rlAssertNotExists &quot;foo&quot; <br>
rlRun &quot;ls -l foo&quot; 2 &quot;Listing foo should now
report an error&quot; <br>
rlPhaseEnd</p>

<p style="margin-top: 1em"># Cleanup phase: Remove test
directory <br>
rlPhaseStartCleanup <br>
rlRun &quot;popd&quot; <br>
rlRun &quot;rm -r $TmpDir&quot; 0 &quot;Removing tmp
directory&quot; <br>
rlPhaseEnd <br>
rlJournalEnd</p>

<p style="margin-top: 1em"># Print the test report <br>
rlJournalPrintText</p>

<p style="margin-top: 1em">The ouput of the
rlJournalPrintText command would produce an output similar
to the following:</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: TEST PROTOCOL <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">:: [ LOG ] :: Test run ID :
debugging <br>
:: [ LOG ] :: Package : coreutils <br>
:: [ LOG ] :: Installed: : coreutils-7.6-9.fc12.i686 <br>
:: [ LOG ] :: Test started : 2010-02-08 14:55:44 <br>
:: [ LOG ] :: Test finished : 2010-02-08 14:55:50 <br>
:: [ LOG ] :: Test name : /examples/beakerlib/Sanity/phases
<br>
:: [ LOG ] :: Distro: : Fedora release 12 (Constantine) <br>
:: [ LOG ] :: Hostname : localhost <br>
:: [ LOG ] :: Architecture : i686</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: Test description <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">PURPOSE of
/examples/beakerlib/Sanity/phases <br>
Description: Testing BeakerLib phases <br>
Author: Petr Splichal &lt;psplicha@redhat.com&gt;</p>

<p style="margin-top: 1em">This example shows how the
phases work in the BeakerLib on a <br>
trivial smoke test for the &quot;touch&quot;, &quot;ls&quot;
and &quot;rm&quot; commands from <br>
the coreutils package.</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: Setup <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">:: [ PASS ] :: Checking for the
presence of coreutils rpm <br>
:: [ PASS ] :: Creating tmp directory <br>
:: [ PASS ] :: Running &rsquo;pushd
/tmp/tmp.IcluQu5GVS&rsquo; # no-reboot <br>
:: [ LOG ] :: Duration: 0s <br>
:: [ LOG ] :: Assertions: 3 good, 0 bad <br>
:: [ PASS ] :: RESULT: Setup</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: Test <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">:: [ PASS ] :: Creating the foo
test file <br>
:: [ PASS ] :: File foo should exist <br>
:: [ PASS ] :: Listing the foo test file <br>
:: [ PASS ] :: Removing the foo test file <br>
:: [ PASS ] :: File foo should not exist <br>
:: [ PASS ] :: Listing foo should now report an error <br>
:: [ LOG ] :: Duration: 1s <br>
:: [ LOG ] :: Assertions: 6 good, 0 bad <br>
:: [ PASS ] :: RESULT: Test</p>


<p style="margin-top: 1em">::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
<br>
:: [ LOG ] :: Cleanup <br>

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</p>

<p style="margin-top: 1em">:: [ PASS ] :: Running
&rsquo;popd&rsquo; <br>
:: [ PASS ] :: Removing tmp directory <br>
:: [ LOG ] :: Duration: 1s <br>
:: [ LOG ] :: Assertions: 2 good, 0 bad <br>
:: [ PASS ] :: RESULT: Cleanup</p>

<p style="margin-top: 1em">Note that the detailed test
description is read from a separate file PURPOSE placed in
the same directory as the test itself.</p>

<p style="margin-top: 1em">A lot of useful debugging
information is reported on the DEBUG level. You can run your
test with &quot;DEBUG=1 make run&quot; to get them.</p>

<p style="margin-top: 1em">Verbosity of the test logging
may be altered also by setting the LOG_LEVEL variable.
Possible values are &quot;ERROR&quot;, &quot;WARNING&quot;,
&quot;INFO&quot; and &quot;DEBUG&quot;. You will see
messages like the <br>
ones below.</p>

<p style="margin-top: 1em">:: [ WARNING ] :: rlGetArch:
Update test to use rlGetPrimaryArch/rlGetSecondaryArch <br>
:: [ DEBUG ] :: rlGetArch: This is architecture
&rsquo;x86_64&rsquo; <br>
:: [ ERROR ] :: this function was dropped as its development
is completely moved to the beaker library <br>
:: [ INFO ] :: if you realy on this function and you really
need to have it present in core beakerlib, file a RFE,
please</p>

<p style="margin-top: 1em">Setting
LOG_LEVEL=&quot;DEBUG&quot; is equivalent to DEBUG=1.</p>

<p style="margin-top: 1em">BKRDOC <br>
Description <br>
Bkrdoc is a documentation generator from tests written using
BeakerLib library. This generator makes documentation from
test code with and also without any documentation <br>
markup.</p>

<p style="margin-top: 1em">What it&rsquo;s good for <br>
For fast, brief and reliable documentation creation.
It&lsquo;s good for quick start with unknown BeakerLib test.
Created documentations provides information about the <br>
documentation credibility. Also created documentations shows
environmental variables and helps reader to run test script
from which was documentation created.</p>

<p style="margin-top: 1em">Bkrdoc project page <br>
https://github.com/rh-lab-q/bkrdoc</p>

<p style="margin-top: 1em">LINKS <br>
Project Page <br>
https://github.com/beakerlib</p>

<p style="margin-top: 1em">Manual <br>
https://github.com/beakerlib/beakerlib/wiki/man</p>

<p style="margin-top: 1em">Issues list <br>
https://github.com/beakerlib/beakerlib/issues</p>

<p style="margin-top: 1em">Reporting issues <br>
https://github.com/beakerlib/beakerlib/issues/new</p>

<p style="margin-top: 1em">AUTHORS <br>
&Acirc;&middot; Petr Muller &lt;pmuller@redhat.com&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Ondrej Hudlicky
&lt;ohudlick@redhat.com&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Jan Hutar
&lt;jhutar@redhat.com&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Petr Splichal
&lt;psplicha@redhat.com&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Ales Zelinka
&lt;azelinka@redhat.com&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Dalibor Pospisil
&lt;dapospis@redhat.com&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Martin Kyral
&lt;mkyral@redhat.com&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Jakub Prokes
&lt;jprokes@redhat.com&gt;</p>

<p style="margin-top: 1em">perl v5.24.1 2017-05-23
BEAKERLIB(1)</p>
<hr>
</body>
</html>
