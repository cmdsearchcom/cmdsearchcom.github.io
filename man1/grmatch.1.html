<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:15:26 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GRMATCH(1) User Commands GRMATCH(1)</p>

<p style="margin-top: 1em">NAME <br>
grmatch - pairing lines by involving identifier or cross
matching</p>

<p style="margin-top: 1em">SYNOPSIS <br>
grmatch [options] -r &lt;reference&gt; -i &lt;input&gt; [-o
&lt;output&gt;]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The program &lsquo;grmatch&lsquo; matches lines read from
two input files, namely from a reference and from an input
file. All implemented algorithms are symmetric, in the
manner that the <br>
result should be the same if these two files are swapped.
The only case when the order of these files is important is
when a geometrical transformation is also returned (see <br>
point matching below), in this case the swapping of the
files results the inverse form of the original
transformation. The lines (rows) can be matched using
various criteria. 1. <br>
Lines can be matched by identifier, where the identifier can
be any concatenation of arbitrary, space-separated columns
found in the files. Generally, the identifier is
repre&acirc; <br>
sented by a single column (e.g. it is an astronomical
catalog identifier). The behaviour of the program can be
tuned for the cases when there are more than one rows with
the same <br>
identifier. 2. Lines can be matched using a 2-dimensional
point matchig algorithm. In this method, the program expects
two-two columns both from the reference and input files <br>
which can be treated as X and Y coordinates. If both point
lists are known, the program tries to find the appropriate
geometrical transformation which transforms the points from
<br>
the frame of the reference list to the frame of the input
list and, simultaneously, tries to find as many pairs as
possible. The parameters of the geometrical transformation
<br>
and the whole algorithm can be fine-tuned. 3. Lines can be
matched using arbitrary- (N-) dimensional coordinate
matching algorithm. This method expects N-N columns both
from the <br>
reference and input files which can be treated as X_1, ...,
X_N Cartesian coordinates and the method assumes both of the
point sets in the same reference frame. The point
&rsquo;A&rsquo; <br>
from the reference list and the point &rsquo;P&rsquo; from
the input list forms a pair if the closest point to
&rsquo;A&rsquo; from the input list is &rsquo;P&rsquo; and
vice versa.</p>

<p style="margin-top: 1em">OPTIONS <br>
General options: <br>
-h, --help <br>
Give general summary about the command line options.</p>

<p style="margin-top: 1em">--long-help, --help-long <br>
Gives a detailed list of command line options.</p>

<p style="margin-top: 1em">--wiki-help, --help-wiki,
--mediawiki-help, --help-mediawiki <br>
Gives a detailed list of command line options in Mediawiki
format.</p>

<p style="margin-top: 1em">--version, --version-short,
--short-version <br>
Give some version information about the program.</p>

<p style="margin-top: 1em">-C, --comment <br>
Comment the output (both the transformation file and the
match file).</p>

<p style="margin-top: 1em">Options for input/output
specifications: <br>
-r &lt;referencefile&gt;, --input-reference
&lt;referencefile&gt; <br>
Mandatory, name of the reference file.</p>

<p style="margin-top: 1em">&lt;inputfile&gt;, -i
&lt;inputile&gt;, --input &lt;inputfile&gt; <br>
Name of the input file. If this switch is omitted, the input
isread from stdin (specifying some input is mandatory).</p>

<p style="margin-top: 1em">-o &lt;output&gt;, --output
&lt;output&gt;, --output-matched &lt;output&gt; <br>
Name of the output file, containing the matched lines. The
matched lines are pasted lines, the first part is from the
reference file and the second part is from the input <br>
file, these two parts are concatenated by a TAB character.
This switch is optional, if it is not specified, no such
output will be generated.</p>

<p style="margin-top: 1em">--output-excluded-reference
&lt;out&gt;, --output-excluded-input &lt;out&gt; <br>
Names of the files which contain the valid but excluded
lines from the reference and from the input. These outputs
are disjoint from the previous output and altogether <br>
contaions all valid lines.</p>

<p style="margin-top: 1em">--output-id &lt;out&gt; <br>
Name of the file which contaions only the identifiers of the
matched lines. If the primary matching method was not
identifier matching, one should specify the column <br>
indices of the identifiers by --col-ref-id and --col-inp-id
also.</p>

<p style="margin-top: 1em">--output-transformation
&lt;output-transformation-file&gt; <br>
Name of the output file containing the geometrical
transformation, in human-readable format, if the matching
method was point matching (in other case, this option has no
<br>
effect). The commented version of this file includes some
statistics about the matching (the total number of lines
used and matched, the required CPU time, the <br>
final triangulation level, the fit residuals and other
things like these).</p>

<p style="margin-top: 1em">In all of the above input/output
file specifications, the replacement of the file name by
&quot;-&quot; (a single minus sign) forces the reading from
stdin or writing to stdout. Note <br>
that all parts of the any line after &quot;#&quot;
(hashmark) are treated as a comment, therefore ignored.</p>

<p style="margin-top: 1em">General options for point
matching: <br>
--match-points <br>
This switch forces the usage of the point matching method.
By default, this method is assumed to be used, therefore
this switch can be omitted.</p>

<p style="margin-top: 1em">--col-ref &lt;x&gt;,&lt;y&gt;,
--col-inp &lt;x&gt;,&lt;y&gt; <br>
The column indices containing the X and Y coordinates, for
the reference and for the input file, respectively. The
index of the first column is always 1, the index of <br>
the second is 2 and so on. Lines in which these columns do
not contain valid real numbers bers are omitted.</p>

<p style="margin-top: 1em">-a &lt;order&gt;, --order
&lt;order&gt; <br>
This switch specifies the polynomial order of the resulted
geometrical transformation. It can be arbitrary positive
integer. Note that if the order is A, at least <br>
(A+1)*(A+2)/2 valid points are needed both from the
reference and both from the input file to fit the
transformation.</p>

<p style="margin-top: 1em">--max-distance &lt;maxdist&gt;
<br>
The maximal accepted distance between the matched points in
the coordinate frame of the input coordinate list (and not
in the coordinate frame of the reference coordinate <br>
list). Possible pairs (which are valid pairs due to the
symmetric coordinate matching algorihms) are excluded if
their Eucledian distance is larger than maxdist. Note <br>
that this option has no initial value, therefore, if
omitted, all possible pairs due to the symmetric matching
are resulted, which, in certain cases in practice, can <br>
result unexpected behaviour. One should always specify a
reasonable maximal distance which can be estimated only by
the knowledge of the physics of the input files.</p>

<p style="margin-top: 1em">See more options concerning to
point matching in the section &quot;Fine-Tuning of Point
Matching&quot; below. That section also describes the tuning
of the triangulation used <br>
by the point matching algorithm. For a more detailed
description about the point matching algorithms based on
pattern and triangle matching see [1], [2] or [3].</p>

<p style="margin-top: 1em">General options for coordinate
matching: <br>
--match-coord, --match-coords <br>
This switch forces the usage of the coordinate matching
method. Note that because of the common options with the
point matching method, one should specify this switch to
<br>
force the usage of the coordinate matching method (the
default method is point matching, see above).</p>

<p style="margin-top: 1em">--col-ref
&lt;x&gt;[,&lt;y&gt;,[&lt;z&gt;...]] --col-inp
&lt;x&gt;[,&lt;y&gt;,[&lt;z&gt;...]] <br>
The column indices containing the spatial coordinates, for
the reference and for the input file, respectively. The
index of the first column is always 1, the index of <br>
the second is 2 and so on. Lines in which these columns do
not contain valid real numbers are omitted. Note that the
dimension of the coordinate matching space is <br>
specified indirectly, by the number of column indices listed
here. Because of this, the number of column indices should
be the same for the reference and input, in <br>
other case, when the dimensions are mismatched, the program
exits unsuccessfully.</p>

<p style="margin-top: 1em">--max-distance &lt;maxdist&gt;
<br>
The maximal accepted distance between the matched points.
Possible pairs (which are valid pairs due to the symmetric
coordinate matching algorihms) are excluded if their <br>
Eucledian distance is larger than maxdist. Note that this
option has no initial value, therefore, if omitted, all
possible pairs due to the symmetric matching are <br>
resulted (see also point matching, above).</p>

<p style="margin-top: 1em">General options for identifier
matching: <br>
--match-id, --match-identifiers <br>
This switch forces the usage of the identifier matching
method.</p>

<p style="margin-top: 1em">--col-ref-id
&lt;i&gt;[,&lt;j&gt;,[&lt;k&gt;...]] --col-inp-id
&lt;i&gt;[,&lt;j&gt;,[&lt;k&gt;...]] <br>
Column index or indices containing the identifiers, from the
reference and from the input file, respectively.</p>

<p style="margin-top: 1em">--no-ambiguity,
--first-ambiguity, --any-ambiguity, --full-ambiguity <br>
These options tune the behaviour of the matching when there
is more than one occurrence of a given identifier in the
reference and/or input file. If --no-ambiguity is <br>
specified, these identifiers are discarded, this is the
default method. If --first-ambiguity is specified, only the
first occurence is treated as a matched line, inde&acirc;
<br>
pendently from the number of occurrences. If the switch
--any-ambiguity is specified, the lines are paired
sequentally, until there is any left from the reference and
<br>
from the input. For example, if there is 4 occurrences in
the reference and 6 in the input file of a given identifier,
4 matched pairs are returned. Otherwise, if <br>
--full-ambiguity is specified, all possible combinations of
the lines are treated as matched lines. For example, if
there is 4 occurrences in the reference and <br>
6 in the input file of a given identifier, all 4*6=24
combinations are returned as matched pairs.</p>

<p style="margin-top: 1em">Fine-tuning of point matching:
<br>
--triangulation &lt;parameters&gt; <br>
This switch is followed by comma-separated directives, which
specify the parameters of the triangulation-based point
matching algorithm:</p>

<p style="margin-top: 1em">delaunay, level=&lt;level&gt;,
full, auto, unitarity=&lt;U&gt; <br>
These directives specify the triangulation level used for
point matching. &quot;delaunay&quot; forces the usage only
of the Delaunay-triangles. This is the fastest method,
how&acirc; <br>
ever, it is only working if the points in the reference and
input lists are almost competely overlapping and describe
almost the same point sets (within a ratio of <br>
common points above 60-70%). The &quot;level&quot; specifies
the level of the expansion of the Delaunay-triangulation
(see [1] for more details). In practice, the lower <br>
the ratio of common points and/or the ratio of the
overlapping, the higher level should be used. Specifying
&quot;level=1&quot; or &quot;level=2&quot; gives a robust
but still fast <br>
method for general usage. The directive &quot;full&quot;
forces full triangulation. This can be overwhelmingly slow
and annoying and requires tons of memory if there are <br>
more than 40-50 points (the amounts of these resources are
proportional to the 6th(!) and 3rd power of the number of
the points, respectively). The directive &quot;auto&quot;
<br>
increases the level of the triangulation expansion
automatically until a proper match is found. A match is
considered as a good match if the unitarity of the
trans&acirc; <br>
formation is less than the unitarity U specified by the
&quot;unitarity=U&quot; directive (see also the section
Notes/Unitarity below).</p>

<p style="margin-top: 1em">mixed, conformable, reverse <br>
These directives define the chirality of the triangle spaces
to be used. Practically, it means the following. If we
don&rsquo;t know whether the input and reference lists are
<br>
inverted respecting to each other, one should use
&quot;mixed&quot; triangle space. If we are sure about that
the input and reference lists are not inverted, we can use
&quot;con&acirc; <br>
formable&quot; triangle space. If we know that the input and
reference lists are inverted, we can use &quot;reverse&quot;
space. Note that although &quot;mixed&quot; triangle space
can <br>
always result a good match, it is a wise idea to fix the
chirality by specifying &quot;conformable&quot; or
&quot;reverse&quot; if we really know that the point sets
are not inverted <br>
or inverted respecting to each other. If the chirality is
fixed, the program yields more matched pairs, the
appropriate triangulation level can be smaller <br>
and in &quot;auto&quot; mode, the program returns the match
definitely faster.</p>

<p style="margin-top: 1em">maxnumber=&lt;max&gt;,
maxref=&lt;mr&gt;, maxinp=&lt;mi&gt; <br>
These directives specify the maximal number of points which
are used for triangulation (for any type of triangulation).
If &quot;maxnumber&quot; is specified, it is equiva&acirc;
<br>
lent to define &quot;maxref&quot; and &quot;maxinp&quot;
with the same values. Then, the first &lt;mr&gt; points from
the reference and the first &lt;mi&gt; points from the input
list are used to <br>
generate the triangle sets. The &quot;first&quot; points are
selected using the optional information found in one of the
columns, see the following switches.</p>

<p style="margin-top: 1em">(Note that there should be only
one --triangulation switch, all desired directives should be
written in the same argument, separated by commas.)</p>

<p style="margin-top: 1em">--col-ref-ordering [-]&lt;w&gt;,
--col-inp-ordering [-]&lt;w&gt;. <br>
These switches specify one-one column index from the
reference and from the input files which are used to order
these lists and select the first &quot;maxref&quot; and
&quot;maxinp&quot; <br>
points (see above) for the generation of the two triangle
meshes. Both columns should contain valid real numbers,
otherwise the whole(!) line is excluded (not <br>
only from sorting but from the whole matching procedure). If
there is no negative sign before the column index, the data
are sorted in descending(!) order, therefore <br>
the lines with the lines with the highest(!) values are
selected for triangulation. If there is a negative sign
before the index, the data are sorted in ascending <br>
order by these values, therefore the lines with the
smallest(!) values are selected for triangulation. For
example, if we want to match star lists, we might want <br>
to use only the brightest ones to generate the triangle
sets. If the brightnesses of the stars are specified by
their fluxes, we should not use the negative sign <br>
(the list should be sorted in descending order to select the
first few lines as the brightest stars), and if the
brightness is known by the magnitude, we have to use <br>
the negative sign.</p>

<p style="margin-top: 1em">--fit
iterations=&lt;N&gt;,firstrejection=&lt;F&gt;,sigma=&lt;S&gt;
<br>
Like --triangulation, this switch is followed by some
directives. These directives specify the number &lt;N&gt; of
iterations (&quot;iterations=&lt;N&gt;&quot;) for point
matching. <br>
The &quot;firstrejection&quot; directive speciy the serial
number &lt;F&gt; of the first iteration where points farer
than &lt;S&gt; &quot;sigma&quot; level are excluded in the
next iteration. Note <br>
that in practice these type of iteration is really not
important (due to, for instance, the limitations of the
outliers by the --max-distance switch), however, some <br>
suspicious users can be convinced by such arguments.</p>

<p style="margin-top: 1em">--weight
reference|input,column=&lt;wi&gt;,[magnitude],[power=&lt;p&gt;]
<br>
These directives specify the weights which are used during
the fit of the geometrical transformation. For example, in
practice it is useful in the following situa&acirc; <br>
tion. We try to match star lists, then the fainter stars are
believed to have higher astrometrical errors, therefore they
should have smaller influence in the fit. We can <br>
take the weights from the reference (specify
&quot;reference&quot;) and from the input (specify
&quot;input&quot;), from the column specified by the
weight-index. The weights can be <br>
derived from stellar magnitudes, if so, specify
&quot;magnitude&quot; to convert the read values in
magnitude to flux. The real weights then is the
&quot;power&quot;th power of the <br>
flux. The default value of the &quot;power&quot; is 1,
however, for the maximum-likelihood estimation of an assumed
Gaussian distribution, the weights should be the second
power <br>
of the fluxes.</p>

<p style="margin-top: 1em">Some notes on unitarity. The
unitarity of a geometrical transformation measures how it
differs from the closest transformation which is affine and
a combination of dilation, <br>
rotation and shift. For such a transformation the unitarity
is 0 and if the second-order terms in a transformation
distort a such unitary transformation, the unitarity will
<br>
have the same magnitude like the magnitude of this
second-order effect. For example, to map a part of a sphere
with the size of d degrees will have an unitarity of
1-cos(d). <br>
Therefore, for astrometrical purposes, a reasonable value of
the critical unitarity in &quot;auto&quot; triangulation
mode can be estimated as 2 or 3 times 1-cos(d/2) where d is
the <br>
size of the field in which astrometry should be
performed.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to &lt;apal@szofi.net&gt;, see also
http://fitsh.net/.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 1996, 2002, 2004-2008, 2010-2015;
Pal, Andras &lt;apal@szofi.net&gt;</p>

<p style="margin-top: 1em">grmatch 0.9d6 (0.9.2@2016.09.23)
September 2016 GRMATCH(1)</p>
<hr>
</body>
</html>
