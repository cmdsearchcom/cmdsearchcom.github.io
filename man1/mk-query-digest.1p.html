<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:25:38 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MK-QUERY-DIGEST(1) User Contributed Perl Documentation
MK-QUERY-DIGEST(1)</p>

<p style="margin-top: 1em">NAME <br>
mk-query-digest - Analyze query execution logs and generate
a query report, filter, replay, or transform queries for
MySQL, PostgreSQL, memcached, and more.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
Usage: mk-query-digest [OPTION...] [FILE]</p>

<p style="margin-top: 1em">mk-query-digest parses and
analyzes MySQL log files. With no FILE, or when FILE is -,
it read standard input.</p>

<p style="margin-top: 1em">Analyze, aggregate, and report
on a slow query log:</p>

<p style="margin-top: 1em">mk-query-digest
/path/to/slow.log</p>

<p style="margin-top: 1em">Review a slow log, saving
results to the test.query_review table in a MySQL server
running on host1. See &quot;--review&quot; for more on
reviewing queries:</p>

<p style="margin-top: 1em">mk-query-digest --review
h=host1,D=test,t=query_review /path/to/slow.log</p>

<p style="margin-top: 1em">Filter out everything but SELECT
queries, replay the queries against another server, then use
the timings from replaying them to analyze their
performance:</p>

<p style="margin-top: 1em">mk-query-digest
/path/to/slow.log --execute h=another_server --filter
&rsquo;$event-&gt;{fingerprint} =~ m/^select/&rsquo;</p>

<p style="margin-top: 1em">Print the structure of events so
you can construct a complex &quot;--filter&quot;:</p>

<p style="margin-top: 1em">mk-query-digest
/path/to/slow.log --no-report --filter &rsquo;print
Dumper($event)&rsquo;</p>

<p style="margin-top: 1em">Watch SHOW FULL PROCESSLIST and
output a log in slow query log format:</p>

<p style="margin-top: 1em">mk-query-digest --processlist
h=host1 --print --no-report</p>

<p style="margin-top: 1em">The default aggregation and
analysis is CPU and memory intensive. Disable it if you
don&rsquo;t need the default report:</p>

<p style="margin-top: 1em">mk-query-digest
&lt;arguments&gt; --no-report</p>

<p style="margin-top: 1em">RISKS <br>
The following section is included to inform users about the
potential risks, whether known or unknown, of using this
tool. The two main categories of risks are those created by
<br>
the nature of the tool (e.g. read-only tools vs. read-write
tools) and those created by bugs.</p>

<p style="margin-top: 1em">By default mk-query-digest
merely collects and aggregates data from the files
specified. It is designed to be as efficient as possible,
but depending on the input you give it, <br>
it can use a lot of CPU and memory. Practically speaking, it
is safe to run even on production systems, but you might
want to monitor it until you are satisfied that the input
<br>
you give it does not cause undue load.</p>

<p style="margin-top: 1em">Various options will cause
mk-query-digest to insert data into tables, execute SQL
queries, and so on. These include the &quot;--execute&quot;
option and &quot;--review&quot;.</p>

<p style="margin-top: 1em">At the time of this release, we
know of no bugs that could cause serious harm to users.</p>

<p style="margin-top: 1em">The authoritative source for
updated information is always the online issue tracking
system. Issues that affect this tool will be marked as such.
You can see a list of such <br>
issues at the following URL:
&lt;http://www.maatkit.org/bugs/mk-query-digest&gt;.</p>

<p style="margin-top: 1em">See also &quot;BUGS&quot; for
more information on filing bugs and getting help.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This tool was formerly known as mk-log-parser.</p>

<p style="margin-top: 1em">&quot;mk-query-digest&quot; is a
framework for doing things with events from a query source
such as the slow query log or PROCESSLIST. By default it
acts as a very sophisticated log <br>
analysis tool. You can group and sort queries in many
different ways simultaneously and find the most expensive
queries, or create a timeline of queries in the log, for
example. <br>
It can also do a &quot;query review,&quot; which means to
save a sample of each type of query into a MySQL table so
you can easily see whether you&rsquo;ve reviewed and
analyzed a query before. <br>
The benefit of this is that you can keep track of changes to
your server&rsquo;s queries and avoid repeated work. You can
also save other information with the queries, such as <br>
comments, issue numbers in your ticketing system, and so
on.</p>

<p style="margin-top: 1em">Note that this is a work in
*very* active progress and you should expect incompatible
changes in the future.</p>

<p style="margin-top: 1em">ATTRIBUTES <br>
mk-query-digest works on events, which are a collection of
key/value pairs called attributes. You&rsquo;ll recognize
most of the attributes right away: Query_time, Lock_time,
and so <br>
on. You can just look at a slow log and see them. However,
there are some that don&rsquo;t exist in the slow log, and
slow logs may actually include different kinds of attributes
<br>
(for example, you may have a server with the Percona
patches).</p>

<p style="margin-top: 1em">For a full list of attributes,
see
&lt;http://code.google.com/p/maatkit/wiki/EventAttributes&gt;.</p>

<p style="margin-top: 1em">With creative use of
&quot;--filter&quot;, you can create new attributes derived
from existing attributes. For example, to create an
attribute called &quot;Row_ratio&quot; for examining the
ratio <br>
of &quot;Rows_sent&quot; to &quot;Rows_examined&quot;,
specify a filter like:</p>

<p style="margin-top: 1em">--filter
&rsquo;($event-&gt;{Row_ratio} = $event-&gt;{Rows_sent} /
($event-&gt;{Rows_examined})) &amp;&amp; 1&rsquo;</p>

<p style="margin-top: 1em">The &quot;&amp;&amp; 1&quot;
trick is needed to create a valid one-line syntax that is
always true, even if the assignment happens to evaluate
false. The new attribute will automatically appears <br>
in the output:</p>

<p style="margin-top: 1em"># Row ratio 1.00 0.00 1 0.50 1
0.71 0.50</p>

<p style="margin-top: 1em">Attributes created this way can
be specified for &quot;--order-by&quot; or any option that
requires an attribute.</p>

<p style="margin-top: 1em">memcached <br>
memcached events have additional attributes related to the
memcached protocol: cmd, key, res (result) and val. Also,
boolean attributes are created for the various commands,
<br>
misses and errors: Memc_CMD where CMD is a memcached command
(get, set, delete, etc.), Memc_error and Memc_miss.</p>

<p style="margin-top: 1em">These attributes are no
different from slow log attributes, so you can use them with
&quot;--[no]report&quot;, &quot;--group-by&quot;, in a
&quot;--filter&quot;, etc.</p>

<p style="margin-top: 1em">These attributes and more are
documented at
&lt;http://code.google.com/p/maatkit/wiki/EventAttributes&gt;.</p>

<p style="margin-top: 1em">OUTPUT <br>
The default output is a query analysis report. The
&quot;--[no]report&quot; option controls whether or not this
report is printed. Sometimes you may wish to parse all the
queries but <br>
suppress the report, for example when using
&quot;--print&quot;, &quot;--review&quot; or
&quot;--save-results&quot;.</p>

<p style="margin-top: 1em">There is one paragraph for each
class of query analyzed. A &quot;class&quot; of queries all
have the same value for the &quot;--group-by&quot; attribute
which is &quot;fingerprint&quot; by default. (See <br>
&quot;ATTRIBUTES&quot;.) A fingerprint is an abstracted
version of the query text with literals removed, whitespace
collapsed, and so forth. The report is formatted so
it&rsquo;s easy to paste <br>
into emails without wrapping, and all non-query lines begin
with a comment, so you can save it to a .sql file and open
it in your favorite syntax-highlighting text editor. There
<br>
is a response-time profile at the beginning.</p>

<p style="margin-top: 1em">The output described here is
controlled by &quot;--report-format&quot;. That option
allows you to specify what to print and in what order. The
default output in the default order is <br>
described here.</p>

<p style="margin-top: 1em">The report, by default, begins
with a paragraph about the entire analysis run The
information is very similar to what you&rsquo;ll see for
each class of queries in the log, but it <br>
doesn&rsquo;t have some information that would be too
expensive to keep globally for the analysis. It also has
some statistics about the code&rsquo;s execution itself,
such as the CPU and <br>
memory usage, the local date and time of the run, and a list
of input file read/parsed.</p>

<p style="margin-top: 1em">Following this is the
response-time profile over the events. This is a highly
summarized view of the unique events in the detailed query
report that follows. It contains the <br>
following columns:</p>

<p style="margin-top: 1em">Column Meaning <br>
============
==========================================================
<br>
Rank The query&rsquo;s rank within the entire set of queries
analyzed <br>
Query ID The query&rsquo;s fingerprint <br>
Response time The total response time, and percentage of
overall total <br>
Calls The number of times this query was executed <br>
R/Call The mean response time per execution <br>
Apdx The Apdex score; see --apdex-threshold for details <br>
V/M The Variance-to-mean ratio of response time <br>
EXPLAIN If --explain was specified, a sparkline; see
--explain <br>
Item The distilled query</p>

<p style="margin-top: 1em">A final line whose rank is shown
as MISC contains aggregate statistics on the queries that
were not included in the report, due to options such as
&quot;--limit&quot; and &quot;--outliers&quot;. <br>
For details on the variance-to-mean ratio, please see
http://en.wikipedia.org/wiki/Index_of_dispersion.</p>

<p style="margin-top: 1em">Next, the detailed query report
is printed. Each query appears in a paragraph. Here is a
sample, slightly reformatted so &rsquo;perldoc&rsquo; will
not wrap lines in a terminal. The <br>
following will all be one paragraph, but we&rsquo;ll break
it up for commentary.</p>

<p style="margin-top: 1em"># Query 2: 0.01 QPS, 0.02x conc,
ID 0xFDEA8D2993C9CAF3 at byte 160665</p>

<p style="margin-top: 1em">This line identifies the
sequential number of the query in the sort order specified
by &quot;--order-by&quot;. Then there&rsquo;s the queries
per second, and the approximate concurrency for <br>
this query (calculated as a function of the timespan and
total Query_time). Next there&rsquo;s a query ID. This ID is
a hex version of the query&rsquo;s checksum in the database,
if you&rsquo;re <br>
using &quot;--review&quot;. You can select the reviewed
query&rsquo;s details from the database with a query like
&quot;SELECT .... WHERE
checksum=0xFDEA8D2993C9CAF3&quot;.</p>

<p style="margin-top: 1em">If you are investigating the
report and want to print out every sample of a particular
query, then the following &quot;--filter&quot; may be
helpful: &quot;mk-query-digest slow-log.log <br>
--no-report --print --filter
&rsquo;$event-&quot;{fingerprint} &amp;&amp;
make_checksum($event-&gt;{fingerprint}) eq
&quot;FDEA8D2993C9CAF3&quot;&rsquo;&gt;.</p>

<p style="margin-top: 1em">Notice that you must remove the
0x prefix from the checksum in order for this to work.</p>

<p style="margin-top: 1em">Finally, in case you want to
find a sample of the query in the log file, there&rsquo;s
the byte offset where you can look. (This is not always
accurate, due to some silly anomalies in <br>
the slow-log format, but it&rsquo;s usually right.) The
position refers to the worst sample, which we&rsquo;ll see
more about below.</p>

<p style="margin-top: 1em">Next is the table of metrics
about this class of queries.</p>

<p style="margin-top: 1em"># pct total min max avg 95%
stddev median <br>
# Count 0 2 <br>
# Exec time 13 1105s 552s 554s 553s 554s 2s 553s <br>
# Lock time 0 216us 99us 117us 108us 117us 12us 108us <br>
# Rows sent 20 6.26M 3.13M 3.13M 3.13M 3.13M 12.73 3.13M
<br>
# Rows exam 0 6.26M 3.13M 3.13M 3.13M 3.13M 12.73 3.13M</p>

<p style="margin-top: 1em">The first line is column headers
for the table. The percentage is the percent of the total
for the whole analysis run, and the total is the actual
value of the specified metric. <br>
For example, in this case we can see that the query executed
2 times, which is 13% of the total number of queries in the
file. The min, max and avg columns are self-explanatory.
<br>
The 95% column shows the 95th percentile; 95% of the values
are less than or equal to this value. The standard deviation
shows you how tightly grouped the values are. The <br>
standard deviation and median are both calculated from the
95th percentile, discarding the extremely large values.</p>

<p style="margin-top: 1em">The stddev, median and 95th
percentile statistics are approximate. Exact statistics
require keeping every value seen, sorting, and doing some
calculations on them. This uses a <br>
lot of memory. To avoid this, we keep 1000 buckets, each of
them 5% bigger than the one before, ranging from .000001 up
to a very big number. When we see a value we increment <br>
the bucket into which it falls. Thus we have fixed memory
per class of queries. The drawback is the imprecision, which
typically falls in the 5 percent range.</p>

<p style="margin-top: 1em">Next we have statistics on the
users, databases and time range for the query.</p>

<p style="margin-top: 1em"># Users 1 user1 <br>
# Databases 2 db1(1), db2(1) <br>
# Time range 2008-11-26 04:55:18 to 2008-11-27 00:15:15</p>

<p style="margin-top: 1em">The users and databases are
shown as a count of distinct values, followed by the values.
If there&rsquo;s only one, it&rsquo;s shown alone; if there
are many, we show each of the most <br>
frequent ones, followed by the number of times it
appears.</p>

<p style="margin-top: 1em"># Query_time distribution <br>
# 1us <br>
# 10us <br>
# 100us <br>
# 1ms <br>
# 10ms <br>
# 100ms <br>
# 1s <br>
# 10s+
#############################################################</p>

<p style="margin-top: 1em">The execution times show a
logarithmic chart of time clustering. Each query goes into
one of the &quot;buckets&quot; and is counted up. The
buckets are powers of ten. The first bucket <br>
is all values in the &quot;single microsecond range&quot; --
that is, less than 10us. The second is &quot;tens of
microseconds,&quot; which is from 10us up to (but not
including) 100us; and so on. <br>
The charted attribute can be changed by specifying
&quot;--report-histogram&quot; but is limited to time-based
attributes.</p>

<p style="margin-top: 1em"># Tables <br>
# SHOW TABLE STATUS LIKE &rsquo;table1&rsquo;G <br>
# SHOW CREATE TABLE &lsquo;table1&lsquo;G <br>
# EXPLAIN <br>
SELECT * FROM table1G</p>

<p style="margin-top: 1em">This section is a convenience:
if you&rsquo;re trying to optimize the queries you see in
the slow log, you probably want to examine the table
structure and size. These are copy-and- <br>
paste-ready commands to do that.</p>

<p style="margin-top: 1em">Finally, we see a sample of the
queries in this class of query. This is not a random sample.
It is the query that performed the worst, according to the
sort order given by <br>
&quot;--order-by&quot;. You will normally see a commented
&quot;# EXPLAIN&quot; line just before it, so you can
copy-paste the query to examine its EXPLAIN plan. But for
non-SELECT queries that <br>
isn&rsquo;t possible to do, so the tool tries to transform
the query into a roughly equivalent SELECT query, and adds
that below.</p>

<p style="margin-top: 1em">If you want to find this sample
event in the log, use the offset mentioned above, and
something like the following:</p>

<p style="margin-top: 1em">tail -c +&lt;offset&gt;
/path/to/file | head</p>

<p style="margin-top: 1em">See also
&quot;--report-format&quot;.</p>

<p style="margin-top: 1em">SPARKLINES <br>
The output also contains sparklines. Sparklines are
&quot;data-intense, design-simple, word-sized graphics&quot;
(&lt;http://en.wikipedia.org/wiki/Sparkline&gt;).There is a
sparkline for <br>
&quot;--report-histogram&quot; and for
&quot;--explain&quot;. See each of those options for details
about interpreting their sparklines.</p>

<p style="margin-top: 1em">QUERY REVIEWS <br>
A &quot;query review&quot; is the process of storing all the
query fingerprints analyzed. This has several benefits:</p>

<p style="margin-top: 1em">&Acirc;&middot; You can add
meta-data to classes of queries, such as marking them for
follow-up, adding notes to queries, or marking them with an
issue ID for your issue tracking system.</p>

<p style="margin-top: 1em">&Acirc;&middot; You can refer to
the stored values on subsequent runs so you&rsquo;ll know
whether you&rsquo;ve seen a query before. This can help you
cut down on duplicated work.</p>

<p style="margin-top: 1em">&Acirc;&middot; You can store
historical data such as the row count, query times, and
generally anything you can see in the report.</p>

<p style="margin-top: 1em">To use this feature, you run
mk-query-digest with the &quot;--review&quot; option. It
will store the fingerprints and other information into the
table you specify. Next time you run it <br>
with the same option, it will do the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; It won&rsquo;t
show you queries you&rsquo;ve already reviewed. A query is
considered to be already reviewed if you&rsquo;ve set a
value for the &quot;reviewed_by&quot; column. (If you want
to see <br>
queries you&rsquo;ve already reviewed, use the
&quot;--report-all&quot; option.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Queries that
you&rsquo;ve reviewed, and don&rsquo;t appear in the output,
will cause gaps in the query number sequence in the first
line of each paragraph. And the value you&rsquo;ve <br>
specified for &quot;--limit&quot; will still be honored. So
if you&rsquo;ve reviewed all queries in the top 10 and you
ask for the top 10, you won&rsquo;t see anything in the
output.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you want to
see the queries you&rsquo;ve already reviewed, you can
specify &quot;--report-all&quot;. Then you&rsquo;ll see the
normal analysis output, but you&rsquo;ll also see the
information from <br>
the review table, just below the execution time graph. For
example,</p>

<p style="margin-top: 1em"># Review information <br>
# comments: really bad IN() subquery, fix soon! <br>
# first_seen: 2008-12-01 11:48:57 <br>
# jira_ticket: 1933 <br>
# last_seen: 2008-12-18 11:49:07 <br>
# priority: high <br>
# reviewed_by: xaprb <br>
# reviewed_on: 2008-12-18 15:03:11</p>

<p style="margin-top: 1em">You can see how useful this
meta-data is -- as you analyze your queries, you get your
comments integrated right into the report.</p>

<p style="margin-top: 1em">If you add the
&quot;--review-history&quot; option, it will also store
information into a separate database table, so you can keep
historical trending information on classes of <br>
queries.</p>

<p style="margin-top: 1em">FINGERPRINTS <br>
A query fingerprint is the abstracted form of a query, which
makes it possible to group similar queries together.
Abstracting a query removes literal values, normalizes <br>
whitespace, and so on. For example, consider these two
queries:</p>

<p style="margin-top: 1em">SELECT name, password FROM user
WHERE id=&rsquo;12823&rsquo;; <br>
select name, password from user <br>
where id=5;</p>

<p style="margin-top: 1em">Both of those queries will
fingerprint to</p>

<p style="margin-top: 1em">select name, password from user
where id=?</p>

<p style="margin-top: 1em">Once the query&rsquo;s
fingerprint is known, we can then talk about a query as
though it represents all similar queries.</p>

<p style="margin-top: 1em">What &quot;mk-query-digest&quot;
does is analogous to a GROUP BY statement in SQL. (But note
that &quot;multiple columns&quot; doesn&rsquo;t define a
multi-column grouping; it defines multiple reports!) <br>
If your command-line looks like this,</p>

<p style="margin-top: 1em">mk-query-digest
/path/to/slow.log --select Rows_read,Rows_sent --group-by
fingerprint --order-by Query_time:sum --limit 10</p>

<p style="margin-top: 1em">The corresponding pseudo-SQL
looks like this:</p>

<p style="margin-top: 1em">SELECT WORST(query BY
Query_time), SUM(Query_time), ... <br>
FROM /path/to/slow.log <br>
GROUP BY FINGERPRINT(query) <br>
ORDER BY SUM(Query_time) DESC <br>
LIMIT 10</p>

<p style="margin-top: 1em">You can also use the value
&quot;distill&quot;, which is a kind of super-fingerprint.
See &quot;--group-by&quot; for more.</p>

<p style="margin-top: 1em">When parsing memcached input
(&quot;--type&quot; memcached), the fingerprint is an
abstracted version of the command and key, with placeholders
removed. For example, &quot;get <br>
user_123_preferences&quot; fingerprints to &quot;get
user_?_preferences&quot;. There is also a
&quot;key_print&quot; which a fingerprinted version of the
key. This example&rsquo;s key_print is <br>
&quot;user_?_preferences&quot;.</p>

<p style="margin-top: 1em">Query fingerprinting
accommodates a great many special cases, which have proven
necessary in the real world. For example, an IN list with 5
literals is really equivalent to one <br>
with 4 literals, so lists of literals are collapsed to a
single one. If you want to understand more about how and why
all of these cases are handled, please review the test <br>
cases in the Subversion repository. If you find something
that is not fingerprinted properly, please submit a bug
report with a reproducible test case. Here is a list of <br>
transformations during fingerprinting, which might not be
exhaustive:</p>

<p style="margin-top: 1em">&Acirc;&middot; Group all SELECT
queries from mysqldump together, even if they are against
different tables. Ditto for all of mk-table-checksum&rsquo;s
checksum queries.</p>

<p style="margin-top: 1em">&Acirc;&middot; Shorten
multi-value INSERT statements to a single VALUES() list.</p>

<p style="margin-top: 1em">&Acirc;&middot; Strip
comments.</p>

<p style="margin-top: 1em">&Acirc;&middot; Abstract the
databases in USE statements, so all USE statements are
grouped together.</p>

<p style="margin-top: 1em">&Acirc;&middot; Replace all
literals, such as quoted strings. For efficiency, the code
that replaces literal numbers is somewhat non-selective, and
might replace some things as numbers when <br>
they really are not. Hexadecimal literals are also replaced.
NULL is treated as a literal. Numbers embedded in
identifiers are also replaced, so tables named similarly
<br>
will be fingerprinted to the same values (e.g. users_2009
and users_2010 will fingerprint identically).</p>

<p style="margin-top: 1em">&Acirc;&middot; Collapse all
whitespace into a single space.</p>

<p style="margin-top: 1em">&Acirc;&middot; Lowercase the
entire query.</p>

<p style="margin-top: 1em">&Acirc;&middot; Replace all
literals inside of IN() and VALUES() lists with a single
placeholder, regardless of cardinality.</p>

<p style="margin-top: 1em">&Acirc;&middot; Collapse
multiple identical UNION queries into a single one.</p>

<p style="margin-top: 1em">OPTIONS <br>
DSN values in &quot;--review-history&quot; default to values
in &quot;--review&quot; if COPY is yes.</p>

<p style="margin-top: 1em">This tool accepts additional
command-line arguments. Refer to the &quot;SYNOPSIS&quot;
and usage information for details.</p>

<p style="margin-top: 1em">--apdex-threshold <br>
type: float; default: 1.0</p>

<p style="margin-top: 1em">Set Apdex target threshold (T)
for query response time. The Application Performance Index
(Apdex) Technical Specification V1.1 defines T as &quot;a
positive decimal value in <br>
seconds, having no more than two significant digits of
granularity.&quot; This value only applies to query response
time (Query_time).</p>

<p style="margin-top: 1em">Options can be abbreviated so
specifying &quot;--apdex-t&quot; also works.</p>

<p style="margin-top: 1em">See
&lt;http://www.apdex.org/&gt;.</p>

<p style="margin-top: 1em">--ask-pass <br>
Prompt for a password when connecting to MySQL.</p>

<p style="margin-top: 1em">--attribute-aliases <br>
type: array; default: db|Schema</p>

<p style="margin-top: 1em">List of attribute|alias,etc.</p>

<p style="margin-top: 1em">Certain attributes have multiple
names, like db and Schema. If an event does not have the
primary attribute, mk-query-digest looks for an alias
attribute. If it finds an <br>
alias, it creates the primary attribute with the alias
attribute&rsquo;s value and removes the alias attribute.</p>

<p style="margin-top: 1em">If the event has the primary
attribute, all alias attributes are deleted.</p>

<p style="margin-top: 1em">This helps simplify event
attributes so that, for example, there will not be report
lines for both db and Schema.</p>

<p style="margin-top: 1em">--attribute-value-limit <br>
type: int; default: 4294967296</p>

<p style="margin-top: 1em">A sanity limit for attribute
values.</p>

<p style="margin-top: 1em">This option deals with bugs in
slow-logging functionality that causes large values for
attributes. If the attribute&rsquo;s value is bigger than
this, the last-seen value for that <br>
class of query is used instead.</p>

<p style="margin-top: 1em">--aux-dsn <br>
type: DSN</p>

<p style="margin-top: 1em">Auxiliary DSN used for special
options.</p>

<p style="margin-top: 1em">The following options may
require a DSN even when only parsing a slow log file:</p>

<p style="margin-top: 1em">* --since <br>
* --until</p>

<p style="margin-top: 1em">See each option for why it might
require a DSN.</p>

<p style="margin-top: 1em">--charset <br>
short form: -A; type: string</p>

<p style="margin-top: 1em">Default character set. If the
value is utf8, sets Perl&rsquo;s binmode on STDOUT to utf8,
passes the mysql_enable_utf8 option to DBD::mysql, and runs
SET NAMES UTF8 after <br>
connecting to MySQL. Any other value sets binmode on STDOUT
without the utf8 layer, and runs SET NAMES after connecting
to MySQL.</p>

<p style="margin-top: 1em">--check-attributes-limit <br>
type: int; default: 1000</p>

<p style="margin-top: 1em">Stop checking for new attributes
after this many events.</p>

<p style="margin-top: 1em">For better speed,
mk-query-digest stops checking events for new attributes
after a certain number of events. Any new attributes after
this number will be ignored and will <br>
not be reported.</p>

<p style="margin-top: 1em">One special case is new
attributes for pre-existing query classes (see
&quot;--group-by&quot; about query classes). New attributes
will not be added to pre-existing query classes even <br>
if the attributes are detected before the
&quot;--check-attributes-limit&quot; limit.</p>

<p style="margin-top: 1em">--config <br>
type: Array</p>

<p style="margin-top: 1em">Read this comma-separated list
of config files; if specified, this must be the first option
on the command line.</p>

<p style="margin-top: 1em">--[no]continue-on-error <br>
default: yes</p>

<p style="margin-top: 1em">Continue parsing even if there
is an error.</p>

<p style="margin-top: 1em">--create-review-history-table
<br>
Create the &quot;--review-history&quot; table if it does not
exist.</p>

<p style="margin-top: 1em">This option causes the table
specified by &quot;--review-history&quot; to be created with
the default structure shown in the documentation for that
option.</p>

<p style="margin-top: 1em">--create-review-table <br>
Create the &quot;--review&quot; table if it does not
exist.</p>

<p style="margin-top: 1em">This option causes the table
specified by &quot;--review&quot; to be created with the
default structure shown in the documentation for that
option.</p>

<p style="margin-top: 1em">--daemonize <br>
Fork to the background and detach from the shell. POSIX
operating systems only.</p>

<p style="margin-top: 1em">--defaults-file <br>
short form: -F; type: string</p>

<p style="margin-top: 1em">Only read mysql options from the
given file. You must give an absolute pathname.</p>

<p style="margin-top: 1em">--embedded-attributes <br>
type: array</p>

<p style="margin-top: 1em">Two Perl regex patterns to
capture pseudo-attributes embedded in queries.</p>

<p style="margin-top: 1em">Embedded attributes might be
special attribute-value pairs that you&rsquo;ve hidden in
comments. The first regex should match the entire set of
attributes (in case there are <br>
multiple). The second regex should match and capture
attribute-value pairs from the first regex.</p>

<p style="margin-top: 1em">For example, suppose your query
looks like the following:</p>

<p style="margin-top: 1em">SELECT * from users -- file:
/login.php, line: 493;</p>

<p style="margin-top: 1em">You might run mk-query-digest
with the following option:</p>

<p style="margin-top: 1em">mk-query-digest
--embedded-attributes &rsquo; --
.*&rsquo;,&rsquo;(168)&rsquo;</p>

<p style="margin-top: 1em">The first regular expression
captures the whole comment:</p>

<p style="margin-top: 1em">&quot; -- file: /login.php,
line: 493;&quot;</p>

<p style="margin-top: 1em">The second one splits it into
attribute-value pairs and adds them to the event:</p>

<p style="margin-top: 1em">ATTRIBUTE VALUE <br>
========= ========== <br>
file /login.php <br>
line 493</p>

<p style="margin-top: 1em">NOTE: All commas in the regex
patterns must be escaped with &nbsp;otherwise the pattern
will break.</p>

<p style="margin-top: 1em">--execute <br>
type: DSN</p>

<p style="margin-top: 1em">Execute queries on this DSN.</p>

<p style="margin-top: 1em">Adds a callback into the chain,
after filters but before the reports. Events are executed on
this DSN. If they are successful, the time they take to
execute overwrites the <br>
event&rsquo;s Query_time attribute and the original
Query_time value (from the log) is saved as the
Exec_orig_time attribute. If unsuccessful, the callback
returns false and <br>
terminates the chain.</p>

<p style="margin-top: 1em">If the connection fails,
mk-query-digest tries to reconnect once per second.</p>

<p style="margin-top: 1em">See also &quot;--mirror&quot;
and &quot;--execute-throttle&quot;.</p>

<p style="margin-top: 1em">--execute-throttle <br>
type: array</p>

<p style="margin-top: 1em">Throttle values for
&quot;--execute&quot;.</p>

<p style="margin-top: 1em">By default &quot;--execute&quot;
runs without any limitations or concerns for the amount of
time that it takes to execute the events. The
&quot;--execute-throttle&quot; allows you to limit the <br>
amount of time spent doing &quot;--execute&quot; relative to
the other processes that handle events. This works by
marking some events with a &quot;Skip_exec&quot; attribute
when &quot;--execute&quot; <br>
begins to take too much time. &quot;--execute&quot; will not
execute an event if this attribute is true. This indirectly
decreases the time spent doing &quot;--execute&quot;.</p>

<p style="margin-top: 1em">The
&quot;--execute-throttle&quot; option takes at least two
comma-separated values: max allowed &quot;--execute&quot;
time as a percentage and a check interval time. An optional
third value is <br>
a percentage step for increasing and decreasing the
probability that an event will be marked
&quot;Skip_exec&quot; true. 5 (percent) is the default
step.</p>

<p style="margin-top: 1em">For example:
&quot;--execute-throttle&quot; &quot;70,60,10&quot;. This
will limit &quot;--execute&quot; to 70% of total event
processing time, checked every minute (60 seconds) and
probability stepped up <br>
and down by 10%. When &quot;--execute&quot; exceeds 70%, the
probability that events will be marked &quot;Skip_exec&quot;
true increases by 10%. &quot;--execute&quot; time is checked
again after another <br>
minute. If it&rsquo;s still above 70%, then the probability
will increase another 10%. Or, if it&rsquo;s dropped below
70%, then the probability will decrease by 10%.</p>

<p style="margin-top: 1em">--expected-range <br>
type: array; default: 5,10</p>

<p style="margin-top: 1em">Explain items when there are
more or fewer than expected.</p>

<p style="margin-top: 1em">Defines the number of items
expected to be seen in the report given by
&quot;--[no]report&quot;, as controlled by
&quot;--limit&quot; and &quot;--outliers&quot;. If there are
more or fewer items in the <br>
report, each one will explain why it was included.</p>

<p style="margin-top: 1em">--explain <br>
type: DSN</p>

<p style="margin-top: 1em">Run EXPLAIN for the sample query
with this DSN and print results.</p>

<p style="margin-top: 1em">This works only when
&quot;--group-by&quot; includes fingerprint. It causes
mk-query-digest to run EXPLAIN and include the output into
the report. For safety, queries that appear to <br>
have a subquery that EXPLAIN will execute won&rsquo;t be
EXPLAINed. Those are typically &quot;derived table&quot;
queries of the form</p>

<p style="margin-top: 1em">select ... from ( select .... )
der;</p>

<p style="margin-top: 1em">The EXPLAIN results are printed
in three places: a sparkline in the event header, a full
vertical format in the event report, and a sparkline in the
profile.</p>

<p style="margin-top: 1em">The full format appears at the
end of each event report in vertical style (&quot;G&quot;)
just like MySQL prints it.</p>

<p style="margin-top: 1em">The sparklines (see
&quot;SPARKLINES&quot;) are compact representations of the
access type for each table and whether or not &quot;Using
temporary&quot; or &quot;Using filesort&quot; appear in
EXPLAIN. <br>
The sparklines look like:</p>

<p style="margin-top: 1em">nr&gt;TF</p>

<p style="margin-top: 1em">That sparkline means that there
are two tables, the first uses a range (n) access, the
second uses a ref access, and both &quot;Using
temporary&quot; (T) and &quot;Using filesort&quot; (F) <br>
appear. The greater-than character just separates table
access codes from T and/or F.</p>

<p style="margin-top: 1em">The abbreviated table access
codes are:</p>

<p style="margin-top: 1em">a ALL <br>
c const <br>
e eq_ref <br>
f fulltext <br>
i index <br>
m index_merge <br>
n range <br>
o ref_or_null <br>
r ref <br>
s system <br>
u unique_subquery</p>

<p style="margin-top: 1em">A capitalized access code means
that &quot;Using index&quot; appears in EXPLAIN for that
table.</p>

<p style="margin-top: 1em">--filter <br>
type: string</p>

<p style="margin-top: 1em">Discard events for which this
Perl code doesn&rsquo;t return true.</p>

<p style="margin-top: 1em">This option is a string of Perl
code or a file containing Perl code that gets compiled into
a subroutine with one argument: $event. This is a hashref.
If the given value is <br>
a readable file, then mk-query-digest reads the entire file
and uses its contents as the code. The file should not
contain a shebang (#!/usr/bin/perl) line.</p>

<p style="margin-top: 1em">If the code returns true, the
chain of callbacks continues; otherwise it ends. The code is
the last statement in the subroutine other than &quot;return
$event&quot;. The subroutine <br>
template is:</p>

<p style="margin-top: 1em">sub { $event = shift; filter
&amp;&amp; return $event; }</p>

<p style="margin-top: 1em">Filters given on the command
line are wrapped inside parentheses like like &quot;( filter
)&quot;. For complex, multi-line filters, you must put the
code inside a file so it will not <br>
be wrapped inside parentheses. Either way, the filter must
produce syntactically valid code given the template. For
example, an if-else branch given on the command line <br>
would not be valid:</p>

<p style="margin-top: 1em">--filter &rsquo;if () { } else {
}&rsquo; # WRONG</p>

<p style="margin-top: 1em">Since it&rsquo;s given on the
command line, the if-else branch would be wrapped inside
parentheses which is not syntactically valid. So to
accomplish something more complex like <br>
this would require putting the code in a file, for example
filter.txt:</p>

<p style="margin-top: 1em">my $event_ok; if (...) {
$event_ok=1; } else { $event_ok=0; } $event_ok</p>

<p style="margin-top: 1em">Then specify &quot;--filter
filter.txt&quot; to read the code from filter.txt.</p>

<p style="margin-top: 1em">If the filter code won&rsquo;t
compile, mk-query-digest will die with an error. If the
filter code does compile, an error may still occur at
runtime if the code tries to do <br>
something wrong (like pattern match an undefined value).
mk-query-digest does not provide any safeguards so code
carefully!</p>

<p style="margin-top: 1em">An example filter that discards
everything but SELECT statements:</p>

<p style="margin-top: 1em">--filter &rsquo;$event-&gt;{arg}
=~ m/^select/i&rsquo;</p>

<p style="margin-top: 1em">This is compiled into a
subroutine like the following:</p>

<p style="margin-top: 1em">sub { $event = shift; (
$event-&gt;{arg} =~ m/^select/i ) &amp;&amp; return $event;
}</p>

<p style="margin-top: 1em">It is permissible for the code
to have side effects (to alter $event).</p>

<p style="margin-top: 1em">You can find an explanation of
the structure of $event at
&lt;http://code.google.com/p/maatkit/wiki/EventAttributes&gt;.</p>

<p style="margin-top: 1em">Here are more examples of filter
code:</p>

<p style="margin-top: 1em">Host/IP matches domain.com <br>
--filter &rsquo;($event-&gt;{host} || $event-&gt;{ip} ||
&quot;&quot;) =~ m/domain.com/&rsquo;</p>

<p style="margin-top: 1em">Sometimes MySQL logs the host
where the IP is expected. Therefore, we check both.</p>

<p style="margin-top: 1em">User matches john <br>
--filter &rsquo;($event-&gt;{user} || &quot;&quot;) =~
m/john/&rsquo;</p>

<p style="margin-top: 1em">More than 1 warning <br>
--filter &rsquo;($event-&gt;{Warning_count} || 0) &gt;
1&rsquo;</p>

<p style="margin-top: 1em">Query does full table scan or
full join <br>
--filter &rsquo;(($event-&gt;{Full_scan} || &quot;&quot;) eq
&quot;Yes&quot;) || (($event-&gt;{Full_join} ||
&quot;&quot;) eq &quot;Yes&quot;)&rsquo;</p>

<p style="margin-top: 1em">Query was not served from query
cache <br>
--filter &rsquo;($event-&gt;{QC_Hit} || &quot;&quot;) eq
&quot;No&quot;&rsquo;</p>

<p style="margin-top: 1em">Query is 1 MB or larger <br>
--filter &rsquo;$event-&gt;{bytes} &gt;=
1_048_576&rsquo;</p>

<p style="margin-top: 1em">Since &quot;--filter&quot;
allows you to alter $event, you can use it to do other
things, like create new attributes. See
&quot;ATTRIBUTES&quot; for an example.</p>

<p style="margin-top: 1em">--fingerprints <br>
Add query fingerprints to the standard query analysis
report. This is mostly useful for debugging purposes.</p>

<p style="margin-top: 1em">--[no]for-explain <br>
default: yes</p>

<p style="margin-top: 1em">Print extra information to make
analysis easy.</p>

<p style="margin-top: 1em">This option adds code snippets
to make it easy to run SHOW CREATE TABLE and SHOW TABLE
STATUS for the query&rsquo;s tables. It also rewrites
non-SELECT queries into a SELECT that <br>
might be helpful for determining the non-SELECT
statement&rsquo;s index usage.</p>

<p style="margin-top: 1em">--group-by <br>
type: Array; default: fingerprint</p>

<p style="margin-top: 1em">Which attribute of the events to
group by.</p>

<p style="margin-top: 1em">In general, you can group
queries into classes based on any attribute of the query,
such as &quot;user&quot; or &quot;db&quot;, which will by
default show you which users and which databases get <br>
the most &quot;Query_time&quot;. The default attribute,
&quot;fingerprint&quot;, groups similar, abstracted queries
into classes; see below and see also
&quot;FINGERPRINTS&quot;.</p>

<p style="margin-top: 1em">A report is printed for each
&quot;--group-by&quot; value (unless &quot;--no-report&quot;
is given). Therefore, &quot;--group-by user,db&quot; means
&quot;report on queries with the same user and report on
<br>
queries with the same db&quot;--it does not mean
&quot;report on queries with the same user and db.&quot; See
also &quot;OUTPUT&quot;.</p>

<p style="margin-top: 1em">Every value must have a
corresponding value in the same position in
&quot;--order-by&quot;. However, adding values to
&quot;--group-by&quot; will automatically add values to
&quot;--order-by&quot;, for <br>
your convenience.</p>

<p style="margin-top: 1em">There are several magical values
that cause some extra data mining to happen before the
grouping takes place:</p>

<p style="margin-top: 1em">fingerprint <br>
This causes events to be fingerprinted to abstract queries
into a canonical form, which is then used to group events
together into a class. See &quot;FINGERPRINTS&quot; for more
<br>
about fingerprinting.</p>

<p style="margin-top: 1em">tables <br>
This causes events to be inspected for what appear to be
tables, and then aggregated by that. Note that a query that
contains two or more tables will be counted as many <br>
times as there are tables; so a join against two tables will
count the Query_time against both tables.</p>

<p style="margin-top: 1em">distill <br>
This is a sort of super-fingerprint that collapses queries
down into a suggestion of what they do, such as &quot;INSERT
SELECT table1 table2&quot;.</p>

<p style="margin-top: 1em">If parsing memcached input
(&quot;--type&quot; memcached), there are other attributes
which you can group by: key_print (see memcached section in
&quot;FINGERPRINTS&quot;), cmd, key, res and val <br>
(see memcached section in &quot;ATTRIBUTES&quot;).</p>

<p style="margin-top: 1em">--[no]gzip <br>
default: yes</p>

<p style="margin-top: 1em">Gzip &quot;--save-results&quot;
files; requires IO::Compress::Gzip.</p>

<p style="margin-top: 1em">--help <br>
Show help and exit.</p>

<p style="margin-top: 1em">--host <br>
short form: -h; type: string</p>

<p style="margin-top: 1em">Connect to host.</p>

<p style="margin-top: 1em">--ignore-attributes <br>
type: array; default: arg, cmd, insert_id, ip, port,
Thread_id, timestamp, exptime, flags, key, res, val,
server_id, offset, end_log_pos, Xid</p>

<p style="margin-top: 1em">Do not aggregate these
attributes when auto-detecting &quot;--select&quot;.</p>

<p style="margin-top: 1em">If you do not specify
&quot;--select&quot; then mk-query-digest auto-detects and
aggregates every attribute that it finds in the slow log.
Some attributes, however, should not be <br>
aggregated. This option allows you to specify a list of
attributes to ignore. This only works when no explicit
&quot;--select&quot; is given.</p>

<p style="margin-top: 1em">--inherit-attributes <br>
type: array; default: db,ts</p>

<p style="margin-top: 1em">If missing, inherit these
attributes from the last event that had them.</p>

<p style="margin-top: 1em">This option sets which
attributes are inherited or carried forward to events which
do not have them. For example, if one event has the db
attribute equal to &quot;foo&quot;, but the <br>
next event doesn&rsquo;t have the db attribute, then it
inherits &quot;foo&quot; for its db attribute.</p>

<p style="margin-top: 1em">Inheritance is usually
desirable, but in some cases it might confuse things. If a
query inherits a database that it doesn&rsquo;t actually
use, then this could confuse <br>
&quot;--execute&quot;.</p>

<p style="margin-top: 1em">--interval <br>
type: float; default: .1</p>

<p style="margin-top: 1em">How frequently to poll the
processlist, in seconds.</p>

<p style="margin-top: 1em">--iterations <br>
type: int; default: 1</p>

<p style="margin-top: 1em">How many times to iterate
through the collect-and-report cycle. If 0, iterate to
infinity. Each iteration runs for &quot;--run-time&quot;
amount of time. An iteration is usually <br>
determined by an amount of time and a report is printed when
that amount of time elapses. With
&quot;--run-time-mode&quot; &quot;interval&quot;, an
interval is instead determined by the <br>
interval time you specify with &quot;--run-time&quot;. See
&quot;--run-time&quot; and &quot;--run-time-mode&quot; for
more information.</p>

<p style="margin-top: 1em">--limit <br>
type: Array; default: 95%:20</p>

<p style="margin-top: 1em">Limit output to the given
percentage or count.</p>

<p style="margin-top: 1em">If the argument is an integer,
report only the top N worst queries. If the argument is an
integer followed by the &quot;%&quot; sign, report that
percentage of the worst queries. If <br>
the percentage is followed by a colon and another integer,
report the top percentage or the number specified by that
integer, whichever comes first.</p>

<p style="margin-top: 1em">The value is actually a
comma-separated array of values, one for each item in
&quot;--group-by&quot;. If you don&rsquo;t specify a value
for any of those items, the default is the top 95%.</p>

<p style="margin-top: 1em">See also
&quot;--outliers&quot;.</p>

<p style="margin-top: 1em">--log <br>
type: string</p>

<p style="margin-top: 1em">Print all output to this file
when daemonized.</p>

<p style="margin-top: 1em">--mirror <br>
type: float</p>

<p style="margin-top: 1em">How often to check whether
connections should be moved, depending on
&quot;read_only&quot;. Requires &quot;--processlist&quot;
and &quot;--execute&quot;.</p>

<p style="margin-top: 1em">This option causes
mk-query-digest to check every N seconds whether it is
reading from a read-write server and executing against a
read-only server, which is a sensible way <br>
to set up two servers if you&rsquo;re doing something like
master-master replication. The
&lt;http://code.google.com/p/mysql-master-master/&gt;
master-master toolkit does this. The aim <br>
is to keep the passive server ready for failover, which is
impossible without putting it under a realistic
workload.</p>

<p style="margin-top: 1em">--order-by <br>
type: Array; default: Query_time:sum</p>

<p style="margin-top: 1em">Sort events by this attribute
and aggregate function.</p>

<p style="margin-top: 1em">This is a comma-separated list
of order-by expressions, one for each &quot;--group-by&quot;
attribute. The default &quot;Query_time:sum&quot; is used
for &quot;--group-by&quot; attributes without <br>
explicitly given &quot;--order-by&quot; attributes (that is,
if you specify more &quot;--group-by&quot; attributes than
corresponding &quot;--order-by&quot; attributes). The syntax
is <br>
&quot;attribute:aggregate&quot;. See &quot;ATTRIBUTES&quot;
for valid attributes. Valid aggregates are:</p>

<p style="margin-top: 1em">Aggregate Meaning <br>
========= ============================ <br>
sum Sum/total attribute value <br>
min Minimum attribute value <br>
max Maximum attribute value <br>
cnt Frequency/count of the query</p>

<p style="margin-top: 1em">For example, the default
&quot;Query_time:sum&quot; means that queries in the query
analysis report will be ordered (sorted) by their total
query execution time (&quot;Exec time&quot;). <br>
&quot;Query_time:max&quot; orders the queries by their
maximum query execution time, so the query with the single
largest &quot;Query_time&quot; will be list first.
&quot;cnt&quot; refers more to the <br>
frequency of the query as a whole, how often it appears;
&quot;Count&quot; is its corresponding line in the query
analysis report. So any attribute and &quot;cnt&quot; should
yield the same <br>
report wherein queries are sorted by the number of times
they appear.</p>

<p style="margin-top: 1em">When parsing general logs
(&quot;--type&quot; &quot;genlog&quot;), the default
&quot;--order-by&quot; becomes &quot;Query_time:cnt&quot;.
General logs do not report query times so only the
&quot;cnt&quot; aggregate makes <br>
sense because all query times are zero.</p>

<p style="margin-top: 1em">If you specify an attribute that
doesn&rsquo;t exist in the events, then mk-query-digest
falls back to the default &quot;Query_time:sum&quot; and
prints a notice at the beginning of the <br>
report for each query class. You can create attributes with
&quot;--filter&quot; and order by them; see
&quot;ATTRIBUTES&quot; for an example.</p>

<p style="margin-top: 1em">--outliers <br>
type: array; default: Query_time:1:10</p>

<p style="margin-top: 1em">Report outliers by
attribute:percentile:count.</p>

<p style="margin-top: 1em">The syntax of this option is a
comma-separated list of colon-delimited strings. The first
field is the attribute by which an outlier is defined. The
second is a number that <br>
is compared to the attribute&rsquo;s 95th percentile. The
third is optional, and is compared to the attribute&rsquo;s
cnt aggregate. Queries that pass this specification are
added to <br>
the report, regardless of any limits you specified in
&quot;--limit&quot;.</p>

<p style="margin-top: 1em">For example, to report queries
whose 95th percentile Query_time is at least 60 seconds and
which are seen at least 5 times, use the following
argument:</p>

<p style="margin-top: 1em">--outliers Query_time:60:5</p>

<p style="margin-top: 1em">You can specify an --outliers
option for each value in &quot;--group-by&quot;.</p>

<p style="margin-top: 1em">--password <br>
short form: -p; type: string</p>

<p style="margin-top: 1em">Password to use when
connecting.</p>

<p style="margin-top: 1em">--pid <br>
type: string</p>

<p style="margin-top: 1em">Create the given PID file when
daemonized. The file contains the process ID of the
daemonized instance. The PID file is removed when the
daemonized instance exits. The <br>
program checks for the existence of the PID file when
starting; if it exists and the process with the matching PID
exists, the program exits.</p>

<p style="margin-top: 1em">--pipeline-profile <br>
Print a profile of the pipeline processes.</p>

<p style="margin-top: 1em">--port <br>
short form: -P; type: int</p>

<p style="margin-top: 1em">Port number to use for
connection.</p>

<p style="margin-top: 1em">--print <br>
Print log events to STDOUT in standard slow-query-log
format.</p>

<p style="margin-top: 1em">--print-iterations <br>
Print the start time for each &quot;--iterations&quot;.</p>

<p style="margin-top: 1em">This option causes a line like
the following to be printed at the start of each
&quot;--iterations&quot; report:</p>

<p style="margin-top: 1em"># Iteration 2 started at
2009-11-24T14:39:48.345780</p>

<p style="margin-top: 1em">This line will print even if
&quot;--no-report&quot; is specified. If &quot;--iterations
0&quot; is specified, each iteration number will be 0.</p>

<p style="margin-top: 1em">--processlist <br>
type: DSN</p>

<p style="margin-top: 1em">Poll this DSN&rsquo;s
processlist for queries, with &quot;--interval&quot; sleep
between.</p>

<p style="margin-top: 1em">If the connection fails,
mk-query-digest tries to reopen it once per second. See also
&quot;--mirror&quot;.</p>

<p style="margin-top: 1em">--progress <br>
type: array; default: time,30</p>

<p style="margin-top: 1em">Print progress reports to
STDERR. The value is a comma-separated list with two parts.
The first part can be percentage, time, or iterations; the
second part specifies how <br>
often an update should be printed, in percentage, seconds,
or number of iterations.</p>

<p style="margin-top: 1em">--read-timeout <br>
type: time; default: 0</p>

<p style="margin-top: 1em">Wait this long for an event from
the input; 0 to wait forever.</p>

<p style="margin-top: 1em">This option sets the maximum
time to wait for an event from the input. It applies to all
types of input except &quot;--processlist&quot;. If an event
is not received after the <br>
specified time, the script stops reading the input and
prints its reports. If &quot;--iterations&quot; is 0 or
greater than 1, the next iteration will begin, else the
script will <br>
exit.</p>

<p style="margin-top: 1em">This option requires the Perl
POSIX module.</p>

<p style="margin-top: 1em">--[no]report <br>
default: yes</p>

<p style="margin-top: 1em">Print out reports on the
aggregate results from &quot;--group-by&quot;.</p>

<p style="margin-top: 1em">This is the standard slow-log
analysis functionality. See &quot;OUTPUT&quot; for the
description of what this does and what the results look
like.</p>

<p style="margin-top: 1em">--report-all <br>
Include all queries, even if they have already been
reviewed.</p>

<p style="margin-top: 1em">--report-format <br>
type: Array; default:
rusage,date,hostname,files,header,profile,query_report,prepared</p>

<p style="margin-top: 1em">Print these sections of the
query analysis report.</p>

<p style="margin-top: 1em">SECTION PRINTS <br>
============
====================================================== <br>
rusage CPU times and memory usage reported by ps <br>
date Current local date and time <br>
hostname Hostname of machine on which mk-query-digest was
run <br>
files Input files read/parse <br>
header Summary of the entire analysis run <br>
profile Compact table of queries for an overview of the
report <br>
query_report Detailed information about each unique query
<br>
prepared Prepared statements</p>

<p style="margin-top: 1em">The sections are printed in the
order specified. The rusage, date, files and header sections
are grouped together if specified together; other sections
are separated by <br>
blank lines.</p>

<p style="margin-top: 1em">See &quot;OUTPUT&quot; for more
information on the various parts of the query report.</p>

<p style="margin-top: 1em">--report-histogram <br>
type: string; default: Query_time</p>

<p style="margin-top: 1em">Chart the distribution of this
attribute&rsquo;s values.</p>

<p style="margin-top: 1em">The distribution chart is
limited to time-based attributes, so charting
&quot;Rows_examined&quot;, for example, will produce a
useless chart. Charts look like:</p>

<p style="margin-top: 1em"># Query_time distribution <br>
# 1us <br>
# 10us <br>
# 100us <br>
# 1ms <br>
# 10ms ################################ <br>
# 100ms
################################################################
<br>
# 1s ######## <br>
# 10s+</p>

<p style="margin-top: 1em">A sparkline (see
&quot;SPARKLINES&quot;) of the full chart is also printed in
the header for each query event. The sparkline of that full
chart is:</p>

<p style="margin-top: 1em"># Query_time sparkline: | .^_
|</p>

<p style="margin-top: 1em">The sparkline itself is the 8
characters between the pipes (&quot;|&quot;), one character
for each of the 8 buckets (1us, 10us, etc.) Four character
codes are used to represent the <br>
approximate relation between each bucket&rsquo;s value:</p>

<p style="margin-top: 1em">_ . - ^</p>

<p style="margin-top: 1em">The caret &quot;^&quot;
represents peaks (buckets with the most values), and the
underscore &quot;_&quot; represents lows (buckets with the
least or at least one value). The period &quot;.&quot; and
the <br>
hyphen &quot;-&quot; represent buckets with values between
these two extremes. If a bucket has no values, a space is
printed. So in the example above, the period represents the
10ms <br>
bucket, the caret the 100ms bucket, and the underscore the
1s bucket.</p>

<p style="margin-top: 1em">See &quot;OUTPUT&quot; for more
information.</p>

<p style="margin-top: 1em">--review <br>
type: DSN</p>

<p style="margin-top: 1em">Store a sample of each class of
query in this DSN.</p>

<p style="margin-top: 1em">The argument specifies a table
to store all unique query fingerprints in. The table must
have at least the following columns. You can add more
columns for your own special <br>
purposes, but they won&rsquo;t be used by mk-query-digest.
The following CREATE TABLE definition is also used for
&quot;--create-review-table&quot;. MAGIC_create_review:</p>

<p style="margin-top: 1em">CREATE TABLE query_review ( <br>
checksum BIGINT UNSIGNED NOT NULL PRIMARY KEY, <br>
fingerprint TEXT NOT NULL, <br>
sample TEXT NOT NULL, <br>
first_seen DATETIME, <br>
last_seen DATETIME, <br>
reviewed_by VARCHAR(20), <br>
reviewed_on DATETIME, <br>
comments TEXT <br>
)</p>

<p style="margin-top: 1em">The columns are as follows:</p>

<p style="margin-top: 1em">COLUMN MEANING <br>
=========== =============== <br>
checksum A 64-bit checksum of the query fingerprint <br>
fingerprint The abstracted version of the query; its primary
key <br>
sample The query text of a sample of the class of queries
<br>
first_seen The smallest timestamp of this class of queries
<br>
last_seen The largest timestamp of this class of queries
<br>
reviewed_by Initially NULL; if set, query is skipped
thereafter <br>
reviewed_on Initially NULL; not assigned any special meaning
<br>
comments Initially NULL; not assigned any special
meaning</p>

<p style="margin-top: 1em">Note that the
&quot;fingerprint&quot; column is the true primary key for a
class of queries. The &quot;checksum&quot; is just a
cryptographic hash of this value, which provides a shorter
value <br>
that is very likely to also be unique.</p>

<p style="margin-top: 1em">After parsing and aggregating
events, your table should contain a row for each
fingerprint. This option depends on &quot;--group-by
fingerprint&quot; (which is the default). It will <br>
not work otherwise.</p>

<p style="margin-top: 1em">--review-history <br>
type: DSN</p>

<p style="margin-top: 1em">The table in which to store
historical values for review trend analysis.</p>

<p style="margin-top: 1em">Each time you review queries
with &quot;--review&quot;, mk-query-digest will save
information into this table so you can see how classes of
queries have changed over time.</p>

<p style="margin-top: 1em">This DSN inherits unspecified
values from &quot;--review&quot;. It should mention a table
in which to store statistics about each class of queries.
mk-query-digest verifies the <br>
existence of the table, and your privileges to insert,
delete and update on that table.</p>

<p style="margin-top: 1em">mk-query-digest then inspects
the columns in the table. The table must have at least the
following columns:</p>

<p style="margin-top: 1em">CREATE TABLE
query_review_history ( <br>
checksum BIGINT UNSIGNED NOT NULL, <br>
sample TEXT NOT NULL <br>
);</p>

<p style="margin-top: 1em">Any columns not mentioned above
are inspected to see if they follow a certain naming
convention. The column is special if the name ends with an
underscore followed by any of <br>
these MAGIC_history_cols values:</p>


<p style="margin-top: 1em">pct|avt|cnt|sum|min|max|pct_95|stddev|median|rank</p>

<p style="margin-top: 1em">If the column ends with one of
those values, then the prefix is interpreted as the event
attribute to store in that column, and the suffix is
interpreted as the metric to be <br>
stored. For example, a column named Query_time_min will be
used to store the minimum Query_time for the class of
events. The presence of this column will also add <br>
Query_time to the &quot;--select&quot; list.</p>

<p style="margin-top: 1em">The table should also have a
primary key, but that is up to you, depending on how you
want to store the historical data. We suggest adding ts_min
and ts_max columns and <br>
making them part of the primary key along with the checksum.
But you could also just add a ts_min column and make it a
DATE type, so you&rsquo;d get one row per class of queries
<br>
per day.</p>

<p style="margin-top: 1em">The default table structure
follows. The following MAGIC_create_review_history table
definition is used for
&quot;--create-review-history-table&quot;:</p>

<p style="margin-top: 1em">CREATE TABLE
query_review_history ( <br>
checksum BIGINT UNSIGNED NOT NULL, <br>
sample TEXT NOT NULL, <br>
ts_min DATETIME, <br>
ts_max DATETIME, <br>
ts_cnt FLOAT, <br>
Query_time_sum FLOAT, <br>
Query_time_min FLOAT, <br>
Query_time_max FLOAT, <br>
Query_time_pct_95 FLOAT, <br>
Query_time_stddev FLOAT, <br>
Query_time_median FLOAT, <br>
Lock_time_sum FLOAT, <br>
Lock_time_min FLOAT, <br>
Lock_time_max FLOAT, <br>
Lock_time_pct_95 FLOAT, <br>
Lock_time_stddev FLOAT, <br>
Lock_time_median FLOAT, <br>
Rows_sent_sum FLOAT, <br>
Rows_sent_min FLOAT, <br>
Rows_sent_max FLOAT, <br>
Rows_sent_pct_95 FLOAT, <br>
Rows_sent_stddev FLOAT, <br>
Rows_sent_median FLOAT, <br>
Rows_examined_sum FLOAT, <br>
Rows_examined_min FLOAT, <br>
Rows_examined_max FLOAT, <br>
Rows_examined_pct_95 FLOAT, <br>
Rows_examined_stddev FLOAT, <br>
Rows_examined_median FLOAT, <br>
-- Percona extended slowlog attributes <br>
-- http://www.percona.com/docs/wiki/patches:slow_extended
<br>
Rows_affected_sum FLOAT, <br>
Rows_affected_min FLOAT, <br>
Rows_affected_max FLOAT, <br>
Rows_affected_pct_95 FLOAT, <br>
Rows_affected_stddev FLOAT, <br>
Rows_affected_median FLOAT, <br>
Rows_read_sum FLOAT, <br>
Rows_read_min FLOAT, <br>
Rows_read_max FLOAT, <br>
Rows_read_pct_95 FLOAT, <br>
Rows_read_stddev FLOAT, <br>
Rows_read_median FLOAT, <br>
Merge_passes_sum FLOAT, <br>
Merge_passes_min FLOAT, <br>
Merge_passes_max FLOAT, <br>
Merge_passes_pct_95 FLOAT, <br>
Merge_passes_stddev FLOAT, <br>
Merge_passes_median FLOAT, <br>
InnoDB_IO_r_ops_min FLOAT, <br>
InnoDB_IO_r_ops_max FLOAT, <br>
InnoDB_IO_r_ops_pct_95 FLOAT, <br>
InnoDB_IO_r_ops_stddev FLOAT, <br>
InnoDB_IO_r_ops_median FLOAT, <br>
InnoDB_IO_r_bytes_min FLOAT, <br>
InnoDB_IO_r_bytes_max FLOAT, <br>
InnoDB_IO_r_bytes_pct_95 FLOAT, <br>
InnoDB_IO_r_bytes_stddev FLOAT, <br>
InnoDB_IO_r_bytes_median FLOAT, <br>
InnoDB_IO_r_wait_min FLOAT, <br>
InnoDB_IO_r_wait_max FLOAT, <br>
InnoDB_IO_r_wait_pct_95 FLOAT, <br>
InnoDB_IO_r_wait_stddev FLOAT, <br>
InnoDB_IO_r_wait_median FLOAT, <br>
InnoDB_rec_lock_wait_min FLOAT, <br>
InnoDB_rec_lock_wait_max FLOAT, <br>
InnoDB_rec_lock_wait_pct_95 FLOAT, <br>
InnoDB_rec_lock_wait_stddev FLOAT, <br>
InnoDB_rec_lock_wait_median FLOAT, <br>
InnoDB_queue_wait_min FLOAT, <br>
InnoDB_queue_wait_max FLOAT, <br>
InnoDB_queue_wait_pct_95 FLOAT, <br>
InnoDB_queue_wait_stddev FLOAT, <br>
InnoDB_queue_wait_median FLOAT, <br>
InnoDB_pages_distinct_min FLOAT, <br>
InnoDB_pages_distinct_max FLOAT, <br>
InnoDB_pages_distinct_pct_95 FLOAT, <br>
InnoDB_pages_distinct_stddev FLOAT, <br>
InnoDB_pages_distinct_median FLOAT, <br>
-- Boolean (Yes/No) attributes. Only the cnt and sum are
needed for these. <br>
-- cnt is how many times is attribute was recorded and sum
is how many of <br>
-- those times the value was Yes. Therefore sum/cnt * 100 =
% of recorded <br>
-- times that the value was Yes. <br>
QC_Hit_cnt FLOAT, <br>
QC_Hit_sum FLOAT, <br>
Full_scan_cnt FLOAT, <br>
Full_scan_sum FLOAT, <br>
Full_join_cnt FLOAT, <br>
Full_join_sum FLOAT, <br>
Tmp_table_cnt FLOAT, <br>
Tmp_table_sum FLOAT, <br>
Disk_tmp_table_cnt FLOAT, <br>
Disk_tmp_table_sum FLOAT, <br>
Filesort_cnt FLOAT, <br>
Filesort_sum FLOAT, <br>
Disk_filesort_cnt FLOAT, <br>
Disk_filesort_sum FLOAT, <br>
PRIMARY KEY(checksum, ts_min, ts_max) <br>
);</p>

<p style="margin-top: 1em">Note that we store the count
(cnt) for the ts attribute only; it will be redundant to
store this for other attributes.</p>

<p style="margin-top: 1em">--run-time <br>
type: time</p>

<p style="margin-top: 1em">How long to run for each
&quot;--iterations&quot;. The default is to run forever (you
can interrupt with CTRL-C). Because &quot;--iterations&quot;
defaults to 1, if you only specify <br>
&quot;--run-time&quot;, mk-query-digest runs for that amount
of time and then exits. The two options are specified
together to do collect-and-report cycles. For example,
specifying <br>
&quot;--iterations&quot; 4 &quot;--run-time&quot;
&quot;15m&quot; with a continuous input (like STDIN or
&quot;--processlist&quot;) will cause mk-query-digest to run
for 1 hour (15 minutes x 4), reporting four <br>
times, once at each 15 minute interval.</p>

<p style="margin-top: 1em">--run-time-mode <br>
type: string; default: clock</p>

<p style="margin-top: 1em">Set what the value of
&quot;--run-time&quot; operates on. Following are the
possible values for this option:</p>

<p style="margin-top: 1em">clock <br>
&quot;--run-time&quot; specifies an amount of real clock
time during which the tool should run for each
&quot;--iterations&quot;.</p>

<p style="margin-top: 1em">event <br>
&quot;--run-time&quot; specifies an amount of log time. Log
time is determined by timestamps in the log. The first
timestamp seen is remembered, and each timestamp after that
is <br>
compared to the first to determine how much log time has
passed. For example, if the first timestamp seen is
&quot;12:00:00&quot; and the next is &quot;12:01:30&quot;,
that is 1 minute and <br>
30 seconds of log time. The tool will read events until the
log time is greater than or equal to the specified
&quot;--run-time&quot; value.</p>

<p style="margin-top: 1em">Since timestamps in logs are not
always printed, or not always printed frequently, this mode
varies in accuracy.</p>

<p style="margin-top: 1em">interval <br>
&quot;--run-time&quot; specifies interval boundaries of log
time into which events are divided and reports are
generated. This mode is different from the others because it
doesn&rsquo;t <br>
specify how long to run. The value of &quot;--run-time&quot;
must be an interval that divides evenly into minutes, hours
or days. For example, &quot;5m&quot; divides evenly into
hours <br>
(60/5=12, so 12 5 minutes intervals per hour) but
&quot;7m&quot; does not (60/7=8.6).</p>

<p style="margin-top: 1em">Specifying &quot;--run-time-mode
interval --run-time 30m --iterations 0&quot; is similar to
specifying &quot;--run-time-mode clock --run-time 30m
--iterations 0&quot;. In the latter case, <br>
mk-query-digest will run forever, producing reports every 30
minutes, but this only works effectively with continuous
inputs like STDIN and the processlist. For fixed <br>
inputs, like log files, the former example produces multiple
reports by dividing the log into 30 minutes intervals based
on timestamps.</p>

<p style="margin-top: 1em">Intervals are calculated from
the zeroth second/minute/hour in which a timestamp occurs,
not from whatever time it specifies. For example, with 30
minute intervals and a <br>
timestamp of &quot;12:10:30&quot;, the interval is not
&quot;12:10:30&quot; to &quot;12:40:30&quot;, it is
&quot;12:00:00&quot; to &quot;12:29:59&quot;. Or, with 1
hour intervals, it is &quot;12:00:00&quot; to
&quot;12:59:59&quot;. When a <br>
new timestamp exceeds the interval, a report is printed, and
the next interval is recalculated based on the new
timestamp.</p>

<p style="margin-top: 1em">Since &quot;--iterations&quot;
is 1 by default, you probably want to specify a new value
else mk-query-digest will only get and report on the first
interval from the log since 1 <br>
interval = 1 iteration. If you want to get and report every
interval in a log, specify &quot;--iterations&quot; 0.</p>

<p style="margin-top: 1em">--sample <br>
type: int</p>

<p style="margin-top: 1em">Filter out all but the first N
occurrences of each query. The queries are filtered on the
first value in &quot;--group-by&quot;, so by default, this
will filter by query fingerprint. <br>
For example, &quot;--sample 2&quot; will permit two sample
queries for each fingerprint. Useful in conjunction with
&quot;--print&quot; to print out the queries. You probably
want to set <br>
&quot;--no-report&quot; to avoid the overhead of aggregating
and reporting if you&rsquo;re just using this to print out
samples of queries. A complete example:</p>

<p style="margin-top: 1em">mk-query-digest --sample 2
--no-report --print slow.log</p>

<p style="margin-top: 1em">--save-results <br>
type: string</p>

<p style="margin-top: 1em">Save results to the specified
file.</p>

<p style="margin-top: 1em">If &quot;--[no]gzip&quot; is
true (by default it is) then .gz is appended to the file
name.</p>

<p style="margin-top: 1em">--select <br>
type: Array</p>

<p style="margin-top: 1em">Compute aggregate statistics for
these attributes.</p>

<p style="margin-top: 1em">By default mk-query-digest
auto-detects, aggregates and prints metrics for every query
attribute that it finds in the slow query log. This option
specifies a list of only <br>
the attributes that you want. You can specify an alternative
attribute with a colon. For example, &quot;db:Schema&quot;
uses db if it&rsquo;s available, and Schema if it&rsquo;s
not.</p>

<p style="margin-top: 1em">Previously, mk-query-digest only
aggregated these attributes:</p>


<p style="margin-top: 1em">Query_time,Lock_time,Rows_sent,Rows_examined,user,db:Schema,ts</p>

<p style="margin-top: 1em">Attributes specified in the
&quot;--review-history&quot; table will always be selected
even if you do not specify &quot;--select&quot;.</p>

<p style="margin-top: 1em">See also
&quot;--ignore-attributes&quot; and
&quot;ATTRIBUTES&quot;.</p>

<p style="margin-top: 1em">--set-vars <br>
type: string; default: wait_timeout=10000</p>

<p style="margin-top: 1em">Set these MySQL variables.
Immediately after connecting to MySQL, this string will be
appended to SET and executed.</p>

<p style="margin-top: 1em">--shorten <br>
type: int; default: 1024</p>

<p style="margin-top: 1em">Shorten long statements in
reports.</p>

<p style="margin-top: 1em">Shortens long statements,
replacing the omitted portion with a &quot;/*... omitted
...*/&quot; comment. This applies only to the output in
reports, not to information stored for <br>
&quot;--review&quot; or other places. It prevents a large
statement from causing difficulty in a report. The argument
is the preferred length of the shortened statement. Not all
<br>
statements can be shortened, but very large INSERT and
similar statements often can; and so can IN() lists,
although only the first such list in the statement will be
<br>
shortened.</p>

<p style="margin-top: 1em">If it shortens something beyond
recognition, you can find the original statement in the log,
at the offset shown in the report header (see
&quot;OUTPUT&quot;).</p>

<p style="margin-top: 1em">--show-all <br>
type: Hash</p>

<p style="margin-top: 1em">Show all values for these
attributes.</p>

<p style="margin-top: 1em">By default mk-query-digest only
shows as many of an attribute&rsquo;s value that fit on a
single line. This option allows you to specify attributes
for which all values will be <br>
shown (line width is ignored). This only works for
attributes with string values like user, host, db, etc.
Multiple attributes can be specified, comma-separated.</p>

<p style="margin-top: 1em">--since <br>
type: string</p>

<p style="margin-top: 1em">Parse only queries newer than
this value (parse queries since this date).</p>

<p style="margin-top: 1em">This option allows you to ignore
queries older than a certain value and parse only those
queries which are more recent than the value. The value can
be several types:</p>

<p style="margin-top: 1em">* Simple time value N with
optional suffix: N[shmd], where <br>
s=seconds, h=hours, m=minutes, d=days (default s if no
suffix <br>
given); this is like saying &quot;since N[shmd] ago&quot;
<br>
* Full date with optional hours:minutes:seconds: <br>
YYYY-MM-DD [HH:MM::SS] <br>
* Short, MySQL-style date: <br>
YYMMDD [HH:MM:SS] <br>
* Any time expression evaluated by MySQL: <br>
CURRENT_DATE - INTERVAL 7 DAY</p>

<p style="margin-top: 1em">If you give a MySQL time
expression, then you must also specify a DSN so that
mk-query-digest can connect to MySQL to evaluate the
expression. If you specify &quot;--execute&quot;, <br>
&quot;--explain&quot;, &quot;--processlist&quot;,
&quot;--review&quot; or &quot;--review-history&quot;, then
one of these DSNs will be used automatically. Otherwise, you
must specify an &quot;--aux-dsn&quot; or mk-query- <br>
digest will die saying that the value is invalid.</p>

<p style="margin-top: 1em">The MySQL time expression is
wrapped inside a query like &quot;SELECT
UNIX_TIMESTAMP(&lt;expression&gt;)&quot;, so be sure that
the expression is valid inside this query. For example, do
<br>
not use UNIX_TIMESTAMP() because
UNIX_TIMESTAMP(UNIX_TIMESTAMP()) returns 0.</p>

<p style="margin-top: 1em">Events are assumed to be in
chronological--older events at the beginning of the log and
newer events at the end of the log. &quot;--since&quot; is
strict: it ignores all queries until <br>
one is found that is new enough. Therefore, if the query
events are not consistently timestamped, some may be ignored
which are actually new enough.</p>

<p style="margin-top: 1em">See also
&quot;--until&quot;.</p>

<p style="margin-top: 1em">--socket <br>
short form: -S; type: string</p>

<p style="margin-top: 1em">Socket file to use for
connection.</p>

<p style="margin-top: 1em">--statistics <br>
Print statistics about internal counters. This option is
mostly for development and debugging. The statistics report
is printed for each iteration after all other reports, <br>
even if no events are processed or &quot;--no-report&quot;
is specified. The statistics report looks like:</p>

<p style="margin-top: 1em"># No events processed.</p>

<p style="margin-top: 1em"># Statistic Count %/Events <br>
# ================================================ ======
======== <br>
# events_read 142030 100.00 <br>
# events_parsed 50430 35.51 <br>
# events_aggregated 0 0.00 <br>
# ignored_midstream_server_response 18111 12.75 <br>
# no_tcp_data 91600 64.49 <br>
# pipeline_restarted_after_MemcachedProtocolParser 142030
100.00 <br>
# pipeline_restarted_after_TcpdumpParser 1 0.00 <br>
# unknown_client_command 1 0.00 <br>
# unknown_client_data 32318 22.75</p>

<p style="margin-top: 1em">The first column is the internal
counter name; the second column is counter&rsquo;s count;
and the third column is the count as a percentage of
&quot;events_read&quot;.</p>

<p style="margin-top: 1em">In this case, it shows why no
events were processed/aggregated: 100% of events were
rejected by the &quot;MemcachedProtocolParser&quot;. Of
those, 35.51% were data packets, but of <br>
these 12.75% of ignored mid-stream server response, one was
an unknown client command, and 22.75% were unknown client
data. The other 64.49% were TCP control packets <br>
(probably most ACKs).</p>

<p style="margin-top: 1em">Since mk-query-digest is
complex, you will probably need someone familiar with its
code to decipher the statistics report.</p>

<p style="margin-top: 1em">--table-access <br>
Print a table access report.</p>

<p style="margin-top: 1em">The table access report shows
which tables are accessed by all the queries and if the
access is a read or write. The report looks like:</p>

<p style="margin-top: 1em">write
&lsquo;baz&lsquo;.&lsquo;tbl&lsquo; <br>
read &lsquo;baz&lsquo;.&lsquo;new_tbl&lsquo; <br>
write &lsquo;baz&lsquo;.&lsquo;tbl3&lsquo; <br>
write &lsquo;db6&lsquo;.&lsquo;tbl6&lsquo;</p>

<p style="margin-top: 1em">If you pipe the output to sort,
the read and write tables will be grouped together and
sorted alphabetically:</p>

<p style="margin-top: 1em">read
&lsquo;baz&lsquo;.&lsquo;new_tbl&lsquo; <br>
write &lsquo;baz&lsquo;.&lsquo;tbl&lsquo; <br>
write &lsquo;baz&lsquo;.&lsquo;tbl3&lsquo; <br>
write &lsquo;db6&lsquo;.&lsquo;tbl6&lsquo;</p>

<p style="margin-top: 1em">--tcpdump-errors <br>
type: string</p>

<p style="margin-top: 1em">Write the tcpdump data to this
file on error. If mk-query-digest doesn&rsquo;t parse the
stream correctly for some reason, the session&rsquo;s
packets since the last query event will be <br>
written out to create a usable test case. If this happens,
mk-query-digest will not raise an error; it will just
discard the session&rsquo;s saved state and permit the tool
to <br>
continue working. See &quot;tcpdump&quot; for more
information about parsing tcpdump output.</p>

<p style="margin-top: 1em">--timeline <br>
Show a timeline of events.</p>

<p style="margin-top: 1em">This option makes
mk-query-digest print another kind of report: a timeline of
the events. Each query is still grouped and aggregate into
classes according to &quot;--group-by&quot;, <br>
but then they are printed in chronological order. The
timeline report prints out the timestamp, interval, count
and value of each classes.</p>

<p style="margin-top: 1em">If all you want is the timeline
report, then specify &quot;--no-report&quot; to suppress the
default query analysis report. Otherwise, the timeline
report will be printed at the end <br>
before the response-time profile (see
&quot;--report-format&quot; and &quot;OUTPUT&quot;).</p>

<p style="margin-top: 1em">For example, this:</p>

<p style="margin-top: 1em">mk-query-digest /path/to/log
--group-by distill --timeline</p>

<p style="margin-top: 1em">will print something like:</p>

<p style="margin-top: 1em">#
########################################################
<br>
# distill report <br>
# ########################################################
<br>
# 2009-07-25 11:19:27 1+00:00:01 2 SELECT foo <br>
# 2009-07-27 11:19:30 00:01 2 SELECT bar <br>
# 2009-07-27 11:30:00 1+06:30:00 2 SELECT foo</p>

<p style="margin-top: 1em">--type <br>
type: Array</p>

<p style="margin-top: 1em">The type of input to parse
(default slowlog). The permitted types are</p>

<p style="margin-top: 1em">binlog <br>
Parse a binary log file.</p>

<p style="margin-top: 1em">genlog <br>
Parse a MySQL general log file. General logs lack a lot of
&quot;ATTRIBUTES&quot;, notably &quot;Query_time&quot;. The
default &quot;--order-by&quot; for general logs changes to
&quot;Query_time:cnt&quot;.</p>

<p style="margin-top: 1em">http <br>
Parse HTTP traffic from tcpdump.</p>

<p style="margin-top: 1em">pglog <br>
Parse a log file in PostgreSQL format. The parser will
automatically recognize logs sent to syslog and
transparently parse the syslog format, too. The recommended
<br>
configuration for logging in your postgresql.conf is as
follows.</p>

<p style="margin-top: 1em">The log_destination setting can
be set to either syslog or stderr. Syslog has the added
benefit of not interleaving log messages from several
sessions concurrently, <br>
which the parser cannot handle, so this might be better than
stderr. CSV-formatted logs are not supported at this
time.</p>

<p style="margin-top: 1em">The log_min_duration_statement
setting should be set to 0 to capture all statements with
their durations. Alternatively, the parser will also
recognize and handle <br>
various combinations of log_duration and log_statement.</p>

<p style="margin-top: 1em">You may enable log_connections
and log_disconnections, but this is optional.</p>

<p style="margin-top: 1em">It is highly recommended to set
your log_line_prefix to the following:</p>

<p style="margin-top: 1em">log_line_prefix = &rsquo;%m
c=%c,u=%u,D=%d &rsquo;</p>

<p style="margin-top: 1em">This lets the parser find
timestamps with milliseconds, session IDs, users, and
databases from the log. If these items are missing,
you&rsquo;ll simply get less information to <br>
analyze. For compatibility with other log analysis tools
such as PQA and pgfouine, various log line prefix formats
are supported. The general format is as follows: a <br>
timestamp can be detected and extracted (the syslog
timestamp is NOT parsed), and a name=value list of
properties can also. Although the suggested format is as
shown <br>
above, any name=value list will be captured and interpreted
by using the first letter of the &rsquo;name&rsquo; part,
lowercased, to determine the meaning of the item. The <br>
lowercased first letter is interpreted to mean the same
thing as PostgreSQL&rsquo;s built-in %-codes for the
log_line_prefix format string. For example, u means user, so
<br>
unicorn=fred will be interpreted as user=fred; d means
database, so D=john will be interpreted as database=john.
The pgfouine-suggested formatting is user=%u and db=%d, <br>
so it should Just Work regardless of which format you
choose. The main thing is to add as much information as
possible into the log_line_prefix to permit richer <br>
analysis.</p>

<p style="margin-top: 1em">Currently, only English locale
messages are supported, so if your server&rsquo;s locale is
set to something else, the log won&rsquo;t be parsed
properly. (Log messages with <br>
&quot;duration:&quot; and &quot;statement:&quot; won&rsquo;t
be recognized.)</p>

<p style="margin-top: 1em">slowlog <br>
Parse a log file in any variation of MySQL slow-log
format.</p>

<p style="margin-top: 1em">tcpdump <br>
Inspect network packets and decode the MySQL client
protocol, extracting queries and responses from it.</p>

<p style="margin-top: 1em">mk-query-digest does not
actually watch the network (i.e. it does NOT &quot;sniff
packets&quot;). Instead, it&rsquo;s just parsing the output
of tcpdump. You are responsible for <br>
generating this output; mk-query-digest does not do it for
you. Then you send this to mk-query-digest as you would any
log file: as files on the command line or to <br>
STDIN.</p>

<p style="margin-top: 1em">The parser expects the input to
be formatted with the following options: &quot;-x -n -q
-tttt&quot;. For example, if you want to capture output from
your local machine, you can do <br>
something like the following (the port must come last on
FreeBSD):</p>

<p style="margin-top: 1em">tcpdump -s 65535 -x -nn -q -tttt
-i any -c 1000 port 3306 &gt; mysql.tcp.txt <br>
mk-query-digest --type tcpdump mysql.tcp.txt</p>

<p style="margin-top: 1em">The other tcpdump parameters,
such as -s, -c, and -i, are up to you. Just make sure the
output looks like this (there is a line break in the first
line to avoid man-page <br>
problems):</p>

<p style="margin-top: 1em">2009-04-12 09:50:16.804849 IP
127.0.0.1.42167 <br>
&gt; 127.0.0.1.3306: tcp 37 <br>
0x0000: 4508 0059 6eb2 4000 4006 cde2 7f00 0001 <br>
0x0010: ....</p>

<p style="margin-top: 1em">Remember tcpdump has a handy -c
option to stop after it captures some number of packets!
That&rsquo;s very useful for testing your tcpdump command.
Note that tcpdump can&rsquo;t <br>
capture traffic on a Unix socket. Read
&lt;http://bugs.mysql.com/bug.php?id=31577&gt; if
you&rsquo;re confused about this.</p>

<p style="margin-top: 1em">Devananda Van Der Veen explained
on the MySQL Performance Blog how to capture traffic without
dropping packets on busy servers. Dropped packets cause
mk-query-digest to <br>
miss the response to a request, then see the response to a
later request and assign the wrong execution time to the
query. You can change the filter to something like <br>
the following to help capture a subset of the queries. (See
&lt;http://www.mysqlperformanceblog.com/?p=6092&gt; for
details.)</p>

<p style="margin-top: 1em">tcpdump -i any -s 65535 -x -n -q
-tttt &rsquo;port 3306 and tcp[1] &amp; 7 == 2 and tcp[3]
&amp; 7 == 2&rsquo;</p>

<p style="margin-top: 1em">All MySQL servers running on
port 3306 are automatically detected in the tcpdump output.
Therefore, if the tcpdump out contains packets from multiple
servers on port <br>
3306 (for example, 10.0.0.1:3306, 10.0.0.2:3306, etc.), all
packets/queries from all these servers will be analyzed
together as if they were one server.</p>

<p style="margin-top: 1em">If you&rsquo;re analyzing
traffic for a MySQL server that is not running on port 3306,
see &quot;--watch-server&quot;.</p>

<p style="margin-top: 1em">Also note that mk-query-digest
may fail to report the database for queries when parsing
tcpdump output. The database is discovered only in the
initial connect events for <br>
a new client or when &lt;USE db&gt; is executed. If the
tcpdump output contains neither of these, then
mk-query-digest cannot discover the database.</p>

<p style="margin-top: 1em">Server-side prepared statements
are supported. SSL-encrypted traffic cannot be inspected and
decoded.</p>

<p style="margin-top: 1em">memcached <br>
Similar to tcpdump, but the expected input is memcached
packets instead of MySQL packets. For example:</p>

<p style="margin-top: 1em">tcpdump -i any port 11211 -s
65535 -x -nn -q -tttt &gt; memcached.tcp.txt <br>
mk-query-digest --type memcached memcached.tcp.txt</p>

<p style="margin-top: 1em">memcached uses port 11211 by
default.</p>

<p style="margin-top: 1em">--until <br>
type: string</p>

<p style="margin-top: 1em">Parse only queries older than
this value (parse queries until this date).</p>

<p style="margin-top: 1em">This option allows you to ignore
queries newer than a certain value and parse only those
queries which are older than the value. The value can be one
of the same types <br>
listed for &quot;--since&quot;.</p>

<p style="margin-top: 1em">Unlike &quot;--since&quot;,
&quot;--until&quot; is not strict: all queries are parsed
until one has a timestamp that is equal to or greater than
&quot;--until&quot;. Then all subsequent queries are <br>
ignored.</p>

<p style="margin-top: 1em">--user <br>
short form: -u; type: string</p>

<p style="margin-top: 1em">User for login if not current
user.</p>

<p style="margin-top: 1em">--variations <br>
type: Array</p>

<p style="margin-top: 1em">Report the number of variations
in these attributes&rsquo; values.</p>

<p style="margin-top: 1em">Variations show how many
distinct values an attribute had within a class. The usual
value for this option is &quot;arg&quot; which shows how
many distinct queries were in the class. <br>
This can be useful to determine a query&rsquo;s
cacheability.</p>

<p style="margin-top: 1em">Distinct values are determined
by CRC32 checksums of the attributes&rsquo; values. These
checksums are reported in the query report for attributes
specified by this option, like:</p>

<p style="margin-top: 1em"># arg crc 109 (1/25%), 144
(1/25%)... 2 more</p>

<p style="margin-top: 1em">In that class there were 4
distinct queries. The checksums of the first two variations
are shown, and each one occurred once (or, 25% of the
time).</p>

<p style="margin-top: 1em">The counts of distinct
variations is approximate because only 1,000 variations are
saved. The mod (%) 1000 of the full CRC32 checksum is saved,
so some distinct checksums <br>
are treated as equal.</p>

<p style="margin-top: 1em">--version <br>
Show version and exit.</p>

<p style="margin-top: 1em">--watch-server <br>
type: string</p>

<p style="margin-top: 1em">This option tells
mk-query-digest which server IP address and port (like
&quot;10.0.0.1:3306&quot;) to watch when parsing tcpdump
(for &quot;--type&quot; tcpdump and memcached); all other
<br>
servers are ignored. If you don&rsquo;t specify it,
mk-query-digest watches all servers by looking for any IP
address using port 3306 or &quot;mysql&quot;. If
you&rsquo;re watching a server with <br>
a non-standard port, this won&rsquo;t work, so you must
specify the IP address and port to watch.</p>

<p style="margin-top: 1em">If you want to watch a mix of
servers, some running on standard port 3306 and some running
on non-standard ports, you need to create separate tcpdump
outputs for the non- <br>
standard port servers and then specify this option for each.
At present mk-query-digest cannot auto-detect servers on
port 3306 and also be told to watch a server on a non- <br>
standard port.</p>

<p style="margin-top: 1em">--[no]zero-admin <br>
default: yes</p>

<p style="margin-top: 1em">Zero out the Rows_XXX properties
for administrator command events.</p>

<p style="margin-top: 1em">--[no]zero-bool <br>
default: yes</p>

<p style="margin-top: 1em">Print 0% boolean values in
report.</p>

<p style="margin-top: 1em">DSN OPTIONS <br>
These DSN options are used to create a DSN. Each option is
given like &quot;option=value&quot;. The options are
case-sensitive, so P and p are not the same option. There
cannot be <br>
whitespace before or after the &quot;=&quot; and if the
value contains whitespace it must be quoted. DSN options are
comma-separated. See the maatkit manpage for full
details.</p>

<p style="margin-top: 1em">&Acirc;&middot; A</p>

<p style="margin-top: 1em">dsn: charset; copy: yes</p>

<p style="margin-top: 1em">Default character set.</p>

<p style="margin-top: 1em">&Acirc;&middot; D</p>

<p style="margin-top: 1em">dsn: database; copy: yes</p>

<p style="margin-top: 1em">Database that contains the query
review table.</p>

<p style="margin-top: 1em">&Acirc;&middot; F</p>

<p style="margin-top: 1em">dsn: mysql_read_default_file;
copy: yes</p>

<p style="margin-top: 1em">Only read default options from
the given file</p>

<p style="margin-top: 1em">&Acirc;&middot; h</p>

<p style="margin-top: 1em">dsn: host; copy: yes</p>

<p style="margin-top: 1em">Connect to host.</p>

<p style="margin-top: 1em">&Acirc;&middot; p</p>

<p style="margin-top: 1em">dsn: password; copy: yes</p>

<p style="margin-top: 1em">Password to use when
connecting.</p>

<p style="margin-top: 1em">&Acirc;&middot; P</p>

<p style="margin-top: 1em">dsn: port; copy: yes</p>

<p style="margin-top: 1em">Port number to use for
connection.</p>

<p style="margin-top: 1em">&Acirc;&middot; S</p>

<p style="margin-top: 1em">dsn: mysql_socket; copy: yes</p>

<p style="margin-top: 1em">Socket file to use for
connection.</p>

<p style="margin-top: 1em">&Acirc;&middot; t</p>

<p style="margin-top: 1em">Table to use as the query review
table.</p>

<p style="margin-top: 1em">&Acirc;&middot; u</p>

<p style="margin-top: 1em">dsn: user; copy: yes</p>

<p style="margin-top: 1em">User for login if not current
user.</p>

<p style="margin-top: 1em">DOWNLOADING <br>
You can download Maatkit from Google Code at
&lt;http://code.google.com/p/maatkit/&gt;, or you can get
any of the tools easily with a command like the
following:</p>

<p style="margin-top: 1em">wget
http://www.maatkit.org/get/toolname <br>
or <br>
wget http://www.maatkit.org/trunk/toolname</p>

<p style="margin-top: 1em">Where &quot;toolname&quot; can
be replaced with the name (or fragment of a name) of any of
the Maatkit tools. Once downloaded, they&rsquo;re ready to
run; no installation is needed. The first <br>
URL gets the latest released version of the tool, and the
second gets the latest trunk code from Subversion.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
The environment variable &quot;MKDEBUG&quot; enables verbose
debugging output in all of the Maatkit tools:</p>

<p style="margin-top: 1em">MKDEBUG=1 mk-....</p>

<p style="margin-top: 1em">SYSTEM REQUIREMENTS <br>
You need Perl and some core packages that ought to be
installed in any reasonably new version of Perl.</p>

<p style="margin-top: 1em">BUGS <br>
For a list of known bugs see
&lt;http://www.maatkit.org/bugs/mk-query-digest&gt;.</p>

<p style="margin-top: 1em">Please use Google Code Issues
and Groups to report bugs or request support:
&lt;http://code.google.com/p/maatkit/&gt;. You can also join
#maatkit on Freenode to discuss Maatkit.</p>

<p style="margin-top: 1em">Please include the complete
command-line used to reproduce the problem you are seeing,
the version of all MySQL servers involved, the complete
output of the tool when run with <br>
&quot;--version&quot;, and if possible, debugging output
produced by running with the &quot;MKDEBUG=1&quot;
environment variable.</p>

<p style="margin-top: 1em">COPYRIGHT, LICENSE AND WARRANTY
<br>
This program is copyright 2007-2011 Baron Schwartz. Feedback
and improvements are welcome.</p>

<p style="margin-top: 1em">THIS PROGRAM IS PROVIDED
&quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A <br>
PARTICULAR PURPOSE.</p>

<p style="margin-top: 1em">This program is free software;
you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free
Software Foundation, version 2; <br>
OR the Perl Artistic License. On UNIX and similar systems,
you can issue &lsquo;man perlgpl&rsquo; or &lsquo;man
perlartistic&rsquo; to read these licenses.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program;
if not, write to the Free Software Foundation, Inc., 59
Temple Place, Suite 330, <br>
Boston, MA 02111-1307 USA.</p>

<p style="margin-top: 1em">AUTHOR <br>
Baron Schwartz, Daniel Nichter</p>

<p style="margin-top: 1em">ABOUT MAATKIT <br>
This tool is part of Maatkit, a toolkit for power users of
MySQL. Maatkit was created by Baron Schwartz; Baron and
Daniel Nichter are the primary code contributors. Both are
<br>
employed by Percona. Financial support for Maatkit
development is primarily provided by Percona and its
clients.</p>

<p style="margin-top: 1em">VERSION <br>
This manual page documents Ver 0.9.29 Distrib 7540
$Revision: 7531 $.</p>

<p style="margin-top: 1em">perl v5.24.1 2011-06-08
MK-QUERY-DIGEST(1)</p>
<hr>
</body>
</html>
