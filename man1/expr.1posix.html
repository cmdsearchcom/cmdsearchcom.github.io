<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:08:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>EXPR(1POSIX) POSIX Programmer&rsquo;s Manual
EXPR(1POSIX)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
expr &acirc; evaluate arguments as an expression</p>

<p style="margin-top: 1em">SYNOPSIS <br>
expr operand...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The expr utility shall evaluate an expression and write the
result to standard output.</p>

<p style="margin-top: 1em">OPTIONS <br>
None.</p>

<p style="margin-top: 1em">OPERANDS <br>
The single expression evaluated by expr shall be formed from
the operand operands, as described in the EXTENDED
DESCRIPTION section. The application shall ensure that each
of the <br>
expression operator symbols:</p>

<p style="margin-top: 1em">( ) | &amp; = &gt; &gt;= &lt;
&lt;= != + &acirc; * / % :</p>

<p style="margin-top: 1em">and the symbols integer and
string in the table are provided as separate arguments to
expr.</p>

<p style="margin-top: 1em">STDIN <br>
Not used.</p>

<p style="margin-top: 1em">INPUT FILES <br>
None.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of expr:</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of POSIX.1&acirc;2008,
Section 8.2, Internationaliza&acirc; <br>
tion Variables for the precedence of internationalization
variables used to determine the values of locale
categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_COLLATE <br>
Determine the locale for the behavior of ranges, equivalence
classes, and multi-character collating elements within
regular expressions and by the string comparison <br>
operators.</p>

<p style="margin-top: 1em">LC_CTYPE Determine the locale
for the interpretation of sequences of bytes of text data as
characters (for example, single-byte as opposed to
multi-byte characters in arguments) <br>
and the behavior of character classes within regular
expressions.</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">NLSPATH Determine the location
of message catalogs for the processing of LC_MESSAGES.</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
Default.</p>

<p style="margin-top: 1em">STDOUT <br>
The expr utility shall evaluate the expression and write the
result, followed by a &lt;newline&gt;, to standard
output.</p>

<p style="margin-top: 1em">STDERR <br>
The standard error shall be used only for diagnostic
messages.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
None.</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
The formation of the expression to be evaluated is shown in
the following table. The symbols expr, expr1, and expr2
represent expressions formed from integer and string symbols
<br>
and the expression operator symbols (all separate arguments)
by recursive application of the constructs described in the
table. The expressions are listed in order of increasing
<br>
precedence, with equal-precedence operators grouped between
horizontal lines. All of the operators shall be
left-associative.</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; Expression &acirc; Description &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr1 | expr2 &acirc; Returns the evaluation of expr1
if it is &acirc; <br>
&acirc; &acirc; neither null nor zero; otherwise, &acirc;
<br>
&acirc; &acirc; returns the evaluation of expr2 if it is
&acirc; <br>
&acirc; &acirc; not null; otherwise, zero. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr1 &amp; expr2 &acirc; Returns the evaluation of
expr1 if nei&acirc; &acirc; <br>
&acirc; &acirc; ther expression evaluates to null or &acirc;
<br>
&acirc; &acirc; zero; otherwise, returns zero. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc; &acirc; Returns the result of a decimal integer
&acirc; <br>
&acirc; &acirc; comparison if both arguments are inte&acirc;
&acirc; <br>
&acirc; &acirc; gers; otherwise, returns the result of a
&acirc; <br>
&acirc; &acirc; string comparison using the
locale-spe&acirc; &acirc; <br>
&acirc; &acirc; cific collation sequence. The result of
&acirc; <br>
&acirc; &acirc; each comparison is 1 if the specified
&acirc; <br>
&acirc; &acirc; relationship is true, or 0 if the
rela&acirc; &acirc; <br>
&acirc; &acirc; tionship is false. &acirc; <br>
&acirc;expr1 = expr2 &acirc; Equal. &acirc; <br>
&acirc;expr1 &gt; expr2 &acirc; Greater than. &acirc; <br>
&acirc;expr1 &gt;= expr2 &acirc; Greater than or equal.
&acirc; <br>
&acirc;expr1 &lt; expr2 &acirc; Less than. &acirc; <br>
&acirc;expr1 &lt;= expr2 &acirc; Less than or equal. &acirc;
<br>
&acirc;expr1 != expr2 &acirc; Not equal. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr1 + expr2 &acirc; Addition of decimal
integer-valued argu&acirc; &acirc; <br>
&acirc; &acirc; ments. &acirc; <br>
&acirc;expr1 &acirc; expr2 &acirc; Subtraction of decimal
integer-valued &acirc; <br>
&acirc; &acirc; arguments. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr1 * expr2 &acirc; Multiplication of decimal
integer-valued &acirc; <br>
&acirc; &acirc; arguments. &acirc; <br>
&acirc;expr1 / expr2 &acirc; Integer division of decimal
integer-val&acirc; &acirc; <br>
&acirc; &acirc; ued arguments, producing an integer &acirc;
<br>
&acirc; &acirc; result. &acirc; <br>
&acirc;expr1 % expr2 &acirc; Remainder of integer division
of decimal &acirc; <br>
&acirc; &acirc; integer-valued arguments. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr1 : expr2 &acirc; Matching expression; see below.
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;( expr ) &acirc; Grouping symbols. Any expression can
be &acirc; <br>
&acirc; &acirc; placed within parentheses. Parentheses
&acirc; <br>
&acirc; &acirc; can be nested to a depth of &acirc; <br>
&acirc; &acirc; {EXPR_NEST_MAX}. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;integer &acirc; An argument consisting only of an
&acirc; <br>
&acirc; &acirc; (optional) unary minus followed by
dig&acirc; &acirc; <br>
&acirc; &acirc; its. &acirc; <br>
&acirc;string &acirc; A string argument; see below. &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
Matching Expression <br>
The &rsquo;:&rsquo; matching operator shall compare the
string resulting from the evaluation of expr1 with the
regular expression pattern resulting from the evaluation of
expr2. Regular <br>
expression syntax shall be that defined in the Base
Definitions volume of POSIX.1&acirc;2008, Section 9.3, Basic
Regular Expressions, except that all patterns are anchored
to the <br>
beginning of the string (that is, only sequences starting at
the first character of a string are matched by the regular
expression) and, therefore, it is unspecified whether
&rsquo;^&rsquo; <br>
is a special character in that context. Usually, the
matching operator shall return a string representing the
number of characters matched (&rsquo;0&rsquo; on failure).
Alternatively, if the <br>
pattern contains at least one regular expression
subexpression &quot;[.]&quot;, the string matched by the
back-reference expression &quot;1&quot; shall be returned.
If the back-reference <br>
expression &quot;1&quot; does not match, then the null
string shall be returned.</p>

<p style="margin-top: 1em">String Operand <br>
A string argument is an argument that cannot be identified
as an integer argument or as one of the expression operator
symbols shown in the OPERANDS section.</p>

<p style="margin-top: 1em">The use of string arguments
length, substr, index, or match produces unspecified
results.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The following exit values shall be returned:</p>

<p style="margin-top: 1em">0 The expression evaluates to
neither null nor zero.</p>

<p style="margin-top: 1em">1 The expression evaluates to
null or zero.</p>

<p style="margin-top: 1em">2 Invalid expression.</p>

<p style="margin-top: 1em">&gt;2 An error occurred.</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
Default.</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
After argument processing by the shell, expr is not required
to be able to tell the difference between an operator and an
operand except by the value. If &quot;$a&quot; is
&rsquo;=&rsquo;, the com&acirc; <br>
mand:</p>

<p style="margin-top: 1em">expr $a = &rsquo;=&rsquo;</p>

<p style="margin-top: 1em">looks like:</p>

<p style="margin-top: 1em">expr = = =</p>

<p style="margin-top: 1em">as the arguments are passed to
expr (and they all may be taken as the &rsquo;=&rsquo;
operator). The following works reliably:</p>

<p style="margin-top: 1em">expr X$a = X=</p>

<p style="margin-top: 1em">Also note that this volume of
POSIX.1&acirc;2008 permits implementations to extend
utilities. The expr utility permits the integer arguments to
be preceded with a unary minus. This <br>
means that an integer argument could look like an option.
Therefore, the conforming application must employ the
&quot;&acirc;&acirc;&quot; construct of Guideline 10 of the
Base Definitions volume of <br>
POSIX.1&acirc;2008, Section 12.2, Utility Syntax Guidelines
to protect its operands if there is any chance the first
operand might be a negative integer (or any string with a
leading <br>
minus).</p>

<p style="margin-top: 1em">EXAMPLES <br>
The expr utility has a rather difficult syntax:</p>

<p style="margin-top: 1em">* Many of the operators are also
shell control operators or reserved words, so they have to
be escaped on the command line.</p>

<p style="margin-top: 1em">* Each part of the expression is
composed of separate arguments, so liberal usage of
&lt;blank&gt; characters is required. For example:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; Invalid &acirc; Valid &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr 1+2 &acirc; expr 1 + 2 &acirc; <br>
&acirc;expr &quot;1 + 2&quot; &acirc; expr 1 + 2 &acirc;
<br>
&acirc;expr 1 + (2 * 3) &acirc; expr 1 + 2 3 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
In many cases, the arithmetic and string features provided
as part of the shell command language are easier to use than
their equivalents in expr. Newly written scripts should <br>
avoid expr in favor of the new features within the shell;
see Section 2.5, Parameters and Variables and Section 2.6.4,
Arithmetic Expansion.</p>

<p style="margin-top: 1em">The following command:</p>

<p style="margin-top: 1em">a=$(expr $a + 1)</p>

<p style="margin-top: 1em">adds 1 to the variable a.</p>

<p style="margin-top: 1em">The following command, for
&quot;$a&quot; equal to either /usr/abc/file or just
file:</p>

<p style="margin-top: 1em">expr $a : &rsquo;.*/&rsquo;
$a</p>

<p style="margin-top: 1em">returns the last segment of a
pathname (that is, file). Applications should avoid the
character &rsquo;/&rsquo; used alone as an argument; expr
may interpret it as the division operator.</p>

<p style="margin-top: 1em">The following command:</p>

<p style="margin-top: 1em">expr &quot;//$a&quot; :
&rsquo;.*/&rsquo;</p>

<p style="margin-top: 1em">is a better representation of
the previous example. The addition of the &quot;//&quot;
characters eliminates any ambiguity about the division
operator and simplifies the whole expression. <br>
Also note that pathnames may contain characters contained in
the IFS variable and should be quoted to avoid having
&quot;$a&quot; expand into multiple arguments.</p>

<p style="margin-top: 1em">The following command:</p>

<p style="margin-top: 1em">expr &quot;$VAR&quot; :
&rsquo;.*&rsquo;</p>

<p style="margin-top: 1em">returns the number of characters
in VAR.</p>

<p style="margin-top: 1em">RATIONALE <br>
In an early proposal, EREs were used in the matching
expression syntax. This was changed to BREs to avoid
breaking historical applications.</p>

<p style="margin-top: 1em">The use of a leading
&lt;circumflex&gt; in the BRE is unspecified because many
historical implementations have treated it as a special
character, despite their system documentation. <br>
For example:</p>

<p style="margin-top: 1em">expr foo : ^foo expr ^foo :
^foo</p>

<p style="margin-top: 1em">return 3 and 0, respectively, on
those systems; their documentation would imply the reverse.
Thus, the anchoring condition is left unspecified to avoid
breaking historical <br>
scripts relying on this undocumented feature.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
None.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Section 2.5, Parameters and Variables, Section 2.6.4,
Arithmetic Expansion</p>

<p style="margin-top: 1em">The Base Definitions volume of
POSIX.1&acirc;2008, Chapter 8, Environment Variables,
Section 9.3, Basic Regular Expressions, Section 12.2,
Utility Syntax Guidelines</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2013 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 7,
Copyright (C) 2013 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. (This is <br>
POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.)
In the event of any discrepancy between this version and the
original IEEE and The Open Group Standard, the original <br>
IEEE and The Open Group Standard is the referee document.
The original Standard can be obtained online at
http://www.unix.org/online.html .</p>

<p style="margin-top: 1em">Any typographical or formatting
errors that appear in this page are most likely to have been
introduced during the conversion of the source files to man
page format. To report <br>
such errors, see
https://www.kernel.org/doc/man-pages/reporting_bugs.html
.</p>

<p style="margin-top: 1em">IEEE/The Open Group 2013
EXPR(1POSIX)</p>
<hr>
</body>
</html>
