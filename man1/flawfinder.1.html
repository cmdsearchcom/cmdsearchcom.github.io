<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:10:16 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FLAWFINDER(1) Flawfinder FLAWFINDER(1)</p>

<p style="margin-top: 1em">NAME <br>
flawfinder - lexically find potential security flaws
(&quot;hits&quot;) in source code</p>

<p style="margin-top: 1em">SYNOPSIS <br>
flawfinder [--help|-h] [--version] [--listrules] <br>
[--allowlink] [--followdotdir] [--nolink] <br>
[--patch=filename|-P filename] <br>
[--inputs|-I] [ --minlevel=X | -m X ] [--falsepositive|-F]
<br>
[--neverignore|-n] <br>
[--regex=PATTERN | -e PATTERN] <br>
[--context|-c] [--columns|-C] [--dataonly|-D] [--html|-H]
[--immediate|-i] [--singleline|-S] [--omittime] [--quiet|-Q]
<br>
[--loadhitlist=F] [--savehitlist=F] [--diffhitlist=F] <br>
[--] [ source code file or source root directory ]+</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Flawfinder searches through C/C++ source code looking for
potential security flaws. To run flawfinder, simply give
flawfinder a list of directories or files. For each
directory <br>
given, all files that have C/C++ filename extensions in that
directory (and its subdirectories, recursively) will be
examined. Thus, for most projects, simply give flawfinder
<br>
the name of the source code&rsquo;s topmost directory (use
&lsquo;&lsquo;.&rsquo;&rsquo; for the current directory),
and flawfinder will examine all of the project&rsquo;s C/C++
source code. If you only want to <br>
have changes reviewed, save a unified diff of those changes
(created by GNU &quot;diff -u&quot; or &quot;svn diff&quot;
or &quot;git diff&quot;) in a patch file and use the --patch
(-P) option.</p>

<p style="margin-top: 1em">Flawfinder will produce a list
of &lsquo;&lsquo;hits&rsquo;&rsquo; (potential security
flaws), sorted by risk; the riskiest hits are shown first.
The risk level is shown inside square brackets and <br>
varies from 0, very little risk, to 5, great risk. This risk
level depends not only on the function, but on the values of
the parameters of the function. For example, constant <br>
strings are often less risky than fully variable strings in
many contexts, and in those contexts the hit will have a
lower risk level. Flawfinder knows about gettext (a common
<br>
library for internationalized programs) and will treat
constant strings passed through gettext as though they were
constant strings; this reduces the number of false hits in
<br>
internationalized programs. Flawfinder will do the same sort
of thing with _T() and _TEXT(), common Microsoft macros for
handling internationalized programs. Flawfinder cor&acirc;
<br>
rectly ignores most text inside comments and strings.
Normally flawfinder shows all hits with a risk level of at
least 1, but you can use the --minlevel option to show only
hits <br>
with higher risk levels if you wish. Hit descriptions also
note the relevant Common Weakness Enumeration (CWE)
identifier(s) in parentheses, as discussed below. Flawfinder
is <br>
officially CWE-Compatible.</p>

<p style="margin-top: 1em">Not every hit is actually a
security vulnerability, and not every security vulnerability
is necessarily found. Nevertheless, flawfinder can be an aid
in finding and removing <br>
security vulnerabilities. A common way to use flawfinder is
to first apply flawfinder to a set of source code and
examine the highest-risk items. Then, use --inputs to
examine <br>
the input locations, and check to make sure that only legal
and safe input values are accepted from untrusted users.</p>

<p style="margin-top: 1em">Once you&rsquo;ve audited a
program, you can mark source code lines that are actually
fine but cause spurious warnings so that flawfinder will
stop complaining about them. To mark a <br>
line so that these warnings are suppressed, put a
specially-formatted comment either on the same line (after
the source code) or all by itself in the previous line. The
comment <br>
must have one of the two following formats:</p>

<p style="margin-top: 1em">&Acirc;&middot; // Flawfinder:
ignore</p>

<p style="margin-top: 1em">&Acirc;&middot; /* Flawfinder:
ignore */</p>

<p style="margin-top: 1em">For compatibility&rsquo;s sake,
you can replace &quot;Flawfinder:&quot; with
&quot;ITS4:&quot; or &quot;RATS:&quot; in these
specially-formatted comments. Since it&rsquo;s possible that
such lines are wrong, you can use <br>
the --neverignore option, which causes flawfinder to never
ignore any line no matter what the comment directives say
(more confusingly, --neverignore ignores the ignores).</p>

<p style="margin-top: 1em">Flawfinder uses an internal
database called the &lsquo;&lsquo;ruleset&rsquo;&rsquo;; the
ruleset identifies functions that are common causes of
security flaws. The standard ruleset includes a large <br>
number of different potential problems, including both
general issues that can impact any C/C++ program, as well as
a number of specific Unix-like and Windows functions that
are <br>
especially problematic. The --listrules option reports the
list of current rules and their default risk levels. As
noted above, every potential security flaw found in a given
<br>
source code file (matching an entry in the ruleset) is
called a &lsquo;&lsquo;hit,&rsquo;&rsquo; and the set of
hits found during any particular run of the program is
called the &lsquo;&lsquo;hitlist.&rsquo;&rsquo; Hitlists
<br>
can be saved (using --savehitlist), reloaded back for
redisplay (using --loadhitlist), and you can show only the
hits that are different from another run (using
--diffhitlist).</p>

<p style="margin-top: 1em">Flawfinder is a simple tool,
leading to some fundamental pros and cons. Flawfinder works
by doing simple lexical tokenization (skipping comments and
correctly tokenizing <br>
strings), looking for token matches to the database
(particularly to find function calls). Flawfinder is thus
similar to RATS and ITS4, which also use simple lexical
tokeniza&acirc; <br>
tion. Flawfinder then examines the text of the function
parameters to estimate risk. Unlike tools such as splint,
gcc&rsquo;s warning flags, and clang, flawfinder does not
use or <br>
have access to information about control flow, data flow, or
data types when searching for potential vulnerabilities or
estimating the level of risk. Thus, flawfinder will
nec&acirc; <br>
essarily produce many false positives for vulnerabilities
and fail to report many vulnerabilities. On the other hand,
flawfinder can find vulnerabilities in programs that cannot
<br>
be built or cannot be linked. It can often work with
programs that cannot even be compiled (at least by the
reviewer&rsquo;s tools). Flawfinder also doesn&rsquo;t get
as confused by macro <br>
definitions and other oddities that more sophisticated tools
have trouble with. Flawfinder can also be useful as a simple
introduction to static analysis tools in general, since <br>
it is easy to start using and easy to understand.</p>

<p style="margin-top: 1em">Any filename given on the
command line will be examined (even if it doesn&rsquo;t have
a usual C/C++ filename extension); thus you can force
flawfinder to examine any specific files <br>
you desire. While searching directories recursively,
flawfinder only opens and examines regular files that have
C/C++ filename extensions. Flawfinder presumes that files
are <br>
C/C++ files if they have the extensions &quot;.c&quot;,
&quot;.h&quot;, &quot;.ec&quot;, &quot;.ecp&quot;,
&quot;.pgc&quot;, &quot;.C&quot;, &quot;.cpp&quot;,
&quot;.CPP&quot;, &quot;.cxx&quot;, &quot;.cc&quot;,
&quot;.CC&quot;, &quot;.pcc&quot;, &quot;.hpp&quot;, or
&quot;.H&quot;. The filename &lsquo;&lsquo;-&rsquo;&rsquo;
means the <br>
standard input. To prevent security problems, special files
(such as device special files and named pipes) are always
skipped, and by default symbolic links are skipped (the <br>
--allowlink option follows symbolic links).</p>

<p style="margin-top: 1em">After the list of hits is a
brief summary of the results (use -D to remove this
information). It will show the number of hits, lines
analyzed (as reported by wc -l), and the <br>
physical source lines of code (SLOC) analyzed. A physical
SLOC is a non-blank, non-comment line. It will then show the
number of hits at each level; note that there will never
<br>
be a hit at a level lower than minlevel (1 by default).
Thus, &quot;[0] 0 [1] 9&quot; means that at level 0 there
were 0 hits reported, and at level 1 there were 9 hits
reported. It <br>
will next show the number of hits at a given level or larger
(so level 3+ has the sum of the number of hits at level 3,
4, and 5). Thus, an entry of &quot;[0+] 37&quot; shows that
at <br>
level 0 or higher there were 37 hits (the 0+ entry will
always be the same as the &quot;hits&quot; number above).
Hits per KSLOC is next shown; this is each of the
&quot;level or higher&quot; val&acirc; <br>
ues multiplied by 1000 and divided by the physical SLOC. If
symlinks were skipped, the count of those is reported. If
hits were suppressed (using the &quot;ignore&quot; directive
in <br>
source code comments as described above), the number
suppressed is reported. The minimum risk level to be
included in the report is displayed; by default this is 1
(use --min&acirc; <br>
level to change this). The summary ends with important
reminders: Not every hit is necessarily a security
vulnerability, and there may be other security
vulnerabilities not <br>
reported by the tool.</p>

<p style="margin-top: 1em">Flawfinder is released under the
GNU GPL license version 2 or later (GPLv2+).</p>

<p style="margin-top: 1em">Flawfinder works similarly to
another program, ITS4, which is not fully open source
software (as defined in the Open Source Definition) nor free
software (as defined by the Free <br>
Software Foundation). The author of Flawfinder has never
seen ITS4&rsquo;s source code.</p>

<p style="margin-top: 1em">BRIEF TUTORIAL <br>
Here&rsquo;s a brief example of how flawfinder might be
used. Imagine that you have the C/C++ source code for some
program named xyzzy (which you may or may not have written),
and <br>
you&rsquo;re searching for security vulnerabilities (so you
can fix them before customers encounter the
vulnerabilities). For this tutorial, I&rsquo;ll assume that
you&rsquo;re using a Unix-like <br>
system, such as Linux, OpenBSD, or MacOS X.</p>

<p style="margin-top: 1em">If the source code is in a
subdirectory named xyzzy, you would probably start by
opening a text window and using flawfinder&rsquo;s default
settings, to analyze the program and report <br>
a prioritized list of potential security vulnerabilities
(the &lsquo;&lsquo;less&rsquo;&rsquo; just makes sure the
results stay on the screen): <br>
flawfinder xyzzy | less</p>

<p style="margin-top: 1em">At this point, you will see a
large number of entries. Each entry has a filename, a colon,
a line number, a risk level in brackets (where 5 is the most
risky), a category, the <br>
name of the function, and a description of why flawfinder
thinks the line is a vulnerability. Flawfinder normally
sorts by risk level, showing the riskiest items first; if
you <br>
have limited time, it&rsquo;s probably best to start working
on the riskiest items and continue until you run out of
time. If you want to limit the display to risks with only a
cer&acirc; <br>
tain risk level or higher, use the --minlevel option. If
you&rsquo;re getting an extraordinary number of false
positives because variable names look like dangerous
function names, use <br>
the -F option to remove reports about them. If you
don&rsquo;t understand the error message, please see
documents such as the Writing Secure Programs for Linux and
Unix HOWTO <br>

&acirc;&uml;http://www.dwheeler.com/secure-programs&acirc;&copy;
at http://www.dwheeler.com/secure-programs which provides
more information on writing secure programs.</p>

<p style="margin-top: 1em">Once you identify the problem
and understand it, you can fix it. Occasionally you may want
to re-do the analysis, both because the line numbers will
change and to make sure that <br>
the new code doesn&rsquo;t introduce yet a different
vulnerability.</p>

<p style="margin-top: 1em">If you&rsquo;ve determined that
some line isn&rsquo;t really a problem, and you&rsquo;re
sure of it, you can insert just before or on the offending
line a comment like <br>
/* Flawfinder: ignore */ <br>
to keep them from showing up in the output.</p>

<p style="margin-top: 1em">Once you&rsquo;ve done that, you
should go back and search for the program&rsquo;s inputs, to
make sure that the program strongly filters any of its
untrusted inputs. Flawfinder can iden&acirc; <br>
tify many program inputs by using the --inputs option, like
this: <br>
flawfinder --inputs xyzzy</p>

<p style="margin-top: 1em">Flawfinder can integrate well
with text editors and integrated development environments;
see the examples for more information.</p>

<p style="margin-top: 1em">Flawfinder includes many other
options, including ones to create HTML versions of the
output (useful for prettier displays). The next section
describes those options in more <br>
detail.</p>

<p style="margin-top: 1em">OPTIONS <br>
Flawfinder has a number of options, which can be grouped
into options that control its own documentation, select
input data, select which hits to display, select the output
for&acirc; <br>
mat, and perform hitlist management. Flawfinder supports the
standard syntax defined in the POSIX (Issue 7, 2013 Edition)
section &lsquo;&lsquo;Utility Conventions&rsquo;&rsquo;. It
also supports the <br>
GNU long options (double-dash options of form --option) as
defined in the GNU C Library Reference Manual
&lsquo;&lsquo;Program Argument Syntax
Conventions&rsquo;&rsquo; and GNU Coding Standards
&lsquo;&lsquo;Stan&acirc; <br>
dards for Command Line Interfaces&rsquo;&rsquo;. Long option
arguments can be provided as
&lsquo;&lsquo;--name=value&rsquo;&rsquo; or
&lsquo;&lsquo;-name value&rsquo;&rsquo;. Some options can
only be accessed using the more readable GNU <br>
long option conventions; common options are also supported
by the older single-letter option convention.</p>

<p style="margin-top: 1em">Documentation <br>
--help</p>

<p style="margin-top: 1em">-h Show usage (help)
information.</p>

<p style="margin-top: 1em">--version Shows (just) the
version number and exits.</p>

<p style="margin-top: 1em">--listrules List the terms
(tokens) that trigger further examination, their default
risk level, and the default warning (including the CWE
identifier(s), if applicable), all tab- <br>
separated. The terms are primarily names of
potentially-dangerous functions. Note that the reported risk
level and warning for some specific code may be different
<br>
than the default, depending on how the term is used. Combine
with -D if you do not want the usual header. Flawfinder
version 1.29 changed the separator from spaces <br>
to tabs, and added the default warning field.</p>

<p style="margin-top: 1em">Selecting Input Data <br>
--allowlink Allow the use of symbolic links; normally
symbolic links are skipped. Don&rsquo;t use this option if
you&rsquo;re analyzing code by others; attackers could do
many things to <br>
cause problems for an analysis with this option enabled. For
example, an attacker could insert symbolic links to files
such as /etc/passwd (leaking information about <br>
the file) or create a circular loop, which would cause
flawfinder to run &lsquo;&lsquo;forever&rsquo;&rsquo;.
Another problem with enabling this option is that if the
same file is refer&acirc; <br>
enced multiple times using symbolic links, it will be
analyzed multiple times (and thus reported multiple times).
Note that flawfinder already includes some protec&acirc;
<br>
tion against symbolic links to special file types such as
device file types (e.g., /dev/zero or C:stuff this was the
default.</p>

<p style="margin-top: 1em">--followdotdir <br>
Enter directories whose names begin with &quot;.&quot;.
Normally such directories are ignored, since they normally
include version control private data (such as .git/ or <br>
.svn/), configurations, and so on.</p>

<p style="margin-top: 1em">--nolink Ignored. Historically
this disabled following symbolic links; this behavior is now
the default.</p>

<p style="margin-top: 1em">--patch=patchfile</p>

<p style="margin-top: 1em">-P patchfile <br>
Examine the selected files or directories, but only report
hits in lines that are added or modified by the given patch
file. The patch file must be in a recognized <br>
unified diff format (e.g., the output of GNU &quot;diff -u
old new&quot;, &quot;svn diff&quot;, or &quot;git diff
[commit]&quot;). Flawfinder assumes that the patch has
already been applied to <br>
the files. The patch file can also include changes to
irrelevant files (they will simply be ignored). The line
numbers given in the patch file are used to determine <br>
which lines were changed, so if you have modified the files
since the patch file was created, regenerate the patch file
first. Beware that the file names of the new <br>
files given in the patch file must match exactly, including
upper/lower case, path prefix, and directory separator
(&nbsp;vs. /). Only unified diff format is accepted <br>
(GNU diff, svn diff, and git diff output is okay); if you
have a different format, again regenerate it first. Only
hits that occur on resultant changed lines, or <br>
immediately above and below them, are reported. This option
implies --neverignore.</p>

<p style="margin-top: 1em">Selecting Hits to Display <br>
--inputs</p>

<p style="margin-top: 1em">-I Show only functions that
obtain data from outside the program; this also sets
minlevel to 0.</p>

<p style="margin-top: 1em">--minlevel=X</p>

<p style="margin-top: 1em">-m X Set minimum risk level to X
for inclusion in hitlist. This can be from 0
(&lsquo;&lsquo;no risk&rsquo;&rsquo;) to 5
(&lsquo;&lsquo;maximum risk&rsquo;&rsquo;); the default is
1.</p>

<p style="margin-top: 1em">--falsepositive</p>

<p style="margin-top: 1em">-F Do not include hits that are
likely to be false positives. Currently, this means that
function names are ignored if they&rsquo;re not followed by
&quot;(&quot;, and that declarations of <br>
character arrays aren&rsquo;t noted. Thus, if you have use a
variable named &quot;access&quot; everywhere, this will
eliminate references to this ordinary variable. This
isn&rsquo;t the <br>
default, because this also increases the likelihood of
missing important hits; in particular, function names in
#define clauses and calls through function pointers will be
<br>
missed.</p>

<p style="margin-top: 1em">--neverignore</p>

<p style="margin-top: 1em">-n Never ignore security issues,
even if they have an &lsquo;&lsquo;ignore&rsquo;&rsquo;
directive in a comment.</p>

<p style="margin-top: 1em">--regexp=PATTERN</p>

<p style="margin-top: 1em">-e PATTERN <br>
Only report hits with text that matches the regular
expression pattern PATTERN. For example, to only report hits
containing the text &quot;CWE-120&quot;, use
&lsquo;&lsquo;--regex CWE-120&rsquo;&rsquo;. <br>
These option flag names are the same as grep.</p>

<p style="margin-top: 1em">Selecting Output Format <br>
--columns</p>

<p style="margin-top: 1em">-C Show the column number (as
well as the file name and line number) of each hit; this is
shown after the line number by adding a colon and the column
number in the line <br>
(the first character in a line is column number 1). This is
useful for editors that can jump to specific columns, or for
integrating with other tools (such as those <br>
to further filter out false positives).</p>

<p style="margin-top: 1em">--context</p>

<p style="margin-top: 1em">-c Show context, i.e., the line
having the &quot;hit&quot;/potential flaw. By default the
line is shown immediately after the warning.</p>

<p style="margin-top: 1em">--dataonly</p>

<p style="margin-top: 1em">-D Don&rsquo;t display the
header and footer. Use this along with --quiet to see just
the data itself.</p>

<p style="margin-top: 1em">--html</p>

<p style="margin-top: 1em">-H Format the output as HTML
instead of as simple text.</p>

<p style="margin-top: 1em">--immediate</p>

<p style="margin-top: 1em">-i Immediately display hits
(don&rsquo;t just wait until the end).</p>

<p style="margin-top: 1em">--singleline</p>

<p style="margin-top: 1em">-S Display as single line of
text output for each hit. Useful for interacting with
compilation tools.</p>

<p style="margin-top: 1em">--omittime Omit timing
information. This is useful for regression tests of
flawfinder itself, so that the output doesn&rsquo;t vary
depending on how long the analysis takes.</p>

<p style="margin-top: 1em">--quiet</p>

<p style="margin-top: 1em">-Q Don&rsquo;t display status
information (i.e., which files are being examined) while the
analysis is going on.</p>

<p style="margin-top: 1em">Hitlist Management <br>
--savehitlist=F <br>
Save all resulting hits (the &quot;hitlist&quot;) to F.</p>

<p style="margin-top: 1em">--loadhitlist=F <br>
Load the hitlist from F instead of analyzing source
programs. Warning: Do not load hitlists from untrusted
sources (for security reasons).</p>

<p style="margin-top: 1em">--diffhitlist=F <br>
Show only hits (loaded or analyzed) not in F. F was
presumably created previously using --savehitlist. Warning:
Do not diff hitlists from untrusted sources (for <br>
security reasons). If the --loadhitlist option is not
provided, this will show the hits in the analyzed source
code files that were not previously stored in F. If <br>
used along with --loadhitlist, this will show the hits in
the loaded hitlist not in F. The difference algorithm is
conservative; hits are only considered the <br>
&lsquo;&lsquo;same&rsquo;&rsquo; if they have the same
filename, line number, column position, function name, and
risk level.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Here are various examples of how to invoke flawfinder. The
first examples show various simple command-line options.
Flawfinder is designed to work well with text editors and
<br>
integrated development environments, so the next sections
show how to integrate flawfinder into vim and emacs.</p>

<p style="margin-top: 1em">Simple command-line options <br>
flawfinder /usr/src/linux-3.16 <br>
Examine all the C/C++ files in the directory
/usr/src/linux-3.16 and all its subdirectories
(recursively), reporting on all hits found. By default
flawfinder will <br>
skip symbolic links and directories with names that start
with a period.</p>

<p style="margin-top: 1em">flawfinder --minlevel=4 . <br>
Examine all the C/C++ files in the current directory and its
subdirectories (recursively); only report vulnerabilities
level 4 and up (the two highest risk levels).</p>

<p style="margin-top: 1em">flawfinder --inputs mydir <br>
Examine all the C/C++ files in mydir and its subdirectories
(recursively), and report functions that take inputs (so
that you can ensure that they filter the inputs <br>
appropriately).</p>

<p style="margin-top: 1em">flawfinder --neverignore mydir
<br>
Examine all the C/C++ files in the directory mydir and its
subdirectories, including even the hits marked for ignoring
in the code comments.</p>

<p style="margin-top: 1em">flawfinder -QD mydir <br>
Examine mydir and report only the actual results (removing
the header and footer of the output). This form is useful if
the output will be piped into other tools for <br>
further analysis. The -C (--columns) and -S (--singleline)
options can also be useful if you&rsquo;re piping the data
into other tools.</p>

<p style="margin-top: 1em">flawfinder -QDSC mydir <br>
Examine mydir, reporting only the actual results (no header
or footer). Each hit is reported on one line, and column
numbers are reported. This can be a useful com&acirc; <br>
mand if you are feeding flawfinder output to other
tools.</p>

<p style="margin-top: 1em">flawfinder --quiet --html
--context mydir &gt; results.html <br>
Examine all the C/C++ files in the directory mydir and its
subdirectories, and produce an HTML formatted version of the
results. Source code management systems (such <br>
as SourceForge and Savannah) might use a command like
this.</p>

<p style="margin-top: 1em">flawfinder --quiet --savehitlist
saved.hits *.[ch] <br>
Examine all .c and .h files in the current directory.
Don&rsquo;t report on the status of processing, and save the
resulting hitlist (the set of all hits) in the file <br>
saved.hits.</p>

<p style="margin-top: 1em">flawfinder --diffhitlist
saved.hits *.[ch] <br>
Examine all .c and .h files in the current directory, and
show any hits that weren&rsquo;t already in the file
saved.hits. This can be used to show only the
&lsquo;&lsquo;new&rsquo;&rsquo; vul&acirc; <br>
nerabilities in a modified program, if saved.hits was
created from the older version of the program being
analyzed.</p>

<p style="margin-top: 1em">flawfinder --patch recent.patch
. <br>
Examine the current directory recursively, but only report
lines that were changed or added in the already-applied
patchfile named recent.patch.</p>

<p style="margin-top: 1em">flawfinder --regex
&quot;CWE-120|CWE-126&quot; src/ <br>
Examine directory src recursively, but only report hits
where CWE-120 or CWE-126 apply.</p>

<p style="margin-top: 1em">Invoking from vim <br>
The text editor vim includes a &quot;quickfix&quot;
mechanism that works well with flawfinder, so that you can
easily view the warning messages and jump to the relevant
source code.</p>

<p style="margin-top: 1em">First, you need to invoke
flawfinder to create a list of hits, and there are two ways
to do this. The first way is to start flawfinder first, and
then (using its output) invoke <br>
vim. The second way is to start (or continue to run) vim,
and then invoke flawfinder (typically from inside vim).</p>

<p style="margin-top: 1em">For the first way, run
flawfinder and store its output in some FLAWFILE (say
&quot;flawfile&quot;), then invoke vim using its -q option,
like this: &quot;vim -q flawfile&quot;. The second way <br>
(starting flawfinder after starting vim) can be done a
legion of ways. One is to invoke flawfinder using a shell
command, &quot;:!flawfinder-command &gt; FLAWFILE&quot;,
then follow that <br>
with the command &quot;:cf FLAWFILE&quot;. Another way is to
store the flawfinder command in your makefile (as, say, a
pseudocommand like &quot;flaw&quot;), and then run
&quot;:make flaw&quot;.</p>

<p style="margin-top: 1em">In all these cases you need a
command for flawfinder to run. A plausible command, which
places each hit in its own line (-S) and removes headers and
footers that would confuse <br>
it, is:</p>

<p style="margin-top: 1em">flawfinder -SQD .</p>

<p style="margin-top: 1em">You can now use various editing
commands to view the results. The command &quot;:cn&quot;
displays the next hit; &quot;:cN&quot; displays the previous
hit, and &quot;:cr&quot; rewinds back to the first hit. <br>
&quot;:copen&quot; will open a window to show the current
list of hits, called the &quot;quickfix window&quot;;
&quot;:cclose&quot; will close the quickfix window. If the
buffer in the used window has <br>
changed, and the error is in another file, jumping to the
error will fail. You have to make sure the window contains a
buffer which can be abandoned before trying to jump to a
<br>
new file, say by saving the file; this prevents accidental
data loss.</p>

<p style="margin-top: 1em">Invoking from emacs <br>
The text editor / operating system emacs includes &quot;grep
mode&quot; and &quot;compile mode&quot; mechanisms that work
well with flawfinder, making it easy to view warning
messages, jump to the <br>
relevant source code, and fix any problems you find.</p>

<p style="margin-top: 1em">First, you need to invoke
flawfinder to create a list of warning messages. You can use
&quot;grep mode&quot; or &quot;compile mode&quot; to create
this list. Often &quot;grep mode&quot; is more convenient;
<br>
it leaves compile mode untouched so you can easily recompile
once you&rsquo;ve changed something. However, if you want to
jump to the exact column position of a hit, compile mode may
<br>
be more convenient because emacs can use the column output
of flawfinder to directly jump to the right location without
any special configuration.</p>

<p style="margin-top: 1em">To use grep mode, enter the
command &quot;M-x grep&quot; and then enter the needed
flawfinder command. To use compile mode, enter the command
&quot;M-x compile&quot; and enter the needed flawfinder <br>
command. This is a meta-key command, so you&rsquo;ll need to
use the meta key for your keyboard (this is usually the ESC
key). As with all emacs commands, you&rsquo;ll need to press
RETURN <br>
after typing &quot;grep&quot; or &quot;compile&quot;. So on
many systems, the grep mode is invoked by typing ESC x g r e
p RETURN.</p>

<p style="margin-top: 1em">You then need to enter a
command, removing whatever was there before if necessary. A
plausible command is:</p>

<p style="margin-top: 1em">flawfinder -SQDC .</p>

<p style="margin-top: 1em">This command makes every hit
report a single line, which is much easier for tools to
handle. The quiet and dataonly options remove the other
status information not needed for <br>
use inside emacs. The trailing period means that the current
directory and all descendents are searched for C/C++ code,
and analyzed for flaws.</p>

<p style="margin-top: 1em">Once you&rsquo;ve invoked
flawfinder, you can use emacs to jump around in its results.
The command C-x &lsquo; (Control-x backtick) visits the
source code location for the next warning mes&acirc; <br>
sage. C-u C-x &lsquo; (control-u control-x backtick)
restarts from the beginning. You can visit the source for
any particular error message by moving to that hit message
in the *com&acirc; <br>
pilation* buffer or *grep* buffer and typing the return key.
(Technical note: in the compilation buffer, this invokes
compile-goto-error.) You can also click the Mouse-2 button
<br>
on the error message (you don&rsquo;t need to switch to the
*compilation* buffer first).</p>

<p style="margin-top: 1em">If you want to use grep mode to
jump to specific columns of a hit, you&rsquo;ll need to
specially configure emacs to do this. To do this, modify the
emacs variable &quot;grep-regexp- <br>
alist&quot;. This variable tells Emacs how to parse output
of a &quot;grep&quot; command, similar to the variable
&quot;compilation-error-regexp-alist&quot; which lists
various formats of compilation <br>
error messages.</p>

<p style="margin-top: 1em">Invoking from Integrated
Development Environments (IDEs) <br>
For (other) IDEs, consult your IDE&rsquo;s set of
plug-ins.</p>

<p style="margin-top: 1em">COMMON WEAKNESS ENUMERATION
(CWE) <br>
The Common Weakness Enumeration (CWE) is &lsquo;&lsquo;a
formal list or dictionary of common software weaknesses that
can occur in software&rsquo;s architecture, design, code or
implementation <br>
that can lead to exploitable security vulnerabilities...
created to serve as a common language for describing
software security weaknesses&rsquo;&rsquo; <br>
(http://cwe.mitre.org/about/faq.html). For more information
on CWEs, see http://cwe.mitre.org.</p>

<p style="margin-top: 1em">Flawfinder supports the CWE and
is officially CWE-Compatible. Hit descriptions typically
include a relevant Common Weakness Enumeration (CWE)
identifier in parentheses where <br>
there is known to be a relevant CWE. For example, many of
the buffer-related hits mention CWE-120, the CWE identifier
for &lsquo;&lsquo;buffer copy without checking size of
input&rsquo;&rsquo; (aka <br>
&lsquo;&lsquo;Classic Buffer Overflow&rsquo;&rsquo;). In a
few cases more than one CWE identifier may be listed. The
HTML report also includes hypertext links to the CWE
definitions hosted at MITRE. <br>
In this way, flawfinder is designed to meet the CWE-Output
requirement.</p>

<p style="margin-top: 1em">Many of the CWEs reported by
flawfinder are identified in the CWE/SANS top 25 list 2011
(http://cwe.mitre.org/top25/). Many people will want to
search for CWEs in this list, <br>
such as CWE-120 (classic buffer overflow), When flawfinder
maps to a CWE that is more general than a top 25 item, it
lists it as more-general:more-specific (e.g., <br>
CWE-119:CWE-120), where more-general is the actual mapping.
If flawfinder maps to a more specific CWE item that is a
specific case of a top 25 item, it is listed in the form
<br>
top-25/more-specific (e.g., CWE-362/CWE-367), where the real
mapping is the more specific CWE entry. If the same entry
maps to multiple CWEs, the CWEs are separated by commas <br>
(this often occurs with CWE-20, Improper Input Validation).
This simplifies searching for certain CWEs.</p>

<p style="margin-top: 1em">CWE version 2.7 (released June
23, 2014) was used for the mapping. The current CWE mappings
select the most specific CWE the tool can determine. In
theory, most CWE security <br>
elements (signatures/patterns that the tool searches for)
could theoretically be mapped to CWE-676 (Use of Potentially
Dangerous Function), but such a mapping would not be
use&acirc; <br>
ful. Thus, more specific mappings were preferred where one
could be found. Flawfinder is a lexical analysis tool; as a
result, it is impractical for it to be more specific than
<br>
the mappings currently implemented. This also means that it
is unlikely to need much updating for map currency; it
simply doesn&rsquo;t have enough information to refine to a
detailed <br>
CWE level that CWE changes would typically affect. The list
of CWE identifiers was generated automatically using
&quot;make show-cwes&quot;, so there is confidence that this
list is cor&acirc; <br>
rect. Please report CWE mapping problems as bugs if you find
any.</p>

<p style="margin-top: 1em">Flawfinder may fail to find a
vulnerability, even if flawfinder covers one of these CWE
weaknesses. That said, flawfinder does find vulnerabilities
listed by the CWEs it covers, <br>
and it will not report lines without those vulnerabilities
in many cases. Thus, as required for any tool intending to
be CWE compatible, flawfinder has a rate of false positives
<br>
less than 100% and a rate of false negatives less than 100%.
Flawfinder almost always reports whenever it finds a match
to a CWE security element (a signature/pattern as defined
<br>
in its database), though certain obscure constructs can
cause it to fail (see BUGS below).</p>

<p style="margin-top: 1em">Flawfinder can report on the
following CWEs (these are the CWEs that flawfinder covers;
&lsquo;&lsquo;*&rsquo;&rsquo; marks those in the CWE/SANS
top 25 list):</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-20: Improper
Input Validation</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-22: Improper
Limitation of a Pathname to a Restricted Directory
(&lsquo;&lsquo;Path Traversal&rsquo;&rsquo;)</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-78: Improper
Neutralization of Special Elements used in an OS Command
(&lsquo;&lsquo;OS Command Injection&rsquo;&rsquo;)*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-119:
Improper Restriction of Operations within the Bounds of a
Memory Buffer (a parent of CWE-120*, so this is shown as
CWE-119:CWE-120)</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-120: Buffer
Copy without Checking Size of Input (&lsquo;&lsquo;Classic
Buffer Overflow&rsquo;&rsquo;)*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-126: Buffer
Over-read</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-134:
Uncontrolled Format String*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-190: Integer
Overflow or Wraparound*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-250:
Execution with Unnecessary Privileges</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-327: Use of
a Broken or Risky Cryptographic Algorithm*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-362:
Concurrent Execution using Shared Resource with Improper
Synchronization (&lsquo;&lsquo;Race
Condition&rsquo;&rsquo;)</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-377:
Insecure Temporary File</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-676: Use of
Potentially Dangerous Function*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-732:
Incorrect Permission Assignment for Critical Resource*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-785: Use of
Path Manipulation Function without Maximum-sized Buffer
(child of CWE-120*, so this is shown as CWE-120/CWE-785)</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-807:
Reliance on Untrusted Inputs in a Security Decision*</p>

<p style="margin-top: 1em">&Acirc;&middot; CWE-829:
Inclusion of Functionality from Untrusted Control
Sphere*</p>

<p style="margin-top: 1em">You can select a specific subset
of CWEs to report by using the
&lsquo;&lsquo;--regex&rsquo;&rsquo; (-e) option. This option
accepts a regular expression, so you can select multiple
CWEs, e.g., <br>
&lsquo;&lsquo;--regex
&quot;CWE-120|CWE-126&quot;&rsquo;&rsquo;. If you select
multiple CWEs with &lsquo;&lsquo;|&rsquo;&rsquo; on a
command line you will typically need to quote the parameters
(since an unquoted &lsquo;&lsquo;|&rsquo;&rsquo; is the pipe
sym&acirc; <br>
bol). Flawfinder is designed to meet the CWE-Searchable
requirement.</p>

<p style="margin-top: 1em">If your goal is to report a
subset of CWEs that are listed in a file, that can be
achieved on a Unix-like system using the
&lsquo;&lsquo;--regex&rsquo;&rsquo; aka
&lsquo;&lsquo;-e&rsquo;&rsquo; option. The file must be in
<br>
regular expression format. For example,
&lsquo;&lsquo;flawfinder -e $(cat file1)&rsquo;&rsquo; would
report only hits that matched the pattern in
&lsquo;&lsquo;file1&rsquo;&rsquo;. If file1 contained
&lsquo;&lsquo;CWE-120|CWE-126&rsquo;&rsquo; it <br>
would only report hits matching those CWEs.</p>

<p style="margin-top: 1em">A list of all CWE security
elements (the signatures/patterns that flawfinder looks for)
can be found by using the
&lsquo;&lsquo;--listrules&rsquo;&rsquo; option. Each line
lists the signature token <br>
(typically a function name) that may lead to a hit, the
default risk level, and the default warning (which includes
the default CWE identifier). For most purposes this is also
<br>
enough if you want to see what CWE security elements map to
which CWEs, or the reverse. For example, to see the most of
the signatures (function names) that map to CWE-327, <br>
without seeing the default risk level or detailed warning
text, run &lsquo;&lsquo;flawfinder --listrules | grep
CWE-327 | cut -f1&rsquo;&rsquo;. You can also see the tokens
without a CWE mapping this <br>
way by running &lsquo;&lsquo;flawfinder -D --listrules |
grep -v CWE-&rsquo;&rsquo;. However, while --listrules lists
all CWE security elements, it only lists the default
mappings from CWE security <br>
elements to CWE identifiers. It does not include the
refinements that flawfinder applies (e.g., by examining
function parameters).</p>

<p style="margin-top: 1em">If you want a detailed and exact
mapping between the CWE security elements and CWE
identifiers, the flawfinder source code (included in the
distribution) is the best place for <br>
that information. This detailed information is primarily of
interest to those few people who are trying to refine the
CWE mappings of flawfinder or refine CWE in general. The
<br>
source code documents the mapping between the security
elements to the respective CWE identifiers, and is a single
Python file. The &lsquo;&lsquo;c_rules&rsquo;&rsquo; dataset
defines most rules, with <br>
reference to a function that may make further refinements.
You can search the dataset for function names to see what
CWE it generates by default; if first parameter is not <br>
&lsquo;&lsquo;normal&rsquo;&rsquo; then that is the name of
a refining Python method that may select different CWEs
(depending on additional information). Conversely, you can
search for &lsquo;&lsquo;CWE-number&rsquo;&rsquo; <br>
and find what security elements (signatures or patterns)
refer to that CWE identifier. For most people, this is much
more than they need; most people just want to scan their
<br>
source code to quickly find problems.</p>

<p style="margin-top: 1em">SECURITY <br>
The whole point of this tool is to help find vulnerabilities
so they can be fixed. However, developers and reviewers must
know how to develop secure software to use this tool, <br>
because otherwise, a fool with a tool is still a fool. My
book at http://www.dwheeler.com/secure-programs may
help.</p>

<p style="margin-top: 1em">This tool should be, at most, a
small part of a larger software development process designed
to eliminate or reduce the impact of vulnerabilities.
Developers and reviewers need <br>
know how to develop secure software, and they need to apply
this knowledge to reduce the risks of vulnerabilities in the
first place.</p>

<p style="margin-top: 1em">Different vulnerability-finding
tools tend to find different vulnerabilities. Thus, you are
best off using human review and a variety of tools. This
tool can help find some <br>
vulnerabilities, but by no means all.</p>

<p style="margin-top: 1em">You should always analyze a copy
of the source program being analyzed, not a directory that
can be modified by a developer while flawfinder is
performing the analysis. This is <br>
especially true if you don&rsquo;t necessily trust a
developer of the program being analyzed. If an attacker has
control over the files while you&rsquo;re analyzing them,
the attacker could <br>
move files around or change their contents to prevent the
exposure of a security problem (or create the impression of
a problem where there is none). If you&rsquo;re worried
about <br>
malicious programmers you should do this anyway, because
after analysis you&rsquo;ll need to verify that the code
eventually run is the code you analyzed. Also, do not use
the <br>
--allowlink option in such cases; attackers could create
malicious symbolic links to files outside of their source
code area (such as /etc/passwd).</p>

<p style="margin-top: 1em">Source code management systems
(like SourceForge and Savannah) definitely fall into this
category; if you&rsquo;re maintaining one of those systems,
first copy or extract the files <br>
into a separate directory (that can&rsquo;t be controlled by
attackers) before running flawfinder or any other code
analysis tool.</p>

<p style="margin-top: 1em">Note that flawfinder only opens
regular files, directories, and (if requested) symbolic
links; it will never open other kinds of files, even if a
symbolic link is made to them. <br>
This counters attackers who insert unusual file types into
the source code. However, this only works if the filesystem
being analyzed can&rsquo;t be modified by an attacker during
the <br>
analysis, as recommended above. This protection also
doesn&rsquo;t work on Cygwin platforms, unfortunately.</p>

<p style="margin-top: 1em">Cygwin systems (Unix emulation
on top of Windows) have an additional problem if flawfinder
is used to analyze programs that the analyst cannot trust.
The problem is due to a <br>
design flaw in Windows (that it inherits from MS-DOS). On
Windows and MS-DOS, certain filenames (e.g.,
&lsquo;&lsquo;com1&rsquo;&rsquo;) are automatically treated
by the operating system as the names <br>
of peripherals, and this is true even when a full pathname
is given. Yes, Windows and MS-DOS really are designed this
badly. Flawfinder deals with this by checking what a <br>
filesystem object is, and then only opening directories and
regular files (and symlinks if enabled). Unfortunately, this
doesn&rsquo;t work on Cygwin; on at least some versions of
<br>
Cygwin on some versions of Windows, merely trying to
determine if a file is a device type can cause the program
to hang. A workaround is to delete or rename any filenames
that <br>
are interpreted as device names before performing the
analysis. These so-called &lsquo;&lsquo;reserved
names&rsquo;&rsquo; are CON, PRN, AUX, CLOCK$, NUL,
COM1-COM9, and LPT1-LPT9, optionally followed <br>
by an extension (e.g.,
&lsquo;&lsquo;com1.txt&rsquo;&rsquo;), in any directory, and
in any case (Windows is case-insensitive).</p>

<p style="margin-top: 1em">Do not load or diff hitlists
from untrusted sources. They are implemented using the
Python pickle module, and the pickle module is not intended
to be secure against erroneous or <br>
maliciously constructed data. Stored hitlists are intended
for later use by the same user who created the hitlist; in
that context this restriction is not a problem.</p>

<p style="margin-top: 1em">BUGS <br>
Flawfinder is based on simple text pattern matching, which
is part of its fundamental design and not easily changed.
This design apporach leads to a number of fundamental
limi&acirc; <br>
tations, e.g., a higher false positive rate, and is the
underlying cause of most of the bugs listed here. On the
positive side, flawfinder doesn&rsquo;t get confused by many
compli&acirc; <br>
cated preprocessor sequences that other tools sometimes
choke on; flawfinder can often handle code that cannot link,
and sometimes cannot even build.</p>

<p style="margin-top: 1em">Flawfinder is currently limited
to C/C++. In addition, when analyzing C++ it focuses
primarily on the C subset of C++. For example, flawfinder
does not report on expressions <br>
like cin &gt;&gt; charbuf, where charbuf is a char array.
That is because flawfinder doesn&rsquo;t have type
information, and &quot;&gt;&gt;&quot; is safe with many
other types; reporting on all &quot;&gt;&gt;&quot; would
<br>
lead to too many false positives. That said, it&rsquo;s
designed so that adding support for other languages should
be easy where its text-based approach can usefully
apply.</p>

<p style="margin-top: 1em">Flawfinder can be fooled by
user-defined functions or method names that happen to be the
same as those defined as &lsquo;&lsquo;hits&rsquo;&rsquo; in
its database, and will often trigger on definitions <br>
(as well as uses) of functions with the same name. This is
typically not a problem for C code. In C code, a function
with the same name as a common library routine name often
<br>
indicates that the developer is simply rewriting a common
library routine with the same interface, say for
portability&rsquo;s sake. C programs tend to avoid reusing
the same name for <br>
a different purpose (since in C function names are global by
default). There are reasonable odds that these rewritten
routines will be vulnerable to the same kinds of misuse,
<br>
and thus, reusing these rules is a reasonable approach.
However, this can be a much more serious problem in C++ code
which heavily uses classes and namespaces, since the same
<br>
method name may have many different meanings. The
--falsepositive option can help somewhat in this case. If
this is a serious problem, feel free to modify the program,
or <br>
process the flawfinder output through other tools to remove
the false positives.</p>

<p style="margin-top: 1em">Preprocessor commands embedded
in the middle of a parameter list of a call can cause
problems in parsing, in particular, if a string is opened
and then closed multiple times <br>
using an #ifdef .. #else construct, flawfinder gets
confused. Such constructs are bad style, and will confuse
many other tools too. If you must analyze such files,
rewrite <br>
those lines. Thankfully, these are quite rare.</p>

<p style="margin-top: 1em">Some complex or unusual
constructs can mislead flawfinder. In particular, if a
parameter begins with gettext(&quot; and ends with ),
flawfinder will presume that the parameter of <br>
gettext is a constant. This means it will get confused by
patterns like gettext(&quot;hi&quot;) +
function(&quot;bye&quot;). In practice, this doesn&rsquo;t
seem to be a problem; gettext() is usually <br>
wrapped around the entire parameter.</p>

<p style="margin-top: 1em">The routine to detect statically
defined character arrays uses simple text matching; some
complicated expressions can cause it to trigger or not
trigger unexpectedly.</p>

<p style="margin-top: 1em">Flawfinder looks for specific
patterns known to be common mistakes. Flawfinder (or any
tool like it) is not a good tool for finding intentionally
malicious code (e.g., Trojan <br>
horses); malicious programmers can easily insert code that
would not be detected by this kind of tool.</p>

<p style="margin-top: 1em">Flawfinder looks for specific
patterns known to be common mistakes in application code.
Thus, it is likely to be less effective analyzing programs
that aren&rsquo;t application-layer <br>
code (e.g., kernel code or self-hosting code). The
techniques may still be useful; feel free to replace the
database if your situation is significantly different from
normal.</p>

<p style="margin-top: 1em">Flawfinder&rsquo;s output format
(filename:linenumber, followed optionally by a
:columnnumber) can be misunderstood if any source files have
very weird filenames. Filenames embedding <br>
a newline/linefeed character will cause odd breaks, and
filenames including colon (:) are likely to be
misunderstood. This is especially important if
flawfinder&rsquo;s output is <br>
being used by other tools, such as filters or text editors.
If you&rsquo;re looking at new code, examine the files for
such characters. It&rsquo;s incredibly unwise to have such
filenames <br>
anyway; many tools can&rsquo;t handle such filenames at all.
Newline and linefeed are often used as internal data
delimeters. The colon is often used as special characters in
<br>
filesystems: MacOS uses it as a directory separator,
Windows/MS-DOS uses it to identify drive letters,
Windows/MS-DOS inconsistently uses it to identify special
devices like <br>
CON:, and applications on many platforms use the colon to
identify URIs/URLs. Filenames including spaces and/or tabs
don&rsquo;t cause problems for flawfinder, though note that
other <br>
tools might have problems with them.</p>

<p style="margin-top: 1em">Flawfinder is not
internationalized, so it currently does not support
localization.</p>

<p style="margin-top: 1em">In general, flawfinder attempts
to err on the side of caution; it tends to report hits, so
that they can be examined further, instead of silently
ignoring them. Thus, flawfinder <br>
prefers to have false positives (reports that turn out to
not be problems) rather than false negatives (failure to
report on a security vulnerability). But this is a
generality; <br>
flawfinder uses simplistic heuristics and simply can&rsquo;t
get everything &quot;right&quot;.</p>

<p style="margin-top: 1em">Security vulnerabilities might
not be identified as such by flawfinder, and conversely,
some hits aren&rsquo;t really security vulnerabilities. This
is true for all static security <br>
scanners, and is especially true for tools like flawfinder
that use a simple lexical analysis and pattern analysis to
identify potential vulnerabilities. Still, it can serve as
<br>
a useful aid for humans, helping to identify useful places
to examine further, and that&rsquo;s the point of this
simple tool.</p>

<p style="margin-top: 1em">SEE ALSO <br>
See the flawfinder website at
http://www.dwheeler.com/flawfinder. You should also see the
Secure Programming for Unix and Linux HOWTO at
http://www.dwheeler.com/secure-programs.</p>

<p style="margin-top: 1em">AUTHOR <br>
David A. Wheeler (dwheeler@dwheeler.com).</p>

<p style="margin-top: 1em">Flawfinder 3 Aug 2014
FLAWFINDER(1)</p>
<hr>
</body>
</html>
