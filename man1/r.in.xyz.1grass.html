<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:35:40 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>r.in.xyz(1grass) Grass User&rsquo;s Manual
r.in.xyz(1grass)</p>

<p style="margin-top: 1em">NAME <br>
r.in.xyz - Creates a raster map from an assemblage of many
coordinates using univariate statistics.</p>

<p style="margin-top: 1em">KEYWORDS <br>
raster, import, conversion, aggregation, ASCII, LIDAR</p>

<p style="margin-top: 1em">SYNOPSIS <br>
r.in.xyz <br>
r.in.xyz --help <br>
r.in.xyz [-sgi] input=name output=name [method=string]
[type=string] [separator=character] [x=integer] [y=integer]
[z=integer] [skip=integer] [zrange=min,max] <br>
[zscale=float] [value_column=integer] [vrange=min,max]
[vscale=float] [percent=integer] [pth=integer] [trim=float]
[--overwrite] [--help] [--verbose] [--quiet] <br>
[--ui]</p>

<p style="margin-top: 1em">Flags: <br>
-s <br>
Scan data file for extent then exit</p>

<p style="margin-top: 1em">-g <br>
In scan mode, print using shell script style</p>

<p style="margin-top: 1em">-i <br>
Ignore broken lines</p>

<p style="margin-top: 1em">--overwrite <br>
Allow output files to overwrite existing files</p>

<p style="margin-top: 1em">--help <br>
Print usage summary</p>

<p style="margin-top: 1em">--verbose <br>
Verbose module output</p>

<p style="margin-top: 1em">--quiet <br>
Quiet module output</p>

<p style="margin-top: 1em">--ui <br>
Force launching GUI dialog</p>

<p style="margin-top: 1em">Parameters: <br>
input=name [required] <br>
ASCII file containing input data (or &quot;-&quot; to read
from stdin)</p>

<p style="margin-top: 1em">output=name [required] <br>
Name for output raster map</p>

<p style="margin-top: 1em">method=string <br>
Statistic to use for raster values <br>
Options: n, min, max, range, sum, mean, stddev, variance,
coeff_var, median, percentile, skewness, trimmean <br>
Default: mean</p>

<p style="margin-top: 1em">type=string <br>
Storage type for resultant raster map <br>
Options: CELL, FCELL, DCELL <br>
Default: FCELL</p>

<p style="margin-top: 1em">separator=character <br>
Field separator <br>
Special characters: pipe, comma, space, tab, newline <br>
Default: pipe</p>

<p style="margin-top: 1em">x=integer <br>
Column number of x coordinates in input file (first column
is 1) <br>
Default: 1</p>

<p style="margin-top: 1em">y=integer <br>
Column number of y coordinates in input file <br>
Default: 2</p>

<p style="margin-top: 1em">z=integer <br>
Column number of data values in input file <br>
If a separate value column is given, this option refers to
the z-coordinate column to be filtered by the zrange option
<br>
Default: 3</p>

<p style="margin-top: 1em">skip=integer <br>
Number of header lines to skip at top of input file <br>
Default: 0</p>

<p style="margin-top: 1em">zrange=min,max <br>
Filter range for z data (min,max)</p>

<p style="margin-top: 1em">zscale=float <br>
Scale to apply to z data <br>
Default: 1.0</p>

<p style="margin-top: 1em">value_column=integer <br>
Alternate column number of data values in input file <br>
If not given (or set to 0) the z-column data is used <br>
Default: 0</p>

<p style="margin-top: 1em">vrange=min,max <br>
Filter range for alternate value column data (min,max)</p>

<p style="margin-top: 1em">vscale=float <br>
Scale to apply to alternate value column data <br>
Default: 1.0</p>

<p style="margin-top: 1em">percent=integer <br>
Percent of map to keep in memory <br>
Options: 1-100 <br>
Default: 100</p>

<p style="margin-top: 1em">pth=integer <br>
pth percentile of the values <br>
Options: 1-100</p>

<p style="margin-top: 1em">trim=float <br>
Discard &lt;trim&gt; percent of the smallest and
&lt;trim&gt; percent of the largest observations <br>
Options: 0-50</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The r.in.xyz module will load and bin ungridded x,y,z ASCII
data into a new raster map. The user may choose from a
variety of statistical methods in creating the new raster.
<br>
Gridded data provided as a stream of x,y,z points may also
be imported.</p>

<p style="margin-top: 1em">Please note that the current
region extents and resolution are used for the import. It is
therefore recommended to first use the -s flag to get the
extents of the input points to <br>
be imported, then adjust the current region accordingly, and
only then proceed with the actual import.</p>

<p style="margin-top: 1em">r.in.xyz is designed for
processing massive point cloud datasets, for example raw
LIDAR or sidescan sonar swath data. It has been tested with
datasets as large as tens of billion <br>
of points (705GB in a single file).</p>

<p style="margin-top: 1em">Available statistics for
populating the raster are:</p>

<p style="margin-top: 1em">n number of points in cell</p>

<p style="margin-top: 1em">min minimum value of points in
cell</p>

<p style="margin-top: 1em">max maximum value of points in
cell</p>

<p style="margin-top: 1em">range range of points in
cell</p>

<p style="margin-top: 1em">sum sum of points in cell</p>

<p style="margin-top: 1em">mean average value of points in
cell</p>

<p style="margin-top: 1em">stddev standard deviation of
points in cell</p>

<p style="margin-top: 1em">variance variance of points in
cell</p>

<p style="margin-top: 1em">coeff_var coefficient of
variance of points in cell</p>

<p style="margin-top: 1em">median median value of points in
cell</p>

<p style="margin-top: 1em">percentile pth percentile of
points in cell</p>

<p style="margin-top: 1em">skewness skewness of points in
cell</p>

<p style="margin-top: 1em">trimmean trimmed mean of points
in cell</p>

<p style="margin-top: 1em">&Acirc;&middot; Variance and
derivatives use the biased estimator (n). [subject to
change]</p>

<p style="margin-top: 1em">&Acirc;&middot; Coefficient of
variance is given in percentage and defined as
(stddev/mean)*100.</p>

<p style="margin-top: 1em">It is also possible to bin and
store another data column (e.g. backscatter) while
simultaneously filtering and scaling both the data column
values and the z range.</p>

<p style="margin-top: 1em">NOTES <br>
Gridded data <br>
If data is known to be on a regular grid r.in.xyz can
reconstruct the map perfectly as long as some care is taken
to set up the region correctly and that the data&acirc;s
native map <br>
projection is used. A typical method would involve
determining the grid resolution either by examining the
data&acirc;s associated documentation or by studying the
text file. Next scan <br>
the data with r.in.xyz&acirc;s -s (or -g) flag to find the
input data&acirc;s bounds. GRASS uses the cell-center raster
convention where data points fall within the center of a
cell, as <br>
opposed to the grid-node convention. Therefore you will need
to grow the region out by half a cell in all directions
beyond what the scan found in the file. After the region
<br>
bounds and resolution are set correctly with g.region, run
r.in.xyz using the n method and verify that n=1 at all
places. r.univar can help. Once you are confident that the
<br>
region exactly matches the data proceed to run r.in.xyz
using one of the mean, min, max, or median methods. With n=1
throughout, the result should be identical regardless of
<br>
which of those methods are used.</p>

<p style="margin-top: 1em">Memory use <br>
While the input file can be arbitrarily large, r.in.xyz will
use a large amount of system memory for large raster regions
(10000x10000). If the module refuses to start
complain&acirc; <br>
ing that there isn&acirc;t enough memory, use the percent
parameter to run the module in several passes. In addition
using a less precise map format (CELL [integer] or FCELL
[floating <br>
point]) will use less memory than a DCELL [double precision
floating point] output map. Methods such as n, min, max, sum
will also use less memory, while stddev, variance, and <br>
coeff_var will use more. The aggregate functions median,
percentile, skewness and trimmed mean will use even more
memory and may not be appropriate for use with arbitrarily
<br>
large input files.</p>

<p style="margin-top: 1em">The default map type=FCELL is
intended as compromise between preserving data precision and
limiting system resource consumption. If reading data from a
stdin stream, the program <br>
can only run using a single pass.</p>

<p style="margin-top: 1em">Setting region bounds and
resolution <br>
You can use the -s scan flag to find the extent of the input
data (and thus point density) before performing the full
import. Use g.region to adjust the region bounds to match.
<br>
The -g shell style flag prints the extent suitable as
parameters for g.region. A suitable resolution can be found
by dividing the number of input points by the area covered.
<br>
e.g. <br>
wc -l inputfile.txt <br>
g.region -p <br>
# points_per_cell = n_points / (rows * cols) <br>
g.region -e <br>
# UTM location: <br>
# points_per_sq_m = n_points / (ns_extent * ew_extent) <br>
# Lat/Lon location: <br>
# points_per_sq_m = n_points / (ns_extent *
ew_extent*cos(lat) * (1852*60)^2)</p>

<p style="margin-top: 1em">If you only intend to
interpolate the data with r.to.vect and v.surf.rst, then
there is little point to setting the region resolution so
fine that you only catch one data point <br>
per cell -- you might as well use &quot;v.in.ascii
-zbt&quot; directly.</p>

<p style="margin-top: 1em">Filtering <br>
Points falling outside the current region will be skipped.
This includes points falling exactly on the southern region
bound. (to capture those adjust the region with
&quot;g.region <br>
s=s-0.000001&quot;; see g.region)</p>

<p style="margin-top: 1em">Blank lines and comment lines
starting with the hash symbol (#) will be skipped.</p>

<p style="margin-top: 1em">The zrange parameter may be used
for filtering the input data by vertical extent. Example
uses might include preparing multiple raster sections to be
combined into a 3D raster <br>
array with r.to.rast3, or for filtering outliers on
relatively flat terrain.</p>

<p style="margin-top: 1em">In varied terrain the user may
find that min maps make for a good noise filter as most
LIDAR noise is from premature hits. The min map may also be
useful to find the underlying <br>
topography in a forested or urban environment if the cells
are over sampled.</p>

<p style="margin-top: 1em">The user can use a combination
of r.in.xyz output maps to create custom filters. e.g. use
r.mapcalc to create a mean-(2*stddev) map. [In this example
the user may want to include <br>
a lower bound filter in r.mapcalc to remove highly variable
points (small n) or run r.neighbors to smooth the stddev map
before further use.]</p>

<p style="margin-top: 1em">Alternate value column <br>
The value_column parameter can be used in specialized cases
when you want to filter by z-range but bin and store another
column&acirc;s data. For example if you wanted to look at
<br>
backscatter values between 1000 and 1500 meters elevation.
This is particularly useful when using r.in.xyz to prepare
depth slices for a 3D raster &amp;#8212; the zrange option
<br>
defines the depth slice but the data values stored in the
voxels describe an additional dimension. As with the z
column, a filtering range and scaling factor may be
applied.</p>

<p style="margin-top: 1em">Reprojection <br>
If the raster map is to be reprojected, it may be more
appropriate to reproject the input points with m.proj or
cs2cs before running r.in.xyz.</p>

<p style="margin-top: 1em">Interpolation into a DEM <br>
The vector engine&acirc;s topographic abilities introduce a
finite memory overhead per vector point which will typically
limit a vector map to approximately 3 million points (~
1750^2 <br>
cells). If you want more, use the r.to.vect -b flag to skip
building topology. Without topology, however, all
you&acirc;ll be able to do with the vector map is display
with d.vect and <br>
interpolate with v.surf.rst. Run r.univar on your raster map
to check the number of non-NULL cells and adjust bounds
and/or resolution as needed before proceeding.</p>

<p style="margin-top: 1em">Typical commands to create a DEM
using a regularized spline fit: <br>
r.univar lidar_min <br>
r.to.vect -z type=point in=lidar_min out=lidar_min_pt <br>
v.surf.rst in=lidar_min_pt elev=lidar_min.rst</p>

<p style="margin-top: 1em">Import of x,y,string data <br>
r.in.xyz is expecting numeric values as z column. In order
to perform a occurrence count operation even on x,y data
with non-numeric attribute(s), the data can be imported
using <br>
either the x or y coordinate as a fake z column for method=n
(count number of points per grid cell), the z values are
ignored anyway.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Import of x,y,z ASCII into DEM <br>
Sometimes elevation data are delivered as x,y,z ASCII files
instead of a raster matrix: <br>
# Important: observe the raster spacing from the ASCII file:
<br>
# ASCII file format (example): <br>
# 630007.5 228492.5 141.99614 <br>
# 630022.5 228492.5 141.37904 <br>
# 630037.5 228492.5 142.29822 <br>
# 630052.5 228492.5 143.97987 <br>
# ... <br>
# The point distance is 15m here. <br>
# detect extent, print result as g.region parameters <br>
r.in.xyz input=elevation.xyz separator=space -s output=dummy
-g <br>
# ... n=228492.5 s=215007.5 e=644992.5 w=630007.5
b=55.578793 t=156.32986 <br>
# set computational region, along with the actual raster
resolution <br>
# which is defined by the ASCII file point spacing: <br>
g.region n=228492.5 s=215007.5 e=644992.5 w=630007.5 res=15
-p <br>
# enlarge computational region by half a raster cell (here
7.5m) to <br>
# store the points as cell centers: <br>
g.region n=n+7.5 s=s-7.5 w=w-7.5 e=e+7.5 -p <br>
# import XYZ ASCII file, with z values as raster cell values
<br>
r.in.xyz input=elevation.xyz separator=space method=mean
output=myelev <br>
# univariate statistics for verification of raster values
<br>
r.univar myelev</p>

<p style="margin-top: 1em">Import of LiDAR data and DEM
creation <br>
Import the Jockey&acirc;s Ridge, NC, LIDAR dataset
(compressed file &quot;lidaratm2.txt.gz&quot;), and process
it into a clean DEM: <br>
# scan and set region bounds <br>
r.in.xyz -s separator=&quot;,&quot; in=lidaratm2.txt
out=test <br>
g.region n=35.969493 s=35.949693 e=-75.620999 w=-75.639999
<br>
g.region res=0:00:00.075 -a <br>
# create &quot;n&quot; map containing count of points per
cell for checking density <br>
r.in.xyz in=lidaratm2.txt out=lidar_n
separator=&quot;,&quot; method=n zrange=-2,50 <br>
# check point density [rho = n_sum / (rows*cols)] <br>
r.univar lidar_n | grep sum <br>
# create &quot;min&quot; map (elevation filtered for
premature hits) <br>
r.in.xyz in=lidaratm2.txt out=lidar_min
separator=&quot;,&quot; method=min zrange=-2,50 <br>
# set computational region to area of interest <br>
g.region n=35:57:56.25N s=35:57:13.575N w=75:38:23.7W
e=75:37:15.675W <br>
# check number of non-null cells (try and keep under a few
million) <br>
r.univar lidar_min | grep &acirc;^n:&acirc; <br>
# convert to points <br>
r.to.vect -z type=point in=lidar_min out=lidar_min_pt <br>
# interpolate using a regularized spline fit <br>
v.surf.rst in=lidar_min_pt elev=lidar_min.rst <br>
# set color scale to something interesting <br>
r.colors lidar_min.rst rule=bcyr -n -e <br>
# prepare a 1:1:1 scaled version for NVIZ visualization (for
lat/lon input) <br>
r.mapcalc &quot;lidar_min.rst_scaled = lidar_min.rst /
(1852*60)&quot; <br>
r.colors lidar_min.rst_scaled rule=bcyr -n -e</p>

<p style="margin-top: 1em">TODO <br>
&Acirc;&middot; Support for multiple map output from a
single run. <br>
method=string[,string,...] output=name[,name,...] <br>
This can be easily handled by a wrapper script, with the
added benefit of it being very simple to parallelize that
way.</p>

<p style="margin-top: 1em">&Acirc;&middot; Add two new
flags for support for direct binary input from libLAS for
LIDAR data and MB-System&acirc;s mbio for multi-beam
bathymetry data. <br>
note: See the new r.in.lidar module for this.</p>

<p style="margin-top: 1em">KNOWN ISSUES <br>
&Acirc;&middot; &quot;nan&quot; can leak into coeff_var
maps. <br>
Cause unknown. Possible work-around: &quot;r.null
setnull=nan&quot; <br>
If you encounter any problems (or solutions!) please contact
the GRASS Development Team.</p>

<p style="margin-top: 1em">SEE ALSO <br>
g.region, m.proj, r.fillnulls, r.in.ascii, r.in.lidar,
r3.in.xyz, r.mapcalc, r.neighbors, r.out.xyz, r.to.rast3,
r.to.vect, r.univar, v.in.ascii, v.surf.rst</p>

<p style="margin-top: 1em">v.lidar.correction,
v.lidar.edgedetection, v.lidar.growing, v.outlier,
v.surf.bspline</p>

<p style="margin-top: 1em">pv - The UNIX pipe viewer
utility</p>

<p style="margin-top: 1em">Overview: Interpolation and
Resampling in GRASS GIS</p>

<p style="margin-top: 1em">AUTHORS <br>
Hamish Bowman <br>
Department of Marine Science <br>
University of Otago <br>
New Zealand <br>
Extended by Volker Wichmann to support the aggregate
functions median, percentile, skewness and trimmed mean.</p>

<p style="margin-top: 1em">Last changed: $Date: 2016-08-03
13:53:17 +0200 (Wed, 03 Aug 2016) $</p>

<p style="margin-top: 1em">SOURCE CODE <br>
Available at: r.in.xyz source code (history)</p>

<p style="margin-top: 1em">Main index | Raster index |
Topics index | Keywords index | Graphical index | Full
index</p>

<p style="margin-top: 1em">&Acirc;&copy; 2003-2016 GRASS
Development Team, GRASS GIS 7.2.0 Reference Manual</p>

<p style="margin-top: 1em">GRASS 7.2.0 r.in.xyz(1grass)</p>
<hr>
</body>
</html>
