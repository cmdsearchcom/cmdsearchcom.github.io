<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>r.in.xyz(1grass)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">r.in.xyz(1grass)</td>
    <td class="head-vol">Grass User's Manual</td>
    <td class="head-rtitle">r.in.xyz(1grass)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<i></i><b>r.in.xyz</b> - Creates a raster map from an assemblage of many
  coordinates using univariate statistics.
<h1 class="Sh" title="Sh" id="KEYWORDS"><a class="selflink" href="#KEYWORDS">KEYWORDS</a></h1>
raster, import, conversion, aggregation, ASCII, LIDAR
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>r.in.xyz</b>
<div>&#x00A0;</div>
<b>r.in.xyz --help</b>
<div>&#x00A0;</div>
<b>r.in.xyz</b> [-<b>sgi</b>] <b>input</b>=<i>name</i> <b>output</b>=<i>name</i>
  [ <b>method</b>=<i>string</i>] [<b>type</b>=<i>string</i>]
  [<b>separator</b>=<i>character</i>] [<b>x</b>=<i>integer</i>]
  [<b>y</b>=<i>integer</i>] [ <b>z</b>=<i>integer</i>]
  [<b>skip</b>=<i>integer</i>] [ <b>zrange</b>=<i>min,max</i>]
  [<b>zscale</b>=<i>float</i>] [<b>value_column</b>=<i>integer</i>]
  [<b>vrange</b>= <i>min,max</i>] [<b>vscale</b>=<i>float</i>]
  [<b>percent</b>=<i>integer</i>] [<b>pth</b>=<i>integer</i>]
  [<b>trim</b>=<i>float</i>] [-- <b>overwrite</b>] [--<b>help</b>]
  [--<b>verbose</b>] [-- <b>quiet</b>] [--<b>ui</b>]
<h2 class="Ss" title="Ss" id="Flags:"><a class="selflink" href="#Flags:">Flags:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Scan data file for extent then exit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    In scan mode, print using shell script style</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Ignore broken lines</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--overwrite</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Allow output files to overwrite existing files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Print usage summary</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbose</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Verbose module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quiet</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Quiet module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ui</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Force launching GUI dialog</dd>
</dl>
<h2 class="Ss" title="Ss" id="Parameters:"><a class="selflink" href="#Parameters:">Parameters:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>input</b>=<i>name</i> <b>[required]</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    ASCII file containing input data (or &quot;-&quot; to read from stdin)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>output</b>=<i>name</i> <b>[required]</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name for output raster map</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>method</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Statistic to use for raster values
    <div>&#x00A0;</div>
    Options: <i>n, min, max, range, sum, mean, stddev, variance, coeff_var,
      median, percentile, skewness, trimmean</i>
    <div>&#x00A0;</div>
    Default: <i>mean</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>type</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Storage type for resultant raster map
    <div>&#x00A0;</div>
    Options: <i>CELL, FCELL, DCELL</i>
    <div>&#x00A0;</div>
    Default: <i>FCELL</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>separator</b>=<i>character</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Field separator
    <div>&#x00A0;</div>
    Special characters: pipe, comma, space, tab, newline
    <div>&#x00A0;</div>
    Default: <i>pipe</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Column number of x coordinates in input file (first column is 1)
    <div>&#x00A0;</div>
    Default: <i>1</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>y</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Column number of y coordinates in input file
    <div>&#x00A0;</div>
    Default: <i>2</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>z</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Column number of data values in input file
    <div>&#x00A0;</div>
    If a separate value column is given, this option refers to the z-coordinate
      column to be filtered by the zrange option
    <div>&#x00A0;</div>
    Default: <i>3</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>skip</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Number of header lines to skip at top of input file
    <div>&#x00A0;</div>
    Default: <i>0</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zrange</b>=<i>min,max</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Filter range for z data (min,max)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zscale</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Scale to apply to z data
    <div>&#x00A0;</div>
    Default: <i>1.0</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>value_column</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Alternate column number of data values in input file
    <div>&#x00A0;</div>
    If not given (or set to 0) the z-column data is used
    <div>&#x00A0;</div>
    Default: <i>0</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vrange</b>=<i>min,max</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Filter range for alternate value column data (min,max)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vscale</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Scale to apply to alternate value column data
    <div>&#x00A0;</div>
    Default: <i>1.0</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>percent</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Percent of map to keep in memory
    <div>&#x00A0;</div>
    Options: <i>1-100</i>
    <div>&#x00A0;</div>
    Default: <i>100</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pth</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    pth percentile of the values
    <div>&#x00A0;</div>
    Options: <i>1-100</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Discard &lt;trim&gt; percent of the smallest and &lt;trim&gt; percent of the
      largest observations
    <div>&#x00A0;</div>
    Options: <i>0-50</i></dd>
</dl>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <i>r.in.xyz</i> module will load and bin ungridded x,y,z ASCII data into a
  new raster map. The user may choose from a variety of statistical methods in
  creating the new raster. Gridded data provided as a stream of x,y,z points may
  also be imported.
<div class="Pp"></div>
Please note that the current region extents and resolution are used for the
  import. It is therefore recommended to first use the <i>-s</i> flag to get the
  extents of the input points to be imported, then adjust the current region
  accordingly, and only then proceed with the actual import.
<div class="Pp"></div>
<i>r.in.xyz</i> is designed for processing massive point cloud datasets, for
  example raw LIDAR or sidescan sonar swath data. It has been tested with
  datasets as large as tens of billion of points (705GB in a single file).
<div class="Pp"></div>
Available statistics for populating the raster are:
<table class="tbl">
  <colgroup>
    <col style="width: 60.00ex;"/>
    <col style="width: 1.00ex;"/>
    <col style="width: 60.00ex;"/>
  </colgroup>
  <tr>
    <td><i>n</i></td>
    <td> </td>
    <td>number of points in cell</td>
  </tr>
  <tr>
    <td><i>min</i></td>
    <td> </td>
    <td>minimum value of points in cell</td>
  </tr>
  <tr>
    <td><i>max</i></td>
    <td> </td>
    <td>maximum value of points in cell</td>
  </tr>
  <tr>
    <td><i>range</i></td>
    <td> </td>
    <td>range of points in cell</td>
  </tr>
  <tr>
    <td><i>sum</i></td>
    <td> </td>
    <td>sum of points in cell</td>
  </tr>
  <tr>
    <td><i>mean</i></td>
    <td> </td>
    <td>average value of points in cell</td>
  </tr>
  <tr>
    <td><i>stddev</i></td>
    <td> </td>
    <td>standard deviation of points in cell</td>
  </tr>
  <tr>
    <td><i>variance</i></td>
    <td> </td>
    <td>variance of points in cell</td>
  </tr>
  <tr>
    <td><i>coeff_var</i></td>
    <td> </td>
    <td>coefficient of variance of points in cell</td>
  </tr>
  <tr>
    <td><i>median</i></td>
    <td> </td>
    <td>median value of points in cell</td>
  </tr>
  <tr>
    <td><i>percentile</i></td>
    <td> </td>
    <td>p<i>th</i> percentile of points in cell</td>
  </tr>
  <tr>
    <td><i>skewness</i></td>
    <td> </td>
    <td>skewness of points in cell</td>
  </tr>
  <tr>
    <td><i>trimmean</i></td>
    <td> </td>
    <td>trimmed mean of points in cell</td>
  </tr>
</table>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>Variance</i> and derivatives use the biased estimator
      (n). [subject to change]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>Coefficient of variance</i> is given in percentage and
      defined as (stddev/mean)*100.</dd>
</dl>
</div>
<div class="Pp"></div>
It is also possible to bin and store another data column (e.g. backscatter)
  while simultaneously filtering and scaling both the data column values and the
  z range.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
<h2 class="Ss" title="Ss" id="Gridded_data"><a class="selflink" href="#Gridded_data">Gridded
  data</a></h2>
If data is known to be on a regular grid <i>r.in.xyz</i> can reconstruct the map
  perfectly as long as some care is taken to set up the region correctly and
  that the data&#x2019;s native map projection is used. A typical method would
  involve determining the grid resolution either by examining the data&#x2019;s
  associated documentation or by studying the text file. Next scan the data with
  <i>r.in.xyz</i>&#x2019;s <b>-s</b> (or <b>-g</b>) flag to find the input
  data&#x2019;s bounds. GRASS uses the cell-center raster convention where data
  points fall within the center of a cell, as opposed to the grid-node
  convention. Therefore you will need to grow the region out by half a cell in
  all directions beyond what the scan found in the file. After the region bounds
  and resolution are set correctly with <i>g.region</i>, run <i>r.in.xyz</i>
  using the <i>n</i> method and verify that n=1 at all places. <i>r.univar</i>
  can help. Once you are confident that the region exactly matches the data
  proceed to run <i>r.in.xyz</i> using one of the <i>mean,</i> <i>min, max</i>,
  or <i>median</i> methods. With n=1 throughout, the result should be identical
  regardless of which of those methods are used.
<h2 class="Ss" title="Ss" id="Memory_use"><a class="selflink" href="#Memory_use">Memory
  use</a></h2>
While the <b>input</b> file can be arbitrarily large, <i>r.in.xyz</i> will use a
  large amount of system memory for large raster regions (10000x10000). If the
  module refuses to start complaining that there isn&#x2019;t enough memory, use
  the <b>percent</b> parameter to run the module in several passes. In addition
  using a less precise map format (CELL [integer] or FCELL [floating point])
  will use less memory than a DCELL [double precision floating point]
  <b>output</b> map. Methods such as <i>n,</i> <i>min, max, sum</i> will also
  use less memory, while <i>stddev, variance,</i> <i>and coeff_var</i> will use
  more. The aggregate functions <i>median, percentile, skewness</i> and
  <i>trimmed mean</i> will use even more memory and may not be appropriate for
  use with arbitrarily large input files.
<div class="Pp"></div>
The default map <b>type</b>=FCELL is intended as compromise between preserving
  data precision and limiting system resource consumption. If reading data from
  a stdin stream, the program can only run using a single pass.
<h2 class="Ss" title="Ss" id="Setting_region_bounds_and_resolution"><a class="selflink" href="#Setting_region_bounds_and_resolution">Setting
  region bounds and resolution</a></h2>
You can use the <b>-s</b> scan flag to find the extent of the input data (and
  thus point density) before performing the full import. Use <i>g.region</i> to
  adjust the region bounds to match. The <b>-g</b> shell style flag prints the
  extent suitable as parameters for <i>g.region</i>. A suitable resolution can
  be found by dividing the number of input points by the area covered. e.g.
<div>&#x00A0;</div>
<pre>
wc -l inputfile.txt
g.region -p
# points_per_cell = n_points / (rows * cols)
g.region -e
# UTM location:
# points_per_sq_m = n_points / (ns_extent * ew_extent)
# Lat/Lon location:
# points_per_sq_m = n_points / (ns_extent * ew_extent*cos(lat) * (1852*60)^2)
</pre>
<div class="Pp"></div>
If you only intend to interpolate the data with <i>r.to.vect</i> and
  <i>v.surf.rst</i>, then there is little point to setting the region resolution
  so fine that you only catch one data point per cell -- you might as well use
  &quot;v.in.ascii -zbt&quot; directly.
<h2 class="Ss" title="Ss" id="Filtering"><a class="selflink" href="#Filtering">Filtering</a></h2>
Points falling outside the current region will be skipped. This includes points
  falling <i>exactly</i> on the southern region bound. (to capture those adjust
  the region with &quot;g.region s=s-0.000001&quot;; see <i>g.region</i>)
<div class="Pp"></div>
Blank lines and comment lines starting with the hash symbol (#) will be skipped.
<div class="Pp"></div>
The <b>zrange</b> parameter may be used for filtering the input data by vertical
  extent. Example uses might include preparing multiple raster sections to be
  combined into a 3D raster array with <i>r.to.rast3</i>, or for filtering
  outliers on relatively flat terrain.
<div class="Pp"></div>
In varied terrain the user may find that <i>min</i> maps make for a good noise
  filter as most LIDAR noise is from premature hits. The <i>min</i> map may also
  be useful to find the underlying topography in a forested or urban environment
  if the cells are over sampled.
<div class="Pp"></div>
The user can use a combination of <i>r.in.xyz</i> <b>output</b> maps to create
  custom filters. e.g. use <i>r.mapcalc</i> to create a mean-(2*stddev) map. [In
  this example the user may want to include a lower bound filter in
  <i>r.mapcalc</i> to remove highly variable points (small <i>n</i>) or run
  <i>r.neighbors</i> to smooth the stddev map before further use.]
<h2 class="Ss" title="Ss" id="Alternate_value_column"><a class="selflink" href="#Alternate_value_column">Alternate
  value column</a></h2>
The <b>value_column</b> parameter can be used in specialized cases when you want
  to filter by z-range but bin and store another column&#x2019;s data. For
  example if you wanted to look at backscatter values between 1000 and 1500
  meters elevation. This is particularly useful when using <i>r.in.xyz</i> to
  prepare depth slices for a 3D raster &amp;#8212; the <b>zrange</b> option
  defines the depth slice but the data values stored in the voxels describe an
  additional dimension. As with the z column, a filtering range and scaling
  factor may be applied.
<h2 class="Ss" title="Ss" id="Reprojection"><a class="selflink" href="#Reprojection">Reprojection</a></h2>
If the raster map is to be reprojected, it may be more appropriate to reproject
  the input points with <i>m.proj</i> or <i>cs2cs</i> before running
  <i>r.in.xyz</i>.
<h2 class="Ss" title="Ss" id="Interpolation_into_a_DEM"><a class="selflink" href="#Interpolation_into_a_DEM">Interpolation
  into a DEM</a></h2>
The vector engine&#x2019;s topographic abilities introduce a finite memory
  overhead per vector point which will typically limit a vector map to
  approximately 3 million points (~ 1750^2 cells). If you want more, use the
  <i>r.to.vect</i> <b>-b</b> flag to skip building topology. Without topology,
  however, all you&#x2019;ll be able to do with the vector map is display with
  <i>d.vect</i> and interpolate with <i>v.surf.rst</i>. Run <i>r.univar</i> on
  your raster map to check the number of non-NULL cells and adjust bounds and/or
  resolution as needed before proceeding.
<div class="Pp"></div>
Typical commands to create a DEM using a regularized spline fit:
<div>&#x00A0;</div>
<pre>
r.univar lidar_min
r.to.vect -z type=point in=lidar_min out=lidar_min_pt
v.surf.rst in=lidar_min_pt elev=lidar_min.rst
</pre>
<h2 class="Ss" title="Ss" id="Import_of_x,y,string_data"><a class="selflink" href="#Import_of_x,y,string_data">Import
  of x,y,string data</a></h2>
<i>r.in.xyz</i> is expecting numeric values as z column. In order to perform a
  occurrence count operation even on x,y data with non-numeric attribute(s), the
  data can be imported using either the x or y coordinate as a fake z column for
  <b>method</b>=n (count number of points per grid cell), the z values are
  ignored anyway.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<h2 class="Ss" title="Ss" id="Import_of_x,y,z_ASCII_into_DEM"><a class="selflink" href="#Import_of_x,y,z_ASCII_into_DEM">Import
  of x,y,z ASCII into DEM</a></h2>
Sometimes elevation data are delivered as x,y,z ASCII files instead of a raster
  matrix:
<div>&#x00A0;</div>
<pre>
# Important: observe the raster spacing from the ASCII file:
# ASCII file format (example):
# 630007.5 228492.5 141.99614
# 630022.5 228492.5 141.37904
# 630037.5 228492.5 142.29822
# 630052.5 228492.5 143.97987
# ...
# The point distance is 15m here.
# detect extent, print result as g.region parameters
r.in.xyz input=elevation.xyz separator=space -s output=dummy -g
# ... n=228492.5 s=215007.5 e=644992.5 w=630007.5 b=55.578793 t=156.32986
# set computational region, along with the actual raster resolution
# which is defined by the ASCII file point spacing:
g.region n=228492.5 s=215007.5 e=644992.5 w=630007.5 res=15 -p
# enlarge computational region by half a raster cell (here 7.5m) to
# store the points as cell centers:
g.region n=n+7.5 s=s-7.5 w=w-7.5 e=e+7.5 -p
# import XYZ ASCII file, with z values as raster cell values
r.in.xyz input=elevation.xyz separator=space method=mean output=myelev
# univariate statistics for verification of raster values
r.univar myelev
</pre>
<h2 class="Ss" title="Ss" id="Import_of_LiDAR_data_and_DEM_creation"><a class="selflink" href="#Import_of_LiDAR_data_and_DEM_creation">Import
  of LiDAR data and DEM creation</a></h2>
Import the Jockey&#x2019;s Ridge, NC, LIDAR dataset (compressed file
  &quot;lidaratm2.txt.gz&quot;), and process it into a clean DEM:
<div>&#x00A0;</div>
<pre>
# scan and set region bounds
r.in.xyz -s separator=&quot;,&quot; in=lidaratm2.txt out=test
g.region n=35.969493 s=35.949693 e=-75.620999 w=-75.639999
g.region res=0:00:00.075 -a
# create &quot;n&quot; map containing count of points per cell for checking density
r.in.xyz in=lidaratm2.txt out=lidar_n separator=&quot;,&quot; method=n zrange=-2,50
# check point density [rho = n_sum / (rows*cols)]
r.univar lidar_n | grep sum
# create &quot;min&quot; map (elevation filtered for premature hits)
r.in.xyz in=lidaratm2.txt out=lidar_min separator=&quot;,&quot; method=min zrange=-2,50
# set computational region to area of interest
g.region n=35:57:56.25N s=35:57:13.575N w=75:38:23.7W e=75:37:15.675W
# check number of non-null cells (try and keep under a few million)
r.univar lidar_min | grep &#x2019;^n:&#x2019;
# convert to points
r.to.vect -z type=point in=lidar_min out=lidar_min_pt
# interpolate using a regularized spline fit
v.surf.rst in=lidar_min_pt elev=lidar_min.rst
# set color scale to something interesting
r.colors lidar_min.rst rule=bcyr -n -e
# prepare a 1:1:1 scaled version for NVIZ visualization (for lat/lon input)
r.mapcalc &quot;lidar_min.rst_scaled = lidar_min.rst / (1852*60)&quot;
r.colors lidar_min.rst_scaled rule=bcyr -n -e
</pre>
<h1 class="Sh" title="Sh" id="TODO"><a class="selflink" href="#TODO">TODO</a></h1>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Support for multiple map output from a single run.
    <div>&#x00A0;</div>
    method=string[,string,...] output=name[,name,...]
    <div>&#x00A0;</div>
    This can be easily handled by a wrapper script, with the added benefit of it
      being very simple to parallelize that way.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Add two new flags for support for direct binary input from
      libLAS for LIDAR data and MB-System&#x2019;s mbio for multi-beam
      bathymetry data.
    <div>&#x00A0;</div>
     <i>note</i>: See the new <i>r.in.lidar</i> module for this.</dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="KNOWN_ISSUES"><a class="selflink" href="#KNOWN_ISSUES">KNOWN
  ISSUES</a></h1>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;nan&quot; can leak into <i>coeff_var</i> maps.
    <div>&#x00A0;</div>
    Cause unknown. Possible work-around: &quot;r.null setnull=nan&quot;</dd>
</dl>
</div>
If you encounter any problems (or solutions!) please contact the GRASS
  Development Team.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i></i> <i>g.region,</i> <i>m.proj,</i> <i>r.fillnulls,</i> <i>r.in.ascii,</i>
  <i>r.in.lidar,</i> <i>r3.in.xyz,</i> <i>r.mapcalc,</i> <i>r.neighbors,</i>
  <i>r.out.xyz,</i> <i>r.to.rast3,</i> <i>r.to.vect,</i> <i>r.univar,</i>
  <i>v.in.ascii,</i> <i>v.surf.rst</i> <i></i>
<div class="Pp"></div>
<i></i> <i>v.lidar.correction,</i> <i>v.lidar.edgedetection,</i>
  <i>v.lidar.growing,</i> <i>v.outlier,</i> <i>v.surf.bspline</i> <i></i>
<div class="Pp"></div>
<i>pv</i> - The UNIX pipe viewer utility
<div class="Pp"></div>
Overview: Interpolation and Resampling in GRASS GIS
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Hamish Bowman
<div>&#x00A0;</div>
<i></i> <i>Department of Marine Science</i>
<div>&#x00A0;</div>
University of Otago
<div>&#x00A0;</div>
New Zealand
<div>&#x00A0;</div>
<div>&#x00A0;</div>
Extended by Volker Wichmann to support the aggregate functions <i>median,
  percentile, skewness</i> and <i>trimmed mean</i>.
<div class="Pp"></div>
<i>Last changed: $Date: 2016-08-03 13:53:17 +0200 (Wed, 03 Aug 2016) $</i>
<h1 class="Sh" title="Sh" id="SOURCE_CODE"><a class="selflink" href="#SOURCE_CODE">SOURCE
  CODE</a></h1>
Available at: r.in.xyz source code (history)
<div class="Pp"></div>
Main index | Raster index | Topics index | Keywords index | Graphical index |
  Full index
<div class="Pp"></div>
&#x00A9; 2003-2016 GRASS Development Team, GRASS GIS 7.2.0 Reference
  Manual</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os">GRASS 7.2.0</td>
  </tr>
</table>
</body>
</html>
