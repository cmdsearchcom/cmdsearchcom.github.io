<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:23:47 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKEPP_TUTORIAL(1) Makepp MAKEPP_TUTORIAL(1)</p>

<p style="margin-top: 1em">NAME <br>
makepp_tutorial -- Tutorial on writing makefiles</p>

<p style="margin-top: 1em">DESCRIPTION <br>
A makefile is the set of instructions that you use to tell
makepp how to build your program. Makepp can accept most
makefiles written for the standard Unix make, but if
you&rsquo;re <br>
starting from scratch, it is often much simpler to use some
of makepp&rsquo;s advanced features. This is an introduction
for writing makefiles that are specific to makepp.</p>

<p style="margin-top: 1em">If you already know a lot about
writing makefiles, you might want to at least peruse the
later sections of this file because they show the preferred
way to do things with makepp, <br>
which is often different from the traditional way to do it
with make. Another source of examples and advice on writing
makefiles for makepp is makepp_cookbook.</p>

<p style="margin-top: 1em">Building a program from its
source files can be a complicated and time-consuming
operation. The commands are too long to be typed in manually
every time. However, a <br>
straightforward shell script is seldom used for compiling a
program, because it&rsquo;s too time-consuming to recompile
all modules when only one of them has changed.</p>

<p style="margin-top: 1em">However, it&rsquo;s too
error-prone to allow a human to tell the computer which
files need to be recompiled. Forgetting to recompile a file
can mean hours of frustrating debugging. A <br>
reliable automatic tool is necessary for determining exactly
which modules need recompilation.</p>

<p style="margin-top: 1em">Makepp (short for
Make-plus-plus, or make++) is a tool for solving exactly
this problem. It is an improvement on the make program, a
standard tool that has been around for many <br>
years. It relies either on its own builtin knowledge (in
very simple cases), or on a file called a Makefile that
contains a detailed recipe for building the program.</p>

<p style="margin-top: 1em">Usually, the input files are
program source code, and the output files are executables,
but makepp doesn&rsquo;t care what they are. You can use a
makefile to control any kind of <br>
procedure where you need to selectively execute certain
commands depending on which files have changed. You could,
for example, use makepp to do data analysis, where your
input <br>
files are raw data and analysis programs, and your output
files are processed data or graphs or whatever. Makepp will
figure out which of the processed data files need to be <br>
updated whenever some of the data files or analysis programs
change. The examples in this introduction will assume you
are building an executable program from source code, but
<br>
you can do a lot more with makepp than just that if you use
your imagination.</p>

<p style="margin-top: 1em">If your program consists of a
single module, you probably don&rsquo;t need makepp, because
you know that any change that you make requires recompiling
that module. However, if your <br>
program consists of even just two modules, then you will
definitely want to use a program like makepp.</p>

<p style="margin-top: 1em">Do I need a makefile? <br>
If your program is relatively simple and doesn&rsquo;t
require anything particularly special, makepp may already
know how to build it without your explicitly giving
instructions. For <br>
example, suppose you have a program in a single source file,
called &quot;test.c&quot;. You can just type &quot;makepp
test&quot; and your program will build like this:</p>

<p style="margin-top: 1em">% makepp test <br>
makepp: Entering directory &lsquo;/somewhere/or/other&rsquo;
<br>
gcc -g -Wall -c test.c -o test.o <br>
gcc -g -Wall test.o -o test <br>
Warning: on Unix, to run a program called
&rsquo;test&rsquo;, you must type <br>
./test <br>
rather than just &rsquo;test&rsquo;.</p>

<p style="margin-top: 1em">These are the basic commands
needed to compile a program on Unix. If these commands
don&rsquo;t make any sense to you, see
makepp_tutorial_compilation.</p>

<p style="margin-top: 1em">Makepp contains builtin rules
for C, C++, and Fortran.</p>

<p style="margin-top: 1em">Makepp can sometimes figure out
how to compile programs that are contained in more than one
source file, or programs that must be linked with various
system libraries. It does <br>
this by guessing which source files and libraries you need
based on the files that you include. The actual algorithm is
too complicated to discuss here in a tutorial (but see <br>
makepp_builtin); you can try it, and if it doesn&rsquo;t
work automatically for you, you need to write your own
makefile.</p>

<p style="margin-top: 1em">By default, for C and C++,
makepp compiles the program with debug information and
without optimization. If you want to turn on optimization so
that your program runs faster, <br>
change the command line to:</p>

<p style="margin-top: 1em">makepp CFLAGS=-O2 test</p>

<p style="margin-top: 1em">If you&rsquo;re compiling C++
instead of C, use &quot;CXXFLAGS=-O2&quot; instead of
&quot;CFLAGS=-O2&quot;. For a complete list of other options
you can configure without writing a makefile, see <br>
makepp_builtin.</p>

<p style="margin-top: 1em">Makepp&rsquo;s builtin rules are
somewhat more powerful than the standard Unix make, but if
you write programs of any complexity, it&rsquo;s likely that
you&rsquo;ll need a makefile eventually to <br>
tell makepp what to do.</p>

<p style="margin-top: 1em">If you are not familiar with
Unix compilation commands, it may be helpful at this point
to read makepp_tutorial_compilation for a description of
what these cryptic Unix <br>
compilation commands do.</p>

<p style="margin-top: 1em">A simple makefile <br>
Suppose you are writing a C++ program which has two source
modules, &quot;processing.cxx&quot; and &quot;gui.cxx&quot;,
along with numerous include files. If you were to build your
program from <br>
scratch, you would need to execute something like these
commands:</p>

<p style="margin-top: 1em">c++ -c processing.cxx -o
processing.o <br>
c++ -c gui.cxx -o gui.o <br>
c++ processing.o gui.o -o my_program</p>

<p style="margin-top: 1em">The first two commands are
compilation commands, and the third invokes the linker to
combine the two object files into a single executable. If
you make changes to &quot;gui.cxx&quot; but <br>
not to &quot;processing.cxx&quot;, then you don&rsquo;t need
to reexecute the first command, but you do need to execute
the last two commands. makepp can figure this out for you
automatically.</p>

<p style="margin-top: 1em">(If you&rsquo;ve never worked
with make before, you may be thinking that you could combine
the above three commands into a single command, like
this:</p>

<p style="margin-top: 1em">c++ processing.cxx gui.cxx -o
my_program</p>

<p style="margin-top: 1em">When you omit the &quot;-c&quot;
option to the compiler, it combines the compilation and
linking step. This is often quite convenient when you are
not writing a makefile. However, it&rsquo;s <br>
not a good idea to do this in a makefile, because it always
recompiles both modules even if one of them hasn&rsquo;t
changed, and this can take a significant amount of extra
time.)</p>

<p style="margin-top: 1em">In order to use makepp to
control the build process, you&rsquo;ll need to write a
makefile. The makefile is a text file that contains the
recipe for building your program. It usually <br>
resides in the same directory as the sources, and it is
usually called &quot;Makeppfile&quot;, &quot;Makefile&quot;
or, only at the root of your build tree
&quot;RootMakeppfile&quot;.</p>

<p style="margin-top: 1em">Each one of these commands
should be a separate rule in a makefile. A rule is an
instruction for building one or more output files from one
or more input files. Makepp <br>
determines which rules need to be reexecuted by determining
whether any of the input files for a rule have changed since
the last time the rule was executed.</p>

<p style="margin-top: 1em">A rule has a syntax like
this:</p>

<p style="margin-top: 1em">output_filenames :
input_filenames <br>
actions</p>

<p style="margin-top: 1em">The first line of the rule
contains a space-separated list of output files, followed by
a colon, followed by a space-separated list of input files.
The output files are also <br>
called targets, and the input files are also called
dependencies; we say that the target file depends on the
dependencies, because if any of the dependencies change, the
target <br>
must be rebuilt.</p>

<p style="margin-top: 1em">The remaining lines of the rule
(the actions) are shell commands to be executed. Each action
must be indented with at least one space (traditional make
requires a tab <br>
character). Usually, there&rsquo;s just one action line, but
there can be as many as you want; each line is executed
sequentially, and if any one of them fails, the remainder
are not <br>
executed. The rule ends at the first line which is not
indented.</p>

<p style="margin-top: 1em">Some or all of the actions may
also be Perl statements. These may be on a single line and
surrounded by &quot;perl { ... }&quot;. Or they may span
several lines, in which case the braces <br>
must be doubled, &quot;perl {{ ... }}&quot;.</p>

<p style="margin-top: 1em">You can place the rules in any
order in the makefile, but it is traditional to write the
rule that links the program first, followed by the
compilation rules. One reason for <br>
this is that if you simply type
&quot;&quot;makepp&quot;&quot;, then makepp attempts to
build the first target in the file, which means that it will
build your whole program and not just a piece of <br>
it. (If you want to build something other than the first
target, you have to specify the name of the target on the
command line, e.g., &quot;&quot;makepp
processing.o&quot;&quot;.)</p>

<p style="margin-top: 1em">The above compilation commands
should be written as three separate rules. A makefile for
building this program could look like this:</p>

<p style="margin-top: 1em"># Link command: <br>
my_program: processing.o gui.o <br>
c++ processing.o gui.o -o my_program <br>
perl {{ <br>
print &quot;my_program is built0; <br>
}}</p>

<p style="margin-top: 1em"># Compilation commands: <br>
processing.o: processing.cxx <br>
c++ -c processing.cxx -o processing.o</p>

<p style="margin-top: 1em">gui.o: gui.cxx <br>
c++ -c gui.cxx -o gui.o</p>

<p style="margin-top: 1em">(Characters on a line following
a &quot;#&quot; are ignored; they are just comments. You do
not need the &quot;&quot;# Link command:&quot;&quot; comment
in the makefile at all.)</p>

<p style="margin-top: 1em">To use this makefile, simply cd
to the directory and type &quot;&quot;makepp&quot;&quot;.
Makepp will attempt to build the first target in the
makefile, which is &quot;my_program&quot;. (If you
don&rsquo;t want <br>
it to build the first target, then you have to supply a the
name of the target you actually want to build on the command
line.)</p>

<p style="margin-top: 1em">When makepp attempts to build
&quot;my_program&quot;, it realizes that it first must build
&quot;processing.o&quot; and &quot;gui.o&quot; before it can
execute the link command. So it looks at the other <br>
rules in the makefile to determine how to build these.</p>

<p style="margin-top: 1em">In order to build
&quot;processing.o&quot;, makepp uses the second rule. Since
&quot;processing.o&quot; depends on
&quot;processing.cxx&quot;, makepp will also try to make
&quot;processing.cxx&quot;. There is no rule <br>
to make &quot;processing.cxx&quot;; it must already
exist.</p>

<p style="margin-top: 1em">Makepp checks whether
&quot;processing.cxx&quot; has changed since the last time
&quot;processing.o&quot; was built. By default, it
determines this by looking at the dates on the file. Makepp
<br>
remembers what the date of &quot;processing.cxx&quot; was
the last time &quot;processing.o&quot; was made by storing
it in a separate file (in a subdirectory called
&quot;.makepp&quot;). Makepp will execute <br>
the actions to build the target if any of the following is
true:</p>

<p style="margin-top: 1em">&Acirc;&middot; The target does
not exist.</p>

<p style="margin-top: 1em">&Acirc;&middot; The target
exists, but makepp does not have any information about the
last build.</p>

<p style="margin-top: 1em">&Acirc;&middot; The date on any
input file has changed since the last build, and there is a
significant difference in the input file. For C or C++ files
this means a change other than <br>
whitespace or within comments.</p>

<p style="margin-top: 1em">&Acirc;&middot; The date on any
target has changed since the last build, and there is a
difference in the target file.</p>

<p style="margin-top: 1em">&Acirc;&middot; The actions have
changed since the last build.</p>

<p style="margin-top: 1em">&Acirc;&middot; The last build
occurred on a different architecture (different CPU type or
operating system type).</p>

<p style="margin-top: 1em">&Acirc;&middot; Any environment
variable listed on the rule has changed in value.</p>

<p style="margin-top: 1em">It might seem a little funny
that makepp executes the action if either the output file or
the input files have changed since the last build. Makepp is
designed to guarantee that <br>
your build is correct, according to the commands in the
makefile. If you go and modify the file yourself, then
makepp can&rsquo;t guarantee that the modified file is
actually correct, <br>
so it insists on rebuilding. (For more information on how
makepp decides whether to rebuild, and how you can control
this, see makepp_signatures and makepp_command.)</p>

<p style="margin-top: 1em">Now &quot;processing.o&quot;
might not depend only on &quot;processing.cxx&quot;; if
&quot;processing.cxx&quot; includes any &quot;.h&quot;
files, then it needs to be recompiled if any of those
&quot;.h&quot; files has changed, <br>
even if &quot;processing.cxx&quot; itself has not changed.
You could modify the rule like this:</p>

<p style="margin-top: 1em"># Unnecessary listing of .h
files <br>
processing.o: processing.cxx processing.h simple_vector.h
list.h <br>
c++ -c processing.cxx -o processing.o</p>

<p style="margin-top: 1em">However, it is a real nuisance
to modify the makefile every time you change the list of
files that are included, and it is also extremely error
prone. You would not only have to <br>
list the files that &quot;processing.cxx&quot; includes, but
also all the files that those files include, etc. You
don&rsquo;t have to do this. Makepp is smart enough to check
for include files <br>
automatically. Any time it sees a command that looks like a
C or C++ compilation (by looking at the first word of the
action), it reads in the source files looking for <br>
&quot;#include&quot; directives. It knows where to look for
include files by parsing your compiler command line for
&quot;-I&quot; options . Any files which are included are
automatically added to <br>
the dependency list, and any files which those include. If
any of them has changed, the file will be recompiled.</p>

<p style="margin-top: 1em">Once makepp knows that
&quot;processing.o&quot; is up to date, it then determines
whether &quot;gui.o&quot; needs to be rebuilt by applying
the same procedure to the third rule. When both <br>
&quot;processing.o&quot; and &quot;gui.o&quot; are known to
be built correctly, then makepp applies the same procedure
to see if the link command needs to be reexecuted.</p>

<p style="margin-top: 1em">The above makefile will work,
but even for this simple problem, an experienced user is not
likely to write his makefile this way. Several improvements
are discussed in the next <br>
sections.</p>

<p style="margin-top: 1em">Using variables</p>

<p style="margin-top: 1em">So far, our makefile for
compiling our program of two modules looks like this:</p>

<p style="margin-top: 1em"># Link command: <br>
my_program: processing.o gui.o <br>
c++ processing.o gui.o -o my_program</p>

<p style="margin-top: 1em"># Compilation commands: <br>
processing.o: processing.cxx <br>
c++ -c processing.cxx -o processing.o</p>

<p style="margin-top: 1em">gui.o: gui.cxx <br>
c++ -c gui.cxx -o gui.o</p>

<p style="margin-top: 1em">This works wonderfully, but
suppose now we want to change some compilation options. Or
maybe we want to use a different compiler. We&rsquo;d have
to change all three compilation <br>
lines.</p>

<p style="margin-top: 1em">Similarly, suppose we want to
change the list of modules to compile. We&rsquo;d have to
change it in two places.</p>

<p style="margin-top: 1em">Duplication of information like
this is a recipe for disaster. If you go and change your
makefile, it&rsquo;s pretty much guaranteed that at some
point, you or someone else will <br>
forget to change one of the places. Depending on what the
change is (especially if it affects preprocessor
definitions), this can lead to subtle and hard-to-debug
problems in <br>
your program.</p>

<p style="margin-top: 1em">The way to avoid duplication of
information is to specify the information only once and
store it in a variable, which can be accessed each time the
information is needed.</p>

<p style="margin-top: 1em"># Define the symbols we might
want to change: <br>
CXX := c++ <br>
CXXFLAGS := -g</p>

<p style="margin-top: 1em">OBJECTS := processing.o
gui.o</p>

<p style="margin-top: 1em">my_program: $(OBJECTS) <br>
$(CXX) $(OBJECTS) -o my_program</p>

<p style="margin-top: 1em">processing.o: processing.cxx
<br>
$(CXX) $(INCLUDES) $(CXXFLAGS) -c processing.cxx -o
processing.o</p>

<p style="margin-top: 1em">gui.o: gui.cxx <br>
$(CXX) $(CXXFLAGS) -c gui.cxx -o gui.o</p>

<p style="margin-top: 1em">Here &quot;$(CXX)&quot; expands
to be the value of the variable &quot;CXX&quot;, and
similarly for &quot;$(CXXFLAGS)&quot; and
&quot;$(OBJECTS)&quot;. Now we can just change one line in
the makefile, and all relevant <br>
compilation commands are affected.</p>

<p style="margin-top: 1em">In fact, we don&rsquo;t even
need to change the makefile to change compilation options.
Assignments specified on the command line override
assignments in the makefile. For example, <br>
we could type this to the shell:</p>

<p style="margin-top: 1em">makepp CXXFLAGS=&quot;-g
-O2&quot;</p>

<p style="margin-top: 1em">which overrides the setting of
&quot;CXXFLAGS&quot; in the makefile. It is as if the
makefile contained the line</p>

<p style="margin-top: 1em">CXXFLAGS := -g -O2</p>

<p style="margin-top: 1em">instead of the definition it
does contain.</p>

<p style="margin-top: 1em">It might not at all be useful to
be able to override these things for your own development,
but if you distribute your sources to other people, they
might appreciate it.</p>

<p style="margin-top: 1em">Variable names are case
sensitive (e.g., &quot;OBJECTS&quot; is different from
&quot;objects&quot;). Usually people write most variables in
upper case only, but you don&rsquo;t have to.</p>

<p style="margin-top: 1em">If you need to put a literal
dollar sign into a rule action, write it with a double
dollar sign, like this:</p>

<p style="margin-top: 1em">test: <br>
for testfile in *.test; do run_test $$testfile; done</p>

<p style="margin-top: 1em">Conventionally, there are a few
variables which you might want to set. These are just
conventions, but you will see them in a lot of
makefiles.</p>

<p style="margin-top: 1em">CC := cc # The C compiler. <br>
CFLAGS := -g # C compilation options which relate to <br>
# optimization or debugging (usually <br>
# just -g or -O). Usually this wouldn&rsquo;t <br>
# include -I options to specify the <br>
# include directories, because then you <br>
# couldn&rsquo;t override it on the command line <br>
# easily as in the above example. <br>
CXX := c++ # The C++ compiler. (Sometimes &quot;CPP&quot;
instead <br>
# of CXX.) <br>
CXXFLAGS := -g # C++ compilation options related to <br>
# optimization or debugging (-O or -g). <br>
F77 := f77 # The Fortran compiler. <br>
FFLAGS := # Optimization flags for Fortran.</p>

<p style="margin-top: 1em">Makepp will guess appropriate
values for some of these variables if you don&rsquo;t
specify them (see makepp_builtin), but it is usually best to
set them explicitly--it makes it easier <br>
on anyone reading your makefile.</p>

<p style="margin-top: 1em">There are a lot more extremely
powerful things you can do with variables, but first we need
to explain some more things about makefiles.</p>

<p style="margin-top: 1em">Pattern rules</p>

<p style="margin-top: 1em">Having one rule for each
compilation command is fine when there are only a few files,
but what if your program consists of dozens of source files?
Most of them have to be <br>
compiled with very similar commands. It is tedious to type
in a separate rule for each source file, and then if you
decide to change the rules, you have to change the makefile
<br>
in a dozen places. A better solution to this problem is to
use a pattern rule.</p>

<p style="margin-top: 1em">A pattern rule is a concise way
of specifying a rule for many files at once. The rule will
depend on the file names, but usually it depends on them in
a simple way. You specify <br>
a pattern by using the &quot;%&quot; wildcard. When present
in the dependency list, &quot;%&quot; matches any string of
any length; when present in the list of targets,
&quot;%&quot; stands for the string <br>
that &quot;%&quot; in the dependency list matched.</p>

<p style="margin-top: 1em">The following pattern rule will
take any &quot;.c&quot; file and compile it into a
&quot;.o&quot; file:</p>

<p style="margin-top: 1em">%.o: %.c <br>
$(CC) $(CFLAGS) $(INCLUDES) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">(This assumes that you have the
variables &quot;CC&quot;, &quot;CFLAGS&quot;, and
&quot;INCLUDES&quot; defined to be something suitable.
Makepp will guess a value for &quot;CC&quot; and
&quot;CFLAGS&quot;.)</p>

<p style="margin-top: 1em">The first line of the rule says
that it applies to every possible input file that matches
the pattern &quot;%.c&quot;. These &quot;.c&quot; files can
be transformed into the corresponding &quot;.o&quot; file
<br>
using the specified actions.</p>

<p style="margin-top: 1em">The action of rule is quite
similar to the other actions we&rsquo;ve seen previously,
except that it uses automatic variables. An automatic
variable is a variable whose value is <br>
automatically set by makepp depending on the rule that it
appears in. The most useful automatic variables are:</p>

<p style="margin-top: 1em">&quot;$(input)&quot; <br>
The name of the first input file. In this rule, this would
be the file that matches the &quot;%.c&quot; pattern.
&quot;$(dependency)&quot; is a synonym for
&quot;$(input)&quot;. In older makefiles, you <br>
will also see the cryptic symbol $&lt; used as well.</p>

<p style="margin-top: 1em">&quot;$(output)&quot; <br>
The name of the first output file. In this rule, this would
be the file that matches the &quot;%.o&quot; pattern.
&quot;$(target)&quot; and $@ are synonyms.</p>

<p style="margin-top: 1em">&quot;$(inputs)&quot; <br>
The name of all explicitly listed input files. In this case,
since there is only one, &quot;$(inputs)&quot; is equivalent
to &quot;$(input)&quot;. &quot;$(dependencies)&quot; and $^
are synonyms.</p>

<p style="margin-top: 1em">&quot;$(outputs)&quot; <br>
The name of all explicitly listed targets. In this case,
since there is only one, &quot;$(outputs)&quot; is
equivalent to &quot;$(output)&quot;. &quot;$(targets)&quot;
is a synonym for &quot;$(outputs)&quot;.</p>

<p style="margin-top: 1em">Note that these variables are
lower case.</p>

<p style="margin-top: 1em">You can use these automatic
variables even for non-pattern rules. This avoids repeating
target filenames.</p>

<p style="margin-top: 1em">You can actually do considerably
more complicated things with pattern rules. For example,</p>

<p style="margin-top: 1em"># Put the object files into a
separate directory: <br>
objects/%.o: %.cpp <br>
$(CXX) $(CXXFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em"># Run a preprocessor to make
source files: <br>
moc_%.cxx: %.h <br>
$(MOC) $(input) -o $(output)</p>

<p style="margin-top: 1em">Using pattern rules and
automatic variables, we&rsquo;d probably rewrite our
makefile for our simple program like this:</p>

<p style="margin-top: 1em">CXX := c++ <br>
CXXFLAGS := -g <br>
INCLUDES := -I. # This would contain any -I options to the
<br>
# compiler, if there are any. <br>
LIBS := -L/usr/X11R6/lib -lX11 # Contains libraries we need
to link in. <br>
OBJECTS := processing.o gui.o</p>

<p style="margin-top: 1em">my_program: $(OBJECTS) <br>
$(CXX) $(inputs) -o $(output) $(LIBS)</p>

<p style="margin-top: 1em">%.o: %.cxx <br>
$(CXX) $(INCLUDES) $(CXXFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">Now we don&rsquo;t have to have
an explicit rule for each object file we need to produce. If
we want to add another module to our program, we only have
to change the one line that <br>
defines the &quot;OBJECTS&quot; variable. Note that this
makefile is now much more concise than our original
makefile. Each piece of information occurs only once so
there is no <br>
possibility of making a mistake by changing information in
one place and forgetting to change it in others.</p>

<p style="margin-top: 1em">When you use pattern rules,
it&rsquo;s not uncommon for there to be two different rules
that can produce the same file. If both rules are pattern
rules, then the one that occurs later <br>
in the makefile is actually used. If one rule is a pattern
rule, and the other is an explicit rule (one that actually
names the target file explicitly), then the explicit rule
<br>
is used. This is often helpful if you want to compile most
modules with the same command, but there is one module that
needs slightly different compilation options, as shown in
<br>
this makefile fragment:</p>

<p style="margin-top: 1em">CXXFLAGS := -g -O2 <br>
FAST_CXXFLAGS := -DNO_DEBUG -O6 -malign-double
-funroll-all-loops</p>

<p style="margin-top: 1em">%.o: %.cpp <br>
$(CXX) $(CXXFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">time_critical_subs.o:
time_critical_subs.cpp <br>
$(CXX) $(FAST_CXXFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">There is also another syntax
that can be more convenient for affecting compilation
options for just one or a few targets. It is possible to
tell makepp that a variable should <br>
have a different value for certain specific targets. In this
example, it would look like this:</p>

<p style="margin-top: 1em">CXXFLAGS := -g -O2 <br>
FAST_CXXFLAGS := -DNO_DEBUG -O6 -malign-double
-funroll-all-loops</p>

<p style="margin-top: 1em">%.o: %.cpp <br>
$(CXX) $(CXXFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">time_critical_subs.o: CXXFLAGS
:= $(FAST_CXXFLAGS)</p>

<p style="margin-top: 1em">In general, if you specify a
variable name after a list of targets, then it takes a
different value when the build command for those targets is
being determined.</p>

<p style="margin-top: 1em">If you find yourself wanting to
do something with patterns that isn&rsquo;t expressed easily
using the &quot;%&quot; wildcard, makepp has another syntax
which is somewhat harder to read, but <br>
considerably more powerful. See the foreach clause in rules
for more details.</p>

<p style="margin-top: 1em">Makepp actually has builtin
rules for compiling C or C++ or Fortran code, which are
available if you don&rsquo;t override them with your own
rules. The builtin rules are almost <br>
identical to the examples above. Most makefiles contain
pattern rules for compilation, but you can depend on the
builtin rules if you want.</p>

<p style="margin-top: 1em">Phony targets <br>
Often it is convenient to put commands into the makefile
that don&rsquo;t actually build a file, but are somehow
logically associated with the build process. For example, a
very <br>
common procedure in makefiles is something like this:</p>

<p style="margin-top: 1em">prefix=/usr/local</p>

<p style="margin-top: 1em">install: our_program <br>
&amp;install -m 0755 our_program $(prefix)/bin <br>
&amp;install -m 0644 $(wildcard *.png)
$(prefix)/share/our_program/icons</p>

<p style="margin-top: 1em">.PHONY: install</p>

<p style="margin-top: 1em">When someone types &quot;makepp
install&quot;, then makepp first builds
&quot;our_program&quot;, then runs the commands associated
with the install target. The &quot;install&quot; command
simply copies its <br>
arguments to the specified directory, and sets the
file&rsquo;s protection to the indicated value. So it copies
our_program into /usr/local/bin, and some associated data
files into <br>
/usr/local/share/our_program/icons. But this doesn&rsquo;t
create a file called &quot;install&quot; in the current
directory.</p>

<p style="margin-top: 1em">The command itself,
&amp;install, is preceded by an ampersand. This means that
it is not a Shell command, but a similar builtin command.
(You see the difference in that you need <br>
the &quot;$(wildcard)&quot; function, because the Shell is
not expanding it for you.) Makepp has quite a few of these,
both for portability reasons -- &quot;install&quot;, when it
is at all <br>
present, differs wildly, and even trivial commands like
&quot;echo&quot; do -- and performance. See the builtin
commands for more details.</p>

<p style="margin-top: 1em">The &quot;install&quot; target
here is called a phony target because makepp treats it as if
it were a real file, but it is not actually a file,
it&rsquo;s just a trick for forcing makepp to <br>
build its dependencies and then run some commands.</p>

<p style="margin-top: 1em">That&rsquo;s what the line</p>

<p style="margin-top: 1em">.PHONY: install</p>

<p style="margin-top: 1em">is for. It tells makepp that it
really shouldn&rsquo;t expect the file &quot;./install&quot;
to exist after the commands have executed. If you forget the
phony declaration, then makepp will <br>
expect the file &quot;install&quot; to exist after executing
the commands, and it will complain loudly if it does
not.</p>

<p style="margin-top: 1em">You can also write the phony
declaration like this: <br>
$(phony install): our_program <br>
...</p>

<p style="margin-top: 1em">and then omit the &quot;.PHONY:
install&quot; line. This means that you can declare the
target as phony on the same line as you define it, which may
make your makefiles more readable.</p>

<p style="margin-top: 1em">Phony targets are extremely
common in makefiles. In almost all makefiles, the first
target is the phony target &quot;all&quot;, like this:</p>

<p style="margin-top: 1em">$(phony all): program1 program2
program3</p>

<p style="margin-top: 1em">If no target is specified on the
command line, makepp attempts to build the first target in
the file. If your makefile makes more than just one program,
you most likely want to <br>
build all of the programs by default. In this example, if
the programmer just types &quot;makepp&quot; without any
arguments, makepp attempts to build &quot;all&quot;, which
forces it to build all <br>
three programs from this directory.</p>

<p style="margin-top: 1em">Here is a sample makefile
fragment that illustrates some commonly used phony
targets:</p>

<p style="margin-top: 1em">PROGRAMS := combobulator
discombobulator</p>

<p style="margin-top: 1em">$(phony all): $(PROGRAMS) # All
is the first target, so it&rsquo;s the default.</p>

<p style="margin-top: 1em">combobulator:
$(COMBOBULATOR_OBJS) <br>
$(CXX) $(inputs) -o $(output)</p>

<p style="margin-top: 1em">discombobulator:
$(DISCOMBOBULATOR_OBJS) <br>
$(CXX) $(inputs) -o $(output)</p>

<p style="margin-top: 1em"># <br>
# This target makes sure everything is compiled, and then
puts the <br>
# programs into a place where everyone can access them. We
make the <br>
# directories if they don&rsquo;t exist yet. We don&rsquo;t
use &amp;mkdir, because <br>
# &amp;install keeps track of everything it does, so
&amp;uninstall can later <br>
# undo this. <br>
# <br>
prefix := /usr/local</p>

<p style="margin-top: 1em">$(phony install): all <br>
&amp;install -d $(prefix)/bin $(prefix)/share/combobulate
<br>
&amp;install -m 0755 $(PROGRAMS) $(prefix)/bin <br>
&amp;install -m 0644 $(wildcard *.xbm)
$(prefix)/share/combobulate</p>

<p style="margin-top: 1em"># <br>
# This target makes a source distribution for shipping out
to someone. <br>
# <br>
VERSION := 3.14</p>

<p style="margin-top: 1em">$(phony distribution): <br>
rm -rf combobulate-$(VERSION) # Get rid of previous junk, if
any. <br>
&amp;mkdir combobulate-$(VERSION) <br>
&amp;cp -l $(wildcard *.c *.h) Makefile README INSTALL
combobulate-$(VERSION) <br>
tar cf - combobulate-$(VERSION) | gzip -9c &gt;
combobulate-$(VERSION).tar.gz <br>
rm -rf combobulate-$(VERSION)</p>

<p style="margin-top: 1em"># <br>
# This target runs regression tests to make sure the
program(s) are <br>
# doing what they are supposed to do. <br>
# <br>
$(phony test): $(PROGRAMS) <br>
noecho for testfile in *.test; do ./combobulate $$testfile |
./discombobulate - &gt; junk_output; if cmp -s junk_output
$$testfile; then echo passed $$testfile; else echo failed
$$testfile; fi; done <br>
# <br>
# If &quot;noecho&quot; is the first word of the action, the
action itself is not <br>
# printed before it is executed. In this case, printing the
action <br>
# would merely clutter up the screen so it is very common to
suppress <br>
# printing for such long commands. <br>
# <br>
# Note the use of the double dollar sign to pass a single
dollar sign to <br>
# the shell. Note also the backslashes at the end of a line
to indicate <br>
# that a shell command continues to the next line. <br>
#</p>

<p style="margin-top: 1em">Working with several directories
<br>
If your program grows to a substantial size, or if it uses
libraries that need to be built but should be kept separate,
it is quite likely that you have split up your sources <br>
into several directories. One of the main motivations for
writing makepp was to make dealing with several directories
much easier than with the standard make utility. If
you&rsquo;re <br>
familiar with the standard Unix make, you&rsquo;ll notice
that with makepp, you don&rsquo;t have to mess around with
ugly complexities like recursive invocations of make.</p>

<p style="margin-top: 1em">With makepp, you simply put a
separate makefile in each directory that builds the relevant
files in that directory. When a makefile refers to files
whose build commands are in <br>
different makefiles, makepp automatically finds the
appropriate build rules in the other makefiles. All actions
in each makefile are executed with the current directory set
to <br>
be the directory containing the makefile, so each makefile
can be written independently of all the others. No makefile
has to know anything about the other makefiles; it does <br>
not even have to tell makepp to load the rules from those
other makefiles.</p>

<p style="margin-top: 1em">When you&rsquo;ve written your
makefiles, cd to the directory that contains your main
program, and type &quot;makepp&quot; just like you usually
would. Makepp will load in the makefile from <br>
that directory. It will notice that this makefile refers to
files in other directories, and it will examine those other
directories to see if there is a makefile in them. In <br>
this way, all relevant makefiles will be loaded.</p>

<p style="margin-top: 1em">As a simple example, suppose
your top level directory contains the following makefile
(suggested name is &quot;RootMakeppfile&quot;, but
&quot;Makeppfile&quot; will also work):</p>

<p style="margin-top: 1em"># Top level makefile:</p>

<p style="margin-top: 1em">CXX := c++ <br>
CXXFLAGS := -O2 <br>
my_program: main.o goodies/libgoodies.so <br>
$(CXX) $(inputs) -o $(output)</p>

<p style="margin-top: 1em">%.o: %.cxx <br>
$(CXX) $(CXXFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">You would need to write a
makefile in the directory &quot;goodies&quot; which builds
&quot;libgoodies.so&quot;, like this:</p>

<p style="margin-top: 1em"># goodies/Makefile</p>

<p style="margin-top: 1em">CXX := c++ <br>
CXXFLAGS := -O2</p>

<p style="margin-top: 1em">MODULES = candy.o chips.o
licorice.o cookies.o popcorn.o spinach.o</p>

<p style="margin-top: 1em">libgoodies.so: $(MODULES) <br>
$(CXX) -shared $(inputs) -o $(output) <br>
# Note that the command is written assuming that <br>
# the current directory is the subdirectory <br>
# &quot;goodies&quot;, not the top level subdirectory. <br>
# Makepp cds into this directory before executing <br>
# any commands from this makefile.</p>

<p style="margin-top: 1em">%.o: %.cxx <br>
$(CXX) $(CXXFLAGS) -fpic -c $(input) -o $(output)</p>

<p style="margin-top: 1em">And that&rsquo;s all you need to
do.</p>

<p style="margin-top: 1em">Any variables which you specify
on the command line override the definition of the variable
in all makefiles. Thus, for example, if you type
&quot;makepp CXXFLAGS=&quot;-g&quot;&quot;, all modules <br>
will be recompiled for debug because the definition of
&quot;CXXFLAGS&quot; in both makefiles is overridden.</p>

<p style="margin-top: 1em">The directories containing other
sources need not be subdirectories of the top-level
directory (as they are in this example). They can be
anywhere in the file system; makepp <br>
will automatically load a makefile from any directory that
contains a file which is a dependency of some target it is
trying to build. It will also load a makefile from any <br>
directory that is scanned by a wildcard.</p>

<p style="margin-top: 1em">Automatic loading works if files
built by your makefile all reside in the same directory as
the makefile itself. If you write your makefile so that its
rules produce files in a <br>
different directory than the makefile itself, then you might
have to tell makepp where to look for the makefiles, since
it doesn&rsquo;t have any way of guessing. You can do this
<br>
using the &quot;load_makefile&quot; statement in your
makefile. For more information about this and other issues
related to multi-directory builds, see &quot;Tips for
multiple directories&quot; in <br>
makepp_cookbook.</p>

<p style="margin-top: 1em">One caveat: if you reference the
variable &quot;$(MAKE)&quot; in your makefile, makepp
automatically goes into backward compatibility mode and
turns off automatic loading.</p>

<p style="margin-top: 1em">Template or boilerplate
files</p>

<p style="margin-top: 1em">Makepp has several other
features which make life slightly easier for programmers who
have to maintain a program spanning several directories. In
the above examples, you&rsquo;ll <br>
notice that the definitions of the variables &quot;CXX&quot;
and &quot;CXXFLAGS&quot; have to be repeated in each
makefile. It can be a nuisance to reenter the same
information into every makefile, <br>
and it could be a problem if you ever decide to change
it--you may have to modify dozens of different
makefiles.</p>

<p style="margin-top: 1em">What you can do instead is to
put all of the information that&rsquo;s common to each
makefile into a separate file, located perhaps at the top of
the directory tree. Common <br>
information usually includes variable definitions, and
sometimes also pattern rules. (In the above example,
however, the pattern rules are not the same in both
makefiles.) <br>
Let&rsquo;s suppose you&rsquo;ve called this file
&quot;standard_defs.mk&quot;. Then each makefile simply
needs to contain a statement like this:</p>

<p style="margin-top: 1em">include standard_defs.mk</p>

<p style="margin-top: 1em">When makepp sees this statement,
it inserts the contents of the file into the makefile at
that point. The &quot;include&quot; statement first looks
for the file in the current directory, <br>
then in the parent of the current directory, and so on up to
the top level of the file system, so you don&rsquo;t
actually need to specify &quot;../standard_defs.mk&quot; or
<br>
&quot;../../../../standard_defs.mk&quot;.</p>

<p style="margin-top: 1em">So we could rewrite the above
makefiles to look like this. &quot;standard_defs.mk&quot;
would exist in the top level directory, and it might contain
the following definitions:</p>

<p style="margin-top: 1em"># standard_defs.mk <br>
CXX := c++ <br>
CXXFLAGS := -O2</p>

<p style="margin-top: 1em"># <br>
# We&rsquo;ve also included a pattern rule that might be
useful in one or more <br>
# subdirectories. This pattern rule is for C compilation for
putting <br>
# things into a shared library (that&rsquo;s what the -fpic
option is for). <br>
# <br>
%.o: %.cxx <br>
$(CXX) $(CXXFLAGS) -fpic -c $(input) -o $(output)</p>

<p style="margin-top: 1em">Note that since the included
file is actually inserted into each makefile, rules in the
included file are applied with the default directory set to
the directory containing the <br>
makefile that included the file, not the directory
containing the include file.</p>

<p style="margin-top: 1em">The top level
&quot;Makefile&quot; might look like this:</p>

<p style="margin-top: 1em"># Top level makefile <br>
include standard_defs.mk</p>

<p style="margin-top: 1em">my_program: main.o
goodies/libgoodies.so <br>
$(CXX) $(inputs) -o $(output)</p>

<p style="margin-top: 1em"># <br>
# Note that this pattern rule overrides the one found in
standard_defs.mk, <br>
# because makepp sees it later. This pattern rule is for
compilation for <br>
# a module that doesn&rsquo;t belong in a shared library.
<br>
# <br>
%.o: %.cxx <br>
$(CXX) $(CXXFLAGS) $(input) -o $(output)</p>

<p style="margin-top: 1em">And the subdirectory&rsquo;s
makefile might look like this:</p>

<p style="margin-top: 1em"># goodies/Makefile <br>
include standard_defs.mk</p>

<p style="margin-top: 1em">MODULES = candy.o chips.o
licorice.o cookies.o popcorn.o spinach.o</p>

<p style="margin-top: 1em">libgoodies.so: $(MODULES) <br>
$(CXX) -shared $(inputs) -o $(output)</p>

<p style="margin-top: 1em"># We don&rsquo;t need the
pattern rule for compilation of .cxx to .o files, <br>
# because it&rsquo;s contained in standard_defs.mk.</p>

<p style="margin-top: 1em">The -F compilation option</p>

<p style="margin-top: 1em">If you run makepp from within an
editor such as emacs, and you are editing sources from
several different directories, you may find that the default
directory for makepp differs <br>
depending on which file you were most recently editing. As a
result, makepp may not load the correct makefile.</p>

<p style="margin-top: 1em">What you can do to ensure that
makepp always loads the correct makefile(s), no matter what
directory happens to be your current directory, is to use
the &quot;-F&quot; command line option, <br>
like this:</p>

<p style="margin-top: 1em">makepp -F ~/src/my_program</p>

<p style="margin-top: 1em">Makepp will first cd to the
directory &quot;~/src/my_program&quot; before it attempts to
load a makefile.</p>

<p style="margin-top: 1em">Using Wildcards <br>
Up until this point, we&rsquo;ve had to explicitly list all
of the modules that go into a program or a library. The
previous makefile, for example, contained this line:</p>

<p style="margin-top: 1em">MODULES = candy.o chips.o
licorice.o cookies.o popcorn.o spinach.o</p>

<p style="margin-top: 1em">libgoodies.so: $(MODULES) <br>
$(CXX) -shared $(inputs) -o $(output)</p>

<p style="margin-top: 1em">In this case, listing all of the
modules that go into &quot;libgoodies.so&quot; is not such a
big deal since there aren&rsquo;t very many of them. But
sometimes it can be a real nuisance to <br>
list all of the object files, especially if this list is
changing rapidly during development. Frequently, you want
every single module in the whole directory to be compiled
into <br>
your program or library. It would be a lot easier if you
could just tell makepp to do that without listing them
all.</p>

<p style="margin-top: 1em">Well, you can. The above lines
could be rewritten as:</p>

<p style="margin-top: 1em">libgoodies.so: *.o <br>
$(CXX) -shared $(inputs) -o $(output)</p>

<p style="margin-top: 1em">The &quot;*.o&quot; wildcard
matches any existing &quot;.o&quot; files, or any
&quot;.o&quot; files which do not yet exist but can be made
by any of the rules that makepp knows about from any
makefiles that <br>
it has read. So the wildcard will return the same list of
files, no matter whether you haven&rsquo;t compiled anything
yet, or whether all the modules have been compiled
before.</p>

<p style="margin-top: 1em">Of course, if you contaminate
your directories with extra files that shouldn&rsquo;t be
compiled directly into your library, (e.g., if you write
little test programs and leave them in <br>
same directory as the library source files), then these
modules will be incorrectly included into your library. If
you choose to use wildcards, it&rsquo;s up to you to keep
the <br>
directory clean enough.</p>

<p style="margin-top: 1em">Makepp supports the usual Unix
wildcards and one additional one:</p>

<p style="margin-top: 1em">&quot; *&quot; <br>
Matches any string of 0 or more characters. It will not
match the &quot;/&quot; character. For example,
&quot;a*c&quot; matches &quot;ac&quot;, &quot;abc&quot;, and
&quot;aaaaabc&quot;, but not &quot;aa/bc&quot;.</p>

<p style="margin-top: 1em">&quot;?&quot; Matches exactly
one character (not including &quot;/&quot;). For example,
&quot;???.o&quot; matches all filenames that have 3
characters before the &quot;.o&quot; extension.</p>

<p style="margin-top: 1em">[chars] <br>
Matches any of a list of characters at that position. For
example, &quot;[abc].o&quot; matches &quot;a.o&quot;,
&quot;b.o&quot;, &quot;c.o&quot;, but not &quot;abc.o&quot;
or &quot;d.o&quot;. You can also specify a range of <br>
characters, e.g., &quot;data_[0-9]&quot; will match
&quot;data_0&quot;, &quot;data_1&quot;, etc.</p>

<p style="margin-top: 1em">&quot; **&quot; <br>
This is a special wildcard, found only in makepp (and the
zsh shell, from which I stole the idea, as bash has done
since). It matches any number of intervening directories.
<br>
For example, &quot;**/*.o&quot; matches &quot;xyz.o&quot;,
&quot;test_programs/abc.o&quot;, and
&quot;a/deeply/nested/subdirectory/def.o&quot;.</p>

<p style="margin-top: 1em">If your sources are contained in
several subdirectories, and you want to link all the object
modules together, you could write it like this:</p>

<p style="margin-top: 1em">liboodles.so: **/*.o <br>
$(CXX) -shared $(inputs) -o $(output)</p>

<p style="margin-top: 1em">Functions and Advanced Variable
Usage <br>
Makepp has a number of extremely powerful ways of
manipulating text. This tutorial shows a few of the more
useful ways, but you might want to glance through
makepp_variables and <br>
makepp_functions for a more complete list.</p>

<p style="margin-top: 1em">Lists of corresponding files</p>

<p style="margin-top: 1em">A common problem in makefiles is
the maintenance of two lists of files which correspond.
Consider the following two variables:</p>

<p style="margin-top: 1em">SOURCES := a.cpp bc.cpp def.cpp
<br>
OBJS := a.o bc.o def.o</p>

<p style="margin-top: 1em">We might want to have a list of
sources if the makefile can build source distributions, and
we might need a list of objects for the link command.
It&rsquo;s tedious to change both <br>
lines whenever a new module is added, and it&rsquo;s not
unlikely that a programmer will change one line and forget
to change the other. Here we will show four different ways
to avoid <br>
the duplication.</p>

<p style="margin-top: 1em">The patsubst function <br>
The first is to use makepp&rsquo;s functions to convert one
list into another. A function invocation looks a little like
a variable, except that a function can take arguments:</p>

<p style="margin-top: 1em">$(function arg1 arg2 arg3
...)</p>

<p style="margin-top: 1em">Makepp supplies many powerful
functions, but probably the most useful of them is the
&quot;patsubst&quot; function. You could write the above
lines like this:</p>

<p style="margin-top: 1em">SOURCES = a.cpp bc.cpp def.cpp
<br>
OBJS = $(patsubst %.cpp, %.o, $(SOURCES))</p>

<p style="margin-top: 1em">The &quot;patsubst&quot;
function applies a pattern to every word in a list of words,
and performs a simple textual substitution. Any words in the
list that match the pattern in the <br>
first argument are put into the output after making the
substitution indicated by the second argument. The
&quot;%&quot; wildcard matches any string of 0 or more
characters. In this <br>
example, the pattern &quot;%.cpp&quot; is applied to every
word in &quot;$(SOURCES)&quot;. The first word,
&quot;a.cpp&quot; matches the pattern, and the &quot;%&quot;
wildcard matches the string &quot;a&quot;. The &quot;%&quot;
in <br>
the second argument is then replaced by &quot;a&quot;, and
the result is &quot;a.o&quot;. For the second argument,
&quot;%&quot; matches &quot;bc&quot;, so the result is
&quot;bc.o&quot;.</p>

<p style="margin-top: 1em">Makepp&rsquo;s functions can
strip directory names, remove extensions, filter out
matching words, return the output from shell commands, and
other useful tricks. In addition, you <br>
can also write your own functions in perl that can be called
from other parts of the makefile. See makepp_extending for
details.</p>

<p style="margin-top: 1em">Substitution references <br>
Since the &quot;patsubst&quot; function is so common, there
is an abbreviated syntax for it called a substitution
reference. We could have written the above lines like
this:</p>

<p style="margin-top: 1em">SOURCES = a.cpp bc.cpp def.cpp
<br>
OBJS = $(SOURCES:%.cpp=%.o) <br>
OBJS = $(SOURCES:.cpp=.o) # Shorthand, when both begin with
%.</p>

<p style="margin-top: 1em">rc-style substitution <br>
Sometimes invocations of &quot;patsubst&quot; or the
equivalent substitution references can be somewhat cryptic.
Makepp provides another option which is sometimes more
convenient: rc- <br>
style substitution (so called because it was pioneered by
the rc shell).</p>

<p style="margin-top: 1em">MODULES := a bc def <br>
SOURCES := $(MODULES).cpp <br>
OBJS := $(MODULES).o</p>

<p style="margin-top: 1em">What happened here is that when
it evaluated &quot;$(MODULES).cpp&quot;, makepp appended
&quot;.cpp&quot; to every word in &quot;$(MODULES)&quot;,
and similarly for &quot;$(MODULES).o&quot;. In general, any
<br>
characters preceding the &quot;$(variable)&quot; (up to a
word delimiter) are placed before each word in
&quot;$(variable)&quot;, and any characters following
&quot;$(variable)&quot; are placed after each <br>
word in &quot;$(variable)&quot;. Thus the result of
evaluating &quot;x$(MODULES)y&quot; would be &quot;xay xbcy
xdefy&quot;.</p>

<p style="margin-top: 1em">Inline Perl code <br>
If you know Perl, you can insert Perl code to perform
arbitrary manipulations on variables into your makefile.
This is best illustrated by an example:</p>

<p style="margin-top: 1em">SOURCES := a.cpp bc.cpp def.cpp
<br>
perl_begin <br>
($OBJS = $SOURCES) =~ s/.cpp/.o/g; <br>
perl_end</p>

<p style="margin-top: 1em">Any text between the
&quot;perl_begin&quot; statement and the
&quot;perl_end&quot; statement is passed off to the perl
interpreter. You can also use an equivalent more perlish
syntax of &quot;perl { <br>
... }&quot;. All variables in the makefile (except automatic
variables) are accessible as Perl scalars. Any variables you
set with Perl code will be accessible in the makefile.</p>

<p style="margin-top: 1em">So what the above example does
is to copy the text from $SOURCES to $OBJS, then substitute
each occurrence of &quot;.cpp&quot; with &quot;.o&quot;.</p>

<p style="margin-top: 1em">In this example, using inline
Perl code is probably unnecessary since there are easier and
clearer ways of doing the same manipulation. But the full
power of the perl <br>
interpreter is available if you need it.</p>

<p style="margin-top: 1em">Source/Object Separation and
Variant Builds</p>

<p style="margin-top: 1em">Up to this point all of the
makefiles we have seen put the object files in the same
directory as the source files. This is usually the way
makefiles are written, and it&rsquo;s <br>
certainly the simplest way to do things. However, suppose
you have to compile your program on both a Linux machine and
a Solaris machine. The binaries from the two machines are
<br>
incompatible, of course. Unlike the traditional make, makepp
is smart enough to know that if the last compilation was on
Linux, and the current compilation is on Solaris, a <br>
recompilation of everything is necessary.</p>

<p style="margin-top: 1em">But this still leaves a problem:
when you recompile on Solaris, you wipe out your Linux
binaries. Then when you switch back to Linux, you have to
recompile everything again, <br>
even though the source files that haven&rsquo;t changed.</p>

<p style="margin-top: 1em">A related problem is if you
build your program with several different options. Suppose
for example that you usually compile your program with
optimization:</p>

<p style="margin-top: 1em">CFLAGS := -O2</p>

<p style="margin-top: 1em">%.o: %.c <br>
$(CC) $(CFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">my_program: *.o <br>
$(CC) $(inputs) -o $(output)</p>

<p style="margin-top: 1em">However, you discover a bug, and
you want to enable debugging on all files, so you do change
&quot;CFLAGS&quot;:</p>

<p style="margin-top: 1em">CFLAGS := -g -DMALLOC_DEBUG</p>

<p style="margin-top: 1em">Makepp realizes that the build
commands have changed, and it needs to recompile everything.
But again, recompiling with debugging enabled wipes out your
old binaries, so if you <br>
want to turn optimization back on, everything must be
recompiled again, even the files that haven&rsquo;t
changed.</p>

<p style="margin-top: 1em">The obvious solution to these
problems is to put the architecture-dependent or
build-variant-dependent files in a separate subdirectory.
There are two basic techniques for doing <br>
this: explicitly specifying an alternate directory, or using
repositories.</p>

<p style="margin-top: 1em">Explicit specifications of
alternate directories</p>

<p style="margin-top: 1em">You could rewrite the rules in
your makefile to dump the objects into a different
directory, like this:</p>

<p style="margin-top: 1em">ARCH ;= $(shell uname
-s)-$(shell uname -m)-$(shell uname -r) <br>
# ARCH becomes the output from the uname commands. <br>
# Sometimes people use only $(shell uname -m), but <br>
# this will be the same for FreeBSD and Linux on an <br>
# x86. The -r is not really useful on Linux, but is <br>
# important for other OSes: binaries for SunOS 5.8 <br>
# typically won&rsquo;t run on SunOS 5.7. Note the ;= which
<br>
# means to evaluate this at most once, when first <br>
# needed. <br>
CFLAGS := -O2 <br>
OBJDIR ;= $(ARCH)-optim</p>

<p style="margin-top: 1em">$(OBJDIR)/%.o: %.c <br>
$(CC) $(CFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">$(OBJDIR)/my_program:
$(OBJDIR)/*.o <br>
$(CC) $(inputs) -o $(output)</p>

<p style="margin-top: 1em">Now when you run makepp,
&quot;ARCH&quot; is automatically set to something different
for each architecture, and all of the objects are placed in
a different directory for each <br>
architecture, so they don&rsquo;t overwrite each other. If
you want to recompile turning on debugging, then you would
have to change both &quot;CFLAGS&quot; and
&quot;OBJDIR&quot;.</p>

<p style="margin-top: 1em">One problem with this approach
is that implicit loading will no longer work. The only place
that makepp knows to look for a makefile when it needs to
build something is in the <br>
directory of the file it&rsquo;s trying to build. If this is
a problem for you, then you can explicitly tell makepp where
to look using the &quot;load_makefile&quot; statement.</p>

<p style="margin-top: 1em">Repositories</p>

<p style="margin-top: 1em">Repositories are a magical way
of using a makefile that is written to put objects in the
same directory, but having makepp automatically put the
objects in a different directory. <br>
Suppose we start with the original makefile above (before we
modified it to put the objects in a different directory),
and we&rsquo;ve been working on Linux so our source
directory is <br>
filled with Linux binaries. When we want to recompile our
code on Solaris instead of Linux, we use the following
command instead of just typing &quot;makepp&quot;:</p>

<p style="margin-top: 1em">% mkdir solaris <br>
% cd solaris <br>
% makepp -R ..</p>

<p style="margin-top: 1em">What the &quot;-R&quot; option
to makepp does in this case is to declare the directory
&quot;..&quot; (which is the original source directory) as a
repository. A repository is just a way of getting <br>
makepp to trick all of the actions into believing that all
files in one directory tree are actually located in a
different directory tree in the file system. In the above
<br>
example, makepp pretends that all the files in
&quot;..&quot; (and all subdirectories of &quot;..&quot;)
are actually in the current directory (and corresponding
subdirectories).</p>

<p style="margin-top: 1em">More precisely, a repository is
a place where makepp looks if it needs to find a file that
doesn&rsquo;t exist in the current directory tree. If the
file exists in the current <br>
directory tree, it is used; if it doesn&rsquo;t exist, but a
file exists in the repository, makepp makes a temporary
symbolic link from the file in the repository to the current
<br>
directory. (A symbolic link is an alias for the original
file. It&rsquo;s like a copy, except that trying to access
the link actually accesses the original file.) The rule
actions <br>
then act on the file in the current directory, but actually
reference the files in the repository.</p>

<p style="margin-top: 1em">In this example, initially we
start off with a blank new directory solaris. (It
doesn&rsquo;t have to be blank, of course, and it
won&rsquo;t be the second time you run makepp.) Makepp is
<br>
run in this directory, and it sees that there is no makefile
there. However, there is a makefile in the repository, so it
links in the one from the repository, and reads it. <br>
The pattern rule in the makefile that converts
&quot;.c&quot; files into &quot;.o&quot; files causes makepp
to link all the &quot;.c&quot; files that it needs from the
repository, and run the compilation <br>
command from the solaris subdirectory. Therefore the
&quot;.o&quot; files are now placed into the solaris
subdirectory, not in the top level directory. When the build
command is <br>
finished, any files linked from the repository are deleted,
so the solaris subdirectory will contain only the binary
files for Solaris. Any &quot;.o&quot; files that exist in
the <br>
repository are unmodified, so when you go back to your Linux
machine and rerun makepp, most of your program will not have
to be recompiled.</p>

<p style="margin-top: 1em">Sometimes it might be more
convenient to use a different form of the repository
command. The above three shell commands could be entirely
replaced by the following one command:</p>

<p style="margin-top: 1em">% makepp -R solaris=. -F
solaris</p>

<p style="margin-top: 1em">What this does is to say that
the files in the current directory are to be linked into the
solaris subdirectory as necessary. (The solaris subdirectory
will be created <br>
automatically if it does not exist.) Then the &quot;-F&quot;
option causes makepp to cd to the solaris directory and
execute the makefile there (which will be linked from the
repository).</p>

<p style="margin-top: 1em">Using a repository does not have
the same drawbacks as explicitly specifying an object
directory; makefiles will be implicitly loaded as expected,
since as far as makepp is <br>
concerned, the makefile actually is in the same directory as
the target files. However, if your build involves not just
one but several directory trees, using repositories can <br>
become quite complicated.</p>

<p style="margin-top: 1em">Repositories are just a way of
pretending that things located at one place in the file
system are actually in a different place for the duration of
the build. This is a very <br>
powerful technique that can be used for more than just
separating your sources and binaries. For more details, see
makepp_repositories.</p>

<p style="margin-top: 1em">Debugging Makefiles <br>
Log File</p>

<p style="margin-top: 1em">If you have a complicated build
procedure, you find that makepp is rebuilding things more
often than you think they need to be rebuilt. Or you may
find that it is not rebuilding <br>
things when it should. You don&rsquo;t have to keep staring
at your makefiles until you see the problem. On every build,
makepp produces a log file that explains which rule it <br>
thought it was supposed to use to build each target, what
files it thought each target depended on, and (if it did
decide to rebuild) why it thought a rebuild was necessary.
<br>
This binary file is viewed makepplog, mppl utility.</p>

<p style="margin-top: 1em">The output format is more or
less self-explanatory. Indentation conveys depth in
makepp&rsquo;s inference tree. Suppose the target is
&quot;all&quot;, and &quot;all&quot; depends on
&quot;my_program&quot;, and <br>
&quot;my_program&quot; depends on &quot;*.o&quot;, which
depend on the corresponding &quot;.c&quot; files. Log
messages related to &quot;all&quot; will not be indented,
log messages related to building the target <br>
&quot;my_program&quot; will be indented two spaces, log
messages related to building any of the object files will be
indented 4 spaces, and log messages related to building any
of the <br>
source files will be indented 6 spaces.</p>

<p style="margin-top: 1em">If you&rsquo;re doing a parallel
make (using the &quot;-j&quot; command line option), the
order of the messages in the log file will not make nearly
as much sense since messages from different <br>
targets will be interspersed. You might try debugging a
serial make first.</p>

<p style="margin-top: 1em">Common errors in makefiles</p>

<p style="margin-top: 1em">Not specifying all dependencies
<br>
Makepp is designed to be extremely clever about finding
dependencies, and if you just use a standard Unix C or C++
compiler command, it is actually somewhat difficult to get
<br>
makepp to miss something. (Please send me examples if you
find that it missed something, so I can make makepp
smarter.) However, if you are running commands other than
<br>
compilation, or dealing with languages other than C or C++,
it is much easier to run into problems.</p>

<p style="margin-top: 1em">If you don&rsquo;t tell makepp
all of the dependencies of a file, and it can&rsquo;t infer
them by parsing the command line or scanning the files for
includes, then it may not rebuild a <br>
file when it should. You can make this kind of error less
likely by using only automatic variables in your actions,
rather than repeating the dependency lists. For example,</p>

<p style="margin-top: 1em">combined_file: a b c <br>
do_something a b c d &gt; combined_file</p>

<p style="margin-top: 1em">has an error because d is
mentioned in the action but not in the dependency list. If
the command had been written using automatic variables like
this:</p>

<p style="margin-top: 1em">combined_file: a b c d <br>
do_something $(inputs) &gt; combined_file</p>

<p style="margin-top: 1em">then it would have been
impossible to make this mistake.</p>

<p style="margin-top: 1em">Another way that a missing
dependency can occur is if a program actually uses a file
but doesn&rsquo;t take the file&rsquo;s name on the command
line. For example, if you&rsquo;re compiling <br>
Fortran code, makepp at the moment doesn&rsquo;t know how to
scan for included files. Thus you must explicitly list any
files that are included.</p>

<p style="margin-top: 1em">One thing that is sometimes
helpful for testing is to start with a completely clean
directory--just the bare minimum you think should be
necessary--and rebuild absolute <br>
everything from scratch. This can be most conveniently done
by using repositories, like this:</p>

<p style="margin-top: 1em">% rm -rf test-build-dir <br>
% makepp -R test-build-dir=. -F test-build-dir</p>

<p style="margin-top: 1em">If the build fails because some
file is not present, it means that makepp didn&rsquo;t
realize some file was a dependency, because it only links
files from the repository that it <br>
thought were needed. Performing this test occasionally may
save hours of debugging later. I have worked on projects
where this was never done for months because <br>
recompilation took so long. As a result, many little
problems crept in. There were some object files that
didn&rsquo;t have source files any more, some source files
that were <br>
never properly rebuilt by a preprocessing command, etc.</p>

<p style="margin-top: 1em">Of course, this won&rsquo;t
catch all missing dependencies, but it will catch some of
them.</p>

<p style="margin-top: 1em">Not specifying all targets <br>
You must specify all files that a given command modifies as
targets, or else makepp may not have realized they have
changed. You can specify more than one target. For <br>
example,</p>

<p style="margin-top: 1em">y.tab.h y.tab.c: parse.y <br>
yacc -d parse.y</p>

<p style="margin-top: 1em">If you had forgotten to specify
y.tab.h as a target, then makepp would not know to rebuild
y.tab.h using this command, and files that depend on y.tab.h
might not be <br>
recompiled after the yacc command is run.</p>

<p style="margin-top: 1em">Please suggest things that you
have found confusing or dangerous, and I&rsquo;ll either
note them or try to fix makepp so they aren&rsquo;t a danger
any more.</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
MAKEPP_TUTORIAL(1)</p>
<hr>
</body>
</html>
