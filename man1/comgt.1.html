<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:59:53 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>comgt(1) General Commands Manual comgt(1)</p>

<p style="margin-top: 1em">NAME <br>
comgt - Option GlobeTrotter GPRS/EDGE/3G/HSDPA and Vodafone
3G/GPRS datacard control tool</p>

<p style="margin-top: 1em">SYNOPSIS <br>
comgt -d device -ehstvVx script</p>

<p style="margin-top: 1em">OPTIONS <br>
-d device <br>
set the device to be used to communicate with the data-card.
If not specified then comgt trys /dev/noz2, /dev/ttyUSB2 and
then /dev/modem</p>

<p style="margin-top: 1em">-e <br>
turn on serial communications echo.</p>

<p style="margin-top: 1em">-h <br>
display summary help and exit.</p>

<p style="margin-top: 1em">-s <br>
don&Acirc;&acute;t run the internal default script before an
external script.</p>

<p style="margin-top: 1em">-t <br>
change to an alternate line terminator (default
&quot;0).</p>

<p style="margin-top: 1em">-v <br>
run in verbose mode. This traces scripts as they are
executed. It is intended to help in debugging scripts.</p>

<p style="margin-top: 1em">-V <br>
Print Version information.</p>

<p style="margin-top: 1em">-x <br>
for internal and external scripts, any reference to 115200
baud is converted to 57600. This is useful for data cards
that don&rsquo;t like 115200 baud such as the Glo&acirc;
<br>
beTrotter EDGE.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
comgt is a scripting language interpreter useful for
establishing communications on serial lines and through
PCMCIA modems as well as GPRS and 3G datacards.</p>

<p style="margin-top: 1em">comgt has some features that are
rarely found in other utilities of the same type.</p>

<p style="margin-top: 1em">Features <br>
- Pre-defined built-in scripts for 2G/3G datacard control
<br>
- Simple, BASIC-like script language. <br>
- Command-line and file sourcing of script. <br>
- Multi-response waitfor. <br>
- waitquiet permits line stabilization. <br>
- In-line text capture. <br>
- Multi-process support: fork, wait, kill, exit. <br>
- Debugging verbose and log output. <br>
- logging to file. <br>
- Flow control: goto, gosub, return, if, else. <br>
- Low-impact on system resources. <br>
- Time commands and functions. <br>
- String manipulations. <br>
- Environment manipulation: env(), putenv. <br>
- External utilities system calls: system, exec.</p>

<p style="margin-top: 1em">Supported GPRS and 3G datacards
<br>
comgt has been tested against GlobeTrotter GPRS,EDGE, Combo
EDGE, 3G, 3G EDGE, HSDPA and GlobeTrotter Fusion as well as
Vodafone 3G. It can set the PIN and display information <br>
about datacards before a PPP connection is started.
Additionally, because the GlobeTrotter and Vodafone 3G/GPRS
datacard have a secondary serial interface, these datacards
can <br>
be monitored while a PPP connection is in existence and
transferring data.</p>

<p style="margin-top: 1em">comgt is primarily designed to
work with the GlobeTrotter range of datacards but should be
compatible with any other GPRS or 3G datacard provided its
interface is implemented as <br>
one or more serial or USB serial devices and it is
controlled and queried by an implementation of the Hayes
command interface with the same AT command extensions used
by the <br>
listed datacards.</p>

<p style="margin-top: 1em">Using comgt <br>
comgt has only one function: to run a script. This may be
one of a number of &quot;standard&quot; internal scripts or
an external script. Both types of script are invoked in the
same way. <br>
The &quot;standard&quot; scripts are built into comgt and
will work for serially connected modems, built-in modems,
PCMCIA modems as well as the GlobeTrotter GPRS and the
Vodafone 3G/GPRS <br>
datacards. There is a search priority order for scripts -
1)internal, 2)working directory, 3)/etc/comgt</p>

<p style="margin-top: 1em">Built-in scripts <br>
comgt <br>
This runs the default internal script. Running comgt without
any script specified, e.g., comgt -d /dev/ttyS1 it will
check for a PIN and prompt you if it is required. The next
<br>
thing it does is wait for the device to register, it then
reports the signal strength. If you don&Acirc;&acute;t
specify a port with the -d option then /dev/modem is
assumed. If the -s <br>
switch is not used then this default script is run before
any external script.</p>

<p style="margin-top: 1em">comgt help <br>
Lists these and the other options available.</p>

<p style="margin-top: 1em">comgt info <br>
Lists the datacard configuration.</p>

<p style="margin-top: 1em">comgt sig <br>
Prints the signal strength.</p>

<p style="margin-top: 1em">comgt reg <br>
Prints the registration state.</p>

<p style="margin-top: 1em">comgt 3G <br>
Puts a GlobeTrotter 3G/Fusion and Vodafone 3G into 3G
network only mode (UMTS/HSDPA).</p>

<p style="margin-top: 1em">comgt 2G <br>
Puts a GlobeTrotter 3G/Fusion and Vodafone 3G into 2G
network only mode (GSM/GPRS/EDGE).</p>

<p style="margin-top: 1em">comgt 3G2G <br>
Puts a GlobeTrotter 3G/Fusion and Vodafone 3G into 3G
preferred mode (UMTS/HSDPA and GSM/GPRS/EDGE).</p>

<p style="margin-top: 1em">comgt GTEDGE <br>
Use this command to initialise GlobeTrotter EDGE and
GlobeTrotter Combo EDGE cards before doing anything else.
(It switches on the radio).</p>

<p style="margin-top: 1em">comgt USA <br>
Switch to 900/1900 MHz band for USA operation. GlobeTrotter
GPRS datacards only.</p>

<p style="margin-top: 1em">comgt EUROPE <br>
Switch to 900/1800 MHz band for European operation.
GlobeTrotter GPRS datacards only.</p>

<p style="margin-top: 1em">comgt PIN <br>
Test the SIM PIN status and use the environment variable
COMGTPIN as the value .</p>

<p style="margin-top: 1em">comgt APN <br>
Set the APN of the datacard to the value contained in the
COMGTAPN environment variable.</p>

<p style="margin-top: 1em">Custom Scripts <br>
As well as built in scripts you can make your own. The
following script sets a Vodafone 3G datacard or Option
Fusion card&Acirc;&acute;s UMTS mode to GPRS:</p>

<p style="margin-top: 1em">#Set GPRS only mode <br>
set com 115200n81 <br>
set senddelay 0.05 <br>
waitquiet 1 0.2 <br>
send &quot;AT_OPSYS=0^m&quot; <br>
print &quot;Setting GPRS only mode&quot;</p>

<p style="margin-top: 1em">If you saved the above script as
GPRS you would call it like this:</p>

<p style="margin-top: 1em">comgt GPRS</p>

<p style="margin-top: 1em">If you needed to specify the
port as well then do this:</p>

<p style="margin-top: 1em">comgt -d /dev/ttyS1 GPRS</p>

<p style="margin-top: 1em">You can also pass environment
parameters to a comgt script via $env().</p>

<p style="margin-top: 1em">Replacing chat <br>
chat is a utility that comes with the ppp package (for
Linux, anyway) that, with a set of expect-send string
couples, does enough to connect most people to ISPs and
such. While <br>
chat&Acirc;&acute;s use is very simple, it
isn&Acirc;&acute;t very flexible. That&Acirc;&acute;s where
comgt takes over.</p>

<p style="margin-top: 1em">comgt can be used in place of
chat using the same strategy. For example, a pppd line
reading:</p>

<p style="margin-top: 1em">pppd connect &Acirc;&acute;chat
-v &quot;&quot; ATDT5551212 CONNECT &quot;&quot; ogin: ppp
word: whitewater&Acirc;&acute; /dev/cua1 38400 debug crtscts
modem defaultroute</p>

<p style="margin-top: 1em">Would, using comgt, read:</p>

<p style="margin-top: 1em">pppd connect &Acirc;&acute;comgt
-s /root/scripts/isp.scr&Acirc;&acute; /dev/cua1 38400 debug
crtscts modem defaultroute</p>

<p style="margin-top: 1em">And the isp.scr script would
read:</p>

<p style="margin-top: 1em">send &quot;ATDT5551212^m&quot;
<br>
waitfor 60 &quot;ogin:&quot; <br>
send &quot;ppp^m&quot; <br>
waitfor 60 &quot;word:&quot; <br>
send &quot;whitewater^m&quot;</p>

<p style="margin-top: 1em">Of course it then becomes
trivial to make this script a whole lot more functional by
adding code for busy detect, re-dialing, etc...</p>

<p style="margin-top: 1em">Verbose output <br>
When the verbose option is turned on, comgt reports
everthing on the standard error channel. If turned on from
the command line (-v), the output contains 4 sections.</p>

<p style="margin-top: 1em">- Command line argument actions
<br>
These are actions taken because they were specified from the
command line, such as opening a communication device (-d),
etc... For these to be output, you must specify -v as <br>
the first argument.</p>

<p style="margin-top: 1em">- List of arguments <br>
The number and list of arguments passed. This is useful in
case you have a bunch of environment variables or quotes,
back-quotes, backslashes on the command line and
you&Acirc;&acute;re not <br>
sure what the script really sees.</p>

<p style="margin-top: 1em">- Script list <br>
A list of the script to execute. This may be a concatenation
of the default internal script, unless this is suppressed by
the -s option, and a script file. Every line is <br>
listed with its line number and character position.</p>

<p style="margin-top: 1em">- Execution output <br>
List of commands as they are executed. The parser prints the
line its currently on, starting from the exact point where
its at to the end of the line. Multiple command groups <br>
on a single line produce multiple output lines. Verbose
output may be mixed with script output (print, eprint or
lprint.)</p>

<p style="margin-top: 1em">Here&Acirc;&acute;s an
example:</p>

<p style="margin-top: 1em">$ comgt -v -d/dev/cua1 -s
blah.scr <br>
comgt 00:18:46 -&gt; Verbose output enabled <br>
comgt 00:18:46 -&gt; Script file: blah.scr <br>
comgt 00:18:46 -&gt; argc:5 <br>
comgt 00:18:46 -&gt; argv[0]=comgt <br>
comgt 00:18:46 -&gt; argv[1]=-v <br>
comgt 00:18:46 -&gt; argv[2]=-d/dev/cua1 <br>
comgt 00:18:46 -&gt; argv[3]=-s <br>
comgt 00:18:46 -&gt; argv[4]=blah.scr <br>
comgt 00:18:46 -&gt; ---Script--- <br>
1@0000 set com 38400n81 let a=2 <br>
2@0025 print &quot;9x&quot;,a,&quot;=&quot;,9*a,&quot;0 <br>
3@0051 sleep 5 <br>
4@0059 exit 0 <br>
comgt 00:18:46 -&gt; ---End of script--- <br>
comgt 00:18:46 -&gt; @0000 set com 38400n81 let a=2 <br>
comgt 00:18:46 -&gt; @0017 let a=2 <br>
comgt 00:18:46 -&gt; @0025 print
&quot;9x&quot;,a,&quot;=&quot;,9*a,&quot;0 <br>
9x2=18 <br>
comgt 00:18:46 -&gt; @0051 sleep 5 <br>
comgt 00:18:51 -&gt; @0059 exit 0</p>

<p style="margin-top: 1em">Programming manual <br>
Syntax <br>
The syntax used for comgt scripts is rather simple, somewhat
BASIC-like. A script is a non-tokenized, pure ASCII text
file containing lines terminated by newline characters <br>
(Unix standard.) Scripts can be created and/or modified
using any standard text editor (vi, vim, joe, pico, emacs,
ed, microEmacs) Lines in a comgt script read like so:</p>

<p style="margin-top: 1em">- Empty line <br>
- [indent]rem remark <br>
- [indent][[:|label] LABEL] [command [arguments]] rem remark
<br>
- [indent][[:|label] LABEL] [command [arguments]] [command
[arguments]]...</p>

<p style="margin-top: 1em">Characters used for indentation
are the space and tabulation characters. <br>
The rem command makes the script parser skip the rest of the
line. <br>
The rem command can also be written as &quot;#&quot; or
&quot;//&quot;.</p>

<p style="margin-top: 1em">Labels consist of lowercase and
uppercase letters and digits. <br>
Case is ignored in labels.</p>

<p style="margin-top: 1em">Commands and their arguments are
separated by spaces and/or tabs. <br>
Command groups are separated by spaces, tabs, or
newlines.</p>

<p style="margin-top: 1em">Expressions must not contain
spaces or tabs. <br>
This is ok : let n=x+76 <br>
This is not: let n= x + 76 <br>
Because this space ^ would terminate the let command
group.</p>

<p style="margin-top: 1em">Error reporting <br>
When comgt detects a script error, it immediately turns on
verbose mode, generates a dump (see the dump command),
reports the error in three lines and stops the execution.
The <br>
first line reported is the command group being executed, the
second one shows where the parser got and the third line
reports the character position of the program counter, the
<br>
error and the exit code.</p>

<p style="margin-top: 1em">Here&Acirc;&acute;s an
example:</p>

<p style="margin-top: 1em">$ comgt -vs blar2.scr</p>

<p style="margin-top: 1em">Where the blar2.scr script
is:</p>

<p style="margin-top: 1em">inc n <br>
dec d3 <br>
let a=58/3 <br>
let $d=&quot;fod&quot; <br>
let c=1/0 <br>
let $y4=&quot;sdfgsdfgsdfg&quot;</p>

<p style="margin-top: 1em">The trace and error report looks
like this:</p>

<p style="margin-top: 1em">comgt 11:20:15 -&gt; Verbose
output enabled <br>
comgt 11:20:15 -&gt; Script file: blar2.scr <br>
comgt 11:20:15 -&gt; argc:3 <br>
comgt 11:20:15 -&gt; argv[0]=comgt <br>
comgt 11:20:15 -&gt; argv[1]=-vs <br>
comgt 11:20:15 -&gt; argv[2]=blar2.scr <br>
comgt 11:20:15 -&gt; ---Script--- <br>
1@0000 inc n <br>
2@0007 dec d3 <br>
3@0015 let a=58/3 <br>
4@0027 let $d=&quot;fod&quot; <br>
5@0041 let c=1/0 <br>
6@0052 let $y4=&quot;sdfgsdfgsdfg&quot; <br>
comgt 11:20:15 -&gt; ---End of script--- <br>
comgt 11:20:15 -&gt; @0000 inc n <br>
comgt 11:20:15 -&gt; @0007 dec d3 <br>
comgt 11:20:15 -&gt; @0015 let a=58/3 <br>
comgt 11:20:15 -&gt; @0027 let $d=&quot;fod&quot; <br>
comgt 11:20:15 -&gt; @0041 let c=1/0 <br>
comgt 11:20:15 -&gt; -- Error Report -- <br>
comgt 11:20:15 -&gt; ----&gt; ^ <br>
comgt 11:20:15 -&gt; Error @49, line 5, Division by zero.
(6)</p>

<p style="margin-top: 1em">Exit codes <br>
When comgt terminates, it does so with an &quot;exit
code&quot;. That is a number passed back to the calling
process to signify success or failures. In every-day Unix, 0
(zero) means <br>
success and everything else means whatever the author of the
program wants it to mean. In a shell script, or directly on
the command line, you may look at the content of $? <br>
after having called comgt to examine its exit code.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">#!/bin/sh <br>
comgt /root/bin/call-isp <br>
if [ $? != 0 ]; then <br>
echo &quot;Oops! Something went wrong.&quot; <br>
fi</p>

<p style="margin-top: 1em">Internal comgt error codes are
as follows:</p>

<p style="margin-top: 1em">0 : No problems whatsoever.
Apparently. <br>
1 : Communication device problems. <br>
2 : Console (tty) device problems. <br>
3 : Memory problems. <br>
4 : File or pipe problems. <br>
5 : Syntax errors. <br>
6 : Division by zero. <br>
7 : Variable mis-management. <br>
8 : System problems. (Couldn&Acirc;&acute;t call /bin/sh or
some such)</p>

<p style="margin-top: 1em">Commands <br>
Command : : Alias: label <br>
Description : Notes an anchor point for goto or gosub to
branch to. <br>
Syntax : Keyword must not contain any special characters.
<br>
Note : Must be first statement in a line. <br>
See Also : goto, gosub, return. <br>
Example: <br>
:loop <br>
gosub bravo <br>
print &quot;The time is &quot;,$time(),&quot;0 <br>
sleep 1 <br>
goto loop <br>
label bravo <br>
print &quot;Twonk!0 <br>
return</p>

<p style="margin-top: 1em">Command : abort <br>
Description : Causes comgt to call abort() and produce a
core dump. <br>
Syntax : abort <br>
See Also : dump, exit.</p>

<p style="margin-top: 1em">Command : cd <br>
Description : Change directory. <br>
Syntax : cd directory <br>
Notes : -1 is returned in % if the change could not be made.
<br>
Notes : directory is a string and thus could be a variable.
<br>
See Also : $cwd(). <br>
Example: <br>
cd &quot;duh&quot; <br>
if % != 0 print &quot;Could not cd into duh.0</p>

<p style="margin-top: 1em">Command : close <br>
Description : closes file previously opened with open. <br>
Syntax : close file <br>
See Also : open.</p>

<p style="margin-top: 1em">Command : dec <br>
Description : Decrements the content of an integer variable
by 1. <br>
Syntax : dec x <br>
Notes : x is from a to z or a0 to z9. <br>
Notes : Note that &quot;let x=x-1&quot; also works. <br>
See Also : let, inc.</p>

<p style="margin-top: 1em">Command : dump <br>
Description : Lists all non-zero integer variables and
modified string <br>
Description : variables as log entries (standard error
channel.) <br>
Syntax : dump <br>
See Also : abort, exit</p>

<p style="margin-top: 1em">Command : else <br>
Description : Alternatively execute commands if last
&quot;if&quot; tested false. <br>
Syntax : else commands... <br>
See Also : if <br>
Example: <br>
if w&lt;350 print &quot;Wow! Imagine that.0 <br>
else print &quot;Rush Limbaugh is a big fat bastard.0</p>

<p style="margin-top: 1em">Command : eprint <br>
Description : print a comma-separated list of arguments on
stderr. <br>
Syntax : eprint var,stringvar,&quot;text&quot;,... <br>
Notes : Like print but on the standard error file
descriptor. <br>
Notes : The error output can be re-directed with
&quot;2&gt;file&quot; on <br>
Notes : the command line. <br>
See Also : print.</p>

<p style="margin-top: 1em">Command : exec <br>
Description : Replaces current comgt process with another
process. <br>
Syntax : exec &quot;command -args...&quot; <br>
See Also : system, fork. <br>
Example: <br>
#Finished script, call cu. <br>
exec &quot;cu -l &quot;+$dev()+&quot; -s &quot;+$baud()</p>

<p style="margin-top: 1em">Command : exit <br>
Description : terminates script execution with exit code.
<br>
Syntax : exit exit_code <br>
See Also : abort, dump. <br>
Example: <br>
:error <br>
exit 1 <br>
:smeggit <br>
exit 0</p>

<p style="margin-top: 1em">Command : flash <br>
Description : Toggles DTR on communication device for a
specified time. <br>
Syntax : flash float_constant <br>
Notes : float_constant is precise down to 1/100th sec. <br>
Notes : Causes modem to drop carrier or go to command mode,
<br>
Notes : depending on modem settings. Setting the baud rate
to 0 <br>
Notes : for a time has the same effect. <br>
See Also : sleep, set com. <br>
Example: <br>
:disconnect <br>
flash 0.5 <br>
exit 0</p>

<p style="margin-top: 1em">Command : fprint <br>
Description : print a comma-separated list of arguments in a
file. <br>
Syntax : fprint var,stringvar,&quot;text&quot;,... <br>
Notes : Like print but appended to a file previously opened
<br>
Notes : by open. <br>
See Also : print.</p>

<p style="margin-top: 1em">Command : fork <br>
Description : forks comgt process in two. Both processes
continue <br>
Description : executing the script. <br>
Syntax : fork <br>
Notes : % returns 0 for child process, new process ID for
<br>
Notes : parent or -1 for error. <br>
See Also : wait, kill, pid(), ppid(). <br>
Example: <br>
fork <br>
if % = -1 goto error <br>
if % = 0 goto child <br>
:parent <br>
...</p>

<p style="margin-top: 1em">Command : get <br>
Description : get string from communication device. <br>
Syntax : get timeout &quot;terminators&quot; $string <br>
Notes : timeout is a float constant, terminators is a <br>
Notes : list of characters that, when received, terminate
<br>
Notes : get. Terminators are ignored when received first.
<br>
See Also : waitfor. <br>
Example: <br>
waitfor 60 &quot;connect&quot; <br>
if % != 0 goto error <br>
get 2 &quot; ^m&quot; $s <br>
print &quot;Connection parameters: &quot;,$s,&quot;0</p>

<p style="margin-top: 1em">Command : gosub <br>
Description : calls a subroutine. <br>
Syntax : gosub label <br>
Notes : Currently, comgt only supports 128 levels of gosub
<br>
Notes : calls (enough!) <br>
See Also : :, goto, return. <br>
Example: <br>
gosub routine <br>
sleep 1 <br>
gosub routine <br>
goto end <br>
:routine <br>
print &quot;Flim-flam!0 <br>
return</p>

<p style="margin-top: 1em">Command : goto <br>
Description : Sends execution somewhere else in the script.
<br>
Syntax : goto label <br>
See Also : :, gosub, return. <br>
Example: <br>
:win95 <br>
print &quot;Today I want to go and use Linux, thank you.0
<br>
goto win95</p>

<p style="margin-top: 1em">Command : hset <br>
Description : Set the hundreds timer. <br>
Syntax : hset value <br>
Notes : This command resets the hundreds of seconds timer to
<br>
Notes : a value for htime to start from. <br>
See Also : htime(). <br>
Example: <br>
hset 0 <br>
:loop <br>
print &quot;Time in 1/100 of a sec.: &quot;,htime(),&quot;0
<br>
sleep 0.01 <br>
goto loop</p>

<p style="margin-top: 1em">Command : if <br>
Description : tests a condition <br>
Syntax : if test_condition commands... <br>
Notes : Conditionnaly executes commands if test condition is
true. <br>
Notes : Test operators are = (equal), != (not equal), <br>
Notes : &lt;&gt; (not equal to) &lt; (less than), &gt;
(greater than), <br>
Notes : &lt;= (less or equal), &gt;= (greater or equal).
<br>
Notes : All operators can be used with integers and strings.
<br>
Notes : If test_condition is false, if skips to <br>
Notes : the next line. <br>
See Also : else. <br>
Example: <br>
if n&gt;30 print &quot;Oh-ho! too many sheep!0 goto error
<br>
if n=17 print &quot;Hurray! we&Acirc;&acute;ve enough sheep0
goto party <br>
if n&lt;17 print &quot;Murray, get more sheep.0 goto getmore
<br>
if $z &lt; &quot;Marmaluke&quot; goto ... <br>
if 3*a&gt;5+b goto ...</p>

<p style="margin-top: 1em">Command : inc <br>
Description : increments the content of an integer variable
by 1. <br>
Syntax : inc x <br>
Notes : x is a-z or a0-z9. <br>
See Also : dec, let.</p>

<p style="margin-top: 1em">Command : input <br>
Description : input string from keyboard into string
variable. <br>
Syntax : input $x <br>
Notes : input terminates entry only with the ENTER key. <br>
Notes : Spaces, tabs and other funny characters are all <br>
Notes : stored in the variable. <br>
See Also : set echo. <br>
Example: <br>
print &quot;Enter your full name :&quot; <br>
input $n4</p>

<p style="margin-top: 1em">Command : kill <br>
Description : Sends a signal to a process. <br>
Syntax : kill signal processID <br>
Notes : Both signal and processID are integer values. Same
as <br>
Notes : standard unix kill except that signal aliases are
not <br>
Notes : accepted and signal is not optional. <br>
Notes : 0 is returned in % if the signal could be sent, -1
<br>
Notes : otherwise. <br>
Notes : Signal 0 can be used to detect process existance.
<br>
See Also : wait, pid(), ppid(). <br>
Example: <br>
fork <br>
let p=% <br>
if p = 0 goto child <br>
sleep 300 <br>
kill 15 p <br>
sleep 1 <br>
kill 0 p <br>
if % != 0 print &quot;Child terminated0 goto ok <br>
print &quot;Could not terminate child!0 <br>
kill 9 p <br>
sleep 1 <br>
kill 0 p <br>
if % = 0 print &quot;Could not kill child!0 goto error <br>
print &quot;Child killed.0 <br>
:ok <br>
...</p>

<p style="margin-top: 1em">Command : let <br>
Description : Does a variable assignment. <br>
Syntax : let x=content <br>
Notes : x is [$]a0-z9. <br>
See Also : inc, dec. <br>
Example: <br>
let a=5 <br>
let b=(time()-a)+5 <br>
let y7=6809 <br>
let z=0%11010111 #Binary <br>
let z=077324 #octal <br>
let z=0xf5b8 #hexadecimal <br>
let $c=&quot;Daniel &quot; <br>
let $d=$c+&quot; Chouinard&quot; <br>
let $s5=&quot;Frimpin&Acirc;&acute; Jeosaphat!&quot;</p>

<p style="margin-top: 1em">Command : lprint <br>
Description : Print a comma-separated list of arguments to
the log. <br>
Syntax : fprint var,stringvar,&quot;text&quot;,... <br>
Notes : Like print but printed like a log entry if verbose
is on. <br>
Notes : logging is sent to stderr. <br>
See Also : print, eprint, fprint.</p>

<p style="margin-top: 1em">Command : open <br>
Description : Opens a file or a communication device. <br>
Syntax : open com device, open com (stdin), open file FILE
<br>
See Also : close. <br>
Example: <br>
open com /dev/cua1 <br>
set com 38400n81 <br>
open file &quot;/tmp/log&quot; <br>
fprintf &quot;This is a log0 <br>
close file</p>

<p style="margin-top: 1em">Command : print <br>
Description : print a comma-separated list of arguments.
<br>
Syntax : print var,stringvar,&quot;text&quot;,... <br>
Notes : Spaces and newlines are not automatically added.
<br>
See Also : eprint, fprint, lprint. <br>
Example: <br>
let b=26 <br>
let $c=&quot;text variables&quot; <br>
print &quot;Contstant text &quot;,b,&quot; &quot;,$c,&quot;
time: &quot;,$time(),&quot;0</p>

<p style="margin-top: 1em">Command : putenv <br>
Description : Sets an environment variable. <br>
Syntax : putenv &quot;var=content&quot; <br>
Notes : Environment variables are automatically exported,
<br>
Notes : never returned. Children processes inherit the <br>
Notes : environment. <br>
See Also : $env(). <br>
Example: <br>
putenv &quot;SCRIPTDIR=/usr/lib/comgt/scripts&quot; <br>
system &quot;dothat&quot; # dothat reads env. var.
SCRIPTDIR...</p>

<p style="margin-top: 1em">Command : rem Aliases: #, //
<br>
Description : Remark. Rest of line is ignored. <br>
Syntax : Note that a space must follow &quot;rem&quot;. <br>
Example: <br>
#This is a remark <br>
// So is this <br>
rem This ain&Acirc;&acute;t no disco.</p>

<p style="margin-top: 1em">Command : return <br>
Description : Returns from subroutine. <br>
Syntax : return <br>
See Also : gosub.</p>

<p style="margin-top: 1em">Command : send <br>
Description : sends a string to the communication line
(modem usually). <br>
Syntax : send string <br>
Notes : Carriage return (ENTER) is not sent automatically
<br>
Notes : (use ^m). <br>
Example: <br>
send &quot;atdt555-1212^m&quot; <br>
send $g+&quot;^m&quot; <br>
send &quot;The time is &quot;+$time()+&quot;^m^j&quot;</p>

<p style="margin-top: 1em">Command : set <br>
Description : sets working parameters. <br>
Syntax : set parameter value <br>
Notes :</p>

<p style="margin-top: 1em">Command Description <br>
-----------------------------
------------------------------------------------- <br>
set echo on|off Keyboard echo on-screen. <br>
set comecho on|off Received characters echoed on-screen.
<br>
set senddelay time_constant In-between character delay for
&quot;send&quot; <br>
set ignorecase on|off Case sensitivity for
&quot;waitfor&quot;. <br>
Default=on. <br>
set clocal on|off clocal on = ignore modem signals <br>
set umask mode file mode creation defaults. <br>
See man umask. <br>
set verbose on|off verbose on = debug output enabled. <br>
set com com_params communication parameters. <br>
ex.: 19200n81, 300e71 <br>
baud ||| <br>
Parity | <br>
Data bits | <br>
Stop bits |</p>

<p style="margin-top: 1em">Example: <br>
set echo off <br>
print &quot;Password :&quot; <br>
input $p <br>
print &quot;0 <br>
set echo on <br>
set comecho on <br>
set clocal on <br>
set senddelay 0.1 <br>
set ignorecase on <br>
set com 38400n81 <br>
set umask 022 # Must be octal (leading zero) <br>
...</p>

<p style="margin-top: 1em">Note on clocal: <br>
If want your script to keep working after the carrier detect
<br>
signal has dropped, set clocal on, otherwise, a CD drop
causes <br>
the device line to close (hang up). This could happen if,
<br>
let&Acirc;&acute;s say, your script calls and connects, then
disconnects or <br>
drops dtr (flash), then tries to re-connect again.</p>

<p style="margin-top: 1em">Command : sleep <br>
Description : Pauses execution. <br>
Syntax : sleep float_constant <br>
Notes : Float_constant is precise down to 1/100th sec,
unless <br>
Notes : more than 100 seconds, in which case the precision
<br>
Notes : falls down to 1 sec.</p>

<p style="margin-top: 1em">Example: <br>
sleep 0.06 <br>
sleep 3 <br>
sleep 86400 /* A whole day */</p>

<p style="margin-top: 1em">Command : system <br>
Description : Calls a system (unix) command <br>
Syntax : system &quot;command&quot; <br>
See Also : exec. <br>
Example: <br>
:dir <br>
print &quot;listing of directory &quot;,$cwd(),0 <br>
system &quot;ls -l |more&quot;</p>

<p style="margin-top: 1em">Command : testkey <br>
Description : Tests keyboard for keystroke, returns 1 in %
if present. <br>
Syntax : testkey <br>
Notes : Can only test for ENTER key. Future versions of
comgt <br>
Notes : will test for more and return keycodes in %. <br>
See Also : input. <br>
Example: <br>
let n=1 <br>
:loop <br>
print n,&quot; sheep... ZZZzzz...0 <br>
sleep n <br>
inc n <br>
testkey <br>
if % = 0 goto loop</p>

<p style="margin-top: 1em">Command : wait <br>
Description : Wait for a child process to terminate. <br>
Syntax : wait <br>
Notes : Process ID of terminated child is returned in % <br>
See Also : fork, kill. <br>
Example: <br>
fork <br>
let p=% <br>
if p=0 goto child <br>
if p=-1 goto error <br>
print &quot;Waiting for child to finish...&quot; <br>
wait <br>
print &quot;0 <br>
if %!=p print &quot;Wait got wrong PID!0 goto error <br>
print &quot;Child is done.0</p>

<p style="margin-top: 1em">Command : waitfor <br>
Description : Waits until one of a list of strings is
received <br>
Syntax : waitfor timeout
&quot;string1&quot;,&quot;string2&quot;,&quot;string3&quot;...
<br>
Notes : Timeout is a floating time constant. waitquiet
returns <br>
Notes : 0 for the first string received, 1 for the second,
etc... <br>
Notes : and -1 for a timeout. Case is ignored by default
unless <br>
Notes : ignorecase is set to off. <br>
See Also : get. <br>
Example: <br>
:dial <br>
send &quot;atdt555-4411^m&quot; <br>
waitfor 60 &quot;no carrier&quot;,&quot;busy&quot;,&quot;no
dial tone&quot;,&quot;connect&quot; <br>
if % = -1 goto timedout <br>
if % = 0 goto nocd <br>
if % = 1 goto redial <br>
if % = 2 goto error <br>
if % = 3 goto connected</p>

<p style="margin-top: 1em">Command : waitquiet <br>
Description : Waits until communication line stops receiving
for a time. <br>
Syntax : waitquiet timeout quiettime <br>
Notes : Both timeout and quiettime are floating time
constants <br>
Notes : with 1/100th sec. accuracy. Usefull for
&quot;swallowing&quot; <br>
Notes : incoming characters for a while or waiting for an
<br>
Notes : unknown prompt. <br>
Example: <br>
:closecon <br>
send &quot;logoff^m&quot; <br>
waitquiet 10 0.5 <br>
send &quot;yes^m&quot;</p>

<p style="margin-top: 1em">Integer functions <br>
I-Function : Access <br>
Description : Verifies access rights to a file <br>
Syntax : let
x=access(&quot;/tmp/file&quot;,&quot;frwx&quot;) <br>
Notes : The second string contains one or more of <br>
Notes :
&Acirc;&acute;f&Acirc;&acute;,&Acirc;&acute;r&Acirc;&acute;,&Acirc;&acute;w&Acirc;&acute;,&Acirc;&acute;x&Acirc;&acute;
to repectively check <br>
Notes : existence, read, write and execute permissions. <br>
Notes : Under root id, the only useful check is
&Acirc;&acute;f&Acirc;&acute;, as <br>
Notes : all others will return true. <br>
Return Value: 0 if the file exists, is readable, writable,
<br>
Return Value: executable, or -1 if not. <br>
See Also : man access(2)</p>

<p style="margin-top: 1em">I-Function : baud <br>
Description : Returns current baudrate of communication
line. <br>
Syntax : let x=baud() <br>
Notes : Does not necessarily match the modem connection
speed. <br>
See Also : $baud().</p>

<p style="margin-top: 1em">I-Function : len <br>
Description : Returns the length of a string. <br>
Syntax : let x=len($s) <br>
Notes : &quot;&quot; is zero. Strings currently have a
maximum length of <br>
Notes : 1024 characters. comgt doesn&Acirc;&acute;t handle
string overflow <br>
Notes : at all.</p>

<p style="margin-top: 1em">I-Function : htime <br>
Description : Returns hundreds of seconds since start of
script. <br>
Syntax : let x=htime() <br>
Notes : Set to a specific value with hset. <br>
See Also : hset.</p>

<p style="margin-top: 1em">I-Function : pid <br>
Description : Returns process ID number of current process
(comgt) <br>
Syntax : let x=pid() <br>
See Also : ppid(), fork</p>

<p style="margin-top: 1em">I-Function : ppid <br>
Description : Returns process ID number of parent process.
<br>
Syntax : let x=ppid() <br>
Notes : Can be used by forked child to detect parent <br>
Notes : process.</p>

<p style="margin-top: 1em">I-Function : time <br>
Description : Returns time in seconds since Jan 1, 00:00:00
1970 GMT. <br>
Syntax : let x=time() <br>
Notes : Used to calculate time differences. <br>
See Also : $time()</p>

<p style="margin-top: 1em">I-Function : val <br>
Description : Returns value of string. <br>
Syntax : let x=val($x) <br>
Notes : String is not an expression; must only contain [0-9]
<br>
Notes : characters. Future versions of comgt will be able to
<br>
Notes : evaluate expressions. (Maybe) (This was written 6
<br>
Notes : years ago.)</p>

<p style="margin-top: 1em">I-Function : verbose <br>
Description : Returns value of verbose setting. <br>
Syntax : let x=verbose() <br>
Notes : 0=off, 1=on.</p>

<p style="margin-top: 1em">String functions <br>
S-Function : basename <br>
Description : Returns basename part of path. <br>
Syntax : let $x=$basename($p) <br>
Notes :
$basename(&quot;/usr/bin/more&quot;)=&quot;more&quot; <br>
See Also : $dirname().</p>

<p style="margin-top: 1em">S-Function : baud <br>
Description : Returns string representation of current baud
rate. <br>
Syntax : let $x=$baud() <br>
Notes : Defined by &quot;set com&quot; <br>
See Also : baud(), set com.</p>

<p style="margin-top: 1em">S-Function : cwd <br>
Description : Returns current working directory pathname.
<br>
Syntax : let $x=$cwd() <br>
See Also : cd.</p>

<p style="margin-top: 1em">S-Function : dev <br>
Description : Returns current communication device pathname.
<br>
Syntax : let $x=$dev() <br>
Notes : defined by &quot;-d&quot; command line argument or
&quot;open com&quot; <br>
See Also : open com.</p>

<p style="margin-top: 1em">S-Function : dirname <br>
Description : Returns directory name part of path. <br>
Syntax : let $x=$dirname($p) <br>
Notes :
$dirname(&quot;/usr/bin/more&quot;)=&quot;/usr/bin&quot;
<br>
See Also : $basename().</p>

<p style="margin-top: 1em">S-Function : env <br>
Description : Returns content of an environment variable
<br>
Syntax : let $x=$env(&quot;HOME&quot;) <br>
Notes : Non-existant variables return an empty string. <br>
See Also : putenv.</p>

<p style="margin-top: 1em">S-Function : hex <br>
Description : Converts value to hexadecimal representation
<br>
Syntax : let $x=$hex(x) <br>
Notes : Letters a-f in lowercase, no preceding
&quot;0x&quot; <br>
See Also : $hexu(), $oct().</p>

<p style="margin-top: 1em">S-Function : hexu <br>
Description : Converts value to hexadecimal representation
<br>
Syntax : let $x=$hex(x) <br>
Notes : Letters A-F in uppercase, no preceding
&quot;0x&quot; <br>
See Also : $hex(), $oct().</p>

<p style="margin-top: 1em">S-Function : hms <br>
Description : Converts number of seconds into time string
<br>
Syntax : let $x=$hms(x) <br>
Notes : Format is &quot;HH:MM:SS&quot;. Useful for
chronometer displays <br>
Notes : Use with &quot;time()&quot;, do not try to increment
a variable <br>
Notes : every second using &quot;sleep 1&quot;. (See ISP
script example) <br>
Notes : Format becomes &quot;HHH:MM:SS&quot; after 99 hours,
59 minutes, <br>
Notes : 59s... <br>
See Also : time().</p>

<p style="margin-top: 1em">S-Function : left <br>
Description : Returns left portion of a string <br>
Syntax : let $x=$left($s,l) <br>
Notes : $s=Source string, l=length <br>
Notes : l must be less than the length of the string. <br>
See Also : $right(), $mid().</p>

<p style="margin-top: 1em">S-Function : mid <br>
Description : Returns midsection of a string. <br>
Syntax : let $x=$mid($s,s,l) <br>
Notes : $s=Source string, s=start, l=length <br>
Notes : s must be less than the length of the string, l can
be <br>
Notes : some huge number (9999) to return the right side of
a <br>
Notes : string to the end. the first character of a string
is <br>
Notes : position 0, not 1. <br>
See Also : $right(), $left().</p>

<p style="margin-top: 1em">S-Function : oct <br>
Description : Converts value to octal representation. <br>
Syntax : let $x=$oct(x) <br>
See Also : $hex(), $hexu().</p>

<p style="margin-top: 1em">S-Function : right <br>
Description : Returns right portion of a string. <br>
Syntax : let $x=$right($s,l) <br>
Notes : $s=Source string, l=length <br>
Notes : l must be less than the length of the string. <br>
See Also : $left(), $mid().</p>

<p style="margin-top: 1em">S-Function : rpipe <br>
Description : Returns the first line from a system piped
command <br>
Syntax : let $x=$rpipe(&quot;/bin/ls |grep myfile&quot;)
<br>
Notes : Not very useful unless used with head, tail, grep,
<br>
Notes : etc... <br>
See Also : system.</p>

<p style="margin-top: 1em">S-Function : time <br>
Description : Returns 24 character local time string <br>
Syntax : let $x=$time() <br>
See Also : time(). <br>
Notes : Time is in this format: Mon Apr 8 14:21:22 1996 <br>
012345678901234567890123 <br>
1 2</p>

<p style="margin-top: 1em">S-Function : tolower <br>
Description : Returns lowercase&Acirc;&acute;d string. <br>
Syntax : let $x=$tolower($y)</p>

<p style="margin-top: 1em">S-Function : toupper <br>
Description : Returns uppercase&Acirc;&acute;d string. <br>
Syntax : let $x=$toupper($y)</p>

<p style="margin-top: 1em">Test operators <br>
Operator Description Example Result <br>
= equal if 1+2=3 yes <br>
!= not equal if 1+2!=3 no <br>
&lt;&gt; not equal if 1+2&lt;&gt;3 no <br>
&gt; Greater than if 1+3&gt;3 yes <br>
&lt; Less than if 1+3&lt;3 no <br>
&gt;= Greater or equal if 3&gt;=3 yes <br>
&lt;= Greater or equal if 2&lt;=3 yes</p>

<p style="margin-top: 1em">Strings can be compared using
the same operators.</p>

<p style="margin-top: 1em">&quot;aaa&quot; &lt;
&quot;aab&quot;, &quot;aaaa&quot; &gt; &quot;aaa&quot;,
&quot;Test&quot; != &quot;test&quot;, &quot;One&quot; =
&quot;One&quot;, <br>
&quot;A&quot; &gt; &quot;a&quot;, &quot;Fumble&quot; &lt;=
&quot;Fumigate&quot;, &quot;Farsical&quot; &lt;&gt;
&quot;Comedic&quot;</p>

<p style="margin-top: 1em">Note that &quot;set ignorecase
on&quot; does NOT apply to string comparisons.</p>

<p style="margin-top: 1em">Expression operators <br>
Operator Description Example Result <br>
+ Addition let a=2+2 4 <br>
+ Concatenation let $b=&quot;aa&quot;+&quot;bb&quot;
&quot;aabb&quot; <br>
- Substraction let e=2-5 -3 <br>
* Multiplication let f=11*2 22 <br>
/ Division let g=34/11 3 <br>
&amp; Bit-Wise AND let h=42&amp;7 2 <br>
| Bit-Wise OR let a=42|5 47 <br>
^ Bit-Wise XOR let a=42^7 45</p>

<p style="margin-top: 1em">Mixed expression examples:</p>

<p style="margin-top: 1em">#Returns number of seconds since
00:00:00 <br>
let $t=$time() #Take a snapshot. <br>
let
a=(val(mid$($t,11,2))*3600)+(val(mid$($t,14,2))*60)+val(mid$($t,17,2))
<br>
#Notice the extra sets of parenthesis because
comgt&Acirc;&acute;s expression <br>
#evaluator is brain-dead. <br>
#For example, 5-2+1 should give you 4, right? Well,
according to <br>
#getvalue(), it actually gives 2, because it does it
somewhat from <br>
#right to left. <br>
#So to evaluate 5-2+1 correctly, use (5-2)+1. If
you&Acirc;&acute;re using <br>
#simple, two-element calculations, don&Acirc;&acute;t worry
about it. <br>
#5-2 will give you 3.</p>

<p style="margin-top: 1em">#Concatenation (Calls cu) <br>
exec &quot;cu -l &quot;+$dev()+&quot; -s
&quot;+$baud()&quot;</p>

<p style="margin-top: 1em">#In a test condition <br>
if a+c &gt; strlen($c) goto toomuch</p>

<p style="margin-top: 1em">#String comparison <br>
let $t=$mid($time(),11,8) <br>
if $t &gt; &quot;19:59:59&quot; print &quot;Too late for
that!0 goto toolate <br>
if $t &lt; &quot;08:00:00&quot; print &quot;Too early!0 goto
tooearly <br>
if $t = &quot;00:00:00&quot; print &quot;Oh god!
It&Acirc;&acute;s Twinkee time!0</p>

<p style="margin-top: 1em">KNOWN FEATURES <br>
The getvalue() parser. It makes me laugh so I think
I&Acirc;&acute;ll leave it that way. -
Daniel.Chouinard@pwc.utc.com</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
COMGTPIN - the 4 digit pin of the SIM for use by PIN script
COMGTAPN - the APN to write to the data card, used by the
APN script.</p>

<p style="margin-top: 1em">AUTHORS <br>
Daniel.Chouinard &lt;Daniel.Chouinard@pwc.utc.com&gt; wrote
the original dcon utility.</p>

<p style="margin-top: 1em">Paul Hardwick
&lt;paul@peck.org.uk&gt; updated it for the latest
compilers, provided the built-in script functionality and
tested it against GPRS and 3G datacards.</p>

<p style="margin-top: 1em">Martin Gregorie
&lt;martin@gregorie.org&gt; wrote the original manpage for
comgt from the dcon documentation and packaged comgt for
distribution.</p>

<p style="margin-top: 1em">History <br>
Daniel Chouinard wrote most (90%) of dcon back in 1989 when
he started doing Unix Apps tech support mostly by modem to
customer systems. He was tired of typing all those
pass&acirc; <br>
words and funny call-charging codes everytime he used cu.
Also, the company he worked for needed a system that would
log call times and estimated costs. Thus dcon was born. <br>
Six or seven years later (1996) and he was using pppd to
connect to his ISP site. He was more or less happy with chat
but found it lacked flow control and multiple response <br>
checks from &quot;atdt...&quot;. He wanted it to do
different things for &quot;no carrier&quot;, &quot;no dial
tone&quot;, and &quot;busy&quot;. Although he thought that
chat would probably be enhanced someday, when <br>
he found dcon.c on one of his old 45M tapes he tried
compiling it on his Linux box and, lo and behold, it did. In
the end, he added a few things to it (kill, fork, wait,
1/100 <br>
sec. times) and left it at that.</p>

<p style="margin-top: 1em">A couple of years ago Paul
Hardwick found the program, dcon 0.97, last modified in
1996. The purpose of this program was to run scripts that
would control Linux serial ports. The <br>
implementation was very similar to something he had written
for Windows. Anyway, rather than reinvent he contacted the
author, Daniel Chouinard, and asked his permission to reuse
<br>
the code. Happily he gave permission and a basic but useful
utility called comgt was created. Paul takes no credit for
the engine, apart from making it compatible with todays <br>
compilers. It is basically dcon repackaged.</p>

<p style="margin-top: 1em">20 October, 2006 comgt(1)</p>
<hr>
</body>
</html>
