<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_RULES(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_RULES(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_RULES(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp_rules -- How to tell makepp to build something
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>?:</b>&#x00A0;&amp;,
<br/>
 -,
<br/>
 @,&#x00A0; <b>B:</b>&#x00A0;:build_cache,
<br/>
 :build_check,&#x00A0; <b>D:</b>&#x00A0;:dispatch,&#x00A0;
  <b>E:</b>&#x00A0;:env,&#x00A0; <b>I:</b>&#x00A0;&quot;ignore_error&quot;,
<br/>
 :include,&#x00A0; <b>L:</b>&#x00A0;:last_chance,&#x00A0;
  <b>M:</b>&#x00A0;makeperl,&#x00A0;
  <b>N:</b>&#x00A0;&quot;noecho&quot;,&#x00A0; <b>P:</b>&#x00A0;:parser,
<br/>
 &quot;perl&quot;,&#x00A0; <b>S:</b>&#x00A0;:signature
<div class="Pp"></div>
A rule is what tells makepp how to build a file or a class of files. Makepp
  supports the same rule syntax as other implementations of make, plus some
  additions of its own.
<div class="Pp"></div>
A rule has the general format
<div class="Pp"></div>
<pre>
    target_expression : dependency_expression  [ : optional arguments]
        actions
</pre>
<div class="Pp"></div>
The list of targets may not contain any automatic variables (except
  &quot;$(foreach)&quot;). The dependency list may contain only automatic
  variables referring to the target (i.e., &quot;$(output)&quot;,
  &quot;$(outputs)&quot;, or their synonyms). The action may contain any
  automatic variables.
<div class="Pp"></div>
If makepp decides that the rule needs to be executed, each line of the rule is
  executed sequentially, and if any returns a non-zero status, the remainder are
  not executed (and makepp aborts with an error unless you specified the
  &quot;-k&quot; option on the command line.) Each action should be only one
  line. If an action is too long to write conveniently on a single line, you can
  split it into several lines and put a backslash to indicate that the several
  lines should be combined into one.
<div class="Pp"></div>
In order to distinguish actions from the next rule, the action should be
  indented more than the line containing the targets and dependencies. Unlike
  other implementations of make, makepp doesn't really care how much you indent
  it or whether you use tab characters rather than spaces. To keep backward
  compatibility with traditional make, the rules makepp uses to decide when
  actions end and the next rule begins are somewhat complicated:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The first action line must be indented more than the line
      containing the target.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a line is indented by one tab character or 8 spaces or
      more, then it is considered an action line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A blank line or a comment line with the &quot;#&quot;
      character at the right margin ends the rule, unless the next non-blank
      line is indented more than 8 spaces (or more than one tab).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a line is indented as much or more than the first action
      line, then it is considered an additional action line.</dd>
</dl>
<div class="Pp"></div>
There are a few special action items:
<dl class="Bl-tag">
  <dt class="It-tag">&amp;</dt>
  <dd class="It-tag">This symbol shall be followed by a command name and any
      number of arguments. Shell syntax is not understood fully here, only
      single and double quotes and backslashed characters within, as throughout
      makepp. The command name either leads to a function &quot;c_
      <i>name</i>&quot; to be called with the remaining strings as arguments. If
      such a function can not be found, this is identical to calling
      &quot;run&quot; from a &quot;perl&quot; block.
    <div style="height: 1.00em;">&#x00A0;</div>
    This allows efficiently calling a built-in, makefile-provided or external
      command. The prefix &quot;&amp;&quot; has been chosen because it is the
      function invoker in Perl, and because at the beginning it is illegal in
      Shell.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(ROOT)/include/%.h: %.h
        &amp;ln $(input) $(output)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">noecho</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@</dt>
  <dd class="It-tag">Normally, each shell command is printed as it is executed.
      However, if the first word of the action is &quot;noecho&quot; (or if it
      begins with the character &quot;@&quot;), then the command is not printed.
      For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o: %.cxx
          noecho $(LIBTOOL) --mode=compile $(CC) -c $(input)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This means that when the libtool command is executed, it is not printed.
      (Libtool itself usually prints the modified command that it executes, so
      it's redundant to print it twice.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ignore_error</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Normally, if the shell command returns a non-zero status,
      then makepp aborts because the command failed. However, some programs
      incorrectly set the status on exit, or there may be an error which really
      isn't fatal and shouldn't abort the whole compilation. You can cause
      makepp to ignore the return status by specifying &quot;ignore_error&quot;
      as the first word of the command line (or &quot;-&quot; as the first
      character). For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony distribution):
        ignore_error rm -r my_program-$(VERSION) # Get rid of previous junk.
        &amp;mkdir my_program-$(VERSION)
        &amp;cp $(FILES) my_program-$(VERSION)
        tar cf my_program-$(VERSION).tar my_program-$(VERSION)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This command makes a directory, copies a bunch of files into it, and then
      puts everything into a tar file for distribution. It's a good idea to
      clean out the previous contents of the directory, if there was anything
      there previously, and that's what the first line does. The &quot;rm&quot;
      might fail, but its return status is ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">perl</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makeperl</dt>
  <dd class="It-tag">This is essentially the same as the perl statement, but it
      is performed each time when running the rule, not when reading the
      makefile. The first variant is plain Perl code, while the second variant
      first passes the statement through Make-style variable expansion.
    <div style="height: 1.00em;">&#x00A0;</div>
    For the two possibilities of putting the braces of the body, see the
      explanation at &quot;perl_perlcode&quot; in makepp_statements. Note that
      the third variant explained there makes no sence here, because all action
      lines must be indented. You must signal failure in Perl statements, by
      calling &quot;die&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Per rule the Perl statements are currently evaluated in a common subprocess,
      except on Windows. That means they have only read access to any makefile
      variables. It is also the process which executes non-Perl actions. So
      calling exec or exit will confuse makepp. But this may change in the
      future. For an efficient way to call Perl scripts, see the previous item
      &quot;&amp;&quot; or &quot;run&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $(phony version):
        noecho perl {{  # $(target) &amp; $(VERSION) from Perl:
          print &quot;This is &quot;.f_target().&quot; $VERSION\n&quot;;
        }}
        echo You can mix this with Shell commands
        -makeperl { print &quot;This is $(target) $(VERSION)\n&quot; }
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
There are several different kinds of rules, each with different purposes.
<h2 class="Ss" title="Ss" id="Explicit_Rules"><a class="selflink" href="#Explicit_Rules">Explicit
  Rules</a></h2>
<pre>
    target1 target2: dependency1 dependency2 ...
        actions to be performed
</pre>
<div class="Pp"></div>
This syntax specifies that in order to make either <i>target1</i> or
  <i>target2</i>, all the files <i>dependency1</i>, <i>dependency2</i>, etc.,
  must already have been made. Then the given actions are executed by the shell
  to make the targets.
<div class="Pp"></div>
The first explicit rule in a file is the default target, and is made if you do
  not specify any targets on the command line.
<div class="Pp"></div>
Unlike traditional make programs, makepp usually assumes that one invocation of
  the action makes all of the targets (unless there are no dependencies). For
  example, one invocation of yacc creates both output files for this rule:
<div class="Pp"></div>
<pre>
    y.tab.c y.tab.h : parser.y
        $(YACC) -d parser.y
</pre>
<div class="Pp"></div>
Note that other implementations of make do not have a concept of a single
  command producing multiple output files, and so when you specify multiple
  targets they will execute the rule once per target. Makepp will revert to this
  behavior if it looks like this is an old-style makefile. Specifically, it will
  execute the rule once per target, instead of just once overall, if all of the
  following are true:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The rule action mentions the automatic variable $@. (The
      synonyms &quot;$(output)&quot; or &quot;$(target)&quot; do not trigger
      this behavior.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The rule action does not mention the automatic variable
      &quot;$(outputs)&quot; (or its synonym &quot;$(targets)&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">This is not a pattern rule, and there is no foreach
    clause.</dd>
</dl>
<div class="Pp"></div>
For example,
<div class="Pp"></div>
<pre>
    all test install:
        for subdir in $(SUBDIRS); do cd $$subdir &amp;&amp; $(MAKE) $@; cd ..; done
</pre>
<div class="Pp"></div>
is a common idiom in makefiles, and makepp supports it. (Note that you should
  never use recursive make in any new makefiles you write--use the
  &quot;load_makefile&quot; statement, or implicit makefile loading instead.)
<div class="Pp"></div>
If you want to have the same rule executed once for each target (e.g., because
  the targets have similar commands), it's preferable to use either a pattern
  rule (see below) or a &quot;foreach&quot; clause. For example, if with a
  traditional make program you would write:
<div class="Pp"></div>
<pre>
    a b c d:
        do_something to build $@ &gt; $@
</pre>
<div class="Pp"></div>
in makepp, you would probably want to write it like this:
<div class="Pp"></div>
<pre>
    $(foreach) : : foreach a b c d
        do_something to build $(output) &gt; $(output)
</pre>
<div class="Pp"></div>
<i>Phony targets</i>
<div class="Pp"></div>
A <i>phony target</i> is a target that will never actually exist in the file
  system; it's just a way of getting makepp to build some targets and possibly
  execute some additional commands.
<div class="Pp"></div>
A typical phony target is &quot;all&quot;, which usually is used to cause
  everything that can be built to be built, like this:
<div class="Pp"></div>
<pre>
    all: prog1 prog2 subdir/prog3 subdir2/libmine.a
          @&amp;echo &quot;All done!&quot;
</pre>
<div class="Pp"></div>
If you type &quot;makepp&#x00A0;all&quot;, or if you put all as the first
  explicit target in your makefile (which is typical) and just type
  &quot;makepp&quot;, then it will cause all the dependencies to be built, then
  it will print &quot;All done!&quot;. At this point, makepp will look for the
  file <i>./all</i> and will discover that it doesn't exist. It will complain
  loudly.
<div class="Pp"></div>
To keep makepp from expecting the file <i>./all</i> to exit, you need to tell it
  that it's a phony target. Just put a line like the following in your makefile
  (it makes no difference where):
<div class="Pp"></div>
<pre>
    .PHONY: all
</pre>
<div class="Pp"></div>
An equivalent alternative which is sometimes more convenient is to use the
  &quot;$(phony&#x00A0;)&quot; function, like this:
<div class="Pp"></div>
<pre>
    $(phony all): prog1 prog2 subdir/prog3 subdir2/libmine.a
</pre>
<div class="Pp"></div>
Phony targets in one makefile can refer to phony targets in another makefile.
  This is often done with the &quot;clean&quot; target, like this:
<div class="Pp"></div>
<pre>
    # Top level makefile:
    # lots of rules and stuff here
    # ....
    $(phony clean): subdir1/clean subdir2/clean
        &amp;rm -fm my_program
</pre>
<div class="Pp"></div>
Then in the subdirectories, the makefiles might read like this:
<div class="Pp"></div>
<pre>
    # Makefile in a subdirectory
    # ...
    $(phony clean):
        &amp;rm -fm $(wildcard *.o *.a)
</pre>
<div class="Pp"></div>
But nowadays you would use the &quot;makeppclean&quot; command, instead of a
  clean target.
<div class="Pp"></div>
<i>Wildcards</i>
<div class="Pp"></div>
It is safe to specify wildcards in the dependency list. Wildcards match not only
  files that exist, but files which can be created given the rules in the
  makefile. For example, to build a library from all .o files in a directory,
  you could write this:
<div class="Pp"></div>
<pre>
    libmine.a: *.o
        &amp;rm -f $(output)
        ar cr $(output) $(inputs)
</pre>
<div class="Pp"></div>
This will work even if none of the &quot;.o&quot; files have been created yet,
  because makepp's wildcards match files which do not yet exist but can be
  built. This will even pick up files whose rule is discovered later (in the
  same makefile, or one not yet read). In this last point it differs from the
  &quot;wildcard&quot; function, which is limited to the known rules, as it must
  return its result when it is expanded.
<div class="Pp"></div>
Makepp supports all the usual shell wildcards (&quot;*&quot;, &quot;?&quot;, and
  &quot;[]&quot;). It also has a wildcard &quot;**&quot; which matches any
  number of intervening directories. (This idea was stolen from zsh.) For
  example, &quot;**/*.c&quot; matches all the <i>.c</i> files in the entire
  source tree. &quot;objects/**/*.o&quot; matches all the <i>.o</i> files
  contained anywhere in the subdirectory <i>objects</i> or any of its
  subdirectories or any of their subdirectories. The &quot;**&quot; wildcard
  will not follow soft links to directories at any level. It also will never
  return phony targets.
<div class="Pp"></div>
Makepp's wildcards will ignore files or directories which exist but cannot be
  read. After all, such files cannot be used in the build process anyway.
  Putting unreadable files in a directory is primarily useful to inhibit the
  automatic import of the given file from a repository.
<div class="Pp"></div>
The initial assertion was that this is safe. This is in the sence that it works
  whether the files already exist, or need to be built first. However it is
  unsafe in the sence that it will still match files that were built by makepp,
  but no longer have a rule (e.g. you removed the <i>.c</i> file, but the
  <i>.o</i> file is still there.) To prevent this, use the
  &quot;--rm-stale&quot; option.
<h2 class="Ss" title="Ss" id="Pattern_rules"><a class="selflink" href="#Pattern_rules">Pattern
  rules</a></h2>
A pattern rule is a rule that is applied based on some textual pattern. This is
  used to apply the same rule to a whole class of files. The syntax is the same
  as GNU make's pattern rules:
<div class="Pp"></div>
<pre>
    %.o: %.c
        $(CC) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
This says that any file in the current directory which matches &quot;*.c&quot;
  can be converted into the corresponding .o file using the given command.
<div class="Pp"></div>
Note that several pattern dependencies may be supplied. For example, if your
  <i>xyz.o</i> file depends on the corresponding <i>xyz.cpp</i> file, and also
  on a file called <i>moc_xyz.cflags</i> which contains the compiler options,
  this could be expressed with:
<div class="Pp"></div>
<pre>
    %.o: %.cpp %.cflags
        $(CXX) `cat $(stem).cflags` -c $(inputs) -o $(output)
</pre>
<div class="Pp"></div>
You may also have several pattern targets. For example,
<div class="Pp"></div>
<pre>
    %.tab.h %.tab.c : %.y
        yacc -d $(input)
        &amp;mv y.tab.h $(stem).tab.h
        &amp;mv y.tab.c $(stem).tab.c
</pre>
<div class="Pp"></div>
Ordinarily, pattern rules only look for files in the current directories. You
  can force them to search in the current directory and all directories beneath
  it by setting
<div class="Pp"></div>
<pre>
    makepp_percent_subdirs := 1
</pre>
<div class="Pp"></div>
before the first pattern rule in your makefile or on the command line for
  example.
<div class="Pp"></div>
There is a clear difference between &quot;%&quot; and the wildcard
  &quot;*&quot;, though both match any string: The wildcard returns a list of
  files that is completely used at that point. So this depends on all <i>.o</i>
  files buildable here:
<div class="Pp"></div>
<pre>
    prog: *.o
        $(LD) $(LDFLAGS) $(inputs) -o $(output)
</pre>
<div class="Pp"></div>
This could not be achieved by replacing &quot;*&quot; with &quot;%&quot;,
  because the latter is for one-by-one matching of input to output, producing
  internally one rule for each matched stem.
<h2 class="Ss" title="Ss" id="Static_pattern_rules"><a class="selflink" href="#Static_pattern_rules">Static
  pattern rules</a></h2>
A static pattern rule is a pattern rule that is applied only to a limited set of
  files:
<div class="Pp"></div>
<pre>
    $(SPECIAL_MODULES).o : %.o : %.cpp
        $(CXX) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
This says that the pattern rule applies only to the files in
  &quot;$(SPECIAL_MODULES).o&quot;.
<div class="Pp"></div>
This is mostly for compatibility with GNU make; foreach rules (see below) are a
  more powerful way of doing the same thing.
<h2 class="Ss" title="Ss" id="Foreach_rules"><a class="selflink" href="#Foreach_rules">Foreach
  rules</a></h2>
The above pattern rule syntax is powerful enough to support almost all builds,
  but occasionally it is necessary to do something more complicated. Makepp
  provides a more powerful syntax: the &quot;:foreach&quot; clause for the rule.
<div class="Pp"></div>
<pre>
    target_expression : dependency_expression : foreach file-list
        actions
</pre>
<div class="Pp"></div>
The simplest kind of foreach rule is just a pattern rule whose application is
  restricted to a specific list of files. For example, suppose you have a
  pattern rule that tells makepp how to compile all <i>.c</i> files. However,
  you have a list of <i>.c</i> files for which you want to do something
  different. You could do something like this:
<div class="Pp"></div>
<pre>
    # Here's the rule that applies to everything:
    %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
 
    %.o : %.c : foreach $(SPECIAL_MODULES)
        $(CC) $(SPECIAL_CFLAGS) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
An even more powerful use of foreach rules takes advantage of the fact that the
  variable &quot;$(foreach)&quot; is set in turn to each file matching the file
  list and the target and dependency expressions are evaluated. The file-list
  may contain wildcards, and these match even files which don't exist yet but
  which can be built (see &quot;Wildcards&quot; in makepp_rules).
<div class="Pp"></div>
This is an unwieldy syntax but it is extremely flexible, because the
  &quot;$(foreach)&quot; variable may appear in any way in the expression.
  First, note that pattern rules are in fact a special case of foreach rules;
  the pattern rule
<div class="Pp"></div>
<pre>
     %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
is exactly equivalent to:
<div class="Pp"></div>
<pre>
    $(patsubst %.c, %.o, $(foreach)) : $(foreach) : foreach *.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
(In fact, it's converted to approximately that internally.)
<div class="Pp"></div>
As an example of how you would use a &quot;:foreach&quot; clause where a pattern
  rule isn't sufficient, suppose you have some <i>.c</i> files which are built
  using some kind of preprocessor which takes as input files with a <i>.k</i>
  extension. You want to compile those <i>.c</i> files with a different set of
  compilation options than the usual <i>.c</i> files which are ordinary source
  files. You could do something like this:
<div class="Pp"></div>
<pre>
    # Rule for ordinary .c files:
    %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
 
    # Rule to make .c files from .k files:
    %.c : %.k
        $(preprocessor) $(input) &gt; $(output)
 
    # Special build rules for .c files which are made from .k files:
    $(foreach:%.k=%.o) : $(foreach:%.c=%.k) : foreach *.k
        $(CC) $(SPECIAL_CFLAGS) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
(This uses the slightly more concise substitution reference syntax rather than
  calling &quot;patsubst&quot; explicitly.)
<div class="Pp"></div>
Note that if all you want to do is to change the value of a variable
  (&quot;CFLAGS&quot; in this case) it's sometimes more convenient to use
  target-specific variables.
<h2 class="Ss" title="Ss" id="Legacy_suffix_rules"><a class="selflink" href="#Legacy_suffix_rules">Legacy
  suffix rules</a></h2>
For backward compatibility, makepp supports the old-style suffix rules.
<div class="Pp"></div>
<pre>
    .suffix1.suffix2:
        actions
</pre>
<div class="Pp"></div>
is equivalent to
<div class="Pp"></div>
<pre>
    %.suffix2: %.suffix1
        actions
</pre>
<div class="Pp"></div>
but much harder to remember. (Which suffix comes first?) Typically, a rule will
  appear in a legacy makefile like this:
<div class="Pp"></div>
<pre>
    .c.o:
        $(CC) $(CFLAGS) -c $*.c -o $*.o
</pre>
<div class="Pp"></div>
which is exactly equivalent to
<div class="Pp"></div>
<pre>
    %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
</pre>
<h2 class="Ss" title="Ss" id="Conflicting_rules"><a class="selflink" href="#Conflicting_rules">Conflicting
  rules</a></h2>
When there is more than one way to make a file, makepp uses a simple procedure
  to determine which rule to use.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">It is an error to have conflicting explicit rules for
      building a file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Pattern rules and foreach rules with wildcards never
      override explicit rules. Thus explicit rules can be used to specify
      exceptions for pattern rules. (Note that simply using a
      &quot;:foreach&quot; clause doesn't make something a pattern rule. It must
      have a wildcard (like &quot;*&quot; or &quot;?&quot;) as part of the
      filename in the &quot;:foreach&quot; clause. If it is just an explicit
      list of files, it is treated as an explicit rule for each of those
    files.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">When conflicting pattern rules come from different
      makefiles, rules from &quot;nearer&quot; makefiles override rules from
      &quot;farther&quot; makefiles. &quot;Nearer&quot; means that the makefile
      is located closer to the target in the directory hierarchy (i.e., the file
      name of the target relative to the directory the makefile is run from is
      shorter). If this doesn't distinguish the makefiles, then the rule from
      the makefile which is loaded latest is used.
    <div style="height: 1.00em;">&#x00A0;</div>
    This means that you can specify a pattern rule that applies to all files in
      your entire directory tree in just the top-level makefile, but then you
      can override it in a lower-level makefile. For example, your top-level
      makefile could contain:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o : %.c : foreach **/*.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and you could have a makefile in one of the subdirectories that says:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o : %.c
        $(CC) $(SPECIAL_CFLAGS) -c $(input) -o $(output)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Pattern rules that have a shorter chain of inference are
      preferred over other pattern rules. For example, if you had the following
      rules (based on an example from the Linux kernel):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.s: %.c
        $(CC) -s $(input) -o $(output)
 
    %.o: %.s
        $(AS) $(input) -o $(output)
 
    %.o: %.c
        $(CC) -c $(input) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If we need to build &quot;xyz.o&quot;, we could either build the
      intermediate &quot;.s&quot; file and then run that through the assembler
      using the first two rules, or we could go directly to a &quot;.o&quot;
      file using the last rule. The last rule is preferred because there are
      fewer steps in the chain of inference (one instead of two).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Pattern rules later in a makefile override pattern rules
      that are earlier. (This is backwards from GNU make.) This means that you
      should put your more general rules earlier, and your more specific rules
      later. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o: %.c                            # General compilation rule.
        action
 
    special_%.o: special_%.c            # Special rule for files with a
        different action                # &quot;special_&quot; prefix.
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Rule_options"><a class="selflink" href="#Rule_options">Rule
  options</a></h2>
Sometimes it is necessary to supply additional options to modify how makepp
  executes the rule. These options are specified as &quot;:optionname
  value&quot;, either on the line containing the dependencies, or on the next
  line.
<div class="Pp"></div>
Supplying the options on separate lines may make it possible for you to use the
  same makefile with makepp and a traditional make. For example,
<div class="Pp"></div>
<pre>
    target : dependencies
           : signature target_newer
        actions
</pre>
<div class="Pp"></div>
will work fine with a traditional Unix make, because it interprets the
  &quot;:&#x00A0;signature&quot; line as a shell command, and a command
  beginning with a colon does nothing.
<dl class="Bl-tag">
  <dt class="It-tag">:build_cache <i>/path/to/build/cache</i></dt>
  <dd class="It-tag">
    <pre>
     target : dependencies
            : build_cache /put/cache/files/over/there
          actions
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Specifies the path to a build cache to be used for files produced by this
      rule. This overrides the effect of the &quot;build_cache&quot; statement
      or the &quot;--build-cache&quot; command line option, if any, for this
      rule. See makepp_build_cache for details about build caches.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you specify &quot;none&quot; instead of a path, you disable the build
      cache for this particular rule. This can be useful to avoid wasting disk
      space on files that you know aren't useful to cache, either because you
      are very sure they will never be reused or because they are built so fast
      that it's not worth caching them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:build_check <i>build_check_method</i></dt>
  <dd class="It-tag">
    <pre>
     target : dependencies
            : build_check target_newer
          actions
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This tells makepp what algorithm to use to decide if the targets need to be
      rebuilt. See makepp_build_check for more details. This overrides the
      effect of the &quot;build_check&quot; statement or the
      &quot;--build-check-method&quot; command line option, if any, for this
      rule.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:env <i>VARIABLE ...</i></dt>
  <dd class="It-tag">Add a dependency on the values of the named environment
      variables. If any of them differ from the previous build, then the targets
      are considered out of date, if the build_check method so dictates. (All of
      the built-in build check methods except for target_newer respect this.)
    <div style="height: 1.00em;">&#x00A0;</div>
    VARIABLE may be of the form &quot;filename in PATH_VARIABLE&quot; (in
      quotes), in which case the targets are considered out of date if the first
      directory from the colon-delimited value of PATH_VARIABLE in which
      filename exists is different from the last build. This can be used to
      avoid rebuilding the targets when PATH_VARIABLE changes in an irrelevant
      way.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:dispatch <i>command ...</i></dt>
  <dd class="It-tag">Enclose each shell action (but not Perl actions nor Perl
      commands) in a &quot;sh -c '...'&quot; and prefix it with command, but
      assume that the target doesn't depend on command. This is useful if you
      want to send actions to a job queuing system, but the result is assumed to
      be independent of the queuing parameters, as well as to whether the
      queuing system is used at all.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:include <i>file_or_pattern</i></dt>
  <dd class="It-tag">Rule varies depending on compiler:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o : %.c
        : include %.d : signature C
        gcc -MD -c ...
 
    %.o : %.c
        : include %.u : signature C # IBM uses a different suffix
        xlc -M -c ...
 
    sub dependify {             # Turn Microsoft's chatter into useful format
        s/\$/\$\$/g;
        s/(Note: including file: *)?(.+?)\r?\n/$1 ? &quot;'$2' &quot; : &quot;'&quot;.f_output().&quot;': &quot;/e;
    }
    %.o : %.c
        : include %.d : signature C
        cl -showIncludes -c ... &gt;$(stem).d
        &amp;sed &amp;dependify -o +&lt;$(stem).d
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Some compilers (Intel's icc just like gcc above, or IBM's xlc) can produce
      dependency files on the fly. That is, while they compile, they write a
      makefile that makepp can include. The advantage over makepp's scanner is
      that it is guaranteed to be 100% correct, where we may only come close.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option harnesses that in a special way: If the file is not present,
      i.e. typically on the 1st build, normal scanning occurs. But if the file
      is present, no scanning occurs (which is why we specify a smart signature
      above -- not scanning falls back to the dumb default of timestamp and
      size). Instead it includes the file, before executing the rule. After
      successfully executing the rule, it forgets whatever it read the first
      time, given that the file might have been outdated. Instead it reads the
      file again, if it changed, for having up-to-date build info.
    <div style="height: 1.00em;">&#x00A0;</div>
    WARNING: This is inherently unreliable. The dependency file gets produced by
      the very rule for which it is a dependency. On the other hand, the
      compiler knows about all it's internal sub-includes, which makepp usually
      ignores. This is a reliability advantage only for the case where a
      compiler patch fixes only the sub-includes. The price is that makepp ends
      up looking at many more files, which takes time.
    <div style="height: 1.00em;">&#x00A0;</div>
    There is a catch when you remove an &quot;#include&quot; statement
      <b>and</b> the corresponding file: It will still be mentioned in the
      dependency file from the last time, when it was needed. In such a case you
      must edit the dependency file to remove the dependency which is no longer
      fulfillable.
    <div style="height: 1.00em;">&#x00A0;</div>
    This feature can not be used with a build cache because fetching a file from
      there requires knowing everything about the file. But a dependency file
      depends on those files makepp learns about by reading it. Such a circular
      dependency is not normally possible in a reliable build system. This is an
      exception because after rebuilding and rereading a dependency file
      everything is correct again.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you build in your repositories, makepp will pick up the dependency file
      from the 1st repository which contains one. This is unlike other files,
      where it takes the 1st with the expected signature. This is better than
      for build caches, where for lack of signature, it can't even find the
      file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:last_chance</dt>
  <dd class="It-tag">Enable an open-ended rule, such as
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.foo foo%.bar: :last_chance
        &amp;echo $@ -o $@
        &amp;cp $(outputs)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Because a rule such as this could generate an essentially infinite number of
      targets, a target of this rule will not match a $(wildcard) function or
      pattern rule unless something else has already instanced the rule by
      referencing the target specifically. Furthermore, if
      &quot;--rm-stale&quot; is specified, then a target left over from a
      previous makepp run will appear stale if the only way to build it is via a
      last_chance rule that hasn't been instanced for the target yet, which is a
      desirable behavior because the build will fail more consistently when it
      erroneously relies on a wildcard to match targets from a previous run.
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;:last_chance&quot; option is intended to call attention to the
      special behavior of the rule with respect to matching wildcards.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:parser <i>parser</i></dt>
  <dd class="It-tag">This tells makepp how to parse the command for detecting
      (include) files. Usually, makepp guesses how to do this based on the words
      in the command itself (see makepp_scanning for details). However, if
      makepp guesses wrongly, you may want to explicitly indicate the parser,
      like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o: %.abc
        : parser c_compilation
        action here
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This causes makepp to perform the same parsing and scanning that it does for
      C/C++ build commands, even if it doesn't recognize the action as a C
      compilation.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default parser depends on the command. If you do not specify a
      &quot;:parser&quot; option, then the first word of each command is
      examined. For example for a compile or link command, makepp will use the
      &quot;c_compilation&quot; parser; or if the command looks like the GNU
      variant, &quot;gcc_compilation&quot;. If no parser is found it uses the
      &quot;none&quot; parser. For more details on this, or if you want to write
      your own parser or change makepp's default parsers, see makepp_scanning.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that this applies to every command in the rule, which may not be what
      you want:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o: %.c : parser c-compilation
        @echo 'Building $(output)'
        @funny_cc ...
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will also interpret &quot;echo&quot; as a compiler and deduce its
      argument 'Building mymodule.o' as an implicit dependency. This will lead
      to the complaint that it doesn't know how to build such a file. In this
      case you would be better off with &quot;register_parser&quot;. There you
      find an explanation how <i>parser</i> can be given either as a classname
      or as a function name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:signature <i>signature_method</i></dt>
  <dd class="It-tag">
    <pre>
    target : dependencies
           : signature md5
        actions
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This tells makepp what algorithm to use to determine if the dependencies
      have changed. See makepp_signatures for more details. Signature methods
      which are included with the makepp distribution are are &quot;plain&quot;,
      &quot;md5&quot;, &quot;C&quot; or &quot;c_compilation_md5&quot;, and
      &quot;shared_object&quot;. This overrides any signature method specified
      with the &quot;-m&quot; or &quot;--signature-method&quot; command line
      options, or with the &quot;signature&quot; statement.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Special_characters"><a class="selflink" href="#Special_characters">Special
  characters</a></h2>
Makepp can support filenames that have special characters in them like a colon
  or a space. Suppose, for example, you want to create a file called
  &quot;a:thing&quot; from the file &quot;b:thing&quot;. You can't write the
  rule this way:
<div class="Pp"></div>
<pre>
    a:thing : b:thing       # This is a syntax error
        &amp;cat $(input) -o $(output)
</pre>
<div class="Pp"></div>
because makepp won't know which colons separate targets from dependencies and
  which are part of the filenames. Instead, simply enclose the name in quotes,
  like this:
<div class="Pp"></div>
<pre>
    &quot;a:thing&quot; : &quot;b:thing&quot;
        &amp;cat $(input) -o $(output)
</pre>
<div class="Pp"></div>
Now the rule is unambiguous.
<div class="Pp"></div>
Makepp's quoting syntax is quite similar to the shell's. You can, for example,
  use single quotes instead of double quotes, or you can escape special
  characters with a backslash:
<div class="Pp"></div>
<pre>
    a\:thing : 'b:thing'
        &amp;cat $(input) -o $(output)
</pre>
<div class="Pp"></div>
Suppose, for example, that your filename is &quot;'&quot;!;\$&quot;. Now why
  you'd want such a filename I don't know, but here are several ways you could
  specify it to makepp (and the shell):
<div class="Pp"></div>
<pre>
    \''&quot;!;\$$'
    &quot;'\&quot;!;\\$$&quot;
</pre>
<div class="Pp"></div>
Pay attention as to when makepp strips quotes and when the shell does. Makepp
  looks at quotes only in the following cases:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">in the &quot;ifeq&quot; family of tests</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">before and after the rule colon</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">in a makepp builtin command</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">in a function that pertains to files</dd>
</dl>
<div class="Pp"></div>
Unlike the shell, makepp doesn't expand quotes while assigning them to a
  variable. Thus the following rules are identical:
<div class="Pp"></div>
<pre>
    FILE = 'name with spaces'
    x := $(print $(FILE))       # just to check that quotes are still there
    $(FILE):                    # quotes around single file stripped by makepp
        &amp;echo hello -o$(FILE)   # quotes around single file stripped by makepp
        echo there &gt;&gt;$(FILE)    # quotes around single file stripped by Shell
    'name with spaces':
        &amp;echo hello -o'name with spaces'
        echo there &gt;&gt;'$(output)' # quotes were stripped above, add them again
</pre>
<div class="Pp"></div>
Note that (unlike the Shell) variables beginning with &quot;$&quot; are expanded
  even inside single quotes. Dollar signs cannot be protected by quotes or
  backslashes. To get a literal dollar sign, use a double dollar sign, e.g.,
<div class="Pp"></div>
<pre>
    $(phony all):
        @&amp;echo This is a dollar sign: $$
        @for val in a b c d; do echo $$val; done
</pre>
<div class="Pp"></div>
Generally, you should be able to deal with just about any special character by
  quoting it in some way. This includes spaces, control characters, etc.
  However, be aware that at present, makepp's comment stripping is somewhat
  simplistic, and any &quot;#&quot; characters preceded by whitespace will be
  interpreted as comments no matter how they are quoted.
<div class="Pp"></div>
When a target or dependency name is put into an automatic variable like
  &quot;$(output)&quot;, then the quotes and any backslashes are stripped. This
  means that if you want to reference the filename in the actions, you will
  probably have to quote it again, like this:
<div class="Pp"></div>
<pre>
    &quot;a file name with spaces&quot;:
        echo &quot;Special contents&quot; &gt; &quot;$@&quot;
</pre>
<div class="Pp"></div>
If you don't put the quotes around $@, then the shell will see the command
<div class="Pp"></div>
<pre>
    echo &quot;Special contents&quot; &gt; a file name with spaces
</pre>
<div class="Pp"></div>
which writes the string &quot;Special contents file name with spaces&quot; to
  the file called <i>a</i>. This is probably not what you want.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Gary Holt (holt-makepp@gholt.net)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
