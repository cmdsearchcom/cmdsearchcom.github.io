<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:29:58 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PARSLEY(1) Parsley PARSLEY(1)</p>

<p style="margin-top: 1em">NAME <br>
parsley - Parsley Documentation</p>

<p style="margin-top: 1em">Contents:</p>

<p style="margin-top: 1em">PARSLEY TUTORIAL PART I: BASICS
AND SYNTAX <br>
From Regular Expressions To Grammars <br>
Parsley is a pattern matching and parsing tool for Python
programmers.</p>

<p style="margin-top: 1em">Most Python programmers are
familiar with regular expressions, as provided by
Python&rsquo;s re module. To use it, you provide a string
that describes the pattern you want to match, <br>
and your input.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">&gt;&gt;&gt; import re <br>
&gt;&gt;&gt; x = re.compile(&quot;a(b|c)d+e&quot;) <br>
&gt;&gt;&gt; x.match(&quot;abddde&quot;) <br>
&lt;_sre.SRE_Match object at 0x7f587af54af8&gt;</p>

<p style="margin-top: 1em">You can do exactly the same sort
of thing in Parsley:</p>

<p style="margin-top: 1em">&gt;&gt;&gt; import parsley <br>
&gt;&gt;&gt; x = parsley.makeGrammar(&quot;foo =
&rsquo;a&rsquo; (&rsquo;b&rsquo; | &rsquo;c&rsquo;)
&rsquo;d&rsquo;+ &rsquo;e&rsquo;&quot;, {}) <br>
&gt;&gt;&gt; x(&quot;abdde&quot;).foo() <br>
&rsquo;e&rsquo;</p>

<p style="margin-top: 1em">From this small example, a
couple differences between regular expressions and Parsley
grammars can be seen:</p>

<p style="margin-top: 1em">Parsley Grammars Have Named
Rules <br>
A Parsley grammar can have many rules, and each has a name.
The example above has a single rule named foo. Rules can
call each other; calling rules in Parsley works like calling
<br>
functions in Python. Here is another way to write the
grammar above:</p>

<p style="margin-top: 1em">foo = &rsquo;a&rsquo; baz
&rsquo;d&rsquo;+ &rsquo;e&rsquo; <br>
baz = &rsquo;b&rsquo; | &rsquo;c&rsquo;</p>

<p style="margin-top: 1em">Parsley Grammars Are Expressions
<br>
Calling match for a regular expression returns a match
object if the match succeeds or None if it fails. Parsley
parsers return the value of last expression in the rule.
Behind <br>
the scenes, Parsley turns each rule in your grammar into
Python methods. In pseudo-Python code, it looks something
like this:</p>

<p style="margin-top: 1em">def foo(self): <br>
match(&rsquo;a&rsquo;) <br>
self.baz() <br>
match_one_or_more(&rsquo;d&rsquo;) <br>
return match(&rsquo;e&rsquo;)</p>

<p style="margin-top: 1em">def baz(self): <br>
return match(&rsquo;b&rsquo;) or match(&rsquo;c&rsquo;)</p>

<p style="margin-top: 1em">The value of the last expression
in the rule is what the rule returns. This is why our
example returns &rsquo;e&rsquo;.</p>

<p style="margin-top: 1em">The similarities to regular
expressions pretty much end here, though. Having multiple
named rules composed of expressions makes for a much more
powerful tool, and now we&rsquo;re going <br>
to look at some more features that go even further.</p>

<p style="margin-top: 1em">Rules Can Embed Python
Expressions <br>
Since these rules just turn into Python code eventually, we
can stick some Python code into them ourselves. This is
particularly useful for changing the return value of a rule.
<br>
The Parsley expression for this is -&gt;. We can also bind
the results of expressions to variable names and use them in
Python code. So things like this are possible:</p>

<p style="margin-top: 1em">x =
parsley.makeGrammar(&quot;&quot;&quot; <br>
foo = &rsquo;a&rsquo;:one baz:two &rsquo;d&rsquo;+
&rsquo;e&rsquo; -&gt; (one, two) <br>
baz = &rsquo;b&rsquo; | &rsquo;c&rsquo; <br>
&quot;&quot;&quot;, {}) <br>
print x(&quot;abdde&quot;).foo()</p>

<p style="margin-top: 1em">(&rsquo;a&rsquo;,
&rsquo;b&rsquo;)</p>

<p style="margin-top: 1em">Literal match expressions like
&rsquo;a&rsquo; return the character they match. Using a
colon and a variable name after an expression is like
assignment in Python. As a result, we can use <br>
those names in a Python expression - in this case, creating
a tuple.</p>

<p style="margin-top: 1em">Another way to use Python code
in a rule is to write custom tests for matching. Sometimes
it&rsquo;s more convenient to write some Python that
determines if a rule matches than to <br>
stick to Parsley expressions alone. For those cases, we can
use ?(). Here, we use the builtin rule anything to match a
single character, then a Python predicate to decide if
it&rsquo;s <br>
the one we want:</p>

<p style="margin-top: 1em">digit = anything:x ?(x in
&rsquo;0123456789&rsquo;) -&gt; x</p>

<p style="margin-top: 1em">This rule digit will match any
decimal digit. We need the -&gt; x on the end to return the
character rather than the value of the predicate expression,
which is just True.</p>

<p style="margin-top: 1em">Repeated Matches Make Lists <br>
Like regular expressions, Parsley supports repeating
matches. You can match an expression zero or more times with
&rsquo;* &rsquo;, one or more times with &rsquo;+&rsquo;,
and a specific number of times <br>
with &rsquo;{n, m}&rsquo; or just &rsquo;{n}&rsquo;. Since
all expressions in Parsley return a value, these repetition
operators return a list containing each match they made.</p>

<p style="margin-top: 1em">x =
parsley.makeGrammar(&quot;&quot;&quot; <br>
digit = anything:x ?(x in &rsquo;0123456789&rsquo;) -&gt; x
<br>
number = digit+ <br>
&quot;&quot;&quot;, {}) <br>
print x(&quot;314159&quot;).number()</p>

<p style="margin-top: 1em">[&rsquo;3&rsquo;,
&rsquo;1&rsquo;, &rsquo;4&rsquo;, &rsquo;1&rsquo;,
&rsquo;5&rsquo;, &rsquo;9&rsquo;]</p>

<p style="margin-top: 1em">The number rule repeatedly
matches digit and collects the matches into a list. This
gets us part way to turning a string like 314159 into an
integer. All we need now is to turn <br>
the list back into a string and call int():</p>

<p style="margin-top: 1em">x =
parsley.makeGrammar(&quot;&quot;&quot; <br>
digit = anything:x ?(x in &rsquo;0123456789&rsquo;) -&gt; x
<br>
number = digit+:ds -&gt; int(&rsquo;&rsquo;.join(ds)) <br>
&quot;&quot;&quot;, {}) <br>
print x(&quot;8675309&quot;).number()</p>

<p style="margin-top: 1em">8675309</p>

<p style="margin-top: 1em">Collecting Chunks Of Input <br>
If it seemed kind of strange to break our input string up
into a list and then reassemble it into a string using join,
you&rsquo;re not alone. Parsley has a shortcut for this
since <br>
it&rsquo;s a common case: you can use &lt;&gt; around a rule
to make it return the slice of input it consumes, ignoring
the actual return value of the rule. For example:</p>

<p style="margin-top: 1em">x =
parsley.makeGrammar(&quot;&quot;&quot; <br>
digit = anything:x ?(x in &rsquo;0123456789&rsquo;) <br>
number = &lt;digit+&gt;:ds -&gt; int(ds) <br>
&quot;&quot;&quot;, {}) <br>
print x(&quot;11235&quot;).number()</p>

<p style="margin-top: 1em">11235</p>

<p style="margin-top: 1em">Here, &lt;digit+&gt; returns the
string &quot;11235&quot;, since that&rsquo;s the portion of
the input that digit+ matched. (In this case it&rsquo;s the
entire input, but we&rsquo;ll see some more complex cases
<br>
soon.) Since it ignores the list returned by digit+, leaving
the -&gt; x out of digit doesn&rsquo;t change the
result.</p>

<p style="margin-top: 1em">Building A Calculator <br>
Now let&rsquo;s look at using these rules in a more
complicated parser. We have support for parsing numbers;
let&rsquo;s do addition, as well.</p>

<p style="margin-top: 1em">x =
parsley.makeGrammar(&quot;&quot;&quot; <br>
digit = anything:x ?(x in &rsquo;0123456789&rsquo;) <br>
number = &lt;digit+&gt;:ds -&gt; int(ds) <br>
expr = number:left ( &rsquo;+&rsquo; number:right -&gt; left
+ right <br>
| -&gt; left) <br>
&quot;&quot;&quot;, {}) <br>
print x(&quot;17+34&quot;).expr() <br>
print x(&quot;18&quot;).expr()</p>

<p style="margin-top: 1em">51 <br>
18</p>

<p style="margin-top: 1em">Parentheses group expressions
just like in Python. the &rsquo;|&rsquo; operator is like or
in Python - it short-circuits. It tries each expression
until it finds one that matches. For <br>
&quot;17+34&quot;, the number rule matches &quot;17&quot;,
then Parsley tries to match + followed by another number.
Since &quot;+&quot; and &quot;34&quot; are the next things
in the input, those match, and it then <br>
runs the Python expression left + right and returns its
value. For the input &quot;18&quot; it does the same, but +
does not match, so Parsley tries the next thing after |.
Since this is <br>
just a Python expression, the match succeeds and the number
18 is returned.</p>

<p style="margin-top: 1em">Now let&rsquo;s add
subtraction:</p>

<p style="margin-top: 1em">digit = anything:x ?(x in
&rsquo;0123456789&rsquo;) <br>
number = &lt;digit+&gt;:ds -&gt; int(ds) <br>
expr = number:left ( &rsquo;+&rsquo; number:right -&gt; left
+ right <br>
| &rsquo;-&rsquo; number:right -&gt; left - right <br>
| -&gt; left)</p>

<p style="margin-top: 1em">This will accept things like
&rsquo;5-4&rsquo; now.</p>

<p style="margin-top: 1em">Since parsing numbers is so
common and useful, Parsley actually has &rsquo;digit&rsquo;
as a builtin rule, so we don&rsquo;t even need to define it
ourselves. We&rsquo;ll leave it out in further exam&acirc;
<br>
ples and rely on the version Parsley provides.</p>

<p style="margin-top: 1em">Normally we like to allow
whitespace in our expressions, so let&rsquo;s add some
support for spaces:</p>

<p style="margin-top: 1em">number = &lt;digit+&gt;:ds -&gt;
int(ds) <br>
ws = &rsquo; &rsquo;* <br>
expr = number:left ws (&rsquo;+&rsquo; ws number:right -&gt;
left + right <br>
|&rsquo;-&rsquo; ws number:right -&gt; left - right <br>
| -&gt; left)</p>

<p style="margin-top: 1em">Now we can handle &quot;17
+34&quot;, &quot;2 - 1&quot;, etc.</p>

<p style="margin-top: 1em">We could go ahead and add
multiplication and division here (and hopefully it&rsquo;s
obvious how that would work), but let&rsquo;s complicate
things further and allow multiple operations in <br>
our expressions -- things like &quot;1 - 2 + 3&quot;.</p>

<p style="margin-top: 1em">There&rsquo;s a couple different
ways to do this. Possibly the easiest is to build a list of
numbers and operations, then do the math.:</p>

<p style="margin-top: 1em">x =
parsley.makeGrammar(&quot;&quot;&quot; <br>
number = &lt;digit+&gt;:ds -&gt; int(ds) <br>
ws = &rsquo; &rsquo;* <br>
add = &rsquo;+&rsquo; ws number:n -&gt; (&rsquo;+&rsquo;, n)
<br>
sub = &rsquo;-&rsquo; ws number:n -&gt; (&rsquo;-&rsquo;, n)
<br>
addsub = ws (add | sub) <br>
expr = number:left (addsub+:right -&gt; right <br>
| -&gt; left) <br>
&quot;&quot;&quot;, {}) <br>
print x(&quot;1 + 2 - 3&quot;).expr()</p>

<p style="margin-top: 1em">[(&rsquo;+&rsquo;, 2),
(&rsquo;-, 3)]</p>

<p style="margin-top: 1em">Oops, this is only half the job
done. We&rsquo;re collecting the operators and values, but
now we need to do the actual calculation. The easiest way to
do it is probably to write a <br>
Python function and call it from inside the grammar.</p>

<p style="margin-top: 1em">So far we have been passing an
empty dict as the second argument to makeGrammar. This is a
dict of variable bindings that can be used in Python
expressions in the grammar. So we <br>
can pass Python objects, such as functions, this way:</p>

<p style="margin-top: 1em">def calculate(start, pairs):
<br>
result = start <br>
for op, value in pairs: <br>
if op == &rsquo;+&rsquo;: <br>
result += value <br>
elif op == &rsquo;-&rsquo;: <br>
result -= value <br>
return result <br>
x = parsley.makeGrammar(&quot;&quot;&quot; <br>
number = &lt;digit+&gt;:ds -&gt; int(ds) <br>
ws = &rsquo; &rsquo;* <br>
add = &rsquo;+&rsquo; ws number:n -&gt; (&rsquo;+&rsquo;, n)
<br>
sub = &rsquo;-&rsquo; ws number:n -&gt; (&rsquo;-&rsquo;, n)
<br>
addsub = ws (add | sub) <br>
expr = number:left (addsub+:right -&gt; calculate(left,
right) <br>
| -&gt; left) <br>
&quot;&quot;&quot;, {&quot;calculate&quot;: calculate}) <br>
print x(&quot;4 + 5 - 6&quot;).expr()</p>

<p style="margin-top: 1em">3</p>

<p style="margin-top: 1em">Introducing this function lets
us simplify even further: instead of using addsub+, we can
use addsub*, since calculate(left, []) will return left --
so now expr becomes:</p>

<p style="margin-top: 1em">expr = number:left addsub*:right
-&gt; calculate(left, right)</p>

<p style="margin-top: 1em">So now let&rsquo;s look at
adding multiplication and division. Here, we run into
precedence rules: should &quot;4 * 5 + 6&quot; give us 26,
or 44? The traditional choice is for multiplication <br>
and division to take precedence over addition and
subtraction, so the answer should be 26. We&rsquo;ll resolve
this by making sure multiplication and division happen
before addition <br>
and subtraction are considered:</p>

<p style="margin-top: 1em">def calculate(start, pairs):
<br>
result = start <br>
for op, value in pairs: <br>
if op == &rsquo;+&rsquo;: <br>
result += value <br>
elif op == &rsquo;-&rsquo;: <br>
result -= value <br>
elif op == &rsquo;*&rsquo;: <br>
result *= value <br>
elif op == &rsquo;/&rsquo;: <br>
result /= value <br>
return result <br>
x = parsley.makeGrammar(&quot;&quot;&quot; <br>
number = &lt;digit+&gt;:ds -&gt; int(ds) <br>
ws = &rsquo; &rsquo;* <br>
add = &rsquo;+&rsquo; ws expr2:n -&gt; (&rsquo;+&rsquo;, n)
<br>
sub = &rsquo;-&rsquo; ws expr2:n -&gt; (&rsquo;-&rsquo;, n)
<br>
mul = &rsquo;*&rsquo; ws number:n -&gt; (&rsquo;*&rsquo;, n)
<br>
div = &rsquo;/&rsquo; ws number:n -&gt; (&rsquo;/&rsquo;,
n)</p>

<p style="margin-top: 1em">addsub = ws (add | sub) <br>
muldiv = ws (mul | div)</p>

<p style="margin-top: 1em">expr = expr2:left addsub*:right
-&gt; calculate(left, right) <br>
expr2 = number:left muldiv*:right -&gt; calculate(left,
right) <br>
&quot;&quot;&quot;, {&quot;calculate&quot;: calculate}) <br>
print x(&quot;4 * 5 + 6&quot;).expr()</p>

<p style="margin-top: 1em">26</p>

<p style="margin-top: 1em">Notice particularly that add,
sub, and expr all call the expr2 rule now where they called
number before. This means that all the places where a number
was expected previously, a <br>
multiplication or division expression can appear
instead.</p>

<p style="margin-top: 1em">Finally let&rsquo;s add
parentheses, so you can override the precedence and write
&quot;4 * (5 + 6)&quot; when you do want 44. We&rsquo;ll do
this by adding a value rule that accepts either a number
<br>
or an expression in parentheses, and replace existing calls
to number with calls to value.</p>

<p style="margin-top: 1em">def calculate(start, pairs):
<br>
result = start <br>
for op, value in pairs: <br>
if op == &rsquo;+&rsquo;: <br>
result += value <br>
elif op == &rsquo;-&rsquo;: <br>
result -= value <br>
elif op == &rsquo;*&rsquo;: <br>
result *= value <br>
elif op == &rsquo;/&rsquo;: <br>
result /= value <br>
return result <br>
x = parsley.makeGrammar(&quot;&quot;&quot; <br>
number = &lt;digit+&gt;:ds -&gt; int(ds) <br>
parens = &rsquo;(&rsquo; ws expr:e ws &rsquo;)&rsquo; -&gt;
e <br>
value = number | parens <br>
ws = &rsquo; &rsquo;* <br>
add = &rsquo;+&rsquo; ws expr2:n -&gt; (&rsquo;+&rsquo;, n)
<br>
sub = &rsquo;-&rsquo; ws expr2:n -&gt; (&rsquo;-&rsquo;, n)
<br>
mul = &rsquo;*&rsquo; ws value:n -&gt; (&rsquo;*&rsquo;, n)
<br>
div = &rsquo;/&rsquo; ws value:n -&gt; (&rsquo;/&rsquo;,
n)</p>

<p style="margin-top: 1em">addsub = ws (add | sub) <br>
muldiv = ws (mul | div)</p>

<p style="margin-top: 1em">expr = expr2:left addsub*:right
-&gt; calculate(left, right) <br>
expr2 = value:left muldiv*:right -&gt; calculate(left,
right) <br>
&quot;&quot;&quot;, {&quot;calculate&quot;: calculate})</p>

<p style="margin-top: 1em">print x(&quot;4 * (5 + 6) +
1&quot;).expr()</p>

<p style="margin-top: 1em">45</p>

<p style="margin-top: 1em">And there you have it: a
four-function calculator with precedence and
parentheses.</p>

<p style="margin-top: 1em">PARSLEY TUTORIAL PART II:
PARSING STRUCTURED DATA <br>
Now that you are familiar with the basics of Parsley syntax,
let&rsquo;s look at a more realistic example: a JSON
parser.</p>

<p style="margin-top: 1em">The JSON spec on
http://json.org/ describes the format, and we can adapt its
description to a parser. We&rsquo;ll write the Parsley rules
in the same order as the grammar rules in the <br>
right sidebar on the JSON site, starting with the top-level
rule, &rsquo;object&rsquo;.</p>

<p style="margin-top: 1em">object = ws &rsquo;{&rsquo;
members:m ws &rsquo;}&rsquo; -&gt; dict(m)</p>

<p style="margin-top: 1em">Parsley defines a builtin rule
ws which consumes any spaces, tabs, or newlines it can.</p>

<p style="margin-top: 1em">Since JSON objects are
represented in Python as dicts, and dict takes a list of
pairs, we need a rule to collect name/value pairs inside an
object expression.</p>

<p style="margin-top: 1em">members = (pair:first (ws
&rsquo;,&rsquo; pair)*:rest -&gt; [first] + rest) <br>
| -&gt; []</p>

<p style="margin-top: 1em">This handles the three cases for
object contents: one, multiple, or zero pairs. A name/value
pair is separated by a colon. We use the builtin rule spaces
to consume any white&acirc; <br>
space after the colon:</p>

<p style="margin-top: 1em">pair = ws string:k ws
&rsquo;:&rsquo; value:v -&gt; (k, v)</p>

<p style="margin-top: 1em">Arrays, similarly, are sequences
of array elements, and are represented as Python lists.</p>

<p style="margin-top: 1em">array = &rsquo;[&rsquo;
elements:xs ws &rsquo;]&rsquo; -&gt; xs <br>
elements = (value:first (ws &rsquo;,&rsquo; value)*:rest
-&gt; [first] + rest) | -&gt; []</p>

<p style="margin-top: 1em">Values can be any JSON
expression.</p>

<p style="margin-top: 1em">value = ws (string | number |
object | array <br>
| &rsquo;true&rsquo; -&gt; True <br>
| &rsquo;false&rsquo; -&gt; False <br>
| &rsquo;null&rsquo; -&gt; None)</p>

<p style="margin-top: 1em">Strings are sequences of zero or
more characters between double quotes. Of course, we need to
deal with escaped characters as well. This rule introduces
the operator ~, which <br>
does negative lookahead; if the expression following it
succeeds, its parse will fail. If the expression fails, the
rest of the parse continues. Either way, no input will be
con&acirc; <br>
sumed.</p>

<p style="margin-top: 1em">string = &rsquo;&quot;&rsquo;
(escapedChar | ~&rsquo;&quot;&rsquo; anything)*:c
&rsquo;&quot;&rsquo; -&gt; &rsquo;&rsquo;.join(c)</p>

<p style="margin-top: 1em">This is a common pattern, so
let&rsquo;s examine it step by step. This will match leading
whitespace and then a double quote character. It then
matches zero or more characters. If it&rsquo;s <br>
not an escapedChar (which will start with a backslash), we
check to see if it&rsquo;s a double quote, in which case we
want to end the loop. If it&rsquo;s not a double quote, we
match it <br>
using the rule anything, which accepts a single character of
any kind, and continue. Finally, we match the ending double
quote and return the characters in the string. We cannot
<br>
use the &lt;&gt; syntax in this case because we don&rsquo;t
want a literal slice of the input -- we want escape
sequences to be replaced with the character they
represent.</p>

<p style="margin-top: 1em">It&rsquo;s very common to use ~
for &quot;match until&quot; situations where you want to
keep parsing only until an end marker is found. Similarly,
~~ is positive lookahead: it succeed if its <br>
expression succeeds but not consume any input.</p>

<p style="margin-top: 1em">The escapedChar rule should not
be too surprising: we match a backslash then whatever escape
code is given.</p>

<p style="margin-top: 1em">escapedChar = &rsquo;\&rsquo;
((&rsquo;&quot;&rsquo; -&gt; &rsquo;&quot;&rsquo;)
|(&rsquo;\&rsquo; -&gt; &rsquo;\&rsquo;) <br>
|(&rsquo;/&rsquo; -&gt; &rsquo;/&rsquo;) |(&rsquo;b&rsquo;
-&gt; &rsquo;) <br>
|(&rsquo;f&rsquo; -&gt; &rsquo;) |(&rsquo;n&rsquo; -&gt;
&rsquo;0)&rsquo;) |(&rsquo;t&rsquo; -&gt; &rsquo;&rsquo;)
<br>
|(&rsquo;r&rsquo; -&gt; &rsquo; <br>
|(&rsquo;&acute;&rsquo; -&gt; &rsquo;&acute;&rsquo;) |
escapedUnicode)</p>

<p style="margin-top: 1em">Unicode escapes (of the form
2603) require matching four hex digits, so we use the
repetition operator {}, which works like + or * except
taking either a {min, max} pair or <br>
simply a {number} indicating the exact number of
repetitions.</p>

<p style="margin-top: 1em">hexdigit = :x ?(x in
&rsquo;0123456789abcdefABCDEF&rsquo;) -&gt; x <br>
escapedUnicode = &rsquo;u&rsquo; &lt;hexdigit{4}&gt;:hs
-&gt; unichr(int(hs, 16))</p>

<p style="margin-top: 1em">With strings out of the way, we
advance to numbers, both integer and floating-point.</p>

<p style="margin-top: 1em">number = spaces (&rsquo;-&rsquo;
| -&gt; &rsquo;&rsquo;):sign (intPart:ds (floatPart(sign ds)
<br>
| -&gt; int(sign + ds)))</p>

<p style="margin-top: 1em">Here we vary from the json.org
description a little and move sign handling up into the
number rule. We match either an intPart followed by a
floatPart or just an intPart by <br>
itself.</p>

<p style="margin-top: 1em">digit = :x ?(x in
&rsquo;0123456789&rsquo;) -&gt; x <br>
digits = &lt;digit*&gt; <br>
digit1_9 = :x ?(x in &rsquo;123456789&rsquo;) -&gt; x</p>

<p style="margin-top: 1em">intPart = (digit1_9:first
digits:rest -&gt; first + rest) | digit <br>
floatPart :sign :ds = &lt;(&rsquo;.&rsquo; digits exponent?)
| exponent&gt;:tail <br>
-&gt; float(sign + ds + tail) <br>
exponent = (&rsquo;e&rsquo; | &rsquo;E&rsquo;)
(&rsquo;+&rsquo; | &rsquo;-&rsquo;)? digits</p>

<p style="margin-top: 1em">In JSON, multi-digit numbers
cannot start with 0 (since that is Javascript&rsquo;s syntax
for octal numbers), so intPart uses digit1_9 to exclude it
in the first position.</p>

<p style="margin-top: 1em">The floatPart rule takes two
parameters, sign and ds. Our number rule passes values for
these when it invokes floatPart, letting us avoid
duplication of work within the rule. <br>
Note that pattern matching on arguments to rules works the
same as on the string input to the parser. In this case, we
provide no pattern, just a name: :ds is the same as
any&acirc; <br>
thing:ds.</p>

<p style="margin-top: 1em">(Also note that our float rule
cheats a little: it does not really parse floating-point
numbers, it merely recognizes them and passes them to
Python&rsquo;s float builtin to actually <br>
produce the value.)</p>

<p style="margin-top: 1em">The full version of this parser
and its test cases can be found in the examples directory in
the Parsley distribution.</p>

<p style="margin-top: 1em">PARSLEY TUTORIAL PART III:
PARSING NETWORK DATA <br>
This tutorial assumes basic knowledge of writing Twisted TCP
clients or servers.</p>

<p style="margin-top: 1em">Basic parsing <br>
Parsing data that comes in over the network can be difficult
due to that there is no guarantee of receiving whole
messages. Buffering is often complicated by protocols
switching <br>
between using fixed-width messages and delimiters for
framing. Fortunately, Parsley can remove all of this
tedium.</p>

<p style="margin-top: 1em">With parsley.makeProtocol(),
Parsley can generate a Twisted IProtocol-implementing class
which will match incoming network data using Parsley grammar
rules. Before getting <br>
started with makeProtocol(), let&rsquo;s build a grammar for
netstrings. The netstrings protocol is very simple:</p>

<p style="margin-top: 1em">4:spam,4:eggs,</p>

<p style="margin-top: 1em">This stream contains two
netstrings: spam, and eggs. The data is prefixed with one or
more ASCII digits followed by a :, and suffixed with a ,.
So, a Parsley grammar to match a <br>
netstring would look like:</p>

<p style="margin-top: 1em">nonzeroDigit = digit:x ?(x !=
&rsquo;0&rsquo;) <br>
digits = &lt;&rsquo;0&rsquo; | nonzeroDigit digit*&gt;:i
-&gt; int(i)</p>

<p style="margin-top: 1em">netstring = digits:length
&rsquo;:&rsquo; &lt;anything{length}&gt;:string
&rsquo;,&rsquo; -&gt; string</p>

<p style="margin-top: 1em">makeProtocol() takes, in
addition to a grammar, a factory for a &quot;sender&quot;
and a factory for a &quot;receiver&quot;. In the system of
objects managed by the ParserProtocol, the sender is in <br>
charge of writing data to the wire, and the receiver has
methods called on it by the Parsley rules. To demonstrate
it, here is the final piece needed in the Parsley grammar
for <br>
netstrings:</p>

<p style="margin-top: 1em">receiveNetstring =
netstring:string -&gt;
receiver.netstringReceived(string)</p>

<p style="margin-top: 1em">The receiver is always available
in Parsley rules with the name receiver, allowing Parsley
rules to call methods on it.</p>

<p style="margin-top: 1em">When data is received over the
wire, the ParserProtocol tries to match the received data
against the current rule. If the current rule requires more
data to finish matching, the <br>
ParserProtocol stops and waits until more data comes in,
then tries to continue matching. This repeats until the
current rule is completely matched, and then the
ParserProtocol <br>
starts matching any leftover data against the current rule
again.</p>

<p style="margin-top: 1em">One specifies the current rule
by setting a currentRule attribute on the receiver, which
the ParserProtocol looks at before doing any parsing.
Changing the current rule is <br>
addressed in the Switching rules section.</p>

<p style="margin-top: 1em">Since the ParserProtocol will
never modify the currentRule attribute itself, the default
behavior is to keep using the same rule. Parsing netstrings
doesn&rsquo;t require any rule <br>
changing, so, the default behavior of continuing to use the
same rule is fine.</p>

<p style="margin-top: 1em">Both the sender factory and
receiver factory are constructed when the
ParserProtocol&rsquo;s connection is established. The sender
factory is a one-argument callable which will be <br>
passed the ParserProtocol&rsquo;s Transport. This allows the
sender to send data over the transport. For example:</p>

<p style="margin-top: 1em">class NetstringSender(object):
<br>
def __init__(self, transport): <br>
self.transport = transport</p>

<p style="margin-top: 1em">def sendNetstring(self, string):
<br>
self.transport.write(&rsquo;%d:%s,&rsquo; % (len(string),
string))</p>

<p style="margin-top: 1em">The receiver factory is another
one-argument callable which is passed the constructed
sender. The returned object must at least have
prepareParsing() and finishParsing() methods. <br>
prepareParsing() is called with the ParserProtocol instance
when a connection is established (i.e. in the connectionMade
of the ParserProtocol) and finishParsing() is called when
<br>
a connection is closed (i.e. in the connectionLost of the
ParserProtocol).</p>

<p style="margin-top: 1em">NOTE: <br>
Both the receiver factory and its returned object&rsquo;s
prepareParsing() are called at in the ParserProtocol&rsquo;s
connectionMade method; this separation is for ease of
testing <br>
receivers.</p>

<p style="margin-top: 1em">To demonstrate a receiver, here
is a simple receiver that receives netstrings and echos the
same netstrings back:</p>

<p style="margin-top: 1em">class NetstringReceiver(object):
<br>
currentRule = &rsquo;receiveNetstring&rsquo;</p>

<p style="margin-top: 1em">def __init__(self, sender): <br>
self.sender = sender</p>

<p style="margin-top: 1em">def prepareParsing(self,
parser): <br>
pass</p>

<p style="margin-top: 1em">def finishParsing(self, reason):
<br>
pass</p>

<p style="margin-top: 1em">def netstringReceived(self,
string): <br>
self.sender.sendNetstring(string)</p>

<p style="margin-top: 1em">Putting it all together, the
Protocol is constructed using the grammar, sender factory,
and receiver factory:</p>

<p style="margin-top: 1em">NetstringProtocol =
makeProtocol( <br>
grammar, NetstringSender, NetstringReceiver)</p>

<p style="margin-top: 1em">The complete script is also
available for download.</p>

<p style="margin-top: 1em">Intermezzo: error reporting <br>
If an exception is raised from within Parsley during
parsing, whether it&rsquo;s due to input not matching the
current rule or an exception being raised from code the
grammar calls, <br>
the connection will be immediately closed. The traceback
will be captured as a Failure and passed to the
finishParsing() method of the receiver.</p>

<p style="margin-top: 1em">At present, there is no way to
recover from failure.</p>

<p style="margin-top: 1em">Composing senders and receivers
<br>
The design of senders and receivers is intentional to make
composition easy: no subclassing is required. While the
composition is easy enough to do on your own, Parsley
provides <br>
a function: stack(). It takes a base factory followed by
zero or more wrappers.</p>

<p style="margin-top: 1em">Its use is extremely simple:
stack(x, y, z) will return a callable suitable either as a
sender or receiver factory which will, when called with an
argument, return x(y(z(argu&acirc; <br>
ment))).</p>

<p style="margin-top: 1em">An example of wrapping a sender
factory:</p>

<p style="margin-top: 1em">class
NetstringReversalWrapper(object): <br>
def __init__(self, wrapped): <br>
self.wrapped = wrapped</p>

<p style="margin-top: 1em">def sendNetstring(self, string):
<br>
self.wrapped.sendNetstring(string[::-1])</p>

<p style="margin-top: 1em">And then, constructing the
Protocol:</p>

<p style="margin-top: 1em">NetstringProtocol =
makeProtocol( <br>
grammar, <br>
stack(NetstringReversalWrapper, NetstringSender), <br>
NetstringReceiver)</p>

<p style="margin-top: 1em">A wrapper doesn&rsquo;t need to
call the same methods on the thing it&rsquo;s wrapping. Also
note that in most cases, it&rsquo;s important to forward
unknown methods on to the wrapped object. An <br>
example of wrapping a receiver:</p>

<p style="margin-top: 1em">class
NetstringSplittingWrapper(object): <br>
def __init__(self, wrapped): <br>
self.wrapped = wrapped</p>

<p style="margin-top: 1em">def netstringReceived(self,
string): <br>
splitpoint = len(string) // 2 <br>

self.wrapped.netstringFirstHalfReceived(string[:splitpoint])
<br>

self.wrapped.netstringSecondHalfReceived(string[splitpoint:])</p>

<p style="margin-top: 1em">def __getattr__(self, attr):
<br>
return getattr(self.wrapped, attr)</p>

<p style="margin-top: 1em">The corresponding receiver and
again, constructing the Protocol:</p>

<p style="margin-top: 1em">class
SplitNetstringReceiver(object): <br>
currentRule = &rsquo;receiveNetstring&rsquo;</p>

<p style="margin-top: 1em">def __init__(self, sender): <br>
self.sender = sender</p>

<p style="margin-top: 1em">def prepareParsing(self,
parser): <br>
pass</p>

<p style="margin-top: 1em">def finishParsing(self, reason):
<br>
pass</p>

<p style="margin-top: 1em">def
netstringFirstHalfReceived(self, string): <br>
self.sender.sendNetstring(string)</p>

<p style="margin-top: 1em">def
netstringSecondHalfReceived(self, string): <br>
pass</p>

<p style="margin-top: 1em">NetstringProtocol =
makeProtocol( <br>
grammar, <br>
stack(NetstringReversalWrapper, NetstringSender),</p>

<p style="margin-top: 1em">The complete script is also
available for download.</p>

<p style="margin-top: 1em">Switching rules <br>
As mentioned before, it&rsquo;s possible to change the
current rule. Imagine a &quot;netstrings2&quot; protocol
that looks like this:</p>

<p style="margin-top: 1em">3:foo,3;bar,4:spam,4;eggs,</p>

<p style="margin-top: 1em">That is, the protocol alternates
between using : and using ; delimiting data length and the
data. The amended grammar would look something like
this:</p>

<p style="margin-top: 1em">nonzeroDigit = digit:x ?(x !=
&rsquo;0&rsquo;) <br>
digits = &lt;&rsquo;0&rsquo; | nonzeroDigit digit*&gt;:i
-&gt; int(i) <br>
netstring :delimiter = digits:length delimiter
&lt;anything{length}&gt;:string &rsquo;,&rsquo; -&gt;
string</p>

<p style="margin-top: 1em">colon = digits:length
&rsquo;:&rsquo; &lt;anything{length}&gt;:string
&rsquo;,&rsquo; -&gt;
receiver.netstringReceived(&rsquo;:&rsquo;, string) <br>
semicolon = digits:length &rsquo;;&rsquo;
&lt;anything{length}&gt;:string &rsquo;,&rsquo; -&gt;
receiver.netstringReceived(&rsquo;;&rsquo;, string)</p>

<p style="margin-top: 1em">Changing the current rule is as
simple as changing the currentRule attribute on the
receiver. So, the netstringReceived method could look like
this:</p>

<p style="margin-top: 1em">def netstringReceived(self,
delimiter, string): <br>
self.sender.sendNetstring(string) <br>
if delimiter == &rsquo;:&rsquo;: <br>
self.currentRule = &rsquo;semicolon&rsquo; <br>
else: <br>
self.currentRule = &rsquo;colon&rsquo;</p>

<p style="margin-top: 1em">While changing the currentRule
attribute can be done at any time, the ParserProtocol only
examines the currentRule at the beginning of parsing and
after a rule has finished <br>
matching. As a result, if the currentRule changes, the
ParserProtocol will wait until the current rule is
completely matched before switching rules.</p>

<p style="margin-top: 1em">The complete script is also
available for download.</p>

<p style="margin-top: 1em">EXTENDING GRAMMARS AND
INHERITANCE <br>
warning <br>
Unfinished</p>

<p style="margin-top: 1em">Another feature taken from OMeta
is grammar inheritance. We can write a grammar with rules
that override ones in a parent. If we load the grammar from
our calculator tutorial as <br>
Calc, we can extend it with some constants:</p>

<p style="margin-top: 1em">from parsley import makeGrammar
<br>
import math <br>
import calc <br>
calcGrammarEx = &quot;&quot;&quot; <br>
value = super | constant <br>
constant = &rsquo;pi&rsquo; -&gt; math.pi <br>
| &rsquo;e&rsquo; -&gt; math.e <br>
&quot;&quot;&quot; <br>
CalcEx = makeGrammar(calcGrammar, {&quot;math&quot;: math},
extends=calc.Calc)</p>

<p style="margin-top: 1em">Invoking the rule super calls
the rule value in Calc. If it fails to match, our new value
rule attempts to match a constant name.</p>

<p style="margin-top: 1em">TERML <br>
TermL (&quot;term-ell&quot;) is the Term Language, a small
expression-based language for representing arbitrary data in
a simple structured format. It is ideal for expressing
abstract syn&acirc; <br>
tax trees (ASTs) and other kinds of primitive data
trees.</p>

<p style="margin-top: 1em">Creating Terms <br>
&gt;&gt;&gt; from terml.nodes import termMaker as t <br>
&gt;&gt;&gt; t.Term() <br>
term(&rsquo;Term&rsquo;)</p>

<p style="margin-top: 1em">That&rsquo;s it! We&rsquo;ve
created an empty term, Term, with nothing inside.</p>

<p style="margin-top: 1em">&gt;&gt;&gt; t.Num(1) <br>
term(&rsquo;Num(1)&rsquo;) <br>
&gt;&gt;&gt; t.Outer(t.Inner()) <br>
term(&rsquo;Outer(Inner)&rsquo;)</p>

<p style="margin-top: 1em">We can see that terms are not
just namedtuple lookalikes. They have their own internals
and store data in a slightly different and more structured
way than a normal tuple.</p>

<p style="margin-top: 1em">Parsing Terms <br>
Parsley can parse terms from streams. Terms can contain any
kind of parseable data, including other terms. Returning to
the ubiquitous calculator example:</p>

<p style="margin-top: 1em">add = Add(:x, :y) -&gt; x +
y</p>

<p style="margin-top: 1em">Here this rule matches a term
called Add which has two components, bind those components
to a couple of names (x and y), and return their sum. If
this rule were applied to a term <br>
like Add(3, 5), it would return 8.</p>

<p style="margin-top: 1em">Terms can be nested, too.
Here&rsquo;s an example that performs a slightly contrived
match on a negated term inside an addition:</p>

<p style="margin-top: 1em">add_negate = Add(:x, Negate(:y))
-&gt; x - y</p>

<p style="margin-top: 1em">PARSLEY REFERENCE <br>
Basic syntax <br>
foo = ....: <br>
Define a rule named foo.</p>

<p style="margin-top: 1em">expr1 expr2: <br>
Match expr1, and then match expr2 if it succeeds, returning
the value of expr2. Like Python&rsquo;s and.</p>

<p style="margin-top: 1em">expr1 | expr2: <br>
Try to match expr1 --- if it fails, match expr2 instead.
Like Python&rsquo;s or.</p>

<p style="margin-top: 1em">expr*: Match expr zero or more
times, returning a list of matches.</p>

<p style="margin-top: 1em">expr+: Match expr one or more
times, returning a list of matches.</p>

<p style="margin-top: 1em">expr?: Try to match expr.
Returns None if it fails to match.</p>

<p style="margin-top: 1em">expr{n, m}: <br>
Match expr at least n times, and no more than m times.</p>

<p style="margin-top: 1em">expr{n}: <br>
Match expr n times exactly.</p>

<p style="margin-top: 1em">~expr: Negative lookahead. Fails
if the next item in the input matches expr. Consumes no
input.</p>

<p style="margin-top: 1em">~~expr: <br>
Positive lookahead. Fails if the next item in the input does
not match expr. Consumes no input.</p>

<p style="margin-top: 1em">ruleName or ruleName(arg1 arg2
etc): <br>
Call the rule ruleName, possibly with args.</p>

<p style="margin-top: 1em">&rsquo;x&rsquo;: Match the
literal character &rsquo;x&rsquo;.</p>

<p style="margin-top: 1em">&lt;expr&gt;: <br>
Returns the string consumed by matching expr. Good for
tokenizing rules.</p>

<p style="margin-top: 1em">expr:name: <br>
Bind the result of expr to the local variable name.</p>

<p style="margin-top: 1em">-&gt; pythonExpression: <br>
Evaluate the given Python expression and return its result.
Can be used inside parentheses too!</p>

<p style="margin-top: 1em">!(pythonExpression): <br>
Invoke a Python expression as an action.</p>

<p style="margin-top: 1em">?(pythonExpression): <br>
Fail if the Python expression is false, Returns True
otherwise.</p>

<p style="margin-top: 1em">expr ^(CustomLabel): <br>
If the expr fails, the exception raised will contain
CustomLabel. Good for providing more context when a rule is
broken. CustomLabel can contain any character other than
<br>
&quot;(&quot; and &quot;)&quot;.</p>

<p style="margin-top: 1em">Comments like Python comments
are supported as well, starting with # and extending to the
end of the line.</p>

<p style="margin-top: 1em">Python API <br>
Protocol parsing API <br>
class ometa.protocol.ParserProtocol <br>
The Twisted Protocol subclass used for parsing stream
protocols using Parsley. It has two public attributes:</p>

<p style="margin-top: 1em">sender After the connection is
established, this attribute will refer to the sender created
by the sender factory of the ParserProtocol.</p>

<p style="margin-top: 1em">receiver <br>
After the connection is established, this attribute will
refer to the receiver created by the receiver factory of the
ParserProtocol.</p>

<p style="margin-top: 1em">It&rsquo;s common to also add a
factory attribute to the ParserProtocol from its
factory&rsquo;s buildProtocol method, but this isn&rsquo;t
strictly required or guaranteed to be present.</p>

<p style="margin-top: 1em">Subclassing or instantiating
ParserProtocol is not necessary; makeProtocol() is
sufficient and requires less boilerplate.</p>

<p style="margin-top: 1em">class ometa.protocol.Receiver
<br>
Receiver is not a real class but is used here for
demonstration purposes to indicate the required API.</p>

<p style="margin-top: 1em">currentRule <br>
ParserProtocol examines the currentRule attribute at the
beginning of parsing as well as after every time a rule has
completely matched. At these times, the rule <br>
with the same name as the value of currentRule will be
selected to start parsing the incoming stream of data.</p>

<p style="margin-top: 1em">prepareParsing(parserProtocol)
<br>
prepareParsing() is called after the ParserProtocol has
established a connection, and is passed the ParserProtocol
instance itself.</p>

<p style="margin-top: 1em">Parameters <br>
parserProtocol -- An instance of ProtocolParser.</p>

<p style="margin-top: 1em">finishParsing(reason) <br>
finishParsing() is called if an exception was raised during
parsing, or when the ParserProtocol has lost its connection,
whichever comes first. It will only be <br>
called once.</p>

<p style="margin-top: 1em">An exception raised during
parsing can be due to incoming data that doesn&rsquo;t match
the current rule or an exception raised calling python code
during matching.</p>

<p style="margin-top: 1em">Parameters <br>
reason -- A Failure encapsulating the reason parsing has
ended.</p>

<p style="margin-top: 1em">Senders do not have any required
API as ParserProtocol will never call methods on a
sender.</p>

<p style="margin-top: 1em">Built-in Parsley Rules <br>
anything: <br>
Matches a single character from the input.</p>

<p style="margin-top: 1em">letter: <br>
Matches a single ASCII letter.</p>

<p style="margin-top: 1em">digit: Matches a decimal
digit.</p>

<p style="margin-top: 1em">letterOrDigit: <br>
Combines the above.</p>

<p style="margin-top: 1em">end: Matches the end of
input.</p>

<p style="margin-top: 1em">ws: Matches zero or more spaces,
tabs, or newlines.</p>

<p style="margin-top: 1em">exactly(char): <br>
Matches the character char.</p>

<p style="margin-top: 1em">AUTHOR <br>
Allen Short</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2013, Allen Short</p>

<p style="margin-top: 1em">1.3 Feb 11, 2017 PARSLEY(1)</p>
<hr>
</body>
</html>
