<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PARSLEY(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PARSLEY(1)</td>
    <td class="head-vol">Parsley</td>
    <td class="head-rtitle">PARSLEY(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
parsley - Parsley Documentation
<div style="height: 1.00em;">&#x00A0;</div>
Contents:
<h1 class="Sh" title="Sh" id="PARSLEY_TUTORIAL_PART_I:_BASICS_AND_SYNTAX"><a class="selflink" href="#PARSLEY_TUTORIAL_PART_I:_BASICS_AND_SYNTAX">PARSLEY
  TUTORIAL PART I: BASICS AND SYNTAX</a></h1>
<h2 class="Ss" title="Ss" id="From_Regular_Expressions_To_Grammars"><a class="selflink" href="#From_Regular_Expressions_To_Grammars">From
  Regular Expressions To Grammars</a></h2>
Parsley is a pattern matching and parsing tool for Python programmers.
<div style="height: 1.00em;">&#x00A0;</div>
Most Python programmers are familiar with regular expressions, as provided by
  Python's <i>re</i> module. To use it, you provide a string that describes the
  pattern you want to match, and your input.
<div style="height: 1.00em;">&#x00A0;</div>
For example:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; x = re.compile(&quot;a(b|c)d+e&quot;)
&gt;&gt;&gt; x.match(&quot;abddde&quot;)
&lt;_sre.SRE_Match object at 0x7f587af54af8&gt;
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
You can do exactly the same sort of thing in Parsley:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
&gt;&gt;&gt; import parsley
&gt;&gt;&gt; x = parsley.makeGrammar(&quot;foo = 'a' ('b' | 'c') 'd'+ 'e'&quot;, {})
&gt;&gt;&gt; x(&quot;abdde&quot;).foo()
'e'
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
From this small example, a couple differences between regular expressions and
  Parsley grammars can be seen:
<h2 class="Ss" title="Ss" id="Parsley_Grammars_Have_Named_Rules"><a class="selflink" href="#Parsley_Grammars_Have_Named_Rules">Parsley
  Grammars Have Named Rules</a></h2>
A Parsley grammar can have many rules, and each has a name. The example above
  has a single rule named <i>foo</i>. Rules can call each other; calling rules
  in Parsley works like calling functions in Python. Here is another way to
  write the grammar above:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
foo = 'a' baz 'd'+ 'e'
baz = 'b' | 'c'
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Parsley_Grammars_Are_Expressions"><a class="selflink" href="#Parsley_Grammars_Are_Expressions">Parsley
  Grammars Are Expressions</a></h2>
Calling <i>match</i> for a regular expression returns a match object if the
  match succeeds or None if it fails. Parsley parsers return the value of last
  expression in the rule. Behind the scenes, Parsley turns each rule in your
  grammar into Python methods. In pseudo-Python code, it looks something like
  this:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
def foo(self):
    match('a')
    self.baz()
    match_one_or_more('d')
    return match('e')
<div class="Pp"></div>
def baz(self):
    return match('b') or match('c')
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The value of the last expression in the rule is what the rule returns. This is
  why our example returns 'e'.
<div style="height: 1.00em;">&#x00A0;</div>
The similarities to regular expressions pretty much end here, though. Having
  multiple named rules composed of expressions makes for a much more powerful
  tool, and now we're going to look at some more features that go even further.
<h2 class="Ss" title="Ss" id="Rules_Can_Embed_Python_Expressions"><a class="selflink" href="#Rules_Can_Embed_Python_Expressions">Rules
  Can Embed Python Expressions</a></h2>
Since these rules just turn into Python code eventually, we can stick some
  Python code into them ourselves. This is particularly useful for changing the
  return value of a rule. The Parsley expression for this is <i>-&gt;</i>. We
  can also bind the results of expressions to variable names and use them in
  Python code. So things like this are possible:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
x = parsley.makeGrammar(&quot;&quot;&quot;
foo = 'a':one baz:two 'd'+ 'e' -&gt; (one, two)
baz = 'b' | 'c'
&quot;&quot;&quot;, {})
print x(&quot;abdde&quot;).foo()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
('a', 'b')
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Literal match expressions like <i>'a'</i> return the character they match. Using
  a colon and a variable name after an expression is like assignment in Python.
  As a result, we can use those names in a Python expression - in this case,
  creating a tuple.
<div style="height: 1.00em;">&#x00A0;</div>
Another way to use Python code in a rule is to write custom tests for matching.
  Sometimes it's more convenient to write some Python that determines if a rule
  matches than to stick to Parsley expressions alone. For those cases, we can
  use <i>?()</i>. Here, we use the builtin rule <i>anything</i> to match a
  single character, then a Python predicate to decide if it's the one we want:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
digit = anything:x ?(x in '0123456789') -&gt; x
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This rule <i>digit</i> will match any decimal digit. We need the <i>-&gt; x</i>
  on the end to return the character rather than the value of the predicate
  expression, which is just <i>True</i>.
<h2 class="Ss" title="Ss" id="Repeated_Matches_Make_Lists"><a class="selflink" href="#Repeated_Matches_Make_Lists">Repeated
  Matches Make Lists</a></h2>
Like regular expressions, Parsley supports repeating matches. You can match an
  expression zero or more times with '* ', one or more times with '+', and a
  specific number of times with '{n, m}' or just '{n}'. Since all expressions in
  Parsley return a value, these repetition operators return a list containing
  each match they made.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
x = parsley.makeGrammar(&quot;&quot;&quot;
digit = anything:x ?(x in '0123456789') -&gt; x
number = digit+
&quot;&quot;&quot;, {})
print x(&quot;314159&quot;).number()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
['3', '1', '4', '1', '5', '9']
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The <i>number</i> rule repeatedly matches <i>digit</i> and collects the matches
  into a list. This gets us part way to turning a string like <i>314159</i> into
  an integer. All we need now is to turn the list back into a string and call
  <i>int()</i>:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
x = parsley.makeGrammar(&quot;&quot;&quot;
digit = anything:x ?(x in '0123456789') -&gt; x
number = digit+:ds -&gt; int(''.join(ds))
&quot;&quot;&quot;, {})
print x(&quot;8675309&quot;).number()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
8675309
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Collecting_Chunks_Of_Input"><a class="selflink" href="#Collecting_Chunks_Of_Input">Collecting
  Chunks Of Input</a></h2>
If it seemed kind of strange to break our input string up into a list and then
  reassemble it into a string using <i>join</i>, you're not alone. Parsley has a
  shortcut for this since it's a common case: you can use <i>&lt;&gt;</i> around
  a rule to make it return the slice of input it consumes, ignoring the actual
  return value of the rule. For example:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
x = parsley.makeGrammar(&quot;&quot;&quot;
digit = anything:x ?(x in '0123456789')
number = &lt;digit+&gt;:ds -&gt; int(ds)
&quot;&quot;&quot;, {})
print x(&quot;11235&quot;).number()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
11235
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Here, <i>&lt;digit+&gt;</i> returns the string <i>&quot;11235&quot;</i>, since
  that's the portion of the input that <i>digit+</i> matched. (In this case it's
  the entire input, but we'll see some more complex cases soon.) Since it
  ignores the list returned by <i>digit+</i>, leaving the <i>-&gt; x</i> out of
  <i>digit</i> doesn't change the result.
<h2 class="Ss" title="Ss" id="Building_A_Calculator"><a class="selflink" href="#Building_A_Calculator">Building
  A Calculator</a></h2>
Now let's look at using these rules in a more complicated parser. We have
  support for parsing numbers; let's do addition, as well.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
x = parsley.makeGrammar(&quot;&quot;&quot;
digit = anything:x ?(x in '0123456789')
number = &lt;digit+&gt;:ds -&gt; int(ds)
expr = number:left ( '+' number:right -&gt; left + right
                   | -&gt; left)
&quot;&quot;&quot;, {})
print x(&quot;17+34&quot;).expr()
print x(&quot;18&quot;).expr()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
51
18
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Parentheses group expressions just like in Python. the ' <i>|</i>' operator is
  like <i>or</i> in Python - it short-circuits. It tries each expression until
  it finds one that matches. For <i>&quot;17+34&quot;</i>, the <i>number</i>
  rule matches &quot;17&quot;, then Parsley tries to match <i>+</i> followed by
  another <i>number</i>. Since &quot;+&quot; and &quot;34&quot; are the next
  things in the input, those match, and it then runs the Python expression
  <i>left + right</i> and returns its value. For the input <i>&quot;18&quot;</i>
  it does the same, but <i>+</i> does not match, so Parsley tries the next thing
  after <i>|</i>. Since this is just a Python expression, the match succeeds and
  the number 18 is returned.
<div style="height: 1.00em;">&#x00A0;</div>
Now let's add subtraction:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
digit = anything:x ?(x in '0123456789')
number = &lt;digit+&gt;:ds -&gt; int(ds)
expr = number:left ( '+' number:right -&gt; left + right
                   | '-' number:right -&gt; left - right
                   | -&gt; left)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This will accept things like '5-4' now.
<div style="height: 1.00em;">&#x00A0;</div>
Since parsing numbers is so common and useful, Parsley actually has 'digit' as a
  builtin rule, so we don't even need to define it ourselves. We'll leave it out
  in further examples and rely on the version Parsley provides.
<div style="height: 1.00em;">&#x00A0;</div>
Normally we like to allow whitespace in our expressions, so let's add some
  support for spaces:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
number = &lt;digit+&gt;:ds -&gt; int(ds)
ws = ' '*
expr = number:left ws ('+' ws number:right -&gt; left + right
                      |'-' ws number:right -&gt; left - right
                      | -&gt; left)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Now we can handle &quot;17 +34&quot;, &quot;2 - 1&quot;, etc.
<div style="height: 1.00em;">&#x00A0;</div>
We could go ahead and add multiplication and division here (and hopefully it's
  obvious how that would work), but let's complicate things further and allow
  multiple operations in our expressions -- things like &quot;1 - 2 + 3&quot;.
<div style="height: 1.00em;">&#x00A0;</div>
There's a couple different ways to do this. Possibly the easiest is to build a
  list of numbers and operations, then do the math.:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
x = parsley.makeGrammar(&quot;&quot;&quot;
number = &lt;digit+&gt;:ds -&gt; int(ds)
ws = ' '*
add = '+' ws number:n -&gt; ('+', n)
sub = '-' ws number:n -&gt; ('-', n)
addsub = ws (add | sub)
expr = number:left (addsub+:right -&gt; right
                   | -&gt; left)
&quot;&quot;&quot;, {})
print x(&quot;1 + 2 - 3&quot;).expr()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
[('+', 2), ('-, 3)]
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Oops, this is only half the job done. We're collecting the operators and values,
  but now we need to do the actual calculation. The easiest way to do it is
  probably to write a Python function and call it from inside the grammar.
<div style="height: 1.00em;">&#x00A0;</div>
So far we have been passing an empty dict as the second argument to
  <b>makeGrammar</b>. This is a dict of variable bindings that can be used in
  Python expressions in the grammar. So we can pass Python objects, such as
  functions, this way:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
def calculate(start, pairs):
    result = start
    for op, value in pairs:
        if op == '+':
            result += value
        elif op == '-':
            result -= value
    return result
x = parsley.makeGrammar(&quot;&quot;&quot;
number = &lt;digit+&gt;:ds -&gt; int(ds)
ws = ' '*
add = '+' ws number:n -&gt; ('+', n)
sub = '-' ws number:n -&gt; ('-', n)
addsub = ws (add | sub)
expr = number:left (addsub+:right -&gt; calculate(left, right)
                   | -&gt; left)
&quot;&quot;&quot;, {&quot;calculate&quot;: calculate})
print x(&quot;4 + 5 - 6&quot;).expr()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
3
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Introducing this function lets us simplify even further: instead of using
  <b>addsub+</b>, we can use <b>addsub*</b>, since <b>calculate(left, [])</b>
  will return <b>left</b> -- so now <b>expr</b> becomes:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
expr = number:left addsub*:right -&gt; calculate(left, right)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
So now let's look at adding multiplication and division. Here, we run into
  precedence rules: should &quot;4 * 5 + 6&quot; give us 26, or 44? The
  traditional choice is for multiplication and division to take precedence over
  addition and subtraction, so the answer should be 26. We'll resolve this by
  making sure multiplication and division happen before addition and subtraction
  are considered:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
def calculate(start, pairs):
    result = start
    for op, value in pairs:
        if op == '+':
            result += value
        elif op == '-':
            result -= value
        elif op == '*':
            result *= value
        elif op == '/':
            result /= value
    return result
x = parsley.makeGrammar(&quot;&quot;&quot;
number = &lt;digit+&gt;:ds -&gt; int(ds)
ws = ' '*
add = '+' ws expr2:n -&gt; ('+', n)
sub = '-' ws expr2:n -&gt; ('-', n)
mul = '*' ws number:n -&gt; ('*', n)
div = '/' ws number:n -&gt; ('/', n)
<div class="Pp"></div>
addsub = ws (add | sub)
muldiv = ws (mul | div)
<div class="Pp"></div>
expr = expr2:left addsub*:right -&gt; calculate(left, right)
expr2 = number:left muldiv*:right -&gt; calculate(left, right)
&quot;&quot;&quot;, {&quot;calculate&quot;: calculate})
print x(&quot;4 * 5 + 6&quot;).expr()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
26
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Notice particularly that <b>add</b>, <b>sub</b>, and <b>expr</b> all call the
  <b>expr2</b> rule now where they called <b>number</b> before. This means that
  all the places where a number was expected previously, a multiplication or
  division expression can appear instead.
<div style="height: 1.00em;">&#x00A0;</div>
Finally let's add parentheses, so you can override the precedence and write
  &quot;4 * (5 + 6)&quot; when you do want 44. We'll do this by adding a
  <b>value</b> rule that accepts either a number or an expression in
  parentheses, and replace existing calls to <b>number</b> with calls to
  <b>value</b>.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
def calculate(start, pairs):
    result = start
    for op, value in pairs:
        if op == '+':
            result += value
        elif op == '-':
            result -= value
        elif op == '*':
            result *= value
        elif op == '/':
            result /= value
    return result
x = parsley.makeGrammar(&quot;&quot;&quot;
number = &lt;digit+&gt;:ds -&gt; int(ds)
parens = '(' ws expr:e ws ')' -&gt; e
value = number | parens
ws = ' '*
add = '+' ws expr2:n -&gt; ('+', n)
sub = '-' ws expr2:n -&gt; ('-', n)
mul = '*' ws value:n -&gt; ('*', n)
div = '/' ws value:n -&gt; ('/', n)
<div class="Pp"></div>
addsub = ws (add | sub)
muldiv = ws (mul | div)
<div class="Pp"></div>
expr = expr2:left addsub*:right -&gt; calculate(left, right)
expr2 = value:left muldiv*:right -&gt; calculate(left, right)
&quot;&quot;&quot;, {&quot;calculate&quot;: calculate})
<div class="Pp"></div>
print x(&quot;4 * (5 + 6) + 1&quot;).expr()
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
45
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
And there you have it: a four-function calculator with precedence and
  parentheses.
<h1 class="Sh" title="Sh" id="PARSLEY_TUTORIAL_PART_II:_PARSING_STRUCTURED_DATA"><a class="selflink" href="#PARSLEY_TUTORIAL_PART_II:_PARSING_STRUCTURED_DATA">PARSLEY
  TUTORIAL PART II: PARSING STRUCTURED DATA</a></h1>
Now that you are familiar with the basics of Parsley syntax, let's look at a
  more realistic example: a JSON parser.
<div style="height: 1.00em;">&#x00A0;</div>
The JSON spec on <i>http://json.org/</i> describes the format, and we can adapt
  its description to a parser. We'll write the Parsley rules in the same order
  as the grammar rules in the right sidebar on the JSON site, starting with the
  top-level rule, 'object'.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
object = ws '{' members:m ws '}' -&gt; dict(m)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Parsley defines a builtin rule <b>ws</b> which consumes any spaces, tabs, or
  newlines it can.
<div style="height: 1.00em;">&#x00A0;</div>
Since JSON objects are represented in Python as dicts, and <b>dict</b> takes a
  list of pairs, we need a rule to collect name/value pairs inside an object
  expression.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
members = (pair:first (ws ',' pair)*:rest -&gt; [first] + rest)
          | -&gt; []
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This handles the three cases for object contents: one, multiple, or zero pairs.
  A name/value pair is separated by a colon. We use the builtin rule
  <b>spaces</b> to consume any whitespace after the colon:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
pair = ws string:k ws ':' value:v -&gt; (k, v)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Arrays, similarly, are sequences of array elements, and are represented as
  Python lists.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
array = '[' elements:xs ws ']' -&gt; xs
elements = (value:first (ws ',' value)*:rest -&gt; [first] + rest) | -&gt; []
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Values can be any JSON expression.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
value = ws (string | number | object | array
           | 'true'  -&gt; True
           | 'false' -&gt; False
           | 'null'  -&gt; None)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Strings are sequences of zero or more characters between double quotes. Of
  course, we need to deal with escaped characters as well. This rule introduces
  the operator <b>~</b>, which does negative lookahead; if the expression
  following it succeeds, its parse will fail. If the expression fails, the rest
  of the parse continues. Either way, no input will be consumed.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
string = '&quot;' (escapedChar | ~'&quot;' anything)*:c '&quot;' -&gt; ''.join(c)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This is a common pattern, so let's examine it step by step. This will match
  leading whitespace and then a double quote character. It then matches zero or
  more characters. If it's not an <b>escapedChar</b> (which will start with a
  backslash), we check to see if it's a double quote, in which case we want to
  end the loop. If it's not a double quote, we match it using the rule
  <b>anything</b>, which accepts a single character of any kind, and continue.
  Finally, we match the ending double quote and return the characters in the
  string. We cannot use the <b>&lt;&gt;</b> syntax in this case because we don't
  want a literal slice of the input -- we want escape sequences to be replaced
  with the character they represent.
<div style="height: 1.00em;">&#x00A0;</div>
It's very common to use <b>~</b> for &quot;match until&quot; situations where
  you want to keep parsing only until an end marker is found. Similarly,
  <b>~~</b> is positive lookahead: it succeed if its expression succeeds but not
  consume any input.
<div style="height: 1.00em;">&#x00A0;</div>
The <b>escapedChar</b> rule should not be too surprising: we match a backslash
  then whatever escape code is given.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
escapedChar = '\\' (('&quot;' -&gt; '&quot;')    |('\\' -&gt; '\\')
                   |('/' -&gt; '/')    |('b' -&gt; '\b')
                   |('f' -&gt; '\f')   |('n' -&gt; '\n')
                   |('r' -&gt; '\r')   |('t' -&gt; '\t')
                   |('\'' -&gt; '\'')  | escapedUnicode)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Unicode escapes (of the form <b>\u2603</b>) require matching four hex digits, so
  we use the repetition operator <b>{}</b>, which works like + or * except
  taking either a <b>{min, max}</b> pair or simply a <b>{number}</b> indicating
  the exact number of repetitions.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
hexdigit = :x ?(x in '0123456789abcdefABCDEF') -&gt; x
escapedUnicode = 'u' &lt;hexdigit{4}&gt;:hs -&gt; unichr(int(hs, 16))
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
With strings out of the way, we advance to numbers, both integer and
  floating-point.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
number = spaces ('-' | -&gt; ''):sign (intPart:ds (floatPart(sign ds)
                                               | -&gt; int(sign + ds)))
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Here we vary from the json.org description a little and move sign handling up
  into the <b>number</b> rule. We match either an <b>intPart</b> followed by a
  <b>floatPart</b> or just an <b>intPart</b> by itself.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
digit = :x ?(x in '0123456789') -&gt; x
digits = &lt;digit*&gt;
digit1_9 = :x ?(x in '123456789') -&gt; x
<div class="Pp"></div>
intPart = (digit1_9:first digits:rest -&gt; first + rest) | digit
floatPart :sign :ds = &lt;('.' digits exponent?) | exponent&gt;:tail
                     -&gt; float(sign + ds + tail)
exponent = ('e' | 'E') ('+' | '-')? digits
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
In JSON, multi-digit numbers cannot start with 0 (since that is Javascript's
  syntax for octal numbers), so <b>intPart</b> uses <b>digit1_9</b> to exclude
  it in the first position.
<div style="height: 1.00em;">&#x00A0;</div>
The <b>floatPart</b> rule takes two parameters, <b>sign</b> and <b>ds</b>. Our
  <b>number</b> rule passes values for these when it invokes <b>floatPart</b>,
  letting us avoid duplication of work within the rule. Note that pattern
  matching on arguments to rules works the same as on the string input to the
  parser. In this case, we provide no pattern, just a name: <b>:ds</b> is the
  same as <b>anything:ds</b>.
<div style="height: 1.00em;">&#x00A0;</div>
(Also note that our float rule cheats a little: it does not really parse
  floating-point numbers, it merely recognizes them and passes them to Python's
  <b>float</b> builtin to actually produce the value.)
<div style="height: 1.00em;">&#x00A0;</div>
The full version of this parser and its test cases can be found in the
  <b>examples</b> directory in the Parsley distribution.
<h1 class="Sh" title="Sh" id="PARSLEY_TUTORIAL_PART_III:_PARSING_NETWORK_DATA"><a class="selflink" href="#PARSLEY_TUTORIAL_PART_III:_PARSING_NETWORK_DATA">PARSLEY
  TUTORIAL PART III: PARSING NETWORK DATA</a></h1>
This tutorial assumes basic knowledge of writing <i>Twisted</i> <i>TCP
  clients</i> or <i>servers</i>.
<h2 class="Ss" title="Ss" id="Basic_parsing"><a class="selflink" href="#Basic_parsing">Basic
  parsing</a></h2>
Parsing data that comes in over the network can be difficult due to that there
  is no guarantee of receiving whole messages. Buffering is often complicated by
  protocols switching between using fixed-width messages and delimiters for
  framing. Fortunately, Parsley can remove all of this tedium.
<div style="height: 1.00em;">&#x00A0;</div>
With <b>parsley.makeProtocol()</b>, Parsley can generate a <i>Twisted</i>
  <i>IProtocol</i>-implementing class which will match incoming network data
  using Parsley grammar rules. Before getting started with
  <b>makeProtocol()</b>, let's build a grammar for <i>netstrings</i>. The
  netstrings protocol is very simple:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
4:spam,4:eggs,
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This stream contains two netstrings: <b>spam</b>, and <b>eggs</b>. The data is
  prefixed with one or more ASCII digits followed by a <b>:</b>, and suffixed
  with a <b>,</b>. So, a Parsley grammar to match a netstring would look like:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
nonzeroDigit = digit:x ?(x != '0')
digits = &lt;'0' | nonzeroDigit digit*&gt;:i -&gt; int(i)
<div class="Pp"></div>
netstring = digits:length ':' &lt;anything{length}&gt;:string ',' -&gt; string
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>makeProtocol()</b> takes, in addition to a grammar, a factory for a
  &quot;sender&quot; and a factory for a &quot;receiver&quot;. In the system of
  objects managed by the <b>ParserProtocol</b>, the sender is in charge of
  writing data to the wire, and the receiver has methods called on it by the
  Parsley rules. To demonstrate it, here is the final piece needed in the
  Parsley grammar for netstrings:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
receiveNetstring = netstring:string -&gt; receiver.netstringReceived(string)
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The receiver is always available in Parsley rules with the name <b>receiver</b>,
  allowing Parsley rules to call methods on it.
<div style="height: 1.00em;">&#x00A0;</div>
When data is received over the wire, the <b>ParserProtocol</b> tries to match
  the received data against the current rule. If the current rule requires more
  data to finish matching, the <b>ParserProtocol</b> stops and waits until more
  data comes in, then tries to continue matching. This repeats until the current
  rule is completely matched, and then the <b>ParserProtocol</b> starts matching
  any leftover data against the current rule again.
<div style="height: 1.00em;">&#x00A0;</div>
One specifies the current rule by setting a <b>currentRule</b> attribute on the
  receiver, which the <b>ParserProtocol</b> looks at before doing any parsing.
  Changing the current rule is addressed in the <i>Switching rules</i> section.
<div style="height: 1.00em;">&#x00A0;</div>
Since the <b>ParserProtocol</b> will never modify the <b>currentRule</b>
  attribute itself, the default behavior is to keep using the same rule. Parsing
  netstrings doesn't require any rule changing, so, the default behavior of
  continuing to use the same rule is fine.
<div style="height: 1.00em;">&#x00A0;</div>
Both the sender factory and receiver factory are constructed when the
  <b>ParserProtocol</b>'s connection is established. The sender factory is a
  one-argument callable which will be passed the <b>ParserProtocol</b>'s
  <i>Transport</i>. This allows the sender to send data over the transport. For
  example:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
class NetstringSender(object):
    def __init__(self, transport):
        self.transport = transport
<div class="Pp"></div>
    def sendNetstring(self, string):
        self.transport.write('%d:%s,' % (len(string), string))
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The receiver factory is another one-argument callable which is passed the
  constructed sender. The returned object must at least have
  <b>prepareParsing()</b> and <b>finishParsing()</b> methods.
  <b>prepareParsing()</b> is called with the <b>ParserProtocol</b> instance when
  a connection is established (i.e. in the <b>connectionMade</b> of the
  <b>ParserProtocol</b>) and <b>finishParsing()</b> is called when a connection
  is closed (i.e. in the <b>connectionLost</b> of the <b>ParserProtocol</b>).
<div style="height: 1.00em;">&#x00A0;</div>
<b>NOTE:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">Both the receiver factory and its returned
  object's <b>prepareParsing()</b> are called at in the <b>ParserProtocol</b>'s
  <b>connectionMade</b> method; this separation is for ease of testing
  receivers.</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To demonstrate a receiver, here is a simple receiver that receives netstrings
  and echos the same netstrings back:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
class NetstringReceiver(object):
    currentRule = 'receiveNetstring'
<div class="Pp"></div>
    def __init__(self, sender):
        self.sender = sender
<div class="Pp"></div>
    def prepareParsing(self, parser):
        pass
<div class="Pp"></div>
    def finishParsing(self, reason):
        pass
<div class="Pp"></div>
    def netstringReceived(self, string):
        self.sender.sendNetstring(string)
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Putting it all together, the Protocol is constructed using the grammar, sender
  factory, and receiver factory:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
<div class="Pp"></div>
<div class="Pp"></div>
NetstringProtocol = makeProtocol(
    grammar, NetstringSender, NetstringReceiver)
<div class="Pp"></div>
<div class="Pp"></div>
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>The complete script is also available for download.</b>
<h2 class="Ss" title="Ss" id="Intermezzo:_error_reporting"><a class="selflink" href="#Intermezzo:_error_reporting">Intermezzo:
  error reporting</a></h2>
If an exception is raised from within Parsley during parsing, whether it's due
  to input not matching the current rule or an exception being raised from code
  the grammar calls, the connection will be immediately closed. The traceback
  will be captured as a <i>Failure</i> and passed to the <b>finishParsing()</b>
  method of the receiver.
<div style="height: 1.00em;">&#x00A0;</div>
At present, there is no way to recover from failure.
<h2 class="Ss" title="Ss" id="Composing_senders_and_receivers"><a class="selflink" href="#Composing_senders_and_receivers">Composing
  senders and receivers</a></h2>
The design of senders and receivers is intentional to make composition easy: no
  subclassing is required. While the composition is easy enough to do on your
  own, Parsley provides a function: <b>stack()</b>. It takes a base factory
  followed by zero or more wrappers.
<div style="height: 1.00em;">&#x00A0;</div>
Its use is extremely simple: <b>stack(x, y, z)</b> will return a callable
  suitable either as a sender or receiver factory which will, when called with
  an argument, return <b>x(y(z(argument)))</b>.
<div style="height: 1.00em;">&#x00A0;</div>
An example of wrapping a sender factory:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
class NetstringReversalWrapper(object):
    def __init__(self, wrapped):
        self.wrapped = wrapped
<div class="Pp"></div>
    def sendNetstring(self, string):
        self.wrapped.sendNetstring(string[::-1])
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
And then, constructing the Protocol:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
NetstringProtocol = makeProtocol(
    grammar,
    stack(NetstringReversalWrapper, NetstringSender),
    NetstringReceiver)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
A wrapper doesn't need to call the same methods on the thing it's wrapping. Also
  note that in most cases, it's important to forward unknown methods on to the
  wrapped object. An example of wrapping a receiver:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
class NetstringSplittingWrapper(object):
    def __init__(self, wrapped):
        self.wrapped = wrapped
<div class="Pp"></div>
    def netstringReceived(self, string):
        splitpoint = len(string) // 2
        self.wrapped.netstringFirstHalfReceived(string[:splitpoint])
        self.wrapped.netstringSecondHalfReceived(string[splitpoint:])
<div class="Pp"></div>
    def __getattr__(self, attr):
        return getattr(self.wrapped, attr)
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The corresponding receiver and again, constructing the Protocol:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
class SplitNetstringReceiver(object):
    currentRule = 'receiveNetstring'
<div class="Pp"></div>
    def __init__(self, sender):
        self.sender = sender
<div class="Pp"></div>
    def prepareParsing(self, parser):
        pass
<div class="Pp"></div>
    def finishParsing(self, reason):
        pass
<div class="Pp"></div>
    def netstringFirstHalfReceived(self, string):
        self.sender.sendNetstring(string)
<div class="Pp"></div>
    def netstringSecondHalfReceived(self, string):
        pass
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
NetstringProtocol = makeProtocol(
    grammar,
    stack(NetstringReversalWrapper, NetstringSender),
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>The complete script is also available for download.</b>
<h2 class="Ss" title="Ss" id="Switching_rules"><a class="selflink" href="#Switching_rules">Switching
  rules</a></h2>
As mentioned before, it's possible to change the current rule. Imagine a
  &quot;netstrings2&quot; protocol that looks like this:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
3:foo,3;bar,4:spam,4;eggs,
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
That is, the protocol alternates between using <b>:</b> and using <b>;</b>
  delimiting data length and the data. The amended grammar would look something
  like this:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
nonzeroDigit = digit:x ?(x != '0')
digits = &lt;'0' | nonzeroDigit digit*&gt;:i -&gt; int(i)
netstring :delimiter = digits:length delimiter &lt;anything{length}&gt;:string ',' -&gt; string
<div class="Pp"></div>
colon = digits:length ':' &lt;anything{length}&gt;:string ',' -&gt; receiver.netstringReceived(':', string)
semicolon = digits:length ';' &lt;anything{length}&gt;:string ',' -&gt; receiver.netstringReceived(';', string)
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Changing the current rule is as simple as changing the <b>currentRule</b>
  attribute on the receiver. So, the <b>netstringReceived</b> method could look
  like this:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    def netstringReceived(self, delimiter, string):
        self.sender.sendNetstring(string)
        if delimiter == ':':
            self.currentRule = 'semicolon'
        else:
            self.currentRule = 'colon'
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
While changing the <b>currentRule</b> attribute can be done at any time, the
  <b>ParserProtocol</b> only examines the <b>currentRule</b> at the beginning of
  parsing and after a rule has finished matching. As a result, if the
  <b>currentRule</b> changes, the <b>ParserProtocol</b> will wait until the
  current rule is completely matched before switching rules.
<div style="height: 1.00em;">&#x00A0;</div>
<b>The complete script is also available for download.</b>
<h1 class="Sh" title="Sh" id="EXTENDING_GRAMMARS_AND_INHERITANCE"><a class="selflink" href="#EXTENDING_GRAMMARS_AND_INHERITANCE">EXTENDING
  GRAMMARS AND INHERITANCE</a></h1>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>warning</b></dt>
  <dd class="It-tag">Unfinished</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Another feature taken from OMeta is <i>grammar inheritance</i>. We can write a
  grammar with rules that override ones in a parent. If we load the grammar from
  our calculator tutorial as <b>Calc</b>, we can extend it with some constants:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
from parsley import makeGrammar
import math
import calc
calcGrammarEx = &quot;&quot;&quot;
value = super | constant
constant = 'pi' -&gt; math.pi
         | 'e' -&gt; math.e
&quot;&quot;&quot;
CalcEx = makeGrammar(calcGrammar, {&quot;math&quot;: math}, extends=calc.Calc)
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Invoking the rule <b>super</b> calls the rule <b>value</b> in Calc. If it fails
  to match, our new <b>value</b> rule attempts to match a constant name.
<h1 class="Sh" title="Sh" id="TERML"><a class="selflink" href="#TERML">TERML</a></h1>
TermL (&quot;term-ell&quot;) is the Term Language, a small expression-based
  language for representing arbitrary data in a simple structured format. It is
  ideal for expressing abstract syntax trees (ASTs) and other kinds of primitive
  data trees.
<h2 class="Ss" title="Ss" id="Creating_Terms"><a class="selflink" href="#Creating_Terms">Creating
  Terms</a></h2>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
&gt;&gt;&gt; from terml.nodes import termMaker as t
&gt;&gt;&gt; t.Term()
term('Term')
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
That's it! We've created an empty term, <i>Term</i>, with nothing inside.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
&gt;&gt;&gt; t.Num(1)
term('Num(1)')
&gt;&gt;&gt; t.Outer(t.Inner())
term('Outer(Inner)')
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
We can see that terms are not just <i>namedtuple</i> lookalikes. They have their
  own internals and store data in a slightly different and more structured way
  than a normal tuple.
<h2 class="Ss" title="Ss" id="Parsing_Terms"><a class="selflink" href="#Parsing_Terms">Parsing
  Terms</a></h2>
Parsley can parse terms from streams. Terms can contain any kind of parseable
  data, including other terms. Returning to the ubiquitous calculator example:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
add = Add(:x, :y) -&gt; x + y
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Here this rule matches a term called <i>Add</i> which has two components, bind
  those components to a couple of names ( <i>x</i> and <i>y</i>), and return
  their sum. If this rule were applied to a term like <i>Add(3, 5)</i>, it would
  return 8.
<div style="height: 1.00em;">&#x00A0;</div>
Terms can be nested, too. Here's an example that performs a slightly contrived
  match on a negated term inside an addition:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
add_negate = Add(:x, Negate(:y)) -&gt; x - y
</pre>
</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="PARSLEY_REFERENCE"><a class="selflink" href="#PARSLEY_REFERENCE">PARSLEY
  REFERENCE</a></h1>
<h2 class="Ss" title="Ss" id="Basic_syntax"><a class="selflink" href="#Basic_syntax">Basic
  syntax</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>foo = ....</b>:</b></dt>
  <dd class="It-tag">Define a rule named foo.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr1 expr2</b>:</b></dt>
  <dd class="It-tag">Match expr1, and then match expr2 if it succeeds, returning
      the value of expr2. Like Python's <b>and</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr1 | expr2</b>:</b></dt>
  <dd class="It-tag">Try to match <b>expr1</b> --- if it fails, match
      <b>expr2</b> instead. Like Python's <b>or</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr*</b>:</b></dt>
  <dd class="It-tag">Match <b>expr</b> zero or more times, returning a list of
      matches.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr+</b>:</b></dt>
  <dd class="It-tag">Match <b>expr</b> one or more times, returning a list of
      matches.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr?</b>:</b></dt>
  <dd class="It-tag">Try to match <b>expr</b>. Returns <b>None</b> if it fails
      to match.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr{n, m}</b>:</b></dt>
  <dd class="It-tag">Match <b>expr</b> at least <b>n</b> times, and no more than
      <b>m</b> times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr{n}</b>:</b></dt>
  <dd class="It-tag">Match <b>expr</b> <b>n</b> times exactly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>~expr</b>:</b></dt>
  <dd class="It-tag">Negative lookahead. Fails if the next item in the input
      matches <b>expr</b>. Consumes no input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>~~expr</b>:</b></dt>
  <dd class="It-tag">Positive lookahead. Fails if the next item in the input
      does <i>not</i> match <b>expr</b>. Consumes no input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>ruleName</b> or <b>ruleName(arg1 arg2
    etc)</b>:</b></dt>
  <dd class="It-tag">Call the rule <b>ruleName</b>, possibly with args.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>'x'</b>:</b></dt>
  <dd class="It-tag">Match the literal character 'x'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>&lt;expr&gt;</b>:</b></dt>
  <dd class="It-tag">Returns the string consumed by matching <b>expr</b>. Good
      for tokenizing rules.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr:name</b>:</b></dt>
  <dd class="It-tag">Bind the result of expr to the local variable
    <b>name</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-&gt; pythonExpression</b>:</b></dt>
  <dd class="It-tag">Evaluate the given Python expression and return its result.
      Can be used inside parentheses too!</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>!(pythonExpression)</b>:</b></dt>
  <dd class="It-tag">Invoke a Python expression as an action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>?(pythonExpression)</b>:</b></dt>
  <dd class="It-tag">Fail if the Python expression is false, Returns True
      otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>expr ^(CustomLabel)</b>:</b></dt>
  <dd class="It-tag">If the expr fails, the exception raised will contain
      CustomLabel. Good for providing more context when a rule is broken.
      CustomLabel can contain any character other than &quot;(&quot; and
      &quot;)&quot;.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Comments like Python comments are supported as well, starting with # and
  extending to the end of the line.
<h2 class="Ss" title="Ss" id="Python_API"><a class="selflink" href="#Python_API">Python
  API</a></h2>
<h2 class="Ss" title="Ss" id="Protocol_parsing_API"><a class="selflink" href="#Protocol_parsing_API">Protocol
  parsing API</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class ometa.protocol.ParserProtocol</b></dt>
  <dd class="It-tag">The Twisted <b>Protocol</b> subclass used for parsing
      stream protocols using Parsley. It has two public attributes:</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>sender</b></dt>
  <dd class="It-tag">After the connection is established, this attribute will
      refer to the sender created by the sender factory of the
      <i>ParserProtocol</i>.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>receiver</b></dt>
  <dd class="It-tag">After the connection is established, this attribute will
      refer to the receiver created by the receiver factory of the
      <i>ParserProtocol</i>.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
It's common to also add a <b>factory</b> attribute to the <i>ParserProtocol</i>
  from its factory's <b>buildProtocol</b> method, but this isn't strictly
  required or guaranteed to be present.
<div style="height: 1.00em;">&#x00A0;</div>
Subclassing or instantiating <i>ParserProtocol</i> is not necessary;
  <b>makeProtocol()</b> is sufficient and requires less boilerplate.</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class ometa.protocol.Receiver</b></dt>
  <dd class="It-tag"><i>Receiver</i> is not a real class but is used here for
      demonstration purposes to indicate the required API.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>currentRule</b></dt>
  <dd class="It-tag"><i>ParserProtocol</i> examines the <i>currentRule</i>
      attribute at the beginning of parsing as well as after every time a rule
      has completely matched. At these times, the rule with the same name as the
      value of <i>currentRule</i> will be selected to start parsing the incoming
      stream of data.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>prepareParsing(parserProtocol)</b></dt>
  <dd class="It-tag"><i>prepareParsing()</i> is called after the
      <i>ParserProtocol</i> has established a connection, and is passed the
      <i>ParserProtocol</i> instance itself.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Parameters</b></dt>
  <dd class="It-tag"><b>parserProtocol</b> -- An instance of
      <b>ProtocolParser</b>.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>finishParsing(reason)</b></dt>
  <dd class="It-tag"><i>finishParsing()</i> is called if an exception was raised
      during parsing, or when the <i>ParserProtocol</i> has lost its connection,
      whichever comes first. It will only be called once.
    <div style="height: 1.00em;">&#x00A0;</div>
    An exception raised during parsing can be due to incoming data that doesn't
      match the current rule or an exception raised calling python code during
      matching.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Parameters</b></dt>
  <dd class="It-tag"><b>reason</b> -- A <i>Failure</i> encapsulating the reason
      parsing has ended.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Senders do not have any required API as <i>ParserProtocol</i> will never call
  methods on a sender.
<h2 class="Ss" title="Ss" id="Built-in_Parsley_Rules"><a class="selflink" href="#Built-in_Parsley_Rules">Built-in
  Parsley Rules</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>anything</b>:</b></dt>
  <dd class="It-tag">Matches a single character from the input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>letter</b>:</b></dt>
  <dd class="It-tag">Matches a single ASCII letter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>digit</b>:</b></dt>
  <dd class="It-tag">Matches a decimal digit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>letterOrDigit</b>:</b></dt>
  <dd class="It-tag">Combines the above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>end</b>:</b></dt>
  <dd class="It-tag">Matches the end of input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>ws</b>:</b></dt>
  <dd class="It-tag">Matches zero or more spaces, tabs, or newlines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>exactly(char)</b>:</b></dt>
  <dd class="It-tag">Matches the character <i>char</i>.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Allen Short
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2013, Allen Short</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 11, 2017</td>
    <td class="foot-os">1.3</td>
  </tr>
</table>
</body>
</html>
