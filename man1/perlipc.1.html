<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:56 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLIPC(1) Perl Programmers Reference Guide
PERLIPC(1)</p>

<p style="margin-top: 1em">NAME <br>
perlipc - Perl interprocess communication (signals, fifos,
pipes, safe subprocesses, sockets, and semaphores)</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The basic IPC facilities of Perl are built out of the good
old Unix signals, named pipes, pipe opens, the Berkeley
socket routines, and SysV IPC calls. Each is used in
slightly <br>
different situations.</p>

<p style="margin-top: 1em">Signals <br>
Perl uses a simple signal handling model: the %SIG hash
contains names or references of user-installed signal
handlers. These handlers will be called with an argument
which is <br>
the name of the signal that triggered it. A signal may be
generated intentionally from a particular keyboard sequence
like control-C or control-Z, sent to you from another <br>
process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your
own process running out of stack space, or hitting a process
<br>
file-size limit.</p>

<p style="margin-top: 1em">For example, to trap an
interrupt signal, set up a handler like this:</p>

<p style="margin-top: 1em">our $shucks;</p>

<p style="margin-top: 1em">sub catch_zap { <br>
my $signame = shift; <br>
$shucks++; <br>
die &quot;Somebody sent me a SIG$signame&quot;; <br>
} <br>
$SIG{INT} = __PACKAGE__ . &quot;::catch_zap&quot;; <br>
$SIG{INT} = catch_zap; # best strategy</p>

<p style="margin-top: 1em">Prior to Perl 5.7.3 it was
necessary to do as little as you possibly could in your
handler; notice how all we do is set a global variable and
then raise an exception. That&rsquo;s <br>
because on most systems, libraries are not re-entrant;
particularly, memory allocation and I/O routines are not.
That meant that doing nearly anything in your handler could
in <br>
theory trigger a memory fault and subsequent core dump - see
&quot;Deferred Signals (Safe Signals)&quot; below.</p>

<p style="margin-top: 1em">The names of the signals are the
ones listed out by &quot;kill -l&quot; on your system, or
you can retrieve them using the CPAN module IPC::Signal.</p>

<p style="margin-top: 1em">You may also choose to assign
the strings &quot;IGNORE&quot; or &quot;DEFAULT&quot; as the
handler, in which case Perl will try to discard the signal
or do the default thing.</p>

<p style="margin-top: 1em">On most Unix platforms, the
&quot;CHLD&quot; (sometimes also known as &quot;CLD&quot;)
signal has special behavior with respect to a value of
&quot;IGNORE&quot;. Setting $SIG{CHLD} to &quot;IGNORE&quot;
on such a <br>
platform has the effect of not creating zombie processes
when the parent process fails to &quot;wait()&quot; on its
child processes (i.e., child processes are automatically
reaped). <br>
Calling &quot;wait()&quot; with $SIG{CHLD} set to
&quot;IGNORE&quot; usually returns &quot;-1&quot; on such
platforms.</p>

<p style="margin-top: 1em">Some signals can be neither
trapped nor ignored, such as the KILL and STOP (but not the
TSTP) signals. Note that ignoring signals makes them
disappear. If you only want them <br>
blocked temporarily without them getting lost you&rsquo;ll
have to use POSIX&rsquo; sigprocmask.</p>

<p style="margin-top: 1em">Sending a signal to a negative
process ID means that you send the signal to the entire Unix
process group. This code sends a hang-up signal to all
processes in the current <br>
process group, and also sets $SIG{HUP} to &quot;IGNORE&quot;
so it doesn&rsquo;t kill itself:</p>

<p style="margin-top: 1em"># block scope for local <br>
{ <br>
local $SIG{HUP} = &quot;IGNORE&quot;; <br>
kill HUP =&gt; -$$; <br>
# snazzy writing of: kill(&quot;HUP&quot;, -$$) <br>
}</p>

<p style="margin-top: 1em">Another interesting signal to
send is signal number zero. This doesn&rsquo;t actually
affect a child process, but instead checks whether
it&rsquo;s alive or has changed its UIDs.</p>

<p style="margin-top: 1em">unless (kill 0 =&gt; $kid_pid) {
<br>
warn &quot;something wicked happened to $kid_pid&quot;; <br>
}</p>

<p style="margin-top: 1em">Signal number zero may fail
because you lack permission to send the signal when directed
at a process whose real or saved UID is not identical to the
real or effective UID of the <br>
sending process, even though the process is alive. You may
be able to determine the cause of failure using $! or
&quot;%!&quot;.</p>

<p style="margin-top: 1em">unless (kill(0 =&gt; $pid) ||
$!{EPERM}) { <br>
warn &quot;$pid looks dead&quot;; <br>
}</p>

<p style="margin-top: 1em">You might also want to employ
anonymous functions for simple signal handlers:</p>

<p style="margin-top: 1em">$SIG{INT} = sub { die
&quot;0utta here!0 };</p>

<p style="margin-top: 1em">SIGCHLD handlers require some
special care. If a second child dies while in the signal
handler caused by the first death, we won&rsquo;t get
another signal. So must loop here else we <br>
will leave the unreaped child as a zombie. And the next time
two children die we get another zombie. And so on.</p>

<p style="margin-top: 1em">use POSIX
&quot;:sys_wait_h&quot;; <br>
$SIG{CHLD} = sub { <br>
while ((my $child = waitpid(-1, WNOHANG)) &gt; 0) { <br>
$Kid_Status{$child} = $?; <br>
} <br>
}; <br>
# do something that forks...</p>

<p style="margin-top: 1em">Be careful: qx(), system(), and
some modules for calling external commands do a fork(), then
wait() for the result. Thus, your signal handler will be
called. Because wait() was <br>
already called by system() or qx(), the wait() in the signal
handler will see no more zombies and will therefore
block.</p>

<p style="margin-top: 1em">The best way to prevent this
issue is to use waitpid(), as in the following example:</p>

<p style="margin-top: 1em">use POSIX
&quot;:sys_wait_h&quot;; # for nonblocking read</p>

<p style="margin-top: 1em">my %children;</p>

<p style="margin-top: 1em">$SIG{CHLD} = sub { <br>
# don&rsquo;t change $! and $? outside handler <br>
local ($!, $?); <br>
my $pid = waitpid(-1, WNOHANG); <br>
return if $pid == -1; <br>
return unless defined $children{$pid}; <br>
delete $children{$pid}; <br>
cleanup_child($pid, $?); <br>
};</p>

<p style="margin-top: 1em">while (1) { <br>
my $pid = fork(); <br>
die &quot;cannot fork&quot; unless defined $pid; <br>
if ($pid == 0) { <br>
# ... <br>
exit 0; <br>
} else { <br>
$children{$pid}=1; <br>
# ... <br>
system($command); <br>
# ... <br>
} <br>
}</p>

<p style="margin-top: 1em">Signal handling is also used for
timeouts in Unix. While safely protected within an
&quot;eval{}&quot; block, you set a signal handler to trap
alarm signals and then schedule to have one <br>
delivered to you in some number of seconds. Then try your
blocking operation, clearing the alarm when it&rsquo;s done
but not before you&rsquo;ve exited your &quot;eval{}&quot;
block. If it goes <br>
off, you&rsquo;ll use die() to jump out of the block.</p>

<p style="margin-top: 1em">Here&rsquo;s an example:</p>

<p style="margin-top: 1em">my $ALARM_EXCEPTION =
&quot;alarm clock restart&quot;; <br>
eval { <br>
local $SIG{ALRM} = sub { die $ALARM_EXCEPTION }; <br>
alarm 10; <br>
flock(FH, 2) # blocking write lock <br>
|| die &quot;cannot flock: $!&quot;; <br>
alarm 0; <br>
}; <br>
if ($@ &amp;&amp; $@ !~ quotemeta($ALARM_EXCEPTION)) { die
}</p>

<p style="margin-top: 1em">If the operation being timed out
is system() or qx(), this technique is liable to generate
zombies. If this matters to you, you&rsquo;ll need to do
your own fork() and exec(), and <br>
kill the errant child process.</p>

<p style="margin-top: 1em">For more complex signal
handling, you might see the standard POSIX module.
Lamentably, this is almost entirely undocumented, but the
t/lib/posix.t file from the Perl source <br>
distribution has some examples in it.</p>

<p style="margin-top: 1em">Handling the SIGHUP Signal in
Daemons <br>
A process that usually starts when the system boots and
shuts down when the system is shut down is called a daemon
(Disk And Execution MONitor). If a daemon process has a <br>
configuration file which is modified after the process has
been started, there should be a way to tell that process to
reread its configuration file without stopping the process.
<br>
Many daemons provide this mechanism using a
&quot;SIGHUP&quot; signal handler. When you want to tell the
daemon to reread the file, simply send it the
&quot;SIGHUP&quot; signal.</p>

<p style="margin-top: 1em">The following example implements
a simple daemon, which restarts itself every time the
&quot;SIGHUP&quot; signal is received. The actual code is
located in the subroutine &quot;code()&quot;, which <br>
just prints some debugging info to show that it works; it
should be replaced with the real code.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w</p>

<p style="margin-top: 1em">use POSIX (); <br>
use FindBin (); <br>
use File::Basename (); <br>
use File::Spec::Functions;</p>

<p style="margin-top: 1em">$| = 1;</p>

<p style="margin-top: 1em"># make the daemon
cross-platform, so exec always calls the script <br>
# itself with the right path, no matter how the script was
invoked. <br>
my $script = File::Basename::basename($0); <br>
my $SELF = catfile($FindBin::Bin, $script);</p>

<p style="margin-top: 1em"># POSIX unmasks the sigprocmask
properly <br>
$SIG{HUP} = sub { <br>
print &quot;got SIGHUP0; <br>
exec($SELF, @ARGV) || die &quot;$0: couldn&rsquo;t restart:
$!&quot;; <br>
};</p>

<p style="margin-top: 1em">code();</p>

<p style="margin-top: 1em">sub code { <br>
print &quot;PID: $$0; <br>
print &quot;ARGV: @ARGV0; <br>
my $count = 0; <br>
while (++$count) { <br>
sleep 2; <br>
print &quot;$count0; <br>
} <br>
}</p>

<p style="margin-top: 1em">Deferred Signals (Safe Signals)
<br>
Before Perl 5.7.3, installing Perl code to deal with signals
exposed you to danger from two things. First, few system
library functions are re-entrant. If the signal interrupts
<br>
while Perl is executing one function (like malloc(3) or
printf(3)), and your signal handler then calls the same
function again, you could get unpredictable behavior--often,
a <br>
core dump. Second, Perl isn&rsquo;t itself re-entrant at the
lowest levels. If the signal interrupts Perl while Perl is
changing its own internal data structures, similarly <br>
unpredictable behavior may result.</p>

<p style="margin-top: 1em">There were two things you could
do, knowing this: be paranoid or be pragmatic. The paranoid
approach was to do as little as possible in your signal
handler. Set an existing <br>
integer variable that already has a value, and return. This
doesn&rsquo;t help you if you&rsquo;re in a slow system
call, which will just restart. That means you have to
&quot;die&quot; to <br>
longjmp(3) out of the handler. Even this is a little
cavalier for the true paranoiac, who avoids &quot;die&quot;
in a handler because the system is out to get you. The
pragmatic approach <br>
was to say &quot;I know the risks, but prefer the
convenience&quot;, and to do anything you wanted in your
signal handler, and be prepared to clean up core dumps now
and again.</p>

<p style="margin-top: 1em">Perl 5.7.3 and later avoid these
problems by &quot;deferring&quot; signals. That is, when the
signal is delivered to the process by the system (to the C
code that implements Perl) a flag <br>
is set, and the handler returns immediately. Then at
strategic &quot;safe&quot; points in the Perl interpreter
(e.g. when it is about to execute a new opcode) the flags
are checked and <br>
the Perl level handler from %SIG is executed. The
&quot;deferred&quot; scheme allows much more flexibility in
the coding of signal handlers as we know the Perl
interpreter is in a safe <br>
state, and that we are not in a system library function when
the handler is called. However the implementation does
differ from previous Perls in the following ways:</p>

<p style="margin-top: 1em">Long-running opcodes <br>
As the Perl interpreter looks at signal flags only when it
is about to execute a new opcode, a signal that arrives
during a long-running opcode (e.g. a regular expression <br>
operation on a very large string) will not be seen until the
current opcode completes.</p>

<p style="margin-top: 1em">If a signal of any given type
fires multiple times during an opcode (such as from a
fine-grained timer), the handler for that signal will be
called only once, after the <br>
opcode completes; all other instances will be discarded.
Furthermore, if your system&rsquo;s signal queue gets
flooded to the point that there are signals that have been
raised <br>
but not yet caught (and thus not deferred) at the time an
opcode completes, those signals may well be caught and
deferred during subsequent opcodes, with sometimes
surprising <br>
results. For example, you may see alarms delivered even
after calling alarm(0) as the latter stops the raising of
alarms but does not cancel the delivery of alarms raised
<br>
but not yet caught. Do not depend on the behaviors described
in this paragraph as they are side effects of the current
implementation and may change in future versions of <br>
Perl.</p>

<p style="margin-top: 1em">Interrupting IO <br>
When a signal is delivered (e.g., SIGINT from a control-C)
the operating system breaks into IO operations like read(2),
which is used to implement Perl&rsquo;s readline() function,
<br>
the &quot;&lt;&gt;&quot; operator. On older Perls the
handler was called immediately (and as &quot;read&quot; is
not &quot;unsafe&quot;, this worked well). With the
&quot;deferred&quot; scheme the handler is not called <br>
immediately, and if Perl is using the system&rsquo;s
&quot;stdio&quot; library that library may restart the
&quot;read&quot; without returning to Perl to give it a
chance to call the %SIG handler. If <br>
this happens on your system the solution is to use the
&quot;:perlio&quot; layer to do IO--at least on those
handles that you want to be able to break into with signals.
(The &quot;:perlio&quot; <br>
layer checks the signal flags and calls %SIG handlers before
resuming IO operation.)</p>

<p style="margin-top: 1em">The default in Perl 5.7.3 and
later is to automatically use the &quot;:perlio&quot;
layer.</p>

<p style="margin-top: 1em">Note that it is not advisable to
access a file handle within a signal handler where that
signal has interrupted an I/O operation on that same handle.
While perl will at least <br>
try hard not to crash, there are no guarantees of data
integrity; for example, some data might get dropped or
written twice.</p>

<p style="margin-top: 1em">Some networking library
functions like gethostbyname() are known to have their own
implementations of timeouts which may conflict with your
timeouts. If you have problems <br>
with such functions, try using the POSIX sigaction()
function, which bypasses Perl safe signals. Be warned that
this does subject you to possible memory corruption, as <br>
described above.</p>

<p style="margin-top: 1em">Instead of setting
$SIG{ALRM}:</p>

<p style="margin-top: 1em">local $SIG{ALRM} = sub { die
&quot;alarm&quot; };</p>

<p style="margin-top: 1em">try something like the
following:</p>

<p style="margin-top: 1em">use POSIX qw(SIGALRM); <br>
POSIX::sigaction(SIGALRM, POSIX::SigAction-&gt;new(sub { die
&quot;alarm&quot; })) <br>
|| die &quot;Error setting SIGALRM handler: $!0;</p>

<p style="margin-top: 1em">Another way to disable the safe
signal behavior locally is to use the
&quot;Perl::Unsafe::Signals&quot; module from CPAN, which
affects all signals.</p>

<p style="margin-top: 1em">Restartable system calls <br>
On systems that supported it, older versions of Perl used
the SA_RESTART flag when installing %SIG handlers. This
meant that restartable system calls would continue rather
<br>
than returning when a signal arrived. In order to deliver
deferred signals promptly, Perl 5.7.3 and later do not use
SA_RESTART. Consequently, restartable system calls can <br>
fail (with $! set to &quot;EINTR&quot;) in places where they
previously would have succeeded.</p>

<p style="margin-top: 1em">The default &quot;:perlio&quot;
layer retries &quot;read&quot;, &quot;write&quot; and
&quot;close&quot; as described above; interrupted
&quot;wait&quot; and &quot;waitpid&quot; calls will always
be retried.</p>

<p style="margin-top: 1em">Signals as &quot;faults&quot;
<br>
Certain signals like SEGV, ILL, and BUS are generated by
virtual memory addressing errors and similar
&quot;faults&quot;. These are normally fatal: there is
little a Perl-level handler <br>
can do with them. So Perl delivers them immediately rather
than attempting to defer them.</p>

<p style="margin-top: 1em">Signals triggered by operating
system state <br>
On some operating systems certain signal handlers are
supposed to &quot;do something&quot; before returning. One
example can be CHLD or CLD, which indicates a child process
has <br>
completed. On some operating systems the signal handler is
expected to &quot;wait&quot; for the completed child
process. On such systems the deferred signal scheme will not
work for <br>
those signals: it does not do the &quot;wait&quot;. Again
the failure will look like a loop as the operating system
will reissue the signal because there are completed child
processes <br>
that have not yet been &quot;wait&quot;ed for.</p>

<p style="margin-top: 1em">If you want the old signal
behavior back despite possible memory corruption, set the
environment variable &quot;PERL_SIGNALS&quot; to
&quot;unsafe&quot;. This feature first appeared in Perl
5.8.1.</p>

<p style="margin-top: 1em">Named Pipes <br>
A named pipe (often referred to as a FIFO) is an old Unix
IPC mechanism for processes communicating on the same
machine. It works just like regular anonymous pipes, except
that <br>
the processes rendezvous using a filename and need not be
related.</p>

<p style="margin-top: 1em">To create a named pipe, use the
&quot;POSIX::mkfifo()&quot; function.</p>

<p style="margin-top: 1em">use POSIX qw(mkfifo); <br>
mkfifo($path, 0700) || die &quot;mkfifo $path failed:
$!&quot;;</p>

<p style="margin-top: 1em">You can also use the Unix
command mknod(1), or on some systems, mkfifo(1). These may
not be in your normal path, though.</p>

<p style="margin-top: 1em"># system return val is
backwards, so &amp;&amp; not || <br>
# <br>
$ENV{PATH} .= &quot;:/etc:/usr/etc&quot;; <br>
if ( system(&quot;mknod&quot;, $path, &quot;p&quot;) <br>
&amp;&amp; system(&quot;mkfifo&quot;, $path) ) <br>
{ <br>
die &quot;mk{nod,fifo} $path failed&quot;; <br>
}</p>

<p style="margin-top: 1em">A fifo is convenient when you
want to connect a process to an unrelated one. When you open
a fifo, the program will block until there&rsquo;s something
on the other end.</p>

<p style="margin-top: 1em">For example, let&rsquo;s say
you&rsquo;d like to have your .signature file be a named
pipe that has a Perl program on the other end. Now every
time any program (like a mailer, news reader, <br>
finger program, etc.) tries to read from that file, the
reading program will read the new signature from your
program. We&rsquo;ll use the pipe-checking file-test
operator, -p, to <br>
find out whether anyone (or anything) has accidentally
removed our fifo.</p>

<p style="margin-top: 1em">chdir(); # go home <br>
my $FIFO = &quot;.signature&quot;;</p>

<p style="margin-top: 1em">while (1) { <br>
unless (-p $FIFO) { <br>
unlink $FIFO; # discard any failure, will catch later <br>
require POSIX; # delayed loading of heavy module <br>
POSIX::mkfifo($FIFO, 0700) <br>
|| die &quot;can&rsquo;t mkfifo $FIFO: $!&quot;; <br>
}</p>

<p style="margin-top: 1em"># next line blocks till
there&rsquo;s a reader <br>
open (FIFO, &quot;&gt; $FIFO&quot;) || die &quot;can&rsquo;t
open $FIFO: $!&quot;; <br>
print FIFO &quot;John Smith (smith@host.org)0,
&lsquo;fortune -s&lsquo;; <br>
close(FIFO) || die &quot;can&rsquo;t close $FIFO: $!&quot;;
<br>
sleep 2; # to avoid dup signals <br>
}</p>

<p style="margin-top: 1em">Using open() for IPC <br>
Perl&rsquo;s basic open() statement can also be used for
unidirectional interprocess communication by either
appending or prepending a pipe symbol to the second argument
to open(). <br>
Here&rsquo;s how to start something up in a child process
you intend to write to:</p>

<p style="margin-top: 1em">open(SPOOLER, &quot;| cat -v |
lpr -h 2&gt;/dev/null&quot;) <br>
|| die &quot;can&rsquo;t fork: $!&quot;; <br>
local $SIG{PIPE} = sub { die &quot;spooler pipe broke&quot;
}; <br>
print SPOOLER &quot;stuff0; <br>
close SPOOLER || die &quot;bad spool: $! $?&quot;;</p>

<p style="margin-top: 1em">And here&rsquo;s how to start up
a child process you intend to read from:</p>

<p style="margin-top: 1em">open(STATUS, &quot;netstat -an
2&gt;&amp;1 |&quot;) <br>
|| die &quot;can&rsquo;t fork: $!&quot;; <br>
while (&lt;STATUS&gt;) { <br>
next if /^(tcp|udp)/; <br>
print; <br>
} <br>
close STATUS || die &quot;bad netstat: $! $?&quot;;</p>

<p style="margin-top: 1em">If one can be sure that a
particular program is a Perl script expecting filenames in
@ARGV, the clever programmer can write something like
this:</p>

<p style="margin-top: 1em">% program f1 &quot;cmd1|&quot; -
f2 &quot;cmd2|&quot; f3 &lt; tmpfile</p>

<p style="margin-top: 1em">and no matter which sort of
shell it&rsquo;s called from, the Perl program will read
from the file f1, the process cmd1, standard input (tmpfile
in this case), the f2 file, the cmd2 <br>
command, and finally the f3 file. Pretty nifty, eh?</p>

<p style="margin-top: 1em">You might notice that you could
use backticks for much the same effect as opening a pipe for
reading:</p>

<p style="margin-top: 1em">print grep { !/^(tcp|udp)/ }
&lsquo;netstat -an 2&gt;&amp;1&lsquo;; <br>
die &quot;bad netstatus ($?)&quot; if $?;</p>

<p style="margin-top: 1em">While this is true on the
surface, it&rsquo;s much more efficient to process the file
one line or record at a time because then you don&rsquo;t
have to read the whole thing into memory at <br>
once. It also gives you finer control of the whole process,
letting you kill off the child process early if you&rsquo;d
like.</p>

<p style="margin-top: 1em">Be careful to check the return
values from both open() and close(). If you&rsquo;re writing
to a pipe, you should also trap SIGPIPE. Otherwise, think of
what happens when you start <br>
up a pipe to a command that doesn&rsquo;t exist: the open()
will in all likelihood succeed (it only reflects the
fork()&rsquo;s success), but then your output will
fail--spectacularly. Perl <br>
can&rsquo;t know whether the command worked, because your
command is actually running in a separate process whose
exec() might have failed. Therefore, while readers of bogus
commands <br>
return just a quick EOF, writers to bogus commands will get
hit with a signal, which they&rsquo;d best be prepared to
handle. Consider:</p>

<p style="margin-top: 1em">open(FH, &quot;|bogus&quot;) ||
die &quot;can&rsquo;t fork: $!&quot;; <br>
print FH &quot;bang0; # neither necessary nor sufficient
<br>
# to check print retval! <br>
close(FH) || die &quot;can&rsquo;t close: $!&quot;;</p>

<p style="margin-top: 1em">The reason for not checking the
return value from print() is because of pipe buffering;
physical writes are delayed. That won&rsquo;t blow up until
the close, and it will blow up with <br>
a SIGPIPE. To catch it, you could use this:</p>

<p style="margin-top: 1em">$SIG{PIPE} = &quot;IGNORE&quot;;
<br>
open(FH, &quot;|bogus&quot;) || die &quot;can&rsquo;t fork:
$!&quot;; <br>
print FH &quot;bang0; <br>
close(FH) || die &quot;can&rsquo;t close:
status=$?&quot;;</p>

<p style="margin-top: 1em">Filehandles <br>
Both the main process and any child processes it forks share
the same STDIN, STDOUT, and STDERR filehandles. If both
processes try to access them at once, strange things can
<br>
happen. You may also want to close or reopen the filehandles
for the child. You can get around this by opening your pipe
with open(), but on some systems this means that the <br>
child process cannot outlive the parent.</p>

<p style="margin-top: 1em">Background Processes <br>
You can run a command in the background with:</p>

<p style="margin-top: 1em">system(&quot;cmd
&amp;&quot;);</p>

<p style="margin-top: 1em">The command&rsquo;s STDOUT and
STDERR (and possibly STDIN, depending on your shell) will be
the same as the parent&rsquo;s. You won&rsquo;t need to
catch SIGCHLD because of the double-fork taking <br>
place; see below for details.</p>

<p style="margin-top: 1em">Complete Dissociation of Child
from Parent <br>
In some cases (starting server processes, for instance)
you&rsquo;ll want to completely dissociate the child process
from the parent. This is often called daemonization. A well-
<br>
behaved daemon will also chdir() to the root directory so it
doesn&rsquo;t prevent unmounting the filesystem containing
the directory from which it was launched, and redirect its
<br>
standard file descriptors from and to /dev/null so that
random output doesn&rsquo;t wind up on the user&rsquo;s
terminal.</p>

<p style="margin-top: 1em">use POSIX
&quot;setsid&quot;;</p>

<p style="margin-top: 1em">sub daemonize { <br>
chdir(&quot;/&quot;) || die &quot;can&rsquo;t chdir to /:
$!&quot;; <br>
open(STDIN, &quot;&lt; /dev/null&quot;) || die
&quot;can&rsquo;t read /dev/null: $!&quot;; <br>
open(STDOUT, &quot;&gt; /dev/null&quot;) || die
&quot;can&rsquo;t write to /dev/null: $!&quot;; <br>
defined(my $pid = fork()) || die &quot;can&rsquo;t fork:
$!&quot;; <br>
exit if $pid; # non-zero now means I am the parent <br>
(setsid() != -1) || die &quot;Can&rsquo;t start a new
session: $!&quot; <br>
open(STDERR, &quot;&gt;&amp;STDOUT&quot;) || die
&quot;can&rsquo;t dup stdout: $!&quot;; <br>
}</p>

<p style="margin-top: 1em">The fork() has to come before
the setsid() to ensure you aren&rsquo;t a process group
leader; the setsid() will fail if you are. If your system
doesn&rsquo;t have the setsid() function, <br>
open /dev/tty and use the &quot;TIOCNOTTY&quot; ioctl() on
it instead. See tty(4) for details.</p>

<p style="margin-top: 1em">Non-Unix users should check
their &quot;Your_OS::Process&quot; module for other possible
solutions.</p>

<p style="margin-top: 1em">Safe Pipe Opens <br>
Another interesting approach to IPC is making your single
program go multiprocess and communicate between--or even
amongst--yourselves. The open() function will accept a file
<br>
argument of either &quot;-|&quot; or &quot;|-&quot; to do a
very interesting thing: it forks a child connected to the
filehandle you&rsquo;ve opened. The child is running the
same program as the parent. <br>
This is useful for safely opening a file when running under
an assumed UID or GID, for example. If you open a pipe to
minus, you can write to the filehandle you opened and your
<br>
kid will find it in his STDIN. If you open a pipe from
minus, you can read from the filehandle you opened whatever
your kid writes to his STDOUT.</p>

<p style="margin-top: 1em">use English qw[ -no_match_vars
]; <br>
my $PRECIOUS = &quot;/path/to/some/safe/file&quot;; <br>
my $sleep_count; <br>
my $pid;</p>

<p style="margin-top: 1em">do { <br>
$pid = open(KID_TO_WRITE, &quot;|-&quot;); <br>
unless (defined $pid) { <br>
warn &quot;cannot fork: $!&quot;; <br>
die &quot;bailing out&quot; if $sleep_count++ &gt; 6; <br>
sleep 10; <br>
} <br>
} until defined $pid;</p>

<p style="margin-top: 1em">if ($pid) { # I am the parent
<br>
print KID_TO_WRITE @some_data; <br>
close(KID_TO_WRITE) || warn &quot;kid exited $?&quot;; <br>
} else { # I am the child <br>
# drop permissions in setuid and/or setgid programs: <br>
($EUID, $EGID) = ($UID, $GID); <br>
open (OUTFILE, &quot;&gt; $PRECIOUS&quot;) <br>
|| die &quot;can&rsquo;t open $PRECIOUS: $!&quot;; <br>
while (&lt;STDIN&gt;) { <br>
print OUTFILE; # child&rsquo;s STDIN is parent&rsquo;s
KID_TO_WRITE <br>
} <br>
close(OUTFILE) || die &quot;can&rsquo;t close $PRECIOUS:
$!&quot;; <br>
exit(0); # don&rsquo;t forget this!! <br>
}</p>

<p style="margin-top: 1em">Another common use for this
construct is when you need to execute something without the
shell&rsquo;s interference. With system(), it&rsquo;s
straightforward, but you can&rsquo;t use a pipe open <br>
or backticks safely. That&rsquo;s because there&rsquo;s no
way to stop the shell from getting its hands on your
arguments. Instead, use lower-level control to call exec()
directly.</p>

<p style="margin-top: 1em">Here&rsquo;s a safe backtick or
pipe open for read:</p>

<p style="margin-top: 1em">my $pid = open(KID_TO_READ,
&quot;-|&quot;); <br>
defined($pid) || die &quot;can&rsquo;t fork: $!&quot;;</p>

<p style="margin-top: 1em">if ($pid) { # parent <br>
while (&lt;KID_TO_READ&gt;) { <br>
# do something interesting <br>
} <br>
close(KID_TO_READ) || warn &quot;kid exited $?&quot;;</p>

<p style="margin-top: 1em">} else { # child <br>
($EUID, $EGID) = ($UID, $GID); # suid only <br>
exec($program, @options, @args) <br>
|| die &quot;can&rsquo;t exec program: $!&quot;; <br>
# NOTREACHED <br>
}</p>

<p style="margin-top: 1em">And here&rsquo;s a safe pipe
open for writing:</p>

<p style="margin-top: 1em">my $pid = open(KID_TO_WRITE,
&quot;|-&quot;); <br>
defined($pid) || die &quot;can&rsquo;t fork: $!&quot;;</p>

<p style="margin-top: 1em">$SIG{PIPE} = sub { die
&quot;whoops, $program pipe broke&quot; };</p>

<p style="margin-top: 1em">if ($pid) { # parent <br>
print KID_TO_WRITE @data; <br>
close(KID_TO_WRITE) || warn &quot;kid exited $?&quot;;</p>

<p style="margin-top: 1em">} else { # child <br>
($EUID, $EGID) = ($UID, $GID); <br>
exec($program, @options, @args) <br>
|| die &quot;can&rsquo;t exec program: $!&quot;; <br>
# NOTREACHED <br>
}</p>

<p style="margin-top: 1em">It is very easy to dead-lock a
process using this form of open(), or indeed with any use of
pipe() with multiple subprocesses. The example above is
&quot;safe&quot; because it is simple <br>
and calls exec(). See &quot;Avoiding Pipe Deadlocks&quot;
for general safety principles, but there are extra gotchas
with Safe Pipe Opens.</p>

<p style="margin-top: 1em">In particular, if you opened the
pipe using &quot;open FH, &quot;|-&quot;&quot;, then you
cannot simply use close() in the parent process to close an
unwanted writer. Consider this code:</p>

<p style="margin-top: 1em">my $pid = open(WRITER,
&quot;|-&quot;); # fork open a kid <br>
defined($pid) || die &quot;first fork failed: $!&quot;; <br>
if ($pid) { <br>
if (my $sub_pid = fork()) { <br>
defined($sub_pid) || die &quot;second fork failed: $!&quot;;
<br>
close(WRITER) || die &quot;couldn&rsquo;t close WRITER:
$!&quot;; <br>
# now do something else... <br>
} <br>
else { <br>
# first write to WRITER <br>
# ... <br>
# then when finished <br>
close(WRITER) || die &quot;couldn&rsquo;t close WRITER:
$!&quot;; <br>
exit(0); <br>
} <br>
} <br>
else { <br>
# first do something with STDIN, then <br>
exit(0); <br>
}</p>

<p style="margin-top: 1em">In the example above, the true
parent does not want to write to the WRITER filehandle, so
it closes it. However, because WRITER was opened using
&quot;open FH, &quot;|-&quot;&quot;, it has a <br>
special behavior: closing it calls waitpid() (see
&quot;waitpid&quot; in perlfunc), which waits for the
subprocess to exit. If the child process ends up waiting for
something happening in <br>
the section marked &quot;do something else&quot;, you have
deadlock.</p>

<p style="margin-top: 1em">This can also be a problem with
intermediate subprocesses in more complicated code, which
will call waitpid() on all open filehandles during global
destruction--in no predictable <br>
order.</p>

<p style="margin-top: 1em">To solve this, you must manually
use pipe(), fork(), and the form of open() which sets one
file descriptor to another, as shown below:</p>

<p style="margin-top: 1em">pipe(READER, WRITER) || die
&quot;pipe failed: $!&quot;; <br>
$pid = fork(); <br>
defined($pid) || die &quot;first fork failed: $!&quot;; <br>
if ($pid) { <br>
close READER; <br>
if (my $sub_pid = fork()) { <br>
defined($sub_pid) || die &quot;first fork failed: $!&quot;;
<br>
close(WRITER) || die &quot;can&rsquo;t close WRITER:
$!&quot;; <br>
} <br>
else { <br>
# write to WRITER... <br>
# ... <br>
# then when finished <br>
close(WRITER) || die &quot;can&rsquo;t close WRITER:
$!&quot;; <br>
exit(0); <br>
} <br>
# write to WRITER... <br>
} <br>
else { <br>
open(STDIN, &quot;&lt;&amp;READER&quot;) || die
&quot;can&rsquo;t reopen STDIN: $!&quot;; <br>
close(WRITER) || die &quot;can&rsquo;t close WRITER:
$!&quot;; <br>
# do something... <br>
exit(0); <br>
}</p>

<p style="margin-top: 1em">Since Perl 5.8.0, you can also
use the list form of &quot;open&quot; for pipes. This is
preferred when you wish to avoid having the shell interpret
metacharacters that may be in your <br>
command string.</p>

<p style="margin-top: 1em">So for example, instead of
using:</p>

<p style="margin-top: 1em">open(PS_PIPE, &quot;ps
aux|&quot;) || die &quot;can&rsquo;t open ps pipe:
$!&quot;;</p>

<p style="margin-top: 1em">One would use either of
these:</p>

<p style="margin-top: 1em">open(PS_PIPE, &quot;-|&quot;,
&quot;ps&quot;, &quot;aux&quot;) <br>
|| die &quot;can&rsquo;t open ps pipe: $!&quot;;</p>

<p style="margin-top: 1em">@ps_args = qw[ ps aux ]; <br>
open(PS_PIPE, &quot;-|&quot;, @ps_args) <br>
|| die &quot;can&rsquo;t open @ps_args|: $!&quot;;</p>

<p style="margin-top: 1em">Because there are more than
three arguments to open(), forks the ps(1) command without
spawning a shell, and reads its standard output via the
&quot;PS_PIPE&quot; filehandle. The <br>
corresponding syntax to write to command pipes is to use
&quot;|-&quot; in place of &quot;-|&quot;.</p>

<p style="margin-top: 1em">This was admittedly a rather
silly example, because you&rsquo;re using string literals
whose content is perfectly safe. There is therefore no cause
to resort to the harder-to-read, <br>
multi-argument form of pipe open(). However, whenever you
cannot be assured that the program arguments are free of
shell metacharacters, the fancier form of open() should be
<br>
used. For example:</p>

<p style="margin-top: 1em">@grep_args = (&quot;egrep&quot;,
&quot;-i&quot;, $some_pattern, @many_files); <br>
open(GREP_PIPE, &quot;-|&quot;, @grep_args) <br>
|| die &quot;can&rsquo;t open @grep_args|: $!&quot;;</p>

<p style="margin-top: 1em">Here the multi-argument form of
pipe open() is preferred because the pattern and indeed even
the filenames themselves might hold metacharacters.</p>

<p style="margin-top: 1em">Be aware that these operations
are full Unix forks, which means they may not be correctly
implemented on all alien systems. Additionally, these are
not true multithreading. To <br>
learn more about threading, see the modules file mentioned
below in the SEE ALSO section.</p>

<p style="margin-top: 1em">Avoiding Pipe Deadlocks <br>
Whenever you have more than one subprocess, you must be
careful that each closes whichever half of any pipes created
for interprocess communication it is not using. This is <br>
because any child process reading from the pipe and
expecting an EOF will never receive it, and therefore never
exit. A single process closing a pipe is not enough to close
it; <br>
the last process with the pipe open must close it for it to
read EOF.</p>

<p style="margin-top: 1em">Certain built-in Unix features
help prevent this most of the time. For instance,
filehandles have a &quot;close on exec&quot; flag, which is
set en masse under control of the $^F <br>
variable. This is so any filehandles you didn&rsquo;t
explicitly route to the STDIN, STDOUT or STDERR of a child
program will be automatically closed.</p>

<p style="margin-top: 1em">Always explicitly and
immediately call close() on the writable end of any pipe,
unless that process is actually writing to it. Even if you
don&rsquo;t explicitly call close(), Perl <br>
will still close() all filehandles during global
destruction. As previously discussed, if those filehandles
have been opened with Safe Pipe Open, this will result in
calling <br>
waitpid(), which may again deadlock.</p>

<p style="margin-top: 1em">Bidirectional Communication with
Another Process <br>
While this works reasonably well for unidirectional
communication, what about bidirectional communication? The
most obvious approach doesn&rsquo;t work:</p>

<p style="margin-top: 1em"># THIS DOES NOT WORK!! <br>
open(PROG_FOR_READING_AND_WRITING, &quot;| some program
|&quot;)</p>

<p style="margin-top: 1em">If you forget to &quot;use
warnings&quot;, you&rsquo;ll miss out entirely on the
helpful diagnostic message:</p>

<p style="margin-top: 1em">Can&rsquo;t do bidirectional
pipe at -e line 1.</p>

<p style="margin-top: 1em">If you really want to, you can
use the standard open2() from the &quot;IPC::Open2&quot;
module to catch both ends. There&rsquo;s also an open3() in
&quot;IPC::Open3&quot; for tridirectional I/O so you <br>
can also catch your child&rsquo;s STDERR, but doing so would
then require an awkward select() loop and wouldn&rsquo;t
allow you to use normal Perl input operations.</p>

<p style="margin-top: 1em">If you look at its source,
you&rsquo;ll see that open2() uses low-level primitives like
the pipe() and exec() syscalls to create all the
connections. Although it might have been more <br>
efficient by using socketpair(), this would have been even
less portable than it already is. The open2() and open3()
functions are unlikely to work anywhere except on a Unix
<br>
system, or at least one purporting POSIX compliance.</p>

<p style="margin-top: 1em">Here&rsquo;s an example of using
open2():</p>

<p style="margin-top: 1em">use FileHandle; <br>
use IPC::Open2; <br>
$pid = open2(*Reader, *Writer, &quot;cat -un&quot;); <br>
print Writer &quot;stuff0; <br>
$got = &lt;Reader&gt;;</p>

<p style="margin-top: 1em">The problem with this is that
buffering is really going to ruin your day. Even though your
&quot;Writer&quot; filehandle is auto-flushed so the process
on the other end gets your data in <br>
a timely manner, you can&rsquo;t usually do anything to
force that process to give its data to you in a similarly
quick fashion. In this special case, we could actually so,
because we <br>
gave cat a -u flag to make it unbuffered. But very few
commands are designed to operate over pipes, so this seldom
works unless you yourself wrote the program on the other end
<br>
of the double-ended pipe.</p>

<p style="margin-top: 1em">A solution to this is to use a
library which uses pseudottys to make your program behave
more reasonably. This way you don&rsquo;t have to have
control over the source code of the <br>
program you&rsquo;re using. The &quot;Expect&quot; module
from CPAN also addresses this kind of thing. This module
requires two other modules from CPAN, &quot;IO::Pty&quot;
and &quot;IO::Stty&quot;. It sets up a <br>
pseudo terminal to interact with programs that insist on
talking to the terminal device driver. If your system is
supported, this may be your best bet.</p>

<p style="margin-top: 1em">Bidirectional Communication with
Yourself <br>
If you want, you may make low-level pipe() and fork()
syscalls to stitch this together by hand. This example only
talks to itself, but you could reopen the appropriate
handles <br>
to STDIN and STDOUT and call other processes. (The following
example lacks proper error checking.)</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
# pipe1 - bidirectional communication using two pipe pairs
<br>
# designed for the socketpair-challenged <br>
use IO::Handle; # thousands of lines just for autoflush :-(
<br>
pipe(PARENT_RDR, CHILD_WTR); # XXX: check failure? <br>
pipe(CHILD_RDR, PARENT_WTR); # XXX: check failure? <br>
CHILD_WTR-&gt;autoflush(1); <br>
PARENT_WTR-&gt;autoflush(1);</p>

<p style="margin-top: 1em">if ($pid = fork()) { <br>
close PARENT_RDR; <br>
close PARENT_WTR; <br>
print CHILD_WTR &quot;Parent Pid $$ is sending this0; <br>
chomp($line = &lt;CHILD_RDR&gt;); <br>
print &quot;Parent Pid $$ just read this:
&rsquo;$line&rsquo;0; <br>
close CHILD_RDR; close CHILD_WTR; <br>
waitpid($pid, 0); <br>
} else { <br>
die &quot;cannot fork: $!&quot; unless defined $pid; <br>
close CHILD_RDR; <br>
close CHILD_WTR; <br>
chomp($line = &lt;PARENT_RDR&gt;); <br>
print &quot;Child Pid $$ just read this:
&rsquo;$line&rsquo;0; <br>
print PARENT_WTR &quot;Child Pid $$ is sending this0; <br>
close PARENT_RDR; <br>
close PARENT_WTR; <br>
exit(0); <br>
}</p>

<p style="margin-top: 1em">But you don&rsquo;t actually
have to make two pipe calls. If you have the socketpair()
system call, it will do this all for you.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
# pipe2 - bidirectional communication using socketpair <br>
# &quot;the best ones always go both ways&quot;</p>

<p style="margin-top: 1em">use Socket; <br>
use IO::Handle; # thousands of lines just for autoflush
:-(</p>

<p style="margin-top: 1em"># We say AF_UNIX because
although *_LOCAL is the <br>
# POSIX 1003.1g form of the constant, many machines <br>
# still don&rsquo;t have it. <br>
socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
<br>
|| die &quot;socketpair: $!&quot;;</p>

<p style="margin-top: 1em">CHILD-&gt;autoflush(1); <br>
PARENT-&gt;autoflush(1);</p>

<p style="margin-top: 1em">if ($pid = fork()) { <br>
close PARENT; <br>
print CHILD &quot;Parent Pid $$ is sending this0; <br>
chomp($line = &lt;CHILD&gt;); <br>
print &quot;Parent Pid $$ just read this:
&rsquo;$line&rsquo;0; <br>
close CHILD; <br>
waitpid($pid, 0); <br>
} else { <br>
die &quot;cannot fork: $!&quot; unless defined $pid; <br>
close CHILD; <br>
chomp($line = &lt;PARENT&gt;); <br>
print &quot;Child Pid $$ just read this:
&rsquo;$line&rsquo;0; <br>
print PARENT &quot;Child Pid $$ is sending this0; <br>
close PARENT; <br>
exit(0); <br>
}</p>

<p style="margin-top: 1em">Sockets: Client/Server
Communication <br>
While not entirely limited to Unix-derived operating systems
(e.g., WinSock on PCs provides socket support, as do some
VMS libraries), you might not have sockets on your system,
<br>
in which case this section probably isn&rsquo;t going to do
you much good. With sockets, you can do both virtual
circuits like TCP streams and datagrams like UDP packets.
You may be <br>
able to do even more depending on your system.</p>

<p style="margin-top: 1em">The Perl functions for dealing
with sockets have the same names as the corresponding system
calls in C, but their arguments tend to differ for two
reasons. First, Perl <br>
filehandles work differently than C file descriptors.
Second, Perl already knows the length of its strings, so you
don&rsquo;t need to pass that information.</p>

<p style="margin-top: 1em">One of the major problems with
ancient, antemillennial socket code in Perl was that it used
hard-coded values for some of the constants, which severely
hurt portability. If you <br>
ever see code that does anything like explicitly setting
&quot;$AF_INET = 2&quot;, you know you&rsquo;re in for big
trouble. An immeasurably superior approach is to use the
&quot;Socket&quot; module, <br>
which more reliably grants access to the various constants
and functions you&rsquo;ll need.</p>

<p style="margin-top: 1em">If you&rsquo;re not writing a
server/client for an existing protocol like NNTP or SMTP,
you should give some thought to how your server will know
when the client has finished talking, <br>
and vice-versa. Most protocols are based on one-line
messages and responses (so one party knows the other has
finished when a &quot;0 is received) or multi-line messages
and <br>
responses that end with a period on an empty line (&quot;00
terminates a message/response).</p>

<p style="margin-top: 1em">Internet Line Terminators <br>
The Internet line terminator is &quot; 15 12&quot;. Under
ASCII0, but under variants of Unix, that could usually be
written as &quot;0 might at times be other systems, &quot;
<br>
&quot; 15 15 12&quot;, &quot; 12 12 15&quot;, or something
completely different. The standards specify writing &quot;
15 12&quot; to be conformant (be strict in what you
provide), but they also <br>
recommend accepting a lone &quot; 12&quot; on input (be
lenient in what you require). We haven&rsquo;t always been
very good about that in the code in this manpage, but unless
you&rsquo;re on a Mac <br>
from way back in its pre-Unix dark ages, you&rsquo;ll
probably be ok.</p>

<p style="margin-top: 1em">Internet TCP Clients and Servers
<br>
Use Internet-domain sockets when you want to do
client-server communication that might extend to machines
outside of your own system.</p>

<p style="margin-top: 1em">Here&rsquo;s a sample TCP client
using Internet-domain sockets:</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use strict; <br>
use Socket; <br>
my ($remote, $port, $iaddr, $paddr, $proto, $line);</p>

<p style="margin-top: 1em">$remote = shift ||
&quot;localhost&quot;; <br>
$port = shift || 2345; # random port <br>
if ($port =~ / die &quot;No port&quot; unless $port; <br>
$iaddr = inet_aton($remote) || die &quot;no host:
$remote&quot;; <br>
$paddr = sockaddr_in($port, $iaddr);</p>

<p style="margin-top: 1em">$proto =
getprotobyname(&quot;tcp&quot;); <br>
socket(SOCK, PF_INET, SOCK_STREAM, $proto) || die
&quot;socket: $!&quot;; <br>
connect(SOCK, $paddr) || die &quot;connect: $!&quot;; <br>
while ($line = &lt;SOCK&gt;) { <br>
print $line; <br>
}</p>

<p style="margin-top: 1em">close (SOCK) || die &quot;close:
$!&quot;; <br>
exit(0);</p>

<p style="margin-top: 1em">And here&rsquo;s a corresponding
server to go along with it. We&rsquo;ll leave the address as
&quot;INADDR_ANY&quot; so that the kernel can choose the
appropriate interface on multihomed hosts. If <br>
you want sit on a particular interface (like the external
side of a gateway or firewall machine), fill this in with
your real address instead.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -Tw <br>
use strict; <br>
BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; } <br>
use Socket; <br>
use Carp; <br>
my $EOL = &quot; 15 12&quot;;</p>

<p style="margin-top: 1em">sub logmsg { print &quot;$0 $$:
@_ at &quot;, scalar localtime(), &quot;0 }</p>

<p style="margin-top: 1em">my $port = shift || 2345; <br>
die &quot;invalid port&quot; unless if $port =~ /^ +
$/x;</p>

<p style="margin-top: 1em">my $proto =
getprotobyname(&quot;tcp&quot;);</p>

<p style="margin-top: 1em">socket(Server, PF_INET,
SOCK_STREAM, $proto) || die &quot;socket: $!&quot;; <br>
setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
pack(&quot;l&quot;, 1)) <br>
|| die &quot;setsockopt: $!&quot;; <br>
bind(Server, sockaddr_in($port, INADDR_ANY)) || die
&quot;bind: $!&quot;; <br>
listen(Server, SOMAXCONN) || die &quot;listen: $!&quot;;</p>

<p style="margin-top: 1em">logmsg &quot;server started on
port $port&quot;;</p>

<p style="margin-top: 1em">my $paddr;</p>

<p style="margin-top: 1em">$SIG{CHLD} = REAPER;</p>

<p style="margin-top: 1em">for ( ; $paddr = accept(Client,
Server); close Client) { <br>
my($port, $iaddr) = sockaddr_in($paddr); <br>
my $name = gethostbyaddr($iaddr, AF_INET);</p>

<p style="margin-top: 1em">logmsg &quot;connection from
$name [&quot;, <br>
inet_ntoa($iaddr), &quot;] <br>
at port $port&quot;;</p>

<p style="margin-top: 1em">print Client &quot;Hello there,
$name, it&rsquo;s now &quot;, <br>
scalar localtime(), $EOL; <br>
}</p>

<p style="margin-top: 1em">And here&rsquo;s a multithreaded
version. It&rsquo;s multithreaded in that like most typical
servers, it spawns (fork()s) a slave server to handle the
client request so that the master <br>
server can quickly go back to service a new client.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -Tw <br>
use strict; <br>
BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; } <br>
use Socket; <br>
use Carp; <br>
my $EOL = &quot; 15 12&quot;;</p>

<p style="margin-top: 1em">sub spawn; # forward declaration
<br>
sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar
localtime(), &quot;0 }</p>

<p style="margin-top: 1em">my $port = shift || 2345; <br>
die &quot;invalid port&quot; unless if $port =~ /^ +
$/x;</p>

<p style="margin-top: 1em">my $proto =
getprotobyname(&quot;tcp&quot;);</p>

<p style="margin-top: 1em">socket(Server, PF_INET,
SOCK_STREAM, $proto) || die &quot;socket: $!&quot;; <br>
setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
pack(&quot;l&quot;, 1)) <br>
|| die &quot;setsockopt: $!&quot;; <br>
bind(Server, sockaddr_in($port, INADDR_ANY)) || die
&quot;bind: $!&quot;; <br>
listen(Server, SOMAXCONN) || die &quot;listen: $!&quot;;</p>

<p style="margin-top: 1em">logmsg &quot;server started on
port $port&quot;;</p>

<p style="margin-top: 1em">my $waitedpid = 0; <br>
my $paddr;</p>

<p style="margin-top: 1em">use POSIX
&quot;:sys_wait_h&quot;; <br>
use Errno;</p>

<p style="margin-top: 1em">sub REAPER { <br>
local $!; # don&rsquo;t let waitpid() overwrite current
error <br>
while ((my $pid = waitpid(-1, WNOHANG)) &gt; 0 &amp;&amp;
WIFEXITED($?)) { <br>
logmsg &quot;reaped $waitedpid&quot; . ($? ? &quot; with
exit $?&quot; : &quot;&quot;); <br>
} <br>
$SIG{CHLD} = REAPER; # loathe SysV <br>
}</p>

<p style="margin-top: 1em">$SIG{CHLD} = REAPER;</p>

<p style="margin-top: 1em">while (1) { <br>
$paddr = accept(Client, Server) || do { <br>
# try again if accept() returned because got a signal <br>
next if $!{EINTR}; <br>
die &quot;accept: $!&quot;; <br>
}; <br>
my ($port, $iaddr) = sockaddr_in($paddr); <br>
my $name = gethostbyaddr($iaddr, AF_INET);</p>

<p style="margin-top: 1em">logmsg &quot;connection from
$name [&quot;, <br>
inet_ntoa($iaddr), <br>
&quot;] at port $port&quot;;</p>

<p style="margin-top: 1em">spawn sub { <br>
$| = 1; <br>
print &quot;Hello there, $name, it&rsquo;s now &quot;,
scalar localtime(), $EOL; <br>
exec &quot;/usr/games/fortune&quot; # XXX: &quot;wrong&quot;
line terminators <br>
or confess &quot;can&rsquo;t exec fortune: $!&quot;; <br>
}; <br>
close Client; <br>
}</p>

<p style="margin-top: 1em">sub spawn { <br>
my $coderef = shift;</p>

<p style="margin-top: 1em">unless (@_ == 0 &amp;&amp;
$coderef &amp;&amp; ref($coderef) eq &quot;CODE&quot;) {
<br>
confess &quot;usage: spawn CODEREF&quot;; <br>
}</p>

<p style="margin-top: 1em">my $pid; <br>
unless (defined($pid = fork())) { <br>
logmsg &quot;cannot fork: $!&quot;; <br>
return; <br>
} <br>
elsif ($pid) { <br>
logmsg &quot;begat $pid&quot;; <br>
return; # I&rsquo;m the parent <br>
} <br>
# else I&rsquo;m the child -- go spawn</p>

<p style="margin-top: 1em">open(STDIN,
&quot;&lt;&amp;Client&quot;) || die &quot;can&rsquo;t dup
client to stdin&quot;; <br>
open(STDOUT, &quot;&gt;&amp;Client&quot;) || die
&quot;can&rsquo;t dup client to stdout&quot;; <br>
## open(STDERR, &quot;&gt;&amp;STDOUT&quot;) || die
&quot;can&rsquo;t dup stdout to stderr&quot;; <br>
exit($coderef-&gt;()); <br>
}</p>

<p style="margin-top: 1em">This server takes the trouble to
clone off a child version via fork() for each incoming
request. That way it can handle many requests at once, which
you might not always want. <br>
Even if you don&rsquo;t fork(), the listen() will allow that
many pending connections. Forking servers have to be
particularly careful about cleaning up their dead children
(called <br>
&quot;zombies&quot; in Unix parlance), because otherwise
you&rsquo;ll quickly fill up your process table. The REAPER
subroutine is used here to call waitpid() for any child
processes that have <br>
finished, thereby ensuring that they terminate cleanly and
don&rsquo;t join the ranks of the living dead.</p>

<p style="margin-top: 1em">Within the while loop we call
accept() and check to see if it returns a false value. This
would normally indicate a system error needs to be reported.
However, the introduction <br>
of safe signals (see &quot;Deferred Signals (Safe
Signals)&quot; above) in Perl 5.7.3 means that accept()
might also be interrupted when the process receives a
signal. This typically <br>
happens when one of the forked subprocesses exits and
notifies the parent process with a CHLD signal.</p>

<p style="margin-top: 1em">If accept() is interrupted by a
signal, $! will be set to EINTR. If this happens, we can
safely continue to the next iteration of the loop and
another call to accept(). It is <br>
important that your signal handling code not modify the
value of $!, or else this test will likely fail. In the
REAPER subroutine we create a local version of $! before
calling <br>
waitpid(). When waitpid() sets $! to ECHILD as it inevitably
does when it has no more children waiting, it updates the
local copy and leaves the original unchanged.</p>

<p style="margin-top: 1em">You should use the -T flag to
enable taint checking (see perlsec) even if we aren&rsquo;t
running setuid or setgid. This is always a good idea for
servers or any program run on behalf <br>
of someone else (like CGI scripts), because it lessens the
chances that people from the outside will be able to
compromise your system.</p>

<p style="margin-top: 1em">Let&rsquo;s look at another TCP
client. This one connects to the TCP &quot;time&quot;
service on a number of different machines and shows how far
their clocks differ from the system on which <br>
it&rsquo;s being run:</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use strict; <br>
use Socket;</p>

<p style="margin-top: 1em">my $SECS_OF_70_YEARS =
2208988800; <br>
sub ctime { scalar localtime(shift() || time()) }</p>

<p style="margin-top: 1em">my $iaddr =
gethostbyname(&quot;localhost&quot;); <br>
my $proto = getprotobyname(&quot;tcp&quot;); <br>
my $port = getservbyname(&quot;time&quot;, &quot;tcp&quot;);
<br>
my $paddr = sockaddr_in(0, $iaddr); <br>
my($host);</p>

<p style="margin-top: 1em">$| = 1; <br>
printf &quot;%-24s %8s %s0, &quot;localhost&quot;, 0,
ctime();</p>

<p style="margin-top: 1em">foreach $host (@ARGV) { <br>
printf &quot;%-24s &quot;, $host; <br>
my $hisiaddr = inet_aton($host) || die &quot;unknown
host&quot;; <br>
my $hispaddr = sockaddr_in($port, $hisiaddr); <br>
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) <br>
|| die &quot;socket: $!&quot;; <br>
connect(SOCKET, $hispaddr) || die &quot;connect: $!&quot;;
<br>
my $rtime = pack(&quot;C4&quot;, ()); <br>
read(SOCKET, $rtime, 4); <br>
close(SOCKET); <br>
my $histime = unpack(&quot;N&quot;, $rtime) -
$SECS_OF_70_YEARS; <br>
printf &quot;%8d %s0, $histime - time(), ctime($histime);
<br>
}</p>

<p style="margin-top: 1em">Unix-Domain TCP Clients and
Servers <br>
That&rsquo;s fine for Internet-domain clients and servers,
but what about local communications? While you can use the
same setup, sometimes you don&rsquo;t want to. Unix-domain
sockets are <br>
local to the current host, and are often used internally to
implement pipes. Unlike Internet domain sockets, Unix domain
sockets can show up in the file system with an ls(1) <br>
listing.</p>

<p style="margin-top: 1em">% ls -l /dev/log <br>
srw-rw-rw- 1 root 0 Oct 31 07:23 /dev/log</p>

<p style="margin-top: 1em">You can test for these with
Perl&rsquo;s -S file test:</p>

<p style="margin-top: 1em">unless (-S &quot;/dev/log&quot;)
{ <br>
die &quot;something&rsquo;s wicked with the log
system&quot;; <br>
}</p>

<p style="margin-top: 1em">Here&rsquo;s a sample
Unix-domain client:</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use Socket; <br>
use strict; <br>
my ($rendezvous, $line);</p>

<p style="margin-top: 1em">$rendezvous = shift ||
&quot;catsock&quot;; <br>
socket(SOCK, PF_UNIX, SOCK_STREAM, 0) || die &quot;socket:
$!&quot;; <br>
connect(SOCK, sockaddr_un($rendezvous)) || die
&quot;connect: $!&quot;; <br>
while (defined($line = &lt;SOCK&gt;)) { <br>
print $line; <br>
} <br>
exit(0);</p>

<p style="margin-top: 1em">And here&rsquo;s a corresponding
server. You don&rsquo;t have to worry about silly network
terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus <br>
everything works right.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -Tw <br>
use strict; <br>
use Socket; <br>
use Carp;</p>

<p style="margin-top: 1em">BEGIN { $ENV{PATH} =
&quot;/usr/bin:/bin&quot; } <br>
sub spawn; # forward declaration <br>
sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar
localtime(), &quot;0 }</p>

<p style="margin-top: 1em">my $NAME = &quot;catsock&quot;;
<br>
my $uaddr = sockaddr_un($NAME); <br>
my $proto = getprotobyname(&quot;tcp&quot;);</p>

<p style="margin-top: 1em">socket(Server, PF_UNIX,
SOCK_STREAM, 0) || die &quot;socket: $!&quot;; <br>
unlink($NAME); <br>
bind (Server, $uaddr) || die &quot;bind: $!&quot;; <br>
listen(Server, SOMAXCONN) || die &quot;listen: $!&quot;;</p>

<p style="margin-top: 1em">logmsg &quot;server started on
$NAME&quot;;</p>

<p style="margin-top: 1em">my $waitedpid;</p>

<p style="margin-top: 1em">use POSIX
&quot;:sys_wait_h&quot;; <br>
sub REAPER { <br>
my $child; <br>
while (($waitedpid = waitpid(-1, WNOHANG)) &gt; 0) { <br>
logmsg &quot;reaped $waitedpid&quot; . ($? ? &quot; with
exit $?&quot; : &quot;&quot;); <br>
} <br>
$SIG{CHLD} = REAPER; # loathe SysV <br>
}</p>

<p style="margin-top: 1em">$SIG{CHLD} = REAPER;</p>

<p style="margin-top: 1em">for ( $waitedpid = 0; <br>
accept(Client, Server) || $waitedpid; <br>
$waitedpid = 0, close Client) <br>
{ <br>
next if $waitedpid; <br>
logmsg &quot;connection on $NAME&quot;; <br>
spawn sub { <br>
print &quot;Hello there, it&rsquo;s now &quot;, scalar
localtime(), &quot;0; <br>
exec(&quot;/usr/games/fortune&quot;) || die
&quot;can&rsquo;t exec fortune: $!&quot;; <br>
}; <br>
}</p>

<p style="margin-top: 1em">sub spawn { <br>
my $coderef = shift();</p>

<p style="margin-top: 1em">unless (@_ == 0 &amp;&amp;
$coderef &amp;&amp; ref($coderef) eq &quot;CODE&quot;) {
<br>
confess &quot;usage: spawn CODEREF&quot;; <br>
}</p>

<p style="margin-top: 1em">my $pid; <br>
unless (defined($pid = fork())) { <br>
logmsg &quot;cannot fork: $!&quot;; <br>
return; <br>
} <br>
elsif ($pid) { <br>
logmsg &quot;begat $pid&quot;; <br>
return; # I&rsquo;m the parent <br>
} <br>
else { <br>
# I&rsquo;m the child -- go spawn <br>
}</p>

<p style="margin-top: 1em">open(STDIN,
&quot;&lt;&amp;Client&quot;) || die &quot;can&rsquo;t dup
client to stdin&quot;; <br>
open(STDOUT, &quot;&gt;&amp;Client&quot;) || die
&quot;can&rsquo;t dup client to stdout&quot;; <br>
## open(STDERR, &quot;&gt;&amp;STDOUT&quot;) || die
&quot;can&rsquo;t dup stdout to stderr&quot;; <br>
exit($coderef-&gt;()); <br>
}</p>

<p style="margin-top: 1em">As you see, it&rsquo;s
remarkably similar to the Internet domain TCP server, so
much so, in fact, that we&rsquo;ve omitted several duplicate
functions--spawn(), logmsg(), ctime(), and <br>
REAPER()--which are the same as in the other server.</p>

<p style="margin-top: 1em">So why would you ever want to
use a Unix domain socket instead of a simpler named pipe?
Because a named pipe doesn&rsquo;t give you sessions. You
can&rsquo;t tell one process&rsquo;s data from <br>
another&rsquo;s. With socket programming, you get a separate
session for each client; that&rsquo;s why accept() takes two
arguments.</p>

<p style="margin-top: 1em">For example, let&rsquo;s say
that you have a long-running database server daemon that you
want folks to be able to access from the Web, but only if
they go through a CGI interface. <br>
You&rsquo;d have a small, simple CGI program that does
whatever checks and logging you feel like, and then acts as
a Unix-domain client and connects to your private
server.</p>

<p style="margin-top: 1em">TCP Clients with IO::Socket <br>
For those preferring a higher-level interface to socket
programming, the IO::Socket module provides an
object-oriented approach. IO::Socket has been included in
the standard <br>
Perl distribution ever since Perl 5.004. If you&rsquo;re
running an earlier version of Perl (in which case, how are
you reading this manpage?), just fetch IO::Socket from CPAN,
where <br>
you&rsquo;ll also find modules providing easy interfaces to
the following systems: DNS, FTP, Ident (RFC 931), NIS and
NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, and
<br>
Time--to name just a few.</p>

<p style="margin-top: 1em">A Simple Client <br>
Here&rsquo;s a client that creates a TCP connection to the
&quot;daytime&quot; service at port 13 of the host name
&quot;localhost&quot; and prints out everything that the
server there cares to provide.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use IO::Socket; <br>
$remote = IO::Socket::INET-&gt;new( <br>
Proto =&gt; &quot;tcp&quot;, <br>
PeerAddr =&gt; &quot;localhost&quot;, <br>
PeerPort =&gt; &quot;daytime(13)&quot;, <br>
) <br>
|| die &quot;can&rsquo;t connect to daytime service on
localhost&quot;; <br>
while (&lt;$remote&gt;) { print }</p>

<p style="margin-top: 1em">When you run this program, you
should get something back that looks like this:</p>

<p style="margin-top: 1em">Wed May 14 08:40:46 MDT 1997</p>

<p style="margin-top: 1em">Here are what those parameters
to the new() constructor mean:</p>

<p style="margin-top: 1em">&quot;Proto&quot; <br>
This is which protocol to use. In this case, the socket
handle returned will be connected to a TCP socket, because
we want a stream-oriented connection, that is, one that <br>
acts pretty much like a plain old file. Not all sockets are
this of this type. For example, the UDP protocol can be used
to make a datagram socket, used for message- <br>
passing.</p>

<p style="margin-top: 1em">&quot;PeerAddr&quot; <br>
This is the name or Internet address of the remote host the
server is running on. We could have specified a longer name
like &quot;www.perl.com&quot;, or an address like <br>
&quot;207.171.7.72&quot;. For demonstration purposes,
we&rsquo;ve used the special hostname &quot;localhost&quot;,
which should always mean the current machine you&rsquo;re
running on. The corresponding <br>
Internet address for localhost is &quot;127.0.0.1&quot;, if
you&rsquo;d rather use that.</p>

<p style="margin-top: 1em">&quot;PeerPort&quot; <br>
This is the service name or port number we&rsquo;d like to
connect to. We could have gotten away with using just
&quot;daytime&quot; on systems with a well-configured system
services <br>
file,[FOOTNOTE: The system services file is found in
/etc/services under Unixy systems.] but here we&rsquo;ve
specified the port number (13) in parentheses. Using just
the number <br>
would have also worked, but numeric literals make careful
programmers nervous.</p>

<p style="margin-top: 1em">Notice how the return value from
the &quot;new&quot; constructor is used as a filehandle in
the &quot;while&quot; loop? That&rsquo;s what&rsquo;s called
an indirect filehandle, a scalar variable containing a <br>
filehandle. You can use it the same way you would a normal
filehandle. For example, you can read one line from it this
way:</p>

<p style="margin-top: 1em">$line = &lt;$handle&gt;;</p>

<p style="margin-top: 1em">all remaining lines from is this
way:</p>

<p style="margin-top: 1em">@lines = &lt;$handle&gt;;</p>

<p style="margin-top: 1em">and send a line of data to it
this way:</p>

<p style="margin-top: 1em">print $handle &quot;some
data0;</p>

<p style="margin-top: 1em">A Webget Client <br>
Here&rsquo;s a simple client that takes a remote host to
fetch a document from, and then a list of files to get from
that host. This is a more interesting client than the
previous one <br>
because it first sends something to the server before
fetching the server&rsquo;s response.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use IO::Socket; <br>
unless (@ARGV &gt; 1) { die &quot;usage: $0 host url
...&quot; } <br>
$host = shift(@ARGV); <br>
$EOL = &quot; 15 12&quot;; <br>
$BLANK = $EOL x 2; <br>
for my $document (@ARGV) { <br>
$remote = IO::Socket::INET-&gt;new( Proto =&gt;
&quot;tcp&quot;, <br>
PeerAddr =&gt; $host, <br>
PeerPort =&gt; &quot;http(80)&quot;, <br>
) || die &quot;cannot connect to httpd on $host&quot;; <br>
$remote-&gt;autoflush(1); <br>
print $remote &quot;GET $document HTTP/1.0&quot; . $BLANK;
<br>
while ( &lt;$remote&gt; ) { print } <br>
close $remote; <br>
}</p>

<p style="margin-top: 1em">The web server handling the HTTP
service is assumed to be at its standard port, number 80. If
the server you&rsquo;re trying to connect to is at a
different port, like 1080 or 8080, <br>
you should specify it as the named-parameter pair,
&quot;PeerPort =&gt; 8080&quot;. The &quot;autoflush&quot;
method is used on the socket because otherwise the system
would buffer up the output we <br>
sent it. (If you&rsquo;re on a prehistoric Mac, you&rsquo;ll
also need to change every &quot;0 in your code that sends
data over the network to be a &quot; 15 12&quot;
instead.)</p>

<p style="margin-top: 1em">Connecting to the server is only
the first part of the process: once you have the connection,
you have to use the server&rsquo;s language. Each server on
the network has its own <br>
little command language that it expects as input. The string
that we send to the server starting with &quot;GET&quot; is
in HTTP syntax. In this case, we simply request each
specified <br>
document. Yes, we really are making a new connection for
each document, even though it&rsquo;s the same host.
That&rsquo;s the way you always used to have to speak HTTP.
Recent versions <br>
of web browsers may request that the remote server leave the
connection open a little while, but the server doesn&rsquo;t
have to honor such a request.</p>

<p style="margin-top: 1em">Here&rsquo;s an example of
running that program, which we&rsquo;ll call webget:</p>

<p style="margin-top: 1em">% webget www.perl.com
/guanaco.html <br>
HTTP/1.1 404 File Not Found <br>
Date: Thu, 08 May 1997 18:02:32 GMT <br>
Server: Apache/1.2b6 <br>
Connection: close <br>
Content-type: text/html</p>

<p style="margin-top: 1em">&lt;HEAD&gt;&lt;TITLE&gt;404
File Not Found&lt;/TITLE&gt;&lt;/HEAD&gt; <br>
&lt;BODY&gt;&lt;H1&gt;File Not Found&lt;/H1&gt; <br>
The requested URL /guanaco.html was not found on this
server.&lt;P&gt; <br>
&lt;/BODY&gt;</p>

<p style="margin-top: 1em">Ok, so that&rsquo;s not very
interesting, because it didn&rsquo;t find that particular
document. But a long response wouldn&rsquo;t have fit on
this page.</p>

<p style="margin-top: 1em">For a more featureful version of
this program, you should look to the lwp-request program
included with the LWP modules from CPAN.</p>

<p style="margin-top: 1em">Interactive Client with
IO::Socket <br>
Well, that&rsquo;s all fine if you want to send one command
and get one answer, but what about setting up something
fully interactive, somewhat like the way telnet works? That
way you <br>
can type a line, get the answer, type a line, get the
answer, etc.</p>

<p style="margin-top: 1em">This client is more complicated
than the two we&rsquo;ve done so far, but if you&rsquo;re on
a system that supports the powerful &quot;fork&quot; call,
the solution isn&rsquo;t that rough. Once you&rsquo;ve made
<br>
the connection to whatever service you&rsquo;d like to chat
with, call &quot;fork&quot; to clone your process. Each of
these two identical process has a very simple job to do: the
parent copies <br>
everything from the socket to standard output, while the
child simultaneously copies everything from standard input
to the socket. To accomplish the same thing using just one
<br>
process would be much harder, because it&rsquo;s easier to
code two processes to do one thing than it is to code one
process to do two things. (This keep-it-simple principle a
<br>
cornerstones of the Unix philosophy, and good software
engineering as well, which is probably why it&rsquo;s spread
to other systems.)</p>

<p style="margin-top: 1em">Here&rsquo;s the code:</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use strict; <br>
use IO::Socket; <br>
my ($host, $port, $kidpid, $handle, $line);</p>

<p style="margin-top: 1em">unless (@ARGV == 2) { die
&quot;usage: $0 host port&quot; } <br>
($host, $port) = @ARGV;</p>

<p style="margin-top: 1em"># create a tcp connection to the
specified host and port <br>
$handle = IO::Socket::INET-&gt;new(Proto =&gt;
&quot;tcp&quot;, <br>
PeerAddr =&gt; $host, <br>
PeerPort =&gt; $port) <br>
|| die &quot;can&rsquo;t connect to port $port on $host:
$!&quot;;</p>

<p style="margin-top: 1em">$handle-&gt;autoflush(1); # so
output gets there right away <br>
print STDERR &quot;[Connected to $host:$port]0;</p>

<p style="margin-top: 1em"># split the program into two
processes, identical twins <br>
die &quot;can&rsquo;t fork: $!&quot; unless defined($kidpid
= fork());</p>

<p style="margin-top: 1em"># the if{} block runs only in
the parent process <br>
if ($kidpid) { <br>
# copy the socket to standard output <br>
while (defined ($line = &lt;$handle&gt;)) { <br>
print STDOUT $line; <br>
} <br>
kill(&quot;TERM&quot;, $kidpid); # send SIGTERM to child
<br>
} <br>
# the else{} block runs only in the child process <br>
else { <br>
# copy standard input to the socket <br>
while (defined ($line = &lt;STDIN&gt;)) { <br>
print $handle $line; <br>
} <br>
exit(0); # just in case <br>
}</p>

<p style="margin-top: 1em">The &quot;kill&quot; function in
the parent&rsquo;s &quot;if&quot; block is there to send a
signal to our child process, currently running in the
&quot;else&quot; block, as soon as the remote server has
closed its <br>
end of the connection.</p>

<p style="margin-top: 1em">If the remote server sends data
a byte at time, and you need that data immediately without
waiting for a newline (which might not happen), you may wish
to replace the &quot;while&quot; <br>
loop in the parent with the following:</p>

<p style="margin-top: 1em">my $byte; <br>
while (sysread($handle, $byte, 1) == 1) { <br>
print STDOUT $byte; <br>
}</p>

<p style="margin-top: 1em">Making a system call for each
byte you want to read is not very efficient (to put it
mildly) but is the simplest to explain and works reasonably
well.</p>

<p style="margin-top: 1em">TCP Servers with IO::Socket <br>
As always, setting up a server is little bit more involved
than running a client. The model is that the server creates
a special kind of socket that does nothing but listen on a
<br>
particular port for incoming connections. It does this by
calling the &quot;IO::Socket::INET-&gt;new()&quot; method
with slightly different arguments than the client did.</p>

<p style="margin-top: 1em">Proto <br>
This is which protocol to use. Like our clients, we&rsquo;ll
still specify &quot;tcp&quot; here.</p>

<p style="margin-top: 1em">LocalPort <br>
We specify a local port in the &quot;LocalPort&quot;
argument, which we didn&rsquo;t do for the client. This is
service name or port number for which you want to be the
server. (Under Unix, <br>
ports under 1024 are restricted to the superuser.) In our
sample, we&rsquo;ll use port 9000, but you can use any port
that&rsquo;s not currently in use on your system. If you try
to <br>
use one already in used, you&rsquo;ll get an &quot;Address
already in use&quot; message. Under Unix, the &quot;netstat
-a&quot; command will show which services current have
servers.</p>

<p style="margin-top: 1em">Listen <br>
The &quot;Listen&quot; parameter is set to the maximum
number of pending connections we can accept until we turn
away incoming clients. Think of it as a call-waiting queue
for your <br>
telephone. The low-level Socket module has a special symbol
for the system maximum, which is SOMAXCONN.</p>

<p style="margin-top: 1em">Reuse <br>
The &quot;Reuse&quot; parameter is needed so that we restart
our server manually without waiting a few minutes to allow
system buffers to clear out.</p>

<p style="margin-top: 1em">Once the generic server socket
has been created using the parameters listed above, the
server then waits for a new client to connect to it. The
server blocks in the &quot;accept&quot; <br>
method, which eventually accepts a bidirectional connection
from the remote client. (Make sure to autoflush this handle
to circumvent buffering.)</p>

<p style="margin-top: 1em">To add to user-friendliness, our
server prompts the user for commands. Most servers
don&rsquo;t do this. Because of the prompt without a
newline, you&rsquo;ll have to use the &quot;sysread&quot;
<br>
variant of the interactive client above.</p>

<p style="margin-top: 1em">This server accepts one of five
different commands, sending output back to the client.
Unlike most network servers, this one handles only one
incoming client at a time. <br>
Multithreaded servers are covered in Chapter 16 of the
Camel.</p>

<p style="margin-top: 1em">Here&rsquo;s the code.
We&rsquo;ll</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use IO::Socket; <br>
use Net::hostent; # for OOish version of gethostbyaddr</p>

<p style="margin-top: 1em">$PORT = 9000; # pick something
not in use</p>

<p style="margin-top: 1em">$server =
IO::Socket::INET-&gt;new( Proto =&gt; &quot;tcp&quot;, <br>
LocalPort =&gt; $PORT, <br>
Listen =&gt; SOMAXCONN, <br>
Reuse =&gt; 1);</p>

<p style="margin-top: 1em">die &quot;can&rsquo;t setup
server&quot; unless $server; <br>
print &quot;[Server $0 accepting clients]0;</p>

<p style="margin-top: 1em">while ($client =
$server-&gt;accept()) { <br>
$client-&gt;autoflush(1); <br>
print $client &quot;Welcome to $0; type help for command
list.0; <br>
$hostinfo = gethostbyaddr($client-&gt;peeraddr); <br>
printf &quot;[Connect from %s]0, $hostinfo ?
$hostinfo-&gt;name : $client-&gt;peerhost; <br>
print $client &quot;Command? &quot;; <br>
while ( &lt;$client&gt;) { <br>
next unless /; # blank line <br>
if (/quit|exit/i) { last } <br>
elsif (/date|time/i) { printf $client &quot;%s0, scalar
localtime() } <br>
elsif (/who/i ) { print $client &lsquo;who
2&gt;&amp;1&lsquo; } <br>
elsif (/cookie/i ) { print $client &lsquo;/usr/games/fortune
2&gt;&amp;1&lsquo; } <br>
elsif (/motd/i ) { print $client &lsquo;cat /etc/motd
2&gt;&amp;1&lsquo; } <br>
else { <br>
print $client &quot;Commands: quit date who cookie motd0;
<br>
} <br>
} continue { <br>
print $client &quot;Command? &quot;; <br>
} <br>
close $client; <br>
}</p>

<p style="margin-top: 1em">UDP: Message Passing <br>
Another kind of client-server setup is one that uses not
connections, but messages. UDP communications involve much
lower overhead but also provide less reliability, as there
<br>
are no promises that messages will arrive at all, let alone
in order and unmangled. Still, UDP offers some advantages
over TCP, including being able to &quot;broadcast&quot; or
<br>
&quot;multicast&quot; to a whole bunch of destination hosts
at once (usually on your local subnet). If you find yourself
overly concerned about reliability and start building checks
into <br>
your message system, then you probably should use just TCP
to start with.</p>

<p style="margin-top: 1em">UDP datagrams are not a
bytestream and should not be treated as such. This makes
using I/O mechanisms with internal buffering like stdio
(i.e. print() and friends) especially <br>
cumbersome. Use syswrite(), or better send(), like in the
example below.</p>

<p style="margin-top: 1em">Here&rsquo;s a UDP program
similar to the sample Internet TCP client given earlier.
However, instead of checking one host at a time, the UDP
version will check many of them <br>
asynchronously by simulating a multicast and then using
select() to do a timed-out wait for I/O. To do something
similar with TCP, you&rsquo;d have to use a different socket
handle <br>
for each host.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use strict; <br>
use Socket; <br>
use Sys::Hostname;</p>

<p style="margin-top: 1em">my ( $count, $hisiaddr,
$hispaddr, $histime, <br>
$host, $iaddr, $paddr, $port, $proto, <br>
$rin, $rout, $rtime, $SECS_OF_70_YEARS);</p>

<p style="margin-top: 1em">$SECS_OF_70_YEARS =
2_208_988_800;</p>

<p style="margin-top: 1em">$iaddr =
gethostbyname(hostname()); <br>
$proto = getprotobyname(&quot;udp&quot;); <br>
$port = getservbyname(&quot;time&quot;, &quot;udp&quot;);
<br>
$paddr = sockaddr_in(0, $iaddr); # 0 means let kernel
pick</p>

<p style="margin-top: 1em">socket(SOCKET, PF_INET,
SOCK_DGRAM, $proto) || die &quot;socket: $!&quot;; <br>
bind(SOCKET, $paddr) || die &quot;bind: $!&quot;;</p>

<p style="margin-top: 1em">$| = 1; <br>
printf &quot;%-12s %8s %s0, &quot;localhost&quot;, 0, scalar
localtime(); <br>
$count = 0; <br>
for $host (@ARGV) { <br>
$count++; <br>
$hisiaddr = inet_aton($host) || die &quot;unknown
host&quot;; <br>
$hispaddr = sockaddr_in($port, $hisiaddr); <br>
defined(send(SOCKET, 0, 0, $hispaddr)) || die &quot;send
$host: $!&quot;; <br>
}</p>

<p style="margin-top: 1em">$rin = &quot;&quot;; <br>
vec($rin, fileno(SOCKET), 1) = 1;</p>

<p style="margin-top: 1em"># timeout after 10.0 seconds
<br>
while ($count &amp;&amp; select($rout = $rin, undef, undef,
10.0)) { <br>
$rtime = &quot;&quot;; <br>
$hispaddr = recv(SOCKET, $rtime, 4, 0) || die &quot;recv:
$!&quot;; <br>
($port, $hisiaddr) = sockaddr_in($hispaddr); <br>
$host = gethostbyaddr($hisiaddr, AF_INET); <br>
$histime = unpack(&quot;N&quot;, $rtime) -
$SECS_OF_70_YEARS; <br>
printf &quot;%-12s &quot;, $host; <br>
printf &quot;%8d %s0, $histime - time(), scalar
localtime($histime); <br>
$count--; <br>
}</p>

<p style="margin-top: 1em">This example does not include
any retries and may consequently fail to contact a reachable
host. The most prominent reason for this is congestion of
the queues on the sending <br>
host if the number of hosts to contact is sufficiently
large.</p>

<p style="margin-top: 1em">SysV IPC <br>
While System V IPC isn&rsquo;t so widely used as sockets, it
still has some interesting uses. However, you cannot use
SysV IPC or Berkeley mmap() to have a variable shared
amongst <br>
several processes. That&rsquo;s because Perl would
reallocate your string when you weren&rsquo;t wanting it to.
You might look into the &quot;IPC::Shareable&quot; or
&quot;threads::shared&quot; modules for <br>
that.</p>

<p style="margin-top: 1em">Here&rsquo;s a small example
showing shared memory usage.</p>

<p style="margin-top: 1em">use IPC::SysV qw(IPC_PRIVATE
IPC_RMID S_IRUSR S_IWUSR);</p>

<p style="margin-top: 1em">$size = 2000; <br>
$id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR); <br>
defined($id) || die &quot;shmget: $!&quot;; <br>
print &quot;shm key $id0;</p>

<p style="margin-top: 1em">$message = &quot;Message
#1&quot;; <br>
shmwrite($id, $message, 0, 60) || die &quot;shmwrite:
$!&quot;; <br>
print &quot;wrote: &rsquo;$message&rsquo;0; <br>
shmread($id, $buff, 0, 60) || die &quot;shmread: $!&quot;;
<br>
print &quot;read : &rsquo;$buff&rsquo;0;</p>

<p style="margin-top: 1em"># the buffer of shmread is
zero-character end-padded. <br>
substr($buff, index($buff, &quot; &quot;)) = &quot;&quot;;
<br>
print &quot;un&quot; unless $buff eq $message; <br>
print &quot;swell0;</p>

<p style="margin-top: 1em">print &quot;deleting shm $id0;
<br>
shmctl($id, IPC_RMID, 0) || die &quot;shmctl: $!&quot;;</p>

<p style="margin-top: 1em">Here&rsquo;s an example of a
semaphore:</p>

<p style="margin-top: 1em">use IPC::SysV qw(IPC_CREAT);</p>

<p style="margin-top: 1em">$IPC_KEY = 1234; <br>
$id = semget($IPC_KEY, 10, 0666 | IPC_CREAT); <br>
defined($id) || die &quot;shmget: $!&quot;; <br>
print &quot;shm key $id0;</p>

<p style="margin-top: 1em">Put this code in a separate file
to be run in more than one process. Call the file take:</p>

<p style="margin-top: 1em"># create a semaphore</p>

<p style="margin-top: 1em">$IPC_KEY = 1234; <br>
$id = semget($IPC_KEY, 0, 0); <br>
defined($id) || die &quot;shmget: $!&quot;;</p>

<p style="margin-top: 1em">$semnum = 0; <br>
$semflag = 0;</p>

<p style="margin-top: 1em"># &quot;take&quot; semaphore
<br>
# wait for semaphore to be zero <br>
$semop = 0; <br>
$opstring1 = pack(&quot;s!s!s!&quot;, $semnum, $semop,
$semflag);</p>

<p style="margin-top: 1em"># Increment the semaphore count
<br>
$semop = 1; <br>
$opstring2 = pack(&quot;s!s!s!&quot;, $semnum, $semop,
$semflag); <br>
$opstring = $opstring1 . $opstring2;</p>

<p style="margin-top: 1em">semop($id, $opstring) || die
&quot;semop: $!&quot;;</p>

<p style="margin-top: 1em">Put this code in a separate file
to be run in more than one process. Call this file give:</p>

<p style="margin-top: 1em"># &quot;give&quot; the semaphore
<br>
# run this in the original process and you will see <br>
# that the second process continues</p>

<p style="margin-top: 1em">$IPC_KEY = 1234; <br>
$id = semget($IPC_KEY, 0, 0); <br>
die unless defined($id);</p>

<p style="margin-top: 1em">$semnum = 0; <br>
$semflag = 0;</p>

<p style="margin-top: 1em"># Decrement the semaphore count
<br>
$semop = -1; <br>
$opstring = pack(&quot;s!s!s!&quot;, $semnum, $semop,
$semflag);</p>

<p style="margin-top: 1em">semop($id, $opstring) || die
&quot;semop: $!&quot;;</p>

<p style="margin-top: 1em">The SysV IPC code above was
written long ago, and it&rsquo;s definitely clunky looking.
For a more modern look, see the IPC::SysV module which is
included with Perl starting from Perl <br>
5.005.</p>

<p style="margin-top: 1em">A small example demonstrating
SysV message queues:</p>

<p style="margin-top: 1em">use IPC::SysV qw(IPC_PRIVATE
IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);</p>

<p style="margin-top: 1em">my $id = msgget(IPC_PRIVATE,
IPC_CREAT | S_IRUSR | S_IWUSR); <br>
defined($id) || die &quot;msgget failed: $!&quot;;</p>

<p style="margin-top: 1em">my $sent = &quot;message&quot;;
<br>
my $type_sent = 1234;</p>

<p style="margin-top: 1em">msgsnd($id, pack(&quot;l!
a*&quot;, $type_sent, $sent), 0) <br>
|| die &quot;msgsnd failed: $!&quot;;</p>

<p style="margin-top: 1em">msgrcv($id, my $rcvd_buf, 60, 0,
0) <br>
|| die &quot;msgrcv failed: $!&quot;;</p>

<p style="margin-top: 1em">my($type_rcvd, $rcvd) =
unpack(&quot;l! a*&quot;, $rcvd_buf);</p>

<p style="margin-top: 1em">if ($rcvd eq $sent) { <br>
print &quot;okay0; <br>
} else { <br>
print &quot;not okay0; <br>
}</p>

<p style="margin-top: 1em">msgctl($id, IPC_RMID, 0) || die
&quot;msgctl failed: $!0;</p>

<p style="margin-top: 1em">NOTES <br>
Most of these routines quietly but politely return
&quot;undef&quot; when they fail instead of causing your
program to die right then and there due to an uncaught
exception. (Actually, <br>
some of the new Socket conversion functions do croak() on
bad arguments.) It is therefore essential to check return
values from these functions. Always begin your socket <br>
programs this way for optimal success, and don&rsquo;t
forget to add the -T taint-checking flag to the
&quot;#!&quot; line for servers:</p>

<p style="margin-top: 1em">#!/usr/bin/perl -Tw <br>
use strict; <br>
use sigtrap; <br>
use Socket;</p>

<p style="margin-top: 1em">BUGS <br>
These routines all create system-specific portability
problems. As noted elsewhere, Perl is at the mercy of your C
libraries for much of its system behavior. It&rsquo;s
probably <br>
safest to assume broken SysV semantics for signals and to
stick with simple TCP and UDP socket operations; e.g.,
don&rsquo;t try to pass open file descriptors over a local
UDP datagram <br>
socket if you want your code to stand a chance of being
portable.</p>

<p style="margin-top: 1em">AUTHOR <br>
Tom Christiansen, with occasional vestiges of Larry
Wall&rsquo;s original version and suggestions from the Perl
Porters.</p>

<p style="margin-top: 1em">SEE ALSO <br>
There&rsquo;s a lot more to networking than this, but this
should get you started.</p>

<p style="margin-top: 1em">For intrepid programmers, the
indispensable textbook is Unix Network Programming, 2nd
Edition, Volume 1 by W. Richard Stevens (published by
Prentice-Hall). Most books on <br>
networking address the subject from the perspective of a C
programmer; translation to Perl is left as an exercise for
the reader.</p>

<p style="margin-top: 1em">The IO::Socket(3) manpage
describes the object library, and the Socket(3) manpage
describes the low-level interface to sockets. Besides the
obvious functions in perlfunc, you <br>
should also check out the modules file at your nearest CPAN
site, especially
&lt;http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_&gt;.
See perlmodlib or best yet, the <br>
Perl FAQ for a description of what CPAN is and where to get
it if the previous link doesn&rsquo;t work for you.</p>

<p style="margin-top: 1em">Section 5 of CPAN&rsquo;s
modules file is devoted to &quot;Networking, Device Control
(modems), and Interprocess Communication&quot;, and contains
numerous unbundled modules numerous networking <br>
modules, Chat and Expect operations, CGI programming, DCE,
FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet,
Threads, and ToolTalk--to name just a few.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLIPC(1)</p>
<hr>
</body>
</html>
