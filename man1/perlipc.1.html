<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLIPC(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLIPC(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLIPC(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlipc - Perl interprocess communication (signals, fifos, pipes, safe
  subprocesses, sockets, and semaphores)
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The basic IPC facilities of Perl are built out of the good old Unix signals,
  named pipes, pipe opens, the Berkeley socket routines, and SysV IPC calls.
  Each is used in slightly different situations.
<h1 class="Sh" title="Sh" id="Signals"><a class="selflink" href="#Signals">Signals</a></h1>
Perl uses a simple signal handling model: the %SIG hash contains names or
  references of user-installed signal handlers. These handlers will be called
  with an argument which is the name of the signal that triggered it. A signal
  may be generated intentionally from a particular keyboard sequence like
  control-C or control-Z, sent to you from another process, or triggered
  automatically by the kernel when special events transpire, like a child
  process exiting, your own process running out of stack space, or hitting a
  process file-size limit.
<div class="Pp"></div>
For example, to trap an interrupt signal, set up a handler like this:
<div class="Pp"></div>
<pre>
    our $shucks;
    sub catch_zap {
        my $signame = shift;
        $shucks++;
        die &quot;Somebody sent me a SIG$signame&quot;;
    }
    $SIG{INT} = __PACKAGE__ . &quot;::catch_zap&quot;;  
    $SIG{INT} = \&amp;catch_zap;  # best strategy
</pre>
<div class="Pp"></div>
Prior to Perl 5.7.3 it was necessary to do as little as you possibly could in
  your handler; notice how all we do is set a global variable and then raise an
  exception. That's because on most systems, libraries are not re-entrant;
  particularly, memory allocation and I/O routines are not. That meant that
  doing nearly <i>anything</i> in your handler could in theory trigger a memory
  fault and subsequent core dump - see &quot;Deferred Signals (Safe
  Signals)&quot; below.
<div class="Pp"></div>
The names of the signals are the ones listed out by &quot;kill -l&quot; on your
  system, or you can retrieve them using the CPAN module IPC::Signal.
<div class="Pp"></div>
You may also choose to assign the strings &quot;IGNORE&quot; or
  &quot;DEFAULT&quot; as the handler, in which case Perl will try to discard the
  signal or do the default thing.
<div class="Pp"></div>
On most Unix platforms, the &quot;CHLD&quot; (sometimes also known as
  &quot;CLD&quot;) signal has special behavior with respect to a value of
  &quot;IGNORE&quot;. Setting $SIG{CHLD} to &quot;IGNORE&quot; on such a
  platform has the effect of not creating zombie processes when the parent
  process fails to &quot;wait()&quot; on its child processes (i.e., child
  processes are automatically reaped). Calling &quot;wait()&quot; with
  $SIG{CHLD} set to &quot;IGNORE&quot; usually returns &quot;-1&quot; on such
  platforms.
<div class="Pp"></div>
Some signals can be neither trapped nor ignored, such as the KILL and STOP (but
  not the TSTP) signals. Note that ignoring signals makes them disappear. If you
  only want them blocked temporarily without them getting lost you'll have to
  use POSIX' sigprocmask.
<div class="Pp"></div>
Sending a signal to a negative process ID means that you send the signal to the
  entire Unix process group. This code sends a hang-up signal to all processes
  in the current process group, and also sets $SIG{HUP} to &quot;IGNORE&quot; so
  it doesn't kill itself:
<div class="Pp"></div>
<pre>
    # block scope for local
    {
        local $SIG{HUP} = &quot;IGNORE&quot;;
        kill HUP =&gt; -$$;
        # snazzy writing of: kill(&quot;HUP&quot;, -$$)
    }
</pre>
<div class="Pp"></div>
Another interesting signal to send is signal number zero. This doesn't actually
  affect a child process, but instead checks whether it's alive or has changed
  its UIDs.
<div class="Pp"></div>
<pre>
    unless (kill 0 =&gt; $kid_pid) {
        warn &quot;something wicked happened to $kid_pid&quot;;
    }
</pre>
<div class="Pp"></div>
Signal number zero may fail because you lack permission to send the signal when
  directed at a process whose real or saved UID is not identical to the real or
  effective UID of the sending process, even though the process is alive. You
  may be able to determine the cause of failure using $! or &quot;%!&quot;.
<div class="Pp"></div>
<pre>
    unless (kill(0 =&gt; $pid) || $!{EPERM}) {
        warn &quot;$pid looks dead&quot;;
    }
</pre>
<div class="Pp"></div>
You might also want to employ anonymous functions for simple signal handlers:
<div class="Pp"></div>
<pre>
    $SIG{INT} = sub { die &quot;\nOutta here!\n&quot; };
</pre>
<div class="Pp"></div>
SIGCHLD handlers require some special care. If a second child dies while in the
  signal handler caused by the first death, we won't get another signal. So must
  loop here else we will leave the unreaped child as a zombie. And the next time
  two children die we get another zombie. And so on.
<div class="Pp"></div>
<pre>
    use POSIX &quot;:sys_wait_h&quot;;
    $SIG{CHLD} = sub {
        while ((my $child = waitpid(-1, WNOHANG)) &gt; 0) {
            $Kid_Status{$child} = $?;
        }
    };
    # do something that forks...
</pre>
<div class="Pp"></div>
Be careful: <i>qx()</i>, <i>system()</i>, and some modules for calling external
  commands do a <i>fork()</i>, then <i>wait()</i> for the result. Thus, your
  signal handler will be called. Because <i>wait()</i> was already called by
  <i>system()</i> or <i>qx()</i>, the <i>wait()</i> in the signal handler will
  see no more zombies and will therefore block.
<div class="Pp"></div>
The best way to prevent this issue is to use <i>waitpid()</i>, as in the
  following example:
<div class="Pp"></div>
<pre>
    use POSIX &quot;:sys_wait_h&quot;; # for nonblocking read
    my %children;
    $SIG{CHLD} = sub {
        # don't change $! and $? outside handler
        local ($!, $?);
        my $pid = waitpid(-1, WNOHANG);
        return if $pid == -1;
        return unless defined $children{$pid};
        delete $children{$pid};
        cleanup_child($pid, $?);
    };
    while (1) {
        my $pid = fork();
        die &quot;cannot fork&quot; unless defined $pid;
        if ($pid == 0) {
            # ...
            exit 0;
        } else {
            $children{$pid}=1;
            # ...
            system($command);
            # ...
       }
    }
</pre>
<div class="Pp"></div>
Signal handling is also used for timeouts in Unix. While safely protected within
  an &quot;eval{}&quot; block, you set a signal handler to trap alarm signals
  and then schedule to have one delivered to you in some number of seconds. Then
  try your blocking operation, clearing the alarm when it's done but not before
  you've exited your &quot;eval{}&quot; block. If it goes off, you'll use
  <i>die()</i> to jump out of the block.
<div class="Pp"></div>
Here's an example:
<div class="Pp"></div>
<pre>
    my $ALARM_EXCEPTION = &quot;alarm clock restart&quot;;
    eval {
        local $SIG{ALRM} = sub { die $ALARM_EXCEPTION };
        alarm 10;
        flock(FH, 2)    # blocking write lock
                        || die &quot;cannot flock: $!&quot;;
        alarm 0;
    };
    if ($@ &amp;&amp; $@ !~ quotemeta($ALARM_EXCEPTION)) { die }
</pre>
<div class="Pp"></div>
If the operation being timed out is <i>system()</i> or <i>qx()</i>, this
  technique is liable to generate zombies. If this matters to you, you'll need
  to do your own <i>fork()</i> and <i>exec()</i>, and kill the errant child
  process.
<div class="Pp"></div>
For more complex signal handling, you might see the standard POSIX module.
  Lamentably, this is almost entirely undocumented, but the <i>t/lib/posix.t</i>
  file from the Perl source distribution has some examples in it.
<h2 class="Ss" title="Ss" id="Handling_the_SIGHUP_Signal_in_Daemons"><a class="selflink" href="#Handling_the_SIGHUP_Signal_in_Daemons">Handling
  the SIGHUP Signal in Daemons</a></h2>
A process that usually starts when the system boots and shuts down when the
  system is shut down is called a daemon (Disk And Execution MONitor). If a
  daemon process has a configuration file which is modified after the process
  has been started, there should be a way to tell that process to reread its
  configuration file without stopping the process. Many daemons provide this
  mechanism using a &quot;SIGHUP&quot; signal handler. When you want to tell the
  daemon to reread the file, simply send it the &quot;SIGHUP&quot; signal.
<div class="Pp"></div>
The following example implements a simple daemon, which restarts itself every
  time the &quot;SIGHUP&quot; signal is received. The actual code is located in
  the subroutine &quot;code()&quot;, which just prints some debugging info to
  show that it works; it should be replaced with the real code.
<div class="Pp"></div>
<pre>
  #!/usr/bin/perl -w
  use POSIX ();
  use FindBin ();
  use File::Basename ();
  use File::Spec::Functions;
  $| = 1;
  # make the daemon cross-platform, so exec always calls the script
  # itself with the right path, no matter how the script was invoked.
  my $script = File::Basename::basename($0);
  my $SELF  = catfile($FindBin::Bin, $script);
  # POSIX unmasks the sigprocmask properly
  $SIG{HUP} = sub {
      print &quot;got SIGHUP\n&quot;;
      exec($SELF, @ARGV)        || die &quot;$0: couldn't restart: $!&quot;;
  };
  code();
  sub code {
      print &quot;PID: $$\n&quot;;
      print &quot;ARGV: @ARGV\n&quot;;
      my $count = 0;
      while (++$count) {
          sleep 2;
          print &quot;$count\n&quot;;
      }
  }
</pre>
<h2 class="Ss" title="Ss" id="Deferred_Signals_(Safe_Signals)"><a class="selflink" href="#Deferred_Signals_(Safe_Signals)">Deferred
  Signals (Safe Signals)</a></h2>
Before Perl 5.7.3, installing Perl code to deal with signals exposed you to
  danger from two things. First, few system library functions are re-entrant. If
  the signal interrupts while Perl is executing one function (like
  <i>malloc</i>(3) or <i>printf</i>(3)), and your signal handler then calls the
  same function again, you could get unpredictable behavior--often, a core dump.
  Second, Perl isn't itself re-entrant at the lowest levels. If the signal
  interrupts Perl while Perl is changing its own internal data structures,
  similarly unpredictable behavior may result.
<div class="Pp"></div>
There were two things you could do, knowing this: be paranoid or be pragmatic.
  The paranoid approach was to do as little as possible in your signal handler.
  Set an existing integer variable that already has a value, and return. This
  doesn't help you if you're in a slow system call, which will just restart.
  That means you have to &quot;die&quot; to <i>longjmp</i>(3) out of the
  handler. Even this is a little cavalier for the true paranoiac, who avoids
  &quot;die&quot; in a handler because the system <i>is</i> out to get you. The
  pragmatic approach was to say &quot;I know the risks, but prefer the
  convenience&quot;, and to do anything you wanted in your signal handler, and
  be prepared to clean up core dumps now and again.
<div class="Pp"></div>
Perl 5.7.3 and later avoid these problems by &quot;deferring&quot; signals. That
  is, when the signal is delivered to the process by the system (to the C code
  that implements Perl) a flag is set, and the handler returns immediately. Then
  at strategic &quot;safe&quot; points in the Perl interpreter (e.g. when it is
  about to execute a new opcode) the flags are checked and the Perl level
  handler from %SIG is executed. The &quot;deferred&quot; scheme allows much
  more flexibility in the coding of signal handlers as we know the Perl
  interpreter is in a safe state, and that we are not in a system library
  function when the handler is called. However the implementation does differ
  from previous Perls in the following ways:
<dl class="Bl-tag">
  <dt class="It-tag">Long-running opcodes</dt>
  <dd class="It-tag">As the Perl interpreter looks at signal flags only when it
      is about to execute a new opcode, a signal that arrives during a
      long-running opcode (e.g. a regular expression operation on a very large
      string) will not be seen until the current opcode completes.
    <div style="height: 1.00em;">&#x00A0;</div>
    If a signal of any given type fires multiple times during an opcode (such as
      from a fine-grained timer), the handler for that signal will be called
      only once, after the opcode completes; all other instances will be
      discarded. Furthermore, if your system's signal queue gets flooded to the
      point that there are signals that have been raised but not yet caught (and
      thus not deferred) at the time an opcode completes, those signals may well
      be caught and deferred during subsequent opcodes, with sometimes
      surprising results. For example, you may see alarms delivered even after
      calling alarm(0) as the latter stops the raising of alarms but does not
      cancel the delivery of alarms raised but not yet caught. Do not depend on
      the behaviors described in this paragraph as they are side effects of the
      current implementation and may change in future versions of Perl.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Interrupting IO</dt>
  <dd class="It-tag">When a signal is delivered (e.g., SIGINT from a control-C)
      the operating system breaks into IO operations like <i>read</i>(2), which
      is used to implement Perl's <i>readline()</i> function, the
      &quot;&lt;&gt;&quot; operator. On older Perls the handler was called
      immediately (and as &quot;read&quot; is not &quot;unsafe&quot;, this
      worked well). With the &quot;deferred&quot; scheme the handler is
      <i>not</i> called immediately, and if Perl is using the system's
      &quot;stdio&quot; library that library may restart the &quot;read&quot;
      without returning to Perl to give it a chance to call the %SIG handler. If
      this happens on your system the solution is to use the &quot;:perlio&quot;
      layer to do IO--at least on those handles that you want to be able to
      break into with signals. (The &quot;:perlio&quot; layer checks the signal
      flags and calls %SIG handlers before resuming IO operation.)
    <div style="height: 1.00em;">&#x00A0;</div>
    The default in Perl 5.7.3 and later is to automatically use the
      &quot;:perlio&quot; layer.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that it is not advisable to access a file handle within a signal
      handler where that signal has interrupted an I/O operation on that same
      handle. While perl will at least try hard not to crash, there are no
      guarantees of data integrity; for example, some data might get dropped or
      written twice.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some networking library functions like <i>gethostbyname()</i> are known to
      have their own implementations of timeouts which may conflict with your
      timeouts. If you have problems with such functions, try using the POSIX
      <i>sigaction()</i> function, which bypasses Perl safe signals. Be warned
      that this does subject you to possible memory corruption, as described
      above.
    <div style="height: 1.00em;">&#x00A0;</div>
    Instead of setting $SIG{ALRM}:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
   local $SIG{ALRM} = sub { die &quot;alarm&quot; };
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    try something like the following:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  use POSIX qw(SIGALRM);
  POSIX::sigaction(SIGALRM, POSIX::SigAction-&gt;new(sub { die &quot;alarm&quot; }))
          || die &quot;Error setting SIGALRM handler: $!\n&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Another way to disable the safe signal behavior locally is to use the
      &quot;Perl::Unsafe::Signals&quot; module from CPAN, which affects all
      signals.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Restartable system calls</dt>
  <dd class="It-tag">On systems that supported it, older versions of Perl used
      the SA_RESTART flag when installing %SIG handlers. This meant that
      restartable system calls would continue rather than returning when a
      signal arrived. In order to deliver deferred signals promptly, Perl 5.7.3
      and later do <i>not</i> use SA_RESTART. Consequently, restartable system
      calls can fail (with $! set to &quot;EINTR&quot;) in places where they
      previously would have succeeded.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default &quot;:perlio&quot; layer retries &quot;read&quot;,
      &quot;write&quot; and &quot;close&quot; as described above; interrupted
      &quot;wait&quot; and &quot;waitpid&quot; calls will always be
    retried.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Signals as &quot;faults&quot;</dt>
  <dd class="It-tag">Certain signals like SEGV, ILL, and BUS are generated by
      virtual memory addressing errors and similar &quot;faults&quot;. These are
      normally fatal: there is little a Perl-level handler can do with them. So
      Perl delivers them immediately rather than attempting to defer them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Signals triggered by operating system state</dt>
  <dd class="It-tag">On some operating systems certain signal handlers are
      supposed to &quot;do something&quot; before returning. One example can be
      CHLD or CLD, which indicates a child process has completed. On some
      operating systems the signal handler is expected to &quot;wait&quot; for
      the completed child process. On such systems the deferred signal scheme
      will not work for those signals: it does not do the &quot;wait&quot;.
      Again the failure will look like a loop as the operating system will
      reissue the signal because there are completed child processes that have
      not yet been &quot;wait&quot;ed for.</dd>
</dl>
<div class="Pp"></div>
If you want the old signal behavior back despite possible memory corruption, set
  the environment variable &quot;PERL_SIGNALS&quot; to &quot;unsafe&quot;. This
  feature first appeared in Perl 5.8.1.
<h1 class="Sh" title="Sh" id="Named_Pipes"><a class="selflink" href="#Named_Pipes">Named
  Pipes</a></h1>
A named pipe (often referred to as a FIFO) is an old Unix IPC mechanism for
  processes communicating on the same machine. It works just like regular
  anonymous pipes, except that the processes rendezvous using a filename and
  need not be related.
<div class="Pp"></div>
To create a named pipe, use the &quot;POSIX::mkfifo()&quot; function.
<div class="Pp"></div>
<pre>
    use POSIX qw(mkfifo);
    mkfifo($path, 0700)     ||  die &quot;mkfifo $path failed: $!&quot;;
</pre>
<div class="Pp"></div>
You can also use the Unix command <i>mknod</i>(1), or on some systems,
  <i>mkfifo</i>(1). These may not be in your normal path, though.
<div class="Pp"></div>
<pre>
    # system return val is backwards, so &amp;&amp; not ||
    #
    $ENV{PATH} .= &quot;:/etc:/usr/etc&quot;;
    if  (      system(&quot;mknod&quot;,  $path, &quot;p&quot;)
            &amp;&amp; system(&quot;mkfifo&quot;, $path) )
    {
        die &quot;mk{nod,fifo} $path failed&quot;;
    }
</pre>
<div class="Pp"></div>
A fifo is convenient when you want to connect a process to an unrelated one.
  When you open a fifo, the program will block until there's something on the
  other end.
<div class="Pp"></div>
For example, let's say you'd like to have your <i>.signature</i> file be a named
  pipe that has a Perl program on the other end. Now every time any program
  (like a mailer, news reader, finger program, etc.) tries to read from that
  file, the reading program will read the new signature from your program. We'll
  use the pipe-checking file-test operator, <b>-p</b>, to find out whether
  anyone (or anything) has accidentally removed our fifo.
<div class="Pp"></div>
<pre>
    chdir();    # go home
    my $FIFO = &quot;.signature&quot;;
    while (1) {
        unless (-p $FIFO) {
            unlink $FIFO;   # discard any failure, will catch later
            require POSIX;  # delayed loading of heavy module
            POSIX::mkfifo($FIFO, 0700)
                                || die &quot;can't mkfifo $FIFO: $!&quot;;
        }
        # next line blocks till there's a reader
        open (FIFO, &quot;&gt; $FIFO&quot;)  || die &quot;can't open $FIFO: $!&quot;;
        print FIFO &quot;John Smith (smith\@host.org)\n&quot;, `fortune -s`;
        close(FIFO)             || die &quot;can't close $FIFO: $!&quot;;
        sleep 2;                # to avoid dup signals
    }
</pre>
<h1 class="Sh" title="Sh" id="Using_open()_for_IPC"><a class="selflink" href="#Using_open()_for_IPC">Using
  <i>open()</i> for IPC</a></h1>
Perl's basic <i>open()</i> statement can also be used for unidirectional
  interprocess communication by either appending or prepending a pipe symbol to
  the second argument to <i>open()</i>. Here's how to start something up in a
  child process you intend to write to:
<div class="Pp"></div>
<pre>
    open(SPOOLER, &quot;| cat -v | lpr -h 2&gt;/dev/null&quot;)
                        || die &quot;can't fork: $!&quot;;
    local $SIG{PIPE} = sub { die &quot;spooler pipe broke&quot; };
    print SPOOLER &quot;stuff\n&quot;;
    close SPOOLER       || die &quot;bad spool: $! $?&quot;;
</pre>
<div class="Pp"></div>
And here's how to start up a child process you intend to read from:
<div class="Pp"></div>
<pre>
    open(STATUS, &quot;netstat -an 2&gt;&amp;1 |&quot;)
                        || die &quot;can't fork: $!&quot;;
    while (&lt;STATUS&gt;) {
        next if /^(tcp|udp)/;
        print;
    }
    close STATUS        || die &quot;bad netstat: $! $?&quot;;
</pre>
<div class="Pp"></div>
If one can be sure that a particular program is a Perl script expecting
  filenames in @ARGV, the clever programmer can write something like this:
<div class="Pp"></div>
<pre>
    % program f1 &quot;cmd1|&quot; - f2 &quot;cmd2|&quot; f3 &lt; tmpfile
</pre>
<div class="Pp"></div>
and no matter which sort of shell it's called from, the Perl program will read
  from the file <i>f1</i>, the process <i>cmd1</i>, standard input
  (<i>tmpfile</i> in this case), the <i>f2</i> file, the <i>cmd2</i> command,
  and finally the <i>f3</i> file. Pretty nifty, eh?
<div class="Pp"></div>
You might notice that you could use backticks for much the same effect as
  opening a pipe for reading:
<div class="Pp"></div>
<pre>
    print grep { !/^(tcp|udp)/ } `netstat -an 2&gt;&amp;1`;
    die &quot;bad netstatus ($?)&quot; if $?;
</pre>
<div class="Pp"></div>
While this is true on the surface, it's much more efficient to process the file
  one line or record at a time because then you don't have to read the whole
  thing into memory at once. It also gives you finer control of the whole
  process, letting you kill off the child process early if you'd like.
<div class="Pp"></div>
Be careful to check the return values from both <i>open()</i> and
  <i>close()</i>. If you're <i>writing</i> to a pipe, you should also trap
  SIGPIPE. Otherwise, think of what happens when you start up a pipe to a
  command that doesn't exist: the <i>open()</i> will in all likelihood succeed
  (it only reflects the <i>fork()</i>'s success), but then your output will
  fail--spectacularly. Perl can't know whether the command worked, because your
  command is actually running in a separate process whose <i>exec()</i> might
  have failed. Therefore, while readers of bogus commands return just a quick
  EOF, writers to bogus commands will get hit with a signal, which they'd best
  be prepared to handle. Consider:
<div class="Pp"></div>
<pre>
    open(FH, &quot;|bogus&quot;)      || die &quot;can't fork: $!&quot;;
    print FH &quot;bang\n&quot;;      #  neither necessary nor sufficient 
                            #  to check print retval!
    close(FH)               || die &quot;can't close: $!&quot;;
</pre>
<div class="Pp"></div>
The reason for not checking the return value from <i>print()</i> is because of
  pipe buffering; physical writes are delayed. That won't blow up until the
  close, and it will blow up with a SIGPIPE. To catch it, you could use this:
<div class="Pp"></div>
<pre>
    $SIG{PIPE} = &quot;IGNORE&quot;;
    open(FH, &quot;|bogus&quot;)  || die &quot;can't fork: $!&quot;;
    print FH &quot;bang\n&quot;;
    close(FH)           || die &quot;can't close: status=$?&quot;;
</pre>
<h2 class="Ss" title="Ss" id="Filehandles"><a class="selflink" href="#Filehandles">Filehandles</a></h2>
Both the main process and any child processes it forks share the same STDIN,
  STDOUT, and STDERR filehandles. If both processes try to access them at once,
  strange things can happen. You may also want to close or reopen the
  filehandles for the child. You can get around this by opening your pipe with
  <i>open()</i>, but on some systems this means that the child process cannot
  outlive the parent.
<h2 class="Ss" title="Ss" id="Background_Processes"><a class="selflink" href="#Background_Processes">Background
  Processes</a></h2>
You can run a command in the background with:
<div class="Pp"></div>
<pre>
    system(&quot;cmd &amp;&quot;);
</pre>
<div class="Pp"></div>
The command's STDOUT and STDERR (and possibly STDIN, depending on your shell)
  will be the same as the parent's. You won't need to catch SIGCHLD because of
  the double-fork taking place; see below for details.
<h2 class="Ss" title="Ss" id="Complete_Dissociation_of_Child_from_Parent"><a class="selflink" href="#Complete_Dissociation_of_Child_from_Parent">Complete
  Dissociation of Child from Parent</a></h2>
In some cases (starting server processes, for instance) you'll want to
  completely dissociate the child process from the parent. This is often called
  daemonization. A well-behaved daemon will also <i>chdir()</i> to the root
  directory so it doesn't prevent unmounting the filesystem containing the
  directory from which it was launched, and redirect its standard file
  descriptors from and to <i>/dev/null</i> so that random output doesn't wind up
  on the user's terminal.
<div class="Pp"></div>
<pre>
    use POSIX &quot;setsid&quot;;
    sub daemonize {
        chdir(&quot;/&quot;)                      || die &quot;can't chdir to /: $!&quot;;
        open(STDIN,  &quot;&lt; /dev/null&quot;)     || die &quot;can't read /dev/null: $!&quot;;
        open(STDOUT, &quot;&gt; /dev/null&quot;)     || die &quot;can't write to /dev/null: $!&quot;;
        defined(my $pid = fork())       || die &quot;can't fork: $!&quot;;
        exit if $pid;                   # non-zero now means I am the parent
        (setsid() != -1)                || die &quot;Can't start a new session: $!&quot; 
        open(STDERR, &quot;&gt;&amp;STDOUT&quot;)        || die &quot;can't dup stdout: $!&quot;;
    }
</pre>
<div class="Pp"></div>
The <i>fork()</i> has to come before the <i>setsid()</i> to ensure you aren't a
  process group leader; the <i>setsid()</i> will fail if you are. If your system
  doesn't have the <i>setsid()</i> function, open <i>/dev/tty</i> and use the
  &quot;TIOCNOTTY&quot; <i>ioctl()</i> on it instead. See <i>tty</i>(4) for
  details.
<div class="Pp"></div>
Non-Unix users should check their &quot; <i>Your_OS</i>::Process&quot; module
  for other possible solutions.
<h2 class="Ss" title="Ss" id="Safe_Pipe_Opens"><a class="selflink" href="#Safe_Pipe_Opens">Safe
  Pipe Opens</a></h2>
Another interesting approach to IPC is making your single program go
  multiprocess and communicate between--or even amongst--yourselves. The
  <i>open()</i> function will accept a file argument of either &quot;-|&quot; or
  &quot;|-&quot; to do a very interesting thing: it forks a child connected to
  the filehandle you've opened. The child is running the same program as the
  parent. This is useful for safely opening a file when running under an assumed
  UID or GID, for example. If you open a pipe <i>to</i> minus, you can write to
  the filehandle you opened and your kid will find it in <i>his</i> STDIN. If
  you open a pipe <i>from</i> minus, you can read from the filehandle you opened
  whatever your kid writes to <i>his</i> STDOUT.
<div class="Pp"></div>
<pre>
    use English qw[ -no_match_vars ];
    my $PRECIOUS = &quot;/path/to/some/safe/file&quot;;
    my $sleep_count;
    my $pid;
    do {
        $pid = open(KID_TO_WRITE, &quot;|-&quot;);
        unless (defined $pid) {
            warn &quot;cannot fork: $!&quot;;
            die &quot;bailing out&quot; if $sleep_count++ &gt; 6;
            sleep 10;
        }
    } until defined $pid;
    if ($pid) {                 # I am the parent 
        print KID_TO_WRITE @some_data;
        close(KID_TO_WRITE)     || warn &quot;kid exited $?&quot;;
    } else {                    # I am the child
        # drop permissions in setuid and/or setgid programs:
        ($EUID, $EGID) = ($UID, $GID);  
        open (OUTFILE, &quot;&gt; $PRECIOUS&quot;) 
                                || die &quot;can't open $PRECIOUS: $!&quot;;
        while (&lt;STDIN&gt;) {
            print OUTFILE;      # child's STDIN is parent's KID_TO_WRITE
        }
        close(OUTFILE)          || die &quot;can't close $PRECIOUS: $!&quot;;
        exit(0);                # don't forget this!!
    }
</pre>
<div class="Pp"></div>
Another common use for this construct is when you need to execute something
  without the shell's interference. With <i>system()</i>, it's straightforward,
  but you can't use a pipe open or backticks safely. That's because there's no
  way to stop the shell from getting its hands on your arguments. Instead, use
  lower-level control to call <i>exec()</i> directly.
<div class="Pp"></div>
Here's a safe backtick or pipe open for read:
<div class="Pp"></div>
<pre>
    my $pid = open(KID_TO_READ, &quot;-|&quot;);
    defined($pid)           || die &quot;can't fork: $!&quot;;
    if ($pid) {             # parent
        while (&lt;KID_TO_READ&gt;) {
                            # do something interesting
        }
        close(KID_TO_READ)  || warn &quot;kid exited $?&quot;;
    } else {                # child
        ($EUID, $EGID) = ($UID, $GID); # suid only
        exec($program, @options, @args)
                            || die &quot;can't exec program: $!&quot;;
        # NOTREACHED
    }
</pre>
<div class="Pp"></div>
And here's a safe pipe open for writing:
<div class="Pp"></div>
<pre>
    my $pid = open(KID_TO_WRITE, &quot;|-&quot;);
    defined($pid)           || die &quot;can't fork: $!&quot;;
    $SIG{PIPE} = sub { die &quot;whoops, $program pipe broke&quot; };
    if ($pid) {             # parent
        print KID_TO_WRITE @data;
        close(KID_TO_WRITE) || warn &quot;kid exited $?&quot;;
    } else {                # child
        ($EUID, $EGID) = ($UID, $GID);
        exec($program, @options, @args)
                            || die &quot;can't exec program: $!&quot;;
        # NOTREACHED
    }
</pre>
<div class="Pp"></div>
It is very easy to dead-lock a process using this form of <i>open()</i>, or
  indeed with any use of <i>pipe()</i> with multiple subprocesses. The example
  above is &quot;safe&quot; because it is simple and calls <i>exec()</i>. See
  &quot;Avoiding Pipe Deadlocks&quot; for general safety principles, but there
  are extra gotchas with Safe Pipe Opens.
<div class="Pp"></div>
In particular, if you opened the pipe using &quot;open FH, &quot;|-&quot;&quot;,
  then you cannot simply use <i>close()</i> in the parent process to close an
  unwanted writer. Consider this code:
<div class="Pp"></div>
<pre>
    my $pid = open(WRITER, &quot;|-&quot;);        # fork open a kid
    defined($pid)               || die &quot;first fork failed: $!&quot;;
    if ($pid) {
        if (my $sub_pid = fork()) {
            defined($sub_pid)   || die &quot;second fork failed: $!&quot;;
            close(WRITER)       || die &quot;couldn't close WRITER: $!&quot;;
            # now do something else...
        }
        else {
            # first write to WRITER
            # ...
            # then when finished
            close(WRITER)       || die &quot;couldn't close WRITER: $!&quot;;
            exit(0);
        }
    }
    else {
        # first do something with STDIN, then
        exit(0);
    }
</pre>
<div class="Pp"></div>
In the example above, the true parent does not want to write to the WRITER
  filehandle, so it closes it. However, because WRITER was opened using
  &quot;open FH, &quot;|-&quot;&quot;, it has a special behavior: closing it
  calls <i>waitpid()</i> (see &quot;waitpid&quot; in perlfunc), which waits for
  the subprocess to exit. If the child process ends up waiting for something
  happening in the section marked &quot;do something else&quot;, you have
  deadlock.
<div class="Pp"></div>
This can also be a problem with intermediate subprocesses in more complicated
  code, which will call <i>waitpid()</i> on all open filehandles during global
  destruction--in no predictable order.
<div class="Pp"></div>
To solve this, you must manually use <i>pipe()</i>, <i>fork()</i>, and the form
  of <i>open()</i> which sets one file descriptor to another, as shown below:
<div class="Pp"></div>
<pre>
    pipe(READER, WRITER)        || die &quot;pipe failed: $!&quot;;
    $pid = fork();
    defined($pid)               || die &quot;first fork failed: $!&quot;;
    if ($pid) {
        close READER;
        if (my $sub_pid = fork()) {
            defined($sub_pid)   || die &quot;first fork failed: $!&quot;;
            close(WRITER)       || die &quot;can't close WRITER: $!&quot;;
        }
        else {
            # write to WRITER...
            # ...
            # then  when finished
            close(WRITER)       || die &quot;can't close WRITER: $!&quot;;
            exit(0);
        }
        # write to WRITER...
    }
    else {
        open(STDIN, &quot;&lt;&amp;READER&quot;) || die &quot;can't reopen STDIN: $!&quot;;
        close(WRITER)           || die &quot;can't close WRITER: $!&quot;;
        # do something...
        exit(0);
    }
</pre>
<div class="Pp"></div>
Since Perl 5.8.0, you can also use the list form of &quot;open&quot; for pipes.
  This is preferred when you wish to avoid having the shell interpret
  metacharacters that may be in your command string.
<div class="Pp"></div>
So for example, instead of using:
<div class="Pp"></div>
<pre>
    open(PS_PIPE, &quot;ps aux|&quot;)    || die &quot;can't open ps pipe: $!&quot;;
</pre>
<div class="Pp"></div>
One would use either of these:
<div class="Pp"></div>
<pre>
    open(PS_PIPE, &quot;-|&quot;, &quot;ps&quot;, &quot;aux&quot;) 
                                || die &quot;can't open ps pipe: $!&quot;;
    @ps_args = qw[ ps aux ];
    open(PS_PIPE, &quot;-|&quot;, @ps_args)
                                || die &quot;can't open @ps_args|: $!&quot;;
</pre>
<div class="Pp"></div>
Because there are more than three arguments to <i>open()</i>, forks the
  <i>ps</i>(1) command <i>without</i> spawning a shell, and reads its standard
  output via the &quot;PS_PIPE&quot; filehandle. The corresponding syntax to
  <i>write</i> to command pipes is to use &quot;|-&quot; in place of
  &quot;-|&quot;.
<div class="Pp"></div>
This was admittedly a rather silly example, because you're using string literals
  whose content is perfectly safe. There is therefore no cause to resort to the
  harder-to-read, multi-argument form of pipe <i>open()</i>. However, whenever
  you cannot be assured that the program arguments are free of shell
  metacharacters, the fancier form of <i>open()</i> should be used. For example:
<div class="Pp"></div>
<pre>
    @grep_args = (&quot;egrep&quot;, &quot;-i&quot;, $some_pattern, @many_files);
    open(GREP_PIPE, &quot;-|&quot;, @grep_args)
                        || die &quot;can't open @grep_args|: $!&quot;;
</pre>
<div class="Pp"></div>
Here the multi-argument form of pipe <i>open()</i> is preferred because the
  pattern and indeed even the filenames themselves might hold metacharacters.
<div class="Pp"></div>
Be aware that these operations are full Unix forks, which means they may not be
  correctly implemented on all alien systems. Additionally, these are not true
  multithreading. To learn more about threading, see the <i>modules</i> file
  mentioned below in the SEE ALSO section.
<h2 class="Ss" title="Ss" id="Avoiding_Pipe_Deadlocks"><a class="selflink" href="#Avoiding_Pipe_Deadlocks">Avoiding
  Pipe Deadlocks</a></h2>
Whenever you have more than one subprocess, you must be careful that each closes
  whichever half of any pipes created for interprocess communication it is not
  using. This is because any child process reading from the pipe and expecting
  an EOF will never receive it, and therefore never exit. A single process
  closing a pipe is not enough to close it; the last process with the pipe open
  must close it for it to read EOF.
<div class="Pp"></div>
Certain built-in Unix features help prevent this most of the time. For instance,
  filehandles have a &quot;close on exec&quot; flag, which is set <i>en
  masse</i> under control of the $^F variable. This is so any filehandles you
  didn't explicitly route to the STDIN, STDOUT or STDERR of a child
  <i>program</i> will be automatically closed.
<div class="Pp"></div>
Always explicitly and immediately call <i>close()</i> on the writable end of any
  pipe, unless that process is actually writing to it. Even if you don't
  explicitly call <i>close()</i>, Perl will still <i>close()</i> all filehandles
  during global destruction. As previously discussed, if those filehandles have
  been opened with Safe Pipe Open, this will result in calling <i>waitpid()</i>,
  which may again deadlock.
<h2 class="Ss" title="Ss" id="Bidirectional_Communication_with_Another_Process"><a class="selflink" href="#Bidirectional_Communication_with_Another_Process">Bidirectional
  Communication with Another Process</a></h2>
While this works reasonably well for unidirectional communication, what about
  bidirectional communication? The most obvious approach doesn't work:
<div class="Pp"></div>
<pre>
    # THIS DOES NOT WORK!!
    open(PROG_FOR_READING_AND_WRITING, &quot;| some program |&quot;)
</pre>
<div class="Pp"></div>
If you forget to &quot;use warnings&quot;, you'll miss out entirely on the
  helpful diagnostic message:
<div class="Pp"></div>
<pre>
    Can't do bidirectional pipe at -e line 1.
</pre>
<div class="Pp"></div>
If you really want to, you can use the standard <i>open2()</i> from the
  &quot;IPC::Open2&quot; module to catch both ends. There's also an
  <i>open3()</i> in &quot;IPC::Open3&quot; for tridirectional I/O so you can
  also catch your child's STDERR, but doing so would then require an awkward
  <i>select()</i> loop and wouldn't allow you to use normal Perl input
  operations.
<div class="Pp"></div>
If you look at its source, you'll see that <i>open2()</i> uses low-level
  primitives like the <i>pipe()</i> and <i>exec()</i> syscalls to create all the
  connections. Although it might have been more efficient by using
  <i>socketpair()</i>, this would have been even less portable than it already
  is. The <i>open2()</i> and <i>open3()</i> functions are unlikely to work
  anywhere except on a Unix system, or at least one purporting POSIX compliance.
<div class="Pp"></div>
Here's an example of using <i>open2()</i>:
<div class="Pp"></div>
<pre>
    use FileHandle;
    use IPC::Open2;
    $pid = open2(*Reader, *Writer, &quot;cat -un&quot;);
    print Writer &quot;stuff\n&quot;;
    $got = &lt;Reader&gt;;
</pre>
<div class="Pp"></div>
The problem with this is that buffering is really going to ruin your day. Even
  though your &quot;Writer&quot; filehandle is auto-flushed so the process on
  the other end gets your data in a timely manner, you can't usually do anything
  to force that process to give its data to you in a similarly quick fashion. In
  this special case, we could actually so, because we gave <i>cat</i> a
  <b>-u</b> flag to make it unbuffered. But very few commands are designed to
  operate over pipes, so this seldom works unless you yourself wrote the program
  on the other end of the double-ended pipe.
<div class="Pp"></div>
A solution to this is to use a library which uses pseudottys to make your
  program behave more reasonably. This way you don't have to have control over
  the source code of the program you're using. The &quot;Expect&quot; module
  from CPAN also addresses this kind of thing. This module requires two other
  modules from CPAN, &quot;IO::Pty&quot; and &quot;IO::Stty&quot;. It sets up a
  pseudo terminal to interact with programs that insist on talking to the
  terminal device driver. If your system is supported, this may be your best
  bet.
<h2 class="Ss" title="Ss" id="Bidirectional_Communication_with_Yourself"><a class="selflink" href="#Bidirectional_Communication_with_Yourself">Bidirectional
  Communication with Yourself</a></h2>
If you want, you may make low-level <i>pipe()</i> and <i>fork()</i> syscalls to
  stitch this together by hand. This example only talks to itself, but you could
  reopen the appropriate handles to STDIN and STDOUT and call other processes.
  (The following example lacks proper error checking.)
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    # pipe1 - bidirectional communication using two pipe pairs
    #         designed for the socketpair-challenged
    use IO::Handle;               # thousands of lines just for autoflush :-(
    pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
    pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
    CHILD_WTR-&gt;autoflush(1);
    PARENT_WTR-&gt;autoflush(1);
    if ($pid = fork()) {
        close PARENT_RDR; 
        close PARENT_WTR;
        print CHILD_WTR &quot;Parent Pid $$ is sending this\n&quot;;
        chomp($line = &lt;CHILD_RDR&gt;);
        print &quot;Parent Pid $$ just read this: '$line'\n&quot;;
        close CHILD_RDR; close CHILD_WTR;
        waitpid($pid, 0);
    } else {
        die &quot;cannot fork: $!&quot; unless defined $pid;
        close CHILD_RDR; 
        close CHILD_WTR;
        chomp($line = &lt;PARENT_RDR&gt;);
        print &quot;Child Pid $$ just read this: '$line'\n&quot;;
        print PARENT_WTR &quot;Child Pid $$ is sending this\n&quot;;
        close PARENT_RDR; 
        close PARENT_WTR;
        exit(0);
    }
</pre>
<div class="Pp"></div>
But you don't actually have to make two pipe calls. If you have the
  <i>socketpair()</i> system call, it will do this all for you.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    # pipe2 - bidirectional communication using socketpair
    #   &quot;the best ones always go both ways&quot;
    use Socket;
    use IO::Handle;  # thousands of lines just for autoflush :-(
    # We say AF_UNIX because although *_LOCAL is the
    # POSIX 1003.1g form of the constant, many machines
    # still don't have it.
    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
                                ||  die &quot;socketpair: $!&quot;;
    CHILD-&gt;autoflush(1);
    PARENT-&gt;autoflush(1);
    if ($pid = fork()) {
        close PARENT;
        print CHILD &quot;Parent Pid $$ is sending this\n&quot;;
        chomp($line = &lt;CHILD&gt;);
        print &quot;Parent Pid $$ just read this: '$line'\n&quot;;
        close CHILD;
        waitpid($pid, 0);
    } else {
        die &quot;cannot fork: $!&quot; unless defined $pid;
        close CHILD;
        chomp($line = &lt;PARENT&gt;);
        print &quot;Child Pid $$ just read this: '$line'\n&quot;;
        print PARENT &quot;Child Pid $$ is sending this\n&quot;;
        close PARENT;
        exit(0);
    }
</pre>
<h1 class="Sh" title="Sh" id="Sockets:_Client/Server_Communication"><a class="selflink" href="#Sockets:_Client/Server_Communication">Sockets:
  Client/Server Communication</a></h1>
While not entirely limited to Unix-derived operating systems (e.g., WinSock on
  PCs provides socket support, as do some VMS libraries), you might not have
  sockets on your system, in which case this section probably isn't going to do
  you much good. With sockets, you can do both virtual circuits like TCP streams
  and datagrams like UDP packets. You may be able to do even more depending on
  your system.
<div class="Pp"></div>
The Perl functions for dealing with sockets have the same names as the
  corresponding system calls in C, but their arguments tend to differ for two
  reasons. First, Perl filehandles work differently than C file descriptors.
  Second, Perl already knows the length of its strings, so you don't need to
  pass that information.
<div class="Pp"></div>
One of the major problems with ancient, antemillennial socket code in Perl was
  that it used hard-coded values for some of the constants, which severely hurt
  portability. If you ever see code that does anything like explicitly setting
  &quot;$AF_INET = 2&quot;, you know you're in for big trouble. An immeasurably
  superior approach is to use the &quot;Socket&quot; module, which more reliably
  grants access to the various constants and functions you'll need.
<div class="Pp"></div>
If you're not writing a server/client for an existing protocol like NNTP or
  SMTP, you should give some thought to how your server will know when the
  client has finished talking, and vice-versa. Most protocols are based on
  one-line messages and responses (so one party knows the other has finished
  when a &quot;\n&quot; is received) or multi-line messages and responses that
  end with a period on an empty line (&quot;\n.\n&quot; terminates a
  message/response).
<h2 class="Ss" title="Ss" id="Internet_Line_Terminators"><a class="selflink" href="#Internet_Line_Terminators">Internet
  Line Terminators</a></h2>
The Internet line terminator is &quot;\015\012&quot;. Under ASCII variants of
  Unix, that could usually be written as &quot;\r\n&quot;, but under other
  systems, &quot;\r\n&quot; might at times be &quot;\015\015\012&quot;,
  &quot;\012\012\015&quot;, or something completely different. The standards
  specify writing &quot;\015\012&quot; to be conformant (be strict in what you
  provide), but they also recommend accepting a lone &quot;\012&quot; on input
  (be lenient in what you require). We haven't always been very good about that
  in the code in this manpage, but unless you're on a Mac from way back in its
  pre-Unix dark ages, you'll probably be ok.
<h2 class="Ss" title="Ss" id="Internet_TCP_Clients_and_Servers"><a class="selflink" href="#Internet_TCP_Clients_and_Servers">Internet
  TCP Clients and Servers</a></h2>
Use Internet-domain sockets when you want to do client-server communication that
  might extend to machines outside of your own system.
<div class="Pp"></div>
Here's a sample TCP client using Internet-domain sockets:
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    use strict;
    use Socket;
    my ($remote, $port, $iaddr, $paddr, $proto, $line);
    $remote  = shift || &quot;localhost&quot;;
    $port    = shift || 2345;  # random port
    if ($port =~ /\D/) { $port = getservbyname($port, &quot;tcp&quot;) }
    die &quot;No port&quot; unless $port;
    $iaddr   = inet_aton($remote)       || die &quot;no host: $remote&quot;;
    $paddr   = sockaddr_in($port, $iaddr);
    $proto   = getprotobyname(&quot;tcp&quot;);
    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die &quot;socket: $!&quot;;
    connect(SOCK, $paddr)               || die &quot;connect: $!&quot;;
    while ($line = &lt;SOCK&gt;) {
        print $line;
    }
    close (SOCK)                        || die &quot;close: $!&quot;;
    exit(0);
</pre>
<div class="Pp"></div>
And here's a corresponding server to go along with it. We'll leave the address
  as &quot;INADDR_ANY&quot; so that the kernel can choose the appropriate
  interface on multihomed hosts. If you want sit on a particular interface (like
  the external side of a gateway or firewall machine), fill this in with your
  real address instead.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; }
    use Socket;
    use Carp;
    my $EOL = &quot;\015\012&quot;;
    sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar localtime(), &quot;\n&quot; }
    my $port  = shift || 2345;
    die &quot;invalid port&quot; unless if $port =~ /^ \d+ $/x;
    my $proto = getprotobyname(&quot;tcp&quot;);
    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die &quot;socket: $!&quot;;
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack(&quot;l&quot;, 1))    
                                                    || die &quot;setsockopt: $!&quot;;
    bind(Server, sockaddr_in($port, INADDR_ANY))    || die &quot;bind: $!&quot;;
    listen(Server, SOMAXCONN)                       || die &quot;listen: $!&quot;;
    logmsg &quot;server started on port $port&quot;;
    my $paddr;
    $SIG{CHLD} = \&amp;REAPER;
    for ( ; $paddr = accept(Client, Server); close Client) {
        my($port, $iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr, AF_INET);
        logmsg &quot;connection from $name [&quot;,
                inet_ntoa($iaddr), &quot;]
                at port $port&quot;;
        print Client &quot;Hello there, $name, it's now &quot;,
                        scalar localtime(), $EOL;
    }
</pre>
<div class="Pp"></div>
And here's a multithreaded version. It's multithreaded in that like most typical
  servers, it spawns ( <i>fork()</i>s) a slave server to handle the client
  request so that the master server can quickly go back to service a new client.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; }
    use Socket;
    use Carp;
    my $EOL = &quot;\015\012&quot;;
    sub spawn;  # forward declaration
    sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar localtime(), &quot;\n&quot; }
    my $port  = shift || 2345;
    die &quot;invalid port&quot; unless if $port =~ /^ \d+ $/x;
    my $proto = getprotobyname(&quot;tcp&quot;);
    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die &quot;socket: $!&quot;;
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack(&quot;l&quot;, 1))         
                                                    || die &quot;setsockopt: $!&quot;;
    bind(Server, sockaddr_in($port, INADDR_ANY))    || die &quot;bind: $!&quot;;
    listen(Server, SOMAXCONN)                       || die &quot;listen: $!&quot;;
    logmsg &quot;server started on port $port&quot;;
    my $waitedpid = 0;
    my $paddr;
    use POSIX &quot;:sys_wait_h&quot;;
    use Errno;
    sub REAPER {
        local $!;   # don't let waitpid() overwrite current error
        while ((my $pid = waitpid(-1, WNOHANG)) &gt; 0 &amp;&amp; WIFEXITED($?)) {
            logmsg &quot;reaped $waitedpid&quot; . ($? ? &quot; with exit $?&quot; : &quot;&quot;);
        }
        $SIG{CHLD} = \&amp;REAPER;  # loathe SysV
    }
    $SIG{CHLD} = \&amp;REAPER;
    while (1) {
        $paddr = accept(Client, Server) || do {
            # try again if accept() returned because got a signal
            next if $!{EINTR};
            die &quot;accept: $!&quot;;
        };
        my ($port, $iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr, AF_INET);
        logmsg &quot;connection from $name [&quot;,
               inet_ntoa($iaddr),
               &quot;] at port $port&quot;;
        spawn sub {
            $| = 1;
            print &quot;Hello there, $name, it's now &quot;, scalar localtime(), $EOL;
            exec &quot;/usr/games/fortune&quot;       # XXX: &quot;wrong&quot; line terminators
                or confess &quot;can't exec fortune: $!&quot;;
        };
        close Client;
    }
    sub spawn {
        my $coderef = shift;
        unless (@_ == 0 &amp;&amp; $coderef &amp;&amp; ref($coderef) eq &quot;CODE&quot;) {
            confess &quot;usage: spawn CODEREF&quot;;
        }
        my $pid;
        unless (defined($pid = fork())) {
            logmsg &quot;cannot fork: $!&quot;;
            return;
        } 
        elsif ($pid) {
            logmsg &quot;begat $pid&quot;;
            return; # I'm the parent
        }
        # else I'm the child -- go spawn
        open(STDIN,  &quot;&lt;&amp;Client&quot;)    || die &quot;can't dup client to stdin&quot;;
        open(STDOUT, &quot;&gt;&amp;Client&quot;)    || die &quot;can't dup client to stdout&quot;;
        ## open(STDERR, &quot;&gt;&amp;STDOUT&quot;) || die &quot;can't dup stdout to stderr&quot;;
        exit($coderef-&gt;());
    }
</pre>
<div class="Pp"></div>
This server takes the trouble to clone off a child version via <i>fork()</i> for
  each incoming request. That way it can handle many requests at once, which you
  might not always want. Even if you don't <i>fork()</i>, the <i>listen()</i>
  will allow that many pending connections. Forking servers have to be
  particularly careful about cleaning up their dead children (called
  &quot;zombies&quot; in Unix parlance), because otherwise you'll quickly fill
  up your process table. The REAPER subroutine is used here to call
  <i>waitpid()</i> for any child processes that have finished, thereby ensuring
  that they terminate cleanly and don't join the ranks of the living dead.
<div class="Pp"></div>
Within the while loop we call <i>accept()</i> and check to see if it returns a
  false value. This would normally indicate a system error needs to be reported.
  However, the introduction of safe signals (see &quot;Deferred Signals (Safe
  Signals)&quot; above) in Perl 5.7.3 means that <i>accept()</i> might also be
  interrupted when the process receives a signal. This typically happens when
  one of the forked subprocesses exits and notifies the parent process with a
  CHLD signal.
<div class="Pp"></div>
If <i>accept()</i> is interrupted by a signal, $! will be set to EINTR. If this
  happens, we can safely continue to the next iteration of the loop and another
  call to <i>accept()</i>. It is important that your signal handling code not
  modify the value of $!, or else this test will likely fail. In the REAPER
  subroutine we create a local version of $! before calling <i>waitpid()</i>.
  When <i>waitpid()</i> sets $! to ECHILD as it inevitably does when it has no
  more children waiting, it updates the local copy and leaves the original
  unchanged.
<div class="Pp"></div>
You should use the <b>-T</b> flag to enable taint checking (see perlsec) even if
  we aren't running setuid or setgid. This is always a good idea for servers or
  any program run on behalf of someone else (like CGI scripts), because it
  lessens the chances that people from the outside will be able to compromise
  your system.
<div class="Pp"></div>
Let's look at another TCP client. This one connects to the TCP &quot;time&quot;
  service on a number of different machines and shows how far their clocks
  differ from the system on which it's being run:
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl  -w
    use strict;
    use Socket;
    my $SECS_OF_70_YEARS = 2208988800;
    sub ctime { scalar localtime(shift() || time()) }
    my $iaddr = gethostbyname(&quot;localhost&quot;);
    my $proto = getprotobyname(&quot;tcp&quot;);
    my $port = getservbyname(&quot;time&quot;, &quot;tcp&quot;);
    my $paddr = sockaddr_in(0, $iaddr);
    my($host);
    $| = 1;
    printf &quot;%-24s %8s %s\n&quot;, &quot;localhost&quot;, 0, ctime();
    foreach $host (@ARGV) {
        printf &quot;%-24s &quot;, $host;
        my $hisiaddr = inet_aton($host)     || die &quot;unknown host&quot;;
        my $hispaddr = sockaddr_in($port, $hisiaddr);
        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   
                                            || die &quot;socket: $!&quot;;
        connect(SOCKET, $hispaddr)          || die &quot;connect: $!&quot;;
        my $rtime = pack(&quot;C4&quot;, ());
        read(SOCKET, $rtime, 4);
        close(SOCKET);
        my $histime = unpack(&quot;N&quot;, $rtime) - $SECS_OF_70_YEARS;
        printf &quot;%8d %s\n&quot;, $histime - time(), ctime($histime);
    }
</pre>
<h2 class="Ss" title="Ss" id="Unix-Domain_TCP_Clients_and_Servers"><a class="selflink" href="#Unix-Domain_TCP_Clients_and_Servers">Unix-Domain
  TCP Clients and Servers</a></h2>
That's fine for Internet-domain clients and servers, but what about local
  communications? While you can use the same setup, sometimes you don't want to.
  Unix-domain sockets are local to the current host, and are often used
  internally to implement pipes. Unlike Internet domain sockets, Unix domain
  sockets can show up in the file system with an <i>ls</i>(1) listing.
<div class="Pp"></div>
<pre>
    % ls -l /dev/log
    srw-rw-rw-  1 root            0 Oct 31 07:23 /dev/log
</pre>
<div class="Pp"></div>
You can test for these with Perl's <b>-S</b> file test:
<div class="Pp"></div>
<pre>
    unless (-S &quot;/dev/log&quot;) {
        die &quot;something's wicked with the log system&quot;;
    }
</pre>
<div class="Pp"></div>
Here's a sample Unix-domain client:
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    use Socket;
    use strict;
    my ($rendezvous, $line);
    $rendezvous = shift || &quot;catsock&quot;;
    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || die &quot;socket: $!&quot;;
    connect(SOCK, sockaddr_un($rendezvous))   || die &quot;connect: $!&quot;;
    while (defined($line = &lt;SOCK&gt;)) {
        print $line;
    }
    exit(0);
</pre>
<div class="Pp"></div>
And here's a corresponding server. You don't have to worry about silly network
  terminators here because Unix domain sockets are guaranteed to be on the
  localhost, and thus everything works right.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -Tw
    use strict;
    use Socket;
    use Carp;
    BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; }
    sub spawn;  # forward declaration
    sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar localtime(), &quot;\n&quot; }
    my $NAME = &quot;catsock&quot;;
    my $uaddr = sockaddr_un($NAME);
    my $proto = getprotobyname(&quot;tcp&quot;);
    socket(Server, PF_UNIX, SOCK_STREAM, 0) || die &quot;socket: $!&quot;;
    unlink($NAME);
    bind  (Server, $uaddr)                  || die &quot;bind: $!&quot;;
    listen(Server, SOMAXCONN)               || die &quot;listen: $!&quot;;
    logmsg &quot;server started on $NAME&quot;;
    my $waitedpid;
    use POSIX &quot;:sys_wait_h&quot;;
    sub REAPER {
        my $child;
        while (($waitedpid = waitpid(-1, WNOHANG)) &gt; 0) {
            logmsg &quot;reaped $waitedpid&quot; . ($? ? &quot; with exit $?&quot; : &quot;&quot;);
        }
        $SIG{CHLD} = \&amp;REAPER;  # loathe SysV
    }
    $SIG{CHLD} = \&amp;REAPER;
    for ( $waitedpid = 0;
          accept(Client, Server) || $waitedpid;
          $waitedpid = 0, close Client)
    {
        next if $waitedpid;
        logmsg &quot;connection on $NAME&quot;;
        spawn sub {
            print &quot;Hello there, it's now &quot;, scalar localtime(), &quot;\n&quot;;
            exec(&quot;/usr/games/fortune&quot;)  || die &quot;can't exec fortune: $!&quot;;
        };
    }
    sub spawn {
        my $coderef = shift();
        unless (@_ == 0 &amp;&amp; $coderef &amp;&amp; ref($coderef) eq &quot;CODE&quot;) {
            confess &quot;usage: spawn CODEREF&quot;;
        }
        my $pid;
        unless (defined($pid = fork())) {
            logmsg &quot;cannot fork: $!&quot;;
            return;
        } 
        elsif ($pid) {
            logmsg &quot;begat $pid&quot;;
            return; # I'm the parent
        } 
        else {
            # I'm the child -- go spawn
        }
        open(STDIN,  &quot;&lt;&amp;Client&quot;)    || die &quot;can't dup client to stdin&quot;;
        open(STDOUT, &quot;&gt;&amp;Client&quot;)    || die &quot;can't dup client to stdout&quot;;
        ## open(STDERR, &quot;&gt;&amp;STDOUT&quot;) || die &quot;can't dup stdout to stderr&quot;;
        exit($coderef-&gt;());
    }
</pre>
<div class="Pp"></div>
As you see, it's remarkably similar to the Internet domain TCP server, so much
  so, in fact, that we've omitted several duplicate functions-- <i>spawn()</i>,
  <i>logmsg()</i>, <i>ctime()</i>, and <i>REAPER()</i>--which are the same as in
  the other server.
<div class="Pp"></div>
So why would you ever want to use a Unix domain socket instead of a simpler
  named pipe? Because a named pipe doesn't give you sessions. You can't tell one
  process's data from another's. With socket programming, you get a separate
  session for each client; that's why <i>accept()</i> takes two arguments.
<div class="Pp"></div>
For example, let's say that you have a long-running database server daemon that
  you want folks to be able to access from the Web, but only if they go through
  a CGI interface. You'd have a small, simple CGI program that does whatever
  checks and logging you feel like, and then acts as a Unix-domain client and
  connects to your private server.
<h1 class="Sh" title="Sh" id="TCP_Clients_with_IO::Socket"><a class="selflink" href="#TCP_Clients_with_IO::Socket">TCP
  Clients with IO::Socket</a></h1>
For those preferring a higher-level interface to socket programming, the
  IO::Socket module provides an object-oriented approach. IO::Socket has been
  included in the standard Perl distribution ever since Perl 5.004. If you're
  running an earlier version of Perl (in which case, how are you reading this
  manpage?), just fetch IO::Socket from CPAN, where you'll also find modules
  providing easy interfaces to the following systems: DNS, FTP, Ident (RFC 931),
  NIS and NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, and Time--to
  name just a few.
<h2 class="Ss" title="Ss" id="A_Simple_Client"><a class="selflink" href="#A_Simple_Client">A
  Simple Client</a></h2>
Here's a client that creates a TCP connection to the &quot;daytime&quot; service
  at port 13 of the host name &quot;localhost&quot; and prints out everything
  that the server there cares to provide.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    use IO::Socket;
    $remote = IO::Socket::INET-&gt;new(
                        Proto    =&gt; &quot;tcp&quot;,
                        PeerAddr =&gt; &quot;localhost&quot;,
                        PeerPort =&gt; &quot;daytime(13)&quot;,
                    )
                  || die &quot;can't connect to daytime service on localhost&quot;;
    while (&lt;$remote&gt;) { print }
</pre>
<div class="Pp"></div>
When you run this program, you should get something back that looks like this:
<div class="Pp"></div>
<pre>
    Wed May 14 08:40:46 MDT 1997
</pre>
<div class="Pp"></div>
Here are what those parameters to the <i>new()</i> constructor mean:
<dl class="Bl-tag">
  <dt class="It-tag">&quot;Proto&quot;</dt>
  <dd class="It-tag">This is which protocol to use. In this case, the socket
      handle returned will be connected to a TCP socket, because we want a
      stream-oriented connection, that is, one that acts pretty much like a
      plain old file. Not all sockets are this of this type. For example, the
      UDP protocol can be used to make a datagram socket, used for
      message-passing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;PeerAddr&quot;</dt>
  <dd class="It-tag">This is the name or Internet address of the remote host the
      server is running on. We could have specified a longer name like
      &quot;www.perl.com&quot;, or an address like &quot;207.171.7.72&quot;. For
      demonstration purposes, we've used the special hostname
      &quot;localhost&quot;, which should always mean the current machine you're
      running on. The corresponding Internet address for localhost is
      &quot;127.0.0.1&quot;, if you'd rather use that.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;PeerPort&quot;</dt>
  <dd class="It-tag">This is the service name or port number we'd like to
      connect to. We could have gotten away with using just &quot;daytime&quot;
      on systems with a well-configured system services file,[FOOTNOTE: The
      system services file is found in <i>/etc/services</i> under Unixy
      systems.] but here we've specified the port number (13) in parentheses.
      Using just the number would have also worked, but numeric literals make
      careful programmers nervous.</dd>
</dl>
<div class="Pp"></div>
Notice how the return value from the &quot;new&quot; constructor is used as a
  filehandle in the &quot;while&quot; loop? That's what's called an
  <i>indirect</i> <i>filehandle</i>, a scalar variable containing a filehandle.
  You can use it the same way you would a normal filehandle. For example, you
  can read one line from it this way:
<div class="Pp"></div>
<pre>
    $line = &lt;$handle&gt;;
</pre>
<div class="Pp"></div>
all remaining lines from is this way:
<div class="Pp"></div>
<pre>
    @lines = &lt;$handle&gt;;
</pre>
<div class="Pp"></div>
and send a line of data to it this way:
<div class="Pp"></div>
<pre>
    print $handle &quot;some data\n&quot;;
</pre>
<h2 class="Ss" title="Ss" id="A_Webget_Client"><a class="selflink" href="#A_Webget_Client">A
  Webget Client</a></h2>
Here's a simple client that takes a remote host to fetch a document from, and
  then a list of files to get from that host. This is a more interesting client
  than the previous one because it first sends something to the server before
  fetching the server's response.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    use IO::Socket;
    unless (@ARGV &gt; 1) { die &quot;usage: $0 host url ...&quot; }
    $host = shift(@ARGV);
    $EOL = &quot;\015\012&quot;;
    $BLANK = $EOL x 2;
    for my $document (@ARGV) {
        $remote = IO::Socket::INET-&gt;new( Proto     =&gt; &quot;tcp&quot;,
                                         PeerAddr  =&gt; $host,
                                         PeerPort  =&gt; &quot;http(80)&quot;,
                  )     || die &quot;cannot connect to httpd on $host&quot;;
        $remote-&gt;autoflush(1);
        print $remote &quot;GET $document HTTP/1.0&quot; . $BLANK;
        while ( &lt;$remote&gt; ) { print }
        close $remote;
    }
</pre>
<div class="Pp"></div>
The web server handling the HTTP service is assumed to be at its standard port,
  number 80. If the server you're trying to connect to is at a different port,
  like 1080 or 8080, you should specify it as the named-parameter pair,
  &quot;PeerPort =&gt; 8080&quot;. The &quot;autoflush&quot; method is used on
  the socket because otherwise the system would buffer up the output we sent it.
  (If you're on a prehistoric Mac, you'll also need to change every
  &quot;\n&quot; in your code that sends data over the network to be a
  &quot;\015\012&quot; instead.)
<div class="Pp"></div>
Connecting to the server is only the first part of the process: once you have
  the connection, you have to use the server's language. Each server on the
  network has its own little command language that it expects as input. The
  string that we send to the server starting with &quot;GET&quot; is in HTTP
  syntax. In this case, we simply request each specified document. Yes, we
  really are making a new connection for each document, even though it's the
  same host. That's the way you always used to have to speak HTTP. Recent
  versions of web browsers may request that the remote server leave the
  connection open a little while, but the server doesn't have to honor such a
  request.
<div class="Pp"></div>
Here's an example of running that program, which we'll call <i>webget</i>:
<div class="Pp"></div>
<pre>
    % webget www.perl.com /guanaco.html
    HTTP/1.1 404 File Not Found
    Date: Thu, 08 May 1997 18:02:32 GMT
    Server: Apache/1.2b6
    Connection: close
    Content-type: text/html
    &lt;HEAD&gt;&lt;TITLE&gt;404 File Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;
    &lt;BODY&gt;&lt;H1&gt;File Not Found&lt;/H1&gt;
    The requested URL /guanaco.html was not found on this server.&lt;P&gt;
    &lt;/BODY&gt;
</pre>
<div class="Pp"></div>
Ok, so that's not very interesting, because it didn't find that particular
  document. But a long response wouldn't have fit on this page.
<div class="Pp"></div>
For a more featureful version of this program, you should look to the
  <i>lwp-request</i> program included with the LWP modules from CPAN.
<h2 class="Ss" title="Ss" id="Interactive_Client_with_IO::Socket"><a class="selflink" href="#Interactive_Client_with_IO::Socket">Interactive
  Client with IO::Socket</a></h2>
Well, that's all fine if you want to send one command and get one answer, but
  what about setting up something fully interactive, somewhat like the way
  <i>telnet</i> works? That way you can type a line, get the answer, type a
  line, get the answer, etc.
<div class="Pp"></div>
This client is more complicated than the two we've done so far, but if you're on
  a system that supports the powerful &quot;fork&quot; call, the solution isn't
  that rough. Once you've made the connection to whatever service you'd like to
  chat with, call &quot;fork&quot; to clone your process. Each of these two
  identical process has a very simple job to do: the parent copies everything
  from the socket to standard output, while the child simultaneously copies
  everything from standard input to the socket. To accomplish the same thing
  using just one process would be <i>much</i> harder, because it's easier to
  code two processes to do one thing than it is to code one process to do two
  things. (This keep-it-simple principle a cornerstones of the Unix philosophy,
  and good software engineering as well, which is probably why it's spread to
  other systems.)
<div class="Pp"></div>
Here's the code:
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    use strict;
    use IO::Socket;
    my ($host, $port, $kidpid, $handle, $line);
    unless (@ARGV == 2) { die &quot;usage: $0 host port&quot; }
    ($host, $port) = @ARGV;
    # create a tcp connection to the specified host and port
    $handle = IO::Socket::INET-&gt;new(Proto     =&gt; &quot;tcp&quot;,
                                    PeerAddr  =&gt; $host,
                                    PeerPort  =&gt; $port)
               || die &quot;can't connect to port $port on $host: $!&quot;;
    $handle-&gt;autoflush(1);       # so output gets there right away
    print STDERR &quot;[Connected to $host:$port]\n&quot;;
    # split the program into two processes, identical twins
    die &quot;can't fork: $!&quot; unless defined($kidpid = fork());
    # the if{} block runs only in the parent process
    if ($kidpid) {
        # copy the socket to standard output
        while (defined ($line = &lt;$handle&gt;)) {
            print STDOUT $line;
        }
        kill(&quot;TERM&quot;, $kidpid);   # send SIGTERM to child
    }
    # the else{} block runs only in the child process
    else {
        # copy standard input to the socket
        while (defined ($line = &lt;STDIN&gt;)) {
            print $handle $line;
        }
        exit(0);                # just in case
    }
</pre>
<div class="Pp"></div>
The &quot;kill&quot; function in the parent's &quot;if&quot; block is there to
  send a signal to our child process, currently running in the &quot;else&quot;
  block, as soon as the remote server has closed its end of the connection.
<div class="Pp"></div>
If the remote server sends data a byte at time, and you need that data
  immediately without waiting for a newline (which might not happen), you may
  wish to replace the &quot;while&quot; loop in the parent with the following:
<div class="Pp"></div>
<pre>
    my $byte;
    while (sysread($handle, $byte, 1) == 1) {
        print STDOUT $byte;
    }
</pre>
<div class="Pp"></div>
Making a system call for each byte you want to read is not very efficient (to
  put it mildly) but is the simplest to explain and works reasonably well.
<h1 class="Sh" title="Sh" id="TCP_Servers_with_IO::Socket"><a class="selflink" href="#TCP_Servers_with_IO::Socket">TCP
  Servers with IO::Socket</a></h1>
As always, setting up a server is little bit more involved than running a
  client. The model is that the server creates a special kind of socket that
  does nothing but listen on a particular port for incoming connections. It does
  this by calling the &quot;IO::Socket::INET-&gt;new()&quot; method with
  slightly different arguments than the client did.
<dl class="Bl-tag">
  <dt class="It-tag">Proto</dt>
  <dd class="It-tag">This is which protocol to use. Like our clients, we'll
      still specify &quot;tcp&quot; here.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">LocalPort</dt>
  <dd class="It-tag">We specify a local port in the &quot;LocalPort&quot;
      argument, which we didn't do for the client. This is service name or port
      number for which you want to be the server. (Under Unix, ports under 1024
      are restricted to the superuser.) In our sample, we'll use port 9000, but
      you can use any port that's not currently in use on your system. If you
      try to use one already in used, you'll get an &quot;Address already in
      use&quot; message. Under Unix, the &quot;netstat -a&quot; command will
      show which services current have servers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Listen</dt>
  <dd class="It-tag">The &quot;Listen&quot; parameter is set to the maximum
      number of pending connections we can accept until we turn away incoming
      clients. Think of it as a call-waiting queue for your telephone. The
      low-level Socket module has a special symbol for the system maximum, which
      is SOMAXCONN.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Reuse</dt>
  <dd class="It-tag">The &quot;Reuse&quot; parameter is needed so that we
      restart our server manually without waiting a few minutes to allow system
      buffers to clear out.</dd>
</dl>
<div class="Pp"></div>
Once the generic server socket has been created using the parameters listed
  above, the server then waits for a new client to connect to it. The server
  blocks in the &quot;accept&quot; method, which eventually accepts a
  bidirectional connection from the remote client. (Make sure to autoflush this
  handle to circumvent buffering.)
<div class="Pp"></div>
To add to user-friendliness, our server prompts the user for commands. Most
  servers don't do this. Because of the prompt without a newline, you'll have to
  use the &quot;sysread&quot; variant of the interactive client above.
<div class="Pp"></div>
This server accepts one of five different commands, sending output back to the
  client. Unlike most network servers, this one handles only one incoming client
  at a time. Multithreaded servers are covered in Chapter 16 of the Camel.
<div class="Pp"></div>
Here's the code. We'll
<div class="Pp"></div>
<pre>
 #!/usr/bin/perl -w
 use IO::Socket;
 use Net::hostent;      # for OOish version of gethostbyaddr
 $PORT = 9000;          # pick something not in use
 $server = IO::Socket::INET-&gt;new( Proto     =&gt; &quot;tcp&quot;,
                                  LocalPort =&gt; $PORT,
                                  Listen    =&gt; SOMAXCONN,
                                  Reuse     =&gt; 1);
 die &quot;can't setup server&quot; unless $server;
 print &quot;[Server $0 accepting clients]\n&quot;;
 while ($client = $server-&gt;accept()) {
   $client-&gt;autoflush(1);
   print $client &quot;Welcome to $0; type help for command list.\n&quot;;
   $hostinfo = gethostbyaddr($client-&gt;peeraddr);
   printf &quot;[Connect from %s]\n&quot;, $hostinfo ? $hostinfo-&gt;name : $client-&gt;peerhost;
   print $client &quot;Command? &quot;;
   while ( &lt;$client&gt;) {
     next unless /\S/;       # blank line
     if    (/quit|exit/i)    { last                                      }
     elsif (/date|time/i)    { printf $client &quot;%s\n&quot;, scalar localtime() }
     elsif (/who/i )         { print  $client `who 2&gt;&amp;1`                 }
     elsif (/cookie/i )      { print  $client `/usr/games/fortune 2&gt;&amp;1`  }
     elsif (/motd/i )        { print  $client `cat /etc/motd 2&gt;&amp;1`       }
     else {
       print $client &quot;Commands: quit date who cookie motd\n&quot;;
     }
   } continue {
      print $client &quot;Command? &quot;;
   }
   close $client;
 }
</pre>
<h1 class="Sh" title="Sh" id="UDP:_Message_Passing"><a class="selflink" href="#UDP:_Message_Passing">UDP:
  Message Passing</a></h1>
Another kind of client-server setup is one that uses not connections, but
  messages. UDP communications involve much lower overhead but also provide less
  reliability, as there are no promises that messages will arrive at all, let
  alone in order and unmangled. Still, UDP offers some advantages over TCP,
  including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a
  whole bunch of destination hosts at once (usually on your local subnet). If
  you find yourself overly concerned about reliability and start building checks
  into your message system, then you probably should use just TCP to start with.
<div class="Pp"></div>
UDP datagrams are <i>not</i> a bytestream and should not be treated as such.
  This makes using I/O mechanisms with internal buffering like stdio (i.e.
  <i>print()</i> and friends) especially cumbersome. Use <i>syswrite()</i>, or
  better <i>send()</i>, like in the example below.
<div class="Pp"></div>
Here's a UDP program similar to the sample Internet TCP client given earlier.
  However, instead of checking one host at a time, the UDP version will check
  many of them asynchronously by simulating a multicast and then using
  <i>select()</i> to do a timed-out wait for I/O. To do something similar with
  TCP, you'd have to use a different socket handle for each host.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    use strict;
    use Socket;
    use Sys::Hostname;
    my ( $count, $hisiaddr, $hispaddr, $histime,
         $host, $iaddr, $paddr, $port, $proto,
         $rin, $rout, $rtime, $SECS_OF_70_YEARS);
    $SECS_OF_70_YEARS = 2_208_988_800;
    $iaddr = gethostbyname(hostname());
    $proto = getprotobyname(&quot;udp&quot;);
    $port = getservbyname(&quot;time&quot;, &quot;udp&quot;);
    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick
    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die &quot;socket: $!&quot;;
    bind(SOCKET, $paddr)                          || die &quot;bind: $!&quot;;
    $| = 1;
    printf &quot;%-12s %8s %s\n&quot;,  &quot;localhost&quot;, 0, scalar localtime();
    $count = 0;
    for $host (@ARGV) {
        $count++;
        $hisiaddr = inet_aton($host)              || die &quot;unknown host&quot;;
        $hispaddr = sockaddr_in($port, $hisiaddr);
        defined(send(SOCKET, 0, 0, $hispaddr))    || die &quot;send $host: $!&quot;;
    }
    $rin = &quot;&quot;;
    vec($rin, fileno(SOCKET), 1) = 1;
    # timeout after 10.0 seconds
    while ($count &amp;&amp; select($rout = $rin, undef, undef, 10.0)) {
        $rtime = &quot;&quot;;
        $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die &quot;recv: $!&quot;;
        ($port, $hisiaddr) = sockaddr_in($hispaddr);
        $host = gethostbyaddr($hisiaddr, AF_INET);
        $histime = unpack(&quot;N&quot;, $rtime) - $SECS_OF_70_YEARS;
        printf &quot;%-12s &quot;, $host;
        printf &quot;%8d %s\n&quot;, $histime - time(), scalar localtime($histime);
        $count--;
    }
</pre>
<div class="Pp"></div>
This example does not include any retries and may consequently fail to contact a
  reachable host. The most prominent reason for this is congestion of the queues
  on the sending host if the number of hosts to contact is sufficiently large.
<h1 class="Sh" title="Sh" id="SysV_IPC"><a class="selflink" href="#SysV_IPC">SysV
  IPC</a></h1>
While System V IPC isn't so widely used as sockets, it still has some
  interesting uses. However, you cannot use SysV IPC or Berkeley <i>mmap()</i>
  to have a variable shared amongst several processes. That's because Perl would
  reallocate your string when you weren't wanting it to. You might look into the
  &quot;IPC::Shareable&quot; or &quot;threads::shared&quot; modules for that.
<div class="Pp"></div>
Here's a small example showing shared memory usage.
<div class="Pp"></div>
<pre>
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
    $size = 2000;
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
    defined($id)                    || die &quot;shmget: $!&quot;;
    print &quot;shm key $id\n&quot;;
    $message = &quot;Message #1&quot;;
    shmwrite($id, $message, 0, 60)  || die &quot;shmwrite: $!&quot;;
    print &quot;wrote: '$message'\n&quot;;
    shmread($id, $buff, 0, 60)      || die &quot;shmread: $!&quot;;
    print &quot;read : '$buff'\n&quot;;
    # the buffer of shmread is zero-character end-padded.
    substr($buff, index($buff, &quot;\0&quot;)) = &quot;&quot;;
    print &quot;un&quot; unless $buff eq $message;
    print &quot;swell\n&quot;;
    print &quot;deleting shm $id\n&quot;;
    shmctl($id, IPC_RMID, 0)        || die &quot;shmctl: $!&quot;;
</pre>
<div class="Pp"></div>
Here's an example of a semaphore:
<div class="Pp"></div>
<pre>
    use IPC::SysV qw(IPC_CREAT);
    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
    defined($id)                    || die &quot;shmget: $!&quot;;
    print &quot;shm key $id\n&quot;;
</pre>
<div class="Pp"></div>
Put this code in a separate file to be run in more than one process. Call the
  file <i>take</i>:
<div class="Pp"></div>
<pre>
    # create a semaphore
    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 0, 0);
    defined($id)                    || die &quot;shmget: $!&quot;;
    $semnum  = 0;
    $semflag = 0;
    # &quot;take&quot; semaphore
    # wait for semaphore to be zero
    $semop = 0;
    $opstring1 = pack(&quot;s!s!s!&quot;, $semnum, $semop, $semflag);
    # Increment the semaphore count
    $semop = 1;
    $opstring2 = pack(&quot;s!s!s!&quot;, $semnum, $semop,  $semflag);
    $opstring  = $opstring1 . $opstring2;
    semop($id, $opstring)   || die &quot;semop: $!&quot;;
</pre>
<div class="Pp"></div>
Put this code in a separate file to be run in more than one process. Call this
  file <i>give</i>:
<div class="Pp"></div>
<pre>
    # &quot;give&quot; the semaphore
    # run this in the original process and you will see
    # that the second process continues
    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 0, 0);
    die unless defined($id);
    $semnum  = 0;
    $semflag = 0;
    # Decrement the semaphore count
    $semop = -1;
    $opstring = pack(&quot;s!s!s!&quot;, $semnum, $semop, $semflag);
    semop($id, $opstring)   || die &quot;semop: $!&quot;;
</pre>
<div class="Pp"></div>
The SysV IPC code above was written long ago, and it's definitely clunky
  looking. For a more modern look, see the IPC::SysV module which is included
  with Perl starting from Perl 5.005.
<div class="Pp"></div>
A small example demonstrating SysV message queues:
<div class="Pp"></div>
<pre>
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);
    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
    defined($id)                || die &quot;msgget failed: $!&quot;;
    my $sent      = &quot;message&quot;;
    my $type_sent = 1234;
    msgsnd($id, pack(&quot;l! a*&quot;, $type_sent, $sent), 0)
                                || die &quot;msgsnd failed: $!&quot;;
    msgrcv($id, my $rcvd_buf, 60, 0, 0)
                                || die &quot;msgrcv failed: $!&quot;;
    my($type_rcvd, $rcvd) = unpack(&quot;l! a*&quot;, $rcvd_buf);
    if ($rcvd eq $sent) {
        print &quot;okay\n&quot;;
    } else {
        print &quot;not okay\n&quot;;
    }
    msgctl($id, IPC_RMID, 0)    || die &quot;msgctl failed: $!\n&quot;;
</pre>
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
Most of these routines quietly but politely return &quot;undef&quot; when they
  fail instead of causing your program to die right then and there due to an
  uncaught exception. (Actually, some of the new <i>Socket</i> conversion
  functions do <i>croak()</i> on bad arguments.) It is therefore essential to
  check return values from these functions. Always begin your socket programs
  this way for optimal success, and don't forget to add the <b>-T</b>
  taint-checking flag to the &quot;#!&quot; line for servers:
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -Tw
    use strict;
    use sigtrap;
    use Socket;
</pre>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
These routines all create system-specific portability problems. As noted
  elsewhere, Perl is at the mercy of your C libraries for much of its system
  behavior. It's probably safest to assume broken SysV semantics for signals and
  to stick with simple TCP and UDP socket operations; e.g., don't try to pass
  open file descriptors over a local UDP datagram socket if you want your code
  to stand a chance of being portable.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Tom Christiansen, with occasional vestiges of Larry Wall's original version and
  suggestions from the Perl Porters.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
There's a lot more to networking than this, but this should get you started.
<div class="Pp"></div>
For intrepid programmers, the indispensable textbook is <i>Unix Network</i>
  <i>Programming, 2nd Edition, Volume 1</i> by W. Richard Stevens (published by
  Prentice-Hall). Most books on networking address the subject from the
  perspective of a C programmer; translation to Perl is left as an exercise for
  the reader.
<div class="Pp"></div>
The <i>IO::Socket</i>(3) manpage describes the object library, and the
  <i>Socket</i>(3) manpage describes the low-level interface to sockets. Besides
  the obvious functions in perlfunc, you should also check out the
  <i>modules</i> file at your nearest CPAN site, especially
  &lt;http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_&gt;. See
  perlmodlib or best yet, the <i>Perl FAQ</i> for a description of what CPAN is
  and where to get it if the previous link doesn't work for you.
<div class="Pp"></div>
Section 5 of CPAN's <i>modules</i> file is devoted to &quot;Networking, Device
  Control (modems), and Interprocess Communication&quot;, and contains numerous
  unbundled modules numerous networking modules, Chat and Expect operations, CGI
  programming, DCE, FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet,
  Threads, and ToolTalk--to name just a few.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
