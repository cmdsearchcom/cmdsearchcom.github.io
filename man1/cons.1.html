<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:00:19 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CONS(1) Cons - Software Construction System CONS(1)</p>

<p style="margin-top: 1em">NAME <br>
Cons - A Software Construction System</p>

<p style="margin-top: 1em">DESCRIPTION <br>
A guide and reference for version 2.2.0</p>

<p style="margin-top: 1em">Copyright (c) 1996-2000 Free
Software Foundation, Inc.</p>

<p style="margin-top: 1em">This program is free software;
you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free
Software Foundation; either <br>
version 2 of the License, or (at your option) any later
version.</p>

<p style="margin-top: 1em">This program is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PUR&acirc; <br>
POSE. See the GNU General Public License for more
details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program;
see the file COPYING. If not, write to the Free Software
Foundation, Inc., 59 Temple <br>
Place - Suite 330, Boston, MA 02111-1307, USA.</p>

<p style="margin-top: 1em">Introduction <br>
Cons is a system for constructing, primarily, software, but
is quite different from previous software construction
systems. Cons was designed from the ground up to deal easily
<br>
with the construction of software spread over multiple
source directories. Cons makes it easy to create build
scripts that are simple, understandable and maintainable.
Cons <br>
ensures that complex software is easily and accurately
reproducible.</p>

<p style="margin-top: 1em">Cons uses a number of techniques
to accomplish all of this. Construction scripts are just
Perl scripts, making them both easy to comprehend and very
flexible. Global scoping of <br>
variables is replaced with an import/export mechanism for
sharing information between scripts, significantly improving
the readability and maintainability of each script.
Con&acirc; <br>
struction environments are introduced: these are Perl
objects that capture the information required for
controlling the build process. Multiple environments are
used when differ&acirc; <br>
ent semantics are required for generating products in the
build tree. Cons implements automatic dependency analysis
and uses this to globally sequence the entire build. Variant
<br>
builds are easily produced from a single source tree.
Intelligent build subsetting is possible, when working on
localized changes. Overrides can be setup to easily override
build <br>
instructions without modifying any scripts. MD5
cryptographic signatures are associated with derived files,
and are used to accurately determine whether a given file
needs to be <br>
rebuilt.</p>

<p style="margin-top: 1em">While offering all of the above,
and more, Cons remains simple and easy to use. This will,
hopefully, become clear as you read the remainder of this
document.</p>

<p style="margin-top: 1em">Why Cons? Why not Make? <br>
Cons is a make replacement. In the following paragraphs, we
look at a few of the undesirable characteristics of
make--and typical build environments based on make--that
motivated <br>
the development of Cons.</p>

<p style="margin-top: 1em">Build complexity</p>

<p style="margin-top: 1em">Traditional make-based systems
of any size tend to become quite complex. The original make
utility and its derivatives have contributed to this
tendency in a number of ways. Make <br>
is not good at dealing with systems that are spread over
multiple directories. Various work-arounds are used to
overcome this difficulty; the usual choice is for make to
invoke <br>
itself recursively for each sub-directory of a build. This
leads to complicated code, in which it is often unclear how
a variable is set, or what effect the setting of a variable
<br>
will have on the build as a whole. The make scripting
language has gradually been extended to provide more
possibilities, but these have largely served to clutter an
already <br>
overextended language. Often, builds are done in multiple
passes in order to provide appropriate products from one
directory to another directory. This represents a further
<br>
increase in build complexity.</p>

<p style="margin-top: 1em">Build reproducibility</p>

<p style="margin-top: 1em">The bane of all makes has always
been the correct handling of dependencies. Most often, an
attempt is made to do a reasonable job of dependencies
within a single directory, but <br>
no serious attempt is made to do the job between
directories. Even when dependencies are working correctly,
make&rsquo;s reliance on a simple time stamp comparison to
determine whether <br>
a file is out of date with respect to its dependents is not,
in general, adequate for determining when a file should be
rederived. If an external library, for example, is rebuilt
<br>
and then &lsquo;&lsquo;snapped&rsquo;&rsquo; into place, the
timestamps on its newly created files may well be earlier
than the last local build, since it was built before it
became visible.</p>

<p style="margin-top: 1em">Variant builds</p>

<p style="margin-top: 1em">Make provides only limited
facilities for handling variant builds. With the
proliferation of hardware platforms and the need for
debuggable vs. optimized code, the ability to <br>
easily create these variants is essential. More importantly,
if variants are created, it is important to either be able
to separate the variants or to be able to reproduce the <br>
original or variant at will. With make it is very difficult
to separate the builds into multiple build directories,
separate from the source. And if this technique isn&rsquo;t
used, <br>
it&rsquo;s also virtually impossible to guarantee at any
given time which variant is present in the tree, without
resorting to a complete rebuild.</p>

<p style="margin-top: 1em">Repositories</p>

<p style="margin-top: 1em">Make provides only limited
support for building software from code that exists in a
central repository directory structure. The VPATH feature of
GNU make (and some other make <br>
implementations) is intended to provide this, but
doesn&rsquo;t work as expected: it changes the path of
target file to the VPATH name too early in its analysis, and
therefore searches <br>
for all dependencies in the VPATH directory. To ensure
correct development builds, it is important to be able to
create a file in a local build directory and have any files
in a <br>
code repository (a VPATH directory, in make terms) that
depend on the local file get rebuilt properly. This
isn&rsquo;t possible with VPATH, without coding a lot of
complex repository <br>
knowledge directly into the makefiles.</p>

<p style="margin-top: 1em">Keeping it simple <br>
A few of the difficulties with make have been cited above.
In this and subsequent sections, we shall introduce Cons and
show how these issues are addressed.</p>

<p style="margin-top: 1em">Perl scripts</p>

<p style="margin-top: 1em">Cons is Perl-based. That is,
Cons scripts--Conscript and Construct files, the equivalent
to Makefile or makefile--are all written in Perl. This
provides an immediate benefit: the <br>
language for writing scripts is a familiar one. Even if you
don&rsquo;t happen to be a Perl programmer, it helps to know
that Perl is basically just a simple declarative language,
with <br>
a well-defined flow of control, and familiar semantics. It
has variables that behave basically the way you would expect
them to, subroutines, flow of control, and so on. There is
<br>
no special syntax introduced for Cons. The use of Perl as a
scripting language simplifies the task of expressing the
appropriate solution to the often complex requirements of a
<br>
build.</p>

<p style="margin-top: 1em">Hello, World!</p>

<p style="margin-top: 1em">To ground the following
discussion, here&rsquo;s how you could build the Hello,
World! C application with Cons:</p>

<p style="margin-top: 1em">$env = new cons(); <br>
Program $env &rsquo;hello&rsquo;, &rsquo;hello.c&rsquo;;</p>

<p style="margin-top: 1em">If you install this script in a
directory, naming the script Construct, and create the
hello.c source file in the same directory, then you can type
&lsquo;cons hello&rsquo; to build the <br>
application:</p>

<p style="margin-top: 1em">% cons hello <br>
cc -c hello.c -o hello.o <br>
cc -o hello hello.o</p>

<p style="margin-top: 1em">Construction environments</p>

<p style="margin-top: 1em">A key simplification of Cons is
the idea of a construction environment. A construction
environment is an object characterized by a set of key/value
pairs and a set of methods. In <br>
order to tell Cons how to build something, you invoke the
appropriate method via an appropriate construction
environment. Consider the following example:</p>

<p style="margin-top: 1em">$env = new cons( <br>
CC =&gt; &rsquo;gcc&rsquo;, <br>
LIBS =&gt; &rsquo;libworld.a&rsquo; <br>
);</p>

<p style="margin-top: 1em">Program $env
&rsquo;hello&rsquo;, &rsquo;hello.c&rsquo;;</p>

<p style="margin-top: 1em">In this case, rather than using
the default construction environment, as is, we have
overridden the value of &lsquo;CC&rsquo; so that the GNU C
Compiler equivalent is used, instead. Since <br>
this version of Hello, World! requires a library,
libworld.a, we have specified that any program linked in
this environment should be linked with that library. If the
library <br>
exists already, well and good, but if not, then we&rsquo;ll
also have to include the statement:</p>

<p style="margin-top: 1em">Library $env
&rsquo;libworld&rsquo;, &rsquo;world.c&rsquo;;</p>

<p style="margin-top: 1em">Now if you type &lsquo;cons
hello&rsquo;, the library will be built before the program
is linked, and, of course, &lsquo;gcc&rsquo; will be used to
compile both modules:</p>

<p style="margin-top: 1em">% cons hello <br>
gcc -c hello.c -o hello.o <br>
gcc -c world.c -o world.o <br>
ar r libworld.a world.o <br>
ar: creating libworld.a <br>
ranlib libworld.a <br>
gcc -o hello hello.o libworld.a</p>

<p style="margin-top: 1em">Automatic and complete
dependency analysis</p>

<p style="margin-top: 1em">With Cons, dependencies are
handled automatically. Continuing the previous example, note
that when we modify world.c, world.o is recompiled,
libworld.a recreated, and hello <br>
relinked:</p>

<p style="margin-top: 1em">% vi world.c <br>
[EDIT] <br>
% cons hello <br>
gcc -c world.c -o world.o <br>
ar r libworld.a world.o <br>
ar: creating libworld.a <br>
ranlib libworld.a <br>
gcc -o hello hello.o libworld.a</p>

<p style="margin-top: 1em">This is a relatively simple
example: Cons &lsquo;&lsquo;knows&rsquo;&rsquo; world.o
depends upon world.c, because the dependency is explicitly
set up by the &lsquo;Library&rsquo; method. It also knows
that lib&acirc; <br>
world.a depends upon world.o and that hello depends upon
libworld.a, all for similar reasons.</p>

<p style="margin-top: 1em">Now it turns out that hello.c
also includes the interface definition file, world.h:</p>

<p style="margin-top: 1em">% emacs world.h <br>
[EDIT] <br>
% cons hello <br>
gcc -c hello.c -o hello.o <br>
gcc -o hello hello.o libworld.a</p>

<p style="margin-top: 1em">How does Cons know that hello.c
includes world.h, and that hello.o must therefore be
recompiled? For now, suffice it to say that when considering
whether or not hello.o is up-to- <br>
date, Cons invokes a scanner for its dependency, hello.c.
This scanner enumerates the files included by hello.c to
come up with a list of further dependencies, beyond those
made <br>
explicit by the Cons script. This process is recursive: any
files included by included files will also be scanned.</p>

<p style="margin-top: 1em">Isn&rsquo;t this expensive? The
answer is--it depends. If you do a full build of a large
system, the scanning time is insignificant. If you do a
rebuild of a large system, then Cons <br>
will spend a fair amount of time thinking about it before it
decides that nothing has to be done (although not
necessarily more time than make!). The good news is that
Cons makes <br>
it very easy to intelligently subset your build, when you
are working on localized changes.</p>

<p style="margin-top: 1em">Automatic global build
sequencing</p>

<p style="margin-top: 1em">Because Cons does full and
accurate dependency analysis, and does this globally, for
the entire build, Cons is able to use this information to
take full control of the sequencing <br>
of the build. This sequencing is evident in the above
examples, and is equivalent to what you would expect for
make, given a full set of dependencies. With Cons, this
extends <br>
trivially to larger, multi-directory builds. As a result,
all of the complexity involved in making sure that a build
is organized correctly--including multi-pass hierarchical
<br>
builds--is eliminated. We&rsquo;ll discuss this further in
the next sections.</p>

<p style="margin-top: 1em">Building large trees--still just
as simple <br>
A hierarchy of build scripts</p>

<p style="margin-top: 1em">A larger build, in Cons, is
organized by creating a hierarchy of build scripts. At the
top of the tree is a script called Construct. The rest of
the scripts, by convention, are <br>
each called Conscript. These scripts are connected together,
very simply, by the &lsquo;Build&rsquo;,
&lsquo;Export&rsquo;, and &lsquo;Import&rsquo; commands.</p>

<p style="margin-top: 1em">The Build command</p>

<p style="margin-top: 1em">The &lsquo;Build&rsquo; command
takes a list of Conscript file names, and arranges for them
to be included in the build. For example:</p>

<p style="margin-top: 1em">Build qw( <br>
drivers/display/Conscript <br>
drivers/mouse/Conscript <br>
parser/Conscript <br>
utilities/Conscript <br>
);</p>

<p style="margin-top: 1em">This is a simple two-level
hierarchy of build scripts: all the subsidiary Conscript
files are mentioned in the top-level Construct file. Notice
that not all directories in the <br>
tree necessarily have build scripts associated with
them.</p>

<p style="margin-top: 1em">This could also be written as a
multi-level script. For example, the Construct file might
contain this command:</p>

<p style="margin-top: 1em">Build qw( <br>
parser/Conscript <br>
drivers/Conscript <br>
utilities/Conscript <br>
);</p>

<p style="margin-top: 1em">and the Conscript file in the
drivers directory might contain this:</p>

<p style="margin-top: 1em">Build qw( <br>
display/Conscript <br>
mouse/Conscript <br>
);</p>

<p style="margin-top: 1em">Experience has shown that the
former model is a little easier to understand, since the
whole construction tree is laid out in front of you, at the
top-level. Hybrid schemes are <br>
also possible. A separately maintained component that needs
to be incorporated into a build tree, for example, might
hook into the build tree in one place, but define its own
<br>
construction hierarchy.</p>

<p style="margin-top: 1em">By default, Cons does not change
its working directory to the directory containing a
subsidiary Conscript file it is including. This behavior can
be enabled for a build by spec&acirc; <br>
ifying, in the top-level Construct file:</p>

<p style="margin-top: 1em">Conscript_chdir 1;</p>

<p style="margin-top: 1em">When enabled, Cons will change
to the subsidiary Conscript file&rsquo;s containing
directory while reading in that file, and then change back
to the top-level directory once the file <br>
has been processed.</p>

<p style="margin-top: 1em">It is expected that this
behavior will become the default in some future version of
Cons. To prepare for this transition, builds that expect
Cons to remain at the top of the <br>
build while it reads in a subsidiary Conscript file should
explicitly disable this feature as follows:</p>

<p style="margin-top: 1em">Conscript_chdir 0;</p>

<p style="margin-top: 1em">Relative, top-relative, and
absolute file names</p>

<p style="margin-top: 1em">You may have noticed that the
file names specified to the Build command are relative to
the location of the script it is invoked from. This is
generally true for other filename <br>
arguments to other commands, too, although we might as well
mention here that if you begin a file name with a hash mark,
&lsquo;&lsquo;#&rsquo;&rsquo;, then that file is interpreted
relative to the top- <br>
level directory (where the Construct file resides). And, not
surprisingly, if you begin it with
&lsquo;&lsquo;/&rsquo;&rsquo;, then it is considered to be
an absolute pathname. This is true even on sys&acirc; <br>
tems which use a back slash rather than a forward slash to
name absolute paths.</p>

<p style="margin-top: 1em">Using modules in build
scripts</p>

<p style="margin-top: 1em">You may pull modules into each
Conscript file using the normal Perl &lsquo;use&rsquo; or
&lsquo;require&rsquo; statements:</p>

<p style="margin-top: 1em">use English; <br>
require My::Module;</p>

<p style="margin-top: 1em">Each &lsquo;use&rsquo; or
&lsquo;require&rsquo; only affects the one Conscript file in
which it appears. To use a module in multiple Conscript
files, you must put a &lsquo;use&rsquo; or
&lsquo;require&rsquo; statement in each <br>
one that needs the module.</p>

<p style="margin-top: 1em">Scope of variables</p>

<p style="margin-top: 1em">The top-level Construct file and
all Conscript files begin life in a common, separate Perl
package. Cons controls the symbol table for the package so
that, the symbol table for <br>
each script is empty, except for the Construct file, which
gets some of the command line arguments. All of the
variables that are set or used, therefore, are set by the
script <br>
itself--not by some external script.</p>

<p style="margin-top: 1em">Variables can be explicitly
imported by a script from its parent script. To import a
variable, it must have been exported by the parent and
initialized (otherwise an error will <br>
occur).</p>

<p style="margin-top: 1em">The Export command</p>

<p style="margin-top: 1em">The &lsquo;Export&rsquo; command
is used as in the following example:</p>

<p style="margin-top: 1em">$env = new cons(); <br>
$INCLUDE = &quot;#export/include&quot;; <br>
$LIB = &quot;#export/lib&quot;; <br>
Export qw( env INCLUDE LIB ); <br>
Build qw( util/Conscript );</p>

<p style="margin-top: 1em">The values of the simple
variables mentioned in the &lsquo;Export&rsquo; list will be
squirreled away by any subsequent &lsquo;Build&rsquo;
commands. The &lsquo;Export&rsquo; command will only export
Perl scalar <br>
variables, that is, variables whose name begins with
&lsquo;$&rsquo;. Other variables, objects, etc. can be
exported by reference--but all scripts will refer to the
same object, and this <br>
object should be considered to be read-only by the
subsidiary scripts and by the original exporting script.
It&rsquo;s acceptable, however, to assign a new value to the
exported scalar <br>
variable--that won&rsquo;t change the underlying variable
referenced. This sequence, for example, is OK:</p>

<p style="margin-top: 1em">$env = new cons(); <br>
Export qw( env INCLUDE LIB ); <br>
Build qw( util/Conscript ); <br>
$env = new cons(CFLAGS =&gt; &rsquo;-O&rsquo;); <br>
Build qw( other/Conscript );</p>

<p style="margin-top: 1em">It doesn&rsquo;t matter whether
the variable is set before or after the &lsquo;Export&rsquo;
command. The important thing is the value of the variable at
the time the &lsquo;Build&rsquo; command is executed. <br>
This is what gets squirreled away. Any subsequent
&lsquo;Export&rsquo; commands, by the way, invalidate the
first: you must mention all the variables you wish to export
on each &lsquo;Export&rsquo; com&acirc; <br>
mand.</p>

<p style="margin-top: 1em">The Import command</p>

<p style="margin-top: 1em">Variables exported by the
&lsquo;Export&rsquo; command can be imported into subsidiary
scripts by the &lsquo;Import&rsquo; command. The subsidiary
script always imports variables directly from the
supe&acirc; <br>
rior script. Consider this example:</p>

<p style="margin-top: 1em">Import qw( env INCLUDE );</p>

<p style="margin-top: 1em">This is only legal if the parent
script exported both &lsquo;$env&rsquo; and
&lsquo;$INCLUDE&rsquo;. It also must have given each of
these variables values. It is OK for the subsidiary script
to only <br>
import a subset of the exported variables (in this example,
&lsquo;$LIB&rsquo;, which was exported by the previous
example, is not imported).</p>

<p style="margin-top: 1em">All the imported variables are
automatically re-exported, so the sequence:</p>

<p style="margin-top: 1em">Import qw ( env INCLUDE ); <br>
Build qw ( beneath-me/Conscript );</p>

<p style="margin-top: 1em">will supply both
&lsquo;$env&rsquo; and &lsquo;$INCLUDE&rsquo; to the
subsidiary file. If only &lsquo;$env&rsquo; is to be
exported, then the following will suffice:</p>

<p style="margin-top: 1em">Import qw ( env INCLUDE ); <br>
Export qw ( env ); <br>
Build qw ( beneath-me/Conscript );</p>

<p style="margin-top: 1em">Needless to say, the variables
may be modified locally before invoking &lsquo;Build&rsquo;
on the subsidiary script.</p>

<p style="margin-top: 1em">Build script evaluation
order</p>

<p style="margin-top: 1em">The only constraint on the
ordering of build scripts is that superior scripts are
evaluated before their inferior scripts. The top-level
Construct file, for instance, is evalu&acirc; <br>
ated first, followed by any inferior scripts. This is all
you really need to know about the evaluation order, since
order is generally irrelevant. Consider the following
&lsquo;Build&rsquo; <br>
command:</p>

<p style="margin-top: 1em">Build qw( <br>
drivers/display/Conscript <br>
drivers/mouse/Conscript <br>
parser/Conscript <br>
utilities/Conscript <br>
);</p>

<p style="margin-top: 1em">We&rsquo;ve chosen to put the
script names in alphabetical order, simply because
that&rsquo;s the most convenient for maintenance purposes.
Changing the order will make no difference to the <br>
build.</p>

<p style="margin-top: 1em">A Model for sharing files <br>
Some simple conventions</p>

<p style="margin-top: 1em">In any complex software system,
a method for sharing build products needs to be established.
We propose a simple set of conventions which are trivial to
implement with Cons, but <br>
very effective.</p>

<p style="margin-top: 1em">The basic rule is to require
that all build products which need to be shared between
directories are shared via an intermediate directory. We
have typically called this export, <br>
and, in a C environment, provided conventional
sub-directories of this directory, such as include, lib,
bin, etc.</p>

<p style="margin-top: 1em">These directories are defined by
the top-level Construct file. A simple Construct file for a
Hello, World! application, organized using multiple
directories, might look like <br>
this:</p>

<p style="margin-top: 1em"># Construct file for Hello,
World!</p>

<p style="margin-top: 1em"># Where to put all our shared
products. <br>
$EXPORT = &rsquo;#export&rsquo;;</p>

<p style="margin-top: 1em">Export qw( CONS INCLUDE LIB BIN
);</p>

<p style="margin-top: 1em"># Standard directories for
sharing products. <br>
$INCLUDE = &quot;$EXPORT/include&quot;; <br>
$LIB = &quot;$EXPORT/lib&quot;; <br>
$BIN = &quot;$EXPORT/bin&quot;;</p>

<p style="margin-top: 1em"># A standard construction
environment. <br>
$CONS = new cons ( <br>
CPPPATH =&gt; $INCLUDE, # Include path for C Compilations
<br>
LIBPATH =&gt; $LIB, # Library path for linking programs <br>
LIBS =&gt; &rsquo;-lworld&rsquo;, # List of standard
libraries <br>
);</p>

<p style="margin-top: 1em">Build qw( <br>
hello/Conscript <br>
world/Conscript <br>
);</p>

<p style="margin-top: 1em">The world directory&rsquo;s
Conscript file looks like this:</p>

<p style="margin-top: 1em"># Conscript file for directory
world <br>
Import qw( CONS INCLUDE LIB );</p>

<p style="margin-top: 1em"># Install the products of this
directory <br>
Install $CONS $LIB, &rsquo;libworld.a&rsquo;; <br>
Install $CONS $INCLUDE, &rsquo;world.h&rsquo;;</p>

<p style="margin-top: 1em"># Internal products <br>
Library $CONS &rsquo;libworld.a&rsquo;,
&rsquo;world.c&rsquo;;</p>

<p style="margin-top: 1em">and the hello directory&rsquo;s
Conscript file looks like this:</p>

<p style="margin-top: 1em"># Conscript file for directory
hello <br>
Import qw( CONS BIN );</p>

<p style="margin-top: 1em"># Exported products <br>
Install $CONS $BIN, &rsquo;hello&rsquo;;</p>

<p style="margin-top: 1em"># Internal products <br>
Program $CONS &rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;;</p>

<p style="margin-top: 1em">To construct a Hello, World!
program with this directory structure, go to the top-level
directory, and invoke &lsquo;cons&rsquo; with the
appropriate arguments. In the following example, we <br>
tell Cons to build the directory export. To build a
directory, Cons recursively builds all known products within
that directory (only if they need rebuilding, of course). If
any <br>
of those products depend upon other products in other
directories, then those will be built, too.</p>

<p style="margin-top: 1em">% cons export <br>
Install world/world.h as export/include/world.h <br>
cc -Iexport/include -c hello/hello.c -o hello/hello.o <br>
cc -Iexport/include -c world/world.c -o world/world.o <br>
ar r world/libworld.a world/world.o <br>
ar: creating world/libworld.a <br>
ranlib world/libworld.a <br>
Install world/libworld.a as export/lib/libworld.a <br>
cc -o hello/hello hello/hello.o -Lexport/lib -lworld <br>
Install hello/hello as export/bin/hello</p>

<p style="margin-top: 1em">Clean, understandable,
location-independent scripts</p>

<p style="margin-top: 1em">You&rsquo;ll note that the two
Conscript files are very clean and to-the-point. They simply
specify products of the directory and how to build those
products. The build instructions <br>
are minimal: they specify which construction environment to
use, the name of the product, and the name of the inputs.
Note also that the scripts are location-independent: if you
<br>
wish to reorganize your source tree, you are free to do so:
you only have to change the Construct file (in this
example), to specify the new locations of the Conscript
files. The <br>
use of an export tree makes this goal easy.</p>

<p style="margin-top: 1em">Note, too, how Cons takes care
of little details for you. All the export directories, for
example, were made automatically. And the installed files
were really hard-linked into <br>
the respective export directories, to save space and time.
This attention to detail saves considerable work, and makes
it even easier to produce simple, maintainable scripts.</p>

<p style="margin-top: 1em">Separating source and build
trees <br>
It&rsquo;s often desirable to keep any derived files from
the build completely separate from the source files. This
makes it much easier to keep track of just what is a source
file, <br>
and also makes it simpler to handle variant builds,
especially if you want the variant builds to co-exist.</p>

<p style="margin-top: 1em">Separating build and source
directories using the Link command</p>

<p style="margin-top: 1em">Cons provides a simple mechanism
that handles all of these requirements. The
&lsquo;Link&rsquo; command is invoked as in this
example:</p>

<p style="margin-top: 1em">Link &rsquo;build&rsquo; =&gt;
&rsquo;src&rsquo;;</p>

<p style="margin-top: 1em">The specified directories are
&lsquo;&lsquo;linked&rsquo;&rsquo; to the specified source
directory. Let&rsquo;s suppose that you setup a source
directory, src, with the sub-directories world and hello
below <br>
it, as in the previous example. You could then substitute
for the original build lines the following:</p>

<p style="margin-top: 1em">Build qw( <br>
build/world/Conscript <br>
build/hello/Conscript <br>
);</p>

<p style="margin-top: 1em">Notice that you treat the
Conscript file as if it existed in the build directory. Now
if you type the same command as before, you will get the
following results:</p>

<p style="margin-top: 1em">% cons export <br>
Install build/world/world.h as export/include/world.h <br>
cc -Iexport/include -c build/hello/hello.c -o
build/hello/hello.o <br>
cc -Iexport/include -c build/world/world.c -o
build/world/world.o <br>
ar r build/world/libworld.a build/world/world.o <br>
ar: creating build/world/libworld.a <br>
ranlib build/world/libworld.a <br>
Install build/world/libworld.a as export/lib/libworld.a <br>
cc -o build/hello/hello build/hello/hello.o -Lexport/lib
-lworld <br>
Install build/hello/hello as export/bin/hello</p>

<p style="margin-top: 1em">Again, Cons has taken care of
the details for you. In particular, you will notice that all
the builds are done using source files and object files from
the build directory. For <br>
example, build/world/world.o is compiled from
build/world/world.c, and export/include/world.h is installed
from build/world/world.h. This is accomplished on most
systems by the <br>
simple expedient of &lsquo;&lsquo;hard&rsquo;&rsquo; linking
the required files from each source directory into the
appropriate build directory.</p>

<p style="margin-top: 1em">The links are maintained
correctly by Cons, no matter what you do to the source
directory. If you modify a source file, your editor may do
this &lsquo;&lsquo;in place&rsquo;&rsquo; or it may rename
it <br>
first and create a new file. In the latter case, any hard
link will be lost. Cons will detect this condition the next
time the source file is needed, and will relink it
appropri&acirc; <br>
ately.</p>

<p style="margin-top: 1em">You&rsquo;ll also notice, by the
way, that no changes were required to the underlying
Conscript files. And we can go further, as we shall see in
the next section.</p>

<p style="margin-top: 1em">Variant builds <br>
Hello, World! for baNaNa and peAcH OS&rsquo;s</p>

<p style="margin-top: 1em">Variant builds require just
another simple extension. Let&rsquo;s take as an example a
requirement to allow builds for both the baNaNa and peAcH
operating systems. In this case, we are <br>
using a distributed file system, such as NFS to access the
particular system, and only one or the other of the systems
has to be compiled for any given invocation of
&lsquo;cons&rsquo;. <br>
Here&rsquo;s one way we could set up the Construct file for
our Hello, World! application:</p>

<p style="margin-top: 1em"># Construct file for Hello,
World!</p>

<p style="margin-top: 1em">die qq(OS must be specified)
unless $OS = $ARG{OS}; <br>
die qq(OS must be &quot;peach&quot; or &quot;banana&quot;)
<br>
if $OS ne &quot;peach&quot; &amp;&amp; $OS ne
&quot;banana&quot;;</p>

<p style="margin-top: 1em"># Where to put all our shared
products. <br>
$EXPORT = &quot;#export/$OS&quot;;</p>

<p style="margin-top: 1em">Export qw( CONS INCLUDE LIB BIN
);</p>

<p style="margin-top: 1em"># Standard directories for
sharing products. <br>
$INCLUDE = &quot;$EXPORT/include&quot;; <br>
$LIB = &quot;$EXPORT/lib&quot;; <br>
$BIN = &quot;$EXPORT/bin&quot;;</p>

<p style="margin-top: 1em"># A standard construction
environment. <br>
$CONS = new cons ( <br>
CPPPATH =&gt; $INCLUDE, # Include path for C Compilations
<br>
LIBPATH =&gt; $LIB, # Library path for linking programs <br>
LIBS =&gt; &rsquo;-lworld&rsquo;, # List of standard
libraries <br>
);</p>

<p style="margin-top: 1em"># $BUILD is where we will derive
everything. <br>
$BUILD = &quot;#build/$OS&quot;;</p>

<p style="margin-top: 1em"># Tell cons where the source
files for $BUILD are. <br>
Link $BUILD =&gt; &rsquo;src&rsquo;;</p>

<p style="margin-top: 1em">Build ( <br>
&quot;$BUILD/hello/Conscript&quot;, <br>
&quot;$BUILD/world/Conscript&quot;, <br>
);</p>

<p style="margin-top: 1em">Now if we login to a peAcH
system, we can build our Hello, World! application for that
platform:</p>

<p style="margin-top: 1em">% cons export OS=peach <br>
Install build/peach/world/world.h as
export/peach/include/world.h <br>
cc -Iexport/peach/include -c build/peach/hello/hello.c -o
build/peach/hello/hello.o <br>
cc -Iexport/peach/include -c build/peach/world/world.c -o
build/peach/world/world.o <br>
ar r build/peach/world/libworld.a build/peach/world/world.o
<br>
ar: creating build/peach/world/libworld.a <br>
ranlib build/peach/world/libworld.a <br>
Install build/peach/world/libworld.a as
export/peach/lib/libworld.a <br>
cc -o build/peach/hello/hello build/peach/hello/hello.o
-Lexport/peach/lib -lworld <br>
Install build/peach/hello/hello as
export/peach/bin/hello</p>

<p style="margin-top: 1em">Variations on a theme</p>

<p style="margin-top: 1em">Other variations of this model
are possible. For example, you might decide that you want to
separate out your include files into platform dependent and
platform independent <br>
files. In this case, you&rsquo;d have to define an
alternative to &lsquo;$INCLUDE&rsquo; for platform-dependent
files. Most Conscript files, generating purely
platform-independent include files, <br>
would not have to change.</p>

<p style="margin-top: 1em">You might also want to be able
to compile your whole system with debugging or profiling,
for example, enabled. You could do this with appropriate
command line options, such as <br>
&lsquo;DEBUG=on&rsquo;. This would then be translated into
the appropriate platform-specific requirements to enable
debugging (this might include turning off optimization, for
example). You <br>
could optionally vary the name space for these different
types of systems, but, as we&rsquo;ll see in the next
section, it&rsquo;s not essential to do this, since Cons is
pretty smart about <br>
rebuilding things when you change options.</p>

<p style="margin-top: 1em">Signatures <br>
MD5 cryptographic signatures</p>

<p style="margin-top: 1em">Whenever Cons creates a derived
file, it stores a signature for that file. The signature is
stored in a separate file, one per directory. After the
previous example was compiled, <br>
the .consign file in the build/peach/world directory looked
like this:</p>

<p style="margin-top: 1em">world.o:834179303
23844c0b102ecdc0b4548d1cd1cbd8c6 <br>
libworld.a:834179304 9bf6587fa06ec49d864811a105222c00</p>

<p style="margin-top: 1em">The first number is a
timestamp--for a UNIX systems, this is typically the number
of seconds since January 1st, 1970. The second value is an
MD5 checksum. The Message Digest <br>
Algorithm is an algorithm that, given an input string,
computes a strong cryptographic signature for that string.
The MD5 checksum stored in the .consign file is, in effect,
a <br>
digest of all the dependency information for the specified
file. So, for example, for the world.o file, this includes
at least the world.c file, and also any header files that
<br>
Cons knows about that are included, directly or indirectly
by world.c. Not only that, but the actual command line that
was used to generate world.o is also fed into the
computa&acirc; <br>
tion of the signature. Similarly, libworld.a gets a
signature which &lsquo;&lsquo;includes&rsquo;&rsquo; all the
signatures of its constituents (and hence, transitively, the
signatures of their con&acirc; <br>
stituents), as well as the command line that created the
file.</p>

<p style="margin-top: 1em">The signature of a non-derived
file is computed, by default, by taking the current
modification time of the file and the file&rsquo;s entry
name (unless there happens to be a current <br>
.consign entry for that file, in which case that signature
is used).</p>

<p style="margin-top: 1em">Notice that there is no need for
a derived file to depend upon any particular Construct or
Conscript file--if changes to these files affect the file in
question, then this will <br>
be automatically reflected in its signature, since relevant
parts of the command line are included in the signature.
Unrelated changes will have no effect.</p>

<p style="margin-top: 1em">When Cons considers whether to
derive a particular file, then, it first computes the
expected signature of the file. It then compares the
file&rsquo;s last modification time with the <br>
time recorded in the .consign entry, if one exists. If these
times match, then the signature stored in the .consign file
is considered to be accurate. If the file&rsquo;s previous
sig&acirc; <br>
nature does not match the new, expected signature, then the
file must be rederived.</p>

<p style="margin-top: 1em">Notice that a file will be
rederived whenever anything about a dependent file changes.
In particular, notice that any change to the modification
time of a dependent (forward or <br>
backwards in time) will force recompilation of the derived
file.</p>

<p style="margin-top: 1em">The use of these signatures is
an extremely simple, efficient, and effective method of
improving--dramatically--the reproducibility of a
system.</p>

<p style="margin-top: 1em">We&rsquo;ll demonstrate this
with a simple example:</p>

<p style="margin-top: 1em"># Simple &quot;Hello,
World!&quot; Construct file <br>
$CFLAGS = &rsquo;-g&rsquo; if $ARG{DEBUG} eq
&rsquo;on&rsquo;; <br>
$CONS = new cons(CFLAGS =&gt; $CFLAGS); <br>
Program $CONS &rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;;</p>

<p style="margin-top: 1em">Notice how Cons recompiles at
the appropriate times:</p>

<p style="margin-top: 1em">% cons hello <br>
cc -c hello.c -o hello.o <br>
cc -o hello hello.o <br>
% cons hello <br>
cons: &quot;hello&quot; is up-to-date. <br>
% cons DEBUG=on hello <br>
cc -g -c hello.c -o hello.o <br>
cc -o hello hello.o <br>
% cons DEBUG=on hello <br>
cons: &quot;hello&quot; is up-to-date. <br>
% cons hello <br>
cc -c hello.c -o hello.o <br>
cc -o hello hello.o</p>

<p style="margin-top: 1em">Code Repositories <br>
Many software development organizations will have one or
more central repository directory trees containing the
current source code for one or more projects, as well as the
<br>
derived object files, libraries, and executables. In order
to reduce unnecessary recompilation, it is useful to use
files from the repository to build development soft&acirc;
<br>
ware--assuming, of course, that no newer dependency file
exists in the local build tree.</p>

<p style="margin-top: 1em">Repository</p>

<p style="margin-top: 1em">Cons provides a mechanism to
specify a list of code repositories that will be searched,
in-order, for source files and derived files not found in
the local build directory tree.</p>

<p style="margin-top: 1em">The following lines in a
Construct file will instruct Cons to look first under the
/usr/experiment/repository directory and then under the
/usr/product/repository directory:</p>

<p style="margin-top: 1em">Repository qw ( <br>
/usr/experiment/repository <br>
/usr/product/repository <br>
);</p>

<p style="margin-top: 1em">The repository directories
specified may contain source files, derived files (objects,
libraries and executables), or both. If there is no local
file (source or derived) under <br>
the directory in which Cons is executed, then the first copy
of a same-named file found under a repository directory will
be used to build any local derived files.</p>

<p style="margin-top: 1em">Cons maintains one global list
of repositories directories. Cons will eliminate the current
directory, and any non-existent directories, from the
list.</p>

<p style="margin-top: 1em">Finding the Construct file in a
Repository</p>

<p style="margin-top: 1em">Cons will also search for
Construct and Conscript files in the repository tree or
trees. This leads to a chicken-and-egg situation, though:
how do you look in a repository tree <br>
for a Construct file if the Construct file tells you where
the repository is? To get around this, repositories may be
specified via &lsquo;-R&rsquo; options on the command
line:</p>

<p style="margin-top: 1em">% cons -R
/usr/experiment/repository -R /usr/product/repository .</p>

<p style="margin-top: 1em">Any repository directories
specified in the Construct or Conscript files will be
appended to the repository directories specified by
command-line &lsquo;-R&rsquo; options.</p>

<p style="margin-top: 1em">Repository source files</p>

<p style="margin-top: 1em">If the source code (include the
Conscript file) for the library version of the Hello, World!
C application is in a repository (with no derived files),
Cons will use the reposi&acirc; <br>
tory source files to create the local object files and
executable file:</p>

<p style="margin-top: 1em">% cons -R
/usr/src_only/repository hello <br>
gcc -c /usr/src_only/repository/hello.c -o hello.o <br>
gcc -c /usr/src_only/repository/world.c -o world.o <br>
ar r libworld.a world.o <br>
ar: creating libworld.a <br>
ranlib libworld.a <br>
gcc -o hello hello.o libworld.a</p>

<p style="margin-top: 1em">Creating a local source file
will cause Cons to rebuild the appropriate derived file or
files:</p>

<p style="margin-top: 1em">% pico world.c <br>
[EDIT] <br>
% cons -R /usr/src_only/repository hello <br>
gcc -c world.c -o world.o <br>
ar r libworld.a world.o <br>
ar: creating libworld.a <br>
ranlib libworld.a <br>
gcc -o hello hello.o libworld.a</p>

<p style="margin-top: 1em">And removing the local source
file will cause Cons to revert back to building the derived
files from the repository source:</p>

<p style="margin-top: 1em">% rm world.c <br>
% cons -R /usr/src_only/repository hello <br>
gcc -c /usr/src_only/repository/world.c -o world.o <br>
ar r libworld.a world.o <br>
ar: creating libworld.a <br>
ranlib libworld.a <br>
gcc -o hello hello.o libworld.a</p>

<p style="margin-top: 1em">Repository derived files</p>

<p style="margin-top: 1em">If a repository tree contains
derived files (usually object files, libraries, or
executables), Cons will perform its normal signature
calculation to decide whether the repository <br>
file is up-to-date or a derived file must be built locally.
This means that, in order to ensure correct signature
calculation, a repository tree must also contain the
.consign <br>
files that were created by Cons when generating the derived
files.</p>

<p style="margin-top: 1em">This would usually be
accomplished by building the software in the repository (or,
alternatively, in a build directory, and then copying the
result to the repository):</p>

<p style="margin-top: 1em">% cd /usr/all/repository <br>
% cons hello <br>
gcc -c hello.c -o hello.o <br>
gcc -c world.c -o world.o <br>
ar r libworld.a world.o <br>
ar: creating libworld.a <br>
ranlib libworld.a <br>
gcc -o hello hello.o libworld.a</p>

<p style="margin-top: 1em">(This is safe even if the
Construct file lists the /usr/all/repository directory in a
&lsquo;Repository&rsquo; command because Cons will remove
the current directory from the repository <br>
list.)</p>

<p style="margin-top: 1em">Now if we want to build a copy
of the application with our own hello.c file, we only need
to create the one necessary source file, and use the
&lsquo;-R&rsquo; option to have Cons use other <br>
files from the repository:</p>

<p style="margin-top: 1em">% mkdir $HOME/build1 <br>
% cd $HOME/build1 <br>
% ed hello.c <br>
[EDIT] <br>
% cons -R /usr/all/repository hello <br>
gcc -c hello.c -o hello.o <br>
gcc -o hello hello.o /usr/all/repository/libworld.a</p>

<p style="margin-top: 1em">Notice that Cons has not
bothered to recreate a local libworld.a library (or
recompile the world.o module), but instead uses the
already-compiled version from the repository.</p>

<p style="margin-top: 1em">Because the MD5 signatures that
Cons puts in the .consign file contain timestamps for the
derived files, the signature timestamps must match the file
timestamps for a signature <br>
to be considered valid.</p>

<p style="margin-top: 1em">Some software systems may alter
the timestamps on repository files (by copying them, e.g.),
in which case Cons will, by default, assume the repository
signatures are invalid and <br>
rebuild files unnecessarily. This behavior may be altered by
specifying:</p>

<p style="margin-top: 1em">Repository_Sig_Times_OK 0;</p>

<p style="margin-top: 1em">This tells Cons to ignore
timestamps when deciding whether a signature is valid. (Note
that avoiding this sanity check means there must be proper
control over the repository <br>
tree to ensure that the derived files cannot be modified
without updating the .consign signature.)</p>

<p style="margin-top: 1em">Local copies of files</p>

<p style="margin-top: 1em">If the repository tree contains
the complete results of a build, and we try to build from
the repository without any files in our local tree,
something moderately surprising hap&acirc; <br>
pens:</p>

<p style="margin-top: 1em">% mkdir $HOME/build2 <br>
% cd $HOME/build2 <br>
% cons -R /usr/all/repository hello <br>
cons: &quot;hello&quot; is up-to-date.</p>

<p style="margin-top: 1em">Why does Cons say that the hello
program is up-to-date when there is no hello program in the
local build directory? Because the repository (not the local
directory) contains the <br>
up-to-date hello program, and Cons correctly determines that
nothing needs to be done to rebuild this up-to-date copy of
the file.</p>

<p style="margin-top: 1em">There are, however, many times
in which it is appropriate to ensure that a local copy of a
file always exists. A packaging or testing script, for
example, may assume that cer&acirc; <br>
tain generated files exist locally. Instead of making these
subsidiary scripts aware of the repository directory, the
&lsquo;Local&rsquo; command may be added to a Construct or
Conscript <br>
file to specify that a certain file or files must appear in
the local build directory:</p>

<p style="margin-top: 1em">Local qw( <br>
hello <br>
);</p>

<p style="margin-top: 1em">Then, if we re-run the same
command, Cons will make a local copy of the program from the
repository copy (telling you that it is doing so):</p>

<p style="margin-top: 1em">% cons -R /usr/all/repository
hello <br>
Local copy of hello from /usr/all/repository/hello <br>
cons: &quot;hello&quot; is up-to-date.</p>

<p style="margin-top: 1em">Notice that, because the act of
making the local copy is not considered a &quot;build&quot;
of the hello file, Cons still reports that it is
up-to-date.</p>

<p style="margin-top: 1em">Creating local copies is most
useful for files that are being installed into an
intermediate directory (for sharing with other directories)
via the &lsquo;Install&rsquo; command. Accompany&acirc; <br>
ing the &lsquo;Install&rsquo; command for a file with a
companion &lsquo;Local&rsquo; command is so common that Cons
provides a &lsquo;Install_Local&rsquo; command as a
convenient way to do both:</p>

<p style="margin-top: 1em">Install_Local $env,
&rsquo;#export&rsquo;, &rsquo;hello&rsquo;;</p>

<p style="margin-top: 1em">is exactly equivalent to:</p>

<p style="margin-top: 1em">Install $env
&rsquo;#export&rsquo;, &rsquo;hello&rsquo;; <br>
Local &rsquo;#export/hello&rsquo;;</p>

<p style="margin-top: 1em">Both the &lsquo;Local&rsquo; and
&lsquo;Install_Local&rsquo; commands update the local
.consign file with the appropriate file signatures, so that
future builds are performed correctly.</p>

<p style="margin-top: 1em">Repository dependency
analysis</p>

<p style="margin-top: 1em">Due to its built-in scanning,
Cons will search the specified repository trees for included
.h files. Unless the compiler also knows about the
repository trees, though, it will <br>
be unable to find .h files that only exist in a repository.
If, for example, the hello.c file includes the hello.h file
in its current directory:</p>

<p style="margin-top: 1em">% cons -R /usr/all/repository
hello <br>
gcc -c /usr/all/repository/hello.c -o hello.o <br>
/usr/all/repository/hello.c:1: hello.h: No such file or
directory</p>

<p style="margin-top: 1em">Solving this problem forces some
requirements onto the way construction environments are
defined and onto the way the C &lsquo;#include&rsquo;
preprocessor directive is used to include <br>
files.</p>

<p style="margin-top: 1em">In order to inform the compiler
about the repository trees, Cons will add appropriate
&lsquo;-I&rsquo; flags to the compilation commands. This
means that the &lsquo;CPPPATH&rsquo; variable in the
con&acirc; <br>
struct environment must explicitly specify all
subdirectories which are to be searched for included files,
including the current directory. Consequently, we can fix
the above <br>
example by changing the environment creation in the
Construct file as follows:</p>

<p style="margin-top: 1em">$env = new cons( <br>
CC =&gt; &rsquo;gcc&rsquo;, <br>
CPPPATH =&gt; &rsquo;.&rsquo;, <br>
LIBS =&gt; &rsquo;libworld.a&rsquo;, <br>
);</p>

<p style="margin-top: 1em">Due to the definition of the
&lsquo;CPPPATH&rsquo; variable, this yields, when we
re-execute the command:</p>

<p style="margin-top: 1em">% cons -R /usr/all/repository
hello <br>
gcc -c -I. -I/usr/all/repository /usr/all/repository/hello.c
-o hello.o <br>
gcc -o hello hello.o /usr/all/repository/libworld.a</p>

<p style="margin-top: 1em">The order of the
&lsquo;-I&rsquo; flags replicates, for the C preprocessor,
the same repository-directory search path that Cons uses for
its own dependency analysis. If there are multiple <br>
repositories and multiple &lsquo;CPPPATH&rsquo; directories,
Cons will append the repository directories to the beginning
of each &lsquo;CPPPATH&rsquo; directory, rapidly multiplying
the number of &lsquo;-I&rsquo; <br>
flags. As an extreme example, a Construct file
containing:</p>

<p style="margin-top: 1em">Repository qw( <br>
/u1 <br>
/u2 <br>
);</p>

<p style="margin-top: 1em">$env = new cons( <br>
CPPPATH =&gt; &rsquo;a:b:c&rsquo;, <br>
);</p>

<p style="margin-top: 1em">Would yield a compilation
command of:</p>

<p style="margin-top: 1em">cc -Ia -I/u1/a -I/u2/a -Ib
-I/u1/b -I/u2/b -Ic -I/u1/c -I/u2/c -c hello.c -o
hello.o</p>

<p style="margin-top: 1em">Because Cons relies on the
compiler&rsquo;s &lsquo;-I&rsquo; flags to communicate the
order in which repository directories must be searched,
Cons&rsquo; handling of repository directories is
fundamen&acirc; <br>
tally incompatible with using double-quotes on the
&lsquo;#include&rsquo; directives in your C source code:</p>

<p style="margin-top: 1em">#include &quot;file.h&quot; /*
DON&rsquo;T USE DOUBLE-QUOTES LIKE THIS */</p>

<p style="margin-top: 1em">This is because most C
preprocessors, when faced with such a directive, will always
first search the directory containing the source file. This
undermines the elaborate &lsquo;-I&rsquo; <br>
options that Cons constructs to make the preprocessor
conform to its preferred search path.</p>

<p style="margin-top: 1em">Consequently, when using
repository trees in Cons, always use angle-brackets for
included files:</p>

<p style="margin-top: 1em">#include &lt;file.h&gt; /* USE
ANGLE-BRACKETS INSTEAD */</p>

<p style="margin-top: 1em">Repository_List</p>

<p style="margin-top: 1em">Cons provides a
&lsquo;Repository_List&rsquo; command to return a list of
all repository directories in their current search order.
This can be used for debugging, or to do more complex <br>
Perl stuff:</p>

<p style="margin-top: 1em">@list = Repository_List; <br>
print join(&rsquo; &rsquo;, @list), &quot;0;</p>

<p style="margin-top: 1em">Repository interaction with
other Cons features</p>

<p style="margin-top: 1em">Cons&rsquo; handling of
repository trees interacts correctly with other Cons
features--which is to say, it generally does what you would
expect.</p>

<p style="margin-top: 1em">Most notably, repository trees
interact correctly, and rather powerfully, with the
&rsquo;Link&rsquo; command. A repository tree may contain
one or more subdirectories for version builds <br>
established via &lsquo;Link&rsquo; to a source subdirectory.
Cons will search for derived files in the appropriate build
subdirectories under the repository tree.</p>

<p style="margin-top: 1em">Default targets <br>
Until now, we&rsquo;ve demonstrated invoking Cons with an
explicit target to build:</p>

<p style="margin-top: 1em">% cons hello</p>

<p style="margin-top: 1em">Normally, Cons does not build
anything unless a target is specified, but specifying
&rsquo;.&rsquo; (the current directory) will build
everything:</p>

<p style="margin-top: 1em">% cons # does not build
anything</p>

<p style="margin-top: 1em">% cons . # builds everything
under the top-level directory</p>

<p style="margin-top: 1em">Adding the &lsquo;Default&rsquo;
method to any Construct or Conscript file will add the
specified targets to a list of default targets. Cons will
build these defaults if there are no tar&acirc; <br>
gets specified on the command line. So adding the following
line to the top-level Construct file will mimic Make&rsquo;s
typical behavior of building everything by default:</p>

<p style="margin-top: 1em">Default &rsquo;.&rsquo;;</p>

<p style="margin-top: 1em">The following would add the
hello and goodbye commands (in the same directory as the
Construct or Conscript file) to the default list:</p>

<p style="margin-top: 1em">Default qw( <br>
hello <br>
goodbye <br>
);</p>

<p style="margin-top: 1em">The &lsquo;Default&rsquo; method
may be used more than once to add targets to the default
list.</p>

<p style="margin-top: 1em">Selective builds <br>
Cons provides two methods for reducing the size of given
build. The first is by specifying targets on the command
line, and the second is a method for pruning the build tree.
<br>
We&rsquo;ll consider target specification first.</p>

<p style="margin-top: 1em">Selective targeting</p>

<p style="margin-top: 1em">Like make, Cons allows the
specification of &lsquo;&lsquo;targets&rsquo;&rsquo; on the
command line. Cons targets may be either files or
directories. When a directory is specified, this is simply a
<br>
short-hand notation for every derivable product--that Cons
knows about--in the specified directory and below. For
example:</p>

<p style="margin-top: 1em">% cons build/hello/hello.o</p>

<p style="margin-top: 1em">means build hello.o and
everything that hello.o might need. This is from a previous
version of the Hello, World! program in which hello.o
depended upon export/include/world.h. If <br>
that file is not up-to-date (because someone modified
src/world/world.h), then it will be rebuilt, even though it
is in a directory remote from build/hello.</p>

<p style="margin-top: 1em">In this example:</p>

<p style="margin-top: 1em">% cons build</p>

<p style="margin-top: 1em">Everything in the build
directory is built, if necessary. Again, this may cause more
files to be built. In particular, both
export/include/world.h and export/lib/libworld.a are <br>
required by the build/hello directory, and so they will be
built if they are out-of-date.</p>

<p style="margin-top: 1em">If we do, instead:</p>

<p style="margin-top: 1em">% cons export</p>

<p style="margin-top: 1em">then only the files that should
be installed in the export directory will be rebuilt, if
necessary, and then installed there. Note that &lsquo;cons
build&rsquo; might build files that &lsquo;cons <br>
export&rsquo; doesn&rsquo;t build, and vice-versa.</p>

<p style="margin-top: 1em">No
&lsquo;&lsquo;special&rsquo;&rsquo; targets</p>

<p style="margin-top: 1em">With Cons, make-style
&lsquo;&lsquo;special&rsquo;&rsquo; targets are not
required. The simplest analog with Cons is to use special
export directories, instead. Let&rsquo;s suppose, for
example, that you have <br>
a whole series of unit tests that are associated with your
code. The tests live in the source directory near the code.
Normally, however, you don&rsquo;t want to build these
tests. One <br>
solution is to provide all the build instructions for
creating the tests, and then to install the tests into a
separate part of the tree. If we install the tests in a
top-level <br>
directory called tests, then:</p>

<p style="margin-top: 1em">% cons tests</p>

<p style="margin-top: 1em">will build all the tests.</p>

<p style="margin-top: 1em">% cons export</p>

<p style="margin-top: 1em">will build the production
version of the system (but not the tests), and:</p>

<p style="margin-top: 1em">% cons build</p>

<p style="margin-top: 1em">should probably be avoided
(since it will compile tests unecessarily).</p>

<p style="margin-top: 1em">If you want to build just a
single test, then you could explicitly name the test (in
either the tests directory or the build directory). You
could also aggregate the tests into a <br>
convenient hierarchy within the tests directory. This
hierarchy need not necessarily match the source hierarchy,
in much the same manner that the include hierarchy probably
<br>
doesn&rsquo;t match the source hierarchy (the include
hierarchy is unlikely to be more than two levels deep, for C
programs).</p>

<p style="margin-top: 1em">If you want to build absolutely
everything in the tree (subject to whatever options you
select), you can use:</p>

<p style="margin-top: 1em">% cons .</p>

<p style="margin-top: 1em">This is not particularly
efficient, since it will redundantly walk all the trees,
including the source tree. The source tree, of course, may
have buildable objects in it--nothing <br>
stops you from doing this, even if you normally build in a
separate build tree.</p>

<p style="margin-top: 1em">Build Pruning <br>
In conjunction with target selection, build pruning can be
used to reduce the scope of the build. In the previous peAcH
and baNaNa example, we have already seen how script-driven
<br>
build pruning can be used to make only half of the potential
build available for any given invocation of
&lsquo;cons&rsquo;. Cons also provides, as a convenience, a
command line convention <br>
that allows you to specify which Conscript files actually
get &lsquo;&lsquo;built&rsquo;&rsquo;--that is, incorporated
into the build tree. For example:</p>

<p style="margin-top: 1em">% cons build +world</p>

<p style="margin-top: 1em">The &lsquo;+&rsquo; argument
introduces a Perl regular expression. This must, of course,
be quoted at the shell level if there are any shell
meta-characters within the expression. The <br>
expression is matched against each Conscript file which has
been mentioned in a &lsquo;Build&rsquo; statement, and only
those scripts with matching names are actually incorporated
into the <br>
build tree. Multiple such arguments are allowed, in which
case a match against any of them is sufficient to cause a
script to be included.</p>

<p style="margin-top: 1em">In the example, above, the hello
program will not be built, since Cons will have no knowledge
of the script hello/Conscript. The libworld.a archive will
be built, however, if <br>
need be.</p>

<p style="margin-top: 1em">There are a couple of uses for
build pruning via the command line. Perhaps the most useful
is the ability to make local changes, and then, with
sufficient knowledge of the conse&acirc; <br>
quences of those changes, restrict the size of the build
tree in order to speed up the rebuild time. A second use for
build pruning is to actively prevent the recompilation of
<br>
certain files that you know will recompile due to, for
example, a modified header file. You may know that either
the changes to the header file are immaterial, or that the
<br>
changes may be safely ignored for most of the tree, for
testing purposes.With Cons, the view is that it is pragmatic
to admit this type of behavior, with the understanding that
<br>
on the next full build everything that needs to be rebuilt
will be. There is no equivalent to a &lsquo;&lsquo;make
touch&rsquo;&rsquo; command, to mark files as permanently
up-to-date. So any risk that <br>
is incurred by build pruning is mitigated. For release
quality work, obviously, we recommend that you do not use
build pruning (it&rsquo;s perfectly OK to use during
integration, how&acirc; <br>
ever, for checking compilation, etc. Just be sure to do an
unconstrained build before committing the integration).</p>

<p style="margin-top: 1em">Temporary overrides <br>
Cons provides a very simple mechanism for overriding aspects
of a build. The essence is that you write an override file
containing one or more &lsquo;Override&rsquo; commands, and
you spec&acirc; <br>
ify this on the command line, when you run
&lsquo;cons&rsquo;:</p>

<p style="margin-top: 1em">% cons -o over export</p>

<p style="margin-top: 1em">will build the export directory,
with all derived files subject to the overrides present in
the over file. If you leave out the &lsquo;-o&rsquo; option,
then everything necessary to remove <br>
all overrides will be rebuilt.</p>

<p style="margin-top: 1em">Overriding environment
variables</p>

<p style="margin-top: 1em">The override file can contain
two types of overrides. The first is incoming environment
variables. These are normally accessible by the Construct
file from the &lsquo;%ENV&rsquo; hash vari&acirc; <br>
able. These can trivially be overridden in the override file
by setting the appropriate elements of &lsquo;%ENV&rsquo;
(these could also be overridden in the user&rsquo;s
environment, of course).</p>

<p style="margin-top: 1em">The Override command</p>

<p style="margin-top: 1em">The second type of override is
accomplished with the &lsquo;Override&rsquo; command, which
looks like this:</p>

<p style="margin-top: 1em">Override &lt;regexp&gt;,
&lt;var1&gt; =&gt; &lt;value1&gt;, &lt;var2&gt; =&gt;
&lt;value2&gt;, ...;</p>

<p style="margin-top: 1em">The regular expression regexp is
matched against every derived file that is a candidate for
the build. If the derived file matches, then the
variable/value pairs are used to <br>
override the values in the construction environment
associated with the derived file.</p>

<p style="margin-top: 1em">Let&rsquo;s suppose that we have
a construction environment like this:</p>

<p style="margin-top: 1em">$CONS = new cons( <br>
COPT =&gt; &rsquo;&rsquo;, <br>
CDBG =&gt; &rsquo;-g&rsquo;, <br>
CFLAGS =&gt; &rsquo;%COPT %CDBG&rsquo;, <br>
);</p>

<p style="margin-top: 1em">Then if we have an override file
over containing this command:</p>

<p style="margin-top: 1em">Override &rsquo;.o$&rsquo;, COPT
=&gt; &rsquo;-O&rsquo;, CDBG =&gt; &rsquo;&rsquo;;</p>

<p style="margin-top: 1em">then any &lsquo;cons&rsquo;
invocation with &lsquo;-o over&rsquo; that creates .o files
via this environment will cause them to be compiled with
&lsquo;-O &rsquo;and no &lsquo;-g&rsquo;. The override
could, of course, be <br>
restricted to a single directory by the appropriate
selection of a regular expression.</p>

<p style="margin-top: 1em">Here&rsquo;s the original
version of the Hello, World! program, built with this
environment. Note that Cons rebuilds the appropriate pieces
when the override is applied or removed:</p>

<p style="margin-top: 1em">% cons hello <br>
cc -g -c hello.c -o hello.o <br>
cc -o hello hello.o <br>
% cons -o over hello <br>
cc -O -c hello.c -o hello.o <br>
cc -o hello hello.o <br>
% cons -o over hello <br>
cons: &quot;hello&quot; is up-to-date. <br>
% cons hello <br>
cc -g -c hello.c -o hello.o <br>
cc -o hello hello.o</p>

<p style="margin-top: 1em">It&rsquo;s important that the
&lsquo;Override&rsquo; command only be used for temporary,
on-the-fly overrides necessary for development because the
overrides are not platform independent and <br>
because they rely too much on intimate knowledge of the
workings of the scripts. For temporary use, however, they
are exactly what you want.</p>

<p style="margin-top: 1em">Note that it is still useful to
provide, say, the ability to create a fully optimized
version of a system for production use--from the Construct
and Conscript files. This way you <br>
can tailor the optimized system to the platform. Where
optimizer trade-offs need to be made (particular files may
not be compiled with full optimization, for example), then
these <br>
can be recorded for posterity (and reproducibility) directly
in the scripts.</p>

<p style="margin-top: 1em">More on construction
environments <br>
Default construction variables</p>

<p style="margin-top: 1em">We have mentioned, and used, the
concept of a construction environment, many times in the
preceding pages. Now it&rsquo;s time to make this a little
more concrete. With the following <br>
statement:</p>

<p style="margin-top: 1em">$env = new cons();</p>

<p style="margin-top: 1em">a reference to a new, default
construction environment is created. This contains a number
of construction variables and some methods. At the present
writing, the default list of <br>
construction variables is defined as follows:</p>

<p style="margin-top: 1em">CC =&gt; &rsquo;cc&rsquo;, <br>
CFLAGS =&gt; &rsquo;&rsquo;, <br>
CCCOM =&gt; &rsquo;%CC %CFLAGS %_IFLAGS -c %&lt; -o
%&gt;&rsquo;, <br>
INCDIRPREFIX =&gt; &rsquo;-I&rsquo;, <br>
CXX =&gt; &rsquo;%CC&rsquo;, <br>
CXXFLAGS =&gt; &rsquo;%CFLAGS&rsquo;, <br>
CXXCOM =&gt; &rsquo;%CXX %CXXFLAGS %_IFLAGS -c %&lt; -o
%&gt;&rsquo;, <br>
LINK =&gt; &rsquo;%CXX&rsquo;, <br>
LINKCOM =&gt; &rsquo;%LINK %LDFLAGS -o %&gt; %&lt; %_LDIRS
%LIBS&rsquo;, <br>
LINKMODULECOM =&gt; &rsquo;%LD -r -o %&gt; %&lt;&rsquo;,
<br>
LIBDIRPREFIX =&gt; &rsquo;-L&rsquo;, <br>
AR =&gt; &rsquo;ar&rsquo;, <br>
ARFLAGS =&gt; &rsquo;r&rsquo;, <br>
ARCOM =&gt; &quot;%AR %ARFLAGS %&gt; %&lt;1RANLIB
%&gt;&quot;, <br>
RANLIB =&gt; &rsquo;ranlib&rsquo;, <br>
AS =&gt; &rsquo;as&rsquo;, <br>
ASFLAGS =&gt; &rsquo;&rsquo;, <br>
ASCOM =&gt; &rsquo;%AS %ASFLAGS %&lt; -o %&gt;&rsquo;, <br>
LD =&gt; &rsquo;ld&rsquo;, <br>
LDFLAGS =&gt; &rsquo;&rsquo;, <br>
PREFLIB =&gt; &rsquo;lib&rsquo;, <br>
SUFLIB =&gt; &rsquo;.a&rsquo;, <br>
SUFLIBS =&gt; &rsquo;.so:.a&rsquo;, <br>
SUFOBJ =&gt; &rsquo;.o&rsquo;, <br>
ENV =&gt; { &rsquo;PATH&rsquo; =&gt;
&rsquo;/bin:/usr/bin&rsquo; },</p>

<p style="margin-top: 1em">On Win32 systems (Windows NT),
the following construction variables are overridden in the
default:</p>

<p style="margin-top: 1em">CC =&gt; &rsquo;cl&rsquo;, <br>
CFLAGS =&gt; &rsquo;/nologo&rsquo;, <br>
CCCOM =&gt; &rsquo;%CC %CFLAGS %_IFLAGS /c %&lt;
/Fo%&gt;&rsquo;, <br>
CXXCOM =&gt; &rsquo;%CXX %CXXFLAGS %_IFLAGS /c %&lt;
/Fo%&gt;&rsquo;, <br>
INCDIRPREFIX =&gt; &rsquo;/I&rsquo;, <br>
LINK =&gt; &rsquo;link&rsquo;, <br>
LINKCOM =&gt; &rsquo;%LINK %LDFLAGS /out:%&gt; %&lt; %_LDIRS
%LIBS&rsquo;, <br>
LINKMODULECOM =&gt; &rsquo;%LD /r /o %&gt; %&lt;&rsquo;,
<br>
LIBDIRPREFIX =&gt; &rsquo;/LIBPATH:&rsquo;, <br>
AR =&gt; &rsquo;lib&rsquo;, <br>
ARFLAGS =&gt; &rsquo;/nologo &rsquo;, <br>
ARCOM =&gt; &quot;%AR %ARFLAGS /out:%&gt; %&lt;&quot;, <br>
RANLIB =&gt; &rsquo;&rsquo;, <br>
LD =&gt; &rsquo;link&rsquo;, <br>
LDFLAGS =&gt; &rsquo;/nologo &rsquo;, <br>
PREFLIB =&gt; &rsquo;&rsquo;, <br>
SUFEXE =&gt; &rsquo;.exe&rsquo;, <br>
SUFLIB =&gt; &rsquo;.lib&rsquo;, <br>
SUFLIBS =&gt; &rsquo;.dll:.lib&rsquo;, <br>
SUFOBJ =&gt; &rsquo;.obj&rsquo;,</p>

<p style="margin-top: 1em">These variables are used by the
various methods associated with the environment, in
particular any method that ultimately invokes an external
command will substitute these vari&acirc; <br>
ables into the final command, as appropriate. For example,
the &lsquo;Objects&rsquo; method takes a number of source
files and arranges to derive, if necessary, the
corresponding object <br>
files. For example:</p>

<p style="margin-top: 1em">Objects $env
&rsquo;foo.c&rsquo;, &rsquo;bar.c&rsquo;;</p>

<p style="margin-top: 1em">This will arrange to produce, if
necessary, foo.o and bar.o. The command invoked is simply
&lsquo;%CCCOM&rsquo;, which expands through substitution, to
the appropriate external command <br>
required to build each object. We will explore the
substitution rules further under the &lsquo;Command&rsquo;
method, below.</p>

<p style="margin-top: 1em">The construction variables are
also used for other purposes. For example,
&lsquo;CPPPATH&rsquo; is used to specify a colon-separated
path of include directories. These are intended to be <br>
passed to the C preprocessor and are also used by the C-file
scanning machinery to determine the dependencies involved in
a C Compilation. Variables beginning with underscore, <br>
are created by various methods, and should normally be
considered &lsquo;&lsquo;internal&rsquo;&rsquo; variables.
For example, when a method is called which calls for the
creation of an object from a C <br>
source, the variable &lsquo;_IFLAGS&rsquo; is created: this
corresponds to the &lsquo;-I&rsquo; switches required by the
C compiler to represent the directories specified by
&lsquo;CPPPATH&rsquo;.</p>

<p style="margin-top: 1em">Note that, for any particular
environment, the value of a variable is set once, and then
never reset (to change a variable, you must create a new
environment. Methods are pro&acirc; <br>
vided for copying existing environments for this purpose).
Some internal variables, such as &lsquo;_IFLAGS&rsquo; are
created on demand, but once set, they remain fixed for the
life of the <br>
environment.</p>

<p style="margin-top: 1em">The &lsquo;CFLAGS&rsquo;,
&lsquo;LDFLAGS&rsquo;, and &lsquo;ARFLAGS&rsquo; variables
all supply a place for passing options to the compiler,
loader, and archiver, respectively. Less obviously, the
&lsquo;INCDIRPREFIX&rsquo; <br>
variable specifies the option string to be appended to the
beginning of each include directory so that the compiler
knows where to find .h files. Similarly, the
&lsquo;LIBDIRPREFIX&rsquo; <br>
variable specifies the option string to be appended to the
beginning of each directory that the linker should search
for libraries.</p>

<p style="margin-top: 1em">Another variable,
&lsquo;ENV&rsquo;, is used to determine the system
environment during the execution of an external command. By
default, the only environment variable that is set is
&lsquo;PATH&rsquo;, <br>
which is the execution path for a UNIX command. For the
utmost reproducibility, you should really arrange to set
your own execution path, in your top-level Construct file
(or <br>
perhaps by importing an appropriate construction package
with the Perl &lsquo;use&rsquo; command). The default
variables are intended to get you off the ground.</p>

<p style="margin-top: 1em">Interpolating construction
variables</p>

<p style="margin-top: 1em">Construction environment
variables may be interpolated in the source and target file
names by prefixing the construction variable name with
&lsquo;%&rsquo;.</p>

<p style="margin-top: 1em">$env = new cons( <br>
DESTDIR =&gt; &rsquo;programs&rsquo;, <br>
SRCDIR =&gt; &rsquo;src&rsquo;, <br>
); <br>
Program $env &rsquo;%DESTDIR/hello&rsquo;,
&rsquo;%SRCDIR/hello.c&rsquo;;</p>

<p style="margin-top: 1em">Expansion of construction
variables is recursive--that is, the file name(s) will be
re-expanded until no more substitutions can be made. If a
construction variable is not defined <br>
in the environment, then the null string will be
substituted.</p>

<p style="margin-top: 1em">Default construction methods
<br>
The list of default construction methods includes the
following:</p>

<p style="margin-top: 1em">The &lsquo;new&rsquo;
constructor</p>

<p style="margin-top: 1em">The &lsquo;new&rsquo; method is
a Perl object constructor. That is, it is not invoked via a
reference to an existing construction environment reference,
but, rather statically, using the <br>
name of the Perl package where the constructor is defined.
The method is invoked like this:</p>

<p style="margin-top: 1em">$env = new
cons(&lt;overrides&gt;);</p>

<p style="margin-top: 1em">The environment you get back is
blessed into the package &lsquo;cons&rsquo;, which means
that it will have associated with it the default methods
described below. Individual construction <br>
variables can be overridden by providing name/value pairs in
an override list. Note that to override any command
environment variable (i.e. anything under
&lsquo;ENV&rsquo;), you will have <br>
to override all of them. You can get around this difficulty
by using the &lsquo;copy&rsquo; method on an existing
construction environment.</p>

<p style="margin-top: 1em">The &lsquo;clone&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;clone&rsquo; method
creates a clone of an existing construction environment, and
can be called as in the following example:</p>

<p style="margin-top: 1em">$env2 =
$env1-&gt;clone(&lt;overrides&gt;);</p>

<p style="margin-top: 1em">You can provide overrides in the
usual manner to create a different environment from the
original. If you just want a new name for the same
environment (which may be helpful when <br>
exporting environments to existing components), you can just
use simple assignment.</p>

<p style="margin-top: 1em">The &lsquo;copy&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;copy&rsquo; method
extracts the externally defined construction variables from
an environment and returns them as a list of name/value
pairs. Overrides can also be provided, in <br>
which case, the overridden values will be returned, as
appropriate. The returned list can be assigned to a hash, as
shown in the prototype, below, but it can also be
manipulated <br>
in other ways:</p>

<p style="margin-top: 1em">%env =
$env1-&gt;copy(&lt;overrides&gt;);</p>

<p style="margin-top: 1em">The value of &lsquo;ENV&rsquo;,
which is itself a hash, is also copied to a new hash, so
this may be changed without fear of affecting the original
environment. So, for example, if you <br>
really want to override just the &lsquo;PATH&rsquo; variable
in the default environment, you could do the following:</p>

<p style="margin-top: 1em">%cons = new cons()-&gt;copy();
<br>
$cons{ENV}{PATH} = &quot;&lt;your path here&gt;&quot;; <br>
$cons = new cons(%cons);</p>

<p style="margin-top: 1em">This will leave anything else
that might be in the default execution environment
undisturbed.</p>

<p style="margin-top: 1em">The &lsquo;Install&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Install&rsquo; method
arranges for the specified files to be installed in the
specified directory. The installation is optimized: the file
is not copied if it can be linked. If <br>
this is not the desired behavior, you will need to use a
different method to install the file. It is called as
follows:</p>

<p style="margin-top: 1em">Install $env &lt;directory&gt;,
&lt;names&gt;;</p>

<p style="margin-top: 1em">Note that, while the files to be
installed may be arbitrarily named, only the last component
of each name is used for the installed target name. So, for
example, if you arrange <br>
to install foo/bar in baz, this will create a bar file in
the baz directory (not foo/bar).</p>

<p style="margin-top: 1em">The &lsquo;InstallAs&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;InstallAs&rsquo;
method arranges for the specified source file(s) to be
installed as the specified target file(s). Multiple files
should be specified as a file list. The installa&acirc; <br>
tion is optimized: the file is not copied if it can be
linked. If this is not the desired behavior, you will need
to use a different method to install the file. It is called
as <br>
follows:</p>

<p style="margin-top: 1em">&lsquo;InstallAs&rsquo; works in
two ways:</p>

<p style="margin-top: 1em">Single file install:</p>

<p style="margin-top: 1em">InstallAs $env TgtFile,
SrcFile;</p>

<p style="margin-top: 1em">Multiple file install:</p>

<p style="margin-top: 1em">InstallAs $env
[&rsquo;tgt1&rsquo;, &rsquo;tgt2&rsquo;],
[&rsquo;src1&rsquo;, &rsquo;src2&rsquo;];</p>

<p style="margin-top: 1em">Or, even as:</p>

<p style="margin-top: 1em">@srcs = qw(src1 src2 src3); <br>
@tgts = qw(tgt1 tgt2 tgt3); <br>
InstallAs $env [@tgts], [@srcs];</p>

<p style="margin-top: 1em">Both the target and the sources
lists should be of the same length.</p>

<p style="margin-top: 1em">The &lsquo;Precious&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Precious&rsquo;
method asks cons not to delete the specified file or list of
files before building them again. It is invoked as:</p>

<p style="margin-top: 1em">Precious &lt;files&gt;;</p>

<p style="margin-top: 1em">This is especially useful for
allowing incremental updates to libraries or debug
information files which are updated rather than rebuilt anew
each time. Cons will still delete <br>
the files when the &lsquo;-r&rsquo; flag is specified.</p>

<p style="margin-top: 1em">The &lsquo;Command&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Command&rsquo; method
is a catchall method which can be used to arrange for any
external command to be called to update the target. For this
command, a target file and list of <br>
inputs is provided. In addition a construction command line,
or lines, is provided as a string (this string may have
multiple commands embedded within it, separated by new <br>
lines). &lsquo;Command&rsquo; is called as follows:</p>

<p style="margin-top: 1em">Command $env &lt;target&gt;,
&lt;inputs&gt;, &lt;construction command&gt;;</p>

<p style="margin-top: 1em">The target is made dependent
upon the list of input files specified, and the inputs must
be built successfully or Cons will not attempt to build the
target.</p>

<p style="margin-top: 1em">Within the construction command,
any variable from the construction environment may be
introduced by prefixing the name of the construction
variable with &lsquo;%&rsquo;. This is recursive: <br>
the command is expanded until no more substitutions can be
made. If a construction variable is not defined in the
environment, then the null string will be substituted. A
dou&acirc; <br>
bled &lsquo;%%&rsquo; will be replaced by a single
&lsquo;%&rsquo; in the construction command.</p>

<p style="margin-top: 1em">There are several pseudo
variables which will also be expanded:</p>

<p style="margin-top: 1em">%&gt; The target file name (in a
multi-target command, this is always the first target
mentioned).</p>

<p style="margin-top: 1em">%0 Same as
&lsquo;%&gt;&rsquo;.</p>

<p style="margin-top: 1em">%1, %2, ..., %9 <br>
These refer to the first through ninth input file,
respectively.</p>

<p style="margin-top: 1em">%&lt; The full set of inputs. If
any of these have been used anywhere else in the current
command line (via &lsquo;%1&rsquo;, &lsquo;%2&rsquo;, etc.),
then those will be deleted from the list pro&acirc; <br>
vided by &lsquo;%&lt;&rsquo;. Consider the following command
found in a Conscript file in the test directory:</p>

<p style="margin-top: 1em">Command $env &rsquo;tgt&rsquo;,
qw(foo bar baz), qq( <br>
echo %&lt; -i %1 &gt; %&gt; <br>
echo %&lt; -i %2 &gt;&gt; %&gt; <br>
echo %&lt; -i %3 &gt;&gt; %&gt; <br>
);</p>

<p style="margin-top: 1em">If tgt needed to be updated,
then this would result in the execution of the following
commands, assuming that no remapping has been established
for the test directory:</p>

<p style="margin-top: 1em">echo test/bar test/baz -i
test/foo &gt; test/tgt <br>
echo test/foo test/baz -i test/bar &gt;&gt; test/tgt <br>
echo test/foo test/bar -i test/baz &gt;&gt; test/tgt</p>

<p style="margin-top: 1em">Any of the above pseudo
variables may be followed immediately by one of the
following suffixes to select a portion of the expanded path
name:</p>

<p style="margin-top: 1em">:a the absolute path to the file
name <br>
:b the directory plus the file name stripped of any suffix
<br>
:d the directory <br>
:f the file name <br>
:s the file name suffix <br>
:F the file name stripped of any suffix</p>

<p style="margin-top: 1em">Continuing with the above
example, &lsquo;%&lt;:f&rsquo; would expand to &lsquo;foo
bar baz&rsquo;, and &lsquo;%&rsquo;:d&gt; would expand to
&lsquo;test&rsquo;.</p>

<p style="margin-top: 1em">It is possible to
programmatically rewrite part of the command by enclosing
part of it between &lsquo;%[&rsquo; and &lsquo;%]&rsquo;.
This will call the construction variable named as the first
word <br>
enclosed in the brackets as a Perl code reference; the
results of this call will be used to replace the contents of
the brackets in the command line. For example, given an <br>
existing input file named tgt.in:</p>

<p style="margin-top: 1em">@keywords = qw(foo bar baz);
<br>
$env = new cons(X_COMMA =&gt; sub { join(&quot;,&quot;, @_)
}); <br>
Command $env &rsquo;tgt&rsquo;, &rsquo;tgt.in&rsquo;, qq(
<br>
echo &rsquo;# Keywords: %[X_COMMA @keywords %]&rsquo; &gt;
%&gt; <br>
cat %&lt; &gt;&gt; %&gt; <br>
);</p>

<p style="margin-top: 1em">This will execute:</p>

<p style="margin-top: 1em">echo &rsquo;# Keywords:
foo,bar,baz&rsquo; &gt; tgt <br>
cat tgt.in &gt;&gt; tgt</p>

<p style="margin-top: 1em">After substitution occurs,
strings of white space are converted into single blanks, and
leading and trailing white space is eliminated. It is
therefore not possible to introduce <br>
variable length white space in strings passed into a
command, without resorting to some sort of shell
quoting.</p>

<p style="margin-top: 1em">If a multi-line command string
is provided, the commands are executed sequentially. If any
of the commands fails, then none of the rest are executed,
and the target is not marked <br>
as updated, i.e. a new signature is not stored for the
target.</p>

<p style="margin-top: 1em">Normally, if all the commands
succeed, and return a zero status (or whatever
platform-specific indication of success is required), then a
new signature is stored for the target. <br>
If a command erroneously reports success even after a
failure, then Cons will assume that the target file created
by that command is accurate and up-to-date.</p>

<p style="margin-top: 1em">The first word of each command
string, after expansion, is assumed to be an executable
command looked up on the &lsquo;PATH&rsquo; environment
variable (which is, in turn, specified by the <br>
&lsquo;ENV&rsquo; construction variable). If this command is
found on the path, then the target will depend upon it: the
command will therefore be automatically built, as necessary.
It&rsquo;s <br>
possible to write multi-part commands to some shells,
separated by semi-colons. Only the first command word will
be depended upon, however, so if you write your command
strings <br>
this way, you must either explicitly set up a dependency
(with the &lsquo;Depends&rsquo; method), or be sure that the
command you are using is a system command which is expected
to be avail&acirc; <br>
able. If it isn&rsquo;t available, you will, of course, get
an error.</p>

<p style="margin-top: 1em">If any command (even one within
a multi-line command) begins with &lsquo;[perl]&rsquo;, the
remainder of that command line will be evaluated by the
running Perl instead of being forked by <br>
the shell. If an error occurs in parsing the Perl or if the
Perl expression returns 0 or undef, the command will be
considered to have failed. For example, here is a simple
<br>
command which creates a file &lsquo;foo&rsquo; directly from
Perl:</p>

<p style="margin-top: 1em">$env = new cons(); <br>
Command $env &rsquo;foo&rsquo;, <br>
qq([perl] open(FOO,&rsquo;&gt;foo&rsquo;);print FOO
&quot;hi\n&quot;; close(FOO); 1);</p>

<p style="margin-top: 1em">Note that when the command is
executed, you are in the same package as when the Construct
or Conscript file was read, so you can call Perl functions
you&rsquo;ve defined in the same <br>
Construct or Conscript file in which the
&lsquo;Command&rsquo; appears:</p>

<p style="margin-top: 1em">$env = new cons(); <br>
sub create_file { <br>
my $file = shift; <br>
open(FILE, &quot;&gt;$file&quot;); <br>
print FILE &quot;hi0; <br>
close(FILE); <br>
return 1; <br>
} <br>
Command $env &rsquo;foo&rsquo;, &quot;[perl]
&amp;create_file(&rsquo;%&gt;&rsquo;)&quot;;</p>

<p style="margin-top: 1em">The Perl string will be used to
generate the signature for the derived file, so if you
change the string, the file will be rebuilt. The contents of
any subroutines you call, <br>
however, are not part of the signature, so if you modify a
called subroutine such as &lsquo;create_file&rsquo; above,
the target will not be rebuilt. Caveat user.</p>

<p style="margin-top: 1em">Cons normally prints a command
before executing it. This behavior is suppressed if the
first character of the command is &lsquo;@&rsquo;. Note that
you may need to separate the &lsquo;@&rsquo; from <br>
the command name or escape it to prevent &lsquo;@cmd&rsquo;
from looking like an array to Perl quote operators that
perform interpolation:</p>

<p style="margin-top: 1em"># The first command line is
incorrect, <br>
# because &quot;@cp&quot; looks like an array <br>
# to the Perl qq// function. <br>
# Use the second form instead. <br>
Command $env &rsquo;foo&rsquo;, &rsquo;foo.in&rsquo;, qq(
<br>
@cp %&lt; tempfile <br>
@ cp tempfile %&gt; <br>
);</p>

<p style="margin-top: 1em">If there are shell meta
characters anywhere in the expanded command line, such as
&lsquo;&lt;&rsquo;, &lsquo;&gt;&rsquo;, quotes, or
semi-colon, then the command will actually be executed by
invoking a shell. <br>
This means that a command such as:</p>

<p style="margin-top: 1em">cd foo</p>

<p style="margin-top: 1em">alone will typically fail, since
there is no command &lsquo;cd&rsquo; on the path. But the
command string:</p>

<p style="margin-top: 1em">cd $&lt;:d; tar cf $&gt;:f
$&lt;:f</p>

<p style="margin-top: 1em">when expanded will still contain
the shell meta character semi-colon, and a shell will be
invoked to interpret the command. Since &lsquo;cd&rsquo; is
interpreted by this sub-shell, the com&acirc; <br>
mand will execute as expected.</p>

<p style="margin-top: 1em">To specify a command with
multiple targets, you can specify a reference to a list of
targets. In Perl, a list reference can be created by
enclosing a list in square brackets. <br>
Hence the following command:</p>

<p style="margin-top: 1em">Command $env
[&rsquo;foo.h&rsquo;, &rsquo;foo.c&rsquo;],
&rsquo;foo.template&rsquo;, q( <br>
gen %1 <br>
);</p>

<p style="margin-top: 1em">could be used in a case where
the command &lsquo;gen&rsquo; creates two files, both foo.h
and foo.c.</p>

<p style="margin-top: 1em">The &lsquo;Objects&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Objects&rsquo; method
arranges to create the object files that correspond to the
specified source files. It is invoked as shown below:</p>

<p style="margin-top: 1em">@files = Objects $env &lt;source
or object files&gt;;</p>

<p style="margin-top: 1em">Under Unix, source files ending
in .s and .c are currently supported, and will be compiled
into a name of the same file ending in .o. By default, all
files are created by invok&acirc; <br>
ing the external command which results from expanding the
&lsquo;CCCOM&rsquo; construction variable, with
&lsquo;%&lt;&rsquo; and &lsquo;%&gt;&rsquo; set to the
source and object files, respectively (see the
&lsquo;Command&rsquo; <br>
method for expansion details). The variable
&lsquo;CPPPATH&rsquo; is also used when scanning source
files for dependencies. This is a colon separated list of
pathnames, and is also used to <br>
create the construction variable &lsquo;_IFLAGS,&rsquo;
which will contain the appropriate list of -&lsquo;I&rsquo;
options for the compilation. Any relative pathnames in
&lsquo;CPPPATH&rsquo; is interpreted rela&acirc; <br>
tive to the directory in which the associated construction
environment was created (absolute and top-relative names may
also be used). This variable is used by &lsquo;CCCOM&rsquo;.
The <br>
behavior of this command can be modified by changing any of
the variables which are interpolated into
&lsquo;CCCOM&rsquo;, such as &lsquo;CC&rsquo;,
&lsquo;CFLAGS&rsquo;, and, indirectly,
&lsquo;CPPPATH&rsquo;. It&rsquo;s also pos&acirc; <br>
sible to replace the value of &lsquo;CCCOM&rsquo;, itself.
As a convenience, this file returns the list of object
filenames.</p>

<p style="margin-top: 1em">The &lsquo;Program&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Program&rsquo; method
arranges to link the specified program with the specified
object files. It is invoked in the following manner:</p>

<p style="margin-top: 1em">Program $env &lt;program
name&gt;, &lt;source or object files&gt;;</p>

<p style="margin-top: 1em">The program name will have the
value of the &lsquo;SUFEXE&rsquo; construction variable
appended (by default, &lsquo;.exe&rsquo; on Win32 systems,
nothing on Unix systems) if the suffix is not already <br>
present.</p>

<p style="margin-top: 1em">Source files may be specified in
place of objects files--the &lsquo;Objects&rsquo; method
will be invoked to arrange the conversion of all the files
into object files, and hence all the <br>
observations about the &lsquo;Objects&rsquo; method, above,
apply to this method also.</p>

<p style="margin-top: 1em">The actual linking of the
program will be handled by an external command which results
from expanding the &lsquo;LINKCOM&rsquo; construction
variable, with &lsquo;%&lt;&rsquo; set to the object files
to be <br>
linked (in the order presented), and &lsquo;%&gt;&rsquo; set
to the target (see the &lsquo;Command&rsquo; method for
expansion details). The user may set additional variables in
the construction environ&acirc; <br>
ment, including &lsquo;LINK&rsquo;, to define which program
to use for linking, &lsquo;LIBPATH&rsquo;, a colon-separated
list of library search paths, for use with library
specifications of the form <br>
-llib, and &lsquo;LIBS&rsquo;, specifying the list of
libraries to link against (in either -llib form or just as
pathnames. Relative pathnames in both &lsquo;LIBPATH&rsquo;
and &lsquo;LIBS&rsquo; are interpreted <br>
relative to the directory in which the associated
construction environment is created (absolute and
top-relative names may also be used). Cons automatically
sets up dependencies <br>
on any libraries mentioned in &lsquo;LIBS&rsquo;: those
libraries will be built before the command is linked.</p>

<p style="margin-top: 1em">The &lsquo;Library&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Library&rsquo; method
arranges to create the specified library from the specified
object files. It is invoked as follows:</p>

<p style="margin-top: 1em">Library $env &lt;library
name&gt;, &lt;source or object files&gt;;</p>

<p style="margin-top: 1em">The library name will have the
value of the &lsquo;SUFLIB&rsquo; construction variable
appended (by default, &lsquo;.lib&rsquo; on Win32 systems,
&lsquo;.a&rsquo; on Unix systems) if the suffix is not
already <br>
present.</p>

<p style="margin-top: 1em">Source files may be specified in
place of objects files--the &lsquo;Objects&rsquo; method
will be invoked to arrange the conversion of all the files
into object files, and hence all the <br>
observations about the &lsquo;Objects&rsquo; method, above,
apply to this method also.</p>

<p style="margin-top: 1em">The actual creation of the
library will be handled by an external command which results
from expanding the &lsquo;ARCOM&rsquo; construction
variable, with &lsquo;%&lt;&rsquo; set to the library
members (in <br>
the order presented), and &lsquo;%&gt;&rsquo; to the library
to be created (see the &lsquo;Command&rsquo; method for
expansion details). The user may set variables in the
construction environment which <br>
will affect the operation of the command. These include
&lsquo;AR&rsquo;, the archive program to use,
&lsquo;ARFLAGS&rsquo;, which can be used to modify the flags
given to the program specified by &lsquo;AR&rsquo;, <br>
and &lsquo;RANLIB&rsquo;, the name of a archive index
generation program, if needed (if the particular need does
not require the latter functionality, then
&lsquo;ARCOM&rsquo; must be redefined to not <br>
reference &lsquo;RANLIB&rsquo;).</p>

<p style="margin-top: 1em">The &lsquo;Library&rsquo; method
allows the same library to be specified in multiple method
invocations. All of the contributing objects from all the
invocations (which may be from different <br>
directories) are combined and generated by a single archive
command. Note, however, that if you prune a build so that
only part of a library is specified, then only that part of
<br>
the library will be generated (the rest will
disappear!).</p>

<p style="margin-top: 1em">The &lsquo;Module&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Module&rsquo; method
is a combination of the &lsquo;Program&rsquo; and
&lsquo;Command&rsquo; methods. Rather than generating an
executable program directly, this command allows you to
specify your own <br>
command to actually generate a module. The method is invoked
as follows:</p>

<p style="margin-top: 1em">Module $env &lt;module name&gt;,
&lt;source or object files&gt;, &lt;construction
command&gt;;</p>

<p style="margin-top: 1em">This command is useful in
instances where you wish to create, for example, dynamically
loaded modules, or statically linked code libraries.</p>

<p style="margin-top: 1em">The &lsquo;Depends&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Depends&rsquo; method
allows you to specify additional dependencies for a target.
It is invoked as follows:</p>

<p style="margin-top: 1em">Depends $env &lt;target&gt;,
&lt;dependencies&gt;;</p>

<p style="margin-top: 1em">This may be occasionally useful,
especially in cases where no scanner exists (or is writable)
for particular types of files. Normally, dependencies are
calculated automatically <br>
from a combination of the explicit dependencies set up by
the method invocation or by scanning source files.</p>

<p style="margin-top: 1em">A set of identical dependencies
for multiple targets may be specified using a reference to a
list of targets. In Perl, a list reference can be created by
enclosing a list in <br>
square brackets. Hence the following command:</p>

<p style="margin-top: 1em">Depends $env [&rsquo;foo&rsquo;,
&rsquo;bar&rsquo;], &rsquo;input_file_1&rsquo;,
&rsquo;input_file_2&rsquo;;</p>

<p style="margin-top: 1em">specifies that both the foo and
bar files depend on the listed input files.</p>

<p style="margin-top: 1em">The &lsquo;Ignore&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Ignore&rsquo; method
allows you to ignore explicitly dependencies that Cons
infers on its own. It is invoked as follows:</p>

<p style="margin-top: 1em">Ignore &lt;patterns&gt;;</p>

<p style="margin-top: 1em">This can be used to avoid
recompilations due to changes in system header files or
utilities that are known to not affect the generated
targets.</p>

<p style="margin-top: 1em">If, for example, a program is
built in an NFS-mounted directory on multiple systems that
have different copies of stdio.h, the differences will
affect the signatures of all <br>
derived targets built from source files that &lsquo;#include
&lt;stdio.h&gt;&rsquo;. This will cause all those targets to
be rebuilt when changing systems. If this is not desirable
behavior, <br>
then the following line will remove the dependencies on the
stdio.h file:</p>

<p style="margin-top: 1em">Ignore
&rsquo;^/usr/include/stdio.h$&rsquo;;</p>

<p style="margin-top: 1em">Note that the arguments to the
&lsquo;Ignore&rsquo; method are regular expressions, so
special characters must be escaped and you may wish to
anchor the beginning or end of the expression <br>
with &lsquo;^&rsquo; or &lsquo;$&rsquo; characters.</p>

<p style="margin-top: 1em">The &lsquo;Salt&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Salt&rsquo; method
adds a constant value to the signature calculation for every
derived file. It is invoked as follows:</p>

<p style="margin-top: 1em">Salt $string;</p>

<p style="margin-top: 1em">Changing the Salt value will
force a complete rebuild of every derived file. This can be
used to force rebuilds in certain desired circumstances. For
example,</p>

<p style="margin-top: 1em">Salt &lsquo;uname -s&lsquo;;</p>

<p style="margin-top: 1em">Would force a complete rebuild
of every derived file whenever the operating system on which
the build is performed (as reported by &lsquo;uname
-s&rsquo;) changes.</p>

<p style="margin-top: 1em">The &lsquo;UseCache&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;UseCache&rsquo;
method instructs Cons to maintain a cache of derived files,
to be shared among separate build trees of the same
project.</p>


<p style="margin-top: 1em">UseCache(&quot;cache/&lt;buildname&gt;&quot;)
&acirc;&ordf;&acirc;&ordf; warn(&quot;cache directory not
found&quot;);</p>

<p style="margin-top: 1em">The &lsquo;SourcePath&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;SourcePath&rsquo;
mathod returns the real source path name of a file, as
opposted to the path name within a build directory. It is
invoked as follows:</p>

<p style="margin-top: 1em">$path = SourcePath
&lt;buildpath&gt;;</p>

<p style="margin-top: 1em">The &lsquo;ConsPath&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;ConsPath&rsquo;
method returns true if the supplied path is a derivable
file, and returns undef (false) otherwise. It is invoked as
follows:</p>

<p style="margin-top: 1em">$result = ConsPath
&lt;path&gt;;</p>

<p style="margin-top: 1em">The &lsquo;SplitPath&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;SplitPath&rsquo;
method looks up multiple path names in a string separated by
the default path separator for the operating system
(&rsquo;:&rsquo; on UNIX systems, &rsquo;;&rsquo; on Windows
NT), and <br>
returns the fully-qualified names. It is invoked as
follows:</p>

<p style="margin-top: 1em">@paths = SplitPath
&lt;pathlist&gt;;</p>

<p style="margin-top: 1em">The &lsquo;SplitPath&rsquo;
method will convert names prefixed &rsquo;#&rsquo; to the
appropriate top-level build name (without the
&rsquo;#&rsquo;) and will convert relative names to
top-level names.</p>

<p style="margin-top: 1em">The &lsquo;DirPath&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;DirPath&rsquo; method
returns the build path name(s) of a directory or list of
directories. It is invoked as follows:</p>

<p style="margin-top: 1em">$cwd = DirPath
&lt;paths&gt;;</p>

<p style="margin-top: 1em">The most common use for the
&lsquo;DirPath&rsquo; method is:</p>

<p style="margin-top: 1em">$cwd = DirPath
&rsquo;.&rsquo;;</p>

<p style="margin-top: 1em">to fetch the path to the current
directory of a subsidiary Conscript file.</p>

<p style="margin-top: 1em">The &lsquo;FilePath&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;FilePath&rsquo;
method returns the build path name(s) of a file or list of
files. It is invoked as follows:</p>

<p style="margin-top: 1em">$file = FilePath
&lt;path&gt;;</p>

<p style="margin-top: 1em">The &lsquo;Help&rsquo;
method</p>

<p style="margin-top: 1em">The &lsquo;Help&rsquo; method
specifies help text that will be displayed when the user
invokes &lsquo;cons -h&rsquo;. This can be used to provide
documentation of specific targets, values, build <br>
options, etc. for the build tree. It is invoked as
follows:</p>

<p style="margin-top: 1em">Help &lt;helptext&gt;;</p>

<p style="margin-top: 1em">The &lsquo;Help&rsquo; method
may only be called once, and should typically be specified
in the top-level Construct file.</p>

<p style="margin-top: 1em">Extending Cons <br>
Overriding construction variables</p>

<p style="margin-top: 1em">There are several ways of
extending Cons, which vary in degree of difficulty. The
simplest method is to define your own construction
environment, based on the default environ&acirc; <br>
ment, but modified to reflect your particular needs. This
will often suffice for C-based applications. You can use the
&lsquo;new&rsquo; constructor, and the &lsquo;clone&rsquo;
and &lsquo;copy&rsquo; methods to <br>
create hybrid environments. These changes can be entirely
transparent to the underlying Conscript files.</p>

<p style="margin-top: 1em">Adding new methods</p>

<p style="margin-top: 1em">For slightly more demanding
changes, you may wish to add new methods to the
&lsquo;cons&rsquo; package. Here&rsquo;s an example of a
very simple extension, &lsquo;InstallScript&rsquo;, which
installs a tcl <br>
script in a requested location, but edits the script first
to reflect a platform-dependent path that needs to be
installed in the script:</p>

<p style="margin-top: 1em"># cons::InstallScript - Create a
platform dependent version of a shell <br>
# script by replacing string
&lsquo;&lsquo;#!your-path-here&rsquo;&rsquo; with platform
specific <br>
# path $BIN_DIR.</p>

<p style="margin-top: 1em">sub cons::InstallScript { <br>
my ($env, $dst, $src) = @_; <br>
Command $env $dst, $src, qq( <br>
sed s+your-path-here+$BIN_DIR+ %&lt; &gt; %&gt; <br>
chmod oug+x %&gt; <br>
); <br>
}</p>

<p style="margin-top: 1em">Notice that this method is
defined directly in the &lsquo;cons&rsquo; package (by
prefixing the name with &lsquo;cons::&rsquo;). A change made
in this manner will be globally visible to all
environ&acirc; <br>
ments, and could be called as in the following example:</p>

<p style="margin-top: 1em">InstallScript $env
&quot;$BIN/foo&quot;, &quot;foo.tcl&quot;;</p>

<p style="margin-top: 1em">For a small improvement in
generality, the &lsquo;BINDIR&rsquo; variable could be
passed in as an argument or taken from the construction
environment--as &lsquo;%BINDIR&rsquo;.</p>

<p style="margin-top: 1em">Overriding methods</p>

<p style="margin-top: 1em">Instead of adding the method to
the &lsquo;cons&rsquo; name space, you could define a new
package which inherits existing methods from the
&lsquo;cons&rsquo; package and overrides or adds others.
This <br>
can be done using Perl&rsquo;s inheritance mechanisms.</p>

<p style="margin-top: 1em">The following example defines a
new package &lsquo;cons::switch&rsquo; which overrides the
standard &lsquo;Library&rsquo; method. The overridden method
builds linked library modules, rather than library <br>
archives. A new constructor is provided. Environments
created with this constructor will have the new library
method; others won&rsquo;t.</p>

<p style="margin-top: 1em">package cons::switch; <br>
BEGIN {@ISA = &rsquo;cons&rsquo;}</p>

<p style="margin-top: 1em">sub new { <br>
shift; <br>
bless new cons(@_); <br>
}</p>

<p style="margin-top: 1em">sub Library { <br>
my($env) = shift; <br>
my($lib) = shift; <br>
my(@objs) = Objects $env @_; <br>
Command $env $lib, @objs, q( <br>
%LD -r %LDFLAGS %&lt; -o %&gt; <br>
); <br>
}</p>

<p style="margin-top: 1em">This functionality could be
invoked as in the following example:</p>

<p style="margin-top: 1em">$env = new
cons::switch(@overrides); <br>
... <br>
Library $env &rsquo;lib.o&rsquo;, &rsquo;foo.c&rsquo;,
&rsquo;bar.c&rsquo;;</p>

<p style="margin-top: 1em">Invoking Cons <br>
The &lsquo;cons&rsquo; command is usually invoked from the
root of the build tree. A Construct file must exist in that
directory. If the &lsquo;-f&rsquo; argument is used, then an
alternate Construct <br>
file may be used (and, possibly, an alternate root, since
&lsquo;cons&rsquo; will cd to Construct file&rsquo;s
containing directory).</p>

<p style="margin-top: 1em">If &lsquo;cons&rsquo; is invoked
from a child of the root of the build tree with the
&lsquo;-t&rsquo; argument, it will walk up the directory
hierarchy looking for a Construct file. (An alternate name
<br>
may still be specified with &lsquo;-f&rsquo;.) The targets
supplied on the command line will be modified to be relative
to the discovered Construct file. For example, from a
directory con&acirc; <br>
taining a top-level Construct file, the following
invocation:</p>

<p style="margin-top: 1em">% cd libfoo/subdir <br>
% cons -t target</p>

<p style="margin-top: 1em">is exactly equivalent to:</p>

<p style="margin-top: 1em">% cons libfoo/subdir/target</p>

<p style="margin-top: 1em">If there are any
&lsquo;Default&rsquo; targets specified in the directory
hierarchy&rsquo;s Construct or Conscript files, only the
default targets at or below the directory from which
&lsquo;cons -t&rsquo; <br>
was invoked will be built.</p>

<p style="margin-top: 1em">The command is invoked as
follows:</p>

<p style="margin-top: 1em">cons &lt;arguments&gt; --
&lt;construct-args&gt;</p>

<p style="margin-top: 1em">where arguments can be any of
the following, in any order:</p>

<p style="margin-top: 1em">target Build the specified
target. If target is a directory, then recursively build
everything within that directory.</p>

<p style="margin-top: 1em">+pattern Limit the Conscript
files considered to just those that match pattern, which is
a Perl regular expression. Multiple &lsquo;+&rsquo;
arguments are accepted.</p>

<p style="margin-top: 1em">name=&lt;val&gt; <br>
Sets name to value val in the &lsquo;ARG&rsquo; hash passed
to the top-level Construct file.</p>

<p style="margin-top: 1em">&lsquo;-cc&rsquo; Show command
that would have been executed, when retrieving from cache.
No indication that the file has been retrieved is given;
this is useful for generating build <br>
logs that can be compared with real build logs.</p>

<p style="margin-top: 1em">&lsquo;-cd&rsquo; Disable all
caching. Do not retrieve from cache nor flush to cache.</p>

<p style="margin-top: 1em">&lsquo;-cr&rsquo; Build
dependencies in random order. This is useful when building
multiple similar trees with caching enabled.</p>

<p style="margin-top: 1em">&lsquo;-cs&rsquo; Synchronize
existing build targets that are found to be up-to-date with
cache. This is useful if caching has been disabled with -cc
or just recently enabled with Use&acirc; <br>
Cache.</p>

<p style="margin-top: 1em">&lsquo;-d&rsquo; Enable
dependency debugging.</p>

<p style="margin-top: 1em">&lsquo;-f&rsquo; &lt;file&gt;
<br>
Use the specified file instead of Construct (but first
change to containing directory of file).</p>

<p style="margin-top: 1em">&lsquo;-h&rsquo; Show a help
message local to the current build if one such is defined,
and exit.</p>

<p style="margin-top: 1em">&lsquo;-k&rsquo; Keep going as
far as possible after errors.</p>

<p style="margin-top: 1em">&lsquo;-o&rsquo; &lt;file&gt;
<br>
Read override file file.</p>

<p style="margin-top: 1em">&lsquo;-p&rsquo; Show
construction products in specified trees. No build is
attempted.</p>

<p style="margin-top: 1em">&lsquo;-pa&rsquo; Show
construction products and associated actions. No build is
attempted.</p>

<p style="margin-top: 1em">&lsquo;-pw&rsquo; Show products
and where they are defined. No build is attempted.</p>

<p style="margin-top: 1em">&lsquo;-q&rsquo; Don&rsquo;t be
verbose about Installing and Removing targets.</p>

<p style="margin-top: 1em">&lsquo;-r&rsquo; Remove
construction products associated with &lt;targets&gt;. No
build is attempted.</p>

<p style="margin-top: 1em">&lsquo;-R&rsquo; &lt;repos&gt;
<br>
Search for files in repos. Multiple -R repos directories are
searched in the order specified.</p>

<p style="margin-top: 1em">&lsquo;-t&rsquo; Traverse up the
directory hierarchy looking for a Construct file, if none
exists in the current directory. Targets will be modified to
be relative to the Construct <br>
file.</p>

<p style="margin-top: 1em">&lsquo;-v&rsquo; Show
&lsquo;cons&rsquo; version and continue processing.</p>

<p style="margin-top: 1em">&lsquo;-V&rsquo; Show
&lsquo;cons&rsquo; version and exit.</p>

<p style="margin-top: 1em">&lsquo;-wf&rsquo; &lt;file&gt;
<br>
Write all filenames considered into file.</p>

<p style="margin-top: 1em">&lsquo;-x&rsquo; Show a help
message similar to this one, and exit.</p>

<p style="margin-top: 1em">And construct-args can be any
arguments that you wish to process in the Construct file.
Note that there should be a -- separating the arguments to
cons and the arguments that you <br>
wish to process in the Construct file.</p>

<p style="margin-top: 1em">Processing of construct-args can
be done by any standard package like Getopt or its variants,
or any user defined package. cons will pass in the
construct-args as @ARGV and will <br>
not attempt to interpret anything after the --.</p>

<p style="margin-top: 1em">% cons -R /usr/local/repository
-d os=solaris +driver -- -c test -f DEBUG</p>

<p style="margin-top: 1em">would pass the following to
cons</p>

<p style="margin-top: 1em">-R /usr/local/repository -d
os=solaris +driver</p>

<p style="margin-top: 1em">and the following, to the top
level Construct file as @ARGV</p>

<p style="margin-top: 1em">-c test -f DEBUG</p>

<p style="margin-top: 1em">Note that &lsquo;cons -r
.&rsquo; is equivalent to a full recursive &lsquo;make
clean&rsquo;, but requires no support in the Construct file
or any Conscript files. This is most useful if you are
compil&acirc; <br>
ing files into source directories (if you separate the build
and export directories, then you can just remove the
directories).</p>

<p style="margin-top: 1em">The options &lsquo;-p&rsquo;,
&lsquo;-pa&rsquo;, and &lsquo;-pw&rsquo; are extremely
useful for use as an aid in reading scripts or debugging
them. If you want to know what script installs
export/include/foo.h, for <br>
example, just type:</p>

<p style="margin-top: 1em">% cons -pw
export/include/foo.h</p>

<p style="margin-top: 1em">Using and writing dependency
scanners <br>
QuickScan allows simple target-independent scanners to be
set up for source files. Only one QuickScan scanner may be
associated with any given source file and environment.</p>

<p style="margin-top: 1em">QuickScan is invoked as
follows:</p>

<p style="margin-top: 1em">QuickScan CONSENV CODEREF,
FILENAME [, PATH]</p>

<p style="margin-top: 1em">The subroutine referenced by
CODEREF is expected to return a list of filenames included
directly by FILE. These filenames will, in turn, be scanned.
The optional PATH argument <br>
supplies a lookup path for finding FILENAME and/or files
returned by the user-supplied subroutine. The PATH may be a
reference to an array of lookup-directory names, or a string
<br>
of names separated by the system&rsquo;s separator character
(&rsquo;:&rsquo; on UNIX systems, &rsquo;;&rsquo; on Windows
NT).</p>

<p style="margin-top: 1em">The subroutine is called once
for each line in the file, with $_ set to the current line.
If the subroutine needs to look at additional lines, or, for
that matter, the entire <br>
file, then it may read them itself, from the filehandle
SCAN. It may also terminate the loop, if it knows that no
further include information is available, by closing the
file&acirc; <br>
handle.</p>

<p style="margin-top: 1em">Whether or not a lookup path is
provided, QuickScan first tries to lookup the file relative
to the current directory (for the top-level file supplied
directly to QuickScan), or <br>
from the directory containing the file which referenced the
file. This is not very general, but seems good
enough--especially if you have the luxury of writing your
own utilities <br>
and can control the use of the search path in a standard
way. Finally, the search path is, currently, colon
separated. This may not make the NT camp happy.</p>

<p style="margin-top: 1em">Here&rsquo;s a real example,
taken from a Construct file here:</p>

<p style="margin-top: 1em">sub cons::SMFgen { <br>
my($env, @tables) = @_; <br>
foreach $t (@tables) { . s <br>
$env-&gt;QuickScan(sub { /m f <br>
$env-&gt;{SMF_INCLUDE_PATH}); <br>
$env-&gt;Command( <br>

[&quot;$t.smdb.cc&quot;,&quot;$t.smdb.h&quot;,&quot;$t.snmp.cc&quot;,&quot;$t.ami.cc&quot;,
&quot;$t.http.cc&quot;], <br>
&quot;$t.smf&quot;, <br>
q( <br>
smfgen %( %SMF_INCLUDE_OPT %) %&lt; <br>
) <br>
); <br>
} <br>
}</p>

<p style="margin-top: 1em">[NOTE that the form
&lsquo;$env-&gt;QuickScan ...&rsquo; and
&lsquo;$env-&gt;Command ...&rsquo; should not be necessary,
but, for some reason, is required for this particular
invocation. This appears to be a <br>
bug in Perl or a misunderstanding on my part; this
invocation style does not always appear to be
necessary.]</p>

<p style="margin-top: 1em">This finds all names of the form
&lt;name&gt;.smf in the file. It will return the names even
if they&rsquo;re found within comments, but that&rsquo;s OK
(the mechanism is forgiving of extra files; <br>
they&rsquo;re just ignored on the assumption that the
missing file will be noticed when the program, in this
example, smfgen, is actually invoked).</p>

<p style="margin-top: 1em">A scanner is only invoked for a
given source file if it is needed by some target in the
tree. It is only ever invoked once for a given source
file.</p>

<p style="margin-top: 1em">Here is another way to build the
same scanner. This one uses an explicit code reference, and
also (unecessarily, in this case) reads the whole file
itself:</p>

<p style="margin-top: 1em">sub myscan { <br>
my(@includes); <br>
do { . s <br>
push(@includes, /m f <br>
} while &lt;SCAN&gt;; <br>
@includes <br>
}</p>

<p style="margin-top: 1em">Note that the order of the loop
is reversed, with the loop test at the end. This is because
the first line is already read for you. This scanner can be
attached to a source file <br>
by:</p>

<p style="margin-top: 1em">QuickScan $env scan,
&quot;$_.smf&quot;;</p>

<p style="margin-top: 1em">SUPPORT AND SUGGESTIONS <br>
Cons is maintained by the user community. To subscribe, send
mail to cons-discuss-request@gnu.org with body
subscribe.</p>

<p style="margin-top: 1em">Please report any suggestions
through the cons-discuss@gnu.org mailing list.</p>

<p style="margin-top: 1em">BUGS <br>
Sure to be some. Please report any bugs through the
bug-cons@gnu.org mailing list.</p>

<p style="margin-top: 1em">INFORMATION ABOUT CONS <br>
Information about CONS can be obtained from the official
cons web site http://www.dsmit.com/cons/ or its mirrors
listed there.</p>

<p style="margin-top: 1em">The cons maintainers can be
contacted by email at cons-maintainers@gnu.org</p>

<p style="margin-top: 1em">AUTHORS <br>
Originally by Bob Sidebotham. Then significantly enriched by
the members of the Cons community cons-discuss@gnu.org.</p>

<p style="margin-top: 1em">The Cons community would like to
thank Ulrich Pfeifer for the original pod documentation
derived from the cons.html file. Cons documentation is now a
part of the program itself.</p>

<p style="margin-top: 1em">3rd Berkeley Distribution 2.2.0
CONS(1)</p>
<hr>
</body>
</html>
