<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>CONS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CONS(1)</td>
    <td class="head-vol">Cons - Software Construction System</td>
    <td class="head-rtitle">CONS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
Cons - A Software Construction System
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A guide and reference for version 2.2.0
<div class="Pp"></div>
Copyright (c) 1996-2000 Free Software Foundation, Inc.
<div class="Pp"></div>
This program is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any later
  version.
<div class="Pp"></div>
This program is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU General Public License for more details.
<div class="Pp"></div>
You should have received a copy of the GNU General Public License along with
  this program; see the file COPYING. If not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<h1 class="Sh" title="Sh" id="Introduction"><a class="selflink" href="#Introduction">Introduction</a></h1>
<b>Cons</b> is a system for constructing, primarily, software, but is quite
  different from previous software construction systems. Cons was designed from
  the ground up to deal easily with the construction of software spread over
  multiple source directories. Cons makes it easy to create build scripts that
  are simple, understandable and maintainable. Cons ensures that complex
  software is easily and accurately reproducible.
<div class="Pp"></div>
Cons uses a number of techniques to accomplish all of this. Construction scripts
  are just Perl scripts, making them both easy to comprehend and very flexible.
  Global scoping of variables is replaced with an import/export mechanism for
  sharing information between scripts, significantly improving the readability
  and maintainability of each script. <b>Construction</b> <b>environments</b>
  are introduced: these are Perl objects that capture the information required
  for controlling the build process. Multiple environments are used when
  different semantics are required for generating products in the build tree.
  Cons implements automatic dependency analysis and uses this to globally
  sequence the entire build. Variant builds are easily produced from a single
  source tree. Intelligent build subsetting is possible, when working on
  localized changes. Overrides can be setup to easily override build
  instructions without modifying any scripts. MD5 cryptographic
  <b>signatures</b> are associated with derived files, and are used to
  accurately determine whether a given file needs to be rebuilt.
<div class="Pp"></div>
While offering all of the above, and more, Cons remains simple and easy to use.
  This will, hopefully, become clear as you read the remainder of this document.
<h1 class="Sh" title="Sh" id="Why_Cons?_Why_not_Make?"><a class="selflink" href="#Why_Cons?_Why_not_Make?">Why
  Cons? Why not Make?</a></h1>
Cons is a <b>make</b> replacement. In the following paragraphs, we look at a few
  of the undesirable characteristics of make--and typical build environments
  based on make--that motivated the development of Cons.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Build complexity</b>
<div class="Pp"></div>
Traditional make-based systems of any size tend to become quite complex. The
  original make utility and its derivatives have contributed to this tendency in
  a number of ways. Make is not good at dealing with systems that are spread
  over multiple directories. Various work-arounds are used to overcome this
  difficulty; the usual choice is for make to invoke itself recursively for each
  sub-directory of a build. This leads to complicated code, in which it is often
  unclear how a variable is set, or what effect the setting of a variable will
  have on the build as a whole. The make scripting language has gradually been
  extended to provide more possibilities, but these have largely served to
  clutter an already overextended language. Often, builds are done in multiple
  passes in order to provide appropriate products from one directory to another
  directory. This represents a further increase in build complexity.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Build reproducibility</b>
<div class="Pp"></div>
The bane of all makes has always been the correct handling of dependencies. Most
  often, an attempt is made to do a reasonable job of dependencies within a
  single directory, but no serious attempt is made to do the job between
  directories. Even when dependencies are working correctly, make's reliance on
  a simple time stamp comparison to determine whether a file is out of date with
  respect to its dependents is not, in general, adequate for determining when a
  file should be rederived. If an external library, for example, is rebuilt and
  then ``snapped'' into place, the timestamps on its newly created files may
  well be earlier than the last local build, since it was built before it became
  visible.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Variant builds</b>
<div class="Pp"></div>
Make provides only limited facilities for handling variant builds. With the
  proliferation of hardware platforms and the need for debuggable vs. optimized
  code, the ability to easily create these variants is essential. More
  importantly, if variants are created, it is important to either be able to
  separate the variants or to be able to reproduce the original or variant at
  will. With make it is very difficult to separate the builds into multiple
  build directories, separate from the source. And if this technique isn't used,
  it's also virtually impossible to guarantee at any given time which variant is
  present in the tree, without resorting to a complete rebuild.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Repositories</b>
<div class="Pp"></div>
Make provides only limited support for building software from code that exists
  in a central repository directory structure. The VPATH feature of GNU make
  (and some other make implementations) is intended to provide this, but doesn't
  work as expected: it changes the path of target file to the VPATH name too
  early in its analysis, and therefore searches for all dependencies in the
  VPATH directory. To ensure correct development builds, it is important to be
  able to create a file in a local build directory and have any files in a code
  repository (a VPATH directory, in make terms) that depend on the local file
  get rebuilt properly. This isn't possible with VPATH, without coding a lot of
  complex repository knowledge directly into the makefiles.
<h1 class="Sh" title="Sh" id="Keeping_it_simple"><a class="selflink" href="#Keeping_it_simple">Keeping
  it simple</a></h1>
A few of the difficulties with make have been cited above. In this and
  subsequent sections, we shall introduce Cons and show how these issues are
  addressed.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Perl scripts</b>
<div class="Pp"></div>
Cons is Perl-based. That is, Cons scripts-- <i>Conscript</i> and
  <i>Construct</i> files, the equivalent to <i>Makefile</i> or
  <i>makefile</i>--are all written in Perl. This provides an immediate benefit:
  the language for writing scripts is a familiar one. Even if you don't happen
  to be a Perl programmer, it helps to know that Perl is basically just a simple
  declarative language, with a well-defined flow of control, and familiar
  semantics. It has variables that behave basically the way you would expect
  them to, subroutines, flow of control, and so on. There is no special syntax
  introduced for Cons. The use of Perl as a scripting language simplifies the
  task of expressing the appropriate solution to the often complex requirements
  of a build.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Hello, World!</b>
<div class="Pp"></div>
To ground the following discussion, here's how you could build the <b>Hello,</b>
  <b>World!</b> C application with Cons:
<div class="Pp"></div>
<pre>
  $env = new cons();
  Program $env 'hello', 'hello.c';
<div class="Pp"></div>
</pre>
If you install this script in a directory, naming the script <i>Construct</i>,
  and create the <i>hello.c</i> source file in the same directory, then you can
  type `cons hello' to build the application:
<div class="Pp"></div>
<pre>
  % cons hello
  cc -c hello.c -o hello.o
  cc -o hello hello.o
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Construction environments</b>
<div class="Pp"></div>
A key simplification of Cons is the idea of a <b>construction environment</b>. A
  construction environment is an <b>object</b> characterized by a set of
  key/value pairs and a set of <b>methods. </b>In order to tell Cons how to
  build something, you invoke the appropriate method via an appropriate
  construction environment. Consider the following example:
<div class="Pp"></div>
<pre>
  $env = new cons(
        CC      =&gt;      'gcc',
        LIBS    =&gt;      'libworld.a'
  );
<div class="Pp"></div>
</pre>
<pre>
  Program $env 'hello', 'hello.c';
<div class="Pp"></div>
</pre>
In this case, rather than using the default construction environment, as is, we
  have overridden the value of `CC' so that the GNU C Compiler equivalent is
  used, instead. Since this version of <b>Hello, World!</b> requires a library,
  <i>libworld.a</i>, we have specified that any program linked in this
  environment should be linked with that library. If the library exists already,
  well and good, but if not, then we'll also have to include the statement:
<div class="Pp"></div>
<pre>
  Library $env 'libworld', 'world.c';
<div class="Pp"></div>
</pre>
Now if you type `cons hello', the library will be built before the program is
  linked, and, of course, `gcc' will be used to compile both modules:
<div class="Pp"></div>
<pre>
  % cons hello
  gcc -c hello.c -o hello.o
  gcc -c world.c -o world.o
  ar r libworld.a world.o
  ar: creating libworld.a
  ranlib libworld.a
  gcc -o hello hello.o libworld.a
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Automatic and complete dependency analysis</b>
<div class="Pp"></div>
With Cons, dependencies are handled automatically. Continuing the previous
  example, note that when we modify <i>world.c</i>, <i>world.o</i> is
  recompiled, <i>libworld.a</i> recreated, and <i>hello</i> relinked:
<div class="Pp"></div>
<pre>
  % vi world.c
    [EDIT]
  % cons hello
  gcc -c world.c -o world.o
  ar r libworld.a world.o
  ar: creating libworld.a
  ranlib libworld.a
  gcc -o hello hello.o libworld.a
<div class="Pp"></div>
</pre>
This is a relatively simple example: Cons ``knows'' <i>world.o</i> depends upon
  <i>world.c</i>, because the dependency is explicitly set up by the `Library'
  method. It also knows that <i>libworld.a</i> depends upon <i>world.o</i> and
  that <i>hello</i> depends upon <i>libworld.a</i>, all for similar reasons.
<div class="Pp"></div>
Now it turns out that <i>hello.c</i> also includes the interface definition
  file, <i>world.h</i>:
<div class="Pp"></div>
<pre>
  % emacs world.h
    [EDIT]
  % cons hello
  gcc -c hello.c -o hello.o
  gcc -o hello hello.o libworld.a
<div class="Pp"></div>
</pre>
How does Cons know that <i>hello.c</i> includes <i>world.h</i>, and that
  <i>hello.o</i> must therefore be recompiled? For now, suffice it to say that
  when considering whether or not <i>hello.o</i> is up-to-date, Cons invokes a
  scanner for its dependency, <i>hello.c</i>. This scanner enumerates the files
  included by <i>hello.c</i> to come up with a list of further dependencies,
  beyond those made explicit by the Cons script. This process is recursive: any
  files included by included files will also be scanned.
<div class="Pp"></div>
Isn't this expensive? The answer is--it depends. If you do a full build of a
  large system, the scanning time is insignificant. If you do a rebuild of a
  large system, then Cons will spend a fair amount of time thinking about it
  before it decides that nothing has to be done (although not necessarily more
  time than make!). The good news is that Cons makes it very easy to
  intelligently subset your build, when you are working on localized changes.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Automatic global build sequencing</b>
<div class="Pp"></div>
Because Cons does full and accurate dependency analysis, and does this globally,
  for the entire build, Cons is able to use this information to take full
  control of the <b>sequencing</b> of the build. This sequencing is evident in
  the above examples, and is equivalent to what you would expect for make, given
  a full set of dependencies. With Cons, this extends trivially to larger,
  multi-directory builds. As a result, all of the complexity involved in making
  sure that a build is organized correctly--including multi-pass hierarchical
  builds--is eliminated. We'll discuss this further in the next sections.
<h1 class="Sh" title="Sh" id="Building_large_trees--still_just_as_simple"><a class="selflink" href="#Building_large_trees--still_just_as_simple">Building
  large trees--still just as simple</a></h1>
<b>A hierarchy of build scripts</b>
<div class="Pp"></div>
A larger build, in Cons, is organized by creating a hierarchy of <b>build</b>
  <b>scripts</b>. At the top of the tree is a script called <i>Construct</i>.
  The rest of the scripts, by convention, are each called <i>Conscript</i>.
  These scripts are connected together, very simply, by the `Build', `Export',
  and `Import' commands.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The Build command</b>
<div class="Pp"></div>
The `Build' command takes a list of <i>Conscript</i> file names, and arranges
  for them to be included in the build. For example:
<div class="Pp"></div>
<pre>
  Build qw(
        drivers/display/Conscript
        drivers/mouse/Conscript
        parser/Conscript
        utilities/Conscript
  );
<div class="Pp"></div>
</pre>
This is a simple two-level hierarchy of build scripts: all the subsidiary
  <i>Conscript</i> files are mentioned in the top-level <i>Construct</i> file.
  Notice that not all directories in the tree necessarily have build scripts
  associated with them.
<div class="Pp"></div>
This could also be written as a multi-level script. For example, the
  <i>Construct</i> file might contain this command:
<div class="Pp"></div>
<pre>
  Build qw(
        parser/Conscript
        drivers/Conscript
        utilities/Conscript
  );
<div class="Pp"></div>
</pre>
and the <i>Conscript</i> file in the <i>drivers</i> directory might contain
  this:
<div class="Pp"></div>
<pre>
  Build qw(
        display/Conscript
        mouse/Conscript
  );
<div class="Pp"></div>
</pre>
Experience has shown that the former model is a little easier to understand,
  since the whole construction tree is laid out in front of you, at the
  top-level. Hybrid schemes are also possible. A separately maintained component
  that needs to be incorporated into a build tree, for example, might hook into
  the build tree in one place, but define its own construction hierarchy.
<div class="Pp"></div>
By default, Cons does not change its working directory to the directory
  containing a subsidiary <i>Conscript</i> file it is including. This behavior
  can be enabled for a build by specifying, in the top-level <i>Construct</i>
  file:
<div class="Pp"></div>
<pre>
  Conscript_chdir 1;
<div class="Pp"></div>
</pre>
When enabled, Cons will change to the subsidiary <i>Conscript</i> file's
  containing directory while reading in that file, and then change back to the
  top-level directory once the file has been processed.
<div class="Pp"></div>
It is expected that this behavior will become the default in some future version
  of Cons. To prepare for this transition, builds that expect Cons to remain at
  the top of the build while it reads in a subsidiary <i>Conscript</i> file
  should explicitly disable this feature as follows:
<div class="Pp"></div>
<pre>
  Conscript_chdir 0;
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Relative, top-relative, and absolute file names</b>
<div class="Pp"></div>
You may have noticed that the file names specified to the Build command are
  relative to the location of the script it is invoked from. This is generally
  true for other filename arguments to other commands, too, although we might as
  well mention here that if you begin a file name with a hash mark, ``#'', then
  that file is interpreted relative to the top-level directory (where the
  <i>Construct</i> file resides). And, not surprisingly, if you begin it with
  ``/'', then it is considered to be an absolute pathname. This is true even on
  systems which use a back slash rather than a forward slash to name absolute
  paths.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Using modules in build scripts</b>
<div class="Pp"></div>
You may pull modules into each <i>Conscript</i> file using the normal Perl `use'
  or `require' statements:
<div class="Pp"></div>
<pre>
  use English;
  require My::Module;
<div class="Pp"></div>
</pre>
Each `use' or `require' only affects the one <i>Conscript</i> file in which it
  appears. To use a module in multiple <i>Conscript</i> files, you must put a
  `use' or `require' statement in each one that needs the module.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Scope of variables</b>
<div class="Pp"></div>
The top-level <i>Construct</i> file and all <i>Conscript</i> files begin life in
  a common, separate Perl package. <b>Cons</b> controls the symbol table for the
  package so that, the symbol table for each script is empty, except for the
  <i>Construct</i> file, which gets some of the command line arguments. All of
  the variables that are set or used, therefore, are set by the script
  itself--not by some external script.
<div class="Pp"></div>
Variables can be explicitly <b>imported</b> by a script from its parent script.
  To import a variable, it must have been <b>exported</b> by the parent and
  initialized (otherwise an error will occur).
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The Export command</b>
<div class="Pp"></div>
The `Export' command is used as in the following example:
<div class="Pp"></div>
<pre>
  $env = new cons();
  $INCLUDE = &quot;#export/include&quot;;
  $LIB = &quot;#export/lib&quot;;
  Export qw( env INCLUDE LIB );
  Build qw( util/Conscript );
<div class="Pp"></div>
</pre>
The values of the simple variables mentioned in the `Export' list will be
  squirreled away by any subsequent `Build' commands. The `Export' command will
  only export Perl <b>scalar</b> variables, that is, variables whose name begins
  with `$'. Other variables, objects, etc. can be exported by reference--but all
  scripts will refer to the same object, and this object should be considered to
  be read-only by the subsidiary scripts and by the original exporting script.
  It's acceptable, however, to assign a new value to the exported scalar
  variable--that won't change the underlying variable referenced. This sequence,
  for example, is OK:
<div class="Pp"></div>
<pre>
  $env = new cons();
  Export qw( env INCLUDE LIB );
  Build qw( util/Conscript );
  $env = new cons(CFLAGS =&gt; '-O');
  Build qw( other/Conscript );
<div class="Pp"></div>
</pre>
It doesn't matter whether the variable is set before or after the `Export'
  command. The important thing is the value of the variable at the time the
  `Build' command is executed. This is what gets squirreled away. Any subsequent
  `Export' commands, by the way, invalidate the first: you must mention all the
  variables you wish to export on each `Export' command.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The Import command</b>
<div class="Pp"></div>
Variables exported by the `Export' command can be imported into subsidiary
  scripts by the `Import' command. The subsidiary script always imports
  variables directly from the superior script. Consider this example:
<div class="Pp"></div>
<pre>
  Import qw( env INCLUDE );
<div class="Pp"></div>
</pre>
This is only legal if the parent script exported both `$env' and `$INCLUDE'. It
  also must have given each of these variables values. It is OK for the
  subsidiary script to only import a subset of the exported variables (in this
  example, `$LIB', which was exported by the previous example, is not imported).
<div class="Pp"></div>
All the imported variables are automatically re-exported, so the sequence:
<div class="Pp"></div>
<pre>
  Import qw ( env INCLUDE );
  Build qw ( beneath-me/Conscript );
<div class="Pp"></div>
</pre>
will supply both `$env' and `$INCLUDE' to the subsidiary file. If only `$env' is
  to be exported, then the following will suffice:
<div class="Pp"></div>
<pre>
  Import qw ( env INCLUDE );
  Export qw ( env );
  Build qw ( beneath-me/Conscript );
<div class="Pp"></div>
</pre>
Needless to say, the variables may be modified locally before invoking `Build'
  on the subsidiary script.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Build script evaluation order</b>
<div class="Pp"></div>
The only constraint on the ordering of build scripts is that superior scripts
  are evaluated before their inferior scripts. The top-level <i>Construct</i>
  file, for instance, is evaluated first, followed by any inferior scripts. This
  is all you really need to know about the evaluation order, since order is
  generally irrelevant. Consider the following `Build' command:
<div class="Pp"></div>
<pre>
  Build qw(
        drivers/display/Conscript
        drivers/mouse/Conscript
        parser/Conscript
        utilities/Conscript
  );
<div class="Pp"></div>
</pre>
We've chosen to put the script names in alphabetical order, simply because
  that's the most convenient for maintenance purposes. Changing the order will
  make no difference to the build.
<h1 class="Sh" title="Sh" id="A_Model_for_sharing_files"><a class="selflink" href="#A_Model_for_sharing_files">A
  Model for sharing files</a></h1>
<b>Some simple conventions</b>
<div class="Pp"></div>
In any complex software system, a method for sharing build products needs to be
  established. We propose a simple set of conventions which are trivial to
  implement with Cons, but very effective.
<div class="Pp"></div>
The basic rule is to require that all build products which need to be shared
  between directories are shared via an intermediate directory. We have
  typically called this <i>export</i>, and, in a C environment, provided
  conventional sub-directories of this directory, such as <i>include</i>,
  <i>lib</i>, <i>bin</i>, etc.
<div class="Pp"></div>
These directories are defined by the top-level <i>Construct</i> file. A simple
  <i>Construct</i> file for a <b>Hello, World!</b> application, organized using
  multiple directories, might look like this:
<div class="Pp"></div>
<pre>
  # Construct file for Hello, World!
<div class="Pp"></div>
</pre>
<pre>
  # Where to put all our shared products.
  $EXPORT = '#export';
<div class="Pp"></div>
</pre>
<pre>
  Export qw( CONS INCLUDE LIB BIN );
<div class="Pp"></div>
</pre>
<pre>
  # Standard directories for sharing products.
  $INCLUDE = &quot;$EXPORT/include&quot;;
  $LIB = &quot;$EXPORT/lib&quot;;
  $BIN = &quot;$EXPORT/bin&quot;;
<div class="Pp"></div>
</pre>
<pre>
  # A standard construction environment.
  $CONS = new cons (
        CPPPATH =&gt; $INCLUDE,    # Include path for C Compilations
        LIBPATH =&gt; $LIB,        # Library path for linking programs
        LIBS =&gt; '-lworld',      # List of standard libraries
  );
<div class="Pp"></div>
</pre>
<pre>
  Build qw(
        hello/Conscript
        world/Conscript
  );
<div class="Pp"></div>
</pre>
The <i>world</i> directory's <i>Conscript</i> file looks like this:
<div class="Pp"></div>
<pre>
  # Conscript file for directory world
  Import qw( CONS INCLUDE LIB );
<div class="Pp"></div>
</pre>
<pre>
  # Install the products of this directory
  Install $CONS $LIB, 'libworld.a';
  Install $CONS $INCLUDE, 'world.h';
<div class="Pp"></div>
</pre>
<pre>
  # Internal products
  Library $CONS 'libworld.a', 'world.c';
<div class="Pp"></div>
</pre>
and the <i>hello</i> directory's <i>Conscript</i> file looks like this:
<div class="Pp"></div>
<pre>
  # Conscript file for directory hello
  Import qw( CONS BIN );
<div class="Pp"></div>
</pre>
<pre>
  # Exported products
  Install $CONS $BIN, 'hello';
<div class="Pp"></div>
</pre>
<pre>
  # Internal products
  Program $CONS 'hello', 'hello.c';
<div class="Pp"></div>
</pre>
To construct a <b>Hello, World!</b> program with this directory structure, go to
  the top-level directory, and invoke `cons' with the appropriate arguments. In
  the following example, we tell Cons to build the directory <i>export</i>. To
  build a directory, Cons recursively builds all known products within that
  directory (only if they need rebuilding, of course). If any of those products
  depend upon other products in other directories, then those will be built,
  too.
<div class="Pp"></div>
<pre>
  % cons export
  Install world/world.h as export/include/world.h
  cc -Iexport/include -c hello/hello.c -o hello/hello.o
  cc -Iexport/include -c world/world.c -o world/world.o
  ar r world/libworld.a world/world.o
  ar: creating world/libworld.a
  ranlib world/libworld.a
  Install world/libworld.a as export/lib/libworld.a
  cc -o hello/hello hello/hello.o -Lexport/lib -lworld
  Install hello/hello as export/bin/hello
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Clean, understandable, location-independent scripts</b>
<div class="Pp"></div>
You'll note that the two <i>Conscript</i> files are very clean and to-the-point.
  They simply specify products of the directory and how to build those products.
  The build instructions are minimal: they specify which construction
  environment to use, the name of the product, and the name of the inputs. Note
  also that the scripts are location-independent: if you wish to reorganize your
  source tree, you are free to do so: you only have to change the
  <i>Construct</i> file (in this example), to specify the new locations of the
  <i>Conscript</i> files. The use of an export tree makes this goal easy.
<div class="Pp"></div>
Note, too, how Cons takes care of little details for you. All the <i>export</i>
  directories, for example, were made automatically. And the installed files
  were really hard-linked into the respective export directories, to save space
  and time. This attention to detail saves considerable work, and makes it even
  easier to produce simple, maintainable scripts.
<h1 class="Sh" title="Sh" id="Separating_source_and_build_trees"><a class="selflink" href="#Separating_source_and_build_trees">Separating
  source and build trees</a></h1>
It's often desirable to keep any derived files from the build completely
  separate from the source files. This makes it much easier to keep track of
  just what is a source file, and also makes it simpler to handle <b>variant</b>
  builds, especially if you want the variant builds to co-exist.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Separating build and source directories using the Link command</b>
<div class="Pp"></div>
Cons provides a simple mechanism that handles all of these requirements. The
  `Link' command is invoked as in this example:
<div class="Pp"></div>
<pre>
  Link 'build' =&gt; 'src';
<div class="Pp"></div>
</pre>
The specified directories are ``linked'' to the specified source directory.
  Let's suppose that you setup a source directory, <i>src</i>, with the
  sub-directories <i>world</i> and <i>hello</i> below it, as in the previous
  example. You could then substitute for the original build lines the following:
<div class="Pp"></div>
<pre>
  Build qw(
        build/world/Conscript
        build/hello/Conscript
  );
<div class="Pp"></div>
</pre>
Notice that you treat the <i>Conscript</i> file as if it existed in the build
  directory. Now if you type the same command as before, you will get the
  following results:
<div class="Pp"></div>
<pre>
  % cons export
  Install build/world/world.h as export/include/world.h
  cc -Iexport/include -c build/hello/hello.c -o build/hello/hello.o
  cc -Iexport/include -c build/world/world.c -o build/world/world.o
  ar r build/world/libworld.a build/world/world.o
  ar: creating build/world/libworld.a
  ranlib build/world/libworld.a
  Install build/world/libworld.a as export/lib/libworld.a
  cc -o build/hello/hello build/hello/hello.o -Lexport/lib -lworld
  Install build/hello/hello as export/bin/hello
<div class="Pp"></div>
</pre>
Again, Cons has taken care of the details for you. In particular, you will
  notice that all the builds are done using source files and object files from
  the build directory. For example, <i>build/world/world.o</i> is compiled from
  <i>build/world/world.c</i>, and <i>export/include/world.h</i> is installed
  from <i>build/world/world.h</i>. This is accomplished on most systems by the
  simple expedient of ``hard'' linking the required files from each source
  directory into the appropriate build directory.
<div class="Pp"></div>
The links are maintained correctly by Cons, no matter what you do to the source
  directory. If you modify a source file, your editor may do this ``in place''
  or it may rename it first and create a new file. In the latter case, any hard
  link will be lost. Cons will detect this condition the next time the source
  file is needed, and will relink it appropriately.
<div class="Pp"></div>
You'll also notice, by the way, that <b>no</b> changes were required to the
  underlying <i>Conscript</i> files. And we can go further, as we shall see in
  the next section.
<h1 class="Sh" title="Sh" id="Variant_builds"><a class="selflink" href="#Variant_builds">Variant
  builds</a></h1>
<b>Hello, World! for baNaNa and peAcH OS's</b>
<div class="Pp"></div>
Variant builds require just another simple extension. Let's take as an example a
  requirement to allow builds for both the baNaNa and peAcH operating systems.
  In this case, we are using a distributed file system, such as NFS to access
  the particular system, and only one or the other of the systems has to be
  compiled for any given invocation of `cons'. Here's one way we could set up
  the <i>Construct</i> file for our <b>Hello, World!</b> application:
<div class="Pp"></div>
<pre>
  # Construct file for Hello, World!
<div class="Pp"></div>
</pre>
<pre>
  die qq(OS must be specified) unless $OS = $ARG{OS};
  die qq(OS must be &quot;peach&quot; or &quot;banana&quot;)
        if $OS ne &quot;peach&quot; &amp;&amp; $OS ne &quot;banana&quot;;
<div class="Pp"></div>
</pre>
<pre>
  # Where to put all our shared products.
  $EXPORT = &quot;#export/$OS&quot;;
<div class="Pp"></div>
</pre>
<pre>
  Export qw( CONS INCLUDE LIB BIN );
<div class="Pp"></div>
</pre>
<pre>
  # Standard directories for sharing products.
  $INCLUDE = &quot;$EXPORT/include&quot;;
  $LIB = &quot;$EXPORT/lib&quot;;
  $BIN = &quot;$EXPORT/bin&quot;;
<div class="Pp"></div>
</pre>
<pre>
  # A standard construction environment.
  $CONS = new cons (
        CPPPATH =&gt; $INCLUDE,    # Include path for C Compilations
        LIBPATH =&gt; $LIB,        # Library path for linking programs
        LIBS =&gt; '-lworld',      # List of standard libraries
  );
<div class="Pp"></div>
</pre>
<pre>
  # $BUILD is where we will derive everything.
  $BUILD = &quot;#build/$OS&quot;;
<div class="Pp"></div>
</pre>
<pre>
  # Tell cons where the source files for $BUILD are.
  Link $BUILD =&gt; 'src';
<div class="Pp"></div>
</pre>
<pre>
  Build (
        &quot;$BUILD/hello/Conscript&quot;,
        &quot;$BUILD/world/Conscript&quot;,
  );
<div class="Pp"></div>
</pre>
Now if we login to a peAcH system, we can build our <b>Hello, World!</b>
  application for that platform:
<div class="Pp"></div>
<pre>
  % cons export OS=peach
  Install build/peach/world/world.h as export/peach/include/world.h
  cc -Iexport/peach/include -c build/peach/hello/hello.c -o build/peach/hello/hello.o
  cc -Iexport/peach/include -c build/peach/world/world.c -o build/peach/world/world.o
  ar r build/peach/world/libworld.a build/peach/world/world.o
  ar: creating build/peach/world/libworld.a
  ranlib build/peach/world/libworld.a
  Install build/peach/world/libworld.a as export/peach/lib/libworld.a
  cc -o build/peach/hello/hello build/peach/hello/hello.o -Lexport/peach/lib -lworld
  Install build/peach/hello/hello as export/peach/bin/hello
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Variations on a theme</b>
<div class="Pp"></div>
Other variations of this model are possible. For example, you might decide that
  you want to separate out your include files into platform dependent and
  platform independent files. In this case, you'd have to define an alternative
  to `$INCLUDE' for platform-dependent files. Most <i>Conscript</i> files,
  generating purely platform-independent include files, would not have to
  change.
<div class="Pp"></div>
You might also want to be able to compile your whole system with debugging or
  profiling, for example, enabled. You could do this with appropriate command
  line options, such as `DEBUG=on'. This would then be translated into the
  appropriate platform-specific requirements to enable debugging (this might
  include turning off optimization, for example). You could optionally vary the
  name space for these different types of systems, but, as we'll see in the next
  section, it's not <b>essential</b> to do this, since Cons is pretty smart
  about rebuilding things when you change options.
<h1 class="Sh" title="Sh" id="Signatures"><a class="selflink" href="#Signatures">Signatures</a></h1>
<b>MD5 cryptographic signatures</b>
<div class="Pp"></div>
Whenever Cons creates a derived file, it stores a <b>signature</b> for that
  file. The signature is stored in a separate file, one per directory. After the
  previous example was compiled, the <i>.consign</i> file in the
  <i>build/peach/world</i> directory looked like this:
<div class="Pp"></div>
<pre>
  world.o:834179303 23844c0b102ecdc0b4548d1cd1cbd8c6
  libworld.a:834179304 9bf6587fa06ec49d864811a105222c00
<div class="Pp"></div>
</pre>
The first number is a timestamp--for a UNIX systems, this is typically the
  number of seconds since January 1st, 1970. The second value is an MD5
  checksum. The <b>Message Digest Algorithm</b> is an algorithm that, given an
  input string, computes a strong cryptographic signature for that string. The
  MD5 checksum stored in the <i>.consign</i> file is, in effect, a digest of all
  the dependency information for the specified file. So, for example, for the
  <i>world.o</i> file, this includes at least the <i>world.c</i> file, and also
  any header files that Cons knows about that are included, directly or
  indirectly by <i>world.c</i>. Not only that, but the actual command line that
  was used to generate <i>world.o</i> is also fed into the computation of the
  signature. Similarly, <i>libworld.a</i> gets a signature which ``includes''
  all the signatures of its constituents (and hence, transitively, the
  signatures of <b>their</b> constituents), as well as the command line that
  created the file.
<div class="Pp"></div>
The signature of a non-derived file is computed, by default, by taking the
  current modification time of the file and the file's entry name (unless there
  happens to be a current <i>.consign</i> entry for that file, in which case
  that signature is used).
<div class="Pp"></div>
Notice that there is no need for a derived file to depend upon any particular
  <i>Construct</i> or <i>Conscript</i> file--if changes to these files affect
  the file in question, then this will be automatically reflected in its
  signature, since relevant parts of the command line are included in the
  signature. Unrelated changes will have no effect.
<div class="Pp"></div>
When Cons considers whether to derive a particular file, then, it first computes
  the expected signature of the file. It then compares the file's last
  modification time with the time recorded in the <i>.consign</i> entry, if one
  exists. If these times match, then the signature stored in the <i>.consign</i>
  file is considered to be accurate. If the file's previous signature does not
  match the new, expected signature, then the file must be rederived.
<div class="Pp"></div>
Notice that a file will be rederived whenever anything about a dependent file
  changes. In particular, notice that <b>any</b> change to the modification time
  of a dependent (forward or backwards in time) will force recompilation of the
  derived file.
<div class="Pp"></div>
The use of these signatures is an extremely simple, efficient, and effective
  method of improving--dramatically--the reproducibility of a system.
<div class="Pp"></div>
We'll demonstrate this with a simple example:
<div class="Pp"></div>
<pre>
  # Simple &quot;Hello, World!&quot; Construct file
  $CFLAGS = '-g' if $ARG{DEBUG} eq 'on';
  $CONS = new cons(CFLAGS =&gt; $CFLAGS);
  Program $CONS 'hello', 'hello.c';
<div class="Pp"></div>
</pre>
Notice how Cons recompiles at the appropriate times:
<div class="Pp"></div>
<pre>
  % cons hello
  cc -c hello.c -o hello.o
  cc -o hello hello.o
  % cons hello
  cons: &quot;hello&quot; is up-to-date.
  % cons DEBUG=on hello
  cc -g -c hello.c -o hello.o
  cc -o hello hello.o
  % cons DEBUG=on hello
  cons: &quot;hello&quot; is up-to-date.
  % cons hello
  cc -c hello.c -o hello.o
  cc -o hello hello.o
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="Code_Repositories"><a class="selflink" href="#Code_Repositories">Code
  Repositories</a></h1>
Many software development organizations will have one or more central repository
  directory trees containing the current source code for one or more projects,
  as well as the derived object files, libraries, and executables. In order to
  reduce unnecessary recompilation, it is useful to use files from the
  repository to build development software--assuming, of course, that no newer
  dependency file exists in the local build tree.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Repository</b>
<div class="Pp"></div>
Cons provides a mechanism to specify a list of code repositories that will be
  searched, in-order, for source files and derived files not found in the local
  build directory tree.
<div class="Pp"></div>
The following lines in a <i>Construct</i> file will instruct Cons to look first
  under the <i>/usr/experiment/repository</i> directory and then under the
  <i>/usr/product/repository</i> directory:
<div class="Pp"></div>
<pre>
  Repository qw (
        /usr/experiment/repository
        /usr/product/repository
  );
<div class="Pp"></div>
</pre>
The repository directories specified may contain source files, derived files
  (objects, libraries and executables), or both. If there is no local file
  (source or derived) under the directory in which Cons is executed, then the
  first copy of a same-named file found under a repository directory will be
  used to build any local derived files.
<div class="Pp"></div>
Cons maintains one global list of repositories directories. Cons will eliminate
  the current directory, and any non-existent directories, from the list.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Finding the Construct file in a Repository</b>
<div class="Pp"></div>
Cons will also search for <i>Construct</i> and <i>Conscript</i> files in the
  repository tree or trees. This leads to a chicken-and-egg situation, though:
  how do you look in a repository tree for a <i>Construct</i> file if the
  <i>Construct</i> file tells you where the repository is? To get around this,
  repositories may be specified via `-R' options on the command line:
<div class="Pp"></div>
<pre>
  % cons -R /usr/experiment/repository -R /usr/product/repository .
<div class="Pp"></div>
</pre>
Any repository directories specified in the <i>Construct</i> or <i>Conscript</i>
  files will be appended to the repository directories specified by command-line
  `-R' options.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Repository source files</b>
<div class="Pp"></div>
If the source code (include the <i>Conscript</i> file) for the library version
  of the <i>Hello, World!</i> C application is in a repository (with no derived
  files), Cons will use the repository source files to create the local object
  files and executable file:
<div class="Pp"></div>
<pre>
  % cons -R /usr/src_only/repository hello
  gcc -c /usr/src_only/repository/hello.c -o hello.o
  gcc -c /usr/src_only/repository/world.c -o world.o
  ar r libworld.a world.o
  ar: creating libworld.a
  ranlib libworld.a
  gcc -o hello hello.o libworld.a
<div class="Pp"></div>
</pre>
Creating a local source file will cause Cons to rebuild the appropriate derived
  file or files:
<div class="Pp"></div>
<pre>
  % pico world.c
    [EDIT]
  % cons -R /usr/src_only/repository hello
  gcc -c world.c -o world.o
  ar r libworld.a world.o
  ar: creating libworld.a
  ranlib libworld.a
  gcc -o hello hello.o libworld.a
<div class="Pp"></div>
</pre>
And removing the local source file will cause Cons to revert back to building
  the derived files from the repository source:
<div class="Pp"></div>
<pre>
  % rm world.c
  % cons -R /usr/src_only/repository hello
  gcc -c /usr/src_only/repository/world.c -o world.o
  ar r libworld.a world.o
  ar: creating libworld.a
  ranlib libworld.a
  gcc -o hello hello.o libworld.a
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Repository derived files</b>
<div class="Pp"></div>
If a repository tree contains derived files (usually object files, libraries, or
  executables), Cons will perform its normal signature calculation to decide
  whether the repository file is up-to-date or a derived file must be built
  locally. This means that, in order to ensure correct signature calculation, a
  repository tree must also contain the <i>.consign</i> files that were created
  by Cons when generating the derived files.
<div class="Pp"></div>
This would usually be accomplished by building the software in the repository
  (or, alternatively, in a build directory, and then copying the result to the
  repository):
<div class="Pp"></div>
<pre>
  % cd /usr/all/repository
  % cons hello
  gcc -c hello.c -o hello.o
  gcc -c world.c -o world.o
  ar r libworld.a world.o
  ar: creating libworld.a
  ranlib libworld.a
  gcc -o hello hello.o libworld.a
<div class="Pp"></div>
</pre>
(This is safe even if the <i>Construct</i> file lists the
  <i>/usr/all/repository</i> directory in a `Repository' command because Cons
  will remove the current directory from the repository list.)
<div class="Pp"></div>
Now if we want to build a copy of the application with our own <i>hello.c</i>
  file, we only need to create the one necessary source file, and use the `-R'
  option to have Cons use other files from the repository:
<div class="Pp"></div>
<pre>
  % mkdir $HOME/build1
  % cd $HOME/build1
  % ed hello.c
    [EDIT]
  % cons -R /usr/all/repository hello
  gcc -c hello.c -o hello.o
  gcc -o hello hello.o /usr/all/repository/libworld.a
<div class="Pp"></div>
</pre>
Notice that Cons has not bothered to recreate a local <i>libworld.a</i> library
  (or recompile the <i>world.o</i> module), but instead uses the
  already-compiled version from the repository.
<div class="Pp"></div>
Because the MD5 signatures that Cons puts in the <i>.consign</i> file contain
  timestamps for the derived files, the signature timestamps must match the file
  timestamps for a signature to be considered valid.
<div class="Pp"></div>
Some software systems may alter the timestamps on repository files (by copying
  them, e.g.), in which case Cons will, by default, assume the repository
  signatures are invalid and rebuild files unnecessarily. This behavior may be
  altered by specifying:
<div class="Pp"></div>
<pre>
  Repository_Sig_Times_OK 0;
<div class="Pp"></div>
</pre>
This tells Cons to ignore timestamps when deciding whether a signature is valid.
  (Note that avoiding this sanity check means there must be proper control over
  the repository tree to ensure that the derived files cannot be modified
  without updating the <i>.consign</i> signature.)
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Local copies of files</b>
<div class="Pp"></div>
If the repository tree contains the complete results of a build, and we try to
  build from the repository without any files in our local tree, something
  moderately surprising happens:
<div class="Pp"></div>
<pre>
  % mkdir $HOME/build2
  % cd $HOME/build2
  % cons -R /usr/all/repository hello
  cons: &quot;hello&quot; is up-to-date.
<div class="Pp"></div>
</pre>
Why does Cons say that the <i>hello</i> program is up-to-date when there is no
  <i>hello</i> program in the local build directory? Because the repository (not
  the local directory) contains the up-to-date <i>hello</i> program, and Cons
  correctly determines that nothing needs to be done to rebuild this up-to-date
  copy of the file.
<div class="Pp"></div>
There are, however, many times in which it is appropriate to ensure that a local
  copy of a file always exists. A packaging or testing script, for example, may
  assume that certain generated files exist locally. Instead of making these
  subsidiary scripts aware of the repository directory, the `Local' command may
  be added to a <i>Construct</i> or <i>Conscript</i> file to specify that a
  certain file or files must appear in the local build directory:
<div class="Pp"></div>
<pre>
  Local qw(
        hello
  );
<div class="Pp"></div>
</pre>
Then, if we re-run the same command, Cons will make a local copy of the program
  from the repository copy (telling you that it is doing so):
<div class="Pp"></div>
<pre>
  % cons -R /usr/all/repository hello
  Local copy of hello from /usr/all/repository/hello
  cons: &quot;hello&quot; is up-to-date.
<div class="Pp"></div>
</pre>
Notice that, because the act of making the local copy is not considered a
  &quot;build&quot; of the <i>hello</i> file, Cons still reports that it is
  up-to-date.
<div class="Pp"></div>
Creating local copies is most useful for files that are being installed into an
  intermediate directory (for sharing with other directories) via the `Install'
  command. Accompanying the `Install' command for a file with a companion
  `Local' command is so common that Cons provides a `Install_Local' command as a
  convenient way to do both:
<div class="Pp"></div>
<pre>
  Install_Local $env, '#export', 'hello';
<div class="Pp"></div>
</pre>
is exactly equivalent to:
<div class="Pp"></div>
<pre>
  Install $env '#export', 'hello';
  Local '#export/hello';
<div class="Pp"></div>
</pre>
Both the `Local' and `Install_Local' commands update the local <i>.consign</i>
  file with the appropriate file signatures, so that future builds are performed
  correctly.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Repository dependency analysis</b>
<div class="Pp"></div>
Due to its built-in scanning, Cons will search the specified repository trees
  for included <i>.h</i> files. Unless the compiler also knows about the
  repository trees, though, it will be unable to find <i>.h</i> files that only
  exist in a repository. If, for example, the <i>hello.c</i> file includes the
  <i>hello.h</i> file in its current directory:
<div class="Pp"></div>
<pre>
  % cons -R /usr/all/repository hello
  gcc -c /usr/all/repository/hello.c -o hello.o
  /usr/all/repository/hello.c:1: hello.h: No such file or directory
<div class="Pp"></div>
</pre>
Solving this problem forces some requirements onto the way construction
  environments are defined and onto the way the C `#include' preprocessor
  directive is used to include files.
<div class="Pp"></div>
In order to inform the compiler about the repository trees, Cons will add
  appropriate `-I' flags to the compilation commands. This means that the
  `CPPPATH' variable in the construct environment must explicitly specify all
  subdirectories which are to be searched for included files, including the
  current directory. Consequently, we can fix the above example by changing the
  environment creation in the <i>Construct</i> file as follows:
<div class="Pp"></div>
<pre>
  $env = new cons(
        CC      =&gt; 'gcc',
        CPPPATH =&gt; '.',
        LIBS    =&gt; 'libworld.a',
  );
<div class="Pp"></div>
</pre>
Due to the definition of the `CPPPATH' variable, this yields, when we re-execute
  the command:
<div class="Pp"></div>
<pre>
  % cons -R /usr/all/repository hello
  gcc -c -I. -I/usr/all/repository /usr/all/repository/hello.c -o hello.o
  gcc -o hello hello.o /usr/all/repository/libworld.a
<div class="Pp"></div>
</pre>
The order of the `-I' flags replicates, for the C preprocessor, the same
  repository-directory search path that Cons uses for its own dependency
  analysis. If there are multiple repositories and multiple `CPPPATH'
  directories, Cons will append the repository directories to the beginning of
  each `CPPPATH' directory, rapidly multiplying the number of `-I' flags. As an
  extreme example, a <i>Construct</i> file containing:
<div class="Pp"></div>
<pre>
  Repository qw(
        /u1
        /u2
  );
<div class="Pp"></div>
</pre>
<pre>
  $env = new cons(
        CPPPATH =&gt; 'a:b:c',
  );
<div class="Pp"></div>
</pre>
Would yield a compilation command of:
<div class="Pp"></div>
<pre>
  cc -Ia -I/u1/a -I/u2/a -Ib -I/u1/b -I/u2/b -Ic -I/u1/c -I/u2/c -c hello.c -o hello.o
<div class="Pp"></div>
</pre>
Because Cons relies on the compiler's `-I' flags to communicate the order in
  which repository directories must be searched, Cons' handling of repository
  directories is fundamentally incompatible with using double-quotes on the
  `#include' directives in your C source code:
<div class="Pp"></div>
<pre>
  #include &quot;file.h&quot;     /* DON'T USE DOUBLE-QUOTES LIKE THIS */
<div class="Pp"></div>
</pre>
This is because most C preprocessors, when faced with such a directive, will
  always first search the directory containing the source file. This undermines
  the elaborate `-I' options that Cons constructs to make the preprocessor
  conform to its preferred search path.
<div class="Pp"></div>
Consequently, when using repository trees in Cons, <b>always</b> use
  angle-brackets for included files:
<div class="Pp"></div>
<pre>
  #include &lt;file.h&gt;     /* USE ANGLE-BRACKETS INSTEAD */
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Repository_List</b>
<div class="Pp"></div>
Cons provides a `Repository_List' command to return a list of all repository
  directories in their current search order. This can be used for debugging, or
  to do more complex Perl stuff:
<div class="Pp"></div>
<pre>
  @list = Repository_List;
  print join(' ', @list), &quot;\n&quot;;
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Repository interaction with other Cons features</b>
<div class="Pp"></div>
Cons' handling of repository trees interacts correctly with other Cons
  features--which is to say, it generally does what you would expect.
<div class="Pp"></div>
Most notably, repository trees interact correctly, and rather powerfully, with
  the 'Link' command. A repository tree may contain one or more subdirectories
  for version builds established via `Link' to a source subdirectory. Cons will
  search for derived files in the appropriate build subdirectories under the
  repository tree.
<h1 class="Sh" title="Sh" id="Default_targets"><a class="selflink" href="#Default_targets">Default
  targets</a></h1>
Until now, we've demonstrated invoking Cons with an explicit target to build:
<div class="Pp"></div>
<pre>
  % cons hello
<div class="Pp"></div>
</pre>
Normally, Cons does not build anything unless a target is specified, but
  specifying '.' (the current directory) will build everything:
<div class="Pp"></div>
<pre>
  % cons                # does not build anything
<div class="Pp"></div>
</pre>
<pre>
  % cons .              # builds everything under the top-level directory
<div class="Pp"></div>
</pre>
Adding the `Default' method to any <i>Construct</i> or <i>Conscript</i> file
  will add the specified targets to a list of default targets. Cons will build
  these defaults if there are no targets specified on the command line. So
  adding the following line to the top-level <i>Construct</i> file will mimic
  Make's typical behavior of building everything by default:
<div class="Pp"></div>
<pre>
  Default '.';
<div class="Pp"></div>
</pre>
The following would add the <i>hello</i> and <i>goodbye</i> commands (in the
  same directory as the <i>Construct</i> or <i>Conscript</i> file) to the
  default list:
<div class="Pp"></div>
<pre>
  Default qw(
        hello
        goodbye
  );
<div class="Pp"></div>
</pre>
The `Default' method may be used more than once to add targets to the default
  list.
<h1 class="Sh" title="Sh" id="Selective_builds"><a class="selflink" href="#Selective_builds">Selective
  builds</a></h1>
Cons provides two methods for reducing the size of given build. The first is by
  specifying targets on the command line, and the second is a method for pruning
  the build tree. We'll consider target specification first.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Selective targeting</b>
<div class="Pp"></div>
Like make, Cons allows the specification of ``targets'' on the command line.
  Cons targets may be either files or directories. When a directory is
  specified, this is simply a short-hand notation for every derivable
  product--that Cons knows about--in the specified directory and below. For
  example:
<div class="Pp"></div>
<pre>
  % cons build/hello/hello.o
<div class="Pp"></div>
</pre>
means build <i>hello.o</i> and everything that <i>hello.o</i> might need. This
  is from a previous version of the <b>Hello, World!</b> program in which
  <i>hello.o</i> depended upon <i>export/include/world.h</i>. If that file is
  not up-to-date (because someone modified <i>src/world/world.h)</i>, then it
  will be rebuilt, even though it is in a directory remote from
  <i>build/hello</i>.
<div class="Pp"></div>
In this example:
<div class="Pp"></div>
<pre>
  % cons build
<div class="Pp"></div>
</pre>
Everything in the <i>build</i> directory is built, if necessary. Again, this may
  cause more files to be built. In particular, both
  <i>export/include/world.h</i> and <i>export/lib/libworld.a</i> are required by
  the <i>build/hello</i> directory, and so they will be built if they are
  out-of-date.
<div class="Pp"></div>
If we do, instead:
<div class="Pp"></div>
<pre>
  % cons export
<div class="Pp"></div>
</pre>
then only the files that should be installed in the export directory will be
  rebuilt, if necessary, and then installed there. Note that `cons build' might
  build files that `cons export' doesn't build, and vice-versa.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>No ``special'' targets</b>
<div class="Pp"></div>
With Cons, make-style ``special'' targets are not required. The simplest analog
  with Cons is to use special <i>export</i> directories, instead. Let's suppose,
  for example, that you have a whole series of unit tests that are associated
  with your code. The tests live in the source directory near the code.
  Normally, however, you don't want to build these tests. One solution is to
  provide all the build instructions for creating the tests, and then to install
  the tests into a separate part of the tree. If we install the tests in a
  top-level directory called <i>tests</i>, then:
<div class="Pp"></div>
<pre>
  % cons tests
<div class="Pp"></div>
</pre>
will build all the tests.
<div class="Pp"></div>
<pre>
  % cons export
<div class="Pp"></div>
</pre>
will build the production version of the system (but not the tests), and:
<div class="Pp"></div>
<pre>
  % cons build
<div class="Pp"></div>
</pre>
should probably be avoided (since it will compile tests unecessarily).
<div class="Pp"></div>
If you want to build just a single test, then you could explicitly name the test
  (in either the <i>tests</i> directory or the <i>build</i> directory). You
  could also aggregate the tests into a convenient hierarchy within the tests
  directory. This hierarchy need not necessarily match the source hierarchy, in
  much the same manner that the include hierarchy probably doesn't match the
  source hierarchy (the include hierarchy is unlikely to be more than two levels
  deep, for C programs).
<div class="Pp"></div>
If you want to build absolutely everything in the tree (subject to whatever
  options you select), you can use:
<div class="Pp"></div>
<pre>
  % cons .
<div class="Pp"></div>
</pre>
This is not particularly efficient, since it will redundantly walk all the
  trees, including the source tree. The source tree, of course, may have
  buildable objects in it--nothing stops you from doing this, even if you
  normally build in a separate build tree.
<h1 class="Sh" title="Sh" id="Build_Pruning"><a class="selflink" href="#Build_Pruning">Build
  Pruning</a></h1>
In conjunction with target selection, <b>build pruning</b> can be used to reduce
  the scope of the build. In the previous peAcH and baNaNa example, we have
  already seen how script-driven build pruning can be used to make only half of
  the potential build available for any given invocation of `cons'. Cons also
  provides, as a convenience, a command line convention that allows you to
  specify which <i>Conscript</i> files actually get ``built''--that is,
  incorporated into the build tree. For example:
<div class="Pp"></div>
<pre>
  % cons build +world
<div class="Pp"></div>
</pre>
The `+' argument introduces a Perl regular expression. This must, of course, be
  quoted at the shell level if there are any shell meta-characters within the
  expression. The expression is matched against each <i>Conscript</i> file which
  has been mentioned in a `Build' statement, and only those scripts with
  matching names are actually incorporated into the build tree. Multiple such
  arguments are allowed, in which case a match against any of them is sufficient
  to cause a script to be included.
<div class="Pp"></div>
In the example, above, the <i>hello</i> program will not be built, since Cons
  will have no knowledge of the script <i>hello/Conscript</i>. The
  <i>libworld.a</i> archive will be built, however, if need be.
<div class="Pp"></div>
There are a couple of uses for build pruning via the command line. Perhaps the
  most useful is the ability to make local changes, and then, with sufficient
  knowledge of the consequences of those changes, restrict the size of the build
  tree in order to speed up the rebuild time. A second use for build pruning is
  to actively prevent the recompilation of certain files that you know will
  recompile due to, for example, a modified header file. You may know that
  either the changes to the header file are immaterial, or that the changes may
  be safely ignored for most of the tree, for testing purposes.With Cons, the
  view is that it is pragmatic to admit this type of behavior, with the
  understanding that on the next full build everything that needs to be rebuilt
  will be. There is no equivalent to a ``make touch'' command, to mark files as
  permanently up-to-date. So any risk that is incurred by build pruning is
  mitigated. For release quality work, obviously, we recommend that you do not
  use build pruning (it's perfectly OK to use during integration, however, for
  checking compilation, etc. Just be sure to do an unconstrained build before
  committing the integration).
<h1 class="Sh" title="Sh" id="Temporary_overrides"><a class="selflink" href="#Temporary_overrides">Temporary
  overrides</a></h1>
Cons provides a very simple mechanism for overriding aspects of a build. The
  essence is that you write an override file containing one or more `Override'
  commands, and you specify this on the command line, when you run `cons':
<div class="Pp"></div>
<pre>
  % cons -o over export
<div class="Pp"></div>
</pre>
will build the <i>export</i> directory, with all derived files subject to the
  overrides present in the <i>over</i> file. If you leave out the `-o' option,
  then everything necessary to remove all overrides will be rebuilt.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Overriding environment variables</b>
<div class="Pp"></div>
The override file can contain two types of overrides. The first is incoming
  environment variables. These are normally accessible by the <i>Construct</i>
  file from the `%ENV' hash variable. These can trivially be overridden in the
  override file by setting the appropriate elements of `%ENV' (these could also
  be overridden in the user's environment, of course).
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The Override command</b>
<div class="Pp"></div>
The second type of override is accomplished with the `Override' command, which
  looks like this:
<div class="Pp"></div>
<pre>
  Override &lt;regexp&gt;, &lt;var1&gt; =&gt; &lt;value1&gt;, &lt;var2&gt; =&gt; &lt;value2&gt;, ...;
<div class="Pp"></div>
</pre>
The regular expression <i>regexp</i> is matched against every derived file that
  is a candidate for the build. If the derived file matches, then the
  variable/value pairs are used to override the values in the construction
  environment associated with the derived file.
<div class="Pp"></div>
Let's suppose that we have a construction environment like this:
<div class="Pp"></div>
<pre>
  $CONS = new cons(
        COPT =&gt; '',
        CDBG =&gt; '-g',
        CFLAGS =&gt; '%COPT %CDBG',
  );
<div class="Pp"></div>
</pre>
Then if we have an override file <i>over</i> containing this command:
<div class="Pp"></div>
<pre>
  Override '\.o$', COPT =&gt; '-O', CDBG =&gt; '';
<div class="Pp"></div>
</pre>
then any `cons' invocation with `-o over' that creates <i>.o</i> files via this
  environment will cause them to be compiled with `-O 'and no `-g'. The override
  could, of course, be restricted to a single directory by the appropriate
  selection of a regular expression.
<div class="Pp"></div>
Here's the original version of the Hello, World! program, built with this
  environment. Note that Cons rebuilds the appropriate pieces when the override
  is applied or removed:
<div class="Pp"></div>
<pre>
  % cons hello
  cc -g -c hello.c -o hello.o
  cc -o hello hello.o
  % cons -o over hello
  cc -O -c hello.c -o hello.o
  cc -o hello hello.o
  % cons -o over hello
  cons: &quot;hello&quot; is up-to-date.
  % cons hello
  cc -g -c hello.c -o hello.o
  cc -o hello hello.o
<div class="Pp"></div>
</pre>
It's important that the `Override' command only be used for temporary,
  on-the-fly overrides necessary for development because the overrides are not
  platform independent and because they rely too much on intimate knowledge of
  the workings of the scripts. For temporary use, however, they are exactly what
  you want.
<div class="Pp"></div>
Note that it is still useful to provide, say, the ability to create a fully
  optimized version of a system for production use--from the <i>Construct</i>
  and <i>Conscript</i> files. This way you can tailor the optimized system to
  the platform. Where optimizer trade-offs need to be made (particular files may
  not be compiled with full optimization, for example), then these can be
  recorded for posterity (and reproducibility) directly in the scripts.
<h1 class="Sh" title="Sh" id="More_on_construction_environments"><a class="selflink" href="#More_on_construction_environments">More
  on construction environments</a></h1>
<b>Default construction variables</b>
<div class="Pp"></div>
We have mentioned, and used, the concept of a <b>construction environment</b>,
  many times in the preceding pages. Now it's time to make this a little more
  concrete. With the following statement:
<div class="Pp"></div>
<pre>
  $env = new cons();
<div class="Pp"></div>
</pre>
a reference to a new, default construction environment is created. This contains
  a number of construction variables and some methods. At the present writing,
  the default list of construction variables is defined as follows:
<div class="Pp"></div>
<pre>
  CC            =&gt; 'cc',
  CFLAGS        =&gt; '',
  CCCOM         =&gt; '%CC %CFLAGS %_IFLAGS -c %&lt; -o %&gt;',
  INCDIRPREFIX  =&gt; '-I',
  CXX           =&gt; '%CC',
  CXXFLAGS      =&gt; '%CFLAGS',
  CXXCOM        =&gt; '%CXX %CXXFLAGS %_IFLAGS -c %&lt; -o %&gt;',
  LINK          =&gt; '%CXX',
  LINKCOM       =&gt; '%LINK %LDFLAGS -o %&gt; %&lt; %_LDIRS %LIBS',
  LINKMODULECOM =&gt; '%LD -r -o %&gt; %&lt;',
  LIBDIRPREFIX  =&gt; '-L',
  AR            =&gt; 'ar',
  ARFLAGS       =&gt; 'r',
  ARCOM         =&gt; &quot;%AR %ARFLAGS %&gt; %&lt;\n%RANLIB %&gt;&quot;,
  RANLIB        =&gt; 'ranlib',
  AS            =&gt; 'as',
  ASFLAGS       =&gt; '',
  ASCOM         =&gt; '%AS %ASFLAGS %&lt; -o %&gt;',
  LD            =&gt; 'ld',
  LDFLAGS       =&gt; '',
  PREFLIB       =&gt; 'lib',
  SUFLIB        =&gt; '.a',
  SUFLIBS       =&gt; '.so:.a',
  SUFOBJ        =&gt; '.o',
  ENV           =&gt; { 'PATH' =&gt; '/bin:/usr/bin' },
<div class="Pp"></div>
</pre>
On Win32 systems (Windows NT), the following construction variables are
  overridden in the default:
<div class="Pp"></div>
<pre>
  CC            =&gt; 'cl',
  CFLAGS        =&gt; '/nologo',
  CCCOM         =&gt; '%CC %CFLAGS %_IFLAGS /c %&lt; /Fo%&gt;',
  CXXCOM        =&gt; '%CXX %CXXFLAGS %_IFLAGS /c %&lt; /Fo%&gt;',
  INCDIRPREFIX  =&gt; '/I',
  LINK          =&gt; 'link',
  LINKCOM       =&gt; '%LINK %LDFLAGS /out:%&gt; %&lt; %_LDIRS %LIBS',
  LINKMODULECOM =&gt; '%LD /r /o %&gt; %&lt;',
  LIBDIRPREFIX  =&gt; '/LIBPATH:',
  AR            =&gt; 'lib',
  ARFLAGS       =&gt; '/nologo ',
  ARCOM         =&gt; &quot;%AR %ARFLAGS /out:%&gt; %&lt;&quot;,
  RANLIB        =&gt; '',
  LD            =&gt; 'link',
  LDFLAGS       =&gt; '/nologo ',
  PREFLIB       =&gt; '',
  SUFEXE        =&gt; '.exe',
  SUFLIB        =&gt; '.lib',
  SUFLIBS       =&gt; '.dll:.lib',
  SUFOBJ        =&gt; '.obj',
<div class="Pp"></div>
</pre>
These variables are used by the various methods associated with the environment,
  in particular any method that ultimately invokes an external command will
  substitute these variables into the final command, as appropriate. For
  example, the `Objects' method takes a number of source files and arranges to
  derive, if necessary, the corresponding object files. For example:
<div class="Pp"></div>
<pre>
  Objects $env 'foo.c', 'bar.c';
<div class="Pp"></div>
</pre>
This will arrange to produce, if necessary, <i>foo.o</i> and <i>bar.o</i>. The
  command invoked is simply `%CCCOM', which expands through substitution, to the
  appropriate external command required to build each object. We will explore
  the substitution rules further under the `Command' method, below.
<div class="Pp"></div>
The construction variables are also used for other purposes. For example,
  `CPPPATH' is used to specify a colon-separated path of include directories.
  These are intended to be passed to the C preprocessor and are also used by the
  C-file scanning machinery to determine the dependencies involved in a C
  Compilation. Variables beginning with underscore, are created by various
  methods, and should normally be considered ``internal'' variables. For
  example, when a method is called which calls for the creation of an object
  from a C source, the variable `_IFLAGS' is created: this corresponds to the
  `-I' switches required by the C compiler to represent the directories
  specified by `CPPPATH'.
<div class="Pp"></div>
Note that, for any particular environment, the value of a variable is set once,
  and then never reset (to change a variable, you must create a new environment.
  Methods are provided for copying existing environments for this purpose). Some
  internal variables, such as `_IFLAGS' are created on demand, but once set,
  they remain fixed for the life of the environment.
<div class="Pp"></div>
The `CFLAGS', `LDFLAGS', and `ARFLAGS' variables all supply a place for passing
  options to the compiler, loader, and archiver, respectively. Less obviously,
  the `INCDIRPREFIX' variable specifies the option string to be appended to the
  beginning of each include directory so that the compiler knows where to find
  <i>.h</i> files. Similarly, the `LIBDIRPREFIX' variable specifies the option
  string to be appended to the beginning of each directory that the linker
  should search for libraries.
<div class="Pp"></div>
Another variable, `ENV', is used to determine the system environment during the
  execution of an external command. By default, the only environment variable
  that is set is `PATH', which is the execution path for a UNIX command. For the
  utmost reproducibility, you should really arrange to set your own execution
  path, in your top-level <i>Construct</i> file (or perhaps by importing an
  appropriate construction package with the Perl `use' command). The default
  variables are intended to get you off the ground.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Interpolating construction variables</b>
<div class="Pp"></div>
Construction environment variables may be interpolated in the source and target
  file names by prefixing the construction variable name with `%'.
<div class="Pp"></div>
<pre>
  $env = new cons(
        DESTDIR =&gt;      'programs',
        SRCDIR  =&gt;      'src',
  );
  Program $env '%DESTDIR/hello', '%SRCDIR/hello.c';
<div class="Pp"></div>
</pre>
Expansion of construction variables is recursive--that is, the file
  <i>name</i>(s) will be re-expanded until no more substitutions can be made. If
  a construction variable is not defined in the environment, then the null
  string will be substituted.
<h1 class="Sh" title="Sh" id="Default_construction_methods"><a class="selflink" href="#Default_construction_methods">Default
  construction methods</a></h1>
The list of default construction methods includes the following:
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`new' constructor
<div class="Pp"></div>
The `new' method is a Perl object constructor. That is, it is not invoked via a
  reference to an existing construction environment <b>reference</b>, but,
  rather statically, using the name of the Perl <b>package</b> where the
  constructor is defined. The method is invoked like this:
<div class="Pp"></div>
<pre>
  $env = new cons(&lt;overrides&gt;);
<div class="Pp"></div>
</pre>
The environment you get back is blessed into the package `cons', which means
  that it will have associated with it the default methods described below.
  Individual construction variables can be overridden by providing name/value
  pairs in an override list. Note that to override any command environment
  variable (i.e. anything under `ENV'), you will have to override all of them.
  You can get around this difficulty by using the `copy' method on an existing
  construction environment.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`clone' method
<div class="Pp"></div>
The `clone' method creates a clone of an existing construction environment, and
  can be called as in the following example:
<div class="Pp"></div>
<pre>
  $env2 = $env1-&gt;clone(&lt;overrides&gt;);
<div class="Pp"></div>
</pre>
You can provide overrides in the usual manner to create a different environment
  from the original. If you just want a new name for the same environment (which
  may be helpful when exporting environments to existing components), you can
  just use simple assignment.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`copy' method
<div class="Pp"></div>
The `copy' method extracts the externally defined construction variables from an
  environment and returns them as a list of name/value pairs. Overrides can also
  be provided, in which case, the overridden values will be returned, as
  appropriate. The returned list can be assigned to a hash, as shown in the
  prototype, below, but it can also be manipulated in other ways:
<div class="Pp"></div>
<pre>
  %env = $env1-&gt;copy(&lt;overrides&gt;);
<div class="Pp"></div>
</pre>
The value of `ENV', which is itself a hash, is also copied to a new hash, so
  this may be changed without fear of affecting the original environment. So,
  for example, if you really want to override just the `PATH' variable in the
  default environment, you could do the following:
<div class="Pp"></div>
<pre>
  %cons = new cons()-&gt;copy();
  $cons{ENV}{PATH} = &quot;&lt;your path here&gt;&quot;;
  $cons = new cons(%cons);
<div class="Pp"></div>
</pre>
This will leave anything else that might be in the default execution environment
  undisturbed.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Install' method
<div class="Pp"></div>
The `Install' method arranges for the specified files to be installed in the
  specified directory. The installation is optimized: the file is not copied if
  it can be linked. If this is not the desired behavior, you will need to use a
  different method to install the file. It is called as follows:
<div class="Pp"></div>
<pre>
  Install $env &lt;directory&gt;, &lt;names&gt;;
<div class="Pp"></div>
</pre>
Note that, while the files to be installed may be arbitrarily named, only the
  last component of each name is used for the installed target name. So, for
  example, if you arrange to install <i>foo/bar</i> in <i>baz</i>, this will
  create a <i>bar</i> file in the <i>baz</i> directory (not <i>foo/bar</i>).
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`InstallAs' method
<div class="Pp"></div>
The `InstallAs' method arranges for the specified source <i>file</i>(s) to be
  installed as the specified target <i>file</i>(s). Multiple files should be
  specified as a file list. The installation is optimized: the file is not
  copied if it can be linked. If this is not the desired behavior, you will need
  to use a different method to install the file. It is called as follows:
<div class="Pp"></div>
`InstallAs' works in two ways:
<div class="Pp"></div>
Single file install:
<div class="Pp"></div>
<pre>
  InstallAs $env TgtFile, SrcFile;
<div class="Pp"></div>
</pre>
Multiple file install:
<div class="Pp"></div>
<pre>
  InstallAs $env ['tgt1', 'tgt2'], ['src1', 'src2'];
<div class="Pp"></div>
</pre>
Or, even as:
<div class="Pp"></div>
<pre>
  @srcs = qw(src1 src2 src3);
  @tgts = qw(tgt1 tgt2 tgt3);
  InstallAs $env [@tgts], [@srcs];
<div class="Pp"></div>
</pre>
Both the target and the sources lists should be of the same length.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Precious' method
<div class="Pp"></div>
The `Precious' method asks cons not to delete the specified file or list of
  files before building them again. It is invoked as:
<div class="Pp"></div>
<pre>
  Precious &lt;files&gt;;
<div class="Pp"></div>
</pre>
This is especially useful for allowing incremental updates to libraries or debug
  information files which are updated rather than rebuilt anew each time. Cons
  will still delete the files when the `-r' flag is specified.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Command' method
<div class="Pp"></div>
The `Command' method is a catchall method which can be used to arrange for any
  external command to be called to update the target. For this command, a target
  file and list of inputs is provided. In addition a construction command line,
  or lines, is provided as a string (this string may have multiple commands
  embedded within it, separated by new lines). `Command' is called as follows:
<div class="Pp"></div>
<pre>
  Command $env &lt;target&gt;, &lt;inputs&gt;, &lt;construction command&gt;;
<div class="Pp"></div>
</pre>
The target is made dependent upon the list of input files specified, and the
  inputs must be built successfully or Cons will not attempt to build the
  target.
<div class="Pp"></div>
Within the construction command, any variable from the construction environment
  may be introduced by prefixing the name of the construction variable with `%'.
  This is recursive: the command is expanded until no more substitutions can be
  made. If a construction variable is not defined in the environment, then the
  null string will be substituted. A doubled `%%' will be replaced by a single
  `%' in the construction command.
<div class="Pp"></div>
There are several pseudo variables which will also be expanded:
<div>&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">%&gt;</dt>
  <dd class="It-tag">The target file name (in a multi-target command, this is
      always the first target mentioned).
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%0</dt>
  <dd class="It-tag">Same as `%&gt;'.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%1, %2, ..., %9</dt>
  <dd class="It-tag">These refer to the first through ninth input file,
      respectively.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%&lt;</dt>
  <dd class="It-tag">The full set of inputs. If any of these have been used
      anywhere else in the current command line (via `%1', `%2', etc.), then
      those will be deleted from the list provided by `%&lt;'. Consider the
      following command found in a <i>Conscript</i> file in the <i>test</i>
      directory:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  Command $env 'tgt', qw(foo bar baz), qq(
        echo %&lt; -i %1 &gt; %&gt;
        echo %&lt; -i %2 &gt;&gt; %&gt;
        echo %&lt; -i %3 &gt;&gt; %&gt;
  );
<div class="Pp"></div>
    </pre>
    If <i>tgt</i> needed to be updated, then this would result in the execution
      of the following commands, assuming that no remapping has been established
      for the <i>test</i> directory:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  echo test/bar test/baz -i test/foo &gt; test/tgt
  echo test/foo test/baz -i test/bar &gt;&gt; test/tgt
  echo test/foo test/bar -i test/baz &gt;&gt; test/tgt
<div class="Pp"></div>
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
Any of the above pseudo variables may be followed immediately by one of the
  following suffixes to select a portion of the expanded path name:
<div class="Pp"></div>
<pre>
  :a    the absolute path to the file name
  :b    the directory plus the file name stripped of any suffix
  :d    the directory
  :f    the file name
  :s    the file name suffix
  :F    the file name stripped of any suffix
<div class="Pp"></div>
</pre>
Continuing with the above example, `%&lt;:f' would expand to `foo bar baz', and
  `%':d&gt; would expand to `test'.
<div class="Pp"></div>
It is possible to programmatically rewrite part of the command by enclosing part
  of it between `%[' and `%]'. This will call the construction variable named as
  the first word enclosed in the brackets as a Perl code reference; the results
  of this call will be used to replace the contents of the brackets in the
  command line. For example, given an existing input file named <i>tgt.in</i>:
<div class="Pp"></div>
<pre>
  @keywords = qw(foo bar baz);
  $env = new cons(X_COMMA =&gt; sub { join(&quot;,&quot;, @_) });
  Command $env 'tgt', 'tgt.in', qq(
        echo '# Keywords: %[X_COMMA @keywords %]' &gt; %&gt;
        cat %&lt; &gt;&gt; %&gt;
  );
<div class="Pp"></div>
</pre>
This will execute:
<div class="Pp"></div>
<pre>
  echo '# Keywords: foo,bar,baz' &gt; tgt
  cat tgt.in &gt;&gt; tgt
<div class="Pp"></div>
</pre>
After substitution occurs, strings of white space are converted into single
  blanks, and leading and trailing white space is eliminated. It is therefore
  not possible to introduce variable length white space in strings passed into a
  command, without resorting to some sort of shell quoting.
<div class="Pp"></div>
If a multi-line command string is provided, the commands are executed
  sequentially. If any of the commands fails, then none of the rest are
  executed, and the target is not marked as updated, i.e. a new signature is not
  stored for the target.
<div class="Pp"></div>
Normally, if all the commands succeed, and return a zero status (or whatever
  platform-specific indication of success is required), then a new signature is
  stored for the target. If a command erroneously reports success even after a
  failure, then Cons will assume that the target file created by that command is
  accurate and up-to-date.
<div class="Pp"></div>
The first word of each command string, after expansion, is assumed to be an
  executable command looked up on the `PATH' environment variable (which is, in
  turn, specified by the `ENV' construction variable). If this command is found
  on the path, then the target will depend upon it: the command will therefore
  be automatically built, as necessary. It's possible to write multi-part
  commands to some shells, separated by semi-colons. Only the first command word
  will be depended upon, however, so if you write your command strings this way,
  you must either explicitly set up a dependency (with the `Depends' method), or
  be sure that the command you are using is a system command which is expected
  to be available. If it isn't available, you will, of course, get an error.
<div class="Pp"></div>
If any command (even one within a multi-line command) begins with `[perl]', the
  remainder of that command line will be evaluated by the running Perl instead
  of being forked by the shell. If an error occurs in parsing the Perl or if the
  Perl expression returns 0 or undef, the command will be considered to have
  failed. For example, here is a simple command which creates a file `foo'
  directly from Perl:
<div class="Pp"></div>
<pre>
  $env = new cons();
  Command $env 'foo',
    qq([perl] open(FOO,'&gt;foo');print FOO &quot;hi\\n&quot;; close(FOO); 1);
<div class="Pp"></div>
</pre>
Note that when the command is executed, you are in the same package as when the
  <i>Construct</i> or <i>Conscript</i> file was read, so you can call Perl
  functions you've defined in the same <i>Construct</i> or <i>Conscript</i> file
  in which the `Command' appears:
<div class="Pp"></div>
<pre>
  $env = new cons();
  sub create_file {
        my $file = shift;
        open(FILE, &quot;&gt;$file&quot;);
        print FILE &quot;hi\n&quot;;
        close(FILE);
        return 1;
  }
  Command $env 'foo', &quot;[perl] &amp;create_file('%&gt;')&quot;;
<div class="Pp"></div>
</pre>
The Perl string will be used to generate the signature for the derived file, so
  if you change the string, the file will be rebuilt. The contents of any
  subroutines you call, however, are not part of the signature, so if you modify
  a called subroutine such as `create_file' above, the target will <i>not</i> be
  rebuilt. Caveat user.
<div class="Pp"></div>
Cons normally prints a command before executing it. This behavior is suppressed
  if the first character of the command is `@'. Note that you may need to
  separate the `@' from the command name or escape it to prevent `@cmd' from
  looking like an array to Perl quote operators that perform interpolation:
<div class="Pp"></div>
<pre>
  # The first command line is incorrect,
  # because &quot;@cp&quot; looks like an array
  # to the Perl qq// function.
  # Use the second form instead.
  Command $env 'foo', 'foo.in', qq(
        @cp %&lt; tempfile
        @ cp tempfile %&gt;
  );
<div class="Pp"></div>
</pre>
If there are shell meta characters anywhere in the expanded command line, such
  as `&lt;', `&gt;', quotes, or semi-colon, then the command will actually be
  executed by invoking a shell. This means that a command such as:
<div class="Pp"></div>
<pre>
  cd foo
<div class="Pp"></div>
</pre>
alone will typically fail, since there is no command `cd' on the path. But the
  command string:
<div class="Pp"></div>
<pre>
  cd $&lt;:d; tar cf $&gt;:f $&lt;:f
<div class="Pp"></div>
</pre>
when expanded will still contain the shell meta character semi-colon, and a
  shell will be invoked to interpret the command. Since `cd' is interpreted by
  this sub-shell, the command will execute as expected.
<div class="Pp"></div>
To specify a command with multiple targets, you can specify a reference to a
  list of targets. In Perl, a list reference can be created by enclosing a list
  in square brackets. Hence the following command:
<div class="Pp"></div>
<pre>
  Command $env ['foo.h', 'foo.c'], 'foo.template', q(
        gen %1
  );
<div class="Pp"></div>
</pre>
could be used in a case where the command `gen' creates two files, both
  <i>foo.h</i> and <i>foo.c</i>.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Objects' method
<div class="Pp"></div>
The `Objects' method arranges to create the object files that correspond to the
  specified source files. It is invoked as shown below:
<div class="Pp"></div>
<pre>
  @files = Objects $env &lt;source or object files&gt;;
<div class="Pp"></div>
</pre>
Under Unix, source files ending in <i>.s</i> and <i>.c</i> are currently
  supported, and will be compiled into a name of the same file ending in
  <i>.o</i>. By default, all files are created by invoking the external command
  which results from expanding the `CCCOM' construction variable, with `%&lt;'
  and `%&gt;' set to the source and object files, respectively (see the
  `Command' method for expansion details). The variable `CPPPATH' is also used
  when scanning source files for dependencies. This is a colon separated list of
  pathnames, and is also used to create the construction variable `_IFLAGS,'
  which will contain the appropriate list of -`I' options for the compilation.
  Any relative pathnames in `CPPPATH' is interpreted relative to the directory
  in which the associated construction environment was created (absolute and
  top-relative names may also be used). This variable is used by `CCCOM'. The
  behavior of this command can be modified by changing any of the variables
  which are interpolated into `CCCOM', such as `CC', `CFLAGS', and, indirectly,
  `CPPPATH'. It's also possible to replace the value of `CCCOM', itself. As a
  convenience, this file returns the list of object filenames.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Program' method
<div class="Pp"></div>
The `Program' method arranges to link the specified program with the specified
  object files. It is invoked in the following manner:
<div class="Pp"></div>
<pre>
  Program $env &lt;program name&gt;, &lt;source or object files&gt;;
<div class="Pp"></div>
</pre>
The program name will have the value of the `SUFEXE' construction variable
  appended (by default, `.exe' on Win32 systems, nothing on Unix systems) if the
  suffix is not already present.
<div class="Pp"></div>
Source files may be specified in place of objects files--the `Objects' method
  will be invoked to arrange the conversion of all the files into object files,
  and hence all the observations about the `Objects' method, above, apply to
  this method also.
<div class="Pp"></div>
The actual linking of the program will be handled by an external command which
  results from expanding the `LINKCOM' construction variable, with `%&lt;' set
  to the object files to be linked (in the order presented), and `%&gt;' set to
  the target (see the `Command' method for expansion details). The user may set
  additional variables in the construction environment, including `LINK', to
  define which program to use for linking, `LIBPATH', a colon-separated list of
  library search paths, for use with library specifications of the form
  <i>-llib</i>, and `LIBS', specifying the list of libraries to link against (in
  either <i>-llib</i> form or just as pathnames. Relative pathnames in both
  `LIBPATH' and `LIBS' are interpreted relative to the directory in which the
  associated construction environment is created (absolute and top-relative
  names may also be used). Cons automatically sets up dependencies on any
  libraries mentioned in `LIBS': those libraries will be built before the
  command is linked.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Library' method
<div class="Pp"></div>
The `Library' method arranges to create the specified library from the specified
  object files. It is invoked as follows:
<div class="Pp"></div>
<pre>
  Library $env &lt;library name&gt;, &lt;source or object files&gt;;
<div class="Pp"></div>
</pre>
The library name will have the value of the `SUFLIB' construction variable
  appended (by default, `.lib' on Win32 systems, `.a' on Unix systems) if the
  suffix is not already present.
<div class="Pp"></div>
Source files may be specified in place of objects files--the `Objects' method
  will be invoked to arrange the conversion of all the files into object files,
  and hence all the observations about the `Objects' method, above, apply to
  this method also.
<div class="Pp"></div>
The actual creation of the library will be handled by an external command which
  results from expanding the `ARCOM' construction variable, with `%&lt;' set to
  the library members (in the order presented), and `%&gt;' to the library to be
  created (see the `Command' method for expansion details). The user may set
  variables in the construction environment which will affect the operation of
  the command. These include `AR', the archive program to use, `ARFLAGS', which
  can be used to modify the flags given to the program specified by `AR', and
  `RANLIB', the name of a archive index generation program, if needed (if the
  particular need does not require the latter functionality, then `ARCOM' must
  be redefined to not reference `RANLIB').
<div class="Pp"></div>
The `Library' method allows the same library to be specified in multiple method
  invocations. All of the contributing objects from all the invocations (which
  may be from different directories) are combined and generated by a single
  archive command. Note, however, that if you prune a build so that only part of
  a library is specified, then only that part of the library will be generated
  (the rest will disappear!).
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Module' method
<div class="Pp"></div>
The `Module' method is a combination of the `Program' and `Command' methods.
  Rather than generating an executable program directly, this command allows you
  to specify your own command to actually generate a module. The method is
  invoked as follows:
<div class="Pp"></div>
<pre>
  Module $env &lt;module name&gt;, &lt;source or object files&gt;, &lt;construction command&gt;;
<div class="Pp"></div>
</pre>
This command is useful in instances where you wish to create, for example,
  dynamically loaded modules, or statically linked code libraries.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Depends' method
<div class="Pp"></div>
The `Depends' method allows you to specify additional dependencies for a target.
  It is invoked as follows:
<div class="Pp"></div>
<pre>
  Depends $env &lt;target&gt;, &lt;dependencies&gt;;
<div class="Pp"></div>
</pre>
This may be occasionally useful, especially in cases where no scanner exists (or
  is writable) for particular types of files. Normally, dependencies are
  calculated automatically from a combination of the explicit dependencies set
  up by the method invocation or by scanning source files.
<div class="Pp"></div>
A set of identical dependencies for multiple targets may be specified using a
  reference to a list of targets. In Perl, a list reference can be created by
  enclosing a list in square brackets. Hence the following command:
<div class="Pp"></div>
<pre>
  Depends $env ['foo', 'bar'], 'input_file_1', 'input_file_2';
<div class="Pp"></div>
</pre>
specifies that both the <i>foo</i> and <i>bar</i> files depend on the listed
  input files.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Ignore' method
<div class="Pp"></div>
The `Ignore' method allows you to ignore explicitly dependencies that Cons
  infers on its own. It is invoked as follows:
<div class="Pp"></div>
<pre>
  Ignore &lt;patterns&gt;;
<div class="Pp"></div>
</pre>
This can be used to avoid recompilations due to changes in system header files
  or utilities that are known to not affect the generated targets.
<div class="Pp"></div>
If, for example, a program is built in an NFS-mounted directory on multiple
  systems that have different copies of <i>stdio.h</i>, the differences will
  affect the signatures of all derived targets built from source files that
  `#include &lt;stdio.h&gt;'. This will cause all those targets to be rebuilt
  when changing systems. If this is not desirable behavior, then the following
  line will remove the dependencies on the <i>stdio.h</i> file:
<div class="Pp"></div>
<pre>
  Ignore '^/usr/include/stdio\.h$';
<div class="Pp"></div>
</pre>
Note that the arguments to the `Ignore' method are regular expressions, so
  special characters must be escaped and you may wish to anchor the beginning or
  end of the expression with `^' or `$' characters.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Salt' method
<div class="Pp"></div>
The `Salt' method adds a constant value to the signature calculation for every
  derived file. It is invoked as follows:
<div class="Pp"></div>
<pre>
  Salt $string;
<div class="Pp"></div>
</pre>
Changing the Salt value will force a complete rebuild of every derived file.
  This can be used to force rebuilds in certain desired circumstances. For
  example,
<div class="Pp"></div>
<pre>
  Salt `uname -s`;
<div class="Pp"></div>
</pre>
Would force a complete rebuild of every derived file whenever the operating
  system on which the build is performed (as reported by `uname -s') changes.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`UseCache' method
<div class="Pp"></div>
The `UseCache' method instructs Cons to maintain a cache of derived files, to be
  shared among separate build trees of the same project.
<div class="Pp"></div>
<pre>
  UseCache(&quot;cache/&lt;buildname&gt;&quot;) &#x23AA;&#x23AA; warn(&quot;cache directory not found&quot;);
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`SourcePath' method
<div class="Pp"></div>
The `SourcePath' mathod returns the real source path name of a file, as opposted
  to the path name within a build directory. It is invoked as follows:
<div class="Pp"></div>
<pre>
  $path = SourcePath &lt;buildpath&gt;;
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`ConsPath' method
<div class="Pp"></div>
The `ConsPath' method returns true if the supplied path is a derivable file, and
  returns undef (false) otherwise. It is invoked as follows:
<div class="Pp"></div>
<pre>
  $result = ConsPath &lt;path&gt;;
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`SplitPath' method
<div class="Pp"></div>
The `SplitPath' method looks up multiple path names in a string separated by the
  default path separator for the operating system (':' on UNIX systems, ';' on
  Windows NT), and returns the fully-qualified names. It is invoked as follows:
<div class="Pp"></div>
<pre>
  @paths = SplitPath &lt;pathlist&gt;;
<div class="Pp"></div>
</pre>
The `SplitPath' method will convert names prefixed '#' to the appropriate
  top-level build name (without the '#') and will convert relative names to
  top-level names.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`DirPath' method
<div class="Pp"></div>
The `DirPath' method returns the build path <i>name</i>(s) of a directory or
  list of directories. It is invoked as follows:
<div class="Pp"></div>
<pre>
  $cwd = DirPath &lt;paths&gt;;
<div class="Pp"></div>
</pre>
The most common use for the `DirPath' method is:
<div class="Pp"></div>
<pre>
  $cwd = DirPath '.';
<div class="Pp"></div>
</pre>
to fetch the path to the current directory of a subsidiary <i>Conscript</i>
  file.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`FilePath' method
<div class="Pp"></div>
The `FilePath' method returns the build path <i>name</i>(s) of a file or list of
  files. It is invoked as follows:
<div class="Pp"></div>
<pre>
  $file = FilePath &lt;path&gt;;
<div class="Pp"></div>
</pre>
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>The </b>`Help' method
<div class="Pp"></div>
The `Help' method specifies help text that will be displayed when the user
  invokes `cons -h'. This can be used to provide documentation of specific
  targets, values, build options, etc. for the build tree. It is invoked as
  follows:
<div class="Pp"></div>
<pre>
  Help &lt;helptext&gt;;
<div class="Pp"></div>
</pre>
The `Help' method may only be called once, and should typically be specified in
  the top-level <i>Construct</i> file.
<h1 class="Sh" title="Sh" id="Extending_Cons"><a class="selflink" href="#Extending_Cons">Extending
  Cons</a></h1>
<b>Overriding construction variables</b>
<div class="Pp"></div>
There are several ways of extending Cons, which vary in degree of difficulty.
  The simplest method is to define your own construction environment, based on
  the default environment, but modified to reflect your particular needs. This
  will often suffice for C-based applications. You can use the `new'
  constructor, and the `clone' and `copy' methods to create hybrid environments.
  These changes can be entirely transparent to the underlying <i>Conscript</i>
  files.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Adding new methods</b>
<div class="Pp"></div>
For slightly more demanding changes, you may wish to add new methods to the
  `cons' package. Here's an example of a very simple extension, `InstallScript',
  which installs a tcl script in a requested location, but edits the script
  first to reflect a platform-dependent path that needs to be installed in the
  script:
<div class="Pp"></div>
<pre>
  # cons::InstallScript - Create a platform dependent version of a shell
  # script by replacing string ``#!your-path-here'' with platform specific
  # path $BIN_DIR.
<div class="Pp"></div>
</pre>
<pre>
  sub cons::InstallScript {
        my ($env, $dst, $src) = @_;
        Command $env $dst, $src, qq(
                sed s+your-path-here+$BIN_DIR+ %&lt; &gt; %&gt;
                chmod oug+x %&gt;
        );
  }
<div class="Pp"></div>
</pre>
Notice that this method is defined directly in the `cons' package (by prefixing
  the name with `cons::'). A change made in this manner will be globally visible
  to all environments, and could be called as in the following example:
<div class="Pp"></div>
<pre>
  InstallScript $env &quot;$BIN/foo&quot;, &quot;foo.tcl&quot;;
<div class="Pp"></div>
</pre>
For a small improvement in generality, the `BINDIR' variable could be passed in
  as an argument or taken from the construction environment--as `%BINDIR'.
<div>&#x00A0;</div>
<div class="Pp"></div>
<b>Overriding methods</b>
<div class="Pp"></div>
Instead of adding the method to the `cons' name space, you could define a new
  package which inherits existing methods from the `cons' package and overrides
  or adds others. This can be done using Perl's inheritance mechanisms.
<div class="Pp"></div>
The following example defines a new package `cons::switch' which overrides the
  standard `Library' method. The overridden method builds linked library
  modules, rather than library archives. A new constructor is provided.
  Environments created with this constructor will have the new library method;
  others won't.
<div class="Pp"></div>
<pre>
  package cons::switch;
  BEGIN {@ISA = 'cons'}
<div class="Pp"></div>
</pre>
<pre>
  sub new {
        shift;
        bless new cons(@_);
  }
<div class="Pp"></div>
</pre>
<pre>
  sub Library {
        my($env) = shift;
        my($lib) = shift;
        my(@objs) = Objects $env @_;
        Command $env $lib, @objs, q(
                %LD -r %LDFLAGS %&lt; -o %&gt;
        );
  }
<div class="Pp"></div>
</pre>
This functionality could be invoked as in the following example:
<div class="Pp"></div>
<pre>
  $env = new cons::switch(@overrides);
  ...
  Library $env 'lib.o', 'foo.c', 'bar.c';
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="Invoking_Cons"><a class="selflink" href="#Invoking_Cons">Invoking
  Cons</a></h1>
The `cons' command is usually invoked from the root of the build tree. A
  <i>Construct</i> file must exist in that directory. If the `-f' argument is
  used, then an alternate <i>Construct</i> file may be used (and, possibly, an
  alternate root, since `cons' will cd to <i>Construct</i> file's containing
  directory).
<div class="Pp"></div>
If `cons' is invoked from a child of the root of the build tree with the `-t'
  argument, it will walk up the directory hierarchy looking for a
  <i>Construct</i> file. (An alternate name may still be specified with `-f'.)
  The targets supplied on the command line will be modified to be relative to
  the discovered <i>Construct</i> file. For example, from a directory containing
  a top-level <i>Construct</i> file, the following invocation:
<div class="Pp"></div>
<pre>
  % cd libfoo/subdir
  % cons -t target
<div class="Pp"></div>
</pre>
is exactly equivalent to:
<div class="Pp"></div>
<pre>
  % cons libfoo/subdir/target
<div class="Pp"></div>
</pre>
If there are any `Default' targets specified in the directory hierarchy's
  <i>Construct</i> or <i>Conscript</i> files, only the default targets at or
  below the directory from which `cons -t' was invoked will be built.
<div class="Pp"></div>
The command is invoked as follows:
<div class="Pp"></div>
<pre>
  cons &lt;arguments&gt; -- &lt;construct-args&gt;
<div class="Pp"></div>
</pre>
where <i>arguments</i> can be any of the following, in any order:
<div>&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><i>target</i></dt>
  <dd class="It-tag">Build the specified target. If <i>target</i> is a
      directory, then recursively build everything within that directory.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>+pattern</i></dt>
  <dd class="It-tag">Limit the <i>Conscript</i> files considered to just those
      that match <i>pattern</i>, which is a Perl regular expression. Multiple
      `+' arguments are accepted.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>name</i>=&lt;val&gt;</dt>
  <dd class="It-tag">Sets <i>name</i> to value <i>val</i> in the `ARG' hash
      passed to the top-level <i>Construct</i> file.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-cc'</dt>
  <dd class="It-tag">Show command that would have been executed, when retrieving
      from cache. No indication that the file has been retrieved is given; this
      is useful for generating build logs that can be compared with real build
      logs.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-cd'</dt>
  <dd class="It-tag">Disable all caching. Do not retrieve from cache nor flush
      to cache.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-cr'</dt>
  <dd class="It-tag">Build dependencies in random order. This is useful when
      building multiple similar trees with caching enabled.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-cs'</dt>
  <dd class="It-tag">Synchronize existing build targets that are found to be
      up-to-date with cache. This is useful if caching has been disabled with
      -cc or just recently enabled with UseCache.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-d'</dt>
  <dd class="It-tag">Enable dependency debugging.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-f' &lt;file&gt;</dt>
  <dd class="It-tag">Use the specified file instead of <i>Construct</i> (but
      first change to containing directory of <i>file</i>).
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-h'</dt>
  <dd class="It-tag">Show a help message local to the current build if one such
      is defined, and exit.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-k'</dt>
  <dd class="It-tag">Keep going as far as possible after errors.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-o' &lt;file&gt;</dt>
  <dd class="It-tag">Read override file <i>file</i>.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-p'</dt>
  <dd class="It-tag">Show construction products in specified trees. No build is
      attempted.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-pa'</dt>
  <dd class="It-tag">Show construction products and associated actions. No build
      is attempted.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-pw'</dt>
  <dd class="It-tag">Show products and where they are defined. No build is
      attempted.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-q'</dt>
  <dd class="It-tag">Don't be verbose about Installing and Removing targets.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-r'</dt>
  <dd class="It-tag">Remove construction products associated with
      &lt;targets&gt;. No build is attempted.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-R' &lt;repos&gt;</dt>
  <dd class="It-tag">Search for files in <i>repos</i>. Multiple <b>-R</b>
      <i>repos</i> directories are searched in the order specified.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-t'</dt>
  <dd class="It-tag">Traverse up the directory hierarchy looking for a
      <i>Construct</i> file, if none exists in the current directory. Targets
      will be modified to be relative to the <i>Construct</i> file.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-v'</dt>
  <dd class="It-tag">Show `cons' version and continue processing.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-V'</dt>
  <dd class="It-tag">Show `cons' version and exit.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-wf' &lt;file&gt;</dt>
  <dd class="It-tag">Write all filenames considered into <i>file</i>.
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">`-x'</dt>
  <dd class="It-tag">Show a help message similar to this one, and exit.</dd>
</dl>
<div class="Pp"></div>
And <i>construct-args</i> can be any arguments that you wish to process in the
  <i>Construct</i> file. Note that there should be a <b>--</b> separating the
  arguments to cons and the arguments that you wish to process in the
  <i>Construct</i> file.
<div class="Pp"></div>
Processing of <i>construct-args</i> can be done by any standard package like
  <b>Getopt</b> or its variants, or any user defined package. <b>cons</b> will
  pass in the <i>construct-args</i> as <b>@ARGV</b> and will not attempt to
  interpret anything after the <b>--</b>.
<div class="Pp"></div>
<pre>
  % cons -R /usr/local/repository -d os=solaris +driver -- -c test -f DEBUG
<div class="Pp"></div>
</pre>
would pass the following to cons
<div class="Pp"></div>
<pre>
  -R /usr/local/repository -d os=solaris +driver
<div class="Pp"></div>
</pre>
and the following, to the top level <i>Construct</i> file as <b>@ARGV</b>
<div class="Pp"></div>
<pre>
  -c test -f DEBUG
<div class="Pp"></div>
</pre>
Note that `cons -r .' is equivalent to a full recursive `make clean', but
  requires no support in the <i>Construct</i> file or any <i>Conscript</i>
  files. This is most useful if you are compiling files into source directories
  (if you separate the <i>build</i> and <i>export</i> directories, then you can
  just remove the directories).
<div class="Pp"></div>
The options `-p', `-pa', and `-pw' are extremely useful for use as an aid in
  reading scripts or debugging them. If you want to know what script installs
  <i>export/include/foo.h</i>, for example, just type:
<div class="Pp"></div>
<pre>
  % cons -pw export/include/foo.h
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="Using_and_writing_dependency_scanners"><a class="selflink" href="#Using_and_writing_dependency_scanners">Using
  and writing dependency scanners</a></h1>
QuickScan allows simple target-independent scanners to be set up for source
  files. Only one QuickScan scanner may be associated with any given source file
  and environment.
<div class="Pp"></div>
QuickScan is invoked as follows:
<div class="Pp"></div>
<pre>
  QuickScan CONSENV CODEREF, FILENAME [, PATH]
<div class="Pp"></div>
</pre>
The subroutine referenced by CODEREF is expected to return a list of filenames
  included directly by FILE. These filenames will, in turn, be scanned. The
  optional PATH argument supplies a lookup path for finding FILENAME and/or
  files returned by the user-supplied subroutine. The PATH may be a reference to
  an array of lookup-directory names, or a string of names separated by the
  system's separator character (':' on UNIX systems, ';' on Windows NT).
<div class="Pp"></div>
The subroutine is called once for each line in the file, with $_ set to the
  current line. If the subroutine needs to look at additional lines, or, for
  that matter, the entire file, then it may read them itself, from the
  filehandle SCAN. It may also terminate the loop, if it knows that no further
  include information is available, by closing the filehandle.
<div class="Pp"></div>
Whether or not a lookup path is provided, QuickScan first tries to lookup the
  file relative to the current directory (for the top-level file supplied
  directly to QuickScan), or from the directory containing the file which
  referenced the file. This is not very general, but seems good
  enough--especially if you have the luxury of writing your own utilities and
  can control the use of the search path in a standard way. Finally, the search
  path is, currently, colon separated. This may not make the NT camp happy.
<div class="Pp"></div>
Here's a real example, taken from a <i>Construct</i> file here:
<div class="Pp"></div>
<pre>
  sub cons::SMFgen {
      my($env, @tables) = @_;
      foreach $t (@tables) {
          $env-&gt;QuickScan(sub { /\b\S*?\.smf\b/g }, &quot;$t.smf&quot;,
                          $env-&gt;{SMF_INCLUDE_PATH});
          $env-&gt;Command(
              [&quot;$t.smdb.cc&quot;,&quot;$t.smdb.h&quot;,&quot;$t.snmp.cc&quot;,&quot;$t.ami.cc&quot;, &quot;$t.http.cc&quot;],
              &quot;$t.smf&quot;,
              q(
                smfgen %( %SMF_INCLUDE_OPT %) %&lt;
              )
          );
      }
  }
<div class="Pp"></div>
</pre>
[NOTE that the form `$env-&gt;QuickScan ...' and `$env-&gt;Command ...' should
  not be necessary, but, for some reason, is required for this particular
  invocation. This appears to be a bug in Perl or a misunderstanding on my part;
  this invocation style does not always appear to be necessary.]
<div class="Pp"></div>
This finds all names of the form &lt;name&gt;.smf in the file. It will return
  the names even if they're found within comments, but that's OK (the mechanism
  is forgiving of extra files; they're just ignored on the assumption that the
  missing file will be noticed when the program, in this example, smfgen, is
  actually invoked).
<div class="Pp"></div>
A scanner is only invoked for a given source file if it is needed by some target
  in the tree. It is only ever invoked once for a given source file.
<div class="Pp"></div>
Here is another way to build the same scanner. This one uses an explicit code
  reference, and also (unecessarily, in this case) reads the whole file itself:
<div class="Pp"></div>
<pre>
  sub myscan {
      my(@includes);
      do {
          push(@includes, /\b\S*?\.smf\b/g);
      } while &lt;SCAN&gt;;
      @includes
  }
<div class="Pp"></div>
</pre>
Note that the order of the loop is reversed, with the loop test at the end. This
  is because the first line is already read for you. This scanner can be
  attached to a source file by:
<div class="Pp"></div>
<pre>
    QuickScan $env \myscan, &quot;$_.smf&quot;;
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="SUPPORT_AND_SUGGESTIONS"><a class="selflink" href="#SUPPORT_AND_SUGGESTIONS">SUPPORT
  AND SUGGESTIONS</a></h1>
Cons is maintained by the user community. To subscribe, send mail to
  <b>cons-discuss-request@gnu.org</b> with body <b>subscribe</b>.
<div class="Pp"></div>
Please report any suggestions through the <b>cons-discuss@gnu.org</b> mailing
  list.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Sure to be some. Please report any bugs through the <b>bug-cons@gnu.org</b>
  mailing list.
<h1 class="Sh" title="Sh" id="INFORMATION_ABOUT_CONS"><a class="selflink" href="#INFORMATION_ABOUT_CONS">INFORMATION
  ABOUT CONS</a></h1>
Information about CONS can be obtained from the official cons web site
  <b>http://www.dsmit.com/cons/</b> or its mirrors listed there.
<div class="Pp"></div>
The cons maintainers can be contacted by email at
  <b>cons-maintainers@gnu.org</b>
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Originally by Bob Sidebotham. Then significantly enriched by the members of the
  Cons community <b>cons-discuss@gnu.org</b>.
<div class="Pp"></div>
The Cons community would like to thank Ulrich Pfeifer for the original pod
  documentation derived from the <i>cons.html</i> file. Cons documentation is
  now a part of the program itself.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2.2.0</td>
    <td class="foot-os">3rd Berkeley Distribution</td>
  </tr>
</table>
</body>
</html>
