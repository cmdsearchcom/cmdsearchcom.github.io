<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:04:01 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>dialyzer(1) User Commands dialyzer(1)</p>

<p style="margin-top: 1em">NAME <br>
dialyzer - Dialyzer, a DIscrepancy AnaLYZer for ERlang
programs.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Dialyzer is a static analysis tool that identifies software
discrepancies, such as definite type errors, code that has
become dead or unreachable because of programming error,
<br>
and unnecessary tests, in single Erlang modules or entire
(sets of) applications.</p>

<p style="margin-top: 1em">Dialyzer starts its analysis
from either debug-compiled BEAM bytecode or from Erlang
source code. The file and line number of a discrepancy is
reported along with an indication <br>
of what the discrepancy is about. Dialyzer bases its
analysis on the concept of success typings, which allows for
sound warnings (no false positives).</p>

<p style="margin-top: 1em">USING DIALYZER FROM THE COMMAND
LINE <br>
Dialyzer has a command-line version for automated use. This
section provides a brief description of the options. The
same information can be obtained by writing the following in
<br>
a shell:</p>

<p style="margin-top: 1em">dialyzer --help</p>

<p style="margin-top: 1em">For more details about the
operation of Dialyzer, see section Using Dialyzer from the
GUI in the User&rsquo;s Guide.</p>

<p style="margin-top: 1em">Exit status of the command-line
version:</p>

<p style="margin-top: 1em">0: <br>
No problems were found during the analysis and no warnings
were emitted.</p>

<p style="margin-top: 1em">1: <br>
Problems were found during the analysis.</p>

<p style="margin-top: 1em">2: <br>
No problems were found during the analysis, but warnings
were emitted.</p>

<p style="margin-top: 1em">Usage:</p>

<p style="margin-top: 1em">dialyzer [--add_to_plt] [--apps
applications] [--build_plt] <br>
[--check_plt] [-Ddefine]* [-Dname] [--dump_callgraph file]
<br>
[files_or_dirs] [--fullpath] [--get_warnings] [--gui]
[--help] <br>
[-I include_dir]* [--no_check_plt] [--no_native] <br>
[--no_native_cache] [-o outfile] [--output_plt file] [-pa
dir]* <br>
[--plt plt] [--plt_info] [--plts plt*] [--quiet] [-r dirs]
<br>
[--raw] [--remove_from_plt] [--shell] [--src] [--statistics]
<br>
[--verbose] [--version] [-Wwarn]*</p>

<p style="margin-top: 1em">Note: <br>
* denotes that multiple occurrences of the option are
possible.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">--add_to_plt: <br>
The PLT is extended to also include the files specified with
-c and -r. Use --plt to specify which PLT to start from, and
--output_plt to specify where to put the PLT. Notice <br>
that the analysis possibly can include files from the PLT if
they depend on the new files. This option only works for
BEAM files.</p>

<p style="margin-top: 1em">--apps applications: <br>
This option is typically used when building or modifying a
PLT as in:</p>

<p style="margin-top: 1em">dialyzer --build_plt --apps erts
kernel stdlib mnesia ...</p>

<p style="margin-top: 1em">to refer conveniently to library
applications corresponding to the Erlang/OTP installation.
However, this option is general and can also be used during
analysis to refer to <br>
Erlang/OTP applications. File or directory names can also be
included, as in:</p>

<p style="margin-top: 1em">dialyzer --apps inets ssl ./ebin
../other_lib/ebin/my_module.beam</p>

<p style="margin-top: 1em">--build_plt: <br>
The analysis starts from an empty PLT and creates a new one
from the files specified with -c and -r. This option only
works for BEAM files. To override the default PLT
loca&acirc; <br>
tion, use --plt or --output_plt.</p>

<p style="margin-top: 1em">--check_plt: <br>
Check the PLT for consistency and rebuild it if it is not
up-to-date.</p>

<p style="margin-top: 1em">-Dname (or -Dname=value): <br>
When analyzing from source, pass the define to Dialyzer.
(**)</p>

<p style="margin-top: 1em">--dump_callgraph file: <br>
Dump the call graph into the specified file whose format is
determined by the filename extension. Supported extensions
are: raw, dot, and ps. If something else is used as <br>
filename extension, default format .raw is used.</p>

<p style="margin-top: 1em">files_or_dirs (for backward
compatibility also as -c files_or_dirs): <br>
Use Dialyzer from the command line to detect defects in the
specified files or directories containing .erl or .beam
files, depending on the type of the analysis.</p>

<p style="margin-top: 1em">--fullpath: <br>
Display the full path names of files for which warnings are
emitted.</p>

<p style="margin-top: 1em">--get_warnings: <br>
Make Dialyzer emit warnings even when manipulating the PLT.
Warnings are only emitted for files that are analyzed.</p>

<p style="margin-top: 1em">--gui: <br>
Use the GUI.</p>

<p style="margin-top: 1em">--help (or -h): <br>
Print this message and exit.</p>

<p style="margin-top: 1em">-I include_dir: <br>
When analyzing from source, pass the include_dir to
Dialyzer. (**)</p>

<p style="margin-top: 1em">--no_check_plt: <br>
Skip the PLT check when running Dialyzer. This is useful
when working with installed PLTs that never change.</p>

<p style="margin-top: 1em">--no_native (or -nn): <br>
Bypass the native code compilation of some key files that
Dialyzer heuristically performs when dialyzing many files.
This avoids the compilation time, but can result in <br>
(much) longer analysis time.</p>

<p style="margin-top: 1em">--no_native_cache: <br>
By default, Dialyzer caches the results of native
compilation in directory
$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache. XDG_CACHE_HOME
defaults to $HOME/.cache. Use this <br>
option to disable caching.</p>

<p style="margin-top: 1em">-o outfile (or --output
outfile): <br>
When using Dialyzer from the command line, send the analysis
results to the specified outfile rather than to stdout.</p>

<p style="margin-top: 1em">--output_plt file: <br>
Store the PLT at the specified file after building it.</p>

<p style="margin-top: 1em">-pa dir: <br>
Include dir in the path for Erlang. This is useful when
analyzing files that have -include_lib() directives.</p>

<p style="margin-top: 1em">--plt plt: <br>
Use the specified PLT as the initial PLT. If the PLT was
built during setup, the files are checked for
consistency.</p>

<p style="margin-top: 1em">--plt_info: <br>
Make Dialyzer print information about the PLT and then quit.
The PLT can be specified with --plt(s).</p>

<p style="margin-top: 1em">--plts plt*: <br>
Merge the specified PLTs to create the initial PLT. This
requires that the PLTs are disjoint (that is, do not have
any module appearing in more than one PLT). The PLTs are
<br>
created in the usual way:</p>

<p style="margin-top: 1em">dialyzer --build_plt
--output_plt plt_1 files_to_include <br>
... <br>
dialyzer --build_plt --output_plt plt_n files_to_include</p>

<p style="margin-top: 1em">They can then be used in either
of the following ways:</p>

<p style="margin-top: 1em">dialyzer files_to_analyze --plts
plt_1 ... plt_n</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">dialyzer --plts plt_1 ... plt_n
-- files_to_analyze</p>

<p style="margin-top: 1em">Notice the -- delimiter in the
second case.</p>

<p style="margin-top: 1em">--quiet (or -q): <br>
Make Dialyzer a bit more quiet.</p>

<p style="margin-top: 1em">-r dirs: <br>
Same as files_or_dirs, but the specified directories are
searched recursively for subdirectories containing .erl or
.beam files in them, depending on the type of analysis.</p>

<p style="margin-top: 1em">--raw: <br>
When using Dialyzer from the command line, output the raw
analysis results (Erlang terms) instead of the formatted
result. The raw format is easier to post-process (for
exam&acirc; <br>
ple, to filter warnings or to output HTML pages).</p>

<p style="margin-top: 1em">--remove_from_plt: <br>
The information from the files specified with -c and -r is
removed from the PLT. Notice that this can cause a
reanalysis of the remaining dependent files.</p>

<p style="margin-top: 1em">--shell: <br>
Do not disable the Erlang shell while running the GUI.</p>

<p style="margin-top: 1em">--src: <br>
Override the default, which is to analyze BEAM files, and
analyze starting from Erlang source code instead.</p>

<p style="margin-top: 1em">--statistics: <br>
Print information about the progress of execution (analysis
phases, time spent in each, and size of the relative
input).</p>

<p style="margin-top: 1em">--verbose: <br>
Make Dialyzer a bit more verbose.</p>

<p style="margin-top: 1em">--version (or -v): <br>
Print the Dialyzer version and some more information and
exit.</p>

<p style="margin-top: 1em">-Wwarn: <br>
A family of options that selectively turn on/off warnings.
(For help on the names of warnings, use dialyzer -Whelp.)
Notice that the options can also be specified in the file
<br>
with a -dialyzer() attribute. For details, see section
Requesting or Suppressing Warnings in Source Files.</p>

<p style="margin-top: 1em">Note: <br>
** options -D and -I work both from the command line and in
the Dialyzer GUI; the syntax of defines and includes is the
same as that used by erlc(1).</p>

<p style="margin-top: 1em">Warning options:</p>

<p style="margin-top: 1em">-Werror_handling (***): <br>
Include warnings for functions that only return by an
exception.</p>

<p style="margin-top: 1em">-Wno_behaviours: <br>
Suppress warnings about behavior callbacks that drift from
the published recommended interfaces.</p>

<p style="margin-top: 1em">-Wno_contracts: <br>
Suppress warnings about invalid contracts.</p>

<p style="margin-top: 1em">-Wno_fail_call: <br>
Suppress warnings for failing calls.</p>

<p style="margin-top: 1em">-Wno_fun_app: <br>
Suppress warnings for fun applications that will fail.</p>

<p style="margin-top: 1em">-Wno_improper_lists: <br>
Suppress warnings for construction of improper lists.</p>

<p style="margin-top: 1em">-Wno_match: <br>
Suppress warnings for patterns that are unused or cannot
match.</p>

<p style="margin-top: 1em">-Wno_missing_calls: <br>
Suppress warnings about calls to missing functions.</p>

<p style="margin-top: 1em">-Wno_opaque: <br>
Suppress warnings for violations of opacity of data
types.</p>

<p style="margin-top: 1em">-Wno_return: <br>
Suppress warnings for functions that will never return a
value.</p>

<p style="margin-top: 1em">-Wno_undefined_callbacks: <br>
Suppress warnings about behaviors that have no -callback
attributes for their callbacks.</p>

<p style="margin-top: 1em">-Wno_unused: <br>
Suppress warnings for unused functions.</p>

<p style="margin-top: 1em">-Wrace_conditions (***): <br>
Include warnings for possible race conditions. Notice that
the analysis that finds data races performs intra-procedural
data flow analysis and can sometimes explode in time. <br>
Enable it at your own risk.</p>

<p style="margin-top: 1em">-Wunderspecs (***): <br>
Warn about underspecified functions (the specification is
strictly more allowing than the success typing).</p>

<p style="margin-top: 1em">-Wunknown (***): <br>
Let warnings about unknown functions and types affect the
exit status of the command-line version. The default is to
ignore warnings about unknown functions and types when <br>
setting the exit status. When using Dialyzer from Erlang,
warnings about unknown functions and types are returned; the
default is not to return these warnings.</p>

<p style="margin-top: 1em">-Wunmatched_returns (***): <br>
Include warnings for function calls that ignore a structured
return value or do not match against one of many possible
return value(s).</p>

<p style="margin-top: 1em">The following options are also
available, but their use is not recommended (they are mostly
for Dialyzer developers and internal debugging):</p>

<p style="margin-top: 1em">-Woverspecs (***): <br>
Warn about overspecified functions (the specification is
strictly less allowing than the success typing).</p>

<p style="margin-top: 1em">-Wspecdiffs (***): <br>
Warn when the specification is different than the success
typing.</p>

<p style="margin-top: 1em">Note: <br>
*** denotes options that turn on warnings rather than
turning them off.</p>

<p style="margin-top: 1em">USING DIALYZER FROM ERLANG <br>
Dialyzer can be used directly from Erlang. Both the GUI and
the command-line versions are also available. The options
are similar to the ones given from the command line, see
<br>
section Using Dialyzer from the Command Line.</p>

<p style="margin-top: 1em">REQUESTING OR SUPPRESSING
WARNINGS IN SOURCE FILES <br>
Attribute -dialyzer() can be used for turning off warnings
in a module by specifying functions or warning options. For
example, to turn off all warnings for the function f/0, <br>
include the following line:</p>

<p style="margin-top: 1em">-dialyzer({nowarn_function,
f/0}).</p>

<p style="margin-top: 1em">To turn off warnings for
improper lists, add the following line to the source
file:</p>


<p style="margin-top: 1em">-dialyzer(no_improper_lists).</p>

<p style="margin-top: 1em">Attribute -dialyzer() is allowed
after function declarations. Lists of warning options or
functions are allowed:</p>

<p style="margin-top: 1em">-dialyzer([{nowarn_function,
[f/0]}, no_improper_lists]).</p>

<p style="margin-top: 1em">Warning options can be
restricted to functions:</p>

<p style="margin-top: 1em">-dialyzer({no_improper_lists,
g/0}).</p>

<p style="margin-top: 1em">-dialyzer({[no_return,
no_match], [g/0, h/0]}).</p>

<p style="margin-top: 1em">For help on the warning options,
use dialyzer -Whelp. The options are also enumerated, see
function gui/1 below (WarnOpts).</p>

<p style="margin-top: 1em">Note: <br>
Attribute -dialyzer() is not checked by the Erlang compiler,
but by Dialyzer itself.</p>

<p style="margin-top: 1em">Note: <br>
Warning option -Wrace_conditions has no effect when set in
source files.</p>

<p style="margin-top: 1em">Attribute -dialyzer() can also
be used for turning on warnings. For example, if a module
has been fixed regarding unmatched returns, adding the
following line can help in assur&acirc; <br>
ing that no new unmatched return warnings are
introduced:</p>


<p style="margin-top: 1em">-dialyzer(unmatched_returns).</p>

<p style="margin-top: 1em">EXPORTS <br>
format_warning(Msg) -&gt; string()</p>

<p style="margin-top: 1em">Types:</p>

<p style="margin-top: 1em">Msg = {Tag, Id, msg()} <br>
See run/1.</p>

<p style="margin-top: 1em">Get a string from warnings as
returned by run/1.</p>

<p style="margin-top: 1em">gui() -&gt; ok | {error, Msg}
<br>
gui(OptList) -&gt; ok | {error, Msg}</p>

<p style="margin-top: 1em">Types:</p>

<p style="margin-top: 1em">OptList <br>
See below.</p>

<p style="margin-top: 1em">Dialyzer GUI version.</p>

<p style="margin-top: 1em">OptList :: [Option] <br>
Option :: {files, [Filename :: string()]} <br>
| {files_rec, [DirName :: string()]} <br>
| {defines, [{Macro :: atom(), Value :: term()}]} <br>
| {from, src_code | byte_code} <br>
%% Defaults to byte_code <br>
| {init_plt, FileName :: string()} <br>
%% If changed from default <br>
| {plts, [FileName :: string()]} <br>
%% If changed from default <br>
| {include_dirs, [DirName :: string()]} <br>
| {output_file, FileName :: string()} <br>
| {output_plt, FileName :: string()} <br>
| {check_plt, boolean()}, <br>
| {analysis_type, &rsquo;succ_typings&rsquo; | <br>
&rsquo;plt_add&rsquo; | <br>
&rsquo;plt_build&rsquo; | <br>
&rsquo;plt_check&rsquo; | <br>
&rsquo;plt_remove&rsquo;} <br>
| {warnings, [WarnOpts]} <br>
| {get_warnings, bool()}</p>

<p style="margin-top: 1em">WarnOpts :: error_handling <br>
| no_behaviours <br>
| no_contracts <br>
| no_fail_call <br>
| no_fun_app <br>
| no_improper_lists <br>
| no_match <br>
| no_missing_calls <br>
| no_opaque <br>
| no_return <br>
| no_undefined_callbacks <br>
| no_unused <br>
| race_conditions <br>
| underspecs <br>
| unknown <br>
| unmatched_returns <br>
| overspecs <br>
| specdiffs</p>

<p style="margin-top: 1em">plt_info(string()) -&gt;
{&rsquo;ok&rsquo;, [{atom(), any()}]} |
{&rsquo;error&rsquo;, atom()}</p>

<p style="margin-top: 1em">Returns information about the
specified PLT.</p>

<p style="margin-top: 1em">run(OptList) -&gt; Warnings</p>

<p style="margin-top: 1em">Types:</p>

<p style="margin-top: 1em">OptList <br>
See gui/0,1. <br>
Warnings <br>
See below.</p>

<p style="margin-top: 1em">Dialyzer command-line
version.</p>

<p style="margin-top: 1em">Warnings :: [{Tag, Id, Msg}]
<br>
Tag :: &rsquo;warn_behaviour&rsquo; <br>
| &rsquo;warn_bin_construction&rsquo; <br>
| &rsquo;warn_callgraph&rsquo; <br>
| &rsquo;warn_contract_not_equal&rsquo; <br>
| &rsquo;warn_contract_range&rsquo; <br>
| &rsquo;warn_contract_subtype&rsquo; <br>
| &rsquo;warn_contract_supertype&rsquo; <br>
| &rsquo;warn_contract_syntax&rsquo; <br>
| &rsquo;warn_contract_types&rsquo; <br>
| &rsquo;warn_failing_call&rsquo; <br>
| &rsquo;warn_fun_app&rsquo; <br>
| &rsquo;warn_matching&rsquo; <br>
| &rsquo;warn_non_proper_list&rsquo; <br>
| &rsquo;warn_not_called&rsquo; <br>
| &rsquo;warn_opaque&rsquo; <br>
| &rsquo;warn_race_condition&rsquo; <br>
| &rsquo;warn_return_no_exit&rsquo; <br>
| &rsquo;warn_return_only_exit&rsquo; <br>
| &rsquo;warn_umatched_return&rsquo; <br>
| &rsquo;warn_undefined_callbacks&rsquo; <br>
| &rsquo;warn_unknown&rsquo; <br>
Id = {File :: string(), Line :: integer()} <br>
Msg = msg() -- Undefined</p>

<p style="margin-top: 1em">Ericsson AB dialyzer 3.0.3
dialyzer(1)</p>
<hr>
</body>
</html>
