<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:29:56 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PARALLEL(1) parallel PARALLEL(1)</p>

<p style="margin-top: 1em">NAME <br>
parallel - build and execute shell command lines from
standard input in parallel</p>

<p style="margin-top: 1em">SYNOPSIS <br>
parallel [options] [command [arguments]] &lt;
list_of_arguments</p>

<p style="margin-top: 1em">parallel [options] [command
[arguments]] ( ::: arguments | :::+ arguments | ::::
argfile(s) | ::::+ argfile(s) ) ...</p>

<p style="margin-top: 1em">parallel --semaphore [options]
command</p>

<p style="margin-top: 1em">#!/usr/bin/parallel --shebang
[options] [command [arguments]]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
GNU parallel is a shell tool for executing jobs in parallel
using one or more computers. A job can be a single command
or a small script that has to be run for each of the lines
<br>
in the input. The typical input is a list of files, a list
of hosts, a list of users, a list of URLs, or a list of
tables. A job can also be a command that reads from a pipe.
GNU <br>
parallel can then split the input into blocks and pipe a
block into each command in parallel.</p>

<p style="margin-top: 1em">If you use xargs and tee today
you will find GNU parallel very easy to use as GNU parallel
is written to have the same options as xargs. If you write
loops in shell, you will <br>
find GNU parallel may be able to replace most of the loops
and make them run faster by running several jobs in
parallel.</p>

<p style="margin-top: 1em">GNU parallel makes sure output
from the commands is the same output as you would get had
you run the commands sequentially. This makes it possible to
use output from GNU parallel <br>
as input for other programs.</p>

<p style="margin-top: 1em">For each line of input GNU
parallel will execute command with the line as arguments. If
no command is given, the line of input is executed. Several
lines will be run in parallel. <br>
GNU parallel can often be used as a substitute for xargs or
cat | bash.</p>

<p style="margin-top: 1em">Reader&rsquo;s guide <br>
Start by watching the intro videos for a quick introduction:
http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1</p>

<p style="margin-top: 1em">Then look at the EXAMPLEs after
the list of OPTIONS. That will give you an idea of what GNU
parallel is capable of.</p>

<p style="margin-top: 1em">Then spend an hour walking
through the tutorial (man parallel_tutorial). Your command
line will love you for it.</p>

<p style="margin-top: 1em">Finally you may want to look at
the rest of this manual if you have special needs not
already covered.</p>

<p style="margin-top: 1em">If you want to know the design
decisions behind GNU parallel, try: man parallel_design.
This is also a good intro if you intend to change GNU
parallel.</p>

<p style="margin-top: 1em">OPTIONS <br>
command Command to execute. If command or the following
arguments contain replacement strings (such as {}) every
instance will be substituted with the input.</p>

<p style="margin-top: 1em">If command is given, GNU
parallel solve the same tasks as xargs. If command is not
given GNU parallel will behave similar to cat | sh.</p>

<p style="margin-top: 1em">The command must be an
executable, a script, a composed command, or a function.</p>

<p style="margin-top: 1em">Bash functions: export -f the
function first or use env_parallel.</p>

<p style="margin-top: 1em">Bash aliases: Use
env_parallel.</p>

<p style="margin-top: 1em">Ksh functions and aliases: Use
env_parallel.</p>

<p style="margin-top: 1em">Zsh functions: Use
env_parallel.</p>

<p style="margin-top: 1em">Zsh aliases: No solution.</p>

<p style="margin-top: 1em">Fish functions and aliases: Use
env_parallel.</p>

<p style="margin-top: 1em">Ksh functions and aliases: Use
env_parallel.</p>

<p style="margin-top: 1em">Pdksh functions and aliases: Use
env_parallel.</p>

<p style="margin-top: 1em">The command cannot contain the
character 257 (macron: X).</p>

<p style="margin-top: 1em">{} Input line. This replacement
string will be replaced by a full line read from the input
source. The input source is normally stdin (standard input),
but can also be <br>
given with -a, :::, or ::::.</p>

<p style="margin-top: 1em">The replacement string {} can be
changed with -I.</p>

<p style="margin-top: 1em">If the command line contains no
replacement strings then {} will be appended to the command
line.</p>

<p style="margin-top: 1em">{.} Input line without
extension. This replacement string will be replaced by the
input with the extension removed. If the input line contains
. after the last / the last . <br>
till the end of the string will be removed and {.} will be
replaced with the remaining. E.g. foo.jpg becomes foo,
subdir/foo.jpg becomes subdir/foo, sub.dir/foo.jpg <br>
becomes sub.dir/foo, sub.dir/bar remains sub.dir/bar. If the
input line does not contain . it will remain unchanged.</p>

<p style="margin-top: 1em">The replacement string {.} can
be changed with --er.</p>

<p style="margin-top: 1em">To understand replacement
strings see {}.</p>

<p style="margin-top: 1em">{/} Basename of input line. This
replacement string will be replaced by the input with the
directory part removed.</p>

<p style="margin-top: 1em">The replacement string {/} can
be changed with --basenamereplace.</p>

<p style="margin-top: 1em">To understand replacement
strings see {}.</p>

<p style="margin-top: 1em">{//} Dirname of input line. This
replacement string will be replaced by the dir of the input
line. See dirname(1).</p>

<p style="margin-top: 1em">The replacement string {//} can
be changed with --dirnamereplace.</p>

<p style="margin-top: 1em">To understand replacement
strings see {}.</p>

<p style="margin-top: 1em">{/.} Basename of input line
without extension. This replacement string will be replaced
by the input with the directory and extension part removed.
It is a combination of {/} <br>
and {.}.</p>

<p style="margin-top: 1em">The replacement string {/.} can
be changed with --basenameextensionreplace.</p>

<p style="margin-top: 1em">To understand replacement
strings see {}.</p>

<p style="margin-top: 1em">{#} Sequence number of the job
to run. This replacement string will be replaced by the
sequence number of the job being run. It contains the same
number as $PARALLEL_SEQ.</p>

<p style="margin-top: 1em">The replacement string {#} can
be changed with --seqreplace.</p>

<p style="margin-top: 1em">To understand replacement
strings see {}.</p>

<p style="margin-top: 1em">{%} Job slot number. This
replacement string will be replaced by the job&rsquo;s slot
number between 1 and number of jobs to run in parallel.
There will never be 2 jobs running at <br>
the same time with the same job slot number.</p>

<p style="margin-top: 1em">The replacement string {%} can
be changed with --slotreplace.</p>

<p style="margin-top: 1em">To understand replacement
strings see {}.</p>

<p style="margin-top: 1em">{n} Argument from input source n
or the n&rsquo;th argument. This positional replacement
string will be replaced by the input from input source n
(when used with -a or ::::) or <br>
with the n&rsquo;th argument (when used with -N). If n is
negative it refers to the n&rsquo;th last argument.</p>

<p style="margin-top: 1em">To understand replacement
strings see {}.</p>

<p style="margin-top: 1em">{n.} Argument from input source
n or the n&rsquo;th argument without extension. It is a
combination of {n} and {.}.</p>

<p style="margin-top: 1em">This positional replacement
string will be replaced by the input from input source n
(when used with -a or ::::) or with the n&rsquo;th argument
(when used with -N). The input <br>
will have the extension removed.</p>

<p style="margin-top: 1em">To understand positional
replacement strings see {n}.</p>

<p style="margin-top: 1em">{n/} Basename of argument from
input source n or the n&rsquo;th argument. It is a
combination of {n} and {/}.</p>

<p style="margin-top: 1em">This positional replacement
string will be replaced by the input from input source n
(when used with -a or ::::) or with the n&rsquo;th argument
(when used with -N). The input <br>
will have the directory (if any) removed.</p>

<p style="margin-top: 1em">To understand positional
replacement strings see {n}.</p>

<p style="margin-top: 1em">{n//} Dirname of argument from
input source n or the n&rsquo;th argument. It is a
combination of {n} and {//}.</p>

<p style="margin-top: 1em">This positional replacement
string will be replaced by the dir of the input from input
source n (when used with -a or ::::) or with the n&rsquo;th
argument (when used with <br>
-N). See dirname(1).</p>

<p style="margin-top: 1em">To understand positional
replacement strings see {n}.</p>

<p style="margin-top: 1em">{n/.} Basename of argument from
input source n or the n&rsquo;th argument without extension.
It is a combination of {n}, {/}, and {.}.</p>

<p style="margin-top: 1em">This positional replacement
string will be replaced by the input from input source n
(when used with -a or ::::) or with the n&rsquo;th argument
(when used with -N). The input <br>
will have the directory (if any) and extension removed.</p>

<p style="margin-top: 1em">To understand positional
replacement strings see {n}.</p>

<p style="margin-top: 1em">{=perl expression=} <br>
Replace with calculated perl expression. $_ will contain the
same as {}. After evaluating perl expression $_ will be used
as the value. It is recommended to only change <br>
$_ but you have full access to all of GNU parallel&rsquo;s
internal functions and data structures. A few convenience
functions have been made:</p>

<p style="margin-top: 1em">Q(string) shell quote a
string</p>

<p style="margin-top: 1em">total_jobs() number of jobs in
total</p>

<p style="margin-top: 1em">$job-slot()&gt; slot number of
job</p>

<p style="margin-top: 1em">$job-seq()&gt; sequence number
of job</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">seq 10 | parallel echo {} + 1 is
{= &rsquo;$_++&rsquo; =} <br>
parallel csh -c {= &rsquo;$_=&quot;mkdir &quot;.Q($_)&rsquo;
=} ::: &rsquo;12&quot; dir&rsquo; <br>
seq 50 | parallel echo job {#} of {=
&rsquo;$_=total_jobs()&rsquo; =}</p>

<p style="margin-top: 1em">See also: --rpl --parens</p>

<p style="margin-top: 1em">{=n perl expression=} <br>
Positional equivalent to {=perl expression=}. To understand
positional replacement strings see {n}.</p>

<p style="margin-top: 1em">See also: {=perl expression=}
{n}.</p>

<p style="margin-top: 1em">::: arguments <br>
Use arguments from the command line as input source instead
of stdin (standard input). Unlike other options for GNU
parallel ::: is placed after the command and before <br>
the arguments.</p>

<p style="margin-top: 1em">The following are
equivalent:</p>

<p style="margin-top: 1em">(echo file1; echo file2) |
parallel gzip <br>
parallel gzip ::: file1 file2 <br>
parallel gzip {} ::: file1 file2 <br>
parallel --arg-sep ,, gzip {} ,, file1 file2 <br>
parallel --arg-sep ,, gzip ,, file1 file2 <br>
parallel ::: &quot;gzip file1&quot; &quot;gzip
file2&quot;</p>

<p style="margin-top: 1em">To avoid treating ::: as special
use --arg-sep to set the argument separator to something
else. See also --arg-sep.</p>

<p style="margin-top: 1em">stdin (standard input) will be
passed to the first process run.</p>

<p style="margin-top: 1em">If multiple ::: are given, each
group will be treated as an input source, and all
combinations of input sources will be generated. E.g. ::: 1
2 ::: a b c will result in <br>
the combinations (1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This
is useful for replacing nested for-loops.</p>

<p style="margin-top: 1em">::: and :::: can be mixed. So
these are equivalent:</p>

<p style="margin-top: 1em">parallel echo {1} {2} {3} ::: 6
7 ::: 4 5 ::: 1 2 3 <br>
parallel echo {1} {2} {3} :::: &lt;(seq 6 7) &lt;(seq 4 5)
:::: &lt;(seq 1 3) <br>
parallel -a &lt;(seq 6 7) echo {1} {2} {3} :::: &lt;(seq 4
5) :::: &lt;(seq 1 3) <br>
parallel -a &lt;(seq 6 7) -a &lt;(seq 4 5) echo {1} {2} {3}
::: 1 2 3 <br>
seq 6 7 | parallel -a - -a &lt;(seq 4 5) echo {1} {2} {3}
::: 1 2 3 <br>
seq 4 5 | parallel echo {1} {2} {3} :::: &lt;(seq 6 7) - :::
1 2 3</p>

<p style="margin-top: 1em">:::+ arguments <br>
Like ::: but linked like --xapply to the previous input
source.</p>

<p style="margin-top: 1em">Contrary to --xapply values do
not wrap: The shortest input source determines the
length.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">parallel echo ::: a b c :::+ 1 2
3 ::: X Y :::+ 11 22</p>

<p style="margin-top: 1em">:::: argfiles <br>
Another way to write -a argfile1 -a argfile2 ...</p>

<p style="margin-top: 1em">::: and :::: can be mixed.</p>

<p style="margin-top: 1em">See -a, ::: and --xapply.</p>

<p style="margin-top: 1em">::::+ argfiles <br>
Like ::::+ but linked like --xapply to the previous input
source.</p>

<p style="margin-top: 1em">Contrary to --xapply values do
not wrap: The shortest input source determines the
length.</p>

<p style="margin-top: 1em">--null <br>
-0 Use NUL as delimiter. Normally input lines will end in
(newline). If they end in (NUL), then use this option. It is
useful for processing arguments that may <br>
contain (newline).</p>

<p style="margin-top: 1em">--arg-file input-file <br>
-a input-file <br>
Use input-file as input source. If you use this option,
stdin (standard input) is given to the first process run.
Otherwise, stdin (standard input) is redirected from <br>
/dev/null.</p>

<p style="margin-top: 1em">If multiple -a are given, each
input-file will be treated as an input source, and all
combinations of input sources will be generated. E.g. The
file foo contains 1 2, <br>
the file bar contains a b c. -a foo -a bar will result in
the combinations (1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This
is useful for replacing nested for-loops.</p>

<p style="margin-top: 1em">See also --xapply and {n}.</p>

<p style="margin-top: 1em">--arg-file-sep sep-str <br>
Use sep-str instead of :::: as separator string between
command and argument files. Useful if :::: is used for
something else by the command.</p>

<p style="margin-top: 1em">See also: ::::.</p>

<p style="margin-top: 1em">--arg-sep sep-str <br>
Use sep-str instead of ::: as separator string. Useful if
::: is used for something else by the command.</p>

<p style="margin-top: 1em">Also useful if you command uses
::: but you still want to read arguments from stdin
(standard input): Simply change --arg-sep to a string that
is not in the command <br>
line.</p>

<p style="margin-top: 1em">See also: :::.</p>

<p style="margin-top: 1em">--bar Show progress as a
progress bar. In the bar is shown: % of jobs completed,
estimated seconds left, and number of jobs started.</p>

<p style="margin-top: 1em">It is compatible with
zenity:</p>

<p style="margin-top: 1em">seq 1000 | parallel -j30 --bar
&rsquo;(echo {};sleep 0.1)&rsquo; 2&gt; &gt;(zenity
--progress --auto-kill) | wc</p>

<p style="margin-top: 1em">--basefile file <br>
--bf file <br>
file will be transferred to each sshlogin before a jobs is
started. It will be removed if --cleanup is active. The file
may be a script to run or some common base data <br>
needed for the jobs. Multiple --bf can be specified to
transfer more basefiles. The file will be transferred the
same way as --transferfile.</p>

<p style="margin-top: 1em">--basenamereplace replace-str
<br>
--bnr replace-str <br>
Use the replacement string replace-str instead of {/} for
basename of input line.</p>

<p style="margin-top: 1em">--basenameextensionreplace
replace-str <br>
--bner replace-str <br>
Use the replacement string replace-str instead of {/.} for
basename of input line without extension.</p>

<p style="margin-top: 1em">--bg Run command in background
thus GNU parallel will not wait for completion of the
command before exiting. This is the default if --semaphore
is set.</p>

<p style="margin-top: 1em">See also: --fg, man sem.</p>

<p style="margin-top: 1em">Implies --semaphore.</p>

<p style="margin-top: 1em">--bibtex <br>
--citation <br>
Print the BibTeX entry for GNU parallel and silence citation
notice.</p>

<p style="margin-top: 1em">If it is impossible for you to
run --bibtex you can use --will-cite.</p>

<p style="margin-top: 1em">If you use --will-cite in
scripts to be run by others you are making it harder for
others to see the citation notice. The development of GNU
parallel is indirectly <br>
financed through citations, so if your users do not know
they should cite then you are making it harder to finance
development. However, if you pay 10000 EUR, you should <br>
feel free to use --will-cite in scripts.</p>

<p style="margin-top: 1em">--block size <br>
--block-size size <br>
Size of block in bytes to read at a time. The size can be
postfixed with K, M, G, T, P, k, m, g, t, or p which would
multiply the size with 1024, 1048576, 1073741824, <br>
1099511627776, 1125899906842624, 1000, 1000000, 1000000000,
1000000000000, or 1000000000000000, respectively.</p>

<p style="margin-top: 1em">GNU parallel tries to meet the
block size but can be off by the length of one record. For
performance reasons size should be bigger than a two
records. GNU parallel will <br>
warn you and automatically increase the size if you choose a
size that is too small.</p>

<p style="margin-top: 1em">If you use -N, --block-size
should be bigger than N+1 records.</p>

<p style="margin-top: 1em">size defaults to 1M.</p>

<p style="margin-top: 1em">See --pipe and --pipepart for
use of this.</p>

<p style="margin-top: 1em">--cat Create a temporary file
with content. Normally --pipe/--pipepart will give data to
the program on stdin (standard input). With --cat GNU
parallel will create a temporary <br>
file with the name in {}, so you can do: parallel --pipe
--cat wc {}.</p>

<p style="margin-top: 1em">Implies --pipe unless --pipepart
is used.</p>

<p style="margin-top: 1em">See also --fifo.</p>

<p style="margin-top: 1em">--cleanup <br>
Remove transferred files. --cleanup will remove the
transferred files on the remote computer after processing is
done.</p>

<p style="margin-top: 1em">find log -name &rsquo;*gz&rsquo;
| parallel --sshlogin server.example.com --transferfile {}
--return {.}.bz2 --cleanup &quot;zcat {} | bzip -9
&gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">With --transferfile {} the file
transferred to the remote computer will be removed on the
remote computer. Directories created will not be removed -
even if they are <br>
empty.</p>

<p style="margin-top: 1em">With --return the file
transferred from the remote computer will be removed on the
remote computer. Directories created will not be removed -
even if they are empty.</p>

<p style="margin-top: 1em">--cleanup is ignored when not
used with --transferfile or --return.</p>

<p style="margin-top: 1em">--colsep regexp <br>
-C regexp <br>
Column separator. The input will be treated as a table with
regexp separating the columns. The n&rsquo;th column can be
access using {n} or {n.}. E.g. {3} is the 3rd column.</p>

<p style="margin-top: 1em">--colsep implies --trim rl.</p>

<p style="margin-top: 1em">regexp is a Perl Regular
Expression: http://perldoc.perl.org/perlre.html</p>

<p style="margin-top: 1em">--compress <br>
Compress temporary files. If the output is big and very
compressible this will take up less disk space in $TMPDIR
and possibly be faster due to less disk I/O.</p>

<p style="margin-top: 1em">GNU parallel will try lz4, pigz,
lzop, plzip, pbzip2, pxz, gzip, lzma, xz, bzip2, lzip in
that order, and use the first available.</p>

<p style="margin-top: 1em">--compress-program prg <br>
--decompress-program prg <br>
Use prg for (de)compressing temporary files. It is assumed
that prg -dc will decompress stdin (standard input) to
stdout (standard output) unless --decompress-program is <br>
given.</p>

<p style="margin-top: 1em">--delimiter delim <br>
-d delim Input items are terminated by delim. Quotes and
backslash are not special; every character in the input is
taken literally. Disables the end-of-file string, which is
<br>
treated like any other argument. The specified delimiter may
be characters, C-style character escapes such as 0 or octal
or hexadecimal escape codes. Octal and <br>
hexadecimal escape codes are understood as for the printf
command. Multibyte characters are not supported.</p>

<p style="margin-top: 1em">--dirnamereplace replace-str
<br>
--dnr replace-str <br>
Use the replacement string replace-str instead of {//} for
dirname of input line.</p>

<p style="margin-top: 1em">-E eof-str <br>
Set the end of file string to eof-str. If the end of file
string occurs as a line of input, the rest of the input is
not read. If neither -E nor -e is used, no end of <br>
file string is used.</p>

<p style="margin-top: 1em">--delay secs <br>
Delay starting next job secs seconds. GNU parallel will
pause secs seconds after starting each job. secs can be less
than 1 second.</p>

<p style="margin-top: 1em">--dry-run <br>
Print the job to run on stdout (standard output), but do not
run the job. Use -v -v to include the wrapping that GNU
Parallel generates (for remote jobs, --tmux, --nice, <br>
--pipe, --pipepart, --fifo and --cat). Do not count on this
literaly, though, as the job may be scheduled on another
computer or the local computer if : is in the list.</p>

<p style="margin-top: 1em">--eof[=eof-str] <br>
-e[eof-str] <br>
This option is a synonym for the -E option. Use -E instead,
because it is POSIX compliant for xargs while this option is
not. If eof-str is omitted, there is no end of <br>
file string. If neither -E nor -e is used, no end of file
string is used.</p>

<p style="margin-top: 1em">--env var <br>
Copy environment variable var. This will copy var to the
environment that the command is run in. This is especially
useful for remote execution.</p>

<p style="margin-top: 1em">In Bash var can also be a Bash
function - just remember to export -f the function, see
command.</p>

<p style="margin-top: 1em">The variable &rsquo;_&rsquo; is
special. It will copy all exported environment variables
except for the ones mentioned in
~/.parallel/ignored_vars.</p>

<p style="margin-top: 1em">To copy the full environment
(both exported and not exported variables, arrays, and
functions) use env_parallel as described under the option
command.</p>

<p style="margin-top: 1em">See also: --record-env.</p>

<p style="margin-top: 1em">--eta Show the estimated number
of seconds before finishing. This forces GNU parallel to
read all jobs before starting to find the number of jobs.
GNU parallel normally only <br>
reads the next job to run.</p>

<p style="margin-top: 1em">The estimate is based on the
runtime of finished jobs, so the first estimate will only be
shown when the first job has finished.</p>

<p style="margin-top: 1em">Implies --progress.</p>

<p style="margin-top: 1em">See also: --bar, --progress.</p>

<p style="margin-top: 1em">--fg Run command in foreground
thus GNU parallel will wait for completion of the command
before exiting.</p>

<p style="margin-top: 1em">Implies --semaphore.</p>

<p style="margin-top: 1em">See also --bg, man sem.</p>

<p style="margin-top: 1em">--fifo Create a temporary fifo
with content. Normally --pipe and --pipepart will give data
to the program on stdin (standard input). With --fifo GNU
parallel will create a <br>
temporary fifo with the name in {}, so you can do: parallel
--pipe --fifo wc {}.</p>

<p style="margin-top: 1em">Beware: If data is not read from
the fifo, the job will block forever.</p>

<p style="margin-top: 1em">Implies --pipe unless --pipepart
is used.</p>

<p style="margin-top: 1em">See also --cat.</p>

<p style="margin-top: 1em">--filter-hosts <br>
Remove down hosts. For each remote host: check that login
through ssh works. If not: do not use this host.</p>

<p style="margin-top: 1em">For performance reasons, this
check is performed only at the start and every time
--sshloginfile is changed. If an host goes down after the
first check, it will go <br>
undetected until --sshloginfile is changed; --retries can be
used to mitigate this.</p>

<p style="margin-top: 1em">Currently you can not put
--filter-hosts in a profile, $PARALLEL, /etc/parallel/config
or similar. This is because GNU parallel uses GNU parallel
to compute this, so you <br>
will get an infinite loop. This will likely be fixed in a
later release.</p>

<p style="margin-top: 1em">--gnu Behave like GNU parallel.
This option historically took precedence over --tollef. The
--tollef option is now retired, and therefore may not be
used. --gnu is kept for <br>
compatibility.</p>

<p style="margin-top: 1em">--group Group output. Output
from each jobs is grouped together and is only printed when
the command is finished. stderr (standard error) first
followed by stdout (standard <br>
output). This takes some CPU time. In rare situations GNU
parallel takes up lots of CPU time and if it is acceptable
that the outputs from different commands are mixed <br>
together, then disabling grouping with -u can speedup GNU
parallel by a factor of 10.</p>

<p style="margin-top: 1em">--group is the default. Can be
reversed with -u.</p>

<p style="margin-top: 1em">See also: --line-buffer
--ungroup</p>

<p style="margin-top: 1em">--help <br>
-h Print a summary of the options to GNU parallel and
exit.</p>

<p style="margin-top: 1em">--halt-on-error val <br>
--halt val <br>
When should GNU parallel terminate? In some situations it
makes no sense to run all jobs. GNU parallel should simply
give up as soon as a condition is met.</p>

<p style="margin-top: 1em">val defaults to never, which
runs all jobs no matter what.</p>

<p style="margin-top: 1em">val can also take on the form of
when,why.</p>

<p style="margin-top: 1em">when can be &rsquo;now&rsquo;
which means kill all running jobs and halt immediately, or
it can be &rsquo;soon&rsquo; which means wait for all
running jobs to complete, but start no new jobs.</p>

<p style="margin-top: 1em">why can be &rsquo;fail=X&rsquo;,
&rsquo;fail=Y%&rsquo;, &rsquo;success=X&rsquo;, or
&rsquo;success=Y%&rsquo; where X is the number of jobs that
has to fail or succeed before halting, and Y is the
percentage of jobs <br>
that has to fail or succeed before halting.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">--halt now,fail=1 exit when the
first job fails. Kill running jobs.</p>

<p style="margin-top: 1em">--halt soon,fail=3 exit when 3
jobs fail, but wait for running jobs to complete.</p>

<p style="margin-top: 1em">--halt soon,fail=3% exit when 3%
of the jobs have failed, but wait for running jobs to
complete.</p>

<p style="margin-top: 1em">--halt now,success=1 exit when a
job succeeds. Kill running jobs.</p>

<p style="margin-top: 1em">--halt soon,success=3 exit when
3 jobs succeeds, but wait for running jobs to complete.</p>

<p style="margin-top: 1em">--halt now,success=3% exit when
3% of the jobs have succeeded. Kill running jobs.</p>

<p style="margin-top: 1em">For backwards compability these
also work:</p>

<p style="margin-top: 1em">0 never</p>

<p style="margin-top: 1em">1 soon,fail=1</p>

<p style="margin-top: 1em">2 now,fail=1</p>

<p style="margin-top: 1em">-1 soon,success=1</p>

<p style="margin-top: 1em">-2 now,success=1</p>

<p style="margin-top: 1em">1-99% soon,fail=1-99%</p>

<p style="margin-top: 1em">--header regexp <br>
Use regexp as header. For normal usage the matched header
(typically the first line: --header &rsquo;.*0) will be
split using --colsep (which will default to &rsquo;&rsquo;)
and <br>
column names can be used as replacement variables: {column
name}.</p>

<p style="margin-top: 1em">For --pipe the matched header
will be prepended to each output.</p>

<p style="margin-top: 1em">--header : is an alias for
--header &rsquo;.*0.</p>

<p style="margin-top: 1em">If regexp is a number, it is a
fixed number of lines.</p>

<p style="margin-top: 1em">--hostgroups <br>
--hgrp Enable hostgroups on arguments. If an argument
contains &rsquo;@&rsquo; the string after &rsquo;@&rsquo;
will be removed and treated as a list of hostgroups on which
this job is allowed to run. <br>
If there is no --sshlogin with a corresponding group, the
job will run on any hostgroup.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">parallel --hostgroups --sshlogin
@grp1/myserver1 -S @grp1+grp2/myserver2 --sshlogin
@grp3/myserver3 echo ::: my_grp1_arg@grp1 arg_for_grp2@grp2
third_arg@grp1+grp3</p>

<p style="margin-top: 1em">my_grp1_arg may be run on either
myserver1 or myserver2, third_arg may be run on either
myserver1 or myserver3, but arg_for_grp2 will only be run on
myserver2.</p>

<p style="margin-top: 1em">See also: --sshlogin.</p>

<p style="margin-top: 1em">-I replace-str <br>
Use the replacement string replace-str instead of {}.</p>

<p style="margin-top: 1em">--replace[=replace-str] <br>
-i[replace-str] <br>
This option is a synonym for -Ireplace-str if replace-str is
specified, and for -I {} otherwise. This option is
deprecated; use -I instead.</p>

<p style="margin-top: 1em">--joblog logfile <br>
Logfile for executed jobs. Save a list of the executed jobs
to logfile in the following TAB separated format: sequence
number, sshlogin, start time as seconds since <br>
epoch, run time in seconds, bytes in files transferred,
bytes in files returned, exit status, signal, and command
run.</p>

<p style="margin-top: 1em">For --pipe bytes transferred and
bytes returned are number of input and output of bytes.</p>

<p style="margin-top: 1em">To convert the times into
ISO-8601 strict do:</p>

<p style="margin-top: 1em">perl -a -F&quot;&quot; -ne
&rsquo;chomp($F[2]=&lsquo;date -d @$F[2] +%FT%T&lsquo;);
print join(&quot;&quot;,@F)&rsquo;</p>

<p style="margin-top: 1em">See also --resume
--resume-failed.</p>

<p style="margin-top: 1em">--jobs N <br>
-j N <br>
--max-procs N <br>
-P N Number of jobslots on each machine. Run up to N jobs in
parallel. 0 means as many as possible. Default is 100% which
will run one job per CPU core on each machine.</p>

<p style="margin-top: 1em">If --semaphore is set, the
default is 1 thus making a mutex.</p>

<p style="margin-top: 1em">--jobs +N <br>
-j +N <br>
--max-procs +N <br>
-P +N Add N to the number of CPU cores. Run this many jobs
in parallel. See also --use-cpus-instead-of-cores.</p>

<p style="margin-top: 1em">--jobs -N <br>
-j -N <br>
--max-procs -N <br>
-P -N Subtract N from the number of CPU cores. Run this many
jobs in parallel. If the evaluated number is less than 1
then 1 will be used. See also <br>
--use-cpus-instead-of-cores.</p>

<p style="margin-top: 1em">--jobs N% <br>
-j N% <br>
--max-procs N% <br>
-P N% Multiply N% with the number of CPU cores. Run this
many jobs in parallel. See also
--use-cpus-instead-of-cores.</p>

<p style="margin-top: 1em">--jobs procfile <br>
-j procfile <br>
--max-procs procfile <br>
-P procfile <br>
Read parameter from file. Use the content of procfile as
parameter for -j. E.g. procfile could contain the string
100% or +2 or 10. If procfile is changed when a job <br>
completes, procfile is read again and the new number of jobs
is computed. If the number is lower than before, running
jobs will be allowed to finish but new jobs will <br>
not be started until the wanted number of jobs has been
reached. This makes it possible to change the number of
simultaneous running jobs while GNU parallel is running.</p>

<p style="margin-top: 1em">--keep-order <br>
-k Keep sequence of output same as the order of input.
Normally the output of a job will be printed as soon as the
job completes. Try this to see the difference:</p>

<p style="margin-top: 1em">parallel -j4 sleep {}; echo {}
::: 2 1 4 3 <br>
parallel -j4 -k sleep {}; echo {} ::: 2 1 4 3</p>

<p style="margin-top: 1em">If used with --onall or --nonall
the output will grouped by sshlogin in sorted order.</p>

<p style="margin-top: 1em">-L max-lines <br>
When used with --pipe: Read records of max-lines.</p>

<p style="margin-top: 1em">When used otherwise: Use at most
max-lines nonblank input lines per command line. Trailing
blanks cause an input line to be logically continued on the
next input line.</p>

<p style="margin-top: 1em">-L 0 means read one line, but
insert 0 arguments on the command line.</p>

<p style="margin-top: 1em">Implies -X unless -m, --xargs,
or --pipe is set.</p>

<p style="margin-top: 1em">--max-lines[=max-lines] <br>
-l[max-lines] <br>
When used with --pipe: Read records of max-lines.</p>

<p style="margin-top: 1em">When used otherwise: Synonym for
the -L option. Unlike -L, the max-lines argument is
optional. If max-lines is not specified, it defaults to one.
The -l option is <br>
deprecated since the POSIX standard specifies -L
instead.</p>

<p style="margin-top: 1em">-l 0 is an alias for -l 1.</p>

<p style="margin-top: 1em">Implies -X unless -m, --xargs,
or --pipe is set.</p>

<p style="margin-top: 1em">--line-buffer <br>
--lb Buffer output on line basis. --group will keep the
output together for a whole job. --ungroup allows output to
mixup with half a line coming from one job and half a line
<br>
coming from another job. --line-buffer fits between these
two: GNU parallel will print a full line, but will allow for
mixing lines of different jobs.</p>

<p style="margin-top: 1em">--line-buffer takes more CPU
power than than both --group and --ungroup, but can be
faster than --group if the CPU is not the limiting
factor.</p>

<p style="margin-top: 1em">See also: --group --ungroup</p>

<p style="margin-top: 1em">--load max-load <br>
Do not start new jobs on a given computer unless the number
of running processes on the computer is less than max-load.
max-load uses the same syntax as --jobs, so 100% <br>
for one per CPU is a valid setting. Only difference is 0
which is interpreted as 0.01.</p>

<p style="margin-top: 1em">--controlmaster <br>
-M Use ssh&rsquo;s ControlMaster to make ssh connections
faster. Useful if jobs run remote and are very fast to run.
This is disabled for sshlogins that specify their own ssh
<br>
command.</p>

<p style="margin-top: 1em">--xargs Multiple arguments.
Insert as many arguments as the command line length
permits.</p>

<p style="margin-top: 1em">If {} is not used the arguments
will be appended to the line. If {} is used multiple times
each {} will be replaced with all the arguments.</p>

<p style="margin-top: 1em">Support for --xargs with
--sshlogin is limited and may fail.</p>

<p style="margin-top: 1em">See also -X for context replace.
If in doubt use -X as that will most likely do what is
needed.</p>

<p style="margin-top: 1em">-m Multiple arguments. Insert as
many arguments as the command line length permits. If
multiple jobs are being run in parallel: distribute the
arguments evenly among the <br>
jobs. Use -j1 or --xargs to avoid this.</p>

<p style="margin-top: 1em">If {} is not used the arguments
will be appended to the line. If {} is used multiple times
each {} will be replaced with all the arguments.</p>

<p style="margin-top: 1em">Support for -m with --sshlogin
is limited and may fail.</p>

<p style="margin-top: 1em">See also -X for context replace.
If in doubt use -X as that will most likely do what is
needed.</p>

<p style="margin-top: 1em">--memfree size <br>
Minimum memory free when starting another job. The size can
be postfixed with K, M, G, T, P, k, m, g, t, or p which
would multiply the size with 1024, 1048576, <br>
1073741824, 1099511627776, 1125899906842624, 1000, 1000000,
1000000000, 1000000000000, or 1000000000000000,
respectively.</p>

<p style="margin-top: 1em">If the jobs take up very
different amount of RAM, GNU parallel will only start as
many as there is memory for. If less than size bytes are
free, no more jobs will be <br>
started. If less than 50% size bytes are free, the youngest
job will be killed, and put back on the queue to be run
later.</p>

<p style="margin-top: 1em">--minversion version <br>
Print the version GNU parallel and exit. If the current
version of GNU parallel is less than version the exit code
is 255. Otherwise it is 0.</p>

<p style="margin-top: 1em">This is useful for scripts that
depend on features only available from a certain version of
GNU parallel.</p>

<p style="margin-top: 1em">--nonall --onall with no
arguments. Run the command on all computers given with
--sshlogin but take no arguments. GNU parallel will log into
--jobs number of computers in <br>
parallel and run the job on the computer. -j adjusts how
many computers to log into in parallel.</p>

<p style="margin-top: 1em">This is useful for running the
same command (e.g. uptime) on a list of servers.</p>

<p style="margin-top: 1em">--onall Run all the jobs on all
computers given with --sshlogin. GNU parallel will log into
--jobs number of computers in parallel and run one job at a
time on the computer. The <br>
order of the jobs will not be changed, but some computers
may finish before others.</p>

<p style="margin-top: 1em">When using --group the output
will be grouped by each server, so all the output from one
server will be grouped together.</p>

<p style="margin-top: 1em">--joblog will contain an entry
for each job on each server, so there will be several job
sequence 1.</p>

<p style="margin-top: 1em">--output-as-files <br>
--outputasfiles <br>
--files Instead of printing the output to stdout (standard
output) the output of each job is saved in a file and the
filename is then printed.</p>

<p style="margin-top: 1em">See also: --results</p>

<p style="margin-top: 1em">--pipe <br>
--spreadstdin <br>
Spread input to jobs on stdin (standard input). Read a block
of data from stdin (standard input) and give one block of
data as input to one job.</p>

<p style="margin-top: 1em">The block size is determined by
--block. The strings --recstart and --recend tell GNU
parallel how a record starts and/or ends. The block read
will have the final <br>
partial record removed before the block is passed on to the
job. The partial record will be prepended to next block.</p>

<p style="margin-top: 1em">If --recstart is given this will
be used to split at record start.</p>

<p style="margin-top: 1em">If --recend is given this will
be used to split at record end.</p>

<p style="margin-top: 1em">If both --recstart and --recend
are given both will have to match to find a split
position.</p>

<p style="margin-top: 1em">If neither --recstart nor
--recend are given --recend defaults to &rsquo;0. To have no
record separator use --recend &quot;&quot;.</p>

<p style="margin-top: 1em">--files is often used with
--pipe.</p>

<p style="margin-top: 1em">--pipe maxes out at around 1
GB/s input, and 100 MB/s output. If performance is important
use --pipepart.</p>

<p style="margin-top: 1em">See also: --recstart, --recend,
--fifo, --cat, --pipepart, --files.</p>

<p style="margin-top: 1em">--pipepart <br>
Pipe parts of a physical file. --pipepart works similar to
--pipe, but is much faster.</p>

<p style="margin-top: 1em">If --block is left out,
--pipepart will use a block size that will result in 10 jobs
per jobslot, except if run with --round-robin in which case
it will result in 1 job <br>
per jobslot.</p>

<p style="margin-top: 1em">--pipepart has a few
limitations:</p>

<p style="margin-top: 1em">* The file must be a normal file
or a block device (technically it must be seekable) and must
be given using -a or ::::. The file cannot be a pipe or a
fifo as they are <br>
not seekable.</p>

<p style="margin-top: 1em">If using a block device with lot
of NUL bytes, remember to set --recend &rsquo;&rsquo;.</p>

<p style="margin-top: 1em">* Record counting (-N) and line
counting (-L/-l) do not work.</p>

<p style="margin-top: 1em">--plain Ignore any --profile,
$PARALLEL, and ~/.parallel/config to get full control on the
command line (used by GNU parallel internally when called
with --sshlogin).</p>

<p style="margin-top: 1em">--plus Activate additional
replacement strings: {+/} {+.} {+..} {+...} {..} {...} {/..}
{/...} {##}. The idea being that &rsquo;{+foo}&rsquo;
matches the opposite of &rsquo;{foo}&rsquo; and {} = <br>
{+/}/{/} = {.}.{+.} = {+/}/{/.}.{+.} = {..}.{+..} =
{+/}/{/..}.{+..} = {...}.{+...} = {+/}/{/...}.{+...}</p>

<p style="margin-top: 1em">{##} is the number of jobs to be
run. It is incompatible with -X/-m/--xargs.</p>

<p style="margin-top: 1em">--progress <br>
Show progress of computations. List the computers involved
in the task with number of CPU cores detected and the max
number of jobs to run. After that show progress for <br>
each computer: number of running jobs, number of completed
jobs, and percentage of all jobs done by this computer. The
percentage will only be available after all jobs <br>
have been scheduled as GNU parallel only read the next job
when ready to schedule it - this is to avoid wasting time
and memory by reading everything at startup.</p>

<p style="margin-top: 1em">By sending GNU parallel SIGUSR2
you can toggle turning on/off --progress on a running GNU
parallel process.</p>

<p style="margin-top: 1em">See also --eta.</p>

<p style="margin-top: 1em">--max-args=max-args <br>
-n max-args <br>
Use at most max-args arguments per command line. Fewer than
max-args arguments will be used if the size (see the -s
option) is exceeded, unless the -x option is given, <br>
in which case GNU parallel will exit.</p>

<p style="margin-top: 1em">-n 0 means read one argument,
but insert 0 arguments on the command line.</p>

<p style="margin-top: 1em">Implies -X unless -m is set.</p>

<p style="margin-top: 1em">--max-replace-args=max-args <br>
-N max-args <br>
Use at most max-args arguments per command line. Like -n but
also makes replacement strings {1} .. {max-args} that
represents argument 1 .. max-args. If too few args the <br>
{n} will be empty.</p>

<p style="margin-top: 1em">-N 0 means read one argument,
but insert 0 arguments on the command line.</p>

<p style="margin-top: 1em">This will set the owner of the
homedir to the user:</p>

<p style="margin-top: 1em">tr &rsquo;:&rsquo; &rsquo;0 &lt;
/etc/passwd | parallel -N7 chown {1} {6}</p>

<p style="margin-top: 1em">Implies -X unless -m or --pipe
is set.</p>

<p style="margin-top: 1em">When used with --pipe -N is the
number of records to read. This is somewhat slower than
--block.</p>

<p style="margin-top: 1em">--max-line-length-allowed <br>
Print the maximal number of characters allowed on the
command line and exit (used by GNU parallel itself to
determine the line length on remote computers).</p>

<p style="margin-top: 1em">--number-of-cpus <br>
Print the number of physical CPUs and exit (used by GNU
parallel itself to determine the number of physical CPUs on
remote computers).</p>

<p style="margin-top: 1em">--number-of-cores <br>
Print the number of CPU cores and exit (used by GNU parallel
itself to determine the number of CPU cores on remote
computers).</p>

<p style="margin-top: 1em">--no-keep-order <br>
Overrides an earlier --keep-order (e.g. if set in
~/.parallel/config).</p>

<p style="margin-top: 1em">--nice niceness <br>
Run the command at this niceness. For simple commands you
can just add nice in front of the command. But if the
command consists of more sub commands (Like: ls|wc) then
<br>
prepending nice will not always work. --nice will make sure
all sub commands are niced - even on remote servers.</p>

<p style="margin-top: 1em">--interactive <br>
-p Prompt the user about whether to run each command line
and read a line from the terminal. Only run the command line
if the response starts with &rsquo;y&rsquo; or
&rsquo;Y&rsquo;. Implies -t.</p>

<p style="margin-top: 1em">--parens parensstring <br>
Define start and end parenthesis for {= perl expression =}.
The left and the right parenthesis can be multiple
characters and are assumed to be the same length. The <br>
default is {==} giving {= as the start parenthesis and =} as
the end parenthesis.</p>

<p style="margin-top: 1em">Another useful setting is ,,,,
which would make both parenthesis ,,:</p>

<p style="margin-top: 1em">parallel --parens ,,,, echo foo
is ,,s/I/O/g,, ::: FII</p>

<p style="margin-top: 1em">See also: --rpl {= perl
expression =}</p>

<p style="margin-top: 1em">--profile profilename <br>
-J profilename <br>
Use profile profilename for options. This is useful if you
want to have multiple profiles. You could have one profile
for running jobs in parallel on the local computer <br>
and a different profile for running jobs on remote
computers. See the section PROFILE FILES for examples.</p>

<p style="margin-top: 1em">profilename corresponds to the
file ~/.parallel/profilename.</p>

<p style="margin-top: 1em">You can give multiple profiles
by repeating --profile. If parts of the profiles conflict,
the later ones will be used.</p>

<p style="margin-top: 1em">Default: config</p>

<p style="margin-top: 1em">--quote <br>
-q Quote command. This will quote the command line so
special characters are not interpreted by the shell. See the
section QUOTING. Most people will never need this. <br>
Quoting is disabled by default.</p>

<p style="margin-top: 1em">--no-run-if-empty <br>
-r If the stdin (standard input) only contains whitespace,
do not run the command.</p>

<p style="margin-top: 1em">If used with --pipe this is
slow.</p>

<p style="margin-top: 1em">--noswap Do not start new jobs
on a given computer if there is both swap-in and swap-out
activity.</p>

<p style="margin-top: 1em">The swap activity is only
sampled every 10 seconds as the sampling takes 1 second to
do.</p>

<p style="margin-top: 1em">Swap activity is computed as
(swap-in)*(swap-out) which in practice is a good value:
swapping out is not a problem, swapping in is not a problem,
but both swapping in <br>
and out usually indicates a problem.</p>

<p style="margin-top: 1em">--memfree may give better
results, so try using that first.</p>

<p style="margin-top: 1em">--record-env <br>
Record current environment variables in
~/.parallel/ignored_vars. This is useful before using --env
_.</p>

<p style="margin-top: 1em">See also --env.</p>

<p style="margin-top: 1em">--recstart startstring <br>
--recend endstring <br>
If --recstart is given startstring will be used to split at
record start.</p>

<p style="margin-top: 1em">If --recend is given endstring
will be used to split at record end.</p>

<p style="margin-top: 1em">If both --recstart and --recend
are given the combined string endstringstartstring will have
to match to find a split position. This is useful if either
startstring or <br>
endstring match in the middle of a record.</p>

<p style="margin-top: 1em">If neither --recstart nor
--recend are given then --recend defaults to &rsquo;0. To
have no record separator use --recend &quot;&quot;.</p>

<p style="margin-top: 1em">--recstart and --recend are used
with --pipe.</p>

<p style="margin-top: 1em">Use --regexp to interpret
--recstart and --recend as regular expressions. This is
slow, however.</p>

<p style="margin-top: 1em">--regexp Use --regexp to
interpret --recstart and --recend as regular expressions.
This is slow, however.</p>

<p style="margin-top: 1em">--remove-rec-sep <br>
--removerecsep <br>
--rrs Remove the text matched by --recstart and --recend
before piping it to the command.</p>

<p style="margin-top: 1em">Only used with --pipe.</p>

<p style="margin-top: 1em">--results prefix <br>
--res prefix <br>
Save the output into files. The files will be stored in a
directory tree rooted at prefix. Within this directory tree,
each command will result in two files: <br>
prefix/&lt;ARGS&gt;/stdout and prefix/&lt;ARGS&gt;/stderr,
where &lt;ARGS&gt; is a sequence of directories representing
the header of the input source (if using --header :) or the
number <br>
of the input source and corresponding values.</p>

<p style="margin-top: 1em">prefix can contain replacement
strings.</p>

<p style="margin-top: 1em">E.g:</p>

<p style="margin-top: 1em">parallel --header : --results
foo echo {a} {b} ::: a I II ::: b III IIII</p>

<p style="margin-top: 1em">will generate the files:</p>

<p style="margin-top: 1em">foo/a/I/b/III/stderr <br>
foo/a/I/b/III/stdout <br>
foo/a/I/b/IIII/stderr <br>
foo/a/I/b/IIII/stdout <br>
foo/a/II/b/III/stderr <br>
foo/a/II/b/III/stdout <br>
foo/a/II/b/IIII/stderr <br>
foo/a/II/b/IIII/stdout</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">parallel --results foo echo {1}
{2} ::: I II ::: III IIII</p>

<p style="margin-top: 1em">will generate the files:</p>

<p style="margin-top: 1em">foo/1/I/2/III/stderr <br>
foo/1/I/2/III/stdout <br>
foo/1/I/2/IIII/stderr <br>
foo/1/I/2/IIII/stdout <br>
foo/1/II/2/III/stderr <br>
foo/1/II/2/III/stdout <br>
foo/1/II/2/IIII/stderr <br>
foo/1/II/2/IIII/stdout</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">parallel --results foo-{1} echo
{1} {2} ::: I II ::: III IIII</p>

<p style="margin-top: 1em">will generate the files:</p>

<p style="margin-top: 1em">foo-I/1/I/2/IIII/seq <br>
foo-I/1/I/2/IIII/stderr <br>
foo-I/1/I/2/IIII/stdout <br>
foo-I/1/I/2/III/seq <br>
foo-I/1/I/2/III/stderr <br>
foo-I/1/I/2/III/stdout <br>
foo-II/1/II/2/IIII/seq <br>
foo-II/1/II/2/IIII/stderr <br>
foo-II/1/II/2/IIII/stdout <br>
foo-II/1/II/2/III/seq <br>
foo-II/1/II/2/III/stderr <br>
foo-II/1/II/2/III/stdout</p>

<p style="margin-top: 1em">If you do not want the dir
structure, try --files --tag instead.</p>

<p style="margin-top: 1em">See also --files, --tag,
--header, --joblog.</p>

<p style="margin-top: 1em">--resume Resumes from the last
unfinished job. By reading --joblog or the --results dir GNU
parallel will figure out the last unfinished job and
continue from there. As GNU <br>
parallel only looks at the sequence numbers in --joblog then
the input, the command, and --joblog all have to remain
unchanged; otherwise GNU parallel may run wrong <br>
commands.</p>

<p style="margin-top: 1em">See also --joblog, --results,
--resume-failed, --retries.</p>

<p style="margin-top: 1em">--resume-failed <br>
Retry all failed and resume from the last unfinished job. By
reading --joblog GNU parallel will figure out the failed
jobs and run those again. After that it will resume <br>
last unfinished job and continue from there. As GNU parallel
only looks at the sequence numbers in --joblog then the
input, the command, and --joblog all have to remain <br>
unchanged; otherwise GNU parallel may run wrong
commands.</p>

<p style="margin-top: 1em">See also --joblog, --resume,
--retry-failed, --retries.</p>

<p style="margin-top: 1em">--retry-failed <br>
Retry all failed jobs in joblog. By reading --joblog GNU
parallel will figure out the failed jobs and run those
again.</p>

<p style="margin-top: 1em">--retry-failed ignores the
command and arguments on the command line: It only looks at
the joblog.</p>

<p style="margin-top: 1em">B&lt;Differences between
--resume, --resume-failed, --retry-failed&gt;</p>

<p style="margin-top: 1em">In this example exit {= $_%=2 =}
will cause every other job to fail.</p>

<p style="margin-top: 1em">timeout -k 1 4 parallel --joblog
log -j10 &rsquo;sleep {}; exit {= $_%=2 =}&rsquo; :::
{10..1}</p>

<p style="margin-top: 1em">4 jobs completed. 2 failed:</p>

<p style="margin-top: 1em">Seq [...] Exitval Signal Command
<br>
10 [...] 1 0 sleep 1; exit 1 <br>
9 [...] 0 0 sleep 2; exit 0 <br>
8 [...] 1 0 sleep 3; exit 1 <br>
7 [...] 0 0 sleep 4; exit 0</p>

<p style="margin-top: 1em">--resume does not care about the
Exitval, but only looks at Seq. If the Seq is run, it will
not be run again. So if needed, you can change the command
for the seqs not <br>
run yet:</p>

<p style="margin-top: 1em">parallel --resume --joblog log
-j10 &rsquo;sleep .{}; exit {= $_%=2 =}&rsquo; :::
{10..1}</p>

<p style="margin-top: 1em">Seq [...] Exitval Signal Command
<br>
[... as above ...] <br>
1 [...] 0 0 sleep .10; exit 0 <br>
6 [...] 1 0 sleep .5; exit 1 <br>
5 [...] 0 0 sleep .6; exit 0 <br>
4 [...] 1 0 sleep .7; exit 1 <br>
3 [...] 0 0 sleep .8; exit 0 <br>
2 [...] 1 0 sleep .9; exit 1</p>

<p style="margin-top: 1em">--resume-failed cares about the
Exitval, but also only looks at Seq to figure out which
commands to run. Again this means you can change the
command, but not the <br>
arguments. It will run the failed seqs and the seqs not yet
run:</p>

<p style="margin-top: 1em">parallel --resume-failed
--joblog log -j10 &rsquo;echo {};sleep .{}; exit {= $_%=3
=}&rsquo; ::: {10..1}</p>

<p style="margin-top: 1em">Seq [...] Exitval Signal Command
<br>
[... as above ...] <br>
10 [...] 1 0 echo 1;sleep .1; exit 1 <br>
8 [...] 0 0 echo 3;sleep .3; exit 0 <br>
6 [...] 2 0 echo 5;sleep .5; exit 2 <br>
4 [...] 1 0 echo 7;sleep .7; exit 1 <br>
2 [...] 0 0 echo 9;sleep .9; exit 0</p>

<p style="margin-top: 1em">--retry-failed cares about the
Exitval, but takes the command from the joblog. It ignores
any arguments or commands given on the command line:</p>

<p style="margin-top: 1em">parallel --retry-failed --joblog
log -j10 this part is ignored</p>

<p style="margin-top: 1em">Seq [...] Exitval Signal Command
<br>
[... as above ...] <br>
10 [...] 1 0 echo 1;sleep .1; exit 1 <br>
6 [...] 2 0 echo 5;sleep .5; exit 2 <br>
4 [...] 1 0 echo 7;sleep .7; exit 1</p>

<p style="margin-top: 1em">See also --joblog, --resume,
--resume-failed, --retries.</p>

<p style="margin-top: 1em">--retries n <br>
If a job fails, retry it on another computer on which it has
not failed. Do this n times. If there are fewer than n
computers in --sshlogin GNU parallel will re-use all <br>
the computers. This is useful if some jobs fail for no
apparent reason (such as network failure).</p>

<p style="margin-top: 1em">--return filename <br>
Transfer files from remote computers. --return is used with
--sshlogin when the arguments are files on the remote
computers. When processing is done the file filename <br>
will be transferred from the remote computer using rsync and
will be put relative to the default login dir. E.g.</p>

<p style="margin-top: 1em">echo foo/bar.txt | parallel
--return {.}.out --sshlogin server.example.com touch
{.}.out</p>

<p style="margin-top: 1em">This will transfer the file
$HOME/foo/bar.out from the computer server.example.com to
the file foo/bar.out after running touch foo/bar.out on
server.example.com.</p>

<p style="margin-top: 1em">parallel -S server --trc
out/./{}.out touch {}.out ::: in/file</p>

<p style="margin-top: 1em">This will transfer the file
in/file.out from the computer server.example.com to the
files out/in/file.out after running touch in/file.out on
server.</p>

<p style="margin-top: 1em">echo /tmp/foo/bar.txt | parallel
--return {.}.out --sshlogin server.example.com touch
{.}.out</p>

<p style="margin-top: 1em">This will transfer the file
/tmp/foo/bar.out from the computer server.example.com to the
file /tmp/foo/bar.out after running touch /tmp/foo/bar.out
on <br>
server.example.com.</p>

<p style="margin-top: 1em">Multiple files can be
transferred by repeating the option multiple times:</p>

<p style="margin-top: 1em">echo /tmp/foo/bar.txt | parallel
--sshlogin server.example.com --return {.}.out --return
{.}.out2 touch {.}.out {.}.out2</p>

<p style="margin-top: 1em">--return is often used with
--transferfile and --cleanup.</p>

<p style="margin-top: 1em">--return is ignored when used
with --sshlogin : or when not used with --sshlogin.</p>

<p style="margin-top: 1em">--round-robin <br>
--round Normally --pipe will give a single block to each
instance of the command. With --round-robin all blocks will
at random be written to commands already running. This is
<br>
useful if the command takes a long time to initialize.</p>

<p style="margin-top: 1em">--keep-order will not work with
--round-robin as it is impossible to track which input block
corresponds to which output.</p>

<p style="margin-top: 1em">--round-robin implies --pipe,
except if --pipepart is given.</p>

<p style="margin-top: 1em">--rpl &rsquo;tag perl
expression&rsquo; <br>
Use tag as a replacement string for perl expression. This
makes it possible to define your own replacement strings.
GNU parallel&rsquo;s 7 replacement strings are implemented
<br>
as:</p>

<p style="margin-top: 1em">--rpl &rsquo;{} &rsquo; <br>
--rpl &rsquo;{#} 1 $_=$job-&gt;seq()&rsquo; <br>
--rpl &rsquo;{%} 1 $_=$job-&gt;slot()&rsquo; <br>
--rpl &rsquo;{/} s:.*/::&rsquo; <br>
--rpl &rsquo;{//} $Global::use{&quot;File::Basename&quot;}
||= eval &quot;use File::Basename; 1;&quot;; $_ =
dirname($_);&rsquo; <br>
--rpl &rsquo;{/.} s:.*/::; s:.[^/.]+$::;&rsquo; <br>
--rpl &rsquo;{.} s:.[^/.]+$::&rsquo;</p>

<p style="margin-top: 1em">The --plus replacement strings
are implemented as:</p>

<p style="margin-top: 1em">--rpl &rsquo;{+/}
s:/[^/]*$::&rsquo; <br>
--rpl &rsquo;{+.} s:.*.::&rsquo; <br>
--rpl &rsquo;{+..} s:.*.([^.]*.):$1:&rsquo; <br>
--rpl &rsquo;{+...} s:.*.([^.]*.[^.]*.):$1:&rsquo; <br>
--rpl &rsquo;{..} s:.[^/.]+$::; s:.[^/.]+$::&rsquo; <br>
--rpl &rsquo;{...} s:.[^/.]+$::; s:.[^/.]+$::;
s:.[^/.]+$::&rsquo; <br>
--rpl &rsquo;{/..} s:.*/::; s:.[^/.]+$::;
s:.[^/.]+$::&rsquo; <br>
--rpl &rsquo;{/...} s:.*/::; s:.[^/.]+$::; s:.[^/.]+$::;
s:.[^/.]+$::&rsquo; <br>
--rpl &rsquo;{##} $_=total_jobs()&rsquo;</p>

<p style="margin-top: 1em">If the user defined replacement
string starts with &rsquo;{&rsquo; it can also be used as a
positional replacement string (like {2.}).</p>

<p style="margin-top: 1em">It is recommended to only change
$_ but you have full access to all of GNU parallel&rsquo;s
internal functions and data structures.</p>

<p style="margin-top: 1em">Here are a few examples:</p>

<p style="margin-top: 1em">Is the job sequence even or odd?
<br>
--rpl &rsquo;{odd} $_ = $job-&gt;seq() % 2 ? &quot;odd&quot;
: &quot;even&quot;&rsquo; <br>
Pad job sequence with leading zeros to get equal width <br>
--rpl &rsquo;{0#} $f =
&quot;%0&quot;.int(1+log(total_jobs())/log(10)).&quot;d&quot;;
$_=sprintf($f,$job-&gt;seq())&rsquo; <br>
Job sequence counting from 0 <br>
--rpl &rsquo;{#0} $_ = $job-&gt;seq() - 1&rsquo; <br>
Job slot counting from 2 <br>
--rpl &rsquo;{%1} $_ = $job-&gt;slot() + 1&rsquo;</p>

<p style="margin-top: 1em">See also: {= perl expression =}
--parens</p>

<p style="margin-top: 1em">--max-chars=max-chars <br>
-s max-chars <br>
Use at most max-chars characters per command line, including
the command and initial-arguments and the terminating nulls
at the ends of the argument strings. The <br>
largest allowed value is system-dependent, and is calculated
as the argument length limit for exec, less the size of your
environment. The default value is the maximum.</p>

<p style="margin-top: 1em">Implies -X unless -m is set.</p>

<p style="margin-top: 1em">--show-limits <br>
Display the limits on the command-line length which are
imposed by the operating system and the -s option. Pipe the
input from /dev/null (and perhaps specify <br>
--no-run-if-empty) if you don&rsquo;t want GNU parallel to
do anything.</p>

<p style="margin-top: 1em">--semaphore <br>
Work as a counting semaphore. --semaphore will cause GNU
parallel to start command in the background. When the number
of jobs given by --jobs is reached, GNU parallel <br>
will wait for one of these to complete before starting
another command.</p>

<p style="margin-top: 1em">--semaphore implies --bg unless
--fg is specified.</p>

<p style="margin-top: 1em">--semaphore implies
--semaphorename &lsquo;tty&lsquo; unless --semaphorename is
specified.</p>

<p style="margin-top: 1em">Used with --fg, --wait, and
--semaphorename.</p>

<p style="margin-top: 1em">The command sem is an alias for
parallel --semaphore.</p>

<p style="margin-top: 1em">See also man sem.</p>

<p style="margin-top: 1em">--semaphorename name <br>
--id name <br>
Use name as the name of the semaphore. Default is the name
of the controlling tty (output from tty).</p>

<p style="margin-top: 1em">The default normally works as
expected when used interactively, but when used in a script
name should be set. $$ or my_task_name are often a good
value.</p>

<p style="margin-top: 1em">The semaphore is stored in
~/.parallel/semaphores/</p>

<p style="margin-top: 1em">Implies --semaphore.</p>

<p style="margin-top: 1em">See also man sem.</p>

<p style="margin-top: 1em">--semaphoretimeout secs <br>
--st secs <br>
If secs &gt; 0: If the semaphore is not released within secs
seconds, take it anyway.</p>

<p style="margin-top: 1em">If secs &lt; 0: If the semaphore
is not released within secs seconds, exit.</p>

<p style="margin-top: 1em">Implies --semaphore.</p>

<p style="margin-top: 1em">See also man sem.</p>

<p style="margin-top: 1em">--seqreplace replace-str <br>
Use the replacement string replace-str instead of {#} for
job sequence number.</p>

<p style="margin-top: 1em">--shebang <br>
--hashbang <br>
GNU parallel can be called as a shebang (#!) command as the
first line of a script. The content of the file will be
treated as inputsource.</p>

<p style="margin-top: 1em">Like this:</p>

<p style="margin-top: 1em">#!/usr/bin/parallel --shebang -r
traceroute</p>

<p style="margin-top: 1em">qubes-os.org <br>
debian.org <br>
freenetproject.org</p>

<p style="margin-top: 1em">--shebang must be set as the
first option.</p>

<p style="margin-top: 1em">On FreeBSD env is needed:</p>

<p style="margin-top: 1em">#!/usr/bin/env -S parallel
--shebang -r traceroute</p>

<p style="margin-top: 1em">qubes-os.org <br>
debian.org <br>
freenetproject.org</p>

<p style="margin-top: 1em">There are many limitations of
shebang (#!) depending on your operating system. See details
on http://www.in-ulm.de/~mascheck/various/shebang/</p>

<p style="margin-top: 1em">--shebang-wrap <br>
GNU parallel can parallelize scripts by wrapping the shebang
line. If the program can be run like this:</p>

<p style="margin-top: 1em">cat arguments | parallel
the_program</p>

<p style="margin-top: 1em">then the script can be changed
to:</p>

<p style="margin-top: 1em">#!/usr/bin/parallel
--shebang-wrap /the/original/parser --with-options</p>

<p style="margin-top: 1em">E.g.</p>

<p style="margin-top: 1em">#!/usr/bin/parallel
--shebang-wrap /usr/bin/python</p>

<p style="margin-top: 1em">If the program can be run like
this:</p>

<p style="margin-top: 1em">cat data | parallel --pipe
the_program</p>

<p style="margin-top: 1em">then the script can be changed
to:</p>

<p style="margin-top: 1em">#!/usr/bin/parallel
--shebang-wrap --pipe /the/original/parser
--with-options</p>

<p style="margin-top: 1em">E.g.</p>

<p style="margin-top: 1em">#!/usr/bin/parallel
--shebang-wrap --pipe /usr/bin/perl -w</p>

<p style="margin-top: 1em">--shebang-wrap must be set as
the first option.</p>

<p style="margin-top: 1em">--shellquote <br>
Does not run the command but quotes it. Useful for making
quoted composed commands for GNU parallel.</p>

<p style="margin-top: 1em">--shuf Shuffle jobs. When having
multiple input sources it is hard to randomize jobs. --shuf
will generate all jobs, and shuffle them before running
them. This is useful to get <br>
a quick preview of the results before running the full
batch.</p>

<p style="margin-top: 1em">--skip-first-line <br>
Do not use the first line of input (used by GNU parallel
itself when called with --shebang).</p>

<p style="margin-top: 1em">--sql DBURL (obsolete) <br>
Use --sqlmaster instead.</p>

<p style="margin-top: 1em">--sqlmaster DBURL <br>
Submit jobs via SQL server. DBURL must point to a table,
which will contain the same information as --joblog, the
values from the input sources (stored in columns V1 .. <br>
Vn), and the output (stored in columns Stdout and
Stderr).</p>

<p style="margin-top: 1em">The table will be dropped and
created with the correct amount of V-columns.</p>

<p style="margin-top: 1em">--sqlmaster does not run any
jobs, but it creates the values for the jobs to be run and
wait for them to complete. One or more --sqlworker must be
run to actually <br>
execute the jobs.</p>

<p style="margin-top: 1em">The format of a DBURL is:</p>


<p style="margin-top: 1em">[sql:]vendor://[[user][:password]@][host][:port]/[database]/table</p>

<p style="margin-top: 1em">E.g.</p>


<p style="margin-top: 1em">sql:mysql://hr:hr@localhost:3306/hrdb/jobs
<br>
mysql://scott:tiger@my.example.com/pardb/paralleljobs <br>
sql:oracle://scott:tiger@ora.example.com/xe/parjob <br>
postgresql://scott:tiger@pg.example.com/pgdb/parjob <br>
pg:///parjob <br>
sqlite3:///pardb/parjob</p>

<p style="margin-top: 1em">It can also be an alias from
~/.sql/aliases:</p>

<p style="margin-top: 1em">:myalias
mysql:///mydb/paralleljobs</p>

<p style="margin-top: 1em">--sqlandworker DBURL <br>
Shorthand for: --sqlmaster DBURL --sqlworker DBURL.</p>

<p style="margin-top: 1em">--sqlworker DBURL <br>
Execute jobs via SQL server. Read the input sources
variables from the table pointed to by DBURL. The command on
the command line should be the same as given by <br>
--sqlmaster.</p>

<p style="margin-top: 1em">--ssh sshcommand <br>
GNU parallel defaults to using ssh for remote access. This
can be overridden with --ssh. It can also be set on a per
server basis (see --sshlogin).</p>

<p style="margin-top: 1em">--sshdelay secs <br>
Delay starting next ssh by secs seconds. GNU parallel will
pause secs seconds after starting each ssh. secs can be less
than 1 seconds.</p>

<p style="margin-top: 1em">-S
[@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]]
<br>
-S @hostgroup <br>
--sshlogin
[@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]]
<br>
--sshlogin @hostgroup <br>
Distribute jobs to remote computers. The jobs will be run on
a list of remote computers.</p>

<p style="margin-top: 1em">If hostgroups is given, the
sshlogin will be added to that hostgroup. Multiple
hostgroups are separated by &rsquo;+&rsquo;. The sshlogin
will always be added to a hostgroup named <br>
the same as sshlogin.</p>

<p style="margin-top: 1em">If only the @hostgroup is given,
only the sshlogins in that hostgroup will be used. Multiple
@hostgroup can be given.</p>

<p style="margin-top: 1em">GNU parallel will determine the
number of CPU cores on the remote computers and run the
number of jobs as specified by -j. If the number ncpu is
given GNU parallel will <br>
use this number for number of CPU cores on the host.
Normally ncpu will not be needed.</p>

<p style="margin-top: 1em">An sshlogin is of the form:</p>

<p style="margin-top: 1em">[sshcommand [options]]
[username@]hostname</p>

<p style="margin-top: 1em">The sshlogin must not require a
password (ssh-agent, ssh-copy-id, and sshpass may help with
that).</p>

<p style="margin-top: 1em">The sshlogin &rsquo;:&rsquo; is
special, it means &rsquo;no ssh&rsquo; and will therefore
run on the local computer.</p>

<p style="margin-top: 1em">The sshlogin &rsquo;..&rsquo; is
special, it read sshlogins from ~/.parallel/sshloginfile</p>

<p style="margin-top: 1em">The sshlogin &rsquo;-&rsquo; is
special, too, it read sshlogins from stdin (standard
input).</p>

<p style="margin-top: 1em">To specify more sshlogins
separate the sshlogins by comma, newline (in the same
string), or repeat the options multiple times.</p>

<p style="margin-top: 1em">For examples: see
--sshloginfile.</p>

<p style="margin-top: 1em">The remote host must have GNU
parallel installed.</p>

<p style="margin-top: 1em">--sshlogin is known to cause
problems with -m and -X.</p>

<p style="margin-top: 1em">--sshlogin is often used with
--transferfile, --return, --cleanup, and --trc.</p>

<p style="margin-top: 1em">--sshloginfile filename <br>
--slf filename <br>
File with sshlogins. The file consists of sshlogins on
separate lines. Empty lines and lines starting with
&rsquo;#&rsquo; are ignored. Example:</p>

<p style="margin-top: 1em">server.example.com <br>
username@server2.example.com <br>
8/my-8-core-server.example.com <br>
2/my_other_username@my-dualcore.example.net <br>
# This server has SSH running on port 2222 <br>
ssh -p 2222 server.example.net <br>
4/ssh -p 2222 quadserver.example.net <br>
# Use a different ssh program <br>
myssh -p 2222 -l myusername hexacpu.example.net <br>
# Use a different ssh program with default number of cores
<br>
//usr/local/bin/myssh -p 2222 -l myusername hexacpu <br>
# Use a different ssh program with 6 cores <br>
6//usr/local/bin/myssh -p 2222 -l myusername hexacpu <br>
# Assume 16 cores on the local computer <br>
16/: <br>
# Put server1 in hostgroup1 <br>
@hostgroup1/server1 <br>
# Put myusername@server2 in hostgroup1+hostgroup2 <br>
@hostgroup1+hostgroup2/myusername@server2 <br>
# Force 4 cores and put &rsquo;ssh -p 2222 server3&rsquo; in
hostgroup1 <br>
@hostgroup1/4/ssh -p 2222 server3</p>

<p style="margin-top: 1em">When using a different ssh
program the last argument must be the hostname.</p>

<p style="margin-top: 1em">Multiple --sshloginfile are
allowed.</p>

<p style="margin-top: 1em">GNU parallel will first look for
the file in current dir; if that fails it look for the file
in ~/.parallel.</p>

<p style="margin-top: 1em">The sshloginfile
&rsquo;..&rsquo; is special, it read sshlogins from
~/.parallel/sshloginfile</p>

<p style="margin-top: 1em">The sshloginfile &rsquo;.&rsquo;
is special, it read sshlogins from
/etc/parallel/sshloginfile</p>

<p style="margin-top: 1em">The sshloginfile &rsquo;-&rsquo;
is special, too, it read sshlogins from stdin (standard
input).</p>

<p style="margin-top: 1em">If the sshloginfile is changed
it will be re-read when a job finishes though at most once
per second. This makes it possible to add and remove hosts
while running.</p>

<p style="margin-top: 1em">This can be used to have a
daemon that updates the sshloginfile to only contain servers
that are up:</p>

<p style="margin-top: 1em">cp original.slf tmp2.slf <br>
while [ 1 ] ; do <br>
nice parallel --nonall -j0 -k --slf original.slf --tag echo
| perl &rsquo;s/$//&rsquo; &gt; tmp.slf <br>
if diff tmp.slf tmp2.slf; then <br>
mv tmp.slf tmp2.slf <br>
fi <br>
sleep 10 <br>
done &amp; <br>
parallel --slf tmp2.slf ...</p>

<p style="margin-top: 1em">--slotreplace replace-str <br>
Use the replacement string replace-str instead of {%} for
job slot number.</p>

<p style="margin-top: 1em">--silent Silent. The job to be
run will not be printed. This is the default. Can be
reversed with -v.</p>

<p style="margin-top: 1em">--tty Open terminal tty. If GNU
parallel is used for starting an interactive program then
this option may be needed. It will start only one job at a
time (i.e. -j1), not <br>
buffer the output (i.e. -u), and it will open a tty for the
job. When the job is done, the next job will get the
tty.</p>

<p style="margin-top: 1em">You can of course override -j1
and -u.</p>

<p style="margin-top: 1em">--tag Tag lines with arguments.
Each output line will be prepended with the arguments and
TAB (). When combined with --onall or --nonall the lines
will be prepended with the <br>
sshlogin instead.</p>

<p style="margin-top: 1em">--tag is ignored when using
-u.</p>

<p style="margin-top: 1em">--tagstring str <br>
Tag lines with a string. Each output line will be prepended
with str and TAB (). str can contain replacement strings
such as {}.</p>

<p style="margin-top: 1em">--tagstring is ignored when
using -u, --onall, and --nonall.</p>

<p style="margin-top: 1em">--termseq sequence <br>
Termination sequence. When a job is killed due to --timeout,
--memfree, --halt, or abnormal termination of GNU parallel,
sequence determines how the job is killed. The <br>
default is:</p>


<p style="margin-top: 1em">TERM,200,TERM,100,TERM,50,KILL,25</p>

<p style="margin-top: 1em">which sends a TERM signal, waits
200 ms, sends another TERM signal, waits 100 ms, sends
another TERM signal, waits 50 ms, sends a KILL signal, waits
25 ms, and exits. <br>
GNU parallel discovers if a process dies before the waiting
time is up.</p>

<p style="margin-top: 1em">--tmpdir dirname <br>
Directory for temporary files. GNU parallel normally buffers
output into temporary files in /tmp. By setting --tmpdir you
can use a different dir for the files. Setting <br>
--tmpdir is equivalent to setting $TMPDIR.</p>

<p style="margin-top: 1em">--tmux Use tmux for output.
Start a tmux session and run each job in a window in that
session. No other output will be produced.</p>

<p style="margin-top: 1em">--timeout secs <br>
Time out for command. If the command runs for longer than
secs seconds it will get killed with SIGTERM, followed by
SIGTERM 200 ms later, followed by SIGKILL 200 ms <br>
later.</p>

<p style="margin-top: 1em">If secs is followed by a % then
the timeout will dynamically be computed as a percentage of
the median average runtime. Only values &gt; 100% will make
sense.</p>

<p style="margin-top: 1em">--verbose <br>
-t Print the job to be run on stderr (standard error).</p>

<p style="margin-top: 1em">See also -v, -p.</p>

<p style="margin-top: 1em">--transfer <br>
Transfer files to remote computers. Shorthand for:
--transferfile {}.</p>

<p style="margin-top: 1em">--transferfile filename <br>
--tf filename <br>
--transferfile is used with --sshlogin to transfer files to
the remote computers. The files will be transferred using
rsync and will be put relative to the default work <br>
dir. If the path contains /./ the remaining path will be
relative to the work dir. E.g.</p>

<p style="margin-top: 1em">echo foo/bar.txt | parallel
--sshlogin server.example.com --transferfile {} wc</p>

<p style="margin-top: 1em">This will transfer the file
foo/bar.txt to the computer server.example.com to the file
$HOME/foo/bar.txt before running wc foo/bar.txt on
server.example.com.</p>

<p style="margin-top: 1em">echo /tmp/foo/bar.txt | parallel
--sshlogin server.example.com --transferfile {} wc</p>

<p style="margin-top: 1em">This will transfer the file
/tmp/foo/bar.txt to the computer server.example.com to the
file /tmp/foo/bar.txt before running wc /tmp/foo/bar.txt on
server.example.com.</p>

<p style="margin-top: 1em">echo /tmp/./foo/bar.txt |
parallel --sshlogin server.example.com --transferfile {} wc
{= s:.*/./:./: =}</p>

<p style="margin-top: 1em">This will transfer the file
/tmp/foo/bar.txt to the computer server.example.com to the
file foo/bar.txt before running wc ./foo/bar.txt on
server.example.com.</p>

<p style="margin-top: 1em">--transferfile is often used
with --return and --cleanup. A shorthand for --transferfile
{} is --transfer.</p>

<p style="margin-top: 1em">--transferfile is ignored when
used with --sshlogin : or when not used with --sshlogin.</p>

<p style="margin-top: 1em">--trc filename <br>
Transfer, Return, Cleanup. Shorthand for:</p>

<p style="margin-top: 1em">--transferfile {} --return
filename --cleanup</p>

<p style="margin-top: 1em">--trim &lt;n|l|r|lr|rl&gt; <br>
Trim white space in input.</p>

<p style="margin-top: 1em">n No trim. Input is not
modified. This is the default.</p>

<p style="margin-top: 1em">l Left trim. Remove white space
from start of input. E.g. &quot; a bc &quot; -&gt; &quot;a
bc &quot;.</p>

<p style="margin-top: 1em">r Right trim. Remove white space
from end of input. E.g. &quot; a bc &quot; -&gt; &quot; a
bc&quot;.</p>

<p style="margin-top: 1em">lr <br>
rl Both trim. Remove white space from both start and end of
input. E.g. &quot; a bc &quot; -&gt; &quot;a bc&quot;. This
is the default if --colsep is used.</p>

<p style="margin-top: 1em">--ungroup <br>
-u Ungroup output. Output is printed as soon as possible and
by passes GNU parallel internal processing. This may cause
output from different commands to be mixed thus <br>
should only be used if you do not care about the output.
Compare these:</p>

<p style="margin-top: 1em">seq 4 | parallel -j0
&rsquo;sleep {};echo -n start{};sleep {};echo {}end&rsquo;
<br>
seq 4 | parallel -u -j0 &rsquo;sleep {};echo -n
start{};sleep {};echo {}end&rsquo;</p>

<p style="margin-top: 1em">It also disables --tag. GNU
parallel outputs faster with -u. Compare the speed of
these:</p>

<p style="margin-top: 1em">parallel seq ::: 300000000
&gt;/dev/null <br>
parallel -u seq ::: 300000000 &gt;/dev/null <br>
parallel --line-buffer seq ::: 300000000 &gt;/dev/null</p>

<p style="margin-top: 1em">Can be reversed with
--group.</p>

<p style="margin-top: 1em">See also: --line-buffer
--group</p>

<p style="margin-top: 1em">--extensionreplace replace-str
<br>
--er replace-str <br>
Use the replacement string replace-str instead of {.} for
input line without extension.</p>

<p style="margin-top: 1em">--use-cpus-instead-of-cores <br>
Count the number of physical CPUs instead of CPU cores. When
computing how many jobs to run simultaneously relative to
the number of CPU cores you can ask GNU parallel <br>
to instead look at the number of physical CPUs. This will
make sense for computers that have hyperthreading as two
jobs running on one CPU with hyperthreading will run <br>
slower than two jobs running on two physical CPUs. Some
multi-core CPUs can run faster if only one thread is running
per physical CPU. Most users will not need this <br>
option.</p>

<p style="margin-top: 1em">-v Verbose. Print the job to be
run on stdout (standard output). Can be reversed with
--silent. See also -t.</p>

<p style="margin-top: 1em">Use -v -v to print the wrapping
ssh command when running remotely.</p>

<p style="margin-top: 1em">--version <br>
-V Print the version GNU parallel and exit.</p>

<p style="margin-top: 1em">--workdir mydir <br>
--wd mydir <br>
Files transferred using --transferfile and --return will be
relative to mydir on remote computers, and the command will
be executed in the dir mydir.</p>

<p style="margin-top: 1em">The special mydir value ... will
create working dirs under ~/.parallel/tmp/ on the remote
computers. If --cleanup is given these dirs will be
removed.</p>

<p style="margin-top: 1em">The special mydir value . uses
the current working dir. If the current working dir is
beneath your home dir, the value . is treated as the
relative path to your home <br>
dir. This means that if your home dir is different on remote
computers (e.g. if your login is different) the relative
path will still be relative to your home dir.</p>

<p style="margin-top: 1em">To see the difference try:</p>

<p style="margin-top: 1em">parallel -S server pwd :::
&quot;&quot; <br>
parallel --wd . -S server pwd ::: &quot;&quot; <br>
parallel --wd ... -S server pwd ::: &quot;&quot;</p>

<p style="margin-top: 1em">mydir can contain GNU
parallel&rsquo;s replacement strings.</p>

<p style="margin-top: 1em">--wait Wait for all commands to
complete.</p>

<p style="margin-top: 1em">Implies --semaphore.</p>

<p style="margin-top: 1em">See also man sem.</p>

<p style="margin-top: 1em">-X Multiple arguments with
context replace. Insert as many arguments as the command
line length permits. If multiple jobs are being run in
parallel: distribute the <br>
arguments evenly among the jobs. Use -j1 to avoid this.</p>

<p style="margin-top: 1em">If {} is not used the arguments
will be appended to the line. If {} is used as part of a
word (like pic{}.jpg) then the whole word will be repeated.
If {} is used <br>
multiple times each {} will be replaced with the
arguments.</p>

<p style="margin-top: 1em">Normally -X will do the right
thing, whereas -m can give unexpected results if {} is used
as part of a word.</p>

<p style="margin-top: 1em">Support for -X with --sshlogin
is limited and may fail.</p>

<p style="margin-top: 1em">See also -m.</p>

<p style="margin-top: 1em">--exit <br>
-x Exit if the size (see the -s option) is exceeded.</p>

<p style="margin-top: 1em">--xapply Read multiple input
sources like xapply. If multiple input sources are given,
one argument will be read from each of the input sources.
The arguments can be accessed in <br>
the command as {1} .. {n}, so {1} will be a line from the
first input source, and {6} will refer to the line with the
same line number from the 6th input source.</p>

<p style="margin-top: 1em">Compare these two:</p>

<p style="margin-top: 1em">parallel echo {1} {2} ::: 1 2 3
::: a b c <br>
parallel --xapply echo {1} {2} ::: 1 2 3 ::: a b c</p>

<p style="margin-top: 1em">Arguments will be recycled if
one input source has more arguments than the others:</p>

<p style="margin-top: 1em">parallel --xapply echo {1} {2}
{3} ::: 1 2 ::: I II III ::: a b c d e f g</p>

<p style="margin-top: 1em">See also --header.</p>

<p style="margin-top: 1em">EXAMPLE: Working as xargs -n1.
Argument appending <br>
GNU parallel can work similar to xargs -n1.</p>

<p style="margin-top: 1em">To compress all html files using
gzip run:</p>

<p style="margin-top: 1em">find . -name
&rsquo;*.html&rsquo; | parallel gzip --best</p>

<p style="margin-top: 1em">If the file names may contain a
newline use -0. Substitute FOO BAR with FUBAR in all files
in this dir and subdirs:</p>

<p style="margin-top: 1em">find . -type f -print0 |
parallel -q0 perl -i -pe &rsquo;s/FOO BAR/FUBAR/g&rsquo;</p>

<p style="margin-top: 1em">Note -q is needed because of the
space in &rsquo;FOO BAR&rsquo;.</p>

<p style="margin-top: 1em">EXAMPLE: Reading arguments from
command line <br>
GNU parallel can take the arguments from command line
instead of stdin (standard input). To compress all html
files in the current dir using gzip run:</p>

<p style="margin-top: 1em">parallel gzip --best :::
*.html</p>

<p style="margin-top: 1em">To convert *.wav to *.mp3 using
LAME running one process per CPU core run:</p>

<p style="margin-top: 1em">parallel lame {} -o {.}.mp3 :::
*.wav</p>

<p style="margin-top: 1em">EXAMPLE: Inserting multiple
arguments <br>
When moving a lot of files like this: mv *.log destdir you
will sometimes get the error:</p>

<p style="margin-top: 1em">bash: /bin/mv: Argument list too
long</p>

<p style="margin-top: 1em">because there are too many
files. You can instead do:</p>

<p style="margin-top: 1em">ls | grep -E &rsquo;.log$&rsquo;
| parallel mv {} destdir</p>

<p style="margin-top: 1em">This will run mv for each file.
It can be done faster if mv gets as many arguments that will
fit on the line:</p>

<p style="margin-top: 1em">ls | grep -E &rsquo;.log$&rsquo;
| parallel -m mv {} destdir</p>

<p style="margin-top: 1em">EXAMPLE: Context replace <br>
To remove the files pict0000.jpg .. pict9999.jpg you could
do:</p>

<p style="margin-top: 1em">seq -w 0 9999 | parallel rm
pict{}.jpg</p>

<p style="margin-top: 1em">You could also do:</p>

<p style="margin-top: 1em">seq -w 0 9999 | perl -pe
&rsquo;s/(.*)/pict$1.jpg/&rsquo; | parallel -m rm</p>

<p style="margin-top: 1em">The first will run rm 10000
times, while the last will only run rm as many times needed
to keep the command line length short enough to avoid
Argument list too long (it typically <br>
runs 1-2 times).</p>

<p style="margin-top: 1em">You could also run:</p>

<p style="margin-top: 1em">seq -w 0 9999 | parallel -X rm
pict{}.jpg</p>

<p style="margin-top: 1em">This will also only run rm as
many times needed to keep the command line length short
enough.</p>

<p style="margin-top: 1em">EXAMPLE: Compute intensive jobs
and substitution <br>
If ImageMagick is installed this will generate a thumbnail
of a jpg file:</p>

<p style="margin-top: 1em">convert -geometry 120 foo.jpg
thumb_foo.jpg</p>

<p style="margin-top: 1em">This will run with
number-of-cpu-cores jobs in parallel for all jpg files in a
directory:</p>

<p style="margin-top: 1em">ls *.jpg | parallel convert
-geometry 120 {} thumb_{}</p>

<p style="margin-top: 1em">To do it recursively use
find:</p>

<p style="margin-top: 1em">find . -name &rsquo;*.jpg&rsquo;
| parallel convert -geometry 120 {} {}_thumb.jpg</p>

<p style="margin-top: 1em">Notice how the argument has to
start with {} as {} will include path (e.g. running convert
-geometry 120 ./foo/bar.jpg thumb_./foo/bar.jpg would
clearly be wrong). The command <br>
will generate files like ./foo/bar.jpg_thumb.jpg.</p>

<p style="margin-top: 1em">Use {.} to avoid the extra .jpg
in the file name. This command will make files like
./foo/bar_thumb.jpg:</p>

<p style="margin-top: 1em">find . -name &rsquo;*.jpg&rsquo;
| parallel convert -geometry 120 {} {.}_thumb.jpg</p>

<p style="margin-top: 1em">EXAMPLE: Substitution and
redirection <br>
This will generate an uncompressed version of .gz-files next
to the .gz-file:</p>

<p style="margin-top: 1em">parallel zcat {}
&quot;&gt;&quot;{.} ::: *.gz</p>

<p style="margin-top: 1em">Quoting of &gt; is necessary to
postpone the redirection. Another solution is to quote the
whole command:</p>

<p style="margin-top: 1em">parallel &quot;zcat {}
&gt;{.}&quot; ::: *.gz</p>

<p style="margin-top: 1em">Other special shell characters
(such as * ; $ &gt; &lt; | &gt;&gt; &lt;&lt;) also need to
be put in quotes, as they may otherwise be interpreted by
the shell and not given to GNU parallel.</p>

<p style="margin-top: 1em">EXAMPLE: Composed commands <br>
A job can consist of several commands. This will print the
number of files in each directory:</p>

<p style="margin-top: 1em">ls | parallel &rsquo;echo -n
{}&quot; &quot;; ls {}|wc -l&rsquo;</p>

<p style="margin-top: 1em">To put the output in a file
called &lt;name&gt;.dir:</p>

<p style="margin-top: 1em">ls | parallel &rsquo;(echo -n
{}&quot; &quot;; ls {}|wc -l) &gt;{}.dir&rsquo;</p>

<p style="margin-top: 1em">Even small shell scripts can be
run by GNU parallel:</p>

<p style="margin-top: 1em">find . | parallel &rsquo;a={};
name=${a##*/};&rsquo; &rsquo;upper=$(echo &quot;$name&quot;
| tr &quot;[:lower:]&quot; &quot;[:upper:]&quot;);&rsquo;
&rsquo;echo &quot;$name - $upper&quot;&rsquo;</p>

<p style="margin-top: 1em">ls | parallel &rsquo;mv {}
&quot;$(echo {} | tr &quot;[:upper:]&quot;
&quot;[:lower:]&quot;)&quot;&rsquo;</p>

<p style="margin-top: 1em">Given a list of URLs, list all
URLs that fail to download. Print the line number and the
URL.</p>

<p style="margin-top: 1em">cat urlfile | parallel
&quot;wget {} 2&gt;/dev/null || grep -n {} urlfile&quot;</p>

<p style="margin-top: 1em">Create a mirror directory with
the same filenames except all files and symlinks are empty
files.</p>

<p style="margin-top: 1em">cp -rs /the/source/dir
mirror_dir <br>
find mirror_dir -type l | parallel -m rm {}
&rsquo;&amp;&amp;&rsquo; touch {}</p>

<p style="margin-top: 1em">Find the files in a list that do
not exist</p>

<p style="margin-top: 1em">cat file_list | parallel
&rsquo;if [ ! -e {} ] ; then echo {}; fi&rsquo;</p>

<p style="margin-top: 1em">EXAMPLE: Composed command with
multiple input sources <br>
You have a dir with files named as 24 hours in 5 minute
intervals: 00:00, 00:05, 00:10 .. 23:55. You want to find
the files missing:</p>

<p style="margin-top: 1em">parallel [ -f {1}:{2} ]
&quot;||&quot; echo {1}:{2} does not exist ::: {00..23} :::
{00..55..5}</p>

<p style="margin-top: 1em">EXAMPLE: Calling Bash functions
<br>
If the composed command is longer than a line, it becomes
hard to read. In Bash you can use functions. Just remember
to export -f the function.</p>

<p style="margin-top: 1em">doit() { <br>
echo Doing it for $1 <br>
sleep 2 <br>
echo Done with $1 <br>
} <br>
export -f doit <br>
parallel doit ::: 1 2 3</p>

<p style="margin-top: 1em">doubleit() { <br>
echo Doing it for $1 $2 <br>
sleep 2 <br>
echo Done with $1 $2 <br>
} <br>
export -f doubleit <br>
parallel doubleit ::: 1 2 3 ::: a b</p>

<p style="margin-top: 1em">To do this on remote servers you
need to transfer the function using --env:</p>

<p style="margin-top: 1em">parallel --env doit -S server
doit ::: 1 2 3 <br>
parallel --env doubleit -S server doubleit ::: 1 2 3 ::: a
b</p>

<p style="margin-top: 1em">If your environment (aliases,
variables, and functions) is small you can copy the full
environment without having to export -f anything. See
env_parallel earlier in the man page.</p>

<p style="margin-top: 1em">EXAMPLE: Function tester <br>
To test a program with different parameters:</p>

<p style="margin-top: 1em">tester() { <br>
if (eval &quot;$@&quot;) &gt;&amp;/dev/null; then <br>
perl -e &rsquo;printf &quot; 33[30;102m[ OK ] 33[0m
@ARGV0&rsquo; &quot;$@&quot; <br>
else <br>
perl -e &rsquo;printf &quot; 33[30;101m[FAIL] 33[0m
@ARGV0&rsquo; &quot;$@&quot; <br>
fi <br>
} <br>
export -f tester <br>
parallel tester my_program ::: arg1 arg2 <br>
parallel tester exit ::: 1 0 2 0</p>

<p style="margin-top: 1em">If my_program fails a red FAIL
will be printed followed by the failing command; otherwise a
green OK will be printed followed by the command.</p>

<p style="margin-top: 1em">EXAMPLE: Log rotate <br>
Log rotation renames a logfile to an extension with a higher
number: log.1 becomes log.2, log.2 becomes log.3, and so on.
The oldest log is removed. To avoid overwriting files <br>
the process starts backwards from the high number to the low
number. This will keep 10 old versions of the log:</p>

<p style="margin-top: 1em">seq 9 -1 1 | parallel -j1 mv
log.{} log.&rsquo;{= $_++ =}&rsquo; <br>
mv log log.1</p>

<p style="margin-top: 1em">EXAMPLE: Removing file extension
when processing files <br>
When processing files removing the file extension using {.}
is often useful.</p>

<p style="margin-top: 1em">Create a directory for each
zip-file and unzip it in that dir:</p>

<p style="margin-top: 1em">parallel &rsquo;mkdir {.}; cd
{.}; unzip ../{}&rsquo; ::: *.zip</p>

<p style="margin-top: 1em">Recompress all .gz files in
current directory using bzip2 running 1 job per CPU core in
parallel:</p>

<p style="margin-top: 1em">parallel &quot;zcat {} | bzip2
&gt;{.}.bz2 &amp;&amp; rm {}&quot; ::: *.gz</p>

<p style="margin-top: 1em">Convert all WAV files to MP3
using LAME:</p>

<p style="margin-top: 1em">find sounddir -type f -name
&rsquo;*.wav&rsquo; | parallel lame {} -o {.}.mp3</p>

<p style="margin-top: 1em">Put all converted in the same
directory:</p>

<p style="margin-top: 1em">find sounddir -type f -name
&rsquo;*.wav&rsquo; | parallel lame {} -o mydir/{/.}.mp3</p>

<p style="margin-top: 1em">EXAMPLE: Removing two file
extensions when processing files <br>
If you have directory with tar.gz files and want these
extracted in the corresponding dir (e.g foo.tar.gz will be
extracted in the dir foo) you can do:</p>

<p style="margin-top: 1em">parallel --plus &rsquo;mkdir
{..}; tar -C {..} -xf {}&rsquo; ::: *.tar.gz</p>

<p style="margin-top: 1em">EXAMPLE: Download 10 images for
each of the past 30 days <br>
Let us assume a website stores images like:</p>


<p style="margin-top: 1em">http://www.example.com/path/to/YYYYMMDD_##.jpg</p>

<p style="margin-top: 1em">where YYYYMMDD is the date and
## is the number 01-10. This will download images for the
past 30 days:</p>

<p style="margin-top: 1em">parallel wget
http://www.example.com/path/to/&rsquo;$(date -d &quot;today
-{1} days&quot; +%Y%m%d)_{2}.jpg&rsquo; ::: $(seq 30) :::
$(seq -w 10)</p>

<p style="margin-top: 1em">$(date -d &quot;today -{1}
days&quot; +%Y%m%d) will give the dates in YYYYMMDD with {1}
days subtracted.</p>

<p style="margin-top: 1em">EXAMPLE: Copy files as last
modified date (ISO8601) with added random digits <br>
find . | parallel cp {} &rsquo;../destdir/{=
$a=int(10000*rand); $_=&lsquo;date -r &quot;$_&quot;
+%FT%T&quot;$a&quot;&lsquo;; chomp; =}&rsquo;</p>

<p style="margin-top: 1em">{= and =} mark a perl
expression. date +%FT%T is the date in ISO8601 with
time.</p>

<p style="margin-top: 1em">EXAMPLE: Digtal clock with
&quot;blinking&quot; : <br>
The : in a digital clock blinks. To make every other line
have a &rsquo;:&rsquo; and the rest a &rsquo; &rsquo; a perl
expression is used to look at the 3rd input source. If the
value modudo 2 is 1: Use <br>
&quot;:&quot; otherwise use &quot; &quot;:</p>

<p style="margin-top: 1em">parallel -k echo {1}&rsquo;{=3
$_=$_%2?&quot;:&quot;:&quot; &quot;=}&rsquo;{2}{3} :::
{0..12} ::: {0..5} ::: {0..9}</p>

<p style="margin-top: 1em">EXAMPLE: Aggregating content of
files <br>
This:</p>

<p style="margin-top: 1em">parallel --header : echo
x{X}y{Y}z{Z} &gt; x{X}y{Y}z{Z} ::: X {1..5} ::: Y {01..10}
::: Z {1..5}</p>

<p style="margin-top: 1em">will generate the files x1y01z1
.. x5y10z5. If you want to aggregate the output grouping on
x and z you can do this:</p>

<p style="margin-top: 1em">parallel eval &rsquo;cat
{=s/y01/y*/=} &gt; {=s/y01//=}&rsquo; ::: *y01*</p>

<p style="margin-top: 1em">For all values of x and z it
runs commands like:</p>

<p style="margin-top: 1em">cat x1y*z1 &gt; x1z1</p>

<p style="margin-top: 1em">So you end up with x1z1 .. x5z5
each containing the content of all values of y.</p>

<p style="margin-top: 1em">EXAMPLE: Breadth first parallel
web crawler/mirrorer <br>
This script below will crawl and mirror a URL in parallel.
It downloads first pages that are 1 click down, then 2
clicks down, then 3; instead of the normal depth first,
where <br>
the first link link on each page is fetched first.</p>

<p style="margin-top: 1em">Run like this:</p>

<p style="margin-top: 1em">PARALLEL=-j100 ./parallel-crawl
http://gatt.org.yeslab.org/</p>

<p style="margin-top: 1em">Remove the wget part if you only
want a web crawler.</p>

<p style="margin-top: 1em">It works by fetching a page from
a list of URLs and looking for links in that page that are
within the same starting URL and that have not already been
seen. These links are <br>
added to a new queue. When all the pages from the list is
done, the new queue is moved to the list of URLs and the
process is started over until no unseen links are found.</p>

<p style="margin-top: 1em">#!/bin/bash</p>

<p style="margin-top: 1em"># E.g.
http://gatt.org.yeslab.org/ <br>
URL=$1 <br>
# Stay inside the start dir <br>
BASEURL=$(echo $URL | perl -pe &rsquo;s:#.*::;
s:(//.*/)[^/]*:$1:&rsquo;) <br>
URLLIST=$(mktemp urllist.XXXX) <br>
URLLIST2=$(mktemp urllist.XXXX) <br>
SEEN=$(mktemp seen.XXXX)</p>

<p style="margin-top: 1em"># Spider to get the URLs <br>
echo $URL &gt;$URLLIST <br>
cp $URLLIST $SEEN</p>

<p style="margin-top: 1em">while [ -s $URLLIST ] ; do <br>
cat $URLLIST | <br>
parallel lynx -listonly -image_links -dump {} ; wget -qm -l1
-Q1 {} ; echo Spidered: {} &gt;2 | <br>
perl -ne &rsquo;s/#.*//; s/+.$/$1/ and do { $seen{$1}++ or
print }&rsquo; | <br>
grep -F $BASEURL | <br>
grep -v -x -F -f $SEEN | tee -a $SEEN &gt; $URLLIST2 <br>
mv $URLLIST2 $URLLIST <br>
done</p>

<p style="margin-top: 1em">rm -f $URLLIST $URLLIST2
$SEEN</p>

<p style="margin-top: 1em">EXAMPLE: Process files from a
tar file while unpacking <br>
If the files to be processed are in a tar file then
unpacking one file and processing it immediately may be
faster than first unpacking all files.</p>

<p style="margin-top: 1em">tar xvf foo.tgz | perl -ne
&rsquo;print $l;$l=$_;END{print $l}&rsquo; | parallel
echo</p>

<p style="margin-top: 1em">The Perl one-liner is needed to
make sure the file is complete before handing it to GNU
parallel.</p>

<p style="margin-top: 1em">EXAMPLE: Rewriting a for-loop
and a while-read-loop <br>
for-loops like this:</p>

<p style="margin-top: 1em">(for x in &lsquo;cat list&lsquo;
; do <br>
do_something $x <br>
done) | process_output</p>

<p style="margin-top: 1em">and while-read-loops like
this:</p>

<p style="margin-top: 1em">cat list | (while read x ; do
<br>
do_something $x <br>
done) | process_output</p>

<p style="margin-top: 1em">can be written like this:</p>

<p style="margin-top: 1em">cat list | parallel do_something
| process_output</p>

<p style="margin-top: 1em">For example: Find which host
name in a list has IP address 1.2.3 4:</p>

<p style="margin-top: 1em">cat hosts.txt | parallel -P 100
host | grep 1.2.3.4</p>

<p style="margin-top: 1em">If the processing requires more
steps the for-loop like this:</p>

<p style="margin-top: 1em">(for x in &lsquo;cat list&lsquo;
; do <br>
no_extension=${x%.*}; <br>
do_something $x scale $no_extension.jpg <br>
do_step2 &lt;$x $no_extension <br>
done) | process_output</p>

<p style="margin-top: 1em">and while-loops like this:</p>

<p style="margin-top: 1em">cat list | (while read x ; do
<br>
no_extension=${x%.*}; <br>
do_something $x scale $no_extension.jpg <br>
do_step2 &lt;$x $no_extension <br>
done) | process_output</p>

<p style="margin-top: 1em">can be written like this:</p>

<p style="margin-top: 1em">cat list | parallel
&quot;do_something {} scale {.}.jpg ; do_step2 &lt;{}
{.}&quot; | process_output</p>

<p style="margin-top: 1em">If the body of the loop is
bigger, it improves readability to use a function:</p>

<p style="margin-top: 1em">(for x in &lsquo;cat list&lsquo;
; do <br>
do_something $x <br>
[... 100 lines that do something with $x ...] <br>
done) | process_output</p>

<p style="margin-top: 1em">cat list | (while read x ; do
<br>
do_something $x <br>
[... 100 lines that do something with $x ...] <br>
done) | process_output</p>

<p style="margin-top: 1em">can both be rewritten as:</p>

<p style="margin-top: 1em">doit() { <br>
x=$1 <br>
do_something $x <br>
[... 100 lines that do something with $x ...] <br>
} <br>
export -f doit <br>
cat list | parallel doit</p>

<p style="margin-top: 1em">EXAMPLE: Rewriting nested
for-loops <br>
Nested for-loops like this:</p>

<p style="margin-top: 1em">(for x in &lsquo;cat
xlist&lsquo; ; do <br>
for y in &lsquo;cat ylist&lsquo; ; do <br>
do_something $x $y <br>
done <br>
done) | process_output</p>

<p style="margin-top: 1em">can be written like this:</p>

<p style="margin-top: 1em">parallel do_something {1} {2}
:::: xlist ylist | process_output</p>

<p style="margin-top: 1em">Nested for-loops like this:</p>

<p style="margin-top: 1em">(for colour in red green blue ;
do <br>
for size in S M L XL XXL ; do <br>
echo $colour $size <br>
done <br>
done) | sort</p>

<p style="margin-top: 1em">can be written like this:</p>

<p style="margin-top: 1em">parallel echo {1} {2} ::: red
green blue ::: S M L XL XXL | sort</p>

<p style="margin-top: 1em">EXAMPLE: Finding the lowest
difference between files <br>
diff is good for finding differences in text files. diff |
wc -l gives an indication of the size of the difference. To
find the differences between all files in the current dir
<br>
do:</p>

<p style="margin-top: 1em">parallel --tag &rsquo;diff {1}
{2} | wc -l&rsquo; ::: * ::: * | sort -nk3</p>

<p style="margin-top: 1em">This way it is possible to see
if some files are closer to other files.</p>

<p style="margin-top: 1em">EXAMPLE: for-loops with column
names <br>
When doing multiple nested for-loops it can be easier to
keep track of the loop variable if is is named instead of
just having a number. Use --header : to let the first
argument <br>
be an named alias for the positional replacement string:</p>

<p style="margin-top: 1em">parallel --header : echo
{colour} {size} ::: colour red green blue ::: size S M L XL
XXL</p>

<p style="margin-top: 1em">This also works if the input
file is a file with columns:</p>

<p style="margin-top: 1em">cat addressbook.tsv | parallel
--colsep &rsquo;&rsquo; --header : echo {Name} {E-mail
address}</p>

<p style="margin-top: 1em">EXAMPLE: Count the differences
between all files in a dir <br>
Using --results the results are saved in
/tmp/diffcount*.</p>

<p style="margin-top: 1em">parallel --results
/tmp/diffcount &quot;diff -U 0 {1} {2} | tail -n +3 |grep -v
&rsquo;^@&rsquo;|wc -l&quot; ::: * ::: *</p>

<p style="margin-top: 1em">To see the difference between
file A and file B look at the file
&rsquo;/tmp/diffcount/1/A/2/B&rsquo;.</p>

<p style="margin-top: 1em">EXAMPLE: Speeding up fast jobs
<br>
Starting a job on the local machine takes around 10 ms. This
can be a big overhead if the job takes very few ms to run.
Often you can group small jobs together using -X which <br>
will make the overhead less significant. Compare the speed
of these:</p>

<p style="margin-top: 1em">seq -w 0 9999 | parallel touch
pict{}.jpg <br>
seq -w 0 9999 | parallel -X touch pict{}.jpg</p>

<p style="margin-top: 1em">If your program cannot take
multiple arguments, then you can use GNU parallel to spawn
multiple GNU parallels:</p>

<p style="margin-top: 1em">seq -w 0 999999 | parallel -j10
--pipe parallel -j0 touch pict{}.jpg</p>

<p style="margin-top: 1em">If -j0 normally spawns 252 jobs,
then the above will try to spawn 2520 jobs. On a normal
GNU/Linux system you can spawn 32000 jobs using this
technique with no problems. To raise <br>
the 32000 jobs limit raise /proc/sys/kernel/pid_max to
4194303.</p>

<p style="margin-top: 1em">EXAMPLE: Using shell variables
<br>
When using shell variables you need to quote them correctly
as they may otherwise be split on spaces.</p>

<p style="margin-top: 1em">Notice the difference
between:</p>

<p style="margin-top: 1em">V=(&quot;My brother&rsquo;s 12
<br>
parallel echo ::: ${V[@]} # This is probably not what you
want</p>

<p style="margin-top: 1em">and:</p>

<p style="margin-top: 1em">V=(&quot;My brother&rsquo;s 12
<br>
parallel echo ::: &quot;${V[@]}&quot;</p>

<p style="margin-top: 1em">When using variables in the
actual command that contains special characters (e.g. space)
you can quote them using &rsquo;&quot;$VAR&quot;&rsquo; or
using &quot;&rsquo;s and -q:</p>

<p style="margin-top: 1em">V=&quot;Here are two &quot; <br>
parallel echo &quot;&rsquo;$V&rsquo;&quot; ::: spaces <br>
parallel -q echo &quot;$V&quot; ::: spaces</p>

<p style="margin-top: 1em">EXAMPLE: Group output lines <br>
When running jobs that output data, you often do not want
the output of multiple jobs to run together. GNU parallel
defaults to grouping the output of each job, so the output
is <br>
printed when the job finishes. If you want full lines to be
printed while the job is running you can use --line-buffer.
If you want output to be printed as soon as possible you
<br>
can use -u.</p>

<p style="margin-top: 1em">Compare the output of:</p>

<p style="margin-top: 1em">parallel traceroute :::
qubes-os.org debian.org freenetproject.org <br>
parallel --line-buffer traceroute ::: qubes-os.org
debian.org freenetproject.org <br>
parallel -u traceroute ::: qubes-os.org debian.org
freenetproject.org</p>

<p style="margin-top: 1em">EXAMPLE: Tag output lines <br>
GNU parallel groups the output lines, but it can be hard to
see where the different jobs begin. --tag prepends the
argument to make that more visible:</p>

<p style="margin-top: 1em">parallel --tag traceroute :::
qubes-os.org debian.org freenetproject.org</p>

<p style="margin-top: 1em">--tag works with --line-buffer
but not with -u:</p>

<p style="margin-top: 1em">parallel --tag --line-buffer
traceroute ::: qubes-os.org debian.org
freenetproject.org</p>

<p style="margin-top: 1em">Check the uptime of the servers
in ~/.parallel/sshloginfile:</p>

<p style="margin-top: 1em">parallel --tag -S .. --nonall
uptime</p>

<p style="margin-top: 1em">EXAMPLE: Keep order of output
same as order of input <br>
Normally the output of a job will be printed as soon as it
completes. Sometimes you want the order of the output to
remain the same as the order of the input. This is often
<br>
important, if the output is used as input for another
system. -k will make sure the order of output will be in the
same order as input even if later jobs end before earlier
jobs.</p>

<p style="margin-top: 1em">Append a string to every line in
a text file:</p>

<p style="margin-top: 1em">cat textfile | parallel -k echo
{} append_string</p>

<p style="margin-top: 1em">If you remove -k some of the
lines may come out in the wrong order.</p>

<p style="margin-top: 1em">Another example is
traceroute:</p>

<p style="margin-top: 1em">parallel traceroute :::
qubes-os.org debian.org freenetproject.org</p>

<p style="margin-top: 1em">will give traceroute of
qubes-os.org, debian.org and freenetproject.org, but it will
be sorted according to which job completed first.</p>

<p style="margin-top: 1em">To keep the order the same as
input run:</p>

<p style="margin-top: 1em">parallel -k traceroute :::
qubes-os.org debian.org freenetproject.org</p>

<p style="margin-top: 1em">This will make sure the
traceroute to qubes-os.org will be printed first.</p>

<p style="margin-top: 1em">A bit more complex example is
downloading a huge file in chunks in parallel: Some internet
connections will deliver more data if you download files in
parallel. For downloading <br>
files in parallel see: &quot;EXAMPLE: Download 10 images for
each of the past 30 days&quot;. But if you are downloading a
big file you can download the file in chunks in
parallel.</p>

<p style="margin-top: 1em">To download byte
10000000-19999999 you can use curl:</p>

<p style="margin-top: 1em">curl -r 10000000-19999999
http://example.com/the/big/file &gt;file.part</p>

<p style="margin-top: 1em">To download a 1 GB file we need
100 10MB chunks downloaded and combined in the correct
order.</p>

<p style="margin-top: 1em">seq 0 99 | parallel -k curl -r
{}0000000-{}9999999 http://example.com/the/big/file &gt;
file</p>

<p style="margin-top: 1em">EXAMPLE: Parallel grep <br>
grep -r greps recursively through directories. On multicore
CPUs GNU parallel can often speed this up.</p>

<p style="margin-top: 1em">find . -type f | parallel -k
-j150% -n 1000 -m grep -H -n STRING {}</p>

<p style="margin-top: 1em">This will run 1.5 job per core,
and give 1000 arguments to grep.</p>

<p style="margin-top: 1em">EXAMPLE: Grepping n lines for m
regular expressions. <br>
The simplest solution to grep a big file for a lot of
regexps is:</p>

<p style="margin-top: 1em">grep -f regexps.txt bigfile</p>

<p style="margin-top: 1em">Or if the regexps are fixed
strings:</p>

<p style="margin-top: 1em">grep -F -f regexps.txt
bigfile</p>

<p style="margin-top: 1em">There are 3 limiting factors:
CPU, RAM, and disk I/O.</p>

<p style="margin-top: 1em">RAM is easy to measure: If the
grep process takes up most of your free memory (e.g. when
running top), then RAM is a limiting factor.</p>

<p style="margin-top: 1em">CPU is also easy to measure: If
the grep takes &gt;90% CPU in top, then the CPU is a
limiting factor, and parallelization will speed this up.</p>

<p style="margin-top: 1em">It is harder to see if disk I/O
is the limiting factor, and depending on the disk system it
may be faster or slower to parallelize. The only way to know
for certain is to test <br>
and measure.</p>

<p style="margin-top: 1em">Limiting factor: RAM <br>
The normal grep -f regexs.txt bigfile works no matter the
size of bigfile, but if regexps.txt is so big it cannot fit
into memory, then you need to split this.</p>

<p style="margin-top: 1em">grep -F takes around 100 bytes
of RAM and grep takes about 500 bytes of RAM per 1 byte of
regexp. So if regexps.txt is 1% of your RAM, then it may be
too big.</p>

<p style="margin-top: 1em">If you can convert your regexps
into fixed strings do that. E.g. if the lines you are
looking for in bigfile all looks like:</p>

<p style="margin-top: 1em">ID1 foo bar baz Identifier1 quux
<br>
fubar ID2 foo bar baz Identifier2</p>

<p style="margin-top: 1em">then your regexps.txt can be
converted from:</p>

<p style="margin-top: 1em">ID1.*Identifier1 <br>
ID2.*Identifier2</p>

<p style="margin-top: 1em">into:</p>

<p style="margin-top: 1em">ID1 foo bar baz Identifier1 <br>
ID2 foo bar baz Identifier2</p>

<p style="margin-top: 1em">This way you can use grep -F
which takes around 80% less memory and is much faster.</p>

<p style="margin-top: 1em">If it still does not fit in
memory you can do this:</p>

<p style="margin-top: 1em">parallel --pipepart -a
regexps.txt --block 1M grep -F -f - -n bigfile | <br>
sort -un | perl -pe &rsquo;s/^+://&rsquo;</p>

<p style="margin-top: 1em">The 1M should be your free
memory divided by the number of cores and divided by 200 for
grep -F and by 1000 for normal grep. On GNU/Linux you can
do:</p>

<p style="margin-top: 1em">free=$(awk
&rsquo;/^((Swap)?Cached|MemFree|Buffers):/ { sum += $2 }
<br>
END { print sum }&rsquo; /proc/meminfo) <br>
percpu=$((free / 200 / $(parallel --number-of-cores)))k</p>

<p style="margin-top: 1em">parallel --pipepart -a
regexps.txt --block $percpu --compress grep -F -f - -n
bigfile | <br>
sort -un | perl -pe &rsquo;s/^+://&rsquo;</p>

<p style="margin-top: 1em">If you can live with duplicated
lines and wrong order, it is faster to do:</p>

<p style="margin-top: 1em">parallel --pipepart -a
regexps.txt --block $percpu --compress grep -F -f -
bigfile</p>

<p style="margin-top: 1em">Limiting factor: CPU <br>
If the CPU is the limiting factor parallelization should be
done on the regexps:</p>

<p style="margin-top: 1em">cat regexp.txt | parallel --pipe
-L1000 --round-robin --compress grep -f - -n bigfile | <br>
sort -un | perl -pe &rsquo;s/^+://&rsquo;</p>

<p style="margin-top: 1em">The command will start one grep
per CPU and read bigfile one time per CPU, but as that is
done in parallel, all reads except the first will be cached
in RAM. Depending on the <br>
size of regexp.txt it may be faster to use --block 10m
instead of -L1000.</p>

<p style="margin-top: 1em">Some storage systems perform
better when reading multiple chunks in parallel. This is
true for some RAID systems and for some network file
systems. To parallelize the reading of <br>
bigfile:</p>

<p style="margin-top: 1em">parallel --pipepart --block 100M
-a bigfile -k --compress grep -f regexp.txt</p>

<p style="margin-top: 1em">This will split bigfile into
100MB chunks and run grep on each of these chunks. To
parallelize both reading of bigfile and regexp.txt combine
the two using --fifo:</p>

<p style="margin-top: 1em">parallel --pipepart --block 100M
-a bigfile --fifo cat regexp.txt parallel --pipe -L1000
--round-robin grep -f - {}</p>

<p style="margin-top: 1em">If a line matches multiple
regexps, the line may be duplicated.</p>

<p style="margin-top: 1em">Bigger problem <br>
If the problem is too big to be solved by this, you are
probably ready for Lucene.</p>

<p style="margin-top: 1em">EXAMPLE: Using remote computers
<br>
To run commands on a remote computer SSH needs to be set up
and you must be able to login without entering a password
(The commands ssh-copy-id, ssh-agent, and sshpass may help
<br>
you do that).</p>

<p style="margin-top: 1em">If you need to login to a whole
cluster, you typically do not want to accept the host key
for every host. You want to accept them the first time and
be warned if they are ever <br>
changed. To do that:</p>

<p style="margin-top: 1em"># Add the servers to the
sshloginfile <br>
(echo servera; echo serverb) &gt; .parallel/my_cluster <br>
# Make sure .ssh/config exist <br>
touch .ssh/config <br>
cp .ssh/config .ssh/config.backup <br>
# Disable StrictHostKeyChecking temporarily <br>
(echo &rsquo;Host *&rsquo;; echo StrictHostKeyChecking no)
&gt;&gt; .ssh/config <br>
parallel --slf my_cluster --nonall true <br>
# Remove the disabling of StrictHostKeyChecking <br>
mv .ssh/config.backup .ssh/config</p>

<p style="margin-top: 1em">The servers in
.parallel/my_cluster are now added in .ssh/known_hosts.</p>

<p style="margin-top: 1em">To run echo on
server.example.com:</p>

<p style="margin-top: 1em">seq 10 | parallel --sshlogin
server.example.com echo</p>

<p style="margin-top: 1em">To run commands on more than one
remote computer run:</p>

<p style="margin-top: 1em">seq 10 | parallel --sshlogin
server.example.com,server2.example.net echo</p>

<p style="margin-top: 1em">Or:</p>

<p style="margin-top: 1em">seq 10 | parallel --sshlogin
server.example.com --sshlogin server2.example.net echo</p>

<p style="margin-top: 1em">If the login username is foo on
server2.example.net use:</p>

<p style="margin-top: 1em">seq 10 | parallel --sshlogin
server.example.com --sshlogin foo@server2.example.net
echo</p>

<p style="margin-top: 1em">If your list of hosts is
server1-88.example.net with login foo:</p>

<p style="margin-top: 1em">seq 10 | parallel
-Sfoo@server{1..88}.example.net echo</p>

<p style="margin-top: 1em">To distribute the commands to a
list of computers, make a file mycomputers with all the
computers:</p>

<p style="margin-top: 1em">server.example.com <br>
foo@server2.example.com <br>
server3.example.com</p>

<p style="margin-top: 1em">Then run:</p>

<p style="margin-top: 1em">seq 10 | parallel --sshloginfile
mycomputers echo</p>

<p style="margin-top: 1em">To include the local computer
add the special sshlogin &rsquo;:&rsquo; to the list:</p>

<p style="margin-top: 1em">server.example.com <br>
foo@server2.example.com <br>
server3.example.com <br>
:</p>

<p style="margin-top: 1em">GNU parallel will try to
determine the number of CPU cores on each of the remote
computers, and run one job per CPU core - even if the remote
computers do not have the same <br>
number of CPU cores.</p>

<p style="margin-top: 1em">If the number of CPU cores on
the remote computers is not identified correctly the number
of CPU cores can be added in front. Here the computer has 8
CPU cores.</p>

<p style="margin-top: 1em">seq 10 | parallel --sshlogin
8/server.example.com echo</p>

<p style="margin-top: 1em">EXAMPLE: Transferring of files
<br>
To recompress gzipped files with bzip2 using a remote
computer run:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel --sshlogin server.example.com
--transfer &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">This will list the .gz-files in
the logs directory and all directories below. Then it will
transfer the files to server.example.com to the
corresponding directory in $HOME/logs. <br>
On server.example.com the file will be recompressed using
zcat and bzip2 resulting in the corresponding file with .gz
replaced with .bz2.</p>

<p style="margin-top: 1em">If you want the resulting
bz2-file to be transferred back to the local computer add
--return {.}.bz2:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel --sshlogin server.example.com
--transfer --return {.}.bz2 &quot;zcat {} | bzip2 -9
&gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">After the recompressing is done
the .bz2-file is transferred back to the local computer and
put next to the original .gz-file.</p>

<p style="margin-top: 1em">If you want to delete the
transferred files on the remote computer add --cleanup. This
will remove both the file transferred to the remote computer
and the files transferred from <br>
the remote computer:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel --sshlogin server.example.com
--transfer --return {.}.bz2 --cleanup &quot;zcat {} | bzip2
-9 &gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">If you want run on several
computers add the computers to --sshlogin either using
&rsquo;,&rsquo; or multiple --sshlogin:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel --sshlogin
server.example.com,server2.example.com --sshlogin
server3.example.com --transfer --return {.}.bz2 --cleanup
&quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">You can add the local computer
using --sshlogin :. This will disable the removing and
transferring for the local computer only:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel --sshlogin
server.example.com,server2.example.com --sshlogin
server3.example.com --sshlogin : --transfer --return {.}.bz2
--cleanup &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">Often --transfer, --return and
--cleanup are used together. They can be shortened to
--trc:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel --sshlogin
server.example.com,server2.example.com --sshlogin
server3.example.com --sshlogin : --trc {.}.bz2 &quot;zcat {}
| bzip2 -9 &gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">With the file mycomputers
containing the list of computers it becomes:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel --sshloginfile mycomputers
--trc {.}.bz2 &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">If the file
~/.parallel/sshloginfile contains the list of computers the
special short hand -S .. can be used:</p>

<p style="margin-top: 1em">find logs/ -name
&rsquo;*.gz&rsquo; | parallel -S .. --trc {.}.bz2 &quot;zcat
{} | bzip2 -9 &gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">EXAMPLE: Distributing work to
local and remote computers <br>
Convert *.mp3 to *.ogg running one process per CPU core on
local computer and server2:</p>

<p style="margin-top: 1em">parallel --trc {.}.ogg -S
server2,: &rsquo;mpg321 -w - {} | oggenc -q0 - -o
{.}.ogg&rsquo; ::: *.mp3</p>

<p style="margin-top: 1em">EXAMPLE: Running the same
command on remote computers <br>
To run the command uptime on remote computers you can
do:</p>

<p style="margin-top: 1em">parallel --tag --nonall -S
server1,server2 uptime</p>

<p style="margin-top: 1em">--nonall reads no arguments. If
you have a list of jobs you want run on each computer you
can do:</p>

<p style="margin-top: 1em">parallel --tag --onall -S
server1,server2 echo ::: 1 2 3</p>

<p style="margin-top: 1em">Remove --tag if you do not want
the sshlogin added before the output.</p>

<p style="margin-top: 1em">If you have a lot of hosts use
&rsquo;-j0&rsquo; to access more hosts in parallel.</p>

<p style="margin-top: 1em">EXAMPLE: Using remote computers
behind NAT wall <br>
If the workers are behind a NAT wall, you need some trickery
to get to them.</p>

<p style="margin-top: 1em">If you can ssh to a jump host,
and reach the workers from there, then the obvious solution
would be this, but it does not work:</p>

<p style="margin-top: 1em">parallel --ssh &rsquo;ssh
jumphost ssh&rsquo; -S host1 echo ::: DOES NOT WORK</p>

<p style="margin-top: 1em">It does not work because the
command is dequoted by ssh twice where as GNU parallel only
expects it to be dequoted once.</p>

<p style="margin-top: 1em">So instead put this in
~/.ssh/config:</p>

<p style="margin-top: 1em">Host host1 host2 host3 <br>
ProxyCommand ssh jumphost.domain nc -w 1 %h 22</p>

<p style="margin-top: 1em">It requires nc(netcat) to be
installed on jumphost. With this you can simply:</p>

<p style="margin-top: 1em">parallel -S host1,host2,host3
echo ::: This does work</p>

<p style="margin-top: 1em">No jumphost, but port forwards
<br>
If there is no jumphost but each server has port 22
forwarded from the firewall (e.g. the firewall&rsquo;s port
22001 = port 22 on host1, 22002 = host2, 22003 = host3) then
you can use <br>
~/.ssh/config:</p>

<p style="margin-top: 1em">Host host1.v <br>
Port 22001 <br>
Host host2.v <br>
Port 22002 <br>
Host host3.v <br>
Port 22003 <br>
Host *.v <br>
Hostname firewall</p>

<p style="margin-top: 1em">And then use host{1..3}.v as
normal hosts:</p>

<p style="margin-top: 1em">parallel -S
host1.v,host2.v,host3.v echo ::: a b c</p>

<p style="margin-top: 1em">No jumphost, no port forwards
<br>
If ports cannot be forwarded, you need some sort of VPN to
traverse the NAT-wall. TOR is one options for that, as it is
very easy to get working.</p>

<p style="margin-top: 1em">You need to install TOR and
setup a hidden service. In torrc put:</p>

<p style="margin-top: 1em">HiddenServiceDir
/var/lib/tor/hidden_service/ <br>
HiddenServicePort 22 127.0.0.1:22</p>

<p style="margin-top: 1em">Then start TOR: /etc/init.d/tor
restart</p>

<p style="margin-top: 1em">The TOR hostname is now in
/var/lib/tor/hidden_service/hostname and is something
similar to izjafdceobowklhz.onion. Now you simply prepend
torsocks to ssh:</p>

<p style="margin-top: 1em">parallel --ssh &rsquo;torsocks
ssh&rsquo; -S izjafdceobowklhz.onion -S
zfcdaeiojoklbwhz.onion,auclucjzobowklhi.onion echo ::: a b
c</p>

<p style="margin-top: 1em">If not all hosts are accessible
through TOR:</p>

<p style="margin-top: 1em">parallel -S &rsquo;torsocks ssh
izjafdceobowklhz.onion,host2,host3&rsquo; echo ::: a b c</p>

<p style="margin-top: 1em">EXAMPLE: Parallelizing rsync
<br>
rsync is a great tool, but sometimes it will not fill up the
available bandwidth. This is often a problem when copying
several big files over high speed connections.</p>

<p style="margin-top: 1em">The following will start one
rsync per big file in src-dir to dest-dir on the server
fooserver:</p>

<p style="margin-top: 1em">cd src-dir; find . -type f -size
+100000 | parallel -v ssh fooserver mkdir -p /dest-dir/{//};
rsync -s -Havessh {} fooserver:/dest-dir/{}</p>

<p style="margin-top: 1em">The dirs created may end up with
wrong permissions and smaller files are not being
transferred. To fix those run rsync a final time:</p>

<p style="margin-top: 1em">rsync -Havessh src-dir/
fooserver:/dest-dir/</p>

<p style="margin-top: 1em">If you are unable to push data,
but need to pull them and the files are called digits.png
(e.g. 000000.png) you might be able to do:</p>

<p style="margin-top: 1em">seq -w 0 99 | parallel rsync
-Havessh fooserver:src-path/*{}.png destdir/</p>

<p style="margin-top: 1em">EXAMPLE: Use multiple inputs in
one command <br>
Copy files like foo.es.ext to foo.ext:</p>

<p style="margin-top: 1em">ls *.es.* | perl -pe
&rsquo;print; s/.es//&rsquo; | parallel -N2 cp {1} {2}</p>

<p style="margin-top: 1em">The perl command spits out 2
lines for each input. GNU parallel takes 2 inputs (using
-N2) and replaces {1} and {2} with the inputs.</p>

<p style="margin-top: 1em">Count in binary:</p>

<p style="margin-top: 1em">parallel -k echo ::: 0 1 ::: 0 1
::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1</p>

<p style="margin-top: 1em">Print the number on the opposing
sides of a six sided die:</p>

<p style="margin-top: 1em">parallel --xapply -a &lt;(seq 6)
-a &lt;(seq 6 -1 1) echo <br>
parallel --xapply echo :::: &lt;(seq 6) &lt;(seq 6 -1 1)</p>

<p style="margin-top: 1em">Convert files from all subdirs
to PNG-files with consecutive numbers (useful for making
input PNG&rsquo;s for ffmpeg):</p>

<p style="margin-top: 1em">parallel --xapply -a &lt;(find .
-type f | sort) -a &lt;(seq $(find . -type f|wc -l)) convert
{1} {2}.png</p>

<p style="margin-top: 1em">Alternative version:</p>

<p style="margin-top: 1em">find . -type f | sort | parallel
convert {} {#}.png</p>

<p style="margin-top: 1em">EXAMPLE: Use a table as input
<br>
Content of table_file.tsv:</p>

<p style="margin-top: 1em">foo&lt;TAB&gt;bar <br>
baz &lt;TAB&gt; quux</p>

<p style="margin-top: 1em">To run:</p>

<p style="margin-top: 1em">cmd -o bar -i foo <br>
cmd -o quux -i baz</p>

<p style="margin-top: 1em">you can run:</p>

<p style="margin-top: 1em">parallel -a table_file.tsv
--colsep &rsquo;&rsquo; cmd -o {2} -i {1}</p>

<p style="margin-top: 1em">Note: The default for GNU
parallel is to remove the spaces around the columns. To keep
the spaces:</p>

<p style="margin-top: 1em">parallel -a table_file.tsv
--trim n --colsep &rsquo;&rsquo; cmd -o {2} -i {1}</p>

<p style="margin-top: 1em">EXAMPLE: Run the same command 10
times <br>
If you want to run the same command with the same arguments
10 times in parallel you can do:</p>

<p style="margin-top: 1em">seq 10 | parallel -n0 my_command
my_args</p>

<p style="margin-top: 1em">EXAMPLE: Working as cat | sh.
Resource inexpensive jobs and evaluation <br>
GNU parallel can work similar to cat | sh.</p>

<p style="margin-top: 1em">A resource inexpensive job is a
job that takes very little CPU, disk I/O and network I/O.
Ping is an example of a resource inexpensive job. wget is
too - if the webpages are <br>
small.</p>

<p style="margin-top: 1em">The content of the file
jobs_to_run:</p>

<p style="margin-top: 1em">ping -c 1 10.0.0.1 <br>
wget http://example.com/status.cgi?ip=10.0.0.1 <br>
ping -c 1 10.0.0.2 <br>
wget http://example.com/status.cgi?ip=10.0.0.2 <br>
... <br>
ping -c 1 10.0.0.255 <br>
wget http://example.com/status.cgi?ip=10.0.0.255</p>

<p style="margin-top: 1em">To run 100 processes
simultaneously do:</p>

<p style="margin-top: 1em">parallel -j 100 &lt;
jobs_to_run</p>

<p style="margin-top: 1em">As there is not a command the
jobs will be evaluated by the shell.</p>

<p style="margin-top: 1em">EXAMPLE: Processing a big file
using more cores <br>
To process a big file or some output you can use --pipe to
split up the data into blocks and pipe the blocks into the
processing program.</p>

<p style="margin-top: 1em">If the program is gzip -9 you
can do:</p>

<p style="margin-top: 1em">cat bigfile | parallel --pipe
--recend &rsquo;&rsquo; -k gzip -9 &gt; bigfile.gz</p>

<p style="margin-top: 1em">This will split bigfile into
blocks of 1 MB and pass that to gzip -9 in parallel. One
gzip will be run per CPU core. The output of gzip -9 will be
kept in order and saved to <br>
bigfile.gz</p>

<p style="margin-top: 1em">gzip works fine if the output is
appended, but some processing does not work like that - for
example sorting. For this GNU parallel can put the output of
each command into a <br>
file. This will sort a big file in parallel:</p>

<p style="margin-top: 1em">cat bigfile | parallel --pipe
--files sort | parallel -Xj1 sort -m {} &rsquo;;&rsquo; rm
{} &gt;bigfile.sort</p>

<p style="margin-top: 1em">Here bigfile is split into
blocks of around 1MB, each block ending in &rsquo;0 (which
is the default for --recend). Each block is passed to sort
and the output from sort is saved <br>
into files. These files are passed to the second parallel
that runs sort -m on the files before it removes the files.
The output is saved to bigfile.sort.</p>

<p style="margin-top: 1em">GNU parallel&rsquo;s --pipe
maxes out at around 100 MB/s because every byte has to be
copied through GNU parallel. But if bigfile is a real
(seekable) file GNU parallel can by-pass the <br>
copying and send the parts directly to the program:</p>

<p style="margin-top: 1em">parallel --pipepart --block 100m
-a bigfile --files sort | parallel -Xj1 sort -m {}
&rsquo;;&rsquo; rm {} &gt;bigfile.sort</p>

<p style="margin-top: 1em">EXAMPLE: Running more than 250
jobs workaround <br>
If you need to run a massive amount of jobs in parallel,
then you will likely hit the filehandle limit which is often
around 250 jobs. If you are super user you can raise the
<br>
limit in /etc/security/limits.conf but you can also use this
workaround. The filehandle limit is per process. That means
that if you just spawn more GNU parallels then each of <br>
them can run 250 jobs. This will spawn up to 2500 jobs:</p>

<p style="margin-top: 1em">cat myinput | parallel --pipe -N
50 --round-robin -j50 parallel -j50 your_prg</p>

<p style="margin-top: 1em">This will spawn up to 62500 jobs
(use with caution - you need 64 GB RAM to do this, and you
may need to increase /proc/sys/kernel/pid_max):</p>

<p style="margin-top: 1em">cat myinput | parallel --pipe -N
250 --round-robin -j250 parallel -j250 your_prg</p>

<p style="margin-top: 1em">EXAMPLE: Working as mutex and
counting semaphore <br>
The command sem is an alias for parallel --semaphore.</p>

<p style="margin-top: 1em">A counting semaphore will allow
a given number of jobs to be started in the background. When
the number of jobs are running in the background, GNU sem
will wait for one of these <br>
to complete before starting another command. sem --wait will
wait for all jobs to complete.</p>

<p style="margin-top: 1em">Run 10 jobs concurrently in the
background:</p>

<p style="margin-top: 1em">for i in *.log ; do <br>
echo $i <br>
sem -j10 gzip $i &quot;;&quot; echo done <br>
done <br>
sem --wait</p>

<p style="margin-top: 1em">A mutex is a counting semaphore
allowing only one job to run. This will edit the file myfile
and prepends the file with lines with the numbers 1 to
3.</p>

<p style="margin-top: 1em">seq 3 | parallel sem sed -i -e
&rsquo;i{}&rsquo; myfile</p>

<p style="margin-top: 1em">As myfile can be very big it is
important only one process edits the file at the same
time.</p>

<p style="margin-top: 1em">Name the semaphore to have
multiple different semaphores active at the same time:</p>

<p style="margin-top: 1em">seq 3 | parallel sem --id
mymutex sed -i -e &rsquo;i{}&rsquo; myfile</p>

<p style="margin-top: 1em">EXAMPLE: Mutex for a script <br>
Assume a script is called from cron or from a web service,
but only one instance can be run at a time. With sem and
--shebang-wrap the script can be made to wait for other <br>
instances to finish. Here in bash:</p>

<p style="margin-top: 1em">#!/usr/bin/sem --shebang-wrap -u
--id $0 --fg /bin/bash</p>

<p style="margin-top: 1em">echo This will run <br>
sleep 5 <br>
echo exclusively</p>

<p style="margin-top: 1em">Here perl:</p>

<p style="margin-top: 1em">#!/usr/bin/sem --shebang-wrap -u
--id $0 --fg /usr/bin/perl</p>

<p style="margin-top: 1em">print &quot;This will run
&quot;; <br>
sleep 5; <br>
print &quot;exclusively0;</p>

<p style="margin-top: 1em">Here python:</p>

<p style="margin-top: 1em">#!/usr/local/bin/sem
--shebang-wrap -u --id $0 --fg /usr/bin/python</p>

<p style="margin-top: 1em">import time <br>
print &quot;This will run &quot;; <br>
time.sleep(5) <br>
print &quot;exclusively&quot;;</p>

<p style="margin-top: 1em">EXAMPLE: Start editor with
filenames from stdin (standard input) <br>
You can use GNU parallel to start interactive programs like
emacs or vi:</p>

<p style="margin-top: 1em">cat filelist | parallel --tty -X
emacs <br>
cat filelist | parallel --tty -X vi</p>

<p style="margin-top: 1em">If there are more files than
will fit on a single command line, the editor will be
started again with the remaining files.</p>

<p style="margin-top: 1em">EXAMPLE: Running sudo <br>
sudo requires a password to run a command as root. It caches
the access, so you only need to enter the password again if
you have not used sudo for a while.</p>

<p style="margin-top: 1em">The command:</p>

<p style="margin-top: 1em">parallel sudo echo ::: This is a
bad idea</p>

<p style="margin-top: 1em">is no good, as you would be
prompted for the sudo password for each of the jobs. You can
either do:</p>

<p style="margin-top: 1em">sudo echo This <br>
parallel sudo echo ::: is a good idea</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">sudo parallel echo ::: This is a
good idea</p>

<p style="margin-top: 1em">This way you only have to enter
the sudo password once.</p>

<p style="margin-top: 1em">EXAMPLE: GNU Parallel as queue
system/batch manager <br>
GNU parallel can work as a simple job queue system or batch
manager. The idea is to put the jobs into a file and have
GNU parallel read from that continuously. As GNU parallel
<br>
will stop at end of file we use tail to continue
reading:</p>

<p style="margin-top: 1em">true &gt;jobqueue; tail -n+0 -f
jobqueue | parallel</p>

<p style="margin-top: 1em">To submit your jobs to the
queue:</p>

<p style="margin-top: 1em">echo my_command my_arg &gt;&gt;
jobqueue</p>

<p style="margin-top: 1em">You can of course use -S to
distribute the jobs to remote computers:</p>

<p style="margin-top: 1em">true &gt;jobqueue; tail -n+0 -f
jobqueue | parallel -S ..</p>

<p style="margin-top: 1em">If you keep this running for a
long time, jobqueue will grow. A way of removing the jobs
already run is by making GNU parallel stop when it hits a
special value and then restart. <br>
To use --eof to make GNU parallel exit, tail also needs to
be forced to exit:</p>

<p style="margin-top: 1em">true &gt;jobqueue; <br>
while true; do <br>
tail -n+0 -f jobqueue | <br>
(parallel -E StOpHeRe -S ..; echo GNU Parallel is now done;
<br>
perl -e &rsquo;while(&lt;&gt;){/StOpHeRe/ and last};print
&lt;&gt;&rsquo; jobqueue &gt; j2; <br>
(seq 1000 &gt;&gt; jobqueue &amp;); <br>
echo Done appending dummy data forcing tail to exit) <br>
echo tail exited; <br>
mv j2 jobqueue <br>
done</p>

<p style="margin-top: 1em">In some cases you can run on
more CPUs and computers during the night:</p>

<p style="margin-top: 1em"># Day time <br>
echo 50% &gt; jobfile <br>
cp day_server_list ~/.parallel/sshloginfile <br>
# Night time <br>
echo 100% &gt; jobfile <br>
cp night_server_list ~/.parallel/sshloginfile <br>
tail -n+0 -f jobqueue | parallel --jobs jobfile -S ..</p>

<p style="margin-top: 1em">GNU Parallel discovers if
jobfile or ~/.parallel/sshloginfile changes.</p>

<p style="margin-top: 1em">There is a a small issue when
using GNU parallel as queue system/batch manager: You have
to submit JobSlot number of jobs before they will start, and
after that you can submit <br>
one at a time, and job will start immediately if free slots
are available. Output from the running or completed jobs are
held back and will only be printed when JobSlots more <br>
jobs has been started (unless you use --ungroup or -u, in
which case the output from the jobs are printed
immediately). E.g. if you have 10 jobslots then the output
from the <br>
first completed job will only be printed when job 11 has
started, and the output of second completed job will only be
printed when job 12 has started.</p>

<p style="margin-top: 1em">EXAMPLE: GNU Parallel as dir
processor <br>
If you have a dir in which users drop files that needs to be
processed you can do this on GNU/Linux (If you know what
inotifywait is called on other platforms file a bug
report):</p>

<p style="margin-top: 1em">inotifywait -q -m -r -e MOVED_TO
-e CLOSE_WRITE --format %w%f my_dir | parallel -u echo</p>

<p style="margin-top: 1em">This will run the command echo
on each file put into my_dir or subdirs of my_dir.</p>

<p style="margin-top: 1em">You can of course use -S to
distribute the jobs to remote computers:</p>

<p style="margin-top: 1em">inotifywait -q -m -r -e MOVED_TO
-e CLOSE_WRITE --format %w%f my_dir | parallel -S .. -u
echo</p>

<p style="margin-top: 1em">If the files to be processed are
in a tar file then unpacking one file and processing it
immediately may be faster than first unpacking all files.
Set up the dir processor as <br>
above and unpack into the dir.</p>

<p style="margin-top: 1em">Using GNU Parallel as dir
processor has the same limitations as using GNU Parallel as
queue system/batch manager.</p>

<p style="margin-top: 1em">QUOTING <br>
GNU parallel is very liberal in quoting. You only need to
quote characters that have special meaning in shell:</p>

<p style="margin-top: 1em">( ) $ &lsquo; &rsquo; &quot;
&lt; &gt; ; | <br>
and depending on context these needs to be quoted, too:</p>

<p style="margin-top: 1em">~ &amp; # ! ? space * {</p>

<p style="margin-top: 1em">Therefore most people will never
need more quoting than putting &rsquo;&acute; in front of
the special characters.</p>

<p style="margin-top: 1em">Often you can simply put &acute;
around every &rsquo;:</p>

<p style="margin-top: 1em">perl -ne &rsquo;/^and print
$ARGV,&quot;0&rsquo; file</p>

<p style="margin-top: 1em">can be quoted:</p>

<p style="margin-top: 1em">parallel perl -ne
&acute;&rsquo;/^and print $ARGV,&quot;0&rsquo;&acute; :::
file</p>

<p style="margin-top: 1em">However, when you want to use a
shell variable you need to quote the $-sign. Here is an
example using $PARALLEL_SEQ. This variable is set by GNU
parallel itself, so the <br>
evaluation of the $ must be done by the sub shell started by
GNU parallel:</p>

<p style="margin-top: 1em">seq 10 | parallel -N2 echo
seq:ARALLEL_SEQ arg1:{1} arg2:{2}</p>

<p style="margin-top: 1em">If the variable is set before
GNU parallel starts you can do this:</p>

<p style="margin-top: 1em">VAR=this_is_set_before_starting
<br>
echo test | parallel echo {} $VAR</p>

<p style="margin-top: 1em">Prints: test
this_is_set_before_starting</p>

<p style="margin-top: 1em">It is a little more tricky if
the variable contains more than one space in a row:</p>

<p style="margin-top: 1em">VAR=&quot;two spaces between
each word&quot; <br>
echo test | parallel echo {}
&acute;&quot;$VAR&quot;&acute;</p>

<p style="margin-top: 1em">Prints: test two spaces between
each word</p>

<p style="margin-top: 1em">If the variable should not be
evaluated by the shell starting GNU parallel but be
evaluated by the sub shell started by GNU parallel, then you
need to quote it:</p>

<p style="margin-top: 1em">echo test | parallel
VAR=this_is_set_after_starting ; echo {} AR</p>

<p style="margin-top: 1em">Prints: test
this_is_set_after_starting</p>

<p style="margin-top: 1em">It is a little more tricky if
the variable contains space:</p>

<p style="margin-top: 1em">echo test | parallel
VAR=&rsquo;&quot;two spaces between each word&quot;&rsquo;
echo {} &acute;&quot;$VAR&quot;&acute;</p>

<p style="margin-top: 1em">Prints: test two spaces between
each word</p>

<p style="margin-top: 1em">$$ is the shell variable
containing the process id of the shell. This will print the
process id of the shell running GNU parallel:</p>

<p style="margin-top: 1em">seq 10 | parallel echo $$</p>

<p style="margin-top: 1em">And this will print the process
ids of the sub shells started by GNU parallel.</p>

<p style="margin-top: 1em">seq 10 | parallel echo</p>

<p style="margin-top: 1em">If the special characters should
not be evaluated by the sub shell then you need to protect
it against evaluation from both the shell starting GNU
parallel and the sub shell:</p>

<p style="margin-top: 1em">echo test | parallel echo {}
\AR</p>

<p style="margin-top: 1em">Prints: test $VAR</p>

<p style="margin-top: 1em">GNU parallel can protect against
evaluation by the sub shell by using -q:</p>

<p style="margin-top: 1em">echo test | parallel -q echo {}
AR</p>

<p style="margin-top: 1em">Prints: test $VAR</p>

<p style="margin-top: 1em">This is particularly useful if
you have lots of quoting. If you want to run a perl script
like this:</p>

<p style="margin-top: 1em">perl -ne &rsquo;/^and print
$ARGV,&quot;0&rsquo; file</p>

<p style="margin-top: 1em">It needs to be quoted like one
of these:</p>

<p style="margin-top: 1em">ls | parallel perl -ne
&rsquo;/^\S+\s+\S+&nbsp;and&nbsp;print&nbsp;RGV, <br>
ls | parallel perl -ne &acute;&rsquo;/^and print
$ARGV,&quot;0&rsquo;&acute;</p>

<p style="margin-top: 1em">Notice how spaces, &acute;s,
&quot;&rsquo;s, and $&rsquo;s need to be quoted. GNU
parallel can do the quoting by using option -q:</p>

<p style="margin-top: 1em">ls | parallel -q perl -ne
&rsquo;/^and print $ARGV,&quot;0&rsquo;</p>

<p style="margin-top: 1em">However, this means you cannot
make the sub shell interpret special characters. For example
because of -q this WILL NOT WORK:</p>

<p style="margin-top: 1em">ls *.gz | parallel -q &quot;zcat
{} &gt;{.}&quot; <br>
ls *.gz | parallel -q &quot;zcat {} | bzip2
&gt;{.}.bz2&quot;</p>

<p style="margin-top: 1em">because &gt; and | need to be
interpreted by the sub shell.</p>

<p style="margin-top: 1em">If you get errors like:</p>

<p style="margin-top: 1em">sh: -c: line 0: syntax error
near unexpected token <br>
sh: Syntax error: Unterminated quoted string <br>
sh: -c: line 0: unexpected EOF while looking for matching
&lsquo;&rsquo;&rsquo; <br>
sh: -c: line 1: syntax error: unexpected end of file</p>

<p style="margin-top: 1em">then you might try using -q.</p>

<p style="margin-top: 1em">If you are using bash process
substitution like &lt;(cat foo) then you may try -q and
prepending command with bash -c:</p>

<p style="margin-top: 1em">ls | parallel -q bash -c
&rsquo;wc -c &lt;(echo {})&rsquo;</p>

<p style="margin-top: 1em">Or for substituting output:</p>

<p style="margin-top: 1em">ls | parallel -q bash -c
&rsquo;tar c {} | tee &gt;(gzip &gt;{}.tar.gz) | bzip2
&gt;{}.tar.bz2&rsquo;</p>

<p style="margin-top: 1em">Conclusion: To avoid dealing
with the quoting problems it may be easier just to write a
small script or a function (remember to export -f the
function) and have GNU parallel call <br>
that.</p>

<p style="margin-top: 1em">LIST RUNNING JOBS <br>
If you want a list of the jobs currently running you can
run:</p>

<p style="margin-top: 1em">killall -USR1 parallel</p>

<p style="margin-top: 1em">GNU parallel will then print the
currently running jobs on stderr (standard error).</p>

<p style="margin-top: 1em">COMPLETE RUNNING JOBS BUT DO NOT
START NEW JOBS <br>
If you regret starting a lot of jobs you can simply break
GNU parallel, but if you want to make sure you do not have
half-completed jobs you should send the signal SIGTERM to
GNU <br>
parallel:</p>

<p style="margin-top: 1em">killall -TERM parallel</p>

<p style="margin-top: 1em">This will tell GNU parallel to
not start any new jobs, but wait until the currently running
jobs are finished before exiting.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
$PARALLEL_PID <br>
The environment variable $PARALLEL_PID is set by GNU
parallel and is visible to the jobs started from GNU
parallel. This makes it possible for the jobs to communicate
<br>
directly to GNU parallel. Remember to quote the $, so it
gets evaluated by the correct shell.</p>

<p style="margin-top: 1em">Example: If each of the jobs
tests a solution and one of jobs finds the solution the job
can tell GNU parallel not to start more jobs by: kill -TERM
$PARALLEL_PID. This <br>
only works on the local computer.</p>

<p style="margin-top: 1em">$PARALLEL_SHELL <br>
Use this shell the shell for the commands run by GNU
Parallel:</p>

<p style="margin-top: 1em">&Acirc;&middot; $PARALLEL_SHELL.
If undefined use:</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell that
started GNU Parallel. If that cannot be determined:</p>

<p style="margin-top: 1em">&Acirc;&middot; $SHELL. If
undefined use:</p>

<p style="margin-top: 1em">&Acirc;&middot; /bin/sh</p>

<p style="margin-top: 1em">$PARALLEL_SSH <br>
GNU parallel defaults to using ssh for remote access. This
can be overridden with $PARALLEL_SSH, which again can be
overridden with --ssh. It can also be set on a per <br>
server basis (see --sshlogin).</p>

<p style="margin-top: 1em">$PARALLEL_SEQ <br>
$PARALLEL_SEQ will be set to the sequence number of the job
running. Remember to quote the $, so it gets evaluated by
the correct shell.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">seq 10 | parallel -N2 echo
seq:&rsquo;$&rsquo;PARALLEL_SEQ arg1:{1} arg2:{2}</p>

<p style="margin-top: 1em">$TMPDIR Directory for temporary
files. See: --tmpdir.</p>

<p style="margin-top: 1em">$PARALLEL <br>
The environment variable $PARALLEL will be used as default
options for GNU parallel. If the variable contains special
shell characters (e.g. $, *, or space) then these <br>
need to be to be escaped with .</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">cat list | parallel -j1 -k -v ls
<br>
cat list | parallel -j1 -k -v -S&quot;myssh
user@server&quot; ls</p>

<p style="margin-top: 1em">can be written as:</p>

<p style="margin-top: 1em">cat list |
PARALLEL=&quot;-kvj1&quot; parallel ls <br>
cat list | PARALLEL=&rsquo;-kvj1 -S
myssh&nbsp;user@server&rsquo; parallel echo</p>

<p style="margin-top: 1em">Notice the &nbsp;in the middle
is needed because &rsquo;myssh&rsquo; and
&rsquo;user@server&rsquo; must be one argument.</p>

<p style="margin-top: 1em">DEFAULT PROFILE (CONFIG FILE)
<br>
The global configuration file /etc/parallel/config, followed
by user configuration file ~/.parallel/config (formerly
known as .parallelrc) will be read in turn if they exist.
<br>
Lines starting with &rsquo;#&rsquo; will be ignored. The
format can follow that of the environment variable
$PARALLEL, but it is often easier to simply put each option
on its own line.</p>

<p style="margin-top: 1em">Options on the command line take
precedence, followed by the environment variable $PARALLEL,
user configuration file ~/.parallel/config, and finally the
global configuration file <br>
/etc/parallel/config.</p>

<p style="margin-top: 1em">Note that no file that is read
for options, nor the environment variable $PARALLEL, may
contain retired options such as --tollef.</p>

<p style="margin-top: 1em">PROFILE FILES <br>
If --profile set, GNU parallel will read the profile from
that file rather than the global or user configuration
files. You can have multiple --profiles.</p>

<p style="margin-top: 1em">Example: Profile for running a
command on every sshlogin in ~/.ssh/sshlogins and prepend
the output with the sshlogin:</p>

<p style="margin-top: 1em">echo --tag -S .. --nonall &gt;
~/.parallel/n <br>
parallel -Jn uptime</p>

<p style="margin-top: 1em">Example: Profile for running
every command with -j-1 and nice</p>

<p style="margin-top: 1em">echo -j-1 nice &gt;
~/.parallel/nice_profile <br>
parallel -J nice_profile bzip2 -9 ::: *</p>

<p style="margin-top: 1em">Example: Profile for running a
perl script before every command:</p>

<p style="margin-top: 1em">echo &quot;perl -e &rsquo;=print
, <br>
&gt; ~/.parallel/pre_perl <br>
parallel -J pre_perl echo ::: *</p>

<p style="margin-top: 1em">Note how the $ and &quot; need
to be quoted using .</p>

<p style="margin-top: 1em">Example: Profile for running
distributed jobs with nice on the remote computers:</p>

<p style="margin-top: 1em">echo -S .. nice &gt;
~/.parallel/dist <br>
parallel -J dist --trc {.}.bz2 bzip2 -9 ::: *</p>

<p style="margin-top: 1em">EXIT STATUS <br>
Exit status depends on --halt-on-error if one of these are
used: success=X, success=Y%, fail=Y%.</p>

<p style="margin-top: 1em">0 All jobs ran without error. If
success=X is used: X jobs ran without error. If success=Y%
is used: Y% of the jobs ran without error.</p>

<p style="margin-top: 1em">1-100 Some of the jobs failed.
The exit status gives the number of failed jobs. If Y% is
used the exit status is the percentage of jobs that
failed.</p>

<p style="margin-top: 1em">101 More than 100 jobs
failed.</p>

<p style="margin-top: 1em">255 Other error.</p>

<p style="margin-top: 1em">-1 (In joblog and SQL table)
<br>
Killed by Ctrl-C, timeout, not enough memory or similar.</p>

<p style="margin-top: 1em">-2 (In joblog and SQL table)
<br>
$job-&gt;skip() was called in {= =}.</p>

<p style="margin-top: 1em">-1000 (In SQL table) <br>
Job is ready to run (set by --sqlmaster).</p>

<p style="margin-top: 1em">-1220 (In SQL table) <br>
Job is taken by worker (set by --sqlworker).</p>

<p style="margin-top: 1em">If fail=1 is used, the exit
status will be the exit status of the failing job.</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN GNU Parallel
AND ALTERNATIVES <br>
There are a lot programs with some of the functionality of
GNU parallel. GNU parallel strives to include the best of
the functionality without sacrificing ease of use.</p>

<p style="margin-top: 1em">SUMMARY TABLE <br>
The following features are in some of the comparable
tools:</p>

<p style="margin-top: 1em">Inputs <br>
I1. Arguments can be read from stdin <br>
I2. Arguments can be read from a file <br>
I3. Arguments can be read from multiple files <br>
I4. Arguments can be read from command line <br>
I5. Arguments can be read from a table <br>
I6. Arguments can be read from the same file using #!
(shebang) <br>
I7. Line oriented input as default (Quoting of special chars
not needed)</p>

<p style="margin-top: 1em">Manipulation of input <br>
M1. Composed command <br>
M2. Multiple arguments can fill up an execution line <br>
M3. Arguments can be put anywhere in the execution line <br>
M4. Multiple arguments can be put anywhere in the execution
line <br>
M5. Arguments can be replaced with context <br>
M6. Input can be treated as the complete command line</p>

<p style="margin-top: 1em">Outputs <br>
O1. Grouping output so output from different jobs do not mix
<br>
O2. Send stderr (standard error) to stderr (standard error)
<br>
O3. Send stdout (standard output) to stdout (standard
output) <br>
O4. Order of output can be same as order of input <br>
O5. Stdout only contains stdout (standard output) from the
command <br>
O6. Stderr only contains stderr (standard error) from the
command</p>

<p style="margin-top: 1em">Execution <br>
E1. Running jobs in parallel <br>
E2. List running jobs <br>
E3. Finish running jobs, but do not start new jobs <br>
E4. Number of running jobs can depend on number of cpus <br>
E5. Finish running jobs, but do not start new jobs after
first failure <br>
E6. Number of running jobs can be adjusted while running</p>

<p style="margin-top: 1em">Remote execution <br>
R1. Jobs can be run on remote computers <br>
R2. Basefiles can be transferred <br>
R3. Argument files can be transferred <br>
R4. Result files can be transferred <br>
R5. Cleanup of transferred files <br>
R6. No config files needed <br>
R7. Do not run more than SSHD&rsquo;s MaxStartups can handle
<br>
R8. Configurable SSH command <br>
R9. Retry if connection breaks occasionally</p>

<p style="margin-top: 1em">Semaphore <br>
S1. Possibility to work as a mutex <br>
S2. Possibility to work as a counting semaphore</p>

<p style="margin-top: 1em">Legend <br>
- = no <br>
x = not applicable <br>
ID = yes</p>

<p style="margin-top: 1em">As every new version of the
programs are not tested the table may be outdated. Please
file a bug-report if you find errors (See REPORTING
BUGS).</p>

<p style="margin-top: 1em">parallel: I1 I2 I3 I4 I5 I6 I7
M1 M2 M3 M4 M5 M6 O1 O2 O3 O4 O5 O6 E1 E2 E3 E4 E5 E6 R1 R2
R3 R4 R5 R6 R7 R8 R9 S1 S2</p>

<p style="margin-top: 1em">xargs: I1 I2 - - - - - - M2 M3 -
- - - O2 O3 - O5 O6 E1 - - - - - - - - - - x - - - - -</p>

<p style="margin-top: 1em">find -exec: - - - x - x - - M2
M3 - - - - - O2 O3 O4 O5 O6 - - - - - - - - - - - - - - - -
x x</p>

<p style="margin-top: 1em">make -j: - - - - - - - - - - - -
- O1 O2 O3 - x O6 E1 - - - E5 - - - - - - - - - - - -</p>

<p style="margin-top: 1em">ppss: I1 I2 - - - - I7 M1 - M3 -
- M6 O1 - - x - - E1 E2 ?E3 E4 - - R1 R2 R3 R4 - - ?R7 ? ? -
-</p>

<p style="margin-top: 1em">pexec: I1 I2 - I4 I5 - - M1 - M3
- - M6 O1 O2 O3 - O5 O6 E1 - - E4 - E6 R1 - - - - R6 - - -
S1 -</p>

<p style="margin-top: 1em">xjobs, prll, dxargs,
mdm/middelman, xapply, paexec, ladon, jobflow, ClusterSSH:
TODO - Please file a bug-report if you know what features
they support (See REPORTING BUGS).</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN xargs AND
GNU Parallel <br>
xargs offers some of the same possibilities as GNU
parallel.</p>

<p style="margin-top: 1em">xargs deals badly with special
characters (such as space, &rsquo; and &quot;). To see the
problem try this:</p>

<p style="margin-top: 1em">touch important_file <br>
touch &rsquo;not important_file&rsquo; <br>
ls not* | xargs rm <br>
mkdir -p &quot;My brother&rsquo;s 12 <br>
ls | xargs rmdir <br>
touch &rsquo;c:432 <br>
echo &rsquo;c:768</p>

<p style="margin-top: 1em">You can specify -0, but many
input generators are not optimized for using NUL as
separator but are optimized for newline as separator. E.g
head, tail, awk, ls, echo, sed, tar -v, <br>
perl (-0 and instead of 0, locate (requires using -0), find
(requires using -print0), grep (requires user to use -z or
-Z), sort (requires using -z).</p>

<p style="margin-top: 1em">GNU parallel&rsquo;s newline
separation can be emulated with:</p>

<p style="margin-top: 1em">cat | xargs -d &quot;0 -n1
command</p>

<p style="margin-top: 1em">xargs can run a given number of
jobs in parallel, but has no support for running
number-of-cpu-cores jobs in parallel.</p>

<p style="margin-top: 1em">xargs has no support for
grouping the output, therefore output may run together, e.g.
the first half of a line is from one process and the last
half of the line is from another <br>
process. The example Parallel grep cannot be done reliably
with xargs because of this. To see this in action try:</p>

<p style="margin-top: 1em">parallel perl -e &rsquo;= <br>
::: a b c d e f <br>
ls -l a b c d e f <br>
parallel -kP4 -n1 grep 1 &gt; out.par ::: a b c d e f <br>
echo a b c d e f | xargs -P4 -n1 grep 1 &gt; out.xargs-unbuf
<br>
echo a b c d e f | xargs -P4 -n1 grep --line-buffered 1 &gt;
out.xargs-linebuf <br>
echo a b c d e f | xargs -n1 grep 1 &gt; out.xargs-serial
<br>
ls -l out* <br>
md5sum out*</p>

<p style="margin-top: 1em">xargs has no support for keeping
the order of the output, therefore if running jobs in
parallel using xargs the output of the second job cannot be
postponed till the first job is <br>
done.</p>

<p style="margin-top: 1em">xargs has no support for running
jobs on remote computers.</p>

<p style="margin-top: 1em">xargs has no support for context
replace, so you will have to create the arguments.</p>

<p style="margin-top: 1em">If you use a replace string in
xargs (-I) you can not force xargs to use more than one
argument.</p>

<p style="margin-top: 1em">Quoting in xargs works like -q
in GNU parallel. This means composed commands and
redirection require using bash -c.</p>

<p style="margin-top: 1em">ls | parallel &quot;wc {}
&gt;{}.wc&quot; <br>
ls | parallel &quot;echo {}; ls {}|wc&quot;</p>

<p style="margin-top: 1em">becomes (assuming you have 8
cores)</p>

<p style="margin-top: 1em">ls | xargs -d &quot;0 -P8 -I {}
bash -c &quot;wc {} &gt;{}.wc&quot; <br>
ls | xargs -d &quot;0 -P8 -I {} bash -c &quot;echo {}; ls
{}|wc&quot;</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN find -exec
AND GNU Parallel <br>
find -exec offer some of the same possibilities as GNU
parallel.</p>

<p style="margin-top: 1em">find -exec only works on files.
So processing other input (such as hosts or URLs) will
require creating these inputs as files. find -exec has no
support for running commands in <br>
parallel.</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN make -j AND
GNU Parallel <br>
make -j can run jobs in parallel, but requires a crafted
Makefile to do this. That results in extra quoting to get
filename containing newline to work correctly.</p>

<p style="margin-top: 1em">make -j computes a dependency
graph before running jobs. Jobs run by GNU parallel does not
depend on eachother.</p>

<p style="margin-top: 1em">(Very early versions of GNU
parallel were coincidently implemented using make -j).</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN ppss AND GNU
Parallel <br>
ppss is also a tool for running jobs in parallel.</p>

<p style="margin-top: 1em">The output of ppss is status
information and thus not useful for using as input for
another command. The output from the jobs are put into
files.</p>

<p style="margin-top: 1em">The argument replace string
($ITEM) cannot be changed. Arguments must be quoted - thus
arguments containing special characters (space
&rsquo;&quot;&amp;!*) may cause problems. More than one <br>
argument is not supported. File names containing newlines
are not processed correctly. When reading input from a file
null cannot be used as a terminator. ppss needs to read the
<br>
whole input file before starting any jobs.</p>

<p style="margin-top: 1em">Output and status information is
stored in ppss_dir and thus requires cleanup when completed.
If the dir is not removed before running ppss again it may
cause nothing to happen <br>
as ppss thinks the task is already done. GNU parallel will
normally not need cleaning up if running locally and will
only need cleaning up if stopped abnormally and running <br>
remote (--cleanup may not complete if stopped abnormally).
The example Parallel grep would require extra postprocessing
if written using ppss.</p>

<p style="margin-top: 1em">For remote systems PPSS requires
3 steps: config, deploy, and start. GNU parallel only
requires one step.</p>

<p style="margin-top: 1em">EXAMPLES FROM ppss MANUAL</p>

<p style="margin-top: 1em">Here are the examples from
ppss&rsquo;s manual page with the equivalent using GNU
parallel:</p>

<p style="margin-top: 1em">1 ./ppss.sh standalone -d
/path/to/files -c &rsquo;gzip &rsquo;</p>

<p style="margin-top: 1em">1 find /path/to/files -type f |
parallel gzip</p>

<p style="margin-top: 1em">2 ./ppss.sh standalone -d
/path/to/files -c &rsquo;cp &quot;$ITEM&quot;
/destination/dir &rsquo;</p>

<p style="margin-top: 1em">2 find /path/to/files -type f |
parallel cp {} /destination/dir</p>

<p style="margin-top: 1em">3 ./ppss.sh standalone -f
list-of-urls.txt -c &rsquo;wget -q &rsquo;</p>

<p style="margin-top: 1em">3 parallel -a list-of-urls.txt
wget -q</p>

<p style="margin-top: 1em">4 ./ppss.sh standalone -f
list-of-urls.txt -c &rsquo;wget -q
&quot;$ITEM&quot;&rsquo;</p>

<p style="margin-top: 1em">4 parallel -a list-of-urls.txt
wget -q {}</p>

<p style="margin-top: 1em">5 ./ppss config -C config.cfg -c
&rsquo;encode.sh &rsquo; -d /source/dir -m 192.168.1.100 -u
ppss -k ppss-key.key -S ./encode.sh -n nodes.txt -o
/some/output/dir --upload --download ; ./ppss <br>
deploy -C config.cfg ; ./ppss start -C config</p>

<p style="margin-top: 1em">5 # parallel does not use
configs. If you want a different username put it in
nodes.txt: user@hostname</p>

<p style="margin-top: 1em">5 find source/dir -type f |
parallel --sshloginfile nodes.txt --trc {.}.mp3 lame -a {}
-o {.}.mp3 --preset standard --quiet</p>

<p style="margin-top: 1em">6 ./ppss stop -C config.cfg</p>

<p style="margin-top: 1em">6 killall -TERM parallel</p>

<p style="margin-top: 1em">7 ./ppss pause -C config.cfg</p>

<p style="margin-top: 1em">7 Press: CTRL-Z or killall
-SIGTSTP parallel</p>

<p style="margin-top: 1em">8 ./ppss continue -C
config.cfg</p>

<p style="margin-top: 1em">8 Enter: fg or killall -SIGCONT
parallel</p>

<p style="margin-top: 1em">9 ./ppss.sh status -C
config.cfg</p>

<p style="margin-top: 1em">9 killall -SIGUSR2 parallel</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN pexec AND
GNU Parallel <br>
pexec is also a tool for running jobs in parallel.</p>

<p style="margin-top: 1em">EXAMPLES FROM pexec MANUAL</p>

<p style="margin-top: 1em">Here are the examples from
pexec&rsquo;s info page with the equivalent using GNU
parallel:</p>

<p style="margin-top: 1em">1 pexec -o sqrt-%s.dat -p
&quot;$(seq 10)&quot; -e NUM -n 4 -c -- &rsquo;echo
&quot;scale=10000;sqrt($NUM)&quot; | bc&rsquo;</p>

<p style="margin-top: 1em">1 seq 10 | parallel -j4
&rsquo;echo &quot;scale=10000;sqrt({})&quot; | bc &gt;
sqrt-{}.dat&rsquo;</p>

<p style="margin-top: 1em">2 pexec -p &quot;$(ls
myfiles*.ext)&quot; -i %s -o %s.sort -- sort</p>

<p style="margin-top: 1em">2 ls myfiles*.ext | parallel
sort {} &quot;&gt;{}.sort&quot;</p>

<p style="margin-top: 1em">3 pexec -f image.list -n auto -e
B -u star.log -c -- &rsquo;fistar $B.fits -f 100 -F
id,x,y,flux -o $B.star&rsquo;</p>

<p style="margin-top: 1em">3 parallel -a image.list
&rsquo;fistar {}.fits -f 100 -F id,x,y,flux -o
{}.star&rsquo; 2&gt;star.log</p>

<p style="margin-top: 1em">4 pexec -r *.png -e IMG -c -o -
-- &rsquo;convert $IMG ${IMG%.png}.jpeg ; &quot;echo $IMG:
done&quot;&rsquo;</p>

<p style="margin-top: 1em">4 ls *.png | parallel
&rsquo;convert {} {.}.jpeg; echo {}: done&rsquo;</p>

<p style="margin-top: 1em">5 pexec -r *.png -i %s -o %s.jpg
-c &rsquo;pngtopnm | pnmtojpeg&rsquo;</p>

<p style="margin-top: 1em">5 ls *.png | parallel
&rsquo;pngtopnm &lt; {} | pnmtojpeg &gt; {}.jpg&rsquo;</p>

<p style="margin-top: 1em">6 for p in *.png ; do echo
${p%.png} ; done | pexec -f - -i %s.png -o %s.jpg -c
&rsquo;pngtopnm | pnmtojpeg&rsquo;</p>

<p style="margin-top: 1em">6 ls *.png | parallel
&rsquo;pngtopnm &lt; {} | pnmtojpeg &gt; {.}.jpg&rsquo;</p>

<p style="margin-top: 1em">7 LIST=$(for p in *.png ; do
echo ${p%.png} ; done) <br>
pexec -r $LIST -i %s.png -o %s.jpg -c &rsquo;pngtopnm |
pnmtojpeg&rsquo;</p>

<p style="margin-top: 1em">7 ls *.png | parallel
&rsquo;pngtopnm &lt; {} | pnmtojpeg &gt; {.}.jpg&rsquo;</p>

<p style="margin-top: 1em">8 pexec -n 8 -r *.jpg -y unix -e
IMG -c &rsquo;pexec -j -m blockread -d $IMG | jpegtopnm |
pnmscale 0.5 | pnmtojpeg | pexec -j -m blockwrite -s
th_$IMG&rsquo;</p>

<p style="margin-top: 1em">8 Combining GNU parallel and GNU
sem.</p>

<p style="margin-top: 1em">8 ls *jpg | parallel -j8
&rsquo;sem --id blockread cat {} | jpegtopnm |&rsquo;
&rsquo;pnmscale 0.5 | pnmtojpeg | sem --id blockwrite cat
&gt; th_{}&rsquo;</p>

<p style="margin-top: 1em">8 If reading and writing is done
to the same disk, this may be faster as only one process
will be either reading or writing:</p>

<p style="margin-top: 1em">8 ls *jpg | parallel -j8
&rsquo;sem --id diskio cat {} | jpegtopnm |&rsquo;
&rsquo;pnmscale 0.5 | pnmtojpeg | sem --id diskio cat &gt;
th_{}&rsquo;</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN xjobs AND
GNU Parallel <br>
xjobs is also a tool for running jobs in parallel. It only
supports running jobs on your local computer.</p>

<p style="margin-top: 1em">xjobs deals badly with special
characters just like xargs. See the section DIFFERENCES
BETWEEN xargs AND GNU Parallel.</p>

<p style="margin-top: 1em">Here are the examples from
xjobs&rsquo;s man page with the equivalent using GNU
parallel:</p>

<p style="margin-top: 1em">1 ls -1 *.zip | xjobs unzip</p>

<p style="margin-top: 1em">1 ls *.zip | parallel unzip</p>

<p style="margin-top: 1em">2 ls -1 *.zip | xjobs -n
unzip</p>

<p style="margin-top: 1em">2 ls *.zip | parallel unzip
&gt;/dev/null</p>

<p style="margin-top: 1em">3 find . -name
&rsquo;*.bak&rsquo; | xjobs gzip</p>

<p style="margin-top: 1em">3 find . -name
&rsquo;*.bak&rsquo; | parallel gzip</p>

<p style="margin-top: 1em">4 ls -1 *.jar | sed &rsquo;s//1
&gt; 1.idx/&rsquo; | xjobs jar tf</p>

<p style="margin-top: 1em">4 ls *.jar | parallel jar tf {}
&rsquo;&gt;&rsquo; {}.idx</p>

<p style="margin-top: 1em">5 xjobs -s script</p>

<p style="margin-top: 1em">5 cat script | parallel</p>

<p style="margin-top: 1em">6 mkfifo /var/run/my_named_pipe;
xjobs -s /var/run/my_named_pipe &amp; echo unzip 1.zip
&gt;&gt; /var/run/my_named_pipe; echo tar cf
/backup/myhome.tar /home/me &gt;&gt;
/var/run/my_named_pipe</p>

<p style="margin-top: 1em">6 mkfifo /var/run/my_named_pipe;
cat /var/run/my_named_pipe | parallel &amp; echo unzip 1.zip
&gt;&gt; /var/run/my_named_pipe; echo tar cf
/backup/myhome.tar /home/me &gt;&gt; <br>
/var/run/my_named_pipe</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN prll AND GNU
Parallel <br>
prll is also a tool for running jobs in parallel. It does
not support running jobs on remote computers.</p>

<p style="margin-top: 1em">prll encourages using BASH
aliases and BASH functions instead of scripts. GNU parallel
supports scripts directly, functions if they are exported
using export -f, and aliases if <br>
using env_parallel described earlier.</p>

<p style="margin-top: 1em">prll generates a lot of status
information on stderr (standard error) which makes it harder
to use the stderr (standard error) output of the job
directly as input for another <br>
program.</p>

<p style="margin-top: 1em">Here is the example from
prll&rsquo;s man page with the equivalent using GNU
parallel:</p>

<p style="margin-top: 1em">prll -s &rsquo;mogrify -flip
$1&rsquo; *.jpg <br>
parallel mogrify -flip ::: *.jpg</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN dxargs AND
GNU Parallel <br>
dxargs is also a tool for running jobs in parallel.</p>

<p style="margin-top: 1em">dxargs does not deal well with
more simultaneous jobs than SSHD&rsquo;s MaxStartups. dxargs
is only built for remote run jobs, but does not support
transferring of files.</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN
mdm/middleman AND GNU Parallel <br>
middleman(mdm) is also a tool for running jobs in
parallel.</p>

<p style="margin-top: 1em">Here are the shellscripts of
http://mdm.berlios.de/usage.html ported to GNU parallel:</p>

<p style="margin-top: 1em">seq 19 | parallel buffon -o - |
sort -n &gt; result <br>
cat files | parallel cmd <br>
find dir -execdir sem cmd {} ;</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN xapply AND
GNU Parallel <br>
xapply can run jobs in parallel on the local computer.</p>

<p style="margin-top: 1em">Here are the examples from
xapply&rsquo;s man page with the equivalent using GNU
parallel:</p>

<p style="margin-top: 1em">1 xapply &rsquo;(cd %1
&amp;&amp; make all)&rsquo; */</p>

<p style="margin-top: 1em">1 parallel &rsquo;cd {}
&amp;&amp; make all&rsquo; ::: */</p>

<p style="margin-top: 1em">2 xapply -f &rsquo;diff %1
../version5/%1&rsquo; manifest | more</p>

<p style="margin-top: 1em">2 parallel diff {}
../version5/{} &lt; manifest | more</p>

<p style="margin-top: 1em">3 xapply -p/dev/null -f
&rsquo;diff %1 %2&rsquo; manifest1 checklist1</p>

<p style="margin-top: 1em">3 parallel --xapply diff {1} {2}
:::: manifest1 checklist1</p>

<p style="margin-top: 1em">4 xapply &rsquo;indent&rsquo;
*.c</p>

<p style="margin-top: 1em">4 parallel indent ::: *.c</p>

<p style="margin-top: 1em">5 find ~ksb/bin -type f ! -perm
-111 -print | xapply -f -v &rsquo;chmod a+x&rsquo; -</p>

<p style="margin-top: 1em">5 find ~ksb/bin -type f ! -perm
-111 -print | parallel -v chmod a+x</p>

<p style="margin-top: 1em">6 find */ -... | fmt 960 1024 |
xapply -f -i /dev/tty &rsquo;vi&rsquo; -</p>

<p style="margin-top: 1em">6 sh &lt;(find */ -... |
parallel -s 1024 echo vi)</p>

<p style="margin-top: 1em">6 find */ -... | parallel -s
1024 -Xuj1 vi</p>

<p style="margin-top: 1em">7 find ... | xapply -f -5 -i
/dev/tty &rsquo;vi&rsquo; - - - - -</p>

<p style="margin-top: 1em">7 sh &lt;(find ... |parallel -n5
echo vi)</p>

<p style="margin-top: 1em">7 find ... |parallel -n5 -uj1
vi</p>

<p style="margin-top: 1em">8 xapply -fn &quot;&quot;
/etc/passwd</p>

<p style="margin-top: 1em">8 parallel -k echo &lt;
/etc/passwd</p>

<p style="margin-top: 1em">9 tr &rsquo;:&rsquo; &rsquo;
12&rsquo; &lt; /etc/passwd | xapply -7 -nf &rsquo;chown %1
%6&rsquo; - - - - - - -</p>

<p style="margin-top: 1em">9 tr &rsquo;:&rsquo; &rsquo;
12&rsquo; &lt; /etc/passwd | parallel -N7 chown {1} {6}</p>

<p style="margin-top: 1em">10 xapply &rsquo;[ -d %1/RCS ]
|| echo %1&rsquo; */</p>

<p style="margin-top: 1em">10 parallel &rsquo;[ -d {}/RCS ]
|| echo {}&rsquo; ::: */</p>

<p style="margin-top: 1em">11 xapply -f &rsquo;[ -f %1 ]
&amp;&amp; echo %1&rsquo; List | ...</p>

<p style="margin-top: 1em">11 parallel &rsquo;[ -f {} ]
&amp;&amp; echo {}&rsquo; &lt; List | ...</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN AIX apply
AND GNU Parallel <br>
apply can build command lines based on a template and
arguments - very much like GNU parallel. apply does not run
jobs in parallel. apply does not use an argument separator
(like <br>
:::); instead the template must be the first argument.</p>

<p style="margin-top: 1em">Here are the examples from
https://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.cmds1/apply.htm</p>

<p style="margin-top: 1em">1. To obtain results similar to
those of the ls command, enter:</p>

<p style="margin-top: 1em">apply echo * <br>
parallel echo ::: *</p>

<p style="margin-top: 1em">2. To compare the file named a1
to the file named b1, and the file named a2 to the file
named b2, enter:</p>

<p style="margin-top: 1em">apply -2 cmp a1 b1 a2 b2 <br>
parallel -N2 cmp ::: a1 b1 a2 b2</p>

<p style="margin-top: 1em">3. To run the who command five
times, enter:</p>

<p style="margin-top: 1em">apply -0 who 1 2 3 4 5 <br>
parallel -N0 who ::: 1 2 3 4 5</p>

<p style="margin-top: 1em">4. To link all files in the
current directory to the directory /usr/joe, enter:</p>

<p style="margin-top: 1em">apply &rsquo;ln %1
/usr/joe&rsquo; * <br>
parallel ln {} /usr/joe ::: *</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN paexec AND
GNU Parallel <br>
paexec can run jobs in parallel on both the local and remote
computers.</p>

<p style="margin-top: 1em">paexec requires commands to
print a blank line as the last output. This means you will
have to write a wrapper for most programs.</p>

<p style="margin-top: 1em">paexec has a job dependency
facility so a job can depend on another job to be executed
successfully. Sort of a poor-man&rsquo;s make.</p>

<p style="margin-top: 1em">Here are the examples from
paexec&rsquo;s example catalog with the equivalent using GNU
parallel:</p>

<p style="margin-top: 1em">1_div_X_run: <br>
../../paexec -s -l -c
&quot;&lsquo;pwd&lsquo;/1_div_X_cmd&quot; -n +1 &lt;&lt;EOF
[...] <br>
parallel echo {} &rsquo;|&rsquo;
&lsquo;pwd&lsquo;/1_div_X_cmd &lt;&lt;EOF [...]</p>

<p style="margin-top: 1em">all_substr_run: <br>
../../paexec -lp -c
&quot;&lsquo;pwd&lsquo;/all_substr_cmd&quot; -n +3
&lt;&lt;EOF [...] <br>
parallel echo {} &rsquo;|&rsquo;
&lsquo;pwd&lsquo;/all_substr_cmd &lt;&lt;EOF [...]</p>

<p style="margin-top: 1em">cc_wrapper_run: <br>
../../paexec -c &quot;env CC=gcc CFLAGS=-O2
&lsquo;pwd&lsquo;/cc_wrapper_cmd&quot; -n &rsquo;host1
host2&rsquo; -t &rsquo;/usr/bin/ssh -x&rsquo; &lt;&lt;EOF
[...] <br>
parallel echo {} &rsquo;|&rsquo; &quot;env CC=gcc CFLAGS=-O2
&lsquo;pwd&lsquo;/cc_wrapper_cmd&quot; -S host1,host2
&lt;&lt;EOF [...] <br>
# This is not exactly the same, but avoids the wrapper <br>
parallel gcc -O2 -c -o {.}.o {} -S host1,host2 &lt;&lt;EOF
[...]</p>

<p style="margin-top: 1em">toupper_run: <br>
../../paexec -lp -c
&quot;&lsquo;pwd&lsquo;/toupper_cmd&quot; -n +10 &lt;&lt;EOF
[...] <br>
parallel echo {} &rsquo;|&rsquo; ./toupper_cmd &lt;&lt;EOF
[...] <br>
# Without the wrapper: <br>
parallel echo {} &rsquo;| awk {print&nbsp;toupper}&rsquo;
&lt;&lt;EOF [...]</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN map AND GNU
Parallel <br>
map sees it as a feature to have less features and in doing
so it also handles corner cases incorrectly. A lot of GNU
parallel&rsquo;s code is to handle corner cases correctly on
every <br>
platform, so you will not get a nasty surprise if a user for
example saves a file called: My brother&rsquo;s 12&quot;
records.txt</p>

<p style="margin-top: 1em">map&rsquo;s example showing how
to deal with special characters fails on special
characters:</p>

<p style="margin-top: 1em">echo &quot;The Cure&quot; &gt;
My&nbsp;brother&acute;s&nbsp;12</p>

<p style="margin-top: 1em">ls | map &rsquo;echo -n
&lsquo;gzip &lt; &quot;%&quot; | wc -c&lsquo;; echo -n
&rsquo;*100/&rsquo;; wc -c &lt; &quot;%&quot;&rsquo; |
bc</p>

<p style="margin-top: 1em">It works with GNU parallel:</p>

<p style="margin-top: 1em">ls | parallel &rsquo;echo -n
&lsquo;gzip &lt; {} | wc -c&lsquo;; echo -n
&rsquo;*100/&rsquo;; wc -c &lt; {}&rsquo; | bc</p>

<p style="margin-top: 1em">And you can even get the file
name prepended:</p>

<p style="margin-top: 1em">ls | parallel --tag &rsquo;(echo
-n &lsquo;gzip &lt; {} | wc -c&lsquo;&rsquo;*100/&rsquo;; wc
-c &lt; {}) | bc&rsquo;</p>

<p style="margin-top: 1em">map has no support for grouping.
So this gives the wrong results without any warnings:</p>

<p style="margin-top: 1em">parallel perl -e &rsquo;= <br>
::: a b c d e f <br>
ls -l a b c d e f <br>
parallel -kP4 -n1 grep 1 &gt; out.par ::: a b c d e f <br>
map -p 4 &rsquo;grep 1&rsquo; a b c d e f &gt; out.map-unbuf
<br>
map -p 4 &rsquo;grep --line-buffered 1&rsquo; a b c d e f
&gt; out.map-linebuf <br>
map -p 1 &rsquo;grep --line-buffered 1&rsquo; a b c d e f
&gt; out.map-serial <br>
ls -l out* <br>
md5sum out*</p>

<p style="margin-top: 1em">The documentation shows a
workaround, but not only does that mix stdout (standard
output) with stderr (standard error) it also fails
completely for certain jobs (and may even be <br>
considered less readable):</p>

<p style="margin-top: 1em">parallel echo -n {} ::: 1 2
3</p>

<p style="margin-top: 1em">map -p 4 &rsquo;echo -n %
2&gt;&amp;1 | sed -e &quot;s/^/$$:/&quot;&rsquo; 1 2 3 |
sort | cut -f2- -d:</p>

<p style="margin-top: 1em">maps replacement strings (% %D
%B %E) can be simulated in GNU parallel by putting this in
~/.parallel/config:</p>

<p style="margin-top: 1em">--rpl &rsquo;%&rsquo; <br>
--rpl &rsquo;%D $_=::shell_quote(::dirname($_));&rsquo; <br>
--rpl &rsquo;%B s:.*/::;s:.[^/.]+$::;&rsquo; <br>
--rpl &rsquo;%E s:.*.::&rsquo;</p>

<p style="margin-top: 1em">map cannot handle bundled
options: map -vp 0 echo this fails</p>

<p style="margin-top: 1em">map does not have an argument
separator on the command line, but uses the first argument
as command. This makes quoting harder which again may affect
readability. Compare:</p>

<p style="margin-top: 1em">map -p 2
perl\&nbsp;-ne\&nbsp;\&acute;/^\\S+\\s+\\S+\\&nbsp;and\&nbsp;print\&nbsp;\RGV,\</p>

<p style="margin-top: 1em">parallel -q perl -ne
&rsquo;/^and print $ARGV,&quot;0&rsquo; ::: *</p>

<p style="margin-top: 1em">map can do multiple arguments
with context replace, but not without context replace:</p>

<p style="margin-top: 1em">parallel --xargs echo
&rsquo;BEGIN{&rsquo;{}&rsquo;}END&rsquo; ::: 1 2 3</p>

<p style="margin-top: 1em">map does not set exit value
according to whether one of the jobs failed:</p>

<p style="margin-top: 1em">parallel false ::: 1 || echo Job
failed</p>

<p style="margin-top: 1em">map false 1 || echo Never
run</p>

<p style="margin-top: 1em">map requires Perl v5.10.0 making
it harder to use on old systems.</p>

<p style="margin-top: 1em">map has no way of using % in the
command (GNU Parallel has -I to specify another replacement
string than {}).</p>

<p style="margin-top: 1em">By design map is option
incompatible with xargs, it does not have remote job
execution, a structured way of saving results, multiple
input sources, progress indicator, <br>
configurable record delimiter (only field delimiter),
logging of jobs run with possibility to resume, keeping the
output in the same order as input, --pipe processing, and
<br>
dynamically timeouts.</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN ladon AND
GNU Parallel <br>
ladon can run multiple jobs on files in parallel.</p>

<p style="margin-top: 1em">ladon only works on files and
the only way to specify files is using a quoted glob string
(such as jpg). It is not possible to list the files
manually.</p>

<p style="margin-top: 1em">As replacement strings it uses
FULLPATH DIRNAME BASENAME EXT RELDIR RELPATH</p>

<p style="margin-top: 1em">These can be simulated using GNU
parallel by putting this in ~/.parallel/config:</p>

<p style="margin-top: 1em">--rpl &rsquo;FULLPATH
$_=::shell_quote($_);chomp($_=qx{readlink -f $_});&rsquo;
<br>
--rpl &rsquo;DIRNAME
$_=::shell_quote(::dirname($_));chomp($_=qx{readlink -f
$_});&rsquo; <br>
--rpl &rsquo;BASENAME s:.*/::;s:.[^/.]+$::;&rsquo; <br>
--rpl &rsquo;EXT s:.*.::&rsquo; <br>
--rpl &rsquo;RELDIR
$_=::shell_quote($_);chomp(($_,$c)=qx{readlink -f
$_;pwd});s:Q$c/ :;$_=::dirname($_);&rsquo; <br>
--rpl &rsquo;RELPATH
$_=::shell_quote($_);chomp(($_,$c)=qx{readlink -f
$_;pwd});s:Q$c/ :;&rsquo;</p>

<p style="margin-top: 1em">ladon deals badly with filenames
containing &quot; and newline, and it fails for output
larger than 200k:</p>

<p style="margin-top: 1em">ladon &rsquo;*&rsquo; -- seq
36000 | wc</p>

<p style="margin-top: 1em">EXAMPLES FROM ladon MANUAL</p>

<p style="margin-top: 1em">It is assumed that the
&rsquo;--rpl&rsquo;s above are put in ~/.parallel/config and
that it is run under a shell that supports &rsquo;**&rsquo;
globbing (such as zsh):</p>

<p style="margin-top: 1em">1 ladon &quot;**/*.txt&quot; --
echo RELPATH</p>

<p style="margin-top: 1em">1 parallel echo RELPATH :::
**/*.txt</p>

<p style="margin-top: 1em">2 ladon
&quot;~/Documents/**/*.pdf&quot; -- shasum FULLPATH
&gt;hashes.txt</p>

<p style="margin-top: 1em">2 parallel shasum FULLPATH :::
~/Documents/**/*.pdf &gt;hashes.txt</p>

<p style="margin-top: 1em">3 ladon -m thumbs/RELDIR
&quot;**/*.jpg&quot; -- convert FULLPATH -thumbnail 100x100^
-gravity center -extent 100x100 thumbs/RELPATH</p>

<p style="margin-top: 1em">3 parallel mkdir -p
thumbs/RELDIR; convert FULLPATH -thumbnail 100x100^ -gravity
center -extent 100x100 thumbs/RELPATH ::: **/*.jpg</p>

<p style="margin-top: 1em">4 ladon
&quot;~/Music/*.wav&quot; -- lame -V 2 FULLPATH
DIRNAME/BASENAME.mp3</p>

<p style="margin-top: 1em">4 parallel lame -V 2 FULLPATH
DIRNAME/BASENAME.mp3 ::: ~/Music/*.wav</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN jobflow AND
GNU Parallel <br>
jobflow can run multiple jobs in parallel.</p>

<p style="margin-top: 1em">Just like xargs output from
jobflow jobs running in parallel mix together by default.
jobflow can buffer into files (placed in /run/shm), but
these are not cleaned up - not even <br>
if jobflow dies unexpectently. If the total output is big
(in the order of RAM+swap) it can cause the system to run
out of memory.</p>

<p style="margin-top: 1em">jobflow gives no error if the
command is unknown, and like xargs redirection requires
wrapping with bash -c.</p>

<p style="margin-top: 1em">jobflow makes it possible to set
ressource limits on the running jobs. This can be emulated
by GNU parallel using bash&rsquo;s ulimit:</p>

<p style="margin-top: 1em">jobflow
-limits=mem=100M,cpu=3,fsize=20M,nofiles=300 myjob</p>

<p style="margin-top: 1em">parallel &rsquo;ulimit -v 102400
-t 3 -f 204800 -n 300 myjob&rsquo;</p>

<p style="margin-top: 1em">EXAMPLES FROM jobflow README</p>

<p style="margin-top: 1em">1 cat things.list | jobflow
-threads=8 -exec ./mytask {}</p>

<p style="margin-top: 1em">1 cat things.list | parallel -j8
./mytask {}</p>

<p style="margin-top: 1em">2 seq 100 | jobflow -threads=100
-exec echo {}</p>

<p style="margin-top: 1em">2 seq 100 | parallel -j100 echo
{}</p>

<p style="margin-top: 1em">3 cat urls.txt | jobflow
-threads=32 -exec wget {}</p>

<p style="margin-top: 1em">3 cat urls.txt | parallel -j32
wget {}</p>

<p style="margin-top: 1em">4 find . -name
&rsquo;*.bmp&rsquo; | jobflow -threads=8 -exec bmp2jpeg
{.}.bmp {.}.jpg</p>

<p style="margin-top: 1em">4 find . -name
&rsquo;*.bmp&rsquo; | parallel -j8 bmp2jpeg {.}.bmp
{.}.jpg</p>

<p style="margin-top: 1em">DIFFERENCES BETWEEN ClusterSSH
AND GNU Parallel <br>
ClusterSSH solves a different problem than GNU parallel.</p>

<p style="margin-top: 1em">ClusterSSH opens a terminal
window for each computer and using a master window you can
run the same command on all the computers. This is typically
used for administrating <br>
several computers that are almost identical.</p>

<p style="margin-top: 1em">GNU parallel runs the same (or
different) commands with different arguments in parallel
possibly using remote computers to help computing. If more
than one computer is listed in <br>
-S GNU parallel may only use one of these (e.g. if there are
8 jobs to be run and one computer has 8 cores).</p>

<p style="margin-top: 1em">GNU parallel can be used as a
poor-man&rsquo;s version of ClusterSSH:</p>

<p style="margin-top: 1em">parallel --nonall -S
server-a,server-b do_stuff foo bar</p>

<p style="margin-top: 1em">BUGS <br>
Quoting of newline <br>
Because of the way newline is quoted this will not work:</p>

<p style="margin-top: 1em">echo 1,2,3 | parallel -vkd,
&quot;echo &rsquo;a{}b&rsquo;&quot;</p>

<p style="margin-top: 1em">However, these will all
work:</p>

<p style="margin-top: 1em">echo 1,2,3 | parallel -vkd, echo
a{}b <br>
echo 1,2,3 | parallel -vkd, &quot;echo
&rsquo;a&rsquo;{}&rsquo;b&rsquo;&quot; <br>
echo 1,2,3 | parallel -vkd, &quot;echo
&rsquo;a&rsquo;&quot;{}&quot;&rsquo;b&rsquo;&quot;</p>

<p style="margin-top: 1em">Speed <br>
Startup</p>

<p style="margin-top: 1em">GNU parallel is slow at starting
up - around 250 ms the first time and 150 ms after that.</p>

<p style="margin-top: 1em">Job startup</p>

<p style="margin-top: 1em">Starting a job on the local
machine takes around 10 ms. This can be a big overhead if
the job takes very few ms to run. Often you can group small
jobs together using -X which <br>
will make the overhead less significant. Or you can run
multiple GNU parallels as described in EXAMPLE: Speeding up
fast jobs.</p>

<p style="margin-top: 1em">SSH</p>

<p style="margin-top: 1em">When using multiple computers
GNU parallel opens ssh connections to them to figure out how
many connections can be used reliably simultaneously (Namely
SSHD&rsquo;s MaxStartups). This <br>
test is done for each host in serial, so if your
--sshloginfile contains many hosts it may be slow.</p>

<p style="margin-top: 1em">If your jobs are short you may
see that there are fewer jobs running on the remove systems
than expected. This is due to time spent logging in and out.
-M may help here.</p>

<p style="margin-top: 1em">Disk access</p>

<p style="margin-top: 1em">A single disk can normally read
data faster if it reads one file at a time instead of
reading a lot of files in parallel, as this will avoid disk
seeks. However, newer disk <br>
systems with multiple drives can read faster if reading from
multiple files in parallel.</p>

<p style="margin-top: 1em">If the jobs are of the form
read-all-compute-all-write-all, so everything is read before
anything is written, it may be faster to force only one disk
access at the time:</p>

<p style="margin-top: 1em">sem --id diskio cat file |
compute | sem --id diskio cat &gt; file</p>

<p style="margin-top: 1em">If the jobs are of the form
read-compute-write, so writing starts before all reading is
done, it may be faster to force only one reader and writer
at the time:</p>

<p style="margin-top: 1em">sem --id read cat file | compute
| sem --id write cat &gt; file</p>

<p style="margin-top: 1em">If the jobs are of the form
read-compute-read-compute, it may be faster to run more jobs
in parallel than the system has CPUs, as some of the jobs
will be stuck waiting for disk <br>
access.</p>

<p style="margin-top: 1em">--nice limits command length
<br>
The current implementation of --nice is too pessimistic in
the max allowed command length. It only uses a little more
than half of what it could. This affects -X and -m. If this
<br>
becomes a real problem for you file a bug-report.</p>

<p style="margin-top: 1em">Aliases and functions do not
work <br>
If you get:</p>

<p style="margin-top: 1em">Can&rsquo;t exec
&quot;command&quot;: No such file or directory</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">open3: exec of by command
failed</p>

<p style="margin-top: 1em">it may be because command is not
known, but it could also be because command is an alias or a
function. If it is a function you need to export -f the
function first. An alias <br>
will only work if you use env_parallel described
earlier.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to &lt;bug-parallel@gnu.org&gt; or
https://savannah.gnu.org/bugs/?func=additem&amp;group=parallel</p>

<p style="margin-top: 1em">See a perfect bug report on
https://lists.gnu.org/archive/html/bug-parallel/2015-01/msg00000.html</p>

<p style="margin-top: 1em">Your bug report should always
include:</p>

<p style="margin-top: 1em">&Acirc;&middot; The error
message you get (if any).</p>

<p style="margin-top: 1em">&Acirc;&middot; The complete
output of parallel --version. If you are not running the
latest released version (see
http://ftp.gnu.org/gnu/parallel/) you should specify why you
believe the <br>
problem is not fixed in that version.</p>

<p style="margin-top: 1em">&Acirc;&middot; A minimal,
complete, and verifiable example (See description on
http://stackoverflow.com/help/mcve).</p>

<p style="margin-top: 1em">It should be a complete example
that others can run that shows the problem including all
files needed to run the example. This should preferably be
small and simple, so try to <br>
remove as many options as possible. A combination of yes,
seq, cat, echo, and sleep can reproduce most errors. If your
example requires large files, see if you can make them by
<br>
something like seq 1000000 &gt; file or yes | head -n
10000000 &gt; file. If your example requires remote
execution, see if you can use localhost - maybe using
another login.</p>

<p style="margin-top: 1em">&Acirc;&middot; The output of
your example. If your problem is not easily reproduced by
others, the output might help them figure out the
problem.</p>

<p style="margin-top: 1em">&Acirc;&middot; Whether you have
watched the intro videos
(http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1),
walked through the tutorial (man parallel_tutorial), and
read the EXAMPLE <br>
section in the man page (man parallel - search for
EXAMPLE:).</p>

<p style="margin-top: 1em">If you suspect the error is
dependent on your environment or distribution, please see if
you can reproduce the error on one of these VirtualBox
images: <br>
http://sourceforge.net/projects/virtualboximage/files/</p>

<p style="margin-top: 1em">Specifying the name of your
distribution is not enough as you may have installed
software that is not in the VirtualBox images.</p>

<p style="margin-top: 1em">If you cannot reproduce the
error on any of the VirtualBox images above, see if you can
build a VirtualBox image on which you can reproduce the
error. If not you should assume <br>
the debugging will be done through you. That will put more
burden on you and it is extra important you give any
information that help. In general the problem will be fixed
faster <br>
and with less work for you if you can reproduce the error on
a VirtualBox.</p>

<p style="margin-top: 1em">AUTHOR <br>
When using GNU parallel for a publication please cite:</p>

<p style="margin-top: 1em">O. Tange (2011): GNU Parallel -
The Command-Line Power Tool, ;login: The USENIX Magazine,
February 2011:42-47.</p>

<p style="margin-top: 1em">This helps funding further
development; and it won&rsquo;t cost you a cent. If you pay
10000 EUR you should feel free to use GNU Parallel without
citing.</p>

<p style="margin-top: 1em">Copyright (C) 2007-10-18 Ole
Tange, http://ole.tange.dk</p>

<p style="margin-top: 1em">Copyright (C) 2008,2009,2010 Ole
Tange, http://ole.tange.dk</p>

<p style="margin-top: 1em">Copyright (C)
2010,2011,2012,2013,2014,2015,2016 Ole Tange,
http://ole.tange.dk and Free Software Foundation, Inc.</p>

<p style="margin-top: 1em">Parts of the manual concerning
xargs compatibility is inspired by the manual of xargs from
GNU findutils 4.4.2.</p>

<p style="margin-top: 1em">LICENSE <br>
Copyright (C)
2007,2008,2009,2010,2011,2012,2013,2014,2015,2016 Free
Software Foundation, Inc.</p>

<p style="margin-top: 1em">This program is free software;
you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free
Software Foundation; either <br>
version 3 of the License, or at your option any later
version.</p>

<p style="margin-top: 1em">This program is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR <br>
PURPOSE. See the GNU General Public License for more
details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program.
If not, see &lt;http://www.gnu.org/licenses/&gt;.</p>

<p style="margin-top: 1em">Documentation license I <br>
Permission is granted to copy, distribute and/or modify this
documentation under the terms of the GNU Free Documentation
License, Version 1.3 or any later version published by <br>
the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts. A
copy of the license is included in the file fdl.txt.</p>

<p style="margin-top: 1em">Documentation license II <br>
You are free:</p>

<p style="margin-top: 1em">to Share to copy, distribute and
transmit the work</p>

<p style="margin-top: 1em">to Remix to adapt the work</p>

<p style="margin-top: 1em">Under the following
conditions:</p>

<p style="margin-top: 1em">Attribution <br>
You must attribute the work in the manner specified by the
author or licensor (but not in any way that suggests that
they endorse you or your use of the work).</p>

<p style="margin-top: 1em">Share Alike <br>
If you alter, transform, or build upon this work, you may
distribute the resulting work only under the same, similar
or a compatible license.</p>

<p style="margin-top: 1em">With the understanding that:</p>

<p style="margin-top: 1em">Waiver Any of the above
conditions can be waived if you get permission from the
copyright holder.</p>

<p style="margin-top: 1em">Public Domain <br>
Where the work or any of its elements is in the public
domain under applicable law, that status is in no way
affected by the license.</p>

<p style="margin-top: 1em">Other Rights <br>
In no way are any of the following rights affected by the
license:</p>

<p style="margin-top: 1em">&Acirc;&middot; Your fair
dealing or fair use rights, or other applicable copyright
exceptions and limitations;</p>

<p style="margin-top: 1em">&Acirc;&middot; The
author&rsquo;s moral rights;</p>

<p style="margin-top: 1em">&Acirc;&middot; Rights other
persons may have either in the work itself or in how the
work is used, such as publicity or privacy rights.</p>

<p style="margin-top: 1em">Notice For any reuse or
distribution, you must make clear to others the license
terms of this work.</p>

<p style="margin-top: 1em">A copy of the full license is
included in the file as cc-by-sa.txt.</p>

<p style="margin-top: 1em">DEPENDENCIES <br>
GNU parallel uses Perl, and the Perl modules Getopt::Long,
IPC::Open3, Symbol, IO::File, POSIX, and File::Temp. For
remote usage it also uses rsync with ssh.</p>

<p style="margin-top: 1em">SEE ALSO <br>
ssh(1), ssh-agent(1), sshpass(1), ssh-copy-id(1), rsync(1),
find(1), xargs(1), dirname(1), make(1), pexec(1), ppss(1),
xjobs(1), prll(1), dxargs(1), mdm(1)</p>

<p style="margin-top: 1em">20160622 2016-07-22
PARALLEL(1)</p>
<hr>
</body>
</html>
