<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PARALLEL(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PARALLEL(1)</td>
    <td class="head-vol">parallel</td>
    <td class="head-rtitle">PARALLEL(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
parallel - build and execute shell command lines from standard input in parallel
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>parallel</b> [options] [<i>command</i> [arguments]] &lt; list_of_arguments
<div class="Pp"></div>
<b>parallel</b> [options] [<i>command</i> [arguments]] ( <b>:::</b> arguments |
  <b>:::+</b> arguments | <b>::::</b> argfile(s) | <b>::::+</b> argfile(s) ) ...
<div class="Pp"></div>
<b>parallel</b> --semaphore [options] <i>command</i>
<div class="Pp"></div>
<b>#!/usr/bin/parallel</b> --shebang [options] [<i>command</i> [arguments]]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
GNU <b>parallel</b> is a shell tool for executing jobs in parallel using one or
  more computers. A job can be a single command or a small script that has to be
  run for each of the lines in the input. The typical input is a list of files,
  a list of hosts, a list of users, a list of URLs, or a list of tables. A job
  can also be a command that reads from a pipe. GNU <b>parallel</b> can then
  split the input into blocks and pipe a block into each command in parallel.
<div class="Pp"></div>
If you use xargs and tee today you will find GNU <b>parallel</b> very easy to
  use as GNU <b>parallel</b> is written to have the same options as xargs. If
  you write loops in shell, you will find GNU <b>parallel</b> may be able to
  replace most of the loops and make them run faster by running several jobs in
  parallel.
<div class="Pp"></div>
GNU <b>parallel</b> makes sure output from the commands is the same output as
  you would get had you run the commands sequentially. This makes it possible to
  use output from GNU <b>parallel</b> as input for other programs.
<div class="Pp"></div>
For each line of input GNU <b>parallel</b> will execute <i>command</i> with the
  line as arguments. If no <i>command</i> is given, the line of input is
  executed. Several lines will be run in parallel. GNU <b>parallel</b> can often
  be used as a substitute for <b>xargs</b> or <b>cat | bash</b>.
<h2 class="Ss" title="Ss" id="Reader's_guide"><a class="selflink" href="#Reader's_guide">Reader's
  guide</a></h2>
Start by watching the intro videos for a quick introduction:
  http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1
<div class="Pp"></div>
Then look at the <b>EXAMPLE</b>s after the list of <b>OPTIONS</b>. That will
  give you an idea of what GNU <b>parallel</b> is capable of.
<div class="Pp"></div>
Then spend an hour walking through the tutorial ( <b>man</b>
  <b>parallel_tutorial</b>). Your command line will love you for it.
<div class="Pp"></div>
Finally you may want to look at the rest of this manual if you have special
  needs not already covered.
<div class="Pp"></div>
If you want to know the design decisions behind GNU <b>parallel</b>, try: <b>man
  parallel_design</b>. This is also a good intro if you intend to change GNU
  <b>parallel</b>.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><i>command</i></dt>
  <dd class="It-tag">Command to execute. If <i>command</i> or the following
      arguments contain replacement strings (such as <b>{}</b>) every instance
      will be substituted with the input.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>command</i> is given, GNU <b>parallel</b> solve the same tasks as
      <b>xargs</b>. If <i>command</i> is not given GNU <b>parallel</b> will
      behave similar to <b>cat | sh</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>command</i> must be an executable, a script, a composed command, or a
      function.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Bash functions</b>: <b>export -f</b> the function first or use
      <b>env_parallel</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Bash aliases</b>: Use <b>env_parallel</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Ksh functions and aliases</b>: Use <b>env_parallel</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Zsh functions</b>: Use <b>env_parallel</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Zsh aliases</b>: No solution.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Fish functions and aliases</b>: Use <b>env_parallel</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Ksh functions and aliases</b>: Use <b>env_parallel</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Pdksh functions and aliases</b>: Use <b>env_parallel</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The command cannot contain the character \257 (macron: X).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{}</b></dt>
  <dd class="It-tag">Input line. This replacement string will be replaced by a
      full line read from the input source. The input source is normally stdin
      (standard input), but can also be given with <b>-a</b>, <b>:::</b>, or
      <b>::::</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The replacement string <b>{}</b> can be changed with <b>-I</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the command line contains no replacement strings then <b>{}</b> will be
      appended to the command line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{.}</b></dt>
  <dd class="It-tag">Input line without extension. This replacement string will
      be replaced by the input with the extension removed. If the input line
      contains <b>.</b> after the last <b>/</b> the last <b>.</b> till the end
      of the string will be removed and <b>{.}</b> will be replaced with the
      remaining. E.g. <i>foo.jpg</i> becomes <i>foo</i>, <i>subdir/foo.jpg</i>
      becomes <i>subdir/foo</i>, <i>sub.dir/foo.jpg</i> becomes
      <i>sub.dir/foo</i>, <i>sub.dir/bar</i> remains <i>sub.dir/bar</i>. If the
      input line does not contain <b>.</b> it will remain unchanged.
    <div style="height: 1.00em;">&#x00A0;</div>
    The replacement string <b>{.}</b> can be changed with <b>--er</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand replacement strings see <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{/}</b></dt>
  <dd class="It-tag">Basename of input line. This replacement string will be
      replaced by the input with the directory part removed.
    <div style="height: 1.00em;">&#x00A0;</div>
    The replacement string <b>{/}</b> can be changed with
      <b>--basenamereplace</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand replacement strings see <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{//}</b></dt>
  <dd class="It-tag">Dirname of input line. This replacement string will be
      replaced by the dir of the input line. See <b>dirname</b>(1).
    <div style="height: 1.00em;">&#x00A0;</div>
    The replacement string <b>{//}</b> can be changed with
      <b>--dirnamereplace</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand replacement strings see <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{/.}</b></dt>
  <dd class="It-tag">Basename of input line without extension. This replacement
      string will be replaced by the input with the directory and extension part
      removed. It is a combination of <b>{/}</b> and <b>{.}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The replacement string <b>{/.}</b> can be changed with
      <b>--basenameextensionreplace</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand replacement strings see <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{#}</b></dt>
  <dd class="It-tag">Sequence number of the job to run. This replacement string
      will be replaced by the sequence number of the job being run. It contains
      the same number as $PARALLEL_SEQ.
    <div style="height: 1.00em;">&#x00A0;</div>
    The replacement string <b>{#}</b> can be changed with <b>--seqreplace</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand replacement strings see <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{%}</b></dt>
  <dd class="It-tag">Job slot number. This replacement string will be replaced
      by the job's slot number between 1 and number of jobs to run in parallel.
      There will never be 2 jobs running at the same time with the same job slot
      number.
    <div style="height: 1.00em;">&#x00A0;</div>
    The replacement string <b>{%}</b> can be changed with <b>--slotreplace</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand replacement strings see <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{</b><i>n</i><b>}</b></dt>
  <dd class="It-tag">Argument from input source <i>n</i> or the <i>n</i>'th
      argument. This positional replacement string will be replaced by the input
      from input source <i>n</i> (when used with <b>-a</b> or <b>::::</b>) or
      with the <i>n</i>'th argument (when used with <b>-N</b>). If <i>n</i> is
      negative it refers to the <i>n</i>'th last argument.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand replacement strings see <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{</b><i>n</i>.<b>}</b></dt>
  <dd class="It-tag">Argument from input source <i>n</i> or the <i>n</i>'th
      argument without extension. It is a combination of
      <b>{</b><i>n</i><b>}</b> and <b>{.}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    This positional replacement string will be replaced by the input from input
      source <i>n</i> (when used with <b>-a</b> or <b>::::</b>) or with the
      <i>n</i>'th argument (when used with <b>-N</b>). The input will have the
      extension removed.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand positional replacement strings see
    <b>{</b><i>n</i><b>}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{</b><i>n</i>/<b>}</b></dt>
  <dd class="It-tag">Basename of argument from input source <i>n</i> or the
      <i>n</i>'th argument. It is a combination of <b>{</b><i>n</i><b>}</b> and
      <b>{/}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    This positional replacement string will be replaced by the input from input
      source <i>n</i> (when used with <b>-a</b> or <b>::::</b>) or with the
      <i>n</i>'th argument (when used with <b>-N</b>). The input will have the
      directory (if any) removed.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand positional replacement strings see
    <b>{</b><i>n</i><b>}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{</b><i>n</i>//<b>}</b></dt>
  <dd class="It-tag">Dirname of argument from input source <i>n</i> or the
      <i>n</i>'th argument. It is a combination of <b>{</b><i>n</i><b>}</b> and
      <b>{//}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    This positional replacement string will be replaced by the dir of the input
      from input source <i>n</i> (when used with <b>-a</b> or <b>::::</b>) or
      with the <i>n</i>'th argument (when used with <b>-N</b>). See
      <b>dirname</b>(1).
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand positional replacement strings see
    <b>{</b><i>n</i><b>}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{</b><i>n</i>/.<b>}</b></dt>
  <dd class="It-tag">Basename of argument from input source <i>n</i> or the
      <i>n</i>'th argument without extension. It is a combination of
      <b>{</b><i>n</i> <b>}</b>, <b>{/}</b>, and <b>{.}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    This positional replacement string will be replaced by the input from input
      source <i>n</i> (when used with <b>-a</b> or <b>::::</b>) or with the
      <i>n</i>'th argument (when used with <b>-N</b>). The input will have the
      directory (if any) and extension removed.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand positional replacement strings see
    <b>{</b><i>n</i><b>}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{=</b><i>perl expression</i><b>=}</b></dt>
  <dd class="It-tag">Replace with calculated <i>perl expression</i>.
      <b></b><b>$_</b> <b></b> will contain the same as <b>{}</b>. After
      evaluating <i>perl expression</i> <b></b><b>$_</b><b></b> will be used as
      the value. It is recommended to only change $_ but you have full access to
      all of GNU <b>parallel</b>'s internal functions and data structures. A few
      convenience functions have been made:</dd>
</dl>
<div style="margin-left: 9.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"> <b>Q(</b><i>string</i><b>)</b></dt>
  <dd class="It-tag">shell quote a string</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> <b></b><b><i>total_jobs()</i></b><b></b></dt>
  <dd class="It-tag">number of jobs in total</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> <b></b><b>$job</b><b>-</b><i>slot()</i>&gt;</dt>
  <dd class="It-tag">slot number of job</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> <b></b><b>$job</b><b>-</b><i>seq()</i>&gt;</dt>
  <dd class="It-tag">sequence number of job</dd>
</dl>
</div>
<div style="margin-left: 9.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Example:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
  seq 10 | parallel echo {} + 1 is {= '$_++' =}
  parallel csh -c {= '$_=&quot;mkdir &quot;.Q($_)' =} ::: '12&quot; dir'
  seq 50 | parallel echo job {#} of {= '$_=total_jobs()' =}
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
See also: <b>--rpl</b> <b>--parens</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>{=</b><i>n</i> <i>perl expression</i><b>=}</b></dt>
  <dd class="It-tag">Positional equivalent to <b>{=perl expression=}</b>. To
      understand positional replacement strings see <b>{</b><i>n</i><b>}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>{=perl expression=}</b> <b>{</b><i>n</i><b>}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>:::</b> <i>arguments</i></dt>
  <dd class="It-tag">Use arguments from the command line as input source instead
      of stdin (standard input). Unlike other options for GNU <b>parallel</b>
      <b>:::</b> is placed after the <i>command</i> and before the arguments.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following are equivalent:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  (echo file1; echo file2) | parallel gzip
  parallel gzip ::: file1 file2
  parallel gzip {} ::: file1 file2
  parallel --arg-sep ,, gzip {} ,, file1 file2
  parallel --arg-sep ,, gzip ,, file1 file2
  parallel ::: &quot;gzip file1&quot; &quot;gzip file2&quot;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To avoid treating <b>:::</b> as special use <b>--arg-sep</b> to set the
      argument separator to something else. See also <b>--arg-sep</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    stdin (standard input) will be passed to the first process run.
    <div style="height: 1.00em;">&#x00A0;</div>
    If multiple <b>:::</b> are given, each group will be treated as an input
      source, and all combinations of input sources will be generated. E.g. :::
      1 2 ::: a b c will result in the combinations (1,a) (1,b) (1,c) (2,a)
      (2,b) (2,c). This is useful for replacing nested for-loops.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>:::</b> and <b>::::</b> can be mixed. So these are equivalent:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel echo {1} {2} {3} ::: 6 7 ::: 4 5 ::: 1 2 3
  parallel echo {1} {2} {3} :::: &lt;(seq 6 7) &lt;(seq 4 5) \
    :::: &lt;(seq 1 3)
  parallel -a &lt;(seq 6 7) echo {1} {2} {3} :::: &lt;(seq 4 5) \
    :::: &lt;(seq 1 3)
  parallel -a &lt;(seq 6 7) -a &lt;(seq 4 5) echo {1} {2} {3} \
    ::: 1 2 3
  seq 6 7 | parallel -a - -a &lt;(seq 4 5) echo {1} {2} {3} \
    ::: 1 2 3
  seq 4 5 | parallel echo {1} {2} {3} :::: &lt;(seq 6 7) - \
    ::: 1 2 3
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>:::+</b> <i>arguments</i></dt>
  <dd class="It-tag">Like <b>:::</b> but linked like <b>--xapply</b> to the
      previous input source.
    <div style="height: 1.00em;">&#x00A0;</div>
    Contrary to <b>--xapply</b> values do not wrap: The shortest input source
      determines the length.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel echo ::: a b c :::+ 1 2 3 ::: X Y :::+ 11 22
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>::::</b> <i>argfiles</i></dt>
  <dd class="It-tag">Another way to write <b>-a</b> <i>argfile1</i> <b>-a</b>
      <i>argfile2</i> ...
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>:::</b> and <b>::::</b> can be mixed.
    <div style="height: 1.00em;">&#x00A0;</div>
    See <b>-a</b>, <b>:::</b> and <b>--xapply</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>::::+</b> <i>argfiles</i></dt>
  <dd class="It-tag">Like <b>::::+</b> but linked like <b>--xapply</b> to the
      previous input source.
    <div style="height: 1.00em;">&#x00A0;</div>
    Contrary to <b>--xapply</b> values do not wrap: The shortest input source
      determines the length.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--null</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-0</b></dt>
  <dd class="It-tag">Use NUL as delimiter. Normally input lines will end in \n
      (newline). If they end in \0 (NUL), then use this option. It is useful for
      processing arguments that may contain \n (newline).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--arg-file</b> <i>input-file</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b> <i>input-file</i></dt>
  <dd class="It-tag">Use <i>input-file</i> as input source. If you use this
      option, stdin (standard input) is given to the first process run.
      Otherwise, stdin (standard input) is redirected from /dev/null.
    <div style="height: 1.00em;">&#x00A0;</div>
    If multiple <b>-a</b> are given, each <i>input-file</i> will be treated as
      an input source, and all combinations of input sources will be generated.
      E.g. The file <b>foo</b> contains <b>1 2</b>, the file <b>bar</b> contains
      <b>a b c</b>. <b>-a foo</b> <b>-a bar</b> will result in the combinations
      (1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This is useful for replacing nested
      for-loops.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--xapply</b> and <b>{</b><i>n</i><b>}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--arg-file-sep</b> <i>sep-str</i></dt>
  <dd class="It-tag">Use <i>sep-str</i> instead of <b>::::</b> as separator
      string between command and argument files. Useful if <b>::::</b> is used
      for something else by the command.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>::::</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--arg-sep</b> <i>sep-str</i></dt>
  <dd class="It-tag">Use <i>sep-str</i> instead of <b>:::</b> as separator
      string. Useful if <b>:::</b> is used for something else by the command.
    <div style="height: 1.00em;">&#x00A0;</div>
    Also useful if you command uses <b>:::</b> but you still want to read
      arguments from stdin (standard input): Simply change <b>--arg-sep</b> to a
      string that is not in the command line.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>:::</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bar</b></dt>
  <dd class="It-tag">Show progress as a progress bar. In the bar is shown: % of
      jobs completed, estimated seconds left, and number of jobs started.
    <div style="height: 1.00em;">&#x00A0;</div>
    It is compatible with <b>zenity</b>:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  seq 1000 | parallel -j30 --bar '(echo {};sleep 0.1)' \
    2&gt; &gt;(zenity --progress --auto-kill) | wc
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--basefile</b> <i>file</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bf</b> <i>file</i></dt>
  <dd class="It-tag"><i>file</i> will be transferred to each sshlogin before a
      jobs is started. It will be removed if <b>--cleanup</b> is active. The
      file may be a script to run or some common base data needed for the jobs.
      Multiple <b>--bf</b> can be specified to transfer more basefiles. The
      <i>file</i> will be transferred the same way as
    <b>--transferfile</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--basenamereplace</b> <i>replace-str</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bnr</b> <i>replace-str</i></dt>
  <dd class="It-tag">Use the replacement string <i>replace-str</i> instead of
      <b>{/}</b> for basename of input line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--basenameextensionreplace</b> <i>replace-str</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bner</b> <i>replace-str</i></dt>
  <dd class="It-tag">Use the replacement string <i>replace-str</i> instead of
      <b>{/.}</b> for basename of input line without extension.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bg</b></dt>
  <dd class="It-tag">Run command in background thus GNU <b>parallel</b> will not
      wait for completion of the command before exiting. This is the default if
      <b>--semaphore</b> is set.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--fg</b>, <b>man sem</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--semaphore</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bibtex</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--citation</b></dt>
  <dd class="It-tag">Print the BibTeX entry for GNU <b>parallel</b> and silence
      citation notice.
    <div style="height: 1.00em;">&#x00A0;</div>
    If it is impossible for you to run <b>--bibtex</b> you can use
      <b>--will-cite</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you use <b>--will-cite</b> in scripts to be run by others you are making
      it harder for others to see the citation notice. The development of GNU
      <b>parallel</b> is indirectly financed through citations, so if your users
      do not know they should cite then you are making it harder to finance
      development. However, if you pay 10000 EUR, you should feel free to use
      <b>--will-cite</b> in scripts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--block</b> <i>size</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--block-size</b> <i>size</i></dt>
  <dd class="It-tag">Size of block in bytes to read at a time. The <i>size</i>
      can be postfixed with K, M, G, T, P, k, m, g, t, or p which would multiply
      the size with 1024, 1048576, 1073741824, 1099511627776, 1125899906842624,
      1000, 1000000, 1000000000, 1000000000000, or 1000000000000000,
      respectively.
    <div style="height: 1.00em;">&#x00A0;</div>
    GNU <b>parallel</b> tries to meet the block size but can be off by the
      length of one record. For performance reasons <i>size</i> should be bigger
      than a two records. GNU <b>parallel</b> will warn you and automatically
      increase the size if you choose a <i>size</i> that is too small.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you use <b>-N</b>, <b>--block-size</b> should be bigger than N+1 records.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>size</i> defaults to 1M.
    <div style="height: 1.00em;">&#x00A0;</div>
    See <b>--pipe</b> and <b>--pipepart</b> for use of this.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cat</b></dt>
  <dd class="It-tag">Create a temporary file with content. Normally
      <b>--pipe</b>/ <b>--pipepart</b> will give data to the program on stdin
      (standard input). With <b>--cat</b> GNU <b>parallel</b> will create a
      temporary file with the name in <b>{}</b>, so you can do: <b>parallel
      --pipe --cat wc {}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--pipe</b> unless <b>--pipepart</b> is used.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--fifo</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cleanup</b></dt>
  <dd class="It-tag">Remove transferred files. <b>--cleanup</b> will remove the
      transferred files on the remote computer after processing is done.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  find log -name '*gz' | parallel \
    --sshlogin server.example.com --transferfile {} \
    --return {.}.bz2 --cleanup &quot;zcat {} | bzip -9 &gt;{.}.bz2&quot;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    With <b>--transferfile {}</b> the file transferred to the remote computer
      will be removed on the remote computer. Directories created will not be
      removed - even if they are empty.
    <div style="height: 1.00em;">&#x00A0;</div>
    With <b>--return</b> the file transferred from the remote computer will be
      removed on the remote computer. Directories created will not be removed -
      even if they are empty.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--cleanup</b> is ignored when not used with <b>--transferfile</b> or
      <b>--return</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--colsep</b> <i>regexp</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C</b> <i>regexp</i></dt>
  <dd class="It-tag">Column separator. The input will be treated as a table with
      <i>regexp</i> separating the columns. The n'th column can be access using
      <b>{</b><i>n</i><b>}</b> or <b>{</b><i>n</i>.<b>}</b>. E.g. <b>{3}</b> is
      the 3rd column.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--colsep</b> implies <b>--trim rl</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>regexp</i> is a Perl Regular Expression:
      http://perldoc.perl.org/perlre.html</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--compress</b></dt>
  <dd class="It-tag">Compress temporary files. If the output is big and very
      compressible this will take up less disk space in $TMPDIR and possibly be
      faster due to less disk I/O.
    <div style="height: 1.00em;">&#x00A0;</div>
    GNU <b>parallel</b> will try <b>lz4</b>, <b>pigz</b>, <b>lzop</b>,
      <b>plzip</b>, <b>pbzip2</b>, <b>pxz</b>, <b>gzip</b>, <b>lzma</b>,
      <b>xz</b>, <b>bzip2</b>, <b>lzip</b> in that order, and use the first
      available.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--compress-program</b> <i>prg</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--decompress-program</b> <i>prg</i></dt>
  <dd class="It-tag">Use <i>prg</i> for (de)compressing temporary files. It is
      assumed that <i>prg</i> <i>-dc</i> will decompress stdin (standard input)
      to stdout (standard output) unless <b>--decompress-program</b> is
    given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--delimiter</b> <i>delim</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b> <i>delim</i></dt>
  <dd class="It-tag">Input items are terminated by <i>delim</i>. Quotes and
      backslash are not special; every character in the input is taken
      literally. Disables the end-of-file string, which is treated like any
      other argument. The specified delimiter may be characters, C-style
      character escapes such as \n, or octal or hexadecimal escape codes. Octal
      and hexadecimal escape codes are understood as for the printf command.
      Multibyte characters are not supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dirnamereplace</b> <i>replace-str</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dnr</b> <i>replace-str</i></dt>
  <dd class="It-tag">Use the replacement string <i>replace-str</i> instead of
      <b>{//}</b> for dirname of input line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E</b> <i>eof-str</i></dt>
  <dd class="It-tag">Set the end of file string to <i>eof-str</i>. If the end of
      file string occurs as a line of input, the rest of the input is not read.
      If neither <b>-E</b> nor <b>-e</b> is used, no end of file string is
    used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--delay</b> <i>secs</i></dt>
  <dd class="It-tag">Delay starting next job <i>secs</i> seconds. GNU
      <b>parallel</b> will pause <i>secs</i> seconds after starting each job.
      <i>secs</i> can be less than 1 second.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dry-run</b></dt>
  <dd class="It-tag">Print the job to run on stdout (standard output), but do
      not run the job. Use <b>-v -v</b> to include the wrapping that GNU
      Parallel generates (for remote jobs, <b>--tmux</b>, <b>--nice</b>,
      <b>--pipe</b>, <b>--pipepart</b>, <b>--fifo</b> and <b>--cat</b>). Do not
      count on this literaly, though, as the job may be scheduled on another
      computer or the local computer if : is in the list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--eof</b>[=<i>eof-str</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b>[<i>eof-str</i>]</dt>
  <dd class="It-tag">This option is a synonym for the <b>-E</b> option. Use
      <b>-E</b> instead, because it is POSIX compliant for <b>xargs</b> while
      this option is not. If <i>eof-str</i> is omitted, there is no end of file
      string. If neither <b>-E</b> nor <b>-e</b> is used, no end of file string
      is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--env</b> <i>var</i></dt>
  <dd class="It-tag">Copy environment variable <i>var</i>. This will copy
      <i>var</i> to the environment that the command is run in. This is
      especially useful for remote execution.
    <div style="height: 1.00em;">&#x00A0;</div>
    In Bash <i>var</i> can also be a Bash function - just remember to
      <b>export</b> <b>-f</b> the function, see <b>command</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The variable '_' is special. It will copy all exported environment variables
      except for the ones mentioned in ~/.parallel/ignored_vars.
    <div style="height: 1.00em;">&#x00A0;</div>
    To copy the full environment (both exported and not exported variables,
      arrays, and functions) use <b>env_parallel</b> as described under the
      option <i>command</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--record-env</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--eta</b></dt>
  <dd class="It-tag">Show the estimated number of seconds before finishing. This
      forces GNU <b>parallel</b> to read all jobs before starting to find the
      number of jobs. GNU <b>parallel</b> normally only reads the next job to
      run.
    <div style="height: 1.00em;">&#x00A0;</div>
    The estimate is based on the runtime of finished jobs, so the first estimate
      will only be shown when the first job has finished.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--progress</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--bar</b>, <b>--progress</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fg</b></dt>
  <dd class="It-tag">Run command in foreground thus GNU <b>parallel</b> will
      wait for completion of the command before exiting.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--semaphore</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--bg</b>, <b>man sem</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fifo</b></dt>
  <dd class="It-tag">Create a temporary fifo with content. Normally
      <b>--pipe</b> and <b>--pipepart</b> will give data to the program on stdin
      (standard input). With <b>--fifo</b> GNU <b>parallel</b> will create a
      temporary fifo with the name in <b>{}</b>, so you can do: <b>parallel
      --pipe --fifo wc {}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Beware: If data is not read from the fifo, the job will block forever.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--pipe</b> unless <b>--pipepart</b> is used.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--cat</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--filter-hosts</b></dt>
  <dd class="It-tag">Remove down hosts. For each remote host: check that login
      through ssh works. If not: do not use this host.
    <div style="height: 1.00em;">&#x00A0;</div>
    For performance reasons, this check is performed only at the start and every
      time <b>--sshloginfile</b> is changed. If an host goes down after the
      first check, it will go undetected until <b>--sshloginfile</b> is changed;
      <b>--retries</b> can be used to mitigate this.
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently you can <i>not</i> put <b>--filter-hosts</b> in a profile,
      $PARALLEL, /etc/parallel/config or similar. This is because GNU
      <b>parallel</b> uses GNU <b>parallel</b> to compute this, so you will get
      an infinite loop. This will likely be fixed in a later release.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--gnu</b></dt>
  <dd class="It-tag">Behave like GNU <b>parallel</b>. This option historically
      took precedence over <b>--tollef</b>. The <b>--tollef</b> option is now
      retired, and therefore may not be used. <b>--gnu</b> is kept for
      compatibility.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--group</b></dt>
  <dd class="It-tag">Group output. Output from each jobs is grouped together and
      is only printed when the command is finished. stderr (standard error)
      first followed by stdout (standard output). This takes some CPU time. In
      rare situations GNU <b>parallel</b> takes up lots of CPU time and if it is
      acceptable that the outputs from different commands are mixed together,
      then disabling grouping with <b>-u</b> can speedup GNU <b>parallel</b> by
      a factor of 10.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--group</b> is the default. Can be reversed with <b>-u</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--line-buffer</b> <b>--ungroup</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">Print a summary of the options to GNU <b>parallel</b> and
      exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--halt-on-error</b> <i>val</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--halt</b> <i>val</i></dt>
  <dd class="It-tag">When should GNU <b>parallel</b> terminate? In some
      situations it makes no sense to run all jobs. GNU <b>parallel</b> should
      simply give up as soon as a condition is met.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>val</i> defaults to <b>never</b>, which runs all jobs no matter what.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>val</i> can also take on the form of <i>when</i>,<i>why</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>when</i> can be 'now' which means kill all running jobs and halt
      immediately, or it can be 'soon' which means wait for all running jobs to
      complete, but start no new jobs.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>why</i> can be 'fail=X', 'fail=Y%', 'success=X', or 'success=Y%' where X
      is the number of jobs that has to fail or succeed before halting, and Y is
      the percentage of jobs that has to fail or succeed before halting.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:</dd>
</dl>
<div style="margin-left: 9.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"> --halt now,fail=1</dt>
  <dd class="It-tag">exit when the first job fails. Kill running jobs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> --halt soon,fail=3</dt>
  <dd class="It-tag">exit when 3 jobs fail, but wait for running jobs to
      complete.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> --halt soon,fail=3%</dt>
  <dd class="It-tag">exit when 3% of the jobs have failed, but wait for running
      jobs to complete.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> --halt now,success=1</dt>
  <dd class="It-tag">exit when a job succeeds. Kill running jobs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> --halt soon,success=3</dt>
  <dd class="It-tag">exit when 3 jobs succeeds, but wait for running jobs to
      complete.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> --halt now,success=3%</dt>
  <dd class="It-tag">exit when 3% of the jobs have succeeded. Kill running
    jobs.</dd>
</dl>
</div>
<div style="margin-left: 9.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
For backwards compability these also work:
<dl class="Bl-tag">
  <dt class="It-tag">0</dt>
  <dd class="It-tag">never</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1</dt>
  <dd class="It-tag">soon,fail=1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2</dt>
  <dd class="It-tag">now,fail=1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-1</dt>
  <dd class="It-tag">soon,success=1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-2</dt>
  <dd class="It-tag">now,success=1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1-99%</dt>
  <dd class="It-tag">soon,fail=1-99%</dd>
</dl>
</div>
<div style="margin-left: 9.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--header</b> <i>regexp</i></dt>
  <dd class="It-tag">Use regexp as header. For normal usage the matched header
      (typically the first line: <b>--header '.*\n'</b>) will be split using
      <b>--colsep</b> (which will default to '\t') and column names can be used
      as replacement variables: <b>{column name}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    For <b>--pipe</b> the matched header will be prepended to each output.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--header :</b> is an alias for <b>--header '.*\n'</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>regexp</i> is a number, it is a fixed number of lines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hostgroups</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hgrp</b></dt>
  <dd class="It-tag">Enable hostgroups on arguments. If an argument contains '@'
      the string after '@' will be removed and treated as a list of hostgroups
      on which this job is allowed to run. If there is no <b>--sshlogin</b> with
      a corresponding group, the job will run on any hostgroup.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --hostgroups \
    --sshlogin @grp1/myserver1 -S @grp1+grp2/myserver2 \
    --sshlogin @grp3/myserver3 \
    echo ::: my_grp1_arg@grp1 arg_for_grp2@grp2 third_arg@grp1+grp3
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>my_grp1_arg</b> may be run on either <b>myserver1</b> or
      <b>myserver2</b>, <b>third_arg</b> may be run on either <b>myserver1</b>
      or <b>myserver3</b>, but <b>arg_for_grp2</b> will only be run on
      <b>myserver2</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--sshlogin</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b> <i>replace-str</i></dt>
  <dd class="It-tag">Use the replacement string <i>replace-str</i> instead of
      <b>{}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--replace</b>[=<i>replace-str</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b>[<i>replace-str</i>]</dt>
  <dd class="It-tag">This option is a synonym for <b>-I</b><i>replace-str</i> if
      <i>replace-str</i> is specified, and for <b>-I {}</b> otherwise. This
      option is deprecated; use <b>-I</b> instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--joblog</b> <i>logfile</i></dt>
  <dd class="It-tag">Logfile for executed jobs. Save a list of the executed jobs
      to <i>logfile</i> in the following TAB separated format: sequence number,
      sshlogin, start time as seconds since epoch, run time in seconds, bytes in
      files transferred, bytes in files returned, exit status, signal, and
      command run.
    <div style="height: 1.00em;">&#x00A0;</div>
    For <b>--pipe</b> bytes transferred and bytes returned are number of input
      and output of bytes.
    <div style="height: 1.00em;">&#x00A0;</div>
    To convert the times into ISO-8601 strict do:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  perl -a -F&quot;\t&quot; -ne \
    'chomp($F[2]=`date -d \@$F[2] +%FT%T`); print join(&quot;\t&quot;,@F)'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--resume</b> <b>--resume-failed</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--jobs</b> <i>N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b> <i>N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-procs</b> <i>N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b> <i>N</i></dt>
  <dd class="It-tag">Number of jobslots on each machine. Run up to N jobs in
      parallel. 0 means as many as possible. Default is 100% which will run one
      job per CPU core on each machine.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>--semaphore</b> is set, the default is 1 thus making a mutex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--jobs</b> <i>+N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b> <i>+N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-procs</b> <i>+N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b> <i>+N</i></dt>
  <dd class="It-tag">Add N to the number of CPU cores. Run this many jobs in
      parallel. See also <b>--use-cpus-instead-of-cores</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--jobs</b> <i>-N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b> <i>-N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-procs</b> <i>-N</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b> <i>-N</i></dt>
  <dd class="It-tag">Subtract N from the number of CPU cores. Run this many jobs
      in parallel. If the evaluated number is less than 1 then 1 will be used.
      See also <b>--use-cpus-instead-of-cores</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--jobs</b> <i>N</i>%</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b> <i>N</i>%</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-procs</b> <i>N</i>%</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b> <i>N</i>%</dt>
  <dd class="It-tag">Multiply N% with the number of CPU cores. Run this many
      jobs in parallel. See also <b>--use-cpus-instead-of-cores</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--jobs</b> <i>procfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b> <i>procfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-procs</b> <i>procfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b> <i>procfile</i></dt>
  <dd class="It-tag">Read parameter from file. Use the content of
      <i>procfile</i> as parameter for <i>-j</i>. E.g. <i>procfile</i> could
      contain the string 100% or +2 or 10. If <i>procfile</i> is changed when a
      job completes, <i>procfile</i> is read again and the new number of jobs is
      computed. If the number is lower than before, running jobs will be allowed
      to finish but new jobs will not be started until the wanted number of jobs
      has been reached. This makes it possible to change the number of
      simultaneous running jobs while GNU <b>parallel</b> is running.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--keep-order</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b></dt>
  <dd class="It-tag">Keep sequence of output same as the order of input.
      Normally the output of a job will be printed as soon as the job completes.
      Try this to see the difference:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel -j4 sleep {}\; echo {} ::: 2 1 4 3
  parallel -j4 -k sleep {}\; echo {} ::: 2 1 4 3
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If used with <b>--onall</b> or <b>--nonall</b> the output will grouped by
      sshlogin in sorted order.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b> <i>max-lines</i></dt>
  <dd class="It-tag">When used with <b>--pipe</b>: Read records of
      <i>max-lines</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    When used otherwise: Use at most <i>max-lines</i> nonblank input lines per
      command line. Trailing blanks cause an input line to be logically
      continued on the next input line.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>-L 0</b> means read one line, but insert 0 arguments on the command
      line.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>-X</b> unless <b>-m</b>, <b>--xargs</b>, or <b>--pipe</b> is
    set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-lines</b>[=<i>max-lines</i>]</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b>[<i>max-lines</i>]</dt>
  <dd class="It-tag">When used with <b>--pipe</b>: Read records of
      <i>max-lines</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    When used otherwise: Synonym for the <b>-L</b> option. Unlike <b>-L</b>, the
      <i>max-lines</i> argument is optional. If <i>max-lines</i> is not
      specified, it defaults to one. The <b>-l</b> option is deprecated since
      the POSIX standard specifies <b>-L</b> instead.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>-l 0</b> is an alias for <b>-l 1</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>-X</b> unless <b>-m</b>, <b>--xargs</b>, or <b>--pipe</b> is
    set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--line-buffer</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lb</b></dt>
  <dd class="It-tag">Buffer output on line basis. <b>--group</b> will keep the
      output together for a whole job. <b>--ungroup</b> allows output to mixup
      with half a line coming from one job and half a line coming from another
      job. <b>--line-buffer</b> fits between these two: GNU <b>parallel</b> will
      print a full line, but will allow for mixing lines of different jobs.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--line-buffer</b> takes more CPU power than than both <b>--group</b> and
      <b>--ungroup</b>, but can be faster than <b>--group</b> if the CPU is not
      the limiting factor.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--group</b> <b>--ungroup</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--load</b> <i>max-load</i></dt>
  <dd class="It-tag">Do not start new jobs on a given computer unless the number
      of running processes on the computer is less than <i>max-load</i>.
      <i>max-load</i> uses the same syntax as <b>--jobs</b>, so <i>100%</i> for
      one per CPU is a valid setting. Only difference is 0 which is interpreted
      as 0.01.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--controlmaster</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b></dt>
  <dd class="It-tag">Use ssh's ControlMaster to make ssh connections faster.
      Useful if jobs run remote and are very fast to run. This is disabled for
      sshlogins that specify their own ssh command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xargs</b></dt>
  <dd class="It-tag">Multiple arguments. Insert as many arguments as the command
      line length permits.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>{}</b> is not used the arguments will be appended to the line. If
      <b>{}</b> is used multiple times each <b>{}</b> will be replaced with all
      the arguments.
    <div style="height: 1.00em;">&#x00A0;</div>
    Support for <b>--xargs</b> with <b>--sshlogin</b> is limited and may fail.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>-X</b> for context replace. If in doubt use <b>-X</b> as that
      will most likely do what is needed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m</b></dt>
  <dd class="It-tag">Multiple arguments. Insert as many arguments as the command
      line length permits. If multiple jobs are being run in parallel:
      distribute the arguments evenly among the jobs. Use <b>-j1</b> or
      <b>--xargs</b> to avoid this.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>{}</b> is not used the arguments will be appended to the line. If
      <b>{}</b> is used multiple times each <b>{}</b> will be replaced with all
      the arguments.
    <div style="height: 1.00em;">&#x00A0;</div>
    Support for <b>-m</b> with <b>--sshlogin</b> is limited and may fail.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>-X</b> for context replace. If in doubt use <b>-X</b> as that
      will most likely do what is needed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--memfree</b> <i>size</i></dt>
  <dd class="It-tag">Minimum memory free when starting another job. The
      <i>size</i> can be postfixed with K, M, G, T, P, k, m, g, t, or p which
      would multiply the size with 1024, 1048576, 1073741824, 1099511627776,
      1125899906842624, 1000, 1000000, 1000000000, 1000000000000, or
      1000000000000000, respectively.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the jobs take up very different amount of RAM, GNU <b>parallel</b> will
      only start as many as there is memory for. If less than <i>size</i> bytes
      are free, no more jobs will be started. If less than 50% <i>size</i> bytes
      are free, the youngest job will be killed, and put back on the queue to be
      run later.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--minversion</b> <i>version</i></dt>
  <dd class="It-tag">Print the version GNU <b>parallel</b> and exit. If the
      current version of GNU <b>parallel</b> is less than <i>version</i> the
      exit code is 255. Otherwise it is 0.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is useful for scripts that depend on features only available from a
      certain version of GNU <b>parallel</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nonall</b></dt>
  <dd class="It-tag"><b>--onall</b> with no arguments. Run the command on all
      computers given with <b>--sshlogin</b> but take no arguments. GNU
      <b>parallel</b> will log into <b>--jobs</b> number of computers in
      parallel and run the job on the computer. <b>-j</b> adjusts how many
      computers to log into in parallel.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is useful for running the same command (e.g. uptime) on a list of
      servers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--onall</b></dt>
  <dd class="It-tag">Run all the jobs on all computers given with
      <b>--sshlogin</b>. GNU <b>parallel</b> will log into <b>--jobs</b> number
      of computers in parallel and run one job at a time on the computer. The
      order of the jobs will not be changed, but some computers may finish
      before others.
    <div style="height: 1.00em;">&#x00A0;</div>
    When using <b>--group</b> the output will be grouped by each server, so all
      the output from one server will be grouped together.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--joblog</b> will contain an entry for each job on each server, so there
      will be several job sequence 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--output-as-files</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--outputasfiles</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--files</b></dt>
  <dd class="It-tag">Instead of printing the output to stdout (standard output)
      the output of each job is saved in a file and the filename is then
      printed.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--results</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pipe</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--spreadstdin</b></dt>
  <dd class="It-tag">Spread input to jobs on stdin (standard input). Read a
      block of data from stdin (standard input) and give one block of data as
      input to one job.
    <div style="height: 1.00em;">&#x00A0;</div>
    The block size is determined by <b>--block</b>. The strings
      <b>--recstart</b> and <b>--recend</b> tell GNU <b>parallel</b> how a
      record starts and/or ends. The block read will have the final partial
      record removed before the block is passed on to the job. The partial
      record will be prepended to next block.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>--recstart</b> is given this will be used to split at record start.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>--recend</b> is given this will be used to split at record end.
    <div style="height: 1.00em;">&#x00A0;</div>
    If both <b>--recstart</b> and <b>--recend</b> are given both will have to
      match to find a split position.
    <div style="height: 1.00em;">&#x00A0;</div>
    If neither <b>--recstart</b> nor <b>--recend</b> are given <b>--recend</b>
      defaults to '\n'. To have no record separator use <b>--recend
      &quot;&quot;</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--files</b> is often used with <b>--pipe</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--pipe</b> maxes out at around 1 GB/s input, and 100 MB/s output. If
      performance is important use <b>--pipepart</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--recstart</b>, <b>--recend</b>, <b>--fifo</b>, <b>--cat</b>,
      <b>--pipepart</b>, <b>--files</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pipepart</b></dt>
  <dd class="It-tag">Pipe parts of a physical file. <b>--pipepart</b> works
      similar to <b>--pipe</b>, but is much faster.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>--block</b> is left out, <b>--pipepart</b> will use a block size that
      will result in 10 jobs per jobslot, except if run with
      <b>--round-robin</b> in which case it will result in 1 job per jobslot.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--pipepart</b> has a few limitations:</dd>
</dl>
<div style="margin-left: 9.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">The file must be a normal file or a block device
      (technically it must be seekable) and must be given using <b>-a</b> or
      <b>::::</b>. The file cannot be a pipe or a fifo as they are not seekable.
    <div style="height: 1.00em;">&#x00A0;</div>
    If using a block device with lot of NUL bytes, remember to set <b>--recend
      ''</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Record counting (<b>-N</b>) and line counting
      (<b>-L</b>/<b>-l</b>) do not work.</dd>
</dl>
</div>
<div style="margin-left: 9.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--plain</b></dt>
  <dd class="It-tag">Ignore any <b>--profile</b>, $PARALLEL, and
      ~/.parallel/config to get full control on the command line (used by GNU
      <b>parallel</b> internally when called with <b>--sshlogin</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--plus</b></dt>
  <dd class="It-tag">Activate additional replacement strings: {+/} {+.} {+..}
      {+...} {..} {...} {/..} {/...} {##}. The idea being that '{+foo}' matches
      the opposite of '{foo}' and {} = {+/}/{/} = {.}.{+.} = {+/}/{/.}.{+.} =
      {..}.{+..} = {+/}/{/..}.{+..} = {...}.{+...} = {+/}/{/...}.{+...}
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>{##}</b> is the number of jobs to be run. It is incompatible with
      <b>-X</b>/ <b>-m</b>/<b>--xargs</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--progress</b></dt>
  <dd class="It-tag">Show progress of computations. List the computers involved
      in the task with number of CPU cores detected and the max number of jobs
      to run. After that show progress for each computer: number of running
      jobs, number of completed jobs, and percentage of all jobs done by this
      computer. The percentage will only be available after all jobs have been
      scheduled as GNU <b>parallel</b> only read the next job when ready to
      schedule it - this is to avoid wasting time and memory by reading
      everything at startup.
    <div style="height: 1.00em;">&#x00A0;</div>
    By sending GNU <b>parallel</b> SIGUSR2 you can toggle turning on/off
      <b>--progress</b> on a running GNU <b>parallel</b> process.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--eta</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-args</b>=<i>max-args</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b> <i>max-args</i></dt>
  <dd class="It-tag">Use at most <i>max-args</i> arguments per command line.
      Fewer than <i>max-args</i> arguments will be used if the size (see the
      <b>-s</b> option) is exceeded, unless the <b>-x</b> option is given, in
      which case GNU <b>parallel</b> will exit.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>-n 0</b> means read one argument, but insert 0 arguments on the command
      line.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>-X</b> unless <b>-m</b> is set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-replace-args</b>=<i>max-args</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b> <i>max-args</i></dt>
  <dd class="It-tag">Use at most <i>max-args</i> arguments per command line.
      Like <b>-n</b> but also makes replacement strings <b>{1}</b> ..
      <b>{</b><i>max-args</i><b>}</b> that represents argument 1 ..
      <i>max-args</i>. If too few args the <b>{</b><i>n</i><b>}</b> will be
      empty.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>-N 0</b> means read one argument, but insert 0 arguments on the command
      line.
    <div style="height: 1.00em;">&#x00A0;</div>
    This will set the owner of the homedir to the user:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  tr ':' '\n' &lt; /etc/passwd | parallel -N7 chown {1} {6}
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>-X</b> unless <b>-m</b> or <b>--pipe</b> is set.
    <div style="height: 1.00em;">&#x00A0;</div>
    When used with <b>--pipe</b> <b>-N</b> is the number of records to read.
      This is somewhat slower than <b>--block</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-line-length-allowed</b></dt>
  <dd class="It-tag">Print the maximal number of characters allowed on the
      command line and exit (used by GNU <b>parallel</b> itself to determine the
      line length on remote computers).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--number-of-cpus</b></dt>
  <dd class="It-tag">Print the number of physical CPUs and exit (used by GNU
      <b>parallel</b> itself to determine the number of physical CPUs on remote
      computers).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--number-of-cores</b></dt>
  <dd class="It-tag">Print the number of CPU cores and exit (used by GNU
      <b>parallel</b> itself to determine the number of CPU cores on remote
      computers).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-keep-order</b></dt>
  <dd class="It-tag">Overrides an earlier <b>--keep-order</b> (e.g. if set in
      <b>~/.parallel/config</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nice</b> <i>niceness</i></dt>
  <dd class="It-tag">Run the command at this niceness. For simple commands you
      can just add <b>nice</b> in front of the command. But if the command
      consists of more sub commands (Like: ls|wc) then prepending <b>nice</b>
      will not always work. <b>--nice</b> will make sure all sub commands are
      niced - even on remote servers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--interactive</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag">Prompt the user about whether to run each command line and
      read a line from the terminal. Only run the command line if the response
      starts with 'y' or 'Y'. Implies <b>-t</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--parens</b> <i>parensstring</i></dt>
  <dd class="It-tag">Define start and end parenthesis for <b>{= perl expression
      =}</b>. The left and the right parenthesis can be multiple characters and
      are assumed to be the same length. The default is <b>{==}</b> giving
      <b>{=</b> as the start parenthesis and <b>=}</b> as the end parenthesis.
    <div style="height: 1.00em;">&#x00A0;</div>
    Another useful setting is <b>,,,,</b> which would make both parenthesis
      <b>,,</b>:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --parens ,,,, echo foo is ,,s/I/O/g,, ::: FII
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--rpl</b> <b>{= perl expression =}</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--profile</b> <i>profilename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-J</b> <i>profilename</i></dt>
  <dd class="It-tag">Use profile <i>profilename</i> for options. This is useful
      if you want to have multiple profiles. You could have one profile for
      running jobs in parallel on the local computer and a different profile for
      running jobs on remote computers. See the section PROFILE FILES for
      examples.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>profilename</i> corresponds to the file ~/.parallel/<i>profilename</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can give multiple profiles by repeating <b>--profile</b>. If parts of
      the profiles conflict, the later ones will be used.
    <div style="height: 1.00em;">&#x00A0;</div>
    Default: config</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quote</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b></dt>
  <dd class="It-tag">Quote <i>command</i>. This will quote the command line so
      special characters are not interpreted by the shell. See the section
      QUOTING. Most people will never need this. Quoting is disabled by
    default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-run-if-empty</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b></dt>
  <dd class="It-tag">If the stdin (standard input) only contains whitespace, do
      not run the command.
    <div style="height: 1.00em;">&#x00A0;</div>
    If used with <b>--pipe</b> this is slow.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--noswap</b></dt>
  <dd class="It-tag">Do not start new jobs on a given computer if there is both
      swap-in and swap-out activity.
    <div style="height: 1.00em;">&#x00A0;</div>
    The swap activity is only sampled every 10 seconds as the sampling takes 1
      second to do.
    <div style="height: 1.00em;">&#x00A0;</div>
    Swap activity is computed as (swap-in)*(swap-out) which in practice is a
      good value: swapping out is not a problem, swapping in is not a problem,
      but both swapping in and out usually indicates a problem.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--memfree</b> may give better results, so try using that first.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--record-env</b></dt>
  <dd class="It-tag">Record current environment variables in
      ~/.parallel/ignored_vars. This is useful before using <b>--env _</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--env</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--recstart</b> <i>startstring</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--recend</b> <i>endstring</i></dt>
  <dd class="It-tag">If <b>--recstart</b> is given <i>startstring</i> will be
      used to split at record start.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>--recend</b> is given <i>endstring</i> will be used to split at record
      end.
    <div style="height: 1.00em;">&#x00A0;</div>
    If both <b>--recstart</b> and <b>--recend</b> are given the combined string
      <i>endstring</i><i>startstring</i> will have to match to find a split
      position. This is useful if either <i>startstring</i> or <i>endstring</i>
      match in the middle of a record.
    <div style="height: 1.00em;">&#x00A0;</div>
    If neither <b>--recstart</b> nor <b>--recend</b> are given then
      <b>--recend</b> defaults to '\n'. To have no record separator use
      <b>--recend &quot;&quot;</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--recstart</b> and <b>--recend</b> are used with <b>--pipe</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use <b>--regexp</b> to interpret <b>--recstart</b> and <b>--recend</b> as
      regular expressions. This is slow, however.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--regexp</b></dt>
  <dd class="It-tag">Use <b>--regexp</b> to interpret <b>--recstart</b> and
      <b>--recend</b> as regular expressions. This is slow, however.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--remove-rec-sep</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--removerecsep</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rrs</b></dt>
  <dd class="It-tag">Remove the text matched by <b>--recstart</b> and
      <b>--recend</b> before piping it to the command.
    <div style="height: 1.00em;">&#x00A0;</div>
    Only used with <b>--pipe</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--results</b> <i>prefix</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--res</b> <i>prefix</i></dt>
  <dd class="It-tag">Save the output into files. The files will be stored in a
      directory tree rooted at <i>prefix</i>. Within this directory tree, each
      command will result in two files: <i>prefix</i>/&lt;ARGS&gt;/stdout and
      <i>prefix</i>/&lt;ARGS&gt;/stderr, where &lt;ARGS&gt; is a sequence of
      directories representing the header of the input source (if using
      <b>--header :</b>) or the number of the input source and corresponding
      values.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>prefix</i> can contain replacement strings.
    <div style="height: 1.00em;">&#x00A0;</div>
    E.g:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --header : --results foo echo {a} {b} \
    ::: a I II ::: b III IIII
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will generate the files:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  foo/a/I/b/III/stderr
  foo/a/I/b/III/stdout
  foo/a/I/b/IIII/stderr
  foo/a/I/b/IIII/stdout
  foo/a/II/b/III/stderr
  foo/a/II/b/III/stdout
  foo/a/II/b/IIII/stderr
  foo/a/II/b/IIII/stdout
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --results foo echo {1} {2} ::: I II ::: III IIII
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will generate the files:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  foo/1/I/2/III/stderr
  foo/1/I/2/III/stdout
  foo/1/I/2/IIII/stderr
  foo/1/I/2/IIII/stdout
  foo/1/II/2/III/stderr
  foo/1/II/2/III/stdout
  foo/1/II/2/IIII/stderr
  foo/1/II/2/IIII/stdout
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --results foo-{1} echo {1} {2} ::: I II ::: III IIII
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will generate the files:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  foo-I/1/I/2/IIII/seq
  foo-I/1/I/2/IIII/stderr
  foo-I/1/I/2/IIII/stdout
  foo-I/1/I/2/III/seq
  foo-I/1/I/2/III/stderr
  foo-I/1/I/2/III/stdout
  foo-II/1/II/2/IIII/seq
  foo-II/1/II/2/IIII/stderr
  foo-II/1/II/2/IIII/stdout
  foo-II/1/II/2/III/seq
  foo-II/1/II/2/III/stderr
  foo-II/1/II/2/III/stdout
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you do not want the dir structure, try <b>--files</b> <b>--tag</b>
      instead.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--files</b>, <b>--tag</b>, <b>--header</b>,
    <b>--joblog</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--resume</b></dt>
  <dd class="It-tag">Resumes from the last unfinished job. By reading
      <b>--joblog</b> or the <b>--results</b> dir GNU <b>parallel</b> will
      figure out the last unfinished job and continue from there. As GNU
      <b>parallel</b> only looks at the sequence numbers in <b>--joblog</b> then
      the input, the command, and <b>--joblog</b> all have to remain unchanged;
      otherwise GNU <b>parallel</b> may run wrong commands.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--joblog</b>, <b>--results</b>, <b>--resume-failed</b>,
      <b>--retries</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--resume-failed</b></dt>
  <dd class="It-tag">Retry all failed and resume from the last unfinished job.
      By reading <b>--joblog</b> GNU <b>parallel</b> will figure out the failed
      jobs and run those again. After that it will resume last unfinished job
      and continue from there. As GNU <b>parallel</b> only looks at the sequence
      numbers in <b>--joblog</b> then the input, the command, and
      <b>--joblog</b> all have to remain unchanged; otherwise GNU
      <b>parallel</b> may run wrong commands.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--joblog</b>, <b>--resume</b>, <b>--retry-failed</b>,
      <b>--retries</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--retry-failed</b></dt>
  <dd class="It-tag">Retry all failed jobs in joblog. By reading <b>--joblog</b>
      GNU <b>parallel</b> will figure out the failed jobs and run those again.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--retry-failed</b> ignores the command and arguments on the command
      line: It only looks at the joblog.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    B&lt;Differences between --resume, --resume-failed, --retry-failed&gt;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In this example <b>exit {= </b><b>$_</b><b>%=2 =}</b> will cause every other
      job to fail.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  timeout -k 1 4 parallel --joblog log -j10 'sleep {}; exit {= $_%=2 =}' ::: {10..1}
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    4 jobs completed. 2 failed:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  Seq   [...]   Exitval Signal  Command
  10    [...]   1       0       sleep 1; exit 1
  9     [...]   0       0       sleep 2; exit 0
  8     [...]   1       0       sleep 3; exit 1
  7     [...]   0       0       sleep 4; exit 0
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--resume</b> does not care about the Exitval, but only looks at Seq. If
      the Seq is run, it will not be run again. So if needed, you can change the
      command for the seqs not run yet:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --resume --joblog log -j10 'sleep .{}; exit {= $_%=2 =}' ::: {10..1}
  Seq   [...]   Exitval Signal  Command
  [... as above ...]
  1     [...]   0       0       sleep .10; exit 0
  6     [...]   1       0       sleep .5; exit 1
  5     [...]   0       0       sleep .6; exit 0
  4     [...]   1       0       sleep .7; exit 1
  3     [...]   0       0       sleep .8; exit 0
  2     [...]   1       0       sleep .9; exit 1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--resume-failed</b> cares about the Exitval, but also only looks at Seq
      to figure out which commands to run. Again this means you can change the
      command, but not the arguments. It will run the failed seqs and the seqs
      not yet run:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --resume-failed --joblog log -j10 'echo {};sleep .{}; exit {= $_%=3 =}' ::: {10..1}
  Seq   [...]   Exitval Signal  Command
  [... as above ...]
  10    [...]   1       0       echo 1;sleep .1; exit 1
  8     [...]   0       0       echo 3;sleep .3; exit 0
  6     [...]   2       0       echo 5;sleep .5; exit 2
  4     [...]   1       0       echo 7;sleep .7; exit 1
  2     [...]   0       0       echo 9;sleep .9; exit 0
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--retry-failed</b> cares about the Exitval, but takes the command from
      the joblog. It ignores any arguments or commands given on the command
      line:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --retry-failed --joblog log -j10 this part is ignored
  Seq   [...]   Exitval Signal  Command
  [... as above ...]
  10    [...]   1       0       echo 1;sleep .1; exit 1
  6     [...]   2       0       echo 5;sleep .5; exit 2
  4     [...]   1       0       echo 7;sleep .7; exit 1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--joblog</b>, <b>--resume</b>, <b>--resume-failed</b>,
      <b>--retries</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--retries</b> <i>n</i></dt>
  <dd class="It-tag">If a job fails, retry it on another computer on which it
      has not failed. Do this <i>n</i> times. If there are fewer than <i>n</i>
      computers in <b>--sshlogin</b> GNU <b>parallel</b> will re-use all the
      computers. This is useful if some jobs fail for no apparent reason (such
      as network failure).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--return</b> <i>filename</i></dt>
  <dd class="It-tag">Transfer files from remote computers. <b>--return</b> is
      used with <b>--sshlogin</b> when the arguments are files on the remote
      computers. When processing is done the file <i>filename</i> will be
      transferred from the remote computer using <b>rsync</b> and will be put
      relative to the default login dir. E.g.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  echo foo/bar.txt | parallel --return {.}.out \
    --sshlogin server.example.com touch {.}.out
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will transfer the file <i></i><i>$HOME</i><i>/foo/bar.out</i> from the
      computer <i>server.example.com</i> to the file <i>foo/bar.out</i> after
      running <b>touch foo/bar.out</b> on <i>server.example.com</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel -S server --trc out/./{}.out touch {}.out ::: in/file
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will transfer the file <i>in/file.out</i> from the computer
      <i>server.example.com</i> to the files <i>out/in/file.out</i> after
      running <b>touch in/file.out</b> on <i>server</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  echo /tmp/foo/bar.txt | parallel --return {.}.out \
    --sshlogin server.example.com touch {.}.out
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will transfer the file <i>/tmp/foo/bar.out</i> from the computer
      <i>server.example.com</i> to the file <i>/tmp/foo/bar.out</i> after
      running <b>touch /tmp/foo/bar.out</b> on <i>server.example.com</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Multiple files can be transferred by repeating the option multiple times:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  echo /tmp/foo/bar.txt | parallel \
    --sshlogin server.example.com \
    --return {.}.out --return {.}.out2 touch {.}.out {.}.out2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--return</b> is often used with <b>--transferfile</b> and
      <b>--cleanup</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--return</b> is ignored when used with <b>--sshlogin :</b> or when not
      used with <b>--sshlogin</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--round-robin</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--round</b></dt>
  <dd class="It-tag">Normally <b>--pipe</b> will give a single block to each
      instance of the command. With <b>--round-robin</b> all blocks will at
      random be written to commands already running. This is useful if the
      command takes a long time to initialize.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--keep-order</b> will not work with <b>--round-robin</b> as it is
      impossible to track which input block corresponds to which output.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--round-robin</b> implies <b>--pipe</b>, except if <b>--pipepart</b> is
      given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rpl</b> '<i>tag</i> <i>perl expression</i>'</dt>
  <dd class="It-tag">Use <i>tag</i> as a replacement string for <i>perl
      expression</i>. This makes it possible to define your own replacement
      strings. GNU <b>parallel</b>'s 7 replacement strings are implemented as:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  --rpl '{} '
  --rpl '{#} 1 $_=$job-&gt;seq()'
  --rpl '{%} 1 $_=$job-&gt;slot()'
  --rpl '{/} s:.*/::'
  --rpl '{//} $Global::use{&quot;File::Basename&quot;} ||= eval &quot;use File::Basename; 1;&quot;; $_ = dirname($_);'
  --rpl '{/.} s:.*/::; s:\.[^/.]+$::;'
  --rpl '{.} s:\.[^/.]+$::'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The <b>--plus</b> replacement strings are implemented as:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  --rpl '{+/} s:/[^/]*$::'
  --rpl '{+.} s:.*\.::'
  --rpl '{+..} s:.*\.([^.]*\.):$1:'
  --rpl '{+...} s:.*\.([^.]*\.[^.]*\.):$1:'
  --rpl '{..} s:\.[^/.]+$::; s:\.[^/.]+$::'
  --rpl '{...} s:\.[^/.]+$::; s:\.[^/.]+$::; s:\.[^/.]+$::'
  --rpl '{/..} s:.*/::; s:\.[^/.]+$::; s:\.[^/.]+$::'
  --rpl '{/...} s:.*/::; s:\.[^/.]+$::; s:\.[^/.]+$::; s:\.[^/.]+$::'
  --rpl '{##} $_=total_jobs()'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If the user defined replacement string starts with '{' it can also be used
      as a positional replacement string (like <b>{2.}</b>).
    <div style="height: 1.00em;">&#x00A0;</div>
    It is recommended to only change $_ but you have full access to all of GNU
      <b>parallel</b>'s internal functions and data structures.
    <div style="height: 1.00em;">&#x00A0;</div>
    Here are a few examples:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  Is the job sequence even or odd?
  --rpl '{odd} $_ = $job-&gt;seq() % 2 ? &quot;odd&quot; : &quot;even&quot;'
  Pad job sequence with leading zeros to get equal width
  --rpl '{0#} $f = &quot;%0&quot;.int(1+log(total_jobs())/log(10)).&quot;d&quot;; $_=sprintf($f,$job-&gt;seq())'
  Job sequence counting from 0
  --rpl '{#0} $_ = $job-&gt;seq() - 1'
  Job slot counting from 2
  --rpl '{%1} $_ = $job-&gt;slot() + 1'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>{= perl expression =}</b> <b>--parens</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-chars</b>=<i>max-chars</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b> <i>max-chars</i></dt>
  <dd class="It-tag">Use at most <i>max-chars</i> characters per command line,
      including the command and initial-arguments and the terminating nulls at
      the ends of the argument strings. The largest allowed value is
      system-dependent, and is calculated as the argument length limit for exec,
      less the size of your environment. The default value is the maximum.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>-X</b> unless <b>-m</b> is set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--show-limits</b></dt>
  <dd class="It-tag">Display the limits on the command-line length which are
      imposed by the operating system and the <b>-s</b> option. Pipe the input
      from /dev/null (and perhaps specify --no-run-if-empty) if you don't want
      GNU <b>parallel</b> to do anything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--semaphore</b></dt>
  <dd class="It-tag">Work as a counting semaphore. <b>--semaphore</b> will cause
      GNU <b>parallel</b> to start <i>command</i> in the background. When the
      number of jobs given by <b>--jobs</b> is reached, GNU <b>parallel</b> will
      wait for one of these to complete before starting another command.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--semaphore</b> implies <b>--bg</b> unless <b>--fg</b> is specified.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--semaphore</b> implies <b>--semaphorename `tty`</b> unless
      <b>--semaphorename</b> is specified.
    <div style="height: 1.00em;">&#x00A0;</div>
    Used with <b>--fg</b>, <b>--wait</b>, and <b>--semaphorename</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The command <b>sem</b> is an alias for <b>parallel --semaphore</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>man sem</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--semaphorename</b> <i>name</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--id</b> <i>name</i></dt>
  <dd class="It-tag">Use <b>name</b> as the name of the semaphore. Default is
      the name of the controlling tty (output from <b>tty</b>).
    <div style="height: 1.00em;">&#x00A0;</div>
    The default normally works as expected when used interactively, but when
      used in a script <i>name</i> should be set. <i>$$</i> or
      <i>my_task_name</i> are often a good value.
    <div style="height: 1.00em;">&#x00A0;</div>
    The semaphore is stored in ~/.parallel/semaphores/
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--semaphore</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>man sem</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--semaphoretimeout</b> <i>secs</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--st</b> <i>secs</i></dt>
  <dd class="It-tag">If <i>secs</i> &gt; 0: If the semaphore is not released
      within <i>secs</i> seconds, take it anyway.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>secs</i> &lt; 0: If the semaphore is not released within <i>secs</i>
      seconds, exit.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--semaphore</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>man sem</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seqreplace</b> <i>replace-str</i></dt>
  <dd class="It-tag">Use the replacement string <i>replace-str</i> instead of
      <b>{#}</b> for job sequence number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shebang</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hashbang</b></dt>
  <dd class="It-tag">GNU <b>parallel</b> can be called as a shebang (#!) command
      as the first line of a script. The content of the file will be treated as
      inputsource.
    <div style="height: 1.00em;">&#x00A0;</div>
    Like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  #!/usr/bin/parallel --shebang -r traceroute
  qubes-os.org
  debian.org
  freenetproject.org
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--shebang</b> must be set as the first option.
    <div style="height: 1.00em;">&#x00A0;</div>
    On FreeBSD <b>env</b> is needed:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  #!/usr/bin/env -S parallel --shebang -r traceroute
  qubes-os.org
  debian.org
  freenetproject.org
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    There are many limitations of shebang (#!) depending on your operating
      system. See details on
    http://www.in-ulm.de/~mascheck/various/shebang/</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shebang-wrap</b></dt>
  <dd class="It-tag">GNU <b>parallel</b> can parallelize scripts by wrapping the
      shebang line. If the program can be run like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  cat arguments | parallel the_program
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    then the script can be changed to:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  #!/usr/bin/parallel --shebang-wrap /the/original/parser --with-options
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    E.g.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  #!/usr/bin/parallel --shebang-wrap /usr/bin/python
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If the program can be run like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  cat data | parallel --pipe the_program
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    then the script can be changed to:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  #!/usr/bin/parallel --shebang-wrap --pipe /the/original/parser --with-options
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    E.g.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  #!/usr/bin/parallel --shebang-wrap --pipe /usr/bin/perl -w
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--shebang-wrap</b> must be set as the first option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shellquote</b></dt>
  <dd class="It-tag">Does not run the command but quotes it. Useful for making
      quoted composed commands for GNU <b>parallel</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shuf</b></dt>
  <dd class="It-tag">Shuffle jobs. When having multiple input sources it is hard
      to randomize jobs. --shuf will generate all jobs, and shuffle them before
      running them. This is useful to get a quick preview of the results before
      running the full batch.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--skip-first-line</b></dt>
  <dd class="It-tag">Do not use the first line of input (used by GNU
      <b>parallel</b> itself when called with <b>--shebang</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sql</b> <i>DBURL</i> (obsolete)</dt>
  <dd class="It-tag">Use <b>--sqlmaster</b> instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sqlmaster</b> <i>DBURL</i></dt>
  <dd class="It-tag">Submit jobs via SQL server. <i>DBURL</i> must point to a
      table, which will contain the same information as <b>--joblog</b>, the
      values from the input sources (stored in columns V1 .. Vn), and the output
      (stored in columns Stdout and Stderr).
    <div style="height: 1.00em;">&#x00A0;</div>
    The table will be dropped and created with the correct amount of V-columns.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--sqlmaster</b> does not run any jobs, but it creates the values for the
      jobs to be run and wait for them to complete. One or more
      <b>--sqlworker</b> must be run to actually execute the jobs.
    <div style="height: 1.00em;">&#x00A0;</div>
    The format of a DBURL is:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  [sql:]vendor://[[user][:password]@][host][:port]/[database]/table
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    E.g.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  sql:mysql://hr:hr@localhost:3306/hrdb/jobs
  mysql://scott:tiger@my.example.com/pardb/paralleljobs
  sql:oracle://scott:tiger@ora.example.com/xe/parjob
  postgresql://scott:tiger@pg.example.com/pgdb/parjob
  pg:///parjob
  sqlite3:///pardb/parjob
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It can also be an alias from ~/.sql/aliases:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  :myalias mysql:///mydb/paralleljobs
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sqlandworker</b> <i>DBURL</i></dt>
  <dd class="It-tag">Shorthand for: <b>--sqlmaster</b> <i>DBURL</i>
      <b>--sqlworker</b> <i>DBURL</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sqlworker</b> <i>DBURL</i></dt>
  <dd class="It-tag">Execute jobs via SQL server. Read the input sources
      variables from the table pointed to by <i>DBURL</i>. The <i>command</i> on
      the command line should be the same as given by <b>--sqlmaster</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ssh</b> <i>sshcommand</i></dt>
  <dd class="It-tag">GNU <b>parallel</b> defaults to using <b>ssh</b> for remote
      access. This can be overridden with <b>--ssh</b>. It can also be set on a
      per server basis (see <b>--sshlogin</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sshdelay</b> <i>secs</i></dt>
  <dd class="It-tag">Delay starting next ssh by <i>secs</i> seconds. GNU
      <b>parallel</b> will pause <i>secs</i> seconds after starting each ssh.
      <i>secs</i> can be less than 1 seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b>
    <i>[@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]]</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b> <i></i><i>@hostgroup</i><i></i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sshlogin</b>
    <i>[@hostgroups/][ncpu/]sshlogin[,[@hostgroups/][ncpu/]sshlogin[,...]]</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sshlogin</b> <i></i><i>@hostgroup</i><i></i></dt>
  <dd class="It-tag">Distribute jobs to remote computers. The jobs will be run
      on a list of remote computers.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>hostgroups</i> is given, the <i>sshlogin</i> will be added to that
      hostgroup. Multiple hostgroups are separated by '+'. The <i>sshlogin</i>
      will always be added to a hostgroup named the same as <i>sshlogin</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If only the <i></i><i>@hostgroup</i><i></i> is given, only the sshlogins in
      that hostgroup will be used. Multiple <i></i><i>@hostgroup</i><i></i> can
      be given.
    <div style="height: 1.00em;">&#x00A0;</div>
    GNU <b>parallel</b> will determine the number of CPU cores on the remote
      computers and run the number of jobs as specified by <b>-j</b>. If the
      number <i>ncpu</i> is given GNU <b>parallel</b> will use this number for
      number of CPU cores on the host. Normally <i>ncpu</i> will not be needed.
    <div style="height: 1.00em;">&#x00A0;</div>
    An <i>sshlogin</i> is of the form:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  [sshcommand [options]] [username@]hostname
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The sshlogin must not require a password ( <b>ssh-agent</b>,
      <b>ssh-copy-id</b>, and <b>sshpass</b> may help with that).
    <div style="height: 1.00em;">&#x00A0;</div>
    The sshlogin ':' is special, it means 'no ssh' and will therefore run on the
      local computer.
    <div style="height: 1.00em;">&#x00A0;</div>
    The sshlogin '..' is special, it read sshlogins from
      ~/.parallel/sshloginfile
    <div style="height: 1.00em;">&#x00A0;</div>
    The sshlogin '-' is special, too, it read sshlogins from stdin (standard
      input).
    <div style="height: 1.00em;">&#x00A0;</div>
    To specify more sshlogins separate the sshlogins by comma, newline (in the
      same string), or repeat the options multiple times.
    <div style="height: 1.00em;">&#x00A0;</div>
    For examples: see <b>--sshloginfile</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The remote host must have GNU <b>parallel</b> installed.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--sshlogin</b> is known to cause problems with <b>-m</b> and <b>-X</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--sshlogin</b> is often used with <b>--transferfile</b>,
      <b>--return</b>, <b>--cleanup</b>, and <b>--trc</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sshloginfile</b> <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--slf</b> <i>filename</i></dt>
  <dd class="It-tag">File with sshlogins. The file consists of sshlogins on
      separate lines. Empty lines and lines starting with '#' are ignored.
      Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  server.example.com
  username@server2.example.com
  8/my-8-core-server.example.com
  2/my_other_username@my-dualcore.example.net
  # This server has SSH running on port 2222
  ssh -p 2222 server.example.net
  4/ssh -p 2222 quadserver.example.net
  # Use a different ssh program
  myssh -p 2222 -l myusername hexacpu.example.net
  # Use a different ssh program with default number of cores
  //usr/local/bin/myssh -p 2222 -l myusername hexacpu
  # Use a different ssh program with 6 cores
  6//usr/local/bin/myssh -p 2222 -l myusername hexacpu
  # Assume 16 cores on the local computer
  16/:
  # Put server1 in hostgroup1
  @hostgroup1/server1
  # Put myusername@server2 in hostgroup1+hostgroup2
  @hostgroup1+hostgroup2/myusername@server2
  # Force 4 cores and put 'ssh -p 2222 server3' in hostgroup1
  @hostgroup1/4/ssh -p 2222 server3
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    When using a different ssh program the last argument must be the hostname.
    <div style="height: 1.00em;">&#x00A0;</div>
    Multiple <b>--sshloginfile</b> are allowed.
    <div style="height: 1.00em;">&#x00A0;</div>
    GNU <b>parallel</b> will first look for the file in current dir; if that
      fails it look for the file in ~/.parallel.
    <div style="height: 1.00em;">&#x00A0;</div>
    The sshloginfile '..' is special, it read sshlogins from
      ~/.parallel/sshloginfile
    <div style="height: 1.00em;">&#x00A0;</div>
    The sshloginfile '.' is special, it read sshlogins from
      /etc/parallel/sshloginfile
    <div style="height: 1.00em;">&#x00A0;</div>
    The sshloginfile '-' is special, too, it read sshlogins from stdin (standard
      input).
    <div style="height: 1.00em;">&#x00A0;</div>
    If the sshloginfile is changed it will be re-read when a job finishes though
      at most once per second. This makes it possible to add and remove hosts
      while running.
    <div style="height: 1.00em;">&#x00A0;</div>
    This can be used to have a daemon that updates the sshloginfile to only
      contain servers that are up:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    cp original.slf tmp2.slf
    while [ 1 ] ; do
      nice parallel --nonall -j0 -k --slf original.slf \
        --tag echo | perl 's/\t$//' &gt; tmp.slf
      if diff tmp.slf tmp2.slf; then
        mv tmp.slf tmp2.slf
      fi
      sleep 10
    done &amp;
    parallel --slf tmp2.slf ...
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--slotreplace</b> <i>replace-str</i></dt>
  <dd class="It-tag">Use the replacement string <i>replace-str</i> instead of
      <b>{%}</b> for job slot number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--silent</b></dt>
  <dd class="It-tag">Silent. The job to be run will not be printed. This is the
      default. Can be reversed with <b>-v</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tty</b></dt>
  <dd class="It-tag">Open terminal tty. If GNU <b>parallel</b> is used for
      starting an interactive program then this option may be needed. It will
      start only one job at a time (i.e. <b>-j1</b>), not buffer the output
      (i.e. <b>-u</b>), and it will open a tty for the job. When the job is
      done, the next job will get the tty.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can of course override <b>-j1</b> and <b>-u</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tag</b></dt>
  <dd class="It-tag">Tag lines with arguments. Each output line will be
      prepended with the arguments and TAB (\t). When combined with
      <b>--onall</b> or <b>--nonall</b> the lines will be prepended with the
      sshlogin instead.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--tag</b> is ignored when using <b>-u</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tagstring</b> <i>str</i></dt>
  <dd class="It-tag">Tag lines with a string. Each output line will be prepended
      with <i>str</i> and TAB (\t). <i>str</i> can contain replacement strings
      such as <b>{}</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--tagstring</b> is ignored when using <b>-u</b>, <b>--onall</b>, and
      <b>--nonall</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--termseq</b> <i>sequence</i></dt>
  <dd class="It-tag">Termination sequence. When a job is killed due to
      <b>--timeout</b>, <b>--memfree</b>, <b>--halt</b>, or abnormal termination
      of GNU <b>parallel</b>, <i>sequence</i> determines how the job is killed.
      The default is:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    TERM,200,TERM,100,TERM,50,KILL,25
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    which sends a TERM signal, waits 200 ms, sends another TERM signal, waits
      100 ms, sends another TERM signal, waits 50 ms, sends a KILL signal, waits
      25 ms, and exits. GNU <b>parallel</b> discovers if a process dies before
      the waiting time is up.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tmpdir</b> <i>dirname</i></dt>
  <dd class="It-tag">Directory for temporary files. GNU <b>parallel</b> normally
      buffers output into temporary files in /tmp. By setting <b>--tmpdir</b>
      you can use a different dir for the files. Setting <b>--tmpdir</b> is
      equivalent to setting $TMPDIR.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tmux</b></dt>
  <dd class="It-tag">Use <b>tmux</b> for output. Start a <b>tmux</b> session and
      run each job in a window in that session. No other output will be
      produced.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timeout</b> <i>secs</i></dt>
  <dd class="It-tag">Time out for command. If the command runs for longer than
      <i>secs</i> seconds it will get killed with SIGTERM, followed by SIGTERM
      200 ms later, followed by SIGKILL 200 ms later.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>secs</i> is followed by a % then the timeout will dynamically be
      computed as a percentage of the median average runtime. Only values &gt;
      100% will make sense.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbose</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b></dt>
  <dd class="It-tag">Print the job to be run on stderr (standard error).
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>-v</b>, <b>-p</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--transfer</b></dt>
  <dd class="It-tag">Transfer files to remote computers. Shorthand for:
      <b>--transferfile {}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--transferfile</b> <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tf</b> <i>filename</i></dt>
  <dd class="It-tag"><b>--transferfile</b> is used with <b>--sshlogin</b> to
      transfer files to the remote computers. The files will be transferred
      using <b>rsync</b> and will be put relative to the default work dir. If
      the path contains /./ the remaining path will be relative to the work dir.
      E.g.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  echo foo/bar.txt | parallel \
    --sshlogin server.example.com --transferfile {} wc
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will transfer the file <i>foo/bar.txt</i> to the computer
      <i>server.example.com</i> to the file
      <i></i><i>$HOME</i><i>/foo/bar.txt</i> before running <b>wc
      foo/bar.txt</b> on <i>server.example.com</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  echo /tmp/foo/bar.txt | parallel \
    --sshlogin server.example.com --transferfile {} wc
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will transfer the file <i>/tmp/foo/bar.txt</i> to the computer
      <i>server.example.com</i> to the file <i>/tmp/foo/bar.txt</i> before
      running <b>wc /tmp/foo/bar.txt</b> on <i>server.example.com</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  echo /tmp/./foo/bar.txt | parallel \
    --sshlogin server.example.com --transferfile {} wc {= s:.*/./:./: =}
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will transfer the file <i>/tmp/foo/bar.txt</i> to the computer
      <i>server.example.com</i> to the file <i>foo/bar.txt</i> before running
      <b>wc ./foo/bar.txt</b> on <i>server.example.com</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--transferfile</b> is often used with <b>--return</b> and
      <b>--cleanup</b>. A shorthand for <b>--transferfile {}</b> is
      <b>--transfer</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--transferfile</b> is ignored when used with <b>--sshlogin :</b> or when
      not used with <b>--sshlogin</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--trc</b> <i>filename</i></dt>
  <dd class="It-tag">Transfer, Return, Cleanup. Shorthand for:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--transferfile {}</b> <b>--return</b> <i>filename</i>
    <b>--cleanup</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--trim</b> &lt;n|l|r|lr|rl&gt;</dt>
  <dd class="It-tag">Trim white space in input.</dd>
</dl>
<div style="margin-left: 9.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">n</dt>
  <dd class="It-tag">No trim. Input is not modified. This is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">l</dt>
  <dd class="It-tag">Left trim. Remove white space from start of input. E.g.
      &quot; a bc &quot; -&gt; &quot;a bc &quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">r</dt>
  <dd class="It-tag">Right trim. Remove white space from end of input. E.g.
      &quot; a bc &quot; -&gt; &quot; a bc&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">lr</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rl</dt>
  <dd class="It-tag">Both trim. Remove white space from both start and end of
      input. E.g. &quot; a bc &quot; -&gt; &quot;a bc&quot;. This is the default
      if <b>--colsep</b> is used.</dd>
</dl>
</div>
<div style="margin-left: 9.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ungroup</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u</b></dt>
  <dd class="It-tag">Ungroup output. Output is printed as soon as possible and
      by passes GNU <b>parallel</b> internal processing. This may cause output
      from different commands to be mixed thus should only be used if you do not
      care about the output. Compare these:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  seq 4 | parallel -j0 \
    'sleep {};echo -n start{};sleep {};echo {}end'
  seq 4 | parallel -u -j0 \
    'sleep {};echo -n start{};sleep {};echo {}end'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It also disables <b>--tag</b>. GNU <b>parallel</b> outputs faster with
      <b>-u</b>. Compare the speed of these:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel seq ::: 300000000 &gt;/dev/null
  parallel -u seq ::: 300000000 &gt;/dev/null
  parallel --line-buffer seq ::: 300000000 &gt;/dev/null
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Can be reversed with <b>--group</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: <b>--line-buffer</b> <b>--group</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--extensionreplace</b> <i>replace-str</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--er</b> <i>replace-str</i></dt>
  <dd class="It-tag">Use the replacement string <i>replace-str</i> instead of
      <b>{.}</b> for input line without extension.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--use-cpus-instead-of-cores</b></dt>
  <dd class="It-tag">Count the number of physical CPUs instead of CPU cores.
      When computing how many jobs to run simultaneously relative to the number
      of CPU cores you can ask GNU <b>parallel</b> to instead look at the number
      of physical CPUs. This will make sense for computers that have
      hyperthreading as two jobs running on one CPU with hyperthreading will run
      slower than two jobs running on two physical CPUs. Some multi-core CPUs
      can run faster if only one thread is running per physical CPU. Most users
      will not need this option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag">Verbose. Print the job to be run on stdout (standard
      output). Can be reversed with <b>--silent</b>. See also <b>-t</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use <b>-v</b> <b>-v</b> to print the wrapping ssh command when running
      remotely.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag">Print the version GNU <b>parallel</b> and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--workdir</b> <i>mydir</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--wd</b> <i>mydir</i></dt>
  <dd class="It-tag">Files transferred using <b>--transferfile</b> and
      <b>--return</b> will be relative to <i>mydir</i> on remote computers, and
      the command will be executed in the dir <i>mydir</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The special <i>mydir</i> value <b>...</b> will create working dirs under
      <b>~/.parallel/tmp/</b> on the remote computers. If <b>--cleanup</b> is
      given these dirs will be removed.
    <div style="height: 1.00em;">&#x00A0;</div>
    The special <i>mydir</i> value <b>.</b> uses the current working dir. If the
      current working dir is beneath your home dir, the value <b>.</b> is
      treated as the relative path to your home dir. This means that if your
      home dir is different on remote computers (e.g. if your login is
      different) the relative path will still be relative to your home dir.
    <div style="height: 1.00em;">&#x00A0;</div>
    To see the difference try:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel -S server pwd ::: &quot;&quot;
  parallel --wd . -S server pwd ::: &quot;&quot;
  parallel --wd ... -S server pwd ::: &quot;&quot;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>mydir</i> can contain GNU <b>parallel</b>'s replacement strings.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--wait</b></dt>
  <dd class="It-tag">Wait for all commands to complete.
    <div style="height: 1.00em;">&#x00A0;</div>
    Implies <b>--semaphore</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>man sem</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-X</b></dt>
  <dd class="It-tag">Multiple arguments with context replace. Insert as many
      arguments as the command line length permits. If multiple jobs are being
      run in parallel: distribute the arguments evenly among the jobs. Use
      <b>-j1</b> to avoid this.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <b>{}</b> is not used the arguments will be appended to the line. If
      <b>{}</b> is used as part of a word (like <i>pic{}.jpg</i>) then the whole
      word will be repeated. If <b>{}</b> is used multiple times each <b>{}</b>
      will be replaced with the arguments.
    <div style="height: 1.00em;">&#x00A0;</div>
    Normally <b>-X</b> will do the right thing, whereas <b>-m</b> can give
      unexpected results if <b>{}</b> is used as part of a word.
    <div style="height: 1.00em;">&#x00A0;</div>
    Support for <b>-X</b> with <b>--sshlogin</b> is limited and may fail.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>-m</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--exit</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b></dt>
  <dd class="It-tag">Exit if the size (see the <b>-s</b> option) is
    exceeded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xapply</b></dt>
  <dd class="It-tag">Read multiple input sources like <b>xapply</b>. If multiple
      input sources are given, one argument will be read from each of the input
      sources. The arguments can be accessed in the command as <b>{1}</b> ..
      <b>{</b> <i>n</i><b>}</b>, so <b>{1}</b> will be a line from the first
      input source, and <b>{6}</b> will refer to the line with the same line
      number from the 6th input source.
    <div style="height: 1.00em;">&#x00A0;</div>
    Compare these two:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel echo {1} {2} ::: 1 2 3 ::: a b c
  parallel --xapply echo {1} {2} ::: 1 2 3 ::: a b c
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Arguments will be recycled if one input source has more arguments than the
      others:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  parallel --xapply echo {1} {2} {3} \
    ::: 1 2 ::: I II III ::: a b c d e f g
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also <b>--header</b>.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Working_as_xargs_-n1._Argument_appending"><a class="selflink" href="#EXAMPLE:_Working_as_xargs_-n1._Argument_appending">EXAMPLE:
  Working as xargs -n1. Argument appending</a></h1>
GNU <b>parallel</b> can work similar to <b>xargs -n1</b>.
<div class="Pp"></div>
To compress all html files using <b>gzip</b> run:
<div class="Pp"></div>
<pre>
  find . -name '*.html' | parallel gzip --best
</pre>
<div class="Pp"></div>
If the file names may contain a newline use <b>-0</b>. Substitute FOO BAR with
  FUBAR in all files in this dir and subdirs:
<div class="Pp"></div>
<pre>
  find . -type f -print0 | parallel -q0 perl -i -pe 's/FOO BAR/FUBAR/g'
</pre>
<div class="Pp"></div>
Note <b>-q</b> is needed because of the space in 'FOO BAR'.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Reading_arguments_from_command_line"><a class="selflink" href="#EXAMPLE:_Reading_arguments_from_command_line">EXAMPLE:
  Reading arguments from command line</a></h1>
GNU <b>parallel</b> can take the arguments from command line instead of stdin
  (standard input). To compress all html files in the current dir using
  <b>gzip</b> run:
<div class="Pp"></div>
<pre>
  parallel gzip --best ::: *.html
</pre>
<div class="Pp"></div>
To convert *.wav to *.mp3 using LAME running one process per CPU core run:
<div class="Pp"></div>
<pre>
  parallel lame {} -o {.}.mp3 ::: *.wav
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Inserting_multiple_arguments"><a class="selflink" href="#EXAMPLE:_Inserting_multiple_arguments">EXAMPLE:
  Inserting multiple arguments</a></h1>
When moving a lot of files like this: <b>mv *.log destdir</b> you will sometimes
  get the error:
<div class="Pp"></div>
<pre>
  bash: /bin/mv: Argument list too long
</pre>
<div class="Pp"></div>
because there are too many files. You can instead do:
<div class="Pp"></div>
<pre>
  ls | grep -E '\.log$' | parallel mv {} destdir
</pre>
<div class="Pp"></div>
This will run <b>mv</b> for each file. It can be done faster if <b>mv</b> gets
  as many arguments that will fit on the line:
<div class="Pp"></div>
<pre>
  ls | grep -E '\.log$' | parallel -m mv {} destdir
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Context_replace"><a class="selflink" href="#EXAMPLE:_Context_replace">EXAMPLE:
  Context replace</a></h1>
To remove the files <i>pict0000.jpg</i> .. <i>pict9999.jpg</i> you could do:
<div class="Pp"></div>
<pre>
  seq -w 0 9999 | parallel rm pict{}.jpg
</pre>
<div class="Pp"></div>
You could also do:
<div class="Pp"></div>
<pre>
  seq -w 0 9999 | perl -pe 's/(.*)/pict$1.jpg/' | parallel -m rm
</pre>
<div class="Pp"></div>
The first will run <b>rm</b> 10000 times, while the last will only run <b>rm</b>
  as many times needed to keep the command line length short enough to avoid
  <b>Argument list too long</b> (it typically runs 1-2 times).
<div class="Pp"></div>
You could also run:
<div class="Pp"></div>
<pre>
  seq -w 0 9999 | parallel -X rm pict{}.jpg
</pre>
<div class="Pp"></div>
This will also only run <b>rm</b> as many times needed to keep the command line
  length short enough.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Compute_intensive_jobs_and_substitution"><a class="selflink" href="#EXAMPLE:_Compute_intensive_jobs_and_substitution">EXAMPLE:
  Compute intensive jobs and substitution</a></h1>
If ImageMagick is installed this will generate a thumbnail of a jpg file:
<div class="Pp"></div>
<pre>
  convert -geometry 120 foo.jpg thumb_foo.jpg
</pre>
<div class="Pp"></div>
This will run with number-of-cpu-cores jobs in parallel for all jpg files in a
  directory:
<div class="Pp"></div>
<pre>
  ls *.jpg | parallel convert -geometry 120 {} thumb_{}
</pre>
<div class="Pp"></div>
To do it recursively use <b>find</b>:
<div class="Pp"></div>
<pre>
  find . -name '*.jpg' | parallel convert -geometry 120 {} {}_thumb.jpg
</pre>
<div class="Pp"></div>
Notice how the argument has to start with <b>{}</b> as <b>{}</b> will include
  path (e.g. running <b>convert -geometry 120 ./foo/bar.jpg</b>
  <b>thumb_./foo/bar.jpg</b> would clearly be wrong). The command will generate
  files like ./foo/bar.jpg_thumb.jpg.
<div class="Pp"></div>
Use <b>{.}</b> to avoid the extra .jpg in the file name. This command will make
  files like ./foo/bar_thumb.jpg:
<div class="Pp"></div>
<pre>
  find . -name '*.jpg' | parallel convert -geometry 120 {} {.}_thumb.jpg
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Substitution_and_redirection"><a class="selflink" href="#EXAMPLE:_Substitution_and_redirection">EXAMPLE:
  Substitution and redirection</a></h1>
This will generate an uncompressed version of .gz-files next to the .gz-file:
<div class="Pp"></div>
<pre>
  parallel zcat {} &quot;&gt;&quot;{.} ::: *.gz
</pre>
<div class="Pp"></div>
Quoting of &gt; is necessary to postpone the redirection. Another solution is to
  quote the whole command:
<div class="Pp"></div>
<pre>
  parallel &quot;zcat {} &gt;{.}&quot; ::: *.gz
</pre>
<div class="Pp"></div>
Other special shell characters (such as * ; $ &gt; &lt; | &gt;&gt; &lt;&lt;)
  also need to be put in quotes, as they may otherwise be interpreted by the
  shell and not given to GNU <b>parallel</b>.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Composed_commands"><a class="selflink" href="#EXAMPLE:_Composed_commands">EXAMPLE:
  Composed commands</a></h1>
A job can consist of several commands. This will print the number of files in
  each directory:
<div class="Pp"></div>
<pre>
  ls | parallel 'echo -n {}&quot; &quot;; ls {}|wc -l'
</pre>
<div class="Pp"></div>
To put the output in a file called &lt;name&gt;.dir:
<div class="Pp"></div>
<pre>
  ls | parallel '(echo -n {}&quot; &quot;; ls {}|wc -l) &gt;{}.dir'
</pre>
<div class="Pp"></div>
Even small shell scripts can be run by GNU <b>parallel</b>:
<div class="Pp"></div>
<pre>
  find . | parallel 'a={}; name=${a##*/};' \
    'upper=$(echo &quot;$name&quot; | tr &quot;[:lower:]&quot; &quot;[:upper:]&quot;);'\
    'echo &quot;$name - $upper&quot;'
  ls | parallel 'mv {} &quot;$(echo {} | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;)&quot;'
</pre>
<div class="Pp"></div>
Given a list of URLs, list all URLs that fail to download. Print the line number
  and the URL.
<div class="Pp"></div>
<pre>
  cat urlfile | parallel &quot;wget {} 2&gt;/dev/null || grep -n {} urlfile&quot;
</pre>
<div class="Pp"></div>
Create a mirror directory with the same filenames except all files and symlinks
  are empty files.
<div class="Pp"></div>
<pre>
  cp -rs /the/source/dir mirror_dir
  find mirror_dir -type l | parallel -m rm {} '&amp;&amp;' touch {}
</pre>
<div class="Pp"></div>
Find the files in a list that do not exist
<div class="Pp"></div>
<pre>
  cat file_list | parallel 'if [ ! -e {} ] ; then echo {}; fi'
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Composed_command_with_multiple_input_sources"><a class="selflink" href="#EXAMPLE:_Composed_command_with_multiple_input_sources">EXAMPLE:
  Composed command with multiple input sources</a></h1>
You have a dir with files named as 24 hours in 5 minute intervals: 00:00, 00:05,
  00:10 .. 23:55. You want to find the files missing:
<div class="Pp"></div>
<pre>
  parallel [ -f {1}:{2} ] &quot;||&quot; echo {1}:{2} does not exist ::: {00..23} ::: {00..55..5}
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Calling_Bash_functions"><a class="selflink" href="#EXAMPLE:_Calling_Bash_functions">EXAMPLE:
  Calling Bash functions</a></h1>
If the composed command is longer than a line, it becomes hard to read. In Bash
  you can use functions. Just remember to <b>export -f</b> the function.
<div class="Pp"></div>
<pre>
  doit() {
    echo Doing it for $1
    sleep 2
    echo Done with $1
  }
  export -f doit
  parallel doit ::: 1 2 3
  doubleit() {
    echo Doing it for $1 $2
    sleep 2
    echo Done with $1 $2
  }
  export -f doubleit
  parallel doubleit ::: 1 2 3 ::: a b
</pre>
<div class="Pp"></div>
To do this on remote servers you need to transfer the function using
  <b>--env</b>:
<div class="Pp"></div>
<pre>
  parallel --env doit -S server doit ::: 1 2 3
  parallel --env doubleit -S server doubleit ::: 1 2 3 ::: a b
</pre>
<div class="Pp"></div>
If your environment (aliases, variables, and functions) is small you can copy
  the full environment without having to <b>export -f</b> anything. See
  <b>env_parallel</b> earlier in the man page.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Function_tester"><a class="selflink" href="#EXAMPLE:_Function_tester">EXAMPLE:
  Function tester</a></h1>
To test a program with different parameters:
<div class="Pp"></div>
<pre>
  tester() {
    if (eval &quot;$@&quot;) &gt;&amp;/dev/null; then
      perl -e 'printf &quot;\033[30;102m[ OK ]\033[0m @ARGV\n&quot;' &quot;$@&quot;
    else
      perl -e 'printf &quot;\033[30;101m[FAIL]\033[0m @ARGV\n&quot;' &quot;$@&quot;
    fi
  }
  export -f tester
  parallel tester my_program ::: arg1 arg2
  parallel tester exit ::: 1 0 2 0
</pre>
<div class="Pp"></div>
If <b>my_program</b> fails a red FAIL will be printed followed by the failing
  command; otherwise a green OK will be printed followed by the command.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Log_rotate"><a class="selflink" href="#EXAMPLE:_Log_rotate">EXAMPLE:
  Log rotate</a></h1>
Log rotation renames a logfile to an extension with a higher number: log.1
  becomes log.2, log.2 becomes log.3, and so on. The oldest log is removed. To
  avoid overwriting files the process starts backwards from the high number to
  the low number. This will keep 10 old versions of the log:
<div class="Pp"></div>
<pre>
  seq 9 -1 1 | parallel -j1 mv log.{} log.'{= $_++ =}'
  mv log log.1
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Removing_file_extension_when_processing_files"><a class="selflink" href="#EXAMPLE:_Removing_file_extension_when_processing_files">EXAMPLE:
  Removing file extension when processing files</a></h1>
When processing files removing the file extension using <b>{.}</b> is often
  useful.
<div class="Pp"></div>
Create a directory for each zip-file and unzip it in that dir:
<div class="Pp"></div>
<pre>
  parallel 'mkdir {.}; cd {.}; unzip ../{}' ::: *.zip
</pre>
<div class="Pp"></div>
Recompress all .gz files in current directory using <b>bzip2</b> running 1 job
  per CPU core in parallel:
<div class="Pp"></div>
<pre>
  parallel &quot;zcat {} | bzip2 &gt;{.}.bz2 &amp;&amp; rm {}&quot; ::: *.gz
</pre>
<div class="Pp"></div>
Convert all WAV files to MP3 using LAME:
<div class="Pp"></div>
<pre>
  find sounddir -type f -name '*.wav' | parallel lame {} -o {.}.mp3
</pre>
<div class="Pp"></div>
Put all converted in the same directory:
<div class="Pp"></div>
<pre>
  find sounddir -type f -name '*.wav' | \
    parallel lame {} -o mydir/{/.}.mp3
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Removing_two_file_extensions_when_processing_files"><a class="selflink" href="#EXAMPLE:_Removing_two_file_extensions_when_processing_files">EXAMPLE:
  Removing two file extensions when processing files</a></h1>
If you have directory with tar.gz files and want these extracted in the
  corresponding dir (e.g foo.tar.gz will be extracted in the dir foo) you can
  do:
<div class="Pp"></div>
<pre>
  parallel --plus 'mkdir {..}; tar -C {..} -xf {}' ::: *.tar.gz
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Download_10_images_for_each_of_the_past_30_days"><a class="selflink" href="#EXAMPLE:_Download_10_images_for_each_of_the_past_30_days">EXAMPLE:
  Download 10 images for each of the past 30 days</a></h1>
Let us assume a website stores images like:
<div class="Pp"></div>
<pre>
  http://www.example.com/path/to/YYYYMMDD_##.jpg
</pre>
<div class="Pp"></div>
where YYYYMMDD is the date and ## is the number 01-10. This will download images
  for the past 30 days:
<div class="Pp"></div>
<pre>
  parallel wget http://www.example.com/path/to/'$(date -d &quot;today -{1} days&quot; +%Y%m%d)_{2}.jpg' ::: $(seq 30) ::: $(seq -w 10)
</pre>
<div class="Pp"></div>
<b>$(date -d &quot;today -{1} days&quot; +%Y%m%d)</b> will give the dates in
  YYYYMMDD with <b>{1}</b> days subtracted.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Copy_files_as_last_modified_date_(ISO8601)_with_added_random_digits"><a class="selflink" href="#EXAMPLE:_Copy_files_as_last_modified_date_(ISO8601)_with_added_random_digits">EXAMPLE:
  Copy files as last modified date (ISO8601) with added random digits</a></h1>
<pre>
  find . | parallel cp {} \
    '../destdir/{= $a=int(10000*rand); $_=`date -r &quot;$_&quot; +%FT%T&quot;$a&quot;`; chomp; =}'
</pre>
<div class="Pp"></div>
<b>{=</b> and <b>=}</b> mark a perl expression. <b>date +%FT%T</b> is the date
  in ISO8601 with time.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Digtal_clock_with_&quot;blinking&quot;_:"><a class="selflink" href="#EXAMPLE:_Digtal_clock_with_&quot;blinking&quot;_:">EXAMPLE:
  Digtal clock with &quot;blinking&quot; :</a></h1>
The : in a digital clock blinks. To make every other line have a ':' and the
  rest a ' ' a perl expression is used to look at the 3rd input source. If the
  value modudo 2 is 1: Use &quot;:&quot; otherwise use &quot; &quot;:
<div class="Pp"></div>
<pre>
  parallel -k echo {1}'{=3 $_=$_%2?&quot;:&quot;:&quot; &quot;=}'{2}{3} \
    ::: {0..12} ::: {0..5} ::: {0..9}
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Aggregating_content_of_files"><a class="selflink" href="#EXAMPLE:_Aggregating_content_of_files">EXAMPLE:
  Aggregating content of files</a></h1>
This:
<div class="Pp"></div>
<pre>
  parallel --header : echo x{X}y{Y}z{Z} \&gt; x{X}y{Y}z{Z} \
  ::: X {1..5} ::: Y {01..10} ::: Z {1..5}
</pre>
<div class="Pp"></div>
will generate the files x1y01z1 .. x5y10z5. If you want to aggregate the output
  grouping on x and z you can do this:
<div class="Pp"></div>
<pre>
  parallel eval 'cat {=s/y01/y*/=} &gt; {=s/y01//=}' ::: *y01*
</pre>
<div class="Pp"></div>
For all values of x and z it runs commands like:
<div class="Pp"></div>
<pre>
  cat x1y*z1 &gt; x1z1
</pre>
<div class="Pp"></div>
So you end up with x1z1 .. x5z5 each containing the content of all values of y.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Breadth_first_parallel_web_crawler/mirrorer"><a class="selflink" href="#EXAMPLE:_Breadth_first_parallel_web_crawler/mirrorer">EXAMPLE:
  Breadth first parallel web crawler/mirrorer</a></h1>
This script below will crawl and mirror a URL in parallel. It downloads first
  pages that are 1 click down, then 2 clicks down, then 3; instead of the normal
  depth first, where the first link link on each page is fetched first.
<div class="Pp"></div>
Run like this:
<div class="Pp"></div>
<pre>
  PARALLEL=-j100 ./parallel-crawl http://gatt.org.yeslab.org/
</pre>
<div class="Pp"></div>
Remove the <b>wget</b> part if you only want a web crawler.
<div class="Pp"></div>
It works by fetching a page from a list of URLs and looking for links in that
  page that are within the same starting URL and that have not already been
  seen. These links are added to a new queue. When all the pages from the list
  is done, the new queue is moved to the list of URLs and the process is started
  over until no unseen links are found.
<div class="Pp"></div>
<pre>
  #!/bin/bash
  # E.g. http://gatt.org.yeslab.org/
  URL=$1
  # Stay inside the start dir
  BASEURL=$(echo $URL | perl -pe 's:#.*::; s:(//.*/)[^/]*:$1:')
  URLLIST=$(mktemp urllist.XXXX)
  URLLIST2=$(mktemp urllist.XXXX)
  SEEN=$(mktemp seen.XXXX)
  # Spider to get the URLs
  echo $URL &gt;$URLLIST
  cp $URLLIST $SEEN
  while [ -s $URLLIST ] ; do
    cat $URLLIST |
      parallel lynx -listonly -image_links -dump {} \; \
        wget -qm -l1 -Q1 {} \; echo Spidered: {} \&gt;\&amp;2 |
        perl -ne 's/#.*//; s/\s+\d+.\s(\S+)$/$1/ and do { $seen{$1}++ or print }' |
      grep -F $BASEURL |
      grep -v -x -F -f $SEEN | tee -a $SEEN &gt; $URLLIST2
    mv $URLLIST2 $URLLIST
  done
  rm -f $URLLIST $URLLIST2 $SEEN
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Process_files_from_a_tar_file_while_unpacking"><a class="selflink" href="#EXAMPLE:_Process_files_from_a_tar_file_while_unpacking">EXAMPLE:
  Process files from a tar file while unpacking</a></h1>
If the files to be processed are in a tar file then unpacking one file and
  processing it immediately may be faster than first unpacking all files.
<div class="Pp"></div>
<pre>
  tar xvf foo.tgz | perl -ne 'print $l;$l=$_;END{print $l}' | \
    parallel echo
</pre>
<div class="Pp"></div>
The Perl one-liner is needed to make sure the file is complete before handing it
  to GNU <b>parallel</b>.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Rewriting_a_for-loop_and_a_while-read-loop"><a class="selflink" href="#EXAMPLE:_Rewriting_a_for-loop_and_a_while-read-loop">EXAMPLE:
  Rewriting a for-loop and a while-read-loop</a></h1>
for-loops like this:
<div class="Pp"></div>
<pre>
  (for x in `cat list` ; do
    do_something $x
  done) | process_output
</pre>
<div class="Pp"></div>
and while-read-loops like this:
<div class="Pp"></div>
<pre>
  cat list | (while read x ; do
    do_something $x
  done) | process_output
</pre>
<div class="Pp"></div>
can be written like this:
<div class="Pp"></div>
<pre>
  cat list | parallel do_something | process_output
</pre>
<div class="Pp"></div>
For example: Find which host name in a list has IP address 1.2.3 4:
<div class="Pp"></div>
<pre>
  cat hosts.txt | parallel -P 100 host | grep 1.2.3.4
</pre>
<div class="Pp"></div>
If the processing requires more steps the for-loop like this:
<div class="Pp"></div>
<pre>
  (for x in `cat list` ; do
    no_extension=${x%.*};
    do_something $x scale $no_extension.jpg
    do_step2 &lt;$x $no_extension
  done) | process_output
</pre>
<div class="Pp"></div>
and while-loops like this:
<div class="Pp"></div>
<pre>
  cat list | (while read x ; do
    no_extension=${x%.*};
    do_something $x scale $no_extension.jpg
    do_step2 &lt;$x $no_extension
  done) | process_output
</pre>
<div class="Pp"></div>
can be written like this:
<div class="Pp"></div>
<pre>
  cat list | parallel &quot;do_something {} scale {.}.jpg ; do_step2 &lt;{} {.}&quot; |\
    process_output
</pre>
<div class="Pp"></div>
If the body of the loop is bigger, it improves readability to use a function:
<div class="Pp"></div>
<pre>
  (for x in `cat list` ; do
    do_something $x
    [... 100 lines that do something with $x ...]
  done) | process_output
  cat list | (while read x ; do
    do_something $x
    [... 100 lines that do something with $x ...]
  done) | process_output
</pre>
<div class="Pp"></div>
can both be rewritten as:
<div class="Pp"></div>
<pre>
  doit() {
    x=$1
    do_something $x
    [... 100 lines that do something with $x ...]
  }
  export -f doit
  cat list | parallel doit
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Rewriting_nested_for-loops"><a class="selflink" href="#EXAMPLE:_Rewriting_nested_for-loops">EXAMPLE:
  Rewriting nested for-loops</a></h1>
Nested for-loops like this:
<div class="Pp"></div>
<pre>
  (for x in `cat xlist` ; do
    for y in `cat ylist` ; do
      do_something $x $y
    done
  done) | process_output
</pre>
<div class="Pp"></div>
can be written like this:
<div class="Pp"></div>
<pre>
  parallel do_something {1} {2} :::: xlist ylist | process_output
</pre>
<div class="Pp"></div>
Nested for-loops like this:
<div class="Pp"></div>
<pre>
  (for colour in red green blue ; do
    for size in S M L XL XXL ; do
      echo $colour $size
    done
  done) | sort
</pre>
<div class="Pp"></div>
can be written like this:
<div class="Pp"></div>
<pre>
  parallel echo {1} {2} ::: red green blue ::: S M L XL XXL | sort
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Finding_the_lowest_difference_between_files"><a class="selflink" href="#EXAMPLE:_Finding_the_lowest_difference_between_files">EXAMPLE:
  Finding the lowest difference between files</a></h1>
<b>diff</b> is good for finding differences in text files. <b>diff | wc -l</b>
  gives an indication of the size of the difference. To find the differences
  between all files in the current dir do:
<div class="Pp"></div>
<pre>
  parallel --tag 'diff {1} {2} | wc -l' ::: * ::: * | sort -nk3
</pre>
<div class="Pp"></div>
This way it is possible to see if some files are closer to other files.
<h1 class="Sh" title="Sh" id="EXAMPLE:_for-loops_with_column_names"><a class="selflink" href="#EXAMPLE:_for-loops_with_column_names">EXAMPLE:
  for-loops with column names</a></h1>
When doing multiple nested for-loops it can be easier to keep track of the loop
  variable if is is named instead of just having a number. Use <b>--header :</b>
  to let the first argument be an named alias for the positional replacement
  string:
<div class="Pp"></div>
<pre>
  parallel --header : echo {colour} {size} ::: colour red green blue ::: size S M L XL XXL
</pre>
<div class="Pp"></div>
This also works if the input file is a file with columns:
<div class="Pp"></div>
<pre>
  cat addressbook.tsv | \
    parallel --colsep '\t' --header : echo {Name} {E-mail address}
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Count_the_differences_between_all_files_in_a_dir"><a class="selflink" href="#EXAMPLE:_Count_the_differences_between_all_files_in_a_dir">EXAMPLE:
  Count the differences between all files in a dir</a></h1>
Using <b>--results</b> the results are saved in /tmp/diffcount*.
<div class="Pp"></div>
<pre>
  parallel --results /tmp/diffcount &quot;diff -U 0 {1} {2} | \
    tail -n +3 |grep -v '^@'|wc -l&quot; ::: * ::: *
</pre>
<div class="Pp"></div>
To see the difference between file A and file B look at the file
  '/tmp/diffcount/1/A/2/B'.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Speeding_up_fast_jobs"><a class="selflink" href="#EXAMPLE:_Speeding_up_fast_jobs">EXAMPLE:
  Speeding up fast jobs</a></h1>
Starting a job on the local machine takes around 10 ms. This can be a big
  overhead if the job takes very few ms to run. Often you can group small jobs
  together using <b>-X</b> which will make the overhead less significant.
  Compare the speed of these:
<div class="Pp"></div>
<pre>
  seq -w 0 9999 | parallel touch pict{}.jpg
  seq -w 0 9999 | parallel -X touch pict{}.jpg
</pre>
<div class="Pp"></div>
If your program cannot take multiple arguments, then you can use GNU
  <b>parallel</b> to spawn multiple GNU <b>parallel</b>s:
<div class="Pp"></div>
<pre>
  seq -w 0 999999 | parallel -j10 --pipe parallel -j0 touch pict{}.jpg
</pre>
<div class="Pp"></div>
If <b>-j0</b> normally spawns 252 jobs, then the above will try to spawn 2520
  jobs. On a normal GNU/Linux system you can spawn 32000 jobs using this
  technique with no problems. To raise the 32000 jobs limit raise
  /proc/sys/kernel/pid_max to 4194303.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Using_shell_variables"><a class="selflink" href="#EXAMPLE:_Using_shell_variables">EXAMPLE:
  Using shell variables</a></h1>
When using shell variables you need to quote them correctly as they may
  otherwise be split on spaces.
<div class="Pp"></div>
Notice the difference between:
<div class="Pp"></div>
<pre>
  V=(&quot;My brother's 12\&quot; records are worth &lt;\$\$\$&gt;&quot;'!' Foo Bar)
  parallel echo ::: ${V[@]} # This is probably not what you want
</pre>
<div class="Pp"></div>
and:
<div class="Pp"></div>
<pre>
  V=(&quot;My brother's 12\&quot; records are worth &lt;\$\$\$&gt;&quot;'!' Foo Bar)
  parallel echo ::: &quot;${V[@]}&quot;
</pre>
<div class="Pp"></div>
When using variables in the actual command that contains special characters
  (e.g. space) you can quote them using <b>'&quot;$VAR&quot;'</b> or using
  &quot;'s and <b>-q</b>:
<div class="Pp"></div>
<pre>
  V=&quot;Here  are  two &quot;
  parallel echo &quot;'$V'&quot; ::: spaces
  parallel -q echo &quot;$V&quot; ::: spaces
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Group_output_lines"><a class="selflink" href="#EXAMPLE:_Group_output_lines">EXAMPLE:
  Group output lines</a></h1>
When running jobs that output data, you often do not want the output of multiple
  jobs to run together. GNU <b>parallel</b> defaults to grouping the output of
  each job, so the output is printed when the job finishes. If you want full
  lines to be printed while the job is running you can use <b>--line-buffer</b>.
  If you want output to be printed as soon as possible you can use <b>-u</b>.
<div class="Pp"></div>
Compare the output of:
<div class="Pp"></div>
<pre>
  parallel traceroute ::: qubes-os.org debian.org freenetproject.org
  parallel --line-buffer traceroute ::: qubes-os.org debian.org freenetproject.org
  parallel -u traceroute ::: qubes-os.org debian.org freenetproject.org
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Tag_output_lines"><a class="selflink" href="#EXAMPLE:_Tag_output_lines">EXAMPLE:
  Tag output lines</a></h1>
GNU <b>parallel</b> groups the output lines, but it can be hard to see where the
  different jobs begin. <b>--tag</b> prepends the argument to make that more
  visible:
<div class="Pp"></div>
<pre>
  parallel --tag traceroute ::: qubes-os.org debian.org freenetproject.org
</pre>
<div class="Pp"></div>
<b>--tag</b> works with <b>--line-buffer</b> but not with <b>-u</b>:
<div class="Pp"></div>
<pre>
  parallel --tag --line-buffer traceroute \
    ::: qubes-os.org debian.org freenetproject.org
</pre>
<div class="Pp"></div>
Check the uptime of the servers in <i>~/.parallel/sshloginfile</i>:
<div class="Pp"></div>
<pre>
  parallel --tag -S .. --nonall uptime
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Keep_order_of_output_same_as_order_of_input"><a class="selflink" href="#EXAMPLE:_Keep_order_of_output_same_as_order_of_input">EXAMPLE:
  Keep order of output same as order of input</a></h1>
Normally the output of a job will be printed as soon as it completes. Sometimes
  you want the order of the output to remain the same as the order of the input.
  This is often important, if the output is used as input for another system.
  <b>-k</b> will make sure the order of output will be in the same order as
  input even if later jobs end before earlier jobs.
<div class="Pp"></div>
Append a string to every line in a text file:
<div class="Pp"></div>
<pre>
  cat textfile | parallel -k echo {} append_string
</pre>
<div class="Pp"></div>
If you remove <b>-k</b> some of the lines may come out in the wrong order.
<div class="Pp"></div>
Another example is <b>traceroute</b>:
<div class="Pp"></div>
<pre>
  parallel traceroute ::: qubes-os.org debian.org freenetproject.org
</pre>
<div class="Pp"></div>
will give traceroute of qubes-os.org, debian.org and freenetproject.org, but it
  will be sorted according to which job completed first.
<div class="Pp"></div>
To keep the order the same as input run:
<div class="Pp"></div>
<pre>
  parallel -k traceroute ::: qubes-os.org debian.org freenetproject.org
</pre>
<div class="Pp"></div>
This will make sure the traceroute to qubes-os.org will be printed first.
<div class="Pp"></div>
A bit more complex example is downloading a huge file in chunks in parallel:
  Some internet connections will deliver more data if you download files in
  parallel. For downloading files in parallel see: &quot;EXAMPLE: Download 10
  images for each of the past 30 days&quot;. But if you are downloading a big
  file you can download the file in chunks in parallel.
<div class="Pp"></div>
To download byte 10000000-19999999 you can use <b>curl</b>:
<div class="Pp"></div>
<pre>
  curl -r 10000000-19999999 http://example.com/the/big/file &gt;file.part
</pre>
<div class="Pp"></div>
To download a 1 GB file we need 100 10MB chunks downloaded and combined in the
  correct order.
<div class="Pp"></div>
<pre>
  seq 0 99 | parallel -k curl -r \
    {}0000000-{}9999999 http://example.com/the/big/file &gt; file
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Parallel_grep"><a class="selflink" href="#EXAMPLE:_Parallel_grep">EXAMPLE:
  Parallel grep</a></h1>
<b>grep -r</b> greps recursively through directories. On multicore CPUs GNU
  <b>parallel</b> can often speed this up.
<div class="Pp"></div>
<pre>
  find . -type f | parallel -k -j150% -n 1000 -m grep -H -n STRING {}
</pre>
<div class="Pp"></div>
This will run 1.5 job per core, and give 1000 arguments to <b>grep</b>.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Grepping_n_lines_for_m_regular_expressions."><a class="selflink" href="#EXAMPLE:_Grepping_n_lines_for_m_regular_expressions.">EXAMPLE:
  Grepping n lines for m regular expressions.</a></h1>
The simplest solution to grep a big file for a lot of regexps is:
<div class="Pp"></div>
<pre>
  grep -f regexps.txt bigfile
</pre>
<div class="Pp"></div>
Or if the regexps are fixed strings:
<div class="Pp"></div>
<pre>
  grep -F -f regexps.txt bigfile
</pre>
<div class="Pp"></div>
There are 3 limiting factors: CPU, RAM, and disk I/O.
<div class="Pp"></div>
RAM is easy to measure: If the <b>grep</b> process takes up most of your free
  memory (e.g. when running <b>top</b>), then RAM is a limiting factor.
<div class="Pp"></div>
CPU is also easy to measure: If the <b>grep</b> takes &gt;90% CPU in <b>top</b>,
  then the CPU is a limiting factor, and parallelization will speed this up.
<div class="Pp"></div>
It is harder to see if disk I/O is the limiting factor, and depending on the
  disk system it may be faster or slower to parallelize. The only way to know
  for certain is to test and measure.
<h2 class="Ss" title="Ss" id="Limiting_factor:_RAM"><a class="selflink" href="#Limiting_factor:_RAM">Limiting
  factor: RAM</a></h2>
The normal <b>grep -f regexs.txt bigfile</b> works no matter the size of
  bigfile, but if regexps.txt is so big it cannot fit into memory, then you need
  to split this.
<div class="Pp"></div>
<b>grep -F</b> takes around 100 bytes of RAM and <b>grep</b> takes about 500
  bytes of RAM per 1 byte of regexp. So if regexps.txt is 1% of your RAM, then
  it may be too big.
<div class="Pp"></div>
If you can convert your regexps into fixed strings do that. E.g. if the lines
  you are looking for in bigfile all looks like:
<div class="Pp"></div>
<pre>
  ID1 foo bar baz Identifier1 quux
  fubar ID2 foo bar baz Identifier2
</pre>
<div class="Pp"></div>
then your regexps.txt can be converted from:
<div class="Pp"></div>
<pre>
  ID1.*Identifier1
  ID2.*Identifier2
</pre>
<div class="Pp"></div>
into:
<div class="Pp"></div>
<pre>
  ID1 foo bar baz Identifier1
  ID2 foo bar baz Identifier2
</pre>
<div class="Pp"></div>
This way you can use <b>grep -F</b> which takes around 80% less memory and is
  much faster.
<div class="Pp"></div>
If it still does not fit in memory you can do this:
<div class="Pp"></div>
<pre>
  parallel --pipepart -a regexps.txt --block 1M grep -F -f - -n bigfile |
    sort -un | perl -pe 's/^\d+://'
</pre>
<div class="Pp"></div>
The 1M should be your free memory divided by the number of cores and divided by
  200 for <b>grep -F</b> and by 1000 for normal <b>grep</b>. On GNU/Linux you
  can do:
<div class="Pp"></div>
<pre>
  free=$(awk '/^((Swap)?Cached|MemFree|Buffers):/ { sum += $2 }
              END { print sum }' /proc/meminfo)
  percpu=$((free / 200 / $(parallel --number-of-cores)))k
  parallel --pipepart -a regexps.txt --block $percpu --compress grep -F -f - -n bigfile |
    sort -un | perl -pe 's/^\d+://'
</pre>
<div class="Pp"></div>
If you can live with duplicated lines and wrong order, it is faster to do:
<div class="Pp"></div>
<pre>
  parallel --pipepart -a regexps.txt --block $percpu --compress grep -F -f - bigfile
</pre>
<h2 class="Ss" title="Ss" id="Limiting_factor:_CPU"><a class="selflink" href="#Limiting_factor:_CPU">Limiting
  factor: CPU</a></h2>
If the CPU is the limiting factor parallelization should be done on the regexps:
<div class="Pp"></div>
<pre>
  cat regexp.txt | parallel --pipe -L1000 --round-robin --compress grep -f - -n bigfile |
    sort -un | perl -pe 's/^\d+://'
</pre>
<div class="Pp"></div>
The command will start one <b>grep</b> per CPU and read <i>bigfile</i> one time
  per CPU, but as that is done in parallel, all reads except the first will be
  cached in RAM. Depending on the size of <i>regexp.txt</i> it may be faster to
  use <b>--block 10m</b> instead of <b>-L1000</b>.
<div class="Pp"></div>
Some storage systems perform better when reading multiple chunks in parallel.
  This is true for some RAID systems and for some network file systems. To
  parallelize the reading of <i>bigfile</i>:
<div class="Pp"></div>
<pre>
  parallel --pipepart --block 100M -a bigfile -k --compress grep -f regexp.txt
</pre>
<div class="Pp"></div>
This will split <i>bigfile</i> into 100MB chunks and run <b>grep</b> on each of
  these chunks. To parallelize both reading of <i>bigfile</i> and
  <i>regexp.txt</i> combine the two using <b>--fifo</b>:
<div class="Pp"></div>
<pre>
  parallel --pipepart --block 100M -a bigfile --fifo cat regexp.txt \
    \| parallel --pipe -L1000 --round-robin grep -f - {}
</pre>
<div class="Pp"></div>
If a line matches multiple regexps, the line may be duplicated.
<h2 class="Ss" title="Ss" id="Bigger_problem"><a class="selflink" href="#Bigger_problem">Bigger
  problem</a></h2>
If the problem is too big to be solved by this, you are probably ready for
  Lucene.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Using_remote_computers"><a class="selflink" href="#EXAMPLE:_Using_remote_computers">EXAMPLE:
  Using remote computers</a></h1>
To run commands on a remote computer SSH needs to be set up and you must be able
  to login without entering a password (The commands <b>ssh-copy-id</b>,
  <b>ssh-agent</b>, and <b>sshpass</b> may help you do that).
<div class="Pp"></div>
If you need to login to a whole cluster, you typically do not want to accept the
  host key for every host. You want to accept them the first time and be warned
  if they are ever changed. To do that:
<div class="Pp"></div>
<pre>
  # Add the servers to the sshloginfile
  (echo servera; echo serverb) &gt; .parallel/my_cluster
  # Make sure .ssh/config exist
  touch .ssh/config
  cp .ssh/config .ssh/config.backup
  # Disable StrictHostKeyChecking temporarily
  (echo 'Host *'; echo StrictHostKeyChecking no) &gt;&gt; .ssh/config
  parallel --slf my_cluster --nonall true
  # Remove the disabling of StrictHostKeyChecking
  mv .ssh/config.backup .ssh/config
</pre>
<div class="Pp"></div>
The servers in <b>.parallel/my_cluster</b> are now added in
  <b>.ssh/known_hosts</b>.
<div class="Pp"></div>
To run <b>echo</b> on <b>server.example.com</b>:
<div class="Pp"></div>
<pre>
  seq 10 | parallel --sshlogin server.example.com echo
</pre>
<div class="Pp"></div>
To run commands on more than one remote computer run:
<div class="Pp"></div>
<pre>
  seq 10 | parallel --sshlogin server.example.com,server2.example.net echo
</pre>
<div class="Pp"></div>
Or:
<div class="Pp"></div>
<pre>
  seq 10 | parallel --sshlogin server.example.com \
    --sshlogin server2.example.net echo
</pre>
<div class="Pp"></div>
If the login username is <i>foo</i> on <i>server2.example.net</i> use:
<div class="Pp"></div>
<pre>
  seq 10 | parallel --sshlogin server.example.com \
    --sshlogin foo@server2.example.net echo
</pre>
<div class="Pp"></div>
If your list of hosts is <i>server1-88.example.net</i> with login <i>foo</i>:
<div class="Pp"></div>
<pre>
  seq 10 | parallel -Sfoo@server{1..88}.example.net echo
</pre>
<div class="Pp"></div>
To distribute the commands to a list of computers, make a file
  <i>mycomputers</i> with all the computers:
<div class="Pp"></div>
<pre>
  server.example.com
  foo@server2.example.com
  server3.example.com
</pre>
<div class="Pp"></div>
Then run:
<div class="Pp"></div>
<pre>
  seq 10 | parallel --sshloginfile mycomputers echo
</pre>
<div class="Pp"></div>
To include the local computer add the special sshlogin ':' to the list:
<div class="Pp"></div>
<pre>
  server.example.com
  foo@server2.example.com
  server3.example.com
  :
</pre>
<div class="Pp"></div>
GNU <b>parallel</b> will try to determine the number of CPU cores on each of the
  remote computers, and run one job per CPU core - even if the remote computers
  do not have the same number of CPU cores.
<div class="Pp"></div>
If the number of CPU cores on the remote computers is not identified correctly
  the number of CPU cores can be added in front. Here the computer has 8 CPU
  cores.
<div class="Pp"></div>
<pre>
  seq 10 | parallel --sshlogin 8/server.example.com echo
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Transferring_of_files"><a class="selflink" href="#EXAMPLE:_Transferring_of_files">EXAMPLE:
  Transferring of files</a></h1>
To recompress gzipped files with <b>bzip2</b> using a remote computer run:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | \
    parallel --sshlogin server.example.com \
    --transfer &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
This will list the .gz-files in the <i>logs</i> directory and all directories
  below. Then it will transfer the files to <i>server.example.com</i> to the
  corresponding directory in <i></i><i>$HOME</i><i>/logs</i>. On
  <i>server.example.com</i> the file will be recompressed using <b>zcat</b> and
  <b>bzip2</b> resulting in the corresponding file with <i>.gz</i> replaced with
  <i>.bz2</i>.
<div class="Pp"></div>
If you want the resulting bz2-file to be transferred back to the local computer
  add <i>--return {.}.bz2</i>:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | \
    parallel --sshlogin server.example.com \
    --transfer --return {.}.bz2 &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
After the recompressing is done the <i>.bz2</i>-file is transferred back to the
  local computer and put next to the original <i>.gz</i>-file.
<div class="Pp"></div>
If you want to delete the transferred files on the remote computer add
  <i>--cleanup</i>. This will remove both the file transferred to the remote
  computer and the files transferred from the remote computer:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | \
    parallel --sshlogin server.example.com \
    --transfer --return {.}.bz2 --cleanup &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
If you want run on several computers add the computers to <i>--sshlogin</i>
  either using ',' or multiple <i>--sshlogin</i>:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | \
    parallel --sshlogin server.example.com,server2.example.com \
    --sshlogin server3.example.com \
    --transfer --return {.}.bz2 --cleanup &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
You can add the local computer using <i>--sshlogin :</i>. This will disable the
  removing and transferring for the local computer only:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | \
    parallel --sshlogin server.example.com,server2.example.com \
    --sshlogin server3.example.com \
    --sshlogin : \
    --transfer --return {.}.bz2 --cleanup &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
Often <i>--transfer</i>, <i>--return</i> and <i>--cleanup</i> are used together.
  They can be shortened to <i>--trc</i>:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | \
    parallel --sshlogin server.example.com,server2.example.com \
    --sshlogin server3.example.com \
    --sshlogin : \
    --trc {.}.bz2 &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
With the file <i>mycomputers</i> containing the list of computers it becomes:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | parallel --sshloginfile mycomputers \
    --trc {.}.bz2 &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
If the file <i>~/.parallel/sshloginfile</i> contains the list of computers the
  special short hand <i>-S ..</i> can be used:
<div class="Pp"></div>
<pre>
  find logs/ -name '*.gz' | parallel -S .. \
    --trc {.}.bz2 &quot;zcat {} | bzip2 -9 &gt;{.}.bz2&quot;
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Distributing_work_to_local_and_remote_computers"><a class="selflink" href="#EXAMPLE:_Distributing_work_to_local_and_remote_computers">EXAMPLE:
  Distributing work to local and remote computers</a></h1>
Convert *.mp3 to *.ogg running one process per CPU core on local computer and
  server2:
<div class="Pp"></div>
<pre>
  parallel --trc {.}.ogg -S server2,: \
    'mpg321 -w - {} | oggenc -q0 - -o {.}.ogg' ::: *.mp3
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Running_the_same_command_on_remote_computers"><a class="selflink" href="#EXAMPLE:_Running_the_same_command_on_remote_computers">EXAMPLE:
  Running the same command on remote computers</a></h1>
To run the command <b>uptime</b> on remote computers you can do:
<div class="Pp"></div>
<pre>
  parallel --tag --nonall -S server1,server2 uptime
</pre>
<div class="Pp"></div>
<b>--nonall</b> reads no arguments. If you have a list of jobs you want run on
  each computer you can do:
<div class="Pp"></div>
<pre>
  parallel --tag --onall -S server1,server2 echo ::: 1 2 3
</pre>
<div class="Pp"></div>
Remove <b>--tag</b> if you do not want the sshlogin added before the output.
<div class="Pp"></div>
If you have a lot of hosts use '-j0' to access more hosts in parallel.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Using_remote_computers_behind_NAT_wall"><a class="selflink" href="#EXAMPLE:_Using_remote_computers_behind_NAT_wall">EXAMPLE:
  Using remote computers behind NAT wall</a></h1>
If the workers are behind a NAT wall, you need some trickery to get to them.
<div class="Pp"></div>
If you can <b>ssh</b> to a jump host, and reach the workers from there, then the
  obvious solution would be this, but it <b>does not work</b>:
<div class="Pp"></div>
<pre>
  parallel --ssh 'ssh jumphost ssh' -S host1 echo ::: DOES NOT WORK
</pre>
<div class="Pp"></div>
It does not work because the command is dequoted by <b>ssh</b> twice where as
  GNU <b>parallel</b> only expects it to be dequoted once.
<div class="Pp"></div>
So instead put this in <b>~/.ssh/config</b>:
<div class="Pp"></div>
<pre>
  Host host1 host2 host3
    ProxyCommand ssh jumphost.domain nc -w 1 %h 22
</pre>
<div class="Pp"></div>
It requires <b>nc(netcat)</b> to be installed on jumphost. With this you can
  simply:
<div class="Pp"></div>
<pre>
  parallel -S host1,host2,host3 echo ::: This does work
</pre>
<h2 class="Ss" title="Ss" id="No_jumphost,_but_port_forwards"><a class="selflink" href="#No_jumphost,_but_port_forwards">No
  jumphost, but port forwards</a></h2>
If there is no jumphost but each server has port 22 forwarded from the firewall
  (e.g. the firewall's port 22001 = port 22 on host1, 22002 = host2, 22003 =
  host3) then you can use <b>~/.ssh/config</b>:
<div class="Pp"></div>
<pre>
  Host host1.v
    Port 22001
  Host host2.v
    Port 22002
  Host host3.v
    Port 22003
  Host *.v
    Hostname firewall
</pre>
<div class="Pp"></div>
And then use host{1..3}.v as normal hosts:
<div class="Pp"></div>
<pre>
  parallel -S host1.v,host2.v,host3.v echo ::: a b c
</pre>
<h2 class="Ss" title="Ss" id="No_jumphost,_no_port_forwards"><a class="selflink" href="#No_jumphost,_no_port_forwards">No
  jumphost, no port forwards</a></h2>
If ports cannot be forwarded, you need some sort of VPN to traverse the
  NAT-wall. TOR is one options for that, as it is very easy to get working.
<div class="Pp"></div>
You need to install TOR and setup a hidden service. In <b>torrc</b> put:
<div class="Pp"></div>
<pre>
  HiddenServiceDir /var/lib/tor/hidden_service/
  HiddenServicePort 22 127.0.0.1:22
</pre>
<div class="Pp"></div>
Then start TOR: <b>/etc/init.d/tor restart</b>
<div class="Pp"></div>
The TOR hostname is now in <b>/var/lib/tor/hidden_service/hostname</b> and is
  something similar to <b>izjafdceobowklhz.onion</b>. Now you simply prepend
  <b>torsocks</b> to <b>ssh</b>:
<div class="Pp"></div>
<pre>
  parallel --ssh 'torsocks ssh' -S izjafdceobowklhz.onion \
    -S zfcdaeiojoklbwhz.onion,auclucjzobowklhi.onion echo ::: a b c
</pre>
<div class="Pp"></div>
If not all hosts are accessible through TOR:
<div class="Pp"></div>
<pre>
  parallel -S 'torsocks ssh izjafdceobowklhz.onion,host2,host3' echo ::: a b c
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Parallelizing_rsync"><a class="selflink" href="#EXAMPLE:_Parallelizing_rsync">EXAMPLE:
  Parallelizing rsync</a></h1>
<b>rsync</b> is a great tool, but sometimes it will not fill up the available
  bandwidth. This is often a problem when copying several big files over high
  speed connections.
<div class="Pp"></div>
The following will start one <b>rsync</b> per big file in <i>src-dir</i> to
  <i>dest-dir</i> on the server <i>fooserver</i>:
<div class="Pp"></div>
<pre>
  cd src-dir; find . -type f -size +100000 | \
    parallel -v ssh fooserver mkdir -p /dest-dir/{//}\; \
      rsync -s -Havessh {} fooserver:/dest-dir/{}
</pre>
<div class="Pp"></div>
The dirs created may end up with wrong permissions and smaller files are not
  being transferred. To fix those run <b>rsync</b> a final time:
<div class="Pp"></div>
<pre>
  rsync -Havessh src-dir/ fooserver:/dest-dir/
</pre>
<div class="Pp"></div>
If you are unable to push data, but need to pull them and the files are called
  digits.png (e.g. 000000.png) you might be able to do:
<div class="Pp"></div>
<pre>
  seq -w 0 99 | parallel rsync -Havessh fooserver:src-path/*{}.png destdir/
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Use_multiple_inputs_in_one_command"><a class="selflink" href="#EXAMPLE:_Use_multiple_inputs_in_one_command">EXAMPLE:
  Use multiple inputs in one command</a></h1>
Copy files like foo.es.ext to foo.ext:
<div class="Pp"></div>
<pre>
  ls *.es.* | perl -pe 'print; s/\.es//' | parallel -N2 cp {1} {2}
</pre>
<div class="Pp"></div>
The perl command spits out 2 lines for each input. GNU <b>parallel</b> takes 2
  inputs (using <b>-N2</b>) and replaces {1} and {2} with the inputs.
<div class="Pp"></div>
Count in binary:
<div class="Pp"></div>
<pre>
  parallel -k echo ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1
</pre>
<div class="Pp"></div>
Print the number on the opposing sides of a six sided die:
<div class="Pp"></div>
<pre>
  parallel --xapply -a &lt;(seq 6) -a &lt;(seq 6 -1 1) echo
  parallel --xapply echo :::: &lt;(seq 6) &lt;(seq 6 -1 1)
</pre>
<div class="Pp"></div>
Convert files from all subdirs to PNG-files with consecutive numbers (useful for
  making input PNG's for <b>ffmpeg</b>):
<div class="Pp"></div>
<pre>
  parallel --xapply -a &lt;(find . -type f | sort) \
    -a &lt;(seq $(find . -type f|wc -l)) convert {1} {2}.png
</pre>
<div class="Pp"></div>
Alternative version:
<div class="Pp"></div>
<pre>
  find . -type f | sort | parallel convert {} {#}.png
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Use_a_table_as_input"><a class="selflink" href="#EXAMPLE:_Use_a_table_as_input">EXAMPLE:
  Use a table as input</a></h1>
Content of table_file.tsv:
<div class="Pp"></div>
<pre>
  foo&lt;TAB&gt;bar
  baz &lt;TAB&gt; quux
</pre>
<div class="Pp"></div>
To run:
<div class="Pp"></div>
<pre>
  cmd -o bar -i foo
  cmd -o quux -i baz
</pre>
<div class="Pp"></div>
you can run:
<div class="Pp"></div>
<pre>
  parallel -a table_file.tsv --colsep '\t' cmd -o {2} -i {1}
</pre>
<div class="Pp"></div>
Note: The default for GNU <b>parallel</b> is to remove the spaces around the
  columns. To keep the spaces:
<div class="Pp"></div>
<pre>
  parallel -a table_file.tsv --trim n --colsep '\t' cmd -o {2} -i {1}
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Run_the_same_command_10_times"><a class="selflink" href="#EXAMPLE:_Run_the_same_command_10_times">EXAMPLE:
  Run the same command 10 times</a></h1>
If you want to run the same command with the same arguments 10 times in parallel
  you can do:
<div class="Pp"></div>
<pre>
  seq 10 | parallel -n0 my_command my_args
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Working_as_cat_|_sh._Resource_inexpensive_jobs_and_evaluation"><a class="selflink" href="#EXAMPLE:_Working_as_cat_|_sh._Resource_inexpensive_jobs_and_evaluation">EXAMPLE:
  Working as cat | sh. Resource inexpensive jobs and evaluation</a></h1>
GNU <b>parallel</b> can work similar to <b>cat | sh</b>.
<div class="Pp"></div>
A resource inexpensive job is a job that takes very little CPU, disk I/O and
  network I/O. Ping is an example of a resource inexpensive job. wget is too -
  if the webpages are small.
<div class="Pp"></div>
The content of the file jobs_to_run:
<div class="Pp"></div>
<pre>
  ping -c 1 10.0.0.1
  wget http://example.com/status.cgi?ip=10.0.0.1
  ping -c 1 10.0.0.2
  wget http://example.com/status.cgi?ip=10.0.0.2
  ...
  ping -c 1 10.0.0.255
  wget http://example.com/status.cgi?ip=10.0.0.255
</pre>
<div class="Pp"></div>
To run 100 processes simultaneously do:
<div class="Pp"></div>
<pre>
  parallel -j 100 &lt; jobs_to_run
</pre>
<div class="Pp"></div>
As there is not a <i>command</i> the jobs will be evaluated by the shell.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Processing_a_big_file_using_more_cores"><a class="selflink" href="#EXAMPLE:_Processing_a_big_file_using_more_cores">EXAMPLE:
  Processing a big file using more cores</a></h1>
To process a big file or some output you can use <b>--pipe</b> to split up the
  data into blocks and pipe the blocks into the processing program.
<div class="Pp"></div>
If the program is <b>gzip -9</b> you can do:
<div class="Pp"></div>
<pre>
  cat bigfile | parallel --pipe --recend '' -k gzip -9 &gt; bigfile.gz
</pre>
<div class="Pp"></div>
This will split <b>bigfile</b> into blocks of 1 MB and pass that to <b>gzip</b>
  <b>-9</b> in parallel. One <b>gzip</b> will be run per CPU core. The output of
  <b>gzip -9</b> will be kept in order and saved to <b>bigfile.gz</b>
<div class="Pp"></div>
<b>gzip</b> works fine if the output is appended, but some processing does not
  work like that - for example sorting. For this GNU <b>parallel</b> can put the
  output of each command into a file. This will sort a big file in parallel:
<div class="Pp"></div>
<pre>
  cat bigfile | parallel --pipe --files sort |\
    parallel -Xj1 sort -m {} ';' rm {} &gt;bigfile.sort
</pre>
<div class="Pp"></div>
Here <b>bigfile</b> is split into blocks of around 1MB, each block ending in
  '\n' (which is the default for <b>--recend</b>). Each block is passed to
  <b>sort</b> and the output from <b>sort</b> is saved into files. These files
  are passed to the second <b>parallel</b> that runs <b>sort -m</b> on the files
  before it removes the files. The output is saved to <b>bigfile.sort</b>.
<div class="Pp"></div>
GNU <b>parallel</b>'s <b>--pipe</b> maxes out at around 100 MB/s because every
  byte has to be copied through GNU <b>parallel</b>. But if <b>bigfile</b> is a
  real (seekable) file GNU <b>parallel</b> can by-pass the copying and send the
  parts directly to the program:
<div class="Pp"></div>
<pre>
  parallel --pipepart --block 100m -a bigfile --files sort |\
    parallel -Xj1 sort -m {} ';' rm {} &gt;bigfile.sort
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Running_more_than_250_jobs_workaround"><a class="selflink" href="#EXAMPLE:_Running_more_than_250_jobs_workaround">EXAMPLE:
  Running more than 250 jobs workaround</a></h1>
If you need to run a massive amount of jobs in parallel, then you will likely
  hit the filehandle limit which is often around 250 jobs. If you are super user
  you can raise the limit in /etc/security/limits.conf but you can also use this
  workaround. The filehandle limit is per process. That means that if you just
  spawn more GNU <b>parallel</b>s then each of them can run 250 jobs. This will
  spawn up to 2500 jobs:
<div class="Pp"></div>
<pre>
  cat myinput |\
    parallel --pipe -N 50 --round-robin -j50 parallel -j50 your_prg
</pre>
<div class="Pp"></div>
This will spawn up to 62500 jobs (use with caution - you need 64 GB RAM to do
  this, and you may need to increase /proc/sys/kernel/pid_max):
<div class="Pp"></div>
<pre>
  cat myinput |\
    parallel --pipe -N 250 --round-robin -j250 parallel -j250 your_prg
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Working_as_mutex_and_counting_semaphore"><a class="selflink" href="#EXAMPLE:_Working_as_mutex_and_counting_semaphore">EXAMPLE:
  Working as mutex and counting semaphore</a></h1>
The command <b>sem</b> is an alias for <b>parallel --semaphore</b>.
<div class="Pp"></div>
A counting semaphore will allow a given number of jobs to be started in the
  background. When the number of jobs are running in the background, GNU
  <b>sem</b> will wait for one of these to complete before starting another
  command. <b>sem --wait</b> will wait for all jobs to complete.
<div class="Pp"></div>
Run 10 jobs concurrently in the background:
<div class="Pp"></div>
<pre>
  for i in *.log ; do
    echo $i
    sem -j10 gzip $i &quot;;&quot; echo done
  done
  sem --wait
</pre>
<div class="Pp"></div>
A mutex is a counting semaphore allowing only one job to run. This will edit the
  file <i>myfile</i> and prepends the file with lines with the numbers 1 to 3.
<div class="Pp"></div>
<pre>
  seq 3 | parallel sem sed -i -e 'i{}' myfile
</pre>
<div class="Pp"></div>
As <i>myfile</i> can be very big it is important only one process edits the file
  at the same time.
<div class="Pp"></div>
Name the semaphore to have multiple different semaphores active at the same
  time:
<div class="Pp"></div>
<pre>
  seq 3 | parallel sem --id mymutex sed -i -e 'i{}' myfile
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Mutex_for_a_script"><a class="selflink" href="#EXAMPLE:_Mutex_for_a_script">EXAMPLE:
  Mutex for a script</a></h1>
Assume a script is called from cron or from a web service, but only one instance
  can be run at a time. With <b>sem</b> and <b>--shebang-wrap</b> the script can
  be made to wait for other instances to finish. Here in <b>bash</b>:
<div class="Pp"></div>
<pre>
  #!/usr/bin/sem --shebang-wrap -u --id $0 --fg /bin/bash
  
  echo This will run
  sleep 5
  echo exclusively
</pre>
<div class="Pp"></div>
Here <b>perl</b>:
<div class="Pp"></div>
<pre>
  #!/usr/bin/sem --shebang-wrap -u --id $0 --fg /usr/bin/perl
  
  print &quot;This will run &quot;;
  sleep 5;
  print &quot;exclusively\n&quot;;
</pre>
<div class="Pp"></div>
Here <b>python</b>:
<div class="Pp"></div>
<pre>
  #!/usr/local/bin/sem --shebang-wrap -u --id $0 --fg /usr/bin/python
  
  import time
  print &quot;This will run &quot;;
  time.sleep(5)
  print &quot;exclusively&quot;;
</pre>
<h1 class="Sh" title="Sh" id="EXAMPLE:_Start_editor_with_filenames_from_stdin_(standard_input)"><a class="selflink" href="#EXAMPLE:_Start_editor_with_filenames_from_stdin_(standard_input)">EXAMPLE:
  Start editor with filenames from stdin (standard input)</a></h1>
You can use GNU <b>parallel</b> to start interactive programs like emacs or vi:
<div class="Pp"></div>
<pre>
  cat filelist | parallel --tty -X emacs
  cat filelist | parallel --tty -X vi
</pre>
<div class="Pp"></div>
If there are more files than will fit on a single command line, the editor will
  be started again with the remaining files.
<h1 class="Sh" title="Sh" id="EXAMPLE:_Running_sudo"><a class="selflink" href="#EXAMPLE:_Running_sudo">EXAMPLE:
  Running sudo</a></h1>
<b>sudo</b> requires a password to run a command as root. It caches the access,
  so you only need to enter the password again if you have not used <b>sudo</b>
  for a while.
<div class="Pp"></div>
The command:
<div class="Pp"></div>
<pre>
  parallel sudo echo ::: This is a bad idea
</pre>
<div class="Pp"></div>
is no good, as you would be prompted for the sudo password for each of the jobs.
  You can either do:
<div class="Pp"></div>
<pre>
  sudo echo This
  parallel sudo echo ::: is a good idea
</pre>
<div class="Pp"></div>
or:
<div class="Pp"></div>
<pre>
  sudo parallel echo ::: This is a good idea
</pre>
<div class="Pp"></div>
This way you only have to enter the sudo password once.
<h1 class="Sh" title="Sh" id="EXAMPLE:_GNU_Parallel_as_queue_system/batch_manager"><a class="selflink" href="#EXAMPLE:_GNU_Parallel_as_queue_system/batch_manager">EXAMPLE:
  GNU Parallel as queue system/batch manager</a></h1>
GNU <b>parallel</b> can work as a simple job queue system or batch manager. The
  idea is to put the jobs into a file and have GNU <b>parallel</b> read from
  that continuously. As GNU <b>parallel</b> will stop at end of file we use
  <b>tail</b> to continue reading:
<div class="Pp"></div>
<pre>
  true &gt;jobqueue; tail -n+0 -f jobqueue | parallel
</pre>
<div class="Pp"></div>
To submit your jobs to the queue:
<div class="Pp"></div>
<pre>
  echo my_command my_arg &gt;&gt; jobqueue
</pre>
<div class="Pp"></div>
You can of course use <b>-S</b> to distribute the jobs to remote computers:
<div class="Pp"></div>
<pre>
  true &gt;jobqueue; tail -n+0 -f jobqueue | parallel -S ..
</pre>
<div class="Pp"></div>
If you keep this running for a long time, jobqueue will grow. A way of removing
  the jobs already run is by making GNU <b>parallel</b> stop when it hits a
  special value and then restart. To use <b>--eof</b> to make GNU
  <b>parallel</b> exit, <b>tail</b> also needs to be forced to exit:
<div class="Pp"></div>
<pre>
  true &gt;jobqueue;
  while true; do
    tail -n+0 -f jobqueue |
      (parallel -E StOpHeRe -S ..; echo GNU Parallel is now done;
       perl -e 'while(&lt;&gt;){/StOpHeRe/ and last};print &lt;&gt;' jobqueue &gt; j2;
       (seq 1000 &gt;&gt; jobqueue &amp;);
       echo Done appending dummy data forcing tail to exit)
    echo tail exited;
    mv j2 jobqueue
  done
</pre>
<div class="Pp"></div>
In some cases you can run on more CPUs and computers during the night:
<div class="Pp"></div>
<pre>
  # Day time
  echo 50% &gt; jobfile
  cp day_server_list ~/.parallel/sshloginfile
  # Night time
  echo 100% &gt; jobfile
  cp night_server_list ~/.parallel/sshloginfile
  tail -n+0 -f jobqueue | parallel --jobs jobfile -S ..
</pre>
<div class="Pp"></div>
GNU Parallel discovers if <b>jobfile</b> or <b>~/.parallel/sshloginfile</b>
  changes.
<div class="Pp"></div>
There is a a small issue when using GNU <b>parallel</b> as queue system/batch
  manager: You have to submit JobSlot number of jobs before they will start, and
  after that you can submit one at a time, and job will start immediately if
  free slots are available. Output from the running or completed jobs are held
  back and will only be printed when JobSlots more jobs has been started (unless
  you use --ungroup or -u, in which case the output from the jobs are printed
  immediately). E.g. if you have 10 jobslots then the output from the first
  completed job will only be printed when job 11 has started, and the output of
  second completed job will only be printed when job 12 has started.
<h1 class="Sh" title="Sh" id="EXAMPLE:_GNU_Parallel_as_dir_processor"><a class="selflink" href="#EXAMPLE:_GNU_Parallel_as_dir_processor">EXAMPLE:
  GNU Parallel as dir processor</a></h1>
If you have a dir in which users drop files that needs to be processed you can
  do this on GNU/Linux (If you know what <b>inotifywait</b> is called on other
  platforms file a bug report):
<div class="Pp"></div>
<pre>
  inotifywait -q -m -r -e MOVED_TO -e CLOSE_WRITE --format %w%f my_dir |\
    parallel -u echo
</pre>
<div class="Pp"></div>
This will run the command <b>echo</b> on each file put into <b>my_dir</b> or
  subdirs of <b>my_dir</b>.
<div class="Pp"></div>
You can of course use <b>-S</b> to distribute the jobs to remote computers:
<div class="Pp"></div>
<pre>
  inotifywait -q -m -r -e MOVED_TO -e CLOSE_WRITE --format %w%f my_dir |\
    parallel -S ..  -u echo
</pre>
<div class="Pp"></div>
If the files to be processed are in a tar file then unpacking one file and
  processing it immediately may be faster than first unpacking all files. Set up
  the dir processor as above and unpack into the dir.
<div class="Pp"></div>
Using GNU Parallel as dir processor has the same limitations as using GNU
  Parallel as queue system/batch manager.
<h1 class="Sh" title="Sh" id="QUOTING"><a class="selflink" href="#QUOTING">QUOTING</a></h1>
GNU <b>parallel</b> is very liberal in quoting. You only need to quote
  characters that have special meaning in shell:
<div class="Pp"></div>
<pre>
  ( ) $ ` ' &quot; &lt; &gt; ; | \
</pre>
<div class="Pp"></div>
and depending on context these needs to be quoted, too:
<div class="Pp"></div>
<pre>
  ~ &amp; # ! ? space * {
</pre>
<div class="Pp"></div>
Therefore most people will never need more quoting than putting '\' in front of
  the special characters.
<div class="Pp"></div>
Often you can simply put \' around every ':
<div class="Pp"></div>
<pre>
  perl -ne '/^\S+\s+\S+$/ and print $ARGV,&quot;\n&quot;' file
</pre>
<div class="Pp"></div>
can be quoted:
<div class="Pp"></div>
<pre>
  parallel perl -ne \''/^\S+\s+\S+$/ and print $ARGV,&quot;\n&quot;'\' ::: file
</pre>
<div class="Pp"></div>
However, when you want to use a shell variable you need to quote the $-sign.
  Here is an example using $PARALLEL_SEQ. This variable is set by GNU
  <b>parallel</b> itself, so the evaluation of the $ must be done by the sub
  shell started by GNU <b>parallel</b>:
<div class="Pp"></div>
<pre>
  seq 10 | parallel -N2 echo seq:\$PARALLEL_SEQ arg1:{1} arg2:{2}
</pre>
<div class="Pp"></div>
If the variable is set before GNU <b>parallel</b> starts you can do this:
<div class="Pp"></div>
<pre>
  VAR=this_is_set_before_starting
  echo test | parallel echo {} $VAR
</pre>
<div class="Pp"></div>
Prints: <b>test this_is_set_before_starting</b>
<div class="Pp"></div>
It is a little more tricky if the variable contains more than one space in a
  row:
<div class="Pp"></div>
<pre>
  VAR=&quot;two  spaces  between  each  word&quot;
  echo test | parallel echo {} \'&quot;$VAR&quot;\'
</pre>
<div class="Pp"></div>
Prints: <b>test two spaces between each word</b>
<div class="Pp"></div>
If the variable should not be evaluated by the shell starting GNU
  <b>parallel</b> but be evaluated by the sub shell started by GNU
  <b>parallel</b>, then you need to quote it:
<div class="Pp"></div>
<pre>
  echo test | parallel VAR=this_is_set_after_starting \; echo {} \$VAR
</pre>
<div class="Pp"></div>
Prints: <b>test this_is_set_after_starting</b>
<div class="Pp"></div>
It is a little more tricky if the variable contains space:
<div class="Pp"></div>
<pre>
  echo test |\
    parallel VAR='&quot;two  spaces  between  each  word&quot;' echo {} \'&quot;$VAR&quot;\'
</pre>
<div class="Pp"></div>
Prints: <b>test two spaces between each word</b>
<div class="Pp"></div>
$$ is the shell variable containing the process id of the shell. This will print
  the process id of the shell running GNU <b>parallel</b>:
<div class="Pp"></div>
<pre>
  seq 10 | parallel echo $$
</pre>
<div class="Pp"></div>
And this will print the process ids of the sub shells started by GNU
  <b>parallel</b>.
<div class="Pp"></div>
<pre>
  seq 10 | parallel echo \$\$
</pre>
<div class="Pp"></div>
If the special characters should not be evaluated by the sub shell then you need
  to protect it against evaluation from both the shell starting GNU
  <b>parallel</b> and the sub shell:
<div class="Pp"></div>
<pre>
  echo test | parallel echo {} \\\$VAR
</pre>
<div class="Pp"></div>
Prints: <b>test </b><b>$VAR</b><b></b>
<div class="Pp"></div>
GNU <b>parallel</b> can protect against evaluation by the sub shell by using -q:
<div class="Pp"></div>
<pre>
  echo test | parallel -q echo {} \$VAR
</pre>
<div class="Pp"></div>
Prints: <b>test </b><b>$VAR</b><b></b>
<div class="Pp"></div>
This is particularly useful if you have lots of quoting. If you want to run a
  perl script like this:
<div class="Pp"></div>
<pre>
  perl -ne '/^\S+\s+\S+$/ and print $ARGV,&quot;\n&quot;' file
</pre>
<div class="Pp"></div>
It needs to be quoted like one of these:
<div class="Pp"></div>
<pre>
  ls | parallel perl -ne '/^\\S+\\s+\\S+\$/\ and\ print\ \$ARGV,\&quot;\\n\&quot;'
  ls | parallel perl -ne \''/^\S+\s+\S+$/ and print $ARGV,&quot;\n&quot;'\'
</pre>
<div class="Pp"></div>
Notice how spaces, \'s, &quot;'s, and $'s need to be quoted. GNU <b>parallel</b>
  can do the quoting by using option -q:
<div class="Pp"></div>
<pre>
  ls | parallel -q  perl -ne '/^\S+\s+\S+$/ and print $ARGV,&quot;\n&quot;'
</pre>
<div class="Pp"></div>
However, this means you cannot make the sub shell interpret special characters.
  For example because of <b>-q</b> this WILL NOT WORK:
<div class="Pp"></div>
<pre>
  ls *.gz | parallel -q &quot;zcat {} &gt;{.}&quot;
  ls *.gz | parallel -q &quot;zcat {} | bzip2 &gt;{.}.bz2&quot;
</pre>
<div class="Pp"></div>
because &gt; and | need to be interpreted by the sub shell.
<div class="Pp"></div>
If you get errors like:
<div class="Pp"></div>
<pre>
  sh: -c: line 0: syntax error near unexpected token
  sh: Syntax error: Unterminated quoted string
  sh: -c: line 0: unexpected EOF while looking for matching `''
  sh: -c: line 1: syntax error: unexpected end of file
</pre>
<div class="Pp"></div>
then you might try using <b>-q</b>.
<div class="Pp"></div>
If you are using <b>bash</b> process substitution like <b>&lt;(cat foo)</b> then
  you may try <b>-q</b> and prepending <i>command</i> with <b>bash -c</b>:
<div class="Pp"></div>
<pre>
  ls | parallel -q bash -c 'wc -c &lt;(echo {})'
</pre>
<div class="Pp"></div>
Or for substituting output:
<div class="Pp"></div>
<pre>
  ls | parallel -q bash -c \
    'tar c {} | tee &gt;(gzip &gt;{}.tar.gz) | bzip2 &gt;{}.tar.bz2'
</pre>
<div class="Pp"></div>
<b>Conclusion</b>: To avoid dealing with the quoting problems it may be easier
  just to write a small script or a function (remember to <b>export -f</b> the
  function) and have GNU <b>parallel</b> call that.
<h1 class="Sh" title="Sh" id="LIST_RUNNING_JOBS"><a class="selflink" href="#LIST_RUNNING_JOBS">LIST
  RUNNING JOBS</a></h1>
If you want a list of the jobs currently running you can run:
<div class="Pp"></div>
<pre>
  killall -USR1 parallel
</pre>
<div class="Pp"></div>
GNU <b>parallel</b> will then print the currently running jobs on stderr
  (standard error).
<h1 class="Sh" title="Sh" id="COMPLETE_RUNNING_JOBS_BUT_DO_NOT_START_NEW_JOBS"><a class="selflink" href="#COMPLETE_RUNNING_JOBS_BUT_DO_NOT_START_NEW_JOBS">COMPLETE
  RUNNING JOBS BUT DO NOT START NEW JOBS</a></h1>
If you regret starting a lot of jobs you can simply break GNU <b>parallel</b>,
  but if you want to make sure you do not have half-completed jobs you should
  send the signal <b>SIGTERM</b> to GNU <b>parallel</b>:
<div class="Pp"></div>
<pre>
  killall -TERM parallel
</pre>
<div class="Pp"></div>
This will tell GNU <b>parallel</b> to not start any new jobs, but wait until the
  currently running jobs are finished before exiting.
<h1 class="Sh" title="Sh" id="ENVIRONMENT_VARIABLES"><a class="selflink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">$PARALLEL_PID</dt>
  <dd class="It-tag">The environment variable $PARALLEL_PID is set by GNU
      <b>parallel</b> and is visible to the jobs started from GNU
      <b>parallel</b>. This makes it possible for the jobs to communicate
      directly to GNU <b>parallel</b>. Remember to quote the $, so it gets
      evaluated by the correct shell.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Example:</b> If each of the jobs tests a solution and one of jobs finds
      the solution the job can tell GNU <b>parallel</b> not to start more jobs
      by: <b>kill -TERM </b><b>$PARALLEL_PID</b><b></b>. This only works on the
      local computer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$PARALLEL_SHELL</dt>
  <dd class="It-tag">Use this shell the shell for the commands run by GNU
      Parallel:</dd>
</dl>
<div style="margin-left: 9.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">$PARALLEL_SHELL. If undefined use:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The shell that started GNU Parallel. If that cannot be
      determined:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">$SHELL. If undefined use:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">/bin/sh</dd>
</dl>
</div>
<div style="margin-left: 9.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">$PARALLEL_SSH</dt>
  <dd class="It-tag">GNU <b>parallel</b> defaults to using <b>ssh</b> for remote
      access. This can be overridden with $PARALLEL_SSH, which again can be
      overridden with <b>--ssh</b>. It can also be set on a per server basis
      (see <b>--sshlogin</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$PARALLEL_SEQ</dt>
  <dd class="It-tag">$PARALLEL_SEQ will be set to the sequence number of the job
      running. Remember to quote the $, so it gets evaluated by the correct
      shell.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Example:</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  seq 10 | parallel -N2 \
    echo seq:'$'PARALLEL_SEQ arg1:{1} arg2:{2}
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$TMPDIR</dt>
  <dd class="It-tag">Directory for temporary files. See: <b>--tmpdir</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$PARALLEL</dt>
  <dd class="It-tag">The environment variable $PARALLEL will be used as default
      options for GNU <b>parallel</b>. If the variable contains special shell
      characters (e.g. $, *, or space) then these need to be to be escaped with
      \.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Example:</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  cat list | parallel -j1 -k -v ls
  cat list | parallel -j1 -k -v -S&quot;myssh user@server&quot; ls
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    can be written as:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  cat list | PARALLEL=&quot;-kvj1&quot; parallel ls
  cat list | PARALLEL='-kvj1 -S myssh\ user@server' \
    parallel echo
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Notice the \ in the middle is needed because 'myssh' and 'user@server' must
      be one argument.</dd>
</dl>
<h1 class="Sh" title="Sh" id="DEFAULT_PROFILE_(CONFIG_FILE)"><a class="selflink" href="#DEFAULT_PROFILE_(CONFIG_FILE)">DEFAULT
  PROFILE (CONFIG FILE)</a></h1>
The global configuration file /etc/parallel/config, followed by user
  configuration file ~/.parallel/config (formerly known as .parallelrc) will be
  read in turn if they exist. Lines starting with '#' will be ignored. The
  format can follow that of the environment variable $PARALLEL, but it is often
  easier to simply put each option on its own line.
<div class="Pp"></div>
Options on the command line take precedence, followed by the environment
  variable $PARALLEL, user configuration file ~/.parallel/config, and finally
  the global configuration file /etc/parallel/config.
<div class="Pp"></div>
Note that no file that is read for options, nor the environment variable
  $PARALLEL, may contain retired options such as <b>--tollef</b>.
<h1 class="Sh" title="Sh" id="PROFILE_FILES"><a class="selflink" href="#PROFILE_FILES">PROFILE
  FILES</a></h1>
If <b>--profile</b> set, GNU <b>parallel</b> will read the profile from that
  file rather than the global or user configuration files. You can have multiple
  <b>--profiles</b>.
<div class="Pp"></div>
Example: Profile for running a command on every sshlogin in ~/.ssh/sshlogins and
  prepend the output with the sshlogin:
<div class="Pp"></div>
<pre>
  echo --tag -S .. --nonall &gt; ~/.parallel/n
  parallel -Jn uptime
</pre>
<div class="Pp"></div>
Example: Profile for running every command with <b>-j-1</b> and <b>nice</b>
<div class="Pp"></div>
<pre>
  echo -j-1 nice &gt; ~/.parallel/nice_profile
  parallel -J nice_profile bzip2 -9 ::: *
</pre>
<div class="Pp"></div>
Example: Profile for running a perl script before every command:
<div class="Pp"></div>
<pre>
  echo &quot;perl -e '\$a=\$\$; print \$a,\&quot; \&quot;,'\$PARALLEL_SEQ',\&quot; \&quot;;';&quot; \
    &gt; ~/.parallel/pre_perl
  parallel -J pre_perl echo ::: *
</pre>
<div class="Pp"></div>
Note how the $ and &quot; need to be quoted using \.
<div class="Pp"></div>
Example: Profile for running distributed jobs with <b>nice</b> on the remote
  computers:
<div class="Pp"></div>
<pre>
  echo -S .. nice &gt; ~/.parallel/dist
  parallel -J dist --trc {.}.bz2 bzip2 -9 ::: *
</pre>
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
Exit status depends on <b>--halt-on-error</b> if one of these are used:
  success=X, success=Y%, fail=Y%.
<dl class="Bl-tag">
  <dt class="It-tag">0</dt>
  <dd class="It-tag">All jobs ran without error. If success=X is used: X jobs
      ran without error. If success=Y% is used: Y% of the jobs ran without
      error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1-100</dt>
  <dd class="It-tag">Some of the jobs failed. The exit status gives the number
      of failed jobs. If Y% is used the exit status is the percentage of jobs
      that failed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">101</dt>
  <dd class="It-tag">More than 100 jobs failed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">255</dt>
  <dd class="It-tag">Other error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-1 (In joblog and SQL table)</dt>
  <dd class="It-tag">Killed by Ctrl-C, timeout, not enough memory or
    similar.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-2 (In joblog and SQL table)</dt>
  <dd class="It-tag">$job-&gt;<i>skip()</i> was called in <b>{= =}</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-1000 (In SQL table)</dt>
  <dd class="It-tag">Job is ready to run (set by --sqlmaster).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-1220 (In SQL table)</dt>
  <dd class="It-tag">Job is taken by worker (set by --sqlworker).</dd>
</dl>
<div class="Pp"></div>
If fail=1 is used, the exit status will be the exit status of the failing job.
<h1 class="Sh" title="Sh" id="DIFFERENCES_BETWEEN_GNU_Parallel_AND_ALTERNATIVES"><a class="selflink" href="#DIFFERENCES_BETWEEN_GNU_Parallel_AND_ALTERNATIVES">DIFFERENCES
  BETWEEN GNU Parallel AND ALTERNATIVES</a></h1>
There are a lot programs with some of the functionality of GNU <b>parallel</b>.
  GNU <b>parallel</b> strives to include the best of the functionality without
  sacrificing ease of use.
<h2 class="Ss" title="Ss" id="SUMMARY_TABLE"><a class="selflink" href="#SUMMARY_TABLE">SUMMARY
  TABLE</a></h2>
The following features are in some of the comparable tools:
<div class="Pp"></div>
Inputs
<br/>
 I1. Arguments can be read from stdin
<br/>
 I2. Arguments can be read from a file
<br/>
 I3. Arguments can be read from multiple files
<br/>
 I4. Arguments can be read from command line
<br/>
 I5. Arguments can be read from a table
<br/>
 I6. Arguments can be read from the same file using #! (shebang)
<br/>
 I7. Line oriented input as default (Quoting of special chars not needed)
<div class="Pp"></div>
Manipulation of input
<br/>
 M1. Composed command
<br/>
 M2. Multiple arguments can fill up an execution line
<br/>
 M3. Arguments can be put anywhere in the execution line
<br/>
 M4. Multiple arguments can be put anywhere in the execution line
<br/>
 M5. Arguments can be replaced with context
<br/>
 M6. Input can be treated as the complete command line
<div class="Pp"></div>
Outputs
<br/>
 O1. Grouping output so output from different jobs do not mix
<br/>
 O2. Send stderr (standard error) to stderr (standard error)
<br/>
 O3. Send stdout (standard output) to stdout (standard output)
<br/>
 O4. Order of output can be same as order of input
<br/>
 O5. Stdout only contains stdout (standard output) from the command
<br/>
 O6. Stderr only contains stderr (standard error) from the command
<div class="Pp"></div>
Execution
<br/>
 E1. Running jobs in parallel
<br/>
 E2. List running jobs
<br/>
 E3. Finish running jobs, but do not start new jobs
<br/>
 E4. Number of running jobs can depend on number of cpus
<br/>
 E5. Finish running jobs, but do not start new jobs after first failure
<br/>
 E6. Number of running jobs can be adjusted while running
<div class="Pp"></div>
Remote execution
<br/>
 R1. Jobs can be run on remote computers
<br/>
 R2. Basefiles can be transferred
<br/>
 R3. Argument files can be transferred
<br/>
 R4. Result files can be transferred
<br/>
 R5. Cleanup of transferred files
<br/>
 R6. No config files needed
<br/>
 R7. Do not run more than SSHD's MaxStartups can handle
<br/>
 R8. Configurable SSH command
<br/>
 R9. Retry if connection breaks occasionally
<div class="Pp"></div>
Semaphore
<br/>
 S1. Possibility to work as a mutex
<br/>
 S2. Possibility to work as a counting semaphore
<div class="Pp"></div>
Legend
<br/>
 - = no
<br/>
 x = not applicable
<br/>
 ID = yes
<div class="Pp"></div>
As every new version of the programs are not tested the table may be outdated.
  Please file a bug-report if you find errors (See REPORTING BUGS).
<div class="Pp"></div>
parallel: I1 I2 I3 I4 I5 I6 I7 M1 M2 M3 M4 M5 M6 O1 O2 O3 O4 O5 O6 E1 E2 E3 E4
  E5 E6 R1 R2 R3 R4 R5 R6 R7 R8 R9 S1 S2
<div class="Pp"></div>
xargs: I1 I2 - - - - - - M2 M3 - - - - O2 O3 - O5 O6 E1 - - - - - - - - - - x -
  - - - -
<div class="Pp"></div>
find -exec: - - - x - x - - M2 M3 - - - - - O2 O3 O4 O5 O6 - - - - - - - - - - -
  - - - - - x x
<div class="Pp"></div>
make -j: - - - - - - - - - - - - - O1 O2 O3 - x O6 E1 - - - E5 - - - - - - - - -
  - - -
<div class="Pp"></div>
ppss: I1 I2 - - - - I7 M1 - M3 - - M6 O1 - - x - - E1 E2 ?E3 E4 - - R1 R2 R3 R4
  - - ?R7 ? ? - -
<div class="Pp"></div>
pexec: I1 I2 - I4 I5 - - M1 - M3 - - M6 O1 O2 O3 - O5 O6 E1 - - E4 - E6 R1 - - -
  - R6 - - - S1 -
<div class="Pp"></div>
xjobs, prll, dxargs, mdm/middelman, xapply, paexec, ladon, jobflow, ClusterSSH:
  TODO - Please file a bug-report if you know what features they support (See
  REPORTING BUGS).
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_xargs_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_xargs_AND_GNU_Parallel">DIFFERENCES
  BETWEEN xargs AND GNU Parallel</a></h2>
<b>xargs</b> offers some of the same possibilities as GNU <b>parallel</b>.
<div class="Pp"></div>
<b>xargs</b> deals badly with special characters (such as space, \, ' and
  &quot;). To see the problem try this:
<div class="Pp"></div>
<pre>
  touch important_file
  touch 'not important_file'
  ls not* | xargs rm
  mkdir -p &quot;My brother's 12\&quot; records&quot;
  ls | xargs rmdir
  touch 'c:\windows\system32\clfs.sys'
  echo 'c:\windows\system32\clfs.sys' | xargs ls -l
</pre>
<div class="Pp"></div>
You can specify <b>-0</b>, but many input generators are not optimized for using
  <b>NUL</b> as separator but are optimized for <b>newline</b> as separator. E.g
  <b>head</b>, <b>tail</b>, <b>awk</b>, <b>ls</b>, <b>echo</b>, <b>sed</b>,
  <b>tar -v</b>, <b>perl</b> (<b>-0</b> and \0 instead of \n), <b>locate</b>
  (requires using <b>-0</b>), <b>find</b> (requires using <b>-print0</b>),
  <b>grep</b> (requires user to use <b>-z</b> or <b>-Z</b>), <b>sort</b>
  (requires using <b>-z</b>).
<div class="Pp"></div>
GNU <b>parallel</b>'s newline separation can be emulated with:
<div class="Pp"></div>
<b>cat | xargs -d &quot;\n&quot; -n1 </b><b><i>command</i></b><b></b>
<div class="Pp"></div>
<b>xargs</b> can run a given number of jobs in parallel, but has no support for
  running number-of-cpu-cores jobs in parallel.
<div class="Pp"></div>
<b>xargs</b> has no support for grouping the output, therefore output may run
  together, e.g. the first half of a line is from one process and the last half
  of the line is from another process. The example <b>Parallel grep</b> cannot
  be done reliably with <b>xargs</b> because of this. To see this in action try:
<div class="Pp"></div>
<pre>
  parallel perl -e '\$a=\&quot;1{}\&quot;x10000000\;print\ \$a,\&quot;\\n\&quot;' '&gt;' {} \
    ::: a b c d e f
  ls -l a b c d e f
  parallel -kP4 -n1 grep 1 &gt; out.par ::: a b c d e f
  echo a b c d e f | xargs -P4 -n1 grep 1 &gt; out.xargs-unbuf
  echo a b c d e f | \
    xargs -P4 -n1 grep --line-buffered 1 &gt; out.xargs-linebuf
  echo a b c d e f | xargs -n1 grep 1 &gt; out.xargs-serial
  ls -l out*
  md5sum out*
</pre>
<div class="Pp"></div>
<b>xargs</b> has no support for keeping the order of the output, therefore if
  running jobs in parallel using <b>xargs</b> the output of the second job
  cannot be postponed till the first job is done.
<div class="Pp"></div>
<b>xargs</b> has no support for running jobs on remote computers.
<div class="Pp"></div>
<b>xargs</b> has no support for context replace, so you will have to create the
  arguments.
<div class="Pp"></div>
If you use a replace string in <b>xargs</b> (<b>-I</b>) you can not force
  <b>xargs</b> to use more than one argument.
<div class="Pp"></div>
Quoting in <b>xargs</b> works like <b>-q</b> in GNU <b>parallel</b>. This means
  composed commands and redirection require using <b>bash -c</b>.
<div class="Pp"></div>
<pre>
  ls | parallel &quot;wc {} &gt;{}.wc&quot;
  ls | parallel &quot;echo {}; ls {}|wc&quot;
</pre>
<div class="Pp"></div>
becomes (assuming you have 8 cores)
<div class="Pp"></div>
<pre>
  ls | xargs -d &quot;\n&quot; -P8 -I {} bash -c &quot;wc {} &gt;{}.wc&quot;
  ls | xargs -d &quot;\n&quot; -P8 -I {} bash -c &quot;echo {}; ls {}|wc&quot;
</pre>
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_find_-exec_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_find_-exec_AND_GNU_Parallel">DIFFERENCES
  BETWEEN find -exec AND GNU Parallel</a></h2>
<b>find -exec</b> offer some of the same possibilities as GNU <b>parallel</b>.
<div class="Pp"></div>
<b>find -exec</b> only works on files. So processing other input (such as hosts
  or URLs) will require creating these inputs as files. <b>find</b> <b>-exec</b>
  has no support for running commands in parallel.
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_make_-j_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_make_-j_AND_GNU_Parallel">DIFFERENCES
  BETWEEN make -j AND GNU Parallel</a></h2>
<b>make -j</b> can run jobs in parallel, but requires a crafted Makefile to do
  this. That results in extra quoting to get filename containing newline to work
  correctly.
<div class="Pp"></div>
<b>make -j</b> computes a dependency graph before running jobs. Jobs run by GNU
  <b>parallel</b> does not depend on eachother.
<div class="Pp"></div>
(Very early versions of GNU <b>parallel</b> were coincidently implemented using
  <b>make -j</b>).
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_ppss_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_ppss_AND_GNU_Parallel">DIFFERENCES
  BETWEEN ppss AND GNU Parallel</a></h2>
<b>ppss</b> is also a tool for running jobs in parallel.
<div class="Pp"></div>
The output of <b>ppss</b> is status information and thus not useful for using as
  input for another command. The output from the jobs are put into files.
<div class="Pp"></div>
The argument replace string ($ITEM) cannot be changed. Arguments must be quoted
  - thus arguments containing special characters (space '&quot;&amp;!*) may
  cause problems. More than one argument is not supported. File names containing
  newlines are not processed correctly. When reading input from a file null
  cannot be used as a terminator. <b>ppss</b> needs to read the whole input file
  before starting any jobs.
<div class="Pp"></div>
Output and status information is stored in ppss_dir and thus requires cleanup
  when completed. If the dir is not removed before running <b>ppss</b> again it
  may cause nothing to happen as <b>ppss</b> thinks the task is already done.
  GNU <b>parallel</b> will normally not need cleaning up if running locally and
  will only need cleaning up if stopped abnormally and running remote (
  <b>--cleanup</b> may not complete if stopped abnormally). The example
  <b>Parallel grep</b> would require extra postprocessing if written using
  <b>ppss</b>.
<div class="Pp"></div>
For remote systems PPSS requires 3 steps: config, deploy, and start. GNU
  <b>parallel</b> only requires one step.
<div class="Pp"></div>
<i>EXAMPLES FROM ppss MANUAL</i>
<div class="Pp"></div>
Here are the examples from <b>ppss</b>'s manual page with the equivalent using
  GNU <b>parallel</b>:
<div class="Pp"></div>
<b>1</b> ./ppss.sh standalone -d /path/to/files -c 'gzip '
<div class="Pp"></div>
<b>1</b> find /path/to/files -type f | parallel gzip
<div class="Pp"></div>
<b>2</b> ./ppss.sh standalone -d /path/to/files -c 'cp &quot;$ITEM&quot;
  /destination/dir '
<div class="Pp"></div>
<b>2</b> find /path/to/files -type f | parallel cp {} /destination/dir
<div class="Pp"></div>
<b>3</b> ./ppss.sh standalone -f list-of-urls.txt -c 'wget -q '
<div class="Pp"></div>
<b>3</b> parallel -a list-of-urls.txt wget -q
<div class="Pp"></div>
<b>4</b> ./ppss.sh standalone -f list-of-urls.txt -c 'wget -q &quot;$ITEM&quot;'
<div class="Pp"></div>
<b>4</b> parallel -a list-of-urls.txt wget -q {}
<div class="Pp"></div>
<b>5</b> ./ppss config -C config.cfg -c 'encode.sh ' -d /source/dir -m
  192.168.1.100 -u ppss -k ppss-key.key -S ./encode.sh -n nodes.txt -o
  /some/output/dir --upload --download ; ./ppss deploy -C config.cfg ; ./ppss
  start -C config
<div class="Pp"></div>
<b>5</b> # parallel does not use configs. If you want a different username put
  it in nodes.txt: user@hostname
<div class="Pp"></div>
<b>5</b> find source/dir -type f | parallel --sshloginfile nodes.txt --trc
  {.}.mp3 lame -a {} -o {.}.mp3 --preset standard --quiet
<div class="Pp"></div>
<b>6</b> ./ppss stop -C config.cfg
<div class="Pp"></div>
<b>6</b> killall -TERM parallel
<div class="Pp"></div>
<b>7</b> ./ppss pause -C config.cfg
<div class="Pp"></div>
<b>7</b> Press: CTRL-Z or killall -SIGTSTP parallel
<div class="Pp"></div>
<b>8</b> ./ppss continue -C config.cfg
<div class="Pp"></div>
<b>8</b> Enter: fg or killall -SIGCONT parallel
<div class="Pp"></div>
<b>9</b> ./ppss.sh status -C config.cfg
<div class="Pp"></div>
<b>9</b> killall -SIGUSR2 parallel
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_pexec_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_pexec_AND_GNU_Parallel">DIFFERENCES
  BETWEEN pexec AND GNU Parallel</a></h2>
<b>pexec</b> is also a tool for running jobs in parallel.
<div class="Pp"></div>
<i>EXAMPLES FROM pexec MANUAL</i>
<div class="Pp"></div>
Here are the examples from <b>pexec</b>'s info page with the equivalent using
  GNU <b>parallel</b>:
<div class="Pp"></div>
<b>1</b> pexec -o sqrt-%s.dat -p &quot;$(seq 10)&quot; -e NUM -n 4 -c -- \
<br/>
 'echo &quot;scale=10000;sqrt($NUM)&quot; | bc'
<div class="Pp"></div>
<b>1</b> seq 10 | parallel -j4 'echo &quot;scale=10000;sqrt({})&quot; | bc &gt;
  sqrt-{}.dat'
<div class="Pp"></div>
<b>2</b> pexec -p &quot;$(ls myfiles*.ext)&quot; -i %s -o %s.sort -- sort
<div class="Pp"></div>
<b>2</b> ls myfiles*.ext | parallel sort {} &quot;&gt;{}.sort&quot;
<div class="Pp"></div>
<b>3</b> pexec -f image.list -n auto -e B -u star.log -c -- \
<br/>
 'fistar $B.fits -f 100 -F id,x,y,flux -o $B.star'
<div class="Pp"></div>
<b>3</b> parallel -a image.list \
<br/>
 'fistar {}.fits -f 100 -F id,x,y,flux -o {}.star' 2&gt;star.log
<div class="Pp"></div>
<b>4</b> pexec -r *.png -e IMG -c -o - -- \
<br/>
 'convert $IMG ${IMG%.png}.jpeg ; &quot;echo $IMG: done&quot;'
<div class="Pp"></div>
<b>4</b> ls *.png | parallel 'convert {} {.}.jpeg; echo {}: done'
<div class="Pp"></div>
<b>5</b> pexec -r *.png -i %s -o %s.jpg -c 'pngtopnm | pnmtojpeg'
<div class="Pp"></div>
<b>5</b> ls *.png | parallel 'pngtopnm &lt; {} | pnmtojpeg &gt; {}.jpg'
<div class="Pp"></div>
<b>6</b> for p in *.png ; do echo ${p%.png} ; done | \
<br/>
 pexec -f - -i %s.png -o %s.jpg -c 'pngtopnm | pnmtojpeg'
<div class="Pp"></div>
<b>6</b> ls *.png | parallel 'pngtopnm &lt; {} | pnmtojpeg &gt; {.}.jpg'
<div class="Pp"></div>
<b>7</b> LIST=$(for p in *.png ; do echo ${p%.png} ; done)
<br/>
 pexec -r $LIST -i %s.png -o %s.jpg -c 'pngtopnm | pnmtojpeg'
<div class="Pp"></div>
<b>7</b> ls *.png | parallel 'pngtopnm &lt; {} | pnmtojpeg &gt; {.}.jpg'
<div class="Pp"></div>
<b>8</b> pexec -n 8 -r *.jpg -y unix -e IMG -c \
<br/>
 'pexec -j -m blockread -d $IMG | \
<br/>
 jpegtopnm | pnmscale 0.5 | pnmtojpeg | \
<br/>
 pexec -j -m blockwrite -s th_$IMG'
<div class="Pp"></div>
<b>8</b> Combining GNU <b>parallel</b> and GNU <b>sem</b>.
<div class="Pp"></div>
<b>8</b> ls *jpg | parallel -j8 'sem --id blockread cat {} | jpegtopnm |' \
<br/>
 'pnmscale 0.5 | pnmtojpeg | sem --id blockwrite cat &gt; th_{}'
<div class="Pp"></div>
<b>8</b> If reading and writing is done to the same disk, this may be faster as
  only one process will be either reading or writing:
<div class="Pp"></div>
<b>8</b> ls *jpg | parallel -j8 'sem --id diskio cat {} | jpegtopnm |' \
<br/>
 'pnmscale 0.5 | pnmtojpeg | sem --id diskio cat &gt; th_{}'
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_xjobs_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_xjobs_AND_GNU_Parallel">DIFFERENCES
  BETWEEN xjobs AND GNU Parallel</a></h2>
<b>xjobs</b> is also a tool for running jobs in parallel. It only supports
  running jobs on your local computer.
<div class="Pp"></div>
<b>xjobs</b> deals badly with special characters just like <b>xargs</b>. See the
  section <b>DIFFERENCES BETWEEN xargs AND GNU Parallel</b>.
<div class="Pp"></div>
Here are the examples from <b>xjobs</b>'s man page with the equivalent using GNU
  <b>parallel</b>:
<div class="Pp"></div>
<b>1</b> ls -1 *.zip | xjobs unzip
<div class="Pp"></div>
<b>1</b> ls *.zip | parallel unzip
<div class="Pp"></div>
<b>2</b> ls -1 *.zip | xjobs -n unzip
<div class="Pp"></div>
<b>2</b> ls *.zip | parallel unzip &gt;/dev/null
<div class="Pp"></div>
<b>3</b> find . -name '*.bak' | xjobs gzip
<div class="Pp"></div>
<b>3</b> find . -name '*.bak' | parallel gzip
<div class="Pp"></div>
<b>4</b> ls -1 *.jar | sed 's/\(.*\)/\1 &gt; \1.idx/' | xjobs jar tf
<div class="Pp"></div>
<b>4</b> ls *.jar | parallel jar tf {} '&gt;' {}.idx
<div class="Pp"></div>
<b>5</b> xjobs -s script
<div class="Pp"></div>
<b>5</b> cat script | parallel
<div class="Pp"></div>
<b>6</b> mkfifo /var/run/my_named_pipe; xjobs -s /var/run/my_named_pipe &amp;
  echo unzip 1.zip &gt;&gt; /var/run/my_named_pipe; echo tar cf
  /backup/myhome.tar /home/me &gt;&gt; /var/run/my_named_pipe
<div class="Pp"></div>
<b>6</b> mkfifo /var/run/my_named_pipe; cat /var/run/my_named_pipe | parallel
  &amp; echo unzip 1.zip &gt;&gt; /var/run/my_named_pipe; echo tar cf
  /backup/myhome.tar /home/me &gt;&gt; /var/run/my_named_pipe
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_prll_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_prll_AND_GNU_Parallel">DIFFERENCES
  BETWEEN prll AND GNU Parallel</a></h2>
<b>prll</b> is also a tool for running jobs in parallel. It does not support
  running jobs on remote computers.
<div class="Pp"></div>
<b>prll</b> encourages using BASH aliases and BASH functions instead of scripts.
  GNU <b>parallel</b> supports scripts directly, functions if they are exported
  using <b>export -f</b>, and aliases if using <b>env_parallel</b> described
  earlier.
<div class="Pp"></div>
<b>prll</b> generates a lot of status information on stderr (standard error)
  which makes it harder to use the stderr (standard error) output of the job
  directly as input for another program.
<div class="Pp"></div>
Here is the example from <b>prll</b>'s man page with the equivalent using GNU
  <b>parallel</b>:
<div class="Pp"></div>
<pre>
  prll -s 'mogrify -flip $1' *.jpg
  parallel mogrify -flip ::: *.jpg
</pre>
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_dxargs_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_dxargs_AND_GNU_Parallel">DIFFERENCES
  BETWEEN dxargs AND GNU Parallel</a></h2>
<b>dxargs</b> is also a tool for running jobs in parallel.
<div class="Pp"></div>
<b>dxargs</b> does not deal well with more simultaneous jobs than SSHD's
  MaxStartups. <b>dxargs</b> is only built for remote run jobs, but does not
  support transferring of files.
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_mdm/middleman_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_mdm/middleman_AND_GNU_Parallel">DIFFERENCES
  BETWEEN mdm/middleman AND GNU Parallel</a></h2>
middleman(mdm) is also a tool for running jobs in parallel.
<div class="Pp"></div>
Here are the shellscripts of http://mdm.berlios.de/usage.html ported to GNU
  <b>parallel</b>:
<div class="Pp"></div>
<pre>
  seq 19 | parallel buffon -o - | sort -n &gt; result
  cat files | parallel cmd
  find dir -execdir sem cmd {} \;
</pre>
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_xapply_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_xapply_AND_GNU_Parallel">DIFFERENCES
  BETWEEN xapply AND GNU Parallel</a></h2>
<b>xapply</b> can run jobs in parallel on the local computer.
<div class="Pp"></div>
Here are the examples from <b>xapply</b>'s man page with the equivalent using
  GNU <b>parallel</b>:
<div class="Pp"></div>
<b>1</b> xapply '(cd %1 &amp;&amp; make all)' */
<div class="Pp"></div>
<b>1</b> parallel 'cd {} &amp;&amp; make all' ::: */
<div class="Pp"></div>
<b>2</b> xapply -f 'diff %1 ../version5/%1' manifest | more
<div class="Pp"></div>
<b>2</b> parallel diff {} ../version5/{} &lt; manifest | more
<div class="Pp"></div>
<b>3</b> xapply -p/dev/null -f 'diff %1 %2' manifest1 checklist1
<div class="Pp"></div>
<b>3</b> parallel --xapply diff {1} {2} :::: manifest1 checklist1
<div class="Pp"></div>
<b>4</b> xapply 'indent' *.c
<div class="Pp"></div>
<b>4</b> parallel indent ::: *.c
<div class="Pp"></div>
<b>5</b> find ~ksb/bin -type f ! -perm -111 -print | xapply -f -v 'chmod a+x' -
<div class="Pp"></div>
<b>5</b> find ~ksb/bin -type f ! -perm -111 -print | parallel -v chmod a+x
<div class="Pp"></div>
<b>6</b> find */ -... | fmt 960 1024 | xapply -f -i /dev/tty 'vi' -
<div class="Pp"></div>
<b>6</b> sh &lt;(find */ -... | parallel -s 1024 echo vi)
<div class="Pp"></div>
<b>6</b> find */ -... | parallel -s 1024 -Xuj1 vi
<div class="Pp"></div>
<b>7</b> find ... | xapply -f -5 -i /dev/tty 'vi' - - - - -
<div class="Pp"></div>
<b>7</b> sh &lt;(find ... |parallel -n5 echo vi)
<div class="Pp"></div>
<b>7</b> find ... |parallel -n5 -uj1 vi
<div class="Pp"></div>
<b>8</b> xapply -fn &quot;&quot; /etc/passwd
<div class="Pp"></div>
<b>8</b> parallel -k echo &lt; /etc/passwd
<div class="Pp"></div>
<b>9</b> tr ':' '\012' &lt; /etc/passwd | xapply -7 -nf 'chown %1 %6' - - - - -
  - -
<div class="Pp"></div>
<b>9</b> tr ':' '\012' &lt; /etc/passwd | parallel -N7 chown {1} {6}
<div class="Pp"></div>
<b>10</b> xapply '[ -d %1/RCS ] || echo %1' */
<div class="Pp"></div>
<b>10</b> parallel '[ -d {}/RCS ] || echo {}' ::: */
<div class="Pp"></div>
<b>11</b> xapply -f '[ -f %1 ] &amp;&amp; echo %1' List | ...
<div class="Pp"></div>
<b>11</b> parallel '[ -f {} ] &amp;&amp; echo {}' &lt; List | ...
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_AIX_apply_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_AIX_apply_AND_GNU_Parallel">DIFFERENCES
  BETWEEN AIX apply AND GNU Parallel</a></h2>
<b>apply</b> can build command lines based on a template and arguments - very
  much like GNU <b>parallel</b>. <b>apply</b> does not run jobs in parallel.
  <b>apply</b> does not use an argument separator (like <b>:::</b>); instead the
  template must be the first argument.
<div class="Pp"></div>
Here are the examples from
  https://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.cmds1/apply.htm
<div class="Pp"></div>
1. To obtain results similar to those of the <b>ls</b> command, enter:
<div class="Pp"></div>
<pre>
  apply echo *
  parallel echo ::: *
</pre>
<div class="Pp"></div>
2. To compare the file named <b>a1</b> to the file named <b>b1</b>, and the file
  named <b>a2</b> to the file named <b>b2</b>, enter:
<div class="Pp"></div>
<pre>
  apply -2 cmp a1 b1 a2 b2
  parallel -N2 cmp ::: a1 b1 a2 b2
</pre>
<div class="Pp"></div>
3. To run the <b>who</b> command five times, enter:
<div class="Pp"></div>
<pre>
  apply -0 who 1 2 3 4 5
  parallel -N0 who ::: 1 2 3 4 5
</pre>
<div class="Pp"></div>
4. To link all files in the current directory to the directory <b>/usr/joe</b>,
  enter:
<div class="Pp"></div>
<pre>
  apply 'ln %1 /usr/joe' *
  parallel ln {} /usr/joe ::: *
</pre>
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_paexec_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_paexec_AND_GNU_Parallel">DIFFERENCES
  BETWEEN paexec AND GNU Parallel</a></h2>
<b>paexec</b> can run jobs in parallel on both the local and remote computers.
<div class="Pp"></div>
<b>paexec</b> requires commands to print a blank line as the last output. This
  means you will have to write a wrapper for most programs.
<div class="Pp"></div>
<b>paexec</b> has a job dependency facility so a job can depend on another job
  to be executed successfully. Sort of a poor-man's <b>make</b>.
<div class="Pp"></div>
Here are the examples from <b>paexec</b>'s example catalog with the equivalent
  using GNU <b>parallel</b>:
<dl class="Bl-tag">
  <dt class="It-tag">1_div_X_run:</dt>
  <dd class="It-tag">
    <pre>
  ../../paexec -s -l -c &quot;`pwd`/1_div_X_cmd&quot; -n +1 &lt;&lt;EOF [...]
  parallel echo {} '|' `pwd`/1_div_X_cmd &lt;&lt;EOF [...]
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">all_substr_run:</dt>
  <dd class="It-tag">
    <pre>
  ../../paexec -lp -c &quot;`pwd`/all_substr_cmd&quot; -n +3 &lt;&lt;EOF [...]
  parallel echo {} '|' `pwd`/all_substr_cmd &lt;&lt;EOF [...]
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cc_wrapper_run:</dt>
  <dd class="It-tag">
    <pre>
  ../../paexec -c &quot;env CC=gcc CFLAGS=-O2 `pwd`/cc_wrapper_cmd&quot; \
             -n 'host1 host2' \
             -t '/usr/bin/ssh -x' &lt;&lt;EOF [...]
  parallel echo {} '|' &quot;env CC=gcc CFLAGS=-O2 `pwd`/cc_wrapper_cmd&quot; \
             -S host1,host2 &lt;&lt;EOF [...]
  # This is not exactly the same, but avoids the wrapper
  parallel gcc -O2 -c -o {.}.o {} \
             -S host1,host2 &lt;&lt;EOF [...]
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">toupper_run:</dt>
  <dd class="It-tag">
    <pre>
  ../../paexec -lp -c &quot;`pwd`/toupper_cmd&quot; -n +10 &lt;&lt;EOF [...]
  parallel echo {} '|' ./toupper_cmd &lt;&lt;EOF [...]
  # Without the wrapper:
  parallel echo {} '| awk {print\ toupper\(\$0\)}' &lt;&lt;EOF [...]
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_map_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_map_AND_GNU_Parallel">DIFFERENCES
  BETWEEN map AND GNU Parallel</a></h2>
<b>map</b> sees it as a feature to have less features and in doing so it also
  handles corner cases incorrectly. A lot of GNU <b>parallel</b>'s code is to
  handle corner cases correctly on every platform, so you will not get a nasty
  surprise if a user for example saves a file called: <i>My</i> <i>brother's
  12&quot; records.txt</i>
<div class="Pp"></div>
<b>map</b>'s example showing how to deal with special characters fails on
  special characters:
<div class="Pp"></div>
<pre>
  echo &quot;The Cure&quot; &gt; My\ brother\'s\ 12\&quot;\ records
  ls | \
    map 'echo -n `gzip &lt; &quot;%&quot; | wc -c`; echo -n '*100/'; wc -c &lt; &quot;%&quot;' | bc
</pre>
<div class="Pp"></div>
It works with GNU <b>parallel</b>:
<div class="Pp"></div>
<pre>
  ls | \
    parallel 'echo -n `gzip &lt; {} | wc -c`; echo -n '*100/'; wc -c &lt; {}' | bc
</pre>
<div class="Pp"></div>
And you can even get the file name prepended:
<div class="Pp"></div>
<pre>
  ls | \
    parallel --tag '(echo -n `gzip &lt; {} | wc -c`'*100/'; wc -c &lt; {}) | bc'
</pre>
<div class="Pp"></div>
<b>map</b> has no support for grouping. So this gives the wrong results without
  any warnings:
<div class="Pp"></div>
<pre>
  parallel perl -e '\$a=\&quot;1{}\&quot;x10000000\;print\ \$a,\&quot;\\n\&quot;' '&gt;' {} \
    ::: a b c d e f
  ls -l a b c d e f
  parallel -kP4 -n1 grep 1 &gt; out.par ::: a b c d e f
  map -p 4 'grep 1' a b c d e f &gt; out.map-unbuf
  map -p 4 'grep --line-buffered 1' a b c d e f &gt; out.map-linebuf
  map -p 1 'grep --line-buffered 1' a b c d e f &gt; out.map-serial
  ls -l out*
  md5sum out*
</pre>
<div class="Pp"></div>
The documentation shows a workaround, but not only does that mix stdout
  (standard output) with stderr (standard error) it also fails completely for
  certain jobs (and may even be considered less readable):
<div class="Pp"></div>
<pre>
  parallel echo -n {} ::: 1 2 3
  map -p 4 'echo -n % 2&gt;&amp;1 | sed -e &quot;s/^/$$:/&quot;' 1 2 3 | sort | cut -f2- -d:
</pre>
<div class="Pp"></div>
<b>map</b>s replacement strings (% %D %B %E) can be simulated in GNU
  <b>parallel</b> by putting this in <b>~/.parallel/config</b>:
<div class="Pp"></div>
<pre>
  --rpl '%'
  --rpl '%D $_=::shell_quote(::dirname($_));'
  --rpl '%B s:.*/::;s:\.[^/.]+$::;'
  --rpl '%E s:.*\.::'
</pre>
<div class="Pp"></div>
<b>map</b> cannot handle bundled options: <b>map -vp 0 echo this fails</b>
<div class="Pp"></div>
<b>map</b> does not have an argument separator on the command line, but uses the
  first argument as command. This makes quoting harder which again may affect
  readability. Compare:
<div class="Pp"></div>
<pre>
  map -p 2 perl\\\ -ne\\\ \\\'/^\\\\S+\\\\s+\\\\S+\\\$/\\\ and\\\ print\\\ \\\$ARGV,\\\&quot;\\\\n\\\&quot;\\\' *
  parallel -q perl -ne '/^\S+\s+\S+$/ and print $ARGV,&quot;\n&quot;' ::: *
</pre>
<div class="Pp"></div>
<b>map</b> can do multiple arguments with context replace, but not without
  context replace:
<div class="Pp"></div>
<pre>
  parallel --xargs echo 'BEGIN{'{}'}END' ::: 1 2 3
</pre>
<div class="Pp"></div>
<b>map</b> does not set exit value according to whether one of the jobs failed:
<div class="Pp"></div>
<pre>
  parallel false ::: 1 || echo Job failed
  map false 1 || echo Never run
</pre>
<div class="Pp"></div>
<b>map</b> requires Perl v5.10.0 making it harder to use on old systems.
<div class="Pp"></div>
<b>map</b> has no way of using % in the command (GNU Parallel has -I to specify
  another replacement string than <b>{}</b>).
<div class="Pp"></div>
By design <b>map</b> is option incompatible with <b>xargs</b>, it does not have
  remote job execution, a structured way of saving results, multiple input
  sources, progress indicator, configurable record delimiter (only field
  delimiter), logging of jobs run with possibility to resume, keeping the output
  in the same order as input, --pipe processing, and dynamically timeouts.
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_ladon_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_ladon_AND_GNU_Parallel">DIFFERENCES
  BETWEEN ladon AND GNU Parallel</a></h2>
<b>ladon</b> can run multiple jobs on files in parallel.
<div class="Pp"></div>
<b>ladon</b> only works on files and the only way to specify files is using a
  quoted glob string (such as \*.jpg). It is not possible to list the files
  manually.
<div class="Pp"></div>
As replacement strings it uses FULLPATH DIRNAME BASENAME EXT RELDIR RELPATH
<div class="Pp"></div>
These can be simulated using GNU <b>parallel</b> by putting this in
  <b>~/.parallel/config</b>:
<div class="Pp"></div>
<pre>
    --rpl 'FULLPATH $_=::shell_quote($_);chomp($_=qx{readlink -f $_});'
    --rpl 'DIRNAME $_=::shell_quote(::dirname($_));chomp($_=qx{readlink -f $_});'
    --rpl 'BASENAME s:.*/::;s:\.[^/.]+$::;'
    --rpl 'EXT s:.*\.::'
    --rpl 'RELDIR $_=::shell_quote($_);chomp(($_,$c)=qx{readlink -f $_;pwd});s:\Q$c/\E::;$_=::dirname($_);'
    --rpl 'RELPATH $_=::shell_quote($_);chomp(($_,$c)=qx{readlink -f $_;pwd});s:\Q$c/\E::;'
</pre>
<div class="Pp"></div>
<b>ladon</b> deals badly with filenames containing &quot; and newline, and it
  fails for output larger than 200k:
<div class="Pp"></div>
<pre>
    ladon '*' -- seq 36000 | wc
</pre>
<div class="Pp"></div>
<i>EXAMPLES FROM ladon MANUAL</i>
<div class="Pp"></div>
It is assumed that the '--rpl's above are put in <b>~/.parallel/config</b> and
  that it is run under a shell that supports '**' globbing (such as <b>zsh</b>):
<div class="Pp"></div>
<b>1</b> ladon &quot;**/*.txt&quot; -- echo RELPATH
<div class="Pp"></div>
<b>1</b> parallel echo RELPATH ::: **/*.txt
<div class="Pp"></div>
<b>2</b> ladon &quot;~/Documents/**/*.pdf&quot; -- shasum FULLPATH
  &gt;hashes.txt
<div class="Pp"></div>
<b>2</b> parallel shasum FULLPATH ::: ~/Documents/**/*.pdf &gt;hashes.txt
<div class="Pp"></div>
<b>3</b> ladon -m thumbs/RELDIR &quot;**/*.jpg&quot; -- convert FULLPATH
  -thumbnail 100x100^ -gravity center -extent 100x100 thumbs/RELPATH
<div class="Pp"></div>
<b>3</b> parallel mkdir -p thumbs/RELDIR\; convert FULLPATH -thumbnail 100x100^
  -gravity center -extent 100x100 thumbs/RELPATH ::: **/*.jpg
<div class="Pp"></div>
<b>4</b> ladon &quot;~/Music/*.wav&quot; -- lame -V 2 FULLPATH
  DIRNAME/BASENAME.mp3
<div class="Pp"></div>
<b>4</b> parallel lame -V 2 FULLPATH DIRNAME/BASENAME.mp3 ::: ~/Music/*.wav
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_jobflow_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_jobflow_AND_GNU_Parallel">DIFFERENCES
  BETWEEN jobflow AND GNU Parallel</a></h2>
<b>jobflow</b> can run multiple jobs in parallel.
<div class="Pp"></div>
Just like <b>xargs</b> output from <b>jobflow</b> jobs running in parallel mix
  together by default. <b>jobflow</b> can buffer into files (placed in
  /run/shm), but these are not cleaned up - not even if <b>jobflow</b> dies
  unexpectently. If the total output is big (in the order of RAM+swap) it can
  cause the system to run out of memory.
<div class="Pp"></div>
<b>jobflow</b> gives no error if the command is unknown, and like <b>xargs</b>
  redirection requires wrapping with <b>bash -c</b>.
<div class="Pp"></div>
<b>jobflow</b> makes it possible to set ressource limits on the running jobs.
  This can be emulated by GNU <b>parallel</b> using <b>bash</b>'s <b>ulimit</b>:
<div class="Pp"></div>
<pre>
  jobflow -limits=mem=100M,cpu=3,fsize=20M,nofiles=300 myjob
  parallel 'ulimit -v 102400 -t 3 -f 204800 -n 300 myjob'
</pre>
<div class="Pp"></div>
<i>EXAMPLES FROM jobflow README</i>
<div class="Pp"></div>
<b>1</b> cat things.list | jobflow -threads=8 -exec ./mytask {}
<div class="Pp"></div>
<b>1</b> cat things.list | parallel -j8 ./mytask {}
<div class="Pp"></div>
<b>2</b> seq 100 | jobflow -threads=100 -exec echo {}
<div class="Pp"></div>
<b>2</b> seq 100 | parallel -j100 echo {}
<div class="Pp"></div>
<b>3</b> cat urls.txt | jobflow -threads=32 -exec wget {}
<div class="Pp"></div>
<b>3</b> cat urls.txt | parallel -j32 wget {}
<div class="Pp"></div>
<b>4</b> find . -name '*.bmp' | jobflow -threads=8 -exec bmp2jpeg {.}.bmp
  {.}.jpg
<div class="Pp"></div>
<b>4</b> find . -name '*.bmp' | parallel -j8 bmp2jpeg {.}.bmp {.}.jpg
<h2 class="Ss" title="Ss" id="DIFFERENCES_BETWEEN_ClusterSSH_AND_GNU_Parallel"><a class="selflink" href="#DIFFERENCES_BETWEEN_ClusterSSH_AND_GNU_Parallel">DIFFERENCES
  BETWEEN ClusterSSH AND GNU Parallel</a></h2>
ClusterSSH solves a different problem than GNU <b>parallel</b>.
<div class="Pp"></div>
ClusterSSH opens a terminal window for each computer and using a master window
  you can run the same command on all the computers. This is typically used for
  administrating several computers that are almost identical.
<div class="Pp"></div>
GNU <b>parallel</b> runs the same (or different) commands with different
  arguments in parallel possibly using remote computers to help computing. If
  more than one computer is listed in <b>-S</b> GNU <b>parallel</b> may only use
  one of these (e.g. if there are 8 jobs to be run and one computer has 8
  cores).
<div class="Pp"></div>
GNU <b>parallel</b> can be used as a poor-man's version of ClusterSSH:
<div class="Pp"></div>
<b>parallel --nonall -S server-a,server-b do_stuff foo bar</b>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
<h2 class="Ss" title="Ss" id="Quoting_of_newline"><a class="selflink" href="#Quoting_of_newline">Quoting
  of newline</a></h2>
Because of the way newline is quoted this will not work:
<div class="Pp"></div>
<pre>
  echo 1,2,3 | parallel -vkd, &quot;echo 'a{}b'&quot;
</pre>
<div class="Pp"></div>
However, these will all work:
<div class="Pp"></div>
<pre>
  echo 1,2,3 | parallel -vkd, echo a{}b
  echo 1,2,3 | parallel -vkd, &quot;echo 'a'{}'b'&quot;
  echo 1,2,3 | parallel -vkd, &quot;echo 'a'&quot;{}&quot;'b'&quot;
</pre>
<h2 class="Ss" title="Ss" id="Speed"><a class="selflink" href="#Speed">Speed</a></h2>
<i>Startup</i>
<div class="Pp"></div>
GNU <b>parallel</b> is slow at starting up - around 250 ms the first time and
  150 ms after that.
<div class="Pp"></div>
<i>Job startup</i>
<div class="Pp"></div>
Starting a job on the local machine takes around 10 ms. This can be a big
  overhead if the job takes very few ms to run. Often you can group small jobs
  together using <b>-X</b> which will make the overhead less significant. Or you
  can run multiple GNU <b>parallel</b>s as described in <b>EXAMPLE: Speeding up
  fast jobs</b>.
<div class="Pp"></div>
<i>SSH</i>
<div class="Pp"></div>
When using multiple computers GNU <b>parallel</b> opens <b>ssh</b> connections
  to them to figure out how many connections can be used reliably simultaneously
  (Namely SSHD's MaxStartups). This test is done for each host in serial, so if
  your <b>--sshloginfile</b> contains many hosts it may be slow.
<div class="Pp"></div>
If your jobs are short you may see that there are fewer jobs running on the
  remove systems than expected. This is due to time spent logging in and out.
  <b>-M</b> may help here.
<div class="Pp"></div>
<i>Disk access</i>
<div class="Pp"></div>
A single disk can normally read data faster if it reads one file at a time
  instead of reading a lot of files in parallel, as this will avoid disk seeks.
  However, newer disk systems with multiple drives can read faster if reading
  from multiple files in parallel.
<div class="Pp"></div>
If the jobs are of the form read-all-compute-all-write-all, so everything is
  read before anything is written, it may be faster to force only one disk
  access at the time:
<div class="Pp"></div>
<pre>
  sem --id diskio cat file | compute | sem --id diskio cat &gt; file
</pre>
<div class="Pp"></div>
If the jobs are of the form read-compute-write, so writing starts before all
  reading is done, it may be faster to force only one reader and writer at the
  time:
<div class="Pp"></div>
<pre>
  sem --id read cat file | compute | sem --id write cat &gt; file
</pre>
<div class="Pp"></div>
If the jobs are of the form read-compute-read-compute, it may be faster to run
  more jobs in parallel than the system has CPUs, as some of the jobs will be
  stuck waiting for disk access.
<h2 class="Ss" title="Ss" id="--nice_limits_command_length"><a class="selflink" href="#--nice_limits_command_length">--nice
  limits command length</a></h2>
The current implementation of <b>--nice</b> is too pessimistic in the max
  allowed command length. It only uses a little more than half of what it could.
  This affects <b>-X</b> and <b>-m</b>. If this becomes a real problem for you
  file a bug-report.
<h2 class="Ss" title="Ss" id="Aliases_and_functions_do_not_work"><a class="selflink" href="#Aliases_and_functions_do_not_work">Aliases
  and functions do not work</a></h2>
If you get:
<div class="Pp"></div>
<pre>
  Can't exec &quot;command&quot;: No such file or directory
</pre>
<div class="Pp"></div>
or:
<div class="Pp"></div>
<pre>
  open3: exec of by command failed
</pre>
<div class="Pp"></div>
it may be because <i>command</i> is not known, but it could also be because
  <i>command</i> is an alias or a function. If it is a function you need to
  <b>export -f</b> the function first. An alias will only work if you use
  <b>env_parallel</b> described earlier.
<h1 class="Sh" title="Sh" id="REPORTING_BUGS"><a class="selflink" href="#REPORTING_BUGS">REPORTING
  BUGS</a></h1>
Report bugs to &lt;bug-parallel@gnu.org&gt; or
  https://savannah.gnu.org/bugs/?func=additem&amp;group=parallel
<div class="Pp"></div>
See a perfect bug report on
  https://lists.gnu.org/archive/html/bug-parallel/2015-01/msg00000.html
<div class="Pp"></div>
Your bug report should always include:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The error message you get (if any).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The complete output of <b>parallel --version</b>. If you
      are not running the latest released version (see
      http://ftp.gnu.org/gnu/parallel/) you should specify why you believe the
      problem is not fixed in that version.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A minimal, complete, and verifiable example (See
      description on http://stackoverflow.com/help/mcve).
    <div style="height: 1.00em;">&#x00A0;</div>
    It should be a complete example that others can run that shows the problem
      including all files needed to run the example. This should preferably be
      small and simple, so try to remove as many options as possible. A
      combination of <b>yes</b>, <b>seq</b>, <b>cat</b>, <b>echo</b>, and
      <b>sleep</b> can reproduce most errors. If your example requires large
      files, see if you can make them by something like <b>seq 1000000</b> &gt;
      <b>file</b> or <b>yes</b> <b>| head -n 10000000</b> &gt; <b>file</b>. If
      your example requires remote execution, see if you can use
      <b>localhost</b> - maybe using another login.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The output of your example. If your problem is not easily
      reproduced by others, the output might help them figure out the
    problem.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Whether you have watched the intro videos
      (http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1), walked through
      the tutorial (man parallel_tutorial), and read the EXAMPLE section in the
      man page (man parallel - search for EXAMPLE:).</dd>
</dl>
<div class="Pp"></div>
If you suspect the error is dependent on your environment or distribution,
  please see if you can reproduce the error on one of these VirtualBox images:
  http://sourceforge.net/projects/virtualboximage/files/
<div class="Pp"></div>
Specifying the name of your distribution is not enough as you may have installed
  software that is not in the VirtualBox images.
<div class="Pp"></div>
If you cannot reproduce the error on any of the VirtualBox images above, see if
  you can build a VirtualBox image on which you can reproduce the error. If not
  you should assume the debugging will be done through you. That will put more
  burden on you and it is extra important you give any information that help. In
  general the problem will be fixed faster and with less work for you if you can
  reproduce the error on a VirtualBox.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
When using GNU <b>parallel</b> for a publication please cite:
<div class="Pp"></div>
O. Tange (2011): GNU Parallel - The Command-Line Power Tool, ;login: The USENIX
  Magazine, February 2011:42-47.
<div class="Pp"></div>
This helps funding further development; and it won't cost you a cent. If you pay
  10000 EUR you should feel free to use GNU Parallel without citing.
<div class="Pp"></div>
Copyright (C) 2007-10-18 Ole Tange, http://ole.tange.dk
<div class="Pp"></div>
Copyright (C) 2008,2009,2010 Ole Tange, http://ole.tange.dk
<div class="Pp"></div>
Copyright (C) 2010,2011,2012,2013,2014,2015,2016 Ole Tange, http://ole.tange.dk
  and Free Software Foundation, Inc.
<div class="Pp"></div>
Parts of the manual concerning <b>xargs</b> compatibility is inspired by the
  manual of <b>xargs</b> from GNU findutils 4.4.2.
<h1 class="Sh" title="Sh" id="LICENSE"><a class="selflink" href="#LICENSE">LICENSE</a></h1>
Copyright (C) 2007,2008,2009,2010,2011,2012,2013,2014,2015,2016 Free Software
  Foundation, Inc.
<div class="Pp"></div>
This program is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free Software
  Foundation; either version 3 of the License, or at your option any later
  version.
<div class="Pp"></div>
This program is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU General Public License for more details.
<div class="Pp"></div>
You should have received a copy of the GNU General Public License along with
  this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
<h2 class="Ss" title="Ss" id="Documentation_license_I"><a class="selflink" href="#Documentation_license_I">Documentation
  license I</a></h2>
Permission is granted to copy, distribute and/or modify this documentation under
  the terms of the GNU Free Documentation License, Version 1.3 or any later
  version published by the Free Software Foundation; with no Invariant Sections,
  with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license
  is included in the file fdl.txt.
<h2 class="Ss" title="Ss" id="Documentation_license_II"><a class="selflink" href="#Documentation_license_II">Documentation
  license II</a></h2>
You are free:
<dl class="Bl-tag">
  <dt class="It-tag"><b>to Share</b></dt>
  <dd class="It-tag">to copy, distribute and transmit the work</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>to Remix</b></dt>
  <dd class="It-tag">to adapt the work</dd>
</dl>
<div class="Pp"></div>
Under the following conditions:
<dl class="Bl-tag">
  <dt class="It-tag"><b>Attribution</b></dt>
  <dd class="It-tag">You must attribute the work in the manner specified by the
      author or licensor (but not in any way that suggests that they endorse you
      or your use of the work).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Share Alike</b></dt>
  <dd class="It-tag">If you alter, transform, or build upon this work, you may
      distribute the resulting work only under the same, similar or a compatible
      license.</dd>
</dl>
<div class="Pp"></div>
With the understanding that:
<dl class="Bl-tag">
  <dt class="It-tag"><b>Waiver</b></dt>
  <dd class="It-tag">Any of the above conditions can be waived if you get
      permission from the copyright holder.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Public Domain</b></dt>
  <dd class="It-tag">Where the work or any of its elements is in the public
      domain under applicable law, that status is in no way affected by the
      license.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Other Rights</b></dt>
  <dd class="It-tag">In no way are any of the following rights affected by the
      license:</dd>
</dl>
<div style="margin-left: 9.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Your fair dealing or fair use rights, or other applicable
      copyright exceptions and limitations;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The author's moral rights;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Rights other persons may have either in the work itself or
      in how the work is used, such as publicity or privacy rights.</dd>
</dl>
</div>
<div style="margin-left: 9.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Notice</b></dt>
  <dd class="It-tag">For any reuse or distribution, you must make clear to
      others the license terms of this work.</dd>
</dl>
<div class="Pp"></div>
A copy of the full license is included in the file as cc-by-sa.txt.
<h1 class="Sh" title="Sh" id="DEPENDENCIES"><a class="selflink" href="#DEPENDENCIES">DEPENDENCIES</a></h1>
GNU <b>parallel</b> uses Perl, and the Perl modules Getopt::Long, IPC::Open3,
  Symbol, IO::File, POSIX, and File::Temp. For remote usage it also uses rsync
  with ssh.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>ssh</b>(1), <b>ssh-agent</b>(1), <b>sshpass</b>(1), <b>ssh-copy-id</b>(1),
  <b>rsync</b>(1), <b>find</b>(1), <b>xargs</b>(1), <b>dirname</b>(1),
  <b>make</b>(1), <b>pexec</b>(1), <b>ppss</b>(1), <b>xjobs</b>(1),
  <b>prll</b>(1), <b>dxargs</b>(1), <b>mdm</b>(1)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-07-22</td>
    <td class="foot-os">20160622</td>
  </tr>
</table>
</body>
</html>
