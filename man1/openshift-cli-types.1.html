<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:29:06 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OPENSHIFT CLI(1) June 2016 OPENSHIFT CLI(1)</p>

<p style="margin-top: 1em">NAME <br>
openshift cli types - An introduction to concepts and
types</p>

<p style="margin-top: 1em">SYNOPSIS <br>
openshift cli types [OPTIONS]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Concepts and Types</p>

<p style="margin-top: 1em">Kubernetes and OpenShift help
developers and operators build, test, and deploy
applications in a containerized cloud environment.
Applications may be composed of all of the com&acirc; <br>
ponents below, although most developers will be concerned
with Services, Deployments, and Builds for delivering
changes.</p>

<p style="margin-top: 1em">Concepts:</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Containers: A definition of how
to run one or more processes inside of a portable Linux
environment. Containers are started from an Image and are
usually isolated from other con&acirc; <br>
tainers on the same machine.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Image: A layered Linux
filesystem that contains application code, dependencies, and
any supporting operating system libraries. An image is
identified by a name that can be local <br>
to the current cluster or point to a remote Docker registry
(a storage server for images).</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Pods [pod]: A set of one or more
containers that are deployed onto a Node together and share
a unique IP and Volumes (persistent storage). Pods also
define the security and run&acirc; <br>
time policy for each container.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Labels: Labels are key value
pairs that can be assigned to any resource in the system for
grouping and selection. Many resources use labels to
identify sets of other resources.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Volumes: Containers are not
persistent by default - on restart their contents are
cleared. Volumes are mounted filesystems available to Pods
and their containers which may be <br>
backed by a number of host-local or network attached storage
endpoints. The simplest volume type is EmptyDir, which is a
temporary directory on a single machine. Administrators <br>
may also allow you to request a Persistent Volume that is
automatically attached to your pods.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Nodes [node]: Machines set up in
the cluster to run containers. Usually managed by
administrators and not by end users.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Services [svc]: A name
representing a set of pods (or external servers) that are
accessed by other pods. The service gets an IP and a DNS
name, and can be exposed externally to <br>
the cluster via a port or a Route. It&rsquo;s also easy to
consume services from pods because an environment variable
with the name &lt;SERVICE&gt;_HOST is automatically injected
into other <br>
pods.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Routes [route]: A route is an
external DNS entry (either a top level domain or a
dynamically allocated name) that is created to point to a
service so that it can be accessed out&acirc; <br>
side the cluster. The administrator may configure one or
more Routers to handle those routes, typically through an
Apache or HAProxy load balancer / proxy.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Replication Controllers [rc]: A
replication controller maintains a specific number of pods
based on a template that match a set of labels. If pods are
deleted (because the node <br>
they run on is taken out of service) the controller creates
a new copy of that pod. A replication controller is most
commonly used to represent a single deployment of part of an
<br>
application based on a built image.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Deployment Configuration [dc]:
Defines the template for a pod and manages deploying new
images or configuration changes whenever those change. A
single deployment configuration <br>
is usually analogous to a single micro-service. Can support
many different deployment patterns, including full restart,
customizable rolling updates, and fully custom behaviors,
<br>
as well as pre- and post- hooks. Each deployment is
represented as a replication controller.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Build Configuration [bc]:
Contains a description of how to build source code and a
base image into a new image - the primary method for
delivering changes to your application. <br>
Builds can be source based and use builder images for common
languages like Java, PHP, Ruby, or Python, or be Docker
based and create builds from a Dockerfile. Each build
config&acirc; <br>
uration has web-hooks and can be triggered automatically by
changes to their base images.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Builds [build]: Builds create a
new image from source code, other images, Dockerfiles, or
binary input. A build is run inside of a container and has
the same restrictions normal <br>
pods have. A build usually results in an image pushed to a
Docker registry, but you can also choose to run a post-build
test that does not push an image.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Image Streams and Image Stream
Tags [is,istag]: An image stream groups sets of related
images under tags - analogous to a branch in a source code
repository. Each image stream <br>
may have one or more tags (the default tag is called
&quot;latest&quot;) and those tags may point at external
Docker registries, at other tags in the same stream, or be
controlled to <br>
directly point at known images. In addition, images can be
pushed to an image stream tag directly via the integrated
Docker registry.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Secrets [secret]: The secret
resource can hold text or binary secrets for delivery into
your pods. By default, every container is given a single
secret which contains a token for <br>
accessing the API (with limited privileges) at
/var/run/secrets/kubernetes.io/serviceaccount. You can
create new secrets and mount them in your own pods, as well
as reference <br>
secrets from builds (for connecting to remote servers) or
use them to import remote images into an image stream.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Projects [project]: All of the
above resources (except Nodes) exist inside of a project.
Projects have a list of members and their roles, like
viewer, editor, or admin, as well <br>
as a set of security controls on the running pods, and
limits on how many resources the project can use. The names
of each resource are unique within a project. Developers may
<br>
request projects be created, but administrators control the
resources allocated to projects.</p>

<p style="margin-top: 1em">For more, see
&acirc;&uml;https://docs.openshift.com&acirc;&copy;</p>

<p style="margin-top: 1em">OPTIONS INHERITED FROM PARENT
COMMANDS <br>
--api-version=&quot;&quot; <br>
DEPRECATED: The API version to use when talking to the
server</p>

<p style="margin-top: 1em">--as=&quot;&quot; <br>
Username to impersonate for the operation</p>


<p style="margin-top: 1em">--azure-container-registry-config=&quot;&quot;
<br>
Path to the file container Azure container registry
configuration information.</p>


<p style="margin-top: 1em">--certificate-authority=&quot;&quot;
<br>
Path to a cert. file for the certificate authority</p>


<p style="margin-top: 1em">--client-certificate=&quot;&quot;
<br>
Path to a client certificate file for TLS</p>

<p style="margin-top: 1em">--client-key=&quot;&quot; <br>
Path to a client key file for TLS</p>

<p style="margin-top: 1em">--cluster=&quot;&quot; <br>
The name of the kubeconfig cluster to use</p>

<p style="margin-top: 1em">--config=&quot;&quot; <br>
Path to the config file to use for CLI requests.</p>

<p style="margin-top: 1em">--context=&quot;&quot; <br>
The name of the kubeconfig context to use</p>

<p style="margin-top: 1em">--google-json-key=&quot;&quot;
<br>
The Google Cloud Platform Service Account JSON Key to use
for authentication.</p>


<p style="margin-top: 1em">--insecure-skip-tls-verify=false
<br>
If true, the server&rsquo;s certificate will not be checked
for validity. This will make your HTTPS connections
insecure</p>

<p style="margin-top: 1em">--log-flush-frequency=0 <br>
Maximum number of seconds between log flushes</p>

<p style="margin-top: 1em">--match-server-version=false
<br>
Require server version to match client version</p>

<p style="margin-top: 1em">-n, --namespace=&quot;&quot;
<br>
If present, the namespace scope for this CLI request</p>

<p style="margin-top: 1em">--request-timeout=&quot;0&quot;
<br>
The length of time to wait before giving up on a single
server request. Non-zero values should contain a
corresponding time unit (e.g. 1s, 2m, 3h). A value of zero
means <br>
don&rsquo;t timeout requests.</p>

<p style="margin-top: 1em">--server=&quot;&quot; <br>
The address and port of the Kubernetes API server</p>

<p style="margin-top: 1em">--token=&quot;&quot; <br>
Bearer token for authentication to the API server</p>

<p style="margin-top: 1em">--user=&quot;&quot; <br>
The name of the kubeconfig user to use</p>

<p style="margin-top: 1em">EXAMPLE <br>
# View all projects you have access to <br>
openshift cli get projects</p>

<p style="margin-top: 1em"># See a list of all services in
the current project <br>
openshift cli get svc</p>

<p style="margin-top: 1em"># Describe a deployment
configuration in detail <br>
openshift cli describe dc mydeploymentconfig</p>

<p style="margin-top: 1em"># Show the images tagged into an
image stream <br>
openshift cli describe is ruby-centos7</p>

<p style="margin-top: 1em">SEE ALSO <br>
openshift-cli(1),</p>

<p style="margin-top: 1em">HISTORY <br>
June 2016, Ported from the Kubernetes man-doc generator</p>

<p style="margin-top: 1em">Openshift Openshift CLI User
Manuals OPENSHIFT CLI(1)</p>
<hr>
</body>
</html>
