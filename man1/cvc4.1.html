<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:01:47 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CVC4(1) User Manuals CVC4(1)</p>

<p style="margin-top: 1em">NAME <br>
cvc4, pcvc4 - an automated theorem prover</p>

<p style="margin-top: 1em">SYNOPSIS <br>
cvc4 [ options ] [ file ]</p>

<p style="margin-top: 1em">pcvc4 [ options ] [ file ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
cvc4 is an automated theorem prover for first-order formulas
with respect to background theories of interest. pcvc4 is
CVC4&rsquo;s &quot;portfolio&quot; variant, which is capable
of running <br>
multiple CVC4 instances in parallel, configured
differently.</p>

<p style="margin-top: 1em">With file , commands are read
from file and executed. CVC4 supports the SMT-LIB (versions
1.2 and 2.0) input format, as well as its own native
&acirc;presentation language&acirc; (see <br>
cvc4(5) ), which is similar in many respects to CVC3&rsquo;s
presentation language, but not identical.</p>

<p style="margin-top: 1em">If file is unspecified, standard
input is read (and the CVC4 presentation language is
assumed). If file is unspecified and CVC4 is connected to a
terminal, interactive mode is <br>
assumed.</p>

<p style="margin-top: 1em">COMMON OPTIONS <br>
Each option marked with [*] has a --no-OPTIONNAME variant,
which reverses the sense of the option.</p>

<p style="margin-top: 1em">--lang=LANG | -L LANG <br>
force input language (default is &quot;auto&quot;; see
--lang help)</p>

<p style="margin-top: 1em">--output-lang=LANG <br>
force output language (default is &quot;auto&quot;; see
--output-lang help)</p>

<p style="margin-top: 1em">--verbose | -v <br>
increase verbosity (may be repeated)</p>

<p style="margin-top: 1em">--quiet | -q <br>
decrease verbosity (may be repeated)</p>

<p style="margin-top: 1em">--stats <br>
give statistics on exit [*]</p>

<p style="margin-top: 1em">--version | -V <br>
identify this CVC4 binary</p>

<p style="margin-top: 1em">--help | -h <br>
full command line reference</p>

<p style="margin-top: 1em">--show-config <br>
show CVC4 static configuration</p>

<p style="margin-top: 1em">--strict-parsing <br>
be less tolerant of non-conforming inputs [*]</p>

<p style="margin-top: 1em">--dump=MODE <br>
dump preprocessed assertions, etc., see --dump=help</p>

<p style="margin-top: 1em">--dump-to=FILE <br>
all dumping goes to FILE (instead of stdout)</p>

<p style="margin-top: 1em">--produce-models | -m <br>
support the get-value and get-model commands [*]</p>

<p style="margin-top: 1em">--produce-assertions <br>
keep an assertions list (enables get-assertions command)
[*]</p>

<p style="margin-top: 1em">--incremental | -i <br>
enable incremental solving [*]</p>

<p style="margin-top: 1em">--tlimit=MS <br>
enable time limiting (give milliseconds)</p>

<p style="margin-top: 1em">--tlimit-per=MS <br>
enable time limiting per query (give milliseconds)</p>

<p style="margin-top: 1em">--rlimit=N <br>
enable resource limiting (currently, roughly the number of
SAT conflicts)</p>

<p style="margin-top: 1em">--rlimit-per=N <br>
enable resource limiting per query</p>

<p style="margin-top: 1em">--hard-limit <br>
the resource limit is hard potentially leaving the smtEngine
in an unsafe state (should be destroyed and rebuild after
resourcing out) [*]</p>

<p style="margin-top: 1em">--cpu-time <br>
measures CPU time if set to true and wall time if false
(default false) [*]</p>

<p style="margin-top: 1em">ARITHMETIC THEORY OPTIONS <br>
--unate-lemmas=MODE <br>
determines which lemmas to add before solving (default is
&rsquo;all&rsquo;, see --unate-lemmas=help)</p>

<p style="margin-top: 1em">--arith-prop=MODE <br>
turns on arithmetic propagation (default is
&rsquo;old&rsquo;, see --arith-prop=help)</p>

<p style="margin-top: 1em">--heuristic-pivots=N <br>
the number of times to apply the heuristic pivot rule; if N
&lt; 0, this defaults to the number of variables; if this is
unset, this is tuned by the logic selection</p>


<p style="margin-top: 1em">--standard-effort-variable-order-pivots=N
<br>
limits the number of pivots in a single invocation of
check() at a non-full effort level using Bland&rsquo;s pivot
rule (EXPERTS only)</p>

<p style="margin-top: 1em">--error-selection-rule=RULE <br>
change the pivot rule for the basic variable (default is
&rsquo;min&rsquo;, see --pivot-rule help)</p>

<p style="margin-top: 1em">--simplex-check-period=N <br>
the number of pivots to do in simplex before rechecking for
a conflict on all variables</p>

<p style="margin-top: 1em">--pivot-threshold=N <br>
sets the number of pivots using --pivot-rule per basic
variable per simplex instance before using variable
order</p>

<p style="margin-top: 1em">--prop-row-length=N <br>
sets the maximum row length to be used in propagation</p>

<p style="margin-top: 1em">--enable-dio-solver <br>
turns on Linear Diophantine Equation solver (Griggio, JSAT
2012)</p>

<p style="margin-top: 1em">--disable-dio-solver <br>
turns off Linear Diophantine Equation solver (Griggio, JSAT
2012)</p>


<p style="margin-top: 1em">--enable-arith-rewrite-equalities
<br>
turns on the preprocessing rewrite turning equalities into a
conjunction of inequalities</p>


<p style="margin-top: 1em">--disable-arith-rewrite-equalities
<br>
turns off the preprocessing rewrite turning equalities into
a conjunction of inequalities</p>

<p style="margin-top: 1em">--enable-miplib-trick <br>
turns on the preprocessing step of attempting to infer
bounds on miplib problems</p>

<p style="margin-top: 1em">--disable-miplib-trick <br>
turns off the preprocessing step of attempting to infer
bounds on miplib problems</p>

<p style="margin-top: 1em">--miplib-trick-subs=N <br>
do substitution for miplib &rsquo;tmp&rsquo; vars if defined
in &lt;= N eliminated vars</p>

<p style="margin-top: 1em">--cut-all-bounded <br>
turns on the integer solving step of periodically cutting
all integer variables that have both upper and lower bounds
[*]</p>

<p style="margin-top: 1em">--no-cut-all-bounded <br>
turns off the integer solving step of periodically cutting
all integer variables that have both upper and lower
bounds</p>

<p style="margin-top: 1em">--maxCutsInContext <br>
maximum cuts in a given context before signalling a
restart</p>

<p style="margin-top: 1em">--revert-arith-models-on-unsat
<br>
revert the arithmetic model to a known safe model on unsat
if one is cached [*]</p>

<p style="margin-top: 1em">--fc-penalties <br>
turns on degenerate pivot penalties [*]</p>

<p style="margin-top: 1em">--no-fc-penalties <br>
turns off degenerate pivot penalties</p>

<p style="margin-top: 1em">--use-fcsimplex <br>
use focusing and converging simplex (FMCAD 2013 submission)
[*]</p>

<p style="margin-top: 1em">--use-soi <br>
use sum of infeasibility simplex (FMCAD 2013 submission)
[*]</p>

<p style="margin-top: 1em">--restrict-pivots <br>
have a pivot cap for simplex at effort levels below
fullEffort [*]</p>

<p style="margin-top: 1em">--collect-pivot-stats <br>
collect the pivot history [*]</p>

<p style="margin-top: 1em">--use-approx <br>
attempt to use an approximate solver [*]</p>

<p style="margin-top: 1em">--approx-branch-depth <br>
maximum branch depth the approximate solver is allowed to
take</p>

<p style="margin-top: 1em">--dio-decomps <br>
let skolem variables for integer divisibility constraints
leak from the dio solver [*]</p>

<p style="margin-top: 1em">--new-prop <br>
use the new row propagation system [*]</p>

<p style="margin-top: 1em">--arith-prop-clauses <br>
rows shorter than this are propagated as clauses</p>

<p style="margin-top: 1em">--soi-qe <br>
use quick explain to minimize the sum of infeasibility
conflicts [*]</p>

<p style="margin-top: 1em">--rewrite-divk <br>
rewrite division and mod when by a constant into linear
terms [*]</p>

<p style="margin-top: 1em">--se-solve-int <br>
attempt to use the approximate solve integer method on
standard effort [*]</p>

<p style="margin-top: 1em">--lemmas-on-replay-failure <br>
attempt to use external lemmas if approximate solve integer
failed [*]</p>

<p style="margin-top: 1em">--dio-turns <br>
turns in a row dio solver cutting gets</p>

<p style="margin-top: 1em">--rr-turns <br>
round robin turn</p>

<p style="margin-top: 1em">--dio-repeat <br>
handle dio solver constraints in mass or one at a time
[*]</p>

<p style="margin-top: 1em">--replay-early-close-depth <br>
multiples of the depths to try to close the approx log
eagerly</p>

<p style="margin-top: 1em">--replay-failure-penalty <br>
number of solve integer attempts to skips after a numeric
failure</p>

<p style="margin-top: 1em">--replay-num-err-penalty <br>
number of solve integer attempts to skips after a numeric
failure</p>

<p style="margin-top: 1em">--replay-reject-cut <br>
maximum complexity of any coefficient while replaying
cuts</p>

<p style="margin-top: 1em">--replay-lemma-reject-cut <br>
maximum complexity of any coefficient while outputting
replaying cut lemmas</p>

<p style="margin-top: 1em">--replay-soi-major-threshold
<br>
threshold for a major tolerance failure by the approximate
solver</p>


<p style="margin-top: 1em">--replay-soi-major-threshold-pen
<br>
threshold for a major tolerance failure by the approximate
solver</p>

<p style="margin-top: 1em">--replay-soi-minor-threshold
<br>
threshold for a minor tolerance failure by the approximate
solver</p>


<p style="margin-top: 1em">--replay-soi-minor-threshold-pen
<br>
threshold for a minor tolerance failure by the approximate
solver</p>

<p style="margin-top: 1em">--pp-assert-max-sub-size <br>
threshold for substituting an equality in ppAssert</p>

<p style="margin-top: 1em">--max-replay-tree <br>
threshold for attempting to replay a tree</p>

<p style="margin-top: 1em">--pb-rewrites <br>
apply pseudo boolean rewrites [*]</p>

<p style="margin-top: 1em">--pb-rewrite-threshold <br>
threshold of number of pseudoboolean variables to have
before doing rewrites</p>

<p style="margin-top: 1em">--snorm-infer-eq <br>
infer equalities based on Shostak normalization [*]</p>

<p style="margin-top: 1em">--nl-ext <br>
extended approach to non-linear [*]</p>

<p style="margin-top: 1em">--nl-ext-rbound <br>
use resolution-style inference for inferring new bounds
[*]</p>

<p style="margin-top: 1em">--nl-ext-tplanes <br>
use non-terminating tangent plane strategy for non-linear
[*]</p>

<p style="margin-top: 1em">--nl-ext-ent-conf <br>
check for entailed conflicts in non-linear solver [*]</p>

<p style="margin-top: 1em">--nl-ext-rewrite <br>
do rewrites in non-linear solver [*]</p>

<p style="margin-top: 1em">--nl-ext-solve-subs <br>
do solving for determining constant substitutions [*]</p>

<p style="margin-top: 1em">--nl-ext-purify <br>
purify non-linear terms at preprocess [*]</p>

<p style="margin-top: 1em">--nl-ext-split-zero <br>
intial splits on zero for all variables [*]</p>

<p style="margin-top: 1em">ARRAYS THEORY OPTIONS <br>
--arrays-optimize-linear <br>
turn on optimization for linear array terms (see de Moura
FMCAD 09 arrays paper) [*]</p>

<p style="margin-top: 1em">--arrays-lazy-rintro1 <br>
turn on optimization to only perform RIntro1 rule lazily
(see Jovanovic/Barrett 2012: Being Careful with Theory
Combination) [*]</p>

<p style="margin-top: 1em">--arrays-weak-equiv <br>
use algorithm from Christ/Hoenicke (SMT 2014) [*]</p>

<p style="margin-top: 1em">--arrays-model-based <br>
turn on model-based array solver [*]</p>

<p style="margin-top: 1em">--arrays-eager-index <br>
turn on eager index splitting for generated array lemmas
[*]</p>

<p style="margin-top: 1em">--arrays-eager-lemmas <br>
turn on eager lemma generation for arrays [*]</p>

<p style="margin-top: 1em">--arrays-config <br>
set different array option configurations - for developers
only</p>

<p style="margin-top: 1em">--arrays-reduce-sharing <br>
use model information to reduce size of care graph for
arrays [*]</p>

<p style="margin-top: 1em">--arrays-prop <br>
propagation effort for arrays: 0 is none, 1 is some, 2 is
full</p>

<p style="margin-top: 1em">BASE OPTIONS <br>
--stats-every-query <br>
in incremental mode, print stats after every satisfiability
or validity query [*]</p>

<p style="margin-top: 1em">--stats-hide-zeros <br>
hide statistics which are zero</p>

<p style="margin-top: 1em">--stats-show-zeros <br>
show statistics even when they are zero (default)</p>

<p style="margin-top: 1em">--parse-only <br>
exit after parsing input [*]</p>

<p style="margin-top: 1em">--preprocess-only <br>
exit after preprocessing input [*]</p>

<p style="margin-top: 1em">--trace=TAG | -t TAG <br>
trace something (e.g. -t pushpop), can repeat</p>

<p style="margin-top: 1em">--debug=TAG | -d TAG <br>
debug something (e.g. -d arith), can repeat</p>

<p style="margin-top: 1em">--print-success <br>
print the &quot;success&quot; output required of SMT-LIBv2
[*]</p>

<p style="margin-top: 1em">--smtlib-strict <br>
SMT-LIBv2 compliance mode (implies other options)</p>

<p style="margin-top: 1em">BITVECTOR THEORY OPTIONS <br>
--bv-sat-solver=MODE <br>
choose which sat solver to use, see --bv-sat-solver=help
(EXPERTS only)</p>

<p style="margin-top: 1em">--bitblast=MODE <br>
choose bitblasting mode, see --bitblast=help</p>

<p style="margin-top: 1em">--bitblast-aig <br>
bitblast by first converting to AIG (implies
--bitblast=eager) [*]</p>

<p style="margin-top: 1em">--bv-aig-simp=COMMAND <br>
abc command to run AIG simplifications (implies
--bitblast-aig, default is &quot;balance;drw&quot;) (EXPERTS
only)</p>

<p style="margin-top: 1em">--bv-propagate <br>
use bit-vector propagation in the bit-blaster [*]</p>

<p style="margin-top: 1em">--bv-eq-solver <br>
use the equality engine for the bit-vector theory (only if
--bitblast=lazy) [*]</p>

<p style="margin-top: 1em">--bv-eq-slicer=MODE <br>
turn on the slicing equality solver for the bit-vector
theory (only if --bitblast=lazy)</p>

<p style="margin-top: 1em">--bv-inequality-solver <br>
turn on the inequality solver for the bit-vector theory
(only if --bitblast=lazy) [*]</p>

<p style="margin-top: 1em">--bv-algebraic-solver <br>
turn on the algebraic solver for the bit-vector theory (only
if --bitblast=lazy) [*]</p>

<p style="margin-top: 1em">--bv-algebraic-budget <br>
the budget allowed for the algebraic solver in number of SAT
conflicts (EXPERTS only)</p>

<p style="margin-top: 1em">--bv-to-bool <br>
lift bit-vectors of size 1 to booleans when possible [*]</p>

<p style="margin-top: 1em">--bool-to-bv <br>
convert booleans to bit-vectors of size 1 when possible
[*]</p>

<p style="margin-top: 1em">--bv-div-zero-const <br>
always return -1 on division by zero [*]</p>

<p style="margin-top: 1em">--bv-extract-arith <br>
enable rewrite pushing extract [i:0] over arithmetic
operations (can blow up) (EXPERTS only) [*]</p>

<p style="margin-top: 1em">--bv-abstraction <br>
mcm benchmark abstraction (EXPERTS only) [*]</p>

<p style="margin-top: 1em">--bv-skolemize <br>
skolemize arguments for bv abstraction (only does something
if --bv-abstraction is on) (EXPERTS only) [*]</p>

<p style="margin-top: 1em">--bv-num-func=NUM <br>
number of function symbols in conflicts that are generalized
(EXPERTS only)</p>

<p style="margin-top: 1em">--bv-eager-explanations <br>
compute bit-blasting propagation explanations eagerly
(EXPERTS only) [*]</p>

<p style="margin-top: 1em">--bv-quick-xplain <br>
minimize bv conflicts using the QuickXplain algorithm
(EXPERTS only) [*]</p>

<p style="margin-top: 1em">--bv-intro-pow2 <br>
introduce bitvector powers of two as a preprocessing pass
(EXPERTS only) [*]</p>

<p style="margin-top: 1em">--bv-lazy-rewrite-extf <br>
lazily rewrite extended functions like bv2nat and int2bv
[*]</p>

<p style="margin-top: 1em">--bv-lazy-reduce-extf <br>
reduce extended functions like bv2nat and int2bv at last
call instead of full effort [*]</p>

<p style="margin-top: 1em">--bv-alg-extf <br>
algebraic inferences for extended functions [*]</p>

<p style="margin-top: 1em">DATATYPES THEORY OPTIONS <br>
--dt-rewrite-error-sel <br>
rewrite incorrectly applied selectors to arbitrary ground
term (EXPERTS only) [*]</p>

<p style="margin-top: 1em">--dt-force-assignment <br>
force the datatypes solver to give specific values to all
datatypes terms before answering sat [*]</p>

<p style="margin-top: 1em">--dt-binary-split <br>
do binary splits for datatype constructor types [*]</p>

<p style="margin-top: 1em">--dt-ref-sk-intro <br>
introduce reference skolems for shorter explanations [*]</p>

<p style="margin-top: 1em">--dt-use-testers <br>
do not preprocess away tester predicates [*]</p>

<p style="margin-top: 1em">--cdt-bisimilar <br>
do bisimilarity check for co-datatypes [*]</p>

<p style="margin-top: 1em">--dt-cyclic <br>
do cyclicity check for datatypes [*]</p>

<p style="margin-top: 1em">--dt-infer-as-lemmas <br>
always send lemmas out instead of making internal inferences
[*]</p>

<p style="margin-top: 1em">--dt-blast-splits <br>
when applicable, blast splitting lemmas for all variables at
once [*]</p>

<p style="margin-top: 1em">DECISION HEURISTICS OPTIONS <br>
--decision=MODE <br>
choose decision mode, see --decision=help</p>

<p style="margin-top: 1em">--decision-threshold=N <br>
ignore all nodes greater than threshold in first attempt to
pick decision (EXPERTS only)</p>

<p style="margin-top: 1em">--decision-use-weight <br>
use the weight nodes (locally, by looking at children) to
direct recursive search (EXPERTS only) [*]</p>

<p style="margin-top: 1em">--decision-random-weight=N <br>
assign random weights to nodes between 0 and N-1 (0:
disable) (EXPERTS only)</p>

<p style="margin-top: 1em">--decision-weight-internal=HOW
<br>
computer weights of internal nodes using children: off, max,
sum, usr1 (meaning evolving) (EXPERTS only)</p>

<p style="margin-top: 1em">EXPRESSION PACKAGE OPTIONS <br>
--default-expr-depth=N <br>
print exprs to depth N (0 == default, -1 == no limit)</p>

<p style="margin-top: 1em">--default-dag-thresh=N <br>
dagify common subexprs appearing &gt; N times (1 == default,
0 == don&rsquo;t dagify)</p>

<p style="margin-top: 1em">--print-expr-types <br>
print types with variables when printing exprs [*]</p>

<p style="margin-top: 1em">--eager-type-checking <br>
type check expressions immediately on creation (debug builds
only)</p>

<p style="margin-top: 1em">--lazy-type-checking <br>
type check expressions only when necessary (default)</p>

<p style="margin-top: 1em">IDL OPTIONS <br>
--enable-idl-rewrite-equalities <br>
enable rewriting equalities into two inequalities in IDL
solver (default is disabled)</p>


<p style="margin-top: 1em">--disable-idl-rewrite-equalities
<br>
disable rewriting equalities into two inequalities in IDL
solver (default is disabled)</p>

<p style="margin-top: 1em">DRIVER OPTIONS <br>
--show-debug-tags <br>
show all available tags for debugging</p>

<p style="margin-top: 1em">--show-trace-tags <br>
show all available tags for tracing</p>

<p style="margin-top: 1em">--early-exit <br>
do not run destructors at exit; default on except in debug
builds (EXPERTS only) [*]</p>

<p style="margin-top: 1em">--threads=N <br>
Total number of threads for portfolio</p>

<p style="margin-top: 1em">--threadN=string <br>
configures portfolio thread N (0..#threads-1)</p>

<p style="margin-top: 1em">--thread-stack=N <br>
stack size for worker threads in MB (0 means use
Boost/thread lib default)</p>

<p style="margin-top: 1em">--filter-lemma-length=N <br>
don&rsquo;t share (among portfolio threads) lemmas strictly
longer than N</p>

<p style="margin-top: 1em">--fallback-sequential <br>
Switch to sequential mode (instead of printing an error) if
it can&rsquo;t be solved in portfolio mode [*]</p>

<p style="margin-top: 1em">--incremental-parallel <br>
Use parallel solver even in incremental mode (may print
&rsquo;unknown&rsquo;s at times) [*]</p>

<p style="margin-top: 1em">--interactive <br>
force interactive/non-interactive mode [*]</p>

<p style="margin-top: 1em">--continued-execution <br>
continue executing commands, even on error</p>

<p style="margin-top: 1em">--segv-spin <br>
spin on segfault/other crash waiting for gdb [*]</p>

<p style="margin-top: 1em">--tear-down-incremental=N <br>
implement PUSH/POP/multi-query by destroying and recreating
SmtEngine every N queries (EXPERTS only)</p>

<p style="margin-top: 1em">--wait-to-join <br>
wait for other threads to join before quitting (EXPERTS
only) [*]</p>

<p style="margin-top: 1em">PARSER OPTIONS <br>
--mmap memory map file input [*]</p>

<p style="margin-top: 1em">PRINTING OPTIONS <br>
--model-format=MODE <br>
print format mode for models, see --model-format=help</p>

<p style="margin-top: 1em">--inst-format=MODE <br>
print format mode for instantiations, see
--inst-format=help</p>

<p style="margin-top: 1em">PROOF OPTIONS <br>
--lfsc-letification <br>
turns on global letification in LFSC proofs [*]</p>

<p style="margin-top: 1em">--aggressive-core-min <br>
turns on aggressive unsat core minimization (experimental)
[*]</p>

<p style="margin-top: 1em">--fewer-preprocessing-holes <br>
try to eliminate preprocessing holes in proofs [*]</p>

<p style="margin-top: 1em">--allow-empty-dependencies <br>
if unable to track the dependencies of a
rewritten/preprocessed assertion, fail silently [*]</p>

<p style="margin-top: 1em">SAT LAYER OPTIONS <br>
--random-freq=P <br>
sets the frequency of random decisions in the sat solver
(P=0.0 by default)</p>

<p style="margin-top: 1em">--random-seed=S <br>
sets the random seed for the sat solver</p>

<p style="margin-top: 1em">--restart-int-base=N <br>
sets the base restart interval for the sat solver (N=25 by
default)</p>

<p style="margin-top: 1em">--restart-int-inc=F <br>
sets the restart interval increase factor for the sat solver
(F=3.0 by default)</p>

<p style="margin-top: 1em">--refine-conflicts <br>
refine theory conflict clauses (default false) [*]</p>

<p style="margin-top: 1em">--minisat-elimination <br>
use Minisat elimination [*]</p>

<p style="margin-top: 1em">--minisat-dump-dimacs <br>
instead of solving minisat dumps the asserted clauses in
Dimacs format [*]</p>

<p style="margin-top: 1em">QUANTIFIERS OPTIONS <br>
--miniscope-quant <br>
miniscope quantifiers [*]</p>

<p style="margin-top: 1em">--miniscope-quant-fv <br>
miniscope quantifiers for ground subformulas [*]</p>

<p style="margin-top: 1em">--quant-split <br>
apply splitting to quantified formulas based on variable
disjoint disjuncts [*]</p>

<p style="margin-top: 1em">--prenex-quant=MODE <br>
prenex mode for quantified formulas</p>

<p style="margin-top: 1em">--prenex-quant-user <br>
prenex quantified formulas with user patterns [*]</p>

<p style="margin-top: 1em">--var-elim-quant <br>
enable simple variable elimination for quantified formulas
[*]</p>

<p style="margin-top: 1em">--var-ineq-elim-quant <br>
enable variable elimination based on infinite projection of
unbound arithmetic variables [*]</p>

<p style="margin-top: 1em">--dt-var-exp-quant <br>
expand datatype variables bound to one constructor in
quantifiers [*]</p>

<p style="margin-top: 1em">--ite-lift-quant=MODE <br>
ite lifting mode for quantified formulas</p>

<p style="margin-top: 1em">--cond-var-split-quant <br>
split quantified formulas that lead to variable eliminations
[*]</p>

<p style="margin-top: 1em">--cond-var-split-agg-quant <br>
aggressive split quantified formulas that lead to variable
eliminations [*]</p>

<p style="margin-top: 1em">--ite-dtt-split-quant <br>
split ites with dt testers as conditions [*]</p>

<p style="margin-top: 1em">--pre-skolem-quant <br>
apply skolemization eagerly to bodies of quantified formulas
[*]</p>

<p style="margin-top: 1em">--pre-skolem-quant-nested <br>
apply skolemization to nested quantified formulas [*]</p>

<p style="margin-top: 1em">--pre-skolem-quant-agg <br>
apply skolemization to quantified formulas aggressively
[*]</p>

<p style="margin-top: 1em">--ag-miniscope-quant <br>
perform aggressive miniscoping for quantifiers [*]</p>

<p style="margin-top: 1em">--elim-taut-quant <br>
eliminate tautological disjuncts of quantified formulas
[*]</p>

<p style="margin-top: 1em">--elim-ext-arith-quant <br>
eliminate extended arithmetic symbols in quantified formulas
[*]</p>

<p style="margin-top: 1em">--cond-rewrite-quant <br>
conditional rewriting of quantified formulas [*]</p>

<p style="margin-top: 1em">--e-matching <br>
whether to do heuristic E-matching [*]</p>

<p style="margin-top: 1em">--term-db-mode <br>
which ground terms to consider for instantiation</p>

<p style="margin-top: 1em">--register-quant-body-terms <br>
consider ground terms within bodies of quantified formulas
for matching [*]</p>

<p style="margin-top: 1em">--infer-arith-trigger-eq <br>
infer equalities for trigger terms based on solving
arithmetic equalities [*]</p>

<p style="margin-top: 1em">--infer-arith-trigger-eq-exp
<br>
record explanations for inferArithTriggerEq [*]</p>

<p style="margin-top: 1em">--strict-triggers <br>
only instantiate quantifiers with user patterns based on
triggers [*]</p>

<p style="margin-top: 1em">--relevant-triggers <br>
prefer triggers that are more relevant based on SInE style
analysis [*]</p>

<p style="margin-top: 1em">--relational-triggers <br>
choose relational triggers such as x = f(y), x &gt;= f(y)
[*]</p>

<p style="margin-top: 1em">--purify-triggers <br>
purify triggers, e.g. f( x+1 ) becomes f( y ), x mapsto y-1
[*]</p>

<p style="margin-top: 1em">--purify-dt-triggers <br>
purify dt triggers, match all constructors of correct form
instead of selectors [*]</p>

<p style="margin-top: 1em">--pure-th-triggers <br>
use pure theory terms as single triggers [*]</p>

<p style="margin-top: 1em">--partial-triggers <br>
use triggers that do not contain all free variables [*]</p>

<p style="margin-top: 1em">--multi-trigger-when-single <br>
select multi triggers when single triggers exist [*]</p>

<p style="margin-top: 1em">--multi-trigger-priority <br>
only try multi triggers if single triggers give no
instantiations [*]</p>

<p style="margin-top: 1em">--multi-trigger-cache <br>
caching version of multi triggers [*]</p>

<p style="margin-top: 1em">--multi-trigger-linear <br>
implementation of multi triggers where maximum number of
instantiations is linear wrt number of ground terms [*]</p>

<p style="margin-top: 1em">--trigger-sel <br>
selection mode for triggers</p>

<p style="margin-top: 1em">--trigger-active-sel <br>
selection mode to activate triggers</p>

<p style="margin-top: 1em">--user-pat=MODE <br>
policy for handling user-provided patterns for quantifier
instantiation</p>

<p style="margin-top: 1em">--increment-triggers <br>
generate additional triggers as needed during search [*]</p>

<p style="margin-top: 1em">--inst-when=MODE <br>
when to apply instantiation</p>

<p style="margin-top: 1em">--inst-when-strict-interleave
<br>
ensure theory combination and standard quantifier effort
strategies take turns [*]</p>

<p style="margin-top: 1em">--inst-when-phase=N <br>
instantiation rounds quantifiers takes (&gt;=1) before
allowing theory combination to happen</p>

<p style="margin-top: 1em">--inst-when-tc-first <br>
allow theory combination to happen once initially, before
quantifier strategies are run [*]</p>

<p style="margin-top: 1em">--quant-model-ee <br>
use equality engine of model for last call effort [*]</p>

<p style="margin-top: 1em">--inst-max-level=N <br>
maximum inst level of terms used to instantiate quantified
formulas with (-1 == no limit, default)</p>

<p style="margin-top: 1em">--inst-level-input-only <br>
only input terms are assigned instantiation level zero
[*]</p>

<p style="margin-top: 1em">--quant-rep-mode=MODE <br>
selection mode for representatives in quantifiers engine</p>

<p style="margin-top: 1em">--inst-rlv-cond <br>
add relevancy conditions for instantiations [*]</p>

<p style="margin-top: 1em">--full-saturate-quant <br>
when all other quantifier instantiation strategies fail,
instantiate with ground terms from relevant domain, then
arbitrary ground terms before answering unknown [*]</p>

<p style="margin-top: 1em">--full-saturate-quant-rd <br>
whether to use relevant domain first for full saturation
instantiation strategy [*]</p>

<p style="margin-top: 1em">--fs-inst <br>
interleave full saturate instantiation with other techniques
[*]</p>

<p style="margin-top: 1em">--literal-matching=MODE <br>
choose literal matching mode</p>

<p style="margin-top: 1em">--finite-model-find <br>
use finite model finding heuristic for quantifier
instantiation [*]</p>

<p style="margin-top: 1em">--quant-fun-wd <br>
assume that function defined by quantifiers are well defined
[*]</p>

<p style="margin-top: 1em">--fmf-fun <br>
find models for recursively defined functions, assumes
functions are admissible [*]</p>

<p style="margin-top: 1em">--fmf-fun-rlv <br>
find models for recursively defined functions, assumes
functions are admissible, allows empty type when function is
irrelevant [*]</p>

<p style="margin-top: 1em">--fmf-empty-sorts <br>
allow finite model finding to assume sorts that do not occur
in ground assertions are empty [*]</p>

<p style="margin-top: 1em">--mbqi=MODE <br>
choose mode for model-based quantifier instantiation</p>

<p style="margin-top: 1em">--mbqi-one-inst-per-round <br>
only add one instantiation per quantifier per round for mbqi
[*]</p>

<p style="margin-top: 1em">--mbqi-one-quant-per-round <br>
only add instantiations for one quantifier per round for
mbqi [*]</p>

<p style="margin-top: 1em">--fmf-inst-engine <br>
use instantiation engine in conjunction with finite model
finding [*]</p>

<p style="margin-top: 1em">--fmf-inst-gen <br>
enable Inst-Gen instantiation techniques for finite model
finding [*]</p>


<p style="margin-top: 1em">--fmf-inst-gen-one-quant-per-round
<br>
only perform Inst-Gen instantiation techniques on one
quantifier per round [*]</p>

<p style="margin-top: 1em">--fmf-fresh-dc <br>
use fresh distinguished representative when applying
Inst-Gen techniques [*]</p>

<p style="margin-top: 1em">--fmf-fmc-simple <br>
simple models in full model check for finite model finding
[*]</p>

<p style="margin-top: 1em">--fmf-bound-int <br>
finite model finding on bounded integer quantification
[*]</p>

<p style="margin-top: 1em">--fmf-bound <br>
finite model finding on bounded quantification [*]</p>

<p style="margin-top: 1em">--fmf-bound-lazy <br>
enforce bounds for bounded quantification lazily via use of
proxy variables [*]</p>

<p style="margin-top: 1em">--fmf-bound-min-mode=MODE <br>
mode for which types of bounds to minimize via first
decision heuristics</p>

<p style="margin-top: 1em">--quant-cf <br>
enable conflict find mechanism for quantifiers [*]</p>

<p style="margin-top: 1em">--quant-cf-mode=MODE <br>
what effort to apply conflict find mechanism</p>

<p style="margin-top: 1em">--quant-cf-when=MODE <br>
when to invoke conflict find mechanism for quantifiers</p>

<p style="margin-top: 1em">--qcf-tconstraint <br>
enable entailment checks for t-constraints in qcf algorithm
[*]</p>

<p style="margin-top: 1em">--qcf-all-conflict <br>
add all available conflicting instances during
conflict-based instantiation [*]</p>

<p style="margin-top: 1em">--qcf-nested-conflict <br>
consider conflicts for nested quantifiers [*]</p>

<p style="margin-top: 1em">--qcf-vo-exp <br>
qcf experimental variable ordering [*]</p>

<p style="margin-top: 1em">--inst-no-entail <br>
do not consider instances of quantified formulas that are
currently entailed [*]</p>

<p style="margin-top: 1em">--inst-no-model-true <br>
do not consider instances of quantified formulas that are
currently true in model, if it is available [*]</p>

<p style="margin-top: 1em">--inst-prop <br>
internal propagation for instantiations for selecting
relevant instances [*]</p>

<p style="margin-top: 1em">--qcf-eager-test <br>
optimization, test qcf instances eagerly [*]</p>

<p style="margin-top: 1em">--qcf-eager-check-rd <br>
optimization, eagerly check relevant domain of matched
position [*]</p>

<p style="margin-top: 1em">--qcf-skip-rd <br>
optimization, skip instances based on possibly irrelevant
portions of quantified formulas [*]</p>

<p style="margin-top: 1em">--rewrite-rules <br>
use rewrite rules module [*]</p>

<p style="margin-top: 1em">--rr-one-inst-per-round <br>
add one instance of rewrite rule per round [*]</p>

<p style="margin-top: 1em">--quant-ind <br>
use all available techniques for inductive reasoning [*]</p>

<p style="margin-top: 1em">--dt-stc-ind <br>
apply strengthening for existential quantification over
datatypes based on structural induction [*]</p>

<p style="margin-top: 1em">--int-wf-ind <br>
apply strengthening for integers based on well-founded
induction [*]</p>

<p style="margin-top: 1em">--conjecture-gen <br>
generate candidate conjectures for inductive proofs [*]</p>

<p style="margin-top: 1em">--conjecture-gen-per-round=N
<br>
number of conjectures to generate per instantiation
round</p>

<p style="margin-top: 1em">--conjecture-no-filter <br>
do not filter conjectures [*]</p>


<p style="margin-top: 1em">--conjecture-filter-active-terms
<br>
filter based on active terms [*]</p>

<p style="margin-top: 1em">--conjecture-filter-canonical
<br>
filter based on canonicity [*]</p>

<p style="margin-top: 1em">--conjecture-filter-model <br>
filter based on model [*]</p>

<p style="margin-top: 1em">--conjecture-gen-gt-enum=N <br>
number of ground terms to generate for model filtering</p>

<p style="margin-top: 1em">--conjecture-gen-uee-intro <br>
more aggressive merging for universal equality engine,
introduces terms [*]</p>

<p style="margin-top: 1em">--conjecture-gen-max-depth=N
<br>
maximum depth of terms to consider for conjectures</p>

<p style="margin-top: 1em">--cegqi <br>
counterexample-guided quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cegqi-fair=MODE <br>
if and how to apply fairness for cegqi</p>

<p style="margin-top: 1em">--cegqi-si=MODE <br>
mode for processing single invocation synthesis
conjectures</p>

<p style="margin-top: 1em">--cegqi-si-partial <br>
combined techniques for synthesis conjectures that are
partially single invocation [*]</p>

<p style="margin-top: 1em">--cegqi-si-reconstruct <br>
reconstruct solutions for single invocation conjectures in
original grammar [*]</p>

<p style="margin-top: 1em">--cegqi-si-sol-min-core <br>
minimize solutions for single invocation conjectures based
on unsat core [*]</p>

<p style="margin-top: 1em">--cegqi-si-sol-min-inst <br>
minimize individual instantiations for single invocation
conjectures based on unsat core [*]</p>

<p style="margin-top: 1em">--cegqi-si-reconstruct-const
<br>
include constants when reconstruct solutions for single
invocation conjectures in original grammar [*]</p>

<p style="margin-top: 1em">--cegqi-si-abort <br>
abort if synthesis conjecture is not single invocation
[*]</p>

<p style="margin-top: 1em">--sygus-nf <br>
only search for sygus builtin terms that are in normal form
[*]</p>

<p style="margin-top: 1em">--sygus-nf-arg <br>
account for relationship between arguments of operations in
sygus normal form [*]</p>

<p style="margin-top: 1em">--sygus-nf-sym <br>
narrow sygus search space based on global state of current
candidate program [*]</p>

<p style="margin-top: 1em">--sygus-nf-sym-gen <br>
generalize lemmas for global search space narrowing [*]</p>

<p style="margin-top: 1em">--sygus-nf-sym-arg <br>
generalize based on arguments in global search space
narrowing [*]</p>

<p style="margin-top: 1em">--sygus-nf-sym-content <br>
generalize based on content in global search space narrowing
[*]</p>

<p style="margin-top: 1em">--sygus-inv-templ=MODE <br>
template mode for sygus invariant synthesis</p>

<p style="margin-top: 1em">--sygus-unif-csol <br>
enable approach which unifies conditional solutions [*]</p>

<p style="margin-top: 1em">--sygus-direct-eval <br>
direct unfolding of evaluation functions [*]</p>

<p style="margin-top: 1em">--sygus-cref-eval <br>
direct evaluation of refinement lemmas for conflict analysis
[*]</p>

<p style="margin-top: 1em">--cbqi turns on
counterexample-based quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-recurse <br>
turns on recursive counterexample-based quantifier
instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-sat <br>
answer sat when quantifiers are asserted with
counterexample-based quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-model <br>
guide instantiations by model values for
counterexample-based quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-all <br>
apply counterexample-based instantiation to all quantified
formulas [*]</p>

<p style="margin-top: 1em">--cbqi-use-inf-int <br>
use integer infinity for vts in counterexample-based
quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-use-inf-real <br>
use real infinity for vts in counterexample-based quantifier
instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-prereg-inst <br>
preregister ground instantiations in counterexample-based
quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-min-bounds <br>
use minimally constrained lower/upper bound for
counterexample-based quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-round-up-lia <br>
round up integer lower bounds in substitutions for
counterexample-based quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-midpoint <br>
choose substitutions based on midpoints of lower and upper
bounds for counterexample-based quantifier instantiation
[*]</p>

<p style="margin-top: 1em">--cbqi-nopt <br>
non-optimal bounds for counterexample-based quantifier
instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-lit-dep <br>
dependency lemmas for quantifier alternation in
counterexample-based quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-innermost <br>
only process innermost quantified formulas in
counterexample-based quantifier instantiation [*]</p>

<p style="margin-top: 1em">--cbqi-nested-qe <br>
process nested quantified formulas with quantifier
elimination in counterexample-based quantifier instantiation
[*]</p>

<p style="margin-top: 1em">--quant-epr <br>
infer whether in effectively propositional fragment, use for
cbqi [*]</p>

<p style="margin-top: 1em">--quant-epr-match <br>
use matching heuristics for EPR instantiation [*]</p>

<p style="margin-top: 1em">--local-t-ext <br>
do instantiation based on local theory extensions [*]</p>

<p style="margin-top: 1em">--lte-partial-inst <br>
partially instantiate local theory quantifiers [*]</p>

<p style="margin-top: 1em">--lte-restrict-inst-closure <br>
treat arguments of inst closure as restricted terms for
instantiation [*]</p>

<p style="margin-top: 1em">--quant-alpha-equiv <br>
infer alpha equivalence between quantified formulas [*]</p>

<p style="margin-top: 1em">--macros-quant <br>
perform quantifiers macro expansion [*]</p>

<p style="margin-top: 1em">--macros-quant-mode=MODE <br>
mode for quantifiers macro expansion</p>

<p style="margin-top: 1em">--quant-dsplit-mode=MODE <br>
mode for dynamic quantifiers splitting</p>

<p style="margin-top: 1em">--quant-anti-skolem <br>
perform anti-skolemization for quantified formulas [*]</p>

<p style="margin-top: 1em">--quant-ee <br>
maintain congrunce closure over universal equalities [*]</p>

<p style="margin-top: 1em">--track-inst-lemmas <br>
track instantiation lemmas (for proofs, unsat cores, qe and
synthesis minimization) [*]</p>

<p style="margin-top: 1em">SEP OPTIONS <br>
--sep-check-neg <br>
check negated spatial assertions [*]</p>

<p style="margin-top: 1em">--sep-exp <br>
experimental flag for sep [*]</p>

<p style="margin-top: 1em">--sep-min-refine <br>
only add refinement lemmas for minimal (innermost)
assertions [*]</p>

<p style="margin-top: 1em">--sep-deq-c <br>
assume cardinality elements are distinct [*]</p>

<p style="margin-top: 1em">--sep-pre-skolem-emp <br>
eliminate emp constraint at preprocess time [*]</p>

<p style="margin-top: 1em">--sep-child-refine <br>
child-specific refinements of negated star, positive wand
[*]</p>

<p style="margin-top: 1em">SETS OPTIONS <br>
--sets-proxy-lemmas <br>
introduce proxy variables eagerly to shorten lemmas [*]</p>

<p style="margin-top: 1em">--sets-infer-as-lemmas <br>
send inferences as lemmas [*]</p>

<p style="margin-top: 1em">--sets-rel-eager <br>
standard effort checks for relations [*]</p>

<p style="margin-top: 1em">--sets-ext <br>
enable extended symbols such as complement and universe in
theory of sets [*]</p>

<p style="margin-top: 1em">SMT LAYER OPTIONS <br>
--force-logic=LOGIC <br>
set the logic, and override all further user attempts to
change it (EXPERTS only)</p>

<p style="margin-top: 1em">--simplification=MODE <br>
choose simplification mode, see --simplification=help</p>

<p style="margin-top: 1em">--no-simplification <br>
turn off all simplification (same as
--simplification=none)</p>

<p style="margin-top: 1em">--static-learning <br>
use static learning (on by default) [*]</p>

<p style="margin-top: 1em">--check-models <br>
after SAT/INVALID/UNKNOWN, check that the generated model
satisfies user assertions [*]</p>

<p style="margin-top: 1em">--dump-models <br>
output models after every SAT/INVALID/UNKNOWN response
[*]</p>

<p style="margin-top: 1em">--omit-dont-cares <br>
When producing a model, omit variables whose value does not
matter [*]</p>

<p style="margin-top: 1em">--proof <br>
turn on proof generation [*]</p>

<p style="margin-top: 1em">--check-proofs <br>
after UNSAT/VALID, machine-check the generated proof [*]</p>

<p style="margin-top: 1em">--dump-proofs <br>
output proofs after every UNSAT/VALID response [*]</p>

<p style="margin-top: 1em">--dump-instantiations <br>
output instantiations of quantified formulas after every
UNSAT/VALID response [*]</p>

<p style="margin-top: 1em">--dump-synth <br>
output solution for synthesis conjectures after every
UNSAT/VALID response [*]</p>

<p style="margin-top: 1em">--produce-unsat-cores <br>
turn on unsat core generation [*]</p>

<p style="margin-top: 1em">--check-unsat-cores <br>
after UNSAT/VALID, produce and check an unsat core
(expensive) [*]</p>

<p style="margin-top: 1em">--dump-unsat-cores <br>
output unsat cores after every UNSAT/VALID response [*]</p>

<p style="margin-top: 1em">--dump-unsat-cores-full <br>
dump the full unsat core, including unlabeled assertions
[*]</p>

<p style="margin-top: 1em">--produce-assignments <br>
support the get-assignment command [*]</p>

<p style="margin-top: 1em">--ite-simp <br>
turn on ite simplification (Kim (and Somenzi) et al., SAT
2009) [*]</p>

<p style="margin-top: 1em">--on-repeat-ite-simp <br>
do the ite simplification pass again if repeating
simplification [*]</p>

<p style="margin-top: 1em">--simp-with-care <br>
enables simplifyWithCare in ite simplificiation [*]</p>

<p style="margin-top: 1em">--simp-ite-compress <br>
enables compressing ites after ite simplification [*]</p>

<p style="margin-top: 1em">--unconstrained-simp <br>
turn on unconstrained simplification (see
Bruttomesso/Brummayer PhD thesis) [*]</p>

<p style="margin-top: 1em">--repeat-simp <br>
make multiple passes with nonclausal simplifier [*]</p>

<p style="margin-top: 1em">--simp-ite-hunt-zombies <br>
post ite compression enables zombie removal while the number
of nodes is above this threshold</p>

<p style="margin-top: 1em">--sort-inference <br>
calculate sort inference of input problem, convert the input
based on monotonic sorts [*]</p>

<p style="margin-top: 1em">--abstract-values <br>
in models, output arrays (and in future, maybe others) using
abstract values, as required by the SMT-LIB standard [*]</p>

<p style="margin-top: 1em">--model-u-dt-enum <br>
in models, output uninterpreted sorts as datatype
enumerations [*]</p>

<p style="margin-top: 1em">--rewrite-step <br>
amount of resources spent for each rewrite step (EXPERTS
only)</p>

<p style="margin-top: 1em">--theory-check-step <br>
amount of resources spent for each theory check call
(EXPERTS only)</p>

<p style="margin-top: 1em">--decision-step <br>
amount of getNext decision calls in the decision engine
(EXPERTS only)</p>

<p style="margin-top: 1em">--bitblast-step <br>
amount of resources spent for each bitblast step (EXPERTS
only)</p>

<p style="margin-top: 1em">--parse-step <br>
amount of resources spent for each command/expression
parsing (EXPERTS only)</p>

<p style="margin-top: 1em">--lemma-step <br>
amount of resources spent when adding lemmas (EXPERTS
only)</p>

<p style="margin-top: 1em">--restart-step <br>
amount of resources spent for each theory restart (EXPERTS
only)</p>

<p style="margin-top: 1em">--cnf-step <br>
amount of resources spent for each call to cnf conversion
(EXPERTS only)</p>

<p style="margin-top: 1em">--preprocess-step <br>
amount of resources spent for each preprocessing step in
SmtEngine (EXPERTS only)</p>

<p style="margin-top: 1em">--quantifier-step <br>
amount of resources spent for quantifier instantiations
(EXPERTS only)</p>

<p style="margin-top: 1em">--sat-conflict-step <br>
amount of resources spent for each sat conflict (main sat
solver) (EXPERTS only)</p>

<p style="margin-top: 1em">--bv-sat-conflict-step <br>
amount of resources spent for each sat conflict (bitvectors)
(EXPERTS only)</p>

<p style="margin-top: 1em">--rewrite-apply-to-const <br>
eliminate function applications, rewriting e.g. f(5) to a
new symbol f_5 (EXPERTS only) [*]</p>

<p style="margin-top: 1em">--force-no-limit-cpu-while-dump
<br>
Force no CPU limit when dumping models and proofs [*]</p>

<p style="margin-top: 1em">STRINGS THEORY OPTIONS <br>
--strings-exp <br>
experimental features in the theory of strings [*]</p>

<p style="margin-top: 1em">--strings-lb=N <br>
the strategy of LB rule application: 0-lazy, 1-eager,
2-no</p>

<p style="margin-top: 1em">--strings-std-ascii <br>
the alphabet contains only characters from the standard
ASCII or the extended one [*]</p>

<p style="margin-top: 1em">--strings-fmf <br>
the finite model finding used by the theory of strings
[*]</p>

<p style="margin-top: 1em">--strings-eager <br>
strings eager check [*]</p>

<p style="margin-top: 1em">--strings-eit <br>
the eager intersection used by the theory of strings [*]</p>

<p style="margin-top: 1em">--strings-opt1 <br>
internal option1 for strings: normal form [*]</p>

<p style="margin-top: 1em">--strings-opt2 <br>
internal option2 for strings: constant regexp splitting
[*]</p>

<p style="margin-top: 1em">--strings-inm <br>
internal for strings: ignore negative membership constraints
(fragment checking is needed, left to users for now) [*]</p>

<p style="margin-top: 1em">--strings-lazy-pp <br>
perform string preprocessing lazily [*]</p>

<p style="margin-top: 1em">--strings-len-geqz <br>
strings length greater than zero lemmas [*]</p>

<p style="margin-top: 1em">--strings-len-norm <br>
strings length normalization lemma [*]</p>

<p style="margin-top: 1em">--strings-sp-emp <br>
strings split on empty string [*]</p>

<p style="margin-top: 1em">--strings-infer-sym <br>
strings split on empty string [*]</p>

<p style="margin-top: 1em">--strings-eager-len <br>
strings eager length lemmas [*]</p>

<p style="margin-top: 1em">--strings-check-entail-len <br>
check entailment between length terms to reduce splitting
[*]</p>

<p style="margin-top: 1em">--strings-process-loop <br>
reduce looping word equations to regular expressions [*]</p>

<p style="margin-top: 1em">--strings-abort-loop <br>
abort when a looping word equation is encountered [*]</p>

<p style="margin-top: 1em">--strings-infer-as-lemmas <br>
always send lemmas out instead of making internal inferences
[*]</p>

<p style="margin-top: 1em">--strings-rexplain-lemmas <br>
regression explanations for string lemmas [*]</p>

<p style="margin-top: 1em">--strings-min-prefix-explain
<br>
minimize explanations for prefix of normal forms in strings
[*]</p>

<p style="margin-top: 1em">--strings-guess-model <br>
use model guessing to avoid string extended function
reductions [*]</p>

<p style="margin-top: 1em">--strings-uf-reduct <br>
use uninterpreted functions when applying extended function
reductions [*]</p>

<p style="margin-top: 1em">--strings-binary-csp <br>
use binary search when splitting strings [*]</p>

<p style="margin-top: 1em">--strings-lprop-csp <br>
do length propagation based on constant splits [*]</p>

<p style="margin-top: 1em">THEORY LAYER OPTIONS <br>
--theoryof-mode=MODE <br>
mode for Theory::theoryof() (EXPERTS only)</p>

<p style="margin-top: 1em">--use-theory=NAME <br>
use alternate theory implementation NAME (--use-theory=help
for a list). This option may be repeated or a comma
separated list.</p>

<p style="margin-top: 1em">UNINTERPRETED FUNCTIONS THEORY
OPTIONS <br>
--symmetry-breaker <br>
use UF symmetry breaker (Deharbe et al., CADE 2011) [*]</p>

<p style="margin-top: 1em">--condense-function-values <br>
condense models for functions rather than explicitly
representing them [*]</p>

<p style="margin-top: 1em">--uf-ss-regions <br>
disable region-based method for discovering cliques and
splits in uf strong solver [*]</p>

<p style="margin-top: 1em">--uf-ss-eager-split <br>
add splits eagerly for uf strong solver [*]</p>

<p style="margin-top: 1em">--uf-ss-totality <br>
always use totality axioms for enforcing cardinality
constraints [*]</p>

<p style="margin-top: 1em">--uf-ss-totality-limited=N <br>
apply totality axioms, but only up to cardinality N (-1 ==
do not apply totality axioms, default)</p>

<p style="margin-top: 1em">--uf-ss-totality-sym-break <br>
apply symmetry breaking for totality axioms [*]</p>

<p style="margin-top: 1em">--uf-ss-abort-card=N <br>
tells the uf strong solver a cardinality to abort at (-1 ==
no limit, default)</p>

<p style="margin-top: 1em">--uf-ss-explained-cliques <br>
use explained clique lemmas for uf strong solver [*]</p>

<p style="margin-top: 1em">--uf-ss-simple-cliques <br>
always use simple clique lemmas for uf strong solver [*]</p>

<p style="margin-top: 1em">--uf-ss-deq-prop <br>
eagerly propagate disequalities for uf strong solver [*]</p>

<p style="margin-top: 1em">--uf-ss=MODE <br>
mode of operation for uf strong solver.</p>

<p style="margin-top: 1em">--uf-ss-clique-splits <br>
use cliques instead of splitting on demand to shrink model
[*]</p>

<p style="margin-top: 1em">--uf-ss-sym-break <br>
finite model finding symmetry breaking techniques [*]</p>

<p style="margin-top: 1em">--uf-ss-fair <br>
use fair strategy for finite model finding multiple sorts
[*]</p>

<p style="margin-top: 1em">--uf-ss-fair-monotone <br>
group monotone sorts when enforcing fairness for finite
model finding [*]</p>

<p style="margin-top: 1em">Each option marked with [*] has
a --no-OPTIONNAME variant, which reverses the sense of the
option.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
CVC4 reports all syntactic and semantic errors on standard
error.</p>

<p style="margin-top: 1em">HISTORY <br>
The CVC4 effort is the culmination of fifteen years of
theorem proving research, starting with the Stanford
Validity Checker (SVC) in 1996.</p>

<p style="margin-top: 1em">SVC&rsquo;s successor, the
Cooperating Validity Checker (CVC), had a more optimized
internal design, produced proofs, used the Chaff SAT solver,
and featured a number of usability <br>
enhancements. Its name comes from the cooperative nature of
decision procedures in Nelson-Oppen theory combination,
which share amongst each other equalities between shared
<br>
terms.</p>

<p style="margin-top: 1em">CVC Lite, first made available
in 2003, was a rewrite of CVC that attempted to make CVC
more flexible (hence the &acirc;lite&acirc;) while extending
the feature set: CVCLite supported quan&acirc; <br>
tifiers where its predecessors did not. CVC3 was a major
overhaul of portions of CVC Lite: it added better decision
procedure implementations, added support for using MiniSat
in <br>
the core, and had generally better performance.</p>

<p style="margin-top: 1em">CVC4 is the new version, the
fifth generation of this validity checker line that is now
celebrating fifteen years of heritage. It represents a
complete re-evaluation of the core <br>
architecture to be both performant and to serve as a
cutting-edge research vehicle for the next several years.
Rather than taking CVC3 and redesigning problem parts,
we&rsquo;ve taken <br>
a clean-room approach, starting from scratch. Before using
any designs from CVC3, we have thoroughly scrutinized,
vetted, and updated them. Many parts of CVC4 bear only a
<br>
superficial resemblance, if any, to their correspondent in
CVC3.</p>

<p style="margin-top: 1em">However, CVC4 is fundamentally
similar to CVC3 and many other modern SMT solvers: it is a
DPLL( T ) solver, with a SAT solver at its core and a
delegation path to different deci&acirc; <br>
sion procedure implementations, each in charge of solving
formulas in some background theory.</p>

<p style="margin-top: 1em">The re-evaluation and ground-up
rewrite was necessitated, we felt, by the performance
characteristics of CVC3. CVC3 has many useful features, but
some core aspects of the design <br>
led to high memory use, and the use of heavyweight
computation (where more nimble engineering approaches could
suffice) makes CVC3 a much slower prover than other tools.
As <br>
these designs are central to CVC3, a new version was
preferable to a selective re-engineering, which would have
ballooned in short order.</p>

<p style="margin-top: 1em">VERSION <br>
This manual page refers to CVC4 version 1.5.</p>

<p style="margin-top: 1em">BUGS <br>
A Bugzilla for the CVC4 project is maintained at
http://cvc4.cs.nyu.edu/bugzilla3/.</p>

<p style="margin-top: 1em">AUTHORS <br>
CVC4 is developed by a team of researchers at New York
University and the University of Iowa. See the AUTHORS file
in the distribution for a full list of contributors.</p>

<p style="margin-top: 1em">SEE ALSO <br>
libcvc4(3), libcvc4parser(3), libcvc4compat(3)</p>

<p style="margin-top: 1em">Additionally, the CVC4 wiki
contains useful information about the design and internals
of CVC4. It is maintained at
http://cvc4.cs.nyu.edu/wiki/.</p>

<p style="margin-top: 1em">CVC4 release 1.5 July 2017
CVC4(1)</p>
<hr>
</body>
</html>
