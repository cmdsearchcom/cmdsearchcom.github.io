<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:20:54 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>KSH(1) General Commands Manual KSH(1)</p>

<p style="margin-top: 1em">NAME <br>
ksh, rksh, pfksh - KornShell, a standard/restricted command
and programming language</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ksh [ &Acirc;&plusmn;abcefhiknoprstuvxBCDP ] [ -R file ] [
&Acirc;&plusmn;o option ] ... [ - ] [ arg ... ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Ksh is a command and programming language that executes
commands read from a terminal or a file. Rksh is a
restricted version of the command interpreter ksh; it is
used to set <br>
up login names and execution environments whose capabilities
are more controlled than those of the standard shell. Rpfksh
is a profile shell version of the command interpreter <br>
ksh; it is used to to execute commands with the attributes
specified by the user&rsquo;s profiles (see pfexec(1)). See
Invocation below for the meaning of arguments to the
shell.</p>

<p style="margin-top: 1em">Definitions. <br>
A metacharacter is one of the following characters:</p>

<p style="margin-top: 1em">; &amp; ( ) &acirc;&ordf; &lt;
&gt; new-line space tab</p>

<p style="margin-top: 1em">A blank is a tab or a space. An
identifier is a sequence of letters, digits, or underscores
starting with a letter or underscore. Identifiers are used
as components of variable <br>
names. A vname is a sequence of one or more identifiers
separated by a . and optionally preceded by a .. Vnames are
used as function and variable names. A word is a sequence
<br>
of characters from the character set defined by the current
locale, excluding non-quoted metacharacters.</p>

<p style="margin-top: 1em">A command is a sequence of
characters in the syntax of the shell language. The shell
reads each command and carries out the desired action either
directly or by invoking sepa&acirc; <br>
rate utilities. A built-in command is a command that is
carried out by the shell itself without creating a separate
process. Some commands are built-in purely for convenience
<br>
and are not documented here. Built-ins that cause side
effects in the shell environment and built-ins that are
found before performing a path search (see Execution below)
are <br>
documented here. For historical reasons, some of these
built-ins behave differently than other built-ins and are
called special built-ins.</p>

<p style="margin-top: 1em">Commands. <br>
A simple-command is a list of variable assignments (see
Variable Assignments below) or a sequence of blank separated
words which may be preceded by a list of variable
assignments <br>
(see Environment below). The first word specifies the name
of the command to be executed. Except as specified below,
the remaining words are passed as arguments to the invoked
<br>
command. The command name is passed as argument 0 (see
exec(2)). The value of a simple-command is its exit status;
0-255 if it terminates normally; 256+signum if it terminates
<br>
abnormally (the name of the signal corresponding to the exit
status can be obtained via the -l option of the kill
built-in utility).</p>

<p style="margin-top: 1em">A pipeline is a sequence of one
or more commands separated by &acirc;&ordf;. The standard
output of each command but the last is connected by a
pipe(2) to the standard input of the next <br>
command. Each command, except possibly the last, is run as a
separate process; the shell waits for the last command to
terminate. The exit status of a pipeline is the exit
sta&acirc; <br>
tus of the last command unless the pipefail option is
enabled. Each pipeline can be preceded by the reserved word
! which causes the exit status of the pipeline to become 0
if <br>
the exit status of the last command is non-zero, and 1 if
the exit status of the last command is 0.</p>

<p style="margin-top: 1em">A list is a sequence of one or
more pipelines separated by ;, &amp;, &acirc;&ordf;&amp;,
&amp;&amp;, or &acirc;&ordf;&acirc;&ordf;, and optionally
terminated by ;, &amp;, or &acirc;&ordf;&amp;. Of these five
symbols, ;, &amp;, and &acirc;&ordf;&amp; have equal
prece&acirc; <br>
dence, which is lower than that of &amp;&amp; and
&acirc;&ordf;&acirc;&ordf;. The symbols &amp;&amp; and
&acirc;&ordf;&acirc;&ordf; also have equal precedence. A
semicolon (;) causes sequential execution of the preceding
pipeline; an amper&acirc; <br>
sand (&amp;) causes asynchronous execution of the preceding
pipeline (i.e., the shell does not wait for that pipeline to
finish). The symbol &acirc;&ordf;&amp; causes asynchronous
execution of the <br>
preceding pipeline with a two-way pipe established to the
parent shell; the standard input and output of the spawned
pipeline can be written to and read from by the parent shell
<br>
by applying the redirection operators &lt;&amp; and
&gt;&amp; with arg p to commands and by using -p option of
the built-in commands read and print described later. The
symbol &amp;&amp; (&acirc;&ordf;&acirc;&ordf;) causes <br>
the list following it to be executed only if the preceding
pipeline returns a zero (non-zero) value. One or more
new-lines may appear in a list instead of a semicolon, to
<br>
delimit a command. The first item of the first pipeline of a
list that is a simple command not beginning with a
redirection, and not occurring within a while, until, or if
<br>
list, can be preceded by a semicolon. This semicolon is
ignored unless the showme option is enabled as described
with the set built-in below.</p>

<p style="margin-top: 1em">A command is either a
simple-command or one of the following. Unless otherwise
stated, the value returned by a command is that of the last
simple-command executed in the com&acirc; <br>
mand.</p>

<p style="margin-top: 1em">for vname [ in word ... ] ;do
list ;done <br>
Each time a for command is executed, vname is set to the
next word taken from the in word list. If in word ... is
omitted, then the for command executes the do list once <br>
for each positional parameter that is set starting from 1
(see Parameter Expansion below). Execution ends when there
are no more words in the list.</p>

<p style="margin-top: 1em">for (( [expr1] ; [expr2] ;
[expr3] )) ;do list ;done <br>
The arithmetic expression expr1 is evaluated first (see
Arithmetic evaluation below). The arithmetic expression
expr2 is repeatedly evaluated until it evaluates to zero
<br>
and when non-zero, list is executed and the arithmetic
expression expr3 evaluated. If any expression is omitted,
then it behaves as if it evaluated to 1.</p>

<p style="margin-top: 1em">select vname [ in word ... ] ;do
list ;done <br>
A select command prints on standard error (file descriptor
2) the set of words, each preceded by a number. If in word
... is omitted, then the positional parameters <br>
starting from 1 are used instead (see Parameter Expansion
below). The PS3 prompt is printed and a line is read from
the standard input. If this line consists of the num&acirc;
<br>
ber of one of the listed words, then the value of the
variable vname is set to the word corresponding to this
number. If this line is empty, the selection list is printed
<br>
again. Otherwise the value of the variable vname is set to
null. The contents of the line read from standard input is
saved in the variable REPLY. The list is executed <br>
for each selection until a break or end-of-file is
encountered. If the REPLY variable is set to null by the
execution of list, then the selection list is printed before
<br>
displaying the PS3 prompt for the next selection.</p>

<p style="margin-top: 1em">case word in [ [(]pattern [
&acirc;&ordf; pattern ] ... ) list ;; ] ... esac <br>
A case command executes the list associated with the first
pattern that matches word. The form of the patterns is the
same as that used for file-name generation (see File <br>
Name Generation below). The ;; operator causes execution of
case to terminate. If ;&amp; is used in place of ;; the next
subsequent list, if any, is executed.</p>

<p style="margin-top: 1em">if list ;then list [ ;elif list
;then list ] ... [ ;else list ] ;fi <br>
The list following if is executed and, if it returns a zero
exit status, the list following the first then is executed.
Otherwise, the list following elif is executed <br>
and, if its value is zero, the list following the next then
is executed. Failing each successive elif list, the else
list is executed. If the if list has non-zero exit <br>
status and there is no else list, then the if command
returns a zero exit status.</p>

<p style="margin-top: 1em">while list ;do list ;done <br>
until list ;do list ;done <br>
A while command repeatedly executes the while list and, if
the exit status of the last command in the list is zero,
executes the do list; otherwise the loop terminates. <br>
If no commands in the do list are executed, then the while
command returns a zero exit status; until may be used in
place of while to negate the loop termination test.</p>

<p style="margin-top: 1em">((expression)) <br>
The expression is evaluated using the rules for arithmetic
evaluation described below. If the value of the arithmetic
expression is non-zero, the exit status is 0, other&acirc;
<br>
wise the exit status is 1.</p>

<p style="margin-top: 1em">(list) <br>
Execute list in a separate environment. Note, that if two
adjacent open parentheses are needed for nesting, a space
must be inserted to avoid evaluation as an arithmetic <br>
command as described above.</p>

<p style="margin-top: 1em">{ list;} <br>
list is simply executed. Note that unlike the metacharacters
( and ), { and } are reserved words and must occur at the
beginning of a line or after a ; in order to be <br>
recognized.</p>

<p style="margin-top: 1em">[[ expression ]] <br>
Evaluates expression and returns a zero exit status when
expression is true. See Conditional Expressions below, for a
description of expression.</p>

<p style="margin-top: 1em">function varname { list ;} <br>
varname () { list ;} <br>
Define a function which is referenced by varname. A function
whose varname contains a . is called a discipline function
and the portion of the varname preceding the last <br>
. must refer to an existing variable. The body of the
function is the list of commands between { and }. A function
defined with the function varname syntax can also be <br>
used as an argument to the . special built-in command to get
the equivalent behavior as if the varname() syntax were used
to define it. (See Functions below.)</p>

<p style="margin-top: 1em">namespace identifier { list ;}
<br>
Defines or uses the name space identifier and runs the
commands in list in this name space. (See Name Spaces
below.)</p>

<p style="margin-top: 1em">&amp; [ name [ arg... ] ] <br>
Causes subsequent list commands terminated by &amp; to be
placed in the background job pool name. If name is omitted a
default unnamed pool is used. Commands in a named <br>
background pool may be executed remotely.</p>

<p style="margin-top: 1em">time [ pipeline ] <br>
If pipeline is omitted the user and system time for the
current shell and completed child processes is printed on
standard error. Otherwise, pipeline is executed and the <br>
elapsed time as well as the user and system time are printed
on standard error. The TIMEFORMAT variable may be set to a
format string that specifies how the timing infor&acirc;
<br>
mation should be displayed. See Shell Variables below for a
description of the TIMEFORMAT variable.</p>

<p style="margin-top: 1em">The following reserved words are
recognized as reserved only when they are the first word of
a command and are not quoted:</p>

<p style="margin-top: 1em">if then else elif fi case esac
for while until do done { } function select time [[ ]] !</p>

<p style="margin-top: 1em">Variable Assignments. <br>
One or more variable assignments can start a simple command
or can be arguments to the typeset, enum, export, or
readonly special built-in commands as well as to other
declara&acirc; <br>
tion commands created as types. The syntax for an assignment
is of the form:</p>

<p style="margin-top: 1em">varname=word <br>
varname[word]=word <br>
No space is permitted between varname and the = or between =
and word.</p>

<p style="margin-top: 1em">varname=(assign_list) <br>
No space is permitted between varname and the =. The
variable varname is unset before the assignment. An
assign_list can be one of the following: <br>
word ... <br>
Indexed array assignment. <br>
[word]=word ... <br>
Associative array assignment. If preceded by typeset -a this
will create an indexed array instead. <br>
assignment ... <br>
Compound variable assignment. This creates a compound
variable varname with sub-variables of the form
varname.name, where name is the name portion of <br>
assignment. The value of varname will contain all the
assignment elements. Additional assignments made to
sub-variables of varname will also be displayed <br>
as part of the value of varname. If no assignments are
specified, varname will be a compound variable allowing
subsequence child elements to be defined. <br>
typeset [options] assignment ... <br>
Nested variable assignment. Multiple assignments can be
specified by separating each of them with a ;. The previous
value is unset before the assignment. <br>
Other declaration commands such as readonly, enum, and other
declaration commands can be used in place of typeset. <br>
. filename <br>
Include the assignment commands contained in filename.</p>

<p style="margin-top: 1em">In addition, a += can be used in
place of the = to signify adding to or appending to the
previous value. When += is applied to an arithmetic type,
word is evaluated as an arith&acirc; <br>
metic expression and added to the current value. When
applied to a string variable, the value defined by word is
appended to the value. For compound assignments, the
previous <br>
value is not unset and the new values are appended to the
current ones provided that the types are compatible.</p>

<p style="margin-top: 1em">The right hand side of a
variable assignment undergoes all the expansion listed below
except word splitting, brace expansion, and file name
generation. When the left hand side <br>
is an assignment is a compound variable and the right hand
is the name of a compound variable, the compound variable on
the right will be copied or appended to the compound
vari&acirc; <br>
able on the left.</p>

<p style="margin-top: 1em">Comments. <br>
A word beginning with # causes that word and all the
following characters up to a new-line to be ignored. <br>
Aliasing. <br>
The first word of each command is replaced by the text of an
alias if an alias for this word has been defined. An alias
name consists of any number of characters excluding <br>
metacharacters, quoting characters, file expansion
characters, parameter expansion and command substitution
characters, the characters / and =. The replacement string
can con&acirc; <br>
tain any valid shell script including the metacharacters
listed above. The first word of each command in the replaced
text, other than any that are in the process of being <br>
replaced, will be tested for aliases. If the last character
of the alias value is a blank then the word following the
alias will also be checked for alias substitution. Aliases
<br>
can be used to redefine built-in commands but cannot be used
to redefine the reserved words listed above. Aliases can be
created and listed with the alias command and can be <br>
removed with the unalias command. <br>
Aliasing is performed when scripts are read, not while they
are executed. Therefore, for an alias to take effect, the
alias definition command has to be executed before the
com&acirc; <br>
mand which references the alias is read. <br>
The following aliases are compiled into the shell but can be
unset or redefined: <br>
autoload=&acirc;&sup2;typeset -fu&acirc;&sup2; <br>
command=&acirc;&sup2;command &acirc;&sup2; <br>
compound=&acirc;&sup2;typeset -C&acirc;&sup2; <br>
fc=hist <br>
float=&acirc;&sup2;typeset -lE&acirc;&sup2; <br>
functions=&acirc;&sup2;typeset -f&acirc;&sup2; <br>
hash=&acirc;&sup2;alias -t --&acirc;&sup2; <br>
history=&acirc;&sup2;hist -l&acirc;&sup2; <br>
integer=&acirc;&sup2;typeset -li&acirc;&sup2; <br>
nameref=&acirc;&sup2;typeset -n&acirc;&sup2; <br>
nohup=&acirc;&sup2;nohup &acirc;&sup2; <br>
r=&acirc;&sup2;hist -s&acirc;&sup2; <br>
redirect=&acirc;&sup2;command exec&acirc;&sup2; <br>
source=&acirc;&sup2;command .&acirc;&sup2; <br>
stop=&acirc;&sup2;kill -s STOP&acirc;&sup2; <br>
suspend=&acirc;&sup2;kill -s STOP $$&acirc;&sup2; <br>
times=&acirc;&sup2;{ { time;} 2&gt;&amp;1;}&acirc;&sup2;
<br>
type=&acirc;&sup2;whence -v&acirc;&sup2;</p>

<p style="margin-top: 1em">Tilde Substitution. <br>
After alias substitution is performed, each word is checked
to see if it begins with an unquoted &acirc;&frac14;. For
tilde substitution, word also refers to the word portion of
parameter <br>
expansion (see Parameter Expansion below). If it does, then
the word up to a / is checked to see if it matches a user
name in the password database (See getpwname(3).) If a <br>
match is found, the &acirc;&frac14; and the matched login
name are replaced by the login directory of the matched
user. If no match is found, the original text is left
unchanged. A &acirc;&frac14; by <br>
itself, or in front of a /, is replaced by $HOME. A
&acirc;&frac14; followed by a + or - is replaced by the
value of $PWD and $OLDPWD respectively.</p>

<p style="margin-top: 1em">In addition, when expanding a
variable assignment, tilde substitution is attempted when
the value of the assignment begins with a &acirc;&frac14;,
and when a &acirc;&frac14; appears after a :. The : also
<br>
terminates a &acirc;&frac14; login name.</p>

<p style="margin-top: 1em">Command Substitution. <br>
The standard output from a command list enclosed in
parentheses preceded by a dollar sign ( $(list) ), or in a
brace group preceded by a dollar sign ( ${ list;} ), or in a
pair <br>
of grave accents (&lsquo;&lsquo;) may be used as part or all
of a word; trailing new-lines are removed. In the second
case, the { and } are treated as a reserved words so that {
must be <br>
followed by a blank and } must appear at the beginning of
the line or follow a ;. In the third (obsolete) form, the
string between the quotes is processed for special quoting
<br>
characters before the command is executed (see Quoting
below). The command substitution $(cat file) can be replaced
by the equivalent but faster $(&lt;file). The command
substitu&acirc; <br>
tion $(n&lt;#) will expand to the current byte offset for
file descriptor n. Except for the second form, the command
list is run in a subshell so that no side effects are
possible. <br>
For the second form, the final } will be recognized as a
reserved word after any token.</p>

<p style="margin-top: 1em">Arithmetic Substitution. <br>
An arithmetic expression enclosed in double parentheses
preceded by a dollar sign ( $(()) ) is replaced by the value
of the arithmetic expression within the double
parentheses.</p>

<p style="margin-top: 1em">Process Substitution. <br>
Each command argument of the form &lt;(list) or &gt;(list)
will run process list asynchronously connected to some file
in /dev/fd if this directory exists, or else a fifo a
temporary <br>
directory. The name of this file will become the argument to
the command. If the form with &gt; is selected then writing
on this file will provide input for list. If &lt; is used,
<br>
then the file passed as an argument will contain the output
of the list process. For example,</p>

<p style="margin-top: 1em">paste &lt;(cut -f1 file1)
&lt;(cut -f3 file2) | tee &gt;(process1) &gt;(process2)</p>

<p style="margin-top: 1em">cuts fields 1 and 3 from the
files file1 and file2 respectively, pastes the results
together, and sends it to the processes process1 and
process2, as well as putting it onto the <br>
standard output. Note that the file, which is passed as an
argument to the command, is a UNIX pipe(2) so programs that
expect to lseek(2) on the file will not work.</p>

<p style="margin-top: 1em">Process substitution of the form
&lt;(list) can also be used with the &lt; redirection
operator which causes the output of list to be standard
input or the input for whatever file <br>
descriptor is specified.</p>

<p style="margin-top: 1em">Parameter Expansion. <br>
A parameter is a variable, one or more digits, or any of the
characters &acirc;, @, #, ?, -, $, and !. A variable is
denoted by a vname. To create a variable whose vname
contains a <br>
., a variable whose vname consists of everything before the
last . must already exist. A variable has a value and zero
or more attributes. Variables can be assigned values and
<br>
attributes by using the typeset special built-in command.
The attributes supported by the shell are described later
with the typeset special built-in command. Exported
vari&acirc; <br>
ables pass values and attributes to the environment.</p>

<p style="margin-top: 1em">The shell supports both indexed
and associative arrays. An element of an array variable is
referenced by a subscript. A subscript for an indexed array
is denoted by an arith&acirc; <br>
metic expression (see Arithmetic evaluation below) between a
[ and a ]. To assign values to an indexed array, use
vname=(value ...) or set -A vname value ... . The value of
<br>
all non-negative subscripts must be in the range of 0
through 4,194,303. A negative subscript is treated as an
offset from the maximum current index +1 so that -1 refers
to the <br>
last element. Indexed arrays can be declared with the -a
option to typeset. Indexed arrays need not be declared. Any
reference to a variable with a valid subscript is legal <br>
and an array will be created if necessary.</p>

<p style="margin-top: 1em">An associative array is created
with the -A option to typeset. A subscript for an
associative array is denoted by a string enclosed between [
and ].</p>

<p style="margin-top: 1em">Referencing any array without a
subscript is equivalent to referencing the array with
subscript 0.</p>

<p style="margin-top: 1em">The value of a variable may be
assigned by writing:</p>

<p style="margin-top: 1em">vname=value [ vname=value ]
...</p>

<p style="margin-top: 1em">or <br>
vname[subscript]=value [ vname[subscript]=value ] ... <br>
Note that no space is allowed before or after the =. <br>
Attributes assigned by the typeset special built-in command
apply to all elements of the array. An array element can be
a simple variable, a compound variable or an array
vari&acirc; <br>
able. An element of an indexed array can be either an
indexed array or an associative array. An element of an
associative array can also be either. To refer to an array
ele&acirc; <br>
ment that is part of an array element, concatenate the
subscript in brackets. For example, to refer to the foobar
element of an associative array that is defined as the third
<br>
element of the indexed array, use ${vname[3][foobar]} <br>
A nameref is a variable that is a reference to another
variable. A nameref is created with the -n attribute of
typeset. The value of the variable at the time of the
typeset <br>
command becomes the variable that will be referenced
whenever the nameref variable is used. The name of a nameref
cannot contain a .. When a variable or function name
contains <br>
a ., and the portion of the name up to the first . matches
the name of a nameref, the variable referred to is obtained
by replacing the nameref portion with the name of the
vari&acirc; <br>
able referenced by the nameref. If a nameref is used as the
index of a for loop, a name reference is established for
each item in the list. A nameref provides a convenient way
<br>
to refer to the variable inside a function whose name is
passed as an argument to a function. For example, if the
name of a variable is passed as the first argument to a
func&acirc; <br>
tion, the command <br>
typeset -n var=$1 <br>
inside the function causes references and assignments to var
to be references and assignments to the variable whose name
has been passed to the function. <br>
If any of the floating point attributes, -E, -F, or -X, or
the integer attribute, -i, is set for vname, then the value
is subject to arithmetic evaluation as described below. <br>
Positional parameters, parameters denoted by a number, may
be assigned values with the set special built-in command.
Parameter $0 is set from argument zero when the shell is
<br>
invoked. <br>
The character $ is used to introduce substitutable
parameters. <br>
${parameter} <br>
The shell reads all the characters from ${ to the matching }
as part of the same word even if it contains braces or
metacharacters. The value, if any, of the parameter is <br>
substituted. The braces are required when parameter is
followed by a letter, digit, or underscore that is not to be
interpreted as part of its name, when the variable <br>
name contains a .. The braces are also required when a
variable is subscripted unless it is part of an Arithmetic
Expression or a Conditional Expression. If parameter is <br>
one or more digits then it is a positional parameter. A
positional parameter of more than one digit must be enclosed
in braces. If parameter is &acirc; or @, then all the <br>
positional parameters, starting with $1, are substituted
(separated by a field separator character). If an array
vname with last subscript &acirc; @, or for index arrays of
the <br>
form sub1 .. sub2. is used, then the value for each of the
elements between sub1 and sub2 inclusive (or all elements
for &acirc; and @) is substituted, separated by the first
<br>
character of the value of IFS. <br>
${#parameter} <br>
If parameter is &acirc; or @, the number of positional
parameters is substituted. Otherwise, the length of the
value of the parameter is substituted. <br>
${#vname[*]} <br>
${#vname[@]} <br>
The number of elements in the array vname is
substituted.</p>

<p style="margin-top: 1em">${@vname} <br>
Expands to the type name (See Type Variables below) or
attributes of the variable referred to by vname. <br>
${!vname} <br>
Expands to the name of the variable referred to by vname.
This will be vname except when vname is a name reference.
<br>
${!vname[subscript]} <br>
Expands to name of the subscript unless subscript is *, @.
or of the form sub1 .. sub2. When subscript is *, the list
of array subscripts for vname is generated. For a <br>
variable that is not an array, the value is 0 if the
variable is set. Otherwise it is null. When subscript is @,
same as above, except that when used in double quotes, <br>
each array subscript yields a separate argument. When
subscript is of the form sub1 .. sub2 it expands to the list
of subscripts between sub1 and sub2 inclusive using <br>
the same quoting rules as @. <br>
${!prefix*} <br>
Expands to the names of the variables whose names begin with
prefix. <br>
${parameter:-word} <br>
If parameter is set and is non-null then substitute its
value; otherwise substitute word. <br>
${parameter:=word} <br>
If parameter is not set or is null then set it to word; the
value of the parameter is then substituted. Positional
parameters may not be assigned to in this way. <br>
${parameter:?word} <br>
If parameter is set and is non-null then substitute its
value; otherwise, print word and exit from the shell (if not
interactive). If word is omitted then a standard mes&acirc;
<br>
sage is printed. <br>
${parameter:+word} <br>
If parameter is set and is non-null then substitute word;
otherwise substitute nothing. <br>
In the above, word is not evaluated unless it is to be used
as the substituted string, so that, in the following
example, pwd is executed only if d is not set or is null:
<br>
print ${d:-$(pwd)} <br>
If the colon ( : ) is omitted from the above expressions,
then the shell only checks whether parameter is set or not.
<br>
${parameter:offset:length} <br>
${parameter:offset} <br>
Expands to the portion of the value of parameter starting at
the character (counting from 0) determined by expanding
offset as an arithmetic expression and consisting of <br>
the number of characters determined by the arithmetic
expression defined by length. In the second form, the
remainder of the value is used. If A negative offset counts
<br>
backwards from the end of parameter. Note that one or more
blanks is required in front of a minus sign to prevent the
shell from interpreting the operator as :-. If <br>
parameter is &acirc; or @, or is an array name indexed by
&acirc; or @, then offset and length refer to the array
index and number of elements respectively. A negative offset
is <br>
taken relative to one greater than the highest subscript for
indexed arrays. The order for associate arrays is
unspecified. <br>
${parameter#pattern} <br>
${parameter##pattern} <br>
If the shell pattern matches the beginning of the value of
parameter, then the value of this expansion is the value of
the parameter with the matched portion deleted; oth&acirc;
<br>
erwise the value of this parameter is substituted. In the
first form the smallest matching pattern is deleted and in
the second form the largest matching pattern is <br>
deleted. When parameter is @, *, or an array variable with
subscript @ or *, the substring operation is applied to each
element in turn.</p>

<p style="margin-top: 1em">${parameter%pattern} <br>
${parameter%%pattern} <br>
If the shell pattern matches the end of the value of
parameter, then the value of this expansion is the value of
the parameter with the matched part deleted; otherwise <br>
substitute the value of parameter. In the first form the
smallest matching pattern is deleted and in the second form
the largest matching pattern is deleted. When param&acirc;
<br>
eter is @, *, or an array variable with subscript @ or *,
the substring operation is applied to each element in
turn.</p>

<p style="margin-top: 1em">${parameter/pattern/string} <br>
${parameter//pattern/string} <br>
${parameter/#pattern/string} <br>
${parameter/%pattern/string} <br>
Expands parameter and replaces the longest match of pattern
with the given string. Each occurrence of in string is
replaced by the portion of parameter that matches <br>
the n-th sub-pattern. In the first form, only the first
occurrence of pattern is replaced. In the second form, each
match for pattern is replaced by the given string. <br>
The third form restricts the pattern match to the beginning
of the string while the fourth form restricts the pattern
match to the end of the string. When string is null, <br>
the pattern will be deleted and the / in front of string may
be omitted. When parameter is @, *, or an array variable
with subscript @ or *, the substitution operation is <br>
applied to each element in turn. In this case, the string
portion of word will be re-evaluated for each element.</p>

<p style="margin-top: 1em">The following parameters are
automatically set by the shell: <br>
# The number of positional parameters in decimal. <br>
- Options supplied to the shell on invocation or by the set
command. <br>
? The decimal value returned by the last executed command.
<br>
$ The process number of this shell. <br>
_ Initially, the value of _ is an absolute pathname of the
shell or script being executed as passed in the environment.
Subsequently it is assigned the last argument <br>
of the previous command. This parameter is not set for
commands which are asynchronous. This parameter is also used
to hold the name of the matching MAIL file <br>
when checking for mail. While defining a compound variable
or a type, _ is initialized as a reference to the compound
variable or type. When a discipline function <br>
is invoked, _ is initialized as a reference to the variable
associated with the call to this function. Finally when _ is
used as the name of the first variable of <br>
a type definition, the new type is derived from the type of
the first variable (See Type Variables below.). <br>
! The process id or the pool name and job number of the last
background command invoked or the most recent job put in the
background with the bg built-in command. <br>
Background jobs started in a named pool will be in the form
pool.number where pool is the pool name and number is the
job number within that pool. <br>
.sh.command <br>
When processing a DEBUG trap, this variable contains the
current command line that is about to run. <br>
.sh.edchar <br>
This variable contains the value of the keyboard character
(or sequence of characters if the first character is an ESC,
ascii 033) that has been entered when pro&acirc; <br>
cessing a KEYBD trap (see Key Bindings below). If the value
is changed as part of the trap action, then the new value
replaces the key (or key sequence) that <br>
caused the trap. <br>
.sh.edcol <br>
The character position of the cursor at the time of the most
recent KEYBD trap. <br>
.sh.edmode <br>
The value is set to ESC when processing a KEYBD trap while
in vi insert mode. (See Vi Editing Mode below.) Otherwise,
.sh.edmode is null when processing a KEYBD <br>
trap. <br>
.sh.edtext <br>
The characters in the input buffer at the time of the most
recent KEYBD trap. The value is null when not processing a
KEYBD trap. <br>
.sh.file <br>
The pathname of the file than contains the current command.
<br>
.sh.fun <br>
The name of the current function that is being executed.
<br>
.sh.level <br>
Set to the current function depth. This can be changed
inside a DEBUG trap and will set the context to the
specified level. <br>
.sh.lineno <br>
Set during a DEBUG trap to the line number for the caller of
each function. <br>
.sh.match <br>
An indexed array which stores the most recent match and
sub-pattern matches after conditional pattern matches that
match and after variables expansions using the <br>
operators #, %, or /. The 0-th element stores the complete
match and the i-th. element stores the i-th submatch. The
.sh.match variable becomes unset when the <br>
variable that has expanded is assigned a new value. <br>
.sh.math <br>
Used for defining arithmetic functions (see Arithmetic
evaluation below). and stores the list of user defined
arithmetic functions. <br>
.sh.name <br>
Set to the name of the variable at the time that a
discipline function is invoked. <br>
.sh.subscript <br>
Set to the name subscript of the variable at the time that a
discipline function is invoked. <br>
.sh.subshell <br>
The current depth for subshells and command substitution.
<br>
.sh.value <br>
Set to the value of the variable at the time that the set or
append discipline function is invoked. When a user defined
arithmetic function is invoked, the value <br>
of .sh.value is saved and .sh.value is set to long double
precision floating point. .sh.value is restored when the
function returns. <br>
.sh.version <br>
Set to a value that identifies the version of this shell.
<br>
KSH_VERSION <br>
A name reference to .sh.version. <br>
LINENO The current line number within the script or function
being executed. <br>
OLDPWD The previous working directory set by the cd command.
<br>
OPTARG The value of the last option argument processed by
the getopts built-in command. <br>
OPTIND The index of the last option argument processed by
the getopts built-in command. <br>
PPID The process number of the parent of the shell. <br>
PWD The present working directory set by the cd command.
<br>
RANDOM Each time this variable is referenced, a random
integer, uniformly distributed between 0 and 32767, is
generated. The sequence of random numbers can be initialized
<br>
by assigning a numeric value to RANDOM. <br>
REPLY This variable is set by the select statement and by
the read built-in command when no arguments are supplied.
<br>
SECONDS <br>
Each time this variable is referenced, the number of seconds
since shell invocation is returned. If this variable is
assigned a value, then the value returned upon <br>
reference will be the value that was assigned plus the
number of seconds since the assignment. <br>
SHLVL An integer variable the is incremented each time the
shell is invoked and is exported. If SHLVL is not in the
environment when the shell is invoked, it is set to <br>
1.</p>

<p style="margin-top: 1em">The following variables are used
by the shell: <br>
CDPATH The search path for the cd command. <br>
COLUMNS <br>
If this variable is set, the value is used to define the
width of the edit window for the shell edit modes and for
printing select lists. <br>
EDITOR If the VISUAL variable is not set, the value of this
variable will be checked for the patterns as described with
VISUAL below and the corresponding editing option <br>
(see Special Command set below) will be turned on. <br>
ENV If this variable is set, then parameter expansion,
command substitution, and arithmetic substitution are
performed on the value to generate the pathname of the <br>
script that will be executed when the shell is invoked
interactively (see Invocation below). This file is typically
used for alias and function definitions. The <br>
default value is $HOME/.kshrc. On systems that support a
system wide /etc/ksh.kshrc initialization file, if the
filename generated by the expansion of ENV begins <br>
with /./ or ././ the system wide initialization file will
not be executed. <br>
FCEDIT Obsolete name for the default editor name for the
hist command. FCEDIT is not used when HISTEDIT is set. <br>
FIGNORE <br>
A pattern that defines the set of filenames that will be
ignored when performing filename matching. <br>
FPATH The search path for function definitions. The
directories in this path are searched for a file with the
same name as the function or command when a function with
<br>
the -u attribute is referenced and when a command is not
found. If an executable file with the name of that command
is found, then it is read and executed in the <br>
current environment. Unlike PATH, the current directory must
be represented explicitly by . rather than by adjacent :
characters or a beginning or ending :. <br>
HISTCMD <br>
Number of the current command in the history file. <br>
HISTEDIT <br>
Name for the default editor name for the hist command. <br>
HISTFILE <br>
If this variable is set when the shell is invoked, then the
value is the pathname of the file that will be used to store
the command history (see Command Re-entry <br>
below). <br>
HISTSIZE <br>
If this variable is set when the shell is invoked, then the
number of previously entered commands that are accessible by
this shell will be greater than or equal to <br>
this number. The default is 512. <br>
HOME The default argument (home directory) for the cd
command. <br>
IFS Internal field separators, normally space, tab, and
new-line that are used to separate the results of command
substitution or parameter expansion and to separate <br>
fields with the built-in command read. The first character
of the IFS variable is used to separate arguments for the
&quot;$&acirc;&quot; substitution (see Quoting below). Each
<br>
single occurrence of an IFS character in the string to be
split, that is not in the isspace character class, and any
adjacent characters in IFS that are in the iss&acirc; <br>
pace character class, delimit a field. One or more
characters in IFS that belong to the isspace character
class, delimit a field. In addition, if the same isspace
<br>
character appears consecutively inside IFS, this character
is treated as if it were not in the isspace class, so that
if IFS consists of two tab characters, then <br>
two adjacent tab characters delimit a null field. <br>
JOBMAX This variable defines the maximum number running
background jobs that can run at a time. When this limit is
reached, the shell will wait for a job to complete <br>
before staring a new job. <br>
LANG This variable determines the locale category for any
category not specifically selected with a variable starting
with LC_ or LANG. <br>
LC_ALL This variable overrides the value of the LANG
variable and any other LC_ variable. <br>
LC_COLLATE <br>
This variable determines the locale category for character
collation information. <br>
LC_CTYPE <br>
This variable determines the locale category for character
handling functions. It determines the character classes for
pattern matching (see File Name Generation <br>
below). <br>
LC_NUMERIC <br>
This variable determines the locale category for the decimal
point character. <br>
LINES If this variable is set, the value is used to
determine the column length for printing select lists.
Select lists will print vertically until about two-thirds of
<br>
LINES lines are filled. <br>
MAIL If this variable is set to the name of a mail file and
the MAILPATH variable is not set, then the shell informs the
user of arrival of mail in the specified file. <br>
MAILCHECK <br>
This variable specifies how often (in seconds) the shell
will check for changes in the modification time of any of
the files specified by the MAILPATH or MAIL vari&acirc; <br>
ables. The default value is 600 seconds. When the time has
elapsed the shell will check before issuing the next prompt.
<br>
MAILPATH <br>
A colon ( : ) separated list of file names. If this variable
is set, then the shell informs the user of any modifications
to the specified files that have occurred <br>
within the last MAILCHECK seconds. Each file name can be
followed by a ? and a message that will be printed. The
message will undergo parameter expansion, com&acirc; <br>
mand substitution, and arithmetic substitution with the
variable $_ defined as the name of the file that has
changed. The default message is you have mail in $_. <br>
PATH The search path for commands (see Execution below). The
user may not change PATH if executing under rksh (except in
.profile). <br>
PS1 The value of this variable is expanded for parameter
expansion, command substitution, and arithmetic substitution
to define the primary prompt string which by <br>
default is &lsquo;&lsquo;$&rsquo;&rsquo;. The character ! in
the primary prompt string is replaced by the command number
(see Command Re-entry below). Two successive occurrences of
! <br>
will produce a single ! when the prompt string is printed.
<br>
PS2 Secondary prompt string, by default &lsquo;&lsquo;&gt;
&rsquo;&rsquo;. <br>
PS3 Selection prompt string used within a select loop, by
default &lsquo;&lsquo;#? &rsquo;&rsquo;. <br>
PS4 The value of this variable is expanded for parameter
evaluation, command substitution, and arithmetic
substitution and precedes each line of an execution trace.
By <br>
default, PS4 is &lsquo;&lsquo;+ &rsquo;&rsquo;. In addition
when PS4 is unset, the execution trace prompt is also
&lsquo;&lsquo;+ &rsquo;&rsquo;. <br>
SHELL The pathname of the shell is kept in the environment.
At invocation, if the basename of this variable is rsh,
rksh, or krsh, then the shell becomes restricted. If <br>
it is pfsh or pfksh, then the shell becomes a profile shell
(see pfexec(1)). <br>
TIMEFORMAT <br>
The value of this parameter is used as a format string
specifying how the timing information for pipelines prefixed
with the time reserved word should be displayed. <br>
The % character introduces a format sequence that is
expanded to a time value or other information. The format
sequences and their meanings are as follows. <br>
%% A literal %. <br>
%[p][l]R The elapsed time in seconds. <br>
%[p][l]U The number of CPU seconds spent in user mode. <br>
%[p][l]S The number of CPU seconds spent in system mode.
<br>
%P The CPU percentage, computed as (U + S) / R.</p>

<p style="margin-top: 1em">The brackets denote optional
portions. The optional p is a digit specifying the
precision, the number of fractional digits after a decimal
point. A value of 0 <br>
causes no decimal point or fraction to be output. At most
three places after the decimal point can be displayed;
values of p greater than 3 are treated as 3. If p <br>
is not specified, the value 3 is used.</p>

<p style="margin-top: 1em">The optional l specifies a
longer format, including hours if greater than zero,
minutes, and seconds of the form HHhMMmSS.FFs. The value of
p determines whether or <br>
not the fraction is included.</p>

<p style="margin-top: 1em">All other characters are output
without change and a trailing newline is added. If unset,
the default value, $&rsquo;0eal%2lR0ser%2lU0ys%2lS&rsquo;,
is used. If the <br>
value is null, no timing information is displayed.</p>

<p style="margin-top: 1em">TMOUT If set to a value greater
than zero, TMOUT will be the default timeout value for the
read built-in command. The select compound command
terminates after TMOUT sec&acirc; <br>
onds when input is from a terminal. Otherwise, the shell
will terminate if a line is not entered within the
prescribed number of seconds while reading from a ter&acirc;
<br>
minal. (Note that the shell can be compiled with a maximum
bound for this value which cannot be exceeded.)</p>

<p style="margin-top: 1em">VISUAL If the value of this
variable matches the pattern *[Vv][Ii]*, then the vi option
(see Special Command set below) is turned on. If the value
matches the pattern <br>
*gmacs* , the gmacs option is turned on. If the value
matches the pattern *macs*, then the emacs option will be
turned on. The value of VISUAL overrides the value <br>
of EDITOR.</p>

<p style="margin-top: 1em">The shell gives default values
to PATH, PS1, PS2, PS3, PS4, MAILCHECK, FCEDIT, TMOUT and
IFS, while HOME, SHELL, ENV, and MAIL are not set at all by
the shell (although HOME is <br>
set by login(1)). On some systems MAIL and SHELL are also
set by login(1).</p>

<p style="margin-top: 1em">Field Splitting. <br>
After parameter expansion and command substitution, the
results of substitutions are scanned for the field separator
characters (those found in IFS) and split into distinct <br>
fields where such characters are found. Explicit null fields
(&quot;&quot; or &acirc;&sup2;&acirc;&sup2;) are retained.
Implicit null fields (those resulting from parameters that
have no values or command sub&acirc; <br>
stitutions with no output) are removed.</p>

<p style="margin-top: 1em">If the braceexpand (-B) option
is set then each of the fields resulting from IFS are
checked to see if they contain one or more of the brace
patterns {*,*}, {l1..l2} , {n1..n2} , <br>
{n1..n2% fmt} , {n1..n2 ..n3} , or {n1..n2 ..n3%fmt} , where
* represents any character, l1,l2 are letters and n1,n2,n3
are signed numbers and fmt is a format specified as used
<br>
by printf. In each case, fields are created by prepending
the characters before the { and appending the characters
after the } to each of the strings generated by the
characters <br>
between the { and }. The resulting fields are checked to see
if they have any brace patterns.</p>

<p style="margin-top: 1em">In the first form, a field is
created for each string between { and ,, between , and ,,
and between , and }. The string represented by * can contain
embedded matching { and } <br>
without quoting. Otherwise, each { and } with * must be
quoted.</p>

<p style="margin-top: 1em">In the seconds form, l1 and l2
must both be either upper case or both be lower case
characters in the C locale. In this case a field is created
for each character from l1 thru <br>
l2.</p>

<p style="margin-top: 1em">In the remaining forms, a field
is created for each number starting at n1 and continuing
until it reaches n2 incrementing n1 by n3. The cases where
n3 is not specified behave as <br>
if n3 where 1 if n1&lt;=n2 and -1 otherwise. If forms which
specify %fmt any format flags, widths and precisions can be
specified and fmt can end in any of the specifiers cdiouxX.
<br>
For example, {a,z}{1..5..3%02d}{b..c}x expands to the 8
fields, a01bx, a01cx, a04bx, a04cx, z01bx, z01cx, z04bx and
z4cx.</p>

<p style="margin-top: 1em">File Name Generation. <br>
Following splitting, each field is scanned for the
characters &acirc;, ?, (, and [ unless the -f option has
been set. If one of these characters appears, then the word
is regarded as <br>
a pattern. Each file name component that contains any
pattern character is replaced with a lexicographically
sorted set of names that matches the pattern from that
directory. <br>
If no file name is found that matches the pattern, then that
component of the filename is left unchanged unless the
pattern is prefixed with &acirc;&frac14;(N) in which case it
is removed as <br>
described below. If FIGNORE is set, then each file name
component that matches the pattern defined by the value of
FIGNORE is ignored when generating the matching filenames.
<br>
The names . and .. are also ignored. If FIGNORE is not set,
the character . at the start of each file name component
will be ignored unless the first character of the pattern
<br>
corresponding to this component is the character . itself.
Note, that for other uses of pattern matching the / and .
are not treated specially.</p>

<p style="margin-top: 1em">&acirc; Matches any string,
including the null string. When used for filename expansion,
if the globstar option is on, two adjacent &acirc;&rsquo;s
by itself will match all files and <br>
zero or more directories and subdirectories. If followed by
a / then only directories and subdirectories will match.
<br>
? Matches any single character. <br>
[...] Matches any one of the enclosed characters. A pair of
characters separated by - matches any character lexically
between the pair, inclusive. If the first charac&acirc; <br>
ter following the opening [ is a ! or ^ then any character
not enclosed is matched. A - can be included in the
character set by putting it as the first or last <br>
character. <br>
Within [ and ], character classes can be specified with the
syntax [:class:] where class is one of the following classes
defined in the ANSI-C standard: (Note that <br>
word is equivalent to alnum plus the character _.) <br>
alnum alpha blank cntrl digit graph lower print punct space
upper word xdigit <br>
Within [ and ], an equivalence class can be specified with
the syntax [=c=] which matches all characters with the same
primary collation weight (as defined by the <br>
current locale) as the character c. Within [ and ],
[.symbol.] matches the collating symbol symbol. <br>
A pattern-list is a list of one or more patterns separated
from each other with a &amp; or &acirc;&ordf;. A &amp;
signifies that all patterns must be matched whereas
&acirc;&ordf; requires that only one pat&acirc; <br>
tern be matched. Composite patterns can be formed with one
or more of the following sub-patterns: <br>
?(pattern-list) <br>
Optionally matches any one of the given patterns. <br>
*(pattern-list) <br>
Matches zero or more occurrences of the given patterns. <br>
+(pattern-list) <br>
Matches one or more occurrences of the given patterns. <br>
{n}(pattern-list) <br>
Matches n occurrences of the given patterns. <br>
{m,n}(pattern-list) <br>
Matches from m to n occurrences of the given patterns. If m
is omitted, 0 will be used. If n is omitted at least m
occurrences will be matched. <br>
@(pattern-list) <br>
Matches exactly one of the given patterns. <br>
!(pattern-list) <br>
Matches anything except one of the given patterns. <br>
By default, each pattern, or sub-pattern will match the
longest string possible consistent with generating the
longest overall match. If more than one match is possible,
the one <br>
starting closest to the beginning of the string will be
chosen. However, for each of the above compound patterns a -
can be inserted in front of the ( to cause the shortest <br>
match to the specified pattern-list to be used.</p>

<p style="margin-top: 1em">When pattern-list is contained
within parentheses, the backslash character &nbsp;is treated
specially even when inside a character class. All ANSI-C
character escapes are recog&acirc; <br>
nized and match the specified character. In addition the
following escape sequences are recognized: <br>
Matches any character in the digit class. <br>
Matches any character not in the digit class. <br>
Matches any character in the space class. <br>
Matches any character not in the space class. <br>
0 Matches any character in the word class. <br>
W Matches any character not in the word class.</p>

<p style="margin-top: 1em">A pattern of the form
%(pattern-pair(s)) is a sub-pattern that can be used to
match nested character expressions. Each pattern-pair is a
two character sequence which cannot con&acirc; <br>
tain &amp; or &acirc;&ordf;. The first pattern-pair
specifies the starting and ending characters for the match.
Each subsequent pattern-pair represents the beginning and
ending characters of a <br>
nested group that will be skipped over when counting
starting and ending character matches. The behavior is
unspecified when the first character of a pattern-pair is
alpha- <br>
numeric except for the following: <br>
D Causes the ending character to terminate the search for
this pattern without finding a match. <br>
E Causes the ending character to be interpreted as an escape
character. <br>
L Causes the ending character to be interpreted as a quote
character causing all characters to be ignored when looking
for a match. <br>
Q Causes the ending character to be interpreted as a quote
character causing all characters other than any escape
character to be ignored when looking for a match. <br>
Thus, %({}Q&quot;E, matches characters starting at { until
the matching } is found not counting any { or } that is
inside a double quoted string or preceded by the escape
character <br>
. Without the {} this pattern matches any C language
string.</p>

<p style="margin-top: 1em">Each sub-pattern in a composite
pattern is numbered, starting at 1, by the location of the (
within the pattern. The sequence 0 where n is a single digit
and comes after <br>
the n-th. sub-pattern, matches the same string as the
sub-pattern itself.</p>

<p style="margin-top: 1em">Finally a pattern can contain
sub-patterns of the form
&acirc;&frac14;(options:pattern-list), where either options
or :pattern-list can be omitted. Unlike the other compound
patterns, these <br>
sub-patterns are not counted in the numbered sub-patterns.
:pattern-list must be omitted for options F, G, N , and V
below. If options is present, it can consist of one or more
<br>
of the following: <br>
+ Enable the following options. This is the default. <br>
- Disable the following options. <br>
E The remainder of the pattern uses extended regular
expression syntax like the egrep(1) command. <br>
F The remainder of the pattern uses fgrep(1) expression
syntax. <br>
G The remainder of the pattern uses basic regular expression
syntax like the grep(1) command. <br>
K The remainder of the pattern uses shell pattern syntax.
This is the default. <br>
N This is ignored. However, when it is the first letter and
is used with file name generation, and no matches occur, the
file pattern expands to the empty string. <br>
X The remainder of the pattern uses augmented regular
expression syntax like the xgrep(1) command. <br>
P The remainder of the pattern uses perl(1) regular
expression syntax. Not all perl regular expression syntax is
currently implemented. <br>
V The remainder of the pattern uses System V regular
expression syntax. <br>
i Treat the match as case insensitive. <br>
g File the longest match (greedy). This is the default. <br>
l Left anchor the pattern. This is the default for K style
patterns. <br>
r Right anchor the pattern. This is the default for K style
patterns. <br>
If both options and :pattern-list are specified, then the
options apply only to pattern-list. Otherwise, these options
remain in effect until they are disabled by a subsequent
<br>
&acirc;&frac14;(...) or at the end of the sub-pattern
containing &acirc;&frac14;(...).</p>

<p style="margin-top: 1em">Quoting. <br>
Each of the metacharacters listed earlier (see Definitions
above) has a special meaning to the shell and causes
termination of a word unless quoted. A character may be
quoted <br>
(i.e., made to stand for itself) by preceding it with a .
The pair 0w-line is removed. All characters enclosed between
a pair of single quote marks (&acirc;&sup2;&acirc;&sup2;)
that is not preceded <br>
by a $ are quoted. A single quote cannot appear within the
single quotes. A single quoted string preceded by an
unquoted $ is processed as an ANSI-C string except for the
fol&acirc; <br>
lowing: <br>
Causes the remainder of the string to be ignored. &nbsp;
<br>
Equivalent to the escape character (ascii 033), <br>
\ Equivalent to the escape character (ascii 033), <br>
Expands to the collating element name.</p>

<p style="margin-top: 1em">Inside double quote marks
(&quot;&quot;), parameter and command substitution occur and
&nbsp;quotes the characters &lsquo;, &quot;, and $. A $ in
front of a double quoted string will be ignored in <br>
the &quot;C&quot; or &quot;POSIX&quot; locale, and may cause
the string to be replaced by a locale specific string
otherwise. The meaning of $&acirc; and $@ is identical when
not quoted or when used as a <br>
variable assignment value or as a file name. However, when
used as a command argument, &quot;$&acirc;&quot; is
equivalent to &quot;$1d$2d...&quot;, where d is the first
character of the IFS variable, <br>
whereas &quot;$@&quot; is equivalent to &quot;$1&quot;
&quot;$2&quot; .... Inside grave quote marks
(&lsquo;&lsquo;), &nbsp;quotes the characters &lsquo;, and
$. If the grave quotes occur within double quotes, then
&nbsp; also <br>
quotes the character &quot;.</p>

<p style="margin-top: 1em">The special meaning of reserved
words or aliases can be removed by quoting any character of
the reserved word. The recognition of function names or
built-in command names listed <br>
below cannot be altered by quoting them.</p>

<p style="margin-top: 1em">Arithmetic Evaluation. <br>
The shell performs arithmetic evaluation for arithmetic
substitution, to evaluate an arithmetic command, to evaluate
an indexed array subscript, and to evaluate arguments to the
<br>
built-in commands shift and let. Evaluations are performed
using double precision floating point arithmetic or long
double precision floating point for systems that provide
this <br>
data type. Floating point constants follow the ANSI-C
programming language floating point conventions. The
floating point constants Nan and Inf can be use to represent
&quot;not a <br>
number&quot; and infinity respectively. Integer constants
follow the ANSI-C programming language integer constant
conventions although only single byte character constants
are recog&acirc; <br>
nized and character casts are not recognized. In addition
constants can be of the form [base#]n where base is a
decimal number between two and sixty-four representing the
arith&acirc; <br>
metic base and n is a number in that base. The digits above
9 are represented by the lower case letters, the upper case
letters, @, and _ respectively. For bases less than or <br>
equal to 36, upper and lower case characters can be used
interchangeably.</p>

<p style="margin-top: 1em">An arithmetic expression uses
the same syntax, precedence, and associativity of expression
as the C language. All the C language operators that apply
to floating point quanti&acirc; <br>
ties can be used. In addition, the operator ** can be used
for exponentiation. It has higher precedence than
multiplication and is left associative. In addition, when
the <br>
value of an arithmetic variable or sub-expression can be
represented as a long integer, all C language integer
arithmetic operations can be performed. Variables can be
refer&acirc; <br>
enced by name within an arithmetic expression without using
the parameter expansion syntax. When a variable is
referenced, its value is evaluated as an arithmetic
expression.</p>

<p style="margin-top: 1em">Any of the following math
library functions that are in the C math library can be used
within an arithmetic expression:</p>

<p style="margin-top: 1em">abs acos acosh asin asinh atan
atan2 atanh cbrt ceil copysign cos cosh erf erfc exp exp2
expm1 fabs fpclassify fdim finite floor fma fmax fmin fmod
hypot ilogb int isfinite sinf <br>
isnan isnormal issubnormal issubordered iszero j0 j1 jn
lgamma log log10 log2 logb nearbyint nextafter nexttoward
pow remainder rint round scanb signbit sin sinh sqrt tan
tanh <br>
tgamma trunc y0 y1 yn In addition, arithmetic functions can
be define as shell functions with a variant of the function
name syntax,</p>

<p style="margin-top: 1em">function .sh.math.name ident ...
{ list ;} <br>
where name is the function name used in the arithmetic
expression and each identifier, ident is a name reference to
the long double precision floating point argument. The <br>
value of .sh.value when the function returns is the value of
this function. User defined functions can take up to 3
arguments and override C math library functions.</p>

<p style="margin-top: 1em">An internal representation of a
variable as a double precision floating point can be
specified with the -E [n], -F [n], or -X [n] option of the
typeset special built-in command. <br>
The -E option causes the expansion of the value to be
represented using scientific notation when it is expanded.
The optional option argument n defines the number of
significant <br>
figures. The -F option causes the expansion to be
represented as a floating decimal number when it is
expanded. The -X option cause the expansion to be
represented using the %a <br>
format defined by ISO C-99. The optional option argument n
defines the number of places after the decimal (or radix)
point in this case.</p>

<p style="margin-top: 1em">An internal integer
representation of a variable can be specified with the -i
[n] option of the typeset special built-in command. The
optional option argument n specifies an <br>
arithmetic base to be used when expanding the variable. If
you do not specify an arithmetic base, base 10 will be
used.</p>

<p style="margin-top: 1em">Arithmetic evaluation is
performed on the value of each assignment to a variable with
the -E, -F, -X, or -i attribute. Assigning a floating point
number to a variable whose type <br>
is an integer causes the fractional part to be
truncated.</p>

<p style="margin-top: 1em">Prompting. <br>
When used interactively, the shell prompts with the value of
PS1 after expanding it for parameter expansion, command
substitution, and arithmetic substitution, before reading a
<br>
command. In addition, each single ! in the prompt is
replaced by the command number. A !! is required to place !
in the prompt. If at any time a new-line is typed and
fur&acirc; <br>
ther input is needed to complete a command, then the
secondary prompt (i.e., the value of PS2) is issued.</p>

<p style="margin-top: 1em">Conditional Expressions. <br>
A conditional expression is used with the [[ compound
command to test attributes of files and to compare strings.
Field splitting and file name generation are not performed
on <br>
the words between [[ and ]]. Each expression can be
constructed from one or more of the following unary or
binary expressions: <br>
string True, if string is not null. <br>
-a file <br>
Same as -e below. This is obsolete. <br>
-b file <br>
True, if file exists and is a block special file. <br>
-c file <br>
True, if file exists and is a character special file. <br>
-d file <br>
True, if file exists and is a directory. <br>
-e file <br>
True, if file exists. <br>
-f file <br>
True, if file exists and is an ordinary file. <br>
-g file <br>
True, if file exists and it has its setgid bit set. <br>
-k file <br>
True, if file exists and it has its sticky bit set. <br>
-n string <br>
True, if length of string is non-zero. <br>
-o ?option <br>
True, if option named option is a valid option name. <br>
-o option <br>
True, if option named option is on. <br>
-p file <br>
True, if file exists and is a fifo special file or a pipe.
<br>
-r file <br>
True, if file exists and is readable by current process.
<br>
-s file <br>
True, if file exists and has size greater than zero. <br>
-t fildes <br>
True, if file descriptor number fildes is open and
associated with a terminal device. <br>
-u file <br>
True, if file exists and it has its setuid bit set. <br>
-v name <br>
True, if variable name is a valid variable name and is set.
<br>
-w file <br>
True, if file exists and is writable by current process.
<br>
-x file <br>
True, if file exists and is executable by current process.
If file exists and is a directory, then true if the current
process has permission to search in the directory. <br>
-z string <br>
True, if length of string is zero. <br>
-L file <br>
True, if file exists and is a symbolic link. <br>
-h file <br>
True, if file exists and is a symbolic link. <br>
-N file <br>
True, if file exists and the modification time is greater
than the last access time. <br>
-O file <br>
True, if file exists and is owned by the effective user id
of this process. <br>
-G file <br>
True, if file exists and its group matches the effective
group id of this process. <br>
-R name <br>
True if variable name is a name reference. <br>
-S file <br>
True, if file exists and is a socket. <br>
file1 -nt file2 <br>
True, if file1 exists and file2 does not, or file1 is newer
than file2. <br>
file1 -ot file2 <br>
True, if file2 exists and file1 does not, or file1 is older
than file2. <br>
file1 -ef file2 <br>
True, if file1 and file2 exist and refer to the same file.
<br>
string == pattern <br>
True, if string matches pattern. Any part of pattern can be
quoted to cause it to be matched as a string. With a
successful match to a pattern, the .sh.match array
vari&acirc; <br>
able will contain the match and sub-pattern matches. <br>
string = pattern <br>
Same as == above, but is obsolete. <br>
string != pattern <br>
True, if string does not match pattern. When the string
matches the pattern the .sh.match array variable will
contain the match and sub-pattern matches. <br>
string =&acirc;&frac14; ere <br>
True if string matches the pattern &acirc;&frac14;(E)ere
where ere is an extended regular expression. <br>
string1 &lt; string2 <br>
True, if string1 comes before string2 based on ASCII value
of their characters. <br>
string1 &gt; string2 <br>
True, if string1 comes after string2 based on ASCII value of
their characters. <br>
The following obsolete arithmetic comparisons are also
permitted: <br>
exp1 -eq exp2 <br>
True, if exp1 is equal to exp2. <br>
exp1 -ne exp2 <br>
True, if exp1 is not equal to exp2. <br>
exp1 -lt exp2 <br>
True, if exp1 is less than exp2. <br>
exp1 -gt exp2 <br>
True, if exp1 is greater than exp2. <br>
exp1 -le exp2 <br>
True, if exp1 is less than or equal to exp2. <br>
exp1 -ge exp2 <br>
True, if exp1 is greater than or equal to exp2.</p>

<p style="margin-top: 1em">In each of the above
expressions, if file is of the form /dev/fd/n, where n is an
integer, then the test is applied to the open file whose
descriptor number is n.</p>

<p style="margin-top: 1em">A compound expression can be
constructed from these primitives by using any of the
following, listed in decreasing order of precedence. <br>
(expression) <br>
True, if expression is true. Used to group expressions. <br>
! expression <br>
True if expression is false. <br>
expression1 &amp;&amp; expression2 <br>
True, if expression1 and expression2 are both true. <br>
expression1 &acirc;&ordf;&acirc;&ordf; expression2 <br>
True, if either expression1 or expression2 is true.</p>

<p style="margin-top: 1em">Input/Output. <br>
Before a command is executed, its input and output may be
redirected using a special notation interpreted by the
shell. The following may appear anywhere in a simple-command
or <br>
may precede or follow a command and are not passed on to the
invoked command. Command substitution, parameter expansion,
and arithmetic substitution occur before word or digit <br>
is used except as noted below. File name generation occurs
only if the shell is interactive and the pattern matches a
single file. Field splitting is not performed.</p>

<p style="margin-top: 1em">In each of the following
redirections, if file is of the form /dev/sctp/host/port,
/dev/tcp/host/port, or /dev/udp/host/port, where host is a
hostname or host address, and port <br>
is a service given by name or an integer port number, then
the redirection attempts to make a tcp, sctp or udp
connection to the corresponding socket.</p>

<p style="margin-top: 1em">No intervening space is allowed
between the characters of redirection operators.</p>

<p style="margin-top: 1em">&lt;word Use file word as
standard input (file descriptor 0).</p>

<p style="margin-top: 1em">&gt;word Use file word as
standard output (file descriptor 1). If the file does not
exist then it is created. If the file exists, and the
noclobber option is on, this <br>
causes an error; otherwise, it is truncated to zero
length.</p>

<p style="margin-top: 1em">&gt;|word Same as &gt;, except
that it overrides the noclobber option.</p>

<p style="margin-top: 1em">&gt;;word Write output to a
temporary file. If the command completes successfully rename
it to word, otherwise, delete the temporary file. &gt;;word
cannot be used with the <br>
exec(2). built-in.</p>

<p style="margin-top: 1em">&gt;&gt;word Use file word as
standard output. If the file exists, then output is appended
to it (by first seeking to the end-of-file); otherwise, the
file is created.</p>

<p style="margin-top: 1em">&lt;&gt;word Open file word for
reading and writing as standard output.</p>

<p style="margin-top: 1em">&lt;&gt;;word The same as
&lt;&gt;word except that if the command completes
successfully, word is truncated to the offset at command
completion. &lt;&gt;;word cannot be used with the <br>
exec(2). built-in.</p>

<p style="margin-top: 1em">&lt;&lt;[-]word The shell input
is read up to a line that is the same as word after any
quoting has been removed, or to an end-of-file. No parameter
substitution, command substi&acirc; <br>
tution, arithmetic substitution or file name generation is
performed on word. The resulting document, called a
here-document, becomes the standard input. If any <br>
character of word is quoted, then no interpretation is
placed upon the characters of the document; otherwise,
parameter expansion, command substitution, and arith&acirc;
<br>
metic substitution occur, 0w-line is ignored, and &nbsp;must
be used to quote the characters $, &lsquo;. If - is appended
to &lt;&lt;, then all leading tabs are stripped from <br>
word and from the document. If # is appended to &lt;&lt;,
then leading spaces and tabs will be stripped off the first
line of the document and up to an equivalent inden&acirc;
<br>
tation will be stripped from the remaining lines and from
word. A tab stop is assumed to occur at every 8 columns for
the purposes of determining the indentation.</p>

<p style="margin-top: 1em">&lt;&lt;&lt;word A short form of
here document in which word becomes the contents of the
here-document after any parameter expansion, command
substitution, and arithmetic substitu&acirc; <br>
tion occur.</p>

<p style="margin-top: 1em">&lt;&amp;digit The standard
input is duplicated from file descriptor digit (see dup(2)).
Similarly for the standard output using &gt;&amp;digit.</p>

<p style="margin-top: 1em">&lt;&amp;digit- The file
descriptor given by digit is moved to standard input.
Similarly for the standard output using &gt;&amp;digit-.</p>

<p style="margin-top: 1em">&lt;&amp;- The standard input is
closed. Similarly for the standard output using
&gt;&amp;-.</p>

<p style="margin-top: 1em">&lt;&amp;p The input from the
co-process is moved to standard input.</p>

<p style="margin-top: 1em">&gt;&amp;p The output to the
co-process is moved to standard output.</p>

<p style="margin-top: 1em">&lt;#((expr)) Evaluate
arithmetic expression expr and position file descriptor 0 to
the resulting value bytes from the start of the file. The
variables CUR and EOF evaluate to <br>
the current offset and end-of-file offset respectively when
evaluating expr.</p>

<p style="margin-top: 1em">&gt;#((offset)) The same as
&lt;# except applies to file descriptor 1.</p>

<p style="margin-top: 1em">&lt;#pattern Seeks forward to
the beginning of the next line containing pattern.</p>

<p style="margin-top: 1em">&lt;##pattern The same as &lt;#
except that the portion of the file that is skipped is
copied to standard output.</p>

<p style="margin-top: 1em">If one of the above is preceded
by a digit, with no intervening space, then the file
descriptor number referred to is that specified by the digit
(instead of the default 0 or 1). <br>
If one of the above, other than &gt;&amp;- and the &gt;# and
&lt;# forms, is preceded by {varname} with no intervening
space, then a file descriptor number &gt; 10 will be
selected by the shell <br>
and stored in the variable varname. If &gt;&amp;- or the any
of the &gt;# and &lt;# forms is preceded by {varname} the
value of varname defines the file descriptor to close or
position. For <br>
example:</p>

<p style="margin-top: 1em">... 2&gt;&amp;1</p>

<p style="margin-top: 1em">means file descriptor 2 is to be
opened for writing as a duplicate of file descriptor 1
and</p>

<p style="margin-top: 1em">exec {n}&lt;file</p>

<p style="margin-top: 1em">means open file named file for
reading and store the file descriptor number in variable
n.</p>

<p style="margin-top: 1em">The order in which redirections
are specified is significant. The shell evaluates each
redirection in terms of the (file descriptor, file)
association at the time of evaluation. <br>
For example:</p>

<p style="margin-top: 1em">... 1&gt;fname 2&gt;&amp;1</p>

<p style="margin-top: 1em">first associates file descriptor
1 with file fname. It then associates file descriptor 2 with
the file associated with file descriptor 1 (i.e. fname). If
the order of redirec&acirc; <br>
tions were reversed, file descriptor 2 would be associated
with the terminal (assuming file descriptor 1 had been) and
then file descriptor 1 would be associated with file
fname.</p>

<p style="margin-top: 1em">If a command is followed by
&amp; and job control is not active, then the default
standard input for the command is the empty file /dev/null.
Otherwise, the environment for the exe&acirc; <br>
cution of a command contains the file descriptors of the
invoking shell as modified by input/output
specifications.</p>

<p style="margin-top: 1em">Environment. <br>
The environment (see environ(7)) is a list of name-value
pairs that is passed to an executed program in the same way
as a normal argument list. The names must be identifiers and
<br>
the values are character strings. The shell interacts with
the environment in several ways. On invocation, the shell
scans the environment and creates a variable for each name
<br>
found, giving it the corresponding value and attributes and
marking it export. Executed commands inherit the
environment. If the user modifies the values of these
variables or <br>
creates new ones, using the export or typeset -x commands,
they become part of the environment. The environment seen by
any executed command is thus composed of any name-value <br>
pairs originally inherited by the shell, whose values may be
modified by the current shell, plus any additions which must
be noted in export or typeset -x commands.</p>

<p style="margin-top: 1em">The environment for any
simple-command or function may be augmented by prefixing it
with one or more variable assignments. A variable assignment
argument is a word of the form <br>
identifier=value. Thus:</p>

<p style="margin-top: 1em">TERM=450 cmd args and <br>
(export TERM; TERM=450; cmd args)</p>

<p style="margin-top: 1em">are equivalent (as far as the
above execution of cmd is concerned except for special
built-in commands listed below - those that are preceded
with a dagger).</p>

<p style="margin-top: 1em">If the obsolete -k option is
set, all variable assignment arguments are placed in the
environment, even if they occur after the command name. The
following first prints a=b c <br>
and then c:</p>

<p style="margin-top: 1em">echo a=b c <br>
set -k <br>
echo a=b c <br>
This feature is intended for use with scripts written for
early versions of the shell and its use in new scripts is
strongly discouraged. It is likely to disappear someday.</p>

<p style="margin-top: 1em">Functions. <br>
For historical reasons, there are two ways to define
functions, the name() syntax and the function name syntax,
described in the Commands section above. Shell functions are
read <br>
in and stored internally. Alias names are resolved when the
function is read. Functions are executed like commands with
the arguments passed as positional parameters. (See <br>
Execution below.)</p>

<p style="margin-top: 1em">Functions defined by the
function name syntax and called by name execute in the same
process as the caller and share all files and present
working directory with the caller. <br>
Traps caught by the caller are reset to their default action
inside the function. A trap condition that is not caught or
ignored by the function causes the function to terminate
<br>
and the condition to be passed on to the caller. A trap on
EXIT set inside a function is executed in the environment of
the caller after the function completes. Ordinarily, <br>
variables are shared between the calling program and the
function. However, the typeset special built-in command used
within a function defines local variables whose scope <br>
includes the current function. They can be passed to
functions that they call in the variable assignment list
that precedes the call or as arguments passed as name
references. <br>
Errors within functions return control to the caller.</p>

<p style="margin-top: 1em">Functions defined with the
name() syntax and functions defined with the function name
syntax that are invoked with the . special built-in are
executed in the caller&rsquo;s environ&acirc; <br>
ment and share all variables and traps with the caller.
Errors within these function executions cause the script
that contains them to abort.</p>

<p style="margin-top: 1em">The special built-in command
return is used to return from function calls.</p>

<p style="margin-top: 1em">Function names can be listed
with the -f or +f option of the typeset special built-in
command. The text of functions, when available, will also be
listed with -f. Functions can <br>
be undefined with the -f option of the unset special
built-in command.</p>

<p style="margin-top: 1em">Ordinarily, functions are unset
when the shell executes a shell script. Functions that need
to be defined across separate invocations of the shell
should be placed in a direc&acirc; <br>
tory and the FPATH variable should contain the name of this
directory. They may also be specified in the ENV file.</p>

<p style="margin-top: 1em">Discipline Functions. <br>
Each variable can have zero or more discipline functions
associated with it. The shell initially understands the
discipline names get, set, append, and unset but can be
added <br>
when defining new types. On most systems others can be added
at run time via the C programming interface extension
provided by the builtin built-in utility. If the get
disci&acirc; <br>
pline is defined for a variable, it is invoked whenever the
given variable is referenced. If the variable .sh.value is
assigned a value inside the discipline function, the
ref&acirc; <br>
erenced variable will evaluate to this value instead. If the
set discipline is defined for a variable, it is invoked
whenever the given variable is assigned a value. If the <br>
append discipline is defined for a variable, it is invoked
whenever a value is appended to the given variable. The
variable .sh.value is given the value of the variable before
<br>
invoking the discipline, and the variable will be assigned
the value of .sh.value after the discipline completes. If
.sh.value is unset inside the discipline, then that value is
<br>
unchanged. If the unset discipline is defined for a
variable, it is invoked whenever the given variable is
unset. The variable will not be unset unless it is unset
explicitly <br>
from within this discipline function.</p>

<p style="margin-top: 1em">The variable .sh.name contains
the name of the variable for which the discipline function
is called, .sh.subscript is the subscript of the variable,
and .sh.value will contain <br>
the value being assigned inside the set discipline function.
The variable _ is a reference to the variable including the
subscript if any. For the set discipline, changing <br>
.sh.value will change the value that gets assigned. Finally,
the expansion ${var.name}, when name is the name of a
discipline, and there is no variable of this name, is
equiva&acirc; <br>
lent to the command substitution ${ var.name;}.</p>

<p style="margin-top: 1em">Name Spaces. <br>
Commands and functions that are executed as part of the list
of a namespace command that modify variables or create new
ones, create a new variable whose name is the name of the
<br>
name space as given by identifier preceded by .. When a
variable whose name is name is referenced, it is first
searched for using .identifier.name. Similarly, a function
<br>
defined by a command in the namespace list is created using
the name space name preceded by a ..</p>

<p style="margin-top: 1em">When the list of a namespace
command contains a namespace command, the names of variables
and functions that are created consist of the variable or
function name preceded by the <br>
list of identifiers each preceded by ..</p>

<p style="margin-top: 1em">Outside of a name space, a
variable or function created inside a name space can be
referenced by preceding it with the name space name.</p>

<p style="margin-top: 1em">By default, variables staring
with .sh are in the sh name space.</p>

<p style="margin-top: 1em">Type Variables. <br>
Typed variables provide a way to create data structure and
objects. A type can be defined either by a shared library,
by the enum built-in command described below, or by using
<br>
the new -T option of the typeset built-in command. With the
-T option of typeset, the type name, specified as an option
argument to -T, is set with a compound variable
assign&acirc; <br>
ment that defines the type. Function definitions can appear
inside the compound variable assignment and these become
discipline functions for this type and can be invoked or
<br>
redefined by each instance of the type. The function name
create is treated specially. It is invoked for each instance
of the type that is created but is not inherited and
can&acirc; <br>
not be redefined for each instance.</p>

<p style="margin-top: 1em">When a type is defined a special
built-in command of that name is added. These built-ins are
declaration commands and follow the same expansion rules as
all the special built-in <br>
commands defined below that are preceded by
&acirc;&nbsp;&acirc;&nbsp;. These commands can subsequently
be used inside further type definitions. The man page for
these commands can be generated by <br>
using the --man option or any of the other -- options
described with getopts. The -r, -a, -A, -h, and -S options
of typeset are permitted with each of these new
built-ins.</p>

<p style="margin-top: 1em">An instance of a type is created
by invoking the type name followed by one or more instance
names. Each instance of the type is initialized with a copy
of the sub-variables <br>
except for sub-variables that are defined with the -S
option. Variables defined with the -S are shared by all
instances of the type. Each instance can change the value of
any <br>
sub-variable and can also define new discipline functions of
the same names as those defined by the type definition as
well as any standard discipline names. No additional sub-
<br>
variables can be defined for any instance.</p>

<p style="margin-top: 1em">When defining a type, if the
value of a sub-variable is not set and the -r attribute is
specified, it causes the sub-variable to be a required
sub-variable. Whenever an instance <br>
of a type is created, all required sub-variables must be
specified. These sub-variables become readonly in each
instance.</p>

<p style="margin-top: 1em">When unset is invoked on a
sub-variable within a type, and the -r attribute has not
been specified for this field, the value is reset to the
default value associative with the <br>
type. Invoking unset on a type instance not contained within
another type deletes all sub-variables and the variable
itself.</p>

<p style="margin-top: 1em">A type definition can be derived
from another type definition by defining the first
sub-variable name as _ and defining its type as the base
type. Any remaining definitions will <br>
be additions and modifications that apply to the new type.
If the new type name is the same is that of the base type,
the type will be replaced and the original type will no <br>
longer be accessible.</p>

<p style="margin-top: 1em">The typeset command with the -T
and no option argument or operands will write all the type
definitions to standard output in a form that that can be
read in to create all they <br>
types.</p>

<p style="margin-top: 1em">Jobs. <br>
If the monitor option of the set command is turned on, an
interactive shell associates a job with each pipeline. It
keeps a table of current jobs, printed by the jobs command,
<br>
and assigns them small integer numbers. When a job is
started asynchronously with &amp;, the shell prints a line
which looks like:</p>

<p style="margin-top: 1em">[1] 1234</p>

<p style="margin-top: 1em">indicating that the job which
was started asynchronously was job number 1 and had one
(top-level) process, whose process id was 1234.</p>

<p style="margin-top: 1em">This paragraph and the next
require features that are not in all versions of UNIX and
may not apply. If you are running a job and wish to do
something else you may hit the key <br>
^Z (control-Z) which sends a STOP signal to the current job.
The shell will then normally indicate that the job has been
&lsquo;Stopped&rsquo;, and print another prompt. You can
then <br>
manipulate the state of this job, putting it in the
background with the bg command, or run some other commands
and then eventually bring the job back into the foreground
with the <br>
foreground command fg. A ^Z takes effect immediately and is
like an interrupt in that pending output and unread input
are discarded when it is typed.</p>

<p style="margin-top: 1em">A job being run in the
background will stop if it tries to read from the terminal.
Background jobs are normally allowed to produce output, but
this can be disabled by giving the <br>
command stty tostop. If you set this tty option, then
background jobs will stop when they try to produce output
like they do when they try to read input.</p>

<p style="margin-top: 1em">A job pool is a collection of
jobs started with list &amp; associated with a name.</p>

<p style="margin-top: 1em">There are several ways to refer
to jobs in the shell. A job can be referred to by the
process id of any process of the job or by one of the
following: <br>
%number <br>
The job with the given number. <br>
pool All the jobs in the job pool named by pool. <br>
pool.number <br>
The job number number in the job pool named by pool. <br>
%string <br>
Any job whose command line begins with string. <br>
%?string <br>
Any job whose command line contains string. <br>
%% Current job. <br>
%+ Equivalent to %%. <br>
%- Previous job. In addition, unless noted otherwise,
wherever a job can be specified, the name of a background
job pool can be used to represent all the jobs in that
pool.</p>

<p style="margin-top: 1em">The shell learns immediately
whenever a process changes state. It normally informs you
whenever a job becomes blocked so that no further progress
is possible, but only just <br>
before it prints a prompt. This is done so that it does not
otherwise disturb your work. The notify option of the set
command causes the shell to print these job change
mes&acirc; <br>
sages as soon as they occur.</p>

<p style="margin-top: 1em">When the monitor option is on,
each background job that completes triggers any trap set for
CHLD.</p>

<p style="margin-top: 1em">When you try to leave the shell
while jobs are running or stopped, you will be warned that
&lsquo;You have stopped(running) jobs.&rsquo; You may use
the jobs command to see what they are. <br>
If you immediately try to exit again, the shell will not
warn you a second time, and the stopped jobs will be
terminated. When a login shell receives a HUP signal, it
sends a <br>
HUP signal to each job that has not been disowned with the
disown built-in command described below.</p>

<p style="margin-top: 1em">Signals. <br>
The INT and QUIT signals for an invoked command are ignored
if the command is followed by &amp; and the monitor option
is active. Otherwise, signals have the values inherited by
the <br>
shell from its parent (but see also the trap built-in
command below).</p>

<p style="margin-top: 1em">Execution. <br>
Each time a command is read, the above substitutions are
carried out. If the command name matches one of the Special
Built-in Commands listed below, it is executed within the
<br>
current shell process. Next, the command name is checked to
see if it matches a user defined function. If it does, the
positional parameters are saved and then reset to the <br>
arguments of the function call. A function is also executed
in the current shell process. When the function completes or
issues a return, the positional parameter list is <br>
restored. For functions defined with the function name
syntax, any trap set on EXIT within the function is
executed. The exit value of a function is the value of the
last com&acirc; <br>
mand executed. If a command name is not a special built-in
command or a user defined function, but it is one of the
built-in commands listed below, it is executed in the
current <br>
shell process.</p>

<p style="margin-top: 1em">The shell variables PATH
followed by the variable FPATH defines the list of
directories to search for the command name. Alternative
directory names are separated by a colon (:). <br>
The default path is equal to getconf PATH output. The
current directory can be specified by two or more adjacent
colons, or by a colon at the beginning or end of the path
list. <br>
If the command name contains a /, then the search path is
not used. Otherwise, each directory in the list of
directories defined by PATH and FPATH is checked in order.
If the <br>
directory being searched is contained in FPATH and contains
a file whose name matches the command being searched, then
this file is loaded into the current shell environment as
<br>
if it were the argument to the . command except that only
preset aliases are expanded, and a function of the given
name is executed as described above.</p>

<p style="margin-top: 1em">If this directory is not in
FPATH the shell first determines whether there is a built-in
version of a command corresponding to a given pathname and
if so it is invoked in the <br>
current process. If no built-in is found, the shell checks
for a file named .paths in this directory. If found and
there is a line of the form FPATH=path where path names an
<br>
existing directory then that directory is searched after
immediately after the current directory as if it were found
in the FPATH variable. If path does not begin with /, it is
<br>
checked for relative to the directory being searched.</p>

<p style="margin-top: 1em">The .paths file is then checked
for a line of the form PLUGIN_LIB=libname [ : libname ] ...
. Each library named by libname will be searched for as if
it were an option argu&acirc; <br>
ment to builtin -f, and if it contains a built-in of the
specified name this will be executed instead of a command by
this name. Any built-in loaded from a library found this
<br>
way will be associated with the directory containing the
.paths file so it will only execute if not found in an
earlier directory.</p>

<p style="margin-top: 1em">Finally, the directory will be
checked for a file of the given name. If the file has
execute permission but is not an a.out file, it is assumed
to be a file containing shell <br>
commands. A separate shell is spawned to read it. All
non-exported variables are removed in this case. If the
shell command file doesn&rsquo;t have read permission, or if
the setuid <br>
and/or setgid bits are set on the file, then the shell
executes an agent whose job it is to set up the permissions
and execute the shell with the shell command file passed
down <br>
as an open file. If the .paths contains a line of the form
name=value in the first or second line, then the environment
variable name is modified by prepending the directory <br>
specified by value to the directory list. If value is not an
absolute directory, then it specifies a directory relative
to the directory that the executable was found. If the <br>
environment variable name does not already exist it will be
added to the environment list for the specified command. A
parenthesized command is executed in a sub-shell without
<br>
removing non-exported variables.</p>

<p style="margin-top: 1em">Command Re-entry. <br>
The text of the last HISTSIZE (default 512) commands entered
from a terminal device is saved in a history file. The file
$HOME/.sh_history is used if the HISTFILE variable is <br>
not set or if the file it names is not writable. A shell can
access the commands of all interactive shells which use the
same named HISTFILE. The built-in command hist is used <br>
to list or edit a portion of this file. The portion of the
file to be edited or listed can be selected by number or by
giving the first character or characters of the command.
<br>
A single command or range of commands can be specified. If
you do not specify an editor program as an argument to hist
then the value of the variable HISTEDIT is used. If <br>
HISTEDIT is unset, the obsolete variable FCEDIT is used. If
FCEDIT is not defined, then /bin/ed is used. The edited
command(s) is printed and re-executed upon leaving the
edi&acirc; <br>
tor unless you quit without writing. The -s option (and in
obsolete versions, the editor name -) is used to skip the
editing phase and to re-execute the command. In this case a
<br>
substitution parameter of the form old=new can be used to
modify the command before execution. For example, with the
preset alias r, which is aliased to &acirc;&sup2;hist
-s&acirc;&sup2;, typing &lsquo;r <br>
bad=good c&rsquo; will re-execute the most recent command
which starts with the letter c, replacing the first
occurrence of the string bad with the string good.</p>

<p style="margin-top: 1em">In-line Editing Options. <br>
Normally, each command line entered from a terminal device
is simply typed followed by a new-line (&lsquo;RETURN&rsquo;
or &lsquo;LINE FEED&rsquo;). If either the emacs, gmacs, or
vi option is active, <br>
the user can edit the command line. To be in either of these
edit modes set the corresponding option. An editing option
is automatically selected each time the VISUAL or EDITOR
<br>
variable is assigned a value ending in either of these
option names.</p>

<p style="margin-top: 1em">The editing features require
that the user&rsquo;s terminal accept &lsquo;RETURN&rsquo;
as carriage return without line feed and that a space
(&lsquo; &rsquo;) must overwrite the current character on
the <br>
screen.</p>

<p style="margin-top: 1em">Unless the multiline option is
on, the editing modes implement a concept where the user is
looking through a window at the current line. The window
width is the value of COLUMNS <br>
if it is defined, otherwise 80. If the window width is too
small to display the prompt and leave at least 8 columns to
enter input, the prompt is truncated from the left. If <br>
the line is longer than the window width minus two, a mark
is displayed at the end of the window to notify the user. As
the cursor moves and reaches the window boundaries the <br>
window will be centered about the cursor. The mark is a &gt;
(&lt;, *) if the line extends on the right (left, both)
side(s) of the window.</p>

<p style="margin-top: 1em">The search commands in each edit
mode provide access to the history file. Only strings are
matched, not patterns, although a leading ^ in the string
restricts the match to begin <br>
at the first character in the line.</p>

<p style="margin-top: 1em">Each of the edit modes has an
operation to list the files or commands that match a
partially entered word. When applied to the first word on
the line, or the first word after a <br>
;, &acirc;&ordf;, &amp;, or (, and the word does not begin
with &acirc;&frac14; or contain a /, the list of aliases,
functions, and executable commands defined by the PATH
variable that could match the par&acirc; <br>
tial word is displayed. Otherwise, the list of files that
match the given word is displayed. If the partially entered
word does not contain any file expansion characters, a *
<br>
is appended before generating these lists. After displaying
the generated list, the input line is redrawn. These
operations are called command name listing and file name
list&acirc; <br>
ing, respectively. There are additional operations, referred
to as command name completion and file name completion,
which compute the list of matching commands or files, but
<br>
instead of printing the list, replace the current word with
a complete or partial match. For file name completion, if
the match is unique, a / is appended if the file is a <br>
directory and a space is appended if the file is not a
directory. Otherwise, the longest common prefix for all the
matching files replaces the word. For command name
comple&acirc; <br>
tion, only the portion of the file names after the last /
are used to find the longest command prefix. If only a
single name matches this prefix, then the word is replaced
with <br>
the command name followed by a space. When using a tab for
completion that does not yield a unique match, a subsequent
tab will provide a numbered list of matching alternatives.
<br>
A specific selection can be made by entering the selection
number followed by a tab.</p>

<p style="margin-top: 1em">Key Bindings. <br>
The KEYBD trap can be used to intercept keys as they are
typed and change the characters that are actually seen by
the shell. This trap is executed after each character (or
<br>
sequence of characters when the first character is ESC) is
entered while reading from a terminal. The variable
.sh.edchar contains the character or character sequence
which gen&acirc; <br>
erated the trap. Changing the value of .sh.edchar in the
trap action causes the shell to behave as if the new value
were entered from the keyboard rather than the original <br>
value.</p>

<p style="margin-top: 1em">The variable .sh.edcol is set to
the input column number of the cursor at the time of the
input. The variable .sh.edmode is set to ESC when in vi
insert mode (see below) and is <br>
null otherwise. By prepending ${.sh.editmode} to a value
assigned to .sh.edchar it will cause the shell to change to
control mode if it is not already in this mode.</p>

<p style="margin-top: 1em">This trap is not invoked for
characters entered as arguments to editing directives, or
while reading input for a character search.</p>

<p style="margin-top: 1em">Emacs Editing Mode. <br>
This mode is entered by enabling either the emacs or gmacs
option. The only difference between these two modes is the
way they handle ^T. To edit, the user moves the cursor to
<br>
the point needing correction and then inserts or deletes
characters or words as needed. All the editing commands are
control characters or escape sequences. The notation for
<br>
control characters is caret (^) followed by the character.
For example, ^F is the notation for control F. This is
entered by depressing &lsquo;f&rsquo; while holding down the
&lsquo;CTRL&rsquo; (con&acirc; <br>
trol) key. The &lsquo;SHIFT&rsquo; key is not depressed.
(The notation ^? indicates the DEL (delete) key.)</p>

<p style="margin-top: 1em">The notation for escape
sequences is M- followed by a character. For example, M-f
(pronounced Meta f) is entered by depressing ESC (ascii 033)
followed by &lsquo;f&rsquo;. (M-F would be <br>
the notation for ESC followed by &lsquo;SHIFT&rsquo;
(capital) &lsquo;F&rsquo;.)</p>

<p style="margin-top: 1em">All edit commands operate from
any place on the line (not just at the beginning). Neither
the &lsquo;RETURN&rsquo; nor the &lsquo;LINE FEED&rsquo; key
is entered after edit commands except when noted.</p>

<p style="margin-top: 1em">^F Move cursor forward (right)
one character. <br>
M-[C Move cursor forward (right) one character. <br>
M-f Move cursor forward one word. (The emacs editor&rsquo;s
idea of a word is a string of characters consisting of only
letters, digits and underscores.) <br>
^B Move cursor backward (left) one character. <br>
M-[D Move cursor backward (left) one character. <br>
M-b Move cursor backward one word. <br>
^A Move cursor to start of line. <br>
M-[H Move cursor to start of line. <br>
^E Move cursor to end of line. <br>
M-[Y Move cursor to end of line. <br>
^]char Move cursor forward to character char on current
line. <br>
M-^]char Move cursor backward to character char on current
line. <br>
^X^X Interchange the cursor and mark. <br>
erase (User defined erase character as defined by the
stty(1) command, usually ^H or #.) Delete previous
character. <br>
lnext (User defined literal next character as defined by the
stty(1) command, or ^V if not defined.) Removes the next
character&rsquo;s editing features (if any). <br>
^D Delete current character. <br>
M-d Delete current word. <br>
M-^H (Meta-backspace) Delete previous word. <br>
M-h Delete previous word. <br>
M-^? (Meta-DEL) Delete previous word (if your interrupt
character is ^? (DEL, the default) then this command will
not work). <br>
^T Transpose current character with previous character and
advance the cursor in emacs mode. Transpose two previous
characters in gmacs mode. <br>
^C Capitalize current character. <br>
M-c Capitalize current word. <br>
M-l Change the current word to lower case. <br>
^K Delete from the cursor to the end of the line. If
preceded by a numerical parameter whose value is less than
the current cursor position, then delete from given
posi&acirc; <br>
tion up to the cursor. If preceded by a numerical parameter
whose value is greater than the current cursor position,
then delete from cursor up to given cursor posi&acirc; <br>
tion. <br>
^W Kill from the cursor to the mark. <br>
M-p Push the region from the cursor to the mark on the
stack. <br>
kill (User defined kill character as defined by the stty
command, usually ^G or @.) Kill the entire current line. If
two kill characters are entered in succession, all <br>
kill characters from then on cause a line feed (useful when
using paper terminals). <br>
^Y Restore last item removed from line. (Yank item back to
the line.) <br>
^L Line feed and print current line. <br>
M-^L Clear the screen. <br>
^@ (Null character) Set mark. <br>
M-space (Meta space) Set mark. <br>
^J (New line) Execute the current line. <br>
^M (Return) Execute the current line. <br>
eof End-of-file character, normally ^D, is processed as an
End-of-file only if the current line is null. <br>
^P Fetch previous command. Each time ^P is entered the
previous command back in time is accessed. Moves back one
line when not on the first line of a multi-line command.
<br>
M-[A If the cursor is at the end of the line, it is
equivalent to ^R with string set to the contents of the
current line. Otherwise, it is equivalent to ^P. <br>
M-&lt; Fetch the least recent (oldest) history line. <br>
M-&gt; Fetch the most recent (youngest) history line. <br>
^N Fetch next command line. Each time ^N is entered the next
command line forward in time is accessed. <br>
M-[B Equivalent to ^N. <br>
^Rstring Reverse search history for a previous command line
containing string. If a parameter of zero is given, the
search is forward. String is terminated by a
&lsquo;RETURN&rsquo; or <br>
&lsquo;NEW LINE&rsquo;. If string is preceded by a ^, the
matched line must begin with string. If string is omitted,
then the next command line containing the most recent string
<br>
is accessed. In this case a parameter of zero reverses the
direction of the search. <br>
^O Operate - Execute the current line and fetch the next
line relative to current line from the history file. <br>
M-digits (Escape) Define numeric parameter, the digits are
taken as a parameter to the next command. The commands that
accept a parameter are ^F, ^B, erase, ^C, ^D, ^K, ^R, ^P,
<br>
^N, ^], M-., M-^], M-_, M-=, M-b, M-c, M-d, M-f, M-h, M-l
and M-^H. <br>
M-letter Soft-key - Your alias list is searched for an alias
by the name _letter and if an alias of this name is defined,
its value will be inserted on the input queue. The <br>
letter must not be one of the above meta-functions. <br>
M-[letter Soft-key - Your alias list is searched for an
alias by the name __letter and if an alias of this name is
defined, its value will be inserted on the input queue. This
<br>
can be used to program function keys on many terminals. <br>
M-. The last word of the previous command is inserted on the
line. If preceded by a numeric parameter, the value of this
parameter determines which word to insert rather <br>
than the last word. <br>
M-_ Same as M-.. <br>
M-* Attempt file name generation on the current word. An
asterisk is appended if the word doesn&rsquo;t match any
file or contain any special pattern characters. <br>
M-ESC Command or file name completion as described above.
<br>
^I tab Attempts command or file name completion as described
above. If a partial completion occurs, repeating this will
behave as if M-= were entered. If no match is found <br>
or entered after space, a tab is inserted. <br>
M-= If not preceded by a numeric parameter, it generates the
list of matching commands or file names as described above.
Otherwise, the word under the cursor is replaced <br>
by the item corresponding to the value of the numeric
parameter from the most recently generated command or file
list. If the cursor is not on a word, it is inserted <br>
instead. <br>
^U Multiply parameter of next command by 4. &nbsp; <br>
Escape next character. Editing characters, the user&rsquo;s
erase, kill and interrupt (normally ^?) characters may be
entered in a command line or in a search string if <br>
preceded by a . The &nbsp;removes the next character&rsquo;s
editing features (if any). <br>
M-^V Display version of the shell. <br>
M-# If the line does not begin with a #, a # is inserted at
the beginning of the line and after each new-line, and the
line is entered. This causes a comment to be <br>
inserted in the history file. If the line begins with a #,
the # is deleted and one # after each new-line is also
deleted.</p>

<p style="margin-top: 1em">Vi Editing Mode. <br>
There are two typing modes. Initially, when you enter a
command you are in the input mode. To edit, the user enters
control mode by typing ESC (033) and moves the cursor to the
<br>
point needing correction and then inserts or deletes
characters or words as needed. Most control commands accept
an optional repeat count prior to the command.</p>

<p style="margin-top: 1em">When in vi mode on most systems,
canonical processing is initially enabled and the command
will be echoed again if the speed is 1200 baud or greater
and it contains any control <br>
characters or less than one second has elapsed since the
prompt was printed. The ESC character terminates canonical
processing for the remainder of the command and the user can
<br>
then modify the command line. This scheme has the advantages
of canonical processing with the type-ahead echoing of raw
mode.</p>

<p style="margin-top: 1em">If the option viraw is also set,
the terminal will always have canonical processing disabled.
This mode is implicit for systems that do not support two
alternate end of line <br>
delimiters, and may be helpful for certain terminals.</p>

<p style="margin-top: 1em">Input Edit Commands <br>
By default the editor is in input mode. <br>
erase (User defined erase character as defined by the stty
command, usually ^H or #.) Delete previous character. <br>
^W Delete the previous blank separated word. On some systems
the viraw option may be required for this to work. <br>
eof As the first character of the line causes the shell to
terminate unless the ignoreeof option is set. Otherwise this
character is ignored. <br>
lnext (User defined literal next character as defined by the
stty(1) or ^V if not defined.) Removes the next
character&rsquo;s editing features (if any). On some systems
<br>
the viraw option may be required for this to work. &nbsp;
<br>
Escape the next erase or kill character. <br>
^I tab Attempts command or file name completion as described
above and returns to input mode. If a partial completion
occurs, repeating this will behave as if = were <br>
entered from control mode. If no match is found or entered
after space, a tab is inserted. <br>
Motion Edit Commands <br>
These commands will move the cursor. <br>
[count]l Cursor forward (right) one character. <br>
[count][C Cursor forward (right) one character. <br>
[count]w Cursor forward one alpha-numeric word. <br>
[count]W Cursor to the beginning of the next word that
follows a blank. <br>
[count]e Cursor to end of word. <br>
[count]E Cursor to end of the current blank delimited word.
<br>
[count]h Cursor backward (left) one character. <br>
[count][D Cursor backward (left) one character. <br>
[count]b Cursor backward one word. <br>
[count]B Cursor to preceding blank separated word. <br>
[count]&acirc;&ordf; Cursor to column count. <br>
[count]fc Find the next character c in the current line.
<br>
[count]Fc Find the previous character c in the current line.
<br>
[count]tc Equivalent to f followed by h. <br>
[count]Tc Equivalent to F followed by l. <br>
[count]; Repeats count times, the last single character find
command, f, F, t, or T. <br>
[count], Reverses the last single character find command
count times. <br>
0 Cursor to start of line. <br>
^ Cursor to start of line. <br>
[H Cursor to first non-blank character in line. <br>
$ Cursor to end of line. <br>
[Y Cursor to end of line. <br>
% Moves to balancing (, ), {, }, [, or ]. If cursor is not
on one of the above characters, the remainder of the line is
searched for the first occurrence of one <br>
of the above characters first. <br>
Search Edit Commands <br>
These commands access your command history. <br>
[count]k Fetch previous command. Each time k is entered the
previous command back in time is accessed. <br>
[count]- Equivalent to k. <br>
[count][A If cursor is at the end of the line it is
equivalent to / with string^set to the contents of the
current line. Otherwise, it is equivalent to k. <br>
[count]j Fetch next command. Each time j is entered the next
command forward in time is accessed. <br>
[count]+ Equivalent to j. <br>
[count][B Equivalent to j. <br>
[count]G The command number count is fetched. The default is
the least recent history command. <br>
/string Search backward through history for a previous
command containing string. String is terminated by a
&lsquo;RETURN&rsquo; or &lsquo;NEW LINE&rsquo;. If string is
preceded by a ^, the <br>
matched line must begin with string. If string is null, the
previous string will be used. <br>
?string Same as / except that search will be in the forward
direction. <br>
n Search for next match of the last pattern to / or ?
commands. <br>
N Search for next match of the last pattern to / or ?, but
in reverse direction. <br>
Text Modification Edit Commands <br>
These commands will modify the line. <br>
a Enter input mode and enter text after the current
character. <br>
A Append text to the end of the line. Equivalent to $a. <br>
[count]cmotion <br>
c[count]motion <br>
Delete current character through the character that motion
would move the cursor to and enter input mode. If motion is
c, the entire line will be deleted and <br>
input mode entered. <br>
C Delete the current character through the end of line and
enter input mode. Equivalent to c$. <br>
S Equivalent to cc. <br>
[count]s Replace characters under the cursor in input mode.
<br>
D Delete the current character through the end of line.
Equivalent to d$. <br>
[count]dmotion <br>
d[count]motion <br>
Delete current character through the character that motion
would move to. If motion is d , the entire line will be
deleted. <br>
i Enter input mode and insert text before the current
character. <br>
I Insert text before the beginning of the line. Equivalent
to 0i. <br>
[count]P Place the previous text modification before the
cursor. <br>
[count]p Place the previous text modification after the
cursor. <br>
R Enter input mode and replace characters on the screen with
characters you type overlay fashion. <br>
[count]rc Replace the count character(s) starting at the
current cursor position with c, and advance the cursor. <br>
[count]x Delete current character. <br>
[count]X Delete preceding character. <br>
[count]. Repeat the previous text modification command. <br>
[count]&acirc;&frac14; Invert the case of the count
character(s) starting at the current cursor position and
advance the cursor. <br>
[count]_ Causes the count word of the previous command to be
appended and input mode entered. The last word is used if
count is omitted. <br>
* Causes an * to be appended to the current word and file
name generation attempted. If no match is found, it rings
the bell. Otherwise, the word is replaced by <br>
the matching pattern and input mode is entered. &nbsp; <br>
Command or file name completion as described above. <br>
Other Edit Commands <br>
Miscellaneous commands. <br>
[count]ymotion <br>
y[count]motion <br>
Yank current character through character that motion would
move the cursor to and puts them into the delete buffer. The
text and cursor are unchanged. <br>
yy Yanks the entire line. <br>
Y Yanks from current position to end of line. Equivalent to
y$. <br>
u Undo the last text modifying command. <br>
U Undo all the text modifying commands performed on the
line. <br>
[count]v Returns the command hist -e
${VISUAL:-${EDITOR:-vi}} count in the input buffer. If count
is omitted, then the current line is used. <br>
^L Line feed and print current line. Has effect only in
control mode. <br>
^J (New line) Execute the current line, regardless of mode.
<br>
^M (Return) Execute the current line, regardless of mode.
<br>
# If the first character of the command is a #, then this
command deletes this # and each # that follows a newline.
Otherwise, sends the line after inserting a # <br>
in front of each line in the command. Useful for causing the
current line to be inserted in the history as a comment and
uncommenting previously commented com&acirc; <br>
mands in the history file. <br>
[count]= If count is not specified, it generates the list of
matching commands or file names as described above.
Otherwise, the word under the the cursor is replaced by <br>
the count item from the most recently generated command or
file list. If the cursor is not on a word, it is inserted
instead. <br>
@letter Your alias list is searched for an alias by the name
_letter and if an alias of this name is defined, its value
will be inserted on the input queue for process&acirc; <br>
ing. <br>
^V Display version of the shell.</p>

<p style="margin-top: 1em">Built-in Commands. <br>
The following simple-commands are executed in the shell
process. Input/Output redirection is permitted. Unless
otherwise indicated, the output is written on file
descriptor 1 <br>
and the exit status, when there is no syntax error, is zero.
Except for :, true, false, echo, newgrp, and login, all
built-in commands accept -- to indicate end of options. <br>
They also interpret the option --man as a request to display
the man page onto standard error and -? as a help request
which prints a usage message on standard error. Commands
<br>
that are preceded by one or two &acirc;&nbsp; symbols are
special built-in commands and are treated specially in the
following ways: <br>
1. Variable assignment lists preceding the command remain in
effect when the command completes. <br>
2. I/O redirections are processed after variable
assignments. <br>
3. Errors cause a script that contains them to abort. <br>
4. They are not valid function names. <br>
5. Words following a command preceded by
&acirc;&nbsp;&acirc;&nbsp; that are in the format of a
variable assignment are expanded with the same rules as a
variable assignment. This means that tilde <br>
substitution is performed after the = sign and field
splitting and file name generation are not performed. These
are called declaration built-ins.</p>

<p style="margin-top: 1em">&acirc;&nbsp; : [ arg ... ] <br>
The command only expands parameters.</p>

<p style="margin-top: 1em">&acirc;&nbsp; . name [ arg ... ]
<br>
If name is a function defined with the function name
reserved word syntax, the function is executed in the
current environment (as if it had been defined with the
name() <br>
syntax.) Otherwise if name refers to a file, the file is
read in its entirety and the commands are executed in the
current shell environment. The search path specified <br>
by PATH is used to find the directory containing the file.
If any arguments arg are given, they become the positional
parameters while processing the . command and the <br>
original positional parameters are restored upon completion.
Otherwise the positional parameters are unchanged. The exit
status is the exit status of the last command <br>
executed.</p>

<p style="margin-top: 1em">&acirc;&nbsp;&acirc;&nbsp; alias
[ -ptx ] [ name[ =value ] ] ... <br>
alias with no arguments prints the list of aliases in the
form name=value on standard output. The -p option causes the
word alias to be inserted before each one. When <br>
one or more arguments are given, an alias is defined for
each name whose value is given. A trailing space in value
causes the next word to be checked for alias substitu&acirc;
<br>
tion. The obsolete -t option is used to set and list tracked
aliases. The value of a tracked alias is the full pathname
corresponding to the given name. The value <br>
becomes undefined when the value of PATH is reset but the
alias remains tracked. Without the -t option, for each name
in the argument list for which no value is given, <br>
the name and value of the alias is printed. The obsolete -x
option has no effect. The exit status is non-zero if a name
is given, but no value, and no alias has been <br>
defined for the name.</p>

<p style="margin-top: 1em">bg [ job... ] <br>
This command is only on systems that support job control.
Puts each specified job into the background. The current job
is put in the background if job is not specified. <br>
See Jobs for a description of the format of job.</p>

<p style="margin-top: 1em">&acirc;&nbsp; break [ n ] <br>
Exit from the enclosing for, while, until, or select loop,
if any. If n is specified, then break n levels.</p>

<p style="margin-top: 1em">builtin [ -ds ] [ -f file ] [
name ... ] <br>
If name is not specified, and no -f option is specified, the
built-ins are printed on standard output. The -s option
prints only the special built-ins. Otherwise, each <br>
name represents the pathname whose basename is the name of
the built-in. The entry point function name is determined by
prepending b_ to the built-in name. A built-in <br>
specified by a pathname will only be executed when that
pathname would be found during the path search. Built-ins
found in libraries loaded via the .paths file will be <br>
associate with the pathname of the directory containing the
.paths file.</p>

<p style="margin-top: 1em">The ISO C/C++ prototype is
b_mycommand(int argc, char *argv[], void *context) for the
builtin command mycommand where argv is array an of argc
elements and context is an optional <br>
pointer to a Shell_t structure as described in
&lt;ast/shell.h&gt;. <br>
Special built-ins cannot be bound to a pathname or deleted.
The -d option deletes each of the given built-ins. On
systems that support dynamic loading, the -f option names a
<br>
shared library containing the code for built-ins. The shared
library prefix and/or suffix, which depend on the system,
can be omitted. Once a library is loaded, its symbols <br>
become available for subsequent invocations of builtin.
Multiple libraries can be specified with separate
invocations of the builtin command. Libraries are searched
in the <br>
reverse order in which they are specified. When a library is
loaded, it looks for a function in the library whose name is
lib_init() and invokes this function with an argument <br>
of 0.</p>

<p style="margin-top: 1em">cd [ -LP ] [ arg ] <br>
cd [ -LP ] old new <br>
This command can be in either of two forms. In the first
form it changes the current directory to arg. If arg is -
the directory is changed to the previous directory. <br>
The shell variable HOME is the default arg. The variable PWD
is set to the current directory. The shell variable CDPATH
defines the search path for the directory con&acirc; <br>
taining arg. Alternative directory names are separated by a
colon (:). The default path is &lt;null&gt; (specifying the
current directory). Note that the current directory is <br>
specified by a null path name, which can appear immediately
after the equal sign or between the colon delimiters
anywhere else in the path list. If arg begins with a / <br>
then the search path is not used. Otherwise, each directory
in the path is searched for arg. <br>
The second form of cd substitutes the string new for the
string old in the current directory name, PWD, and tries to
change to this new directory. <br>
By default, symbolic link names are treated literally when
finding the directory name. This is equivalent to the -L
option. The -P option causes symbolic links to be <br>
resolved when determining the directory. The last instance
of -L or -P on the command line determines which method is
used. <br>
The cd command may not be executed by rksh. rksh93.</p>

<p style="margin-top: 1em">command [ -pvxV ] name [ arg ...
] <br>
Without the -v or -V options, command executes name with the
arguments given by arg. The -p option causes a default path
to be searched rather than the one defined by the <br>
value of PATH. Functions will not be searched for when
finding name. In addition, if name refers to a special
built-in, none of the special properties associated with
<br>
the leading daggers will be honored. (For example, the
predefined alias redirect=&acirc;&sup2;command
exec&acirc;&sup2; prevents a script from terminating when an
invalid redirection is given.) <br>
With the -x option, if command execution would result in a
failure because there are too many arguments, errno E2BIG,
the shell will invoke command name multiple times <br>
with a subset of the arguments on each invocation. Arguments
that occur prior to the first word that expands to multiple
arguments and after the last word that expands to <br>
multiple arguments will be passed on each invocation. The
exit status will be the maximum invocation exit status. With
the -v option, command is equivalent to the built- <br>
in whence command described below. The -V option causes
command to act like whence -v.</p>

<p style="margin-top: 1em">&acirc;&nbsp; continue [ n ]
<br>
Resume the next iteration of the enclosing for, while,
until, or select loop. If n is specified, then resume at the
n-th enclosing loop.</p>

<p style="margin-top: 1em">disown [ job... ] <br>
Causes the shell not to send a HUP signal to each given job,
or all active jobs if job is omitted, when a login shell
terminates.</p>

<p style="margin-top: 1em">echo [ arg ... ] <br>
When the first arg does not begin with a -, and none of the
arguments contain a then echo prints each of its arguments
separated by a space and terminated by a new- <br>
line. Otherwise, the behavior of echo is system dependent
and print or printf described below should be used. See
echo(1) for usage and description.</p>

<p style="margin-top: 1em">&acirc;&nbsp;&acirc;&nbsp; enum
[ -i ] type[=(value ...) ] <br>
Creates a declaration command named type that is an integer
type that allows one of the specified values as enumeration
names. If =(value ...) is omitted, then type must <br>
be an indexed array variable with at least two elements and
the values are taken from this array variable. If -i is
specified the values are case insensitive.</p>

<p style="margin-top: 1em">&acirc;&nbsp; eval [ arg ... ]
<br>
The arguments are read as input to the shell and the
resulting command(s) executed.</p>

<p style="margin-top: 1em">&acirc;&nbsp; exec [ -c ] [ -a
name ] [ arg ... ] <br>
If arg is given, the command specified by the arguments is
executed in place of this shell without creating a new
process. The -c option causes the environment to be <br>
cleared before applying variable assignments associated with
the exec invocation. The -a option causes name rather than
the first arg, to become argv[0] for the new <br>
process. Input/output arguments may appear and affect the
current process. If arg is not given, the effect of this
command is to modify file descriptors as prescribed by <br>
the input/output redirection list. In this case, any file
descriptor numbers greater than 2 that are opened with this
mechanism are closed when invoking another program.</p>

<p style="margin-top: 1em">&acirc;&nbsp; exit [ n ] <br>
Causes the shell to exit with the exit status specified by
n. The value will be the least significant 8 bits of the
specified status. If n is omitted, then the exit sta&acirc;
<br>
tus is that of the last command executed. An end-of-file
will also cause the shell to exit except for a shell which
has the ignoreeof option (see set below) turned on.</p>

<p style="margin-top: 1em">&acirc;&nbsp;&acirc;&nbsp;
export [ -p ] [ name[=value] ] ... <br>
If name is not given, the names and values of each variable
with the export attribute are printed with the values quoted
in a manner that allows them to be re-input. The <br>
export command is the same as typeset -x except that if you
use export within a function, no local variable is created.
The -p option causes the word export to be <br>
inserted before each one. Otherwise, the given names are
marked for automatic export to the environment of
subsequently-executed commands.</p>

<p style="margin-top: 1em">false Does nothing, and exits 1.
Used with until for infinite loops.</p>

<p style="margin-top: 1em">fg [ job... ] <br>
This command is only on systems that support job control.
Each job specified is brought to the foreground and waited
for in the specified order. Otherwise, the current <br>
job is brought into the foreground. See Jobs for a
description of the format of job.</p>

<p style="margin-top: 1em">getconf [ name [ pathname ] ]
<br>
Prints the current value of the configuration parameter
given by name. The configuration parameters are defined by
the IEEE POSIX 1003.1 and IEEE POSIX 1003.2 standards. <br>
(See pathconf(2) and sysconf(2).) The pathname argument is
required for parameters whose value depends on the location
in the file system. If no arguments are given, <br>
getconf prints the names and values of the current
configuration parameters. The pathname / is used for each of
the parameters that requires pathname.</p>

<p style="margin-top: 1em">getopts [ -a name ] optstring
vname [ arg ... ] <br>
Checks arg for legal options. If arg is omitted, the
positional parameters are used. An option argument begins
with a + or a -. An option not beginning with + or - or <br>
the argument -- ends the options. Options beginning with +
are only recognized when optstring begins with a +.
optstring contains the letters that getopts recognizes. <br>
If a letter is followed by a :, that option is expected to
have an argument. The options can be separated from the
argument by blanks. The option -? causes getopts to <br>
generate a usage message on standard error. The -a argument
can be used to specify the name to use for the usage
message, which defaults to $0. <br>
getopts places the next option letter it finds inside
variable vname each time it is invoked. The option letter
will be prepended with a + when arg begins with a +. The
<br>
index of the next arg is stored in OPTIND. The option
argument, if any, gets stored in OPTARG. <br>
A leading : in optstring causes getopts to store the letter
of an invalid option in OPTARG, and to set vname to ? for an
unknown option and to : when a required option <br>
argument is missing. Otherwise, getopts prints an error
message. The exit status is non-zero when there are no more
options. <br>
There is no way to specify any of the options :, +, -, ?, [,
and ]. The option # can only be specified as the first
option.</p>

<p style="margin-top: 1em">hist [ -e ename ] [ -nlr ] [
first [ last ] ] <br>
hist -s [ old=new ] [ command ] <br>
In the first form, a range of commands from first to last is
selected from the last HISTSIZE commands that were typed at
the terminal. The arguments first and last may be <br>
specified as a number or as a string. A string is used to
locate the most recent command starting with the given
string. A negative number is used as an offset to the <br>
current command number. If the -l option is selected, the
commands are listed on standard output. Otherwise, the
editor program ename is invoked on a file containing <br>
these keyboard commands. If ename is not supplied, then the
value of the variable HISTEDIT is used. If HISTEDIT is not
set, then FCEDIT (default /bin/ed) is used as the <br>
editor. When editing is complete, the edited command(s) is
executed if the changes have been saved. If last is not
specified, then it will be set to first. If first is <br>
not specified, the default is the previous command for
editing and -16 for listing. The option -r reverses the
order of the commands and the option -n suppresses command
<br>
numbers when listing. In the second form, command is
interpreted as first described above and defaults to the
last command executed. The resulting command is executed
<br>
after the optional substitution old=new is performed.</p>

<p style="margin-top: 1em">jobs [ -lnp ] [ job ... ] <br>
Lists information about each given job; or all active jobs
if job is omitted. The -l option lists process ids in
addition to the normal information. The -n option only <br>
displays jobs that have stopped or exited since last
notified. The -p option causes only the process group to be
listed. See Jobs for a description of the format of job.</p>

<p style="margin-top: 1em">kill [ -s signame ] job ... <br>
kill [ -n signum ] job ... <br>
kill -Ll [ sig ... ] <br>
Sends either the TERM (terminate) signal or the specified
signal to the specified jobs or processes. Signals are
either given by number with the -n option or by name with
<br>
the -s option (as given in &lt;signal.h&gt;, stripped of the
prefix &lsquo;&lsquo;SIG&rsquo;&rsquo; with the exception
that SIGCLD is named CHLD). For backward compatibility, the
n and s can be omit&acirc; <br>
ted and the number or name placed immediately after the -.
If the signal being sent is TERM (terminate) or HUP
(hangup), then the job or process will be sent a CONT
(con&acirc; <br>
tinue) signal if it is stopped. The argument job can be the
process id of a process that is not a member of one of the
active jobs. See Jobs for a description of the <br>
format of job. In the third form, kill -l, or kill -L, if
sig is not specified, the signal names are listed. The -l
option list only the signal names. -L options lists <br>
each signal name and corresponding number. Otherwise, for
each sig that is a name, the corresponding signal number is
listed. For each sig that is a number, the signal <br>
name corresponding to the least significant 8 bits of sig is
listed.</p>

<p style="margin-top: 1em">let arg ... <br>
Each arg is a separate arithmetic expression to be
evaluated. let only recognizes octal constants starting with
0 when the set option letoctal is on. See Arithmetic <br>
Evaluation above, for a description of arithmetic expression
evaluation. <br>
The exit status is 0 if the value of the last expression is
non-zero, and 1 otherwise.</p>

<p style="margin-top: 1em">&acirc;&nbsp; newgrp [ arg ... ]
<br>
Equivalent to exec /bin/newgrp arg ....</p>

<p style="margin-top: 1em">print [ -CRenprsv ] [ -u unit] [
-f format ] [ arg ... ] <br>
With no options or with option - or --, each arg is printed
on standard output. The -f option causes the arguments to be
printed as described by printf. In this case, <br>
any e, n, r, R options are ignored. Otherwise, unless the
-C, -R, -r, or -v are specified, the following escape
conventions will be applied: <br>
The alert character (ascii 07). <br>
The backspace character (ascii 010). <br>
The formfeed character (ascii 014). <br>
The new-line character (ascii 012). <br>
The carriage return character (ascii 015). <br>
The tab character (ascii 011). <br>
The vertical tab character (ascii 013). &nbsp; <br>
The escape character (ascii 033). <br>
\ The backslash character . <br>
x The character defined by the 1, 2, or 3-digit octal string
given by x.</p>

<p style="margin-top: 1em">The -R option will print all
subsequent arguments and options other than -n. The -e
causes the above escape conventions to be applied. This is
the default behavior. It <br>
reverses the effect of an earlier -r. The -p option causes
the arguments to be written onto the pipe of the process
spawned with &acirc;&ordf;&amp; instead of standard output.
The -v <br>
option treats each arg as a variable name and writes the
value in the printf %B format. The -C option treats each arg
as a variable name and writes the value in the <br>
printf %#B format. The -s option causes the arguments to be
written onto the history file instead of standard output.
The -u option can be used to specify a one digit <br>
file descriptor unit number unit on which the output will be
placed. The default is 1. If the option -n is used, no
new-line is added to the output.</p>

<p style="margin-top: 1em">printf format [ arg ... ] <br>
The arguments arg are printed on standard output in
accordance with the ANSI-C formatting rules associated with
the format string format. If the number of arguments <br>
exceeds the number of format specifications, the format
string is reused to format remaining arguments. The
following extensions can also be used: <br>
%b A %b format can be used instead of %s to cause escape
sequences in the corresponding arg to be expanded as
described in print. <br>
%B A %B option causes each of the arguments to be treated as
variable names and the binary value of variable will be
printed. The alternate flag # causes a compound <br>
variable to be output on a single line. This is most useful
for compound variables and variables whose attribute is -b.
<br>
%H A %H format can be used instead of %s to cause characters
in arg that are special in HTML and XML to be output as
their entity name. The alternate flag # formats <br>
the output for use as a URI. <br>
%P A %P format can be used instead of %s to cause arg to be
interpreted as an extended regular expression and be printed
as a shell pattern. <br>
%R A %R format can be used instead of %s to cause arg to be
interpreted as a shell pattern and to be printed as an
extended regular expression. <br>
%q A %q format can be used instead of %s to cause the
resulting string to be quoted in a manner than can be
reinput to the shell. When q is preceded by the
alterna&acirc; <br>
tive format specifier, #, the string is quoted in manner
suitable as a field in a .csv format file. <br>
%(date-format)T <br>
A %(date-format)T format can be use to treat an argument as
a date/time string and to format the date/time according to
the date-format as defined for the date(1) <br>
command. <br>
%Z A %Z format will output a byte whose value is 0. <br>
%d The precision field of the %d format can be followed by a
. and the output base. In this case, the # flag character
causes base# to be prepended. <br>
# The # flag, when used with the %d format without an output
base, displays the output in powers of 1000 indicated by one
of the following suffixes: k M G T P E, and <br>
when used with the %i format displays the output in powers
of 1024 indicated by one of the following suffixes: Ki Mi Gi
Ti Pi Ei. <br>
= The = flag centers the output within the specified field
width. <br>
L The L flag, when used with the %c or %s formats, treats
precision as character width instead of byte count. <br>
, The , flag, when used with the %d or %f formats, separates
groups of digits with the grouping delimiter (, on groups of
3 in the C locale.)</p>

<p style="margin-top: 1em">pwd [ -LP ] <br>
Outputs the value of the current working directory. The -L
option is the default; it prints the logical name of the
current directory. If the -P option is given, all <br>
symbolic links are resolved from the name. The last instance
of -L or -P on the command line determines which method is
used.</p>

<p style="margin-top: 1em">read [ -ACSprsv ] [ -d delim] [
-n n] [ [ -N n] [ [ -t timeout] [ -u unit] [ vname?prompt ]
[ vname ... ] <br>
The shell input mechanism. One line is read and is broken up
into fields using the characters in IFS as separators. The
escape character, is used to remove any spe&acirc; <br>
cial meaning for the next character and for line
continuation. The -d option causes the read to continue to
the first character of delim rather than new-line. The -n
<br>
option causes at most n bytes to read rather a full line but
will return when reading from a slow device as soon as any
characters have been read. The -N option causes <br>
exactly n to be read unless an end-of-file has been
encountered or the read times out because of the -t option.
In raw mode, -r, the &nbsp;character is not treated
specially. <br>
The first field is assigned to the first vname, the second
field to the second vname, etc., with leftover fields
assigned to the last vname. When vname has the binary <br>
attribute and -n or -N is specified, the bytes that are read
are stored directly into the variable. If the -v is
specified, then the value of the first vname will be used
<br>
as a default value when reading from a terminal device. The
-A option causes the variable vname to be unset and each
field that is read to be stored in successive ele&acirc;
<br>
ments of the indexed array vname. The -C option causes the
variable vname to be read as a compound variable. Blanks
will be ignored when finding the beginning open <br>
parenthesis. The -S option causes the line to be treated
like a record in a .csv format file so that double quotes
can be used to allow the delimiter character and the <br>
new-line character to appear within a field. The -p option
causes the input line to be taken from the input pipe of a
process spawned by the shell using &acirc;&ordf;&amp;. If
the -s <br>
option is present, the input will be saved as a command in
the history file. The option -u can be used to specify a one
digit file descriptor unit unit to read from. The <br>
file descriptor can be opened with the exec special built-in
command. The default value of unit n is 0. The option -t is
used to specify a timeout in seconds when read&acirc; <br>
ing from a terminal or pipe. If vname is omitted, then REPLY
is used as the default vname. An end-of-file with the -p
option causes cleanup for this process so that <br>
another can be spawned. If the first argument contains a ?,
the remainder of this word is used as a prompt on standard
error when the shell is interactive. The exit sta&acirc;
<br>
tus is 0 unless an end-of-file is encountered or read has
timed out.</p>

<p style="margin-top: 1em">&acirc;&nbsp;&acirc;&nbsp;
readonly [ -p ] [ vname[=value] ] ... <br>
If vname is not given, the names and values of each variable
with the readonly attribute is printed with the values
quoted in a manner that allows them to be re-inputted. <br>
The -p option causes the word readonly to be inserted before
each one. Otherwise, the given vnames are marked readonly
and these names cannot be changed by subsequent <br>
assignment. When defining a type, if the value of a readonly
sub-variable is not defined the value is required when
creating each instance.</p>

<p style="margin-top: 1em">&acirc;&nbsp; return [ n ] <br>
Causes a shell function or . script to return to the
invoking script with the exit status specified by n. The
value will be the least significant 8 bits of the specified
<br>
status. If n is omitted, then the return status is that of
the last command executed. If return is invoked while not in
a function or a . script, then it behaves the <br>
same as exit.</p>

<p style="margin-top: 1em">&acirc;&nbsp; set [
&Acirc;&plusmn;BCGabefhkmnoprstuvx ] [ &Acirc;&plusmn;o [
option ] ] ... [ &Acirc;&plusmn;A vname ] [ arg ... ] <br>
The options for this command have meaning as follows: <br>
-A Array assignment. Unset the variable vname and assign
values sequentially from the arg list. If +A is used, the
variable vname is not unset first. <br>
-B Enable brace pattern field generation. This is the
default behavior. <br>
-B Enable brace group expansion. On by default. <br>
-C Prevents redirection &gt; from truncating existing files.
Files that are created are opened with the O_EXCL mode.
Requires &gt;&acirc;&ordf; to truncate a file when turned
on. <br>
-G Causes the pattern &acirc;&acirc; by itself to match
files and zero or more directories and sub-directories when
used for file name generation. If followed by a / only
direc&acirc; <br>
tories and sub-directories are matched. <br>
-a All subsequent variables that are defined are
automatically exported. <br>
-b Prints job completion messages as soon as a background
job changes state rather than waiting for the next prompt.
<br>
-e Unless contained in a &acirc;&ordf;&acirc;&ordf; or
&amp;&amp; command, or the command following an if while or
until command or in the pipeline following !, if a command
has a non-zero exit sta&acirc; <br>
tus, execute the ERR trap, if set, and exit. This mode is
disabled while reading profiles. <br>
-f Disables file name generation. <br>
-h Each command becomes a tracked alias when first
encountered. <br>
-k (Obsolete). All variable assignment arguments are placed
in the environment for a command, not just those that
precede the command name. <br>
-m Background jobs will run in a separate process group and
a line will print upon completion. The exit status of
background jobs is reported in a completion mes&acirc; <br>
sage. On systems with job control, this option is turned on
automatically for interactive shells. <br>
-n Read commands and check them for syntax errors, but do
not execute them. Ignored for interactive shells. <br>
-o The following argument can be one of the following option
names: <br>
allexport <br>
Same as -a. <br>
errexit Same as -e. <br>
bgnice All background jobs are run at a lower priority. This
is the default mode. <br>
braceexpand <br>
Same as -B. <br>
emacs Puts you in an emacs style in-line editor for command
entry. <br>
globstar <br>
Same as -G. <br>
gmacs Puts you in a gmacs style in-line editor for command
entry. <br>
ignoreeof <br>
The shell will not exit on end-of-file. The command exit
must be used. <br>
keyword Same as -k. <br>
letoctal <br>
The let command allows octal constants starting with 0. <br>
markdirs <br>
All directory names resulting from file name generation have
a trailing / appended. <br>
monitor Same as -m. <br>
multiline <br>
The built-in editors will use multiple lines on the screen
for lines that are longer than the width of the screen. This
may not work for all terminals. <br>
noclobber <br>
Same as -C. <br>
noexec Same as -n. <br>
noglob Same as -f. <br>
nolog Do not save function definitions in the history file.
<br>
notify Same as -b. <br>
nounset Same as -u. <br>
pipefail <br>
A pipeline will not complete until all components of the
pipeline have completed, and the return value will be the
value of the last non-zero command to <br>
fail or zero if no command has failed. <br>
showme When enabled, simple commands or pipelines preceded
by a semicolon (;) will be displayed as if the xtrace option
were enabled but will not be executed. <br>
Otherwise, the leading ; will be ignored. <br>
privileged <br>
Same as -p. <br>
verbose Same as -v. <br>
trackall <br>
Same as -h. <br>
vi Puts you in insert mode of a vi style in-line editor
until you hit the escape character 033. This puts you in
control mode. A return sends the line. <br>
viraw Each character is processed as it is typed in vi mode.
<br>
xtrace Same as -x. <br>
If no option name is supplied, then the current option
settings are printed. <br>
-p Disables processing of the $HOME/.profile file and uses
the file /etc/suid_profile instead of the ENV file. This
mode is on whenever the effective uid (gid) is <br>
not equal to the real uid (gid). Turning this off causes the
effective uid and gid to be set to the real uid and gid.
<br>
-r Enables the restricted shell. This option cannot be unset
once set. <br>
-s Sort the positional parameters lexicographically. <br>
-t (Obsolete). Exit after reading and executing one command.
<br>
-u Treat unset parameters as an error when substituting.
<br>
-v Print shell input lines as they are read. <br>
-x Print commands and their arguments as they are executed.
<br>
-- Do not change any of the options; useful in setting $1 to
a value beginning with -. If no arguments follow this option
then the positional parameters are unset.</p>

<p style="margin-top: 1em">As an obsolete feature, if the
first arg is - then the -x and -v options are turned off and
the next arg is treated as the first argument. Using +
rather than - causes <br>
these options to be turned off. These options can also be
used upon invocation of the shell. The current set of
options may be found in $-. Unless -A is specified, the <br>
remaining arguments are positional parameters and are
assigned, in order, to $1 $2 .... If no arguments are given,
then the names and values of all variables are printed <br>
on the standard output.</p>

<p style="margin-top: 1em">&acirc;&nbsp; shift [ n ] <br>
The positional parameters from $n+1 ... are renamed $1 ... ,
default n is 1. The parameter n can be any arithmetic
expression that evaluates to a non-negative number <br>
less than or equal to $#.</p>

<p style="margin-top: 1em">sleep seconds <br>
Suspends execution for the number of decimal seconds or
fractions of a second given by seconds.</p>

<p style="margin-top: 1em">&acirc;&nbsp; trap [ -p ] [
action ] [ sig ] ... <br>
The -p option causes the trap action associated with each
trap as specified by the arguments to be printed with
appropriate quoting. Otherwise, action will be processed
<br>
as if it were an argument to eval when the shell receives
signal(s) sig. Each sig can be given as a number or as the
name of the signal. Trap commands are executed in <br>
order of signal number. Any attempt to set a trap on a
signal that was ignored on entry to the current shell is
ineffective. If action is omitted and the first sig is a
<br>
number, or if action is -, then the trap(s) for each sig are
reset to their original values. If action is the null string
then this signal is ignored by the shell and by <br>
the commands it invokes. If sig is ERR then action will be
executed whenever a command has a non-zero exit status. If
sig is DEBUG then action will be executed before <br>
each command. The variable .sh.command will contain the
contents of the current command line when action is running.
If the exit status of the trap is 2 the command will <br>
not be executed. If the exit status of the trap is 255 and
inside a function or a dot script, the function or dot
script will return. If sig is 0 or EXIT and the trap <br>
statement is executed inside the body of a function defined
with the function name syntax, then the command action is
executed after the function completes. If sig is 0 <br>
or EXIT for a trap set outside any function then the command
action is executed on exit from the shell. If sig is KEYBD,
then action will be executed whenever a key is <br>
read while in emacs, gmacs, or vi mode. The trap command
with no arguments prints a list of commands associated with
each signal number.</p>

<p style="margin-top: 1em">An exit or return without an
argument in a trap action will preserve the exit status of
the command that invoked the trap.</p>

<p style="margin-top: 1em">true Does nothing, and exits 0.
Used with while for infinite loops.</p>

<p style="margin-top: 1em">&acirc;&nbsp;&acirc;&nbsp;
typeset [ &Acirc;&plusmn;ACHSfblmnprtux ] [
&Acirc;&plusmn;EFLRXZi[n] ] [ +-M [ mapname ] ] [ -T [
tname=(assign_list) ] ] [ -h str ] [ -a [type] ] [
vname[=value ] ] ... <br>
Sets attributes and values for shell variables and
functions. When invoked inside a function defined with the
function name syntax, a new instance of the variable vname
<br>
is created, and the variable&rsquo;s value and type are
restored when the function completes. The following list of
attributes may be specified: <br>
-A Declares vname to be an associative array. Subscripts are
strings rather than arithmetic expressions. <br>
-C causes each vname to be a compound variable. value names
a compound variable it is copied into vname. Otherwise, it
unsets each vname. <br>
-a Declares vname to be an indexed array. If type is
specified, it must be the name of an enumeration type
created with the enum command and it allows enumeration <br>
constants to be used as subscripts. <br>
-E Declares vname to be a double precision floating point
number. If n is non-zero, it defines the number of
significant figures that are used when expanding vname. <br>
Otherwise, ten significant figures will be used. <br>
-F Declares vname to be a double precision floating point
number. If n is non-zero, it defines the number of places
after the decimal point that are used when expand&acirc;
<br>
ing vname. Otherwise ten places after the decimal point will
be used. <br>
-H This option provides UNIX to host-name file mapping on
non-UNIX machines. <br>
-L Left justify and remove leading blanks from value. If n
is non-zero, it defines the width of the field, otherwise it
is determined by the width of the value of <br>
first assignment. When the variable is assigned to, it is
filled on the right with blanks or truncated, if necessary,
to fit into the field. The -R option is <br>
turned off. <br>
-M Use the character mapping mapping defined by wctrans(3).
such as tolower and toupper when assigning a value to each
of the specified operands. When mapping is <br>
specified and there are not operands, all variables that use
this mapping are written to standard output. When mapping is
omitted and there are no operands, all <br>
mapped variables are written to standard output. <br>
-R Right justify and fill with leading blanks. If n is
non-zero, it defines the width of the field, otherwise it is
determined by the width of the value of first <br>
assignment. The field is left filled with blanks or
truncated from the end if the variable is reassigned. The -L
option is turned off. <br>
-S When used within the assign_list of a type definition, it
causes the specified sub-variable to be shared by all
instances of the type. When used inside a function <br>
defined with the function reserved word, the specified
variables will have function static scope. Otherwise, the
variable is unset prior to processing the assign&acirc; <br>
ment list. <br>
-T If followed by tname, it creates a type named by tname
using the compound assignment assign_list to tname.
Otherwise, it writes all the type definitions to stan&acirc;
<br>
dard output. <br>
-X Declares vname to be a double precision floating point
number and expands using the %a format of ISO-C99. If n is
non-zero, it defines the number of hex digits <br>
after the radix point that is used when expanding vname. The
default is 10. <br>
-Z Right justify and fill with leading zeros if the first
non-blank character is a digit and the -L option has not
been set. Remove leading zeros if the -L option is <br>
also set. If n is non-zero, it defines the width of the
field, otherwise it is determined by the width of the value
of first assignment. <br>
-f The names refer to function names rather than variable
names. No assignments can be made and the only other valid
options are -S, -t, -u and -x. The -S can be <br>
used with discipline functions defined in a type to indicate
that the function is static. For a static function, the same
method will be used by all instances of <br>
that type no matter which instance references it. In
addition, it can only use value of variables from the
original type definition. These discipline functions <br>
cannot be redefined in any type instance. The -t option
turns on execution tracing for this function. The -u option
causes this function to be marked undefined. <br>
The FPATH variable will be searched to find the function
definition when the function is referenced. If no options
other than -f is specified, then the function <br>
definition will be displayed on standard output. If +f is
specified, then a line containing the function name followed
by a shell comment containing the line num&acirc; <br>
ber and path name of the file where this function was
defined, if any, is displayed. The exit status can be used
to determine whether the function is defined so <br>
that typeset -f .sh.math.name will return 0 when math
function name is defined and non-zero otherwise. <br>
-b The variable can hold any number of bytes of data. The
data can be text or binary. The value is represented by the
base64 encoding of the data. If -Z is also <br>
specified, the size in bytes of the data in the buffer will
be determined by the size associated with the -Z. If the
base64 string assigned results in more data, <br>
it will be truncated. Otherwise, it will be filled with
bytes whose value is zero. The printf format %B can be used
to output the actual data in this buffer <br>
instead of the base64 encoding of the data. <br>
-h Used within type definitions to add information when
generating information about the sub-variable on the man
page. It is ignored when used outside of a type defi&acirc;
<br>
nition. When used with -f the information is associated with
the corresponding discipline function. <br>
-i Declares vname to be represented internally as integer.
The right hand side of an assignment is evaluated as an
arithmetic expression when assigning to an integer. <br>
If n is non-zero, it defines the output arithmetic base,
otherwise the output base will be ten. <br>
-l Used with -i, -E or -F, to indicate long integer, or long
float. Otherwise, all upper-case characters are converted to
lower-case. The upper-case option, -u, is <br>
turned off. Equivalent to -M tolower . <br>
-m moves or renames the variable. The value is the name of a
variable whose value will be moved to vname. The original
variable will be unset. Cannot be used with <br>
any other options. <br>
-n Declares vname to be a reference to the variable whose
name is defined by the value of variable vname. This is
usually used to reference a variable inside a func&acirc;
<br>
tion whose name has been passed as an argument. Cannot be
used with any other options. <br>
-p The name, attributes and values for the given vnames are
written on standard output in a form that can be used as
shell input. If +p is specified, then the values <br>
are not displayed. <br>
-r The given vnames are marked readonly and these names
cannot be changed by subsequent assignment. <br>
-t Tags the variables. Tags are user definable and have no
special meaning to the shell. <br>
-u When given along with -i, specifies unsigned integer.
Otherwise, all lower-case characters are converted to
upper-case. The lower-case option, -l, is turned off. <br>
Equivalent to -M toupper . <br>
-x The given vnames are marked for automatic export to the
environment of subsequently-executed commands. Variables
whose names contain a . cannot be exported.</p>

<p style="margin-top: 1em">The -i attribute cannot be
specified along with -R, -L, -Z, or -f.</p>

<p style="margin-top: 1em">Using + rather than - causes
these options to be turned off. If no vname arguments are
given, a list of vnames (and optionally the values) of the
variables is printed. <br>
(Using + rather than - keeps the values from being printed.)
The -p option causes typeset followed by the option letters
to be printed before each name rather than the <br>
names of the options. If any option other than -p is given,
only those variables which have all of the given options are
printed. Otherwise, the vnames and attributes of <br>
all variables that have attributes are printed.</p>

<p style="margin-top: 1em">ulimit [ -HSacdfmnpstv ] [ limit
] <br>
Set or display a resource limit. The available resource
limits are listed below. Many systems do not support one or
more of these limits. The limit for a specified <br>
resource is set when limit is specified. The value of limit
can be a number in the unit specified below with each
resource, or the value unlimited. The -H and -S options <br>
specify whether the hard limit or the soft limit for the
given resource is set. A hard limit cannot be increased once
it is set. A soft limit can be increased up to the <br>
value of the hard limit. If neither the H nor S option is
specified, the limit applies to both. The current resource
limit is printed when limit is omitted. In this <br>
case, the soft limit is printed unless H is specified. When
more than one resource is specified, then the limit name and
unit is printed before the value. <br>
-a Lists all of the current resource limits. <br>
-c The number of 512-byte blocks on the size of core dumps.
<br>
-d The number of K-bytes on the size of the data area. <br>
-f The number of 512-byte blocks on files that can be
written by the current process or by child processes (files
of any size may be read). <br>
-m The number of K-bytes on the size of physical memory.
<br>
-n The number of file descriptors plus 1. <br>
-p The number of 512-byte blocks for pipe buffering. <br>
-s The number of K-bytes on the size of the stack area. <br>
-t The number of CPU seconds to be used by each process.
<br>
-v The number of K-bytes for virtual memory.</p>

<p style="margin-top: 1em">If no option is given, -f is
assumed.</p>

<p style="margin-top: 1em">umask [ -S ] [ mask ] <br>
The user file-creation mask is set to mask (see umask(2)).
mask can either be an octal number or a symbolic value as
described in chmod(1). If a symbolic value is given, <br>
the new umask value is the complement of the result of
applying mask to the complement of the previous umask value.
If mask is omitted, the current value of the mask is <br>
printed. The -S option causes the mode to be printed as a
symbolic value. Otherwise, the mask is printed in octal.</p>

<p style="margin-top: 1em">&acirc;&nbsp; unalias [ -a ]
name ... <br>
The aliases given by the list of names are removed from the
alias list. The -a option causes all the aliases to be
unset.</p>

<p style="margin-top: 1em">&acirc;&nbsp;unset [ -fnv ]
vname ... <br>
The variables given by the list of vnames are unassigned,
i.e., except for sub-variables within a type, their values
and attributes are erased. For sub-variables of a <br>
type, the values are reset to the default value from the
type definition. Readonly variables cannot be unset. If the
-f option is set, then the names refer to function <br>
names. If the -v option is set, then the names refer to
variable names. The -f option overrides -v. If -n is set and
name is a name reference, then name will be unset <br>
rather than the variable that it references. The default is
equivalent to -v. Unsetting LINENO, MAILCHECK, OPTARG,
OPTIND, RANDOM, SECONDS, TMOUT, and _ removes their <br>
special meaning even if they are subsequently assigned
to.</p>

<p style="margin-top: 1em">wait [ job ... ] <br>
Wait for the specified job and report its termination
status. If job is not given, then all currently active child
processes are waited for. The exit status from this <br>
command is that of the last process waited for if job is
specified; otherwise it is zero. See Jobs for a description
of the format of job.</p>

<p style="margin-top: 1em">whence [ -afpv ] name ... <br>
For each name, indicate how it would be interpreted if used
as a command name. <br>
The -v option produces a more verbose report. The -f option
skips the search for functions. The -p option does a path
search for name even if name is an alias, a func&acirc; <br>
tion, or a reserved word. The -p option turns off the -v
option. The -a option is similar to the -v option but causes
all interpretations of the given name to be <br>
reported.</p>

<p style="margin-top: 1em">Invocation. <br>
If the shell is invoked by exec(2), and the first character
of argument zero ($0) is -, then the shell is assumed to be
a login shell and commands are read from /etc/profile and
<br>
then from either .profile in the current directory or
$HOME/.profile, if either file exists. Next, for interactive
shells, commands are read from the file named by performing
<br>
parameter expansion, command substitution, and arithmetic
substitution on the value of the environment variable ENV if
the file exists. If the -s option is not present and arg
<br>
and a file by the name of arg exists, then it reads and
executes this script. Otherwise, if the first arg does not
contain a /, a path search is performed on the first arg to
<br>
determine the name of the script to execute. The script arg
must have execute permission and any setuid and setgid
settings will be ignored. If the script is not found on the
<br>
path, arg is processed as if it named a built-in command or
function. Commands are then read as described below; the
following options are interpreted by the shell when it is
<br>
invoked:</p>

<p style="margin-top: 1em">-D Do not execute the script,
but output the set of double quoted strings preceded by a $.
These strings are needed for localization of the script to
different locales. <br>
-E Reads the file named by the ENV variable or by
$HOME/.kshrc if not defined after the profiles. <br>
-c If the -c option is present, then commands are read from
the first arg. Any remaining arguments become positional
parameters starting at 0. <br>
-s If the -s option is present or if no arguments remain,
then commands are read from the standard input. Shell
output, except for the output of the Special Commands <br>
listed above, is written to file descriptor 2. <br>
-i If the -i option is present or if the shell input and
error output are attached to a terminal (as told by
tcgetattr(2)), then this shell is interactive. In this case
<br>
TERM is ignored (so that kill 0 does not kill an interactive
shell) and INTR is caught and ignored (so that wait is ). In
all cases, QUIT is ignored by the shell. <br>
-r If the -r option is present, the shell is a restricted
shell. <br>
-D A list of all double quoted strings that are preceded by
a $ will be printed on standard output and the shell will
exit. This set of strings will be subject to lan&acirc; <br>
guage translation when the locale is not C or POSIX. No
commands will be executed.</p>

<p style="margin-top: 1em">-P If -P or -o profile is
present, the shell is a profile shell (see pfexec(1)).</p>

<p style="margin-top: 1em">-R filename <br>
The -R filename option is used to generate a cross reference
database that can be used by a separate utility to find
definitions and references for variables and com&acirc; <br>
mands. The filename argument specifies the generated
database. A script file must be provided on the command line
as well.</p>

<p style="margin-top: 1em">The remaining options and
arguments are described under the set command above. An
optional - as the first argument is ignored.</p>

<p style="margin-top: 1em">Rksh Only. <br>
Rksh is used to set up login names and execution
environments whose capabilities are more controlled than
those of the standard shell. The actions of rksh are
identical to those <br>
of ksh, except that the following are disallowed: <br>
Unsetting the restricted option. <br>
changing directory (see cd(1)), <br>
setting or unsetting the value or attributes of SHELL, ENV,
FPATH, or PATH, <br>
specifying path or command names containing /, <br>
redirecting output (&gt;, &gt;|, &lt;&gt;, and &gt;&gt;).
<br>
adding or deleting built-in commands. <br>
using command -p to invoke a command.</p>

<p style="margin-top: 1em">The restrictions above are
enforced after .profile and the ENV files are
interpreted.</p>

<p style="margin-top: 1em">When a command to be executed is
found to be a shell procedure, rksh invokes ksh to execute
it. Thus, it is possible to provide to the end-user shell
procedures that have access <br>
to the full power of the standard shell, while imposing a
limited menu of commands; this scheme assumes that the
end-user does not have write and execute permissions in the
same <br>
directory.</p>

<p style="margin-top: 1em">The net effect of these rules is
that the writer of the .profile has complete control over
user actions, by performing guaranteed setup actions and
leaving the user in an appro&acirc; <br>
priate directory (probably not the login directory).</p>

<p style="margin-top: 1em">The system administrator often
sets up a directory of commands (e.g., /usr/rbin) that can
be safely invoked by rksh.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
Errors detected by the shell, such as syntax errors, cause
the shell to return a non-zero exit status. If the shell is
being used non-interactively, then execution of the shell
<br>
file is abandoned unless the error occurs inside a subshell
in which case the subshell is abandoned. Otherwise, the
shell returns the exit status of the last command executed
<br>
(see also the exit command above). Run time errors detected
by the shell are reported by printing the command or
function name and the error condition. If the line number
that <br>
the error occurred on is greater than one, then the line
number is also printed in square brackets ([]) after the
command or function name.</p>

<p style="margin-top: 1em">FILES <br>
/etc/profile <br>
The system wide initialization file, executed for login
shells.</p>

<p style="margin-top: 1em">$HOME/.profile <br>
The personal initialization file, executed for login shells
after /etc/profile.</p>

<p style="margin-top: 1em">$HOME/..kshrc <br>
Default personal initialization file, executed for
interactive shells when ENV is not set.</p>

<p style="margin-top: 1em">/etc/suid_profile <br>
Alternative initialization file, executed instead of the
personal initialization file when the real and effective
user or group id do not match.</p>

<p style="margin-top: 1em">/dev/null <br>
NULL device</p>

<p style="margin-top: 1em">SEE ALSO <br>
cat(1), cd(1), chmod(1), cut(1), egrep(1), echo(1),
emacs(1), env(1), fgrep(1), gmacs(1), grep(1), newgrp(1),
pfexec(1), stty(1), test(1), umask(1), vi(1), dup(2),
exec(2), <br>
fork(2), getpwnam(3), ioctl(2), lseek(2), paste(1),
pathconf(2), pipe(2), sysconf(2), umask(2), ulimit(2),
wait(2), wctrans(3), rand(3), a.out(5), profile(5),
environ(7).</p>

<p style="margin-top: 1em">Morris I. Bolsky and David G.
Korn, The New KornShell Command and Programming Language,
Prentice Hall, 1995.</p>

<p style="margin-top: 1em">POSIX - Part 2: Shell and
Utilities, IEEE Std 1003.2-1992, ISO/IEC 9945-2, IEEE,
1993.</p>

<p style="margin-top: 1em">CAVEATS <br>
If a command is executed, and then a command with the same
name is installed in a directory in the search path before
the directory where the original command was found, the <br>
shell will continue to exec the original command. Use the -t
option of the alias command to correct this situation.</p>

<p style="margin-top: 1em">Some very old shell scripts
contain a ^ as a synonym for the pipe character
&acirc;&ordf;.</p>

<p style="margin-top: 1em">Using the hist built-in command
within a compound command will cause the whole command to
disappear from the history file.</p>

<p style="margin-top: 1em">The built-in command . file
reads the whole file before any commands are executed.
Therefore, alias and unalias commands in the file will not
apply to any commands defined in <br>
the file.</p>

<p style="margin-top: 1em">Traps are not processed while a
job is waiting for a foreground process. Thus, a trap on
CHLD won&rsquo;t be executed until the foreground job
terminates.</p>

<p style="margin-top: 1em">It is a good idea to leave a
space after the comma operator in arithmetic expressions to
prevent the comma from being interpreted as the decimal
point character in certain <br>
locales.</p>
 
<p style="margin-top: 1em">KSH(1)</p>
<hr>
</body>
</html>
