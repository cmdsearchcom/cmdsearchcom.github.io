<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:40:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>TRACEVIEW(1) Android SDK Tools TRACEVIEW(1)</p>

<p style="margin-top: 1em">NAME <br>
traceview - a graphical viewer for execution logs saved by
Android application.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
traceview [-r] trace</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Traceview is a graphical viewer for execution logs that you
create by using the Debug class to log tracing information
in your code. Traceview can help you debug your application
<br>
and profile its performance.</p>

<p style="margin-top: 1em">OPTIONS <br>
-r regression only</p>

<p style="margin-top: 1em">TRACEVIEW LAYOUT <br>
When you have a trace log file (generated by adding tracing
code to your application or by DDMS), you can have Traceview
load the log files and display their data in a window <br>
visualizes your application in two panels:</p>

<p style="margin-top: 1em">A timeline panel - describes
when each thread and method started and stopped.</p>

<p style="margin-top: 1em">A profile panel - provides a
summary of what happened inside a method.</p>

<p style="margin-top: 1em">The sections below provide
addition information about the traceview output panes.</p>

<p style="margin-top: 1em">Timeline Panel <br>
Each thread&rsquo;s execution is shown in its own row, with
time increasing to the right. Each method is shown in
another color (colors are reused in a round-robin fashion
starting <br>
with the methods that have the most inclusive time). The
thin lines underneath the first row show the extent (entry
to exit) of all the calls to the selected method. The method
<br>
in this case is LoadListener.nativeFinished() and it was
selected in the profile view.</p>

<p style="margin-top: 1em">Profile Panel <br>
This view shows a summary of all the time spent in a method.
The table shows both the inclusive and exclusive times (as
well as the percentage of the total time). Exclusive time
<br>
is the time spent in the method. Inclusive time is the time
spent in the method plus the time spent in any called
functions. We refer to calling methods as
&quot;parents&quot; and called <br>
methods as &quot;children.&quot; When a method is selected
(by clicking on it), it expands to show the parents and
children. Parents are shown with a purple background and
children with a <br>
yellow background. The last column in the table shows the
number of calls to this method plus the number of recursive
calls. The last column shows the number of calls out of the
<br>
total number of calls made to that method. In this view, we
can see that there were 14 calls to
LoadListener.nativeFinished(); looking at the timeline panel
shows that one of <br>
those calls took an unusually long time.</p>

<p style="margin-top: 1em">TRACEVIEW FILE FORMAT <br>
Tracing creates two distinct pieces of output: a data file,
which holds the trace data, and a key file, which provides a
mapping from binary identifiers to thread and method <br>
names. The files are concatenated when tracing completes,
into a single .trace file.</p>

<p style="margin-top: 1em">Note: The previous version of
Traceview did not concatenate these files for you. If you
have old key and data files that you&rsquo;d still like to
trace, you can concatenate them <br>
yourself with cat mytrace.key mytrace.data &gt;
mytrace.trace.</p>

<p style="margin-top: 1em">Data File Format <br>
The data file is binary, structured as follows (all values
are stored in little endian order):</p>

<p style="margin-top: 1em">* File format: <br>
* header <br>
* record 0 <br>
* record 1 <br>
* ... <br>
* <br>
* Header format: <br>
* u4 magic 0x574f4c53 (&rsquo;SLOW&rsquo;) <br>
* u2 version <br>
* u2 offset to data <br>
* u8 start date/time in usec <br>
* <br>
* Record format: <br>
* u1 thread ID <br>
* u4 method ID | method action <br>
* u4 time delta since start, in usec</p>

<p style="margin-top: 1em">The application is expected to
parse all of the header fields, then seek to &quot;offset to
data&quot; from the start of the file. From there it just
reads 9-byte records until EOF is <br>
reached.</p>

<p style="margin-top: 1em">u8 start date/time in usec is
the output from gettimeofday(). It&rsquo;s mainly there so
that you can tell if the output was generated yesterday or
three months ago.</p>

<p style="margin-top: 1em">method action sits in the two
least-significant bits of the method word. The currently
defined meanings are:</p>

<p style="margin-top: 1em">0 - method entry <br>
1 - method exit <br>
2 - method &quot;exited&quot; when unrolled by exception
handling <br>
3 - (reserved)</p>

<p style="margin-top: 1em">An unsigned 32-bit integer can
hold about 70 minutes of time in microseconds.</p>

<p style="margin-top: 1em">Key File Format <br>
The key file is a plain text file divided into three
sections. Each section starts with a keyword that begins
with &rsquo;*&rsquo;. If you see a &rsquo;*&rsquo; at the
start of a line, you have found <br>
the start of a new section.</p>

<p style="margin-top: 1em">An example file might look like
this:</p>

<p style="margin-top: 1em">*version <br>
1 <br>
clock=global <br>
*threads <br>
1 main <br>
6 JDWP Handler <br>
5 Async GC <br>
4 Reference Handler <br>
3 Finalizer <br>
2 Signal Handler <br>
*methods <br>
0x080f23f8 java/io/PrintStream write ([BII)V <br>
0x080f25d4 java/io/PrintStream print (Ljava/lang/String;)V
<br>
0x080f27f4 java/io/PrintStream println (Ljava/lang/String;)V
<br>
0x080da620 java/lang/RuntimeException &lt;init&gt; ()V <br>
[...] <br>
0x080f630c android/os/Debug startMethodTracing ()V <br>
0x080f6350 android/os/Debug startMethodTracing
(Ljava/lang/String;Ljava/lang/String;I)V <br>
*end</p>

<p style="margin-top: 1em">The following list describes the
major sections of a key file:</p>

<p style="margin-top: 1em">version section <br>
The first line is the file version number, currently 1. The
second line, clock=global, indicates that we use a common
clock across all threads. A future version may use per- <br>
thread CPU time counters that are independent for every
thread.</p>

<p style="margin-top: 1em">threads section <br>
One line per thread. Each line consists of two parts: the
thread ID, followed by a tab, followed by the thread name.
There are few restrictions on what a valid thread name <br>
is, so include everything to the end of the line.</p>

<p style="margin-top: 1em">methods section <br>
One line per method entry or exit. A line consists of four
pieces, separated by tab marks: method-ID [TAB] class-name
[TAB] method-name [TAB] signature. Only the methods that
<br>
were actually entered or exited are included in the list.
Note that all three identifiers are required to uniquely
identify a method.</p>

<p style="margin-top: 1em">Neither the threads nor methods
sections are sorted.</p>

<p style="margin-top: 1em">CREATING TRACE FILES <br>
To use Traceview, you need to generate log files containing
the trace information you want to analyze.</p>

<p style="margin-top: 1em">There are two ways to generate
trace logs:</p>

<p style="margin-top: 1em">Include the Debug class in your
code and call its methods to start and stop logging of trace
information to disk. This method is very precise because you
can specify in your <br>
code exactly where to start and stop logging trace data.</p>

<p style="margin-top: 1em">Use the method profiling feature
of DDMS to generate trace logs. This method is less precise
since you do not modify code, but rather specify when to
start and stop logging <br>
with a DDMS. Although you have less control on exactly where
the data is logged, this method is useful if you don&rsquo;t
have access to the application&rsquo;s code, or if you do
not <br>
need the precision of the first method.</p>

<p style="margin-top: 1em">Before you start generating
trace logs, be aware of the following restrictions:</p>

<p style="margin-top: 1em">If you are using the Debug
class, your device or emulator must have an SD card and your
application must have permission to write to the SD
card.</p>

<p style="margin-top: 1em">If you are using DDMS, Android
1.5 devices are not supported.</p>

<p style="margin-top: 1em">If you are using DDMS, Android
2.1 and earlier devices must have an SD card present and
your application must have permission to write to the SD
card.</p>

<p style="margin-top: 1em">If you are using DDMS, Android
2.2 and later devices do not need an SD card. The trace log
files are streamed directly to your development machine.</p>

<p style="margin-top: 1em">To create the trace files,
include the Debug class and call one of the
startMethodTracing() methods. In the call, you specify a
base name for the trace files that the system <br>
generates. To stop tracing, call stopMethodTracing(). These
methods start and stop method tracing across the entire
virtual machine. For example, you could call <br>
startMethodTracing() in your activity&rsquo;s onCreate()
method, and call stopMethodTracing() in that
activity&rsquo;s onDestroy() method.</p>

<p style="margin-top: 1em">// start tracing to
&quot;/sdcard/calc.trace&quot; <br>
Debug.startMethodTracing(&quot;calc&quot;); <br>
// ... <br>
// stop tracing <br>
Debug.stopMethodTracing();</p>

<p style="margin-top: 1em">When your application calls
startMethodTracing(), the system creates a file called
&lt;trace-base-name&gt;.trace. This contains the binary
method trace data and a mapping table with <br>
thread and method names.</p>

<p style="margin-top: 1em">The system then begins buffering
the generated trace data, until your application calls
stopMethodTracing(), at which time it writes the buffered
data to the output file. If the <br>
system reaches the maximum buffer size before
stopMethodTracing() is called, the system stops tracing and
sends a notification to the console.</p>

<p style="margin-top: 1em">Interpreted code will run more
slowly when profiling is enabled. Don&rsquo;t try to
generate absolute timings from the profiler results (i.e.
&quot;function X takes 2.5 seconds to run&quot;). <br>
The times are only useful in relation to other profile
output, so you can see if changes have made the code faster
or slower.</p>

<p style="margin-top: 1em">When using the Android emulator,
you must specify an SD card when you create your AVD because
the trace files are written to the SD card. Your application
must have permission to <br>
write to the SD card as well.</p>

<p style="margin-top: 1em">COPYING TRACE FILES TO A HOST
MACHINE <br>
After your application has run and the system has created
your trace files &lt;trace-base-name&gt;.trace on a device
or emulator, you must copy those files to your development
<br>
computer. You can use adb pull to copy the files.
Here&rsquo;s an example that shows how to copy an example
file, calc.trace, from the default location on the emulator
to the /tmp <br>
directory on the emulator host machine:</p>

<p style="margin-top: 1em">adb pull /sdcard/calc.trace
/tmp</p>

<p style="margin-top: 1em">COPYRIGHT <br>
This manual page is licensed under the Apache License,
Version 2.0.</p>

<p style="margin-top: 1em">Copyright (C) 2013 Android Open
Source Project</p>

<p style="margin-top: 1em">Copyright (C) 2013 Jakub Adam
&lt;jakub.adam@ktknet.cz&gt;</p>

<p style="margin-top: 1em">Debian 2017-01-19
TRACEVIEW(1)</p>
<hr>
</body>
</html>
