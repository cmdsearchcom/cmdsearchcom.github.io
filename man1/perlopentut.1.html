<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:00 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLOPENTUT(1) Perl Programmers Reference Guide
PERLOPENTUT(1)</p>

<p style="margin-top: 1em">NAME <br>
perlopentut - tutorial on opening things in Perl</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Perl has two simple, built-in ways to open files: the shell
way for convenience, and the C way for precision. The shell
way also has 2- and 3-argument forms, which have <br>
different semantics for handling the filename. The choice is
yours.</p>

<p style="margin-top: 1em">Open a la shell <br>
Perl&rsquo;s &quot;open&quot; function was designed to mimic
the way command-line redirection in the shell works. Here
are some basic examples from the shell:</p>

<p style="margin-top: 1em">$ myprogram file1 file2 file3
<br>
$ myprogram &lt; inputfile <br>
$ myprogram &gt; outputfile <br>
$ myprogram &gt;&gt; outputfile <br>
$ myprogram | otherprogram <br>
$ otherprogram | myprogram</p>

<p style="margin-top: 1em">And here are some more advanced
examples:</p>

<p style="margin-top: 1em">$ otherprogram | myprogram f1 -
f2 <br>
$ otherprogram 2&gt;&amp;1 | myprogram - <br>
$ myprogram &lt;&amp;3 <br>
$ myprogram &gt;&amp;4</p>

<p style="margin-top: 1em">Programmers accustomed to
constructs like those above can take comfort in learning
that Perl directly supports these familiar constructs using
virtually the same syntax as the <br>
shell.</p>

<p style="margin-top: 1em">Simple Opens <br>
The &quot;open&quot; function takes two arguments: the first
is a filehandle, and the second is a single string
comprising both what to open and how to open it.
&quot;open&quot; returns true when <br>
it works, and when it fails, returns a false value and sets
the special variable $! to reflect the system error. If the
filehandle was previously opened, it will be implicitly <br>
closed first.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">open(INFO, &quot;datafile&quot;)
|| die(&quot;can&rsquo;t open datafile: $!&quot;); <br>
open(INFO, &quot;&lt; datafile&quot;) ||
die(&quot;can&rsquo;t open datafile: $!&quot;); <br>
open(RESULTS,&quot;&gt; runstats&quot;) ||
die(&quot;can&rsquo;t open runstats: $!&quot;); <br>
open(LOG, &quot;&gt;&gt; logfile &quot;) ||
die(&quot;can&rsquo;t open logfile: $!&quot;);</p>

<p style="margin-top: 1em">If you prefer the
low-punctuation version, you could write that this way:</p>

<p style="margin-top: 1em">open INFO, &quot;&lt;
datafile&quot; or die &quot;can&rsquo;t open datafile:
$!&quot;; <br>
open RESULTS,&quot;&gt; runstats&quot; or die
&quot;can&rsquo;t open runstats: $!&quot;; <br>
open LOG, &quot;&gt;&gt; logfile &quot; or die
&quot;can&rsquo;t open logfile: $!&quot;;</p>

<p style="margin-top: 1em">A few things to notice. First,
the leading &quot;&lt;&quot; is optional. If omitted, Perl
assumes that you want to open the file for reading.</p>

<p style="margin-top: 1em">Note also that the first example
uses the &quot;||&quot; logical operator, and the second
uses &quot;or&quot;, which has lower precedence. Using
&quot;||&quot; in the latter examples would effectively
mean</p>

<p style="margin-top: 1em">open INFO, ( &quot;&lt;
datafile&quot; || die &quot;can&rsquo;t open datafile:
$!&quot; );</p>

<p style="margin-top: 1em">which is definitely not what you
want.</p>

<p style="margin-top: 1em">The other important thing to
notice is that, just as in the shell, any whitespace before
or after the filename is ignored. This is good, because you
wouldn&rsquo;t want these to do <br>
different things:</p>

<p style="margin-top: 1em">open INFO,
&quot;&lt;datafile&quot; <br>
open INFO, &quot;&lt; datafile&quot; <br>
open INFO, &quot;&lt; datafile&quot;</p>

<p style="margin-top: 1em">Ignoring surrounding whitespace
also helps for when you read a filename in from a different
file, and forget to trim it before opening:</p>

<p style="margin-top: 1em">$filename = &lt;INFO&gt;; #
oops, still there <br>
open(EXTRA, &quot;&lt; $filename&quot;) || die
&quot;can&rsquo;t open $filename: $!&quot;;</p>

<p style="margin-top: 1em">This is not a bug, but a
feature. Because &quot;open&quot; mimics the shell in its
style of using redirection arrows to specify how to open the
file, it also does so with respect to extra <br>
whitespace around the filename itself as well. For accessing
files with naughty names, see &quot;Dispelling the
Dweomer&quot;.</p>

<p style="margin-top: 1em">There is also a 3-argument
version of &quot;open&quot;, which lets you put the special
redirection characters into their own argument:</p>

<p style="margin-top: 1em">open( INFO, &quot;&gt;&quot;,
$datafile ) || die &quot;Can&rsquo;t create $datafile:
$!&quot;;</p>

<p style="margin-top: 1em">In this case, the filename to
open is the actual string in $datafile, so you don&rsquo;t
have to worry about $datafile containing characters that
might influence the open mode, or <br>
whitespace at the beginning of the filename that would be
absorbed in the 2-argument version. Also, any reduction of
unnecessary string interpolation is a good thing.</p>

<p style="margin-top: 1em">Indirect Filehandles <br>
&quot;open&quot;&rsquo;s first argument can be a reference
to a filehandle. As of perl 5.6.0, if the argument is
uninitialized, Perl will automatically create a filehandle
and put a reference <br>
to it in the first argument, like so:</p>

<p style="margin-top: 1em">open( my $in, $infile ) or die
&quot;Couldn&rsquo;t read $infile: $!&quot;; <br>
while ( &lt;$in&gt; ) { <br>
# do something with $_ <br>
} <br>
close $in;</p>

<p style="margin-top: 1em">Indirect filehandles make
namespace management easier. Since filehandles are global to
the current package, two subroutines trying to open
&quot;INFILE&quot; will clash. With two <br>
functions opening indirect filehandles like &quot;my
$infile&quot;, there&rsquo;s no clash and no need to worry
about future conflicts.</p>

<p style="margin-top: 1em">Another convenient behavior is
that an indirect filehandle automatically closes when there
are no more references to it:</p>

<p style="margin-top: 1em">sub firstline { <br>
open( my $in, shift ) &amp;&amp; return scalar &lt;$in&gt;;
<br>
# no close() required <br>
}</p>

<p style="margin-top: 1em">Indirect filehandles also make
it easy to pass filehandles to and return filehandles from
subroutines:</p>

<p style="margin-top: 1em">for my $file ( qw(this.conf
that.conf) ) { <br>
my $fin = open_or_throw(&rsquo;&lt;&rsquo;, $file); <br>
process_conf( $fin ); <br>
# no close() needed <br>
}</p>

<p style="margin-top: 1em">use Carp; <br>
sub open_or_throw { <br>
my ($mode, $filename) = @_; <br>
open my $h, $mode, $filename <br>
or croak &quot;Could not open &rsquo;$filename&rsquo;:
$!&quot;; <br>
return $h; <br>
}</p>

<p style="margin-top: 1em">Pipe Opens <br>
In C, when you want to open a file using the standard I/O
library, you use the &quot;fopen&quot; function, but when
opening a pipe, you use the &quot;popen&quot; function. But
in the shell, you <br>
just use a different redirection character. That&rsquo;s
also the case for Perl. The &quot;open&quot; call remains
the same--just its argument differs.</p>

<p style="margin-top: 1em">If the leading character is a
pipe symbol, &quot;open&quot; starts up a new command and
opens a write-only filehandle leading into that command.
This lets you write into that handle and <br>
have what you write show up on that command&rsquo;s standard
input. For example:</p>

<p style="margin-top: 1em">open(PRINTER, &quot;| lpr
-Plp1&quot;) || die &quot;can&rsquo;t run lpr: $!&quot;;
<br>
print PRINTER &quot;stuff0; <br>
close(PRINTER) || die &quot;can&rsquo;t close lpr:
$!&quot;;</p>

<p style="margin-top: 1em">If the trailing character is a
pipe, you start up a new command and open a read-only
filehandle leading out of that command. This lets whatever
that command writes to its <br>
standard output show up on your handle for reading. For
example:</p>

<p style="margin-top: 1em">open(NET, &quot;netstat -i -n
|&quot;) || die &quot;can&rsquo;t fork netstat: $!&quot;;
<br>
while (&lt;NET&gt;) { } # do something with input <br>
close(NET) || die &quot;can&rsquo;t close netstat:
$!&quot;;</p>

<p style="margin-top: 1em">What happens if you try to open
a pipe to or from a non-existent command? If possible, Perl
will detect the failure and set $! as usual. But if the
command contains special <br>
shell characters, such as &quot;&gt;&quot; or &quot;*&quot;,
called &rsquo;metacharacters&rsquo;, Perl does not execute
the command directly. Instead, Perl runs the shell, which
then tries to run the command. <br>
This means that it&rsquo;s the shell that gets the error
indication. In such a case, the &quot;open&quot; call will
only indicate failure if Perl can&rsquo;t even run the
shell. See &quot;How can I <br>
capture STDERR from an external command?&quot; in perlfaq8
to see how to cope with this. There&rsquo;s also an
explanation in perlipc.</p>

<p style="margin-top: 1em">If you would like to open a
bidirectional pipe, the IPC::Open2 library will handle this
for you. Check out &quot;Bidirectional Communication with
Another Process&quot; in perlipc</p>

<p style="margin-top: 1em">perl-5.6.x introduced a version
of piped open that executes a process based on its command
line arguments without relying on the shell. (Similar to the
&quot;system(@LIST)&quot; notation.) <br>
This is safer and faster than executing a single argument
pipe-command, but does not allow special shell constructs.
(It is also not supported on Microsoft Windows, Mac OS <br>
Classic or RISC OS.)</p>

<p style="margin-top: 1em">Here&rsquo;s an example of
&quot;open &rsquo;-|&rsquo;&quot;, which prints a random
Unix fortune cookie as uppercase:</p>

<p style="margin-top: 1em">my $collection = shift(@ARGV);
<br>
open my $fortune, &rsquo;-|&rsquo;, &rsquo;fortune&rsquo;,
$collection <br>
or die &quot;Could not find fortune - $!&quot;; <br>
while (&lt;$fortune&gt;) <br>
{ <br>
print uc($_); <br>
} <br>
close($fortune);</p>

<p style="margin-top: 1em">And this &quot;open
&rsquo;|-&rsquo;&quot; pipes into lpr:</p>

<p style="margin-top: 1em">open my $printer,
&rsquo;|-&rsquo;, &rsquo;lpr&rsquo;, &rsquo;-Plp1&rsquo;
<br>
or die &quot;can&rsquo;t run lpr: $!&quot;; <br>
print {$printer} &quot;stuff0; <br>
close($printer) <br>
or die &quot;can&rsquo;t close lpr: $!&quot;;</p>

<p style="margin-top: 1em">The Minus File <br>
Again following the lead of the standard shell utilities,
Perl&rsquo;s &quot;open&quot; function treats a file whose
name is a single minus, &quot;-&quot;, in a special way. If
you open minus for <br>
reading, it really means to access the standard input. If
you open minus for writing, it really means to access the
standard output.</p>

<p style="margin-top: 1em">If minus can be used as the
default input or default output, what happens if you open a
pipe into or out of minus? What&rsquo;s the default command
it would run? The same script as <br>
you&rsquo;re currently running! This is actually a stealth
&quot;fork&quot; hidden inside an &quot;open&quot; call. See
&quot;Safe Pipe Opens&quot; in perlipc for details.</p>

<p style="margin-top: 1em">Mixing Reads and Writes <br>
It is possible to specify both read and write access. All
you do is add a &quot;+&quot; symbol in front of the
redirection. But as in the shell, using a less-than on a
file never creates <br>
a new file; it only opens an existing one. On the other
hand, using a greater-than always clobbers (truncates to
zero length) an existing file, or creates a brand-new one if
<br>
there isn&rsquo;t an old one. Adding a &quot;+&quot; for
read-write doesn&rsquo;t affect whether it only works on
existing files or always clobbers existing ones.</p>

<p style="margin-top: 1em">open(WTMP, &quot;+&lt;
/usr/adm/wtmp&quot;) <br>
|| die &quot;can&rsquo;t open /usr/adm/wtmp: $!&quot;;</p>

<p style="margin-top: 1em">open(SCREEN, &quot;+&gt;
lkscreen&quot;) <br>
|| die &quot;can&rsquo;t open lkscreen: $!&quot;;</p>

<p style="margin-top: 1em">open(LOGFILE, &quot;+&gt;&gt;
/var/log/applog&quot;) <br>
|| die &quot;can&rsquo;t open /var/log/applog: $!&quot;;</p>

<p style="margin-top: 1em">The first one won&rsquo;t create
a new file, and the second one will always clobber an old
one. The third one will create a new file if necessary and
not clobber an old one, and it <br>
will allow you to read at any point in the file, but all
writes will always go to the end. In short, the first case
is substantially more common than the second and third
cases, <br>
which are almost always wrong. (If you know C, the plus in
Perl&rsquo;s &quot;open&quot; is historically derived from
the one in C&rsquo;s fopen(3S), which it ultimately
calls.)</p>

<p style="margin-top: 1em">In fact, when it comes to
updating a file, unless you&rsquo;re working on a binary
file as in the WTMP case above, you probably don&rsquo;t
want to use this approach for updating. Instead, <br>
Perl&rsquo;s -i flag comes to the rescue. The following
command takes all the C, C++, or yacc source or header files
and changes all their foo&rsquo;s to bar&rsquo;s, leaving
the old version in <br>
the original filename with a &quot;.orig&quot; tacked on the
end: o o g &rsquo; * .</p>

<p style="margin-top: 1em">$ perl -i.orig -pe &rsquo;s/[ C
c h y ]</p>

<p style="margin-top: 1em">This is a short cut for some
renaming games that are really the best way to update
textfiles. See the second question in perlfaq5 for more
details.</p>

<p style="margin-top: 1em">Filters <br>
One of the most common uses for &quot;open&quot; is one you
never even notice. When you process the ARGV filehandle
using &quot;&lt;ARGV&gt;&quot;, Perl actually does an
implicit open on each file in <br>
@ARGV. Thus a program called like this:</p>

<p style="margin-top: 1em">$ myprogram file1 file2
file3</p>

<p style="margin-top: 1em">can have all its files opened
and processed one at a time using a construct no more
complex than:</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
# do something with $_ <br>
}</p>

<p style="margin-top: 1em">If @ARGV is empty when the loop
first begins, Perl pretends you&rsquo;ve opened up minus,
that is, the standard input. In fact, $ARGV, the currently
open file during &quot;&lt;ARGV&gt;&quot; <br>
processing, is even set to &quot;-&quot; in these
circumstances.</p>

<p style="margin-top: 1em">You are welcome to pre-process
your @ARGV before starting the loop to make sure it&rsquo;s
to your liking. One reason to do this might be to remove
command options beginning with a <br>
minus. While you can always roll the simple ones by hand,
the Getopts modules are good for this:</p>

<p style="margin-top: 1em">use Getopt::Std;</p>

<p style="margin-top: 1em"># -v, -D, -o ARG, sets $opt_v,
$opt_D, $opt_o <br>
getopts(&quot;vDo:&quot;);</p>

<p style="margin-top: 1em"># -v, -D, -o ARG, sets $args{v},
$args{D}, $args{o} <br>
getopts(&quot;vDo:&quot;, args);</p>

<p style="margin-top: 1em">Or the standard Getopt::Long
module to permit named arguments:</p>

<p style="margin-top: 1em">use Getopt::Long; <br>
GetOptions( &quot;verbose&quot; =&gt; erbose, # --verbose
<br>
&quot;Debug&quot; =&gt; ebug, # --Debug <br>
&quot;output=s&quot; =&gt; utput ); <br>
# --output=somestring or --output somestring</p>

<p style="margin-top: 1em">Another reason for preprocessing
arguments is to make an empty argument list default to all
files:</p>

<p style="margin-top: 1em">@ARGV = glob(&quot;*&quot;)
unless @ARGV;</p>

<p style="margin-top: 1em">You could even filter out all
but plain, text files. This is a bit silent, of course, and
you might prefer to mention them on the way.</p>

<p style="margin-top: 1em">@ARGV = grep { -f &amp;&amp; -T
} @ARGV;</p>

<p style="margin-top: 1em">If you&rsquo;re using the -n or
-p command-line options, you should put changes to @ARGV in
a &quot;BEGIN{}&quot; block.</p>

<p style="margin-top: 1em">Remember that a normal
&quot;open&quot; has special properties, in that it might
call fopen(3S) or it might called popen(3S), depending on
what its argument looks like; that&rsquo;s why it&rsquo;s
<br>
sometimes called &quot;magic open&quot;. Here&rsquo;s an
example:</p>

<p style="margin-top: 1em">$pwdinfo =
&lsquo;domainname&lsquo; =~ /^(&not;ne)?$/ <br>
? &rsquo;&lt; /etc/passwd&rsquo; <br>
: &rsquo;ypcat passwd |&rsquo;;</p>

<p style="margin-top: 1em">open(PWD, $pwdinfo) <br>
or die &quot;can&rsquo;t open $pwdinfo: $!&quot;;</p>

<p style="margin-top: 1em">This sort of thing also comes
into play in filter processing. Because
&quot;&lt;ARGV&gt;&quot; processing employs the normal,
shell-style Perl &quot;open&quot;, it respects all the
special things we&rsquo;ve <br>
already seen:</p>

<p style="margin-top: 1em">$ myprogram f1 &quot;cmd1|&quot;
- f2 &quot;cmd2|&quot; f3 &lt; tmpfile</p>

<p style="margin-top: 1em">That program will read from the
file f1, the process cmd1, standard input (tmpfile in this
case), the f2 file, the cmd2 command, and finally the f3
file.</p>

<p style="margin-top: 1em">Yes, this also means that if you
have files named &quot;-&quot; (and so on) in your
directory, they won&rsquo;t be processed as literal files by
&quot;open&quot;. You&rsquo;ll need to pass them as
&quot;./-&quot;, much <br>
as you would for the rm program, or you could use
&quot;sysopen&quot; as described below.</p>

<p style="margin-top: 1em">One of the more interesting
applications is to change files of a certain name into
pipes. For example, to autoprocess gzipped or compressed
files by decompressing them with <br>
gzip:</p>

<p style="margin-top: 1em">@ARGV = map { /.(gz|Z)$/ ?
&quot;gzip -dc $_ |&quot; : $_ } @ARGV;</p>

<p style="margin-top: 1em">Or, if you have the GET program
installed from LWP, you can fetch URLs before processing
them:</p>

<p style="margin-top: 1em">@ARGV = map { m#^744</p>

<p style="margin-top: 1em">It&rsquo;s not for nothing that
this is called magic &quot;&lt;ARGV&gt;&quot;. Pretty nifty,
eh?</p>

<p style="margin-top: 1em">Open a la C <br>
If you want the convenience of the shell, then Perl&rsquo;s
&quot;open&quot; is definitely the way to go. On the other
hand, if you want finer precision than C&rsquo;s simplistic
fopen(3S) provides <br>
you should look to Perl&rsquo;s &quot;sysopen&quot;, which
is a direct hook into the open(2) system call. That does
mean it&rsquo;s a bit more involved, but that&rsquo;s the
price of precision.</p>

<p style="margin-top: 1em">&quot;sysopen&quot; takes 3 (or
4) arguments.</p>

<p style="margin-top: 1em">sysopen HANDLE, PATH, FLAGS,
[MASK]</p>

<p style="margin-top: 1em">The HANDLE argument is a
filehandle just as with &quot;open&quot;. The PATH is a
literal path, one that doesn&rsquo;t pay attention to any
greater-thans or less-thans or pipes or minuses, nor <br>
ignore whitespace. If it&rsquo;s there, it&rsquo;s part of
the path. The FLAGS argument contains one or more values
derived from the Fcntl module that have been or&rsquo;d
together using the <br>
bitwise &quot;|&quot; operator. The final argument, the
MASK, is optional; if present, it is combined with the
user&rsquo;s current umask for the creation mode of the
file. You should usually <br>
omit this.</p>

<p style="margin-top: 1em">Although the traditional values
of read-only, write-only, and read-write are 0, 1, and 2
respectively, this is known not to hold true on some
systems. Instead, it&rsquo;s best to load <br>
in the appropriate constants first from the Fcntl module,
which supplies the following standard flags:</p>

<p style="margin-top: 1em">O_RDONLY Read only <br>
O_WRONLY Write only <br>
O_RDWR Read and write <br>
O_CREAT Create the file if it doesn&rsquo;t exist <br>
O_EXCL Fail if the file already exists <br>
O_APPEND Append to the file <br>
O_TRUNC Truncate the file <br>
O_NONBLOCK Non-blocking access</p>

<p style="margin-top: 1em">Less common flags that are
sometimes available on some operating systems include
&quot;O_BINARY&quot;, &quot;O_TEXT&quot;,
&quot;O_SHLOCK&quot;, &quot;O_EXLOCK&quot;,
&quot;O_DEFER&quot;, &quot;O_SYNC&quot;,
&quot;O_ASYNC&quot;, &quot;O_DSYNC&quot;, <br>
&quot;O_RSYNC&quot;, &quot;O_NOCTTY&quot;,
&quot;O_NDELAY&quot; and &quot;O_LARGEFILE&quot;. Consult
your open(2) manpage or its local equivalent for details.
(Note: starting from Perl release 5.6 the
&quot;O_LARGEFILE&quot; <br>
flag, if available, is automatically added to the sysopen()
flags because large files are the default.)</p>

<p style="margin-top: 1em">Here&rsquo;s how to use
&quot;sysopen&quot; to emulate the simple &quot;open&quot;
calls we had before. We&rsquo;ll omit the &quot;|| die
$!&quot; checks for clarity, but make sure you always check
the return values in <br>
real code. These aren&rsquo;t quite the same, since
&quot;open&quot; will trim leading and trailing whitespace,
but you&rsquo;ll get the idea.</p>

<p style="margin-top: 1em">To open a file for reading:</p>

<p style="margin-top: 1em">open(FH, &quot;&lt;
$path&quot;); <br>
sysopen(FH, $path, O_RDONLY);</p>

<p style="margin-top: 1em">To open a file for writing,
creating a new file if needed or else truncating an old
file:</p>

<p style="margin-top: 1em">open(FH, &quot;&gt;
$path&quot;); <br>
sysopen(FH, $path, O_WRONLY | O_TRUNC | O_CREAT);</p>

<p style="margin-top: 1em">To open a file for appending,
creating one if necessary:</p>

<p style="margin-top: 1em">open(FH, &quot;&gt;&gt;
$path&quot;); <br>
sysopen(FH, $path, O_WRONLY | O_APPEND | O_CREAT);</p>

<p style="margin-top: 1em">To open a file for update, where
the file must already exist:</p>

<p style="margin-top: 1em">open(FH, &quot;+&lt;
$path&quot;); <br>
sysopen(FH, $path, O_RDWR);</p>

<p style="margin-top: 1em">And here are things you can do
with &quot;sysopen&quot; that you cannot do with a regular
&quot;open&quot;. As you&rsquo;ll see, it&rsquo;s just a
matter of controlling the flags in the third argument.</p>

<p style="margin-top: 1em">To open a file for writing,
creating a new file which must not previously exist:</p>

<p style="margin-top: 1em">sysopen(FH, $path, O_WRONLY |
O_EXCL | O_CREAT);</p>

<p style="margin-top: 1em">To open a file for appending,
where that file must already exist:</p>

<p style="margin-top: 1em">sysopen(FH, $path, O_WRONLY |
O_APPEND);</p>

<p style="margin-top: 1em">To open a file for update,
creating a new file if necessary:</p>

<p style="margin-top: 1em">sysopen(FH, $path, O_RDWR |
O_CREAT);</p>

<p style="margin-top: 1em">To open a file for update, where
that file must not already exist:</p>

<p style="margin-top: 1em">sysopen(FH, $path, O_RDWR |
O_EXCL | O_CREAT);</p>

<p style="margin-top: 1em">To open a file without blocking,
creating one if necessary:</p>

<p style="margin-top: 1em">sysopen(FH, $path, O_WRONLY |
O_NONBLOCK | O_CREAT);</p>

<p style="margin-top: 1em">Permissions a la mode <br>
If you omit the MASK argument to &quot;sysopen&quot;, Perl
uses the octal value 0666. The normal MASK to use for
executables and directories should be 0777, and for anything
else, 0666.</p>

<p style="margin-top: 1em">Why so permissive? Well, it
isn&rsquo;t really. The MASK will be modified by your
process&rsquo;s current &quot;umask&quot;. A umask is a
number representing disabled permissions bits; that is, <br>
bits that will not be turned on in the created file&rsquo;s
permissions field.</p>

<p style="margin-top: 1em">For example, if your
&quot;umask&quot; were 027, then the 020 part would disable
the group from writing, and the 007 part would disable
others from reading, writing, or executing. Under <br>
these conditions, passing &quot;sysopen&quot; 0666 would
create a file with mode 0640, since &quot;0666 &amp;
~027&quot; is 0640.</p>

<p style="margin-top: 1em">You should seldom use the MASK
argument to &quot;sysopen()&quot;. That takes away the
user&rsquo;s freedom to choose what permission new files
will have. Denying choice is almost always a bad <br>
thing. One exception would be for cases where sensitive or
private data is being stored, such as with mail folders,
cookie files, and internal temporary files.</p>

<p style="margin-top: 1em">Obscure Open Tricks <br>
Re-Opening Files (dups) <br>
Sometimes you already have a filehandle open, and want to
make another handle that&rsquo;s a duplicate of the first
one. In the shell, we place an ampersand in front of a file
<br>
descriptor number when doing redirections. For example,
&quot;2&gt;&amp;1&quot; makes descriptor 2 (that&rsquo;s
STDERR in Perl) be redirected into descriptor 1 (which is
usually Perl&rsquo;s STDOUT). The <br>
same is essentially true in Perl: a filename that begins
with an ampersand is treated instead as a file descriptor if
a number, or as a filehandle if a string.</p>

<p style="margin-top: 1em">open(SAVEOUT,
&quot;&gt;&amp;SAVEERR&quot;) || die &quot;couldn&rsquo;t
dup SAVEERR: $!&quot;; <br>
open(MHCONTEXT, &quot;&lt;&amp;4&quot;) || die
&quot;couldn&rsquo;t dup fd4: $!&quot;;</p>

<p style="margin-top: 1em">That means that if a function is
expecting a filename, but you don&rsquo;t want to give it a
filename because you already have the file open, you can
just pass the filehandle with a <br>
leading ampersand. It&rsquo;s best to use a fully qualified
handle though, just in case the function happens to be in a
different package:</p>


<p style="margin-top: 1em">somefunction(&quot;&amp;main::LOGFILE&quot;);</p>

<p style="margin-top: 1em">This way if somefunction() is
planning on opening its argument, it can just use the
already opened handle. This differs from passing a handle,
because with a handle, you don&rsquo;t <br>
open the file. Here you have something you can pass to
open.</p>

<p style="margin-top: 1em">If you have one of those tricky,
newfangled I/O objects that the C++ folks are raving about,
then this doesn&rsquo;t work because those aren&rsquo;t a
proper filehandle in the native Perl <br>
sense. You&rsquo;ll have to use fileno() to pull out the
proper descriptor number, assuming you can:</p>

<p style="margin-top: 1em">use IO::Socket; <br>
$handle =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;); <br>
$fd = $handle-&gt;fileno; <br>
somefunction(&quot;&amp;$fd&quot;); # not an indirect
function call</p>

<p style="margin-top: 1em">It can be easier (and certainly
will be faster) just to use real filehandles though:</p>

<p style="margin-top: 1em">use IO::Socket; <br>
local *REMOTE =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;); <br>
die &quot;can&rsquo;t connect&quot; unless
defined(fileno(REMOTE)); <br>
somefunction(&quot;&amp;main::REMOTE&quot;);</p>

<p style="margin-top: 1em">If the filehandle or descriptor
number is preceded not just with a simple &quot;&amp;&quot;
but rather with a &quot;&amp;=&quot; combination, then Perl
will not create a completely new descriptor opened to <br>
the same place using the dup(2) system call. Instead, it
will just make something of an alias to the existing one
using the fdopen(3S) library call. This is slightly more
<br>
parsimonious of systems resources, although this is less a
concern these days. Here&rsquo;s an example of that:</p>

<p style="margin-top: 1em">$fd =
$ENV{&quot;MHCONTEXTFD&quot;}; <br>
open(MHCONTEXT, &quot;&lt;&amp;=$fd&quot;) or die
&quot;couldn&rsquo;t fdopen $fd: $!&quot;;</p>

<p style="margin-top: 1em">If you&rsquo;re using magic
&quot;&lt;ARGV&gt;&quot;, you could even pass in as a
command line argument in @ARGV something like
&quot;&lt;&amp;=$MHCONTEXTFD&quot;, but we&rsquo;ve never
seen anyone actually do this.</p>

<p style="margin-top: 1em">Dispelling the Dweomer <br>
Perl is more of a DWIMmer language than something like
Java--where DWIM is an acronym for &quot;do what I
mean&quot;. But this principle sometimes leads to more
hidden magic than one <br>
knows what to do with. In this way, Perl is also filled with
dweomer, an obscure word meaning an enchantment. Sometimes,
Perl&rsquo;s DWIMmer is just too much like dweomer for <br>
comfort.</p>

<p style="margin-top: 1em">If magic &quot;open&quot; is a
bit too magical for you, you don&rsquo;t have to turn to
&quot;sysopen&quot;. To open a file with arbitrary weird
characters in it, it&rsquo;s necessary to protect any
leading <br>
and trailing whitespace. Leading whitespace is protected by
inserting a &quot;./&quot; in front of a filename that
starts with whitespace. Trailing whitespace is protected by
appending <br>
an ASCII NUL byte (&quot; &quot;) at the end of the
string.</p>

<p style="margin-top: 1em">$file =~ s#^(#./$1#; <br>
open(FH, &quot;&lt; $file &quot;) || die &quot;can&rsquo;t
open $file: $!&quot;;</p>

<p style="margin-top: 1em">This assumes, of course, that
your system considers dot the current working directory,
slash the directory separator, and disallows ASCII NULs
within a valid filename. Most <br>
systems follow these conventions, including all POSIX
systems as well as proprietary Microsoft systems. The only
vaguely popular system that doesn&rsquo;t work this way is
the <br>
&quot;Classic&quot; Macintosh system, which uses a colon
where the rest of us use a slash. Maybe &quot;sysopen&quot;
isn&rsquo;t such a bad idea after all.</p>

<p style="margin-top: 1em">If you want to use
&quot;&lt;ARGV&gt;&quot; processing in a totally boring and
non-magical way, you could do this first:</p>

<p style="margin-top: 1em"># &quot;Sam sat on the ground
and put his head in his hands. <br>
# &rsquo;I wish I had never come here, and I don&rsquo;t
want to see <br>
# no more magic,&rsquo; he said, and fell silent.&quot; <br>
for (@ARGV) { <br>
s#^([^./])#./$1#; <br>
$_ .= &quot; &quot;; <br>
} <br>
while (&lt;&gt;) { <br>
# now process $_ <br>
}</p>

<p style="margin-top: 1em">But be warned that users will
not appreciate being unable to use &quot;-&quot; to mean
standard input, per the standard convention.</p>

<p style="margin-top: 1em">Paths as Opens <br>
You&rsquo;ve probably noticed how Perl&rsquo;s
&quot;warn&quot; and &quot;die&quot; functions can produce
messages like:</p>

<p style="margin-top: 1em">Some warning at scriptname line
29, &lt;FH&gt; line 7.</p>

<p style="margin-top: 1em">That&rsquo;s because you opened
a filehandle FH, and had read in seven records from it. But
what was the name of the file, rather than the handle?</p>

<p style="margin-top: 1em">If you aren&rsquo;t running with
&quot;strict refs&quot;, or if you&rsquo;ve turned them off
temporarily, then all you have to do is this:</p>

<p style="margin-top: 1em">open($path, &quot;&lt;
$path&quot;) || die &quot;can&rsquo;t open $path: $!&quot;;
<br>
while (&lt;$path&gt;) { <br>
# whatever <br>
}</p>

<p style="margin-top: 1em">Since you&rsquo;re using the
pathname of the file as its handle, you&rsquo;ll get
warnings more like</p>

<p style="margin-top: 1em">Some warning at scriptname line
29, &lt;/etc/motd&gt; line 7.</p>

<p style="margin-top: 1em">Single Argument Open <br>
Remember how we said that Perl&rsquo;s open took two
arguments? That was a passive prevarication. You see, it can
also take just one argument. If and only if the variable is
a <br>
global variable, not a lexical, you can pass
&quot;open&quot; just one argument, the filehandle, and it
will get the path from the global scalar variable of the
same name.</p>

<p style="margin-top: 1em">$FILE = &quot;/etc/motd&quot;;
<br>
open FILE or die &quot;can&rsquo;t open $FILE: $!&quot;;
<br>
while (&lt;FILE&gt;) { <br>
# whatever <br>
}</p>

<p style="margin-top: 1em">Why is this here? Someone has to
cater to the hysterical porpoises. It&rsquo;s something
that&rsquo;s been in Perl since the very beginning, if not
before.</p>

<p style="margin-top: 1em">Playing with STDIN and STDOUT
<br>
One clever move with STDOUT is to explicitly close it when
you&rsquo;re done with the program.</p>

<p style="margin-top: 1em">END { close(STDOUT) || die
&quot;can&rsquo;t close stdout: $!&quot; }</p>

<p style="margin-top: 1em">If you don&rsquo;t do this, and
your program fills up the disk partition due to a command
line redirection, it won&rsquo;t report the error exit with
a failure status.</p>

<p style="margin-top: 1em">You don&rsquo;t have to accept
the STDIN and STDOUT you were given. You are welcome to
reopen them if you&rsquo;d like.</p>

<p style="margin-top: 1em">open(STDIN, &quot;&lt;
datafile&quot;) <br>
|| die &quot;can&rsquo;t open datafile: $!&quot;;</p>

<p style="margin-top: 1em">open(STDOUT, &quot;&gt;
output&quot;) <br>
|| die &quot;can&rsquo;t open output: $!&quot;;</p>

<p style="margin-top: 1em">And then these can be accessed
directly or passed on to subprocesses. This makes it look as
though the program were initially invoked with those
redirections from the command <br>
line.</p>

<p style="margin-top: 1em">It&rsquo;s probably more
interesting to connect these to pipes. For example:</p>

<p style="margin-top: 1em">$pager = $ENV{PAGER} ||
&quot;(less || more)&quot;; <br>
open(STDOUT, &quot;| $pager&quot;) <br>
|| die &quot;can&rsquo;t fork a pager: $!&quot;;</p>

<p style="margin-top: 1em">This makes it appear as though
your program were called with its stdout already piped into
your pager. You can also use this kind of thing in
conjunction with an implicit fork <br>
to yourself. You might do this if you would rather handle
the post processing in your own program, just in a different
process:</p>

<p style="margin-top: 1em">head(100); <br>
while (&lt;&gt;) { <br>
print; <br>
}</p>

<p style="margin-top: 1em">sub head { <br>
my $lines = shift || 20; <br>
return if $pid = open(STDOUT, &quot;|-&quot;); # return if
parent <br>
die &quot;cannot fork: $!&quot; unless defined $pid; <br>
while (&lt;STDIN&gt;) { <br>
last if --$lines &lt; 0; <br>
print; <br>
} <br>
exit; <br>
}</p>

<p style="margin-top: 1em">This technique can be applied to
repeatedly push as many filters on your output stream as you
wish.</p>

<p style="margin-top: 1em">Other I/O Issues <br>
These topics aren&rsquo;t really arguments related to
&quot;open&quot; or &quot;sysopen&quot;, but they do affect
what you do with your open files.</p>

<p style="margin-top: 1em">Opening Non-File Files <br>
When is a file not a file? Well, you could say when it
exists but isn&rsquo;t a plain file. We&rsquo;ll check
whether it&rsquo;s a symbolic link first, just in case.</p>

<p style="margin-top: 1em">if (-l $file || ! -f _) { <br>
print &quot;$file is not a plain file0; <br>
}</p>

<p style="margin-top: 1em">What other kinds of files are
there than, well, files? Directories, symbolic links, named
pipes, Unix-domain sockets, and block and character devices.
Those are all files, <br>
too--just not plain files. This isn&rsquo;t the same issue
as being a text file. Not all text files are plain files.
Not all plain files are text files. That&rsquo;s why there
are <br>
separate &quot;-f&quot; and &quot;-T&quot; file tests.</p>

<p style="margin-top: 1em">To open a directory, you should
use the &quot;opendir&quot; function, then process it with
&quot;readdir&quot;, carefully restoring the directory name
if necessary:</p>

<p style="margin-top: 1em">opendir(DIR, $dirname) or die
&quot;can&rsquo;t opendir $dirname: $!&quot;; <br>
while (defined($file = readdir(DIR))) { <br>
# do something with &quot;$dirname/$file&quot; <br>
} <br>
closedir(DIR);</p>

<p style="margin-top: 1em">If you want to process
directories recursively, it&rsquo;s better to use the
File::Find module. For example, this prints out all files
recursively and adds a slash to their names if <br>
the file is a directory.</p>

<p style="margin-top: 1em">@ARGV = qw(.) unless @ARGV; <br>
use File::Find; <br>
find sub { print $File::Find::name, -d &amp;&amp;
&rsquo;/&rsquo;, &quot;0 }, @ARGV;</p>

<p style="margin-top: 1em">This finds all bogus symbolic
links beneath a particular directory:</p>

<p style="margin-top: 1em">find sub { print
&quot;$File::Find::name0 if -l &amp;&amp; !-e }, $dir;</p>

<p style="margin-top: 1em">As you see, with symbolic links,
you can just pretend that it is what it points to. Or, if
you want to know what it points to, then
&quot;readlink&quot; is called for:</p>

<p style="margin-top: 1em">if (-l $file) { <br>
if (defined($whither = readlink($file))) { <br>
print &quot;$file points to $whither0; <br>
} else { <br>
print &quot;$file points nowhere: $!0; <br>
} <br>
}</p>

<p style="margin-top: 1em">Opening Named Pipes <br>
Named pipes are a different matter. You pretend
they&rsquo;re regular files, but their opens will normally
block until there is both a reader and a writer. You can
read more about <br>
them in &quot;Named Pipes&quot; in perlipc. Unix-domain
sockets are rather different beasts as well; they&rsquo;re
described in &quot;Unix-Domain TCP Clients and Servers&quot;
in perlipc.</p>

<p style="margin-top: 1em">When it comes to opening
devices, it can be easy and it can be tricky. We&rsquo;ll
assume that if you&rsquo;re opening up a block device, you
know what you&rsquo;re doing. The character devices <br>
are more interesting. These are typically used for modems,
mice, and some kinds of printers. This is described in
&quot;How do I read and write the serial port?&quot; in
perlfaq8 It&rsquo;s <br>
often enough to open them carefully:</p>

<p style="margin-top: 1em">sysopen(TTYIN,
&quot;/dev/ttyS1&quot;, O_RDWR | O_NDELAY | O_NOCTTY) <br>
# (O_NOCTTY no longer needed on POSIX systems) <br>
or die &quot;can&rsquo;t open /dev/ttyS1: $!&quot;; <br>
open(TTYOUT, &quot;+&gt;&amp;TTYIN&quot;) <br>
or die &quot;can&rsquo;t dup TTYIN: $!&quot;;</p>

<p style="margin-top: 1em">$ofh = select(TTYOUT); $| = 1;
select($ofh);</p>

<p style="margin-top: 1em">print TTYOUT &quot;+++at
15&quot;; <br>
$answer = &lt;TTYIN&gt;;</p>

<p style="margin-top: 1em">With descriptors that you
haven&rsquo;t opened using &quot;sysopen&quot;, such as
sockets, you can set them to be non-blocking using
&quot;fcntl&quot;:</p>

<p style="margin-top: 1em">use Fcntl; <br>
my $old_flags = fcntl($handle, F_GETFL, 0) <br>
or die &quot;can&rsquo;t get flags: $!&quot;; <br>
fcntl($handle, F_SETFL, $old_flags | O_NONBLOCK) <br>
or die &quot;can&rsquo;t set non blocking: $!&quot;;</p>

<p style="margin-top: 1em">Rather than losing yourself in a
morass of twisting, turning &quot;ioctl&quot;s, all
dissimilar, if you&rsquo;re going to manipulate ttys,
it&rsquo;s best to make calls out to the stty(1) program if
<br>
you have it, or else use the portable POSIX interface. To
figure this all out, you&rsquo;ll need to read the
termios(3) manpage, which describes the POSIX interface to
tty devices, <br>
and then POSIX, which describes Perl&rsquo;s interface to
POSIX. There are also some high-level modules on CPAN that
can help you with these games. Check out Term::ReadKey and
<br>
Term::ReadLine.</p>

<p style="margin-top: 1em">Opening Sockets <br>
What else can you open? To open a connection using sockets,
you won&rsquo;t use one of Perl&rsquo;s two open functions.
See &quot;Sockets: Client/Server Communication&quot; in
perlipc for that. <br>
Here&rsquo;s an example. Once you have it, you can use FH as
a bidirectional filehandle.</p>

<p style="margin-top: 1em">use IO::Socket; <br>
local *FH =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);</p>

<p style="margin-top: 1em">For opening up a URL, the LWP
modules from CPAN are just what the doctor ordered.
There&rsquo;s no filehandle interface, but it&rsquo;s still
easy to get the contents of a document:</p>

<p style="margin-top: 1em">use LWP::Simple; <br>
$doc = get(&rsquo;http://www.cpan.org/&rsquo;);</p>

<p style="margin-top: 1em">Binary Files <br>
On certain legacy systems with what could charitably be
called terminally convoluted (some would say broken) I/O
models, a file isn&rsquo;t a file--at least, not with
respect to the C <br>
standard I/O library. On these old systems whose libraries
(but not kernels) distinguish between text and binary
streams, to get files to behave properly you&rsquo;ll have
to bend <br>
over backwards to avoid nasty problems. On such infelicitous
systems, sockets and pipes are already opened in binary
mode, and there is currently no way to turn that off. With
<br>
files, you have more options.</p>

<p style="margin-top: 1em">Another option is to use the
&quot;binmode&quot; function on the appropriate handles
before doing regular I/O on them:</p>

<p style="margin-top: 1em">binmode(STDIN); <br>
binmode(STDOUT); <br>
while (&lt;STDIN&gt;) { print }</p>

<p style="margin-top: 1em">Passing &quot;sysopen&quot; a
non-standard flag option will also open the file in binary
mode on those systems that support it. This is the
equivalent of opening the file normally, then <br>
calling &quot;binmode&quot; on the handle.</p>

<p style="margin-top: 1em">sysopen(BINDAT,
&quot;records.data&quot;, O_RDWR | O_BINARY) <br>
|| die &quot;can&rsquo;t open records.data: $!&quot;;</p>

<p style="margin-top: 1em">Now you can use &quot;read&quot;
and &quot;print&quot; on that handle without worrying about
the non-standard system I/O library breaking your data.
It&rsquo;s not a pretty picture, but then, legacy <br>
systems seldom are. CP/M will be with us until the end of
days, and after.</p>

<p style="margin-top: 1em">On systems with exotic I/O
systems, it turns out that, astonishingly enough, even
unbuffered I/O using &quot;sysread&quot; and
&quot;syswrite&quot; might do sneaky data mutilation behind
your back.</p>

<p style="margin-top: 1em">while (sysread(WHENCE, $buf,
1024)) { <br>
syswrite(WHITHER, $buf, length($buf)); <br>
}</p>

<p style="margin-top: 1em">Depending on the vicissitudes of
your runtime system, even these calls may need
&quot;binmode&quot; or &quot;O_BINARY&quot; first. Systems
known to be free of such difficulties include Unix, the <br>
Mac OS, Plan 9, and Inferno.</p>

<p style="margin-top: 1em">File Locking <br>
In a multitasking environment, you may need to be careful
not to collide with other processes who want to do I/O on
the same files as you are working on. You&rsquo;ll often
need <br>
shared or exclusive locks on files for reading and writing
respectively. You might just pretend that only exclusive
locks exist.</p>

<p style="margin-top: 1em">Never use the existence of a
file &quot;-e $file&quot; as a locking indication, because
there is a race condition between the test for the existence
of the file and its creation. It&rsquo;s <br>
possible for another process to create a file in the slice
of time between your existence check and your attempt to
create the file. Atomicity is critical.</p>

<p style="margin-top: 1em">Perl&rsquo;s most portable
locking interface is via the &quot;flock&quot; function,
whose simplicity is emulated on systems that don&rsquo;t
directly support it such as SysV or Windows. The <br>
underlying semantics may affect how it all works, so you
should learn how &quot;flock&quot; is implemented on your
system&rsquo;s port of Perl.</p>

<p style="margin-top: 1em">File locking does not lock out
another process that would like to do I/O. A file lock only
locks out others trying to get a lock, not processes trying
to do I/O. Because locks <br>
are advisory, if one process uses locking and another
doesn&rsquo;t, all bets are off.</p>

<p style="margin-top: 1em">By default, the
&quot;flock&quot; call will block until a lock is granted. A
request for a shared lock will be granted as soon as there
is no exclusive locker. A request for an exclusive <br>
lock will be granted as soon as there is no locker of any
kind. Locks are on file descriptors, not file names. You
can&rsquo;t lock a file until you open it, and you
can&rsquo;t hold on to <br>
a lock once the file has been closed.</p>

<p style="margin-top: 1em">Here&rsquo;s how to get a
blocking shared lock on a file, typically used for
reading:</p>

<p style="margin-top: 1em">use 5.004; <br>
use Fcntl qw(:DEFAULT :flock); <br>
open(FH, &quot;&lt; filename&quot;) or die &quot;can&rsquo;t
open filename: $!&quot;; <br>
flock(FH, LOCK_SH) or die &quot;can&rsquo;t lock filename:
$!&quot;; <br>
# now read from FH</p>

<p style="margin-top: 1em">You can get a non-blocking lock
by using &quot;LOCK_NB&quot;.</p>

<p style="margin-top: 1em">flock(FH, LOCK_SH | LOCK_NB)
<br>
or die &quot;can&rsquo;t lock filename: $!&quot;;</p>

<p style="margin-top: 1em">This can be useful for producing
more user-friendly behaviour by warning if you&rsquo;re
going to be blocking:</p>

<p style="margin-top: 1em">use 5.004; <br>
use Fcntl qw(:DEFAULT :flock); <br>
open(FH, &quot;&lt; filename&quot;) or die &quot;can&rsquo;t
open filename: $!&quot;; <br>
unless (flock(FH, LOCK_SH | LOCK_NB)) { <br>
$| = 1; <br>
print &quot;Waiting for lock...&quot;; <br>
flock(FH, LOCK_SH) or die &quot;can&rsquo;t lock filename:
$!&quot;; <br>
print &quot;got it.0 <br>
} <br>
# now read from FH</p>

<p style="margin-top: 1em">To get an exclusive lock,
typically used for writing, you have to be careful. We
&quot;sysopen&quot; the file so it can be locked before it
gets emptied. You can get a nonblocking <br>
version using &quot;LOCK_EX | LOCK_NB&quot;.</p>

<p style="margin-top: 1em">use 5.004; <br>
use Fcntl qw(:DEFAULT :flock); <br>
sysopen(FH, &quot;filename&quot;, O_WRONLY | O_CREAT) <br>
or die &quot;can&rsquo;t open filename: $!&quot;; <br>
flock(FH, LOCK_EX) <br>
or die &quot;can&rsquo;t lock filename: $!&quot;; <br>
truncate(FH, 0) <br>
or die &quot;can&rsquo;t truncate filename: $!&quot;; <br>
# now write to FH</p>

<p style="margin-top: 1em">Finally, due to the uncounted
millions who cannot be dissuaded from wasting cycles on
useless vanity devices called hit counters, here&rsquo;s how
to increment a number in a file <br>
safely:</p>

<p style="margin-top: 1em">use Fcntl qw(:DEFAULT
:flock);</p>

<p style="margin-top: 1em">sysopen(FH, &quot;numfile&quot;,
O_RDWR | O_CREAT) <br>
or die &quot;can&rsquo;t open numfile: $!&quot;; <br>
# autoflush FH <br>
$ofh = select(FH); $| = 1; select ($ofh); <br>
flock(FH, LOCK_EX) <br>
or die &quot;can&rsquo;t write-lock numfile: $!&quot;;</p>

<p style="margin-top: 1em">$num = &lt;FH&gt; || 0; <br>
seek(FH, 0, 0) <br>
or die &quot;can&rsquo;t rewind numfile : $!&quot;; <br>
print FH $num+1, &quot;0 <br>
or die &quot;can&rsquo;t write numfile: $!&quot;;</p>

<p style="margin-top: 1em">truncate(FH, tell(FH)) <br>
or die &quot;can&rsquo;t truncate numfile: $!&quot;; <br>
close(FH) <br>
or die &quot;can&rsquo;t close numfile: $!&quot;;</p>

<p style="margin-top: 1em">IO Layers <br>
In Perl 5.8.0 a new I/O framework called &quot;PerlIO&quot;
was introduced. This is a new &quot;plumbing&quot; for all
the I/O happening in Perl; for the most part everything will
work just as it <br>
did, but PerlIO also brought in some new features such as
the ability to think of I/O as &quot;layers&quot;. One I/O
layer may in addition to just moving the data also do
transformations <br>
on the data. Such transformations may include compression
and decompression, encryption and decryption, and
transforming between various character encodings.</p>

<p style="margin-top: 1em">Full discussion about the
features of PerlIO is out of scope for this tutorial, but
here is how to recognize the layers being used:</p>

<p style="margin-top: 1em">&Acirc;&middot; The three-(or
more)-argument form of &quot;open&quot; is being used and
the second argument contains something else in addition to
the usual &rsquo;&lt;&rsquo;, &rsquo;&gt;&rsquo;,
&rsquo;&gt;&gt;&rsquo;, &rsquo;|&rsquo; and their variants,
for <br>
example:</p>

<p style="margin-top: 1em">open(my $fh,
&quot;&lt;:crlf&quot;, $fn);</p>

<p style="margin-top: 1em">&Acirc;&middot; The two-argument
form of &quot;binmode&quot; is being used, for example</p>

<p style="margin-top: 1em">binmode($fh,
&quot;:encoding(utf16)&quot;);</p>

<p style="margin-top: 1em">For more detailed discussion
about PerlIO see PerlIO; for more detailed discussion about
Unicode and I/O see perluniintro.</p>

<p style="margin-top: 1em">SEE ALSO <br>
The &quot;open&quot; and &quot;sysopen&quot; functions in
perlfunc(1); the system open(2), dup(2), fopen(3), and
fdopen(3) manpages; the POSIX documentation.</p>

<p style="margin-top: 1em">AUTHOR and COPYRIGHT <br>
Copyright 1998 Tom Christiansen.</p>

<p style="margin-top: 1em">This documentation is free; you
can redistribute it and/or modify it under the same terms as
Perl itself.</p>

<p style="margin-top: 1em">Irrespective of its
distribution, all code examples in these files are hereby
placed into the public domain. You are permitted and
encouraged to use this code in your own <br>
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p style="margin-top: 1em">HISTORY <br>
First release: Sat Jan 9 08:09:11 MST 1999</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLOPENTUT(1)</p>
<hr>
</body>
</html>
