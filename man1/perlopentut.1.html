<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLOPENTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLOPENTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLOPENTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlopentut - tutorial on opening things in Perl
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Perl has two simple, built-in ways to open files: the shell way for convenience,
  and the C way for precision. The shell way also has 2- and 3-argument forms,
  which have different semantics for handling the filename. The choice is yours.
<h1 class="Sh" title="Sh" id="Open_a_la_shell"><a class="selflink" href="#Open_a_la_shell">Open
  a la shell</a></h1>
Perl's &quot;open&quot; function was designed to mimic the way command-line
  redirection in the shell works. Here are some basic examples from the shell:
<div class="Pp"></div>
<pre>
    $ myprogram file1 file2 file3
    $ myprogram    &lt;  inputfile
    $ myprogram    &gt;  outputfile
    $ myprogram    &gt;&gt; outputfile
    $ myprogram    |  otherprogram 
    $ otherprogram |  myprogram
</pre>
<div class="Pp"></div>
And here are some more advanced examples:
<div class="Pp"></div>
<pre>
    $ otherprogram      | myprogram f1 - f2
    $ otherprogram 2&gt;&amp;1 | myprogram -
    $ myprogram     &lt;&amp;3
    $ myprogram     &gt;&amp;4
</pre>
<div class="Pp"></div>
Programmers accustomed to constructs like those above can take comfort in
  learning that Perl directly supports these familiar constructs using virtually
  the same syntax as the shell.
<h2 class="Ss" title="Ss" id="Simple_Opens"><a class="selflink" href="#Simple_Opens">Simple
  Opens</a></h2>
The &quot;open&quot; function takes two arguments: the first is a filehandle,
  and the second is a single string comprising both what to open and how to open
  it. &quot;open&quot; returns true when it works, and when it fails, returns a
  false value and sets the special variable $! to reflect the system error. If
  the filehandle was previously opened, it will be implicitly closed first.
<div class="Pp"></div>
For example:
<div class="Pp"></div>
<pre>
    open(INFO,      &quot;datafile&quot;) || die(&quot;can't open datafile: $!&quot;);
    open(INFO,   &quot;&lt;  datafile&quot;) || die(&quot;can't open datafile: $!&quot;);
    open(RESULTS,&quot;&gt;  runstats&quot;) || die(&quot;can't open runstats: $!&quot;);
    open(LOG,    &quot;&gt;&gt; logfile &quot;) || die(&quot;can't open logfile:  $!&quot;);
</pre>
<div class="Pp"></div>
If you prefer the low-punctuation version, you could write that this way:
<div class="Pp"></div>
<pre>
    open INFO,   &quot;&lt;  datafile&quot;  or die &quot;can't open datafile: $!&quot;;
    open RESULTS,&quot;&gt;  runstats&quot;  or die &quot;can't open runstats: $!&quot;;
    open LOG,    &quot;&gt;&gt; logfile &quot;  or die &quot;can't open logfile:  $!&quot;;
</pre>
<div class="Pp"></div>
A few things to notice. First, the leading &quot;&lt;&quot; is optional. If
  omitted, Perl assumes that you want to open the file for reading.
<div class="Pp"></div>
Note also that the first example uses the &quot;||&quot; logical operator, and
  the second uses &quot;or&quot;, which has lower precedence. Using
  &quot;||&quot; in the latter examples would effectively mean
<div class="Pp"></div>
<pre>
    open INFO, ( &quot;&lt;  datafile&quot;  || die &quot;can't open datafile: $!&quot; );
</pre>
<div class="Pp"></div>
which is definitely not what you want.
<div class="Pp"></div>
The other important thing to notice is that, just as in the shell, any
  whitespace before or after the filename is ignored. This is good, because you
  wouldn't want these to do different things:
<div class="Pp"></div>
<pre>
    open INFO,   &quot;&lt;datafile&quot;   
    open INFO,   &quot;&lt; datafile&quot; 
    open INFO,   &quot;&lt;  datafile&quot;
</pre>
<div class="Pp"></div>
Ignoring surrounding whitespace also helps for when you read a filename in from
  a different file, and forget to trim it before opening:
<div class="Pp"></div>
<pre>
    $filename = &lt;INFO&gt;;         # oops, \n still there
    open(EXTRA, &quot;&lt; $filename&quot;) || die &quot;can't open $filename: $!&quot;;
</pre>
<div class="Pp"></div>
This is not a bug, but a feature. Because &quot;open&quot; mimics the shell in
  its style of using redirection arrows to specify how to open the file, it also
  does so with respect to extra whitespace around the filename itself as well.
  For accessing files with naughty names, see &quot;Dispelling the
  Dweomer&quot;.
<div class="Pp"></div>
There is also a 3-argument version of &quot;open&quot;, which lets you put the
  special redirection characters into their own argument:
<div class="Pp"></div>
<pre>
    open( INFO, &quot;&gt;&quot;, $datafile ) || die &quot;Can't create $datafile: $!&quot;;
</pre>
<div class="Pp"></div>
In this case, the filename to open is the actual string in $datafile, so you
  don't have to worry about $datafile containing characters that might influence
  the open mode, or whitespace at the beginning of the filename that would be
  absorbed in the 2-argument version. Also, any reduction of unnecessary string
  interpolation is a good thing.
<h2 class="Ss" title="Ss" id="Indirect_Filehandles"><a class="selflink" href="#Indirect_Filehandles">Indirect
  Filehandles</a></h2>
&quot;open&quot;'s first argument can be a reference to a filehandle. As of perl
  5.6.0, if the argument is uninitialized, Perl will automatically create a
  filehandle and put a reference to it in the first argument, like so:
<div class="Pp"></div>
<pre>
    open( my $in, $infile )   or die &quot;Couldn't read $infile: $!&quot;;
    while ( &lt;$in&gt; ) {
        # do something with $_
    }
    close $in;
</pre>
<div class="Pp"></div>
Indirect filehandles make namespace management easier. Since filehandles are
  global to the current package, two subroutines trying to open
  &quot;INFILE&quot; will clash. With two functions opening indirect filehandles
  like &quot;my $infile&quot;, there's no clash and no need to worry about
  future conflicts.
<div class="Pp"></div>
Another convenient behavior is that an indirect filehandle automatically closes
  when there are no more references to it:
<div class="Pp"></div>
<pre>
    sub firstline {
        open( my $in, shift ) &amp;&amp; return scalar &lt;$in&gt;;
        # no close() required
    }
</pre>
<div class="Pp"></div>
Indirect filehandles also make it easy to pass filehandles to and return
  filehandles from subroutines:
<div class="Pp"></div>
<pre>
    for my $file ( qw(this.conf that.conf) ) {
        my $fin = open_or_throw('&lt;', $file);
        process_conf( $fin );
        # no close() needed
    }
    use Carp;
    sub open_or_throw {
        my ($mode, $filename) = @_;
        open my $h, $mode, $filename
            or croak &quot;Could not open '$filename': $!&quot;;
        return $h;
    }
</pre>
<h2 class="Ss" title="Ss" id="Pipe_Opens"><a class="selflink" href="#Pipe_Opens">Pipe
  Opens</a></h2>
In C, when you want to open a file using the standard I/O library, you use the
  &quot;fopen&quot; function, but when opening a pipe, you use the
  &quot;popen&quot; function. But in the shell, you just use a different
  redirection character. That's also the case for Perl. The &quot;open&quot;
  call remains the same--just its argument differs.
<div class="Pp"></div>
If the leading character is a pipe symbol, &quot;open&quot; starts up a new
  command and opens a write-only filehandle leading into that command. This lets
  you write into that handle and have what you write show up on that command's
  standard input. For example:
<div class="Pp"></div>
<pre>
    open(PRINTER, &quot;| lpr -Plp1&quot;)    || die &quot;can't run lpr: $!&quot;;
    print PRINTER &quot;stuff\n&quot;;
    close(PRINTER)                  || die &quot;can't close lpr: $!&quot;;
</pre>
<div class="Pp"></div>
If the trailing character is a pipe, you start up a new command and open a
  read-only filehandle leading out of that command. This lets whatever that
  command writes to its standard output show up on your handle for reading. For
  example:
<div class="Pp"></div>
<pre>
    open(NET, &quot;netstat -i -n |&quot;)    || die &quot;can't fork netstat: $!&quot;;
    while (&lt;NET&gt;) { }               # do something with input
    close(NET)                      || die &quot;can't close netstat: $!&quot;;
</pre>
<div class="Pp"></div>
What happens if you try to open a pipe to or from a non-existent command? If
  possible, Perl will detect the failure and set $! as usual. But if the command
  contains special shell characters, such as &quot;&gt;&quot; or &quot;*&quot;,
  called 'metacharacters', Perl does not execute the command directly. Instead,
  Perl runs the shell, which then tries to run the command. This means that it's
  the shell that gets the error indication. In such a case, the &quot;open&quot;
  call will only indicate failure if Perl can't even run the shell. See
  &quot;How can I capture STDERR from an external command?&quot; in perlfaq8 to
  see how to cope with this. There's also an explanation in perlipc.
<div class="Pp"></div>
If you would like to open a bidirectional pipe, the IPC::Open2 library will
  handle this for you. Check out &quot;Bidirectional Communication with Another
  Process&quot; in perlipc
<div class="Pp"></div>
perl-5.6.x introduced a version of piped open that executes a process based on
  its command line arguments without relying on the shell. (Similar to the
  &quot;system(@LIST)&quot; notation.) This is safer and faster than executing a
  single argument pipe-command, but does not allow special shell constructs. (It
  is also not supported on Microsoft Windows, Mac OS Classic or RISC OS.)
<div class="Pp"></div>
Here's an example of &quot;open '-|'&quot;, which prints a random Unix fortune
  cookie as uppercase:
<div class="Pp"></div>
<pre>
    my $collection = shift(@ARGV);
    open my $fortune, '-|', 'fortune', $collection
        or die &quot;Could not find fortune - $!&quot;;
    while (&lt;$fortune&gt;)
    {
        print uc($_);
    }
    close($fortune);
</pre>
<div class="Pp"></div>
And this &quot;open '|-'&quot; pipes into lpr:
<div class="Pp"></div>
<pre>
    open my $printer, '|-', 'lpr', '-Plp1'
        or die &quot;can't run lpr: $!&quot;;
    print {$printer} &quot;stuff\n&quot;;
    close($printer)
        or die &quot;can't close lpr: $!&quot;;
</pre>
<h2 class="Ss" title="Ss" id="The_Minus_File"><a class="selflink" href="#The_Minus_File">The
  Minus File</a></h2>
Again following the lead of the standard shell utilities, Perl's
  &quot;open&quot; function treats a file whose name is a single minus,
  &quot;-&quot;, in a special way. If you open minus for reading, it really
  means to access the standard input. If you open minus for writing, it really
  means to access the standard output.
<div class="Pp"></div>
If minus can be used as the default input or default output, what happens if you
  open a pipe into or out of minus? What's the default command it would run? The
  same script as you're currently running! This is actually a stealth
  &quot;fork&quot; hidden inside an &quot;open&quot; call. See &quot;Safe Pipe
  Opens&quot; in perlipc for details.
<h2 class="Ss" title="Ss" id="Mixing_Reads_and_Writes"><a class="selflink" href="#Mixing_Reads_and_Writes">Mixing
  Reads and Writes</a></h2>
It is possible to specify both read and write access. All you do is add a
  &quot;+&quot; symbol in front of the redirection. But as in the shell, using a
  less-than on a file never creates a new file; it only opens an existing one.
  On the other hand, using a greater-than always clobbers (truncates to zero
  length) an existing file, or creates a brand-new one if there isn't an old
  one. Adding a &quot;+&quot; for read-write doesn't affect whether it only
  works on existing files or always clobbers existing ones.
<div class="Pp"></div>
<pre>
    open(WTMP, &quot;+&lt; /usr/adm/wtmp&quot;) 
        || die &quot;can't open /usr/adm/wtmp: $!&quot;;
    open(SCREEN, &quot;+&gt; lkscreen&quot;)
        || die &quot;can't open lkscreen: $!&quot;;
    open(LOGFILE, &quot;+&gt;&gt; /var/log/applog&quot;)
        || die &quot;can't open /var/log/applog: $!&quot;;
</pre>
<div class="Pp"></div>
The first one won't create a new file, and the second one will always clobber an
  old one. The third one will create a new file if necessary and not clobber an
  old one, and it will allow you to read at any point in the file, but all
  writes will always go to the end. In short, the first case is substantially
  more common than the second and third cases, which are almost always wrong.
  (If you know C, the plus in Perl's &quot;open&quot; is historically derived
  from the one in C's fopen(3S), which it ultimately calls.)
<div class="Pp"></div>
In fact, when it comes to updating a file, unless you're working on a binary
  file as in the WTMP case above, you probably don't want to use this approach
  for updating. Instead, Perl's <b>-i</b> flag comes to the rescue. The
  following command takes all the C, C++, or yacc source or header files and
  changes all their foo's to bar's, leaving the old version in the original
  filename with a &quot;.orig&quot; tacked on the end:
<div class="Pp"></div>
<pre>
    $ perl -i.orig -pe 's/\bfoo\b/bar/g' *.[Cchy]
</pre>
<div class="Pp"></div>
This is a short cut for some renaming games that are really the best way to
  update textfiles. See the second question in perlfaq5 for more details.
<h2 class="Ss" title="Ss" id="Filters"><a class="selflink" href="#Filters">Filters</a></h2>
One of the most common uses for &quot;open&quot; is one you never even notice.
  When you process the ARGV filehandle using &quot;&lt;ARGV&gt;&quot;, Perl
  actually does an implicit open on each file in @ARGV. Thus a program called
  like this:
<div class="Pp"></div>
<pre>
    $ myprogram file1 file2 file3
</pre>
<div class="Pp"></div>
can have all its files opened and processed one at a time using a construct no
  more complex than:
<div class="Pp"></div>
<pre>
    while (&lt;&gt;) {
        # do something with $_
    }
</pre>
<div class="Pp"></div>
If @ARGV is empty when the loop first begins, Perl pretends you've opened up
  minus, that is, the standard input. In fact, $ARGV, the currently open file
  during &quot;&lt;ARGV&gt;&quot; processing, is even set to &quot;-&quot; in
  these circumstances.
<div class="Pp"></div>
You are welcome to pre-process your @ARGV before starting the loop to make sure
  it's to your liking. One reason to do this might be to remove command options
  beginning with a minus. While you can always roll the simple ones by hand, the
  Getopts modules are good for this:
<div class="Pp"></div>
<pre>
    use Getopt::Std;
    # -v, -D, -o ARG, sets $opt_v, $opt_D, $opt_o
    getopts(&quot;vDo:&quot;);            
    # -v, -D, -o ARG, sets $args{v}, $args{D}, $args{o}
    getopts(&quot;vDo:&quot;, \%args);
</pre>
<div class="Pp"></div>
Or the standard Getopt::Long module to permit named arguments:
<div class="Pp"></div>
<pre>
    use Getopt::Long;
    GetOptions( &quot;verbose&quot;  =&gt; \$verbose,        # --verbose
                &quot;Debug&quot;    =&gt; \$debug,          # --Debug
                &quot;output=s&quot; =&gt; \$output );       
            # --output=somestring or --output somestring
</pre>
<div class="Pp"></div>
Another reason for preprocessing arguments is to make an empty argument list
  default to all files:
<div class="Pp"></div>
<pre>
    @ARGV = glob(&quot;*&quot;) unless @ARGV;
</pre>
<div class="Pp"></div>
You could even filter out all but plain, text files. This is a bit silent, of
  course, and you might prefer to mention them on the way.
<div class="Pp"></div>
<pre>
    @ARGV = grep { -f &amp;&amp; -T } @ARGV;
</pre>
<div class="Pp"></div>
If you're using the <b>-n</b> or <b>-p</b> command-line options, you should put
  changes to @ARGV in a &quot;BEGIN{}&quot; block.
<div class="Pp"></div>
Remember that a normal &quot;open&quot; has special properties, in that it might
  call fopen(3S) or it might called popen(3S), depending on what its argument
  looks like; that's why it's sometimes called &quot;magic open&quot;. Here's an
  example:
<div class="Pp"></div>
<pre>
    $pwdinfo = `domainname` =~ /^(\(none\))?$/
                    ? '&lt; /etc/passwd'
                    : 'ypcat passwd |';
    open(PWD, $pwdinfo)                 
                or die &quot;can't open $pwdinfo: $!&quot;;
</pre>
<div class="Pp"></div>
This sort of thing also comes into play in filter processing. Because
  &quot;&lt;ARGV&gt;&quot; processing employs the normal, shell-style Perl
  &quot;open&quot;, it respects all the special things we've already seen:
<div class="Pp"></div>
<pre>
    $ myprogram f1 &quot;cmd1|&quot; - f2 &quot;cmd2|&quot; f3 &lt; tmpfile
</pre>
<div class="Pp"></div>
That program will read from the file <i>f1</i>, the process <i>cmd1</i>,
  standard input ( <i>tmpfile</i> in this case), the <i>f2</i> file, the
  <i>cmd2</i> command, and finally the <i>f3</i> file.
<div class="Pp"></div>
Yes, this also means that if you have files named &quot;-&quot; (and so on) in
  your directory, they won't be processed as literal files by &quot;open&quot;.
  You'll need to pass them as &quot;./-&quot;, much as you would for the
  <i>rm</i> program, or you could use &quot;sysopen&quot; as described below.
<div class="Pp"></div>
One of the more interesting applications is to change files of a certain name
  into pipes. For example, to autoprocess gzipped or compressed files by
  decompressing them with <i>gzip</i>:
<div class="Pp"></div>
<pre>
    @ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc $_ |&quot; : $_  } @ARGV;
</pre>
<div class="Pp"></div>
Or, if you have the <i>GET</i> program installed from LWP, you can fetch URLs
  before processing them:
<div class="Pp"></div>
<pre>
    @ARGV = map { m#^\w+://# ? &quot;GET $_ |&quot; : $_ } @ARGV;
</pre>
<div class="Pp"></div>
It's not for nothing that this is called magic &quot;&lt;ARGV&gt;&quot;. Pretty
  nifty, eh?
<h1 class="Sh" title="Sh" id="Open_a_la_C"><a class="selflink" href="#Open_a_la_C">Open
  a la C</a></h1>
If you want the convenience of the shell, then Perl's &quot;open&quot; is
  definitely the way to go. On the other hand, if you want finer precision than
  C's simplistic fopen(3S) provides you should look to Perl's
  &quot;sysopen&quot;, which is a direct hook into the <i>open</i>(2) system
  call. That does mean it's a bit more involved, but that's the price of
  precision.
<div class="Pp"></div>
&quot;sysopen&quot; takes 3 (or 4) arguments.
<div class="Pp"></div>
<pre>
    sysopen HANDLE, PATH, FLAGS, [MASK]
</pre>
<div class="Pp"></div>
The HANDLE argument is a filehandle just as with &quot;open&quot;. The PATH is a
  literal path, one that doesn't pay attention to any greater-thans or
  less-thans or pipes or minuses, nor ignore whitespace. If it's there, it's
  part of the path. The FLAGS argument contains one or more values derived from
  the Fcntl module that have been or'd together using the bitwise &quot;|&quot;
  operator. The final argument, the MASK, is optional; if present, it is
  combined with the user's current umask for the creation mode of the file. You
  should usually omit this.
<div class="Pp"></div>
Although the traditional values of read-only, write-only, and read-write are 0,
  1, and 2 respectively, this is known not to hold true on some systems.
  Instead, it's best to load in the appropriate constants first from the Fcntl
  module, which supplies the following standard flags:
<div class="Pp"></div>
<pre>
    O_RDONLY            Read only
    O_WRONLY            Write only
    O_RDWR              Read and write
    O_CREAT             Create the file if it doesn't exist
    O_EXCL              Fail if the file already exists
    O_APPEND            Append to the file
    O_TRUNC             Truncate the file
    O_NONBLOCK          Non-blocking access
</pre>
<div class="Pp"></div>
Less common flags that are sometimes available on some operating systems include
  &quot;O_BINARY&quot;, &quot;O_TEXT&quot;, &quot;O_SHLOCK&quot;,
  &quot;O_EXLOCK&quot;, &quot;O_DEFER&quot;, &quot;O_SYNC&quot;,
  &quot;O_ASYNC&quot;, &quot;O_DSYNC&quot;, &quot;O_RSYNC&quot;,
  &quot;O_NOCTTY&quot;, &quot;O_NDELAY&quot; and &quot;O_LARGEFILE&quot;.
  Consult your <i>open</i>(2) manpage or its local equivalent for details.
  (Note: starting from Perl release 5.6 the &quot;O_LARGEFILE&quot; flag, if
  available, is automatically added to the <i>sysopen()</i> flags because large
  files are the default.)
<div class="Pp"></div>
Here's how to use &quot;sysopen&quot; to emulate the simple &quot;open&quot;
  calls we had before. We'll omit the &quot;|| die $!&quot; checks for clarity,
  but make sure you always check the return values in real code. These aren't
  quite the same, since &quot;open&quot; will trim leading and trailing
  whitespace, but you'll get the idea.
<div class="Pp"></div>
To open a file for reading:
<div class="Pp"></div>
<pre>
    open(FH, &quot;&lt; $path&quot;);
    sysopen(FH, $path, O_RDONLY);
</pre>
<div class="Pp"></div>
To open a file for writing, creating a new file if needed or else truncating an
  old file:
<div class="Pp"></div>
<pre>
    open(FH, &quot;&gt; $path&quot;);
    sysopen(FH, $path, O_WRONLY | O_TRUNC | O_CREAT);
</pre>
<div class="Pp"></div>
To open a file for appending, creating one if necessary:
<div class="Pp"></div>
<pre>
    open(FH, &quot;&gt;&gt; $path&quot;);
    sysopen(FH, $path, O_WRONLY | O_APPEND | O_CREAT);
</pre>
<div class="Pp"></div>
To open a file for update, where the file must already exist:
<div class="Pp"></div>
<pre>
    open(FH, &quot;+&lt; $path&quot;);
    sysopen(FH, $path, O_RDWR);
</pre>
<div class="Pp"></div>
And here are things you can do with &quot;sysopen&quot; that you cannot do with
  a regular &quot;open&quot;. As you'll see, it's just a matter of controlling
  the flags in the third argument.
<div class="Pp"></div>
To open a file for writing, creating a new file which must not previously exist:
<div class="Pp"></div>
<pre>
    sysopen(FH, $path, O_WRONLY | O_EXCL | O_CREAT);
</pre>
<div class="Pp"></div>
To open a file for appending, where that file must already exist:
<div class="Pp"></div>
<pre>
    sysopen(FH, $path, O_WRONLY | O_APPEND);
</pre>
<div class="Pp"></div>
To open a file for update, creating a new file if necessary:
<div class="Pp"></div>
<pre>
    sysopen(FH, $path, O_RDWR | O_CREAT);
</pre>
<div class="Pp"></div>
To open a file for update, where that file must not already exist:
<div class="Pp"></div>
<pre>
    sysopen(FH, $path, O_RDWR | O_EXCL | O_CREAT);
</pre>
<div class="Pp"></div>
To open a file without blocking, creating one if necessary:
<div class="Pp"></div>
<pre>
    sysopen(FH, $path, O_WRONLY | O_NONBLOCK | O_CREAT);
</pre>
<h2 class="Ss" title="Ss" id="Permissions_a_la_mode"><a class="selflink" href="#Permissions_a_la_mode">Permissions
  a la mode</a></h2>
If you omit the MASK argument to &quot;sysopen&quot;, Perl uses the octal value
  0666. The normal MASK to use for executables and directories should be 0777,
  and for anything else, 0666.
<div class="Pp"></div>
Why so permissive? Well, it isn't really. The MASK will be modified by your
  process's current &quot;umask&quot;. A umask is a number representing
  <i>disabled</i> permissions bits; that is, bits that will not be turned on in
  the created file's permissions field.
<div class="Pp"></div>
For example, if your &quot;umask&quot; were 027, then the 020 part would disable
  the group from writing, and the 007 part would disable others from reading,
  writing, or executing. Under these conditions, passing &quot;sysopen&quot;
  0666 would create a file with mode 0640, since &quot;0666 &amp; ~027&quot; is
  0640.
<div class="Pp"></div>
You should seldom use the MASK argument to &quot;sysopen()&quot;. That takes
  away the user's freedom to choose what permission new files will have. Denying
  choice is almost always a bad thing. One exception would be for cases where
  sensitive or private data is being stored, such as with mail folders, cookie
  files, and internal temporary files.
<h1 class="Sh" title="Sh" id="Obscure_Open_Tricks"><a class="selflink" href="#Obscure_Open_Tricks">Obscure
  Open Tricks</a></h1>
<h2 class="Ss" title="Ss" id="Re-Opening_Files_(dups)"><a class="selflink" href="#Re-Opening_Files_(dups)">Re-Opening
  Files (dups)</a></h2>
Sometimes you already have a filehandle open, and want to make another handle
  that's a duplicate of the first one. In the shell, we place an ampersand in
  front of a file descriptor number when doing redirections. For example,
  &quot;2&gt;&amp;1&quot; makes descriptor 2 (that's STDERR in Perl) be
  redirected into descriptor 1 (which is usually Perl's STDOUT). The same is
  essentially true in Perl: a filename that begins with an ampersand is treated
  instead as a file descriptor if a number, or as a filehandle if a string.
<div class="Pp"></div>
<pre>
    open(SAVEOUT, &quot;&gt;&amp;SAVEERR&quot;) || die &quot;couldn't dup SAVEERR: $!&quot;;
    open(MHCONTEXT, &quot;&lt;&amp;4&quot;)     || die &quot;couldn't dup fd4: $!&quot;;
</pre>
<div class="Pp"></div>
That means that if a function is expecting a filename, but you don't want to
  give it a filename because you already have the file open, you can just pass
  the filehandle with a leading ampersand. It's best to use a fully qualified
  handle though, just in case the function happens to be in a different package:
<div class="Pp"></div>
<pre>
    somefunction(&quot;&amp;main::LOGFILE&quot;);
</pre>
<div class="Pp"></div>
This way if <i>somefunction()</i> is planning on opening its argument, it can
  just use the already opened handle. This differs from passing a handle,
  because with a handle, you don't open the file. Here you have something you
  can pass to open.
<div class="Pp"></div>
If you have one of those tricky, newfangled I/O objects that the C++ folks are
  raving about, then this doesn't work because those aren't a proper filehandle
  in the native Perl sense. You'll have to use <i>fileno()</i> to pull out the
  proper descriptor number, assuming you can:
<div class="Pp"></div>
<pre>
    use IO::Socket;
    $handle = IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);
    $fd = $handle-&gt;fileno;
    somefunction(&quot;&amp;$fd&quot;);  # not an indirect function call
</pre>
<div class="Pp"></div>
It can be easier (and certainly will be faster) just to use real filehandles
  though:
<div class="Pp"></div>
<pre>
    use IO::Socket;
    local *REMOTE = IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);
    die &quot;can't connect&quot; unless defined(fileno(REMOTE));
    somefunction(&quot;&amp;main::REMOTE&quot;);
</pre>
<div class="Pp"></div>
If the filehandle or descriptor number is preceded not just with a simple
  &quot;&amp;&quot; but rather with a &quot;&amp;=&quot; combination, then Perl
  will not create a completely new descriptor opened to the same place using the
  <i>dup</i>(2) system call. Instead, it will just make something of an alias to
  the existing one using the fdopen(3S) library call. This is slightly more
  parsimonious of systems resources, although this is less a concern these days.
  Here's an example of that:
<div class="Pp"></div>
<pre>
    $fd = $ENV{&quot;MHCONTEXTFD&quot;};
    open(MHCONTEXT, &quot;&lt;&amp;=$fd&quot;)   or die &quot;couldn't fdopen $fd: $!&quot;;
</pre>
<div class="Pp"></div>
If you're using magic &quot;&lt;ARGV&gt;&quot;, you could even pass in as a
  command line argument in @ARGV something like
  &quot;&lt;&amp;=$MHCONTEXTFD&quot;, but we've never seen anyone actually do
  this.
<h2 class="Ss" title="Ss" id="Dispelling_the_Dweomer"><a class="selflink" href="#Dispelling_the_Dweomer">Dispelling
  the Dweomer</a></h2>
Perl is more of a DWIMmer language than something like Java--where DWIM is an
  acronym for &quot;do what I mean&quot;. But this principle sometimes leads to
  more hidden magic than one knows what to do with. In this way, Perl is also
  filled with <i>dweomer</i>, an obscure word meaning an enchantment. Sometimes,
  Perl's DWIMmer is just too much like dweomer for comfort.
<div class="Pp"></div>
If magic &quot;open&quot; is a bit too magical for you, you don't have to turn
  to &quot;sysopen&quot;. To open a file with arbitrary weird characters in it,
  it's necessary to protect any leading and trailing whitespace. Leading
  whitespace is protected by inserting a &quot;./&quot; in front of a filename
  that starts with whitespace. Trailing whitespace is protected by appending an
  ASCII NUL byte (&quot;\0&quot;) at the end of the string.
<div class="Pp"></div>
<pre>
    $file =~ s#^(\s)#./$1#;
    open(FH, &quot;&lt; $file\0&quot;)   || die &quot;can't open $file: $!&quot;;
</pre>
<div class="Pp"></div>
This assumes, of course, that your system considers dot the current working
  directory, slash the directory separator, and disallows ASCII NULs within a
  valid filename. Most systems follow these conventions, including all POSIX
  systems as well as proprietary Microsoft systems. The only vaguely popular
  system that doesn't work this way is the &quot;Classic&quot; Macintosh system,
  which uses a colon where the rest of us use a slash. Maybe &quot;sysopen&quot;
  isn't such a bad idea after all.
<div class="Pp"></div>
If you want to use &quot;&lt;ARGV&gt;&quot; processing in a totally boring and
  non-magical way, you could do this first:
<div class="Pp"></div>
<pre>
    #   &quot;Sam sat on the ground and put his head in his hands.  
    #   'I wish I had never come here, and I don't want to see 
    #   no more magic,' he said, and fell silent.&quot;
    for (@ARGV) { 
        s#^([^./])#./$1#;
        $_ .= &quot;\0&quot;;
    } 
    while (&lt;&gt;) {  
        # now process $_
    }
</pre>
<div class="Pp"></div>
But be warned that users will not appreciate being unable to use &quot;-&quot;
  to mean standard input, per the standard convention.
<h2 class="Ss" title="Ss" id="Paths_as_Opens"><a class="selflink" href="#Paths_as_Opens">Paths
  as Opens</a></h2>
You've probably noticed how Perl's &quot;warn&quot; and &quot;die&quot;
  functions can produce messages like:
<div class="Pp"></div>
<pre>
    Some warning at scriptname line 29, &lt;FH&gt; line 7.
</pre>
<div class="Pp"></div>
That's because you opened a filehandle FH, and had read in seven records from
  it. But what was the name of the file, rather than the handle?
<div class="Pp"></div>
If you aren't running with &quot;strict refs&quot;, or if you've turned them off
  temporarily, then all you have to do is this:
<div class="Pp"></div>
<pre>
    open($path, &quot;&lt; $path&quot;) || die &quot;can't open $path: $!&quot;;
    while (&lt;$path&gt;) {
        # whatever
    }
</pre>
<div class="Pp"></div>
Since you're using the pathname of the file as its handle, you'll get warnings
  more like
<div class="Pp"></div>
<pre>
    Some warning at scriptname line 29, &lt;/etc/motd&gt; line 7.
</pre>
<h2 class="Ss" title="Ss" id="Single_Argument_Open"><a class="selflink" href="#Single_Argument_Open">Single
  Argument Open</a></h2>
Remember how we said that Perl's open took two arguments? That was a passive
  prevarication. You see, it can also take just one argument. If and only if the
  variable is a global variable, not a lexical, you can pass &quot;open&quot;
  just one argument, the filehandle, and it will get the path from the global
  scalar variable of the same name.
<div class="Pp"></div>
<pre>
    $FILE = &quot;/etc/motd&quot;;
    open FILE or die &quot;can't open $FILE: $!&quot;;
    while (&lt;FILE&gt;) {
        # whatever
    }
</pre>
<div class="Pp"></div>
Why is this here? Someone has to cater to the hysterical porpoises. It's
  something that's been in Perl since the very beginning, if not before.
<h2 class="Ss" title="Ss" id="Playing_with_STDIN_and_STDOUT"><a class="selflink" href="#Playing_with_STDIN_and_STDOUT">Playing
  with STDIN and STDOUT</a></h2>
One clever move with STDOUT is to explicitly close it when you're done with the
  program.
<div class="Pp"></div>
<pre>
    END { close(STDOUT) || die &quot;can't close stdout: $!&quot; }
</pre>
<div class="Pp"></div>
If you don't do this, and your program fills up the disk partition due to a
  command line redirection, it won't report the error exit with a failure
  status.
<div class="Pp"></div>
You don't have to accept the STDIN and STDOUT you were given. You are welcome to
  reopen them if you'd like.
<div class="Pp"></div>
<pre>
    open(STDIN, &quot;&lt; datafile&quot;)
        || die &quot;can't open datafile: $!&quot;;
    open(STDOUT, &quot;&gt; output&quot;)
        || die &quot;can't open output: $!&quot;;
</pre>
<div class="Pp"></div>
And then these can be accessed directly or passed on to subprocesses. This makes
  it look as though the program were initially invoked with those redirections
  from the command line.
<div class="Pp"></div>
It's probably more interesting to connect these to pipes. For example:
<div class="Pp"></div>
<pre>
    $pager = $ENV{PAGER} || &quot;(less || more)&quot;;
    open(STDOUT, &quot;| $pager&quot;)
        || die &quot;can't fork a pager: $!&quot;;
</pre>
<div class="Pp"></div>
This makes it appear as though your program were called with its stdout already
  piped into your pager. You can also use this kind of thing in conjunction with
  an implicit fork to yourself. You might do this if you would rather handle the
  post processing in your own program, just in a different process:
<div class="Pp"></div>
<pre>
    head(100);
    while (&lt;&gt;) {
        print;
    } 
    sub head {
        my $lines = shift || 20;
        return if $pid = open(STDOUT, &quot;|-&quot;);       # return if parent
        die &quot;cannot fork: $!&quot; unless defined $pid;
        while (&lt;STDIN&gt;) {
            last if --$lines &lt; 0;
            print;
        } 
        exit;
    }
</pre>
<div class="Pp"></div>
This technique can be applied to repeatedly push as many filters on your output
  stream as you wish.
<h1 class="Sh" title="Sh" id="Other_I/O_Issues"><a class="selflink" href="#Other_I/O_Issues">Other
  I/O Issues</a></h1>
These topics aren't really arguments related to &quot;open&quot; or
  &quot;sysopen&quot;, but they do affect what you do with your open files.
<h2 class="Ss" title="Ss" id="Opening_Non-File_Files"><a class="selflink" href="#Opening_Non-File_Files">Opening
  Non-File Files</a></h2>
When is a file not a file? Well, you could say when it exists but isn't a plain
  file. We'll check whether it's a symbolic link first, just in case.
<div class="Pp"></div>
<pre>
    if (-l $file || ! -f _) {
        print &quot;$file is not a plain file\n&quot;;
    }
</pre>
<div class="Pp"></div>
What other kinds of files are there than, well, files? Directories, symbolic
  links, named pipes, Unix-domain sockets, and block and character devices.
  Those are all files, too--just not <i>plain</i> files. This isn't the same
  issue as being a text file. Not all text files are plain files. Not all plain
  files are text files. That's why there are separate &quot;-f&quot; and
  &quot;-T&quot; file tests.
<div class="Pp"></div>
To open a directory, you should use the &quot;opendir&quot; function, then
  process it with &quot;readdir&quot;, carefully restoring the directory name if
  necessary:
<div class="Pp"></div>
<pre>
    opendir(DIR, $dirname) or die &quot;can't opendir $dirname: $!&quot;;
    while (defined($file = readdir(DIR))) {
        # do something with &quot;$dirname/$file&quot;
    }
    closedir(DIR);
</pre>
<div class="Pp"></div>
If you want to process directories recursively, it's better to use the
  File::Find module. For example, this prints out all files recursively and adds
  a slash to their names if the file is a directory.
<div class="Pp"></div>
<pre>
    @ARGV = qw(.) unless @ARGV;
    use File::Find;
    find sub { print $File::Find::name, -d &amp;&amp; '/', &quot;\n&quot; }, @ARGV;
</pre>
<div class="Pp"></div>
This finds all bogus symbolic links beneath a particular directory:
<div class="Pp"></div>
<pre>
    find sub { print &quot;$File::Find::name\n&quot; if -l &amp;&amp; !-e }, $dir;
</pre>
<div class="Pp"></div>
As you see, with symbolic links, you can just pretend that it is what it points
  to. Or, if you want to know <i>what</i> it points to, then
  &quot;readlink&quot; is called for:
<div class="Pp"></div>
<pre>
    if (-l $file) {
        if (defined($whither = readlink($file))) {
            print &quot;$file points to $whither\n&quot;;
        } else {
            print &quot;$file points nowhere: $!\n&quot;;
        } 
    }
</pre>
<h2 class="Ss" title="Ss" id="Opening_Named_Pipes"><a class="selflink" href="#Opening_Named_Pipes">Opening
  Named Pipes</a></h2>
Named pipes are a different matter. You pretend they're regular files, but their
  opens will normally block until there is both a reader and a writer. You can
  read more about them in &quot;Named Pipes&quot; in perlipc. Unix-domain
  sockets are rather different beasts as well; they're described in
  &quot;Unix-Domain TCP Clients and Servers&quot; in perlipc.
<div class="Pp"></div>
When it comes to opening devices, it can be easy and it can be tricky. We'll
  assume that if you're opening up a block device, you know what you're doing.
  The character devices are more interesting. These are typically used for
  modems, mice, and some kinds of printers. This is described in &quot;How do I
  read and write the serial port?&quot; in perlfaq8 It's often enough to open
  them carefully:
<div class="Pp"></div>
<pre>
    sysopen(TTYIN, &quot;/dev/ttyS1&quot;, O_RDWR | O_NDELAY | O_NOCTTY)
                # (O_NOCTTY no longer needed on POSIX systems)
        or die &quot;can't open /dev/ttyS1: $!&quot;;
    open(TTYOUT, &quot;+&gt;&amp;TTYIN&quot;)
        or die &quot;can't dup TTYIN: $!&quot;;
    $ofh = select(TTYOUT); $| = 1; select($ofh);
    print TTYOUT &quot;+++at\015&quot;;
    $answer = &lt;TTYIN&gt;;
</pre>
<div class="Pp"></div>
With descriptors that you haven't opened using &quot;sysopen&quot;, such as
  sockets, you can set them to be non-blocking using &quot;fcntl&quot;:
<div class="Pp"></div>
<pre>
    use Fcntl;
    my $old_flags = fcntl($handle, F_GETFL, 0) 
        or die &quot;can't get flags: $!&quot;;
    fcntl($handle, F_SETFL, $old_flags | O_NONBLOCK) 
        or die &quot;can't set non blocking: $!&quot;;
</pre>
<div class="Pp"></div>
Rather than losing yourself in a morass of twisting, turning &quot;ioctl&quot;s,
  all dissimilar, if you're going to manipulate ttys, it's best to make calls
  out to the <i>stty</i>(1) program if you have it, or else use the portable
  POSIX interface. To figure this all out, you'll need to read the
  <i>termios</i>(3) manpage, which describes the POSIX interface to tty devices,
  and then POSIX, which describes Perl's interface to POSIX. There are also some
  high-level modules on CPAN that can help you with these games. Check out
  Term::ReadKey and Term::ReadLine.
<h2 class="Ss" title="Ss" id="Opening_Sockets"><a class="selflink" href="#Opening_Sockets">Opening
  Sockets</a></h2>
What else can you open? To open a connection using sockets, you won't use one of
  Perl's two open functions. See &quot;Sockets: Client/Server
  Communication&quot; in perlipc for that. Here's an example. Once you have it,
  you can use FH as a bidirectional filehandle.
<div class="Pp"></div>
<pre>
    use IO::Socket;
    local *FH = IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);
</pre>
<div class="Pp"></div>
For opening up a URL, the LWP modules from CPAN are just what the doctor
  ordered. There's no filehandle interface, but it's still easy to get the
  contents of a document:
<div class="Pp"></div>
<pre>
    use LWP::Simple;
    $doc = get('http://www.cpan.org/');
</pre>
<h2 class="Ss" title="Ss" id="Binary_Files"><a class="selflink" href="#Binary_Files">Binary
  Files</a></h2>
On certain legacy systems with what could charitably be called terminally
  convoluted (some would say broken) I/O models, a file isn't a file--at least,
  not with respect to the C standard I/O library. On these old systems whose
  libraries (but not kernels) distinguish between text and binary streams, to
  get files to behave properly you'll have to bend over backwards to avoid nasty
  problems. On such infelicitous systems, sockets and pipes are already opened
  in binary mode, and there is currently no way to turn that off. With files,
  you have more options.
<div class="Pp"></div>
Another option is to use the &quot;binmode&quot; function on the appropriate
  handles before doing regular I/O on them:
<div class="Pp"></div>
<pre>
    binmode(STDIN);
    binmode(STDOUT);
    while (&lt;STDIN&gt;) { print }
</pre>
<div class="Pp"></div>
Passing &quot;sysopen&quot; a non-standard flag option will also open the file
  in binary mode on those systems that support it. This is the equivalent of
  opening the file normally, then calling &quot;binmode&quot; on the handle.
<div class="Pp"></div>
<pre>
    sysopen(BINDAT, &quot;records.data&quot;, O_RDWR | O_BINARY)
        || die &quot;can't open records.data: $!&quot;;
</pre>
<div class="Pp"></div>
Now you can use &quot;read&quot; and &quot;print&quot; on that handle without
  worrying about the non-standard system I/O library breaking your data. It's
  not a pretty picture, but then, legacy systems seldom are. CP/M will be with
  us until the end of days, and after.
<div class="Pp"></div>
On systems with exotic I/O systems, it turns out that, astonishingly enough,
  even unbuffered I/O using &quot;sysread&quot; and &quot;syswrite&quot; might
  do sneaky data mutilation behind your back.
<div class="Pp"></div>
<pre>
    while (sysread(WHENCE, $buf, 1024)) {
        syswrite(WHITHER, $buf, length($buf));
    }
</pre>
<div class="Pp"></div>
Depending on the vicissitudes of your runtime system, even these calls may need
  &quot;binmode&quot; or &quot;O_BINARY&quot; first. Systems known to be free of
  such difficulties include Unix, the Mac OS, Plan 9, and Inferno.
<h2 class="Ss" title="Ss" id="File_Locking"><a class="selflink" href="#File_Locking">File
  Locking</a></h2>
In a multitasking environment, you may need to be careful not to collide with
  other processes who want to do I/O on the same files as you are working on.
  You'll often need shared or exclusive locks on files for reading and writing
  respectively. You might just pretend that only exclusive locks exist.
<div class="Pp"></div>
Never use the existence of a file &quot;-e $file&quot; as a locking indication,
  because there is a race condition between the test for the existence of the
  file and its creation. It's possible for another process to create a file in
  the slice of time between your existence check and your attempt to create the
  file. Atomicity is critical.
<div class="Pp"></div>
Perl's most portable locking interface is via the &quot;flock&quot; function,
  whose simplicity is emulated on systems that don't directly support it such as
  SysV or Windows. The underlying semantics may affect how it all works, so you
  should learn how &quot;flock&quot; is implemented on your system's port of
  Perl.
<div class="Pp"></div>
File locking <i>does not</i> lock out another process that would like to do I/O.
  A file lock only locks out others trying to get a lock, not processes trying
  to do I/O. Because locks are advisory, if one process uses locking and another
  doesn't, all bets are off.
<div class="Pp"></div>
By default, the &quot;flock&quot; call will block until a lock is granted. A
  request for a shared lock will be granted as soon as there is no exclusive
  locker. A request for an exclusive lock will be granted as soon as there is no
  locker of any kind. Locks are on file descriptors, not file names. You can't
  lock a file until you open it, and you can't hold on to a lock once the file
  has been closed.
<div class="Pp"></div>
Here's how to get a blocking shared lock on a file, typically used for reading:
<div class="Pp"></div>
<pre>
    use 5.004;
    use Fcntl qw(:DEFAULT :flock);
    open(FH, &quot;&lt; filename&quot;)  or die &quot;can't open filename: $!&quot;;
    flock(FH, LOCK_SH)      or die &quot;can't lock filename: $!&quot;;
    # now read from FH
</pre>
<div class="Pp"></div>
You can get a non-blocking lock by using &quot;LOCK_NB&quot;.
<div class="Pp"></div>
<pre>
    flock(FH, LOCK_SH | LOCK_NB)
        or die &quot;can't lock filename: $!&quot;;
</pre>
<div class="Pp"></div>
This can be useful for producing more user-friendly behaviour by warning if
  you're going to be blocking:
<div class="Pp"></div>
<pre>
    use 5.004;
    use Fcntl qw(:DEFAULT :flock);
    open(FH, &quot;&lt; filename&quot;)  or die &quot;can't open filename: $!&quot;;
    unless (flock(FH, LOCK_SH | LOCK_NB)) {
        $| = 1;
        print &quot;Waiting for lock...&quot;;
        flock(FH, LOCK_SH)  or die &quot;can't lock filename: $!&quot;;
        print &quot;got it.\n&quot;
    } 
    # now read from FH
</pre>
<div class="Pp"></div>
To get an exclusive lock, typically used for writing, you have to be careful. We
  &quot;sysopen&quot; the file so it can be locked before it gets emptied. You
  can get a nonblocking version using &quot;LOCK_EX | LOCK_NB&quot;.
<div class="Pp"></div>
<pre>
    use 5.004;
    use Fcntl qw(:DEFAULT :flock);
    sysopen(FH, &quot;filename&quot;, O_WRONLY | O_CREAT)
        or die &quot;can't open filename: $!&quot;;
    flock(FH, LOCK_EX)
        or die &quot;can't lock filename: $!&quot;;
    truncate(FH, 0)
        or die &quot;can't truncate filename: $!&quot;;
    # now write to FH
</pre>
<div class="Pp"></div>
Finally, due to the uncounted millions who cannot be dissuaded from wasting
  cycles on useless vanity devices called hit counters, here's how to increment
  a number in a file safely:
<div class="Pp"></div>
<pre>
    use Fcntl qw(:DEFAULT :flock);
    sysopen(FH, &quot;numfile&quot;, O_RDWR | O_CREAT)
        or die &quot;can't open numfile: $!&quot;;
    # autoflush FH
    $ofh = select(FH); $| = 1; select ($ofh);
    flock(FH, LOCK_EX)
        or die &quot;can't write-lock numfile: $!&quot;;
    $num = &lt;FH&gt; || 0;
    seek(FH, 0, 0)
        or die &quot;can't rewind numfile : $!&quot;;
    print FH $num+1, &quot;\n&quot;
        or die &quot;can't write numfile: $!&quot;;
    truncate(FH, tell(FH))
        or die &quot;can't truncate numfile: $!&quot;;
    close(FH)
        or die &quot;can't close numfile: $!&quot;;
</pre>
<h2 class="Ss" title="Ss" id="IO_Layers"><a class="selflink" href="#IO_Layers">IO
  Layers</a></h2>
In Perl 5.8.0 a new I/O framework called &quot;PerlIO&quot; was introduced. This
  is a new &quot;plumbing&quot; for all the I/O happening in Perl; for the most
  part everything will work just as it did, but PerlIO also brought in some new
  features such as the ability to think of I/O as &quot;layers&quot;. One I/O
  layer may in addition to just moving the data also do transformations on the
  data. Such transformations may include compression and decompression,
  encryption and decryption, and transforming between various character
  encodings.
<div class="Pp"></div>
Full discussion about the features of PerlIO is out of scope for this tutorial,
  but here is how to recognize the layers being used:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The three-(or more)-argument form of &quot;open&quot; is
      being used and the second argument contains something else in addition to
      the usual '&lt;', '&gt;', '&gt;&gt;', '|' and their variants, for example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    open(my $fh, &quot;&lt;:crlf&quot;, $fn);
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The two-argument form of &quot;binmode&quot; is being used,
      for example
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    binmode($fh, &quot;:encoding(utf16)&quot;);
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
For more detailed discussion about PerlIO see PerlIO; for more detailed
  discussion about Unicode and I/O see perluniintro.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The &quot;open&quot; and &quot;sysopen&quot; functions in <i>perlfunc</i>(1);
  the system <i>open</i>(2), <i>dup</i>(2), <i>fopen</i>(3), and
  <i>fdopen</i>(3) manpages; the POSIX documentation.
<h1 class="Sh" title="Sh" id="AUTHOR_and_COPYRIGHT"><a class="selflink" href="#AUTHOR_and_COPYRIGHT">AUTHOR
  and COPYRIGHT</a></h1>
Copyright 1998 Tom Christiansen.
<div class="Pp"></div>
This documentation is free; you can redistribute it and/or modify it under the
  same terms as Perl itself.
<div class="Pp"></div>
Irrespective of its distribution, all code examples in these files are hereby
  placed into the public domain. You are permitted and encouraged to use this
  code in your own programs for fun or for profit as you see fit. A simple
  comment in the code giving credit would be courteous but is not required.
<h1 class="Sh" title="Sh" id="HISTORY"><a class="selflink" href="#HISTORY">HISTORY</a></h1>
First release: Sat Jan 9 08:09:11 MST 1999</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
