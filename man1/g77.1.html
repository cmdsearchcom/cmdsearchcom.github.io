<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:11:32 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>G77(1) GNU G77(1)</p>

<p style="margin-top: 1em">NAME <br>
g77 - GNU project Fortran 77 compiler</p>

<p style="margin-top: 1em">SYNOPSIS <br>
g77 [-c|-S|-E] <br>
[-g] [-pg] [-Olevel] <br>
[-Wwarn...] [-pedantic] <br>
[-Idir...] [-Ldir...] <br>
[-Dmacro[=defn]...] [-Umacro] <br>
[-foption...] [-mmachine-option...] <br>
[-o outfile] infile...</p>

<p style="margin-top: 1em">Only the most useful options are
listed here; see below for the remainder.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The g77 command supports all the options supported by the
gcc command.</p>

<p style="margin-top: 1em">All gcc and g77 options are
accepted both by g77 and by gcc (as well as any other
drivers built at the same time, such as g++), since adding
g77 to the gcc distribution enables <br>
acceptance of g77 options by all of the relevant
drivers.</p>

<p style="margin-top: 1em">In some cases, options have
positive and negative forms; the negative form of -ffoo
would be -fno-foo. This manual documents only one of these
two forms, whichever one is not <br>
the default.</p>

<p style="margin-top: 1em">OPTIONS <br>
Here is a summary of all the options specific to GNU
Fortran, grouped by type. Explanations are in the following
sections.</p>

<p style="margin-top: 1em">Overall Options <br>
-fversion -fset-g77-defaults -fno-silent</p>

<p style="margin-top: 1em">Shorthand Options <br>
-ff66 -fno-f66 -ff77 -fno-f77 -fno-ugly</p>

<p style="margin-top: 1em">Fortran Language Options <br>
-ffree-form -fno-fixed-form -ff90 -fvxt -fdollar-ok
-fno-backslash -fno-ugly-args -fno-ugly-assign
-fno-ugly-assumed -fugly-comma -fugly-complex -fugly-init
<br>
-fugly-logint -fonetrip -ftypeless-boz -fintrin-case-initcap
-fintrin-case-upper -fintrin-case-lower -fintrin-case-any
-fmatch-case-initcap -fmatch-case-upper <br>
-fmatch-case-lower -fmatch-case-any -fsource-case-upper
-fsource-case-lower -fsource-case-preserve
-fsymbol-case-initcap -fsymbol-case-upper
-fsymbol-case-lower <br>
-fsymbol-case-any -fcase-strict-upper -fcase-strict-lower
-fcase-initcap -fcase-upper -fcase-lower -fcase-preserve
-ff2c-intrinsics-delete -ff2c-intrinsics-hide <br>
-ff2c-intrinsics-disable -ff2c-intrinsics-enable
-fbadu77-intrinsics-delete -fbadu77-intrinsics-hide
-fbadu77-intrinsics-disable -fbadu77-intrinsics-enable <br>
-ff90-intrinsics-delete -ff90-intrinsics-hide
-ff90-intrinsics-disable -ff90-intrinsics-enable
-fgnu-intrinsics-delete -fgnu-intrinsics-hide
-fgnu-intrinsics-disable <br>
-fgnu-intrinsics-enable -fmil-intrinsics-delete
-fmil-intrinsics-hide -fmil-intrinsics-disable
-fmil-intrinsics-enable -funix-intrinsics-delete
-funix-intrinsics-hide <br>
-funix-intrinsics-disable -funix-intrinsics-enable
-fvxt-intrinsics-delete -fvxt-intrinsics-hide
-fvxt-intrinsics-disable -fvxt-intrinsics-enable
-ffixed-line-length-n <br>
-ffixed-line-length-none</p>

<p style="margin-top: 1em">Warning Options <br>
-fsyntax-only -pedantic -pedantic-errors -fpedantic -w
-Wno-globals -Wimplicit -Wunused -Wuninitialized -Wall
-Wsurprising -Werror -W</p>

<p style="margin-top: 1em">Debugging Options <br>
-g</p>

<p style="margin-top: 1em">Optimization Options <br>
-malign-double -ffloat-store -fforce-mem -fforce-addr
-fno-inline -ffast-math -fstrength-reduce
-frerun-cse-after-loop -funsafe-math-optimizations
-ffinite-math-only <br>
-fno-trapping-math -fexpensive-optimizations
-fdelayed-branch -fschedule-insns -fschedule-insn2
-fcaller-saves -funroll-loops -funroll-all-loops
-fno-move-all-movables <br>
-fno-reduce-all-givs -fno-rerun-loop-opt</p>

<p style="margin-top: 1em">Directory Options <br>
-Idir -I-</p>

<p style="margin-top: 1em">Code Generation Options <br>
-fno-automatic -finit-local-zero -fno-f2c -ff2c-library
-fno-underscoring -fno-ident -fpcc-struct-return
-freg-struct-return -fshort-double -fno-common -fpack-struct
<br>
-fzeros -fno-second-underscore -femulate-complex
-falias-check -fargument-alias -fargument-noalias
-fno-argument-noalias-global -fno-globals -fflatten-arrays
<br>
-fbounds-check -ffortran-bounds-check</p>

<p style="margin-top: 1em">Compilation can involve as many
as four stages: preprocessing, code generation (often what
is really meant by the term
&lsquo;&lsquo;compilation&rsquo;&rsquo;), assembly, and
linking, always in that <br>
order. The first three stages apply to an individual source
file, and end by producing an object file; linking combines
all the object files (those newly compiled, and those <br>
specified as input) into an executable file.</p>

<p style="margin-top: 1em">For any given input file, the
file name suffix determines what kind of program is
contained in the file---that is, the language in which the
program is written is generally <br>
indicated by the suffix. Suffixes specific to GNU Fortran
are listed below.</p>

<p style="margin-top: 1em">file.f <br>
file.for <br>
file.FOR <br>
Fortran source code that should not be preprocessed.</p>

<p style="margin-top: 1em">Such source code cannot contain
any preprocessor directives, such as &quot;#include&quot;,
&quot;#define&quot;, &quot;#if&quot;, and so on.</p>

<p style="margin-top: 1em">You can force .f files to be
preprocessed by cpp by using -x f77-cpp-input.</p>

<p style="margin-top: 1em">file.F <br>
file.fpp <br>
file.FPP <br>
Fortran source code that must be preprocessed (by the C
preprocessor cpp, which is part of GCC).</p>

<p style="margin-top: 1em">Note that preprocessing is not
extended to the contents of files included by the
&quot;INCLUDE&quot; directive---the &quot;#include&quot;
preprocessor directive must be used instead.</p>

<p style="margin-top: 1em">file.r <br>
Ratfor source code, which must be preprocessed by the ratfor
command, which is available separately (as it is not yet
part of the GNU Fortran distribution). A public domain <br>
version in C is at
&lt;http://sepwww.stanford.edu/sep/prof/ratfor.shar.2&gt;.</p>

<p style="margin-top: 1em">UNIX users typically use the
file.f and file.F nomenclature. Users of other operating
systems, especially those that cannot distinguish upper-case
letters from lower-case <br>
letters in their file names, typically use the file.for and
file.fpp nomenclature.</p>

<p style="margin-top: 1em">Use of the preprocessor cpp
allows use of C-like constructs such as &quot;#define&quot;
and &quot;#include&quot;, but can lead to unexpected, even
mistaken, results due to Fortran&rsquo;s source file <br>
format. It is recommended that use of the C preprocessor be
limited to &quot;#include&quot; and, in conjunction with
&quot;#define&quot;, only &quot;#if&quot; and related
directives, thus avoiding in-line <br>
macro expansion entirely. This recommendation applies
especially when using the traditional fixed source form.
With free source form, fewer unexpected transformations are
<br>
likely to happen, but use of constructs such as Hollerith
and character constants can nevertheless present problems,
especially when these are continued across multiple source
<br>
lines. These problems result, primarily, from differences
between the way such constants are interpreted by the C
preprocessor and by a Fortran compiler.</p>

<p style="margin-top: 1em">Another example of a problem
that results from using the C preprocessor is that a Fortran
comment line that happens to contain any characters
&lsquo;&lsquo;interesting&rsquo;&rsquo; to the C <br>
preprocessor, such as a backslash at the end of the line, is
not recognized by the preprocessor as a comment line, so
instead of being passed through
&lsquo;&lsquo;raw&rsquo;&rsquo;, the line is edited <br>
according to the rules for the preprocessor. For example,
the backslash at the end of the line is removed, along with
the subsequent newline, resulting in the next line being
<br>
effectively commented out---unfortunate if that line is a
non-comment line of important code!</p>

<p style="margin-top: 1em">Note: The -traditional and
-undef flags are supplied to cpp by default, to help avoid
unpleasant surprises.</p>

<p style="margin-top: 1em">This means that ANSI C
preprocessor features (such as the # operator) aren&rsquo;t
available, and only variables in the C reserved namespace
(generally, names with a leading <br>
underscore) are liable to substitution by C predefines.
Thus, if you want to do system-specific tests, use, for
example, #ifdef __linux__ rather than #ifdef linux. Use the
-v <br>
option to see exactly how the preprocessor is invoked.</p>

<p style="margin-top: 1em">Unfortunately, the -traditional
flag will not avoid an error from anything that cpp sees as
an unterminated C comment, such as:</p>

<p style="margin-top: 1em">C Some Fortran compilers accept
/* as starting <br>
C an inline comment.</p>

<p style="margin-top: 1em">The following options that
affect overall processing are recognized by the g77 and gcc
commands in a GNU Fortran installation:</p>

<p style="margin-top: 1em">-fversion <br>
Ensure that the g77 version of the compiler phase is
reported, if run, and, starting in &quot;egcs&quot; version
1.1, that internal consistency checks in the f771 program
are run.</p>

<p style="margin-top: 1em">This option is supplied
automatically when -v or --verbose is specified as a
command-line option for g77 or gcc and when the resulting
commands compile Fortran source files.</p>

<p style="margin-top: 1em">In GCC 3.1, this is changed back
to the behavior gcc displays for .c files.</p>

<p style="margin-top: 1em">-fset-g77-defaults <br>
Version info: This option was obsolete as of
&quot;egcs&quot; version 1.1. The effect is instead achieved
by the &quot;lang_init_options&quot; routine in
gcc/gcc/f/com.c.</p>

<p style="margin-top: 1em">Set up whatever gcc options are
to apply to Fortran compilations, and avoid running internal
consistency checks that might take some time.</p>

<p style="margin-top: 1em">This option is supplied
automatically when compiling Fortran code via the g77 or gcc
command. The description of this option is provided so that
users seeing it in the <br>
output of, say, g77 -v understand why it is there.</p>

<p style="margin-top: 1em">Also, developers who run
&quot;f771&quot; directly might want to specify it by hand
to get the same defaults as they would running
&quot;f771&quot; via g77 or gcc However, such developers
<br>
should, after linking a new &quot;f771&quot; executable,
invoke it without this option once, e.g. via &quot;./f771
-quiet &lt; /dev/null&quot;, to ensure that they have not
introduced any internal <br>
inconsistencies (such as in the table of intrinsics) before
proceeding---g77 will crash with a diagnostic if it detects
an inconsistency.</p>

<p style="margin-top: 1em">-fno-silent <br>
Print (to &quot;stderr&quot;) the names of the program units
as they are compiled, in a form similar to that used by
popular UNIX f77 implementations and f2c</p>

<p style="margin-top: 1em">Shorthand Options <br>
The following options serve as
&lsquo;&lsquo;shorthand&rsquo;&rsquo; for other options
accepted by the compiler:</p>

<p style="margin-top: 1em">-fugly <br>
Note: This option is no longer supported. The information,
below, is provided to aid in the conversion of old
scripts.</p>

<p style="margin-top: 1em">Specify that certain
&lsquo;&lsquo;ugly&rsquo;&rsquo; constructs are to be
quietly accepted. Same as:</p>

<p style="margin-top: 1em">-fugly-args -fugly-assign
-fugly-assumed <br>
-fugly-comma -fugly-complex -fugly-init <br>
-fugly-logint</p>

<p style="margin-top: 1em">These constructs are considered
inappropriate to use in new or well-maintained portable
Fortran code, but widely used in old code.</p>

<p style="margin-top: 1em">-fno-ugly <br>
Specify that all &lsquo;&lsquo;ugly&rsquo;&rsquo; constructs
are to be noisily rejected. Same as:</p>

<p style="margin-top: 1em">-fno-ugly-args -fno-ugly-assign
-fno-ugly-assumed <br>
-fno-ugly-comma -fno-ugly-complex -fno-ugly-init <br>
-fno-ugly-logint</p>

<p style="margin-top: 1em">-ff66 <br>
Specify that the program is written in idiomatic FORTRAN 66.
Same as -fonetrip -fugly-assumed.</p>

<p style="margin-top: 1em">The -fno-f66 option is the
inverse of -ff66. As such, it is the same as -fno-onetrip
-fno-ugly-assumed.</p>

<p style="margin-top: 1em">The meaning of this option is
likely to be refined as future versions of g77 provide more
compatibility with other existing and obsolete Fortran
implementations.</p>

<p style="margin-top: 1em">-ff77 <br>
Specify that the program is written in idiomatic UNIX
FORTRAN 77 and/or the dialect accepted by the f2c product.
Same as -fbackslash -fno-typeless-boz.</p>

<p style="margin-top: 1em">The meaning of this option is
likely to be refined as future versions of g77 provide more
compatibility with other existing and obsolete Fortran
implementations.</p>

<p style="margin-top: 1em">-fno-f77 <br>
The -fno-f77 option is not the inverse of -ff77. It
specifies that the program is not written in idiomatic UNIX
FORTRAN 77 or f2c but in a more widely portable dialect.
<br>
-fno-f77 is the same as -fno-backslash.</p>

<p style="margin-top: 1em">The meaning of this option is
likely to be refined as future versions of g77 provide more
compatibility with other existing and obsolete Fortran
implementations.</p>

<p style="margin-top: 1em">Options Controlling Fortran
Dialect <br>
The following options control the dialect of Fortran that
the compiler accepts:</p>

<p style="margin-top: 1em">-ffree-form <br>
-fno-fixed-form <br>
Specify that the source file is written in free form
(introduced in Fortran 90) instead of the more-traditional
fixed form.</p>

<p style="margin-top: 1em">-ff90 <br>
Allow certain Fortran-90 constructs.</p>

<p style="margin-top: 1em">This option controls whether
certain Fortran 90 constructs are recognized. (Other Fortran
90 constructs might or might not be recognized depending on
other options such as <br>
-fvxt, -ff90-intrinsics-enable, and the current level of
support for Fortran 90.)</p>

<p style="margin-top: 1em">-fvxt <br>
Specify the treatment of certain constructs that have
different meanings depending on whether the code is written
in GNU Fortran (based on FORTRAN 77 and akin to Fortran 90)
<br>
or VXT Fortran (more like VAX FORTRAN).</p>

<p style="margin-top: 1em">The default is -fno-vxt. -fvxt
specifies that the VXT Fortran interpretations for those
constructs are to be chosen.</p>

<p style="margin-top: 1em">-fdollar-ok <br>
Allow $ as a valid character in a symbol name.</p>

<p style="margin-top: 1em">-fno-backslash <br>
Specify that &nbsp;is not to be specially interpreted in
character and Hollerith constants a la C and many UNIX
Fortran compilers.</p>

<p style="margin-top: 1em">For example, with -fbackslash in
effect, A0 specifies three characters, with the second one
being newline. With -fno-backslash, it specifies four
characters, A, n, and <br>
B.</p>

<p style="margin-top: 1em">Note that g77 implements a
fairly general form of backslash processing that is
incompatible with the narrower forms supported by some other
compilers. For example, &rsquo;A 03B&rsquo; <br>
is a three-character string in g77 whereas other compilers
that support backslash might not support the
three-octal-digit form, and thus treat that string as longer
than <br>
three characters.</p>

<p style="margin-top: 1em">-fno-ugly-args <br>
Disallow passing Hollerith and typeless constants as actual
arguments (for example, CALL FOO(4HABCD)).</p>

<p style="margin-top: 1em">-fugly-assign <br>
Use the same storage for a given variable regardless of
whether it is used to hold an assigned-statement label (as
in ASSIGN 10 TO I) or used to hold numeric data (as in I =
<br>
3).</p>

<p style="margin-top: 1em">-fugly-assumed <br>
Assume any dummy array with a final dimension specified as 1
is really an assumed-size array, as if * had been specified
for the final dimension instead of 1.</p>

<p style="margin-top: 1em">For example, DIMENSION X(1) is
treated as if it had read DIMENSION X(*).</p>

<p style="margin-top: 1em">-fugly-comma <br>
In an external-procedure invocation, treat a trailing comma
in the argument list as specification of a trailing null
argument, and treat an empty argument list as <br>
specification of a single null argument.</p>

<p style="margin-top: 1em">For example, CALL FOO(,) is
treated as CALL FOO(%VAL(0), %VAL(0)). That is, two null
arguments are specified by the procedure call when
-fugly-comma is in force. And F = <br>
FUNC() is treated as F = FUNC(%VAL(0)).</p>

<p style="margin-top: 1em">The default behavior,
-fno-ugly-comma, is to ignore a single trailing comma in an
argument list. So, by default, CALL FOO(X,) is treated
exactly the same as CALL FOO(X).</p>

<p style="margin-top: 1em">-fugly-complex <br>
Do not complain about REAL(expr) or AIMAG(expr) when expr is
a &quot;COMPLEX&quot; type other than
&quot;COMPLEX(KIND=1)&quot;---usually this is used to permit
&quot;COMPLEX(KIND=2)&quot; (&quot;DOUBLE <br>
COMPLEX&quot;) operands.</p>

<p style="margin-top: 1em">The -ff90 option controls the
interpretation of this construct.</p>

<p style="margin-top: 1em">-fno-ugly-init <br>
Disallow use of Hollerith and typeless constants as initial
values (in &quot;PARAMETER&quot; and &quot;DATA&quot;
statements), and use of character constants to initialize
numeric types and vice <br>
versa.</p>

<p style="margin-top: 1em">For example, DATA
I/&rsquo;F&rsquo;/, CHRVAR/65/, J/4HABCD/ is disallowed by
-fno-ugly-init.</p>

<p style="margin-top: 1em">-fugly-logint <br>
Treat &quot;INTEGER&quot; and &quot;LOGICAL&quot; variables
and expressions as potential stand-ins for each other.</p>

<p style="margin-top: 1em">For example, automatic
conversion between &quot;INTEGER&quot; and
&quot;LOGICAL&quot; is enabled, for many contexts, via this
option.</p>

<p style="margin-top: 1em">-fonetrip <br>
Executable iterative &quot;DO&quot; loops are to be executed
at least once each time they are reached.</p>

<p style="margin-top: 1em">ANSI FORTRAN 77 and more recent
versions of the Fortran standard specify that the body of an
iterative &quot;DO&quot; loop is not executed if the number
of iterations calculated from <br>
the parameters of the loop is less than 1. (For example, DO
10 I = 1, 0.) Such a loop is called a zero-trip loop.</p>

<p style="margin-top: 1em">Prior to ANSI FORTRAN 77, many
compilers implemented &quot;DO&quot; loops such that the
body of a loop would be executed at least once, even if the
iteration count was zero. Fortran <br>
code written assuming this behavior is said to require
one-trip loops. For example, some code written to the
FORTRAN 66 standard expects this behavior from its
&quot;DO&quot; loops, <br>
although that standard did not specify this behavior.</p>

<p style="margin-top: 1em">The -fonetrip option specifies
that the source file(s) being compiled require one-trip
loops.</p>

<p style="margin-top: 1em">This option affects only those
loops specified by the (iterative) &quot;DO&quot; statement
and by implied-&quot;DO&quot; lists in I/O statements. Loops
specified by implied-&quot;DO&quot; lists in
&quot;DATA&quot; <br>
and specification (non-executable) statements are not
affected.</p>

<p style="margin-top: 1em">-ftypeless-boz <br>
Specifies that prefix-radix non-decimal constants, such as
Z&rsquo;ABCD&rsquo;, are typeless instead of
&quot;INTEGER(KIND=1)&quot;.</p>

<p style="margin-top: 1em">You can test for yourself
whether a particular compiler treats the prefix form as
&quot;INTEGER(KIND=1)&quot; or typeless by running the
following program:</p>

<p style="margin-top: 1em">EQUIVALENCE (I, R) <br>
R = Z&rsquo;ABCD1234&rsquo; <br>
J = Z&rsquo;ABCD1234&rsquo; <br>
IF (J .EQ. I) PRINT *, &rsquo;Prefix form is TYPELESS&rsquo;
<br>
IF (J .NE. I) PRINT *, &rsquo;Prefix form is INTEGER&rsquo;
<br>
END</p>

<p style="margin-top: 1em">Reports indicate that many
compilers process this form as &quot;INTEGER(KIND=1)&quot;,
though a few as typeless, and at least one based on a
command-line option specifying some kind of <br>
compatibility.</p>

<p style="margin-top: 1em">-fintrin-case-initcap <br>
-fintrin-case-upper <br>
-fintrin-case-lower <br>
-fintrin-case-any <br>
Specify expected case for intrinsic names.
-fintrin-case-lower is the default.</p>

<p style="margin-top: 1em">-fmatch-case-initcap <br>
-fmatch-case-upper <br>
-fmatch-case-lower <br>
-fmatch-case-any <br>
Specify expected case for keywords. -fmatch-case-lower is
the default.</p>

<p style="margin-top: 1em">-fsource-case-upper <br>
-fsource-case-lower <br>
-fsource-case-preserve <br>
Specify whether source text other than character and
Hollerith constants is to be translated to uppercase, to
lowercase, or preserved as is. -fsource-case-lower is the
<br>
default.</p>

<p style="margin-top: 1em">-fsymbol-case-initcap <br>
-fsymbol-case-upper <br>
-fsymbol-case-lower <br>
-fsymbol-case-any <br>
Specify valid cases for user-defined symbol names.
-fsymbol-case-any is the default.</p>

<p style="margin-top: 1em">-fcase-strict-upper <br>
Same as -fintrin-case-upper -fmatch-case-upper
-fsource-case-preserve -fsymbol-case-upper. (Requires all
pertinent source to be in uppercase.)</p>

<p style="margin-top: 1em">-fcase-strict-lower <br>
Same as -fintrin-case-lower -fmatch-case-lower
-fsource-case-preserve -fsymbol-case-lower. (Requires all
pertinent source to be in lowercase.)</p>

<p style="margin-top: 1em">-fcase-initcap <br>
Same as -fintrin-case-initcap -fmatch-case-initcap
-fsource-case-preserve -fsymbol-case-initcap. (Requires all
pertinent source to be in initial capitals, as in Print <br>
*,SqRt(Value).)</p>

<p style="margin-top: 1em">-fcase-upper <br>
Same as -fintrin-case-any -fmatch-case-any
-fsource-case-upper -fsymbol-case-any. (Maps all pertinent
source to uppercase.)</p>

<p style="margin-top: 1em">-fcase-lower <br>
Same as -fintrin-case-any -fmatch-case-any
-fsource-case-lower -fsymbol-case-any. (Maps all pertinent
source to lowercase.)</p>

<p style="margin-top: 1em">-fcase-preserve <br>
Same as -fintrin-case-any -fmatch-case-any
-fsource-case-preserve -fsymbol-case-any. (Preserves all
case in user-defined symbols, while allowing any-case
matching of <br>
intrinsics and keywords. For example, call Foo(i,I) would
pass two different variables named i and I to a procedure
named Foo.)</p>

<p style="margin-top: 1em">-fbadu77-intrinsics-delete <br>
-fbadu77-intrinsics-hide <br>
-fbadu77-intrinsics-disable <br>
-fbadu77-intrinsics-enable <br>
Specify status of UNIX intrinsics having inappropriate
forms. -fbadu77-intrinsics-enable is the default.</p>

<p style="margin-top: 1em">-ff2c-intrinsics-delete <br>
-ff2c-intrinsics-hide <br>
-ff2c-intrinsics-disable <br>
-ff2c-intrinsics-enable <br>
Specify status of f2c-specific intrinsics.
-ff2c-intrinsics-enable is the default.</p>

<p style="margin-top: 1em">-ff90-intrinsics-delete <br>
-ff90-intrinsics-hide <br>
-ff90-intrinsics-disable <br>
-ff90-intrinsics-enable <br>
Specify status of F90-specific intrinsics.
-ff90-intrinsics-enable is the default.</p>

<p style="margin-top: 1em">-fgnu-intrinsics-delete <br>
-fgnu-intrinsics-hide <br>
-fgnu-intrinsics-disable <br>
-fgnu-intrinsics-enable <br>
Specify status of Digital&rsquo;s COMPLEX-related
intrinsics. -fgnu-intrinsics-enable is the default.</p>

<p style="margin-top: 1em">-fmil-intrinsics-delete <br>
-fmil-intrinsics-hide <br>
-fmil-intrinsics-disable <br>
-fmil-intrinsics-enable <br>
Specify status of MIL-STD-1753-specific intrinsics.
-fmil-intrinsics-enable is the default.</p>

<p style="margin-top: 1em">-funix-intrinsics-delete <br>
-funix-intrinsics-hide <br>
-funix-intrinsics-disable <br>
-funix-intrinsics-enable <br>
Specify status of UNIX intrinsics. -funix-intrinsics-enable
is the default.</p>

<p style="margin-top: 1em">-fvxt-intrinsics-delete <br>
-fvxt-intrinsics-hide <br>
-fvxt-intrinsics-disable <br>
-fvxt-intrinsics-enable <br>
Specify status of VXT intrinsics. -fvxt-intrinsics-enable is
the default.</p>

<p style="margin-top: 1em">-ffixed-line-length-n <br>
Set column after which characters are ignored in typical
fixed-form lines in the source file, and through which
spaces are assumed (as if padded to that length) after the
<br>
ends of short fixed-form lines.</p>

<p style="margin-top: 1em">Popular values for n include 72
(the standard and the default), 80 (card image), and 132
(corresponds to &lsquo;&lsquo;extended-source&rsquo;&rsquo;
options in some popular compilers). n may be <br>
none, meaning that the entire line is meaningful and that
continued character constants never have implicit spaces
appended to them to fill out the line. <br>
-ffixed-line-length-0 means the same thing as
-ffixed-line-length-none.</p>

<p style="margin-top: 1em">Options to Request or Suppress
Warnings <br>
Warnings are diagnostic messages that report constructions
which are not inherently erroneous but which are risky or
suggest there might have been an error.</p>

<p style="margin-top: 1em">You can request many specific
warnings with options beginning -W, for example -Wimplicit
to request warnings on implicit declarations. Each of these
specific warning options <br>
also has a negative form beginning -Wno- to turn off
warnings; for example, -Wno-implicit. This manual lists only
one of the two forms, whichever is not the default.</p>

<p style="margin-top: 1em">These options control the amount
and kinds of warnings produced by GNU Fortran:</p>

<p style="margin-top: 1em">-fsyntax-only <br>
Check the code for syntax errors, but don&rsquo;t do
anything beyond that.</p>

<p style="margin-top: 1em">-pedantic <br>
Issue warnings for uses of extensions to ANSI FORTRAN 77.
-pedantic also applies to C-language constructs where they
occur in GNU Fortran source files, such as use of \ in <br>
a character constant within a directive like #include.</p>

<p style="margin-top: 1em">Valid ANSI FORTRAN 77 programs
should compile properly with or without this option.
However, without this option, certain GNU extensions and
traditional Fortran features are <br>
supported as well. With this option, many of them are
rejected.</p>

<p style="margin-top: 1em">Some users try to use -pedantic
to check programs for strict ANSI conformance. They soon
find that it does not do quite what they want---it finds
some non-ANSI practices, <br>
but not all. However, improvements to g77 in this area are
welcome.</p>

<p style="margin-top: 1em">-pedantic-errors <br>
Like -pedantic, except that errors are produced rather than
warnings.</p>

<p style="margin-top: 1em">-fpedantic <br>
Like -pedantic, but applies only to Fortran constructs.</p>

<p style="margin-top: 1em">-w Inhibit all warning
messages.</p>

<p style="margin-top: 1em">-Wno-globals <br>
Inhibit warnings about use of a name as both a global name
(a subroutine, function, or block data program unit, or a
common block) and implicitly as the name of an intrinsic
<br>
in a source file.</p>

<p style="margin-top: 1em">Also inhibit warnings about
inconsistent invocations and/or definitions of global
procedures (function and subroutines). Such inconsistencies
include different numbers of <br>
arguments and different types of arguments.</p>

<p style="margin-top: 1em">-Wimplicit <br>
Warn whenever a variable, array, or function is implicitly
declared. Has an effect similar to using the &quot;IMPLICIT
NONE&quot; statement in every program unit. (Some Fortran
<br>
compilers provide this feature by an option named -u or
/WARNINGS=DECLARATIONS.)</p>

<p style="margin-top: 1em">-Wunused <br>
Warn whenever a variable is unused aside from its
declaration.</p>

<p style="margin-top: 1em">-Wuninitialized <br>
Warn whenever an automatic variable is used without first
being initialized.</p>

<p style="margin-top: 1em">These warnings are possible only
in optimizing compilation, because they require data-flow
information that is computed only when optimizing. If you
don&rsquo;t specify -O, you <br>
simply won&rsquo;t get these warnings.</p>

<p style="margin-top: 1em">These warnings occur only for
variables that are candidates for register allocation.
Therefore, they do not occur for a variable whose address is
taken, or whose size is <br>
other than 1, 2, 4 or 8 bytes. Also, they do not occur for
arrays, even when they are in registers.</p>

<p style="margin-top: 1em">Note that there might be no
warning about a variable that is used only to compute a
value that itself is never used, because such computations
may be deleted by data-flow <br>
analysis before the warnings are printed.</p>

<p style="margin-top: 1em">These warnings are made optional
because GNU Fortran is not smart enough to see all the
reasons why the code might be correct despite appearing to
have an error. Here is one <br>
example of how this can happen:</p>

<p style="margin-top: 1em">SUBROUTINE DISPAT(J) <br>
IF (J.EQ.1) I=1 <br>
IF (J.EQ.2) I=4 <br>
IF (J.EQ.3) I=5 <br>
CALL FOO(I) <br>
END</p>

<p style="margin-top: 1em">If the value of &quot;J&quot; is
always 1, 2 or 3, then &quot;I&quot; is always initialized,
but GNU Fortran doesn&rsquo;t know this. Here is another
common case:</p>

<p style="margin-top: 1em">SUBROUTINE MAYBE(FLAG) <br>
LOGICAL FLAG <br>
IF (FLAG) VALUE = 9.4 <br>
... <br>
IF (FLAG) PRINT *, VALUE <br>
END</p>

<p style="margin-top: 1em">This has no bug because
&quot;VALUE&quot; is used only if it is set.</p>

<p style="margin-top: 1em">-Wall <br>
The -Wunused and -Wuninitialized options combined. These are
all the options which pertain to usage that we recommend
avoiding and that we believe is easy to avoid. (As <br>
more warnings are added to g77 some might be added to the
list enabled by -Wall.)</p>

<p style="margin-top: 1em">The remaining -W... options are
not implied by -Wall because they warn about constructions
that we consider reasonable to use, on occasion, in clean
programs.</p>

<p style="margin-top: 1em">-Wsurprising <br>
Warn about &lsquo;&lsquo;suspicious&rsquo;&rsquo; constructs
that are interpreted by the compiler in a way that might
well be surprising to someone reading the code. These
differences can result in <br>
subtle, compiler-dependent (even machine-dependent)
behavioral differences. The constructs warned about
include:</p>

<p style="margin-top: 1em">&Acirc;&middot; Expressions
having two arithmetic operators in a row, such as X*-Y. Such
a construct is nonstandard, and can produce unexpected
results in more complicated situations <br>
such as X**-Y*Z. g77 along with many other compilers,
interprets this example differently than many programmers,
and a few other compilers. Specifically, g77 interprets <br>
X**-Y*Z as (X**(-Y))*Z, while others might think it should
be interpreted as X**(-(Y*Z)).</p>

<p style="margin-top: 1em">A revealing example is the
constant expression 2**-2*1., which g77 evaluates to .25,
while others might evaluate it to 0., the difference
resulting from the way <br>
precedence affects type promotion.</p>

<p style="margin-top: 1em">(The -fpedantic option also
warns about expressions having two arithmetic operators in a
row.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Expressions with
a unary minus followed by an operand and then a binary
operator other than plus or minus. For example, -2**2
produces a warning, because the precedence <br>
is -(2**2), yielding -4, not (-2)**2, which yields 4, and
which might represent what a programmer expects.</p>

<p style="margin-top: 1em">An example of an expression
producing different results in a surprising way is -I*S,
where I holds the value -2147483648 and S holds 0.5. On many
systems, negating I <br>
results in the same value, not a positive number, because it
is already the lower bound of what an
&quot;INTEGER(KIND=1)&quot; variable can hold. So, the
expression evaluates to a <br>
positive number, while the
&lsquo;&lsquo;expected&rsquo;&rsquo; interpretation, (-I)*S,
would evaluate to a negative number.</p>

<p style="margin-top: 1em">Even cases such as -I*J produce
warnings, even though, in most configurations and
situations, there is no computational difference between the
results of the two <br>
interpretations---the purpose of this warning is to warn
about differing interpretations and encourage a better style
of coding, not to identify only those places where <br>
bugs might exist in the user&rsquo;s code.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;DO&quot;
loops with &quot;DO&quot; variables that are not of integral
type---that is, using &quot;REAL&quot; variables as loop
control variables. Although such loops can be written to
work in <br>
the &lsquo;&lsquo;obvious&rsquo;&rsquo; way, the way g77 is
required by the Fortran standard to interpret such code is
likely to be quite different from the way many programmers
expect. (This <br>
is true of all &quot;DO&quot; loops, but the differences are
pronounced for non-integral loop control variables.)</p>

<p style="margin-top: 1em">-Werror <br>
Make all warnings into errors.</p>

<p style="margin-top: 1em">-W Turns on &lsquo;&lsquo;extra
warnings&rsquo;&rsquo; and, if optimization is specified via
-O, the -Wuninitialized option. (This might change in future
versions of g77</p>

<p style="margin-top: 1em">&lsquo;&lsquo;Extra
warnings&rsquo;&rsquo; are issued for:</p>

<p style="margin-top: 1em">&Acirc;&middot; Unused
parameters to a procedure (when -Wunused also is
specified).</p>

<p style="margin-top: 1em">&Acirc;&middot; Overflows
involving floating-point constants (not available for
certain configurations).</p>

<p style="margin-top: 1em">Some of these have no effect
when compiling programs written in Fortran:</p>

<p style="margin-top: 1em">-Wcomment <br>
-Wformat <br>
-Wparentheses <br>
-Wswitch <br>
-Wswitch-default <br>
-Wswitch-enum <br>
-Wtraditional <br>
-Wshadow <br>
-Wid-clash-len <br>
-Wlarger-than-len <br>
-Wconversion <br>
-Waggregate-return <br>
-Wredundant-decls <br>
These options all could have some relevant meaning for GNU
Fortran programs, but are not yet supported.</p>

<p style="margin-top: 1em">Options for Debugging Your
Program or GNU Fortran <br>
GNU Fortran has various special options that are used for
debugging either your program or g77</p>

<p style="margin-top: 1em">-g Produce debugging information
in the operating system&rsquo;s native format (stabs, COFF,
XCOFF, or DWARF). GDB can work with this debugging
information.</p>

<p style="margin-top: 1em">A sample debugging session looks
like this (note the use of the breakpoint):</p>

<p style="margin-top: 1em">$ cat gdb.f <br>
PROGRAM PROG <br>
DIMENSION A(10) <br>
DATA A /1.,2.,3.,4.,5.,6.,7.,8.,9.,10./ <br>
A(5) = 4. <br>
PRINT*,A <br>
END <br>
$ g77 -g -O gdb.f <br>
$ gdb a.out <br>
... <br>
(gdb) break MAIN__ <br>
Breakpoint 1 at 0x8048e96: file gdb.f, line 4. <br>
(gdb) run <br>
Starting program: /home/toon/g77-bugs/./a.out <br>
Breakpoint 1, MAIN__ () at gdb.f:4 <br>
4 A(5) = 4. <br>
Current language: auto; currently fortran <br>
(gdb) print a(5) <br>
$1 = 5 <br>
(gdb) step <br>
5 PRINT*,A <br>
(gdb) print a(5) <br>
$2 = 4 <br>
...</p>

<p style="margin-top: 1em">One could also add the setting
of the breakpoint and the first run command to the file
.gdbinit in the current directory, to simplify the debugging
session.</p>

<p style="margin-top: 1em">Options That Control
Optimization <br>
Most Fortran users will want to use no optimization when
developing and testing programs, and use -O or -O2 when
compiling programs for late-cycle testing and for production
use. <br>
However, note that certain diagnostics---such as for
uninitialized variables---depend on the flow analysis done
by -O, i.e. you must use -O or -O2 to get such
diagnostics.</p>

<p style="margin-top: 1em">The following flags have
particular applicability when compiling Fortran
programs:</p>

<p style="margin-top: 1em">-malign-double <br>
(Intel x86 architecture only.)</p>

<p style="margin-top: 1em">Noticeably improves performance
of g77 programs making heavy use of &quot;REAL(KIND=2)&quot;
(&quot;DOUBLE PRECISION&quot;) data on some systems. In
particular, systems using Pentium, Pentium <br>
Pro, 586, and 686 implementations of the i386 architecture
execute programs faster when &quot;REAL(KIND=2)&quot;
(&quot;DOUBLE PRECISION&quot;) data are aligned on 64-bit
boundaries in memory.</p>

<p style="margin-top: 1em">This option can, at least, make
benchmark results more consistent across various system
configurations, versions of the program, and data sets.</p>

<p style="margin-top: 1em">Note: The warning in the gcc
documentation about this option does not apply, generally
speaking, to Fortran code compiled by g77</p>

<p style="margin-top: 1em">Also also note: The negative
form of -malign-double is -mno-align-double, not
-benign-double.</p>

<p style="margin-top: 1em">-ffloat-store <br>
Might help a Fortran program that depends on exact IEEE
conformance on some machines, but might slow down a program
that doesn&rsquo;t.</p>

<p style="margin-top: 1em">This option is effective when
the floating-point unit is set to work in IEEE 854
&lsquo;extended precision&rsquo;---as it typically is on x86
and m68k GNU systems---rather than IEEE 754 <br>
double precision. -ffloat-store tries to remove the extra
precision by spilling data from floating-point registers
into memory and this typically involves a big performance
<br>
hit. However, it doesn&rsquo;t affect intermediate results,
so that it is only partially effective. &lsquo;Excess
precision&rsquo; is avoided in code like:</p>

<p style="margin-top: 1em">a = b + c <br>
d = a * e</p>

<p style="margin-top: 1em">but not in code like:</p>

<p style="margin-top: 1em">d = (b + c) * e</p>

<p style="margin-top: 1em">For another, potentially better,
way of controlling the precision, see Floating-point
precision.</p>

<p style="margin-top: 1em">-fforce-mem <br>
-fforce-addr <br>
Might improve optimization of loops.</p>

<p style="margin-top: 1em">-fno-inline <br>
Don&rsquo;t compile statement functions inline. Might reduce
the size of a program unit---which might be at expense of
some speed (though it should compile faster). Note that if
<br>
you are not optimizing, no functions can be expanded
inline.</p>

<p style="margin-top: 1em">-ffast-math <br>
Might allow some programs designed to not be too dependent
on IEEE behavior for floating-point to run faster, or die
trying. Sets -funsafe-math-optimizations, <br>
-ffinite-math-only, and -fno-trapping-math.</p>

<p style="margin-top: 1em">-funsafe-math-optimizations <br>
Allow optimizations that may be give incorrect results for
certain IEEE inputs.</p>

<p style="margin-top: 1em">-ffinite-math-only <br>
Allow optimizations for floating-point arithmetic that
assume that arguments and results are not NaNs or
+-Infs.</p>

<p style="margin-top: 1em">This option should never be
turned on by any -O option since it can result in incorrect
output for programs which depend on an exact implementation
of IEEE or ISO <br>
rules/specifications.</p>

<p style="margin-top: 1em">The default is
-fno-finite-math-only.</p>

<p style="margin-top: 1em">-fno-trapping-math <br>
Allow the compiler to assume that floating-point arithmetic
will not generate traps on any inputs. This is useful, for
example, when running a program using IEEE
&quot;non-stop&quot; <br>
floating-point arithmetic.</p>

<p style="margin-top: 1em">-fstrength-reduce <br>
Might make some loops run faster.</p>

<p style="margin-top: 1em">-frerun-cse-after-loop <br>
-fexpensive-optimizations <br>
-fdelayed-branch <br>
-fschedule-insns <br>
-fschedule-insns2 <br>
-fcaller-saves <br>
Might improve performance on some code.</p>

<p style="margin-top: 1em">-funroll-loops <br>
Typically improves performance on code using iterative
&quot;DO&quot; loops by unrolling them and is probably
generally appropriate for Fortran, though it is not turned
on at any <br>
optimization level. Note that outer loop unrolling
isn&rsquo;t done specifically; decisions about whether to
unroll a loop are made on the basis of its instruction
count.</p>

<p style="margin-top: 1em">Also, no &lsquo;loop
discovery&rsquo;[1] is done, so only loops written with
&quot;DO&quot; benefit from loop optimizations,
including---but not limited to---unrolling. Loops written
with &quot;IF&quot; <br>
and &quot;GOTO&quot; are not currently recognized as such.
This option unrolls only iterative &quot;DO&quot; loops, not
&quot;DO WHILE&quot; loops.</p>

<p style="margin-top: 1em">-funroll-all-loops <br>
Probably improves performance on code using &quot;DO
WHILE&quot; loops by unrolling them in addition to iterative
&quot;DO&quot; loops. In the absence of &quot;DO
WHILE&quot;, this option is equivalent <br>
to -funroll-loops but possibly slower.</p>

<p style="margin-top: 1em">-fno-move-all-movables <br>
-fno-reduce-all-givs <br>
-fno-rerun-loop-opt <br>
In general, the optimizations enabled with these options
will lead to faster code being generated by GNU Fortran;
hence they are enabled by default when issuing the g77 <br>
command.</p>

<p style="margin-top: 1em">-fmove-all-movables and
-freduce-all-givs will enable loop optimization to move all
loop-invariant index computations in nested loops over
multi-rank array dummy arguments <br>
out of these loops.</p>

<p style="margin-top: 1em">-frerun-loop-opt will move
offset calculations resulting from the fact that Fortran
arrays by default have a lower bound of 1 out of the
loops.</p>

<p style="margin-top: 1em">These three options are intended
to be removed someday, once loop optimization is
sufficiently advanced to perform all those transformations
without help from these options.</p>

<p style="margin-top: 1em">Options Controlling the
Preprocessor <br>
These options control the C preprocessor, which is run on
each C source file before actual compilation.</p>

<p style="margin-top: 1em">Some of these options also
affect how g77 processes the &quot;INCLUDE&quot; directive.
Since this directive is processed even when preprocessing is
not requested, it is not described in <br>
this section.</p>

<p style="margin-top: 1em">However, the &quot;INCLUDE&quot;
directive does not apply preprocessing to the contents of
the included file itself.</p>

<p style="margin-top: 1em">Therefore, any file that
contains preprocessor directives (such as
&quot;#include&quot;, &quot;#define&quot;, and
&quot;#if&quot;) must be included via the
&quot;#include&quot; directive, not via the
&quot;INCLUDE&quot; <br>
directive. Therefore, any file containing preprocessor
directives, if included, is necessarily included by a file
that itself contains preprocessor directives.</p>

<p style="margin-top: 1em">Options for Directory Search
<br>
These options affect how the cpp preprocessor searches for
files specified via the &quot;#include&quot; directive.
Therefore, when compiling Fortran programs, they are
meaningful when the <br>
preprocessor is used.</p>

<p style="margin-top: 1em">Some of these options also
affect how g77 searches for files specified via the
&quot;INCLUDE&quot; directive, although files included by
that directive are not, themselves, preprocessed. <br>
These options are:</p>

<p style="margin-top: 1em">-I- <br>
-Idir <br>
These affect interpretation of the &quot;INCLUDE&quot;
directive (as well as of the &quot;#include&quot; directive
of the cpp preprocessor).</p>

<p style="margin-top: 1em">Note that -Idir must be
specified without any spaces between -I and the directory
name---that is, -Ifoo/bar is valid, but -I foo/bar is
rejected by the g77 compiler (though <br>
the preprocessor supports the latter form). Also note that
the general behavior of -I and &quot;INCLUDE&quot; is pretty
much the same as of -I with &quot;#include&quot; in the cpp
preprocessor, <br>
with regard to looking for header.gcc files and other such
things.</p>

<p style="margin-top: 1em">Options for Code Generation
Conventions <br>
These machine-independent options control the interface
conventions used in code generation.</p>

<p style="margin-top: 1em">Most of them have both positive
and negative forms; the negative form of -ffoo would be
-fno-foo. In the table below, only one of the forms is
listed---the one which is not the <br>
default. You can figure out the other form by either
removing no- or adding it.</p>

<p style="margin-top: 1em">-fno-automatic <br>
Treat each program unit as if the &quot;SAVE&quot; statement
was specified for every local variable and array referenced
in it. Does not affect common blocks. (Some Fortran
compilers <br>
provide this option under the name -static.)</p>

<p style="margin-top: 1em">-finit-local-zero <br>
Specify that variables and arrays that are local to a
program unit (not in a common block and not passed as an
argument) are to be initialized to binary zeros.</p>

<p style="margin-top: 1em">Since there is a run-time
penalty for initialization of variables that are not given
the &quot;SAVE&quot; attribute, it might be a good idea to
also use -fno-automatic with <br>
-finit-local-zero.</p>

<p style="margin-top: 1em">-fno-f2c <br>
Do not generate code designed to be compatible with code
generated by f2c use the GNU calling conventions
instead.</p>

<p style="margin-top: 1em">The f2c calling conventions
require functions that return type &quot;REAL(KIND=1)&quot;
to actually return the C type &quot;double&quot;, and
functions that return type &quot;COMPLEX&quot; to return the
<br>
values via an extra argument in the calling sequence that
points to where to store the return value. Under the GNU
calling conventions, such functions simply return their <br>
results as they would in GNU C---&quot;REAL(KIND=1)&quot;
functions return the C type &quot;float&quot;, and
&quot;COMPLEX&quot; functions return the GNU C type
&quot;complex&quot; (or its &quot;struct&quot;
equivalent).</p>

<p style="margin-top: 1em">This does not affect the
generation of code that interfaces with the
&quot;libg2c&quot; library.</p>

<p style="margin-top: 1em">However, because the
&quot;libg2c&quot; library uses f2c calling conventions, g77
rejects attempts to pass intrinsics implemented by routines
in this library as actual arguments when <br>
-fno-f2c is used, to avoid bugs when they are actually
called by code expecting the GNU calling conventions to
work.</p>

<p style="margin-top: 1em">For example, INTRINSIC ABS;CALL
FOO(ABS) is rejected when -fno-f2c is in force. (Future
versions of the g77 run-time library might offer routines
that provide GNU-callable <br>
versions of the routines that implement the f2c intrinsics
that may be passed as actual arguments, so that valid
programs need not be rejected when -fno-f2c is used.)</p>

<p style="margin-top: 1em">Caution: If -fno-f2c is used
when compiling any source file used in a program, it must be
used when compiling all Fortran source files used in that
program.</p>

<p style="margin-top: 1em">-ff2c-library <br>
Specify that use of &quot;libg2c&quot; (or the original
&quot;libf2c&quot;) is required. This is the default for the
current version of g77</p>

<p style="margin-top: 1em">Currently it is not valid to
specify -fno-f2c-library. This option is provided so users
can specify it in shell scripts that build programs and
libraries that require the <br>
&quot;libf2c&quot; library, even when being compiled by
future versions of g77 that might otherwise default to
generating code for an incompatible library.</p>

<p style="margin-top: 1em">-fno-underscoring <br>
Do not transform names of entities specified in the Fortran
source file by appending underscores to them.</p>

<p style="margin-top: 1em">With -funderscoring in effect,
g77 appends two underscores to names with underscores and
one underscore to external names with no underscores. (g77
also appends two <br>
underscores to internal names with underscores to avoid
naming collisions with external names. The
-fno-second-underscore option disables appending of the
second underscore <br>
in all cases.)</p>

<p style="margin-top: 1em">This is done to ensure
compatibility with code produced by many UNIX Fortran
compilers, including f2c which perform the same
transformations.</p>

<p style="margin-top: 1em">Use of -fno-underscoring is not
recommended unless you are experimenting with issues such as
integration of (GNU) Fortran into existing system
environments (vis-a-vis <br>
existing libraries, tools, and so on).</p>

<p style="margin-top: 1em">For example, with
-funderscoring, and assuming other defaults like
-fcase-lower and that j() and max_count() are external
functions while my_var and lvar are local variables, <br>
a statement like</p>

<p style="margin-top: 1em">I = J() + MAX_COUNT (MY_VAR,
LVAR)</p>

<p style="margin-top: 1em">is implemented as something akin
to:</p>

<p style="margin-top: 1em">i = j_() +
max_count__(&amp;my_var__, &amp;lvar);</p>

<p style="margin-top: 1em">With -fno-underscoring, the same
statement is implemented as:</p>

<p style="margin-top: 1em">i = j() + max_count(&amp;my_var,
&amp;lvar);</p>

<p style="margin-top: 1em">Use of -fno-underscoring allows
direct specification of user-defined names while debugging
and when interfacing g77 code with other languages.</p>

<p style="margin-top: 1em">Note that just because the names
match does not mean that the interface implemented by g77
for an external name matches the interface implemented by
some other language for <br>
that same name. That is, getting code produced by g77 to
link to code produced by some other compiler using this or
any other method can be only a small part of the overall
<br>
solution---getting the code generated by both compilers to
agree on issues other than naming can require significant
effort, and, unlike naming disagreements, linkers <br>
normally cannot detect disagreements in these other
areas.</p>

<p style="margin-top: 1em">Also, note that with
-fno-underscoring, the lack of appended underscores
introduces the very real possibility that a user-defined
external name will conflict with a name in a <br>
system library, which could make finding
unresolved-reference bugs quite difficult in some
cases---they might occur at program run time, and show up
only as buggy behavior at <br>
run time.</p>

<p style="margin-top: 1em">In future versions of g77 we
hope to improve naming and linking issues so that debugging
always involves using the names as they appear in the
source, even if the names as <br>
seen by the linker are mangled to prevent accidental linking
between procedures with incompatible interfaces.</p>

<p style="margin-top: 1em">-fno-second-underscore <br>
Do not append a second underscore to names of entities
specified in the Fortran source file.</p>

<p style="margin-top: 1em">This option has no effect if
-fno-underscoring is in effect.</p>

<p style="margin-top: 1em">Otherwise, with this option, an
external name such as MAX_COUNT is implemented as a
reference to the link-time external symbol max_count_,
instead of max_count__.</p>

<p style="margin-top: 1em">-fno-ident <br>
Ignore the #ident directive.</p>

<p style="margin-top: 1em">-fzeros <br>
Treat initial values of zero as if they were any other
value.</p>

<p style="margin-top: 1em">As of version 0.5.18, g77
normally treats &quot;DATA&quot; and other statements that
are used to specify initial values of zero for variables and
arrays as if no values were actually <br>
specified, in the sense that no diagnostics regarding
multiple initializations are produced.</p>

<p style="margin-top: 1em">This is done to speed up
compiling of programs that initialize large arrays to
zeros.</p>

<p style="margin-top: 1em">Use -fzeros to revert to the
simpler, slower behavior that can catch multiple
initializations by keeping track of all initializations,
zero or otherwise.</p>

<p style="margin-top: 1em">Caution: Future versions of g77
might disregard this option (and its negative form, the
default) or interpret it somewhat differently. The
interpretation changes will affect <br>
only non-standard programs; standard-conforming programs
should not be affected.</p>

<p style="margin-top: 1em">-femulate-complex <br>
Implement &quot;COMPLEX&quot; arithmetic via emulation,
instead of using the facilities of the gcc back end that
provide direct support of &quot;complex&quot;
arithmetic.</p>

<p style="margin-top: 1em">(gcc had some bugs in its
back-end support for &quot;complex&quot; arithmetic, due
primarily to the support not being completed as of version
2.8.1 and &quot;egcs&quot; 1.1.2.)</p>

<p style="margin-top: 1em">Use -femulate-complex if you
suspect code-generation bugs, or experience compiler
crashes, that might result from g77 using the
&quot;COMPLEX&quot; support in the gcc back end. If <br>
using that option fixes the bugs or crashes you are seeing,
that indicates a likely g77 bugs (though, all compiler
crashes are considered bugs), so, please report it. (Note
<br>
that the known bugs, now believed fixed, produced compiler
crashes rather than causing the generation of incorrect
code.)</p>

<p style="margin-top: 1em">Use of this option should not
affect how Fortran code compiled by g77 works in terms of
its interfaces to other code, e.g. that compiled by f2c</p>

<p style="margin-top: 1em">As of GCC version 3.0, this
option is not necessary anymore.</p>

<p style="margin-top: 1em">Caution: Future versions of g77
might ignore both forms of this option.</p>

<p style="margin-top: 1em">-falias-check <br>
-fargument-alias <br>
-fargument-noalias <br>
-fno-argument-noalias-global <br>
Version info: These options are not supported by versions of
g77 based on gcc version 2.8.</p>

<p style="margin-top: 1em">These options specify to what
degree aliasing (overlap) is permitted between arguments
(passed as pointers) and &quot;COMMON&quot; (external, or
public) storage.</p>

<p style="margin-top: 1em">The default for Fortran code, as
mandated by the FORTRAN 77 and Fortran 90 standards, is
-fargument-noalias-global. The default for code written in
the C language family is <br>
-fargument-alias.</p>

<p style="margin-top: 1em">Note that, on some systems,
compiling with -fforce-addr in effect can produce more
optimal code when the default aliasing options are in effect
(and when optimization is <br>
enabled).</p>

<p style="margin-top: 1em">-fno-globals <br>
Disable diagnostics about inter-procedural analysis
problems, such as disagreements about the type of a function
or a procedure&rsquo;s argument, that might cause a compiler
crash <br>
when attempting to inline a reference to a procedure within
a program unit. (The diagnostics themselves are still
produced, but as warnings, unless -Wno-globals is <br>
specified, in which case no relevant diagnostics are
produced.)</p>

<p style="margin-top: 1em">Further, this option disables
such inlining, to avoid compiler crashes resulting from
incorrect code that would otherwise be diagnosed.</p>

<p style="margin-top: 1em">As such, this option might be
quite useful when compiling existing,
&lsquo;&lsquo;working&rsquo;&rsquo; code that happens to
have a few bugs that do not generally show themselves, but
which g77 <br>
diagnoses.</p>

<p style="margin-top: 1em">Use of this option therefore has
the effect of instructing g77 to behave more like it did up
through version 0.5.19.1, when it paid little or no
attention to disagreements <br>
between program units about a procedure&rsquo;s type and
argument information, and when it performed no inlining of
procedures (except statement functions).</p>

<p style="margin-top: 1em">Without this option, g77
defaults to performing the potentially inlining procedures
as it started doing in version 0.5.20, but as of version
0.5.21, it also diagnoses <br>
disagreements that might cause such inlining to crash the
compiler as (fatal) errors, and warns about similar
disagreements that are currently believed to not likely to
<br>
result in the compiler later crashing or producing incorrect
code.</p>

<p style="margin-top: 1em">-fflatten-arrays <br>
Use back end&rsquo;s C-like constructs (pointer plus offset)
instead of its &quot;ARRAY_REF&quot; construct to handle all
array references.</p>

<p style="margin-top: 1em">Note: This option is not
supported. It is intended for use only by g77 developers, to
evaluate code-generation issues. It might be removed at any
time.</p>

<p style="margin-top: 1em">-fbounds-check <br>
-ffortran-bounds-check <br>
Enable generation of run-time checks for array subscripts
and substring start and end points against the (locally)
declared minimum and maximum values.</p>

<p style="margin-top: 1em">The current implementation uses
the &quot;libf2c&quot; library routine &quot;s_rnge&quot; to
print the diagnostic.</p>

<p style="margin-top: 1em">However, whereas f2c generates a
single check per reference for a multi-dimensional array, of
the computed offset against the valid offset range (0
through the size of the <br>
array), g77 generates a single check per subscript
expression. This catches some cases of potential bugs that
f2c does not, such as references to below the beginning of
an <br>
assumed-size array.</p>

<p style="margin-top: 1em">g77 also generates checks for
&quot;CHARACTER&quot; substring references, something f2c
currently does not do.</p>

<p style="margin-top: 1em">Use the new
-ffortran-bounds-check option to specify bounds-checking for
only the Fortran code you are compiling, not necessarily for
code written in other languages.</p>

<p style="margin-top: 1em">Note: To provide more detailed
information on the offending subscript, g77 provides the
&quot;libg2c&quot; run-time library routine
&quot;s_rnge&quot; with somewhat differently-formatted <br>
information. Here&rsquo;s a sample diagnostic:</p>

<p style="margin-top: 1em">Subscript out of range on file
line 4, procedure rnge.f/bf. <br>
Attempt to access the -6-th element of variable
b[subscript-2-of-2]. <br>
Aborted</p>

<p style="margin-top: 1em">The above message indicates that
the offending source line is line 4 of the file rnge.f,
within the program unit (or statement function) named bf.
The offended array is <br>
named b. The offended array dimension is the second for a
two-dimensional array, and the offending, computed subscript
expression was -6.</p>

<p style="margin-top: 1em">For a &quot;CHARACTER&quot;
substring reference, the second line has this
appearance:</p>

<p style="margin-top: 1em">Attempt to access the 11-th
element of variable a[start-substring].</p>

<p style="margin-top: 1em">This indicates that the offended
&quot;CHARACTER&quot; variable or array is named a, the
offended substring position is the starting (leftmost)
position, and the offending substring <br>
expression is 11.</p>

<p style="margin-top: 1em">(Though the verbage of
&quot;s_rnge&quot; is not ideal for the purpose of the g77
compiler, the above information should provide adequate
diagnostic abilities to it users.)</p>

<p style="margin-top: 1em">Some of these do not work when
compiling programs written in Fortran:</p>

<p style="margin-top: 1em">-fpcc-struct-return <br>
-freg-struct-return <br>
You should not use these except strictly the same way as you
used them to build the version of &quot;libg2c&quot; with
which you will be linking all code compiled by g77 with the
same <br>
option.</p>

<p style="margin-top: 1em">-fshort-double <br>
This probably either has no effect on Fortran programs, or
makes them act loopy.</p>

<p style="margin-top: 1em">-fno-common <br>
Do not use this when compiling Fortran programs, or there
will be Trouble.</p>

<p style="margin-top: 1em">-fpack-struct <br>
This probably will break any calls to the &quot;libg2c&quot;
library, at the very least, even if it is built with the
same option.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
GNU Fortran currently does not make use of any environment
variables to control its operation above and beyond those
that affect the operation of gcc.</p>

<p style="margin-top: 1em">BUGS <br>
For instructions on reporting bugs, see
&lt;http://gcc.gnu.org/bugs.html&gt;. Use of the gccbug
script to report bugs is recommended.</p>

<p style="margin-top: 1em">FOOTNOTES <br>
1. loop discovery refers to the process by which a compiler,
or indeed any reader of a program, determines which portions
of the program are more likely to be executed <br>
repeatedly as it is being run. Such discovery typically is
done early when compiling using optimization techniques, so
the &lsquo;&lsquo;discovered&rsquo;&rsquo; loops get more
attention---and more <br>
run-time resources, such as registers---from the compiler.
It is easy to &lsquo;&lsquo;discover&rsquo;&rsquo; loops
that are constructed out of looping constructs in the
language (such as Fortran&rsquo;s <br>
&quot;DO&quot;). For some programs,
&lsquo;&lsquo;discovering&rsquo;&rsquo; loops constructed
out of lower-level constructs (such as &quot;IF&quot; and
&quot;GOTO&quot;) can lead to generation of more optimal
code than <br>
otherwise.</p>

<p style="margin-top: 1em">SEE ALSO <br>
gpl(7), gfdl(7), fsf-funding(7), cpp(1), gcov(1), gcc(1),
as(1), ld(1), gdb(1), adb(1), dbx(1), sdb(1) and the Info
entries for gcc, cpp, g77, as, ld, binutils and gdb.</p>

<p style="margin-top: 1em">AUTHOR <br>
See the Info entry for g77 for contributors to GCC and
G77.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (c) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004
Free Software Foundation, Inc.</p>

<p style="margin-top: 1em">Permission is granted to copy,
distribute and/or modify this document under the terms of
the GNU Free Documentation License, Version 1.2 or any later
version published by the <br>
Free Software Foundation; with the Invariant Sections being
&lsquo;&lsquo;GNU General Public License&rsquo;&rsquo; and
&lsquo;&lsquo;Funding Free Software&rsquo;&rsquo;, the
Front-Cover texts being (a) (see below), and with <br>
the Back-Cover Texts being (b) (see below). A copy of the
license is included in the gfdl(7) man page.</p>

<p style="margin-top: 1em">(a) The FSF&rsquo;s Front-Cover
Text is:</p>

<p style="margin-top: 1em">A GNU Manual</p>

<p style="margin-top: 1em">(b) The FSF&rsquo;s Back-Cover
Text is:</p>

<p style="margin-top: 1em">You have freedom to copy and
modify this GNU Manual, like GNU <br>
software. Copies published by the Free Software Foundation
raise <br>
funds for GNU development.</p>

<p style="margin-top: 1em">gcc-3.4.6 2016-08-12 G77(1)</p>
<hr>
</body>
</html>
