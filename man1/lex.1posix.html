<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:21:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>LEX(1POSIX) POSIX Programmer&rsquo;s Manual
LEX(1POSIX)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
lex &acirc; generate programs for lexical tasks
(DEVELOPMENT)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
lex [&acirc;t] [&acirc;n|&acirc;v] [file...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The lex utility shall generate C programs to be used in
lexical processing of character input, and that can be used
as an interface to yacc. The C programs shall be generated
<br>
from lex source code and conform to the ISO C standard,
without depending on any undefined, unspecified, or
implementation-defined behavior, except in cases where the
code is <br>
copied directly from the supplied source, or in cases that
are documented by the implementation. Usually, the lex
utility shall write the program it generates to the file
<br>
lex.yy.c; the state of this file is unspecified if lex exits
with a non-zero exit status. See the EXTENDED DESCRIPTION
section for a complete description of the lex input
lan&acirc; <br>
guage.</p>

<p style="margin-top: 1em">OPTIONS <br>
The lex utility shall conform to the Base Definitions volume
of POSIX.1&acirc;2008, Section 12.2, Utility Syntax
Guidelines, except for Guideline 9.</p>

<p style="margin-top: 1em">The following options shall be
supported:</p>

<p style="margin-top: 1em">&acirc;n Suppress the summary of
statistics usually written with the &acirc;v option. If no
table sizes are specified in the lex source code and the
&acirc;v option is not specified, then <br>
&acirc;n is implied.</p>

<p style="margin-top: 1em">&acirc;t Write the resulting
program to standard output instead of lex.yy.c.</p>

<p style="margin-top: 1em">&acirc;v Write a summary of lex
statistics to the standard output. (See the discussion of
lex table sizes in Definitions in lex.) If the &acirc;t
option is specified and &acirc;n is not <br>
specified, this report shall be written to standard error.
If table sizes are specified in the lex source code, and if
the &acirc;n option is not specified, the &acirc;v option
may <br>
be enabled.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operand shall be supported:</p>

<p style="margin-top: 1em">file A pathname of an input
file. If more than one such file is specified, all files
shall be concatenated to produce a single lex program. If no
file operands are speci&acirc; <br>
fied, or if a file operand is &rsquo;&acirc;&rsquo;, the
standard input shall be used.</p>

<p style="margin-top: 1em">STDIN <br>
The standard input shall be used if no file operands are
specified, or if a file operand is &rsquo;&acirc;&rsquo;.
See INPUT FILES.</p>

<p style="margin-top: 1em">INPUT FILES <br>
The input files shall be text files containing lex source
code, as described in the EXTENDED DESCRIPTION section.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of lex:</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of POSIX.1&acirc;2008,
Section 8.2, Internationaliza&acirc; <br>
tion Variables for the precedence of internationalization
variables used to determine the values of locale
categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_COLLATE <br>
Determine the locale for the behavior of ranges, equivalence
classes, and multi-character collating elements within
regular expressions. If this variable is not set to <br>
the POSIX locale, the results are unspecified.</p>

<p style="margin-top: 1em">LC_CTYPE Determine the locale
for the interpretation of sequences of bytes of text data as
characters (for example, single-byte as opposed to
multi-byte characters in arguments <br>
and input files), and the behavior of character classes
within regular expressions. If this variable is not set to
the POSIX locale, the results are unspecified.</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">NLSPATH Determine the location
of message catalogs for the processing of LC_MESSAGES.</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
Default.</p>

<p style="margin-top: 1em">STDOUT <br>
If the &acirc;t option is specified, the text file of C
source code output of lex shall be written to standard
output.</p>

<p style="margin-top: 1em">If the &acirc;t option is not
specified:</p>

<p style="margin-top: 1em">* Implementation-defined
informational, error, and warning messages concerning the
contents of lex source code input shall be written to either
the standard output or standard <br>
error.</p>

<p style="margin-top: 1em">* If the &acirc;v option is
specified and the &acirc;n option is not specified, lex
statistics shall also be written to either the standard
output or standard error, in an implementation- <br>
defined format. These statistics may also be generated if
table sizes are specified with a &rsquo;%&rsquo; operator in
the Definitions section, as long as the &acirc;n option is
not specified.</p>

<p style="margin-top: 1em">STDERR <br>
If the &acirc;t option is specified, implementation-defined
informational, error, and warning messages concerning the
contents of lex source code input shall be written to the
standard <br>
error.</p>

<p style="margin-top: 1em">If the &acirc;t option is not
specified:</p>

<p style="margin-top: 1em">1. Implementation-defined
informational, error, and warning messages concerning the
contents of lex source code input shall be written to either
the standard output or standard <br>
error.</p>

<p style="margin-top: 1em">2. If the &acirc;v option is
specified and the &acirc;n option is not specified, lex
statistics shall also be written to either the standard
output or standard error, in an implementation- <br>
defined format. These statistics may also be generated if
table sizes are specified with a &rsquo;%&rsquo; operator in
the Definitions section, as long as the &acirc;n option is
not specified.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
A text file containing C source code shall be written to
lex.yy.c, or to the standard output if the &acirc;t option
is present.</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
Each input file shall contain lex source code, which is a
table of regular expressions with corresponding actions in
the form of C program fragments.</p>

<p style="margin-top: 1em">When lex.yy.c is compiled and
linked with the lex library (using the &acirc;l l operand
with c99), the resulting program shall read character input
from the standard input and shall <br>
partition it into strings that match the given
expressions.</p>

<p style="margin-top: 1em">When an expression is matched,
these actions shall occur:</p>

<p style="margin-top: 1em">* The input string that was
matched shall be left in yytext as a null-terminated string;
yytext shall either be an external character array or a
pointer to a character string. <br>
As explained in Definitions in lex, the type can be
explicitly selected using the %array or %pointer
declarations, but the default is implementation-defined.</p>

<p style="margin-top: 1em">* The external int yyleng shall
be set to the length of the matching string.</p>

<p style="margin-top: 1em">* The expression&rsquo;s
corresponding program fragment, or action, shall be
executed.</p>

<p style="margin-top: 1em">During pattern matching, lex
shall search the set of patterns for the single longest
possible match. Among rules that match the same number of
characters, the rule given first <br>
shall be chosen.</p>

<p style="margin-top: 1em">The general format of lex source
shall be:</p>

<p style="margin-top: 1em">Definitions %% Rules %%
UserSubroutines</p>

<p style="margin-top: 1em">The first &quot;%%&quot; is
required to mark the beginning of the rules (regular
expressions and actions); the second &quot;%%&quot; is
required only if user subroutines follow.</p>

<p style="margin-top: 1em">Any line in the Definitions
section beginning with a &lt;blank&gt; shall be assumed to
be a C program fragment and shall be copied to the external
definition area of the lex.yy.c file. <br>
Similarly, anything in the Definitions section included
between delimiter lines containing only &quot;%{&quot; and
&quot;%}&quot; shall also be copied unchanged to the
external definition area of <br>
the lex.yy.c file.</p>

<p style="margin-top: 1em">Any such input (beginning with a
&lt;blank&gt; or within &quot;%{&quot; and &quot;%}&quot;
delimiter lines) appearing at the beginning of the Rules
section before any rules are specified shall be written <br>
to lex.yy.c after the declarations of variables for the
yylex() function and before the first line of code in
yylex(). Thus, user variables local to yylex() can be
declared <br>
here, as well as application code to execute upon entry to
yylex().</p>

<p style="margin-top: 1em">The action taken by lex when
encountering any input beginning with a &lt;blank&gt; or
within &quot;%{&quot; and &quot;%}&quot; delimiter lines
appearing in the Rules section but coming after one or more
<br>
rules is undefined. The presence of such input may result in
an erroneous definition of the yylex() function.</p>

<p style="margin-top: 1em">C-language code in the input
shall not contain C-language trigraphs. The C-language code
within &quot;%{&quot; and &quot;%}&quot; delimiter lines
shall not contain any lines consisting only of <br>
&quot;%}&quot;, or only of &quot;%%&quot;.</p>

<p style="margin-top: 1em">Definitions in lex <br>
Definitions appear before the first &quot;%%&quot;
delimiter. Any line in this section not contained between
&quot;%{&quot; and &quot;%}&quot; lines and not beginning
with a &lt;blank&gt; shall be assumed to define <br>
a lex substitution string. The format of these lines shall
be:</p>

<p style="margin-top: 1em">name substitute</p>

<p style="margin-top: 1em">If a name does not meet the
requirements for identifiers in the ISO C standard, the
result is undefined. The string substitute shall replace the
string {name} when it is used in <br>
a rule. The name string shall be recognized in this context
only when the braces are provided and when it does not
appear within a bracket expression or within
double-quotes.</p>

<p style="margin-top: 1em">In the Definitions section, any
line beginning with a &lt;percent-sign&gt; (&rsquo;%&rsquo;)
character and followed by an alphanumeric word beginning
with either &rsquo;s&rsquo; or &rsquo;S&rsquo; shall define
a set of <br>
start conditions. Any line beginning with a &rsquo;%&rsquo;
followed by a word beginning with either &rsquo;x&rsquo; or
&rsquo;X&rsquo; shall define a set of exclusive start
conditions. When the generated scanner <br>
is in a %s state, patterns with no state specified shall be
also active; in a %x state, such patterns shall not be
active. The rest of the line, after the first word, shall be
<br>
considered to be one or more &lt;blank&gt;-separated names
of start conditions. Start condition names shall be
constructed in the same way as definition names. Start
conditions can be <br>
used to restrict the matching of regular expressions to one
or more states as described in Regular Expressions in
lex.</p>

<p style="margin-top: 1em">Implementations shall accept
either of the following two mutually-exclusive declarations
in the Definitions section:</p>

<p style="margin-top: 1em">%array Declare the type of
yytext to be a null-terminated character array.</p>

<p style="margin-top: 1em">%pointer Declare the type of
yytext to be a pointer to a null-terminated character
string.</p>

<p style="margin-top: 1em">The default type of yytext is
implementation-defined. If an application refers to yytext
outside of the scanner source file (that is, via an extern),
the application shall <br>
include the appropriate %array or %pointer declaration in
the scanner source file.</p>

<p style="margin-top: 1em">Implementations shall accept
declarations in the Definitions section for setting certain
internal table sizes. The declarations are shown in the
following table.</p>

<p style="margin-top: 1em">Table: Table Size Declarations
in lex</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;Declaration &acirc; Description &acirc; Minimum Value
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;%p n &acirc; Number of positions &acirc; 2500 &acirc;
<br>
&acirc;%n n &acirc; Number of states &acirc; 500 &acirc;
<br>
&acirc;%a n &acirc; Number of transitions &acirc; 2000
&acirc; <br>
&acirc;%e n &acirc; Number of parse tree nodes &acirc; 1000
&acirc; <br>
&acirc;%k n &acirc; Number of packed character classes
&acirc; 1000 &acirc; <br>
&acirc;%o n &acirc; Size of the output array &acirc; 3000
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
In the table, n represents a positive decimal integer,
preceded by one or more &lt;blank&gt; characters. The exact
meaning of these table size numbers is
implementation-defined. The <br>
implementation shall document how these numbers affect the
lex utility and how they are related to any output that may
be generated by the implementation should limitations be
<br>
encountered during the execution of lex. It shall be
possible to determine from this output which of the table
size values needs to be modified to permit lex to
successfully <br>
generate tables for the input language. The values in the
column Minimum Value represent the lowest values conforming
implementations shall provide.</p>

<p style="margin-top: 1em">Rules in lex <br>
The rules in lex source files are a table in which the left
column contains regular expressions and the right column
contains actions (C program fragments) to be executed when
<br>
the expressions are recognized.</p>

<p style="margin-top: 1em">ERE action <br>
ERE action <br>
...</p>

<p style="margin-top: 1em">The extended regular expression
(ERE) portion of a row shall be separated from action by one
or more &lt;blank&gt; characters. A regular expression
containing &lt;blank&gt; characters shall <br>
be recognized under one of the following conditions:</p>

<p style="margin-top: 1em">* The entire expression appears
within double-quotes.</p>

<p style="margin-top: 1em">* The &lt;blank&gt; characters
appear within double-quotes or square brackets.</p>

<p style="margin-top: 1em">* Each &lt;blank&gt; is preceded
by a &lt;backslash&gt; character.</p>

<p style="margin-top: 1em">User Subroutines in lex <br>
Anything in the user subroutines section shall be copied to
lex.yy.c following yylex().</p>

<p style="margin-top: 1em">Regular Expressions in lex <br>
The lex utility shall support the set of extended regular
expressions (see the Base Definitions volume of
POSIX.1&acirc;2008, Section 9.4, Extended Regular
Expressions), with the fol&acirc; <br>
lowing additions and exceptions to the syntax:</p>

<p style="margin-top: 1em">&quot;...&quot; Any string
enclosed in double-quotes shall represent the characters
within the double-quotes as themselves, except that
&lt;backslash&gt;-escapes (which appear in the follow&acirc;
<br>
ing table) shall be recognized. Any &lt;backslash&gt;-escape
sequence shall be terminated by the closing quote. For
example, &quot; 1&quot;&quot;1&quot; represents a single
string: the octal <br>
value 1 followed by the character &rsquo;1&rsquo;.</p>

<p style="margin-top: 1em">&lt;state&gt;r,
&lt;state1,state2,...&gt;r <br>
The regular expression r shall be matched only when the
program is in one of the start conditions indicated by
state, state1, and so on; see Actions in lex. (As an <br>
exception to the typographical conventions of the rest of
this volume of POSIX.1&acirc;2008, in this case
&lt;state&gt; does not represent a metavariable, but the
literal angle- <br>
bracket characters surrounding a symbol.) The start
condition shall be recognized as such only at the beginning
of a regular expression.</p>

<p style="margin-top: 1em">r/x The regular expression r
shall be matched only if it is followed by an occurrence of
regular expression x (x is the instance of trailing context,
further defined <br>
below). The token returned in yytext shall only match r. If
the trailing portion of r matches the beginning of x, the
result is unspecified. The r expression cannot <br>
include further trailing context or the &rsquo;$&rsquo;
(match-end-of-line) operator; x cannot include the
&rsquo;^&rsquo; (match-beginning-of-line) operator, nor
trailing context, nor the &rsquo;$&rsquo; <br>
operator. That is, only one occurrence of trailing context
is allowed in a lex regular expression, and the
&rsquo;^&rsquo; operator only can be used at the beginning
of such an <br>
expression.</p>

<p style="margin-top: 1em">{name} When name is one of the
substitution symbols from the Definitions section, the
string, including the enclosing braces, shall be replaced by
the substitute value. The <br>
substitute value shall be treated in the extended regular
expression as if it were enclosed in parentheses. No
substitution shall occur if {name} occurs within a <br>
bracket expression or within double-quotes.</p>

<p style="margin-top: 1em">Within an ERE, a
&lt;backslash&gt; character shall be considered to begin an
escape sequence as specified in the table in the Base
Definitions volume of POSIX.1&acirc;2008, Chapter 5,
File&rsquo;, &rsquo;&rsquo;, &rsquo;. In addition, <br>
Format Notation (&rsquo;\&rsquo;, &rsquo;&rsquo;, &rsquo;,,
&rsquo;0, &rsquo; the escape sequences in the following
table shall be recognized.</p>

<p style="margin-top: 1em">A literal &lt;newline&gt; cannot
occur within an ERE; the escape sequence &rsquo;0 can be
used to represent a &lt;newline&gt;. A &lt;newline&gt; shall
not be matched by a period operator.</p>

<p style="margin-top: 1em">Table: Escape Sequences in
lex</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; Escape &acirc; &acirc; &acirc; <br>
&acirc;Sequence &acirc; Description &acirc; Meaning &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;igits &acirc; A &lt;backslash&gt; character &acirc;
The character whose &acirc; <br>
&acirc; &acirc; followed by the longest &acirc; encoding is
represented &acirc; <br>
&acirc; &acirc; sequence of one, two, or &acirc; by the one,
two, or &acirc; <br>
&acirc; &acirc; three octal-digit char&acirc; &acirc;
three-digit octal inte&acirc; &acirc; <br>
&acirc; &acirc; acters (01234567). If &acirc; ger.
Multi-byte charac&acirc; &acirc; <br>
&acirc; &acirc; all of the digits are 0 &acirc; ters require
multiple, &acirc; <br>
&acirc; &acirc; (that is, representation &acirc;
concatenated escape &acirc; <br>
&acirc; &acirc; of the NUL character), &acirc; sequences of
this type, &acirc; <br>
&acirc; &acirc; the behavior is unde&acirc; &acirc;
including the leading &acirc; <br>
&acirc; &acirc; fined. &acirc; &lt;backslash&gt; for each
&acirc; <br>
&acirc; &acirc; &acirc; byte. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;gits &acirc; A &lt;backslash&gt; character &acirc;
The character whose &acirc; <br>
&acirc; &acirc; followed by the longest &acirc; encoding is
represented &acirc; <br>
&acirc; &acirc; sequence of hexadecimal- &acirc; by the
hexadecimal inte&acirc; &acirc; <br>
&acirc; &acirc; digit characters &acirc; ger. &acirc; <br>
&acirc; &acirc; (01234567abcdefABCDEF). &acirc; &acirc; <br>
&acirc; &acirc; If all of the digits are &acirc; &acirc;
<br>
&acirc; &acirc; 0 (that is, representa&acirc; &acirc;
&acirc; <br>
&acirc; &acirc; tion of the NUL charac&acirc; &acirc;
&acirc; <br>
&acirc; &acirc; ter), the behavior is &acirc; &acirc; <br>
&acirc; &acirc; undefined. &acirc; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc; &acirc; &acirc; followed by any charac&acirc;
&acirc; unchanged. &acirc; <br>
&acirc; &acirc; ter not described in &acirc; &acirc; <br>
&acirc; &acirc; this table or in the ta&acirc; &acirc;
&acirc; <br>
&acirc; &acirc; ble in the Base Defini&acirc; &acirc;
&acirc; <br>
&acirc; &acirc; tions volume of &acirc; &acirc; <br>
&acirc; &acirc; POSIX.1&acirc;2008, Chapter 5, &acirc;
&acirc; <br>
&acirc; &acirc; File Format Notation &acirc; &acirc; <br>
&acirc; &acirc; (&rsquo;\&rsquo;, &rsquo;&rsquo;, &rsquo;,,
&acirc; &acirc; <br>
&acirc;&rsquo;, &rsquo;&rsquo;, &rsquo;. &acirc; &acirc;
&acirc; &rsquo;0, &rsquo; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
Note: If a &rsquo;equence needs to be immediately followed
by a hexadecimal digit character, a sequence such as
&quot;&quot;&quot;1&quot; can be used, which represents a
character containing <br>
the value 1, followed by the character &rsquo;1&rsquo;.</p>

<p style="margin-top: 1em">The order of precedence given to
extended regular expressions for lex differs from that
specified in the Base Definitions volume of
POSIX.1&acirc;2008, Section 9.4, Extended Regular <br>
Expressions. The order of precedence for lex shall be as
shown in the following table, from high to low.</p>

<p style="margin-top: 1em">Note: The escaped characters
entry is not meant to imply that these are operators, but
they are included in the table to show their relationships
to the true operators. The <br>
start condition, trailing context, and anchoring notations
have been omitted from the table because of the placement
restrictions described in this section; they can <br>
only appear at the beginning or ending of an ERE.</p>

<p style="margin-top: 1em">Table: ERE Precedence in lex</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; Extended Regular Expression &acirc; Precedence
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;collation-related bracket symbols &acirc; [= =] [: :]
[. .] &acirc; <br>
&acirc;escaped characters &acirc; &lt;special character&gt;
&acirc; <br>
&acirc;bracket expression &acirc; [ ] &acirc; <br>
&acirc;quoting &acirc; &quot;...&quot; &acirc; <br>
&acirc;grouping &acirc; ( ) &acirc; <br>
&acirc;definition &acirc; {name} &acirc; <br>
&acirc;single-character RE duplication &acirc; * + ? &acirc;
<br>
&acirc;concatenation &acirc; &acirc; <br>
&acirc;interval expression &acirc; {m,n} &acirc; <br>
&acirc;alternation &acirc; | &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
The ERE anchoring operators &rsquo;^&rsquo; and
&rsquo;$&rsquo; do not appear in the table. With lex regular
expressions, these operators are restricted in their use:
the &rsquo;^&rsquo; operator can only be used <br>
at the beginning of an entire regular expression, and the
&rsquo;$&rsquo; operator only at the end. The operators
apply to the entire regular expression. Thus, for example,
the pattern <br>
&quot;(^abc)|(def$)&quot; is undefined; it can instead be
written as two separate rules, one with the regular
expression &quot;^abc&quot; and one with &quot;def$&quot;,
which share a common action via the <br>
special &rsquo;|&rsquo; action (see below). If the pattern
were written &quot;^abc|def$&quot;, it would match either
&quot;abc&quot; or &quot;def&quot; on a line by itself.</p>

<p style="margin-top: 1em">Unlike the general ERE rules,
embedded anchoring is not allowed by most historical lex
implementations. An example of embedded anchoring would be
for patterns such as <br>
&quot;(^| )foo( |$)&quot; to match &quot;foo&quot; when it
exists as a complete word. This functionality can be
obtained using existing lex features:</p>

<p style="margin-top: 1em">^foo/[ 0 | <br>
&quot; foo&quot;/[ 0 /* Found foo as a separate word. */</p>

<p style="margin-top: 1em">Note also that &rsquo;$&rsquo;
is a form of trailing context (it is equivalent to &quot;/0)
and as such cannot be used with regular expressions
containing another instance of the operator (see <br>
the preceding discussion of trailing context).</p>

<p style="margin-top: 1em">The additional regular
expressions trailing-context operator &rsquo;/&rsquo; can be
used as an ordinary character if presented within
double-quotes, &quot;/&quot;; preceded by a
&lt;backslash&gt;, &quot;&quot;; or <br>
within a bracket expression, &quot;[/]&quot;. The
start-condition &rsquo;&lt;&rsquo; and &rsquo;&gt;&rsquo;
operators shall be special only in a start condition at the
beginning of a regular expression; elsewhere in <br>
the regular expression they shall be treated as ordinary
characters.</p>

<p style="margin-top: 1em">Actions in lex <br>
The action to be taken when an ERE is matched can be a C
program fragment or the special actions described below; the
program fragment can contain one or more C statements, and
<br>
can also include special actions. The empty C statement
&rsquo;;&rsquo; shall be a valid action; any string in the
lex.yy.c input that matches the pattern portion of such a
rule is effec&acirc; <br>
tively ignored or skipped. However, the absence of an action
shall not be valid, and the action lex takes in such a
condition is undefined.</p>

<p style="margin-top: 1em">The specification for an action,
including C statements and special actions, can extend
across several lines if enclosed in braces:</p>

<p style="margin-top: 1em">ERE &lt;one or more blanks&gt; {
program statement <br>
program statement }</p>

<p style="margin-top: 1em">The program statements shall not
contain unbalanced curly brace preprocessing tokens.</p>

<p style="margin-top: 1em">The default action when a string
in the input to a lex.yy.c program is not matched by any
expression shall be to copy the string to the output.
Because the default behavior of a <br>
program generated by lex is to read the input and copy it to
the output, a minimal lex source program that has just
&quot;%%&quot; shall generate a C program that simply copies
the input <br>
to the output unchanged.</p>

<p style="margin-top: 1em">Four special actions shall be
available:</p>

<p style="margin-top: 1em">| ECHO; REJECT; BEGIN</p>

<p style="margin-top: 1em">| The action &rsquo;|&rsquo;
means that the action for the next rule is the action for
this rule. Unlike the other three actions, &rsquo;|&rsquo;
cannot be enclosed in braces or be &lt;semi&acirc; <br>
colon&gt;-terminated; the application shall ensure that it
is specified alone, with no other actions.</p>

<p style="margin-top: 1em">ECHO; Write the contents of the
string yytext on the output.</p>

<p style="margin-top: 1em">REJECT; Usually only a single
expression is matched by a given string in the input. REJECT
means &lsquo;&lsquo;continue to the next expression that
matches the current input&rsquo;&rsquo;, and shall <br>
cause whatever rule was the second choice after the current
rule to be executed for the same input. Thus, multiple rules
can be matched and executed for one input <br>
string or overlapping input strings. For example, given the
regular expressions &quot;xyz&quot; and &quot;xy&quot; and
the input &quot;xyz&quot;, usually only the regular
expression &quot;xyz&quot; would <br>
match. The next attempted match would start after z. If the
last action in the &quot;xyz&quot; rule is REJECT, both this
rule and the &quot;xy&quot; rule would be executed. The
REJECT <br>
action may be implemented in such a fashion that flow of
control does not continue after it, as if it were equivalent
to a goto to another part of yylex(). The use of <br>
REJECT may result in somewhat larger and slower
scanners.</p>

<p style="margin-top: 1em">BEGIN The action:</p>

<p style="margin-top: 1em">BEGIN newstate;</p>

<p style="margin-top: 1em">switches the state (start
condition) to newstate. If the string newstate has not been
declared previously as a start condition in the Definitions
section, the results <br>
are unspecified. The initial state is indicated by the digit
&rsquo;0&rsquo; or the token INITIAL.</p>

<p style="margin-top: 1em">The functions or macros
described below are accessible to user code included in the
lex input. It is unspecified whether they appear in the C
code output of lex, or are accessi&acirc; <br>
ble only through the &acirc;l l operand to c99 (the lex
library).</p>

<p style="margin-top: 1em">int yylex(void) <br>
Performs lexical analysis on the input; this is the primary
function generated by the lex utility. The function shall
return zero when the end of input is reached; other&acirc;
<br>
wise, it shall return non-zero values (tokens) determined by
the actions that are selected.</p>

<p style="margin-top: 1em">int yymore(void) <br>
When called, indicates that when the next input string is
recognized, it is to be appended to the current value of
yytext rather than replacing it; the value in yyleng <br>
shall be adjusted accordingly.</p>

<p style="margin-top: 1em">int yyless(int n) <br>
Retains n initial characters in yytext, NUL-terminated, and
treats the remaining characters as if they had not been
read; the value in yyleng shall be adjusted accordingly.</p>

<p style="margin-top: 1em">int input(void) <br>
Returns the next character from the input, or zero on
end-of-file. It shall obtain input from the stream pointer
yyin, although possibly via an intermediate buffer. Thus,
<br>
once scanning has begun, the effect of altering the value of
yyin is undefined. The character read shall be removed from
the input stream of the scanner without any pro&acirc; <br>
cessing by the scanner.</p>

<p style="margin-top: 1em">int unput(int c) <br>
Returns the character &rsquo;c&rsquo; to the input; yytext
and yyleng are undefined until the next expression is
matched. The result of using unput() for more characters
than have been <br>
input is unspecified.</p>

<p style="margin-top: 1em">The following functions shall
appear only in the lex library accessible through the
&acirc;l l operand; they can therefore be redefined by a
conforming application:</p>

<p style="margin-top: 1em">int yywrap(void) <br>
Called by yylex() at end-of-file; the default yywrap() shall
always return 1. If the application requires yylex() to
continue processing with another source of input, then <br>
the application can include a function yywrap(), which
associates another file with the external variable FILE *
yyin and shall return a value of zero.</p>

<p style="margin-top: 1em">int main(int argc, char *argv[])
<br>
Calls yylex() to perform lexical analysis, then exits. The
user code can contain main() to perform application-specific
operations, calling yylex() as applicable.</p>

<p style="margin-top: 1em">Except for input(), unput(), and
main(), all external and static names generated by lex shall
begin with the prefix yy or YY.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The following exit values shall be returned:</p>

<p style="margin-top: 1em">0 Successful completion.</p>

<p style="margin-top: 1em">&gt;0 An error occurred.</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
Default.</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
Conforming applications are warned that in the Rules
section, an ERE without an action is not acceptable, but
need not be detected as erroneous by lex. This may result in
compi&acirc; <br>
lation or runtime errors.</p>

<p style="margin-top: 1em">The purpose of input() is to
take characters off the input stream and discard them as far
as the lexical analysis is concerned. A common use is to
discard the body of a comment <br>
once the beginning of a comment is recognized.</p>

<p style="margin-top: 1em">The lex utility is not fully
internationalized in its treatment of regular expressions in
the lex source code or generated lexical analyzer. It would
seem desirable to have the <br>
lexical analyzer interpret the regular expressions given in
the lex source according to the environment specified when
the lexical analyzer is executed, but this is not possible
<br>
with the current lex technology. Furthermore, the very
nature of the lexical analyzers produced by lex must be
closely tied to the lexical requirements of the input
language <br>
being described, which is frequently locale-specific anyway.
(For example, writing an analyzer that is used for French
text is not automatically useful for processing other
lan&acirc; <br>
guages.)</p>

<p style="margin-top: 1em">EXAMPLES <br>
The following is an example of a lex program that implements
a rudimentary scanner for a Pascal-like syntax:</p>

<p style="margin-top: 1em">%{ <br>
/* Need this for the call to atof() below. */ <br>
#include &lt;math.h&gt; <br>
/* Need this for printf(), fopen(), and stdin below. */ <br>
#include &lt;stdio.h&gt; <br>
%}</p>

<p style="margin-top: 1em">DIGIT [0&acirc;9] <br>
ID [a&acirc;z][a&acirc;z0&acirc;9]*</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">{DIGIT}+ { <br>
printf(&quot;An integer: %s (%d)0, yytext, <br>
atoi(yytext)); <br>
}</p>

<p style="margin-top: 1em">{DIGIT}+&quot;.&quot;{DIGIT}* {
<br>
printf(&quot;A float: %s (%g)0, yytext, <br>
atof(yytext)); <br>
}</p>


<p style="margin-top: 1em">if|then|begin|end|procedure|function
{ <br>
printf(&quot;A keyword: %s0, yytext); <br>
}</p>

<p style="margin-top: 1em">{ID} printf(&quot;An identifier:
%s0, yytext);</p>


<p style="margin-top: 1em">&quot;+&quot;|&quot;&acirc;&quot;|&quot;*&quot;|&quot;/&quot;
printf(&quot;An operator: %s0, yytext);</p>

<p style="margin-top: 1em">&quot;{&quot;[^}0*&quot;}&quot;
/* Eat up one-line comments. */</p>

<p style="margin-top: 1em">[ 0+ /* Eat up white space.
*/</p>

<p style="margin-top: 1em">. printf(&quot;Unrecognized
character: %s0, yytext);</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">int main(int argc, char *argv[])
<br>
{ <br>
++argv, &acirc;&acirc;argc; /* Skip over program name. */
<br>
if (argc &gt; 0) <br>
yyin = fopen(argv[0], &quot;r&quot;); <br>
else <br>
yyin = stdin;</p>

<p style="margin-top: 1em">yylex(); <br>
}</p>

<p style="margin-top: 1em">RATIONALE <br>
Even though the &acirc;c option and references to the C
language are retained in this description, lex may be
generalized to other languages, as was done at one time for
EFL, the <br>
Extended FORTRAN Language. Since the lex input specification
is essentially language-independent, versions of this
utility could be written to produce Ada, Modula-2, or Pascal
<br>
code, and there are known historical implementations that do
so.</p>

<p style="margin-top: 1em">The current description of lex
bypasses the issue of dealing with internationalized EREs in
the lex source code or generated lexical analyzer. If it
follows the model used by awk <br>
(the source code is assumed to be presented in the POSIX
locale, but input and output are in the locale specified by
the environment variables), then the tables in the lexical
<br>
analyzer produced by lex would interpret EREs specified in
the lex source in terms of the environment variables
specified when lex was executed. The desired effect would be
to <br>
have the lexical analyzer interpret the EREs given in the
lex source according to the environment specified when the
lexical analyzer is executed, but this is not possible with
<br>
the current lex technology.</p>

<p style="margin-top: 1em">The description of octal and
hexadecimal-digit escape sequences agrees with the ISO C
standard use of escape sequences.</p>

<p style="margin-top: 1em">Earlier versions of this
standard allowed for implementations with bytes other than
eight bits, but this has been modified in this version.</p>

<p style="margin-top: 1em">There is no detailed output
format specification. The observed behavior of lex under
four different historical implementations was that none of
these implementations consistently <br>
reported the line numbers for error and warning messages.
Furthermore, there was a desire that lex be allowed to
output additional diagnostic messages. Leaving message
formats <br>
unspecified avoids these formatting questions and problems
with internationalization.</p>

<p style="margin-top: 1em">Although the %x specifier for
exclusive start conditions is not historical practice, it is
believed to be a minor change to historical implementations
and greatly enhances the <br>
usability of lex programs since it permits an application to
obtain the expected functionality with fewer statements.</p>

<p style="margin-top: 1em">The %array and %pointer
declarations were added as a compromise between historical
systems. The System V-based lex copies the matched text to a
yytext array. The flex program, <br>
supported in BSD and GNU systems, uses a pointer. In the
latter case, significant performance improvements are
available for some scanners. Most historical programs should
<br>
require no change in porting from one system to another
because the string being referenced is null-terminated in
both cases. (The method used by flex in its case is to
null-ter&acirc; <br>
minate the token in place by remembering the character that
used to come right after the token and replacing it before
continuing on to the next scan.) Multi-file programs with
<br>
external references to yytext outside the scanner source
file should continue to operate on their historical systems,
but would require one of the new declarations to be
consid&acirc; <br>
ered strictly portable.</p>

<p style="margin-top: 1em">The description of EREs avoids
unnecessary duplication of ERE details because their
meanings within a lex ERE are the same as that for the ERE
in this volume of POSIX.1&acirc;2008.</p>

<p style="margin-top: 1em">The reason for the undefined
condition associated with text beginning with a
&lt;blank&gt; or within &quot;%{&quot; and &quot;%}&quot;
delimiter lines appearing in the Rules section is historical
prac&acirc; <br>
tice. Both the BSD and System V lex copy the indented (or
enclosed) input in the Rules section (except at the
beginning) to unreachable areas of the yylex() function (the
code is <br>
written directly after a break statement). In some cases,
the System V lex generates an error message or a syntax
error, depending on the form of indented input.</p>

<p style="margin-top: 1em">The intention in breaking the
list of functions into those that may appear in lex.yy.c
versus those that only appear in libl.a is that only those
functions in libl.a can be reli&acirc; <br>
ably redefined by a conforming application.</p>

<p style="margin-top: 1em">The descriptions of standard
output and standard error are somewhat complicated because
historical lex implementations chose to issue diagnostic
messages to standard output <br>
(unless &acirc;t was given). POSIX.1&acirc;2008 allows this
behavior, but leaves an opening for the more expected
behavior of using standard error for diagnostics. Also, the
System V behav&acirc; <br>
ior of writing the statistics when any table sizes are given
is allowed, while BSD-derived systems can avoid it. The
programmer can always precisely obtain the desired results
by <br>
using either the &acirc;t or &acirc;n options.</p>

<p style="margin-top: 1em">The OPERANDS section does not
mention the use of &acirc; as a synonym for standard input;
not all historical implementations support such usage for
any of the file operands.</p>

<p style="margin-top: 1em">A description of the translation
table was deleted from early proposals because of its
relatively low usage in historical applications.</p>

<p style="margin-top: 1em">The change to the definition of
the input() function that allows buffering of input presents
the opportunity for major performance gains in some
applications.</p>

<p style="margin-top: 1em">The following examples clarify
the differences between lex regular expressions and regular
expressions appearing elsewhere in this volume of
POSIX.1&acirc;2008. For regular expressions <br>
of the form &quot;r/x&quot;, the string matching r is always
returned; confusion may arise when the beginning of x
matches the trailing portion of r. For example, given the
regular <br>
expression &quot;a*b/cc&quot; and the input
&quot;aaabcc&quot;, yytext would contain the string
&quot;aaab&quot; on this match. But given the regular
expression &quot;x*/xy&quot; and the input &quot;xxxy&quot;,
the token xxx, <br>
not xx, is returned by some implementations because xxx
matches &quot;x*&quot;.</p>

<p style="margin-top: 1em">In the rule &quot;ab*/bc&quot;,
the &quot;b*&quot; at the end of r extends r&rsquo;s match
into the beginning of the trailing context, so the result is
unspecified. If this rule were &quot;ab/bc&quot;, however,
the <br>
rule matches the text &quot;ab&quot; when it is followed by
the text &quot;bc&quot;. In this latter case, the matching
of r cannot extend into the beginning of x, so the result is
specified.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
None.</p>

<p style="margin-top: 1em">SEE ALSO <br>
c99, ed, yacc</p>

<p style="margin-top: 1em">The Base Definitions volume of
POSIX.1&acirc;2008, Chapter 5, File Format Notation, Chapter
8, Environment Variables, Chapter 9, Regular Expressions,
Section 12.2, Utility Syntax <br>
Guidelines</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2013 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 7,
Copyright (C) 2013 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. (This is <br>
POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.)
In the event of any discrepancy between this version and the
original IEEE and The Open Group Standard, the original <br>
IEEE and The Open Group Standard is the referee document.
The original Standard can be obtained online at
http://www.unix.org/online.html .</p>

<p style="margin-top: 1em">Any typographical or formatting
errors that appear in this page are most likely to have been
introduced during the conversion of the source files to man
page format. To report <br>
such errors, see
https://www.kernel.org/doc/man-pages/reporting_bugs.html
.</p>

<p style="margin-top: 1em">IEEE/The Open Group 2013
LEX(1POSIX)</p>
<hr>
</body>
</html>
