<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>FFMPEG-BITSTREAM-FILTERS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">FFMPEG-BITSTREAM-FILTERS(1)</td>
    <td class="head-vol"> </td>
    <td class="head-rtitle">FFMPEG-BITSTREAM-FILTERS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
ffmpeg-bitstream-filters - FFmpeg bitstream filters
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document describes the bitstream filters provided by the libavcodec
  library.
<div class="Pp"></div>
A bitstream filter operates on the encoded stream data, and performs bitstream
  level modifications without performing decoding.
<h1 class="Sh" title="Sh" id="BITSTREAM_FILTERS"><a class="selflink" href="#BITSTREAM_FILTERS">BITSTREAM
  FILTERS</a></h1>
When you configure your FFmpeg build, all the supported bitstream filters are
  enabled by default. You can list all available ones using the configure option
  &quot;--list-bsfs&quot;.
<div class="Pp"></div>
You can disable all the bitstream filters using the configure option
  &quot;--disable-bsfs&quot;, and selectively enable any bitstream filter using
  the option &quot;--enable-bsf=BSF&quot;, or you can disable a particular
  bitstream filter using the option &quot;--disable-bsf=BSF&quot;.
<div class="Pp"></div>
The option &quot;-bsfs&quot; of the ff* tools will display the list of all the
  supported bitstream filters included in your build.
<div class="Pp"></div>
The ff* tools have a -bsf option applied per stream, taking a comma-separated
  list of filters, whose parameters follow the filter name after a '='.
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -c:v copy -bsf:v filter1[=opt1=str1:opt2=str2][,filter2] OUTPUT
</pre>
<div class="Pp"></div>
Below is a description of the currently available bitstream filters, with their
  parameters, if any.
<h2 class="Ss" title="Ss" id="aac_adtstoasc"><a class="selflink" href="#aac_adtstoasc">aac_adtstoasc</a></h2>
Convert MPEG-2/4 AAC ADTS to MPEG-4 Audio Specific Configuration bitstream
  filter.
<div class="Pp"></div>
This filter creates an MPEG-4 AudioSpecificConfig from an MPEG-2/4 ADTS header
  and removes the ADTS header.
<div class="Pp"></div>
This is required for example when copying an AAC stream from a raw ADTS AAC
  container to a FLV or a MOV/MP4 file.
<h2 class="Ss" title="Ss" id="chomp"><a class="selflink" href="#chomp">chomp</a></h2>
Remove zero padding at the end of a packet.
<h2 class="Ss" title="Ss" id="dump_extra"><a class="selflink" href="#dump_extra">dump_extra</a></h2>
Add extradata to the beginning of the filtered packets.
<div class="Pp"></div>
The additional argument specifies which packets should be filtered. It accepts
  the values:
<dl class="Bl-tag">
  <dt class="It-tag"><b>a</b></dt>
  <dd class="It-tag">add extradata to all key packets, but only if
      <i>local_header</i> is set in the <b>flags2</b> codec context field</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>k</b></dt>
  <dd class="It-tag">add extradata to all key packets</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>e</b></dt>
  <dd class="It-tag">add extradata to all packets</dd>
</dl>
<div class="Pp"></div>
If not specified it is assumed <b>k</b>.
<div class="Pp"></div>
For example the following <b>ffmpeg</b> command forces a global header (thus
  disabling individual packet headers) in the H.264 packets generated by the
  &quot;libx264&quot; encoder, but corrects them by adding the header stored in
  extradata to the key packets:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -map 0 -flags:v +global_header -c:v libx264 -bsf:v dump_extra out.ts
</pre>
<h2 class="Ss" title="Ss" id="dca_core"><a class="selflink" href="#dca_core">dca_core</a></h2>
Extract DCA core from DTS-HD streams.
<h2 class="Ss" title="Ss" id="h264_mp4toannexb"><a class="selflink" href="#h264_mp4toannexb">h264_mp4toannexb</a></h2>
Convert an H.264 bitstream from length prefixed mode to start code prefixed mode
  (as defined in the Annex B of the ITU-T H.264 specification).
<div class="Pp"></div>
This is required by some streaming formats, typically the MPEG-2 transport
  stream format (&quot;mpegts&quot;).
<div class="Pp"></div>
For example to remux an MP4 file containing an H.264 stream to mpegts format
  with <b>ffmpeg</b>, you can use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT.mp4 -codec copy -bsf:v h264_mp4toannexb OUTPUT.ts
</pre>
<h2 class="Ss" title="Ss" id="imxdump"><a class="selflink" href="#imxdump">imxdump</a></h2>
Modifies the bitstream to fit in MOV and to be usable by the Final Cut Pro
  decoder. This filter only applies to the mpeg2video codec, and is likely not
  needed for Final Cut Pro 7 and newer with the appropriate <b>-tag:v</b>.
<div class="Pp"></div>
For example, to remux 30 MB/sec NTSC IMX to MOV:
<div class="Pp"></div>
<pre>
        ffmpeg -i input.mxf -c copy -bsf:v imxdump -tag:v mx3n output.mov
</pre>
<h2 class="Ss" title="Ss" id="mjpeg2jpeg"><a class="selflink" href="#mjpeg2jpeg">mjpeg2jpeg</a></h2>
Convert MJPEG/AVI1 packets to full JPEG/JFIF packets.
<div class="Pp"></div>
MJPEG is a video codec wherein each video frame is essentially a JPEG image. The
  individual frames can be extracted without loss, e.g. by
<div class="Pp"></div>
<pre>
        ffmpeg -i ../some_mjpeg.avi -c:v copy frames_%d.jpg
</pre>
<div class="Pp"></div>
Unfortunately, these chunks are incomplete JPEG images, because they lack the
  DHT segment required for decoding. Quoting from &lt;
  <b>http://www.digitalpreservation.gov/formats/fdd/fdd000063.shtml</b>&gt;:
<div class="Pp"></div>
Avery Lee, writing in the rec.video.desktop newsgroup in 2001, commented that
  &quot;MJPEG, or at least the MJPEG in AVIs having the MJPG fourcc, is
  restricted JPEG with a fixed -- and *omitted* -- Huffman table. The JPEG must
  be YCbCr colorspace, it must be 4:2:2, and it must use basic Huffman encoding,
  not arithmetic or progressive. . . . You can indeed extract the MJPEG frames
  and decode them with a regular JPEG decoder, but you have to prepend the DHT
  segment to them, or else the decoder won't have any idea how to decompress the
  data. The exact table necessary is given in the OpenDML spec.&quot;
<div class="Pp"></div>
This bitstream filter patches the header of frames extracted from an MJPEG
  stream (carrying the AVI1 header ID and lacking a DHT segment) to produce
  fully qualified JPEG images.
<div class="Pp"></div>
<pre>
        ffmpeg -i mjpeg-movie.avi -c:v copy -bsf:v mjpeg2jpeg frame_%d.jpg
        exiftran -i -9 frame*.jpg
        ffmpeg -i frame_%d.jpg -c:v copy rotated.avi
</pre>
<h2 class="Ss" title="Ss" id="mjpega_dump_header"><a class="selflink" href="#mjpega_dump_header">mjpega_dump_header</a></h2>
<h2 class="Ss" title="Ss" id="movsub"><a class="selflink" href="#movsub">movsub</a></h2>
<h2 class="Ss" title="Ss" id="mp3_header_decompress"><a class="selflink" href="#mp3_header_decompress">mp3_header_decompress</a></h2>
<h2 class="Ss" title="Ss" id="mpeg4_unpack_bframes"><a class="selflink" href="#mpeg4_unpack_bframes">mpeg4_unpack_bframes</a></h2>
Unpack DivX-style packed B-frames.
<div class="Pp"></div>
DivX-style packed B-frames are not valid MPEG-4 and were only a workaround for
  the broken Video for Windows subsystem. They use more space, can cause minor
  AV sync issues, require more CPU power to decode (unless the player has some
  decoded picture queue to compensate the 2,0,2,0 frame per packet style) and
  cause trouble if copied into a standard container like mp4 or mpeg-ps/ts,
  because MPEG-4 decoders may not be able to decode them, since they are not
  valid MPEG-4.
<div class="Pp"></div>
For example to fix an AVI file containing an MPEG-4 stream with DivX-style
  packed B-frames using <b>ffmpeg</b>, you can use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT.avi -codec copy -bsf:v mpeg4_unpack_bframes OUTPUT.avi
</pre>
<h2 class="Ss" title="Ss" id="noise"><a class="selflink" href="#noise">noise</a></h2>
Damages the contents of packets without damaging the container. Can be used for
  fuzzing or testing error resilience/concealment.
<div class="Pp"></div>
Parameters: A numeral string, whose value is related to how often output bytes
  will be modified. Therefore, values below or equal to 0 are forbidden, and the
  lower the more frequent bytes will be modified, with 1 meaning every byte is
  modified.
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -c copy -bsf noise[=1] output.mkv
</pre>
<div class="Pp"></div>
applies the modification to every byte.
<h2 class="Ss" title="Ss" id="remove_extra"><a class="selflink" href="#remove_extra">remove_extra</a></h2>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>ffmpeg</i>(1), <i>ffplay</i>(1), <i>ffprobe</i>(1), <i>ffserver</i>(1),
  <i>libavcodec</i>(3)
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
The FFmpeg developers.
<div class="Pp"></div>
For details about the authorship, see the Git history of the project
  (git://source.ffmpeg.org/ffmpeg), e.g. by typing the command <b>git log</b> in
  the FFmpeg source directory, or browsing the online repository at &lt;
  <b>http://source.ffmpeg.org</b>&gt;.
<div class="Pp"></div>
Maintainers for the specific components are listed in the file
  <i>MAINTAINERS</i> in the source code tree.</div>
<table class="foot">
  <tr>
    <td class="foot-date"> </td>
    <td class="foot-os"> </td>
  </tr>
</table>
</body>
</html>
