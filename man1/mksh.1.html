<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:25:40 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MKSH(1) BSD General Commands Manual MKSH(1)</p>

<p style="margin-top: 1em">NAME <br>
mksh, sh &acirc; MirBSD Korn shell</p>

<p style="margin-top: 1em">SYNOPSIS <br>
mksh [-+abCefhiklmnprUuvXx] [-T /dev/ttyCn | -] [-+o option]
[-c string | -s | file [argument ...]] <br>
builtin-name [argument ...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
mksh is a command interpreter intended for both interactive
and shell script use. Its command language is a superset of
the sh(C) shell language and largely compatible to the <br>
original Korn shell.</p>

<p style="margin-top: 1em">I&rsquo;m an Android user, so
what&rsquo;s mksh? <br>
mksh is a UNIX shell / command interpreter, similar to
COMMAND.COM or CMD.EXE, which has been included with Android
Open Source Project for a while now. Basically, it&rsquo;s a
program <br>
that runs in a terminal (console window), takes user input
and runs commands or scripts, which it can also be asked to
do by other programs, even in the background. Any privilege
<br>
pop-ups you might be encountering are thus not mksh issues
but questions by some other program utilising it.</p>

<p style="margin-top: 1em">Invocation <br>
Most builtins can be called directly, for example if a link
points from its name to the shell; not all make sense, have
been tested or work at all though.</p>

<p style="margin-top: 1em">The options are as follows:</p>

<p style="margin-top: 1em">-c string mksh will execute the
command(s) contained in string.</p>

<p style="margin-top: 1em">-i Interactive shell. A shell is
&acirc;interactive&acirc; if this option is used or if both
standard input and standard error are attached to a tty(4).
An interactive shell has job <br>
control enabled, ignores the SIGINT, SIGQUIT, and SIGTERM
signals, and prints prompts before reading input (see the
PS1 and PS2 parameters). It also processes the ENV <br>
parameter or the mkshrc file (see below). For
non-interactive shells, the trackall option is on by default
(see the set command below).</p>

<p style="margin-top: 1em">-l Login shell. If the basename
the shell is called with (i.e. argv[0]) starts with
&acirc;-&acirc; or if this option is used, the shell is
assumed to be a login shell; see Startup <br>
files below.</p>

<p style="margin-top: 1em">-p Privileged shell. A shell is
&acirc;privileged&acirc; if this option is used or if the
real user ID or group ID does not match the effective user
ID or group ID (see getuid(2) and <br>
getgid(2)). Clearing the privileged option causes the shell
to set its effective user ID (group ID) to its real user ID
(group ID). For further implications, see <br>
Startup files.</p>

<p style="margin-top: 1em">-r Restricted shell. A shell is
&acirc;restricted&acirc; if this option is used. The
following restrictions come into effect after the shell
processes any profile and ENV files:</p>

<p style="margin-top: 1em">&Acirc;&middot; The cd (and
chdir) command is disabled. <br>
&Acirc;&middot; The SHELL, ENV, and PATH parameters cannot
be changed. <br>
&Acirc;&middot; Command names can&rsquo;t be specified with
absolute or relative paths. <br>
&Acirc;&middot; The -p option of the built-in command
command can&rsquo;t be used. <br>
&Acirc;&middot; Redirections that create files can&rsquo;t
be used (i.e. &acirc;&gt;&acirc;, &acirc;&gt;|&acirc;,
&acirc;&gt;&gt;&acirc;, &acirc;&lt;&gt;&acirc;).</p>

<p style="margin-top: 1em">-s The shell reads commands from
standard input; all non-option arguments are positional
parameters.</p>

<p style="margin-top: 1em">-T tty Spawn mksh on the tty(4)
device given. Superuser only. If tty is a dash, detach from
controlling terminal (daemonise) instead.</p>

<p style="margin-top: 1em">In addition to the above, the
options described in the set built-in command can also be
used on the command line: both [-+abCefhkmnuvXx] and [-+o
option] can be used for single <br>
letter or long options, respectively.</p>

<p style="margin-top: 1em">If neither the -c nor the -s
option is specified, the first non-option argument specifies
the name of a file the shell reads commands from. If there
are no non-option arguments, <br>
the shell reads commands from the standard input. The name
of the shell (i.e. the contents of $0) is determined as
follows: if the -c option is used and there is a non-option
<br>
argument, it is used as the name; if commands are being read
from a file, the file is used as the name; otherwise, the
basename the shell was called with (i.e. argv[0]) is
used.</p>

<p style="margin-top: 1em">The exit status of the shell is
127 if the command file specified on the command line could
not be opened, or non-zero if a fatal syntax error occurred
during the execution of a <br>
script. In the absence of fatal errors, the exit status is
that of the last command executed, or zero, if no command is
executed.</p>

<p style="margin-top: 1em">Startup files <br>
For the actual location of these files, see FILES. A login
shell processes the system profile first. A privileged shell
then processes the suid profile. A non-privileged login <br>
shell processes the user profile next. A non-privileged
interactive shell checks the value of the ENV parameter
after subjecting it to parameter, command, arithmetic and
tilde <br>
(&acirc;~&acirc;) substitution; if unset or empty, the user
mkshrc profile is processed; otherwise, if a file whose name
is the substitution result exists, it is processed;
non-existence is <br>
silently ignored.</p>

<p style="margin-top: 1em">Command syntax <br>
The shell begins parsing its input by removing any
backslash-newline combinations, then breaking it into words.
Words (which are sequences of characters) are delimited by
unquoted <br>
whitespace characters (space, tab, and newline) or
meta-characters (&acirc;&lt;&acirc;, &acirc;&gt;&acirc;,
&acirc;|&acirc;, &acirc;;&acirc;, &acirc;(&acirc;,
&acirc;)&acirc;, and &acirc;&amp;&acirc;). Aside from
delimiting words, spaces and tabs are ignored, while
new&acirc; <br>
lines usually delimit commands. The meta-characters are used
in building the following tokens: &acirc;&lt;&acirc;,
&acirc;&lt;&amp;&acirc;, &acirc;&lt;&lt;&acirc;,
&acirc;&lt;&lt;&lt;&acirc;, &acirc;&gt;&acirc;,
&acirc;&gt;&amp;&acirc;, &acirc;&gt;&gt;&acirc;,
&acirc;&amp;&gt;&acirc;, etc. are used to specify
redirections <br>
(see Input/output redirection below); &acirc;|&acirc; is
used to create pipelines; &acirc;|&amp;&acirc; is used to
create co-processes (see Co-processes below);
&acirc;;&acirc; is used to separate commands;
&acirc;&amp;&acirc; is used <br>
to create asynchronous pipelines; &acirc;&amp;&amp;&acirc;
and &acirc;||&acirc; are used to specify conditional
execution; &acirc;;;&acirc;, &acirc;;&amp;&acirc; and
&acirc;;|&acirc; are used in case statements; &acirc;(( ..
))&acirc; is used in arithmetic expres&acirc; <br>
sions; and lastly, &acirc;( .. )&acirc; is used to create
subshells.</p>

<p style="margin-top: 1em">Whitespace and meta-characters
can be quoted individually using a backslash
(&acirc;&acirc;), or in groups using double
(&acirc;&quot;&acirc;) or single (&acirc;&rsquo;&acirc;)
quotes. Note that the following characters are <br>
also treated specially by the shell and must be quoted if
they are to represent themselves: &acirc;&acirc;,
&acirc;&quot;&acirc;, &acirc;&rsquo;&acirc;,
&acirc;#&acirc;, &acirc;$&acirc;, &acirc;&lsquo;&acirc;,
&acirc;~&acirc;, &acirc;{&acirc;, &acirc;}&acirc;,
&acirc;*&acirc;, &acirc;?&acirc;, and &acirc;[&acirc;. The
first three of <br>
these are the above mentioned quoting characters (see
Quoting below); &acirc;#&acirc;, if used at the beginning of
a word, introduces a comment &acirc; everything after the
&acirc;#&acirc; up to the nearest <br>
newline is ignored; &acirc;$&acirc; is used to introduce
parameter, command, and arithmetic substitutions (see
Substitution below); &acirc;&lsquo;&acirc; introduces an
old-style command substitution (see <br>
Substitution below); &acirc;~&acirc; begins a directory
expansion (see Tilde expansion below); &acirc;{&acirc; and
&acirc;}&acirc; delimit csh(1)-style alterations (see Brace
expansion below); and finally, &acirc;*&acirc;,
&acirc;?&acirc;, <br>
and &acirc;[&acirc; are used in file name generation (see
File name patterns below).</p>

<p style="margin-top: 1em">As words and tokens are parsed,
the shell builds commands, of which there are two basic
types: simple-commands, typically programmes that are
executed, and compound-commands, such <br>
as for and if statements, grouping constructs, and function
definitions.</p>

<p style="margin-top: 1em">A simple-command consists of
some combination of parameter assignments (see Parameters
below), input/output redirections (see Input/output
redirections below), and command words; <br>
the only restriction is that parameter assignments come
before any command words. The command words, if any, define
the command that is to be executed and its arguments. The
com&acirc; <br>
mand may be a shell built-in command, a function, or an
external command (i.e. a separate executable file that is
located using the PATH parameter; see Command execution
below). <br>
Note that all command constructs have an exit status: for
external commands, this is related to the status returned by
wait(2) (if the command could not be found, the exit status
<br>
is 127; if it could not be executed, the exit status is
126); the exit status of other command constructs (built-in
commands, functions, compound-commands, pipelines, lists,
etc.) <br>
are all well-defined and are described where the construct
is described. The exit status of a command consisting only
of parameter assignments is that of the last command
substi&acirc; <br>
tution performed during the parameter assignment or 0 if
there were no command substitutions.</p>

<p style="margin-top: 1em">Commands can be chained together
using the &acirc;|&acirc; token to form pipelines, in which
the standard output of each command but the last is piped
(see pipe(2)) to the standard input of <br>
the following command. The exit status of a pipeline is that
of its last command, unless the pipefail option is set (see
there). All commands of a pipeline are executed in
sepa&acirc; <br>
rate subshells; this is allowed by POSIX but differs from
both variants of AT&amp;T UNIX ksh, where all but the last
command were executed in subshells; see the read
builtin&rsquo;s descrip&acirc; <br>
tion for implications and workarounds. A pipeline may be
prefixed by the &acirc;!&acirc; reserved word which causes
the exit status of the pipeline to be logically
complemented: if the origi&acirc; <br>
nal status was 0, the complemented status will be 1; if the
original status was not 0, the complemented status will be
0.</p>

<p style="margin-top: 1em">Lists of commands can be created
by separating pipelines by any of the following tokens:
&acirc;&amp;&amp;&acirc;, &acirc;||&acirc;,
&acirc;&amp;&acirc;, &acirc;|&amp;&acirc;, and
&acirc;;&acirc;. The first two are for conditional
execution: &acirc;cmd1 &amp;&amp; <br>
cmd2&acirc; executes cmd2 only if the exit status of cmd1 is
zero; &acirc;||&acirc; is the opposite &acirc; cmd2 is
executed only if the exit status of cmd1 is non-zero.
&acirc;&amp;&amp;&acirc; and &acirc;||&acirc; have equal
prece&acirc; <br>
dence which is higher than that of &acirc;&amp;&acirc;,
&acirc;|&amp;&acirc;, and &acirc;;&acirc;, which also have
equal precedence. Note that the &acirc;&amp;&amp;&acirc; and
&acirc;||&acirc; operators are &quot;left-associative&quot;.
For example, both of these <br>
commands will print only &quot;bar&quot;:</p>

<p style="margin-top: 1em">$ false &amp;&amp; echo foo ||
echo bar <br>
$ true || echo foo &amp;&amp; echo bar</p>

<p style="margin-top: 1em">The &acirc;&amp;&acirc; token
causes the preceding command to be executed asynchronously;
that is, the shell starts the command but does not wait for
it to complete (the shell does keep track of <br>
the status of asynchronous commands; see Job control below).
When an asynchronous command is started when job control is
disabled (i.e. in most scripts), the command is started <br>
with signals SIGINT and SIGQUIT ignored and with input
redirected from /dev/null (however, redirections specified
in the asynchronous command have precedence). The
&acirc;|&amp;&acirc; operator <br>
starts a co-process which is a special kind of asynchronous
process (see Co-processes below). Note that a command must
follow the &acirc;&amp;&amp;&acirc; and &acirc;||&acirc;
operators, while it need not follow <br>
&acirc;&amp;&acirc;, &acirc;|&amp;&acirc;, or
&acirc;;&acirc;. The exit status of a list is that of the
last command executed, with the exception of asynchronous
lists, for which the exit status is 0.</p>

<p style="margin-top: 1em">Compound commands are created
using the following reserved words. These words are only
recognised if they are unquoted and if they are used as the
first word of a command (i.e. <br>
they can&rsquo;t be preceded by parameter assignments or
redirections):</p>

<p style="margin-top: 1em">case else function then ! ( <br>
do esac if time [[ (( <br>
done fi in until { <br>
elif for select while }</p>

<p style="margin-top: 1em">In the following compound
command descriptions, command lists (denoted as list) that
are followed by reserved words must end with a semicolon, a
newline, or a (syntactically cor&acirc; <br>
rect) reserved word. For example, the following are all
valid:</p>

<p style="margin-top: 1em">$ { echo foo; echo bar; } <br>
$ { echo foo; echo bar&lt;newline&gt;} <br>
$ { { echo foo; echo bar; } }</p>

<p style="margin-top: 1em">This is not valid:</p>

<p style="margin-top: 1em">$ { echo foo; echo bar }</p>

<p style="margin-top: 1em">(list) <br>
Execute list in a subshell. There is no implicit way to pass
environment changes from a subshell back to its parent.</p>

<p style="margin-top: 1em">{ list; } <br>
Compound construct; list is executed, but not in a subshell.
Note that &acirc;{&acirc; and &acirc;}&acirc; are reserved
words, not meta-characters.</p>

<p style="margin-top: 1em">case word in [[(] pattern [|
pat] ...) list [;; | ;&amp; | ;| ]] ... esac <br>
The case statement attempts to match word against a
specified pattern; the list associated with the first
successfully matched pattern is executed. Patterns used in
case <br>
statements are the same as those used for file name patterns
except that the restrictions regarding &acirc;.&acirc; and
&acirc;/&acirc; are dropped. Note that any unquoted space
before and after a <br>
pattern is stripped; any space within a pattern must be
quoted. Both the word and the patterns are subject to
parameter, command, and arithmetic substitution, as well as
<br>
tilde substitution.</p>

<p style="margin-top: 1em">For historical reasons, open and
close braces may be used instead of in and esac e.g. case
$foo { *) echo bar;; }.</p>

<p style="margin-top: 1em">The list terminators are:</p>

<p style="margin-top: 1em">&acirc;;;&acirc; Terminate after
the list.</p>

<p style="margin-top: 1em">&acirc;;&amp;&acirc; Fall
through into the next list.</p>

<p style="margin-top: 1em">&acirc;;|&acirc; Evaluate the
remaining pattern-list tuples.</p>

<p style="margin-top: 1em">The exit status of a case
statement is that of the executed list; if no list is
executed, the exit status is zero.</p>

<p style="margin-top: 1em">for name [in word ...]; do list;
done <br>
For each word in the specified word list, the parameter name
is set to the word and list is executed. If in is not used
to specify a word list, the positional parameters <br>
($1, $2, etc.) are used instead. For historical reasons,
open and close braces may be used instead of do and done
e.g. for i; { echo $i; }. The exit status of a for
state&acirc; <br>
ment is the last exit status of list; if list is never
executed, the exit status is zero.</p>

<p style="margin-top: 1em">if list; then list; [elif list;
then list;] ... [else list;] fi <br>
If the exit status of the first list is zero, the second
list is executed; otherwise, the list following the elif, if
any, is executed with similar consequences. If all the <br>
lists following the if and elifs fail (i.e. exit with
non-zero status), the list following the else is executed.
The exit status of an if statement is that of
non-condi&acirc; <br>
tional list that is executed; if no non-conditional list is
executed, the exit status is zero.</p>

<p style="margin-top: 1em">select name [in word ...]; do
list; done <br>
The select statement provides an automatic method of
presenting the user with a menu and selecting from it. An
enumerated list of the specified word(s) is printed on
stan&acirc; <br>
dard error, followed by a prompt (PS3: normally &acirc;#?
&acirc;). A number corresponding to one of the enumerated
words is then read from standard input, name is set to the
selected <br>
word (or unset if the selection is not valid), REPLY is set
to what was read (leading/trailing space is stripped), and
list is executed. If a blank line (i.e. zero or more <br>
IFS octets) is entered, the menu is reprinted without
executing list.</p>

<p style="margin-top: 1em">When list completes, the
enumerated list is printed if REPLY is NULL, the prompt is
printed, and so on. This process continues until an
end-of-file is read, an interrupt is <br>
received, or a break statement is executed inside the loop.
If &acirc;in word ...&acirc; is omitted, the positional
parameters are used (i.e. $1, $2, etc.). For historical
reasons, <br>
open and close braces may be used instead of do and done
e.g. select i; { echo $i; }. The exit status of a select
statement is zero if a break statement is used to exit the
<br>
loop, non-zero otherwise.</p>

<p style="margin-top: 1em">until list; do list; done <br>
This works like while, except that the body is executed only
while the exit status of the first list is non-zero.</p>

<p style="margin-top: 1em">while list; do list; done <br>
A while is a pre-checked loop. Its body is executed as often
as the exit status of the first list is zero. The exit
status of a while statement is the last exit status of <br>
the list in the body of the loop; if the body is not
executed, the exit status is zero.</p>

<p style="margin-top: 1em">function name { list; } <br>
Defines the function name (see Functions below). Note that
redirections specified after a function definition are
performed whenever the function is executed, not when the
<br>
function definition is executed.</p>

<p style="margin-top: 1em">name() command <br>
Mostly the same as function (see Functions below).
Whitespace (space or tab) after name will be ignored most of
the time.</p>

<p style="margin-top: 1em">function name() { list; } <br>
The same as name() (bashism). The function keyword is
ignored.</p>

<p style="margin-top: 1em">time [-p] [pipeline] <br>
The Command execution section describes the time reserved
word.</p>

<p style="margin-top: 1em">(( expression )) <br>
The arithmetic expression expression is evaluated;
equivalent to &acirc;let expression&acirc; (see Arithmetic
expressions and the let command, below).</p>

<p style="margin-top: 1em">[[ expression ]] <br>
Similar to the test and [ ... ] commands (described later),
with the following exceptions:</p>

<p style="margin-top: 1em">&Acirc;&middot; Field splitting
and file name generation are not performed on arguments.</p>

<p style="margin-top: 1em">&Acirc;&middot; The -a (AND) and
-o (OR) operators are replaced with &acirc;&amp;&amp;&acirc;
and &acirc;||&acirc;, respectively.</p>

<p style="margin-top: 1em">&Acirc;&middot; Operators (e.g.
&acirc;-f&acirc;, &acirc;=&acirc;, &acirc;!&acirc;) must be
unquoted.</p>

<p style="margin-top: 1em">&Acirc;&middot; Parameter,
command, and arithmetic substitutions are performed as
expressions are evaluated and lazy expression evaluation is
used for the &acirc;&amp;&amp;&acirc; and &acirc;||&acirc;
operators. This <br>
means that in the following statement, $(&lt;foo) is
evaluated if and only if the file foo exists and is
readable:</p>

<p style="margin-top: 1em">$ [[ -r foo &amp;&amp;
$(&lt;foo) = b*r ]]</p>

<p style="margin-top: 1em">&Acirc;&middot; The second
operand of the &acirc;!=&acirc; and &acirc;=&acirc;
expressions are patterns (e.g. the comparison [[ foobar =
f*r ]] succeeds). This even works indirectly:</p>

<p style="margin-top: 1em">$ bar=foobar;
baz=&rsquo;f*r&rsquo; <br>
$ [[ $bar = $baz ]]; echo $? <br>
$ [[ $bar = &quot;$baz&quot; ]]; echo $?</p>

<p style="margin-top: 1em">Perhaps surprisingly, the first
comparison succeeds, whereas the second doesn&rsquo;t.</p>

<p style="margin-top: 1em">Quoting <br>
Quoting is used to prevent the shell from treating
characters or words specially. There are three methods of
quoting. First, &acirc;&acirc; quotes the following
character, unless it is at <br>
the end of a line, in which case both the &acirc;&acirc; and
the newline are stripped. Second, a single quote
(&acirc;&rsquo;&acirc;) quotes everything up to the next
single quote (this may span lines). <br>
Third, a double quote (&acirc;&quot;&acirc;) quotes all
characters, except &acirc;$&acirc;, &acirc;&lsquo;&acirc;
and &acirc;&acirc;, up to the next unquoted double quote.
&acirc;$&acirc; and &acirc;&lsquo;&acirc; inside double
quotes have their usual meaning (i.e. <br>
parameter, command, or arithmetic substitution) except no
field splitting is carried out on the results of
double-quoted substitutions. If a &acirc;&acirc; inside a
double-quoted string is <br>
followed by &acirc;&acirc;, &acirc;$&acirc;,
&acirc;&lsquo;&acirc;, or &acirc;&quot;&acirc;, it is
replaced by the second character; if it is followed by a
newline, both the &acirc;&acirc; and the newline are
stripped; otherwise, both the &acirc;&acirc; and <br>
the character following are unchanged.</p>

<p style="margin-top: 1em">If a single-quoted string is
preceded by an unquoted &acirc;$&acirc;, C style backslash
expansion (see below) is applied (even single quote
characters inside can be escaped and do not termi&acirc;
<br>
nate the string then); the expanded result is treated as any
other single-quoted string. If a double-quoted string is
preceded by an unquoted &acirc;$&acirc;, the latter is
ignored.</p>

<p style="margin-top: 1em">Backslash expansion <br>
In places where backslashes are expanded, certain C and
AT&amp;T UNIX ksh or GNU bash style escapes are translated.
These include&acirc;, &acirc;&acirc;,
&acirc;U########&acirc;, &acirc;&acirc;, &acirc;,, &acirc;0,
&acirc; <br>
&acirc;####&acirc;, and &acirc; For &acirc;U########&acirc;
and &acirc;####&acirc;, &acirc;#&acirc; means a hexadecimal
digit, of thich there may be none up to four or eight; these
escapes translate a Unicode codepoint to <br>
UTF-8. Furthermore, &acirc;&acirc; and &acirc;\&acirc;
expand to the escape character.</p>

<p style="margin-top: 1em">In the print builtin mode,
&acirc; <br>
hexadecimal sequences &acirc;&acirc; are limited to none up
to two hexadecimal digits &acirc;#&acirc;; both octal and
hexadecimal sequences convert to raw octets; &acirc;
translates to <br>
Backslash expansion in the C style mode slightly differs:
octal sequences &acirc; decimal sequences &acirc; greedily
eat up as many hexadecimal digits &acirc;#&acirc; as they
can and terminate with the first non-hexadecimal digit;
these translate a Unicode codepoint to <br>
UTF-8. The sequence &acirc; <br>
Aliases <br>
There are two types of aliases: normal command aliases and
tracked aliases. Command aliases are normally used as a
short hand for a long or often used command. The shell
expands <br>
command aliases (i.e. substitutes the alias name for its
value) when it reads the first word of a command. An
expanded alias is re-processed to check for more aliases. If
a com&acirc; <br>
mand alias ends in a space or tab, the following word is
also checked for alias expansion. The alias expansion
process stops when a word that is not an alias is found,
when a <br>
quoted word is found, or when an alias word that is
currently being expanded is found. Aliases are specifically
an interactive feature: while they do happen to work in
scripts and <br>
on the command line in some cases, aliases are expanded
during lexing, so their use must be in a separate command
tree from their definition; otherwise, the alias will not be
<br>
found. Noticeably, command lists (separated by semicolon, in
command substitutions also by newline) may be one same parse
tree.</p>

<p style="margin-top: 1em">The following command aliases
are defined automatically by the shell:</p>

<p style="margin-top: 1em">autoload=&rsquo;typeset
-fu&rsquo; <br>
functions=&rsquo;typeset -f&rsquo; <br>
hash=&rsquo;alias -t&rsquo; <br>
history=&rsquo;fc -l&rsquo; <br>
integer=&rsquo;typeset -i&rsquo; <br>
local=&rsquo;typeset&rsquo; <br>
login=&rsquo;exec login&rsquo; <br>
nameref=&rsquo;typeset -n&rsquo; <br>
nohup=&rsquo;nohup &rsquo; <br>
r=&rsquo;fc -e -&rsquo; <br>
stop=&rsquo;kill -STOP&rsquo; <br>
suspend=&rsquo;kill -STOP $$&rsquo; <br>
type=&rsquo;whence -v&rsquo;</p>

<p style="margin-top: 1em">Tracked aliases allow the shell
to remember where it found a particular command. The first
time the shell does a path search for a command that is
marked as a tracked alias, it <br>
saves the full path of the command. The next time the
command is executed, the shell checks the saved path to see
that it is still valid, and if so, avoids repeating the path
<br>
search. Tracked aliases can be listed and created using
alias -t. Note that changing the PATH parameter clears the
saved paths for all tracked aliases. If the trackall option
is <br>
set (i.e. set -o trackall or set -h), the shell tracks all
commands. This option is set automatically for
non-interactive shells. For interactive shells, only the
following com&acirc; <br>
mands are automatically tracked: cat(1), cc(1), chmod(1),
cp(1), date(1), ed(1), emacs(1), grep(1), ls(1), make(1),
mv(1), pr(1), rm(1), sed(1), sh(1), vi(1), and who(1).</p>

<p style="margin-top: 1em">Substitution <br>
The first step the shell takes in executing a simple-command
is to perform substitutions on the words of the command.
There are three kinds of substitution: parameter, command,
<br>
and arithmetic. Parameter substitutions, which are described
in detail in the next section, take the form $name or
${...}; command substitutions take the form $(command) or
(dep&acirc; <br>
recated) &lsquo;command&lsquo; or (executed in the current
environment) ${ command;} and strip trailing newlines; and
arithmetic substitutions take the form $((expression)).
Parsing the cur&acirc; <br>
rent-environment command substitution requires a space, tab
or newline after the opening brace and that the closing
brace be recognised as a keyword (i.e. is preceded by a
newline <br>
or semicolon). They are also called funsubs (function
substitutions) and behave like functions in that local and
return work, and in that exit terminates the parent
shell.</p>

<p style="margin-top: 1em">Another variant of substitution
are the valsubs (value substitutions) ${|command;} which are
also executed in the current environment, like funsubs, but
share their I/O with the <br>
parent; instead, they evaluate to whatever the, initially
empty, expression-local variable REPLY is set to within the
commands.</p>

<p style="margin-top: 1em">If a substitution appears
outside of double quotes, the results of the substitution
are generally subject to word or field splitting according
to the current value of the IFS <br>
parameter. The IFS parameter specifies a list of octets
which are used to break a string up into several words; any
octets from the set space, tab, and newline that appear in
the <br>
IFS octets are called &acirc;IFS whitespace&acirc;.
Sequences of one or more IFS whitespace octets, in
combination with zero or one non-IFS whitespace octets,
delimit a field. As a special <br>
case, leading and trailing IFS whitespace and trailing IFS
non-whitespace are stripped (i.e. no leading or trailing
empty field is created by it); leading non-IFS whitespace
does <br>
create an empty field.</p>

<p style="margin-top: 1em">Example: If IFS is set to
&acirc;&lt;space&gt;:&acirc;, and VAR is set to
&acirc;&lt;space&gt;A&lt;space&gt;:&lt;space&gt;&lt;space&gt;B::D&acirc;,
the substitution for $VAR results in four fields:
&acirc;A&acirc;, &acirc;B&acirc;, &acirc;&acirc; (an empty
field), and <br>
&acirc;D&acirc;. Note that if the IFS parameter is set to
the NULL string, no field splitting is done; if the
parameter is unset, the default value of space, tab, and
newline is used.</p>

<p style="margin-top: 1em">Also, note that the field
splitting applies only to the immediate result of the
substitution. Using the previous example, the substitution
for $VAR:E results in the fields: &acirc;A&acirc;, <br>
&acirc;B&acirc;, &acirc;&acirc;, and &acirc;D:E&acirc;, not
&acirc;A&acirc;, &acirc;B&acirc;, &acirc;&acirc;,
&acirc;D&acirc;, and &acirc;E&acirc;. This behavior is POSIX
compliant, but incompatible with some other shell
implementations which do field splitting on the word <br>
which contained the substitution or use IFS as a general
whitespace delimiter.</p>

<p style="margin-top: 1em">The results of substitution are,
unless otherwise specified, also subject to brace expansion
and file name expansion (see the relevant sections
below).</p>

<p style="margin-top: 1em">A command substitution is
replaced by the output generated by the specified command
which is run in a subshell. For $(command) and ${ command;}
substitutions, normal quoting rules <br>
are used when command is parsed; however, for the deprecated
&lsquo;command&lsquo; form, a &acirc;&acirc; followed by any
of &acirc;$&acirc;, &acirc;&lsquo;&acirc;, or &acirc;&acirc;
is stripped (a &acirc;&acirc; followed by any other
character is <br>
unchanged). As a special case in command substitutions, a
command of the form &lt;file is interpreted to mean
substitute the contents of file. Note that $(&lt;foo) has
the same effect <br>
as $(cat foo).</p>

<p style="margin-top: 1em">Note that some shells do not use
a recursive parser for command substitutions, leading to
failure for certain constructs; to be portable, use as
workaround &acirc;x=$(cat) &lt;&lt;&quot;EOF&quot;&acirc;
(or <br>
the newline-keeping &acirc;x=&lt;&lt;&quot;EOF&quot;&acirc;
extension) instead to merely slurp the string. IEEE Std
1003.1 (&acirc;POSIX.1&acirc;) recommends to use case
statements of the form &acirc;x=$(case $foo in (bar) <br>
echo $bar ;; (*) echo $baz ;; esac)&acirc; instead, which
would work but not serve as example for this portability
issue.</p>

<p style="margin-top: 1em">x=$(case $foo in bar) echo $bar
;; *) echo $baz ;; esac) <br>
# above fails to parse on old shells; below is the
workaround <br>
x=$(eval $(cat)) &lt;&lt;&quot;EOF&quot; <br>
case $foo in bar) echo $bar ;; *) echo $baz ;; esac <br>
EOF</p>

<p style="margin-top: 1em">Arithmetic substitutions are
replaced by the value of the specified expression. For
example, the command print $((2+3*4)) displays 14. See
Arithmetic expressions for a descrip&acirc; <br>
tion of an expression.</p>

<p style="margin-top: 1em">Parameters <br>
Parameters are shell variables; they can be assigned values
and their values can be accessed using a parameter
substitution. A parameter name is either one of the special
single <br>
punctuation or digit character parameters described below,
or a letter followed by zero or more letters or digits
(&acirc;_&acirc; counts as a letter). The latter form can be
treated as <br>
arrays by appending an array index of the form [expr] where
expr is an arithmetic expression. Array indices in mksh are
limited to the range 0 through 4294967295, inclusive. That
<br>
is, they are a 32-bit unsigned integer.</p>

<p style="margin-top: 1em">Parameter substitutions take the
form $name, ${name}, or ${name[expr]} where name is a
parameter name. Substitution of all array elements with
${name[*]} and ${name[@]} works <br>
equivalent to $* and $@ for positional parameters. If
substitution is performed on a parameter (or an array
parameter element) that is not set, a null string is
substituted unless <br>
the nounset option (set -o nounset or set -u) is set, in
which case an error occurs.</p>

<p style="margin-top: 1em">Parameters can be assigned
values in a number of ways. First, the shell implicitly sets
some parameters like &acirc;#&acirc;, &acirc;PWD&acirc;, and
&acirc;$&acirc;; this is the only way the special single
character <br>
parameters are set. Second, parameters are imported from the
shell&rsquo;s environment at startup. Third, parameters can
be assigned values on the command line: for example, FOO=bar
<br>
sets the parameter &acirc;FOO&acirc; to &acirc;bar&acirc;;
multiple parameter assignments can be given on a single
command line and they can be followed by a simple-command,
in which case the assignments <br>
are in effect only for the duration of the command (such
assignments are also exported; see below for the
implications of this). Note that both the parameter name and
the &acirc;=&acirc; must <br>
be unquoted for the shell to recognise a parameter
assignment. The construct FOO+=baz is also recognised; the
old and new values are immediately concatenated. The fourth
way of <br>
setting a parameter is with the export, global, readonly,
and typeset commands; see their descriptions in the Command
execution section. Fifth, for and select loops set
parameters <br>
as well as the getopts, read, and set -A commands. Lastly,
parameters can be assigned values using assignment operators
inside arithmetic expressions (see Arithmetic expressions
<br>
below) or using the ${name=value} form of the parameter
substitution (see below).</p>

<p style="margin-top: 1em">Parameters with the export
attribute (set using the export or typeset -x commands, or
by parameter assignments followed by simple commands) are
put in the environment (see <br>
environ(7)) of commands run by the shell as name=value
pairs. The order in which parameters appear in the
environment of a command is unspecified. When the shell
starts up, it <br>
extracts parameters and their values from its environment
and automatically sets the export attribute for those
parameters.</p>

<p style="margin-top: 1em">Modifiers can be applied to the
${name} form of parameter substitution:</p>

<p style="margin-top: 1em">${name:-word} <br>
If name is set and not NULL, it is substituted; otherwise,
word is substituted.</p>

<p style="margin-top: 1em">${name:+word} <br>
If name is set and not NULL, word is substituted; otherwise,
nothing is substituted.</p>

<p style="margin-top: 1em">${name:=word} <br>
If name is set and not NULL, it is substituted; otherwise,
it is assigned word and the resulting value of name is
substituted.</p>

<p style="margin-top: 1em">${name:?word} <br>
If name is set and not NULL, it is substituted; otherwise,
word is printed on standard error (preceded by name:) and an
error occurs (normally causing termination of a <br>
shell script, function, or script sourced using the
&acirc;.&acirc; built-in). If word is omitted, the string
&acirc;parameter null or not set&acirc; is used instead.
Currently a bug, if word is <br>
a variable which expands to the null string, the error
message is also printed.</p>

<p style="margin-top: 1em">Note that, for all of the above,
word is actually considered quoted, and special parsing
rules apply. The parsing rules also differ on whether the
expression is double-quoted: <br>
word then uses double-quoting rules, except for the double
quote itself (&acirc;&quot;&acirc;) and the closing brace,
which, if backslash escaped, gets quote removal applied.</p>

<p style="margin-top: 1em">In the above modifiers, the
&acirc;:&acirc; can be omitted, in which case the conditions
only depend on name being set (as opposed to set and not
NULL). If word is needed, parameter, command, <br>
arithmetic, and tilde substitution are performed on it; if
word is not needed, it is not evaluated.</p>

<p style="margin-top: 1em">The following forms of parameter
substitution can also be used (if name is an array, its
element #0 will be substituted in a scalar context):</p>

<p style="margin-top: 1em">${#name} <br>
The number of positional parameters if name is
&acirc;*&acirc;, &acirc;@&acirc;, or not specified;
otherwise the length (in characters) of the string value of
parameter name.</p>

<p style="margin-top: 1em">${#name[*]} <br>
${#name[@]} <br>
The number of elements in the array name.</p>

<p style="margin-top: 1em">${%name} <br>
The width (in screen columns) of the string value of
parameter name, or -1 if ${name} contains a control
character.</p>

<p style="margin-top: 1em">${!name} <br>
The name of the variable referred to by name. This will be
name except when name is a name reference (bound variable),
created by the nameref command (which is an alias <br>
for typeset -n).</p>

<p style="margin-top: 1em">${!name[*]} <br>
${!name[@]} <br>
The names of indices (keys) in the array name.</p>

<p style="margin-top: 1em">${name#pattern} <br>
${name##pattern} <br>
If pattern matches the beginning of the value of parameter
name, the matched text is deleted from the result of
substitution. A single &acirc;#&acirc; results in the
shortest match, <br>
and two of them result in the longest match. Cannot be
applied to a vector (${*} or ${@} or ${array[*]} or
${array[@]}).</p>

<p style="margin-top: 1em">${name%pattern} <br>
${name%%pattern} <br>
Like ${..#..} substitution, but it deletes from the end of
the value. Cannot be applied to a vector.</p>

<p style="margin-top: 1em">${name/pattern/string} <br>
${name//pattern/string} <br>
Like ${..#..} substitution, but it replaces the longest
match of pattern, anchored anywhere in the value, with
string. If pattern begins with &acirc;#&acirc;, it is
anchored at the <br>
beginning of the value; if it begins with &acirc;%&acirc;,
it is anchored at the end. Patterns that are empty or
consist only of wildcards are invalid. A single
&acirc;/&acirc; replaces the <br>
first occurence of the search pattern, and two of them
replace all occurences. If /string is omitted, the pattern
is replaced by the empty string, i.e. deleted. Cannot be
<br>
applied to a vector. Inefficiently implemented, may be
slow.</p>

<p style="margin-top: 1em">${name:pos:len} <br>
The first len characters of name, starting at position pos,
are substituted. Both pos and :len are optional. If pos is
negative, counting starts at the end of the string; <br>
if it is omitted, it defaults to 0. If len is omitted or
greater than the length of the remaining string, all of it
is substituted. Both pos and len are evaluated as <br>
arithmetic expressions. Currently, pos must start with a
space, opening parenthesis or digit to be recognised. Cannot
be applied to a vector.</p>

<p style="margin-top: 1em">${name @#[seed]} <br>
The internal hash of the expansion of name, with an optional
(defaulting to zero) [seed]. At the moment, this is NZAAT (a
32-bit hash based on Bob Jenkins&rsquo; one-at-a-time <br>
hash), but this is not set. This is the hash the shell uses
internally for its associative arrays.</p>

<p style="margin-top: 1em">${name@Q} <br>
A quoted expression safe for re-entry, whose value is the
value of the name parameter, is substituted.</p>

<p style="margin-top: 1em">Note that pattern may need
extended globbing pattern (@(...)), single
(&rsquo;...&rsquo;) or double (&quot;...&quot;) quote
escaping unless -o sh is set.</p>

<p style="margin-top: 1em">The following special parameters
are implicitly set by the shell and cannot be set directly
using assignments:</p>

<p style="margin-top: 1em">! Process ID of the last
background process started. If no background processes have
been started, the parameter is not set.</p>

<p style="margin-top: 1em"># The number of positional
parameters ($1, $2, etc.).</p>

<p style="margin-top: 1em">$ The PID of the shell, or the
PID of the original shell if it is a subshell. Do NOT use
this mechanism for generating temporary file names; see
mktemp(1) instead.</p>

<p style="margin-top: 1em">- The concatenation of the
current single letter options (see the set command below for
a list of options).</p>

<p style="margin-top: 1em">? The exit status of the last
non-asynchronous command executed. If the last command was
killed by a signal, $? is set to 128 plus the signal
number.</p>

<p style="margin-top: 1em">0 The name of the shell,
determined as follows: the first argument to mksh if it was
invoked with the -c option and arguments were given;
otherwise the file argument, if it <br>
was supplied; or else the basename the shell was invoked
with (i.e. argv[0]). $0 is also set to the name of the
current script or the name of the current function, if it
<br>
was defined with the function keyword (i.e. a Korn shell
style function).</p>

<p style="margin-top: 1em">1 .. 9 The first nine positional
parameters that were supplied to the shell, function, or
script sourced using the &acirc;.&acirc; built-in. Further
positional parameters may be accessed <br>
using ${number}.</p>

<p style="margin-top: 1em">* All positional parameters
(except 0), i.e. $1, $2, $3, ... <br>
If used outside of double quotes, parameters are separate
words (which are subjected to word splitting); if used
within double quotes, parameters are separated by the first
<br>
character of the IFS parameter (or the empty string if IFS
is NULL).</p>

<p style="margin-top: 1em">@ Same as $*, unless it is used
inside double quotes, in which case a separate word is
generated for each positional parameter. If there are no
positional parameters, no <br>
word is generated. $@ can be used to access arguments,
verbatim, without losing NULL arguments or splitting
arguments with spaces.</p>

<p style="margin-top: 1em">The following parameters are set
and/or used by the shell:</p>

<p style="margin-top: 1em">_ (underscore) When an external
command is executed by the shell, this parameter is set in
the environment of the new process to the path of the
executed command. In <br>
interactive use, this parameter is also set in the parent
shell to the last word of the previous command.</p>

<p style="margin-top: 1em">BASHPID The PID of the shell or
subshell.</p>

<p style="margin-top: 1em">CDPATH Search path for the cd
built-in command. It works the same way as PATH for those
directories not beginning with &acirc;/&acirc; in cd
commands. Note that if CDPATH is set and <br>
does not contain &acirc;.&acirc; or contains an empty path,
the current directory is not searched. Also, the cd built-in
command will display the resulting directory when a match
<br>
is found in any search path other than the empty path.</p>

<p style="margin-top: 1em">COLUMNS Set to the number of
columns on the terminal or window. Always set, defaults to
80, unless the value as reported by stty(1) is non-zero and
sane enough (minimum is <br>
12x3); similar for LINES. This parameter is used by the
interactive line editing modes, and by the select, set -o,
and kill -l commands to format information columns. <br>
Importing from the environment or unsetting this parameter
removes the binding to the actual terminal size in favour of
the provided value.</p>

<p style="margin-top: 1em">ENV If this parameter is found
to be set after any profile files are executed, the expanded
value is used as a shell startup file. It typically contains
function and <br>
alias definitions.</p>

<p style="margin-top: 1em">ERRNO Integer value of the
shell&rsquo;s errno variable. It indicates the reason the
last system call failed. Not yet implemented.</p>

<p style="margin-top: 1em">EXECSHELL If set, this parameter
is assumed to contain the shell that is to be used to
execute commands that execve(2) fails to execute and which
do not start with a &acirc;#!shell&acirc; <br>
sequence.</p>

<p style="margin-top: 1em">FCEDIT The editor used by the fc
command (see below).</p>

<p style="margin-top: 1em">FPATH Like PATH, but used when
an undefined function is executed to locate the file
defining the function. It is also searched when a command
can&rsquo;t be found using PATH. <br>
See Functions below for more information.</p>

<p style="margin-top: 1em">HISTFILE The name of the file
used to store command history. When assigned to, history is
loaded from the specified file. Also, several invocations of
the shell will share <br>
history if their HISTFILE parameters all point to the same
file.</p>

<p style="margin-top: 1em">Note: If HISTFILE isn&rsquo;t
set, no history file is used. This is different from
AT&amp;T UNIX ksh.</p>

<p style="margin-top: 1em">HISTSIZE The number of commands
normally stored for history. The default is 2047.</p>

<p style="margin-top: 1em">HOME The default directory for
the cd command and the value substituted for an unqualified
~ (see Tilde expansion below).</p>

<p style="margin-top: 1em">IFS Internal field separator,
used during substitution and by the read command, to split
values into distinct arguments; normally set to space, tab,
and newline. See <br>
Substitution above for details.</p>

<p style="margin-top: 1em">Note: This parameter is not
imported from the environment when the shell is started.</p>

<p style="margin-top: 1em">KSHEGID The effective group id
of the shell.</p>

<p style="margin-top: 1em">KSHGID The real group id of the
shell.</p>

<p style="margin-top: 1em">KSHUID The real user id of the
shell.</p>

<p style="margin-top: 1em">KSH_VERSION The name and version
of the shell (read-only). See also the version commands in
Emacs editing mode and Vi editing mode sections, below.</p>

<p style="margin-top: 1em">LINENO The line number of the
function or shell script that is currently being
executed.</p>

<p style="margin-top: 1em">LINES Set to the number of lines
on the terminal or window. Always set, defaults to 24. See
COLUMNS.</p>

<p style="margin-top: 1em">EPOCHREALTIME <br>
Time since the epoch, as returned by gettimeofday(2),
formatted as decimal tv_sec followed by a dot
(&acirc;.&acirc;) and tv_usec padded to exactly six decimal
digits.</p>

<p style="margin-top: 1em">OLDPWD The previous working
directory. Unset if cd has not successfully changed
directories since the shell started, or if the shell
doesn&rsquo;t know where it is.</p>

<p style="margin-top: 1em">OPTARG When using getopts, it
contains the argument for a parsed option, if it requires
one.</p>

<p style="margin-top: 1em">OPTIND The index of the next
argument to be processed when using getopts. Assigning 1 to
this parameter causes getopts to process arguments from the
beginning the next time <br>
it is invoked.</p>

<p style="margin-top: 1em">PATH A colon separated list of
directories that are searched when looking for commands and
files sourced using the &acirc;.&acirc; command (see below).
An empty string resulting from <br>
a leading or trailing colon, or two adjacent colons, is
treated as a &acirc;.&acirc; (the current directory).</p>

<p style="margin-top: 1em">PGRP The process ID of the
shell&rsquo;s process group leader.</p>

<p style="margin-top: 1em">PIPESTATUS An array containing
the errorlevel (exit status) codes, one by one, of the last
pipeline run in the foreground.</p>

<p style="margin-top: 1em">PPID The process ID of the
shell&rsquo;s parent.</p>

<p style="margin-top: 1em">PS1 The primary prompt for
interactive shells. Parameter, command, and arithmetic
substitutions are performed, and &acirc;!&acirc; is replaced
with the current command number (see <br>
the fc command below). A literal &acirc;!&acirc; can be put
in the prompt by placing &acirc;!!&acirc; in PS1.</p>

<p style="margin-top: 1em">The default prompt is &acirc;$
&acirc; for non-root users, &acirc;# &acirc; for root. If
mksh is invoked by root and PS1 does not contain a
&acirc;#&acirc; character, the default value will be used
even <br>
if PS1 already exists in the environment.</p>

<p style="margin-top: 1em">The mksh distribution comes with
a sample dot.mkshrc containing a sophisticated example, but
you might like the following one (note that
${HOSTNAME:=$(hostname)} and <br>
the root-vs-user distinguishing clause are (in this example)
executed at PS1 assignment time, while the $USER and $PWD
are escaped and thus will be evaluated each time <br>
a prompt is displayed):</p>

<p style="margin-top: 1em">PS1=&rsquo;${USER:=$(id
-un)}&rsquo;&quot;@${HOSTNAME:=$(hostname)}:WD $( <br>
if (( USER_ID )); then print else print <br>
Note that since the command-line editors try to figure out
how long the prompt is (so they know how far it is to the
edge of the screen), escape codes in the prompt <br>
tend to mess things up. You can tell the shell not to count
certain sequences (such as escape codes) by prefixing your
prompt with a character (such as Ctrl-A) fol&acirc; <br>
lowed by a carriage return and then delimiting the escape
codes with this character. Any occurences of that character
in the prompt are not printed. By the way, <br>
don&rsquo;t blame me for this hack; it&rsquo;s derived from
the original ksh88(1), which did print the delimiter
character so you were out of luck if you did not have any
non- <br>
printing characters.</p>

<p style="margin-top: 1em">Since Backslashes and other
special characters may be interpreted by the shell, to set
PS1 either escape the backslash itself, or use double
quotes. The latter is <br>
more practical. This is a more complex example, avoiding to
directly enter special characters (for example with ^V in
the emacs editing mode), which embeds the cur&acirc; <br>
rent working directory, in reverse video (colour would work,
too), in the prompt string:</p>

<p style="margin-top: 1em">x=$(print \001) <br>
PS1=&quot;$x$(print \r)$x$(tput smso)$xWD$x$(tput
rmso)$x&gt; &quot;</p>

<p style="margin-top: 1em">Due to a strong suggestion from
David G. Korn, mksh now also supports the following form:
1\[7m1$PWD1\[0m1&gt; &rsquo;</p>

<p style="margin-top: 1em">PS1=$&rsquo;1</p>

<p style="margin-top: 1em">PS2 Secondary prompt string, by
default &acirc;&gt; &acirc;, used when more input is needed
to complete a command.</p>

<p style="margin-top: 1em">PS3 Prompt used by the select
statement when reading a menu selection. The default is
&acirc;#? &acirc;.</p>

<p style="margin-top: 1em">PS4 Used to prefix commands that
are printed during execution tracing (see the set -x command
below). Parameter, command, and arithmetic substitutions are
performed <br>
before it is printed. The default is &acirc;+ &acirc;. You
may want to set it to &acirc;[$EPOCHREALTIME] &acirc;
instead, to include timestamps.</p>

<p style="margin-top: 1em">PWD The current working
directory. May be unset or NULL if the shell doesn&rsquo;t
know where it is.</p>

<p style="margin-top: 1em">RANDOM Each time RANDOM is
referenced, it is assigned a number between 0 and 32767 from
a Linear Congruential PRNG first.</p>

<p style="margin-top: 1em">REPLY Default parameter for the
read command if no names are given. Also used in select
loops to store the value that is read from standard
input.</p>

<p style="margin-top: 1em">SECONDS The number of seconds
since the shell started or, if the parameter has been
assigned an integer value, the number of seconds since the
assignment plus the value that <br>
was assigned.</p>

<p style="margin-top: 1em">TMOUT If set to a positive
integer in an interactive shell, it specifies the maximum
number of seconds the shell will wait for input after
printing the primary prompt (PS1). <br>
If the time is exceeded, the shell exits.</p>

<p style="margin-top: 1em">TMPDIR The directory temporary
shell files are created in. If this parameter is not set, or
does not contain the absolute path of a writable directory,
temporary files are <br>
created in /tmp.</p>

<p style="margin-top: 1em">USER_ID The effective user id of
the shell.</p>

<p style="margin-top: 1em">Tilde expansion <br>
Tilde expansion which is done in parallel with parameter
substitution, is done on words starting with an unquoted
&acirc;~&acirc;. The characters following the tilde, up to
the first &acirc;/&acirc;, if <br>
any, are assumed to be a login name. If the login name is
empty, &acirc;+&acirc;, or &acirc;-&acirc;, the value of the
HOME, PWD, or OLDPWD parameter is substituted, respectively.
Otherwise, the pass&acirc; <br>
word file is searched for the login name, and the tilde
expression is substituted with the user&rsquo;s home
directory. If the login name is not found in the password
file or if any <br>
quoting or parameter substitution occurs in the login name,
no substitution is performed.</p>

<p style="margin-top: 1em">In parameter assignments (such
as those preceding a simple-command or those occurring in
the arguments of alias, export, global, readonly, and
typeset), tilde expansion is done <br>
after any assignment (i.e. after the equals sign) or after
an unquoted colon (&acirc;:&acirc;); login names are also
delimited by colons.</p>

<p style="margin-top: 1em">The home directory of previously
expanded login names are cached and re-used. The alias -d
command may be used to list, change, and add to this cache
(e.g. alias -d <br>
fac=/usr/local/facilities; cd ~fac/bin).</p>

<p style="margin-top: 1em">Brace expansion (alteration)
<br>
Brace expressions take the following form:</p>

<p style="margin-top: 1em">prefix{str1,...,strN}suffix</p>

<p style="margin-top: 1em">The expressions are expanded to
N words, each of which is the concatenation of prefix, stri,
and suffix (e.g. &acirc;a{c,b{X,Y},d}e&acirc; expands to
four words: &acirc;ace&acirc;, &acirc;abXe&acirc;,
&acirc;abYe&acirc;, and <br>
&acirc;ade&acirc;). As noted in the example, brace
expressions can be nested and the resulting words are not
sorted. Brace expressions must contain an unquoted comma
(&acirc;,&acirc;) for expansion to <br>
occur (e.g. {} and {foo} are not expanded). Brace expansion
is carried out after parameter substitution and before file
name generation.</p>

<p style="margin-top: 1em">File name patterns <br>
A file name pattern is a word containing one or more
unquoted &acirc;?&acirc;, &acirc;*&acirc;, &acirc;+&acirc;,
&acirc;@&acirc;, or &acirc;!&acirc; characters or
&acirc;[..]&acirc; sequences. Once brace expansion has been
performed, the shell <br>
replaces file name patterns with the sorted names of all the
files that match the pattern (if no files match, the word is
left unchanged). The pattern elements have the following
<br>
meaning:</p>

<p style="margin-top: 1em">? Matches any single
character.</p>

<p style="margin-top: 1em">* Matches any sequence of
octets.</p>

<p style="margin-top: 1em">[..] Matches any of the octets
inside the brackets. Ranges of octets can be specified by
separating two octets by a &acirc;-&acirc; (e.g.
&acirc;[a0-9]&acirc; matches the letter &acirc;a&acirc; or
any digit). In <br>
order to represent itself, a &acirc;-&acirc; must either be
quoted or the first or last octet in the octet list.
Similarly, a &acirc;]&acirc; must be quoted or the first
octet in the list if it <br>
is to represent itself instead of the end of the list. Also,
a &acirc;!&acirc; appearing at the start of the list has
special meaning (see below), so to represent itself it must
be <br>
quoted or appear later in the list.</p>

<p style="margin-top: 1em">[!..] Like [..], except it
matches any octet not inside the brackets.</p>

<p style="margin-top: 1em">*(pattern|...|pattern) <br>
Matches any string of octets that matches zero or more
occurrences of the specified patterns. Example: The pattern
*(foo|bar) matches the strings &acirc;&acirc;,
&acirc;foo&acirc;, &acirc;bar&acirc;, <br>
&acirc;foobarfoo&acirc;, etc.</p>

<p style="margin-top: 1em">+(pattern|...|pattern) <br>
Matches any string of octets that matches one or more
occurrences of the specified patterns. Example: The pattern
+(foo|bar) matches the strings &acirc;foo&acirc;,
&acirc;bar&acirc;, &acirc;foobar&acirc;, <br>
etc.</p>

<p style="margin-top: 1em">?(pattern|...|pattern) <br>
Matches the empty string or a string that matches one of the
specified patterns. Example: The pattern ?(foo|bar) only
matches the strings &acirc;&acirc;, &acirc;foo&acirc;, and
&acirc;bar&acirc;.</p>

<p style="margin-top: 1em">@(pattern|...|pattern) <br>
Matches a string that matches one of the specified patterns.
Example: The pattern @(foo|bar) only matches the strings
&acirc;foo&acirc; and &acirc;bar&acirc;.</p>

<p style="margin-top: 1em">!(pattern|...|pattern) <br>
Matches any string that does not match one of the specified
patterns. Examples: The pattern !(foo|bar) matches all
strings except &acirc;foo&acirc; and &acirc;bar&acirc;; the
pattern !(*) matches <br>
no strings; the pattern !(?)* matches all strings (think
about it).</p>

<p style="margin-top: 1em">Note that complicated globbing,
especially with alternatives, is slow; using separate
comparisons may (or may not) be faster.</p>

<p style="margin-top: 1em">Note that mksh (and pdksh) never
matches &acirc;.&acirc; and &acirc;..&acirc;, but AT&amp;T
UNIX ksh, Bourne sh, and GNU bash do.</p>

<p style="margin-top: 1em">Note that none of the above
pattern elements match either a period (&acirc;.&acirc;) at
the start of a file name or a slash (&acirc;/&acirc;), even
if they are explicitly used in a [..] sequence; also, <br>
the names &acirc;.&acirc; and &acirc;..&acirc; are never
matched, even by the pattern &acirc;.*&acirc;.</p>

<p style="margin-top: 1em">If the markdirs option is set,
any directories that result from file name generation are
marked with a trailing &acirc;/&acirc;.</p>

<p style="margin-top: 1em">Input/output redirection <br>
When a command is executed, its standard input, standard
output, and standard error (file descriptors 0, 1, and 2,
respectively) are normally inherited from the shell. Three
<br>
exceptions to this are commands in pipelines, for which
standard input and/or standard output are those set up by
the pipeline, asynchronous commands created when job control
is <br>
disabled, for which standard input is initially set to be
from /dev/null, and commands for which any of the following
redirections have been specified:</p>

<p style="margin-top: 1em">&gt; file Standard output is
redirected to file. If file does not exist, it is created;
if it does exist, is a regular file, and the noclobber
option is set, an error occurs; <br>
otherwise, the file is truncated. Note that this means the
command cmd &lt;foo &gt;foo will open foo for reading and
then truncate it when it opens it for writing, before <br>
cmd gets a chance to actually read foo.</p>

<p style="margin-top: 1em">&gt;| file Same as &gt;, except
the file is truncated, even if the noclobber option is
set.</p>

<p style="margin-top: 1em">&gt;&gt; file Same as &gt;,
except if file exists it is appended to instead of being
truncated. Also, the file is opened in append mode, so
writes always go to the end of the file (see <br>
open(2)).</p>

<p style="margin-top: 1em">&lt; file Standard input is
redirected from file, which is opened for reading.</p>

<p style="margin-top: 1em">&lt;&gt; file Same as &lt;,
except the file is opened for reading and writing.</p>

<p style="margin-top: 1em">&lt;&lt; marker After reading
the command line containing this kind of redirection (called
a &acirc;here document&acirc;), the shell copies lines from
the command source into a temporary file <br>
until a line matching marker is read. When the command is
executed, standard input is redirected from the temporary
file. If marker contains no quoted characters, the <br>
contents of the temporary file are processed as if enclosed
in double quotes each time the command is executed, so
parameter, command, and arithmetic substitutions are <br>
performed, along with backslash (&acirc;&acirc;) escapes for
&acirc;$&acirc;, &acirc;&lsquo;&acirc;, &acirc;&acirc;, and
&acirc;0wline&acirc;, but not for &acirc;&quot;&acirc;. If
multiple here documents are used on the same command line,
they <br>
are saved in order.</p>

<p style="margin-top: 1em">If no marker is given, the here
document ends at the next &lt;&lt; and substitution will be
performed. If marker is only a set of either single
&acirc;&rsquo;&rsquo;&acirc; or double
&acirc;&quot;&quot;&acirc; quotes <br>
with nothing in between, the here document ends at the next
empty line and substitution will not be performed.</p>

<p style="margin-top: 1em">&lt;&lt;- marker Same as
&lt;&lt;, except leading tabs are stripped from lines in the
here document.</p>

<p style="margin-top: 1em">&lt;&lt;&lt; word Same as
&lt;&lt;, except that word is the here document. This is
called a here string.</p>

<p style="margin-top: 1em">&lt;&amp; fd Standard input is
duplicated from file descriptor fd. fd can be a number,
indicating the number of an existing file descriptor; the
letter &acirc;p&acirc;, indicating the file <br>
descriptor associated with the output of the current
co-process; or the character &acirc;-&acirc;, indicating
standard input is to be closed. Note that fd is limited to a
single <br>
digit in most shell implementations.</p>

<p style="margin-top: 1em">&gt;&amp; fd Same as &lt;&amp;,
except the operation is done on standard output.</p>

<p style="margin-top: 1em">&amp;&gt; file Same as &gt; file
2&gt;&amp;1. This is a GNU bash extension supported by mksh
which also supports the preceding explicit fd number, for
example, 3&amp;&gt; file is the same as 3&gt; file <br>
2&gt;&amp;3 in mksh but a syntax error in GNU bash. Setting
the -o posix or -o sh shell options disable parsing of this
redirection; it&rsquo;s a compatibility feature to legacy
<br>
scripts, to not be used when writing new shell code.</p>

<p style="margin-top: 1em">&amp;&gt;| file, &amp;&gt;&gt;
file, &amp;&gt;&amp; fd <br>
Same as &gt;| file, &gt;&gt; file, or &gt;&amp; fd, followed
by 2&gt;&amp;1, as above. These are mksh extensions.</p>

<p style="margin-top: 1em">In any of the above
redirections, the file descriptor that is redirected (i.e.
standard input or standard output) can be explicitly given
by preceding the redirection with a number <br>
(portably, only a single digit). Parameter, command, and
arithmetic substitutions, tilde substitutions, and (if the
shell is interactive) file name generation are all performed
on <br>
the file, marker, and fd arguments of redirections. Note,
however, that the results of any file name generation are
only used if a single file is matched; if multiple files
match, <br>
the word with the expanded file name generation characters
is used. Note that in restricted shells, redirections which
can create files cannot be used.</p>

<p style="margin-top: 1em">For simple-commands,
redirections may appear anywhere in the command; for
compound-commands (if statements, etc.), any redirections
must appear at the end. Redirections are pro&acirc; <br>
cessed after pipelines are created and in the order they are
given, so the following will print an error with a line
number prepended to it:</p>

<p style="margin-top: 1em">$ cat /foo/bar 2&gt;&amp;1
&gt;/dev/null | pr -n -t</p>

<p style="margin-top: 1em">File descriptors created by
input/output redirections are private to the Korn shell, but
passed to sub-processes if -o posix or -o sh is set.</p>

<p style="margin-top: 1em">Arithmetic expressions <br>
Integer arithmetic expressions can be used with the let
command, inside $((..)) expressions, inside array references
(e.g. name[expr]), as numeric arguments to the test command,
<br>
and as the value of an assignment to an integer
parameter.</p>

<p style="margin-top: 1em">Expressions are calculated using
signed arithmetic and the mksh_ari_t type (a 32-bit signed
integer), unless they begin with a sole &acirc;#&acirc;
character, in which case they use <br>
mksh_uari_t (a 32-bit unsigned integer).</p>

<p style="margin-top: 1em">Expressions may contain
alpha-numeric parameter identifiers, array references, and
integer constants and may be combined with the following C
operators (listed and grouped in <br>
increasing order of precedence):</p>

<p style="margin-top: 1em">Unary operators:</p>

<p style="margin-top: 1em">+ - ! ~ ++ --</p>

<p style="margin-top: 1em">Binary operators:</p>

<p style="margin-top: 1em">, <br>
= += -= *= /= %= &lt;&lt;&lt;= &gt;&gt;&gt;= &lt;&lt;=
&gt;&gt;= &amp;= ^= |= <br>
|| <br>
&amp;&amp; <br>
| <br>
^ <br>
&amp; <br>
== != <br>
&lt; &lt;= &gt; &gt;= <br>
&lt;&lt;&lt; &gt;&gt;&gt; &lt;&lt; &gt;&gt; <br>
+ - <br>
* / %</p>

<p style="margin-top: 1em">Ternary operators:</p>

<p style="margin-top: 1em">?: (precedence is immediately
higher than assignment)</p>

<p style="margin-top: 1em">Grouping operators:</p>

<p style="margin-top: 1em">( )</p>

<p style="margin-top: 1em">Integer constants and
expressions are calculated using an exactly 32-bit wide,
signed or unsigned, type with silent wraparound on integer
overflow. Integer constants may be speci&acirc; <br>
fied with arbitrary bases using the notation base#number,
where base is a decimal integer specifying the base, and
number is a number in the specified base. Additionally,
base-16 <br>
integers may be specified by prefixing them with
&acirc;0x&acirc; (case-insensitive) in all forms of
arithmetic expressions, except as numeric arguments to the
test built-in command. Prefix&acirc; <br>
ing numbers with a sole digit zero (&acirc;0&acirc;) leads
to the shell interpreting it as base-8 integer in posix mode
only; historically, (pd)ksh has never done so either anyway,
and it&rsquo;s <br>
unsafe to do that, but POSIX demands it nowadays. As a
special mksh extension, numbers to the base of one are
treated as either (8-bit transparent) ASCII or Unicode
codepoints, <br>
depending on the shell&rsquo;s utf8-mode flag (current
setting). The AT&amp;T UNIX ksh93 syntax of
&acirc;&rsquo;x&rsquo;&acirc; instead of &acirc;1#x&acirc;
is also supported. Note that NUL bytes (integral value of
zero) <br>
cannot be used. An unset or empty parameter evaluates to 0
in integer context. In Unicode mode, raw octets are mapped
into the range EF80..EFFF as in OPTU-8, which is in the PUA
<br>
and has been assigned by CSUR for this use. If more than one
octet in ASCII mode, or a sequence of more than one octet
not forming a valid and minimal CESU-8 sequence is passed,
<br>
the behaviour is undefined (usually, the shell aborts with a
parse error, but rarely, it succeeds, e.g. on the sequence
C2 20). That&rsquo;s why you should always use ASCII mode
unless <br>
you know that the input is well-formed UTF-8 in the range of
0000..FFFD.</p>

<p style="margin-top: 1em">The operators are evaluated as
follows:</p>

<p style="margin-top: 1em">unary + <br>
Result is the argument (included for completeness).</p>

<p style="margin-top: 1em">unary - <br>
Negation.</p>

<p style="margin-top: 1em">! Logical NOT; the result is 1
if argument is zero, 0 if not.</p>

<p style="margin-top: 1em">~ Arithmetic (bit-wise) NOT.</p>

<p style="margin-top: 1em">++ Increment; must be applied to
a parameter (not a literal or other expression). The
parameter is incremented by 1. When used as a prefix
operator, the result is the <br>
incremented value of the parameter; when used as a postfix
operator, the result is the original value of the
parameter.</p>

<p style="margin-top: 1em">-- Similar to ++, except the
parameter is decremented by 1.</p>

<p style="margin-top: 1em">, Separates two arithmetic
expressions; the left-hand side is evaluated first, then the
right. The result is the value of the expression on the
right-hand side.</p>

<p style="margin-top: 1em">= Assignment; the variable on
the left is set to the value on the right.</p>

<p style="margin-top: 1em">+= -= *= /= %= &lt;&lt;&lt;=
&gt;&gt;&gt;= &lt;&lt;= &gt;&gt;= &amp;= ^= |= <br>
Assignment operators. &lt;var&gt;&lt;op&gt;=&lt;expr&gt; is
the same as &lt;var&gt;=&lt;var&gt;&lt;op&gt;&lt;expr&gt;,
with any operator precedence in &lt;expr&gt; preserved. For
example, &acirc;var1 *= 5 + 3&acirc; is the <br>
same as specifying &acirc;var1 = var1 * (5 + 3)&acirc;.</p>

<p style="margin-top: 1em">|| Logical OR; the result is 1
if either argument is non-zero, 0 if not. The right argument
is evaluated only if the left argument is zero.</p>

<p style="margin-top: 1em">&amp;&amp; Logical AND; the
result is 1 if both arguments are non-zero, 0 if not. The
right argument is evaluated only if the left argument is
non-zero.</p>

<p style="margin-top: 1em">| Arithmetic (bit-wise) OR.</p>

<p style="margin-top: 1em">^ Arithmetic (bit-wise) XOR
(exclusive-OR).</p>

<p style="margin-top: 1em">&amp; Arithmetic (bit-wise)
AND.</p>

<p style="margin-top: 1em">== Equal; the result is 1 if
both arguments are equal, 0 if not.</p>

<p style="margin-top: 1em">!= Not equal; the result is 0 if
both arguments are equal, 1 if not.</p>

<p style="margin-top: 1em">&lt; Less than; the result is 1
if the left argument is less than the right, 0 if not.</p>

<p style="margin-top: 1em">&lt;= &gt; &gt;= <br>
Less than or equal, greater than or equal, greater than. See
&lt;.</p>

<p style="margin-top: 1em">&lt;&lt;&lt; &gt;&gt;&gt; <br>
Rotate left (right); the result is similar to shift (see
&lt;&lt;) except that the bits shifted out at one end are
shifted in at the other end, instead of zero or sign <br>
bits.</p>

<p style="margin-top: 1em">&lt;&lt; &gt;&gt; Shift left
(right); the result is the left argument with its bits
shifted left (right) by the amount given in the right
argument.</p>

<p style="margin-top: 1em">+ - * / <br>
Addition, subtraction, multiplication, and division.</p>

<p style="margin-top: 1em">% Remainder; the result is the
remainder of the division of the left argument by the
right.</p>


<p style="margin-top: 1em">&lt;arg1&gt;?&lt;arg2&gt;:&lt;arg3&gt;
<br>
If &lt;arg1&gt; is non-zero, the result is &lt;arg2&gt;;
otherwise the result is &lt;arg3&gt;. The non-result
argument is not evaluated.</p>

<p style="margin-top: 1em">Co-processes <br>
A co-process (which is a pipeline created with the
&acirc;|&amp;&acirc; operator) is an asynchronous process
that the shell can both write to (using print -p) and read
from (using read -p). The <br>
input and output of the co-process can also be manipulated
using &gt;&amp;p and &lt;&amp;p redirections, respectively.
Once a co-process has been started, another can&rsquo;t be
started until the co- <br>
process exits, or until the co-process&rsquo;s input has
been redirected using an exec n&gt;&amp;p redirection. If a
co-process&rsquo;s input is redirected in this way, the next
co-process to be <br>
started will share the output with the first co-process,
unless the output of the initial co-process has been
redirected using an exec n&lt;&amp;p redirection.</p>

<p style="margin-top: 1em">Some notes concerning
co-processes:</p>

<p style="margin-top: 1em">&Acirc;&middot; The only way to
close the co-process&rsquo;s input (so the co-process reads
an end-of-file) is to redirect the input to a numbered file
descriptor and then close that file descrip&acirc; <br>
tor: exec 3&gt;&amp;p; exec 3&gt;&amp;-</p>

<p style="margin-top: 1em">&Acirc;&middot; In order for
co-processes to share a common output, the shell must keep
the write portion of the output pipe open. This means that
end-of-file will not be detected until all <br>
co-processes sharing the co-process&rsquo;s output have
exited (when they all exit, the shell closes its copy of the
pipe). This can be avoided by redirecting the output to a
num&acirc; <br>
bered file descriptor (as this also causes the shell to
close its copy). Note that this behaviour is slightly
different from the original Korn shell which closes its copy
of <br>
the write portion of the co-process output when the most
recently started co-process (instead of when all sharing
co-processes) exits.</p>

<p style="margin-top: 1em">&Acirc;&middot; print -p will
ignore SIGPIPE signals during writes if the signal is not
being trapped or ignored; the same is true if the co-process
input has been duplicated to another file <br>
descriptor and print -un is used.</p>

<p style="margin-top: 1em">Functions <br>
Functions are defined using either Korn shell function
function-name syntax or the Bourne/POSIX shell
function-name() syntax (see below for the difference between
the two forms). <br>
Functions are like .&acirc;scripts (i.e. scripts sourced
using the &acirc;.&acirc; built-in) in that they are
executed in the current environment. However, unlike
.&acirc;scripts, shell arguments (i.e. <br>
positional parameters $1, $2, etc.) are never visible inside
them. When the shell is determining the location of a
command, functions are searched after special built-in
commands, <br>
before builtins and the PATH is searched.</p>

<p style="margin-top: 1em">An existing function may be
deleted using unset -f function-name. A list of functions
can be obtained using typeset +f and the function
definitions can be listed using typeset -f. <br>
The autoload command (which is an alias for typeset -fu) may
be used to create undefined functions: when an undefined
function is executed, the shell searches the path specified
in <br>
the FPATH parameter for a file with the same name as the
function which, if found, is read and executed. If after
executing the file the named function is found to be
defined, the <br>
function is executed; otherwise, the normal command search
is continued (i.e. the shell searches the regular built-in
command table and PATH). Note that if a command is not found
<br>
using PATH, an attempt is made to autoload a function using
FPATH (this is an undocumented feature of the original Korn
shell).</p>

<p style="margin-top: 1em">Functions can have two
attributes, &acirc;trace&acirc; and &acirc;export&acirc;,
which can be set with typeset -ft and typeset -fx,
respectively. When a traced function is executed, the
shell&rsquo;s xtrace <br>
option is turned on for the function&rsquo;s duration. The
&acirc;export&acirc; attribute of functions is currently not
used. In the original Korn shell, exported functions are
visible to shell <br>
scripts that are executed.</p>

<p style="margin-top: 1em">Since functions are executed in
the current shell environment, parameter assignments made
inside functions are visible after the function completes.
If this is not the desired <br>
effect, the typeset command can be used inside a function to
create a local parameter. Note that AT&amp;T UNIX ksh93 uses
static scoping (one global scope, one local scope per
func&acirc; <br>
tion) and allows local variables only on Korn style
functions, whereas mksh uses dynamic scoping (nested scopes
of varying locality). Note that special parameters (e.g. $$,
$!) <br>
can&rsquo;t be scoped in this way.</p>

<p style="margin-top: 1em">The exit status of a function is
that of the last command executed in the function. A
function can be made to finish immediately using the return
command; this may also be used to <br>
explicitly specify the exit status.</p>

<p style="margin-top: 1em">Functions defined with the
function reserved word are treated differently in the
following ways from functions defined with the ()
notation:</p>

<p style="margin-top: 1em">&Acirc;&middot; The $0 parameter
is set to the name of the function (Bourne-style functions
leave $0 untouched).</p>

<p style="margin-top: 1em">&Acirc;&middot; Parameter
assignments preceding function calls are not kept in the
shell environment (executing Bourne-style functions will
keep assignments).</p>

<p style="margin-top: 1em">&Acirc;&middot; OPTIND is
saved/reset and restored on entry and exit from the function
so getopts can be used properly both inside and outside the
function (Bourne-style functions leave OPTIND <br>
untouched, so using getopts inside a function interferes
with using getopts outside the function).</p>

<p style="margin-top: 1em">&Acirc;&middot; Bourne-style
function definitions take precedence over alias dereferences
and remove alias definitions upon encounter, while aliases
take precedence over Korn-style functions.</p>

<p style="margin-top: 1em">In the future, the following
differences may also be added:</p>

<p style="margin-top: 1em">&Acirc;&middot; A separate
trap/signal environment will be used during the execution of
functions. This will mean that traps set inside a function
will not affect the shell&rsquo;s traps and sig&acirc; <br>
nals that are not ignored in the shell (but may be trapped)
will have their default effect in a function.</p>

<p style="margin-top: 1em">&Acirc;&middot; The EXIT trap,
if set in a function, will be executed after the function
returns.</p>

<p style="margin-top: 1em">Command execution <br>
After evaluation of command-line arguments, redirections,
and parameter assignments, the type of command is
determined: a special built-in command, a function, a normal
builtin, or <br>
the name of a file to execute found using the PATH
parameter. The checks are made in the above order. Special
built-in commands differ from other commands in that the
PATH param&acirc; <br>
eter is not used to find them, an error during their
execution can cause a non-interactive shell to exit, and
parameter assignments that are specified before the command
are kept <br>
after the command completes. Regular built-in commands are
different only in that the PATH parameter is not used to
find them.</p>

<p style="margin-top: 1em">The original ksh and POSIX
differ somewhat in which commands are considered special or
regular.</p>

<p style="margin-top: 1em">POSIX special built-in
utilities:</p>

<p style="margin-top: 1em">., :, break, continue, eval,
exec, exit, export, readonly, return, set, shift, times,
trap, unset</p>

<p style="margin-top: 1em">Additional mksh commands keeping
assignments:</p>

<p style="margin-top: 1em">builtin, global, typeset,
wait</p>

<p style="margin-top: 1em">Builtins that are not
special:</p>

<p style="margin-top: 1em">[, alias, bg, bind, cat, cd,
command, echo, false, fc, fg, getopts, jobs, kill, let,
mknod, print, pwd, read, realpath, rename, sleep, test,
true, ulimit, umask, unalias, whence</p>

<p style="margin-top: 1em">Once the type of command has
been determined, any command-line parameter assignments are
performed and exported for the duration of the command.</p>

<p style="margin-top: 1em">The following describes the
special and regular built-in commands:</p>

<p style="margin-top: 1em">. file [arg ...] <br>
This is called the &acirc;dot&acirc; command. Execute the
commands in file in the current environment. The file is
searched for in the directories of PATH. If arguments are
given, <br>
the positional parameters may be used to access them while
file is being executed. If no arguments are given, the
positional parameters are those of the environment the <br>
command is used in.</p>

<p style="margin-top: 1em">: [...] <br>
The null command. Exit status is set to zero.</p>

<p style="margin-top: 1em">[ expression ] <br>
See test.</p>

<p style="margin-top: 1em">alias [-d | -t [-r] | +-x] [-p]
[+] [name [=value] ...] <br>
Without arguments, alias lists all aliases. For any name
without a value, the existing alias is listed. Any name with
a value defines an alias (see Aliases above).</p>

<p style="margin-top: 1em">When listing aliases, one of two
formats is used. Normally, aliases are listed as name=value,
where value is quoted. If options were preceded with
&acirc;+&acirc;, or a lone &acirc;+&acirc; is <br>
given on the command line, only name is printed.</p>

<p style="margin-top: 1em">The -d option causes directory
aliases which are used in tilde expansion to be listed or
set (see Tilde expansion above).</p>

<p style="margin-top: 1em">If the -p option is used, each
alias is prefixed with the string &acirc;alias &acirc;.</p>

<p style="margin-top: 1em">The -t option indicates that
tracked aliases are to be listed/set (values specified on
the command line are ignored for tracked aliases). The -r
option indicates that all <br>
tracked aliases are to be reset.</p>

<p style="margin-top: 1em">The -x option sets (+x clears)
the export attribute of an alias, or, if no names are given,
lists the aliases with the export attribute (exporting an
alias has no effect).</p>

<p style="margin-top: 1em">bg [job ...] <br>
Resume the specified stopped job(s) in the background. If no
jobs are specified, %+ is assumed. See Job control below for
more information.</p>

<p style="margin-top: 1em">bind [-l] <br>
The current bindings are listed. If the -l flag is given,
bind instead lists the names of the functions to which keys
may be bound. See Emacs editing mode for more infor&acirc;
<br>
mation.</p>

<p style="margin-top: 1em">bind [-m] string=[substitute]
... <br>
bind string=[editing-command] ... <br>
The specified editing command is bound to the given string,
which should consist of a control character optionally
preceded by one of the two prefix characters and
option&acirc; <br>
ally succeded by a tilde character. Future input of the
string will cause the editing command to be immediately
invoked. If the -m flag is given, the specified input <br>
string will afterwards be immediately replaced by the given
substitute string which may contain editing commands but not
other macros. If a tilde postfix is given, a tilde <br>
trailing the one or two prefices and the control character
is ignored, any other trailing character will be processed
afterwards.</p>

<p style="margin-top: 1em">Control characters may be
written using caret notation i.e. ^X represents Ctrl-X. Note
that although only two prefix characters (usually ESC and
^X) are supported, some <br>
multi-character sequences can be supported.</p>

<p style="margin-top: 1em">The following default bindings
show how the arrow keys, the home, end and delete key on a
BSD wsvt25, xterm-xfree86 or GNU screen terminal are bound
(of course some escape <br>
sequences won&rsquo;t work out quite this nicely):</p>

<p style="margin-top: 1em">bind &rsquo;^X&rsquo;=prefix-2
<br>
bind &rsquo;^[[&rsquo;=prefix-2 <br>
bind &rsquo;^XA&rsquo;=up-history <br>
bind &rsquo;^XB&rsquo;=down-history <br>
bind &rsquo;^XC&rsquo;=forward-char <br>
bind &rsquo;^XD&rsquo;=backward-char <br>
bind &rsquo;^X1~&rsquo;=beginning-of-line <br>
bind &rsquo;^X7~&rsquo;=beginning-of-line <br>
bind &rsquo;^XH&rsquo;=beginning-of-line <br>
bind &rsquo;^X4~&rsquo;=end-of-line <br>
bind &rsquo;^X8~&rsquo;=end-of-line <br>
bind &rsquo;^XF&rsquo;=end-of-line <br>
bind &rsquo;^X3~&rsquo;=delete-char-forward</p>

<p style="margin-top: 1em">break [level] <br>
Exit the levelth inner-most for, select, until, or while
loop. level defaults to 1.</p>

<p style="margin-top: 1em">builtin [--] command [arg ...]
<br>
Execute the built-in command command.</p>

<p style="margin-top: 1em">cat [-u] [file ...] <br>
Read files sequentially, in command line order, and write
them to standard output. If a file is a single dash
(&acirc;-&acirc;) or absent, read from standard input.
Unless compiled <br>
with MKSH_NO_EXTERNAL_CAT, if any options are given, an
external cat(1) utility is invoked instead if called from
the shell. For direct builtin calls, the POSIX -u option
<br>
is supported as a no-op.</p>

<p style="margin-top: 1em">cd [-L] [dir] <br>
cd -P [-e] [dir] <br>
chdir [-eLP] [dir] <br>
Set the working directory to dir. If the parameter CDPATH is
set, it lists the search path for the directory containing
dir. A NULL path means the current directory. If <br>
dir is found in any component of the CDPATH search path
other than the NULL path, the name of the new working
directory will be written to standard output. If dir is
miss&acirc; <br>
ing, the home directory HOME is used. If dir is
&acirc;-&acirc;, the previous working directory is used (see
the OLDPWD parameter).</p>

<p style="margin-top: 1em">If the -L option (logical path)
is used or if the physical option isn&rsquo;t set (see the
set command below), references to &acirc;..&acirc; in dir
are relative to the path used to get to <br>
the directory. If the -P option (physical path) is used or
if the physical option is set, &acirc;..&acirc; is relative
to the filesystem directory tree. The PWD and OLDPWD
parameters <br>
are updated to reflect the current and old working
directory, respectively. If the -e option is set for
physical filesystem traversal, and PWD could not be set, the
exit <br>
code is 1; greater than 1 if an error occurred, 0
otherwise.</p>

<p style="margin-top: 1em">cd [-eLP] old new <br>
chdir [-eLP] old new <br>
The string new is substituted for old in the current
directory, and the shell attempts to change to the new
directory.</p>

<p style="margin-top: 1em">command [-pVv] cmd [arg ...]
<br>
If neither the -v nor -V option is given, cmd is executed
exactly as if command had not been specified, with two
exceptions: firstly, cmd cannot be a shell function; and
<br>
secondly, special built-in commands lose their specialness
(i.e. redirection and utility errors do not cause the shell
to exit, and command assignments are not permanent).</p>

<p style="margin-top: 1em">If the -p option is given, a
default search path is used instead of the current value of
PATH, the actual value of which is system dependent.</p>

<p style="margin-top: 1em">If the -v option is given,
instead of executing cmd, information about what would be
executed is given (and the same is done for arg ...). For
special and regular built-in <br>
commands and functions, their names are simply printed; for
aliases, a command that defines them is printed; and for
commands found by searching the PATH parameter, the full
<br>
path of the command is printed. If no command is found (i.e.
the path search fails), nothing is printed and command exits
with a non-zero status. The -V option is like the <br>
-v option, except it is more verbose.</p>

<p style="margin-top: 1em">continue [level] <br>
Jumps to the beginning of the levelth inner-most for,
select, until, or while loop. level defaults to 1.</p>

<p style="margin-top: 1em">echo [-Een] [arg ...] <br>
Warning: this utility is not portable; use the Korn shell
builtin print instead.</p>

<p style="margin-top: 1em">Prints its arguments (separated
by spaces) followed by a newline, to the standard output.
The newline is suppressed if any of the arguments contain
the backslash sequence <br>
&acirc; <br>
The options are provided for compatibility with BSD shell
scripts. The -n option suppresses the trailing newline, -e
enables backslash interpretation (a no-op, since this <br>
is normally done), and -E suppresses backslash
interpretation.</p>

<p style="margin-top: 1em">If the posix or sh option is set
or this is a direct builtin call, only the first argument is
treated as an option, and only if it is exactly
&acirc;-n&acirc;. Backslash interpretation <br>
is disabled.</p>

<p style="margin-top: 1em">eval command ... <br>
The arguments are concatenated (with spaces between them) to
form a single string which the shell then parses and
executes in the current environment.</p>

<p style="margin-top: 1em">exec [command [arg ...]] <br>
The command is executed without forking, replacing the shell
process.</p>

<p style="margin-top: 1em">If no command is given except
for I/O redirection, the I/O redirection is permanent and
the shell is not replaced. Any file descriptors greater than
2 which are opened or <br>
dup(2)&rsquo;d in this way are not made available to other
executed commands (i.e. commands that are not built-in to
the shell). Note that the Bourne shell differs here; it does
<br>
pass these file descriptors on.</p>

<p style="margin-top: 1em">exit [status] <br>
The shell exits with the specified exit status. If status is
not specified, the exit status is the current value of the
$? parameter.</p>

<p style="margin-top: 1em">export [-p] [parameter[=value]]
<br>
Sets the export attribute of the named parameters. Exported
parameters are passed in the environment to executed
commands. If values are specified, the named parameters <br>
are also assigned.</p>

<p style="margin-top: 1em">If no parameters are specified,
all parameters with the export attribute set are printed one
per line; either their names, or, if a &acirc;-&acirc; with
no option letter is specified, <br>
name=value pairs, or, with -p, export commands suitable for
re-entry.</p>

<p style="margin-top: 1em">false A command that exits with
a non-zero status.</p>

<p style="margin-top: 1em">fc [-e editor | -l [-n]] [-r]
[first [last]] <br>
first and last select commands from the history. Commands
can be selected by history number or a string specifying the
most recent command starting with that string. The <br>
-l option lists the command on standard output, and -n
inhibits the default command numbers. The -r option reverses
the order of the list. Without -l, the selected com&acirc;
<br>
mands are edited by the editor specified with the -e option,
or if no -e is specified, the editor specified by the FCEDIT
parameter (if this parameter is not set, /bin/ed is <br>
used), and then executed by the shell.</p>

<p style="margin-top: 1em">fc -e - | -s [-g] [old=new]
[prefix] <br>
Re-execute the selected command (the previous command by
default) after performing the optional substitution of old
with new. If -g is specified, all occurrences of old are
<br>
replaced with new. The meaning of -e - and -s is identical:
re-execute the selected command without invoking an editor.
This command is usually accessed with the prede&acirc; <br>
fined: alias r=&rsquo;fc -e -&rsquo;</p>

<p style="margin-top: 1em">fg [job ...] <br>
Resume the specified job(s) in the foreground. If no jobs
are specified, %+ is assumed. See Job control below for more
information.</p>

<p style="margin-top: 1em">getopts optstring name [arg ...]
<br>
Used by shell procedures to parse the specified arguments
(or positional parameters, if no arguments are given) and to
check for legal options. optstring contains the <br>
option letters that getopts is to recognise. If a letter is
followed by a colon, the option is expected to have an
argument. Options that do not take arguments may be <br>
grouped in a single argument. If an option takes an argument
and the option character is not the last character of the
argument it is found in, the remainder of the argu&acirc;
<br>
ment is taken to be the option&rsquo;s argument; otherwise,
the next argument is the option&rsquo;s argument.</p>

<p style="margin-top: 1em">Each time getopts is invoked, it
places the next option in the shell parameter name and the
index of the argument to be processed by the next call to
getopts in the shell <br>
parameter OPTIND. If the option was introduced with a
&acirc;+&acirc;, the option placed in name is prefixed with
a &acirc;+&acirc;. When an option requires an argument,
getopts places it in the <br>
shell parameter OPTARG.</p>

<p style="margin-top: 1em">When an illegal option or a
missing option argument is encountered, a question mark or a
colon is placed in name (indicating an illegal option or
missing argument, respec&acirc; <br>
tively) and OPTARG is set to the option character that
caused the problem. Furthermore, if optstring does not begin
with a colon, a question mark is placed in name, OPTARG <br>
is unset, and an error message is printed to standard
error.</p>

<p style="margin-top: 1em">When the end of the options is
encountered, getopts exits with a non-zero exit status.
Options end at the first (non-option argument) argument that
does not start with a <br>
&acirc;-&acirc;, or when a &acirc;--&acirc; argument is
encountered.</p>

<p style="margin-top: 1em">Option parsing can be reset by
setting OPTIND to 1 (this is done automatically whenever the
shell or a shell procedure is invoked).</p>

<p style="margin-top: 1em">Warning: Changing the value of
the shell parameter OPTIND to a value other than 1, or
parsing different sets of arguments without resetting
OPTIND, may lead to unexpected <br>
results.</p>

<p style="margin-top: 1em">global ... <br>
See typeset.</p>

<p style="margin-top: 1em">hash [-r] [name ...] <br>
Without arguments, any hashed executable command pathnames
are listed. The -r option causes all hashed commands to be
removed from the hash table. Each name is searched as <br>
if it were a command name and added to the hash table if it
is an executable command.</p>

<p style="margin-top: 1em">jobs [-lnp] [job ...] <br>
Display information about the specified job(s); if no jobs
are specified, all jobs are displayed. The -n option causes
information to be displayed only for jobs that have <br>
changed state since the last notification. If the -l option
is used, the process ID of each process in a job is also
listed. The -p option causes only the process group of <br>
each job to be printed. See Job control below for the format
of job and the displayed job.</p>

<p style="margin-top: 1em">kill [-s signame | -signum |
-signame] { job | pid | pgrp } ... <br>
Send the specified signal to the specified jobs, process
IDs, or process groups. If no signal is specified, the TERM
signal is sent. If a job is specified, the signal is <br>
sent to the job&rsquo;s process group. See Job control below
for the format of job.</p>

<p style="margin-top: 1em">kill -l [exit-status ...] <br>
Print the signal name corresponding to exit-status. If no
arguments are specified, a list of all the signals, their
numbers, and a short description of them are printed.</p>

<p style="margin-top: 1em">let [expression ...] <br>
Each expression is evaluated (see Arithmetic expressions
above). If all expressions are successfully evaluated, the
exit status is 0 (1) if the last expression evaluated to
<br>
non-zero (zero). If an error occurs during the parsing or
evaluation of an expression, the exit status is greater than
1. Since expressions may need to be quoted, (( expr <br>
)) is syntactic sugar for let &quot;expr&quot;.</p>

<p style="margin-top: 1em">let] Internally used alias for
let.</p>

<p style="margin-top: 1em">mknod [-m mode] name b|c major
minor <br>
mknod [-m mode] name p <br>
Create a device special file. The file type may be b (block
type device), c (character type device), or p (named pipe,
FIFO). The file created may be modified according to <br>
its mode (via the -m option), major (major device number),
and minor (minor device number).</p>

<p style="margin-top: 1em">See mknod(8) for further
information.</p>

<p style="margin-top: 1em">print [-nprsu[n] | -R [-en]]
[argument ...] <br>
print prints its arguments on the standard output, separated
by spaces and terminated with a newline. The -n option
suppresses the newline. By default, certain C escapes <br>
are translated. These include these mentioned in Backslash
expansion above, as well as &acirc; ited with the -r option.
The -s option prints to the history file instead of standard
output; the -u option prints to file descriptor n (n
defaults to 1 if omitted); and <br>
the -p option prints to the co-process (see Co-processes
above).</p>

<p style="margin-top: 1em">The -R option is used to
emulate, to some degree, the BSD echo(1) command which does
not process &acirc;&acirc; sequences unless the -e option is
given. As above, the -n option sup&acirc; <br>
presses the trailing newline.</p>

<p style="margin-top: 1em">printf format [arguments ...]
<br>
Formatted output. Approximately the same as the printf(1),
utility, except it uses the same Backslash expansion and I/O
code and does hot handle floating point as the rest <br>
of mksh. This is not normally part of mksh; however,
distributors may have added this as builtin as a speed hack.
Do not use in new code.</p>

<p style="margin-top: 1em">pwd [-LP] <br>
Print the present working directory. If the -L option is
used or if the physical option isn&rsquo;t set (see the set
command below), the logical path is printed (i.e. the path
<br>
used to cd to the current directory). If the -P option
(physical path) is used or if the physical option is set,
the path determined from the filesystem (by following
&acirc;..&acirc; <br>
directories to the root directory) is printed.</p>

<p style="margin-top: 1em">read [-A | -a] [-d x] [-N z | -n
z] [-p | -u[n]] [-t n] [-rs] [p ...] <br>
Reads a line of input, separates the input into fields using
the IFS parameter (see Substitution above), and assigns each
field to the specified parameters p. If no parame&acirc;
<br>
ters are specified, the REPLY parameter is used to store the
result. With the -A and -a options, only no or one parameter
is accepted. If there are more parameters than <br>
fields, the extra parameters are set to the empty string or
0; if there are more fields than parameters, the last
parameter is assigned the remaining fields (including the
<br>
word separators).</p>

<p style="margin-top: 1em">The options are as follows:</p>

<p style="margin-top: 1em">-A Store the result into the
parameter p (or REPLY) as array of words.</p>

<p style="margin-top: 1em">-a Store the result without word
splitting into the parameter p (or REPLY) as array of
characters (wide characters if the utf8-mode option is
enacted, octets otherwise).</p>

<p style="margin-top: 1em">-d x Use the first byte of x,
NUL if empty, instead of the ASCII newline character as
input line delimiter.</p>

<p style="margin-top: 1em">-N z Instead of reading till
end-of-line, read exactly z bytes; less if EOF or a timeout
occurs.</p>

<p style="margin-top: 1em">-n z Instead of reading till
end-of-line, read up to z bytes but return as soon as any
bytes are read, e.g. from a slow terminal device, or if EOF
or a timeout occurs.</p>

<p style="margin-top: 1em">-p Read from the currently
active co-process, see Co-processes above for details on
this.</p>

<p style="margin-top: 1em">-u[n] Read from the file
descriptor n (defaults to 0, i.e. standard input). The
argument must immediately follow the option character.</p>

<p style="margin-top: 1em">-t n Interrupt reading after n
seconds (specified as positive decimal value with an
optional fractional part).</p>

<p style="margin-top: 1em">-r Normally, the ASCII backslash
character escapes the special meaning of the following
character and is stripped from the input; read does not stop
when encountering a <br>
backslash-newline sequence and does not store that newline
in the result. This option enables raw mode, in which
backslashes are not processed.</p>

<p style="margin-top: 1em">-s The input line is saved to
the history.</p>

<p style="margin-top: 1em">If the input is a terminal, both
the -N and -n options set it into raw mode; they read an
entire file if -1 is passed as z argument.</p>

<p style="margin-top: 1em">The first parameter may have a
question mark and a string appended to it, in which case the
string is used as a prompt (printed to standard error before
any input is read) <br>
if the input is a tty(4) (e.g. read nfoo?&rsquo;number of
foos: &rsquo;).</p>

<p style="margin-top: 1em">If no input is read or a timeout
occurred, read exits with a non-zero status.</p>

<p style="margin-top: 1em">Another handy set of tricks: If
read is run in a loop such as while read foo; do ...; done
then leading whitespace will be removed (IFS) and
backslashes processed. You <br>
might want to use while IFS= read -r foo; do ...; done for
pristine I/O. Similarily, when using the -a option, use of
the -r option might be prudent; the same applies for:</p>

<p style="margin-top: 1em">find . -type f -print0 | while
IFS= read -d &rsquo;&rsquo; -r filename; do <br>
print -r -- &quot;found &lt;${filename#./}&gt;&quot; <br>
done</p>

<p style="margin-top: 1em">The inner loop will be executed
in a subshell and variable changes cannot be propagated if
executed in a pipeline:</p>

<p style="margin-top: 1em">bar | baz | while read foo; do
...; done</p>

<p style="margin-top: 1em">Use co-processes instead:</p>

<p style="margin-top: 1em">bar | baz |&amp; <br>
while read -p foo; do ...; done <br>
exec 3&gt;&amp;p; exec 3&gt;&amp;-</p>

<p style="margin-top: 1em">readonly [-p] [parameter
[=value] ...] <br>
Sets the read-only attribute of the named parameters. If
values are given, parameters are set to them before setting
the attribute. Once a parameter is made read-only, it <br>
cannot be unset and its value cannot be changed.</p>

<p style="margin-top: 1em">If no parameters are specified,
the names of all parameters with the read-only attribute are
printed one per line, unless the -p option is used, in which
case readonly com&acirc; <br>
mands defining all read-only parameters, including their
values, are printed.</p>

<p style="margin-top: 1em">realpath [--] name <br>
Prints the resolved absolute pathname corresponding to name.
If name ends with a slash (&acirc;/&acirc;), it&rsquo;s also
checked for existence and whether it is a directory;
otherwise, <br>
realpath returns 0 if the pathname either exists or can be
created immediately, i.e. all but the last component exist
and are directories.</p>

<p style="margin-top: 1em">rename [--] from to <br>
Renames the file from to to. Both must be complete pathnames
and on the same device. This builtin is intended for
emergency situations where /bin/mv becomes unusable, and
<br>
directly calls rename(2).</p>

<p style="margin-top: 1em">return [status] <br>
Returns from a function or . script, with exit status
status. If no status is given, the exit status of the last
executed command is used. If used outside of a function or
<br>
. script, it has the same effect as exit. Note that mksh
treats both profile and ENV files as . scripts, while the
original Korn shell only treats profiles as . scripts.</p>

<p style="margin-top: 1em">set [+-abCefhiklmnprsUuvXx] [+-o
option] [+-A name] [--] [arg ...] <br>
The set command can be used to set (-) or clear (+) shell
options, set the positional parameters, or set an array
parameter. Options can be changed using the +-o option <br>
syntax, where option is the long name of an option, or using
the +-letter syntax, where letter is the option&rsquo;s
single letter name (not all options have a single letter
<br>
name). The following table lists both option letters (if
they exist) and long names along with a description of what
the option does:</p>

<p style="margin-top: 1em">-A name <br>
Sets the elements of the array parameter name to arg ... If
-A is used, the array is reset (i.e. emptied) first; if +A
is used, the first N elements are set (where N is <br>
the number of arguments); the rest are left untouched.</p>

<p style="margin-top: 1em">An alternative syntax for the
command set -A foo -- a b c which is compatible to GNU bash
and also supported by AT&amp;T UNIX ksh93 is: foo=(a b c);
foo+=(d e)</p>

<p style="margin-top: 1em">Another AT&amp;T UNIX ksh93 and
GNU bash extension allows specifying the indices used for
arg ... (from the above example, a b c) like this: set -A
foo -- [0]=a [1]=b [2]=c <br>
or foo=([0]=a [1]=b [2]=c) which can also be written
foo=([0]=a b c) because indices are incremented
automatically.</p>

<p style="margin-top: 1em">-a | -o allexport <br>
All new parameters are created with the export
attribute.</p>

<p style="margin-top: 1em">-b | -o notify <br>
Print job notification messages asynchronously, instead of
just before the prompt. Only used if job control is enabled
(-m).</p>

<p style="margin-top: 1em">-C | -o noclobber <br>
Prevent &gt; redirection from overwriting existing files.
Instead, &gt;| must be used to force an overwrite.</p>

<p style="margin-top: 1em">-e | -o errexit <br>
Exit (after executing the ERR trap) as soon as an error
occurs or a command fails (i.e. exits with a non-zero
status). This does not apply to commands whose exit
sta&acirc; <br>
tus is explicitly tested by a shell construct such as if,
until, while, &amp;&amp;, ||, or ! statements.</p>

<p style="margin-top: 1em">-f | -o noglob <br>
Do not expand file name patterns.</p>

<p style="margin-top: 1em">-h | -o trackall <br>
Create tracked aliases for all executed commands (see
Aliases above). Enabled by default for non-interactive
shells.</p>

<p style="margin-top: 1em">-i | -o interactive <br>
The shell is an interactive shell. This option can only be
used when the shell is invoked. See above for a description
of what this means.</p>

<p style="margin-top: 1em">-k | -o keyword <br>
Parameter assignments are recognised anywhere in a
command.</p>

<p style="margin-top: 1em">-l | -o login <br>
The shell is a login shell. This option can only be used
when the shell is invoked. See above for a description of
what this means.</p>

<p style="margin-top: 1em">-m | -o monitor <br>
Enable job control (default for interactive shells).</p>

<p style="margin-top: 1em">-n | -o noexec <br>
Do not execute any commands. Useful for checking the syntax
of scripts (ignored if interactive).</p>

<p style="margin-top: 1em">-p | -o privileged <br>
The shell is a privileged shell. It is set automatically if,
when the shell starts, the real UID or GID does not match
the effective UID (EUID) or GID (EGID), respec&acirc; <br>
tively. See above for a description of what this means.</p>

<p style="margin-top: 1em">-r | -o restricted <br>
The shell is a restricted shell. This option can only be
used when the shell is invoked. See above for a description
of what this means.</p>

<p style="margin-top: 1em">-s | -o stdin <br>
If used when the shell is invoked, commands are read from
standard input. Set automatically if the shell is invoked
with no arguments.</p>

<p style="margin-top: 1em">When -s is used with the set
command it causes the specified arguments to be sorted
before assigning them to the positional parameters (or to
array name, if -A is <br>
used).</p>

<p style="margin-top: 1em">-U | -o utf8-mode <br>
Enable UTF-8 support in the Emacs editing mode and internal
string handling functions. This flag is disabled by default,
but can be enabled by setting it on the shell <br>
command line; is enabled automatically for interactive
shells if requested at compile time, your system supports
setlocale(LC_CTYPE, &quot;&quot;) and optionally <br>
nl_langinfo(CODESET), or the LC_ALL, LC_CTYPE, or LANG
environment variables, and at least one of these returns
something that matches &acirc;UTF-8&acirc; or
&acirc;utf8&acirc; case-insensi&acirc; <br>
tively; for direct builtin calls depending on the
aforementioned environment variables; or for stdin or
scripts, if the input begins with a UTF-8 Byte Order
Mark.</p>

<p style="margin-top: 1em">-u | -o nounset <br>
Referencing of an unset parameter, other than
&acirc;$@&acirc; or &acirc;$*&acirc;, is treated as an
error, unless one of the &acirc;-&acirc;, &acirc;+&acirc;,
or &acirc;=&acirc; modifiers is used.</p>

<p style="margin-top: 1em">-v | -o verbose <br>
Write shell input to standard error as it is read.</p>

<p style="margin-top: 1em">-X | -o markdirs <br>
Mark directories with a trailing &acirc;/&acirc; during file
name generation.</p>

<p style="margin-top: 1em">-x | -o xtrace <br>
Print command trees when they are executed, preceded by the
value of PS4.</p>

<p style="margin-top: 1em">-o bgnice <br>
Background jobs are run with lower priority.</p>

<p style="margin-top: 1em">-o braceexpand <br>
Enable brace expansion (a.k.a. alternation). This is enabled
by default. If disabled, tilde expansion after an equals
sign is disabled as a side effect.</p>

<p style="margin-top: 1em">-o emacs <br>
Enable BRL emacs-like command-line editing (interactive
shells only); see Emacs editing mode.</p>

<p style="margin-top: 1em">-o gmacs <br>
Enable gmacs-like command-line editing (interactive shells
only). Currently identical to emacs editing except that
transpose-chars (^T) acts slightly differently.</p>

<p style="margin-top: 1em">-o ignoreeof <br>
The shell will not (easily) exit when end-of-file is read;
exit must be used. To avoid infinite loops, the shell will
exit if EOF is read 13 times in a row.</p>

<p style="margin-top: 1em">-o nohup <br>
Do not kill running jobs with a SIGHUP signal when a login
shell exits. Currently set by default, but this may change
in the future to be compatible with AT&amp;T UNIX <br>
ksh, which doesn&rsquo;t have this option, but does send the
SIGHUP signal.</p>

<p style="margin-top: 1em">-o nolog <br>
No effect. In the original Korn shell, this prevents
function definitions from being stored in the history
file.</p>

<p style="margin-top: 1em">-o physical <br>
Causes the cd and pwd commands to use &acirc;physical&acirc;
(i.e. the filesystem&rsquo;s) &acirc;..&acirc; directories
instead of &acirc;logical&acirc; directories (i.e. the shell
handles &acirc;..&acirc;, which allows <br>
the user to be oblivious of symbolic links to directories).
Clear by default. Note that setting this option does not
affect the current value of the PWD parameter; <br>
only the cd command changes PWD. See the cd and pwd commands
above for more details.</p>

<p style="margin-top: 1em">-o pipefail <br>
Make the exit status of a pipeline (before logically
complementing) the rightmost non-zero errorlevel, or zero if
all commands exited with zero.</p>

<p style="margin-top: 1em">-o posix <br>
Enable a somewhat more POSIXish mode. As a side effect,
setting this flag turns off braceexpand mode, which can be
turned back on manually, and sh mode.</p>

<p style="margin-top: 1em">-o sh <br>
Enable /bin/sh (kludge) mode. Automatically enabled if the
basename of the shell invocation begins with
&acirc;sh&acirc; and this autodetection feature is compiled
in (not in <br>
MirBSD). As a side effect, setting this flag turns off
braceexpand mode, which can be turned back on manually, and
posix mode.</p>

<p style="margin-top: 1em">-o vi <br>
Enable vi(1)-like command-line editing (interactive shells
only).</p>

<p style="margin-top: 1em">-o vi-esccomplete <br>
In vi command-line editing, do command and file name
completion when escape (^[) is entered in command mode.</p>

<p style="margin-top: 1em">-o vi-tabcomplete <br>
In vi command-line editing, do command and file name
completion when tab (^I) is entered in insert mode. This is
the default.</p>

<p style="margin-top: 1em">-o viraw <br>
No effect. In the original Korn shell, unless viraw was set,
the vi command-line mode would let the tty(4) driver do the
work until ESC (^[) was entered. mksh is <br>
always in viraw mode.</p>

<p style="margin-top: 1em">These options can also be used
upon invocation of the shell. The current set of options
(with single letter names) can be found in the parameter
&acirc;$-&acirc;. set -o with no <br>
option name will list all the options and whether each is on
or off; set +o will print the long names of all options that
are currently on.</p>

<p style="margin-top: 1em">Remaining arguments, if any, are
positional parameters and are assigned, in order, to the
positional parameters (i.e. $1, $2, etc.). If options end
with &acirc;--&acirc; and there are <br>
no remaining arguments, all positional parameters are
cleared. If no options or arguments are given, the values of
all names are printed. For unknown historical reasons, a
<br>
lone &acirc;-&acirc; option is treated specially &acirc; it
clears both the -v and -x options.</p>

<p style="margin-top: 1em">shift [number] <br>
The positional parameters number+1, number+2, etc. are
renamed to &acirc;1&acirc;, &acirc;2&acirc;, etc. number
defaults to 1.</p>

<p style="margin-top: 1em">sleep seconds <br>
Suspends execution for a minimum of the seconds specified as
positive decimal value with an optional fractional part.
Signal delivery may continue execution earlier.</p>

<p style="margin-top: 1em">source file [arg ...] <br>
Like . (&acirc;dot&acirc;), except that the current working
directory is appended to the PATH in GNU bash and mksh. In
ksh93 and mksh, this is implemented as a shell alias instead
of a <br>
builtin.</p>

<p style="margin-top: 1em">test expression <br>
[ expression ] <br>
test evaluates the expression and returns zero status if
true, 1 if false, or greater than 1 if there was an error.
It is normally used as the condition command of if and <br>
while statements. Symbolic links are followed for all file
expressions except -h and -L.</p>

<p style="margin-top: 1em">The following basic expressions
are available:</p>

<p style="margin-top: 1em">-a file file exists.</p>

<p style="margin-top: 1em">-b file file is a block special
device.</p>

<p style="margin-top: 1em">-c file file is a character
special device.</p>

<p style="margin-top: 1em">-d file file is a directory.</p>

<p style="margin-top: 1em">-e file file exists.</p>

<p style="margin-top: 1em">-f file file is a regular
file.</p>

<p style="margin-top: 1em">-G file file&rsquo;s group is
the shell&rsquo;s effective group ID.</p>

<p style="margin-top: 1em">-g file file&rsquo;s mode has
the setgid bit set.</p>

<p style="margin-top: 1em">-H file file is a context
dependent directory (only useful on HP-UX).</p>

<p style="margin-top: 1em">-h file file is a symbolic
link.</p>

<p style="margin-top: 1em">-k file file&rsquo;s mode has
the sticky(8) bit set.</p>

<p style="margin-top: 1em">-L file file is a symbolic
link.</p>

<p style="margin-top: 1em">-O file file&rsquo;s owner is
the shell&rsquo;s effective user ID.</p>

<p style="margin-top: 1em">-o option Shell option is set
(see the set command above for a list of options). As a
non-standard extension, if the option starts with a
&acirc;!&acirc;, the test is negated; <br>
the test always fails if option doesn&rsquo;t exist (so [ -o
foo -o -o !foo ] returns true if and only if option foo
exists). The same can be achieved with [ <br>
-o ?foo ] like in AT&amp;T UNIX ksh93. option can also be
the short flag led by either &acirc;-&acirc; or
&acirc;+&acirc; (no logical negation), for example
&acirc;-x&acirc; or &acirc;+x&acirc; instead of <br>
&acirc;xtrace&acirc;.</p>

<p style="margin-top: 1em">-p file file is a named pipe
(FIFO).</p>

<p style="margin-top: 1em">-r file file exists and is
readable.</p>

<p style="margin-top: 1em">-S file file is a unix(4)-domain
socket.</p>

<p style="margin-top: 1em">-s file file is not empty.</p>

<p style="margin-top: 1em">-t fd File descriptor fd is a
tty(4) device.</p>

<p style="margin-top: 1em">-u file file&rsquo;s mode has
the setuid bit set.</p>

<p style="margin-top: 1em">-w file file exists and is
writable.</p>

<p style="margin-top: 1em">-x file file exists and is
executable.</p>

<p style="margin-top: 1em">file1 -nt file2 file1 is newer
than file2 or file1 exists and file2 does not.</p>

<p style="margin-top: 1em">file1 -ot file2 file1 is older
than file2 or file2 exists and file1 does not.</p>

<p style="margin-top: 1em">file1 -ef file2 file1 is the
same file as file2.</p>

<p style="margin-top: 1em">string string has non-zero
length.</p>

<p style="margin-top: 1em">-n string string is not
empty.</p>

<p style="margin-top: 1em">-z string string is empty.</p>

<p style="margin-top: 1em">string = string Strings are
equal.</p>

<p style="margin-top: 1em">string == string Strings are
equal.</p>

<p style="margin-top: 1em">string &gt; string First string
operand is greater than second string operand.</p>

<p style="margin-top: 1em">string &lt; string First string
operand is less than second string operand.</p>

<p style="margin-top: 1em">string != string Strings are not
equal.</p>

<p style="margin-top: 1em">number -eq number Numbers
compare equal.</p>

<p style="margin-top: 1em">number -ne number Numbers
compare not equal.</p>

<p style="margin-top: 1em">number -ge number Numbers
compare greater than or equal.</p>

<p style="margin-top: 1em">number -gt number Numbers
compare greater than.</p>

<p style="margin-top: 1em">number -le number Numbers
compare less than or equal.</p>

<p style="margin-top: 1em">number -lt number Numbers
compare less than.</p>

<p style="margin-top: 1em">The above basic expressions, in
which unary operators have precedence over binary operators,
may be combined with the following operators (listed in
increasing order of <br>
precedence):</p>

<p style="margin-top: 1em">expr -o expr Logical OR. <br>
expr -a expr Logical AND. <br>
! expr Logical NOT. <br>
( expr ) Grouping.</p>

<p style="margin-top: 1em">Note that a number actually may
be an arithmetic expression, such as a mathematical term or
the name of an integer variable:</p>

<p style="margin-top: 1em">x=1; [ &quot;x&quot; -eq 1 ]
evaluates to true</p>

<p style="margin-top: 1em">Note that some special rules are
applied (courtesy of POSIX) if the number of arguments to
test or inside the brackets [ ... ] is less than five: if
leading &acirc;!&acirc; arguments <br>
can be stripped such that only one to three arguments
remain, then the lowered comparison is executed; (thanks to
XSI) parentheses ... lower four- and three-argument <br>
forms to two- and one-argument forms, respectively;
three-argument forms ultimately prefer binary operations,
followed by negation and parenthesis lowering; two- and
four- <br>
argument forms prefer negation followed by parenthesis; the
one-argument form always implies -n.</p>

<p style="margin-top: 1em">Note: A common mistake is to use
&acirc;if [ $foo = bar ]&acirc; which fails if parameter
&acirc;foo&acirc; is NULL or unset, if it has embedded
spaces (i.e. IFS octets), or if it is a unary opera&acirc;
<br>
tor like &acirc;!&acirc; or &acirc;-n&acirc;. Use tests like
&acirc;if [ x&quot;$foo&quot; = x&quot;bar&quot; ]&acirc;
instead, or the double-bracket operator &acirc;if [[ $foo =
bar ]]&acirc; or, to avoid pattern matching (see [[ above):
<br>
&acirc;if [[ $foo = &quot;$bar&quot; ]]&acirc;</p>

<p style="margin-top: 1em">The [[ ... ]] construct is not
only more secure to use but also often faster.</p>

<p style="margin-top: 1em">time [-p] [pipeline] <br>
If a pipeline is given, the times used to execute the
pipeline are reported. If no pipeline is given, then the
user and system time used by the shell itself, and all the
<br>
commands it has run since it was started, are reported. The
times reported are the real time (elapsed time from start to
finish), the user CPU time (time spent running in <br>
user mode), and the system CPU time (time spent running in
kernel mode). Times are reported to standard error; the
format of the output is:</p>

<p style="margin-top: 1em">0m0.00s real 0m0.00s user
0m0.00s system</p>

<p style="margin-top: 1em">If the -p option is given the
output is slightly longer:</p>

<p style="margin-top: 1em">real 0.00 <br>
user 0.00 <br>
sys 0.00</p>

<p style="margin-top: 1em">It is an error to specify the -p
option unless pipeline is a simple command.</p>

<p style="margin-top: 1em">Simple redirections of standard
error do not affect the output of the time command:</p>

<p style="margin-top: 1em">$ time sleep 1 2&gt;afile <br>
$ { time sleep 1; } 2&gt;afile</p>

<p style="margin-top: 1em">Times for the first command do
not go to &acirc;afile&acirc;, but those of the second
command do.</p>

<p style="margin-top: 1em">times Print the accumulated user
and system times used both by the shell and by processes
that the shell started which have exited. The format of the
output is:</p>

<p style="margin-top: 1em">0m0.00s 0m0.00s <br>
0m0.00s 0m0.00s</p>

<p style="margin-top: 1em">trap [handler signal ...] <br>
Sets a trap handler that is to be executed when any of the
specified signals are received. handler is either a NULL
string, indicating the signals are to be ignored, a <br>
minus sign (&acirc;-&acirc;), indicating that the default
action is to be taken for the signals (see signal(3)), or a
string containing shell commands to be evaluated and
executed at <br>
the first opportunity (i.e. when the current command
completes, or before printing the next PS1 prompt) after
receipt of one of the signals. signal is the name of a
signal <br>
(e.g. PIPE or ALRM) or the number of the signal (see the
kill -l command above).</p>

<p style="margin-top: 1em">There are two special signals:
EXIT (also known as 0) which is executed when the shell is
about to exit, and ERR, which is executed after an error
occurs (an error is some&acirc; <br>
thing that would cause the shell to exit if the -e or
errexit option were set &acirc; see the set command above).
EXIT handlers are executed in the environment of the last
exe&acirc; <br>
cuted command. Note that for non-interactive shells, the
trap handler cannot be changed for signals that were ignored
when the shell started.</p>

<p style="margin-top: 1em">With no arguments, trap lists,
as a series of trap commands, the current state of the traps
that have been set since the shell started. Note that the
output of trap cannot <br>
be usefully piped to another process (an artifact of the
fact that traps are cleared when subprocesses are
created).</p>

<p style="margin-top: 1em">The original Korn shell&rsquo;s
DEBUG trap and the handling of ERR and EXIT traps in
functions are not yet implemented.</p>

<p style="margin-top: 1em">true A command that exits with a
zero value.</p>

<p style="margin-top: 1em">global [[+-alpnrtUux] [-L[n]]
[-R[n]] [-Z[n]] [-i[n]] | -f [-tux]] [name [=value] ...]
<br>
typeset [[+-alpnrtUux] [-LRZ[n]] [-i[n]] | -f [-tux]] [name
[=value] ...] <br>
Display or set parameter attributes. With no name arguments,
parameter attributes are displayed; if no options are used,
the current attributes of all parameters are <br>
printed as typeset commands; if an option is given (or
&acirc;-&acirc; with no option letter), all parameters and
their values with the specified attributes are printed; if
options are <br>
introduced with &acirc;+&acirc;, parameter values are not
printed.</p>

<p style="margin-top: 1em">If name arguments are given, the
attributes of the named parameters are set (-) or cleared
(+). Values for parameters may optionally be specified. For
name[*], the change <br>
affects the entire array, and no value may be specified.</p>

<p style="margin-top: 1em">If typeset is used inside a
function, any parameters specified are localised. This is
not done by the otherwise identical global. Note: This means
that mksh &rsquo;s global com&acirc; <br>
mand is not equivalent to other programming languages&rsquo;
as it does not allow a function called from another function
to access a parameter at truly global scope, but only <br>
prevents putting an accessed one into local scope.</p>

<p style="margin-top: 1em">When -f is used, typeset
operates on the attributes of functions. As with parameters,
if no name arguments are given, functions are listed with
their values (i.e. defini&acirc; <br>
tions) unless options are introduced with &acirc;+&acirc;,
in which case only the function names are reported.</p>

<p style="margin-top: 1em">-a Indexed array attribute.</p>

<p style="margin-top: 1em">-f Function mode. Display or set
functions and their attributes, instead of parameters.</p>

<p style="margin-top: 1em">-i[n] Integer attribute. n
specifies the base to use when displaying the integer (if
not specified, the base given in the first assignment is
used). Parameters with this <br>
attribute may be assigned values containing arithmetic
expressions.</p>

<p style="margin-top: 1em">-L[n] Left justify attribute. n
specifies the field width. If n is not specified, the
current width of a parameter (or the width of its first
assigned value) is used. <br>
Leading whitespace (and zeros, if used with the -Z option)
is stripped. If necessary, values are either truncated or
space padded to fit the field width.</p>

<p style="margin-top: 1em">-l Lower case attribute. All
upper case characters in values are converted to lower case.
(In the original Korn shell, this parameter meant
&acirc;long integer&acirc; when used <br>
with the -i option.)</p>

<p style="margin-top: 1em">-n Create a bound variable (name
reference): any access to the variable name will access the
variable value in the current scope (this is different from
AT&amp;T UNIX <br>
ksh93!) instead. Also different from AT&amp;T UNIX ksh93 is
that value is lazily evaluated at the time name is accessed.
This can be used by functions to access vari&acirc; <br>
ables whose names are passed as parametres, instead of using
eval.</p>

<p style="margin-top: 1em">-p Print complete typeset
commands that can be used to re-create the attributes and
values of parameters.</p>

<p style="margin-top: 1em">-R[n] Right justify attribute. n
specifies the field width. If n is not specified, the
current width of a parameter (or the width of its first
assigned value) is used. <br>
Trailing whitespace is stripped. If necessary, values are
either stripped of leading characters or space padded to
make them fit the field width.</p>

<p style="margin-top: 1em">-r Read-only attribute.
Parameters with this attribute may not be assigned to or
unset. Once this attribute is set, it cannot be turned
off.</p>

<p style="margin-top: 1em">-t Tag attribute. Has no meaning
to the shell; provided for application use.</p>

<p style="margin-top: 1em">For functions, -t is the trace
attribute. When functions with the trace attribute are
executed, the xtrace (-x) shell option is temporarily turned
on.</p>

<p style="margin-top: 1em">-U Unsigned integer attribute.
Integers are printed as unsigned values (combine with the -i
option). This option is not in the original Korn shell.</p>

<p style="margin-top: 1em">-u Upper case attribute. All
lower case characters in values are converted to upper case.
(In the original Korn shell, this parameter meant
&acirc;unsigned integer&acirc; when <br>
used with the -i option which meant upper case letters would
never be used for bases greater than 10. See the -U
option.)</p>

<p style="margin-top: 1em">For functions, -u is the
undefined attribute. See Functions above for the
implications of this.</p>

<p style="margin-top: 1em">-x Export attribute. Parameters
(or functions) are placed in the environment of any executed
commands. Exported functions are not yet implemented.</p>

<p style="margin-top: 1em">-Z[n] Zero fill attribute. If
not combined with -L, this is the same as -R, except zero
padding is used instead of space padding. For integers, the
number instead of the <br>
base is padded.</p>

<p style="margin-top: 1em">If any of the -i, -L, -l, -R,
-U, -u, or -Z options are changed, all others from this set
are cleared, unless they are also given on the same command
line.</p>

<p style="margin-top: 1em">ulimit
[-aBCcdefHiLlMmnOPpqrSsTtVvw] [value] <br>
Display or set process limits. If no options are used, the
file size limit (-f) is assumed. value, if specified, may be
either an arithmetic expression or the word <br>
&acirc;unlimited&acirc;. The limits affect the shell and any
processes created by the shell after a limit is imposed.
Note that some systems may not allow limits to be increased
once <br>
they are set. Also note that the types of limits available
are system dependent &acirc; some systems have only the -f
limit.</p>

<p style="margin-top: 1em">-a Display all limits; unless -H
is used, soft limits are displayed.</p>

<p style="margin-top: 1em">-B n Set the socket buffer size
to n kibibytes.</p>

<p style="margin-top: 1em">-C n Set the number of cached
threads to n.</p>

<p style="margin-top: 1em">-c n Impose a size limit of n
blocks on the size of core dumps.</p>

<p style="margin-top: 1em">-d n Impose a size limit of n
kibibytes on the size of the data area.</p>

<p style="margin-top: 1em">-e n Set the maximum niceness to
n.</p>

<p style="margin-top: 1em">-f n Impose a size limit of n
blocks on files written by the shell and its child processes
(files of any size may be read).</p>

<p style="margin-top: 1em">-H Set the hard limit only (the
default is to set both hard and soft limits).</p>

<p style="margin-top: 1em">-i n Set the number of pending
signals to n.</p>

<p style="margin-top: 1em">-L n Control flocks;
documentation is missing.</p>

<p style="margin-top: 1em">-l n Impose a limit of n
kibibytes on the amount of locked (wired) physical
memory.</p>

<p style="margin-top: 1em">-M n Set the AIO locked memory
to n kibibytes.</p>

<p style="margin-top: 1em">-m n Impose a limit of n
kibibytes on the amount of physical memory used.</p>

<p style="margin-top: 1em">-n n Impose a limit of n file
descriptors that can be open at once.</p>

<p style="margin-top: 1em">-O n Set the number of AIO
operations to n.</p>

<p style="margin-top: 1em">-P n Limit the number of threads
per process to n.</p>

<p style="margin-top: 1em">-p n Impose a limit of n
processes that can be run by the user at any one time.</p>

<p style="margin-top: 1em">-q n Limit the size of POSIX
message queues to n bytes.</p>

<p style="margin-top: 1em">-r n Set the maximum real-time
priority to n.</p>

<p style="margin-top: 1em">-S Set the soft limit only (the
default is to set both hard and soft limits).</p>

<p style="margin-top: 1em">-s n Impose a size limit of n
kibibytes on the size of the stack area.</p>

<p style="margin-top: 1em">-T n Impose a time limit of n
real seconds to be used by each process.</p>

<p style="margin-top: 1em">-t n Impose a time limit of n
CPU seconds spent in user mode to be used by each
process.</p>

<p style="margin-top: 1em">-V n Set the number of vnode
monitors on Haiku to n.</p>

<p style="margin-top: 1em">-v n Impose a limit of n
kibibytes on the amount of virtual memory (address space)
used.</p>

<p style="margin-top: 1em">-w n Impose a limit of n
kibibytes on the amount of swap space used.</p>

<p style="margin-top: 1em">As far as ulimit is concerned, a
block is 512 bytes.</p>

<p style="margin-top: 1em">umask [-S] [mask] <br>
Display or set the file permission creation mask, or umask
(see umask(2)). If the -S option is used, the mask displayed
or set is symbolic; otherwise, it is an octal num&acirc;
<br>
ber.</p>

<p style="margin-top: 1em">Symbolic masks are like those
used by chmod(1). When used, they describe what permissions
may be made available (as opposed to octal masks in which a
set bit means the cor&acirc; <br>
responding bit is to be cleared). For example,
&acirc;ug=rwx,o=&acirc; sets the mask so files will not be
readable, writable, or executable by &acirc;others&acirc;,
and is equivalent (on most sys&acirc; <br>
tems) to the octal mask &acirc;007&acirc;.</p>

<p style="margin-top: 1em">unalias [-adt] [name ...] <br>
The aliases for the given names are removed. If the -a
option is used, all aliases are removed. If the -t or -d
options are used, the indicated operations are carried out
<br>
on tracked or directory aliases, respectively.</p>

<p style="margin-top: 1em">unset [-fv] parameter ... <br>
Unset the named parameters (-v, the default) or functions
(-f). With parameter[*], attributes are kept, only values
are unset.</p>

<p style="margin-top: 1em">The exit status is non-zero if
any of the parameters have the read-only attribute set, zero
otherwise.</p>

<p style="margin-top: 1em">wait [job ...] <br>
Wait for the specified job(s) to finish. The exit status of
wait is that of the last specified job; if the last job is
killed by a signal, the exit status is 128 + the num&acirc;
<br>
ber of the signal (see kill -l exit-status above); if the
last specified job can&rsquo;t be found (because it never
existed, or had already finished), the exit status of wait
is <br>
127. See Job control below for the format of job. wait will
return if a signal for which a trap has been set is
received, or if a SIGHUP, SIGINT, or SIGQUIT signal is <br>
received.</p>

<p style="margin-top: 1em">If no jobs are specified, wait
waits for all currently running jobs (if any) to finish and
exits with a zero status. If job monitoring is enabled, the
completion status of <br>
jobs is printed (this is not the case when jobs are
explicitly specified).</p>

<p style="margin-top: 1em">whence [-pv] [name ...] <br>
For each name, the type of command is listed (reserved word,
built-in, alias, function, tracked alias, or executable). If
the -p option is used, a path search is performed <br>
even if name is a reserved word, alias, etc. Without the -v
option, whence is similar to command -v except that whence
will find reserved words and won&rsquo;t print aliases as
<br>
alias commands. With the -v option, whence is the same as
command -V. Note that for whence, the -p option does not
affect the search path used, as it does for command. If <br>
the type of one or more of the names could not be
determined, the exit status is non-zero.</p>

<p style="margin-top: 1em">Job control <br>
Job control refers to the shell&rsquo;s ability to monitor
and control jobs which are processes or groups of processes
created for commands or pipelines. At a minimum, the shell
keeps <br>
track of the status of the background (i.e. asynchronous)
jobs that currently exist; this information can be displayed
using the jobs commands. If job control is fully enabled
<br>
(using set -m or set -o monitor), as it is for interactive
shells, the processes of a job are placed in their own
process group. Foreground jobs can be stopped by typing the
sus&acirc; <br>
pend character from the terminal (normally ^Z), jobs can be
restarted in either the foreground or background using the
fg and bg commands, and the state of the terminal is saved
or <br>
restored when a foreground job is stopped or restarted,
respectively.</p>

<p style="margin-top: 1em">Note that only commands that
create processes (e.g. asynchronous commands, subshell
commands, and non-built-in, non-function commands) can be
stopped; commands like read cannot be.</p>

<p style="margin-top: 1em">When a job is created, it is
assigned a job number. For interactive shells, this number
is printed inside &acirc;[..]&acirc;, followed by the
process IDs of the processes in the job when an <br>
asynchronous command is run. A job may be referred to in the
bg, fg, jobs, kill, and wait commands either by the process
ID of the last process in the command pipeline (as stored
<br>
in the $! parameter) or by prefixing the job number with a
percent sign (&acirc;%&acirc;). Other percent sequences can
also be used to refer to jobs:</p>

<p style="margin-top: 1em">%+ | %% | % The most recently
stopped job, or, if there are no stopped jobs, the oldest
running job.</p>

<p style="margin-top: 1em">%- The job that would be the %+
job if the latter did not exist.</p>

<p style="margin-top: 1em">%n The job with job number
n.</p>

<p style="margin-top: 1em">%?string The job with its
command containing the string string (an error occurs if
multiple jobs are matched).</p>

<p style="margin-top: 1em">%string The job with its command
starting with the string string (an error occurs if multiple
jobs are matched).</p>

<p style="margin-top: 1em">When a job changes state (e.g. a
background job finishes or foreground job is stopped), the
shell prints the following status information:</p>

<p style="margin-top: 1em">[number] flag status command</p>

<p style="margin-top: 1em">where...</p>

<p style="margin-top: 1em">number is the job number of the
job;</p>

<p style="margin-top: 1em">flag is the &acirc;+&acirc; or
&acirc;-&acirc; character if the job is the %+ or %- job,
respectively, or space if it is neither;</p>

<p style="margin-top: 1em">status indicates the current
state of the job and can be:</p>

<p style="margin-top: 1em">Done [number] <br>
The job exited. number is the exit status of the job which
is omitted if the status is zero.</p>

<p style="margin-top: 1em">Running The job has neither
stopped nor exited (note that running does not necessarily
mean consuming CPU time &acirc; the process could be blocked
waiting for some event).</p>

<p style="margin-top: 1em">Stopped [signal] <br>
The job was stopped by the indicated signal (if no signal is
given, the job was stopped by SIGTSTP).</p>

<p style="margin-top: 1em">signal-description [&acirc;core
dumped&acirc;] <br>
The job was killed by a signal (e.g. memory fault, hangup);
use kill -l for a list of signal descriptions. The
&acirc;core dumped&acirc; message indicates the process
cre&acirc; <br>
ated a core file.</p>

<p style="margin-top: 1em">command is the command that
created the process. If there are multiple processes in the
job, each process will have a line showing its command and
possibly its status, if it is <br>
different from the status of the previous process.</p>

<p style="margin-top: 1em">When an attempt is made to exit
the shell while there are jobs in the stopped state, the
shell warns the user that there are stopped jobs and does
not exit. If another attempt is <br>
immediately made to exit the shell, the stopped jobs are
sent a SIGHUP signal and the shell exits. Similarly, if the
nohup option is not set and there are running jobs when an
<br>
attempt is made to exit a login shell, the shell warns the
user and does not exit. If another attempt is immediately
made to exit the shell, the running jobs are sent a SIGHUP
<br>
signal and the shell exits.</p>

<p style="margin-top: 1em">Interactive input line editing
<br>
The shell supports three modes of reading command lines from
a tty(4) in an interactive session, controlled by the emacs,
gmacs, and vi options (at most one of these can be set at
<br>
once). The default is emacs. Editing modes can be set
explicitly using the set built-in. If none of these options
are enabled, the shell simply reads lines using the normal
<br>
tty(4) driver. If the emacs or gmacs option is set, the
shell allows emacs-like editing of the command; similarly,
if the vi option is set, the shell allows vi-like editing of
the <br>
command. These modes are described in detail in the
following sections.</p>

<p style="margin-top: 1em">In these editing modes, if a
line is longer than the screen width (see the COLUMNS
parameter), a &acirc;&gt;&acirc;, &acirc;+&acirc;, or
&acirc;&lt;&acirc; character is displayed in the last column
indicating that there <br>
are more characters after, before and after, or before the
current position, respectively. The line is scrolled
horizontally as necessary.</p>

<p style="margin-top: 1em">Completed lines are pushed into
the history, unless they begin with an IFS octet or IFS
white space, or are the same as the previous line.</p>

<p style="margin-top: 1em">Emacs editing mode <br>
When the emacs option is set, interactive input line editing
is enabled. Warning: This mode is slightly different from
the emacs mode in the original Korn shell. In this mode,
<br>
various editing commands (typically bound to one or more
control characters) cause immediate actions without waiting
for a newline. Several editing commands are bound to
particu&acirc; <br>
lar control characters when the shell is invoked; these
bindings can be changed using the bind command.</p>

<p style="margin-top: 1em">The following is a list of
available editing commands. Each description starts with the
name of the command, suffixed with a colon; an [n] (if the
command can be prefixed with a <br>
count); and any keys the command is bound to by default,
written using caret notation e.g. the ASCII ESC character is
written as ^[. These control sequences are not case
sensi&acirc; <br>
tive. A count prefix for a command is entered using the
sequence ^[n, where n is a sequence of 1 or more digits.
Unless otherwise specified, if a count is omitted, it
defaults to <br>
1.</p>

<p style="margin-top: 1em">Note that editing command names
are used only with the bind command. Furthermore, many
editing commands are useful only on terminals with a visible
cursor. The default bindings <br>
were chosen to resemble corresponding Emacs key bindings.
The user&rsquo;s tty(4) characters (e.g. ERASE) are bound to
reasonable substitutes and override the default
bindings.</p>

<p style="margin-top: 1em">abort: ^C, ^G <br>
Abort the current command, empty the line buffer and set the
exit state to interrupted.</p>

<p style="margin-top: 1em">auto-insert: [n] <br>
Simply causes the character to appear as literal input. Most
ordinary characters are bound to this.</p>

<p style="margin-top: 1em">backward-char: [n] ^B, ^XD,
ANSI-CurLeft <br>
Moves the cursor backward n characters.</p>

<p style="margin-top: 1em">backward-word: [n] ^[b,
ANSI-Ctrl-CurLeft, ANSI-Alt-CurLeft <br>
Moves the cursor backward to the beginning of the word;
words consist of alphanumerics, underscore
(&acirc;_&acirc;), and dollar sign (&acirc;$&acirc;)
characters.</p>

<p style="margin-top: 1em">beginning-of-history: ^[&lt;
<br>
Moves to the beginning of the history.</p>

<p style="margin-top: 1em">beginning-of-line: ^A, ANSI-Home
<br>
Moves the cursor to the beginning of the edited input
line.</p>

<p style="margin-top: 1em">capitalise-word: [n] ^[C, ^[c
<br>
Uppercase the first character in the next n words, leaving
the cursor past the end of the last word.</p>

<p style="margin-top: 1em">clear-screen: ^[^L <br>
Prints a compile-time configurable sequence to clear the
screen and home the cursor, redraws the entire prompt and
the currently edited input line. The default sequence <br>
works for almost all standard terminals.</p>

<p style="margin-top: 1em">comment: ^[# <br>
If the current line does not begin with a comment character,
one is added at the beginning of the line and the line is
entered (as if return had been pressed); otherwise, <br>
the existing comment characters are removed and the cursor
is placed at the beginning of the line.</p>

<p style="margin-top: 1em">complete: ^[^[ <br>
Automatically completes as much as is unique of the command
name or the file name containing the cursor. If the entire
remaining command or file name is unique, a space is <br>
printed after its completion, unless it is a directory name
in which case &acirc;/&acirc; is appended. If there is no
command or file name with the current partial word as its
prefix, <br>
a bell character is output (usually causing a beep to be
sounded).</p>

<p style="margin-top: 1em">complete-command: ^X^[ <br>
Automatically completes as much as is unique of the command
name having the partial word up to the cursor as its prefix,
as in the complete command above.</p>

<p style="margin-top: 1em">complete-file: ^[^X <br>
Automatically completes as much as is unique of the file
name having the partial word up to the cursor as its prefix,
as in the complete command described above.</p>

<p style="margin-top: 1em">complete-list: ^I, ^[= <br>
Complete as much as is possible of the current word, and
list the possible completions for it. If only one completion
is possible, match as in the complete command above. <br>
Note that ^I is usually generated by the TAB (tabulator)
key.</p>

<p style="margin-top: 1em">delete-char-backward: [n] ERASE,
^?, ^H <br>
Deletes n characters before the cursor.</p>

<p style="margin-top: 1em">delete-char-forward: [n]
ANSI-Del <br>
Deletes n characters after the cursor.</p>

<p style="margin-top: 1em">delete-word-backward: [n]
WERASE, ^[^?, ^[^H, ^[h <br>
Deletes n words before the cursor.</p>

<p style="margin-top: 1em">delete-word-forward: [n] ^[d
<br>
Deletes characters after the cursor up to the end of n
words.</p>

<p style="margin-top: 1em">down-history: [n] ^N, ^XB,
ANSI-CurDown <br>
Scrolls the history buffer forward n lines (later). Each
input line originally starts just after the last entry in
the history buffer, so down-history is not useful until <br>
either search-history, search-history-up or up-history has
been performed.</p>

<p style="margin-top: 1em">downcase-word: [n] ^[L, ^[l <br>
Lowercases the next n words.</p>

<p style="margin-top: 1em">edit-line: [n] ^Xe <br>
Edit line n or the current line, if not specified,
interactively. The actual command executed is fc -e
${VISUAL:-${EDITOR:-vi}} n.</p>

<p style="margin-top: 1em">end-of-history: ^[&gt; <br>
Moves to the end of the history.</p>

<p style="margin-top: 1em">end-of-line: ^E, ANSI-End <br>
Moves the cursor to the end of the input line.</p>

<p style="margin-top: 1em">eot: ^_ <br>
Acts as an end-of-file; this is useful because edit-mode
input disables normal terminal input canonicalization.</p>

<p style="margin-top: 1em">eot-or-delete: [n] ^D <br>
Acts as eot if alone on a line; otherwise acts as
delete-char-forward.</p>

<p style="margin-top: 1em">error: (not bound) <br>
Error (ring the bell).</p>

<p style="margin-top: 1em">exchange-point-and-mark: ^X^X
<br>
Places the cursor where the mark is and sets the mark to
where the cursor was.</p>

<p style="margin-top: 1em">expand-file: ^[* <br>
Appends a &acirc;*&acirc; to the current word and replaces
the word with the result of performing file globbing on the
word. If no files match the pattern, the bell is rung.</p>

<p style="margin-top: 1em">forward-char: [n] ^F, ^XC,
ANSI-CurRight <br>
Moves the cursor forward n characters.</p>

<p style="margin-top: 1em">forward-word: [n] ^[f,
ANSI-Ctrl-CurRight, ANSI-Alt-CurRight <br>
Moves the cursor forward to the end of the nth word.</p>

<p style="margin-top: 1em">goto-history: [n] ^[g <br>
Goes to history number n.</p>

<p style="margin-top: 1em">kill-line: KILL <br>
Deletes the entire input line.</p>

<p style="margin-top: 1em">kill-region: ^W <br>
Deletes the input between the cursor and the mark.</p>

<p style="margin-top: 1em">kill-to-eol: [n] ^K <br>
Deletes the input from the cursor to the end of the line if
n is not specified; otherwise deletes characters between the
cursor and column n.</p>

<p style="margin-top: 1em">list: ^[? <br>
Prints a sorted, columnated list of command names or file
names (if any) that can complete the partial word containing
the cursor. Directory names have &acirc;/&acirc; appended to
<br>
them.</p>

<p style="margin-top: 1em">list-command: ^X? <br>
Prints a sorted, columnated list of command names (if any)
that can complete the partial word containing the
cursor.</p>

<p style="margin-top: 1em">list-file: ^X^Y <br>
Prints a sorted, columnated list of file names (if any) that
can complete the partial word containing the cursor. File
type indicators are appended as described under list <br>
above.</p>

<p style="margin-top: 1em">newline: ^J, ^M <br>
Causes the current input line to be processed by the shell.
The current cursor position may be anywhere on the line.</p>

<p style="margin-top: 1em">newline-and-next: ^O <br>
Causes the current input line to be processed by the shell,
and the next line from history becomes the current line.
This is only useful after an up-history, <br>
search-history or search-history-up.</p>

<p style="margin-top: 1em">no-op: QUIT <br>
This does nothing.</p>

<p style="margin-top: 1em">prefix-1: ^[ <br>
Introduces a 2-character command sequence.</p>

<p style="margin-top: 1em">prefix-2: ^X, ^[[, ^[O <br>
Introduces a 2-character command sequence.</p>

<p style="margin-top: 1em">prev-hist-word: [n] ^[., ^[_
<br>
The last word, or, if given, the nth word (zero-based) of
the previous (on repeated execution, second-last,
third-last, etc.) command is inserted at the cursor. Use of
<br>
this editing command trashes the mark.</p>

<p style="margin-top: 1em">quote: ^^, ^V <br>
The following character is taken literally rather than as an
editing command.</p>

<p style="margin-top: 1em">redraw: ^L <br>
Reprints the last line of the prompt string and the current
input line on a new line.</p>

<p style="margin-top: 1em">search-character-backward: [n]
^[^] <br>
Search backward in the current line for the nth occurrence
of the next character typed.</p>

<p style="margin-top: 1em">search-character-forward: [n] ^]
<br>
Search forward in the current line for the nth occurrence of
the next character typed.</p>

<p style="margin-top: 1em">search-history: ^R <br>
Enter incremental search mode. The internal history list is
searched backwards for commands matching the input. An
initial &acirc;^&acirc; in the search string anchors the
search. <br>
The escape key will leave search mode. Other commands,
including sequences of escape as prefix-1 followed by a
prefix-1 or prefix-2 key will be executed after leaving <br>
search mode. The abort (^G) command will restore the input
line before search started. Successive search-history
commands continue searching backward to the next previous
<br>
occurrence of the pattern. The history buffer retains only a
finite number of lines; the oldest are discarded as
necessary.</p>

<p style="margin-top: 1em">search-history-up: ANSI-PgUp
<br>
Search backwards through the history buffer for commands
whose beginning match the portion of the input line before
the cursor. When used on an empty line, this has the <br>
same effect as up-history.</p>

<p style="margin-top: 1em">search-history-down: ANSI-PgDn
<br>
Search forwards through the history buffer for commands
whose beginning match the portion of the input line before
the cursor. When used on an empty line, this has the <br>
same effect as down-history. This is only useful after an
up-history, search-history or search-history-up.</p>

<p style="margin-top: 1em">set-mark-command:
^[&lt;space&gt; <br>
Set the mark at the cursor position.</p>

<p style="margin-top: 1em">transpose-chars: ^T <br>
If at the end of line, or if the gmacs option is set, this
exchanges the two previous characters; otherwise, it
exchanges the previous and current characters and moves the
<br>
cursor one character to the right.</p>

<p style="margin-top: 1em">up-history: [n] ^P, ^XA,
ANSI-CurUp <br>
Scrolls the history buffer backward n lines (earlier).</p>

<p style="margin-top: 1em">upcase-word: [n] ^[U, ^[u <br>
Uppercase the next n words.</p>

<p style="margin-top: 1em">version: ^[^V <br>
Display the version of mksh. The current edit buffer is
restored as soon as a key is pressed. The restoring keypress
is processed, unless it is a space.</p>

<p style="margin-top: 1em">yank: ^Y <br>
Inserts the most recently killed text string at the current
cursor position.</p>

<p style="margin-top: 1em">yank-pop: ^[y <br>
Immediately after a yank, replaces the inserted text string
with the next previously killed text string.</p>

<p style="margin-top: 1em">Vi editing mode <br>
Note: The vi command-line editing mode is orphaned, yet
still functional.</p>

<p style="margin-top: 1em">The vi command-line editor in
mksh has basically the same commands as the vi(1) editor
with the following exceptions:</p>

<p style="margin-top: 1em">&Acirc;&middot; You start out in
insert mode.</p>

<p style="margin-top: 1em">&Acirc;&middot; There are file
name and command completion commands: =, *, ^X, ^E, ^F, and,
optionally, &lt;tab&gt; and &lt;esc&gt;.</p>

<p style="margin-top: 1em">&Acirc;&middot; The _ command is
different (in mksh, it is the last argument command; in
vi(1) it goes to the start of the current line).</p>

<p style="margin-top: 1em">&Acirc;&middot; The / and G
commands move in the opposite direction to the j
command.</p>

<p style="margin-top: 1em">&Acirc;&middot; Commands which
don&rsquo;t make sense in a single line editor are not
available (e.g. screen movement commands and ex(1)-style
colon (:) commands).</p>

<p style="margin-top: 1em">Like vi(1), there are two modes:
&acirc;insert&acirc; mode and &acirc;command&acirc; mode. In
insert mode, most characters are simply put in the buffer at
the current cursor position as they are typed; <br>
however, some characters are treated specially. In
particular, the following characters are taken from current
tty(4) settings (see stty(1)) and have their usual meaning
(normal <br>
values are in parentheses): kill (^U), erase (^?), werase
(^W), eof (^D), intr (^C), and quit (^. In addition to the
above, the following characters are also treated specially
<br>
in insert mode:</p>

<p style="margin-top: 1em">^E Command and file name
enumeration (see below).</p>

<p style="margin-top: 1em">^F Command and file name
completion (see below). If used twice in a row, the list of
possible completions is displayed; if used a third time, the
completion is undone.</p>

<p style="margin-top: 1em">^H Erases previous
character.</p>

<p style="margin-top: 1em">^J | ^M End of line. The current
line is read, parsed, and executed by the shell.</p>

<p style="margin-top: 1em">^V Literal next. The next
character typed is not treated specially (can be used to
insert the characters being described here).</p>

<p style="margin-top: 1em">^X Command and file name
expansion (see below).</p>

<p style="margin-top: 1em">&lt;esc&gt; Puts the editor in
command mode (see below).</p>

<p style="margin-top: 1em">&lt;tab&gt; Optional file name
and command completion (see ^F above), enabled with set -o
vi-tabcomplete.</p>

<p style="margin-top: 1em">In command mode, each character
is interpreted as a command. Characters that don&rsquo;t
correspond to commands, are illegal combinations of
commands, or are commands that can&rsquo;t be car&acirc;
<br>
ried out, all cause beeps. In the following command
descriptions, an [n] indicates the command may be prefixed
by a number (e.g. 10l moves right 10 characters); if no
number pre&acirc; <br>
fix is used, n is assumed to be 1 unless otherwise
specified. The term &acirc;current position&acirc; refers to
the position between the cursor and the character preceding
the cursor. A <br>
&acirc;word&acirc; is a sequence of letters, digits, and
underscore characters or a sequence of non-letter,
non-digit, non-underscore, and non-whitespace characters
(e.g. &acirc;ab2*&amp;^&acirc; contains two <br>
words) and a &acirc;big-word&acirc; is a sequence of
non-whitespace characters.</p>

<p style="margin-top: 1em">Special mksh vi commands:</p>

<p style="margin-top: 1em">The following commands are not
in, or are different from, the normal vi file editor:</p>

<p style="margin-top: 1em">[n]_ Insert a space followed by
the nth big-word from the last command in the history at the
current position and enter insert mode; if n is not
specified, the last word is <br>
inserted.</p>

<p style="margin-top: 1em"># Insert the comment character
(&acirc;#&acirc;) at the start of the current line and
return the line to the shell (equivalent to I#^J).</p>

<p style="margin-top: 1em">[n]g Like G, except if n is not
specified, it goes to the most recent remembered line.</p>

<p style="margin-top: 1em">[n]v Edit line n using the vi(1)
editor; if n is not specified, the current line is edited.
The actual command executed is fc -e
${VISUAL:-${EDITOR:-vi}} n.</p>

<p style="margin-top: 1em">* and ^X Command or file name
expansion is applied to the current big-word (with an
appended &acirc;*&acirc; if the word contains no file
globbing characters) &acirc; the big-word is replaced <br>
with the resulting words. If the current big-word is the
first on the line or follows one of the characters
&acirc;;&acirc;, &acirc;|&acirc;, &acirc;&amp;&acirc;,
&acirc;(&acirc;, or &acirc;)&acirc;, and does not contain a
slash <br>
(&acirc;/&acirc;), then command expansion is done; otherwise
file name expansion is done. Command expansion will match
the big-word against all aliases, functions, and built-in
<br>
commands as well as any executable files found by searching
the directories in the PATH parameter. File name expansion
matches the big-word against the files in the <br>
current directory. After expansion, the cursor is placed
just past the last word and the editor is in insert
mode.</p>

<p style="margin-top: 1em">[n] [n]^F, [n]&lt;tab&gt;, and
[n]&lt;esc&gt; <br>
Command/file name completion. Replace the current big-word
with the longest unique match obtained after performing
command and file name expansion. &lt;tab&gt; is only <br>
recognised if the vi-tabcomplete option is set, while
&lt;esc&gt; is only recognised if the vi-esccomplete option
is set (see set -o). If n is specified, the nth possible
<br>
completion is selected (as reported by the command/file name
enumeration command).</p>

<p style="margin-top: 1em">= and ^E Command/file name
enumeration. List all the commands or files that match the
current big-word.</p>

<p style="margin-top: 1em">^V Display the version of mksh.
The current edit buffer is restored as soon as a key is
pressed. The restoring keypress is ignored.</p>

<p style="margin-top: 1em">@c Macro expansion. Execute the
commands found in the alias c.</p>

<p style="margin-top: 1em">Intra-line movement
commands:</p>

<p style="margin-top: 1em">[n]h and [n]^H <br>
Move left n characters.</p>

<p style="margin-top: 1em">[n]l and [n]&lt;space&gt; <br>
Move right n characters.</p>

<p style="margin-top: 1em">0 Move to column 0.</p>

<p style="margin-top: 1em">^ Move to the first
non-whitespace character.</p>

<p style="margin-top: 1em">[n]| Move to column n.</p>

<p style="margin-top: 1em">$ Move to the last
character.</p>

<p style="margin-top: 1em">[n]b Move back n words.</p>

<p style="margin-top: 1em">[n]B Move back n big-words.</p>

<p style="margin-top: 1em">[n]e Move forward to the end of
the word, n times.</p>

<p style="margin-top: 1em">[n]E Move forward to the end of
the big-word, n times.</p>

<p style="margin-top: 1em">[n]w Move forward n words.</p>

<p style="margin-top: 1em">[n]W Move forward n
big-words.</p>

<p style="margin-top: 1em">% Find match. The editor looks
forward for the nearest parenthesis, bracket, or brace and
then moves the cursor to the matching parenthesis, bracket,
or brace.</p>

<p style="margin-top: 1em">[n]fc Move forward to the nth
occurrence of the character c.</p>

<p style="margin-top: 1em">[n]Fc Move backward to the nth
occurrence of the character c.</p>

<p style="margin-top: 1em">[n]tc Move forward to just
before the nth occurrence of the character c.</p>

<p style="margin-top: 1em">[n]Tc Move backward to just
before the nth occurrence of the character c.</p>

<p style="margin-top: 1em">[n]; Repeats the last f, F, t,
or T command.</p>

<p style="margin-top: 1em">[n], Repeats the last f, F, t,
or T command, but moves in the opposite direction.</p>

<p style="margin-top: 1em">Inter-line movement
commands:</p>

<p style="margin-top: 1em">[n]j, [n]+, and [n]^N <br>
Move to the nth next line in the history.</p>

<p style="margin-top: 1em">[n]k, [n]-, and [n]^P <br>
Move to the nth previous line in the history.</p>

<p style="margin-top: 1em">[n]G Move to line n in the
history; if n is not specified, the number of the first
remembered line is used.</p>

<p style="margin-top: 1em">[n]g Like G, except if n is not
specified, it goes to the most recent remembered line.</p>

<p style="margin-top: 1em">[n]/string <br>
Search backward through the history for the nth line
containing string; if string starts with &acirc;^&acirc;,
the remainder of the string must appear at the start of the
history line <br>
for it to match.</p>

<p style="margin-top: 1em">[n]?string <br>
Same as /, except it searches forward through the
history.</p>

<p style="margin-top: 1em">[n]n Search for the nth
occurrence of the last search string; the direction of the
search is the same as the last search.</p>

<p style="margin-top: 1em">[n]N Search for the nth
occurrence of the last search string; the direction of the
search is the opposite of the last search.</p>

<p style="margin-top: 1em">ANSI-CurUp <br>
Take the characters from the beginning of the line to the
current cursor position as search string and do a backwards
history search for lines beginning with this string; <br>
keep the cursor position. This works only in insert mode and
keeps it enabled.</p>

<p style="margin-top: 1em">Edit commands</p>

<p style="margin-top: 1em">[n]a Append text n times; goes
into insert mode just after the current position. The append
is only replicated if command mode is re-entered i.e.
&lt;esc&gt; is used.</p>

<p style="margin-top: 1em">[n]A Same as a, except it
appends at the end of the line.</p>

<p style="margin-top: 1em">[n]i Insert text n times; goes
into insert mode at the current position. The insertion is
only replicated if command mode is re-entered i.e.
&lt;esc&gt; is used.</p>

<p style="margin-top: 1em">[n]I Same as i, except the
insertion is done just before the first non-blank
character.</p>

<p style="margin-top: 1em">[n]s Substitute the next n
characters (i.e. delete the characters and go into insert
mode).</p>

<p style="margin-top: 1em">S Substitute whole line. All
characters from the first non-blank character to the end of
the line are deleted and insert mode is entered.</p>

<p style="margin-top: 1em">[n]cmove-cmd <br>
Change from the current position to the position resulting
from n move-cmds (i.e. delete the indicated region and go
into insert mode); if move-cmd is c, the line starting <br>
from the first non-blank character is changed.</p>

<p style="margin-top: 1em">C Change from the current
position to the end of the line (i.e. delete to the end of
the line and go into insert mode).</p>

<p style="margin-top: 1em">[n]x Delete the next n
characters.</p>

<p style="margin-top: 1em">[n]X Delete the previous n
characters.</p>

<p style="margin-top: 1em">D Delete to the end of the
line.</p>

<p style="margin-top: 1em">[n]dmove-cmd <br>
Delete from the current position to the position resulting
from n move-cmds; move-cmd is a movement command (see above)
or d, in which case the current line is deleted.</p>

<p style="margin-top: 1em">[n]rc Replace the next n
characters with the character c.</p>

<p style="margin-top: 1em">[n]R Replace. Enter insert mode
but overwrite existing characters instead of inserting
before existing characters. The replacement is repeated n
times.</p>

<p style="margin-top: 1em">[n]~ Change the case of the next
n characters.</p>

<p style="margin-top: 1em">[n]ymove-cmd <br>
Yank from the current position to the position resulting
from n move-cmds into the yank buffer; if move-cmd is y, the
whole line is yanked.</p>

<p style="margin-top: 1em">Y Yank from the current position
to the end of the line.</p>

<p style="margin-top: 1em">[n]p Paste the contents of the
yank buffer just after the current position, n times.</p>

<p style="margin-top: 1em">[n]P Same as p, except the
buffer is pasted at the current position.</p>

<p style="margin-top: 1em">Miscellaneous vi commands</p>

<p style="margin-top: 1em">^J and ^M <br>
The current line is read, parsed, and executed by the
shell.</p>

<p style="margin-top: 1em">^L and ^R <br>
Redraw the current line.</p>

<p style="margin-top: 1em">[n]. Redo the last edit command
n times.</p>

<p style="margin-top: 1em">u Undo the last edit
command.</p>

<p style="margin-top: 1em">U Undo all changes that have
been made to the current line.</p>

<p style="margin-top: 1em">intr and quit <br>
The interrupt and quit terminal characters cause the current
line to be deleted and a new prompt to be printed.</p>

<p style="margin-top: 1em">FILES <br>
~/.mkshrc User mkshrc profile (non-privileged interactive
shells); see Startup files. The location can be changed at
compile time (for embedded systems); AOSP Android <br>
builds use /system/etc/mkshrc. <br>
~/.profile User profile (non-privileged login shells); see
Startup files near the top of this manual. <br>
/etc/profile System profile (login shells); see Startup
files. <br>
/etc/shells Shell database. <br>
/etc/suid_profile Suid profile (privileged shells); see
Startup files.</p>

<p style="margin-top: 1em">Note: On Android, /system/etc/
contains the system and suid profile.</p>

<p style="margin-top: 1em">SEE ALSO <br>
awk(1), cat(1), ed(1), getopt(1), sed(1), sh(1), stty(1),
dup(2), execve(2), getgid(2), getuid(2), mknod(2),
mkfifo(2), open(2), pipe(2), rename(2), wait(2), getopt(3),
<br>
nl_langinfo(3), setlocale(3), signal(3), system(3), tty(4),
shells(5), environ(7), script(7), utf-8(7), mknod(8)</p>


<p style="margin-top: 1em">http://docsrv.sco.com:507/en/man/html.C/sh.C.html</p>


<p style="margin-top: 1em">https://www.mirbsd.org/ksh-chan.htm</p>

<p style="margin-top: 1em">Morris Bolsky, The KornShell
Command and Programming Language, Prentice Hall PTR, xvi +
356 pages, 1989, ISBN 978-0-13-516972-8 (0-13-516972-0).</p>

<p style="margin-top: 1em">Morris I. Bolsky and David G.
Korn, The New KornShell Command and Programming Language
(2nd Edition), Prentice Hall PTR, xvi + 400 pages, 1995,
ISBN 978-0-13-182700-4 <br>
(0-13-182700-6).</p>

<p style="margin-top: 1em">Stephen G. Kochan and Patrick H.
Wood, UNIX Shell Programming, Hayden, Revised Edition, xi +
490 pages, 1990, ISBN 978-0-672-48448-3 (0-672-48448-X).</p>

<p style="margin-top: 1em">IEEE Inc., IEEE Standard for
Information Technology &acirc; Portable Operating System
Interface (POSIX), IEEE Press, Part 2: Shell and Utilities,
xvii + 1195 pages, 1993, ISBN <br>
978-1-55937-255-8 (1-55937-255-9).</p>

<p style="margin-top: 1em">Bill Rosenblatt, Learning the
Korn Shell, O&rsquo;Reilly, 360 pages, 1993, ISBN
978-1-56592-054-5 (1-56592-054-6).</p>

<p style="margin-top: 1em">Bill Rosenblatt and Arnold
Robbins, Learning the Korn Shell, Second Edition,
O&rsquo;Reilly, 432 pages, 2002, ISBN 978-0-596-00195-7
(0-596-00195-9).</p>

<p style="margin-top: 1em">Barry Rosenberg, KornShell
Programming Tutorial, Addison-Wesley Professional, xxi + 324
pages, 1991, ISBN 978-0-201-56324-5 (0-201-56324-X).</p>

<p style="margin-top: 1em">AUTHORS <br>
The MirBSD Korn Shell is developed by Thorsten Glaser
&lt;tg@mirbsd.org&gt; and currently maintained as part of
The MirOS Project. This shell is based upon the Public
Domain Korn SHell. <br>
The developer of mksh recognises the efforts of the pdksh
authors, who had dedicated their work into Public Domain,
our users, and all contributors, such as the Debian and
OpenBSD <br>
projects. See the documentation, CVS, and web site for
details.</p>

<p style="margin-top: 1em">CAVEATS <br>
mksh only supports the Unicode BMP (Basic Multilingual
Plane).</p>

<p style="margin-top: 1em">mksh has a different scope model
from AT&amp;T UNIX ksh, which leads to subtile differences
in semantics for identical builtins. This can cause issues
with a nameref to suddenly point <br>
to a local variable by accident; fixing this is hard.</p>

<p style="margin-top: 1em">The parts of a pipeline, like
below, are executed in subshells. Thus, variable assignments
inside them fail. Use co-processes instead.</p>

<p style="margin-top: 1em">foo | bar | read baz # will not
change $baz <br>
foo | bar |&amp; read -p baz # will, however, do so</p>

<p style="margin-top: 1em">mksh provides a consistent set
of 32-bit integer arithmetics, both signed and unsigned,
with defined wraparound and sign of the result of a modulo
operation, even (defying POSIX) <br>
on 64-bit systems. If you require 64-bit integer
arithmetics, use lksh (legacy mksh) instead, but be aware
that, in POSIX, it&rsquo;s legal for the OS to make print
$((2147483647 + 1)) <br>
delete all files on your system, as it&rsquo;s Undefined
Behaviour.</p>

<p style="margin-top: 1em">BUGS <br>
Suspending (using ^Z) pipelines like the one below will only
suspend the currently running part of the pipeline; in this
example, &acirc;fubar&acirc; is immediately printed on
suspension (but <br>
not later after an fg).</p>

<p style="margin-top: 1em">$ /bin/sleep 666 &amp;&amp; echo
fubar</p>

<p style="margin-top: 1em">This document attempts to
describe mksh R46 and up, compiled without any options
impacting functionality, such as MKSH_SMALL, when not called
as /bin/sh which, on some systems <br>
only, enables set -o sh automatically (whose behaviour
differs across targets), for an operating environment
supporting all of its advanced needs. Please report bugs in
mksh to <br>
the MirOS mailing list at &lt;miros-mksh@mirbsd.org&gt; or
in the #!/bin/mksh (or #ksh) IRC channel at irc.freenode.net
(Port 6697 SSL, 6667 unencrypted), or at: <br>
https://launchpad.net/mksh</p>

<p style="margin-top: 1em">MirBSD May 2, 2013 MirBSD</p>
<hr>
</body>
</html>
