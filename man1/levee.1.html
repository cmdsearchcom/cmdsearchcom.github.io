<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:21:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>LEVEE(1) General Commands Manual LEVEE(1)</p>

<p style="margin-top: 1em">NAME <br>
levee - A Screen Oriented Editor.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
levee [+address] [file ...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Levee is a screen oriented editor based on the Unix editor
&quot;vi&quot;. It provides a terse, powerful way to enter
and edit text (however, if you want a word-processor,
you&rsquo;re <br>
better off with WordStar.)</p>

<p style="margin-top: 1em">Levee is a moded editor. It
operates in 3 modes -- visual, command, and insert. Most of
the editing work is done is visual mode, file reading and
writing is done in com&acirc; <br>
mand mode, and insert mode does what you would expect.</p>

<p style="margin-top: 1em">When you enter Levee, you may
specify an address to start editing at. These addresses are
in the same format as command mode addresses, except that a
naked + will put you <br>
at the very end of the file.</p>

<p style="margin-top: 1em">Levee is copyright (c) 1982-2008
by David L. Parsons. (see the notice at the end of this
document for distribution terms)</p>

<p style="margin-top: 1em">COMMAND MODE COMMANDS <br>
These commands are used for editing new files, writing
modified files, changing options, doing substitutions, and a
subset of the visual commands. They take as input whole <br>
lines, terminated by return (to execute), or escape (to
abort.)</p>

<p style="margin-top: 1em">Command mode is reached by
typing &quot;:&quot; or &quot;Q&quot; from visual mode. If
you enter command mode by typing &quot;:&quot;, Levee will
execute one command, then return to visual mode after <br>
prompting you with &quot;[more]&quot;. If you type anything
except a space or return, Levee will accept another command,
and so forth. If, however, you enter command mode via
&quot;Q&quot;, <br>
Levee will remain in command mode until you enter the
&quot;visual&quot; command.</p>

<p style="margin-top: 1em">A NOTE ON COMMAND SYNTAX <br>
A command may be preceded by an optional line-range. If you
do not provide a line-range, Levee will use the default
line-range shown by the command. A line-range is one or two
<br>
address specifications in the following format:</p>

<p style="margin-top: 1em">(.|$|&rsquo;x|#) [ (+|-)
(/patt/|?patt?|#) ]</p>

<p style="margin-top: 1em">. current line.</p>

<p style="margin-top: 1em">$ last line.</p>

<p style="margin-top: 1em">&rsquo;x the line with mark x on
it.</p>

<p style="margin-top: 1em"># line #.</p>

<p style="margin-top: 1em">For example,
&quot;.-5,.+5p&quot; will print every line within ten lines
of the current line. &quot;$-5&quot; is the fifth line from
the end of the file, and &quot;/end/+2&quot; is the second
line past the <br>
next occurrence of the pattern &quot;end&quot;. Patterns may
be regular expressions (see below.)</p>

<p style="margin-top: 1em">Also, a naked line-range will
set the current line to the first line in the range and
print all the lines in that range. &quot;1,10&quot; sets the
current line to 1, then prints lines <br>
1 to 10.</p>

<p style="margin-top: 1em">If you specify a non-existent
line in a range, the command <br>
will abort and Levee will tell you &quot;bad
address&quot;.</p>

<p style="margin-top: 1em">Command mode commands <br>
args show the current argument list, if one exists. The file
that you are currently editing will be framed by
&rsquo;[&rsquo; and &rsquo;]&rsquo;.</p>

<p style="margin-top: 1em">(.,.)change <br>
delete lines, then enter insert mode.</p>

<p style="margin-top: 1em">(.,.)delete <br>
delete lines. Deleted lines are stored in a Yank Buffer for
later putback with &quot;put&quot;.</p>

<p style="margin-top: 1em">edit[!] [file] <br>
Discard the current file and start editing a new one. If
changes were made to the current file, you must enter
&quot;edit!&quot; to force Levee to discard the changes. If
you do <br>
not specify a filename, Levee will try to reedit the current
filename.</p>

<p style="margin-top: 1em">When Levee reads in a new file,
it will tell you how many bytes it read in, or [overflow] if
the file is larger than the internal buffer (256000 bytes on
most platforms; <br>
20k on USCD Pascal.)</p>

<p style="margin-top: 1em">execmode <br>
Remain in command mode until you use the &quot;visual&quot;
command.</p>

<p style="margin-top: 1em">file[name] <br>
Echo what the current filename is, its status, and the
current line. If you provide it with a name, it will change
the filename to that.</p>

<p style="margin-top: 1em">(.)insert <br>
Insert text above the current line. If you specify a line
number, Levee will make that the current line, then insert
above it.</p>

<p style="margin-top: 1em">Insert mode commands <br>
^W back over the last word you entered.</p>

<p style="margin-top: 1em">^H back over one character.</p>

<p style="margin-top: 1em">^U back over all input on this
line.</p>

<p style="margin-top: 1em">^V escape the next character
typed. (For example, ^V^H will put a ^H into the file.)</p>

<p style="margin-top: 1em">ESC exit insert mode.</p>

<p style="margin-top: 1em">^D If at start of line, reduce
indentation &rsquo;shiftwidth&rsquo; columns.</p>

<p style="margin-top: 1em">^T If at start of line, increase
indentation &rsquo;shiftwidth&rsquo; columns.</p>

<p style="margin-top: 1em">When in insert mode, Levee will
not allow you to enter any control characters except return
and tab. Return ends input on this line and opens a new line
for input.</p>

<p style="margin-top: 1em">map[!][key[text]] <br>
Define/list macros. There are 3 forms of map:</p>

<p style="margin-top: 1em">map. This lists all the active
macros.</p>

<p style="margin-top: 1em">map(key). <br>
This shows the macro associated with (key), if any.</p>

<p style="margin-top: 1em">map(key) (text) <br>
This maps (key) to (text). You may map any key except
&quot;:&quot; and escape. In the normal form (map), the
macro will be effective in visual mode, but in the alternate
form, <br>
(map!), the macro will be effective in insert and command
modes.</p>

<p style="margin-top: 1em">For example, if you map!ped
return to &quot;hello world&quot;, every time you entered a
return in command or visual mode, the string &quot;hello
world&quot; would pop up.</p>

<p style="margin-top: 1em">next[file...] <br>
Edit the next file in the arglist, or edit a new arglist.
Levee takes its initial arglist off the command line when
you execute it. If &quot;autowrite&quot; is set, Levee will
<br>
write out the changes to the current file before editing the
next one.</p>

<p style="margin-top: 1em">(.)open <br>
Insert below the current line. Otherwise just like
insert.</p>

<p style="margin-top: 1em">previous <br>
Edit the previous file in the arglist. Otherwise, like
next.</p>

<p style="margin-top: 1em">(.,.)print <br>
Display lines without changing the current line.</p>

<p style="margin-top: 1em">(.)put Put the contents of the
yank buffer back on the line below the current line. If you
specify a line, it resets the current line, then puts the
yank buffer back. The yank <br>
buffer is filled by the delete, change, or yank commands.
Put does not destroy the yank buffer, so you may put back
text multiple times.</p>

<p style="margin-top: 1em">quit[!] <br>
Exit Levee. If you want to discard changes, use
&quot;quit!&quot;</p>

<p style="margin-top: 1em">(.)read[file] <br>
put the contents of &rsquo;file&rsquo; after the current
line.</p>

<p style="margin-top: 1em">rmfile Delete &rsquo;file&rsquo;
from disk.</p>

<p style="margin-top: 1em">set[option=value] <br>
Set a tunable variable. Levee has a dozen or so
user-definable variables which you can twiddle via this
command. There are boolean, integer, and string variables
that you <br>
can set. A string or integer variable is set by &quot;set
xxx=yyy&quot;, a boolean variable is set via &quot;set
xxx&quot; or &quot;set noxxx&quot;.</p>

<p style="margin-top: 1em">Here are the settable variables
(and abbreviations):</p>

<p style="margin-top: 1em">tabsize(ts) <br>
tab stop.</p>

<p style="margin-top: 1em">shiftwidth(sw) <br>
columns to shift on ^D, ^T, &gt;&gt;, or &lt;&lt;</p>

<p style="margin-top: 1em">scroll number of lines to scroll
on ^D, ^U</p>

<p style="margin-top: 1em">autoindent(ai) <br>
supply indentation during insert mode.</p>

<p style="margin-top: 1em">autowrite(aw) <br>
write out changes before :next, :prev</p>

<p style="margin-top: 1em">autocopy(ac) <br>
make backup copies before writing changes.</p>

<p style="margin-top: 1em">list display tabs as ^I, end of
line as $.</p>

<p style="margin-top: 1em">magic use regular expressions in
searches.</p>

<p style="margin-top: 1em">suffix if the filename does not
have a . in it, supply the suffix. (this is the only string
variable.)</p>

<p style="margin-top: 1em">overwrite(ow) <br>
destroy old file first, then write.</p>

<p style="margin-top: 1em">beautify(be) <br>
When set, Levee will not allow insert of any control
character except tab and return unless you escape it with
ctrl-V.</p>

<p style="margin-top: 1em">wrapscan <br>
searches wrap around end of buffer.</p>

<p style="margin-top: 1em">ignorecase(ic) <br>
Ignore the case of alphabetic characters during
searches.</p>

<p style="margin-top: 1em">mapslash <br>
(ST version only) Map &quot;/&quot; in filenames to &quot;
<br>
false. (See the documentation for the Teeny-shell on how the
teeny-shell interprets &lsquo;mapslash&rsquo;)</p>

<p style="margin-top: 1em">lines(li) <br>
(ST version only) How many lines on the display. This is
primarily for running levee through the serial port - put
set li=xx into your LVRC for a xx line terminal.</p>

<p style="margin-top: 1em">cols(co) <br>
(ST version only) How many columns on the display. Like the
lines variable, it&rsquo;s for running levee through the
serial port.</p>

<p style="margin-top: 1em">You may set multiple variables
on one line, as in &rsquo;set ws noai&rsquo;. To see the
current settings of these variables, :set -- without any
arguments -- will show the current settings.</p>

<p style="margin-top: 1em">At startup, Levee looks in the
environment variable LVRC for a list of variables to set
(GEMDOS/MS-DOS). LVRC is one line of the form
&rsquo;option=value ...&rsquo;. If you have a LVRC <br>
defined that is &rsquo;ts=4 ow nows&rsquo;, Levee will set
tabsize to 4, turn on overwrite, and turn off wrapscan.</p>

<p style="margin-top: 1em">If you are using RMX, Levee
looks in the file &quot;:home:r?lvrc&quot; for
initialization. If you are using Osy/SWOs, Levee looks in
the file &quot;*.lvrc&quot;. The format of these files are
dif&acirc; <br>
ferent from the LVRC variable -- see &quot;source&quot; for
more information.</p>

<p style="margin-top: 1em">sourcefile <br>
Take command mode commands from &rsquo;file&rsquo;. These
commands can be any legal command, except
&quot;visual&quot;. If a error happens during execution of
&rsquo;file&rsquo;, Levee abandons that level <br>
of source&rsquo;ing.</p>

<p style="margin-top: 1em">In Osy/SWOs, there are a few
differences in insert mode from within a sourced file. No
character has special meaning except a line containing
nothing but a period, which <br>
terminates insert mode. For example:</p>

<p style="margin-top: 1em">:commands <br>
:insert <br>
blah blah blah blah blah blah <br>
blah blah blah blah blah blah <br>
blah blah blah blah blah blah <br>
:more commands</p>

<p style="margin-top: 1em">If you are running Levee under
any other operating system, you cannot do a insert from a
:source file.</p>


<p style="margin-top: 1em">(.,.)substitute(delim)patt(delim)repl(delim)[qcpg]</p>

<p style="margin-top: 1em">(.,.)substitute&amp;</p>

<p style="margin-top: 1em">Search for patt and replace it
with repl. Levee will look for patt once on each line and
replace it with repl. The delimiter may be any ascii
character.</p>

<p style="margin-top: 1em">The pattern is a regular
expression, just like a search pattern.</p>

<p style="margin-top: 1em">You may include parts of the
pattern in the replacement string; A &rsquo;&amp;&rsquo; in
the replacement pattern copies in the whole source pattern,
so if you do a &rsquo;sub/this/&amp; and <br>
that/g&rsquo;, every instance of &rsquo;this&rsquo; will be
replaced with &rsquo;this and that&rsquo;. Also, you may
pull parts of the pattern out by using the and argument
meta-characters. <br>
Arguments gotten by &amp; are put into the replacement
string everywhere you do a 1..9 [ 1 is the first argument
you set up with &amp; ]. So, if you want to reverse <br>
the order of two substrings, you can do
&rsquo;sub/&ni;ring1&ni;ring2/21/&rsquo;.</p>

<p style="margin-top: 1em">substitute&amp; redoes the last
substitution.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">q,c before doing the substitute,
display the affected line and wait for you to type a
character. If you type &rsquo;y&rsquo;, it will do the
substitution. &rsquo;q&rsquo; aborts the substitute,
&rsquo;a&rsquo; <br>
does the rest of the change without prompting, and
&rsquo;n&rsquo; does not do it.</p>

<p style="margin-top: 1em">p print the affected lines after
the change.</p>

<p style="margin-top: 1em">g do the change globally. That
is, do it for every occurrence of patt on a line, rather
than just once.</p>

<p style="margin-top: 1em">undo Undo the last modification
to the file (except :edit, :next, :rm, or :write.) You can
only undo the last change to a file -- undo counts as a
change. :undo followed by <br>
:undo does nothing to the file.</p>

<p style="margin-top: 1em">unmap(key) <br>
Undefine a macro (see map).</p>

<p style="margin-top: 1em">visual[list] <br>
If you entered command mode by &quot;Q&quot; or
&quot;execmode&quot;, return to visual mode. If you provide
an argument list, it also does a &lsquo;:next&rsquo; on that
list.</p>

<p style="margin-top: 1em">version <br>
Show which version of levee this is.</p>

<p style="margin-top: 1em">(.,.)write [file] <br>
Write lines to a file. If you write the everything to
&rsquo;file&rsquo;, the filename is set to
&rsquo;file&rsquo;, and if you do not specify a file, Levee
will write to the filename.</p>

<p style="margin-top: 1em">(.,.)wq [file] <br>
Write to a file, then quit.</p>

<p style="margin-top: 1em">(.,.)yank <br>
Yank lines from the file into the yank buffer, for later
putback with &quot;put&quot;.</p>

<p style="margin-top: 1em">xit[!] Write changes to the
current file, then exit. If there are more files in the
arglist, use &quot;xit!&quot;</p>

<p style="margin-top: 1em">![command] <br>
Execute command.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">!ls =&gt; does a
&rsquo;ls&rsquo;.</p>

<p style="margin-top: 1em">This command is available only
under GEMDOS, MSDOS, RMX, and Unix.</p>

<p style="margin-top: 1em">($)= Give the line number of the
addressed line. /end/= gives you the line number of the next
line with a &rsquo;end&rsquo; on it.</p>

<p style="margin-top: 1em">VISUAL MODE COMMANDS <br>
Visual mode commands move you around and modify the file.
There are movement commands to move the cursor by a variety
of objects.</p>

<p style="margin-top: 1em">In the description, a (#) means
a optional count. If a command has a optional count, it will
tell you what the count does in parenthesis. A (*) means
that the command can be <br>
used in the delete, yank, and change commands.</p>

<p style="margin-top: 1em">Counts are made up by entering
digits. If you type &rsquo;45&rsquo;, the count will be set
to 45. To cancel a count, type ESC.</p>

<p style="margin-top: 1em">This section discusses
&rsquo;whitespace&rsquo; occasionally. Whitespace is tabs,
spaces, and end of line.</p>

<p style="margin-top: 1em">How the display works <br>
Characters are displayed on the screen as you would expect,
except that nonprinting characters are shown as ^x, and tabs
expand to spaces ( unless you set the option <br>
list, then they show as ^I.) When sitting on a control
character or tab, the cursor is placed on the FIRST
character displayed. If you move the cursor to any other
part of them <br>
( via j or k -- see below), any changes will start at the
next character.</p>

<p style="margin-top: 1em">Levee does not display a end of
file marker, but lines past the end of the file are denoted
by ~ lines.</p>

<p style="margin-top: 1em">If list is set, tabs display as
^I, and the end of line displays as $.</p>

<p style="margin-top: 1em">If a line is too long for the
screen, it will just disappear off the end of the
screen.</p>

<p style="margin-top: 1em">Levee will handle any screen
resolution and any monospaced font you hand it ( if you are
running in low resolution, Levee will give you a 25x40
window, for example.)</p>

<p style="margin-top: 1em">Visual mode commands <br>
^A Show a debugging message at the bottom of the screen.
This is not at all useful unless you are debugging the
editor. Ignore it.</p>

<p style="margin-top: 1em">(#)^D Scroll the screen down a
half screen. If a count is specified, scroll down the
specified number of lines.</p>

<p style="margin-top: 1em">^E Scroll down 1 line (shorthand
for 1^D )</p>

<p style="margin-top: 1em">^G Show file statistics. Exactly
like &rsquo;:file&rsquo;.</p>

<p style="margin-top: 1em">(*)(#)^H <br>
Move the cursor left one (count) chars.</p>

<p style="margin-top: 1em">^I Redraw the screen.</p>

<p style="margin-top: 1em">(*)(#)^J <br>
Move down one (count) lines. When you use ^J and ^K (below)
to move up or down lines, the cursor will remain in the same
column, even if it is in the middle of a tabstop <br>
or past the end of a line.</p>

<p style="margin-top: 1em">(*)(#)^K <br>
Move up one (count) lines.</p>

<p style="margin-top: 1em">(*)(#)^L <br>
Move right one (count) characters.</p>

<p style="margin-top: 1em">(*)(#)^M <br>
Move to the first nonwhite space on the next line. If a
count is specified, move to the first nonwhite count lines
down.</p>

<p style="margin-top: 1em">(#)^U Scroll the screen up a
half page. If a count is specified, scroll up count
lines.</p>

<p style="margin-top: 1em">^Y Scroll the screen up 1 line
(shorthand for 1^U.)</p>

<p style="margin-top: 1em">(#)a Insert text AFTER the
cursor. If you give a count, the insertion will be repeated
count times ( 40i-ESC will give you a line of 40
dashes).</p>

<p style="margin-top: 1em">The commands in insert mode are
the same for visual and command mode.</p>

<p style="margin-top: 1em">(*)(#)b <br>
Move to the beginning of the last word (the count&rsquo;th
word back). A word is a collection of alphanumeric
characters (a-z0-9$_#) or any other nonwhite character (i.e.
any&acirc; <br>
thing but space, tab, eoln).</p>

<p style="margin-top: 1em">c Change a object. Change
deletes an object, then enters insert mode without redrawing
the screen. When you tell it the object to be changed, Levee
puts a &rsquo;$&rsquo; on the last <br>
character of the object. You cannot change backwards.</p>

<p style="margin-top: 1em">The object may be any visual
mode command marked with a &rsquo;(*) &rsquo;. For example,
&rsquo;c4l&rsquo; will change the next 4 characters on the
line to something else. (4cl does the same <br>
thing -- 4c4l changes the next 16 characters on this
line.)</p>

<p style="margin-top: 1em">&rsquo;cc&rsquo; will change
whole lines.</p>

<p style="margin-top: 1em">When changing, deleting, or
yanking a object, it will be placed into a yank buffer,
where it can be retrieved by the &rsquo;p&rsquo; or
&rsquo;P&rsquo; commands.</p>

<p style="margin-top: 1em">(#)d Delete an object. Like
&rsquo;cc&rsquo;, &rsquo;dd&rsquo; affects whole lines.</p>

<p style="margin-top: 1em">(*)(#)e <br>
Move to the end of the current word.</p>

<p style="margin-top: 1em">(*)(#)f(x) <br>
Find the next (count&rsquo;th) occurrence of a character on
the current line. For example, if the cursor is sitting on
the first character of the line &rsquo;abcdef&rsquo;, typing
&quot;ff&quot; <br>
will put the cursor on the &rsquo;f&rsquo;.</p>

<p style="margin-top: 1em">(*)(#)h <br>
Move left one (count) characters. Exactly like ^H.</p>

<p style="margin-top: 1em">(#)i Start inserting characters
at the cursor. If you specify a count, the insertion will be
duplicated count times.</p>

<p style="margin-top: 1em">(*)(#)j <br>
Move down one (count) lines. Exactly like ^J.</p>

<p style="margin-top: 1em">(*)(#)k <br>
Move up one (count) lines. Exactly like ^K.</p>

<p style="margin-top: 1em">,B (*) (#)l <br>
Move right one (count) character. Exactly like ^L.</p>

<p style="margin-top: 1em">m(x) Set the marker (x). There
are 26 markers available (a-z). You may move to a marker by
use of the &rsquo; or &lsquo; commands.</p>

<p style="margin-top: 1em">(*)n Find the next occurrence of
a search pattern. When you do a search with a / or ?
command, Levee will remember the pattern and the direction
you searched in. &rsquo;n&rsquo; will <br>
search in the same direction for the pattern,
&rsquo;N&rsquo; searches in the opposite direction.</p>

<p style="margin-top: 1em">o Open a line below the current
line for insertion.</p>

<p style="margin-top: 1em">p Put yanked/deleted text back
after the cursor. Text is yanked by the delete (d,x,X,D),
change (c,C,s,S), and yank (y,Y) commands.</p>

<p style="margin-top: 1em">(#)r(x) <br>
Replace characters (up to end of line) with (x).
&rsquo;4ra&rsquo; will change the next 4 characters after
the cursor into &rsquo;aaaa&rsquo;.</p>

<p style="margin-top: 1em">(#)s change one (count)
characters. Shorthand for (#)cl.</p>

<p style="margin-top: 1em">(*)(#)t(x) <br>
Move up to a character on the current line. If you are on
the first character of the line &rsquo;abcdef&rsquo; and you
type &rsquo;tf&rsquo;, you will end up sitting on the
&rsquo;e&rsquo;.</p>

<p style="margin-top: 1em">u Undo last modification. You
can undo ANY modification command except :edit, :next, :rm,
or :write. (Just like :undo).</p>

<p style="margin-top: 1em">(*)(#)v <br>
Move back to the very end of the previous (count&rsquo;th)
word. See &rsquo;b&rsquo; for the definition of a word.</p>

<p style="margin-top: 1em">(*)(#)w <br>
Move up to the very beginning of the next (count&rsquo;th)
word.</p>

<p style="margin-top: 1em">(#)x Delete one (count)
characters forward. Shorthand for (#)dl.</p>

<p style="margin-top: 1em">y Yank an object for later use
by put. &rsquo;yy&rsquo; yanks whole lines.</p>

<p style="margin-top: 1em">A Append text at the end of the
line. Shorthand for $a.</p>

<p style="margin-top: 1em">(*)(#)B <br>
Move to the beginning of the current word. Exactly like
&rsquo;b&rsquo;.</p>

<p style="margin-top: 1em">NOTE: this is incorrect. the
capitalized word movement commands should, and will in the
future, be used for movement by space-delimited words.</p>

<p style="margin-top: 1em">C Change to the end of the line.
Shorthand for c$.</p>

<p style="margin-top: 1em">D Delete to the end of the line.
Shorthand for d$.</p>

<p style="margin-top: 1em">(*)(#)F(x) <br>
Move to the first (count&rsquo;th) previous occurrence of a
character on the current line. If you are sitting at the end
of the line &rsquo;abcdef&rsquo;, typing &quot;Fa&quot; will
move you back to <br>
the &rsquo;a&rsquo; at the start of the line.</p>

<p style="margin-top: 1em">(*)(#)G <br>
Goto line. If you specify a count, Levee will move to that
line, and if there is no count, Levee moves to the absolute
end of the file.</p>

<p style="margin-top: 1em">To get to the start of the file,
type &quot;1G&quot;. To the end, just &quot;G&quot;.</p>

<p style="margin-top: 1em">(*)H Move to the first nonwhite
character at the top of the screen.</p>

<p style="margin-top: 1em">I Insert at the end of the
current line. Shorthand for $i.</p>

<p style="margin-top: 1em">(#)J Join two (count+1) lines
together. Joining appends the second line at the end of the
first, putting a space between them. If the first line ends
in whitespace, Levee will <br>
not put in a space.</p>

<p style="margin-top: 1em">(*)L Move to the last nonwhite
character on the last line of the screen.</p>

<p style="margin-top: 1em">(*)M Move to the first nonwhite
character in the middle of the screen.</p>

<p style="margin-top: 1em">O Open a line above the current
line. Otherwise works just like &rsquo;o&rsquo;.</p>

<p style="margin-top: 1em">P Put back the yank buffer at
the cursor. Otherwise works just like &rsquo;p&rsquo;.</p>

<p style="margin-top: 1em">Q Enter and remain in command
mode. Just like the command :exec. To get back to visual
mode, you must enter the command &rsquo;:visual&rsquo;.</p>

<p style="margin-top: 1em">R Replace mode. A limited subset
of insert mode that overwrites characters up to end of line.
All of the normal insert mode commands apply. If you
overwrite a character, <br>
then back over it with ^H,^U, or ^W, it will reappear after
you exit Replace mode.</p>

<p style="margin-top: 1em">Escape exits replace mode.</p>

<p style="margin-top: 1em">NOTE: due to a bug, entering a
&lt;return&gt; in Replace mode will drop you back into
visual mode with an error. The replacements you have made
will remain.</p>

<p style="margin-top: 1em">S Change characters backwards.
Shorthand for (#)ch.</p>

<p style="margin-top: 1em">(*)(#)T(x) <br>
Move back to character on current line. If you are on the
last character of the line &rsquo;abcdef&rsquo;, typing
&quot;Ta&quot; will move you back to the
&rsquo;b&rsquo;.</p>

<p style="margin-top: 1em">(*)(#)W <br>
Move to end of word. Exactly like &rsquo;e&rsquo;.</p>

<p style="margin-top: 1em">(#)X Delete characters
backwards. Shorthand for (#)dh.</p>

<p style="margin-top: 1em">Y Yank to end of line. Shorthand
for y$.</p>

<p style="margin-top: 1em">ZZ Write changes to current file
and exit if last file in arglist. Exactly like :xit.</p>

<p style="margin-top: 1em">(*)(#)$ <br>
Move to end of line. If you give a count, move to the end of
the (count-1) line down (so 2$ moves you to the end of the
next line.).</p>

<p style="margin-top: 1em">0 Move to the beginning of the
current line. Shorthand for 0|.</p>

<p style="margin-top: 1em">(#)! Pipe an object through an
external program. Like &rsquo;cc&rsquo;, &rsquo;!!&rsquo;
affects whole lines.</p>

<p style="margin-top: 1em">(*)% Find matching bracket,
parenthesis, or squiggly bracket. If you are not sitting on
a &rsquo;[]{}()&rsquo;, Levee will search forward for one of
them on the current line, then match <br>
whatever it finds.</p>

<p style="margin-top: 1em">[space] <br>
Move to the first nonwhite character on the current
line.</p>

<p style="margin-top: 1em">&amp; Redo last substitution
command.</p>

<p style="margin-top: 1em">(*)(#){ <br>
Move to the beginning of the count&rsquo;th paragraph back.
A paragraph is delimited by a blank line.</p>

<p style="margin-top: 1em">(*)(#)} <br>
Move to the end of the count&rsquo;th paragraph forward.</p>

<p style="margin-top: 1em">(*)(#)( <br>
Move to the beginning of the count&rsquo;th sentence back. A
sentence is delimited by a ., a !, or a ? followed by a
space, a tab, or end of line.</p>

<p style="margin-top: 1em">(*)(#)) <br>
Move to the end of the count&rsquo;th sentence forward.</p>

<p style="margin-top: 1em">(*)(#)- <br>
Move to the (count&rsquo;th) previous line, first
nonwhite.</p>

<p style="margin-top: 1em">(*)(#)+ <br>
Move to the (count&rsquo;th) next line, first nonwhite.</p>

<p style="margin-top: 1em">(#)~ Change the case of the next
count characters. Upper case becomes lowercase, lowercase
becomes uppercase.</p>

<p style="margin-top: 1em">(*)&lsquo;(x) <br>
Move to the exact position of mark (x). There is a special
mark for some of the visual mode move meant commands --
&rsquo;&rsquo; will move you to where you were before the
last <br>
(,),&rsquo;,&lsquo;,G,/,?,n,N command.</p>

<p style="margin-top: 1em">: Execute one command mode
command. When the command is done, it will return to visual
mode if it produces one line of output, but if it scrolls
the screen, Levee will <br>
prompt [more] before returning to visual mode. If you type a
: in response to the [more] prompt, Levee will remain in
command mode for one more command.</p>

<p style="margin-top: 1em">(#)&lt;(#) <br>
Shift one (count) objects left. If you specify a second
count, Levee will shift the object left that many columns --
if you do not, they will be sh shifted shiftwidth col&acirc;
<br>
umns.</p>

<p style="margin-top: 1em">This is a nondestructive shift.
If the shift would carry past the left margin, the objects
will be moved up to the left margin but no farther.</p>

<p style="margin-top: 1em">Like the other object movement
commands, &rsquo;&lt;&lt;&rsquo; will affect whole
lines.</p>

<p style="margin-top: 1em">(#)&gt;(#) <br>
Shift one (count) objects right. Just like &lt;, except it
will not shift objects past the right margin of the screen.
If you do shift an object past the right margin of the <br>
screen, all of its indent will be removed and it will end up
by the left margin.</p>

<p style="margin-top: 1em">. Repeat last modification
command. (except undo)</p>

<p style="margin-top: 1em">(*)? Search for pattern
backwards. Escape aborts the search pattern, and a empty
pattern means search for the last pattern again.</p>

<p style="margin-top: 1em">(*)/ Search for pattern
forwards. Otherwise like ?.</p>

<p style="margin-top: 1em">(#)| Move to specified column.
If you don&rsquo;t have a count, move to column 0.</p>

<p style="margin-top: 1em">REGULAR EXPRESSIONS <br>
Levee gives special meanings to some characters during a
pattern match. The character &quot;.&quot; will match any
one char, the character &quot;*&quot; will match zero or
more occurrences of <br>
the previous char ( so, a* will match
&rsquo;a&rsquo;,&rsquo;aa&rsquo;,&rsquo;aaa&rsquo;, etc, or
it will match nothing at all). If a pattern begins with
&quot;^&quot;, it will only match at the beginning of a
line, and <br>
patterns ending with a &quot;$&quot; will only match at the
end of a line.</p>

<p style="margin-top: 1em">Brackets (&rsquo;[]&rsquo;) have
special meaning as well. They mean match any one of the
characters inside the brackets. &rsquo;[abc]&rsquo; will
match &rsquo;a&rsquo;, &rsquo;b&rsquo;, or &rsquo;c&rsquo;.
You may specify a range of <br>
characters inside brackets by using a dash (-).
&rsquo;[a-z]&rsquo; will match any lowercase alphabetic
character. If ^ is the first character in the bracket, it
means match any char&acirc; <br>
acter except those in the brackets. &rsquo;[^abc]&rsquo;
will match anything except &rsquo;a&rsquo;,&rsquo;b&rsquo;,
or &rsquo;c&rsquo;.</p>

<p style="margin-top: 1em">Backslash takes away special
meaning for these chars, but &rsquo;&rsquo; specifies a tab,
and &amp; delimit arguments inside a pattern (used only by
:substitute.) The patterns <br>
&lt; and &gt; have special meaning, too; they match the
start and end of alpha-numeric tokens.</p>

<p style="margin-top: 1em">If you turn off the editor
variable &rsquo;magic&rsquo;, none of the above characters
will have special meaning inside of a pattern (see
&rsquo;set&rsquo;).</p>

<p style="margin-top: 1em">Some example patterns:</p>

<p style="margin-top: 1em">^end$ Find a line that is just
&rsquo;end&rsquo;.</p>

<p style="margin-top: 1em">[Ee][Nn][Dd] <br>
Find a &rsquo;end&rsquo;, ignoring case.</p>

<p style="margin-top: 1em">[A-Za-z][A-Za-z0-9]* <br>
Find the next identifier.</p>

<p style="margin-top: 1em">([*].*[*]) <br>
Find the next one-line pascal comment.</p>

<p style="margin-top: 1em">&lt;the&gt; Find the next
occurrence of &lsquo;the&rsquo;.</p>

<p style="margin-top: 1em">LIMITATIONS <br>
Levee can only edit files up to 256000 characters long. ^M
is used as its internal line separator, so inserting ^M will
have interesting consequences.</p>

<p style="margin-top: 1em">BUGS <br>
Probably infinite.</p>

<p style="margin-top: 1em">AUTHOR <br>
David L. Parsons (orc@pell.chi.il.us) <br>
Testing, suggestions, and impractical design goals by: Jim
Bolland. John Tainter. John Plocher.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (c) 1982-2007 David L Parsons <br>
All rights reserved.</p>

<p style="margin-top: 1em">Redistribution and use in source
and binary forms, without or without modification, are
permitted provided that the above copyright notice and this
paragraph are duplicated in <br>
all such forms and that any documentation, advertising
materials, and other materials related to such distribution
and use acknowledge that the software was developed by David
L <br>
Parsons (orc@pell.chi.il.us). My name may not be used to
endorse or promote products derived from this software
without specific prior written permission. THIS SOFTWARE IS
PRO&acirc; <br>
VIDED AS IS&rsquo;&rsquo; AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
PURPOSE.</p>

<p style="margin-top: 1em">Mastodon Linux 29 August 1998
LEVEE(1)</p>
<hr>
</body>
</html>
