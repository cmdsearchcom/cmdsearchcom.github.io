<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GPP(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GPP(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">GPP(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
GPP - Generic Preprocessor
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<br/>
 gpp [-{o|O} <i>outfile</i>] [-I<i>/include/path</i>] [-D<i>name=val</i> ...]
<br/>
 [-z|+z] [-x] [-m] [-C|-T|-H|-X|-P|-U ... [-M ...]]
<br/>
 [-n|+n] [+c <i>&lt;n&gt;</i> <i>str1</i> <i>str2</i>] [+s<i>&lt;n&gt;</i>
  <i>str1</i> <i>str2</i> <i>c</i>]
<br/>
 [-c <i>str1</i>] [--nostdinc] [--nocurinc]
<br/>
 [--curdirinclast] [--warninglevel <i>n</i>]
<br/>
 [--includemarker <i>str</i>] [--include <i>file</i>]
<br/>
 [ <i>infile</i>]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 gpp --help
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 gpp --version
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
GPP is a general-purpose preprocessor with customizable syntax, suitable for a
  wide range of preprocessing tasks. Its independence from any programming
  language makes it much more versatile than cpp, while its syntax is lighter
  and more flexible than that of m4.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
GPP is targeted at all common preprocessing tasks where cpp is not suitable and
  where no very sophisticated features are needed. In order to be able to
  process equally efficiently text files or source code in a variety of
  languages, the syntax used by GPP is fully customizable. The handling of
  comments and strings is especially advanced.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Initially, GPP only understands a minimal set of built-in macros, called
  <i>meta-macros</i>. These meta-macros allow the definition of <i>user
  macros</i> as well as some basic operations forming the core of the
  preprocessing system, including conditional tests, arithmetic evaluation,
  wildcard matching (globbing), and syntax specification. All user macro
  definitions are global -- <i>i.e.</i>, they remain valid until explicitly
  removed; meta-macros cannot be redefined. With each user macro definition GPP
  keeps track of the corresponding syntax specification so that a macro can be
  safely invoked regardless of any subsequent change in operating mode.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
In addition to macros, GPP understands comments and strings, whose syntax and
  behavior can be widely customized to fit any particular purpose. Internally
  comments and strings are the same construction, so everything that applies to
  comments applies to strings as well.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
GPP recognizes the following command-line switches and options. Note that the
  -nostdinc, -nocurinc, -curdirinclast, -warninglevel, and -includemarker
  options from version 2.1 and earlier are deprecated and should not be used.
  Use the &quot;long option&quot; variants instead (--nostdinc, <i>etc.</i>).
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h --help</b><i></i></dt>
  <dd class="It-tag">Print a short help message.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b><i></i></dt>
  <dd class="It-tag">Print version information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o </b><i>outfile</i></dt>
  <dd class="It-tag">Specify a file to which all output should be sent (by
      default, everything is sent to standard output).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-O </b><i>outfile</i></dt>
  <dd class="It-tag">Specify a file to which all output should be sent; output
      is simultanously sent to stdout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b><i>/include/path</i></dt>
  <dd class="It-tag">Specify a path where the <i>#include</i> meta-macro will
      look for include files if they are not present in the current directory.
      The default is /usr/include if no -I option is specified. Multiple -I
      options may be specified to look in several directories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b><i>name=val</i></dt>
  <dd class="It-tag">Define the user macro <i>name</i> as equal to <i>val</i>.
      This is strictly equivalent to using the <i>#define</i> meta-macro, but
      makes it possible to define macros from the command-line. If <i>val</i>
      makes references to arguments or other macros, it should conform to the
      syntax of the mode specified on the command-line. Starting with version
      2.1, macro argument naming is allowed on the command-line. The syntax is
      as follows: -D <i>macro</i>(<i>arg1</i>,...)=<i>definition</i>. The
      arguments are specified in C-style syntax, without any whitespace, but the
      definition should still conform to the syntax of the mode specified on the
      command-line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>+z</b><i></i></dt>
  <dd class="It-tag">Set text mode to Unix mode (LF terminator). Any CR
      character in the input is systematically discarded. This is the default
      under Unix systems.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-z</b><i></i></dt>
  <dd class="It-tag">Set text mode to DOS mode (CR-LF terminator). In this mode
      all CR characters are removed from the input, and all output LF characters
      are converted to CR-LF. This is the default if GPP is compiled with the
      WIN_NT option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b><i></i></dt>
  <dd class="It-tag">Enable the use of the <i>#exec</i> meta-macro. Since
      <i>#exec</i> includes the output of an arbitrary shell command line, it
      may cause a potential security threat, and is thus disabled unless this
      option is specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m</b><i></i></dt>
  <dd class="It-tag">Enable automatic mode switching to the cpp compatibility
      mode if the name of an included file ends in `.h' or `.c'. This makes it
      possible to include C header files with only minor modifications.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b><i></i></dt>
  <dd class="It-tag">Prevent newline or whitespace characters from being removed
      from the input when they occur as the end of a macro call or of a comment.
      By default, when a newline or whitespace character forms the end of a
      macro or a comment it is parsed as part of the macro call or comment and
      therefore removed from output. Use the -n option to keep the last
      character in the input stream if it was whitespace or a newline. This is
      activated in cpp and Prolog modes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>+n</b><i></i></dt>
  <dd class="It-tag">The opposite of -n. This is the default in all modes except
      cpp and Prolog. Note that +n must be placed <i>after</i> -C or -P in order
      to have any effect.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-U </b><i>arg1 ... arg9</i></dt>
  <dd class="It-tag">User-defined mode. The nine following command-line
      arguments are taken to be respectively the macro start sequence, the macro
      end sequence for a call without arguments, the argument start sequence,
      the argument separator, the argument end sequence, the list of characters
      to stack for argument balancing, the list of characters to unstack, the
      string to be used for referring to an argument by number, and finally the
      quote character (if there is none an empty string should be provided).
      These settings apply both to user macros and to meta-macros, unless the -M
      option is used to define other settings for meta-macros. See the section
      on syntax specification for more details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M </b><i>arg1 ... arg7</i></dt>
  <dd class="It-tag">User-defined mode specifications for meta-macros. This
      option can only be used together with -M. The seven following command-line
      arguments are taken to be respectively the macro start sequence, the macro
      end sequence for a call without arguments, the argument start sequence,
      the argument separator, the argument end sequence, the list of characters
      to stack for argument balancing, and the list of characters to unstack.
      See below for more details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(default mode)</b><i></i></dt>
  <dd class="It-tag">The default mode is a vaguely cpp-like mode, but it does
      not handle comments, and presents various incompatibilities with cpp.
      Typical meta-macros and user macros look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     #define x y
    <br/>
     macro(arg,...)
    <div style="height: 1.00em;">&#x00A0;</div>
    This mode is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     -U &quot;&quot; &quot;&quot; &quot;(&quot; &quot;,&quot; &quot;)&quot;
      &quot;(&quot; &quot;)&quot; &quot;#&quot; &quot;\\&quot;
    <br/>
     -M &quot;#&quot; &quot;\n&quot; &quot; &quot; &quot; &quot; &quot;\n&quot;
      &quot;(&quot; &quot;)&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C</b><i></i></dt>
  <dd class="It-tag">cpp compatibility mode. This is the mode where GPP's
      behavior is the closest to that of cpp. Unlike in the default mode,
      meta-macro expansion occurs only at the beginning of lines, and C comments
      and strings are understood. This mode is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     -n -U &quot;&quot; &quot;&quot; &quot;(&quot; &quot;,&quot; &quot;)&quot;
      &quot;(&quot; &quot;)&quot; &quot;#&quot; &quot;&quot;
    <br/>
     -M &quot;\n#\w&quot; &quot;\n&quot; &quot; &quot; &quot; &quot;
      &quot;\n&quot; &quot;&quot; &quot;&quot;
    <br/>
     +c &quot;/*&quot; &quot;*/&quot; +c &quot;//&quot; &quot;\n&quot; +c
      &quot;\\\n&quot; &quot;&quot;
    <br/>
     +s &quot;\&quot;&quot; &quot;\&quot;&quot; &quot;\\&quot; +s &quot;'&quot;
      &quot;'&quot; &quot;\\&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b><i></i></dt>
  <dd class="It-tag">TeX-like mode. In this mode, typical meta-macros and user
      macros look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     \define{x}{y}
    <br/>
     \macro{arg}{...}
    <div style="height: 1.00em;">&#x00A0;</div>
    No comments are understood. This mode is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     -U &quot;\\&quot; &quot;&quot; &quot;{&quot; &quot;}{&quot; &quot;}&quot;
      &quot;{&quot; &quot;}&quot; &quot;#&quot; &quot;@&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-H</b><i></i></dt>
  <dd class="It-tag">HTML-like mode. In this mode, typical meta-macros and user
      macros look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     &lt;#define x|y&gt;
    <br/>
     &lt;#macro arg|...&gt;
    <div style="height: 1.00em;">&#x00A0;</div>
    No comments are understood. This mode is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     -U &quot;&lt;#&quot; &quot;&gt;&quot; &quot;\B&quot; &quot;|&quot;
      &quot;&gt;&quot; &quot;&lt;&quot; &quot;&gt;&quot; &quot;#&quot;
      &quot;\\&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-X</b><i></i></dt>
  <dd class="It-tag">XHTML-like mode. In this mode, typical meta-macros and user
      macros look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     &lt;#define x|y/&gt;
    <br/>
     &lt;#macro arg|.../&gt;
    <div style="height: 1.00em;">&#x00A0;</div>
    No comments are understood. This mode is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     -U &quot;&lt;#&quot; &quot;/&gt;&quot; &quot;\B&quot; &quot;|&quot;
      &quot;/&gt;&quot; &quot;&lt;&quot; &quot;&gt;&quot; &quot;#&quot;
      &quot;\\&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b><i></i></dt>
  <dd class="It-tag">Prolog-compatible cpp-like mode. This mode differs from the
      cpp compatibility mode by its handling of comments, and is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     -n -U &quot;&quot; &quot;&quot; &quot;(&quot; &quot;,&quot; &quot;)&quot;
      &quot;(&quot; &quot;)&quot; &quot;#&quot; &quot;&quot;
    <br/>
     -M &quot;\n#\w&quot; &quot;\n&quot; &quot; &quot; &quot; &quot;
      &quot;\n&quot; &quot;&quot; &quot;&quot;
    <br/>
     +ccss &quot;\!o/*&quot; &quot;*/&quot; +ccss &quot;%&quot; &quot;\n&quot;
      +ccii &quot;\\\n&quot; &quot;&quot;
    <br/>
     +s &quot;\&quot;&quot; &quot;\&quot;&quot; &quot;&quot; +s &quot;\!#'&quot;
      &quot;'&quot; &quot;&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>+c</b><i>&lt;n&gt; str1 str2</i></dt>
  <dd class="It-tag">Specify comments. Any unquoted occurrence of <i>str1</i>
      will be interpreted as the beginning of a comment. All input up to the
      first following occurrence of <i>str2</i> will be discarded. This option
      may be used multiple times to specify different types of comment
      delimiters. The optional parameter <i>&lt;n&gt;</i> can be specified to
      alter the behavior of the comment and, <i>e.g.</i>, turn it into a string
      or make it ignored under certain circumstances, see below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c </b><i>str1</i></dt>
  <dd class="It-tag">Un-specify comments or strings. The comment/string
      specification whose start sequence is <i>str1</i> is removed. This is
      useful to alter the built-in comment specifications of a standard mode --
      <i>e.g.</i>, the cpp compatibility mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>+s</b><i>&lt;n&gt; str1 str2 c</i></dt>
  <dd class="It-tag">Specify strings. Any unquoted occurrence of <i>str1</i>
      will be interpreted as the beginning of a string. All input up to the
      first following occurrence of <i>str2</i> will be output as is without any
      evaluation. The delimiters themselves are output. If <i>c</i> is
      non-empty, its first character is used as a <i>string-quote character</i>
      -- <i>i.e.</i>, a character whose presence immediately before an
      occurrence of <i>str2</i> prevents it from terminating the string. The
      optional parameter <i>&lt;n&gt;</i> can be specified to alter the behavior
      of the string and, <i>e.g.</i>, turn it into a comment, enable macro
      evaluation inside the string, or make the string specification ignored
      under certain circumstances. See below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s </b><i>str1</i></dt>
  <dd class="It-tag">Un-specify comments or strings. Identical to -c.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--include </b><i>file</i></dt>
  <dd class="It-tag">Process <i>file</i> before <i>infile</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nostdinc</b><i></i></dt>
  <dd class="It-tag">Do not look for include files in the standard directory
      /usr/include.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nocurinc</b><i></i></dt>
  <dd class="It-tag">Do not look for include files in the current
    directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--curdirinclast</b><i></i></dt>
  <dd class="It-tag">Look for include files in the current directory
      <i>after</i> the directories specified by <i>-I</i> rather than before
      them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--warninglevel </b><i>n</i></dt>
  <dd class="It-tag">Set warning level to <i>n</i> (0, 1 or 2). Default is 2
      (most verbose).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--includemarker </b><i>str</i></dt>
  <dd class="It-tag">keep track of <i>#include</i> directives by inserting a
      marker in the output stream. The format of the marker is determined by
      <i>str</i>, which must contain three occurrences of the character <i>%</i>
      (or equivalently <i>?</i>). The first occurrence is replaced with the line
      number, the second with the file name, and the third with 1, 2 or blank.
      When this option is specified in default, cpp or Prolog mode, GPP does its
      best to ensure that line numbers are the same in the output as in the
      input by inserting blank lines in the place of definitions or
    comments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>infile</b><i></i></dt>
  <dd class="It-tag">Specify an input file from which GPP reads its input. If no
      input file is specified, input is read from standard input.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="SYNTAX_SPECIFICATION"><a class="selflink" href="#SYNTAX_SPECIFICATION">SYNTAX
  SPECIFICATION</a></h1>
The syntax of a macro call is as follows: it must start with a sequence of
  characters matching the <i>macro start sequence</i> as specified in the
  current mode, followed immediately by the name of the macro, which must be a
  valid <i>identifier</i> -- <i>i.e.</i>, a sequence of letters, digits, or
  underscores (&quot;_&quot;). The macro name must be followed by a <i>short
  macro end</i> <i>sequence</i> if the macro has no arguments, or by a sequence
  of arguments initiated by an <i>argument start sequence</i>. The various
  arguments are then separated by an <i>argument separator</i>, and the macro
  ends with a <i>long macro end sequence</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
In all cases, the parameters of the current context -- <i>i.e.</i>, the
  arguments passed to the body being evaluated -- can be referred to by using an
  <i>argument reference sequence</i> followed by a digit between 1 and 9.
  Alternatively, macro parameters may be named (see below). Furthermore, to
  avoid interference between the GPP syntax and the contents of the input file,
  a <i>quote character</i> is provided. The quote character can be used to
  prevent the interpretation of a macro call, comment, or string as anything but
  plain text. The quote character &quot;protects&quot; the following character,
  and always gets removed during evaluation. Two consecutive quote characters
  evaluate as a single quote character.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Finally, to facilitate proper argument delimitation, certain characters can be
  &quot;stacked&quot; when they occur in a macro argument, so that the argument
  separator or macro end sequence are not parsed if the argument body is not
  balanced. This allows nesting macro calls without using quotes. If an
  improperly balanced argument is needed, quote characters should be added in
  front of some stacked characters to make it balanced.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The macro construction sequences described above can be different for
  meta-macros and for user macros: this is the case in cpp mode, for example.
  Note that, since meta-macros can only have up to two arguments, the
  delimitation rules for the second argument are somewhat sloppier, and unquoted
  argument separator sequences are allowed in the second argument of a
  meta-macro.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Unless one of the standard operating modes is selected, the above syntax
  sequences can be specified either on the command-line, using the -M and -U
  options respectively for meta-macros and user macros, or inside an input file
  via the <i>#mode meta</i> and <i>#mode user</i> meta-macro calls. In both
  cases the mode description consists of nine parameters for user macro
  specifications, namely the macro start sequence, the short macro end sequence,
  the argument start sequence, the argument separator, the long macro end
  sequence, the string listing characters to stack, the string listing
  characters to unstack, the argument reference sequence, and finally the quote
  character. As explained below, these sequences should be supplied using the
  syntax of C strings; they must start with a non-alphanumeric character, and in
  the first five strings special matching sequences can be used (see below). If
  the argument corresponding to the quote character is the empty string, that
  argument's functionality is disabled. For meta-macro specifications there are
  only seven parameters, as the argument reference sequence and quote character
  are shared with the user macro syntax.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The structure of a comment/string is as follows: it must start with a sequence
  of characters matching the given <i>comment/string start sequence</i>, and
  always ends at the first occurrence of the <i>comment/string end</i>
  <i>sequence</i>, unless it is preceded by an odd number of occurrences of the
  <i>string-quote character</i> (if such a character has been specified). In
  certain cases comment/strings can be specified to enable macro evaluation
  inside the comment/string; in that case, if a quote character has been defined
  for macros it can be used as well to prevent the comment/string from ending,
  with the difference that the macro quote character is always removed from
  output whereas the string-quote character is always output. Also note that
  under certain circumstances a comment/string specification can be
  <i>disabled</i>, in which case the comment/string start sequence is simply
  ignored. Finally, it is possible to specify a <i>string warning character</i>
  whose presence inside a comment/string will cause GPP to output a warning
  (this is useful to locate unterminated strings in cpp mode). Note that input
  files are not allowed to contain unterminated comments/strings.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
A comment/string specification can be declared from within the input file using
  the <i>#mode comment</i> meta-macro call (or equivalently <i>#mode
  string</i>), in which case the number of C strings to be given as arguments to
  describe the comment/string can be anywhere between two and four: the first
  two arguments (mandatory) are the start sequence and the end sequence, and can
  make use of the special matching sequences (see below). They may not start
  with alphanumeric characters. The first character of the third argument, if
  there is one, is used as the string-quote character (use an empty string to
  disable the functionality), and the first character of the fourth argument, if
  there is one, is used as the string-warning character. A specification may
  also be given from the command-line, in which case there must be two arguments
  if using the +c option and three if using the +s option.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The behavior of a comment/string is specified by a three-character modifier
  string, which may be passed as an optional argument either to the +c/+s
  command-line options or to the <i>#mode comment</i>/<i>#mode</i> <i>string</i>
  meta-macros. If no modifier string is specified, the default value is
  &quot;ccc&quot; for comments and &quot;sss&quot; for strings. The first
  character corresponds to the behavior inside meta-macro calls (including
  user-macro definitions since these come inside a <i>#define</i> meta-macro
  call), the second character corresponds to the behavior inside user-macro
  parameters, and the third character corresponds to the behavior outside of any
  macro call. Each of these characters can take the following values:
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>i</b><i></i></dt>
  <dd class="It-tag">disable the comment/string specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>c</b><i></i></dt>
  <dd class="It-tag">comment (neither evaluated nor output).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>s</b><i></i></dt>
  <dd class="It-tag">string (the string and its delimiter sequences are output
      as-is).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>q</b><i></i></dt>
  <dd class="It-tag">quoted string (the string is output as-is, without the
      delimiter sequences).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>C</b><i></i></dt>
  <dd class="It-tag">evaluated comment (macros are evaluated, but output is
      discarded).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>S</b><i></i></dt>
  <dd class="It-tag">evaluated string (macros are evaluated, delimiters are
      output).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Q</b><i></i></dt>
  <dd class="It-tag">evaluated quoted string (macros are evaluated, delimiters
      are not output).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<div class="Pp"></div>
Important note: any occurrence of a comment/string start sequence inside another
  comment/string is always ignored, even if macro evaluation is enabled. In
  other words, comments/strings cannot be nested. In particular, the `Q'
  modifier can be a convenient way of defining a syntax for temporarily
  disabling all comment and string specifications.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Syntax specification strings should always be provided as C strings, whether
  they are given as arguments to a <i>#mode</i> meta-macro call or on the
  command-line of a Unix shell. If command-line arguments are given via another
  method than a standard Unix shell, then the shell behavior must be emulated --
  <i>i.e.</i>, the surrounding &quot;&quot; quotes should be removed, all
  occurrences of `\\' should be replaced by a single backslash, and similarly
  `\&quot;' should be replaced by `&quot;'. Sequences like `\n' are recognized
  by GPP and should be left as is.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Special sequences matching certain subsets of the character set can be used.
  They are of the form `\ <i>x</i>', where <i>x</i> is one of:
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>b</b><i></i></dt>
  <dd class="It-tag">matches any sequence of one or more spaces or tab
      characters (`\b' is identical to `&#x00A0;').</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>w</b><i></i></dt>
  <dd class="It-tag">matches any sequence of zero or more spaces or tab
      characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>B</b><i></i></dt>
  <dd class="It-tag">matches any sequence of one or more spaces, tabs or newline
      characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>W</b><i></i></dt>
  <dd class="It-tag">matches any sequence of zero or more spaces, tabs or
      newline characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>a</b><i></i></dt>
  <dd class="It-tag">an alphabetic character (`a' to `z' and `A' to `Z').</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>A</b><i></i></dt>
  <dd class="It-tag">an alphabetic character, or a space, tab or newline.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#</b><i></i></dt>
  <dd class="It-tag">a digit (`0' to `9').</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>i</b><i></i></dt>
  <dd class="It-tag">an identifier character. The set of matched characters is
      customizable using the <i>#mode charset id</i> command. The default
      setting matches alphanumeric characters and underscores (`a' to `z', `A'
      to `Z', `0' to `9' and `_').</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>t</b><i></i></dt>
  <dd class="It-tag">a tab character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>n</b><i></i></dt>
  <dd class="It-tag">a newline character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>o</b><i></i></dt>
  <dd class="It-tag">an operator character. The set of matched characters is
      customizable using the <i>#mode charset op</i> command. The default
      setting matches all characters in
      &quot;+-*/\^&lt;&gt;=`~:.?@#&amp;!%|&quot;, except in Prolog mode where
      `!', `%' and `|' are not matched.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>O</b><i></i></dt>
  <dd class="It-tag">an operator character or a parenthesis character. The set
      of additional matched characters in comparison with `\o' is customizable
      using the <i>#mode charset par</i> command. The default setting is to have
      the characters in &quot;()[]{}&quot; as parentheses.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<div class="Pp"></div>
Moreover, all of these matching subsets except `\w' and `\W' can be negated by
  inserting a `!' -- <i>i.e.</i>, by writing `\!<i>x</i>' instead of
  `\<i>x</i>'.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Note an important distinctive feature of <i>start sequences</i>: when the first
  character of a macro or comment/string start sequence is '&#x00A0;' or one of
  the above special sequences, it is not taken to be part of the sequence itself
  but is used instead as a context check: for example a start sequence beginning
  with '\n' matches only at the beginning of a line, but the matching newline
  character is not taken to be part of the sequence. Similarly a start sequence
  beginning with '&#x00A0;' matches only if some whitespace is present, but the
  matching whitespace is not considered to be part of the start sequence and is
  therefore sent to output. If a context check is performed at the very
  beginning of a file (or more generally of any body to be evaluated), the
  result is the same as matching with a newline character (this makes it
  possible for a cpp-mode file to start with a meta-macro call).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Two special syntax rules were added in version 2.1. First, argument references
  (# <i>n</i>) are no longer evaluated when they are outside of macro calls and
  definitions. However, they are no longer allowed to appear (unless protected
  by quote characters) inside a call to a defined user macro; the current
  behavior (backwards compatible) is to remove them silently from the input if
  that happens.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Second, if the end sequence (either for macros or comments) consists of a single
  newline character, and if delimitation rules lead to evaluation in a context
  where the final newline character is absent, GPP silently ignores the missing
  newline instead of producing an error. The main consequence is that meta-macro
  calls can now be nested in a simple way in standard, cpp and Prolog modes.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="EVALUATION_RULES"><a class="selflink" href="#EVALUATION_RULES">EVALUATION
  RULES</a></h1>
Input is read sequentially and interpreted according to the rules of the current
  mode. All input text is first matched against the specified comment/string
  start sequences of the current mode (except those which are disabled by the
  'i' modifier), unless the body being evaluated is the contents of a
  comment/string whose modifier enables macro evaluation. The most recently
  defined comment/string specifications are checked for first. Important note:
  comments may not appear between the name of a macro and its arguments (doing
  so results in undefined behavior).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Anything that is not a comment/string is then matched against a possible
  meta-macro call, and if that fails too, against a possible user-macro call.
  All remaining text undergoes substitution of argument reference sequences by
  the relevant argument text (empty unless the body being evaluated is the
  definition of a user macro) and removal of the quote character if there is
  one.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Note that meta-macro arguments are passed to the meta-macro prior to any
  evaluation (although the meta-macro may choose to evaluate them, see
  meta-macro descriptions below). In the case of the <i>#mode</i> meta-macro,
  GPP temporarily adds a comment/string specification to enable recognition of C
  strings (&quot;...&quot;) and prevent any evaluation inside them, so no
  interference of the characters being put in the C string arguments to
  <i>#mode</i> with the current syntax is to be feared.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
On the other hand, the arguments to a user macro are systematically evaluated,
  and then passed as context parameters to the macro definition body, which gets
  evaluated with that environment. The only exception is when the macro
  definition is empty, in which case its arguments are not evaluated. Note that
  GPP temporarily switches back to the mode in which the macro was defined in
  order to evaluate it, so it is perfectly safe to change the operating mode
  between the time a macro is defined and the time when it is called.
  Conversely, if a user macro wishes to work with the current mode instead of
  the one that was used to define it it needs to start with a <i>#mode
  restore</i> call and end with a <i>#mode save</i> call.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
A user macro may be defined with named arguments (see <i>#define</i> description
  below). In that case, when the macro definition is being evaluated, each named
  parameter causes a temporary virtual user-macro definition to be created; such
  a macro may be called only without arguments and simply returns the text of
  the corresponding argument.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Note that, since macros are evaluated when they are called rather than when they
  are defined, any attempt to call a recursive macro causes undefined behavior
  except in the very specific case when the macro uses <i>#undef</i> to erase
  itself after finitely many loop iterations.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Finally, a special case occurs when a user macro whose definition does not
  involve any arguments (neither named arguments nor the argument reference
  sequence) is called in a mode where the short user-macro end sequence is empty
  ( <i>e.g.</i>, cpp or TeX&#x00A0;mode). In that case it is assumed to be an
  <i>alias macro</i>: its arguments are first evaluated in the current mode as
  usual, but instead of being passed to the macro definition as parameters
  (which would cause them to be discarded) they are actually appended to the
  macro definition, using the syntax rules of the mode in which the macro was
  defined, and the resulting text is evaluated again. It is therefore important
  to note that, in the case of a macro alias, the arguments actually get
  evaluated twice in two potentially different modes.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="META-MACROS"><a class="selflink" href="#META-MACROS">META-MACROS</a></h1>
These macros are always predefined. Their actual calling sequence depends on the
  current mode; here we use cpp-like notation.
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#define </b><i>x y</i></dt>
  <dd class="It-tag">This defines the user macro <i>x</i> as <i>y</i>. <i>y</i>
      can be any valid GPP input, and may for example refer to other macros.
      <i>x</i> must be an identifier ( <i>i.e.</i>, a sequence of alphanumeric
      characters and '_'), unless named arguments are specified. If <i>x</i> is
      already defined, the previous definition is overwritten. If no second
      argument is given, <i>x</i> will be defined as a macro that outputs
      nothing. Neither <i>x</i> nor <i>y</i> are evaluated; the macro definition
      is only evaluated when it is called, not when it is declared.
    <div style="height: 1.00em;">&#x00A0;</div>
    It is also possible to name the arguments in a macro definition: in that
      case, the argument <i>x</i> should be a user-macro call whose arguments
      are all identifiers. These identifiers become available as user-macros
      inside the macro definition; these virtual macros must be called without
      arguments, and evaluate to the corresponding macro parameter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#defeval </b><i>x y</i></dt>
  <dd class="It-tag">This acts in a similar way to <i>#define</i>, but the
      second argument <i>y</i> is evaluated immediately. Since user macro
      definitions are also evaluated each time they are called, this means that
      the macro <i>y</i> will undergo <i>two</i> successive evaluations. The
      usefulness of <i>#defeval</i> is considerable as it is the only way to
      evaluate something more than once, which may be needed to force evaluation
      of the arguments of a meta-macro that normally doesn't perform any
      evaluation. However since all argument references evaluated at define-time
      are understood as the arguments of the body in which the macro is being
      defined and not as the arguments of the macro itself, usually one has to
      use the quote character to prevent immediate evaluation of argument
      references.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#undef </b><i>x</i></dt>
  <dd class="It-tag">This removes any existing definition of the user macro
      <i>x</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#ifdef </b><i>x</i></dt>
  <dd class="It-tag">This begins a conditional block. Everything that follows is
      evaluated only if the identifier <i>x</i> is defined, and until either a
      <i>#else</i> or a <i>#endif</i> statement is reached. Note, however, that
      the commented text is still scanned thoroughly, so its syntax must be
      valid. It is in particular legal to have the <i>#else</i> or <i>#endif</i>
      statement ending the conditional block appear only as the result of a
      user-macro expansion and not explicitly in the input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#ifndef </b><i>x</i></dt>
  <dd class="It-tag">This begins a conditional block. Everything that follows is
      evaluated only if the identifier <i>x</i> is not defined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#ifeq </b><i>x y</i></dt>
  <dd class="It-tag">This begins a conditional block. Everything that follows is
      evaluated only if the results of the evaluations of <i>x</i> and <i>y</i>
      are identical as character strings. Any leading or trailing whitespace is
      ignored for the comparison. Note that in cpp-mode any unquoted whitespace
      character is understood as the end of the first argument, so it is
      necessary to be careful.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#ifneq </b><i>x y</i></dt>
  <dd class="It-tag">This begins a conditional block. Everything that follows is
      evaluated only if the results of the evaluations of <i>x</i> and <i>y</i>
      are not identical (even up to leading or trailing whitespace).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#else</b><i></i></dt>
  <dd class="It-tag">This toggles the logical value of the current conditional
      block. What follows is evaluated if and only if the preceding input was
      commented out.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#endif</b><i></i></dt>
  <dd class="It-tag">This ends a conditional block started by a <i>#if...</i>
      meta-macro.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#include </b><i>file</i></dt>
  <dd class="It-tag">This causes GPP to open the specified file and evaluate its
      contents, inserting the resulting text in the current output. All defined
      user macros are still available in the included file, and reciprocally all
      macros defined in the included file will be available in everything that
      follows. The include file is looked for first in the current directory,
      and then, if not found, in one of the directories specified by the
      <i>-I</i> command-line option (or <i>/usr/include</i> if no directory was
      specified). Note that, for compatibility reasons, it is possible to put
      the file name between &quot;&quot; or &lt;&gt;.
    <div style="height: 1.00em;">&#x00A0;</div>
    The order in which the various directories are searched for include files is
      affected by the <i>-nostdinc</i>, <i>-nocurinc</i> and
      <i>-curdirinclast</i> command-line options.
    <div style="height: 1.00em;">&#x00A0;</div>
    Upon including a file, GPP immediately saves a copy of the current operating
      mode onto the mode stack, and restores the operating mode at the end of
      the included file. The included file may override this behavior by
      starting with a <i>#mode restore</i> call and ending with a <i>#mode
      push</i> call. Additionally, when the <i>-m</i> command line option is
      specified, GPP will automatically switch to the cpp compatibility mode
      upon including a file whose name ends with either '.c' or '.h'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#exec </b><i>command</i></dt>
  <dd class="It-tag">This causes GPP to execute the specified command line and
      include its standard output in the current output. Note that, for security
      reasons, this meta-macro is disabled unless the <i>-x</i> command line
      flag was specified. If use of <i>#exec</i> is not allowed, a warning
      message is printed and the output is left blank. Note that the specified
      command line is evaluated before being executed, thus allowing the use of
      macros in the command-line. However, the output of the command is included
      verbatim and not evaluated. If you need the output to be evaluated, you
      must use <i>#defeval</i> (see above) to cause a double evaluation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#eval </b><i>expr</i></dt>
  <dd class="It-tag">The <i>#eval</i> meta-macro attempts to evaluate
      <i>expr</i> first by expanding macros (normal GPP evaluation) and then by
      performing arithmetic evaluation and/or wildcard matching. The syntax and
      operator precedence for arithmetic expressions are the same as in C; the
      only missing operators are &lt;&lt;, &gt;&gt;, ?:, and the assignment
      operators.
    <div style="height: 1.00em;">&#x00A0;</div>
    POSIX-style wildcard matching ('globbing') is available only on POSIX
      implementations and can be invoked with the =~ operator. In brief, a '?'
      matches any single character, a '*' matches any string (including the
      empty string), and '[...]' matches any one of the characters enclosed in
      brackets. A '[...]' class is complemented when the first character in the
      brackets is '!'. The characters in a '[...]' class can also be specified
      as a range using the '-' character -- <i>e.g.</i>, '[F-N]' is equivalent
      to '[FGHIJKLMN]'.
    <div style="height: 1.00em;">&#x00A0;</div>
    If unable to assign a numerical value to the result, the returned text is
      simply the result of macro expansion without any arithmetic evaluation.
      The only exceptions to this rule are the comparison operators ==, !=,
      &lt;, &gt;, &lt;=, and &gt;= which, if one of the sides does not evaluate
      to a number, perform string comparison instead (ignoring trailing and
      leading spaces). Additionally, the <i>length(...)</i> arithmetic operator
      returns the length in characters of its evaluated argument.
    <div style="height: 1.00em;">&#x00A0;</div>
    Inside arithmetic expressions, the <i>defined(...)</i> special user macro is
      also available: it takes only one argument, which is not evaluated, and
      returns 1 if it is the name of a user macro and 0 otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#if </b><i>expr</i></dt>
  <dd class="It-tag">This meta-macro invokes the arithmetic/globbing evaluator
      in the same manner as <i>#eval</i> and compares the result of evaluation
      with the string &quot;0&quot; in order to begin a conditional block. In
      particular note that the logical value of <i>expr</i> is always true when
      it cannot be evaluated to a number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#elif </b><i>expr</i></dt>
  <dd class="It-tag">This meta-macro can be used to avoid nested <i>#if</i>
      conditions. <i>#if</i> ... <i>#elif</i> ... <i>#endif</i> is equivalent to
      <i>#if</i> ... <i>#else</i> <i>#if</i> ... <i>#endif</i>
    <i>#endif</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode </b><i>keyword ...</i></dt>
  <dd class="It-tag">This meta-macro controls GPP's operating mode. See below
      for a list of <i>#mode</i> commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#line</b><i></i></dt>
  <dd class="It-tag">This meta-macro evaluates to the line number of the current
      input file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#file</b><i></i></dt>
  <dd class="It-tag">This meta-macro evaluates to the filename of the current
      input file as it appears on the command line or in the argument to
      <i>#include</i>. If GPP is reading its input from stdin, then <i>#file</i>
      evaluates to `stdin'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#date </b><i>fmt</i></dt>
  <dd class="It-tag">This meta-macro evaluates to the current date and time as
      formatted by the specified format string <i>fmt</i>. See the section
      <i>DATE AND</i> <i>TIME CONVERSION SPECIFIERS</i> below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#error </b><i>msg</i></dt>
  <dd class="It-tag">This meta-macro causes an error message with the current
      filename and line number, and with the text <i>msg</i>, to be printed to
      the standard error device. Subsequent processing is then aborted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#warning </b><i>msg</i></dt>
  <dd class="It-tag">This meta-macro causes a warning message with the current
      filename and line number, and with the text <i>msg</i>, to be printed to
      the standard error device. Subsequent processing is then resumed.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<div class="Pp"></div>
The key to GPP's flexibility is the <i>#mode</i> meta-macro. Its first argument
  is always one of a list of available keywords (see below); its second argument
  is always a sequence of words separated by whitespace. Apart from possibly the
  first of them, each of these words is always a delimiter or syntax specifier,
  and should be provided as a C string delimited by double quotes
  (&quot;&#x00A0;&quot;). The various special matching sequences listed in the
  section on syntax specification are available. Any <i>#mode</i> command is
  parsed in a mode where &quot;...&quot; is understood to be a C-style string,
  so it is safe to put any character inside these strings. Also note that the
  first argument of <i>#mode</i> (the keyword) is never evaluated, while the
  second argument is evaluated (except of course for the contents of C strings),
  so that the syntax specification may be obtained as the result of a macro
  evaluation.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The available <i>#mode</i> commands are:
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode save / #mode push</b><i></i></dt>
  <dd class="It-tag">Push the current mode specification onto the mode
    stack.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode restore / #mode pop</b><i></i></dt>
  <dd class="It-tag">Pop mode specification from the mode stack.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode standard </b><i>name</i></dt>
  <dd class="It-tag">Select one of the standard modes. The only argument must be
      one of: default (default mode); cpp, C (cpp mode); tex, TeX&#x00A0;(tex
      mode); html, HTML (html mode); xhtml, XHTML (xhtml mode); prolog, Prolog
      (prolog mode). The mode name must be given directly, not as a C
    string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode user </b><i>&quot;s1&quot; ...
    &quot;s9&quot;</i></dt>
  <dd class="It-tag">Specify user macro syntax. The 9 arguments, all of them C
      strings, are the mode specification for user macros (see the -U
      command-line option and the section on syntax specification). The
      meta-macro specification is not affected.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode meta </b><i>{user | &quot;s1&quot; ...
    &quot;s7&quot;}</i></dt>
  <dd class="It-tag">Specify meta-macro syntax. Either the only argument is
      <i>user</i> (not as a string), and the user-macro mode specifications are
      copied into the meta-macro mode specifications, or there must be seven
      string arguments, whose significance is the same as for the -M
      command-line option (see section on syntax specification).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode quote </b><i>[&quot;c&quot;]</i></dt>
  <dd class="It-tag">With no argument or &quot;&quot; as argument, removes the
      quote character specification and disables the quoting functionality. With
      one string argument, the first character of the string is taken to be the
      new quote character. The quote character can be neither alphanumeric nor
      '_', nor can it be one of the special matching sequences.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode comment </b><i>[xxx] &quot;start&quot;
    &quot;end&quot; [&quot;c&quot; [&quot;c&quot;]]</i></dt>
  <dd class="It-tag">Add a comment specification. Optionally a first argument
      consisting of three characters not enclosed in &quot;&#x00A0;&quot; can be
      used to specify a comment/string modifier (see the section on syntax
      specification). The default modifier is <i>ccc</i>. The first two string
      arguments are used as comment start and end sequences respectively. The
      third string argument is optional and can be used to specify a
      string-quote character. (If it is &quot;&quot;, the functionality is
      disabled.) The fourth string argument is optional and can be used to
      specify a string delimitation warning character. (If it is &quot;&quot;,
      the functionality is disabled.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode string </b><i>[xxx] &quot;start&quot;
    &quot;end&quot; [&quot;c&quot; [&quot;c&quot;]]</i></dt>
  <dd class="It-tag">Add a string specification. Identical to <i>#mode
      comment</i> except that the default modifier is <i>sss</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode nocomment / #mode nostring
    </b><i>[&quot;start&quot;]</i></dt>
  <dd class="It-tag">With no argument, remove all comment/string specifications.
      With one string argument, delete the comment/string specification whose
      start sequence is the argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode preservelf </b><i>{ on | off | 1 | 0 }</i></dt>
  <dd class="It-tag">Equivalent to the <i>-n</i> command-line switch. If the
      argument is <i>on</i> or <i>1</i>, any newline or whitespace character
      terminating a macro call or a comment/string is left in the input stream
      for further processing. If the argument is <i>off</i> or <i>0</i> this
      feature is disabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#mode charset </b><i>{ id | op | par }
    &quot;string&quot;</i></dt>
  <dd class="It-tag">Specify the character sets to be used for matching the \o,
      \O and \i special sequences. The first argument must be one of <i>id</i>
      (the set matched by \i), <i>op</i> (the set matched by \o) or <i>par</i>
      (the set matched by \O in addition to the one matched by \o).
      <i>&quot;string&quot;</i> is a C string which lists all characters to put
      in the set. It may contain only the special matching sequences \a, \A, \b,
      \B, and \# (the other sequences and the negated sequences are not
      allowed). When a '-' is found inbetween two non-special characters this
      adds all characters inbetween (e.g. &quot;A-Z&quot; corresponds to all
      uppercase characters). To have '-' in the matched set, either put it in
      first or last position or place it next to a \x sequence.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="DATE_AND_TIME_CONVERSION_SPECIFIERS"><a class="selflink" href="#DATE_AND_TIME_CONVERSION_SPECIFIERS">DATE
  AND TIME CONVERSION SPECIFIERS</a></h1>
Ordinary characters placed in the format string are copied to without
  conversion. Conversion specifiers are introduced by a `%' character, and are
  replaced as follows:
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%a</b><i></i></dt>
  <dd class="It-tag">The abbreviated weekday name according to the current
      locale.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%A</b><i></i></dt>
  <dd class="It-tag">The full weekday name according to the current locale.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%b</b><i></i></dt>
  <dd class="It-tag">The abbreviated month name according to the current
    locale.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%B</b><i></i></dt>
  <dd class="It-tag">The full month name according to the current locale.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%c</b><i></i></dt>
  <dd class="It-tag">The preferred date and time representation for the current
      locale.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%d</b><i></i></dt>
  <dd class="It-tag">The day of the month as a decimal number (range 01 to
    31).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%F</b><i></i></dt>
  <dd class="It-tag">Equivalent to %Y-%m-%d (the ISO 8601 date format).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%H</b><i></i></dt>
  <dd class="It-tag">The hour as a decimal number using a 24-hour clock (range
      00 to 23).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%I</b><i></i></dt>
  <dd class="It-tag">The hour as a decimal number using a 12-hour clock (range
      01 to 12).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%j</b><i></i></dt>
  <dd class="It-tag">The day of the year as a decimal number (range 001 to
    366).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%m</b><i></i></dt>
  <dd class="It-tag">The month as a decimal number (range 01 to 12).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%M</b><i></i></dt>
  <dd class="It-tag">The minute as a decimal number (range 00 to 59).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%p</b><i></i></dt>
  <dd class="It-tag">Either `AM' or `PM' according to the given time value, or
      the corresponding strings for the current locale. Noon is treated as `pm'
      and midnight as `am'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%R</b><i></i></dt>
  <dd class="It-tag">The time in 24-hour notation (%H:%M).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%S</b><i></i></dt>
  <dd class="It-tag">The second as a decimal number (range 00 to 61).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%U</b><i></i></dt>
  <dd class="It-tag">The week number of the current year as a decimal number,
      range 00 to 53, starting with the first Sunday as the first day of week
      01.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%w</b><i></i></dt>
  <dd class="It-tag">The day of the week as a decimal, range 0 to 6, Sunday
      being 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%W</b><i></i></dt>
  <dd class="It-tag">The week number of the current year as a decimal number,
      range 00 to 53, starting with the first Monday as the first day of week
      01.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%x</b><i></i></dt>
  <dd class="It-tag">The preferred date representation for the current locale
      without the time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%X</b><i></i></dt>
  <dd class="It-tag">The preferred time representation for the current locale
      without the date.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%y</b><i></i></dt>
  <dd class="It-tag">The year as a decimal number without a century (range 00 to
      99).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%Y</b><i></i></dt>
  <dd class="It-tag">The year as a decimal number including the century.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%Z</b><i></i></dt>
  <dd class="It-tag">The time zone or name or abbreviation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>%%</b><i></i></dt>
  <dd class="It-tag">A literal `%' character.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<div class="Pp"></div>
Depending on the C compiler and library used to compile GPP, there may be more
  conversion specifiers available. Consult your compiler's documentation for the
  <i>strftime()</i> function. Note, however, that any conversion specifiers not
  listed above may not be portable across installations of GPP.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
Here is a basic self-explanatory example in standard or cpp mode:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define FOO This is
<br/>
 #define BAR a message.
<br/>
 #define concat #1 #2
<br/>
 concat(FOO,BAR)
<br/>
 #ifeq (concat(foo,bar)) (foo bar)
<br/>
 This is output.
<br/>
 #else
<br/>
 This is not output.
<br/>
 #endif
<div style="height: 1.00em;">&#x00A0;</div>
Using argument naming, the <i>concat</i> macro could alternatively be defined as
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define concat(x,y) x y
<div style="height: 1.00em;">&#x00A0;</div>
In TeX&#x00A0;mode and using argument naming, the same example becomes:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 \define{FOO}{This is}
<br/>
 \define{BAR}{a message.}
<br/>
 \define{\concat{x}{y}}{\x \y}
<br/>
 \concat{\FOO}{\BAR}
<br/>
 \ifeq{\concat{foo}{bar}}{foo bar}
<br/>
 This is output.
<br/>
 \else
<br/>
 This is not output.
<br/>
 \endif
<div style="height: 1.00em;">&#x00A0;</div>
In HTML mode and without argument naming, one gets similarly:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 &lt;#define FOO|This is&gt;
<br/>
 &lt;#define BAR|a message.&gt;
<br/>
 &lt;#define concat|#1 #2&gt;
<br/>
 &lt;#concat &lt;#FOO&gt;|&lt;#BAR&gt;&gt;
<br/>
 &lt;#ifeq &lt;#concat foo|bar&gt;|foo bar&gt;
<br/>
 This is output.
<br/>
 &lt;#else&gt;
<br/>
 This is not output.
<br/>
 &lt;#endif&gt;
<div style="height: 1.00em;">&#x00A0;</div>
The following example (in standard mode) illustrates the use of the quote
  character:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define FOO This is \
<br/>
 a multiline definition.
<br/>
 #define BLAH(x) My argument is x
<br/>
 BLAH(urf)
<br/>
 \BLAH(urf)
<div style="height: 1.00em;">&#x00A0;</div>
Note that the multiline definition is also valid in cpp and Prolog modes despite
  the absence of quote character, because '\' followed by a newline is then
  interpreted as a comment and discarded.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
In cpp mode, C strings and comments are understood as such, as illustrated by
  the following example:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define BLAH foo
<br/>
 BLAH &quot;BLAH&quot; /* BLAH */
<br/>
 'It\'s a /*string*/ !'
<div style="height: 1.00em;">&#x00A0;</div>
The main difference between Prolog mode and cpp mode is the handling of strings
  and comments: in Prolog, a '...' string may not begin immediately after a
  digit, and a /*...*/ comment may not begin immediately after an operator
  character. Furthermore, comments are not removed from the output unless they
  occur in a #command.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The differences between cpp mode and default mode are deeper: in default mode
  #commands may start anywhere, while in cpp mode they must be at the beginning
  of a line; the default mode has no knowledge of comments and strings, but has
  a quote character ('\'), while cpp mode has extensive comment/string
  specifications but no quote character. Moreover, the arguments to meta-macros
  need to be correctly parenthesized in default mode, while no such checking is
  performed in cpp mode.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
This makes it easier to nest meta-macro calls in default mode than in cpp mode.
  For example, consider the following HTML mode input, which tests for the
  availability of the <i>#exec</i> command:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 &lt;#ifeq &lt;#exec echo blah&gt;|blah
<br/>
 &gt; #exec allowed &lt;#else&gt; #exec not allowed &lt;#endif&gt;
<div style="height: 1.00em;">&#x00A0;</div>
There is no cpp mode equivalent, while in default mode it can be easily
  translated as
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #ifeq (#exec echo blah
<br/>
 ) (blah
<br/>
 )
<br/>
 \#exec allowed
<br/>
 #else
<br/>
 \#exec not allowed
<br/>
 #endif
<div style="height: 1.00em;">&#x00A0;</div>
In order to nest meta-macro calls in cpp mode it is necessary to modify the mode
  description, either by changing the meta-macro call syntax, or more elegantly
  by defining a silent string and using the fact that the context at the
  beginning of an evaluated string is a newline character:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #mode string QQQ &quot;$&quot; &quot;$&quot;
<br/>
 #ifeq $#exec echo blah
<br/>
 $ $blah
<br/>
 $
<br/>
 \#exec allowed
<br/>
 #else
<br/>
 \#exec not allowed
<br/>
 #endif
<div style="height: 1.00em;">&#x00A0;</div>
Note, however, that comments/strings cannot be nested (&quot;...&quot; inside
  $...$ would go undetected), so one needs to be careful about what to include
  inside such a silent evaluated string. In this example, the loose meta-macro
  nesting introduced in version 2.1 makes it possible to use the following
  simpler version:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #ifeq blah #exec echo -n blah
<br/>
 \#exec allowed
<br/>
 #else
<br/>
 \#exec not allowed
<br/>
 #endif
<div style="height: 1.00em;">&#x00A0;</div>
Remember that macros without arguments are actually understood to be aliases
  when they are called with arguments, as illustrated by the following example
  (default or cpp mode):
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define DUP(x) x x
<br/>
 #define FOO and I said: DUP
<br/>
 FOO(blah)
<div style="height: 1.00em;">&#x00A0;</div>
The usefulness of the <i>#defeval</i> meta-macro is shown by the following
  example in HTML mode:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 &lt;#define APPLY|&lt;#defeval TEMP|&lt;\##1 \#1&gt;&gt;&lt;#TEMP #2&gt;&gt;
<br/>
 &lt;#define &lt;#foo x&gt;|&lt;#x&gt; and &lt;#x&gt;&gt;
<br/>
 &lt;#APPLY foo|BLAH&gt;
<div style="height: 1.00em;">&#x00A0;</div>
The reason why <i>#defeval</i> is needed is that, since everything is evaluated
  in a single pass, the input that will result in the desired macro call needs
  to be generated by a first evaluation of the arguments passed to APPLY before
  being evaluated a second time.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To translate this example in default mode, one needs to resort to parenthesizing
  in order to nest the #defeval call inside the definition of APPLY, but need to
  do so without outputting the parentheses. The easiest solution is
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define BALANCE(x) x
<br/>
 #define APPLY(f,v) BALANCE(#defeval TEMP f
<br/>
 TEMP(v))
<br/>
 #define foo(x) x and x
<br/>
 APPLY(\foo,BLAH)
<div style="height: 1.00em;">&#x00A0;</div>
As explained above the simplest version in cpp mode relies on defining a silent
  evaluated string to play the role of the BALANCE macro.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The following example (default or cpp mode) demonstrates arithmetic evaluation:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define x 4
<br/>
 The answer is:
<br/>
 #eval x*x + 2*(16-x) + 1998%x
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #if defined(x)&amp;&amp;!(3*x+5&gt;17)
<br/>
 This should be output.
<br/>
 #endif
<div style="height: 1.00em;">&#x00A0;</div>
To finish, here are some examples involving mode switching. The following
  example is self-explanatory (starting in default mode):
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #mode push
<br/>
 #define f(x) x x
<br/>
 #mode standard tex
<br/>
 \f{blah}
<br/>
 \mode{string}{&quot;$&quot; &quot;$&quot;}
<br/>
 \mode{comment}{&quot;/*&quot; &quot;*/&quot;}
<br/>
 $\f{urf}$ /* blah */
<br/>
 \define{FOO}{bar/* and some more */}
<br/>
 \mode{pop}
<br/>
 f($FOO$)
<div style="height: 1.00em;">&#x00A0;</div>
A good example where a user-defined mode becomes useful is the GPP source of
  this document (available with GPP's source code distribution).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Another interesting application is selectively forcing evaluation of macros in C
  strings when in cpp mode. For example, consider the following input:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define blah(x) &quot;and he said: x&quot;
<br/>
 blah(foo)
<div style="height: 1.00em;">&#x00A0;</div>
Obviously one would want the parameter <i>x</i> to be expanded inside the
  string. There are several ways around this problem:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #mode push
<br/>
 #mode nostring &quot;\&quot;&quot;
<br/>
 #define blah(x) &quot;and he said: x&quot;
<br/>
 #mode pop
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #mode quote &quot;`&quot;
<br/>
 #define blah(x) `&quot;and he said: x`&quot;
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #mode string QQQ &quot;$$&quot; &quot;$$&quot;
<br/>
 #define blah(x) $$&quot;and he said: x&quot;$$
<div style="height: 1.00em;">&#x00A0;</div>
The first method is very natural, but has the inconvenience of being lengthy and
  neutralizing string semantics, so that having an unevaluated instance of 'x'
  in the string, or an occurrence of '/*', would be impossible without resorting
  to further contortions.
<div class="Pp"></div>
The second method is slightly more efficient because the local presence of a
  quote character makes it easier to control what is evaluated and what isn't,
  but has the drawback that it is sometimes impossible to find a reasonable
  quote character without having to either significantly alter the source file
  or enclose it inside a <i>#mode push/pop</i> construct. For example, any
  occurrence of '/*' in the string would have to be quoted.
<div class="Pp"></div>
The last method demonstrates the efficiency of evaluated strings in the context
  of selective evaluation: since comments/strings cannot be nested, any
  occurrence of '&quot;' or '/*' inside the '$$' gets output as plain text, as
  expected inside a string, and only macro evaluation is enabled. Also note that
  there is much more freedom in the choice of a string delimiter than in the
  choice of a quote character.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Starting with version 2.1, meta-macro calls can be nested more efficiently in
  default, cpp and Prolog modes. This makes it easy to make a user version of a
  meta-macro, or to increment a counter:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define myeval #eval #1
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define x 1
<br/>
 #defeval x #eval x+1
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="ADVANCED_EXAMPLES"><a class="selflink" href="#ADVANCED_EXAMPLES">ADVANCED
  EXAMPLES</a></h1>
Here are some examples of advanced constructions using GPP. They tend to be
  pretty awkward and should be considered as evidence of GPP's limitations.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The first example is a recursive macro. The main problem is that (since GPP
  evaluates everything) a recursive macro must be very careful about the way in
  which recursion is terminated in order to avoid undefined behavior (most of
  the time GPP will simply crash). In particular, relying on a
  <i>#if/#else/#endif</i> construct to end recursion is not possible and results
  in an infinite loop, because GPP scans user macro calls even in the
  unevaluated branch of the conditional block. A safe way to proceed is for
  example as follows (we give the example in TeX&#x00A0;mode):
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 \define{countdown}{
<br/>
 \if{#1}
<br/>
 #1...
<br/>
 \define{loop}{\countdown}
<br/>
 \else
<br/>
 Done.
<br/>
 \define{loop}{}
<br/>
 \endif
<br/>
 \loop{\eval{#1-1}}
<br/>
 }
<br/>
 \countdown{10}
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Another example, in cpp mode:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #mode string QQQ &quot;$&quot; &quot;$&quot;
<br/>
 #define triangle(x,y) y \
<br/>
 $#if length(y)&lt;x$ $#define iter triangle$ $#else$ \
<br/>
 $#define iter$ $#endif
<br/>
 $ iter(x,*y)
<br/>
 triangle(20)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The following is an (unfortunately very weak) attempt at implementing functional
  abstraction in GPP (in standard mode). Understanding this example and why it
  can't be made much simpler is an exercise left to the curious reader.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #mode string &quot;`&quot; &quot;`&quot; &quot;\\&quot;
<br/>
 #define ASIS(x) x
<br/>
 #define SILENT(x) ASIS()
<br/>
 #define EVAL(x,f,v) SILENT(
<br/>
 #mode string QQQ &quot;`&quot; &quot;`&quot; &quot;\\&quot;
<br/>
 #defeval TEMP0 x
<br/>
 #defeval TEMP1 (
<br/>
 \#define \TEMP2(TEMP0) f
<br/>
 )
<br/>
 TEMP1
<br/>
 )TEMP2(v)
<br/>
 #define LAMBDA(x,f,v) SILENT(
<br/>
 #ifneq (v) ()
<br/>
 #define TEMP3(a,b,c) EVAL(a,b,c)
<br/>
 #else
<br/>
 #define TEMP3(a,b,c) \LAMBDA(a,b)
<br/>
 #endif
<br/>
 )TEMP3(x,f,v)
<br/>
 #define EVALAMBDA(x,y) SILENT(
<br/>
 #defeval TEMP4 x
<br/>
 #defeval TEMP5 y
<br/>
 )
<br/>
 #define APPLY(f,v) SILENT(
<br/>
 #defeval TEMP6 ASIS(\EVA)f
<br/>
 TEMP6
<br/>
 )EVAL(TEMP4,TEMP5,v)
<div style="height: 1.00em;">&#x00A0;</div>
This yields the following results:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 LAMBDA(z,z+z)
<br/>
 =&gt; LAMBDA(z,z+z)
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 LAMBDA(z,z+z,2)
<br/>
 =&gt; 2+2
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define f LAMBDA(y,y*y)
<br/>
 f
<br/>
 =&gt; LAMBDA(y,y*y)
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 APPLY(f,blah)
<br/>
 =&gt; blah*blah
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 APPLY(LAMBDA(t,t t),(t t))
<br/>
 =&gt; (t t) (t t)
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 LAMBDA(x,APPLY(f,(x+x)),urf)
<br/>
 =&gt; (urf+urf)*(urf+urf)
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 APPLY(APPLY(LAMBDA(x,LAMBDA(y,x*y)),foo),bar)
<br/>
 =&gt; foo*bar
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #define test LAMBDA(y,`#ifeq y urf
<br/>
 y is urf#else
<br/>
 y is not urf#endif
<br/>
 `)
<br/>
 APPLY(test,urf)
<br/>
 =&gt; urf is urf
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 APPLY(test,foo)
<br/>
 =&gt; foo is not urf
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
strftime(3), glob(7), m4(1V), cpp(1)
<div class="Pp"></div>
GPP home page: http://www.nothingisreal.com/gpp/
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
GPP was written by Denis Auroux &lt;auroux@math.mit.edu&gt;. Since version 2.12
  it has been maintained by Tristan Miller &lt;psychonaut@nothingisreal.com&gt;.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (C)&#x00A0;1996-2001 Denis Auroux.
<div class="Pp"></div>
Copyright (C)&#x00A0;2003, 2004 Tristan Miller.
<div class="Pp"></div>
Permission is granted to anyone to make or distribute verbatim copies of this
  document as received, in any medium, provided that the copyright notice and
  this permission notice are preserved, thus giving the recipient permission to
  redistribute in turn.
<div class="Pp"></div>
Permission is granted to distribute modified versions of this document, or of
  portions of it, under the above conditions, provided also that they carry
  prominent notices stating who last changed them.</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
