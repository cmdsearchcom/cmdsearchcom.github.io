<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:15:00 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GPP(1) General Commands Manual GPP(1)</p>

<p style="margin-top: 1em">NAME <br>
GPP - Generic Preprocessor</p>

<p style="margin-top: 1em">SYNOPSIS <br>
gpp [-{o|O} outfile] [-I/include/path] [-Dname=val ...] <br>
[-z|+z] [-x] [-m] [-C|-T|-H|-X|-P|-U ... [-M ...]] <br>
[-n|+n] [+c&lt;n&gt; str1 str2] [+s&lt;n&gt; str1 str2 c]
<br>
[-c str1] [--nostdinc] [--nocurinc] <br>
[--curdirinclast] [--warninglevel n] <br>
[--includemarker str] [--include file] <br>
[infile]</p>

<p style="margin-top: 1em">gpp --help</p>

<p style="margin-top: 1em">gpp --version</p>

<p style="margin-top: 1em">DESCRIPTION <br>
GPP is a general-purpose preprocessor with customizable
syntax, suitable for a wide range of preprocessing tasks.
Its independence from any programming language makes it much
<br>
more versatile than cpp, while its syntax is lighter and
more flexible than that of m4.</p>

<p style="margin-top: 1em">GPP is targeted at all common
preprocessing tasks where cpp is not suitable and where no
very sophisticated features are needed. In order to be able
to process equally effi&acirc; <br>
ciently text files or source code in a variety of languages,
the syntax used by GPP is fully customizable. The handling
of comments and strings is especially advanced.</p>

<p style="margin-top: 1em">Initially, GPP only understands
a minimal set of built-in macros, called meta-macros. These
meta-macros allow the definition of user macros as well as
some basic operations form&acirc; <br>
ing the core of the preprocessing system, including
conditional tests, arithmetic evaluation, wildcard matching
(globbing), and syntax specification. All user macro
definitions <br>
are global -- i.e., they remain valid until explicitly
removed; meta-macros cannot be redefined. With each user
macro definition GPP keeps track of the corresponding syntax
spec&acirc; <br>
ification so that a macro can be safely invoked regardless
of any subsequent change in operating mode.</p>

<p style="margin-top: 1em">In addition to macros, GPP
understands comments and strings, whose syntax and behavior
can be widely customized to fit any particular purpose.
Internally comments and strings <br>
are the same construction, so everything that applies to
comments applies to strings as well.</p>

<p style="margin-top: 1em">OPTIONS <br>
GPP recognizes the following command-line switches and
options. Note that the -nostdinc, -nocurinc, -curdirinclast,
-warninglevel, and -includemarker options from version 2.1
<br>
and earlier are deprecated and should not be used. Use the
&quot;long option&quot; variants instead (--nostdinc,
etc.).</p>

<p style="margin-top: 1em">-h --help <br>
Print a short help message.</p>

<p style="margin-top: 1em">--version <br>
Print version information.</p>

<p style="margin-top: 1em">-o outfile <br>
Specify a file to which all output should be sent (by
default, everything is sent to standard output).</p>

<p style="margin-top: 1em">-O outfile <br>
Specify a file to which all output should be sent; output is
simultanously sent to stdout.</p>

<p style="margin-top: 1em">-I/include/path <br>
Specify a path where the #include meta-macro will look for
include files if they are not present in the current
directory. The default is /usr/include if no -I option is
<br>
specified. Multiple -I options may be specified to look in
several directories.</p>

<p style="margin-top: 1em">-Dname=val <br>
Define the user macro name as equal to val. This is strictly
equivalent to using the #define meta-macro, but makes it
possible to define macros from the command-line. If <br>
val makes references to arguments or other macros, it should
conform to the syntax of the mode specified on the
command-line. Starting with version 2.1, macro argument <br>
naming is allowed on the command-line. The syntax is as
follows: -Dmacro(arg1,...)=definition. The arguments are
specified in C-style syntax, without any whitespace, but
<br>
the definition should still conform to the syntax of the
mode specified on the command-line.</p>

<p style="margin-top: 1em">+z Set text mode to Unix mode
(LF terminator). Any CR character in the input is
systematically discarded. This is the default under Unix
systems.</p>

<p style="margin-top: 1em">-z Set text mode to DOS mode
(CR-LF terminator). In this mode all CR characters are
removed from the input, and all output LF characters are
converted to CR-LF. This is the <br>
default if GPP is compiled with the WIN_NT option.</p>

<p style="margin-top: 1em">-x Enable the use of the #exec
meta-macro. Since #exec includes the output of an arbitrary
shell command line, it may cause a potential security
threat, and is thus disabled <br>
unless this option is specified.</p>

<p style="margin-top: 1em">-m Enable automatic mode
switching to the cpp compatibility mode if the name of an
included file ends in &lsquo;.h&rsquo; or &lsquo;.c&rsquo;.
This makes it possible to include C header files with <br>
only minor modifications.</p>

<p style="margin-top: 1em">-n Prevent newline or whitespace
characters from being removed from the input when they occur
as the end of a macro call or of a comment. By default, when
a newline or white&acirc; <br>
space character forms the end of a macro or a comment it is
parsed as part of the macro call or comment and therefore
removed from output. Use the -n option to keep the <br>
last character in the input stream if it was whitespace or a
newline. This is activated in cpp and Prolog modes.</p>

<p style="margin-top: 1em">+n The opposite of -n. This is
the default in all modes except cpp and Prolog. Note that +n
must be placed after -C or -P in order to have any
effect.</p>

<p style="margin-top: 1em">-U arg1 ... arg9 <br>
User-defined mode. The nine following command-line arguments
are taken to be respectively the macro start sequence, the
macro end sequence for a call without arguments, <br>
the argument start sequence, the argument separator, the
argument end sequence, the list of characters to stack for
argument balancing, the list of characters to unstack, <br>
the string to be used for referring to an argument by
number, and finally the quote character (if there is none an
empty string should be provided). These settings apply <br>
both to user macros and to meta-macros, unless the -M option
is used to define other settings for meta-macros. See the
section on syntax specification for more details.</p>

<p style="margin-top: 1em">-M arg1 ... arg7 <br>
User-defined mode specifications for meta-macros. This
option can only be used together with -M. The seven
following command-line arguments are taken to be
respectively <br>
the macro start sequence, the macro end sequence for a call
without arguments, the argument start sequence, the argument
separator, the argument end sequence, the list of <br>
characters to stack for argument balancing, and the list of
characters to unstack. See below for more details.</p>

<p style="margin-top: 1em">(default mode) <br>
The default mode is a vaguely cpp-like mode, but it does not
handle comments, and presents various incompatibilities with
cpp. Typical meta-macros and user macros look <br>
like this:</p>

<p style="margin-top: 1em">#define x y <br>
macro(arg,...)</p>

<p style="margin-top: 1em">This mode is equivalent to</p>

<p style="margin-top: 1em">-U &quot;&quot; &quot;&quot;
&quot;(&quot; &quot;,&quot; &quot;)&quot; &quot;(&quot;
&quot;)&quot; &quot;#&quot; &quot;\&quot; <br>
-M &quot;#&quot; &quot;0 &quot; &quot; &quot; &quot; &quot;0
&quot;(&quot; &quot;)&quot;</p>

<p style="margin-top: 1em">-C cpp compatibility mode. This
is the mode where GPP&rsquo;s behavior is the closest to
that of cpp. Unlike in the default mode, meta-macro
expansion occurs only at the beginning <br>
of lines, and C comments and strings are understood. This
mode is equivalent to</p>

<p style="margin-top: 1em">-n -U &quot;&quot; &quot;&quot;
&quot;(&quot; &quot;,&quot; &quot;)&quot; &quot;(&quot;
&quot;)&quot; &quot;#&quot; &quot;&quot; <br>
-M &quot;0240 &quot; &quot; &quot; &quot; &quot;0
&quot;&quot; &quot;&quot; <br>
+c &quot;/*&quot; &quot;*/&quot; +c &quot;//&quot; &quot;0
+c &quot;\0 &quot;&quot; <br>
+s &quot;</p>

<p style="margin-top: 1em">-T TeX-like mode. In this mode,
typical meta-macros and user macros look like this:</p>

<p style="margin-top: 1em">efine{x}{y} <br>
cro{arg}{...}</p>

<p style="margin-top: 1em">No comments are understood. This
mode is equivalent to</p>

<p style="margin-top: 1em">-U &quot;\&quot; &quot;&quot;
&quot;{&quot; &quot;}{&quot; &quot;}&quot; &quot;{&quot;
&quot;}&quot; &quot;#&quot; &quot;@&quot;</p>

<p style="margin-top: 1em">-H HTML-like mode. In this mode,
typical meta-macros and user macros look like this:</p>

<p style="margin-top: 1em">&lt;#define x|y&gt; <br>
&lt;#macro arg|...&gt;</p>

<p style="margin-top: 1em">No comments are understood. This
mode is equivalent to</p>

<p style="margin-top: 1em">-U &quot;&lt;#&quot;
&quot;&gt;&quot; &quot;0|&quot; &quot;&gt;&quot;
&quot;&lt;&quot; &quot;&gt;&quot; &quot;#&quot;
&quot;\&quot;</p>

<p style="margin-top: 1em">-X XHTML-like mode. In this
mode, typical meta-macros and user macros look like
this:</p>

<p style="margin-top: 1em">&lt;#define x|y/&gt; <br>
&lt;#macro arg|.../&gt;</p>

<p style="margin-top: 1em">No comments are understood. This
mode is equivalent to</p>

<p style="margin-top: 1em">-U &quot;&lt;#&quot;
&quot;/&gt;&quot; &quot;0|&quot; &quot;/&gt;&quot;
&quot;&lt;&quot; &quot;&gt;&quot; &quot;#&quot;
&quot;\&quot;</p>

<p style="margin-top: 1em">-P Prolog-compatible cpp-like
mode. This mode differs from the cpp compatibility mode by
its handling of comments, and is equivalent to</p>

<p style="margin-top: 1em">-n -U &quot;&quot; &quot;&quot;
&quot;(&quot; &quot;,&quot; &quot;)&quot; &quot;(&quot;
&quot;)&quot; &quot;#&quot; &quot;&quot; <br>
-M &quot;0240 &quot; &quot; &quot; &quot; &quot;0
&quot;&quot; &quot;&quot; <br>
+ccss &quot;o/*&quot; &quot;*/&quot; +ccss &quot;%&quot;
&quot;0 +ccii &quot;\0 &quot;&quot; <br>
+s &quot;</p>

<p style="margin-top: 1em">+c&lt;n&gt; str1 str2 <br>
Specify comments. Any unquoted occurrence of str1 will be
interpreted as the beginning of a comment. All input up to
the first following occurrence of str2 will be dis&acirc;
<br>
carded. This option may be used multiple times to specify
different types of comment delimiters. The optional
parameter &lt;n&gt; can be specified to alter the behavior
of the <br>
comment and, e.g., turn it into a string or make it ignored
under certain circumstances, see below.</p>

<p style="margin-top: 1em">-c str1 <br>
Un-specify comments or strings. The comment/string
specification whose start sequence is str1 is removed. This
is useful to alter the built-in comment specifications of a
<br>
standard mode -- e.g., the cpp compatibility mode.</p>

<p style="margin-top: 1em">+s&lt;n&gt; str1 str2 c <br>
Specify strings. Any unquoted occurrence of str1 will be
interpreted as the beginning of a string. All input up to
the first following occurrence of str2 will be output as
<br>
is without any evaluation. The delimiters themselves are
output. If c is non-empty, its first character is used as a
string-quote character -- i.e., a character whose <br>
presence immediately before an occurrence of str2 prevents
it from terminating the string. The optional parameter
&lt;n&gt; can be specified to alter the behavior of the
string <br>
and, e.g., turn it into a comment, enable macro evaluation
inside the string, or make the string specification ignored
under certain circumstances. See below.</p>

<p style="margin-top: 1em">-s str1 <br>
Un-specify comments or strings. Identical to -c.</p>

<p style="margin-top: 1em">--include file <br>
Process file before infile</p>

<p style="margin-top: 1em">--nostdinc <br>
Do not look for include files in the standard directory
/usr/include.</p>

<p style="margin-top: 1em">--nocurinc <br>
Do not look for include files in the current directory.</p>

<p style="margin-top: 1em">--curdirinclast <br>
Look for include files in the current directory after the
directories specified by -I rather than before them.</p>

<p style="margin-top: 1em">--warninglevel n <br>
Set warning level to n (0, 1 or 2). Default is 2 (most
verbose).</p>

<p style="margin-top: 1em">--includemarker str <br>
keep track of #include directives by inserting a marker in
the output stream. The format of the marker is determined by
str, which must contain three occurrences of the <br>
character % (or equivalently ?). The first occurrence is
replaced with the line number, the second with the file
name, and the third with 1, 2 or blank. When this option
<br>
is specified in default, cpp or Prolog mode, GPP does its
best to ensure that line numbers are the same in the output
as in the input by inserting blank lines in the place <br>
of definitions or comments.</p>

<p style="margin-top: 1em">infile Specify an input file
from which GPP reads its input. If no input file is
specified, input is read from standard input.</p>

<p style="margin-top: 1em">SYNTAX SPECIFICATION <br>
The syntax of a macro call is as follows: it must start with
a sequence of characters matching the macro start sequence
as specified in the current mode, followed immediately by
<br>
the name of the macro, which must be a valid identifier --
i.e., a sequence of letters, digits, or underscores
(&quot;_&quot;). The macro name must be followed by a short
macro end <br>
sequence if the macro has no arguments, or by a sequence of
arguments initiated by an argument start sequence. The
various arguments are then separated by an argument
separator, <br>
and the macro ends with a long macro end sequence.</p>

<p style="margin-top: 1em">In all cases, the parameters of
the current context -- i.e., the arguments passed to the
body being evaluated -- can be referred to by using an
argument reference sequence fol&acirc; <br>
lowed by a digit between 1 and 9. Alternatively, macro
parameters may be named (see below). Furthermore, to avoid
interference between the GPP syntax and the contents of the
<br>
input file, a quote character is provided. The quote
character can be used to prevent the interpretation of a
macro call, comment, or string as anything but plain text.
The quote <br>
character &quot;protects&quot; the following character, and
always gets removed during evaluation. Two consecutive quote
characters evaluate as a single quote character.</p>

<p style="margin-top: 1em">Finally, to facilitate proper
argument delimitation, certain characters can be
&quot;stacked&quot; when they occur in a macro argument, so
that the argument separator or macro end sequence <br>
are not parsed if the argument body is not balanced. This
allows nesting macro calls without using quotes. If an
improperly balanced argument is needed, quote characters
should <br>
be added in front of some stacked characters to make it
balanced.</p>

<p style="margin-top: 1em">The macro construction sequences
described above can be different for meta-macros and for
user macros: this is the case in cpp mode, for example. Note
that, since meta-macros <br>
can only have up to two arguments, the delimitation rules
for the second argument are somewhat sloppier, and unquoted
argument separator sequences are allowed in the second
argu&acirc; <br>
ment of a meta-macro.</p>

<p style="margin-top: 1em">Unless one of the standard
operating modes is selected, the above syntax sequences can
be specified either on the command-line, using the -M and -U
options respectively for meta- <br>
macros and user macros, or inside an input file via the
#mode meta and #mode user meta-macro calls. In both cases
the mode description consists of nine parameters for user
macro <br>
specifications, namely the macro start sequence, the short
macro end sequence, the argument start sequence, the
argument separator, the long macro end sequence, the string
list&acirc; <br>
ing characters to stack, the string listing characters to
unstack, the argument reference sequence, and finally the
quote character. As explained below, these sequences should
be <br>
supplied using the syntax of C strings; they must start with
a non-alphanumeric character, and in the first five strings
special matching sequences can be used (see below). If <br>
the argument corresponding to the quote character is the
empty string, that argument&rsquo;s functionality is
disabled. For meta-macro specifications there are only seven
parameters, <br>
as the argument reference sequence and quote character are
shared with the user macro syntax.</p>

<p style="margin-top: 1em">The structure of a
comment/string is as follows: it must start with a sequence
of characters matching the given comment/string start
sequence, and always ends at the first occur&acirc; <br>
rence of the comment/string end sequence, unless it is
preceded by an odd number of occurrences of the string-quote
character (if such a character has been specified). In
cer&acirc; <br>
tain cases comment/strings can be specified to enable macro
evaluation inside the comment/string; in that case, if a
quote character has been defined for macros it can be used
as <br>
well to prevent the comment/string from ending, with the
difference that the macro quote character is always removed
from output whereas the string-quote character is always
out&acirc; <br>
put. Also note that under certain circumstances a
comment/string specification can be disabled, in which case
the comment/string start sequence is simply ignored.
Finally, it is <br>
possible to specify a string warning character whose
presence inside a comment/string will cause GPP to output a
warning (this is useful to locate unterminated strings in
cpp <br>
mode). Note that input files are not allowed to contain
unterminated comments/strings.</p>

<p style="margin-top: 1em">A comment/string specification
can be declared from within the input file using the #mode
comment meta-macro call (or equivalently #mode string), in
which case the number of C <br>
strings to be given as arguments to describe the
comment/string can be anywhere between two and four: the
first two arguments (mandatory) are the start sequence and
the end <br>
sequence, and can make use of the special matching sequences
(see below). They may not start with alphanumeric
characters. The first character of the third argument, if
there is <br>
one, is used as the string-quote character (use an empty
string to disable the functionality), and the first
character of the fourth argument, if there is one, is used
as the <br>
string-warning character. A specification may also be given
from the command-line, in which case there must be two
arguments if using the +c option and three if using the +s
<br>
option.</p>

<p style="margin-top: 1em">The behavior of a comment/string
is specified by a three-character modifier string, which may
be passed as an optional argument either to the +c/+s
command-line options or to the <br>
#mode comment/#mode string meta-macros. If no modifier
string is specified, the default value is &quot;ccc&quot;
for comments and &quot;sss&quot; for strings. The first
character corresponds to the <br>
behavior inside meta-macro calls (including user-macro
definitions since these come inside a #define meta-macro
call), the second character corresponds to the behavior
inside <br>
user-macro parameters, and the third character corresponds
to the behavior outside of any macro call. Each of these
characters can take the following values:</p>

<p style="margin-top: 1em">i disable the comment/string
specification.</p>

<p style="margin-top: 1em">c comment (neither evaluated nor
output).</p>

<p style="margin-top: 1em">s string (the string and its
delimiter sequences are output as-is).</p>

<p style="margin-top: 1em">q quoted string (the string is
output as-is, without the delimiter sequences).</p>

<p style="margin-top: 1em">C evaluated comment (macros are
evaluated, but output is discarded).</p>

<p style="margin-top: 1em">S evaluated string (macros are
evaluated, delimiters are output).</p>

<p style="margin-top: 1em">Q evaluated quoted string
(macros are evaluated, delimiters are not output).</p>

<p style="margin-top: 1em">Important note: any occurrence
of a comment/string start sequence inside another
comment/string is always ignored, even if macro evaluation
is enabled. In other words, com&acirc; <br>
ments/strings cannot be nested. In particular, the
&lsquo;Q&rsquo; modifier can be a convenient way of defining
a syntax for temporarily disabling all comment and string
specifications.</p>

<p style="margin-top: 1em">Syntax specification strings
should always be provided as C strings, whether they are
given as arguments to a #mode meta-macro call or on the
command-line of a Unix shell. If <br>
command-line arguments are given via another method than a
standard Unix shell, then the shell behavior must be
emulated -- i.e., the surrounding &quot;&quot; quotes should
be removed, all <br>
occurrences of &lsquo;\&rsquo; should be replaced by a
single backslash, and similarly &lsquo;</p>

<p style="margin-top: 1em">Special sequences matching
certain subsets of the character set can be used. They are
of the form &lsquo; where x is one of:</p>

<p style="margin-top: 1em">b matches any sequence of one or
more spaces or tab i s i d e n t characters (&lsquo;i). c a
l t o &lsquo;</p>

<p style="margin-top: 1em">w matches any sequence of zero
or more spaces or tab characters.</p>

<p style="margin-top: 1em">B matches any sequence of one or
more spaces, tabs or newline characters.</p>

<p style="margin-top: 1em">W matches any sequence of zero
or more spaces, tabs or newline characters.</p>

<p style="margin-top: 1em">a an alphabetic character
(&lsquo;a&rsquo; to &lsquo;z&rsquo; and &lsquo;A&rsquo; to
&lsquo;Z&rsquo;).</p>

<p style="margin-top: 1em">A an alphabetic character, or a
space, tab or newline.</p>

<p style="margin-top: 1em"># a digit (&lsquo;0&rsquo; to
&lsquo;9&rsquo;).</p>

<p style="margin-top: 1em">i an identifier character. The
set of matched characters is customizable using the #mode
charset id command. The default setting matches alphanumeric
characters and under&acirc; <br>
scores (&lsquo;a&rsquo; to &lsquo;z&rsquo;, &lsquo;A&rsquo;
to &lsquo;Z&rsquo;, &lsquo;0&rsquo; to &lsquo;9&rsquo; and
&lsquo;_&rsquo;).</p>

<p style="margin-top: 1em">t a tab character.</p>

<p style="margin-top: 1em">n a newline character.</p>

<p style="margin-top: 1em">o an operator character. The set
of matched characters is customizable using the #mode
charset op command. The default setting matches all
characters in <br>
&quot;+-*/&lt;&gt;=&lsquo;~:.?@#&amp;!%|&quot;, except in
Prolog mode where &lsquo;!&rsquo;, &lsquo;%&rsquo; and
&lsquo;|&rsquo; are not matched.</p>

<p style="margin-top: 1em">O an operator character or a
parenthesis character. The set of additional matched
characters in comparison with &lsquo;e <br>
default setting is to have the characters in
&quot;()[]{}&quot; as parentheses.</p>

<p style="margin-top: 1em">Moreover, all of these matching
subsets except &lsquo;168 can be negated by inserting a
&lsquo;!&rsquo; -- i.e., by writing &lsquo;x&rsquo; instead
of &lsquo; <br>
Note an important distinctive feature of start sequences:
when the first character of a macro or comment/string start
sequence is &rsquo; &rsquo; or one of the above special
sequences, it is <br>
not taken to be part of the sequence itself but is used
instead as a context check: for example a start sequence
beginning with &rsquo;0 matches only at the beginning of a
line, but <br>
the matching newline character is not taken to be part of
the sequence. Similarly a start sequence beginning with
&rsquo; &rsquo; matches only if some whitespace is present,
but the match&acirc; <br>
ing whitespace is not considered to be part of the start
sequence and is therefore sent to output. If a context check
is performed at the very beginning of a file (or more
gener&acirc; <br>
ally of any body to be evaluated), the result is the same as
matching with a newline character (this makes it possible
for a cpp-mode file to start with a meta-macro call).</p>

<p style="margin-top: 1em">Two special syntax rules were
added in version 2.1. First, argument references (#n) are no
longer evaluated when they are outside of macro calls and
definitions. However, they <br>
are no longer allowed to appear (unless protected by quote
characters) inside a call to a defined user macro; the
current behavior (backwards compatible) is to remove them
<br>
silently from the input if that happens.</p>

<p style="margin-top: 1em">Second, if the end sequence
(either for macros or comments) consists of a single newline
character, and if delimitation rules lead to evaluation in a
context where the final new&acirc; <br>
line character is absent, GPP silently ignores the missing
newline instead of producing an error. The main consequence
is that meta-macro calls can now be nested in a simple way
<br>
in standard, cpp and Prolog modes.</p>

<p style="margin-top: 1em">EVALUATION RULES <br>
Input is read sequentially and interpreted according to the
rules of the current mode. All input text is first matched
against the specified comment/string start sequences of the
<br>
current mode (except those which are disabled by the
&rsquo;i&rsquo; modifier), unless the body being evaluated
is the contents of a comment/string whose modifier enables
macro evaluation. <br>
The most recently defined comment/string specifications are
checked for first. Important note: comments may not appear
between the name of a macro and its arguments (doing so <br>
results in undefined behavior).</p>

<p style="margin-top: 1em">Anything that is not a
comment/string is then matched against a possible meta-macro
call, and if that fails too, against a possible user-macro
call. All remaining text undergoes <br>
substitution of argument reference sequences by the relevant
argument text (empty unless the body being evaluated is the
definition of a user macro) and removal of the quote <br>
character if there is one.</p>

<p style="margin-top: 1em">Note that meta-macro arguments
are passed to the meta-macro prior to any evaluation
(although the meta-macro may choose to evaluate them, see
meta-macro descriptions below). In <br>
the case of the #mode meta-macro, GPP temporarily adds a
comment/string specification to enable recognition of C
strings (&quot;...&quot;) and prevent any evaluation inside
them, so no <br>
interference of the characters being put in the C string
arguments to #mode with the current syntax is to be
feared.</p>

<p style="margin-top: 1em">On the other hand, the arguments
to a user macro are systematically evaluated, and then
passed as context parameters to the macro definition body,
which gets evaluated with that <br>
environment. The only exception is when the macro definition
is empty, in which case its arguments are not evaluated.
Note that GPP temporarily switches back to the mode in which
<br>
the macro was defined in order to evaluate it, so it is
perfectly safe to change the operating mode between the time
a macro is defined and the time when it is called.
Con&acirc; <br>
versely, if a user macro wishes to work with the current
mode instead of the one that was used to define it it needs
to start with a #mode restore call and end with a #mode save
<br>
call.</p>

<p style="margin-top: 1em">A user macro may be defined with
named arguments (see #define description below). In that
case, when the macro definition is being evaluated, each
named parameter causes a tempo&acirc; <br>
rary virtual user-macro definition to be created; such a
macro may be called only without arguments and simply
returns the text of the corresponding argument.</p>

<p style="margin-top: 1em">Note that, since macros are
evaluated when they are called rather than when they are
defined, any attempt to call a recursive macro causes
undefined behavior except in the very <br>
specific case when the macro uses #undef to erase itself
after finitely many loop iterations.</p>

<p style="margin-top: 1em">Finally, a special case occurs
when a user macro whose definition does not involve any
arguments (neither named arguments nor the argument
reference sequence) is called in a mode <br>
where the short user-macro end sequence is empty (e.g., cpp
or TeX mode). In that case it is assumed to be an alias
macro: its arguments are first evaluated in the current mode
<br>
as usual, but instead of being passed to the macro
definition as parameters (which would cause them to be
discarded) they are actually appended to the macro
definition, using the <br>
syntax rules of the mode in which the macro was defined, and
the resulting text is evaluated again. It is therefore
important to note that, in the case of a macro alias, the
<br>
arguments actually get evaluated twice in two potentially
different modes.</p>

<p style="margin-top: 1em">META-MACROS <br>
These macros are always predefined. Their actual calling
sequence depends on the current mode; here we use cpp-like
notation.</p>

<p style="margin-top: 1em">#define x y <br>
This defines the user macro x as y. y can be any valid GPP
input, and may for example refer to other macros. x must be
an identifier (i.e., a sequence of alphanumeric <br>
characters and &rsquo;_&rsquo;), unless named arguments are
specified. If x is already defined, the previous definition
is overwritten. If no second argument is given, x will be
<br>
defined as a macro that outputs nothing. Neither x nor y are
evaluated; the macro definition is only evaluated when it is
called, not when it is declared.</p>

<p style="margin-top: 1em">It is also possible to name the
arguments in a macro definition: in that case, the argument
x should be a user-macro call whose arguments are all
identifiers. These iden&acirc; <br>
tifiers become available as user-macros inside the macro
definition; these virtual macros must be called without
arguments, and evaluate to the corresponding macro
parame&acirc; <br>
ter.</p>

<p style="margin-top: 1em">#defeval x y <br>
This acts in a similar way to #define, but the second
argument y is evaluated immediately. Since user macro
definitions are also evaluated each time they are called,
this <br>
means that the macro y will undergo two successive
evaluations. The usefulness of #defeval is considerable as
it is the only way to evaluate something more than once,
<br>
which may be needed to force evaluation of the arguments of
a meta-macro that normally doesn&rsquo;t perform any
evaluation. However since all argument references evaluated
at <br>
define-time are understood as the arguments of the body in
which the macro is being defined and not as the arguments of
the macro itself, usually one has to use the quote <br>
character to prevent immediate evaluation of argument
references.</p>

<p style="margin-top: 1em">#undef x <br>
This removes any existing definition of the user macro
x.</p>

<p style="margin-top: 1em">#ifdef x <br>
This begins a conditional block. Everything that follows is
evaluated only if the identifier x is defined, and until
either a #else or a #endif statement is reached. Note, <br>
however, that the commented text is still scanned
thoroughly, so its syntax must be valid. It is in particular
legal to have the #else or #endif statement ending the
con&acirc; <br>
ditional block appear only as the result of a user-macro
expansion and not explicitly in the input.</p>

<p style="margin-top: 1em">#ifndef x <br>
This begins a conditional block. Everything that follows is
evaluated only if the identifier x is not defined.</p>

<p style="margin-top: 1em">#ifeq x y <br>
This begins a conditional block. Everything that follows is
evaluated only if the results of the evaluations of x and y
are identical as character strings. Any leading or <br>
trailing whitespace is ignored for the comparison. Note that
in cpp-mode any unquoted whitespace character is understood
as the end of the first argument, so it is neces&acirc; <br>
sary to be careful.</p>

<p style="margin-top: 1em">#ifneq x y <br>
This begins a conditional block. Everything that follows is
evaluated only if the results of the evaluations of x and y
are not identical (even up to leading or trailing <br>
whitespace).</p>

<p style="margin-top: 1em">#else This toggles the logical
value of the current conditional block. What follows is
evaluated if and only if the preceding input was commented
out.</p>

<p style="margin-top: 1em">#endif This ends a conditional
block started by a #if... meta-macro.</p>

<p style="margin-top: 1em">#include file <br>
This causes GPP to open the specified file and evaluate its
contents, inserting the resulting text in the current
output. All defined user macros are still available in <br>
the included file, and reciprocally all macros defined in
the included file will be available in everything that
follows. The include file is looked for first in the
cur&acirc; <br>
rent directory, and then, if not found, in one of the
directories specified by the -I command-line option (or
/usr/include if no directory was specified). Note that, for
<br>
compatibility reasons, it is possible to put the file name
between &quot;&quot; or &lt;&gt;.</p>

<p style="margin-top: 1em">The order in which the various
directories are searched for include files is affected by
the -nostdinc, -nocurinc and -curdirinclast command-line
options.</p>

<p style="margin-top: 1em">Upon including a file, GPP
immediately saves a copy of the current operating mode onto
the mode stack, and restores the operating mode at the end
of the included file. The <br>
included file may override this behavior by starting with a
#mode restore call and ending with a #mode push call.
Additionally, when the -m command line option is
speci&acirc; <br>
fied, GPP will automatically switch to the cpp compatibility
mode upon including a file whose name ends with either
&rsquo;.c&rsquo; or &rsquo;.h&rsquo;.</p>

<p style="margin-top: 1em">#exec command <br>
This causes GPP to execute the specified command line and
include its standard output in the current output. Note
that, for security reasons, this meta-macro is disabled <br>
unless the -x command line flag was specified. If use of
#exec is not allowed, a warning message is printed and the
output is left blank. Note that the specified command <br>
line is evaluated before being executed, thus allowing the
use of macros in the command-line. However, the output of
the command is included verbatim and not evaluated. If <br>
you need the output to be evaluated, you must use #defeval
(see above) to cause a double evaluation.</p>

<p style="margin-top: 1em">#eval expr <br>
The #eval meta-macro attempts to evaluate expr first by
expanding macros (normal GPP evaluation) and then by
performing arithmetic evaluation and/or wildcard matching.
<br>
The syntax and operator precedence for arithmetic
expressions are the same as in C; the only missing operators
are &lt;&lt;, &gt;&gt;, ?:, and the assignment
operators.</p>

<p style="margin-top: 1em">POSIX-style wildcard matching
(&rsquo;globbing&rsquo;) is available only on POSIX
implementations and can be invoked with the =~ operator. In
brief, a &rsquo;?&rsquo; matches any single charac&acirc;
<br>
ter, a &rsquo;*&rsquo; matches any string (including the
empty string), and &rsquo;[...]&rsquo; matches any one of
the characters enclosed in brackets. A &rsquo;[...]&rsquo;
class is complemented when the <br>
first character in the brackets is &rsquo;!&rsquo;. The
characters in a &rsquo;[...]&rsquo; class can also be
specified as a range using the &rsquo;-&rsquo; character --
e.g., &rsquo;[F-N]&rsquo; is equivalent to <br>
&rsquo;[FGHIJKLMN]&rsquo;.</p>

<p style="margin-top: 1em">If unable to assign a numerical
value to the result, the returned text is simply the result
of macro expansion without any arithmetic evaluation. The
only exceptions to <br>
this rule are the comparison operators ==, !=, &lt;, &gt;,
&lt;=, and &gt;= which, if one of the sides does not
evaluate to a number, perform string comparison instead
(ignoring <br>
trailing and leading spaces). Additionally, the length(...)
arithmetic operator returns the length in characters of its
evaluated argument.</p>

<p style="margin-top: 1em">Inside arithmetic expressions,
the defined(...) special user macro is also available: it
takes only one argument, which is not evaluated, and returns
1 if it is the name <br>
of a user macro and 0 otherwise.</p>

<p style="margin-top: 1em">#if expr <br>
This meta-macro invokes the arithmetic/globbing evaluator in
the same manner as #eval and compares the result of
evaluation with the string &quot;0&quot; in order to begin a
condi&acirc; <br>
tional block. In particular note that the logical value of
expr is always true when it cannot be evaluated to a
number.</p>

<p style="margin-top: 1em">#elif expr <br>
This meta-macro can be used to avoid nested #if conditions.
#if ... #elif ... #endif is equivalent to #if ... #else #if
... #endif #endif.</p>

<p style="margin-top: 1em">#mode keyword ... <br>
This meta-macro controls GPP&rsquo;s operating mode. See
below for a list of #mode commands.</p>

<p style="margin-top: 1em">#line This meta-macro evaluates
to the line number of the current input file.</p>

<p style="margin-top: 1em">#file This meta-macro evaluates
to the filename of the current input file as it appears on
the command line or in the argument to #include. If GPP is
reading its input from <br>
stdin, then #file evaluates to &lsquo;stdin&rsquo;.</p>

<p style="margin-top: 1em">#date fmt <br>
This meta-macro evaluates to the current date and time as
formatted by the specified format string fmt. See the
section DATE AND TIME CONVERSION SPECIFIERS below.</p>

<p style="margin-top: 1em">#error msg <br>
This meta-macro causes an error message with the current
filename and line number, and with the text msg, to be
printed to the standard error device. Subsequent
process&acirc; <br>
ing is then aborted.</p>

<p style="margin-top: 1em">#warning msg <br>
This meta-macro causes a warning message with the current
filename and line number, and with the text msg, to be
printed to the standard error device. Subsequent
process&acirc; <br>
ing is then resumed.</p>

<p style="margin-top: 1em">The key to GPP&rsquo;s
flexibility is the #mode meta-macro. Its first argument is
always one of a list of available keywords (see below); its
second argument is always a sequence of <br>
words separated by whitespace. Apart from possibly the first
of them, each of these words is always a delimiter or syntax
specifier, and should be provided as a C string delim&acirc;
<br>
ited by double quotes (&quot; &quot;). The various special
matching sequences listed in the section on syntax
specification are available. Any #mode command is parsed in
a mode where &quot;...&quot; <br>
is understood to be a C-style string, so it is safe to put
any character inside these strings. Also note that the first
argument of #mode (the keyword) is never evaluated, while
<br>
the second argument is evaluated (except of course for the
contents of C strings), so that the syntax specification may
be obtained as the result of a macro evaluation.</p>

<p style="margin-top: 1em">The available #mode commands
are:</p>

<p style="margin-top: 1em">#mode save / #mode push <br>
Push the current mode specification onto the mode stack.</p>

<p style="margin-top: 1em">#mode restore / #mode pop <br>
Pop mode specification from the mode stack.</p>

<p style="margin-top: 1em">#mode standard name <br>
Select one of the standard modes. The only argument must be
one of: default (default mode); cpp, C (cpp mode); tex, TeX
(tex mode); html, HTML (html mode); xhtml, XHTML <br>
(xhtml mode); prolog, Prolog (prolog mode). The mode name
must be given directly, not as a C string.</p>

<p style="margin-top: 1em">#mode user &quot;s1&quot; ...
&quot;s9&quot; <br>
Specify user macro syntax. The 9 arguments, all of them C
strings, are the mode specification for user macros (see the
-U command-line option and the section on syntax <br>
specification). The meta-macro specification is not
affected.</p>

<p style="margin-top: 1em">#mode meta {user |
&quot;s1&quot; ... &quot;s7&quot;} <br>
Specify meta-macro syntax. Either the only argument is user
(not as a string), and the user-macro mode specifications
are copied into the meta-macro mode specifications, <br>
or there must be seven string arguments, whose significance
is the same as for the -M command-line option (see section
on syntax specification).</p>

<p style="margin-top: 1em">#mode quote [&quot;c&quot;] <br>
With no argument or &quot;&quot; as argument, removes the
quote character specification and disables the quoting
functionality. With one string argument, the first character
of the <br>
string is taken to be the new quote character. The quote
character can be neither alphanumeric nor &rsquo;_&rsquo;,
nor can it be one of the special matching sequences.</p>

<p style="margin-top: 1em">#mode comment [xxx]
&quot;start&quot; &quot;end&quot; [&quot;c&quot;
[&quot;c&quot;]] <br>
Add a comment specification. Optionally a first argument
consisting of three characters not enclosed in &quot; &quot;
can be used to specify a comment/string modifier (see the
sec&acirc; <br>
tion on syntax specification). The default modifier is ccc.
The first two string arguments are used as comment start and
end sequences respectively. The third string <br>
argument is optional and can be used to specify a
string-quote character. (If it is &quot;&quot;, the
functionality is disabled.) The fourth string argument is
optional and can be <br>
used to specify a string delimitation warning character. (If
it is &quot;&quot;, the functionality is disabled.)</p>

<p style="margin-top: 1em">#mode string [xxx]
&quot;start&quot; &quot;end&quot; [&quot;c&quot;
[&quot;c&quot;]] <br>
Add a string specification. Identical to #mode comment
except that the default modifier is sss.</p>

<p style="margin-top: 1em">#mode nocomment / #mode nostring
[&quot;start&quot;] <br>
With no argument, remove all comment/string specifications.
With one string argument, delete the comment/string
specification whose start sequence is the argument.</p>

<p style="margin-top: 1em">#mode preservelf { on | off | 1
| 0 } <br>
Equivalent to the -n command-line switch. If the argument is
on or 1, any newline or whitespace character terminating a
macro call or a comment/string is left in the input <br>
stream for further processing. If the argument is off or 0
this feature is disabled.</p>

<p style="margin-top: 1em">#mode charset { id | op | par }
&quot;string&quot; <br>
Specify the character sets to be used for matching the ) op
(the set matched <br>
by y <br>
special matching sequences , 0 <br>
place it next to a sequence.</p>

<p style="margin-top: 1em">DATE AND TIME CONVERSION
SPECIFIERS <br>
Ordinary characters placed in the format string are copied
to without conversion. Conversion specifiers are introduced
by a &lsquo;%&rsquo; character, and are replaced as
follows:</p>

<p style="margin-top: 1em">%a The abbreviated weekday name
according to the current locale.</p>

<p style="margin-top: 1em">%A The full weekday name
according to the current locale.</p>

<p style="margin-top: 1em">%b The abbreviated month name
according to the current locale.</p>

<p style="margin-top: 1em">%B The full month name according
to the current locale.</p>

<p style="margin-top: 1em">%c The preferred date and time
representation for the current locale.</p>

<p style="margin-top: 1em">%d The day of the month as a
decimal number (range 01 to 31).</p>

<p style="margin-top: 1em">%F Equivalent to %Y-%m-%d (the
ISO 8601 date format).</p>

<p style="margin-top: 1em">%H The hour as a decimal number
using a 24-hour clock (range 00 to 23).</p>

<p style="margin-top: 1em">%I The hour as a decimal number
using a 12-hour clock (range 01 to 12).</p>

<p style="margin-top: 1em">%j The day of the year as a
decimal number (range 001 to 366).</p>

<p style="margin-top: 1em">%m The month as a decimal number
(range 01 to 12).</p>

<p style="margin-top: 1em">%M The minute as a decimal
number (range 00 to 59).</p>

<p style="margin-top: 1em">%p Either &lsquo;AM&rsquo; or
&lsquo;PM&rsquo; according to the given time value, or the
corresponding strings for the current locale. Noon is
treated as &lsquo;pm&rsquo; and midnight as
&lsquo;am&rsquo;.</p>

<p style="margin-top: 1em">%R The time in 24-hour notation
(%H:%M).</p>

<p style="margin-top: 1em">%S The second as a decimal
number (range 00 to 61).</p>

<p style="margin-top: 1em">%U The week number of the
current year as a decimal number, range 00 to 53, starting
with the first Sunday as the first day of week 01.</p>

<p style="margin-top: 1em">%w The day of the week as a
decimal, range 0 to 6, Sunday being 0.</p>

<p style="margin-top: 1em">%W The week number of the
current year as a decimal number, range 00 to 53, starting
with the first Monday as the first day of week 01.</p>

<p style="margin-top: 1em">%x The preferred date
representation for the current locale without the time.</p>

<p style="margin-top: 1em">%X The preferred time
representation for the current locale without the date.</p>

<p style="margin-top: 1em">%y The year as a decimal number
without a century (range 00 to 99).</p>

<p style="margin-top: 1em">%Y The year as a decimal number
including the century.</p>

<p style="margin-top: 1em">%Z The time zone or name or
abbreviation.</p>

<p style="margin-top: 1em">%% A literal &lsquo;%&rsquo;
character.</p>

<p style="margin-top: 1em">Depending on the C compiler and
library used to compile GPP, there may be more conversion
specifiers available. Consult your compiler&rsquo;s
documentation for the strftime() func&acirc; <br>
tion. Note, however, that any conversion specifiers not
listed above may not be portable across installations of
GPP.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Here is a basic self-explanatory example in standard or cpp
mode:</p>

<p style="margin-top: 1em">#define FOO This is <br>
#define BAR a message. <br>
#define concat #1 #2 <br>
concat(FOO,BAR) <br>
#ifeq (concat(foo,bar)) (foo bar) <br>
This is output. <br>
#else <br>
This is not output. <br>
#endif</p>

<p style="margin-top: 1em">Using argument naming, the
concat macro could alternatively be defined as</p>

<p style="margin-top: 1em">#define concat(x,y) x y</p>

<p style="margin-top: 1em">In TeX mode and using argument
naming, the same example becomes:</p>

<p style="margin-top: 1em">efine{FOO}{This is} <br>
efine{BAR}{a message.} <br>
efine{ ifeq{ This is output. <br>
\lse <br>
This is not output. <br>
\ndif</p>

<p style="margin-top: 1em">In HTML mode and without
argument naming, one gets similarly:</p>

<p style="margin-top: 1em">&lt;#define FOO|This is&gt; <br>
&lt;#define BAR|a message.&gt; <br>
&lt;#define concat|#1 #2&gt; <br>
&lt;#concat &lt;#FOO&gt;|&lt;#BAR&gt;&gt; <br>
&lt;#ifeq &lt;#concat foo|bar&gt;|foo bar&gt; <br>
This is output. <br>
&lt;#else&gt; <br>
This is not output. <br>
&lt;#endif&gt;</p>

<p style="margin-top: 1em">The following example (in
standard mode) illustrates the use of the quote
character:</p>

<p style="margin-top: 1em">#define FOO This is a multiline
definition. <br>
#define BLAH(x) My argument is x <br>
BLAH(urf) <br>
0</p>

<p style="margin-top: 1em">Note that the multiline
definition is also valid in cpp and Prolog modes despite the
absence of quote character, because &rsquo;&acute; followed
by a newline is then interpreted as a com&acirc; <br>
ment and discarded.</p>

<p style="margin-top: 1em">In cpp mode, C strings and
comments are understood as such, as illustrated by the
following example:</p>

<p style="margin-top: 1em">#define BLAH foo <br>
BLAH &quot;BLAH&quot; /* BLAH */ <br>
&rsquo;It&acute;s a /*string*/ !&rsquo;</p>

<p style="margin-top: 1em">The main difference between
Prolog mode and cpp mode is the handling of strings and
comments: in Prolog, a &rsquo;...&rsquo; string may not
begin immediately after a digit, and a /*...*/ <br>
comment may not begin immediately after an operator
character. Furthermore, comments are not removed from the
output unless they occur in a #command.</p>

<p style="margin-top: 1em">The differences between cpp mode
and default mode are deeper: in default mode #commands may
start anywhere, while in cpp mode they must be at the
beginning of a line; the default <br>
mode has no knowledge of comments and strings, but has a
quote character (&rsquo;&acute;), while cpp mode has
extensive comment/string specifications but no quote
character. Moreover, the <br>
arguments to meta-macros need to be correctly parenthesized
in default mode, while no such checking is performed in cpp
mode.</p>

<p style="margin-top: 1em">This makes it easier to nest
meta-macro calls in default mode than in cpp mode. For
example, consider the following HTML mode input, which tests
for the availability of the #exec <br>
command:</p>

<p style="margin-top: 1em">&lt;#ifeq &lt;#exec echo
blah&gt;|blah <br>
&gt; #exec allowed &lt;#else&gt; #exec not allowed
&lt;#endif&gt;</p>

<p style="margin-top: 1em">There is no cpp mode equivalent,
while in default mode it can be easily translated as</p>

<p style="margin-top: 1em">#ifeq (#exec echo blah <br>
) (blah <br>
) <br>
#else <br>
#endif</p>

<p style="margin-top: 1em">In order to nest meta-macro
calls in cpp mode it is necessary to modify the mode
description, either by changing the meta-macro call syntax,
or more elegantly by defining a <br>
silent string and using the fact that the context at the
beginning of an evaluated string is a newline character:</p>

<p style="margin-top: 1em">#mode string QQQ &quot;$&quot;
&quot;$&quot; <br>
#ifeq $#exec echo blah <br>
$ $blah <br>
$ <br>
#else <br>
#endif</p>

<p style="margin-top: 1em">Note, however, that
comments/strings cannot be nested (&quot;...&quot; inside
$...$ would go undetected), so one needs to be careful about
what to include inside such a silent evaluated <br>
string. In this example, the loose meta-macro nesting
introduced in version 2.1 makes it possible to use the
following simpler version:</p>

<p style="margin-top: 1em">#ifeq blah #exec echo -n blah
<br>
#else <br>
#endif</p>

<p style="margin-top: 1em">Remember that macros without
arguments are actually understood to be aliases when they
are called with arguments, as illustrated by the following
example (default or cpp mode):</p>

<p style="margin-top: 1em">#define DUP(x) x x <br>
#define FOO and I said: DUP <br>
FOO(blah)</p>

<p style="margin-top: 1em">The usefulness of the #defeval
meta-macro is shown by the following example in HTML
mode:</p>

<p style="margin-top: 1em">&lt;#define APPLY|&lt;#defeval
TEMP|&lt; &lt;#define &lt;#foo x&gt;|&lt;#x&gt; and
&lt;#x&gt;&gt; <br>
&lt;#APPLY foo|BLAH&gt;</p>

<p style="margin-top: 1em">The reason why #defeval is
needed is that, since everything is evaluated in a single
pass, the input that will result in the desired macro call
needs to be generated by a first <br>
evaluation of the arguments passed to APPLY before being
evaluated a second time.</p>

<p style="margin-top: 1em">To translate this example in
default mode, one needs to resort to parenthesizing in order
to nest the #defeval call inside the definition of APPLY,
but need to do so without out&acirc; <br>
putting the parentheses. The easiest solution is</p>

<p style="margin-top: 1em">#define BALANCE(x) x <br>
#define APPLY(f,v) BALANCE(#defeval TEMP f <br>
TEMP(v)) <br>
#define foo(x) x and x <br>
APPLY(o,BLAH)</p>

<p style="margin-top: 1em">As explained above the simplest
version in cpp mode relies on defining a silent evaluated
string to play the role of the BALANCE macro.</p>

<p style="margin-top: 1em">The following example (default
or cpp mode) demonstrates arithmetic evaluation:</p>

<p style="margin-top: 1em">#define x 4 <br>
The answer is: <br>
#eval x*x + 2*(16-x) + 1998%x</p>

<p style="margin-top: 1em">#if
defined(x)&amp;&amp;!(3*x+5&gt;17) <br>
This should be output. <br>
#endif</p>

<p style="margin-top: 1em">To finish, here are some
examples involving mode switching. The following example is
self-explanatory (starting in default mode):</p>

<p style="margin-top: 1em">#mode push <br>
#define f(x) x x <br>
#mode standard tex <br>
blah} <br>
de{string}{&quot;$&quot; &quot;$&quot;} <br>
de{comment}{&quot;/*&quot; &quot;*/&quot;} <br>
$urf}$ /* blah */ <br>
efine{FOO}{bar/* and some more */} <br>
de{pop} <br>
f($FOO$)</p>

<p style="margin-top: 1em">A good example where a
user-defined mode becomes useful is the GPP source of this
document (available with GPP&rsquo;s source code
distribution).</p>

<p style="margin-top: 1em">Another interesting application
is selectively forcing evaluation of macros in C strings
when in cpp mode. For example, consider the following
input:</p>

<p style="margin-top: 1em">#define blah(x) &quot;and he
said: x&quot; <br>
blah(foo)</p>

<p style="margin-top: 1em">Obviously one would want the
parameter x to be expanded inside the string. There are
several ways around this problem:</p>

<p style="margin-top: 1em">#mode push <br>
#mode nostring &quot; <br>
#define blah(x) &quot;and he said: x&quot; <br>
#mode pop</p>

<p style="margin-top: 1em">#mode quote &quot;&lsquo;&quot;
<br>
#define blah(x) &lsquo;&quot;and he said: x&lsquo;&quot;</p>

<p style="margin-top: 1em">#mode string QQQ &quot;$$&quot;
&quot;$$&quot; <br>
#define blah(x) $$&quot;and he said: x&quot;$$</p>

<p style="margin-top: 1em">The first method is very
natural, but has the inconvenience of being lengthy and
neutralizing string semantics, so that having an unevaluated
instance of &rsquo;x&rsquo; in the string, or an <br>
occurrence of &rsquo;/*&rsquo;, would be impossible without
resorting to further contortions.</p>

<p style="margin-top: 1em">The second method is slightly
more efficient because the local presence of a quote
character makes it easier to control what is evaluated and
what isn&rsquo;t, but has the drawback <br>
that it is sometimes impossible to find a reasonable quote
character without having to either significantly alter the
source file or enclose it inside a #mode push/pop construct.
<br>
For example, any occurrence of &rsquo;/*&rsquo; in the
string would have to be quoted.</p>

<p style="margin-top: 1em">The last method demonstrates the
efficiency of evaluated strings in the context of selective
evaluation: since comments/strings cannot be nested, any
occurrence of &rsquo;&quot;&rsquo; or &rsquo;/*&rsquo; <br>
inside the &rsquo;$$&rsquo; gets output as plain text, as
expected inside a string, and only macro evaluation is
enabled. Also note that there is much more freedom in the
choice of a string <br>
delimiter than in the choice of a quote character.</p>

<p style="margin-top: 1em">Starting with version 2.1,
meta-macro calls can be nested more efficiently in default,
cpp and Prolog modes. This makes it easy to make a user
version of a meta-macro, or to <br>
increment a counter:</p>

<p style="margin-top: 1em">#define myeval #eval #1</p>

<p style="margin-top: 1em">#define x 1 <br>
#defeval x #eval x+1</p>

<p style="margin-top: 1em">ADVANCED EXAMPLES <br>
Here are some examples of advanced constructions using GPP.
They tend to be pretty awkward and should be considered as
evidence of GPP&rsquo;s limitations.</p>

<p style="margin-top: 1em">The first example is a recursive
macro. The main problem is that (since GPP evaluates
everything) a recursive macro must be very careful about the
way in which recursion is ter&acirc; <br>
minated in order to avoid undefined behavior (most of the
time GPP will simply crash). In particular, relying on a
#if/#else/#endif construct to end recursion is not possible
and <br>
results in an infinite loop, because GPP scans user macro
calls even in the unevaluated branch of the conditional
block. A safe way to proceed is for example as follows (we
give <br>
the example in TeX mode):</p>

<p style="margin-top: 1em">efine{countdown}{ <br>
if{#1} <br>
#1... <br>
efine{loop}{ \lse <br>
Done. <br>
efine{loop}{} <br>
\ndif <br>
p{\val{#1-1}} <br>
} <br>
Another example, in cpp mode:</p>

<p style="margin-top: 1em">#mode string QQQ &quot;$&quot;
&quot;$&quot; <br>
#define triangle(x,y) y $#if length(y)&lt;x$ $#define iter
triangle$ $#else$ $#define iter$ $#endif <br>
$ iter(x,*y) <br>
triangle(20)</p>

<p style="margin-top: 1em">The following is an
(unfortunately very weak) attempt at implementing functional
abstraction in GPP (in standard mode). Understanding this
example and why it can&rsquo;t be made much <br>
simpler is an exercise left to the curious reader.</p>

<p style="margin-top: 1em">#mode string &quot;&lsquo;&quot;
&quot;&lsquo;&quot; &quot;\&quot; <br>
#define ASIS(x) x <br>
#define SILENT(x) ASIS() <br>
#define EVAL(x,f,v) SILENT( <br>
#mode string QQQ &quot;&lsquo;&quot; &quot;&lsquo;&quot;
&quot;\&quot; <br>
#defeval TEMP0 x <br>
#defeval TEMP1 ( <br>
) <br>
TEMP1 <br>
)TEMP2(v) <br>
#define LAMBDA(x,f,v) SILENT( <br>
#ifneq (v) () <br>
#define TEMP3(a,b,c) EVAL(a,b,c) <br>
#else <br>
#define TEMP3(a,b,c) BDA(a,b) <br>
#endif <br>
)TEMP3(x,f,v) <br>
#define EVALAMBDA(x,y) SILENT( <br>
#defeval TEMP4 x <br>
#defeval TEMP5 y <br>
) <br>
#define APPLY(f,v) SILENT( <br>
#defeval TEMP6 ASIS()f <br>
TEMP6 <br>
)EVAL(TEMP4,TEMP5,v)</p>

<p style="margin-top: 1em">This yields the following
results:</p>

<p style="margin-top: 1em">LAMBDA(z,z+z) <br>
=&gt; LAMBDA(z,z+z)</p>

<p style="margin-top: 1em">LAMBDA(z,z+z,2) <br>
=&gt; 2+2</p>

<p style="margin-top: 1em">#define f LAMBDA(y,y*y) <br>
f <br>
=&gt; LAMBDA(y,y*y)</p>

<p style="margin-top: 1em">APPLY(f,blah) <br>
=&gt; blah*blah</p>

<p style="margin-top: 1em">APPLY(LAMBDA(t,t t),(t t)) <br>
=&gt; (t t) (t t)</p>

<p style="margin-top: 1em">LAMBDA(x,APPLY(f,(x+x)),urf)
<br>
=&gt; (urf+urf)*(urf+urf)</p>


<p style="margin-top: 1em">APPLY(APPLY(LAMBDA(x,LAMBDA(y,x*y)),foo),bar)
<br>
=&gt; foo*bar</p>

<p style="margin-top: 1em">#define test
LAMBDA(y,&lsquo;#ifeq y urf <br>
y is urf#else <br>
y is not urf#endif <br>
&lsquo;) <br>
APPLY(test,urf) <br>
=&gt; urf is urf</p>

<p style="margin-top: 1em">APPLY(test,foo) <br>
=&gt; foo is not urf</p>

<p style="margin-top: 1em">SEE ALSO <br>
strftime(3), glob(7), m4(1V), cpp(1)</p>

<p style="margin-top: 1em">GPP home page:
http://www.nothingisreal.com/gpp/</p>

<p style="margin-top: 1em">AUTHOR <br>
GPP was written by Denis Auroux &lt;auroux@math.mit.edu&gt;.
Since version 2.12 it has been maintained by Tristan Miller
&lt;psychonaut@nothingisreal.com&gt;.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) 1996-2001 Denis Auroux.</p>

<p style="margin-top: 1em">Copyright (C) 2003, 2004 Tristan
Miller.</p>

<p style="margin-top: 1em">Permission is granted to anyone
to make or distribute verbatim copies of this document as
received, in any medium, provided that the copyright notice
and this permission notice <br>
are preserved, thus giving the recipient permission to
redistribute in turn.</p>

<p style="margin-top: 1em">Permission is granted to
distribute modified versions of this document, or of
portions of it, under the above conditions, provided also
that they carry prominent notices stating <br>
who last changed them.</p>
 
<p style="margin-top: 1em">GPP(1)</p>
<hr>
</body>
</html>
