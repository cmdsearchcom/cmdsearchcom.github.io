<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:16:24 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>HAPROXY-LUA(1) haproxy-lua HAPROXY-LUA(1)</p>

<p style="margin-top: 1em">NAME <br>
haproxy-lua - haproxy-lua Documentation</p>

<p style="margin-top: 1em">HAPROXY LUA RUNNING CONTEXTS
<br>
The Lua code executed in HAProxy can be processed in 2 main
modes. The first one is the initialisation mode, and the
second is the runtime mode.</p>

<p style="margin-top: 1em">&Acirc;&middot; In the
initialisation mode, we can perform DNS solves, but we
cannot perform socket I/O. In this initialisation mode,
HAProxy still blocked during the execution of the Lua
pro&acirc; <br>
gram.</p>

<p style="margin-top: 1em">&Acirc;&middot; In the runtime
mode, we cannot perform DNS solves, but we can use sockets.
The execution of the Lua code is multiplexed with the
requests processing, so the Lua code seems to <br>
be run in blocking, but it is not the case.</p>

<p style="margin-top: 1em">The Lua code is loaded in one or
more files. These files contains main code and functions.
Lua have 6 execution context.</p>

<p style="margin-top: 1em">1. The Lua file body context. It
is executed during the load of the Lua file in the HAProxy
[global] section with the directive lua-load. It is executed
in initialisation mode. <br>
This section is use for configuring Lua bindings in
HAProxy.</p>

<p style="margin-top: 1em">2. The Lua init context. It is a
Lua function executed just after the HAProxy configuration
parsing. The execution is in initialisation mode. In this
context the HAProxy environ&acirc; <br>
ment are already initialized. It is useful to check
configuration, or initializing socket connections or tasks.
These functions are declared in the body context with the
Lua <br>
function core.register_init(). The prototype of the function
is a simple function without return value and without
parameters, like this: function fcn().</p>

<p style="margin-top: 1em">3. The Lua task context. It is a
Lua function executed after the start of the HAProxy
scheduler, and just after the declaration of the task with
the Lua function core.regis&acirc; <br>
ter_task(). This context can be concurrent with the traffic
processing. It is executed in runtime mode. The prototype of
the function is a simple function without return value <br>
and without parameters, like this: function fcn().</p>

<p style="margin-top: 1em">4. The action context. It is a
Lua function conditionally executed. These actions are
registered by the Lua directives
&quot;core.register_action()&quot;. The prototype of the Lua
called <br>
function is a function with doesn&rsquo;t returns anything
and that take an object of class TXN as entry. function
fcn(txn).</p>

<p style="margin-top: 1em">5. The sample-fetch context.
This function takes a TXN object as entry argument and
returns a string. These types of function cannot execute any
blocking function. They are use&acirc; <br>
ful to aggregate some of original HAProxy sample-fetches and
return the result. The prototype of the function is function
string fcn(txn). These functions can be registered <br>
with the Lua function core.register_fetches(). Each declared
sample-fetch is prefixed by the string &quot;lua.&quot;.</p>

<p style="margin-top: 1em">NOTE: It is possible that this
function cannot found the required data in the original
HAProxy sample-fetches, in this case, it cannot return the
result. This case is not yet <br>
supported</p>

<p style="margin-top: 1em">6. The converter context. It is
a Lua function that takes a string as input and returns
another string as output. These types of function are
stateless, it cannot access to any <br>
context. They don&rsquo;t execute any blocking function. The
call prototype is function string fcn(string). This function
can be registered with the Lua function
core.register_con&acirc; <br>
verters(). Each declared converter is prefixed by the string
&quot;lua.&quot;.</p>

<p style="margin-top: 1em">HAPROXY LUA HELLO WORLD <br>
HAProxy configuration file (hello_world.conf):</p>

<p style="margin-top: 1em">global <br>
lua-load hello_world.lua</p>

<p style="margin-top: 1em">listen proxy <br>
bind 127.0.0.1:10001 <br>
tcp-request inspect-delay 1s <br>
tcp-request content use-service lua.hello_world</p>

<p style="margin-top: 1em">HAProxy Lua file
(hello_world.lua):</p>


<p style="margin-top: 1em">core.register_service(&quot;hello_world&quot;,
&quot;tcp&quot;, function(applet) <br>
applet:send(&quot;hello world0) <br>
end)</p>

<p style="margin-top: 1em">How to start HAProxy for testing
this configuration:</p>

<p style="margin-top: 1em">./haproxy -f
hello_world.conf</p>

<p style="margin-top: 1em">On other terminal, you can test
with telnet:</p>

<p style="margin-top: 1em">#:~ telnet 127.0.0.1 10001 <br>
hello world</p>

<p style="margin-top: 1em">class core() <br>
The &quot;core&quot; class contains all the HAProxy core
functions. These function are useful for the controlling the
execution flow, registering hooks, manipulating global maps
or <br>
ACL, ...</p>

<p style="margin-top: 1em">&quot;core&quot; class is
basically provided with HAProxy. No require line is required
to uses these function.</p>

<p style="margin-top: 1em">The &quot;core&quot; class is
static, it is not possible to create a new object of this
type.</p>

<p style="margin-top: 1em">core.emerg</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;emergency&quot;
(0).</p>

<p style="margin-top: 1em">core.alert</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;alert&quot;
(1).</p>

<p style="margin-top: 1em">core.crit</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;critical&quot;
(2).</p>

<p style="margin-top: 1em">core.err</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;error&quot;
(3).</p>

<p style="margin-top: 1em">core.warning</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;warning&quot;
(4).</p>

<p style="margin-top: 1em">core.notice</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;notice&quot;
(5).</p>

<p style="margin-top: 1em">core.info</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;info&quot; (6).</p>

<p style="margin-top: 1em">core.debug</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">This attribute is an integer, it
contains the value of the loglevel &quot;debug&quot;
(7).</p>

<p style="margin-top: 1em">core.log(loglevel, msg) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">This function sends a log. The
log is sent, according with the HAProxy configuration file,
on the default syslog server if it is configured and on the
stderr if it is <br>
allowed.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; loglevel
(integer) -- Is the log level asociated with the message. It
is a number between 0 and 7.</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See core.emerg, core.alert,
core.crit, core.err, core.warning, core.notice, core.info,
core.debug (log level definitions)</p>

<p style="margin-top: 1em">See code.Debug</p>

<p style="margin-top: 1em">See core.Info</p>

<p style="margin-top: 1em">See core.Warning</p>

<p style="margin-top: 1em">See core.Alert</p>

<p style="margin-top: 1em">core.Debug(msg) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See log</p>

<p style="margin-top: 1em">Does the same job than:</p>

<p style="margin-top: 1em">function Debug(msg) <br>
core.log(core.debug, msg) <br>
end</p>

<p style="margin-top: 1em">core.Info(msg) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See log</p>

<p style="margin-top: 1em">function Info(msg) <br>
core.log(core.info, msg) <br>
end</p>

<p style="margin-top: 1em">core.Warning(msg) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See log</p>

<p style="margin-top: 1em">function Warning(msg) <br>
core.log(core.warning, msg) <br>
end</p>

<p style="margin-top: 1em">core.Alert(msg) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See log</p>

<p style="margin-top: 1em">function Alert(msg) <br>
core.log(core.alert, msg) <br>
end</p>

<p style="margin-top: 1em">core.add_acl(filename, key) <br>
context: init, task, action, sample-fetch, converter</p>

<p style="margin-top: 1em">Add the ACL key in the ACLs list
referenced by the file filename.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; filename
(string) -- the filename that reference the ACL entries.</p>

<p style="margin-top: 1em">&Acirc;&middot; key (string) --
the key which will be added.</p>

<p style="margin-top: 1em">core.del_acl(filename, key) <br>
context: init, task, action, sample-fetch, converter</p>

<p style="margin-top: 1em">Delete the ACL entry referenced
by the key key in the list of ACLs referenced by
filename.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; filename
(string) -- the filename that reference the ACL entries.</p>

<p style="margin-top: 1em">&Acirc;&middot; key (string) --
the key which will be deleted.</p>

<p style="margin-top: 1em">core.del_map(filename, key) <br>
context: init, task, action, sample-fetch, converter</p>

<p style="margin-top: 1em">Delete the map entry indexed
with the specified key in the list of maps referenced by his
filename.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; filename
(string) -- the filename that reference the map entries.</p>

<p style="margin-top: 1em">&Acirc;&middot; key (string) --
the key which will be deleted.</p>

<p style="margin-top: 1em">core.get_info() <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Returns HAProxy core
informations. We can found information like the uptime, the
pid, memory pool usage, tasks number, ...</p>

<p style="margin-top: 1em">These information are also
returned by the management sockat via the command &quot;show
info&quot;. See the management socket documentation fpor
more information about the content <br>
of these variables.</p>

<p style="margin-top: 1em">Returns <br>
an array of values.</p>

<p style="margin-top: 1em">core.now() <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">This function returns the
current time. The time returned is fixed by the HAProxy core
and assures than the hour will be monotnic and that the
system call &rsquo;gettimeofday&rsquo; <br>
will not be called too. The time is refreshed between each
Lua execution or resume, so two consecutive call to the
function &quot;now&quot; will probably returns the same
result.</p>

<p style="margin-top: 1em">Returns <br>
an array which contains two entries &quot;sec&quot; and
&quot;usec&quot;. &quot;sec&quot; contains the current at
the epoch format, and &quot;usec&quot; contains the current
microseconds.</p>

<p style="margin-top: 1em">core.http_date(date) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">This function take a string
repsenting http date, and returns an integer containing the
corresponding date with a epoch format. A valid http date me
respect the format <br>
IMF, RFC850 or ASCTIME.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; date (string) --
a date http-date formatted</p>

<p style="margin-top: 1em">Returns <br>
integer containing epoch date</p>

<p style="margin-top: 1em">See core.imf_date().</p>

<p style="margin-top: 1em">See core.rfc850_date().</p>

<p style="margin-top: 1em">See core.asctime_date().</p>

<p style="margin-top: 1em">See
https://tools.ietf.org/html/rfc7231#section-7.1.1.1</p>

<p style="margin-top: 1em">core.imf_date(date) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">This function take a string
repsenting IMF date, and returns an integer containing the
corresponding date with a epoch format.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; date (string) --
a date IMF formatted</p>

<p style="margin-top: 1em">Returns <br>
integer containing epoch date</p>

<p style="margin-top: 1em">See
https://tools.ietf.org/html/rfc7231#section-7.1.1.1</p>

<p style="margin-top: 1em">The IMF format is like this:</p>

<p style="margin-top: 1em">Sun, 06 Nov 1994 08:49:37
GMT</p>

<p style="margin-top: 1em">core.rfc850_date(date) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">This function take a string
repsenting RFC850 date, and returns an integer containing
the corresponding date with a epoch format.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; date (string) --
a date RFC859 formatted</p>

<p style="margin-top: 1em">Returns <br>
integer containing epoch date</p>

<p style="margin-top: 1em">See
https://tools.ietf.org/html/rfc7231#section-7.1.1.1</p>

<p style="margin-top: 1em">The RFC850 format is like
this:</p>

<p style="margin-top: 1em">Sunday, 06-Nov-94 08:49:37
GMT</p>

<p style="margin-top: 1em">core.asctime_date(date) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">This function take a string
repsenting ASCTIME date, and returns an integer containing
the corresponding date with a epoch format.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; date (string) --
a date ASCTIME formatted</p>

<p style="margin-top: 1em">Returns <br>
integer containing epoch date</p>

<p style="margin-top: 1em">See
https://tools.ietf.org/html/rfc7231#section-7.1.1.1</p>

<p style="margin-top: 1em">The ASCTIME format is like
this:</p>

<p style="margin-top: 1em">Sun Nov 6 08:49:37 1994</p>

<p style="margin-top: 1em">core.rfc850_date(date) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">This function take a string
repsenting http date, and returns an integer containing the
corresponding date with a epoch format.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; date (string) --
a date http-date formatted</p>

<p style="margin-top: 1em">core.asctime_date(date) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">This function take a string
repsenting http date, and returns an integer containing the
corresponding date with a epoch format.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; date (string) --
a date http-date formatted</p>

<p style="margin-top: 1em">core.msleep(milliseconds) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">The core.msleep() stops the Lua
execution between specified milliseconds.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; milliseconds
(integer) -- the required milliseconds.</p>

<p style="margin-top: 1em">core.proxies <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">proxies is an array containing
the list of all proxies declared in the configuration file.
Each entry of the proxies array is an object of type Proxy
class</p>

<p style="margin-top: 1em">core.register_action(name,
actions, func) <br>
context: body</p>

<p style="margin-top: 1em">Register a Lua function executed
as action. All the registered action can be used in HAProxy
with the prefix &quot;lua.&quot;. An action gets a TXN
object class as input.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
is the name of the converter.</p>

<p style="margin-top: 1em">&Acirc;&middot; actions (table)
-- is a table of string describing the HAProxy actions who
want to register to. The expected actions are
&rsquo;tcp-req&rsquo;, &rsquo;tcp-res&rsquo;,
&rsquo;http-req&rsquo; or <br>
&rsquo;http-res&rsquo;.</p>

<p style="margin-top: 1em">&Acirc;&middot; func (function)
-- is the Lua function called to work as converter.</p>

<p style="margin-top: 1em">The prototype of the Lua
function used as argument is:</p>

<p style="margin-top: 1em">function(txn)</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">txn (TXN class): this is a TXN
object used for manipulating the <br>
current request or TCP stream.</p>

<p style="margin-top: 1em">Here, an exemple of action
registration. the action juste send an &rsquo;Hello
world&rsquo; in the logs.</p>


<p style="margin-top: 1em">core.register_action(&quot;hello-world&quot;,
{ &quot;tcp-req&quot;, &quot;http-req&quot; }, function(txn)
<br>
txn:Info(&quot;Hello world&quot;) <br>
end) <br>
This example code is used in HAproxy configuration like
this:</p>

<p style="margin-top: 1em">frontend tcp_frt <br>
mode tcp <br>
tcp-request content lua.hello-world</p>

<p style="margin-top: 1em">frontend http_frt <br>
mode http <br>
http-request lua.hello-world</p>

<p style="margin-top: 1em">core.register_converters(name,
func) <br>
context: body</p>

<p style="margin-top: 1em">Register a Lua function executed
as converter. All the registered converters can be used in
HAProxy with the prefix &quot;lua.&quot;. An converter get a
string as input and return a <br>
string as output. The registered function can take up to 9
values as parameter. All the value are strings.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
is the name of the converter.</p>

<p style="margin-top: 1em">&Acirc;&middot; func (function)
-- is the Lua function called to work as converter.</p>

<p style="margin-top: 1em">The prototype of the Lua
function used as argument is:</p>

<p style="margin-top: 1em">function(str, [p1 [, p2 [, ...
[, p5]]]])</p>

<p style="margin-top: 1em">&Acirc;&middot; str (string):
this is the input value automatically converted in
string.</p>

<p style="margin-top: 1em">&Acirc;&middot; p1 .. p5
(string): this is a list of string arguments declared in the
haroxy configuration file. The number of arguments
doesn&rsquo;t exceed 5. The order and the nature of these
<br>
is conventionally choose by the developper.</p>

<p style="margin-top: 1em">core.register_fetches(name,
func) <br>
context: body</p>

<p style="margin-top: 1em">Register a Lua function executed
as sample fetch. All the registered sample fetchs can be
used in HAProxy with the prefix &quot;lua.&quot;. A Lua
sample fetch return a string as <br>
output. The registered function can take up to 9 values as
parameter. All the value are strings.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
is the name of the converter.</p>

<p style="margin-top: 1em">&Acirc;&middot; func (function)
-- is the Lua function called to work as sample fetch.</p>

<p style="margin-top: 1em">The prototype of the Lua
function used as argument is:</p>

<p style="margin-top: 1em">string function(txn, [p1 [, p2
[, ... [, p5]]]])</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (TXN class):
this is the txn object associated with the current
request.</p>

<p style="margin-top: 1em">&Acirc;&middot; p1 .. p5
(string): this is a list of string arguments declared in the
haroxy configuration file. The number of arguments
doesn&rsquo;t exceed 5. The order and the nature of these
<br>
is conventionally choose by the developper.</p>

<p style="margin-top: 1em">&Acirc;&middot; Returns: A
string containing some data, ot nil if the value cannot be
returned now.</p>

<p style="margin-top: 1em">lua example code:</p>


<p style="margin-top: 1em">core.register_fetches(&quot;hello&quot;,
function(txn) <br>
return &quot;hello&quot; <br>
end) <br>
HAProxy example configuration:</p>

<p style="margin-top: 1em">frontend example <br>
http-request redirect location /%[lua.hello]</p>

<p style="margin-top: 1em">core.register_service(name,
mode, func) <br>
context: body</p>

<p style="margin-top: 1em">Register a Lua function executed
as a service. All the registered service can be used in
HAProxy with the prefix &quot;lua.&quot;. A service gets an
object class as input according <br>
with the required mode.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
is the name of the converter.</p>

<p style="margin-top: 1em">&Acirc;&middot; mode (string) --
is string describing the required mode. Only
&rsquo;tcp&rsquo; or &rsquo;http&rsquo; are allowed.</p>

<p style="margin-top: 1em">&Acirc;&middot; func (function)
-- is the Lua function called to work as converter.</p>

<p style="margin-top: 1em">The prototype of the Lua
function used as argument is:</p>

<p style="margin-top: 1em">function(applet)</p>

<p style="margin-top: 1em">&Acirc;&middot; applet applet
will be a AppletTCP class or a AppletHTTP class. It depends
the type of registered applet. An applet registered with the
&rsquo;http&rsquo; value for the mode parameter <br>
will gets a AppletHTTP class. If the mode value is
&rsquo;tcp&rsquo;, the applet will gets a AppletTCP
class.</p>

<p style="margin-top: 1em">warning: Applets of type
&rsquo;http&rsquo; cannot be called from &rsquo;tcp-&rsquo;
rulesets. Only the &rsquo;http-&rsquo; rulesets are
authorized, this means that is not possible to call an HTTP
applet from a <br>
proxy in tcp mode. Applets of type &rsquo;tcp&rsquo; can be
called from anywhre.</p>

<p style="margin-top: 1em">Here, an exemple of service
registration. the service just send an &rsquo;Hello
world&rsquo; as an http response.</p>


<p style="margin-top: 1em">core.register_service(&quot;hello-world&quot;,
&quot;http&quot;, function(applet) <br>
local response = &quot;Hello World !&quot; <br>
applet:set_status(200) <br>
applet:add_header(&quot;content-length&quot;,
string.len(response)) <br>
applet:add_header(&quot;content-type&quot;,
&quot;text/plain&quot;) <br>
applet:start_response() <br>
applet:send(response) <br>
end) <br>
This example code is used in HAproxy configuration like
this:</p>

<p style="margin-top: 1em">frontend example <br>
http-request use-service lua.hello-world</p>

<p style="margin-top: 1em">core.register_init(func) <br>
context: body</p>

<p style="margin-top: 1em">Register a function executed
after the configuration parsing. This is useful to check any
parameters.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; func (function)
-- is the Lua function called to work as initializer.</p>

<p style="margin-top: 1em">The prototype of the Lua
function used as argument is:</p>

<p style="margin-top: 1em">function() <br>
It takes no input, and no output is expected.</p>

<p style="margin-top: 1em">core.register_task(func) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Register and start independent
task. The task is started when the HAProxy main scheduler
starts. For example this type of tasks can be executed to
perform complex health <br>
checks.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; func (function)
-- is the Lua function called to work as initializer.</p>

<p style="margin-top: 1em">The prototype of the Lua
function used as argument is:</p>

<p style="margin-top: 1em">function() <br>
It takes no input, and no output is expected.</p>

<p style="margin-top: 1em">core.register_cli([path], usage,
func) <br>
context: body</p>

<p style="margin-top: 1em">Register and start independent
task. The task is started when the HAProxy main scheduler
starts. For example this type of tasks can be executed to
perform complex health <br>
checks.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; path (array) --
is the sequence of word for which the cli execute the Lua
binding.</p>

<p style="margin-top: 1em">&Acirc;&middot; usage (string)
-- is the usage message displayed in the help.</p>

<p style="margin-top: 1em">&Acirc;&middot; func (function)
-- is the Lua function called to handle the CLI
commands.</p>

<p style="margin-top: 1em">The prototype of the Lua
function used as argument is:</p>

<p style="margin-top: 1em">function(AppletTCP, [arg1,
[arg2, [...]]]) <br>
I/O are managed with the AppletTCP class object. Args are
given as paramter. The args embbed the registred path. If
the path is declared like this:</p>


<p style="margin-top: 1em">core.register_cli({&quot;show&quot;,
&quot;ssl&quot;, &quot;stats&quot;}, &quot;Display SSL
stats..&quot;, function(applet, arg1, arg2, arg3, arg4,
arg5) <br>
end) <br>
And we execute this in the prompt:</p>

<p style="margin-top: 1em">&gt; prompt <br>
&gt; show ssl stats all <br>
Then, arg1, arg2 and arg3 will contains respectivey
&quot;show&quot;, &quot;ssl&quot; and &quot;stats&quot;.
arg4 will contain &quot;all&quot;. arg5 contains nil.</p>

<p style="margin-top: 1em">core.set_nice(nice) <br>
context: task, action, sample-fetch, converter</p>

<p style="margin-top: 1em">Change the nice of the current
task or current session.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; nice (integer)
-- the nice value, it must be between -1024 and 1024.</p>

<p style="margin-top: 1em">core.set_map(filename, key,
value) <br>
context: init, task, action, sample-fetch, converter</p>

<p style="margin-top: 1em">set the value value associated
to the key key in the map referenced by filename.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; filename
(string) -- the Map reference</p>

<p style="margin-top: 1em">&Acirc;&middot; key (string) --
the key to set or replace</p>

<p style="margin-top: 1em">&Acirc;&middot; value (string)
-- the associated value</p>

<p style="margin-top: 1em">core.sleep(int seconds) <br>
context: body, init, task, action</p>

<p style="margin-top: 1em">The core.sleep() functions stop
the Lua execution between specified seconds.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; seconds
(integer) -- the required seconds.</p>

<p style="margin-top: 1em">core.tcp() <br>
context: init, task, action</p>

<p style="margin-top: 1em">This function returns a new
object of a socket class.</p>

<p style="margin-top: 1em">Returns <br>
A Socket class object.</p>

<p style="margin-top: 1em">core.concat() <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">This function retruns a new
concat object.</p>

<p style="margin-top: 1em">Returns <br>
A Concat class object.</p>

<p style="margin-top: 1em">core.done(data) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; data (any) --
Return some data for the caller. It is useful with
sample-fetches and sample-converters.</p>

<p style="margin-top: 1em">Immediately stops the current
Lua execution and returns to the caller which may be a
sample fetch, a converter or an action and returns the
specified value (ignored for <br>
actions). It is used when the LUA process finishes its work
and wants to give back the control to HAProxy without
executing the remaining code. It can be seen as a <br>
multi-level &quot;return&quot;.</p>

<p style="margin-top: 1em">core.yield() <br>
context: task, action, sample-fetch, converter</p>

<p style="margin-top: 1em">Give back the hand at the
HAProxy scheduler. It is used when the LUA processing
consumes a lot of processing time.</p>

<p style="margin-top: 1em">core.parse_addr(address) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; network -- is a
string describing an ipv4 or ipv6 address and optionally its
network length, like this: &quot;127.0.0.1/8&quot; or
&quot;aaaa::1234/32&quot;.</p>

<p style="margin-top: 1em">Returns <br>
a userdata containing network or nil if an error occurs.</p>

<p style="margin-top: 1em">Parse ipv4 or ipv6 adresses and
its facultative associated network.</p>

<p style="margin-top: 1em">core.match_addr(addr1, addr2)
<br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; addr1 -- is an
address created with &quot;core.parse_addr&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; addr2 -- is an
address created with &quot;core.parse_addr&quot;.</p>

<p style="margin-top: 1em">Returns <br>
boolean, true if the network of the addresses matche, else
returns false.</p>

<p style="margin-top: 1em">Match two networks. For example
&quot;127.0.0.1/32&quot; matchs &quot;127.0.0.0/8&quot;. The
order of network is not important.</p>

<p style="margin-top: 1em">core.tokenize(str, separators[,
noblank]) <br>
context: body, init, task, action, sample-fetch,
converter</p>

<p style="margin-top: 1em">This function is useful for
tokenizing an entry, or splitting some messages. :param
string str: The string which will be split. :param string
separators: A string con&acirc; <br>
taining a list of separators. :param boolean noblank: Ignore
empty entries. :returns: an array of string.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">local array =
core.tokenize(&quot;This function is useful, for tokenizing
an entry.&quot;, &quot;., &quot;, true) <br>
print_r(array) <br>
Returns this array:</p>

<p style="margin-top: 1em">(table) table: 0x21c01e0 [ <br>
1: (string) &quot;This&quot; <br>
2: (string) &quot;function&quot; <br>
3: (string) &quot;is&quot; <br>
4: (string) &quot;useful&quot; <br>
5: (string) &quot;for&quot; <br>
6: (string) &quot;tokenizing&quot; <br>
7: (string) &quot;an&quot; <br>
8: (string) &quot;entry&quot; <br>
]</p>

<p style="margin-top: 1em">class Proxy() <br>
This class provides a way for manipulating proxy and
retrieving information like statistics.</p>

<p style="margin-top: 1em">Proxy.servers <br>
Contain an array with the attached servers. Each server
entry is an object of type Server class.</p>

<p style="margin-top: 1em">Proxy.listeners <br>
Contain an array with the attached listeners. Each listeners
entry is an object of type Listener class.</p>

<p style="margin-top: 1em">Proxy.pause(px) <br>
Pause the proxy. See the management socket documentation for
more information.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; px (class_proxy)
-- A Proxy class which indicates the manipulated proxy.</p>

<p style="margin-top: 1em">Proxy.resume(px) <br>
Resume the proxy. See the management socket documentation
for more information.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; px (class_proxy)
-- A Proxy class which indicates the manipulated proxy.</p>

<p style="margin-top: 1em">Proxy.stop(px) <br>
Stop the proxy. See the management socket documentation for
more information.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; px (class_proxy)
-- A Proxy class which indicates the manipulated proxy.</p>

<p style="margin-top: 1em">Proxy.shut_bcksess(px) <br>
Kill the session attached to a backup server. See the
management socket documentation for more information.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; px (class_proxy)
-- A Proxy class which indicates the manipulated proxy.</p>

<p style="margin-top: 1em">Proxy.get_cap(px) <br>
Returns a string describing the capabilities of the
proxy.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; px (class_proxy)
-- A Proxy class which indicates the manipulated proxy.</p>

<p style="margin-top: 1em">Returns <br>
a string &quot;frontend&quot;, &quot;backend&quot;,
&quot;proxy&quot; or &quot;ruleset&quot;.</p>

<p style="margin-top: 1em">Proxy.get_mode(px) <br>
Returns a string describing the mode of the current
proxy.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; px (class_proxy)
-- A Proxy class which indicates the manipulated proxy.</p>

<p style="margin-top: 1em">Returns <br>
a string &quot;tcp&quot;, &quot;http&quot;,
&quot;health&quot; or &quot;unknown&quot;</p>

<p style="margin-top: 1em">Proxy.get_stats(px) <br>
Returns an array containg the proxy statistics. The
statistics returned are not the same if the proxy is
frontend or a backend.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; px (class_proxy)
-- A Proxy class which indicates the manipulated proxy.</p>

<p style="margin-top: 1em">Returns <br>
a key/value array containing stats</p>

<p style="margin-top: 1em">Server.is_draining(sv) <br>
Return true if the server is currently draining stiky
connections.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Returns <br>
a boolean</p>

<p style="margin-top: 1em">Server.set_weight(sv, weight)
<br>
Dynamically change the weight of the serveur. See the
management socket documentation for more information about
the format of the string.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">&Acirc;&middot; weight (string)
-- A string describing the server weight.</p>

<p style="margin-top: 1em">Server.get_weight(sv) <br>
This function returns an integer representing the serveur
weight.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Returns <br>
an integer.</p>

<p style="margin-top: 1em">Server.set_addr(sv, addr) <br>
Dynamically change the address of the serveur. See the
management socket documentation for more information about
the format of the string.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">&Acirc;&middot; weight (string)
-- A string describing the server address.</p>

<p style="margin-top: 1em">Server.get_addr(sv) <br>
Returns a string describing the address of the serveur.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Returns <br>
A string</p>

<p style="margin-top: 1em">Server.get_stats(sv) <br>
Returns server statistics.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Returns <br>
a key/value array containing stats</p>

<p style="margin-top: 1em">Server.shut_sess(sv) <br>
Shutdown all the sessions attached to the server. See the
management socket documentation for more information about
this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.set_drain(sv) <br>
Drain sticky sessions. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.set_maint(sv) <br>
Set maintenance mode. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.set_ready(sv) <br>
Set normal mode. See the management socket documentation for
more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.check_enable(sv) <br>
Enable health checks. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.check_disable(sv) <br>
Disable health checks. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.check_force_up(sv) <br>
Force health-check up. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.check_force_nolb(sv) <br>
Force health-check nolb mode. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.check_force_down(sv) <br>
Force health-check down. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.agent_enable(sv) <br>
Enable agent check. See the management socket documentation
for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.agent_disable(sv) <br>
Disable agent check. See the management socket documentation
for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.agent_force_up(sv) <br>
Force agent check up. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Server.agent_force_down(sv) <br>
Force agent check down. See the management socket
documentation for more information about this function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; sv
(class_server) -- A Server class which indicates the
manipulated server.</p>

<p style="margin-top: 1em">Listener.get_stats(ls) <br>
Returns server statistics.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; ls
(class_listener) -- A Listener class which indicates the
manipulated listener.</p>

<p style="margin-top: 1em">Returns <br>
a key/value array containing stats</p>

<p style="margin-top: 1em">class Concat() <br>
This class provides a fast way for string concatenation. The
way using native Lua concatenation like the code below is
slow for some reasons.</p>

<p style="margin-top: 1em">str = &quot;string1&quot; <br>
str = str .. &quot;, string2&quot; <br>
str = str .. &quot;, string3&quot; <br>
For each concatenation, Lua: * allocate memory for the
result, * catenate the two string copying the strings in the
new memory bloc, * free the old memory block containing the
<br>
string whoch is no longer used. This process does many
memory move, allocation and free. In addition, the memory is
not really freed, it is just mark mark as unsused and wait
<br>
for the garbage collector.</p>

<p style="margin-top: 1em">The Concat class provide an
alternative way for catenating strings. It uses the internal
Lua mechanism (it does not allocate memory), but it
doesn&rsquo;t copy the data more than <br>
once.</p>

<p style="margin-top: 1em">On my computer, the following
loops spends 0.2s for the Concat method and 18.5s for the
pure Lua implementation. So, the Concat class is about 1000x
faster than the embedded <br>
solution.</p>

<p style="margin-top: 1em">for j = 1, 100 do <br>
c = core.concat() <br>
for i = 1, 20000 do <br>
c:add(&quot;#####&quot;) <br>
end <br>
end</p>

<p style="margin-top: 1em">for j = 1, 100 do <br>
c = &quot;&quot; <br>
for i = 1, 20000 do <br>
c = c .. &quot;#####&quot; <br>
end <br>
end</p>

<p style="margin-top: 1em">Concat.add(concat, string) <br>
This function adds a string to the current concatenated
string.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; concat
(class_concat) -- A Concat class which contains the
currently builded string.</p>

<p style="margin-top: 1em">&Acirc;&middot; string (string)
-- A new string to concatenate to the current builded
string.</p>

<p style="margin-top: 1em">Concat.dump(concat) <br>
This function returns the concanated string.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; concat
(class_concat) -- A Concat class which contains the
currently builded string.</p>

<p style="margin-top: 1em">Returns <br>
the concatenated string</p>

<p style="margin-top: 1em">class Fetches() <br>
This class contains a lot of internal HAProxy sample
fetches. See the HAProxy &quot;configuration.txt&quot;
documentation for more information about her usage. they are
the chapters <br>
7.3.2 to 7.3.6.</p>

<p style="margin-top: 1em">warning some sample fetches are
not available in some context. These limitations are
specified in this documentation when theire useful.</p>

<p style="margin-top: 1em">See TXN.f</p>

<p style="margin-top: 1em">See TXN.sf</p>

<p style="margin-top: 1em">Fetches are useful for:</p>

<p style="margin-top: 1em">&Acirc;&middot; get system
time,</p>

<p style="margin-top: 1em">&Acirc;&middot; get environment
variable,</p>

<p style="margin-top: 1em">&Acirc;&middot; get random
numbers,</p>

<p style="margin-top: 1em">&Acirc;&middot; known backend
status like the number of users in queue or the number of
connections established,</p>

<p style="margin-top: 1em">&Acirc;&middot; client
information like ip source or destination,</p>

<p style="margin-top: 1em">&Acirc;&middot; deal with stick
tables,</p>

<p style="margin-top: 1em">&Acirc;&middot; Established SSL
informations,</p>

<p style="margin-top: 1em">&Acirc;&middot; HTTP information
like headers or method.</p>

<p style="margin-top: 1em">function action(txn) <br>
-- Get source IP <br>
local clientip = txn.f:src() <br>
end</p>

<p style="margin-top: 1em">class Converters() <br>
This class contains a lot of internal HAProxy sample
converters. See the HAProxy documentation
&quot;configuration.txt&quot; for more information about her
usage. Its the chapter <br>
7.3.1.</p>

<p style="margin-top: 1em">See TXN.c</p>

<p style="margin-top: 1em">See TXN.sc</p>

<p style="margin-top: 1em">Converters provides statefull
transformation. They are useful for:</p>

<p style="margin-top: 1em">&Acirc;&middot; converting input
to base64,</p>

<p style="margin-top: 1em">&Acirc;&middot; applying hash on
input string (djb2, crc32, sdbm, wt6),</p>

<p style="margin-top: 1em">&Acirc;&middot; format date,</p>

<p style="margin-top: 1em">&Acirc;&middot; json escape,</p>

<p style="margin-top: 1em">&Acirc;&middot; extracting
preferred language comparing two lists,</p>

<p style="margin-top: 1em">&Acirc;&middot; turn to lower or
upper chars,</p>

<p style="margin-top: 1em">&Acirc;&middot; deal with stick
tables.</p>

<p style="margin-top: 1em">class Channel() <br>
HAProxy uses two buffers for the processing of the requests.
The first one is used with the request data (from the client
to the server) and the second is used for the <br>
response data (from the server to the client).</p>

<p style="margin-top: 1em">Each buffer contains two types
of data. The first type is the incoming data waiting for a
processing. The second part is the outgoing data already
processed. Usually, the <br>
incoming data is processed, after it is tagged as outgoing
data, and finally it is sent. The following functions
provides tools for manipulating these data in a buffer.</p>

<p style="margin-top: 1em">The following diagram shows
where the channel class function are applied.</p>

<p style="margin-top: 1em">Warning: It is not possible to
read from the response in request action, and it is not
possible to read for the request channel in response action.
<br>
[image]</p>

<p style="margin-top: 1em">Channel.dup(channel) <br>
This function returns a string that contain the entire
buffer. The data is not remove from the buffer and can be
reprocessed later.</p>

<p style="margin-top: 1em">If the buffer cant receive more
data, a &rsquo;nil&rsquo; value is returned.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">Returns <br>
a string containing all the available data or nil.</p>

<p style="margin-top: 1em">Channel.get(channel) <br>
This function returns a string that contain the entire
buffer. The data is consumed from the buffer.</p>

<p style="margin-top: 1em">If the buffer cant receive more
data, a &rsquo;nil&rsquo; value is returned.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">Returns <br>
a string containing all the available data or nil.</p>

<p style="margin-top: 1em">Channel.getline(channel) <br>
This function returns a string that contain the first line
of the buffer. The data is consumed. If the data returned
doesn&rsquo;t contains a final &rsquo;n&rsquo; its assumed
than its the <br>
last available data in the buffer.</p>

<p style="margin-top: 1em">If the buffer cant receive more
data, a &rsquo;nil&rsquo; value is returned.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">Returns <br>
a string containing the available line or nil.</p>

<p style="margin-top: 1em">Channel.set(channel, string)
<br>
This function replace the content of the buffer by the
string. The function returns the copied length, otherwise,
it returns -1.</p>

<p style="margin-top: 1em">The data set with this function
are not send. They wait for the end of HAProxy processing,
so the buffer can be full.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">&Acirc;&middot; string (string)
-- The data which will sent.</p>

<p style="margin-top: 1em">Returns <br>
an integer containing the amount of bytes copied or -1.</p>

<p style="margin-top: 1em">Channel.append(channel, string)
<br>
This function append the string argument to the content of
the buffer. The function returns the copied length,
otherwise, it returns -1.</p>

<p style="margin-top: 1em">The data set with this function
are not send. They wait for the end of HAProxy processing,
so the buffer can be full.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">&Acirc;&middot; string (string)
-- The data which will sent.</p>

<p style="margin-top: 1em">Returns <br>
an integer containing the amount of bytes copied or -1.</p>

<p style="margin-top: 1em">Channel.send(channel, string)
<br>
This function required immediate send of the data. Unless if
the connection is close, the buffer is regularly flushed and
all the string can be sent.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">&Acirc;&middot; string (string)
-- The data which will sent.</p>

<p style="margin-top: 1em">Returns <br>
an integer containing the amount of bytes copied or -1.</p>

<p style="margin-top: 1em">Channel.get_in_length(channel)
<br>
This function returns the length of the input part of the
buffer.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">Returns <br>
an integer containing the amount of available bytes.</p>

<p style="margin-top: 1em">Channel.get_out_length(channel)
<br>
This function returns the length of the output part of the
buffer.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">Returns <br>
an integer containing the amount of available bytes.</p>

<p style="margin-top: 1em">Channel.forward(channel, int)
<br>
This function transfer bytes from the input part of the
buffer to the output part.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; channel
(class_channel) -- The manipulated Channel.</p>

<p style="margin-top: 1em">&Acirc;&middot; int (integer) --
The amount of data which will be forwarded.</p>

<p style="margin-top: 1em">Channel.is_full(channel) <br>
This function returns true if the buffer channel is
full.</p>

<p style="margin-top: 1em">Returns <br>
a boolean</p>

<p style="margin-top: 1em">class HTTP() <br>
This class contain all the HTTP manipulation functions.</p>

<p style="margin-top: 1em">HTTP.req_get_headers(http) <br>
Returns an array containing all the request headers.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">Returns <br>
array of headers.</p>

<p style="margin-top: 1em">See HTTP.res_get_headers()</p>

<p style="margin-top: 1em">This is the form of the returned
array:</p>


<p style="margin-top: 1em">HTTP:req_get_headers()[&rsquo;&lt;header-name&gt;&rsquo;][&lt;header-index&gt;]
= &quot;&lt;header-value&gt;&quot;</p>

<p style="margin-top: 1em">local hdr =
HTTP:req_get_headers() <br>
hdr[&quot;host&quot;][0] = &quot;www.test.com&quot; <br>
hdr[&quot;accept&quot;][0] = &quot;audio/basic q=1&quot;
<br>
hdr[&quot;accept&quot;][1] = &quot;audio/*, q=0.2&quot; <br>
hdr[&quot;accept&quot;][2] = &quot;*/*, q=0.1&quot;</p>

<p style="margin-top: 1em">HTTP.res_get_headers(http) <br>
Returns an array containing all the response headers.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">Returns <br>
array of headers.</p>

<p style="margin-top: 1em">See HTTP.req_get_headers()</p>

<p style="margin-top: 1em">This is the form of the returned
array:</p>


<p style="margin-top: 1em">HTTP:res_get_headers()[&rsquo;&lt;header-name&gt;&rsquo;][&lt;header-index&gt;]
= &quot;&lt;header-value&gt;&quot;</p>

<p style="margin-top: 1em">local hdr =
HTTP:req_get_headers() <br>
hdr[&quot;host&quot;][0] = &quot;www.test.com&quot; <br>
hdr[&quot;accept&quot;][0] = &quot;audio/basic q=1&quot;
<br>
hdr[&quot;accept&quot;][1] = &quot;audio/*, q=0.2&quot; <br>
hdr[&quot;accept&quot;][2] = &quot;*.*, q=0.1&quot;</p>

<p style="margin-top: 1em">HTTP.req_add_header(http, name,
value) <br>
Appends an HTTP header field in the request whose name is
specified in &quot;name&quot; and whose value is defined in
&quot;value&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">&Acirc;&middot; value (string)
-- The header value.</p>

<p style="margin-top: 1em">See HTTP.res_add_header()</p>

<p style="margin-top: 1em">HTTP.res_add_header(http, name,
value) <br>
appends an HTTP header field in the response whose name is
specified in &quot;name&quot; and whose value is defined in
&quot;value&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">&Acirc;&middot; value (string)
-- The header value.</p>

<p style="margin-top: 1em">See HTTP.req_add_header()</p>

<p style="margin-top: 1em">HTTP.req_del_header(http, name)
<br>
Removes all HTTP header fields in the request whose name is
specified in &quot;name&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">See HTTP.res_del_header()</p>

<p style="margin-top: 1em">HTTP.res_del_header(http, name)
<br>
Removes all HTTP header fields in the response whose name is
specified in &quot;name&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">See HTTP.req_del_header()</p>

<p style="margin-top: 1em">HTTP.req_set_header(http, name,
value) <br>
This variable replace all occurence of all header
&quot;name&quot;, by only one containing the
&quot;value&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">&Acirc;&middot; value (string)
-- The header value.</p>

<p style="margin-top: 1em">See HTTP.res_set_header()</p>

<p style="margin-top: 1em">This function does the same work
as the folowwing code:</p>

<p style="margin-top: 1em">function fcn(txn) <br>
TXN.http:req_del_header(&quot;header&quot;) <br>
TXN.http:req_add_header(&quot;header&quot;,
&quot;value&quot;) <br>
end</p>

<p style="margin-top: 1em">HTTP.res_set_header(http, name,
value) <br>
This variable replace all occurence of all header
&quot;name&quot;, by only one containing the
&quot;value&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">&Acirc;&middot; value (string)
-- The header value.</p>

<p style="margin-top: 1em">See HTTP.req_rep_header()</p>

<p style="margin-top: 1em">HTTP.req_rep_header(http, name,
regex, replace) <br>
Matches the regular expression in all occurrences of header
field &quot;name&quot; according to &quot;regex&quot;, and
replaces them with the &quot;replace&quot; argument. The
replacement value can <br>
contain back references like 1, 2, ... This function works
with the request.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">&Acirc;&middot; regex (string)
-- The match regular expression.</p>

<p style="margin-top: 1em">&Acirc;&middot; replace (string)
-- The replacement value.</p>

<p style="margin-top: 1em">See HTTP.res_rep_header()</p>

<p style="margin-top: 1em">HTTP.res_rep_header(http, name,
regex, string) <br>
Matches the regular expression in all occurrences of header
field &quot;name&quot; according to &quot;regex&quot;, and
replaces them with the &quot;replace&quot; argument. The
replacement value can <br>
contain back references like 1, 2, ... This function works
with the request.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
The header name.</p>

<p style="margin-top: 1em">&Acirc;&middot; regex (string)
-- The match regular expression.</p>

<p style="margin-top: 1em">&Acirc;&middot; replace (string)
-- The replacement value.</p>

<p style="margin-top: 1em">See
HTTP.req_replace_header()</p>

<p style="margin-top: 1em">HTTP.req_set_method(http,
method) <br>
Rewrites the request method with the parameter
&quot;method&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; method (string)
-- The new method.</p>

<p style="margin-top: 1em">HTTP.req_set_path(http, path)
<br>
Rewrites the request path with the &quot;path&quot;
parameter.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; path (string) --
The new path.</p>

<p style="margin-top: 1em">HTTP.req_set_query(http, query)
<br>
Rewrites the request&rsquo;s query string which appears
after the first question mark (&quot;?&quot;) with the
parameter &quot;query&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; query (string)
-- The new query.</p>

<p style="margin-top: 1em">HTTP.req_set_uri(http, uri) <br>
Rewrites the request URI with the parameter
&quot;uri&quot;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; uri (string) --
The new uri.</p>

<p style="margin-top: 1em">HTTP.res_set_status(http,
status[, reason]) <br>
Rewrites the response status code with the parameter
&quot;code&quot;.</p>

<p style="margin-top: 1em">If no custom reason is provided,
it will be generated from the status.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; http
(class_http) -- The related http object.</p>

<p style="margin-top: 1em">&Acirc;&middot; status (integer)
-- The new response status code.</p>

<p style="margin-top: 1em">&Acirc;&middot; reason (string)
-- The new response reason (optional).</p>

<p style="margin-top: 1em">class TXN() <br>
The txn class contain all the functions relative to the http
or tcp transaction (Note than a tcp stream is the same than
a tcp transaction, but an HTTP transaction is not <br>
the same than a tcp stream).</p>

<p style="margin-top: 1em">The usage of this class permits
to retrieve data from the requests, alter it and forward
it.</p>

<p style="margin-top: 1em">All the functions provided by
this class are available in the context sample-fetches and
actions.</p>

<p style="margin-top: 1em">TXN.c</p>

<p style="margin-top: 1em">Returns <br>
An Converters class.</p>

<p style="margin-top: 1em">This attribute contains a
Converters class object.</p>

<p style="margin-top: 1em">TXN.sc</p>

<p style="margin-top: 1em">Returns <br>
An Converters class.</p>

<p style="margin-top: 1em">This attribute contains a
Converters class object. The functions of this object
returns always a string.</p>

<p style="margin-top: 1em">TXN.f</p>

<p style="margin-top: 1em">Returns <br>
An Fetches class.</p>

<p style="margin-top: 1em">This attribute contains a
Fetches class object.</p>

<p style="margin-top: 1em">TXN.sf</p>

<p style="margin-top: 1em">Returns <br>
An Fetches class.</p>

<p style="margin-top: 1em">This attribute contains a
Fetches class object. The functions of this object returns
always a string.</p>

<p style="margin-top: 1em">TXN.req</p>

<p style="margin-top: 1em">Returns <br>
An Channel class.</p>

<p style="margin-top: 1em">This attribute contains a
channel class object for the request buffer.</p>

<p style="margin-top: 1em">TXN.res</p>

<p style="margin-top: 1em">Returns <br>
An Channel class.</p>

<p style="margin-top: 1em">This attribute contains a
channel class object for the response buffer.</p>

<p style="margin-top: 1em">TXN.http</p>

<p style="margin-top: 1em">Returns <br>
An HTTP class.</p>

<p style="margin-top: 1em">This attribute contains an HTTP
class object. It is avalaible only if the proxy has the
&quot;mode http&quot; enabled.</p>

<p style="margin-top: 1em">TXN.log(TXN, loglevel, msg) <br>
This function sends a log. The log is sent, according with
the HAProxy configuration file, on the default syslog server
if it is configured and on the stderr if it is <br>
allowed.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; loglevel
(integer) -- Is the log level asociated with the message. It
is a number between 0 and 7.</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See core.emerg, core.alert,
core.crit, core.err, core.warning, core.notice, core.info,
core.debug (log level definitions)</p>

<p style="margin-top: 1em">See TXN.deflog</p>

<p style="margin-top: 1em">See TXN.Debug</p>

<p style="margin-top: 1em">See TXN.Info</p>

<p style="margin-top: 1em">See TXN.Warning</p>

<p style="margin-top: 1em">See TXN.Alert</p>

<p style="margin-top: 1em">TXN.deflog(TXN, msg) <br>
Sends a log line with the default loglevel for the proxy
ssociated with the transaction.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See TXN.log</p>

<p style="margin-top: 1em">TXN.Debug(txn, msg)</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See TXN.log</p>

<p style="margin-top: 1em">Does the same job than:</p>

<p style="margin-top: 1em">function Debug(txn, msg) <br>
TXN.log(txn, core.debug, msg) <br>
end</p>

<p style="margin-top: 1em">TXN.Info(txn, msg)</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See TXN.log</p>

<p style="margin-top: 1em">function Debug(txn, msg) <br>
TXN.log(txn, core.info, msg) <br>
end</p>

<p style="margin-top: 1em">TXN.Warning(txn, msg)</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See TXN.log</p>

<p style="margin-top: 1em">function Debug(txn, msg) <br>
TXN.log(txn, core.warning, msg) <br>
end</p>

<p style="margin-top: 1em">TXN.Alert(txn, msg)</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
The log content.</p>

<p style="margin-top: 1em">See TXN.log</p>

<p style="margin-top: 1em">function Debug(txn, msg) <br>
TXN.log(txn, core.alert, msg) <br>
end</p>

<p style="margin-top: 1em">TXN.get_priv(txn) <br>
Return Lua data stored in the current transaction (with the
TXN.set_priv()) function. If no data are stored, it returns
a nil value.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">Returns <br>
the opaque data previsously stored, or nil if nothing is
avalaible.</p>

<p style="margin-top: 1em">TXN.set_priv(txn, data) <br>
Store any data in the current HAProxy transaction. This
action replace the old stored data.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; data (opaque) --
The data which is stored in the transaction.</p>

<p style="margin-top: 1em">TXN.set_var(TXN, var, value)
<br>
Converts a Lua type in a HAProxy type and store it in a
variable &lt;var&gt;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; var (string) --
The variable name according with the HAProxy variable
syntax.</p>

<p style="margin-top: 1em">&Acirc;&middot; value (type) --
The value associated to the variable. The type can be string
or integer.</p>

<p style="margin-top: 1em">TXN.unset_var(TXN, var) <br>
Unset the variable &lt;var&gt;.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; var (string) --
The variable name according with the HAProxy variable
syntax.</p>

<p style="margin-top: 1em">TXN.get_var(TXN, var) <br>
Returns data stored in the variable &lt;var&gt; converter in
Lua type.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; var (string) --
The variable name according with the HAProxy variable
syntax.</p>

<p style="margin-top: 1em">TXN.done(txn) <br>
This function terminates processing of the transaction and
the associated session. It can be used when a critical error
is detected or to terminate processing after some <br>
data have been returned to the client (eg: a redirect).</p>

<p style="margin-top: 1em">Warning: It not make sense to
call this function from sample-fetches. In this case the
behaviour of this one is the same than core.done(): it quit
the Lua execution. The <br>
transaction is really aborted only from an action registered
function.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">TXN.set_loglevel(txn, loglevel)
<br>
Is used to change the log level of the current request. The
&quot;loglevel&quot; must be an integer between 0 and 7.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; loglevel
(integer) -- The required log level. This variable can be
one of</p>

<p style="margin-top: 1em">See core.&lt;loglevel&gt;</p>

<p style="margin-top: 1em">TXN.set_tos(txn, tos) <br>
Is used to set the TOS or DSCP field value of packets sent
to the client to the value passed in &quot;tos&quot; on
platforms which support this.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; tos (integer) --
The new TOS os DSCP.</p>

<p style="margin-top: 1em">TXN.set_mark(txn, mark) <br>
Is used to set the Netfilter MARK on all packets sent to the
client to the value passed in &quot;mark&quot; on platforms
which support it.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; txn (class_txn)
-- The class txn object containing the data.</p>

<p style="margin-top: 1em">&Acirc;&middot; mark (integer)
-- The mark value.</p>

<p style="margin-top: 1em">class Socket() <br>
This class must be compatible with the Lua Socket class.
Only the &rsquo;client&rsquo; functions are available. See
the Lua Socket documentation:</p>


<p style="margin-top: 1em">http://w3.impa.br/~diego/software/luasocket/tcp.html</p>

<p style="margin-top: 1em">Socket.close(socket) <br>
Closes a TCP object. The internal socket used by the object
is closed and the local address to which the object was
bound is made available to other applications. No fur&acirc;
<br>
ther operations (except for further calls to the close
method) are allowed on a closed Socket.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">Note: It is important to close
all used sockets once they are not needed, since, in many
systems, each socket uses a file descriptor, which are
limited system resources. <br>
Garbage-collected objects are automatically closed before
destruction, though.</p>

<p style="margin-top: 1em">Socket.connect(socket, address[,
port]) <br>
Attempts to connect a socket object to a remote host.</p>

<p style="margin-top: 1em">In case of error, the method
returns nil followed by a string describing the error. In
case of success, the method returns 1.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">&Acirc;&middot; address (string)
-- can be an IP address or a host name. See below for more
information.</p>

<p style="margin-top: 1em">&Acirc;&middot; port (integer)
-- must be an integer number in the range [1..64K].</p>

<p style="margin-top: 1em">Returns <br>
1 or nil.</p>

<p style="margin-top: 1em">an address field extension
permits to use the connect() function to connect to other
stream than TCP. The syntax containing a simpleipv4 or ipv6
address is the basically <br>
expected format. This format requires the port.</p>

<p style="margin-top: 1em">Other format accepted are a
socket path like &quot;/socket/path&quot;, it permits to
connect to a socket. abstract namespaces are supported with
the prefix &quot;abns@&quot;, and finaly a <br>
filedescriotr can be passed with the prefix &quot;fd@&quot;.
The prefix &quot;ipv4@&quot;, &quot;ipv6@&quot; and
&quot;unix@&quot; are also supported. The port can be passed
int the string. The syntax <br>
&quot;127.0.0.1:1234&quot; is valid. in this case, the
parameter port is ignored.</p>

<p style="margin-top: 1em">Socket.connect_ssl(socket,
address, port) <br>
Same behavior than the function socket:connect, but uses
SSL.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">Returns <br>
1 or nil.</p>

<p style="margin-top: 1em">Socket.getpeername(socket) <br>
Returns information about the remote side of a connected
client object.</p>

<p style="margin-top: 1em">Returns a string with the IP
address of the peer, followed by the port number that peer
is using for the connection. In case of error, the method
returns nil.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">Returns <br>
a string containing the server information.</p>

<p style="margin-top: 1em">Socket.getsockname(socket) <br>
Returns the local address information associated to the
object.</p>

<p style="margin-top: 1em">The method returns a string with
local IP address and a number with the port. In case of
error, the method returns nil.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">Returns <br>
a string containing the client information.</p>

<p style="margin-top: 1em">Socket.receive(socket[,
pattern[, prefix]]) <br>
Reads data from a client object, according to the specified
read pattern. Patterns follow the Lua file I/O format, and
the difference in performance between all patterns <br>
is negligible.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">&Acirc;&middot; pattern
(string|integer) -- Describe what is required (see
below).</p>

<p style="margin-top: 1em">&Acirc;&middot; prefix (string)
-- A string which will be prefix the returned data.</p>

<p style="margin-top: 1em">Returns <br>
a string containing the required data or nil.</p>

<p style="margin-top: 1em">Pattern can be any of the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">&lsquo;*a&lsquo;: reads from the
socket until the connection is closed. No <br>
end-of-line translation is performed;</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">&lsquo;*l&lsquo;: reads a line
of text from the Socket. The line is terminated by a <br>
LF character (ASCII 10), optionally preceded by a CR
character (ASCII 13). The CR and LF characters are not
included in the returned line. In fact, all CR char&acirc;
<br>
acters are ignored by the pattern. This is the default
pattern.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">number: causes the method to
read a specified number of bytes from the <br>
Socket. Prefix is an optional string to be concatenated to
the beginning of any received data before return.</p>

<p style="margin-top: 1em">&Acirc;&middot; empty: If the
pattern is left empty, the default option is *l.</p>

<p style="margin-top: 1em">If successful, the method
returns the received pattern. In case of error, the method
returns nil followed by an error message which can be the
string &rsquo;closed&rsquo; in case the <br>
connection was closed before the transmission was completed
or the string &rsquo;timeout&rsquo; in case there was a
timeout during the operation. Also, after the error message,
the <br>
function returns the partial result of the transmission.</p>

<p style="margin-top: 1em">Important note: This function
was changed severely. It used to support multiple patterns
(but I have never seen this feature used) and now it
doesn&rsquo;t anymore. Partial <br>
results used to be returned in the same way as successful
results. This last feature violated the idea that all
functions should return nil on error. Thus it was changed
<br>
too.</p>

<p style="margin-top: 1em">Socket.send(socket, data[,
start[, end]]) <br>
Sends data through client object.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">&Acirc;&middot; data (string) --
The data that will be sent.</p>

<p style="margin-top: 1em">&Acirc;&middot; start (integer)
-- The start position in the buffer of the data which will
be sent.</p>

<p style="margin-top: 1em">&Acirc;&middot; end (integer) --
The end position in the buffer of the data which will be
sent.</p>

<p style="margin-top: 1em">Returns <br>
see below.</p>

<p style="margin-top: 1em">Data is the string to be sent.
The optional arguments i and j work exactly like the
standard string.sub Lua function to allow the selection of a
substring to be sent.</p>

<p style="margin-top: 1em">If successful, the method
returns the index of the last byte within [start, end] that
has been sent. Notice that, if start is 1 or absent, this is
effectively the total <br>
number of bytes sent. In case of error, the method returns
nil, followed by an error message, followed by the index of
the last byte within [start, end] that has been <br>
sent. You might want to try again from the byte following
that. The error message can be &rsquo;closed&rsquo; in case
the connection was closed before the transmission was
completed <br>
or the string &rsquo;timeout&rsquo; in case there was a
timeout during the operation.</p>

<p style="margin-top: 1em">Note: Output is not buffered.
For small strings, it is always better to concatenate them
in Lua (with the &rsquo;..&rsquo; operator) and send the
result in one call instead of calling <br>
the method several times.</p>

<p style="margin-top: 1em">Socket.setoption(socket,
option[, value]) <br>
Just implemented for compatibility, this cal does
nothing.</p>

<p style="margin-top: 1em">Socket.settimeout(socket,
value[, mode]) <br>
Changes the timeout values for the object. All I/O
operations are blocking. That is, any call to the methods
send, receive, and accept will block indefinitely, until the
<br>
operation completes. The settimeout method defines a limit
on the amount of time the I/O methods can block. When a
timeout time has elapsed, the affected methods give up <br>
and fail with an error code.</p>

<p style="margin-top: 1em">The amount of time to wait is
specified as the value parameter, in seconds.</p>

<p style="margin-top: 1em">The timeout modes are bot
implemented, the only settable timeout is the inactivity
time waiting for complete the internal buffer send or
waiting for receive data.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; socket
(class_socket) -- Is the manipulated Socket.</p>

<p style="margin-top: 1em">&Acirc;&middot; value (integer)
-- The timeout value.</p>

<p style="margin-top: 1em">class Map() <br>
This class permits to do some lookup in HAProxy maps. The
declared maps can be modified during the runtime throught
the HAProxy management socket.</p>

<p style="margin-top: 1em">default = &quot;usa&quot;</p>

<p style="margin-top: 1em">-- Create and load map <br>
geo = Map.new(&quot;geo.map&quot;, Map.ip);</p>

<p style="margin-top: 1em">-- Create new fetch that returns
the user country <br>
core.register_fetches(&quot;country&quot;, function(txn)
<br>
local src; <br>
local loc;</p>

<p style="margin-top: 1em">src =
txn.f:fhdr(&quot;x-forwarded-for&quot;); <br>
if (src == nil) then <br>
src = txn.f:src() <br>
if (src == nil) then <br>
return default; <br>
end <br>
end</p>

<p style="margin-top: 1em">-- Perform lookup <br>
loc = geo:lookup(src);</p>

<p style="margin-top: 1em">if (loc == nil) then <br>
return default; <br>
end</p>

<p style="margin-top: 1em">return loc; <br>
end);</p>

<p style="margin-top: 1em">Map.int <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.ip See the HAProxy
configuration.txt file, chapter &quot;Using ACLs and
fetching samples&quot; ans subchapter &quot;ACL basics&quot;
to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.str <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.beg <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.sub <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.dir <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.dom <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.end <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.reg <br>
See the HAProxy configuration.txt file, chapter &quot;Using
ACLs and fetching samples&quot; ans subchapter &quot;ACL
basics&quot; to understand this pattern matching method.</p>

<p style="margin-top: 1em">Map.new(file, method) <br>
Creates and load a map.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; file (string) --
Is the file containing the map.</p>

<p style="margin-top: 1em">&Acirc;&middot; method (integer)
-- Is the map pattern matching method. See the attributes of
the Map class.</p>

<p style="margin-top: 1em">Returns <br>
a class Map object.</p>

<p style="margin-top: 1em">See The Map attributes.</p>

<p style="margin-top: 1em">Map.lookup(map, str) <br>
Perform a lookup in a map.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; map (class_map)
-- Is the class Map object.</p>

<p style="margin-top: 1em">&Acirc;&middot; str (string) --
Is the string used as key.</p>

<p style="margin-top: 1em">Returns <br>
a string containing the result or nil if no match.</p>

<p style="margin-top: 1em">Map.slookup(map, str) <br>
Perform a lookup in a map.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; map (class_map)
-- Is the class Map object.</p>

<p style="margin-top: 1em">&Acirc;&middot; str (string) --
Is the string used as key.</p>

<p style="margin-top: 1em">Returns <br>
a string containing the result or empty string if no
match.</p>

<p style="margin-top: 1em">class AppletHTTP() <br>
This class is used with applets that requires the
&rsquo;http&rsquo; mode. The http applet can be registered
with the core.register_service() function. They are used for
processing an <br>
http request like a server in back of HAProxy.</p>

<p style="margin-top: 1em">This is an hello world sample
code:</p>


<p style="margin-top: 1em">core.register_service(&quot;hello-world&quot;,
&quot;http&quot;, function(applet) <br>
local response = &quot;Hello World !&quot; <br>
applet:set_status(200) <br>
applet:add_header(&quot;content-length&quot;,
string.len(response)) <br>
applet:add_header(&quot;content-type&quot;,
&quot;text/plain&quot;) <br>
applet:start_response() <br>
applet:send(response) <br>
end)</p>

<p style="margin-top: 1em">AppletHTTP.c</p>

<p style="margin-top: 1em">Returns <br>
A Converters class</p>

<p style="margin-top: 1em">This attribute contains a
Converters class object.</p>

<p style="margin-top: 1em">AppletHTTP.sc</p>

<p style="margin-top: 1em">Returns <br>
A Converters class</p>

<p style="margin-top: 1em">This attribute contains a
Converters class object. The functions of this object
returns always a string.</p>

<p style="margin-top: 1em">AppletHTTP.f</p>

<p style="margin-top: 1em">Returns <br>
A Fetches class</p>

<p style="margin-top: 1em">This attribute contains a
Fetches class object. Note that the applet execution place
cannot access to a valid HAProxy core HTTP transaction, so
some sample fecthes related <br>
to the HTTP dependant values (hdr, path, ...) are not
available.</p>

<p style="margin-top: 1em">AppletHTTP.sf</p>

<p style="margin-top: 1em">Returns <br>
A Fetches class</p>

<p style="margin-top: 1em">This attribute contains a
Fetches class object. The functions of this object returns
always a string. Note that the applet execution place cannot
access to a valid HAProxy <br>
core HTTP transaction, so some sample fecthes related to the
HTTP dependant values (hdr, path, ...) are not
available.</p>

<p style="margin-top: 1em">AppletHTTP.method</p>

<p style="margin-top: 1em">Returns <br>
string</p>

<p style="margin-top: 1em">The attribute method returns a
string containing the HTTP method.</p>

<p style="margin-top: 1em">AppletHTTP.version</p>

<p style="margin-top: 1em">Returns <br>
string</p>

<p style="margin-top: 1em">The attribute version, returns a
string containing the HTTP request version.</p>

<p style="margin-top: 1em">AppletHTTP.path</p>

<p style="margin-top: 1em">Returns <br>
string</p>

<p style="margin-top: 1em">The attribute path returns a
string containing the HTTP request path.</p>

<p style="margin-top: 1em">AppletHTTP.qs</p>

<p style="margin-top: 1em">Returns <br>
string</p>

<p style="margin-top: 1em">The attribute qs returns a
string containing the HTTP request query string.</p>

<p style="margin-top: 1em">AppletHTTP.length</p>

<p style="margin-top: 1em">Returns <br>
integer</p>

<p style="margin-top: 1em">The attribute length returns an
integer containing the HTTP body length.</p>

<p style="margin-top: 1em">AppletHTTP.headers</p>

<p style="margin-top: 1em">Returns <br>
array</p>

<p style="margin-top: 1em">The attribute headers returns an
array containing the HTTP headers. The header names are
always in lower case. As the header name can be encountered
more than once in each <br>
request, the value is indexed with 0 as first index value.
The array have this form:</p>


<p style="margin-top: 1em">AppletHTTP.headers[&rsquo;&lt;header-name&gt;&rsquo;][&lt;header-index&gt;]
= &quot;&lt;header-value&gt;&quot;</p>


<p style="margin-top: 1em">AppletHTTP.headers[&quot;host&quot;][0]
= &quot;www.test.com&quot; <br>
AppletHTTP.headers[&quot;accept&quot;][0] =
&quot;audio/basic q=1&quot; <br>
AppletHTTP.headers[&quot;accept&quot;][1] = &quot;audio/*,
q=0.2&quot; <br>
AppletHTTP.headers[&quot;accept&quot;][2] = &quot;*/*,
q=0.1&quot;</p>

<p style="margin-top: 1em">AppletHTTP.set_status(applet,
code[, reason]) <br>
This function sets the HTTP status code for the response.
The allowed code are from 100 to 599.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">&Acirc;&middot; code (integer)
-- the status code returned to the client.</p>

<p style="margin-top: 1em">&Acirc;&middot; reason (string)
-- the status reason returned to the client (optional).</p>

<p style="margin-top: 1em">AppletHTTP.add_header(applet,
name, value) <br>
This function add an header in the response. Duplicated
headers are not collapsed. The special header content-length
is used to determinate the response length. If it not <br>
exists, a transfer-encoding: chunked is set, and all the
write from the funcion AppletHTTP:send() become a chunk.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">&Acirc;&middot; name (string) --
the header name</p>

<p style="margin-top: 1em">&Acirc;&middot; value (string)
-- the header value</p>


<p style="margin-top: 1em">AppletHTTP.start_response(applet)
<br>
This function indicates to the HTTP engine that it can
process and send the response headers. After this called we
cannot add headers to the response; We cannot use the <br>
AppletHTTP:send() function if the
AppletHTTP:start_response() is not called.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">AppletHTTP.getline(applet) <br>
This function returns a string containing one line from the
http body. If the data returned doesn&rsquo;t contains a
final &rsquo;0 its assumed than its the last available data
<br>
before the end of stream.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">Returns <br>
a string. The string can be empty if we reach the end of the
stream.</p>

<p style="margin-top: 1em">AppletHTTP.receive(applet[,
size]) <br>
Reads data from the HTTP body, according to the specified
read size. If the size is missing, the function tries to
read all the content of the stream until the end. If the
<br>
size is bigger than the http body, it returns the amount of
data avalaible.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">&Acirc;&middot; size (integer)
-- the required read size.</p>

<p style="margin-top: 1em">Returns <br>
always return a string,the string can be empty is the
connexion is closed.</p>

<p style="margin-top: 1em">AppletHTTP.send(applet, msg)
<br>
Send the message msg on the http request body.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
the message to send.</p>

<p style="margin-top: 1em">AppletHTTP.get_priv(applet) <br>
Return Lua data stored in the current transaction (with the
AppletHTTP.set_priv()) function. If no data are stored, it
returns a nil value.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">Returns <br>
the opaque data previsously stored, or nil if nothing is
avalaible.</p>

<p style="margin-top: 1em">AppletHTTP.set_priv(applet,
data) <br>
Store any data in the current HAProxy transaction. This
action replace the old stored data.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletHTTP) -- An AppletHTTP class</p>

<p style="margin-top: 1em">&Acirc;&middot; data (opaque) --
The data which is stored in the transaction.</p>

<p style="margin-top: 1em">class AppletTCP() <br>
This class is used with applets that requires the
&rsquo;tcp&rsquo; mode. The tcp applet can be registered
with the core.register_service() function. They are used for
processing a <br>
tcp stream like a server in back of HAProxy.</p>

<p style="margin-top: 1em">AppletTCP.c</p>

<p style="margin-top: 1em">Returns <br>
A Converters class</p>

<p style="margin-top: 1em">This attribute contains a
Converters class object.</p>

<p style="margin-top: 1em">AppletTCP.sc</p>

<p style="margin-top: 1em">Returns <br>
A Converters class</p>

<p style="margin-top: 1em">This attribute contains a
Converters class object. The functions of this object
returns always a string.</p>

<p style="margin-top: 1em">AppletTCP.f</p>

<p style="margin-top: 1em">Returns <br>
A Fetches class</p>

<p style="margin-top: 1em">This attribute contains a
Fetches class object.</p>

<p style="margin-top: 1em">AppletTCP.sf</p>

<p style="margin-top: 1em">Returns <br>
A Fetches class</p>

<p style="margin-top: 1em">This attribute contains a
Fetches class object.</p>

<p style="margin-top: 1em">AppletTCP.getline(applet) <br>
This function returns a string containing one line from the
stream. If the data returned doesn&rsquo;t contains a final
&rsquo;0 its assumed than its the last available data before
<br>
the end of stream.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletTCP) -- An AppletTCP class</p>

<p style="margin-top: 1em">Returns <br>
a string. The string can be empty if we reach the end of the
stream.</p>

<p style="margin-top: 1em">AppletTCP.receive(applet[,
size]) <br>
Reads data from the TCP stream, according to the specified
read size. If the size is missing, the function tries to
read all the content of the stream until the end.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletTCP) -- An AppletTCP class</p>

<p style="margin-top: 1em">&Acirc;&middot; size (integer)
-- the required read size.</p>

<p style="margin-top: 1em">Returns <br>
always return a string,the string can be empty is the
connexion is closed.</p>

<p style="margin-top: 1em">AppletTCP.send(appletmsg) <br>
Send the message on the stream.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletTCP) -- An AppletTCP class</p>

<p style="margin-top: 1em">&Acirc;&middot; msg (string) --
the message to send.</p>

<p style="margin-top: 1em">AppletTCP.get_priv(applet) <br>
Return Lua data stored in the current transaction (with the
AppletTCP.set_priv()) function. If no data are stored, it
returns a nil value.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletTCP) -- An AppletTCP class</p>

<p style="margin-top: 1em">Returns <br>
the opaque data previsously stored, or nil if nothing is
avalaible.</p>

<p style="margin-top: 1em">AppletTCP.set_priv(applet, data)
<br>
Store any data in the current HAProxy transaction. This
action replace the old stored data.</p>

<p style="margin-top: 1em">Arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; applet
(class_AppletTCP) -- An AppletTCP class</p>

<p style="margin-top: 1em">&Acirc;&middot; data (opaque) --
The data which is stored in the transaction.</p>

<p style="margin-top: 1em">A lot of useful lua libraries
can be found here:</p>

<p style="margin-top: 1em">&Acirc;&middot;
https://lua-toolbox.com/</p>

<p style="margin-top: 1em">Redis acces:</p>

<p style="margin-top: 1em">&Acirc;&middot;
https://github.com/nrk/redis-lua</p>

<p style="margin-top: 1em">This is an example about the
usage of the Redis library with HAProxy. Note that each call
of any function of this library can throw an error if the
socket connection fails.</p>

<p style="margin-top: 1em">-- load the redis library <br>
local redis = require(&quot;redis&quot;);</p>

<p style="margin-top: 1em">function do_something(txn)</p>

<p style="margin-top: 1em">-- create and connect new tcp
socket <br>
local tcp = core.tcp(); <br>
tcp:settimeout(1); <br>
tcp:connect(&quot;127.0.0.1&quot;, 6379);</p>

<p style="margin-top: 1em">-- use the redis library with
this new socket <br>
local client = redis.connect({socket=tcp}); <br>
client:ping();</p>

<p style="margin-top: 1em">end</p>

<p style="margin-top: 1em">OpenSSL:</p>

<p style="margin-top: 1em">&Acirc;&middot;
http://mkottman.github.io/luacrypto/index.html</p>

<p style="margin-top: 1em">&Acirc;&middot;
https://github.com/brunoos/luasec/wiki</p>

<p style="margin-top: 1em">AUTHOR <br>
Thierry FOURNIER</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2017, Thierry FOURNIER</p>

<p style="margin-top: 1em">1.0 Jan 13, 2017
HAPROXY-LUA(1)</p>
<hr>
</body>
</html>
