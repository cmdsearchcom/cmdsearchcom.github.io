<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:29:05 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OPENSHIFT CLI(1) June 2016 OPENSHIFT CLI(1)</p>

<p style="margin-top: 1em">NAME <br>
openshift cli start-build - Start a new build</p>

<p style="margin-top: 1em">SYNOPSIS <br>
openshift cli start-build [OPTIONS]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Start a build</p>

<p style="margin-top: 1em">This command starts a new build
for the provided build config or copies an existing build
using --from-build= &lt;name&gt;. Pass the --follow flag to
see output from the build.</p>

<p style="margin-top: 1em">In addition, you can pass a
file, directory, or source code repository with the
--from-file, --from-dir, or --from-repo flags directly to
the build. The contents will be streamed <br>
to the build and override the current build source settings.
When using --from-repo, the --commit flag can be used to
control which branch, tag, or commit is sent to the server.
<br>
If you pass --from-file, the file is placed in the root of
an empty directory with the same filename. It is also
possible to pass a http or https url to --from-file and <br>
--from-archive, however authentication is not supported and
in case of https the certificate must be valid and
recognized by your system.</p>

<p style="margin-top: 1em">Note that builds triggered from
binary input will not preserve the source on the server, so
rebuilds triggered by base image changes will use the source
specified on the build <br>
config.</p>

<p style="margin-top: 1em">OPTIONS <br>
--build-loglevel=&quot;&quot; <br>
Specify the log level for the build log output</p>

<p style="margin-top: 1em">--commit=&quot;&quot; <br>
Specify the source code commit identifier the build should
use; requires a build based on a Git repository</p>

<p style="margin-top: 1em">-e, --env=[] <br>
Specify a key-value pair for an environment variable to set
for the build container.</p>

<p style="margin-top: 1em">-F, --follow=false <br>
Start a build and watch its logs until it completes or
fails</p>

<p style="margin-top: 1em">--from-archive=&quot;&quot; <br>
An archive (tar, tar.gz, zip) to be extracted before the
build and used as the binary input.</p>

<p style="margin-top: 1em">--from-build=&quot;&quot; <br>
Specify the name of a build which should be re-run</p>

<p style="margin-top: 1em">--from-dir=&quot;&quot; <br>
A directory to archive and use as the binary input for a
build.</p>

<p style="margin-top: 1em">--from-file=&quot;&quot; <br>
A file to use as the binary input for the build; example a
pom.xml or Dockerfile. Will be the only file in the build
source.</p>

<p style="margin-top: 1em">--from-repo=&quot;&quot; <br>
The path to a local source code repository to use as the
binary input for a build.</p>

<p style="margin-top: 1em">--from-webhook=&quot;&quot; <br>
Specify a generic webhook URL for an existing build config
to trigger</p>

<p style="margin-top: 1em">--git-post-receive=&quot;&quot;
<br>
The contents of the post-receive hook to trigger a build</p>

<p style="margin-top: 1em">--git-repository=&quot;&quot;
<br>
The path to the git repository for post-receive; defaults to
the current directory</p>

<p style="margin-top: 1em">--list-webhooks=&quot;&quot;
<br>
List the webhooks for the specified build config or build;
accepts &rsquo;all&rsquo;, &rsquo;generic&rsquo;, or
&rsquo;github&rsquo;</p>

<p style="margin-top: 1em">-o, --output=&quot;&quot; <br>
Output mode. Use &quot;-o name&quot; for shorter output
(resource/name).</p>

<p style="margin-top: 1em">-w, --wait=false <br>
Wait for a build to complete and exit with a non-zero return
code if the build fails</p>

<p style="margin-top: 1em">OPTIONS INHERITED FROM PARENT
COMMANDS <br>
--api-version=&quot;&quot; <br>
DEPRECATED: The API version to use when talking to the
server</p>

<p style="margin-top: 1em">--as=&quot;&quot; <br>
Username to impersonate for the operation</p>


<p style="margin-top: 1em">--azure-container-registry-config=&quot;&quot;
<br>
Path to the file container Azure container registry
configuration information.</p>


<p style="margin-top: 1em">--certificate-authority=&quot;&quot;
<br>
Path to a cert. file for the certificate authority</p>


<p style="margin-top: 1em">--client-certificate=&quot;&quot;
<br>
Path to a client certificate file for TLS</p>

<p style="margin-top: 1em">--client-key=&quot;&quot; <br>
Path to a client key file for TLS</p>

<p style="margin-top: 1em">--cluster=&quot;&quot; <br>
The name of the kubeconfig cluster to use</p>

<p style="margin-top: 1em">--config=&quot;&quot; <br>
Path to the config file to use for CLI requests.</p>

<p style="margin-top: 1em">--context=&quot;&quot; <br>
The name of the kubeconfig context to use</p>

<p style="margin-top: 1em">--google-json-key=&quot;&quot;
<br>
The Google Cloud Platform Service Account JSON Key to use
for authentication.</p>


<p style="margin-top: 1em">--insecure-skip-tls-verify=false
<br>
If true, the server&rsquo;s certificate will not be checked
for validity. This will make your HTTPS connections
insecure</p>

<p style="margin-top: 1em">--log-flush-frequency=0 <br>
Maximum number of seconds between log flushes</p>

<p style="margin-top: 1em">--match-server-version=false
<br>
Require server version to match client version</p>

<p style="margin-top: 1em">-n, --namespace=&quot;&quot;
<br>
If present, the namespace scope for this CLI request</p>

<p style="margin-top: 1em">--request-timeout=&quot;0&quot;
<br>
The length of time to wait before giving up on a single
server request. Non-zero values should contain a
corresponding time unit (e.g. 1s, 2m, 3h). A value of zero
means <br>
don&rsquo;t timeout requests.</p>

<p style="margin-top: 1em">--server=&quot;&quot; <br>
The address and port of the Kubernetes API server</p>

<p style="margin-top: 1em">--token=&quot;&quot; <br>
Bearer token for authentication to the API server</p>

<p style="margin-top: 1em">--user=&quot;&quot; <br>
The name of the kubeconfig user to use</p>

<p style="margin-top: 1em">EXAMPLE <br>
# Starts build from build config &quot;hello-world&quot;
<br>
openshift cli start-build hello-world</p>

<p style="margin-top: 1em"># Starts build from a previous
build &quot;hello-world-1&quot; <br>
openshift cli start-build --from-build=hello-world-1</p>

<p style="margin-top: 1em"># Use the contents of a
directory as build input <br>
openshift cli start-build hello-world --from-dir=src/</p>

<p style="margin-top: 1em"># Send the contents of a Git
repository to the server from tag &rsquo;v2&rsquo; <br>
openshift cli start-build hello-world
--from-repo=../hello-world --commit=v2</p>

<p style="margin-top: 1em"># Start a new build for build
config &quot;hello-world&quot; and watch the logs until the
build <br>
# completes or fails. <br>
openshift cli start-build hello-world --follow</p>

<p style="margin-top: 1em"># Start a new build for build
config &quot;hello-world&quot; and wait until the build
completes. It <br>
# exits with a non-zero return code if the build fails. <br>
openshift cli start-build hello-world --wait</p>

<p style="margin-top: 1em">SEE ALSO <br>
openshift-cli(1),</p>

<p style="margin-top: 1em">HISTORY <br>
June 2016, Ported from the Kubernetes man-doc generator</p>

<p style="margin-top: 1em">Openshift Openshift CLI User
Manuals OPENSHIFT CLI(1)</p>
<hr>
</body>
</html>
