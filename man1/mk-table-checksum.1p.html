<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:25:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MK-TABLE-CHECKSUM(1) User Contributed Perl Documentation
MK-TABLE-CHECKSUM(1)</p>

<p style="margin-top: 1em">NAME <br>
mk-table-checksum - Perform an online replication
consistency check, or checksum MySQL tables efficiently on
one or many servers.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
Usage: mk-table-checksum [OPTION...] DSN [DSN...]</p>

<p style="margin-top: 1em">mk-table-checksum checksums
MySQL tables efficiently on one or more hosts. Each host is
specified as a DSN and missing values are inherited from the
first host. If you specify <br>
multiple hosts, the first is assumed to be the master.</p>

<p style="margin-top: 1em">STOP! Are you checksumming a
slave(s) against its master? Then be sure to learn what
&quot;--replicate&quot; does. It is probably the option you
want to use.</p>

<p style="margin-top: 1em">mk-table-checksum
--replicate=mydb.checksum master-host <br>
... time passses, replication catches up ... <br>
mk-table-checksum --replicate=mydb.checksum
--replicate-check 2 master-host</p>

<p style="margin-top: 1em">Or,</p>

<p style="margin-top: 1em">mk-table-checksum
h=host1,u=user,p=password h=host2 ...</p>

<p style="margin-top: 1em">Or,</p>

<p style="margin-top: 1em">mk-table-checksum host1 host2
... hostN | mk-checksum-filter</p>

<p style="margin-top: 1em">See &quot;SPECIFYING HOSTS&quot;
for more on the syntax of the host arguments.</p>

<p style="margin-top: 1em">RISKS <br>
The following section is included to inform users about the
potential risks, whether known or unknown, of using this
tool. The two main categories of risks are those created by
<br>
the nature of the tool (e.g. read-only tools vs. read-write
tools) and those created by bugs.</p>

<p style="margin-top: 1em">mk-table-checksum executes
queries that cause the MySQL server to checksum its data.
This can cause significant server load. It is read-only
unless you use the &quot;--replicate&quot; <br>
option, in which case it inserts a small amount of data into
the specified table.</p>

<p style="margin-top: 1em">At the time of this release, we
know of no bugs that could cause serious harm to users.
There are miscellaneous bugs that might be annoying.</p>

<p style="margin-top: 1em">The authoritative source for
updated information is always the online issue tracking
system. Issues that affect this tool will be marked as such.
You can see a list of such <br>
issues at the following URL:
&lt;http://www.maatkit.org/bugs/mk-table-checksum&gt;.</p>

<p style="margin-top: 1em">See also &quot;BUGS&quot; for
more information on filing bugs and getting help.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
mk-table-checksum generates table checksums for MySQL
tables, typically useful for verifying your slaves are in
sync with the master. The checksums are generated by a query
on <br>
the server, and there is very little network traffic as a
result.</p>

<p style="margin-top: 1em">Checksums typically take about
twice as long as COUNT(*) on very large InnoDB tables in my
tests. For smaller tables, COUNT(*) is a good bit faster
than the checksums. See <br>
&quot;--algorithm&quot; for more details on performance.</p>

<p style="margin-top: 1em">If you specify more than one
server, mk-table-checksum assumes the first server is the
master and others are slaves. Checksums are parallelized for
speed, forking off a child <br>
process for each table. Duplicate server names are ignored,
but if you want to checksum a server against itself you can
use two different forms of the hostname (for example, <br>
&quot;localhost 127.0.0.1&quot;, or &quot;h=localhost,P=3306
h=localhost,P=3307&quot;).</p>

<p style="margin-top: 1em">If you want to compare the
tables in one database to those in another database on the
same server, just checksum both databases:</p>

<p style="margin-top: 1em">mk-table-checksum --databases
db1,db2</p>

<p style="margin-top: 1em">You can then use
mk-checksum-filter to compare the results in both databases
easily.</p>

<p style="margin-top: 1em">mk-table-checksum examines table
structure only on the first host specified, so if anything
differs on the others, it won&rsquo;t notice. It ignores
views.</p>

<p style="margin-top: 1em">The checksums work on MySQL
version 3.23.58 through 6.0-alpha. They will not necessarily
produce the same values on all versions. Differences in
formatting and/or space-padding <br>
between 4.1 and 5.0, for example, will cause the checksums
to be different.</p>

<p style="margin-top: 1em">SPECIFYING HOSTS <br>
mk-table-checksum connects to a theoretically unlimited
number of MySQL servers. You specify a list of one or more
host definitions on the command line, such as &quot;host1
host2&quot;. <br>
Each host definition can be just a hostname, or it can be a
complex string that specifies connection options as well.
You can specify connection options two ways:</p>

<p style="margin-top: 1em">&Acirc;&middot; Format a host
definition in a key=value,key=value form. If an argument on
the command line contains the letter &rsquo;=&rsquo;,
mk-table-checksum will parse it into its component parts.
<br>
Examine the &quot;--help&quot; output for details on the
allowed keys.</p>

<p style="margin-top: 1em">Specifying a list of simple host
definitions &quot;host1 host2&quot; is equivalent to the
more complicated &quot;h=host1 h=host2&quot; format.</p>

<p style="margin-top: 1em">&Acirc;&middot; With the
command-line options such as &quot;--user&quot; and
&quot;--password&quot;. These options, if given, apply
globally to all host definitions.</p>

<p style="margin-top: 1em">In addition to specifying
connection options this way, mk-table-checksum allows
shortcuts. Any options specified for the first host
definition on the command line fill in <br>
missing values in subsequent ones. Any options that are
still missing after this are filled in from the command-line
options if possible.</p>

<p style="margin-top: 1em">In other words, the places you
specify connection options have precedence: highest
precedence is the option specified directly in the host
definition, next is the option <br>
specified in the first host definition, and lowest is the
command-line option.</p>

<p style="margin-top: 1em">You can mix simple and complex
host definitions and/or command-line arguments. For example,
if all your servers except one of your slaves uses a
non-standard port number:</p>

<p style="margin-top: 1em">mk-table-checksum --port 4500
master h=slave1,P=3306 slave2 slave3</p>

<p style="margin-top: 1em">If you are confused about how
mk-table-checksum will connect to your servers, give the
&quot;--explain-hosts&quot; option and it will tell you.</p>

<p style="margin-top: 1em">HOW FAST IS IT? <br>
Speed and efficiency are important, because the typical use
case is checksumming large amounts of data.</p>

<p style="margin-top: 1em">&quot;mk-table-checksum&quot; is
designed to do very little work itself, and generates very
little network traffic aside from inspecting table
structures with &quot;SHOW CREATE TABLE&quot;. The <br>
results of checksum queries are typically 40-character or
shorter strings.</p>

<p style="margin-top: 1em">The MySQL server does the bulk
of the work, in the form of the checksum queries. The
following benchmarks show the checksum query times for
various checksum algorithms. The <br>
first two results are simply running &quot;COUNT(col8)&quot;
and &quot;CHECKSUM TABLE&quot; on the table. &quot;CHECKSUM
TABLE&quot; is just &quot;CRC32&quot; under the hood, but
it&rsquo;s implemented inside the storage <br>
engine layer instead of at the MySQL layer.</p>

<p style="margin-top: 1em">ALGORITHM HASH FUNCTION EXTRA
TIME <br>
============== ============= ============== ===== <br>
COUNT(col8) 2.3 <br>
CHECKSUM TABLE 5.3 <br>
BIT_XOR FNV_64 12.7 <br>
ACCUM FNV_64 42.4 <br>
BIT_XOR MD5 --optimize-xor 80.0 <br>
ACCUM MD5 87.4 <br>
BIT_XOR SHA1 --optimize-xor 90.1 <br>
ACCUM SHA1 101.3 <br>
BIT_XOR MD5 172.0 <br>
BIT_XOR SHA1 197.3</p>

<p style="margin-top: 1em">The tests are entirely
CPU-bound. The sample data is an InnoDB table with the
following structure:</p>

<p style="margin-top: 1em">CREATE TABLE test ( <br>
col1 int NOT NULL, <br>
col2 date NOT NULL, <br>
col3 int NOT NULL, <br>
col4 int NOT NULL, <br>
col5 int, <br>
col6 decimal(3,1), <br>
col7 smallint unsigned NOT NULL, <br>
col8 timestamp NOT NULL, <br>
PRIMARY KEY (col2, col1), <br>
KEY (col7), <br>
KEY (col1) <br>
) ENGINE=InnoDB</p>

<p style="margin-top: 1em">The table has 4303585 rows,
365969408 bytes of data and 173457408 bytes of indexes. The
server is a Dell PowerEdge 1800 with dual 32-bit Xeon 2.8GHz
processors and 2GB of RAM. <br>
The tests are fully CPU-bound, and the server is otherwise
idle. The results are generally consistent to within a tenth
of a second on repeated runs.</p>

<p style="margin-top: 1em">&quot;CRC32&quot; is the default
checksum function to use, and should be enough for most
cases. If you need stronger guarantees that your data is
identical, you should use one of the <br>
other functions.</p>

<p style="margin-top: 1em">ALGORITHM SELECTION <br>
The &quot;--algorithm&quot; option allows you to specify
which algorithm you would like to use, but it does not
guarantee that mk-table-checksum will use this algorithm.
mk-table-checksum <br>
will ultimately select the best algorithm possible given
various factors such as the MySQL version and other command
line options.</p>

<p style="margin-top: 1em">The three basic algorithms in
descending order of preference are CHECKSUM, BIT_XOR and
ACCUM. CHECKSUM cannot be used if any one of these criteria
is true:</p>

<p style="margin-top: 1em">* L&lt;&quot;--where&quot;&gt;
is used. <br>
* L&lt;&quot;--since&quot;&gt; is used. <br>
* L&lt;&quot;--chunk-size&quot;&gt; is used. <br>
* L&lt;&quot;--replicate&quot;&gt; is used. <br>
* L&lt;&quot;--count&quot;&gt; is used. <br>
* MySQL version less than 4.1.1.</p>

<p style="margin-top: 1em">The BIT_XOR algorithm also
requires MySQL version 4.1.1 or later.</p>

<p style="margin-top: 1em">After checking these criteria,
if the requested &quot;--algorithm&quot; remains then it is
used, otherwise the first remaining algorithm with the
highest preference is used.</p>

<p style="margin-top: 1em">CONSISTENT CHECKSUMS <br>
If you are using this tool to verify your slaves still have
the same data as the master, which is why I wrote it, you
should read this section.</p>

<p style="margin-top: 1em">The best way to do this with
replication is to use the &quot;--replicate&quot; option.
When the queries are finished running on the master and its
slaves, you can go to the slaves and <br>
issue SQL queries to see if any tables are different from
the master. Try the following:</p>

<p style="margin-top: 1em">SELECT db, tbl, chunk,
this_cnt-master_cnt AS cnt_diff, <br>
this_crc &lt;&gt; master_crc OR ISNULL(master_crc) &lt;&gt;
ISNULL(this_crc) <br>
AS crc_diff <br>
FROM checksum <br>
WHERE master_cnt &lt;&gt; this_cnt OR master_crc &lt;&gt;
this_crc <br>
OR ISNULL(master_crc) &lt;&gt; ISNULL(this_crc);</p>

<p style="margin-top: 1em">The
&quot;--replicate-check&quot; option can do this query for
you. If you can&rsquo;t use this method, try the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; If your servers
are not being written to, you can just run the tool with no
further ado:</p>

<p style="margin-top: 1em">mk-table-checksum server1
server2 ... serverN</p>

<p style="margin-top: 1em">&Acirc;&middot; If the servers
are being written to, you need some way to make sure they
are consistent at the moment you run the checksums. For
situations other than master-slave <br>
replication, you will have to figure this out yourself. You
may be able to use the &quot;--where&quot; option with a
date or time column to only checksum data that&rsquo;s not
recent.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you are
checksumming a master and slaves, you can do a fast parallel
checksum and assume the slaves are caught up to the master.
In practice, this tends to work well <br>
except for tables which are constantly updated. You can use
the &quot;--slave-lag&quot; option to see how far behind
each slave was when it checksummed a given table. This can
help <br>
you decide whether to investigate further.</p>

<p style="margin-top: 1em">&Acirc;&middot; The next most
disruptive technique is to lock the table on the master,
then take checksums. This should prevent changes from
propagating to the slaves. You can just lock on <br>
the master (with &quot;--lock&quot;), or you can both lock
on the master and wait on the slaves till they reach that
point in the master&rsquo;s binlog (&quot;--wait&quot;).
Which is better depends <br>
on your workload; only you know that.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you decide to
make the checksums on the slaves wait until they&rsquo;re
guaranteed to be caught up to the master, the algorithm
looks like this:</p>

<p style="margin-top: 1em">For each table, <br>
Master: lock table <br>
Master: get pos <br>
In parallel, <br>
Master: checksum <br>
Slave(s): wait for pos, then checksum <br>
End <br>
Master: unlock table <br>
End</p>

<p style="margin-top: 1em">What I typically do when
I&rsquo;m not using the &quot;--replicate&quot; option is
simply run the tool on all servers with no further options.
This runs fast, parallel, non-blocking checksums <br>
simultaneously. If there are tables that look different, I
re-run with &quot;--wait&quot;=600 on the tables in
question. This makes the tool lock on the master as
explained above.</p>

<p style="margin-top: 1em">OUTPUT <br>
Output is to STDOUT, one line per server and table, with
header lines for each database. I tried to make the output
easy to process with awk. For this reason columns are always
<br>
present. If there&rsquo;s no value, mk-table-checksum prints
&rsquo;NULL&rsquo;.</p>

<p style="margin-top: 1em">The default is column-aligned
output for human readability, but you can change it to
tab-separated if you want. Use the &quot;--tab&quot; option
for this.</p>

<p style="margin-top: 1em">Output is unsorted, though all
lines for one table should be output together. For speed,
all checksums are done in parallel (as much as possible) and
may complete out of the <br>
order in which they were started. You might want to run them
through another script or command-line utility to make sure
they are in the order you want. If you pipe the output <br>
through mk-checksum-filter, you can sort the output and/or
avoid seeing output about tables that have no
differences.</p>

<p style="margin-top: 1em">The columns in the output are as
follows. The database, table, and chunk come first so you
can sort by them easily (they are the &quot;primary
key&quot;).</p>

<p style="margin-top: 1em">Output from
&quot;--replicate-check&quot; and &quot;--checksum&quot; are
different.</p>

<p style="margin-top: 1em">DATABASE <br>
The database the table is in.</p>

<p style="margin-top: 1em">TABLE <br>
The table name.</p>

<p style="margin-top: 1em">CHUNK <br>
The chunk (see &quot;--chunk-size&quot;). Zero if you are
not doing chunked checksums.</p>

<p style="margin-top: 1em">HOST <br>
The server&rsquo;s hostname.</p>

<p style="margin-top: 1em">ENGINE <br>
The table&rsquo;s storage engine.</p>

<p style="margin-top: 1em">COUNT <br>
The table&rsquo;s row count, unless you specified to skip
it. If &quot;OVERSIZE&quot; is printed, the chunk was
skipped because the actual number of rows was greater than
&quot;--chunk-size&quot; <br>
times &quot;--chunk-size-limit&quot;.</p>

<p style="margin-top: 1em">CHECKSUM <br>
The table&rsquo;s checksum, unless you specified to skip it
or the table has no rows. some types of checksums will be 0
if there are no rows; others will print NULL.</p>

<p style="margin-top: 1em">TIME <br>
How long it took to checksum the &quot;CHUNK&quot;, not
including &quot;WAIT&quot; time. Total checksum time is
&quot;WAIT + TIME&quot;.</p>

<p style="margin-top: 1em">WAIT <br>
How long the slave waited to catch up to its master before
beginning to checksum. &quot;WAIT&quot; is always 0 for the
master. See &quot;--wait&quot;.</p>

<p style="margin-top: 1em">STAT <br>
The return value of MASTER_POS_WAIT(). &quot;STAT&quot; is
always &quot;NULL&quot; for the master.</p>

<p style="margin-top: 1em">LAG How far the slave lags the
master, as reported by SHOW SLAVE STATUS. &quot;LAG&quot; is
always &quot;NULL&quot; for the master.</p>

<p style="margin-top: 1em">REPLICATE TABLE MAINTENANCE <br>
If you use &quot;--replicate&quot; to store and replicate
checksums, you may need to perform maintenance on the
replicate table from time to time to remove old checksums.
This section <br>
describes when checksums in the replicate table are deleted
automatically by mk-table-checksum and when you must
manually delete them.</p>

<p style="margin-top: 1em">Before starting,
mk-table-checksum calculates chunks for each table, even if
&quot;--chunk-size&quot; is not specified (in that case
there is one chunk: &quot;1=1&quot;). Then, before
checksumming <br>
each table, the tool deletes checksum chunks in the
replicate table greater than the current number of chunks.
For example, if a table is chunked into 100 chunks, 0-99,
then mk- <br>
table-checksum does:</p>

<p style="margin-top: 1em">DELETE FROM replicate table
WHERE db=? AND tbl=? AND chunk &gt; 99</p>

<p style="margin-top: 1em">That removes any high-end chunks
from previous runs which no longer exist. Currently, this
operation cannot be disabled.</p>

<p style="margin-top: 1em">If you use &quot;--resume&quot;,
&quot;--resume-replicate&quot;, or &quot;--modulo&quot;,
then you need to be careful that the number of rows in a
table does not decrease so much that the number of chunks
<br>
decreases too, else some checksum chunks may be deleted. The
one exception is if only rows at the high end of the range
are deleted. In that case, the high-end chunks are <br>
deleted and lower chunks remain unchanged. An increasing
number of rows or chunks should not cause any adverse
affects.</p>

<p style="margin-top: 1em">Changing the
&quot;--chunk-size&quot; between runs with
&quot;--resume&quot;, &quot;--resume-replicate&quot;, or
&quot;--modulo&quot; can cause odd or invalid checksums. You
should not do this. It won&rsquo;t work with the <br>
resume options. With &quot;--modulo&quot;, the safest thing
to do is manually delete all the rows in the replicate table
for the table in question and start over.</p>

<p style="margin-top: 1em">If the replicate table becomes
cluttered with old or invalid checksums and the auto-delete
operation is not deleting them, then you will need to
manually clean up the replicate <br>
table. Alternatively, if you specify
&quot;--empty-replicate-table&quot;, then the tool deletes
every row in the replicate table.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
An exit status of 0 (sometimes also called a return value or
return code) indicates success. If there is an error
checksumming any table, the exit status is 1.</p>

<p style="margin-top: 1em">When running
&quot;--replicate-check&quot;, if any slave has chunks that
differ from the master, the exit status is 1.</p>

<p style="margin-top: 1em">QUERIES <br>
If you are using innotop (see
&lt;http://code.google.com/p/innotop&gt;), mytop, or another
tool to watch currently running MySQL queries, you may see
the checksum queries. They look <br>
similar to this:</p>

<p style="margin-top: 1em">REPLACE
/*test.test_tbl:&rsquo;2&rsquo;/&rsquo;5&rsquo;*/ INTO
test.checksum(db, ...</p>

<p style="margin-top: 1em">Since mk-table-checksum&rsquo;s
queries run for a long time and tend to be textually very
long, and thus won&rsquo;t fit on one screen of these
monitoring tools, I&rsquo;ve been careful to place a <br>
comment at the beginning of the query so you can see what it
is and what it&rsquo;s doing. The comment contains the name
of the table that&rsquo;s being checksummed, the chunk it is
<br>
currently checksumming, and how many chunks will be
checksummed. In the case above, it is checksumming chunk 2
of 5 in table test.test_tbl.</p>

<p style="margin-top: 1em">OPTIONS <br>
&quot;--schema&quot; is restricted to option groups
Connection, Filter, Output, Help, Config, Safety.</p>


<p style="margin-top: 1em">&quot;--empty-replicate-table&quot;,
&quot;--resume&quot; and &quot;--resume-replicate&quot; are
mutually exclusive.</p>

<p style="margin-top: 1em">This tool accepts additional
command-line arguments. Refer to the &quot;SYNOPSIS&quot;
and usage information for details.</p>

<p style="margin-top: 1em">--algorithm <br>
type: string</p>

<p style="margin-top: 1em">Checksum algorithm
(ACCUM|CHECKSUM|BIT_XOR).</p>

<p style="margin-top: 1em">Specifies which checksum
algorithm to use. Valid arguments are CHECKSUM, BIT_XOR and
ACCUM. The latter two do cryptographic hash checksums. See
also &quot;ALGORITHM SELECTION&quot;.</p>

<p style="margin-top: 1em">CHECKSUM is built into MySQL,
but has some disadvantages. BIT_XOR and ACCUM are
implemented by SQL queries. They use a cryptographic hash of
all columns concatenated <br>
together with a separator, followed by a bitmap of each
nullable column that is NULL (necessary because CONCAT_WS()
skips NULL columns).</p>

<p style="margin-top: 1em">CHECKSUM is the default. This
method uses MySQL&rsquo;s built-in CHECKSUM TABLE command,
which is a CRC32 behind the scenes. It cannot be used before
MySQL 4.1.1, and various <br>
options disable it as well. It does not simultaneously count
rows; that requires an extra COUNT(*) query. This is a good
option when you are using MyISAM tables with live <br>
checksums enabled; in this case both the COUNT(*) and
CHECKSUM queries will run very quickly.</p>

<p style="margin-top: 1em">The BIT_XOR algorithm is
available for MySQL 4.1.1 and newer. It uses BIT_XOR(),
which is order-independent, to reduce all the rows to a
single checksum.</p>

<p style="margin-top: 1em">ACCUM uses a user variable as an
accumulator. It reduces each row to a single checksum, which
is concatenated with the accumulator and re-checksummed.
This technique is <br>
order-dependent. If the table has a primary key, it will be
used to order the results for consistency; otherwise
it&rsquo;s up to chance.</p>

<p style="margin-top: 1em">The pathological worst case is
where identical rows will cancel each other out in the
BIT_XOR. In this case you will not be able to distinguish a
table full of one value <br>
from a table full of another value. The ACCUM algorithm will
distinguish them.</p>

<p style="margin-top: 1em">However, the ACCUM algorithm is
order-dependent, so if you have two tables with identical
data but the rows are out of order, you&rsquo;ll get
different checksums with ACCUM.</p>

<p style="margin-top: 1em">If a given algorithm won&rsquo;t
work for some reason, mk-table-checksum falls back to
another. The least common denominator is ACCUM, which works
on MySQL 3.23.2 and newer.</p>

<p style="margin-top: 1em">--arg-table <br>
type: string</p>

<p style="margin-top: 1em">The database.table with
arguments for each table to checksum.</p>

<p style="margin-top: 1em">This table may be named anything
you wish. It must contain at least the following
columns:</p>

<p style="margin-top: 1em">CREATE TABLE checksum_args (
<br>
db char(64) NOT NULL, <br>
tbl char(64) NOT NULL, <br>
-- other columns as desired <br>
PRIMARY KEY (db, tbl) <br>
);</p>

<p style="margin-top: 1em">In addition to the columns
shown, it may contain any of the other columns listed here
(Note: this list is used by the code,
MAGIC_overridable_args):</p>

<p style="margin-top: 1em">algorithm chunk-column
chunk-index chunk-size columns count crc function lock <br>
modulo use-index offset optimize-xor chunk-size-limit
probability separator <br>
save-since single-chunk since since-column sleep sleep-coef
trim wait where</p>

<p style="margin-top: 1em">Each of these columns
corresponds to the long form of a command-line option. Each
column should be NULL-able. Column names with hyphens should
be enclosed in backticks <br>
(e.g. &lsquo;chunk-size&lsquo;) when the table is created.
The data type does not matter, but it&rsquo;s suggested you
use a sensible data type to prevent garbage data.</p>

<p style="margin-top: 1em">When
&quot;mk-table-checksum&quot; checksums a table, it will
look for a matching entry in this table. Any column that has
a defined value will override the corresponding command-line
<br>
argument for the table being currently processed. In this
way it is possible to specify custom command-line arguments
for any table.</p>

<p style="margin-top: 1em">If you add columns to the table
that aren&rsquo;t in the above list of allowable columns,
it&rsquo;s an error. The exceptions are &quot;db&quot;,
&quot;tbl&quot;, and &quot;ts&quot;. The &quot;ts&quot;
column can be used as <br>
a timestamp for easy visibility into the last time the
&quot;since&quot; column was updated with
&quot;--save-since&quot;.</p>

<p style="margin-top: 1em">This table is assumed to be
located on the first server given on the command-line.</p>

<p style="margin-top: 1em">--ask-pass <br>
group: Connection</p>

<p style="margin-top: 1em">Prompt for a password when
connecting to MySQL.</p>

<p style="margin-top: 1em">--check-interval <br>
type: time; group: Throttle; default: 1s</p>

<p style="margin-top: 1em">How often to check for slave lag
if &quot;--check-slave-lag&quot; is given.</p>

<p style="margin-top: 1em">--[no]check-replication-filters
<br>
default: yes; group: Safety</p>

<p style="margin-top: 1em">Do not &quot;--replicate&quot;
if any replication filters are set. When --replicate is
specified, mk-table-checksum tries to detect slaves and look
for options that filter <br>
replication, such as binlog_ignore_db and replicate_do_db.
If it finds any such filters, it aborts with an error.
Replication filtering makes it impossible to be sure that
<br>
the checksum queries won&rsquo;t break replication or simply
fail to replicate. If you are sure that it&rsquo;s OK to run
the checksum queries, you can negate this option to disable
the <br>
checks. See also &quot;--replicate-database&quot;.</p>

<p style="margin-top: 1em">--check-slave-lag <br>
type: DSN; group: Throttle</p>

<p style="margin-top: 1em">Pause checksumming until the
specified slave&rsquo;s lag is less than
&quot;--max-lag&quot;.</p>

<p style="margin-top: 1em">If this option is specified and
&quot;--throttle-method&quot; is set to &quot;slavelag&quot;
then &quot;--throttle-method&quot; only checks this
slave.</p>

<p style="margin-top: 1em">--checksum <br>
group: Output</p>

<p style="margin-top: 1em">Print checksums and table names
in the style of md5sum (disables
&quot;--[no]count&quot;).</p>

<p style="margin-top: 1em">Makes the output behave more
like the output of &quot;md5sum&quot;. The checksum is first
on the line, followed by the host, database, table, and
chunk number, concatenated with dots.</p>

<p style="margin-top: 1em">--chunk-column <br>
type: string</p>

<p style="margin-top: 1em">Prefer this column for dividing
tables into chunks. By default, mk-table-checksum chooses
the first suitable column for each table, preferring to use
the primary key. This <br>
option lets you specify a preferred column, which
mk-table-checksum uses if it exists in the table and is
chunkable. If not, then mk-table-checksum will revert to its
<br>
default behavior. Be careful when using this option; a poor
choice could cause bad performance. This is probably best to
use when you are checksumming only a single table, <br>
not an entire server. See also
&quot;--chunk-index&quot;.</p>

<p style="margin-top: 1em">--chunk-index <br>
type: string</p>

<p style="margin-top: 1em">Prefer this index for chunking
tables. By default, mk-table-checksum chooses an appropriate
index for the &quot;--chunk-column&quot; (even if it chooses
the chunk column <br>
automatically). This option lets you specify the index you
prefer. If the index doesn&rsquo;t exist, then
mk-table-checksum will fall back to its default behavior.
mk-table- <br>
checksum adds the index to the checksum SQL statements in a
&quot;FORCE INDEX&quot; clause. Be careful when using this
option; a poor choice of index could cause bad performance.
<br>
This is probably best to use when you are checksumming only
a single table, not an entire server.</p>

<p style="margin-top: 1em">--chunk-range <br>
type: string; default: open</p>

<p style="margin-top: 1em">Set which ends of the chunk
range are open or closed. Possible values are one of
MAGIC_chunk_range:</p>

<p style="margin-top: 1em">VALUE OPENS/CLOSES <br>
========== ====================== <br>
open Both ends are open <br>
openclosed Low end open, high end closed</p>

<p style="margin-top: 1em">By default mk-table-checksum
uses an open range of chunks like:</p>

<p style="margin-top: 1em">&lsquo;id&lsquo; &lt;
&rsquo;10&rsquo; <br>
&lsquo;id&lsquo; &gt;= &rsquo;10&rsquo; AND &lt;
&rsquo;20&rsquo; <br>
&lsquo;id&lsquo; &gt;= &rsquo;20&rsquo;</p>

<p style="margin-top: 1em">That range is open because the
last chunk selects any row with id greater than (or equal
to) 20. An open range can be a problem in cases where a lot
of new rows are inserted <br>
with IDs greater than 20 while mk-table-checksumming is
running because the final open-ended chunk will select all
the newly inserted rows. (The less common case of <br>
inserting rows with IDs less than 10 would require a
&quot;closedopen&quot; range but that is not currently
implemented.) Specifying &quot;openclosed&quot; will cause
the final chunk to be <br>
closed like:</p>

<p style="margin-top: 1em">&lsquo;id&lsquo; &gt;=
&rsquo;20&rsquo; AND &lsquo;id&lsquo; &lt;= N</p>

<p style="margin-top: 1em">N is the
&quot;MAX(&lsquo;id&lsquo;)&quot; that mk-table-checksum
used when it first chunked the rows. Therefore, it will only
chunk the range of rows that existed when the tool started
and not <br>
any newly inserted rows (unless those rows happen to be
inserted with IDs less than N).</p>

<p style="margin-top: 1em">See also
&quot;--chunk-size-limit&quot;.</p>

<p style="margin-top: 1em">--chunk-size <br>
type: string</p>

<p style="margin-top: 1em">Approximate number of rows or
size of data to checksum at a time. Allowable suffixes are
k, M, G. Disallows &quot;--algorithm CHECKSUM&quot;.</p>

<p style="margin-top: 1em">If you specify a chunk size,
mk-table-checksum will try to find an index that will let it
split the table into ranges of approximately
&quot;--chunk-size&quot; rows, based on the <br>
table&rsquo;s index statistics. Currently only numeric and
date types can be chunked.</p>

<p style="margin-top: 1em">If the table is chunkable,
mk-table-checksum will checksum each range separately with
parameters in the checksum query&rsquo;s WHERE clause. If
mk-table-checksum cannot find a <br>
suitable index, it will do the entire table in one chunk as
though you had not specified &quot;--chunk-size&quot; at
all. Each table is handled individually, so some tables may
be <br>
chunked and others not.</p>

<p style="margin-top: 1em">The chunks will be approximately
sized, and depending on the distribution of values in the
indexed column, some chunks may be larger than the value you
specify.</p>

<p style="margin-top: 1em">If you specify a suffix (one of
k, M or G), the parameter is treated as a data size rather
than a number of rows. The output of SHOW TABLE STATUS is
then used to estimate <br>
the amount of data the table contains, and convert that to a
number of rows.</p>

<p style="margin-top: 1em">--chunk-size-limit <br>
type: float; default: 2.0; group: Safety</p>

<p style="margin-top: 1em">Do not checksum chunks with this
many times more rows than &quot;--chunk-size&quot;.</p>

<p style="margin-top: 1em">When &quot;--chunk-size&quot; is
given it specifies an ideal size for each chunk of a
chunkable table (in rows; size values are converted to
rows). Before checksumming each chunk, mk- <br>
table-checksum checks how many rows are in the chunk with
EXPLAIN. If the number of rows reported by EXPLAIN is this
many times greater than &quot;--chunk-size&quot;, then the
chunk <br>
is skipped and &quot;OVERSIZE&quot; is printed for the
&quot;COUNT&quot; column of the &quot;OUTPUT&quot;.</p>

<p style="margin-top: 1em">For example, if you specify
&quot;--chunk-size&quot; 100 and a chunk has 150 rows, then
it is checksummed with the default
&quot;--chunk-size-limit&quot; value 2.0 because 150 is less
than 100 * <br>
2.0. But if the chunk has 205 rows, then it is not
checksummed because 205 is greater than 100 * 2.0.</p>

<p style="margin-top: 1em">The minimum value for this
option is 1 which means that no chunk can be any larger than
&quot;--chunk-size&quot;. You probably don&rsquo;t want to
specify 1 because rows reported by EXPLAIN <br>
are estimates which can be greater than or less than the
real number of rows in the chunk. If too many chunks are
skipped because they are oversize, you might want to <br>
specify a value larger than 2.</p>

<p style="margin-top: 1em">You can disable oversize chunk
checking by specifying &quot;--chunk-size-limit&quot; 0.</p>

<p style="margin-top: 1em">See also
&quot;--unchunkable-tables&quot;.</p>

<p style="margin-top: 1em">--columns <br>
short form: -c; type: array; group: Filter</p>

<p style="margin-top: 1em">Checksum only this
comma-separated list of columns.</p>

<p style="margin-top: 1em">--config <br>
type: Array; group: Config</p>

<p style="margin-top: 1em">Read this comma-separated list
of config files; if specified, this must be the first option
on the command line.</p>

<p style="margin-top: 1em">--[no]count <br>
Count rows in tables. This is built into ACCUM and BIT_XOR,
but requires an extra query for CHECKSUM.</p>

<p style="margin-top: 1em">This is disabled by default to
avoid an extra COUNT(*) query when &quot;--algorithm&quot;
is CHECKSUM. If you have only MyISAM tables and live
checksums are enabled, both CHECKSUM and <br>
COUNT will be very fast, but otherwise you may want to use
one of the other algorithms.</p>

<p style="margin-top: 1em">--[no]crc <br>
default: yes</p>

<p style="margin-top: 1em">Do a CRC (checksum) of
tables.</p>

<p style="margin-top: 1em">Take the checksum of the rows as
well as their count. This is enabled by default. If you
disable it, you&rsquo;ll just get COUNT(*) queries.</p>

<p style="margin-top: 1em">--create-replicate-table <br>
Create the replicate table given by &quot;--replicate&quot;
if it does not exist.</p>

<p style="margin-top: 1em">Normally, if the replicate table
given by &quot;--replicate&quot; does not exist,
&quot;mk-table-checksum&quot; will die. With this option,
however, &quot;mk-table-checksum&quot; will create the
replicate <br>
table for you, using the database.table name given to
&quot;--replicate&quot;.</p>

<p style="margin-top: 1em">The structure of the replicate
table is the same as the suggested table mentioned in
&quot;--replicate&quot;. Note that since ENGINE is not
specified, the replicate table will use the <br>
server&rsquo;s default storage engine. If you want to use a
different engine, you need to create the table yourself.</p>

<p style="margin-top: 1em">--databases <br>
short form: -d; type: hash; group: Filter</p>

<p style="margin-top: 1em">Only checksum this
comma-separated list of databases.</p>

<p style="margin-top: 1em">--databases-regex <br>
type: string</p>

<p style="margin-top: 1em">Only checksum databases whose
names match this Perl regex.</p>

<p style="margin-top: 1em">--defaults-file <br>
short form: -F; type: string; group: Connection</p>

<p style="margin-top: 1em">Only read mysql options from the
given file. You must give an absolute pathname.</p>

<p style="margin-top: 1em">--empty-replicate-table <br>
DELETE all rows in the &quot;--replicate&quot; table before
starting.</p>

<p style="margin-top: 1em">Issues a DELETE against the
table given by &quot;--replicate&quot; before beginning
work. Ignored if &quot;--replicate&quot; is not specified.
This can be useful to remove entries related to <br>
tables that no longer exist, or just to clean out the
results of a previous run.</p>

<p style="margin-top: 1em">If you want to delete entries
for specific databases or tables you must do this
manually.</p>

<p style="margin-top: 1em">--engines <br>
short form: -e; type: hash; group: Filter</p>

<p style="margin-top: 1em">Do only this comma-separated
list of storage engines.</p>

<p style="margin-top: 1em">--explain <br>
group: Output</p>

<p style="margin-top: 1em">Show, but do not execute,
checksum queries (disables
&quot;--empty-replicate-table&quot;).</p>

<p style="margin-top: 1em">--explain-hosts <br>
group: Help</p>

<p style="margin-top: 1em">Print connection information and
exit.</p>

<p style="margin-top: 1em">Print out a list of hosts to
which mk-table-checksum will connect, with all the various
connection options, and exit. See &quot;SPECIFYING
HOSTS&quot;.</p>

<p style="margin-top: 1em">--float-precision <br>
type: int</p>

<p style="margin-top: 1em">Precision for &quot;FLOAT&quot;
and &quot;DOUBLE&quot; number-to-string conversion. Causes
FLOAT and DOUBLE values to be rounded to the specified
number of digits after the decimal point, with <br>
the ROUND() function in MySQL. This can help avoid checksum
mismatches due to different floating-point representations
of the same values on different MySQL versions and <br>
hardware. The default is no rounding; the values are
converted to strings by the CONCAT() function, and MySQL
chooses the string representation. If you specify a value of
<br>
2, for example, then the values 1.008 and 1.009 will be
rounded to 1.01, and will checksum as equal.</p>

<p style="margin-top: 1em">--function <br>
type: string</p>

<p style="margin-top: 1em">Hash function for checksums
(FNV1A_64, MURMUR_HASH, SHA1, MD5, CRC32, etc).</p>

<p style="margin-top: 1em">You can use this option to
choose the cryptographic hash function used for
&quot;--algorithm&quot;=ACCUM or
&quot;--algorithm&quot;=BIT_XOR. The default is to use
&quot;CRC32&quot;, but &quot;MD5&quot; and &quot;SHA1&quot;
<br>
also work, and you can use your own function, such as a
compiled UDF, if you wish. Whatever function you specify is
run in SQL, not in Perl, so it must be available to <br>
MySQL.</p>

<p style="margin-top: 1em">The &quot;FNV1A_64&quot; UDF
mentioned in the benchmarks is much faster than
&quot;MD5&quot;. The C++ source code is distributed with
Maatkit. It is very simple to compile and install; look at
<br>
the header in the source code for instructions. If it is
installed, it is preferred over &quot;MD5&quot;. You can
also use the MURMUR_HASH function if you compile and install
that as <br>
a UDF; the source is also distributed with Maatkit, and it
is faster and has better distribution than FNV1A_64.</p>

<p style="margin-top: 1em">--help <br>
group: Help</p>

<p style="margin-top: 1em">Show help and exit.</p>

<p style="margin-top: 1em">--ignore-columns <br>
type: Hash; group: Filter</p>

<p style="margin-top: 1em">Ignore this comma-separated list
of columns when calculating the checksum.</p>

<p style="margin-top: 1em">This option only affects the
checksum when using the ACCUM or BIT_XOR
&quot;--algorithm&quot;.</p>

<p style="margin-top: 1em">--ignore-databases <br>
type: Hash; group: Filter</p>

<p style="margin-top: 1em">Ignore this comma-separated list
of databases.</p>

<p style="margin-top: 1em">--ignore-databases-regex <br>
type: string</p>

<p style="margin-top: 1em">Ignore databases whose names
match this Perl regex.</p>

<p style="margin-top: 1em">--ignore-engines <br>
type: Hash; default: FEDERATED,MRG_MyISAM; group: Filter</p>

<p style="margin-top: 1em">Ignore this comma-separated list
of storage engines.</p>

<p style="margin-top: 1em">--ignore-tables <br>
type: Hash; group: Filter</p>

<p style="margin-top: 1em">Ignore this comma-separated list
of tables.</p>

<p style="margin-top: 1em">Table names may be qualified
with the database name.</p>

<p style="margin-top: 1em">--ignore-tables-regex <br>
type: string</p>

<p style="margin-top: 1em">Ignore tables whose names match
the Perl regex.</p>

<p style="margin-top: 1em">--lock <br>
Lock on master until done on slaves (implies
&quot;--slave-lag&quot;).</p>

<p style="margin-top: 1em">This option can help you to get
a consistent read on a master and many slaves. If you
specify this option, mk-table-checksum will lock the table
on the first server on the <br>
command line, which it assumes to be the master. It will
keep this lock until the checksums complete on the other
servers.</p>

<p style="margin-top: 1em">This option isn&rsquo;t very
useful by itself, so you probably want to use
&quot;--wait&quot; instead.</p>

<p style="margin-top: 1em">Note: if you&rsquo;re
checksumming a slave against its master, you should use
&quot;--replicate&quot;. In that case, there&rsquo;s no need
for locking, waiting, or any of that.</p>

<p style="margin-top: 1em">--max-lag <br>
type: time; group: Throttle; default: 1s</p>

<p style="margin-top: 1em">Suspend checksumming if the
slave given by &quot;--check-slave-lag&quot; lags.</p>

<p style="margin-top: 1em">This option causes
mk-table-checksum to look at the slave every time it&rsquo;s
about to checksum a chunk. If the slave&rsquo;s lag is
greater than the option&rsquo;s value, or if the slave <br>
isn&rsquo;t running (so its lag is NULL), mk-table-checksum
sleeps for &quot;--check-interval&quot; seconds and then
looks at the lag again. It repeats until the slave is caught
up, then <br>
proceeds to checksum the chunk.</p>

<p style="margin-top: 1em">This option is useful to let you
checksum data as fast as the slaves can handle it, assuming
the slave you directed mk-table-checksum to monitor is
representative of all the <br>
slaves that may be replicating from this server. It should
eliminate the need for &quot;--sleep&quot; or
&quot;--sleep-coef&quot;.</p>

<p style="margin-top: 1em">--modulo <br>
type: int</p>

<p style="margin-top: 1em">Do only every Nth chunk on
chunked tables.</p>

<p style="margin-top: 1em">This option lets you checksum
only some chunks of the table. This is a useful alternative
to &quot;--probability&quot; when you want to be sure you
get full coverage in some specified <br>
number of runs; for example, you can do only every 7th
chunk, and then use &quot;--offset&quot; to rotate the
modulo every day of the week.</p>

<p style="margin-top: 1em">Just like with
&quot;--probability&quot;, a table that cannot be chunked is
done every time.</p>

<p style="margin-top: 1em">--offset <br>
type: string; default: 0</p>

<p style="margin-top: 1em">Modulo offset expression for use
with &quot;--modulo&quot;.</p>

<p style="margin-top: 1em">The argument may be an SQL
expression, such as &quot;WEEKDAY(NOW())&quot; (which
returns a number from 0 through 6). The argument is
evaluated by MySQL. The result is used as <br>
follows: if chunk_num % &quot;--modulo&quot; ==
&quot;--offset&quot;, the chunk will be checksummed.</p>

<p style="margin-top: 1em">--[no]optimize-xor <br>
default: yes</p>

<p style="margin-top: 1em">Optimize BIT_XOR with user
variables.</p>

<p style="margin-top: 1em">This option specifies to use
user variables to reduce the number of times each row must
be passed through the cryptographic hash function when you
are using the BIT_XOR <br>
algorithm.</p>

<p style="margin-top: 1em">With the optimization, the
queries look like this in pseudo-code:</p>

<p style="margin-top: 1em">SELECT CONCAT( <br>
BIT_XOR(SLICE_OF(@user_variable)), <br>
BIT_XOR(SLICE_OF(@user_variable)), <br>
... <br>
BIT_XOR(SLICE_OF(@user_variable := HASH(col1, col2...
colN))));</p>

<p style="margin-top: 1em">The exact positioning of user
variables and calls to the hash function is determined
dynamically, and will vary between MySQL versions. Without
the optimization, it looks <br>
like this:</p>

<p style="margin-top: 1em">SELECT CONCAT( <br>
BIT_XOR(SLICE_OF(MD5(col1, col2... colN))), <br>
BIT_XOR(SLICE_OF(MD5(col1, col2... colN))), <br>
... <br>
BIT_XOR(SLICE_OF(MD5(col1, col2... colN))));</p>

<p style="margin-top: 1em">The difference is the number of
times all the columns must be mashed together and fed
through the hash function. If you are checksumming really
large columns, such as BLOB <br>
or TEXT columns, this might make a big difference.</p>

<p style="margin-top: 1em">--password <br>
short form: -p; type: string; group: Connection</p>

<p style="margin-top: 1em">Password to use when
connecting.</p>

<p style="margin-top: 1em">--pid <br>
type: string</p>

<p style="margin-top: 1em">Create the given PID file. The
file contains the process ID of the script. The PID file is
removed when the script exits. Before starting, the script
checks if the PID <br>
file already exists. If it does not, then the script creates
and writes its own PID to it. If it does, then the script
checks the following: if the file contains a PID and <br>
a process is running with that PID, then the script dies;
or, if there is no process running with that PID, then the
script overwrites the file with its own PID and starts; <br>
else, if the file contains no PID, then the script dies.</p>

<p style="margin-top: 1em">--port <br>
short form: -P; type: int; group: Connection</p>

<p style="margin-top: 1em">Port number to use for
connection.</p>

<p style="margin-top: 1em">--probability <br>
type: int; default: 100</p>

<p style="margin-top: 1em">Checksums will be run with this
percent probability.</p>

<p style="margin-top: 1em">This is an integer between 1 and
100. If 100, every chunk of every table will certainly be
checksummed. If less than that, there is a chance that some
chunks of some tables <br>
will be skipped. This is useful for routine jobs designed to
randomly sample bits of tables without checksumming the
whole server. By default, if a table is not chunkable, <br>
it will be checksummed every time even when the probability
is less than 100. You can override this with
&quot;--single-chunk&quot;.</p>

<p style="margin-top: 1em">See also
&quot;--modulo&quot;.</p>

<p style="margin-top: 1em">--progress <br>
type: array; default: time,30</p>

<p style="margin-top: 1em">Print progress reports to
STDERR. Currently, this feature is only for when
&quot;--throttle-method&quot; waits for slaves to catch
up.</p>

<p style="margin-top: 1em">The value is a comma-separated
list with two parts. The first part can be percentage, time,
or iterations; the second part specifies how often an update
should be printed, <br>
in percentage, seconds, or number of iterations.</p>

<p style="margin-top: 1em">--quiet <br>
short form: -q; group: Output</p>

<p style="margin-top: 1em">Do not print checksum
results.</p>

<p style="margin-top: 1em">--recheck <br>
Re-checksum chunks that &quot;--replicate-check&quot; found
to be different.</p>

<p style="margin-top: 1em">--recurse <br>
type: int; group: Throttle</p>

<p style="margin-top: 1em">Number of levels to recurse in
the hierarchy when discovering slaves. Default is
infinite.</p>

<p style="margin-top: 1em">See
&quot;--recursion-method&quot;.</p>

<p style="margin-top: 1em">--recursion-method <br>
type: string</p>

<p style="margin-top: 1em">Preferred recursion method for
discovering slaves.</p>

<p style="margin-top: 1em">Possible methods are:</p>

<p style="margin-top: 1em">METHOD USES <br>
=========== ================ <br>
processlist SHOW PROCESSLIST <br>
hosts SHOW SLAVE HOSTS</p>

<p style="margin-top: 1em">The processlist method is
preferred because SHOW SLAVE HOSTS is not reliable. However,
the hosts method is required if the server uses a
non-standard port (not 3306). <br>
Usually mk-table-checksum does the right thing and finds the
slaves, but you may give a preferred method and it will be
used first. If it doesn&rsquo;t find any slaves, the other
<br>
methods will be tried.</p>

<p style="margin-top: 1em">--replicate <br>
type: string</p>

<p style="margin-top: 1em">Replicate checksums to slaves
(disallows --algorithm CHECKSUM).</p>

<p style="margin-top: 1em">This option enables a completely
different checksum strategy for a consistent, lock-free
checksum across a master and its slaves. Instead of running
the checksum queries on <br>
each server, you run them only on the master. You specify a
table, fully qualified in db.table format, to insert the
results into. The checksum queries will insert directly <br>
into the table, so they will be replicated through the
binlog to the slaves.</p>

<p style="margin-top: 1em">When the queries are finished
replicating, you can run a simple query on each slave to see
which tables have differences from the master. With the
&quot;--replicate-check&quot; <br>
option, mk-table-checksum can run the query for you to make
it even easier. See &quot;CONSISTENT CHECKSUMS&quot; for
details.</p>

<p style="margin-top: 1em">If you find tables that have
differences, you can use the chunk boundaries in a WHERE
clause with mk-table-sync to help repair them more
efficiently. See mk-table-sync for <br>
details.</p>

<p style="margin-top: 1em">The table must have at least
these columns: db, tbl, chunk, boundaries, this_crc,
master_crc, this_cnt, master_cnt. The table may be named
anything you wish. Here is a <br>
suggested table structure, which is automatically used for
&quot;--create-replicate-table&quot;
(MAGIC_create_replicate):</p>

<p style="margin-top: 1em">CREATE TABLE checksum ( <br>
db char(64) NOT NULL, <br>
tbl char(64) NOT NULL, <br>
chunk int NOT NULL, <br>
boundaries char(100) NOT NULL, <br>
this_crc char(40) NOT NULL, <br>
this_cnt int NOT NULL, <br>
master_crc char(40) NULL, <br>
master_cnt int NULL, <br>
ts timestamp NOT NULL, <br>
PRIMARY KEY (db, tbl, chunk) <br>
);</p>

<p style="margin-top: 1em">Be sure to choose an appropriate
storage engine for the checksum table. If you are
checksumming InnoDB tables, for instance, a deadlock will
break replication if the <br>
checksum table is non-transactional, because the transaction
will still be written to the binlog. It will then replay
without a deadlock on the slave and break replication <br>
with &quot;different error on master and slave.&quot; This
is not a problem with mk-table-checksum, it&rsquo;s a
problem with MySQL replication, and you can read more about
it in the MySQL <br>
manual.</p>

<p style="margin-top: 1em">This works only with
statement-based replication (mk-table-checksum will switch
the binlog format to STATEMENT for the duration of the
session if your server uses row-based <br>
replication).</p>

<p style="margin-top: 1em">In contrast to running the tool
against multiple servers at once, using this option
eliminates the complexities of synchronizing checksum
queries across multiple servers, <br>
which normally requires locking and unlocking, waiting for
master binlog positions, and so on. Thus, it disables
&quot;--lock&quot;, &quot;--wait&quot;, and
&quot;--slave-lag&quot; (but not <br>
&quot;--check-slave-lag&quot;, which is a way to throttle
the execution speed).</p>

<p style="margin-top: 1em">The checksum queries actually do
a REPLACE into this table, so existing rows need not be
removed before running. However, you may wish to do this
anyway to remove rows <br>
related to tables that don&rsquo;t exist anymore. The
&quot;--empty-replicate-table&quot; option does this for
you.</p>

<p style="margin-top: 1em">Since the table must be
qualified with a database (e.g. &quot;db.checksums&quot;),
mk-table-checksum will only USE this database. This may be
important if any replication options are <br>
set because it could affect whether or not changes to the
table are replicated.</p>

<p style="margin-top: 1em">If the slaves have any
--replicate-do-X or --replicate-ignore-X options, you should
be careful not to checksum any databases or tables that
exist on the master and not the <br>
slaves. Changes to such tables may not normally be executed
on the slaves because of the --replicate options, but the
checksum queries modify the contents of the table that <br>
stores the checksums, not the tables whose data you are
checksumming. Therefore, these queries will be executed on
the slave, and if the table or database you&rsquo;re <br>
checksumming does not exist, the queries will cause
replication to fail. For more information on replication
rules, see
&lt;http://dev.mysql.com/doc/en/replication-rules.html&gt;.</p>

<p style="margin-top: 1em">The table specified by
&quot;--replicate&quot; will never be checksummed
itself.</p>

<p style="margin-top: 1em">--replicate-check <br>
type: int</p>

<p style="margin-top: 1em">Check results in
&quot;--replicate&quot; table, to the specified depth. You
must use this after you run the tool normally; it skips the
checksum step and only checks results.</p>

<p style="margin-top: 1em">It recursively finds differences
recorded in the table given by &quot;--replicate&quot;. It
recurses to the depth you specify: 0 is no recursion (check
only the server you specify), 1 <br>
is check the server and its slaves, 2 is check the slaves of
its slaves, and so on.</p>

<p style="margin-top: 1em">It finds differences by running
the query shown in &quot;CONSISTENT CHECKSUMS&quot;, and
prints results, then exits after printing. This is just a
convenient way of running the query <br>
so you don&rsquo;t have to do it manually.</p>

<p style="margin-top: 1em">The output is one informational
line per slave host, followed by the results of the query,
if any. If &quot;--quiet&quot; is specified, there is no
output. If there are no <br>
differences between the master and any slave, there is no
output. If any slave has chunks that differ from the master,
mk-table-checksum&rsquo;s exit status is 1; otherwise it is
<br>
0.</p>

<p style="margin-top: 1em">This option makes
&quot;mk-table-checksum&quot; look for slaves by running
&quot;SHOW PROCESSLIST&quot;. If it finds connections that
appear to be from slaves, it derives connection information
<br>
for each slave with the same default-and-override method
described in &quot;SPECIFYING HOSTS&quot;.</p>

<p style="margin-top: 1em">If &quot;SHOW PROCESSLIST&quot;
doesn&rsquo;t return any rows, &quot;mk-table-checksum&quot;
looks at &quot;SHOW SLAVE HOSTS&quot; instead. The host and
port, and user and password if available, from &quot;SHOW
<br>
SLAVE HOSTS&quot; are combined into a DSN and used as the
argument. This requires slaves to be configured with
&quot;report-host&quot;, &quot;report-port&quot; and so
on.</p>

<p style="margin-top: 1em">This requires the @@SERVER_ID
system variable, so it works only on MySQL 3.23.26 or
newer.</p>

<p style="margin-top: 1em">--replicate-database <br>
type: string</p>

<p style="margin-top: 1em">&quot;USE&quot; only this
database with &quot;--replicate&quot;. By default,
mk-table-checksum executes USE to set its default database
to the database that contains the table it&rsquo;s currently
<br>
working on. It changes its default database as it works on
different tables. This is is a best effort to avoid problems
with replication filters such as binlog_ignore_db <br>
and replicate_ignore_db. However, replication filters can
create a situation where there simply is no one right way to
do things. Some statements might not be replicated, <br>
and others might cause replication to fail on the slaves. In
such cases, it is up to the user to specify a safe default
database. This option specifies a default database <br>
that mk-table-checksum selects with USE, and never changes
afterwards. See also
&lt;L&quot;--[no]check-replication-filters&quot;&gt;.</p>

<p style="margin-top: 1em">--resume <br>
type: string</p>

<p style="margin-top: 1em">Resume checksum using given
output file from a previously interrupted run.</p>

<p style="margin-top: 1em">The given output file should be
the literal output from a previous run of
&quot;mk-table-checksum&quot;. For example:</p>

<p style="margin-top: 1em">mk-table-checksum host1 host2 -C
100 &gt; checksum_results.txt <br>
mk-table-checksum host1 host2 -C 100 --resume
checksum_results.txt</p>

<p style="margin-top: 1em">The command line options given
to the first run and the resumed run must be identical
(except, of course, for --resume). If they are not, the
result will be unpredictable <br>
and probably wrong.</p>

<p style="margin-top: 1em">&quot;--resume&quot; does not
work with &quot;--replicate&quot;; for that, use
&quot;--resume-replicate&quot;.</p>

<p style="margin-top: 1em">--resume-replicate <br>
Resume &quot;--replicate&quot;.</p>

<p style="margin-top: 1em">This option resumes a previous
checksum operation using &quot;--replicate&quot;. It is like
&quot;--resume&quot; but does not require an output file.
Instead, it uses the checksum table given <br>
to &quot;--replicate&quot; to determine where to resume the
checksum operation.</p>

<p style="margin-top: 1em">--save-since <br>
When &quot;--arg-table&quot; and &quot;--since&quot; are
given, save the current &quot;--since&quot; value into that
table&rsquo;s &quot;since&quot; column after checksumming.
In this way you can incrementally checksum <br>
tables by starting where the last one finished.</p>

<p style="margin-top: 1em">The value to be saved could be
the current timestamp, or it could be the maximum existing
value of the column given by &quot;--since-column&quot;. It
depends on what options are in <br>
effect. See the description of &quot;--since&quot; to see
how timestamps are different from ordinary values.</p>

<p style="margin-top: 1em">--schema <br>
Checksum &quot;SHOW CREATE TABLE&quot; instead of table
data.</p>

<p style="margin-top: 1em">--separator <br>
type: string; default: #</p>

<p style="margin-top: 1em">The separator character used for
CONCAT_WS().</p>

<p style="margin-top: 1em">This character is used to join
the values of columns when checksumming with
&quot;--algorithm&quot; of BIT_XOR or ACCUM.</p>

<p style="margin-top: 1em">--set-vars <br>
type: string; default: wait_timeout=10000; group:
Connection</p>

<p style="margin-top: 1em">Set these MySQL variables.
Immediately after connecting to MySQL, this string will be
appended to SET and executed.</p>

<p style="margin-top: 1em">--since <br>
type: string</p>

<p style="margin-top: 1em">Checksum only data newer than
this value.</p>

<p style="margin-top: 1em">If the table is chunk-able or
nibble-able, this value will apply to the first column of
the chunked or nibbled index.</p>

<p style="margin-top: 1em">This is not too different to
&quot;--where&quot;, but instead of universally applying a
WHERE clause to every table, it selectively finds the right
column to use and applies it only if <br>
such a column is found. See also
&quot;--since-column&quot;.</p>

<p style="margin-top: 1em">The argument may be an
expression, which is evaluated by MySQL. For example, you
can specify &quot;CURRENT_DATE - INTERVAL 7 DAY&quot; to get
the date of one week ago.</p>

<p style="margin-top: 1em">A special bit of extra magic: if
the value is temporal (looks like a date or datetime), then
the table is checksummed only if the create time (or last
modified time, for <br>
tables that report the last modified time, such as MyISAM
tables) is newer than the value. In this sense it&rsquo;s
not applied as a WHERE clause at all.</p>

<p style="margin-top: 1em">--since-column <br>
type: string</p>

<p style="margin-top: 1em">The column name to be used for
&quot;--since&quot;.</p>

<p style="margin-top: 1em">The default is for the tool to
choose the best one automatically. If you specify a value,
that will be used if possible; otherwise the best
auto-determined one; otherwise <br>
none. If the column doesn&rsquo;t exist in the table, it is
just ignored.</p>

<p style="margin-top: 1em">--single-chunk <br>
Permit skipping with &quot;--probability&quot; if there is
only one chunk.</p>

<p style="margin-top: 1em">Normally, if a table isn&rsquo;t
split into many chunks, it will always be checksummed
regardless of &quot;--probability&quot;. This setting lets
the probabilistic behavior apply to tables <br>
that aren&rsquo;t divided into chunks.</p>

<p style="margin-top: 1em">--slave-lag <br>
group: Output</p>

<p style="margin-top: 1em">Report replication delay on the
slaves.</p>

<p style="margin-top: 1em">If this option is enabled, the
output will show how many seconds behind the master each
slave is. This can be useful when you want a fast, parallel,
non-blocking checksum, <br>
and you know your slaves might be delayed relative to the
master. You can inspect the results and make an educated
guess whether any discrepancies on the slave are due to <br>
replication delay instead of corrupt data.</p>

<p style="margin-top: 1em">If you&rsquo;re using
&quot;--replicate&quot;, a slave that is delayed relative to
the master does not invalidate the correctness of the
results, so this option is disabled.</p>

<p style="margin-top: 1em">--sleep <br>
type: int; group: Throttle</p>

<p style="margin-top: 1em">Sleep time between
checksums.</p>

<p style="margin-top: 1em">If this option is specified,
mk-table-checksum will sleep the specified number of seconds
between checksums. That is, it will sleep between every
table, and if you specify <br>
&quot;--chunk-size&quot;, it will also sleep between
chunks.</p>

<p style="margin-top: 1em">This is a very crude way to
throttle checksumming; see &quot;--sleep-coef&quot; and
&quot;--check-slave-lag&quot; for techniques that permit
greater control.</p>

<p style="margin-top: 1em">--sleep-coef <br>
type: float; group: Throttle</p>

<p style="margin-top: 1em">Calculate &quot;--sleep&quot; as
a multiple of the last checksum time.</p>

<p style="margin-top: 1em">If this option is specified,
mk-table-checksum will sleep the amount of time elapsed
during the previous checksum, multiplied by the specified
coefficient. This option is <br>
ignored if &quot;--sleep&quot; is specified.</p>

<p style="margin-top: 1em">This is a slightly more
sophisticated way to throttle checksum speed: sleep a
varying amount of time between chunks, depending on how long
the chunks are taking. Even better <br>
is to use &quot;--check-slave-lag&quot; if you&rsquo;re
checksumming master/slave replication.</p>

<p style="margin-top: 1em">--socket <br>
short form: -S; type: string; group: Connection</p>

<p style="margin-top: 1em">Socket file to use for
connection.</p>

<p style="margin-top: 1em">--tab <br>
group: Output</p>

<p style="margin-top: 1em">Print tab-separated output, not
column-aligned output.</p>

<p style="margin-top: 1em">--tables <br>
short form: -t; type: hash; group: Filter</p>

<p style="margin-top: 1em">Do only this comma-separated
list of tables.</p>

<p style="margin-top: 1em">Table names may be qualified
with the database name.</p>

<p style="margin-top: 1em">--tables-regex <br>
type: string</p>

<p style="margin-top: 1em">Only checksum tables whose names
match this Perl regex.</p>

<p style="margin-top: 1em">--throttle-method <br>
type: string; default: none; group: Throttle</p>

<p style="margin-top: 1em">Throttle checksumming when doing
&quot;--replicate&quot;.</p>

<p style="margin-top: 1em">At present there is only one
method: &quot;slavelag&quot;. When &quot;--replicate&quot;
is used, mk-table-checksum automatically sets
&quot;--throttle-method&quot; to &quot;slavelag&quot; and
discovers every slave <br>
and throttles checksumming if any slave lags more than
&quot;--max-lag&quot;. Specify &quot;-throttle-method
none&quot; to disable this behavior completely, or specify
&quot;--check-slave-lag&quot; and <br>
mk-table-checksum will only check that slave.</p>

<p style="margin-top: 1em">See also &quot;--recurse&quot;
and &quot;--recursion-method&quot;.</p>

<p style="margin-top: 1em">--trim <br>
Trim &quot;VARCHAR&quot; columns (helps when comparing 4.1
to &gt;= 5.0).</p>

<p style="margin-top: 1em">This option adds a
&quot;TRIM()&quot; to &quot;VARCHAR&quot; columns in
&quot;BIT_XOR&quot; and &quot;ACCUM&quot; modes.</p>

<p style="margin-top: 1em">This is useful when you
don&rsquo;t care about the trailing space differences
between MySQL versions which vary in their handling of
trailing spaces. MySQL 5.0 and later all retain <br>
trailing spaces in &quot;VARCHAR&quot;, while previous
versions would remove them.</p>

<p style="margin-top: 1em">--unchunkable-tables <br>
group: Safety</p>

<p style="margin-top: 1em">Checksum tables that cannot be
chunked when &quot;--chunk-size&quot; is specified.</p>

<p style="margin-top: 1em">By default mk-table-checksum
will not checksum a table that cannot be chunked when
&quot;--chunk-size&quot; is specified because this might
result in a huge, non-chunkable table being <br>
checksummed in one huge, memory-intensive chunk.</p>

<p style="margin-top: 1em">Specifying this option allows
checksumming tables that cannot be chunked. Be careful when
using this option! Make sure any non-chunkable tables are
not so large that they <br>
will cause the tool to consume too much memory or CPU.</p>

<p style="margin-top: 1em">See also
&quot;--chunk-size-limit&quot;.</p>

<p style="margin-top: 1em">--[no]use-index <br>
default: yes</p>

<p style="margin-top: 1em">Add FORCE INDEX hints to SQL
statements.</p>

<p style="margin-top: 1em">By default
&quot;mk-table-checksum&quot; adds an index hint
(&quot;FORCE INDEX&quot; for MySQL v4.0.9 and newer,
&quot;USE INDEX&quot; for older MySQL versions) to each SQL
statement to coerce MySQL into <br>
using the &quot;--chunk-index&quot; (whether the index is
specified by the option or auto-detected). Specifying
&quot;--no-use-index&quot; causes
&quot;mk-table-checksum&quot; to omit index hints.</p>

<p style="margin-top: 1em">--user <br>
short form: -u; type: string; group: Connection</p>

<p style="margin-top: 1em">User for login if not current
user.</p>

<p style="margin-top: 1em">--[no]verify <br>
default: yes</p>

<p style="margin-top: 1em">Verify checksum compatibility
across servers.</p>

<p style="margin-top: 1em">This option runs a trivial
checksum on all servers to ensure they have compatible
CONCAT_WS() and cryptographic hash functions.</p>

<p style="margin-top: 1em">Versions of MySQL before 4.0.14
will skip empty strings and NULLs in CONCAT_WS, and others
will only skip NULLs. The two kinds of behavior will produce
different results if <br>
you have any columns containing the empty string in your
table. If you know you don&rsquo;t (for instance, all
columns are integers), you can safely disable this check and
you <br>
will get a reliable checksum even on servers with different
behavior.</p>

<p style="margin-top: 1em">--version <br>
group: Help</p>

<p style="margin-top: 1em">Show version and exit.</p>

<p style="margin-top: 1em">--wait <br>
short form: -w; type: time</p>

<p style="margin-top: 1em">Wait this long for slaves to
catch up to their master (implies &quot;--lock&quot;
&quot;--slave-lag&quot;).</p>

<p style="margin-top: 1em">Note: the best way to verify
that a slave is in sync with its master is to use
&quot;--replicate&quot; instead. The &quot;--wait&quot;
option is really only useful if you&rsquo;re trying to
compare <br>
masters and slaves without using &quot;--replicate&quot;,
which is possible but complex and less efficient in some
ways.</p>

<p style="margin-top: 1em">This option helps you get a
consistent checksum across a master server and its slaves.
It combines locking and waiting to accomplish this. First it
locks the table on the <br>
master (the first server on the command line). Then it finds
the master&rsquo;s binlog position. Checksums on slaves will
be deferred until they reach the same binlog position.</p>

<p style="margin-top: 1em">The argument to the option is
the number of seconds to wait for the slaves to catch up to
the master. It is actually the argument to
MASTER_POS_WAIT(). If the slaves don&rsquo;t <br>
catch up to the master within this time, they will unblock
and go ahead with the checksum. You can tell whether this
happened by examining the STAT column in the output, <br>
which is the return value of MASTER_POS_WAIT().</p>

<p style="margin-top: 1em">--where <br>
type: string</p>

<p style="margin-top: 1em">Do only rows matching this
&quot;WHERE&quot; clause (disallows &quot;--algorithm&quot;
CHECKSUM).</p>

<p style="margin-top: 1em">You can use this option to limit
the checksum to only part of the table. This is particularly
useful if you have append-only tables and don&rsquo;t want
to constantly re-check all <br>
rows; you could run a daily job to just check
yesterday&rsquo;s rows, for instance.</p>

<p style="margin-top: 1em">This option is much like the -w
option to mysqldump. Do not specify the WHERE keyword. You
may need to quote the value. Here is an example:</p>

<p style="margin-top: 1em">mk-table-checksum --where
&quot;foo=bar&quot;</p>

<p style="margin-top: 1em">--[no]zero-chunk <br>
default: yes</p>

<p style="margin-top: 1em">Add a chunk for rows with zero
or zero-equivalent values. The only has an effect when
&quot;--chunk-size&quot; is specified. The purpose of the
zero chunk is to capture a potentially <br>
large number of zero values that would imbalance the size of
the first chunk. For example, if a lot of negative numbers
were inserted into an unsigned integer column causing <br>
them to be stored as zeros, then these zero values are
captured by the zero chunk instead of the first chunk and
all its non-zero values.</p>

<p style="margin-top: 1em">DSN OPTIONS <br>
These DSN options are used to create a DSN. Each option is
given like &quot;option=value&quot;. The options are
case-sensitive, so P and p are not the same option. There
cannot be <br>
whitespace before or after the &quot;=&quot; and if the
value contains whitespace it must be quoted. DSN options are
comma-separated. See the maatkit manpage for full
details.</p>

<p style="margin-top: 1em">&Acirc;&middot; A</p>

<p style="margin-top: 1em">dsn: charset; copy: yes</p>

<p style="margin-top: 1em">Default character set.</p>

<p style="margin-top: 1em">&Acirc;&middot; D</p>

<p style="margin-top: 1em">dsn: database; copy: yes</p>

<p style="margin-top: 1em">Default database.</p>

<p style="margin-top: 1em">&Acirc;&middot; F</p>

<p style="margin-top: 1em">dsn: mysql_read_default_file;
copy: yes</p>

<p style="margin-top: 1em">Only read default options from
the given file</p>

<p style="margin-top: 1em">&Acirc;&middot; h</p>

<p style="margin-top: 1em">dsn: host; copy: yes</p>

<p style="margin-top: 1em">Connect to host.</p>

<p style="margin-top: 1em">&Acirc;&middot; p</p>

<p style="margin-top: 1em">dsn: password; copy: yes</p>

<p style="margin-top: 1em">Password to use when
connecting.</p>

<p style="margin-top: 1em">&Acirc;&middot; P</p>

<p style="margin-top: 1em">dsn: port; copy: yes</p>

<p style="margin-top: 1em">Port number to use for
connection.</p>

<p style="margin-top: 1em">&Acirc;&middot; S</p>

<p style="margin-top: 1em">dsn: mysql_socket; copy: yes</p>

<p style="margin-top: 1em">Socket file to use for
connection.</p>

<p style="margin-top: 1em">&Acirc;&middot; u</p>

<p style="margin-top: 1em">dsn: user; copy: yes</p>

<p style="margin-top: 1em">User for login if not current
user.</p>

<p style="margin-top: 1em">DOWNLOADING <br>
You can download Maatkit from Google Code at
&lt;http://code.google.com/p/maatkit/&gt;, or you can get
any of the tools easily with a command like the
following:</p>

<p style="margin-top: 1em">wget
http://www.maatkit.org/get/toolname <br>
or <br>
wget http://www.maatkit.org/trunk/toolname</p>

<p style="margin-top: 1em">Where &quot;toolname&quot; can
be replaced with the name (or fragment of a name) of any of
the Maatkit tools. Once downloaded, they&rsquo;re ready to
run; no installation is needed. The first <br>
URL gets the latest released version of the tool, and the
second gets the latest trunk code from Subversion.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
The environment variable &quot;MKDEBUG&quot; enables verbose
debugging output in all of the Maatkit tools:</p>

<p style="margin-top: 1em">MKDEBUG=1 mk-....</p>

<p style="margin-top: 1em">SYSTEM REQUIREMENTS <br>
You need Perl, DBI, DBD::mysql, and some core packages that
ought to be installed in any reasonably new version of
Perl.</p>

<p style="margin-top: 1em">BUGS <br>
For a list of known bugs see
&lt;http://www.maatkit.org/bugs/mk-table-checksum&gt;.</p>

<p style="margin-top: 1em">Please use Google Code Issues
and Groups to report bugs or request support:
&lt;http://code.google.com/p/maatkit/&gt;. You can also join
#maatkit on Freenode to discuss Maatkit.</p>

<p style="margin-top: 1em">Please include the complete
command-line used to reproduce the problem you are seeing,
the version of all MySQL servers involved, the complete
output of the tool when run with <br>
&quot;--version&quot;, and if possible, debugging output
produced by running with the &quot;MKDEBUG=1&quot;
environment variable.</p>

<p style="margin-top: 1em">COPYRIGHT, LICENSE AND WARRANTY
<br>
This program is copyright 2007-2011 Baron Schwartz. Feedback
and improvements are welcome.</p>

<p style="margin-top: 1em">THIS PROGRAM IS PROVIDED
&quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A <br>
PARTICULAR PURPOSE.</p>

<p style="margin-top: 1em">This program is free software;
you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free
Software Foundation, version 2; <br>
OR the Perl Artistic License. On UNIX and similar systems,
you can issue &lsquo;man perlgpl&rsquo; or &lsquo;man
perlartistic&rsquo; to read these licenses.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program;
if not, write to the Free Software Foundation, Inc., 59
Temple Place, Suite 330, <br>
Boston, MA 02111-1307 USA.</p>

<p style="margin-top: 1em">SEE ALSO <br>
See also mk-checksum-filter and mk-table-sync.</p>

<p style="margin-top: 1em">AUTHOR <br>
Baron &quot;Xaprb&quot; Schwartz</p>

<p style="margin-top: 1em">ABOUT MAATKIT <br>
This tool is part of Maatkit, a toolkit for power users of
MySQL. Maatkit was created by Baron Schwartz; Baron and
Daniel Nichter are the primary code contributors. Both are
<br>
employed by Percona. Financial support for Maatkit
development is primarily provided by Percona and its
clients.</p>

<p style="margin-top: 1em">ACKNOWLEDGMENTS <br>
This is an incomplete list. My apologies for omissions or
misspellings.</p>

<p style="margin-top: 1em">Claus Jeppesen, Francois
Saint-Jacques, Giuseppe Maxia, Heikki Tuuri, James Briggs,
Martin Friebe, Sergey Zhuravlev,</p>

<p style="margin-top: 1em">VERSION <br>
This manual page documents Ver 1.2.23 Distrib 7540
$Revision: 7527 $.</p>

<p style="margin-top: 1em">perl v5.24.1 2011-06-08
MK-TABLE-CHECKSUM(1)</p>
<hr>
</body>
</html>
