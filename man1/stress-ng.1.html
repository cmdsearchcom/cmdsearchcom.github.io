<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>STRESS-NG(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">STRESS-NG(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">STRESS-NG(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
stress-ng - a tool to load and stress a computer system
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>stress-ng</b> [ <i>OPTION </i>[<i>ARG</i>]] ...
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
stress-ng will stress test a computer system in various selectable ways. It was
  designed to exercise various physical subsystems of a computer as well as the
  various operating system kernel interfaces. stress-ng also has a wide range of
  CPU specific stress tests that exercise floating point, integer, bit
  manipulation and control flow.
<div class="Pp"></div>
stress-ng was originally intended to make a machine work hard and trip hardware
  issues such as thermal overruns as well as operating system bugs that only
  occur when a system is being thrashed hard. Use stress-ng with caution as some
  of the tests can make a system run hot on poorly designed hardware and also
  can cause excessive system thrashing which may be difficult to stop.
<div class="Pp"></div>
stress-ng can also measure test throughput rates; this can be useful to observe
  performance changes across different operating system releases or types of
  hardware. However, it has never been intended to be used as a precise
  benchmark test suite, so do NOT use it in this manner.
<div class="Pp"></div>
Running stress-ng with root privileges will adjust out of memory settings on
  Linux systems to make the stressors unkillable in low memory situations, so
  use this judiciously. With the appropriate privilege, stress-ng can allow the
  ionice class and ionice levels to be adjusted, again, this should be used with
  care.
<div class="Pp"></div>
One can specify the number of processes to invoke per type of stress test;
  specifying a negative or zero value will select the number of processors
  available as defined by sysconf(_SC_NPROCESSORS_CONF).
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<b>General stress-ng control options:</b>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--aggressive</b></dt>
  <dd class="It-tag">enables more file, cache and memory aggressive options.
      This may slow tests down, increase latencies and reduce the number of bogo
      ops as well as changing the balance of user time vs system time used
      depending on the type of stressor being used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a N, --all N</b></dt>
  <dd class="It-tag">start N instances of each stressor. If N is less than zero,
      then the number of CPUs online is used for the number of instances. If N
      is zero, then the number of CPUs in the system is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b N, --backoff N</b></dt>
  <dd class="It-tag">wait N microseconds between the start of each stress worker
      process. This allows one to ramp up the stress tests over time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--class name</b></dt>
  <dd class="It-tag">specify the class of stressors to run. Stressors are
      classified into one or more of the following classes: cpu, cpu-cache,
      device, io, interrupt, filesystem, memory, network, os, pipe, scheduler
      and vm. Some stressors fall into just one class. For example the 'get'
      stressor is just in the 'os' class. Other stressors fall into more than
      one class, for example, the 'lsearch' stressor falls into the 'cpu',
      'cpu-cache' and 'memory' classes as it exercises all these three.
      Selecting a specific class will run all the stressors that fall into that
      class only when run with the --sequential option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n, --dry-run</b></dt>
  <dd class="It-tag">parse options, but do not run stress tests. A no-op.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h, --help</b></dt>
  <dd class="It-tag">show help.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ignite-cpu</b></dt>
  <dd class="It-tag">alter kernel controls to try and maximize the CPU. This
      requires root privilege to alter various /sys interface controls.
      Currently this only works for Intel P-State enabled x86 systems on
    Linux.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ionice-class class</b></dt>
  <dd class="It-tag">specify ionice class (only on Linux). Can be idle
      (default), besteffort, be, realtime, rt.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ionice-level level</b></dt>
  <dd class="It-tag">specify ionice level (only on Linux). For idle, 0 is the
      only possible option. For besteffort or realtime values 0 (highest
      priority) to 7 (lowest priority). See ionice(1) for more details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k, --keep-name</b></dt>
  <dd class="It-tag">by default, stress-ng will attempt to change the name of
      the stress processes according to their functionality; this option
      disables this and keeps the process names to be the name of the parent
      process, that is, stress-ng.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-brief</b></dt>
  <dd class="It-tag">by default stress-ng will report the name of the program,
      the message type and the process id as a prefix to all output. The
      --log-brief option will output messages without these fields to produce a
      less verbose output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log-file filename</b></dt>
  <dd class="It-tag">write messages to the specified log file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maximize</b></dt>
  <dd class="It-tag">overrides the default stressor settings and instead sets
      these to the maximum settings allowed. These defaults can always be
      overridden by the per stressor settings options if required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--metrics</b></dt>
  <dd class="It-tag">output number of bogo operations in total performed by the
      stress processes. Note that these are not a reliable metric of performance
      or throughput and have not been designed to be used for benchmarking
      whatsoever. The metrics are just a useful way to observe how a system
      behaves when under various kinds of load.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
The following columns of information are output:
<table class="tbl">
  <colgroup>
    <col style="width: 25.00ex;"/>
    <col style="width: 362.00ex;"/>
  </colgroup>
  <tr>
    <td>Column Heading</td>
    <td>Explanation</td>
  </tr>
  <tr>
    <td>bogo ops</td>
    <td>number of iterations of the stressor during the run. This is metric of
      how much overall &quot;work&quot; has been achieved in bogo
      operations.</td>
  </tr>
  <tr>
    <td>real time (secs)</td>
    <td>average wall clock duration (in seconds) of the stressor. This is the
      total wall clock time of all the instances of that particular stressor
      divided by the number of these stressors being run.</td>
  </tr>
  <tr>
    <td>usr time (secs)</td>
    <td>total user time (in seconds) consumed running all the instances of the
      stressor.</td>
  </tr>
  <tr>
    <td>sys time (secs)</td>
    <td>total system time (in seconds) consumed running all the instances of the
      stressor.</td>
  </tr>
  <tr>
    <td>bogo ops/s (real time)</td>
    <td>total bogo operations per second based on wall clock run time. The wall
      clock time reflects the apparent run time. The more processors one has on
      a system the more the work load can be distributed onto these and hence
      the wall clock time will reduce and the bogo ops rate will increase. This
      is essentially the &quot;apparent&quot; bogo ops rate of the system.</td>
  </tr>
  <tr>
    <td>bogo ops/s (usr+sys time)</td>
    <td>total bogo operations per second based on cumulative user and system
      time. This is the real bogo ops rate of the system taking into
      consideration the actual time execution time of the stressor across all
      the processors. Generally this will decrease as one adds more concurrent
      stressors due to contention on cache, memory, execution units, buses and
      I/O devices.</td>
  </tr>
</table>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--metrics-brief</b></dt>
  <dd class="It-tag">enable metrics and only output metrics that are
    non-zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--minimize</b></dt>
  <dd class="It-tag">overrides the default stressor settings and instead sets
      these to the minimum settings allowed. These defaults can always be
      overridden by the per stressor settings options if required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-advise</b></dt>
  <dd class="It-tag">from version 0.02.26 stress-ng automatically calls
      madvise(2) with random advise options before each mmap and munmap to
      stress the the vm subsystem a little harder. The --no-advise option turns
      this default off.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-rand-seed</b></dt>
  <dd class="It-tag">Do not seed the stress-ng psuedo-random number generator
      with a quasi random start seed, but instead seed it with constant values.
      This forces tests to run each time using the same start conditions which
      can be useful when one requires reproduceable stress tests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--page-in</b></dt>
  <dd class="It-tag">touch allocated pages that are not in core, forcing them to
      be paged back in. This is a useful option to force all the allocated pages
      to be paged in when using the bigheap, mmap and vm stressors. It will
      severely degrade performance when the memory in the system is less than
      the allocated buffer sizes. This uses mincore(2) to determine the pages
      that are not in core and hence need touching to page them back in.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pathological</b></dt>
  <dd class="It-tag">enable stressors that are known to hang systems. Some
      stressors can quickly consume resources in such a way that they can
      rapidly hang a system before the kernel can OOM kill them. These stressors
      are not enabled by default, this option enables them, but you probably
      don't want to do this. You have been warned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--perf</b></dt>
  <dd class="It-tag">measure processor and system activity using perf events.
      Linux only and caveat emptor, according to perf_event_open(2):
      &quot;Always double-check your results! Various generalized events have
      had wrong values.&quot;. Note that with Linux 4.7 one needs to have
      CAP_SYS_ADMIN capabilities for this option to work, or adjust
      /proc/sys/kernel/perf_event_paranoid to below 2 to use this without
      CAP_SYS_ADMIN.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q, --quiet</b></dt>
  <dd class="It-tag">do not show any output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r N, --random N</b></dt>
  <dd class="It-tag">start N random stress workers. If N is 0, then the number
      of configured processors is used for N.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sched scheduler</b></dt>
  <dd class="It-tag">select the named scheduler (only on Linux). To see the list
      of available schedulers use: stress-ng --sched which</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sched-prio prio</b></dt>
  <dd class="It-tag">select the scheduler priority level (only on Linux). If the
      scheduler does not support this then the default priority level of 0 is
      chosen.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sequential N</b></dt>
  <dd class="It-tag">sequentially run all the stressors one by one for a default
      of 60 seconds. The number of instances of each of the individual stressors
      to be started is N. If N is less than zero, then the number of CPUs online
      is used for the number of instances. If N is zero, then the number of CPUs
      in the system is used. Use the --timeout option to specify the duration to
      run each stressor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stressors</b></dt>
  <dd class="It-tag">output the names of the available stressors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--syslog</b></dt>
  <dd class="It-tag">log output (except for verbose -v messages) to the
    syslog.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--taskset list</b></dt>
  <dd class="It-tag">set CPU affinity based on the list of CPUs provided;
      stress-ng is bound to just use these CPUs (Linux only). The CPUs to be
      used are specified by a comma separated list of CPU (0 to N-1). One can
      specify a range of CPUs using '-', for example: --taskset
    0,2-3,6,7-11</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--temp-path path</b></dt>
  <dd class="It-tag">specify a path for stress-ng temporary directories and
      temporary files; the default path is the current working directory. This
      path must have read and write access for the stress-ng stress
    processes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--thrash</b></dt>
  <dd class="It-tag">This can only be used when running on Linux and with root
      privilege. This option starts a background thrasher process that works
      through all the processes on a system and tries to page as many pages in
      the processes as possible. This will cause considerable amount of
      thrashing of swap on an over-committed system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t N, --timeout N</b></dt>
  <dd class="It-tag">stop stress test after N seconds. One can also specify the
      units of time in seconds, minutes, hours, days or years with the suffix s,
      m, h, d or y.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timer-slack N</b></dt>
  <dd class="It-tag">adjust the per process timer slack to N nanoseconds (Linux
      only). Increasing the timer slack allows the kernel to coalesce timer
      events by adding some fuzzinesss to timer expiration times and hence
      reduce wakeups. Conversely, decreasing the timer slack will increase
      wakeups. A value of 0 for the timer-slack will set the system default of
      50,000 nanoseconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--times</b></dt>
  <dd class="It-tag">show the cumulative user and system times of all the child
      processes at the end of the stress run. The percentage of utilisation of
      available CPU time is also calculated from the number of on-line CPUs in
      the system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tz</b></dt>
  <dd class="It-tag">collect temperatures from the available thermal zones on
      the machine (Linux only). Some devices may have one or more thermal zones,
      where as others may have none.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v, --verbose</b></dt>
  <dd class="It-tag">show all debug, warnings and normal information
    output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verify</b></dt>
  <dd class="It-tag">verify results when a test is run. This is not available on
      all tests. This will sanity check the computations or memory contents from
      a test run and report to stderr any unexpected failures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V, --version</b></dt>
  <dd class="It-tag">show version.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x, --exclude list</b></dt>
  <dd class="It-tag">specify a list of one or more stressors to exclude (that
      is, do not run them). This is useful to exclude specific stressors when
      one selects many stressors to run using the --class option, --sequential,
      --all and --random options. Example, run the cpu class stressors
      concurrently and exclude the numa and search stressors:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">stress-ng --class cpu --all 1 -x
      numa,bsearch,hsearch,lsearch</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Y, --yaml filename</b></dt>
  <dd class="It-tag">output gathered statistics to a YAML formatted file named
      'filename'.
    <div>&#x00A0;</div>
    <div style="height: 2.00em;">&#x00A0;</div>
  </dd>
</dl>
<div class="Pp"></div>
<b>Stressor specific options:</b>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--affinity N</b></dt>
  <dd class="It-tag">start N workers that rapidly change CPU affinity (only on
      Linux). Rapidly switching CPU affinity can contribute to poor cache
      behaviour.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--affinity-ops N</b></dt>
  <dd class="It-tag">stop affinity workers after N bogo affinity operations
      (only on Linux).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--affinity-rand</b></dt>
  <dd class="It-tag">switch CPU affinity randomly rather than the default of
      sequentially.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--af-alg N</b></dt>
  <dd class="It-tag">start N workers that exercise the AF_ALG socket domain by
      hashing and encrypting various sized random messages. This exercises the
      SHA1, SHA224, SHA256, SHA384, SHA512, MD4, MD5, RMD128, RMD160, RMD256,
      RMD320, WP256, WP384, WP512, TGR128, TGR160, TGR192 hashes and the
      cbc(aes), lrw(aes), ofb(aes), xts(twofish), xts(serpent), xts(cast6),
      xts(camellia), lrw(twofish), lrw(cast6), lrw(camellia), salsa20
    skcipers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--af-alg-ops N</b></dt>
  <dd class="It-tag">stop af-alg workers after N AF_ALG messages are
    hashed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--aio N</b></dt>
  <dd class="It-tag">start N workers that issue multiple small asynchronous I/O
      writes and reads on a relatively small temporary file using the POSIX aio
      interface. This will just hit the file system cache and soak up a lot of
      user and kernel time in issuing and handling I/O requests. By default,
      each worker process will handle 16 concurrent I/O requests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--aio-ops N</b></dt>
  <dd class="It-tag">stop POSIX asynchronous I/O workers after N bogo
      asynchronous I/O requests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--aio-requests N</b></dt>
  <dd class="It-tag">specify the number of POSIX asynchronous I/O requests each
      worker should issue, the default is 16; 1 to 4096 are allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--aiol N</b></dt>
  <dd class="It-tag">start N workers that issue multiple 4K random asynchronous
      I/O writes using the Linux aio system calls io_setup(2), io_submit(2),
      io_getevents(2) and io_destroy(2). By default, each worker process will
      handle 16 concurrent I/O requests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--aiol-ops N</b></dt>
  <dd class="It-tag">stop Linux asynchronous I/O workers after N bogo
      asynchronous I/O requests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--aiol-requests N</b></dt>
  <dd class="It-tag">specify the number of Linux asynchronous I/O requests each
      worker should issue, the default is 16; 1 to 4096 are allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--apparmor N</b></dt>
  <dd class="It-tag">start N workers that exercise various parts of the AppArmor
      interface. Currently one needs root permission to run this particular
      test. This test is only available on Linux systems with AppArmor
    support.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--apparmor-ops</b></dt>
  <dd class="It-tag">stop the AppArmor workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--atomic N</b></dt>
  <dd class="It-tag">start N workers that exercise various GCC __atomic_*()
      built in operations on 8, 16, 32 and 64 bit intergers that are shared
      among the N workers. This stressor is only available for builds using GCC
      4.7.4 or higher. The stressor forces many front end cache stalls and cache
      references.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--atomic-ops N</b></dt>
  <dd class="It-tag">stop the atomic workers after N bogo atomic
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B N, --bigheap N</b></dt>
  <dd class="It-tag">start N workers that grow their heaps by reallocating
      memory. If the out of memory killer (OOM) on Linux kills the worker or the
      allocation fails then the allocating process starts all over again. Note
      that the OOM adjustment for the worker is set so that the OOM killer will
      treat these workers as the first candidate processes to kill.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bigheap-ops N</b></dt>
  <dd class="It-tag">stop the big heap workers after N bogo allocation
      operations are completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bigheap-growth N</b></dt>
  <dd class="It-tag">specify amount of memory to grow heap by per iteration.
      Size can be from 4K to 64MB. Default is 64K.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bind-mount N</b></dt>
  <dd class="It-tag">start N workers that repeatedly bind mount / to / inside a
      user namespace. This can consume resources rapidly, forcing out of memory
      situations. Do not use this stressor unless you want to risk hanging your
      machine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bind-mount-ops N</b></dt>
  <dd class="It-tag">stop after N bind mount bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--brk N</b></dt>
  <dd class="It-tag">start N workers that grow the data segment by one page at a
      time using multiple brk(2) calls. Each successfully allocated new page is
      touched to ensure it is resident in memory. If an out of memory condition
      occurs then the test will reset the data segment to the point before it
      started and repeat the data segment resizing over again. The process
      adjusts the out of memory setting so that it may be killed by the out of
      memory (OOM) killer before other processes. If it is killed by the OOM
      killer then it will be automatically re-started by a monitoring parent
      process.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--brk-ops N</b></dt>
  <dd class="It-tag">stop the brk workers after N bogo brk operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--brk-notouch</b></dt>
  <dd class="It-tag">do not touch each newly allocated data segment page. This
      disables the default of touching each newly allocated page and hence
      avoids the kernel from necessarily backing the page with real physical
      memory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bsearch N</b></dt>
  <dd class="It-tag">start N workers that binary search a sorted array of 32 bit
      integers using bsearch(3). By default, there are 65536 elements in the
      array. This is a useful method to exercise random access of memory and
      processor cache.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bsearch-ops N</b></dt>
  <dd class="It-tag">stop the bsearch worker after N bogo bsearch operations are
      completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bsearch-size N</b></dt>
  <dd class="It-tag">specify the size (number of 32 bit integers) in the array
      to bsearch. Size can be from 1K to 4M.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C N, --cache N</b></dt>
  <dd class="It-tag">start N workers that perform random wide spread memory read
      and writes to thrash the CPU cache. The code does not intelligently
      determine the CPU cache configuration and so it may be sub-optimal in
      producing hit-miss read/write activity for some processors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache-fence</b></dt>
  <dd class="It-tag">force write serialization on each store operation (x86
      only). This is a no-op for non-x86 architectures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache-flush</b></dt>
  <dd class="It-tag">force flush cache on each store operation (x86 only). This
      is a no-op for non-x86 architectures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache-level N</b></dt>
  <dd class="It-tag">specify level of cache to exercise (1=L1 cache, 2=L2 cache,
      3=L3/LLC cache (the default)). If the cache hierarchy cannot be
      determined, built-in defaults will apply.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache-no-affinity</b></dt>
  <dd class="It-tag">do not change processor affinity when <b>--cache</b> is in
      effect.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache-ops N</b></dt>
  <dd class="It-tag">stop cache thrash workers after N bogo cache thrash
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache-prefetch</b></dt>
  <dd class="It-tag">force read prefetch on next read address on architectures
      that support prefetching.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache-ways N</b></dt>
  <dd class="It-tag">specify the number of cache ways to exercise. This allows a
      subset of the overall cache size to be exercised.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cap N</b></dt>
  <dd class="It-tag">start N workers that read per process capabililties via
      calls to capget(2) (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cap-ops N</b></dt>
  <dd class="It-tag">stop after N cap bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chdir N</b></dt>
  <dd class="It-tag">start N workers that change directory between 8192
      directories using chdir(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chdir-ops N</b></dt>
  <dd class="It-tag">stop after N chdir bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chmod N</b></dt>
  <dd class="It-tag">start N workers that change the file mode bits via chmod(2)
      and fchmod(2) on the same file. The greater the value for N then the more
      contention on the single file. The stressor will work through all the
      combination of mode bits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chmod-ops N</b></dt>
  <dd class="It-tag">stop after N chmod bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chown N</b></dt>
  <dd class="It-tag">start N workers that exercise chown(2) on the same file.
      The greater the value for N then the more contention on the single
    file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chown-ops N</b></dt>
  <dd class="It-tag">stop the chown workers after N bogo chown(2)
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clock N</b></dt>
  <dd class="It-tag">start N workers exercising clocks and POSIX timers. For all
      known clock types this will exercise clock_getres(2), clock_gettime(2) and
      clock_nanosleep(2). For all known timers it will create a 50000ns timer
      and busy poll this until it expires. This stressor will cause frequent
      context switching.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clock-ops N</b></dt>
  <dd class="It-tag">stop clock stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clone N</b></dt>
  <dd class="It-tag">start N workers that create clones (via the clone(2) system
      call). This will rapidly try to create a default of 8192 clones that
      immediately die and wait in a zombie state until they are reaped. Once the
      maximum number of clones is reached (or clone fails because one has
      reached the maximum allowed) the oldest clone thread is reaped and a new
      clone is then created in a first-in first-out manner, and then repeated. A
      random clone flag is selected for each clone to try to exercise different
      clone operarions. The clone stressor is a Linux only option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clone-ops N</b></dt>
  <dd class="It-tag">stop clone stress workers after N bogo clone
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clone-max N</b></dt>
  <dd class="It-tag">try to create as many as N clone threads. This may not be
      reached if the system limit is less than N.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--context N</b></dt>
  <dd class="It-tag">start N workers that run three threads that use
      swapcontext(3) to implement the thread-to-thread context switching. This
      exercises rapid process context saving and restoring and is bandwidth
      limited by register and memory save and restore rates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--context-ops N</b></dt>
  <dd class="It-tag">stop N context workers after N bogo context switches. In
      this stressor, 1 bogo op is equivalent to 1000 swapcontext calls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--copy-file N</b></dt>
  <dd class="It-tag">start N stressors that copy a file using the Linux
      copy_file_range(2) system call. 2MB chunks of data are copyied from random
      locations from one file to random locations to a destination file. By
      default, the files are 256 MB in size. Data is sync'd to the filesystem
      after each copy_file_range(2) call.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--copy-file-ops N</b></dt>
  <dd class="It-tag">stop after N copy_file_range() calls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--copy-file-bytes N</b></dt>
  <dd class="It-tag">copy file size, the default is 256 MB. One can specify the
      size in units of Bytes, KBytes, MBytes and GBytes using the suffix b, k, m
      or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c N, --cpu N</b></dt>
  <dd class="It-tag">start N workers exercising the CPU by sequentially working
      through all the different CPU stress methods. Instead of exercising all
      the CPU stress methods, one can specify a specific CPU stress method with
      the --cpu-method option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cpu-ops N</b></dt>
  <dd class="It-tag">stop cpu stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l P, --cpu-load P</b></dt>
  <dd class="It-tag">load CPU with P percent loading for the CPU stress workers.
      0 is effectively a sleep (no load) and 100 is full loading. The loading
      loop is broken into compute time (load%) and sleep time (100% - load%).
      Accuracy depends on the overall load of the processor and the
      responsiveness of the scheduler, so the actual load may be different from
      the desired load. Note that the number of bogo CPU operations may not be
      linearly scaled with the load as some systems employ CPU frequency scaling
      and so heavier loads produce an increased CPU frequency and greater CPU
      bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cpu-load-slice S</b></dt>
  <dd class="It-tag">note - this option is only useful when --cpu-load is less
      than 100%. The CPU load is broken into multiple busy and idle cycles. Use
      this option to specify the duration of a busy time slice. A negative value
      for S specifies the number of iterations to run before idling the CPU
      (e.g. -30 invokes 30 iterations of a CPU stress loop). A zero value
      selects a random busy time between 0 and 0.5 seconds. A positive value for
      S specifies the number of milliseconds to run before idling the CPU (e.g.
      100 keeps the CPU busy for 0.1 seconds). Specifying small values for S
      lends to small time slices and smoother scheduling. Setting --cpu-load as
      a relatively low value and --cpu-load-slice to be large will cycle the CPU
      between long idle and busy cycles and exercise different CPU frequencies.
      The thermal range of the CPU is also cycled, so this is a good mechanism
      to exercise the scheduler, frequency scaling and passive/active thermal
      cooling mechanisms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cpu-method method</b></dt>
  <dd class="It-tag">specify a cpu stress method. By default, all the stress
      methods are exercised sequentially, however one can specify just one
      method to be used if required. Available cpu stress methods are described
      as follows:
    <table class="tbl">
      <colgroup>
        <col style="width: 16.00ex;"/>
        <col style="width: 287.00ex;"/>
      </colgroup>
      <tr>
        <td>Method</td>
        <td>Description</td>
      </tr>
      <tr>
        <td>all</td>
        <td>iterate over all the below cpu stress methods</td>
      </tr>
      <tr>
        <td>ackermann</td>
        <td>Ackermann function: compute A(3, 10), where: A(m, n) = n + 1 if m =
          0; A(m - 1, 1) if m &gt; 0 and n = 0; A(m - 1, A(m, n - 1)) if m &gt;
          0 and n &gt; 0</td>
      </tr>
      <tr>
        <td>bitops</td>
        <td>various bit operations from bithack, namely: reverse bits, parity
          check, bit count, round to nearest power of 2</td>
      </tr>
      <tr>
        <td>callfunc</td>
        <td>recursively call 8 argument C function to a depth of 1024 calls and
          unwind</td>
      </tr>
      <tr>
        <td>cfloat</td>
        <td>1000 iterations of a mix of floating point complex operations</td>
      </tr>
      <tr>
        <td>cdouble</td>
        <td>1000 iterations of a mix of double floating point complex
          operations</td>
      </tr>
      <tr>
        <td>clongdouble</td>
        <td>1000 iterations of a mix of long double floating point complex
          operations</td>
      </tr>
      <tr>
        <td>correlate</td>
        <td>perform a 16384 &#x00D7; 1024 correlation of random doubles</td>
      </tr>
      <tr>
        <td>crc16</td>
        <td>compute 1024 rounds of CCITT CRC16 on random data</td>
      </tr>
      <tr>
        <td>decimal32</td>
        <td>1000 iterations of a mix of 32 bit decimal floating point operations
          (GCC only)</td>
      </tr>
      <tr>
        <td>decimal64</td>
        <td>1000 iterations of a mix of 64 bit decimal floating point operations
          (GCC only)</td>
      </tr>
      <tr>
        <td>decimal128</td>
        <td>1000 iterations of a mix of 128 bit decimal floating point
          operations (GCC only)</td>
      </tr>
      <tr>
        <td>dither</td>
        <td>Floyd&#x2013;Steinberg dithering of a 1024 &#x00D7; 768 random image
          from 8 bits down to 1 bit of depth.</td>
      </tr>
      <tr>
        <td>djb2a</td>
        <td>128 rounds of hash DJB2a (Dan Bernstein hash using the xor variant)
          on 128 to 1 bytes of random strings</td>
      </tr>
      <tr>
        <td>double</td>
        <td>1000 iterations of a mix of double precision floating point
          operations</td>
      </tr>
      <tr>
        <td>euler</td>
        <td>compute e using n = (1 + (1 &#x00F7; n)) &#x2191; n</td>
      </tr>
      <tr>
        <td>explog</td>
        <td>iterate on n = exp(log(n) &#x00F7; 1.00002)</td>
      </tr>
      <tr>
        <td>fibonacci</td>
        <td>compute Fibonacci sequence of 0, 1, 1, 2, 5, 8...</td>
      </tr>
      <tr>
        <td>fft</td>
        <td>4096 sample Fast Fourier Transform</td>
      </tr>
      <tr>
        <td>float</td>
        <td>1000 iterations of a mix of floating point operations</td>
      </tr>
      <tr>
        <td>fnv1a</td>
        <td>128 rounds of hash FNV-1a (Fowler&#x2013;Noll&#x2013;Vo hash using
          the xor then multiply variant) on 128 to 1 bytes of random
          strings</td>
      </tr>
      <tr>
        <td>gamma</td>
        <td>calculate the Euler-Mascheroni constant &#x03B3; using the limiting
          difference between the harmonic series (1 + 1/2 + 1/3 + 1/4 + 1/5 ...
          + 1/n) and the natural logarithm ln(n), for n = 80000.</td>
      </tr>
      <tr>
        <td>gcd</td>
        <td>compute GCD of integers</td>
      </tr>
      <tr>
        <td>gray</td>
        <td>calculate binary to gray code and gray code back to binary for
          integers from 0 to 65535</td>
      </tr>
      <tr>
        <td>hamming</td>
        <td>compute Hamming H(8,4) codes on 262144 lots of 4 bit data. This
          turns 4 bit data into 8 bit Hamming code containing 4 parity bits. For
          data bits d1..d4, parity bits are computed as: p1 = d2 + d3 + d4 p2 =
          d1 + d3 + d4 p3 = d1 + d2 + d4 p4 = d1 + d2 + d3</td>
      </tr>
      <tr>
        <td>hanoi</td>
        <td>solve a 21 disc Towers of Hanoi stack using the recursive
          solution</td>
      </tr>
      <tr>
        <td>hyperbolic</td>
        <td>compute sinh(&#x03B8;) &#x00D7; cosh(&#x03B8;) + sinh(2&#x03B8;) +
          cosh(3&#x03B8;) for float, double and long double hyperbolic sine and
          cosine functions where &#x03B8; = 0 to 2&#x03C0; in 1500 steps</td>
      </tr>
      <tr>
        <td>idct</td>
        <td>8 &#x00D7; 8 IDCT (Inverse Discrete Cosine Transform)</td>
      </tr>
      <tr>
        <td>int8</td>
        <td>1000 iterations of a mix of 8 bit integer operations</td>
      </tr>
      <tr>
        <td>int16</td>
        <td>1000 iterations of a mix of 16 bit integer operations</td>
      </tr>
      <tr>
        <td>int32</td>
        <td>1000 iterations of a mix of 32 bit integer operations</td>
      </tr>
      <tr>
        <td>int64</td>
        <td>1000 iterations of a mix of 64 bit integer operations</td>
      </tr>
      <tr>
        <td>int128</td>
        <td>1000 iterations of a mix of 128 bit integer operations (GCC
          only)</td>
      </tr>
      <tr>
        <td>int32float</td>
        <td>1000 iterations of a mix of 32 bit integer and floating point
          operations</td>
      </tr>
      <tr>
        <td>int32double</td>
        <td>1000 iterations of a mix of 32 bit integer and double precision
          floating point operations</td>
      </tr>
      <tr>
        <td>int32longdouble</td>
        <td>1000 iterations of a mix of 32 bit integer and long double precision
          floating point operations</td>
      </tr>
      <tr>
        <td>int64float</td>
        <td>1000 iterations of a mix of 64 bit integer and floating point
          operations</td>
      </tr>
      <tr>
        <td>int64double</td>
        <td>1000 iterations of a mix of 64 bit integer and double precision
          floating point operations</td>
      </tr>
      <tr>
        <td>int64longdouble</td>
        <td>1000 iterations of a mix of 64 bit integer and long double precision
          floating point operations</td>
      </tr>
      <tr>
        <td>int128float</td>
        <td>1000 iterations of a mix of 128 bit integer and floating point
          operations (GCC only)</td>
      </tr>
      <tr>
        <td>int128double</td>
        <td>1000 iterations of a mix of 128 bit integer and double precision
          floating point operations (GCC only)</td>
      </tr>
      <tr>
        <td>int128longdouble</td>
        <td>1000 iterations of a mix of 128 bit integer and long double
          precision floating point operations (GCC only)</td>
      </tr>
      <tr>
        <td>int128decimal32</td>
        <td>1000 iterations of a mix of 128 bit integer and 32 bit decimal
          floating point operations (GCC only)</td>
      </tr>
      <tr>
        <td>int128decimal64</td>
        <td>1000 iterations of a mix of 128 bit integer and 64 bit decimal
          floating point operations (GCC only)</td>
      </tr>
      <tr>
        <td>int128decimal128</td>
        <td>1000 iterations of a mix of 128 bit integer and 128 bit decimal
          floating point operations (GCC only)</td>
      </tr>
      <tr>
        <td>jenkin</td>
        <td>Jenkin's integer hash on 128 rounds of 128..1 bytes of random
          data</td>
      </tr>
      <tr>
        <td>jmp</td>
        <td>Simple unoptimised compare &gt;, &lt;, == and jmp branching</td>
      </tr>
      <tr>
        <td>ln2</td>
        <td>compute ln(2) based on series: 1 - 1/2 + 1/3 - 1/4 + 1/5 - 1/6
          ...</td>
      </tr>
      <tr>
        <td>longdouble</td>
        <td>1000 iterations of a mix of long double precision floating point
          operations</td>
      </tr>
      <tr>
        <td>loop</td>
        <td>simple empty loop</td>
      </tr>
      <tr>
        <td>matrixprod</td>
        <td>matrix product of two 128 &#x00D7; 128 matrices of double floats.
          Testing on 64 bit x86 hardware shows that this is provides a good mix
          of memory, cache and floating point operations and is probably the
          best CPU method to use to make a CPU run hot.</td>
      </tr>
      <tr>
        <td>nsqrt</td>
        <td>compute sqrt() of long doubles using Newton-Raphson</td>
      </tr>
      <tr>
        <td>omega</td>
        <td>compute the omega constant defined by &#x03A9;e&#x2191;&#x03A9; = 1
          using efficient iteration of &#x03A9;n+1 = (1 + &#x03A9;n) / (1 +
          e&#x2191;&#x03A9;n)</td>
      </tr>
      <tr>
        <td>parity</td>
        <td>compute parity using various methods from the Standford Bit
          Twiddling Hacks. Methods employed are: the na&#x00EF;ve way, the
          na&#x00EF;ve way with the Brian Kernigan bit counting optimisation,
          the multiply way, the parallel way, and the lookup table ways (2
          variations).</td>
      </tr>
      <tr>
        <td>phi</td>
        <td>compute the Golden Ratio &#x03D5; using series</td>
      </tr>
      <tr>
        <td>pi</td>
        <td>compute &#x03C0; using the Srinivasa Ramanujan fast convergence
          algorithm</td>
      </tr>
      <tr>
        <td>pjw</td>
        <td>128 rounds of hash pjw function on 128 to 1 bytes of random
          strings</td>
      </tr>
      <tr>
        <td>prime</td>
        <td>find all the primes in the range 1..1000000 using a slightly
          optimised brute force na&#x00EF;ve trial division search</td>
      </tr>
      <tr>
        <td>psi</td>
        <td>compute &#x03C8; (the reciprocal Fibonacci constant) using the sum
          of the reciprocals of the Fibonacci numbers</td>
      </tr>
      <tr>
        <td>queens</td>
        <td>compute all the solutions of the classic 8 queens problem for board
          sizes 1..12</td>
      </tr>
      <tr>
        <td>rand</td>
        <td>16384 iterations of rand(), where rand is the MWC pseudo random
          number generator. The MWC random function concatenates two 16 bit
          multiply-with-carry generators: x(n) = 36969 &#x00D7; x(n - 1) +
          carry, y(n) = 18000 &#x00D7; y(n - 1) + carry mod 2 &#x2191; 16 and
          has period of around 2 &#x2191; 60</td>
      </tr>
      <tr>
        <td>rand48</td>
        <td>16384 iterations of drand48(3) and lrand48(3)</td>
      </tr>
      <tr>
        <td>rgb</td>
        <td>convert RGB to YUV and back to RGB (CCIR 601)</td>
      </tr>
      <tr>
        <td>sdbm</td>
        <td>128 rounds of hash sdbm (as used in the SDBM database and GNU awk)
          on 128 to 1 bytes of random strings</td>
      </tr>
      <tr>
        <td>sieve</td>
        <td>find the primes in the range 1..10000000 using the sieve of
          Eratosthenes</td>
      </tr>
      <tr>
        <td>sqrt</td>
        <td>compute sqrt(rand()), where rand is the MWC pseudo random number
          generator</td>
      </tr>
      <tr>
        <td>trig</td>
        <td>compute sin(&#x03B8;) &#x00D7; cos(&#x03B8;) + sin(2&#x03B8;) +
          cos(3&#x03B8;) for float, double and long double sine and cosine
          functions where &#x03B8; = 0 to 2&#x03C0; in 1500 steps</td>
      </tr>
      <tr>
        <td>union</td>
        <td>perform integer arithmetic on a mix of bit fields in a C union. This
          exercises how well the compiler and CPU can perform integer bit field
          loads and stores.</td>
      </tr>
      <tr>
        <td>zeta</td>
        <td>compute the Riemann Zeta function &#x03B6;(s) for s = 2.0..10.0</td>
      </tr>
    </table>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
Note that some of these methods try to exercise the CPU with computations found
  in some real world use cases. However, the code has not been optimised on a
  per-architecture basis, so may be a sub-optimal compared to hand-optimised
  code used in some applications. They do try to represent the typical
  instruction mixes found in these use cases.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cpu-online N</b></dt>
  <dd class="It-tag">start N workers that put randomly selected CPUs offline and
      online. This Linux only stressor requires root privilege to perform this
      action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cpu-online-ops N</b></dt>
  <dd class="It-tag">stop after offline/online operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--crypt N</b></dt>
  <dd class="It-tag">start N workers that encrypt a 16 character random password
      using crypt(3). The password is encrypted using MD5, SHA-256 and SHA-512
      encryption methods.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--crypt-ops N</b></dt>
  <dd class="It-tag">stop after N bogo encryption operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--daemon N</b></dt>
  <dd class="It-tag">start N workers that each create a daemon that dies
      immediately after creating another daemon and so on. This effectively
      works through the process table with short lived processes that do not
      have a parent and are waited for by init. This puts pressure on init to do
      rapid child reaping. The daemon processes perform the usual mix of calls
      to turn into typical UNIX daemons, so this artificially mimics very heavy
      daemon system stress.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--daemon-ops N</b></dt>
  <dd class="It-tag">stop daemon workers after N daemons have been created.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D N, --dentry N</b></dt>
  <dd class="It-tag">start N workers that create and remove directory entries.
      This should create file system meta data activity. The directory entry
      names are suffixed by a gray-code encoded number to try to mix up the
      hashing of the namespace.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dentry-ops N</b></dt>
  <dd class="It-tag">stop denty thrash workers after N bogo dentry
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dentry-order [ forward | reverse | stride | random
    ]</b></dt>
  <dd class="It-tag">specify unlink order of dentries, can be one of forward,
      reverse, stride or random. By default, dentries are unlinked in random
      order. The forward order will unlink them from first to last, reverse
      order will unlink them from last to first, stride order will unlink them
      by stepping around order in a quasi-random pattern and random order will
      randomly select one of forward, reverse or stride orders.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dentries N</b></dt>
  <dd class="It-tag">create N dentries per dentry thrashing loop, default is
      2048.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dir N</b></dt>
  <dd class="It-tag">start N workers that create and remove directories using
      mkdir and rmdir.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dir-ops N</b></dt>
  <dd class="It-tag">stop directory thrash workers after N bogo directory
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dnotify N</b></dt>
  <dd class="It-tag">start N workers performing file system activities such as
      making/deleting files/directories, renaming files, etc. to stress exercise
      the various dnotify events (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dnotify-ops N</b></dt>
  <dd class="It-tag">stop inotify stress workers after N dnotify bogo
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dup N</b></dt>
  <dd class="It-tag">start N workers that perform dup(2) and then close(2)
      operations on /dev/zero. The maximum opens at one time is system defined,
      so the test will run up to this maximum, or 65536 open file descriptors,
      which ever comes first.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dup-ops N</b></dt>
  <dd class="It-tag">stop the dup stress workers after N bogo open
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--epoll N</b></dt>
  <dd class="It-tag">start N workers that perform various related socket stress
      activity using epoll_wait(2) to monitor and handle new connections. This
      involves client/server processes performing rapid connect, send/receives
      and disconnects on the local host. Using epoll allows a large number of
      connections to be efficiently handled, however, this can lead to the
      connection table filling up and blocking further socket connections, hence
      impacting on the epoll bogo op stats. For ipv4 and ipv6 domains, multiple
      servers are spawned on multiple ports. The epoll stressor is for Linux
      only.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--epoll-domain D</b></dt>
  <dd class="It-tag">specify the domain to use, the default is unix (aka local).
      Currently ipv4, ipv6 and unix are supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--epoll-port P</b></dt>
  <dd class="It-tag">start at socket port P. For N epoll worker processes, ports
      P to (P * 4) - 1 are used for ipv4, ipv6 domains and ports P to P - 1 are
      used for the unix domain.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--epoll-ops N</b></dt>
  <dd class="It-tag">stop epoll workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--eventfd N</b></dt>
  <dd class="It-tag">start N parent and child worker processes that read and
      write 8 byte event messages between them via the eventfd mechanism (Linux
      only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--eventfd-ops N</b></dt>
  <dd class="It-tag">stop eventfd workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--exec N</b></dt>
  <dd class="It-tag">start N workers continually forking children that exec
      stress-ng and then exit almost immediately.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--exec-ops N</b></dt>
  <dd class="It-tag">stop exec stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--exec-max P</b></dt>
  <dd class="It-tag">create P child processes that exec stress-ng and then wait
      for them to exit per iteration. The default is just 1; higher values will
      create many temporary zombie processes that are waiting to be reaped. One
      can potentially fill up the process table using high values for --exec-max
      and --exec.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-F N, --fallocate N</b></dt>
  <dd class="It-tag">start N workers continually fallocating (preallocating file
      space) and ftuncating (file truncating) temporary files. If the file is
      larger than the free space, fallocate will produce an ENOSPC error which
      is ignored by this stressor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fallocate-bytes N</b></dt>
  <dd class="It-tag">allocated file size, the default is 1 GB. One can specify
      the size in units of Bytes, KBytes, MBytes and GBytes using the suffix b,
      k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fallocate-ops N</b></dt>
  <dd class="It-tag">stop fallocate stress workers after N bogo fallocate
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fault N</b></dt>
  <dd class="It-tag">start N workers that generates minor and major page
    faults.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fault-ops N</b></dt>
  <dd class="It-tag">stop the page fault workers after N bogo page fault
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fcntl N</b></dt>
  <dd class="It-tag">start N workers that perform fcntl(2) calls with various
      commands. The exercised commands (if available) are: F_DUPFD,
      F_DUPFD_CLOEXEC, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETOWN, F_SETOWN,
      F_GETOWN_EX, F_SETOWN_EX, F_GETSIG, F_SETSIG, F_GETLK, F_SETLK, F_SETLKW,
      F_OFD_GETLK, F_OFD_SETLK and F_OFD_SETLKW.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fcntl-ops N</b></dt>
  <dd class="It-tag">stop the fcntl workers after N bogo fcntl operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fiemap N</b></dt>
  <dd class="It-tag">start N workers that each create a file with many randomly
      changing extents and has 4 child processes per worker that gather the
      extent information using the FS_IOC_FIEMAP ioctl(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fiemap-ops N</b></dt>
  <dd class="It-tag">stop after N fiemap bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fiemap-bytes N</b></dt>
  <dd class="It-tag">specify the size of the fiemap'd file in bytes. One can
      specify the size in units of Bytes, KBytes, MBytes and GBytes using the
      suffix b, k, m or g. Larger files will contain more extents, causing more
      stress when gathering extent information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fifo N</b></dt>
  <dd class="It-tag">start N workers that exercise a named pipe by transmitting
      64 bit integers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fifo-ops N</b></dt>
  <dd class="It-tag">stop fifo workers after N bogo pipe write operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fifo-readers N</b></dt>
  <dd class="It-tag">for each worker, create N fifo reader workers that read the
      named pipe using simple blocking reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--filename N</b></dt>
  <dd class="It-tag">start N workers that exercise file creation using various
      length filenames containing a range of allower filename characters. This
      will try to see if it can exceed the file system allowed filename length
      was well as test various filename lengths between 1 and the maximum
      allowed by the file system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--filename-ops N</b></dt>
  <dd class="It-tag">stop filename workers after N bogo filename tests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--filename-opts opt</b></dt>
  <dd class="It-tag">use characters in the filename based on option 'opt'. Valid
      options are:
    <table class="tbl">
      <colgroup>
        <col style="width: 6.00ex;"/>
        <col style="width: 125.00ex;"/>
      </colgroup>
      <tr>
        <td>Option</td>
        <td>Description</td>
      </tr>
      <tr>
        <td>probe</td>
        <td>default option, probe the file system for valid allowed characters
          in a file name and use these</td>
      </tr>
      <tr>
        <td>posix</td>
        <td>use characters as specifed by The Open Group Base Specifications
          Issue 7, POSIX.1-2008, 3.278 Portable Filename Character Set</td>
      </tr>
      <tr>
        <td>ext</td>
        <td>use characters allowed by the ext2, ext3, ext4 file systems, namely
          any 8 bit character apart from NUL and /</td>
      </tr>
    </table>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--flock N</b></dt>
  <dd class="It-tag">start N workers locking on a single file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--flock-ops N</b></dt>
  <dd class="It-tag">stop flock stress workers after N bogo flock
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f N, --fork N</b></dt>
  <dd class="It-tag">start N workers continually forking children that
      immediately exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fork-ops N</b></dt>
  <dd class="It-tag">stop fork stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fork-max P</b></dt>
  <dd class="It-tag">create P child processes and then wait for them to exit per
      iteration. The default is just 1; higher values will create many temporary
      zombie processes that are waiting to be reaped. One can potentially fill
      up the the process table using high values for --fork-max and --fork.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fp-error N</b></dt>
  <dd class="It-tag">start N workers that generate floating point exceptions.
      Computations are performed to force and check for the FE_DIVBYZERO,
      FE_INEXACT, FE_INVALID, FE_OVERFLOW and FE_UNDERFLOW exceptions. EDOM and
      ERANGE errors are also checked.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fp-error-ops N</b></dt>
  <dd class="It-tag">stop after N bogo floating point exceptions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fstat N</b></dt>
  <dd class="It-tag">start N workers fstat'ing files in a directory (default is
      /dev).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fstat-ops N</b></dt>
  <dd class="It-tag">stop fstat stress workers after N bogo fstat
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fstat-dir directory</b></dt>
  <dd class="It-tag">specify the directory to fstat to override the default of
      /dev. All the files in the directory will be fstat'd repeatedly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--full N</b></dt>
  <dd class="It-tag">start N workers that exercise /dev/full. This attempts to
      write to the device (which should always get error ENOSPC), to read from
      the device (which should always return a buffer of zeros) and to seek
      randomly on the device (which should always succeed). (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--full-ops N</b></dt>
  <dd class="It-tag">stop the stress full workers after N bogo I/O
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--futex N</b></dt>
  <dd class="It-tag">start N workers that rapidly exercise the futex system
      call. Each worker has two processes, a futex waiter and a futex waker. The
      waiter waits with a very small timeout to stress the timeout and rapid
      polled futex waiting. This is a Linux specific stress option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--futex-ops N</b></dt>
  <dd class="It-tag">stop futex workers after N bogo successful futex wait
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--get N</b></dt>
  <dd class="It-tag">start N workers that call all the get*(2) system
    calls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--get-ops N</b></dt>
  <dd class="It-tag">stop get workers after N bogo get operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--getdent N</b></dt>
  <dd class="It-tag">start N workers that recursively read directories /proc,
      /dev/, /tmp, /sys and /run using getdents and getdents64 (Linux
    only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--getdent-ops N</b></dt>
  <dd class="It-tag">stop getdent workers after N bogo getdent bogo
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--getrandom N</b></dt>
  <dd class="It-tag">start N workers that get 8192 random bytes from the
      /dev/urandom pool using the getrandom(2) system call (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--getrandom-ops N</b></dt>
  <dd class="It-tag">stop getrandom workers after N bogo get operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--handle N</b></dt>
  <dd class="It-tag">start N workers that exercise the name_to_handle_at(2) and
      open_by_handle_at(2) system calls. (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--handle-ops N</b></dt>
  <dd class="It-tag">stop after N handle bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d N, --hdd N</b></dt>
  <dd class="It-tag">start N workers continually writing, reading and removing
      temporary files. The default mode is to stress test sequential writes and
      reads. With the --aggressive option enabled without any --hdd-opts options
      the hdd stressor will work through all the --hdd-opt options one by one to
      cover a range of I/O options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hdd-bytes N</b></dt>
  <dd class="It-tag">write N bytes for each hdd process, the default is 1 GB.
      One can specify the size in units of Bytes, KBytes, MBytes and GBytes
      using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hdd-opts list</b></dt>
  <dd class="It-tag">specify various stress test options as a comma separated
      list. Options are as follows:
    <table class="tbl">
      <colgroup>
        <col style="width: 14.00ex;"/>
        <col style="width: 232.00ex;"/>
      </colgroup>
      <tr>
        <td>Option</td>
        <td>Description</td>
      </tr>
      <tr>
        <td>direct</td>
        <td>try to minimize cache effects of the I/O. File I/O writes are
          performed directly from user space buffers and synchronous transfer is
          also attempted. To guarantee synchronous I/O, also use the sync
          option.</td>
      </tr>
      <tr>
        <td>dsync</td>
        <td>ensure output has been transferred to underlying hardware and file
          metadata has been updated (using the O_DSYNC open flag). This is
          equivalent to each write(2) being followed by a call to fdatasync(2).
          See also the fdatasync option.</td>
      </tr>
      <tr>
        <td>fadv-dontneed</td>
        <td>advise kernel to expect the data will not be accessed in the near
          future.</td>
      </tr>
      <tr>
        <td>fadv-noreuse</td>
        <td>advise kernel to expect the data to be accessed only once.</td>
      </tr>
      <tr>
        <td>fadv-normal</td>
        <td>advise kernel there are no explicit access pattern for the data.
          This is the default advice assumption.</td>
      </tr>
      <tr>
        <td>fadv-rnd</td>
        <td>advise kernel to expect random access patterns for the data.</td>
      </tr>
      <tr>
        <td>fadv-seq</td>
        <td>advise kernel to expect sequential access patterns for the
          data.</td>
      </tr>
      <tr>
        <td>fadv-willneed</td>
        <td>advise kernel to expect the data to be accessed in the near
          future.</td>
      </tr>
      <tr>
        <td>fsync</td>
        <td>flush all modified in-core data after each write to the output
          device using an explicit fsync(2) call.</td>
      </tr>
      <tr>
        <td>fdatasync</td>
        <td>similar to fsync, but do not flush the modified metadata unless
          metadata is required for later data reads to be handled correctly.
          This uses an explicit fdatasync(2) call.</td>
      </tr>
      <tr>
        <td>iovec</td>
        <td>use readv/writev multiple buffer I/Os rather than read/write.
          Instead of 1 read/write operation, the buffer is broken into an iovec
          of 16 buffers.</td>
      </tr>
      <tr>
        <td>noatime</td>
        <td>do not update the file last access timestamp, this can reduce
          metadata writes.</td>
      </tr>
      <tr>
        <td>sync</td>
        <td>ensure output has been transferred to underlying hardware (using the
          O_SYNC open flag). This is equivalent to a each write(2) being
          followed by a call to fsync(2). See also the fsync option.</td>
      </tr>
      <tr>
        <td>rd-rnd</td>
        <td>read data randomly. By default, written data is not read back,
          however, this option will force it to be read back randomly.</td>
      </tr>
      <tr>
        <td>rd-seq</td>
        <td>read data sequentially. By default, written data is not read back,
          however, this option will force it to be read back sequentially.</td>
      </tr>
      <tr>
        <td>syncfs</td>
        <td>write all buffered modifications of file metadata and data on the
          filesystem that contains the hdd worker files.</td>
      </tr>
      <tr>
        <td>utimes</td>
        <td>force update of file timestamp which may increase metadata
          writes.</td>
      </tr>
      <tr>
        <td>wr-rnd</td>
        <td>write data randomly. The wr-seq option cannot be used at the same
          time.</td>
      </tr>
      <tr>
        <td>wr-seq</td>
        <td>write data sequentially. This is the default if no write modes are
          specified.</td>
      </tr>
    </table>
  </dd>
</dl>
<div class="Pp"></div>
Note that some of these options are mutually exclusive, for example, there can
  be only one method of writing or reading. Also, fadvise flags may be mutually
  exclusive, for example fadv-willneed cannot be used with fadv-dontneed.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hdd-ops N</b></dt>
  <dd class="It-tag">stop hdd stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hdd-write-size N</b></dt>
  <dd class="It-tag">specify size of each write in bytes. Size can be from 1
      byte to 4MB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--heapsort N</b></dt>
  <dd class="It-tag">start N workers that sort 32 bit integers using the BSD
      heapsort.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--heapsort-ops N</b></dt>
  <dd class="It-tag">stop heapsort stress workers after N bogo heapsorts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--heapsort-size N</b></dt>
  <dd class="It-tag">specify number of 32 bit integers to sort, default is
      262144 (256 &#x00D7; 1024).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hsearch N</b></dt>
  <dd class="It-tag">start N workers that search a 80% full hash table using
      hsearch(3). By default, there are 8192 elements inserted into the hash
      table. This is a useful method to exercise access of memory and processor
      cache.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hsearch-ops N</b></dt>
  <dd class="It-tag">stop the hsearch workers after N bogo hsearch operations
      are completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hsearch-size N</b></dt>
  <dd class="It-tag">specify the number of hash entries to be inserted into the
      hash table. Size can be from 1K to 4M.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--icache N</b></dt>
  <dd class="It-tag">start N workers that stress the instruction cache by
      forcing instruction cache reloads. This is achieved by modifying an
      instruction cache line, causing the processor to reload it when we call a
      function in inside it. Currently only verified and enabled for Intel x86
      CPUs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--icache-ops N</b></dt>
  <dd class="It-tag">stop the icache workers after N bogo icache operations are
      completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--icmp-flood N</b></dt>
  <dd class="It-tag">start N workers that flood localhost with randonly sized
      ICMP ping packets. This option can only be run as root.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--icmp-flood-ops N</b></dt>
  <dd class="It-tag">stop icmp flood workers after N ICMP ping packets have been
      sent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--inotify N</b></dt>
  <dd class="It-tag">start N workers performing file system activities such as
      making/deleting files/directories, moving files, etc. to stress exercise
      the various inotify events (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--inotify-ops N</b></dt>
  <dd class="It-tag">stop inotify stress workers after N inotify bogo
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i N, --io N</b></dt>
  <dd class="It-tag">start N workers continuously calling sync(2) to commit
      buffer cache to disk. This can be used in conjunction with the --hdd
      options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--io-ops N</b></dt>
  <dd class="It-tag">stop io stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ioprio N</b></dt>
  <dd class="It-tag">start N workers that exercise the ioprio_get(2) and
      ioprio_set(2) system calls (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ioprio-ops N</b></dt>
  <dd class="It-tag">stop after N io priority bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--itimer N</b></dt>
  <dd class="It-tag">start N workers that exercise the system interval timers.
      This sets up an ITIMER_PROF itimer that generates a SIGPROF signal. The
      default frequency for the itimer is 1 MHz, however, the Linux kernel will
      set this to be no more that the jiffy setting, hence high frequency
      SIGPROF signals are not normally possible. A busy loop spins on
      getitimer(2) calls to consume CPU and hence decrement the itimer based on
      amount of time spent in CPU and system time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--itimer-ops N</b></dt>
  <dd class="It-tag">stop itimer stress workers after N bogo itimer SIGPROF
      signals.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--itimer-freq F</b></dt>
  <dd class="It-tag">run itimer at F Hz; range from 1 to 1000000 Hz. Normally
      the highest frequency is limited by the number of jiffy ticks per second,
      so running above 1000 Hz is difficult to attain in practice.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--kcmp N</b></dt>
  <dd class="It-tag">start N workers that use kcmp(2) to compare parent and
      child processes to determine if they share kernel resources (Linux
    only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--kcmp-ops N</b></dt>
  <dd class="It-tag">stop kcmp workers after N bogo kcmp operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--key N</b></dt>
  <dd class="It-tag">start N workers that create and manipulate keys using
      add_key(2) and ketctl(2). As many keys are created as the per user limit
      allows and then the following keyctl commands are exercised on each key:
      KEYCTL_SET_TIMEOUT, KEYCTL_DESCRIBE, KEYCTL_UPDATE, KEYCTL_READ,
      KEYCTL_CLEAR and KEYCTL_INVALIDATE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--key-ops N</b></dt>
  <dd class="It-tag">stop key workers after N bogo key operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--kill N</b></dt>
  <dd class="It-tag">start N workers sending SIGUSR1 kill signals to a SIG_IGN
      signal handler. Most of the process time will end up in kernel space.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--kill-ops N</b></dt>
  <dd class="It-tag">stop kill workers after N bogo kill operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--klog N</b></dt>
  <dd class="It-tag">start N workers exercising the kernel syslog(2) system
      call. This will attempt to read the kernel log with various sized read
      buffers. Linux only.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--klog-ops N</b></dt>
  <dd class="It-tag">stop klog workers after N syslog operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lease N</b></dt>
  <dd class="It-tag">start N workers locking, unlocking and breaking leases via
      the fcntl(2) F_SETLEASE operation. The parent processes continually lock
      and unlock a lease on a file while a user selectable number of child
      processes open the file with a non-blocking open to generate SIGIO lease
      breaking notifications to the parent. This stressor is only available if
      F_SETLEASE, F_WRLCK and F_UNLCK support is provided by fcntl(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lease-ops N</b></dt>
  <dd class="It-tag">stop lease workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lease-breakers N</b></dt>
  <dd class="It-tag">start N lease breaker child processes per lease worker.
      Normally one child is plenty to force many SIGIO lease breaking
      notification signals to the parent, however, this option allows one to
      specify more child processes if required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--link N</b></dt>
  <dd class="It-tag">start N workers creating and removing hardlinks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--link-ops N</b></dt>
  <dd class="It-tag">stop link stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockbus N</b></dt>
  <dd class="It-tag">start N workers that rapidly lock and increment 64 bytes of
      randomly chosen memory from a 16MB mmap'd region (Intel x86 CPUs only).
      This will cause cacheline misses and stalling of CPUs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockbus-ops N</b></dt>
  <dd class="It-tag">stop lockbus workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--locka N</b></dt>
  <dd class="It-tag">start N workers that randomly lock and unlock regions of a
      file using the POSIX advisory locking mechanism (see fcntl(2), F_SETLK,
      F_GETLK). Each worker creates a 1024 KB file and attempts to hold a
      maximum of 1024 concurrent locks with a child process that also tries to
      hold 1024 concurrent locks. Old locks are unlocked in a first-in,
      first-out basis.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--locka-ops N</b></dt>
  <dd class="It-tag">stop locka workers after N bogo locka operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockf N</b></dt>
  <dd class="It-tag">start N workers that randomly lock and unlock regions of a
      file using the POSIX lockf(3) locking mechanism. Each worker creates a 64
      KB file and attempts to hold a maximum of 1024 concurrent locks with a
      child process that also tries to hold 1024 concurrent locks. Old locks are
      unlocked in a first-in, first-out basis.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockf-ops N</b></dt>
  <dd class="It-tag">stop lockf workers after N bogo lockf operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockf-nonblock</b></dt>
  <dd class="It-tag">instead of using blocking F_LOCK lockf(3) commands, use
      non-blocking F_TLOCK commands and re-try if the lock failed. This creates
      extra system call overhead and CPU utilisation as the number of lockf
      workers increases and should increase locking contention.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockofd N</b></dt>
  <dd class="It-tag">start N workers that randomly lock and unlock regions of a
      file using the Linux open file description locks (see fcntl(2),
      F_OFD_SETLK, F_OFD_GETLK). Each worker creates a 1024 KB file and attempts
      to hold a maximum of 1024 concurrent locks with a child process that also
      tries to hold 1024 concurrent locks. Old locks are unlocked in a first-in,
      first-out basis.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockofd-ops N</b></dt>
  <dd class="It-tag">stop lockofd workers after N bogo lockofd operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--longjmp N</b></dt>
  <dd class="It-tag">start N workers that exercise setjmp(3)/longjmp(3) by rapid
      looping on longjmp calls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--longjmp-ops N</b></dt>
  <dd class="It-tag">stop longjmp stress workers after N bogo longjmp operations
      (1 bogo op is 1000 longjmp calls).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lsearch N</b></dt>
  <dd class="It-tag">start N workers that linear search a unsorted array of 32
      bit integers using lsearch(3). By default, there are 8192 elements in the
      array. This is a useful method to exercise sequential access of memory and
      processor cache.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lsearch-ops N</b></dt>
  <dd class="It-tag">stop the lsearch workers after N bogo lsearch operations
      are completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lsearch-size N</b></dt>
  <dd class="It-tag">specify the size (number of 32 bit integers) in the array
      to lsearch. Size can be from 1K to 4M.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--madvise N</b></dt>
  <dd class="It-tag">start N workers that apply random madvise(2) advise
      settings on pages of a 4MB file backed shared memory mapping.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--madvice-ops N</b></dt>
  <dd class="It-tag">stop madvise stressors after N bogo madvise
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--malloc N</b></dt>
  <dd class="It-tag">start N workers continuously calling malloc(3), calloc(3),
      realloc(3) and free(3). By default, up to 65536 allocations can be active
      at any point, but this can be altered with the --malloc-max option.
      Allocation, reallocation and freeing are chosen at random; 50% of the time
      memory is allocation (via malloc, calloc or realloc) and 50% of the time
      allocations are free'd. Allocation sizes are also random, with the maximum
      allocation size controlled by the --malloc-bytes option, the default size
      being 64K. The worker is re-started if it is killed by the out of mememory
      (OOM) killer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--malloc-bytes N</b></dt>
  <dd class="It-tag">maximum per allocation/reallocation size. Allocations are
      randomly selected from 1 to N bytes. One can specify the size in units of
      Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g. Large
      allocation sizes cause the memory allocator to use mmap(2) rather than
      expanding the heap using brk(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--malloc-max N</b></dt>
  <dd class="It-tag">maximum number of active allocations allowed. Allocations
      are chosen at ramdom and placed in an allocation slot. Because about
      50%/50% split between allocation and freeing, typically half of the
      allocation slots are in use at any one time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--malloc-ops N</b></dt>
  <dd class="It-tag">stop after N malloc bogo operations. One bogo operations
      relates to a successful malloc(3), calloc(3) or realloc(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--malloc-thresh N</b></dt>
  <dd class="It-tag">specify the threshold where malloc uses mmap(2) instead of
      sbrk(2) to allocate more memory. This is only available on systems that
      provide the GNU C mallopt(3) tuning function.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--matrix N</b></dt>
  <dd class="It-tag">start N workers that perform various matrix operations on
      floating point values. By default, this will exercise all the matrix
      stress methods one by one. One can specify a specific matrix stress method
      with the --matrix-method option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--matrix-ops N</b></dt>
  <dd class="It-tag">stop matrix stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--matrix-method method</b></dt>
  <dd class="It-tag">specify a matrix stress method. Available matrix stress
      methods are described as follows:
    <table class="tbl">
      <colgroup>
        <col style="width: 9.00ex;"/>
        <col style="width: 57.00ex;"/>
      </colgroup>
      <tr>
        <td>Method</td>
        <td>Description</td>
      </tr>
      <tr>
        <td>all</td>
        <td>iterate over all the below matrix stress methods</td>
      </tr>
      <tr>
        <td>add</td>
        <td>add two N &#x00D7; N matrices</td>
      </tr>
      <tr>
        <td>copy</td>
        <td>copy one N &#x00D7; N matrix to another</td>
      </tr>
      <tr>
        <td>div</td>
        <td>divide an N &#x00D7; N matrix by a scalar</td>
      </tr>
      <tr>
        <td>hadamard</td>
        <td>Hadamard product of two N &#x00D7; N matrices</td>
      </tr>
      <tr>
        <td>frobenius</td>
        <td>Frobenius product of two N &#x00D7; N matrices</td>
      </tr>
      <tr>
        <td>mean</td>
        <td>arithmetic mean of two N &#x00D7; N matrices</td>
      </tr>
      <tr>
        <td>mult</td>
        <td>multiply an N &#x00D7; N matrix by a scalar</td>
      </tr>
      <tr>
        <td>prod</td>
        <td>product of two N &#x00D7; N matrices</td>
      </tr>
      <tr>
        <td>sub</td>
        <td>subtract one N &#x00D7; N matrix from another N &#x00D7; N
          matrix</td>
      </tr>
      <tr>
        <td>trans</td>
        <td>transpose an N &#x00D7; N matrix</td>
      </tr>
    </table>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--matrix-size N</b></dt>
  <dd class="It-tag">specify the N &#x00D7; N size of the matrices. Smaller
      values result in a floating point compute throughput bound stressor, where
      as large values result in a cache and/or memory bandwidth bound
    stressor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--membarrier N</b></dt>
  <dd class="It-tag">start N workers that exercise the membarrier system call
      (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--membarrier-ops N</b></dt>
  <dd class="It-tag">stop membarrier stress workers after N bogo membarrier
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--memcpy N</b></dt>
  <dd class="It-tag">start N workers that copy 2MB of data from a shared region
      to a buffer using memcpy(3) and then move the data in the buffer with
      memmove(3) with 3 different alignments. This will exercise processor cache
      and system memory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--memcpy-ops N</b></dt>
  <dd class="It-tag">stop memcpy stress workers after N bogo memcpy
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--memfd N</b></dt>
  <dd class="It-tag">start N workers that create 256 allocations of 1024 pages
      using memfd_create(2) and ftruncate(2) for allocation and mmap(2) to map
      the allocation into the process address space. (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--memfd-bytes N</b></dt>
  <dd class="It-tag">allocate N bytes per memfd stress worker, the default is
      256MB. One can specify the size in units of Bytes, KBytes, MBytes and
      GBytes using the suffix b, k, m</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--memfd-ops N</b></dt>
  <dd class="It-tag">stop after N memfd-create(2) bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mergesort N</b></dt>
  <dd class="It-tag">start N workers that sort 32 bit integers using the BSD
      mergesort.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mergesort-ops N</b></dt>
  <dd class="It-tag">stop mergesort stress workers after N bogo mergesorts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mergesort-size N</b></dt>
  <dd class="It-tag">specify number of 32 bit integers to sort, default is
      262144 (256 &#x00D7; 1024).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mincore N</b></dt>
  <dd class="It-tag">start N workers that walk through all of memory 1 page at a
      time checking of the page mapped and also is resident in memory using
      mincore(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mincore-ops N</b></dt>
  <dd class="It-tag">stop after N mincore bogo operations. One mincore bogo op
      is equivalent to a 1000 mincore(2) calls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mincore-random</b></dt>
  <dd class="It-tag">instead of walking through pages sequentially, select pages
      at random. The chosen address is iterated over by shifting it right one
      place and checked by mincore until the address is less or equal to the
      page size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mknod N</b></dt>
  <dd class="It-tag">start N workers that create and remove fifos, empty files
      and named sockets using mknod and unlink.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mknod-ops N</b></dt>
  <dd class="It-tag">stop directory thrash workers after N bogo mknod
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mlock N</b></dt>
  <dd class="It-tag">start N workers that lock and unlock memory mapped pages
      using mlock(2), munlock(2), mlockall(2) and munlockall(2). This is
      achieved by the mapping of three contiguous pages and then locking the
      second page, hence ensuring non-contiguous pages are locked . This is then
      repeated until the maximum allowed mlocks or a maximum of 262144 mappings
      are made. Next, all future mappings are mlocked and the worker attempts to
      map 262144 pages, then all pages are munlocked and the pages are
    unmapped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mlock-ops N</b></dt>
  <dd class="It-tag">stop after N mlock bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmap N</b></dt>
  <dd class="It-tag">start N workers continuously calling mmap(2)/munmap(2). The
      initial mapping is a large chunk (size specified by --mmap-bytes) followed
      by pseudo-random 4K unmappings, then pseudo-random 4K mappings, and then
      linear 4K unmappings. Note that this can cause systems to trip the kernel
      OOM killer on Linux systems if not enough physical memory and swap is not
      available. The MAP_POPULATE option is used to populate pages into memory
      on systems that support this. By default, anonymous mappings are used,
      however, the --mmap-file and --mmap-async options allow one to perform
      file based mappings if desired.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmap-ops N</b></dt>
  <dd class="It-tag">stop mmap stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmap-async</b></dt>
  <dd class="It-tag">enable file based memory mapping and use asynchronous
      msync'ing on each page, see --mmap-file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmap-bytes N</b></dt>
  <dd class="It-tag">allocate N bytes per mmap stress worker, the default is
      256MB. One can specify the size in units of Bytes, KBytes, MBytes and
      GBytes using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmap-file</b></dt>
  <dd class="It-tag">enable file based memory mapping and by default use
      synchronous msync'ing on each page.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmap-mprotect</b></dt>
  <dd class="It-tag">change protection settings on each page of memory. Each
      time a page or a group of pages are mapped or remapped then this option
      will make the pages read-only, write-only, exec-only, and read-write.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmapfork N</b></dt>
  <dd class="It-tag">start N workers that each fork off 32 child processes, each
      of which tries to allocate some of the free memory left in the system (and
      trying to avoid any swapping). The child processes then hint that the
      allocation will be needed with madvise(2) and then memset it to zero and
      hint that it is no longer needed with madvise before exiting. This
      produces significant amounts of VM activity, a lot of cache misses and
      with minimal swapping.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmapfork-ops N</b></dt>
  <dd class="It-tag">stop after N mmapfork bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmapmany N</b></dt>
  <dd class="It-tag">start N workers that attempt to create the maximum allowed
      per-process memory mappings. This is achieved by mapping 3 contiguous
      pages and then unmapping the middle page hence splitting the mapping into
      two. This is then repeated until the maximum allowed mappings or a maximum
      of 262144 mappings are made.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mmapmany-ops N</b></dt>
  <dd class="It-tag">stop after N mmapmany bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mremap N</b></dt>
  <dd class="It-tag">start N workers continuously calling mmap(2), mremap(2) and
      munmap(2). The initial anonymous mapping is a large chunk (size specified
      by --mremap-bytes) and then iteratively halved in size by remapping all
      the way down to a page size and then back up to the original size. This
      worker is only available for Linux.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mremap-ops N</b></dt>
  <dd class="It-tag">stop mremap stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mremap-bytes N</b></dt>
  <dd class="It-tag">initially allocate N bytes per remap stress worker, the
      default is 256MB. One can specify the size in units of Bytes, KBytes,
      MBytes and GBytes using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--msg N</b></dt>
  <dd class="It-tag">start N sender and receiver processes that continually send
      and receive messages using System V message IPC.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--msg-ops N</b></dt>
  <dd class="It-tag">stop after N bogo message send operations completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--msync N</b></dt>
  <dd class="It-tag">start N stressors that msync data from a file backed memory
      mapping from memory back to the file and msync modified data from the file
      back to the mapped memory. This exercises the msync(2) MS_SYNC and
      MS_INVALIDATE sync operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--msync-ops N</b></dt>
  <dd class="It-tag">stop after N msync bogo operations completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--msync-bytes N</b></dt>
  <dd class="It-tag">allocate N bytes for the memory mapped file, the default is
      256MB. One can specify the size in units of Bytes, KBytes, MBytes and
      GBytes using the</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mq N</b></dt>
  <dd class="It-tag">start N sender and receiver processes that continually send
      and receive messages using POSIX message queues. (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mq-ops N</b></dt>
  <dd class="It-tag">stop after N bogo POSIX message send operations
    completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mq-size N</b></dt>
  <dd class="It-tag">specify size of POSIX message queue. The default size is 10
      messages and most Linux systems this is the maximum allowed size for
      normal users. If the given size is greater than the allowed message queue
      size then a warning is issued and the maximum allowed size is used
      instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nice N</b></dt>
  <dd class="It-tag">start N cpu consuming workers that exercise the available
      nice levels. Each iteration forks off a child process that runs through
      the all the nice levels running a busy loop for 0.1 seconds per level and
      then exits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nice-ops N</b></dt>
  <dd class="It-tag">stop after N nice bogo nice loops</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--null N</b></dt>
  <dd class="It-tag">start N workers writing to /dev/null.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--null-ops N</b></dt>
  <dd class="It-tag">stop null stress workers after N /dev/null bogo write
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--numa N</b></dt>
  <dd class="It-tag">start N workers that migrate stressors and a 4MB memory
      mapped buffer around all the available NUMA nodes. This uses
      migrate_pages(2) to move the stressors and mbind(2) and move_pages(2) to
      move the pages of the mapped buffer. After each move, the buffer is
      written to force activity over the bus which results cache misses. This
      test will only run on hardware with NUMA enabled and more than 1 NUMA
      node.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--numa-ops N</b></dt>
  <dd class="It-tag">stop NUMA stress workers after N bogo NUMA operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--oom-pipe N</b></dt>
  <dd class="It-tag">start N workers that create as many pipes as allowed and
      exercise expanding and shrinking the pipes from the largest pipe size down
      to a page size. Data is written into the pipes and read out again to fill
      the pipe buffers. With the --aggressive mode enabled the data is not read
      out when the pipes are shrunk, causing the kernel to OOM processes
      aggressively. Running many instances of this stressor will force kernel to
      OOM processes due to the many large pipe buffer allocations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--oom-pipe-ops N</b></dt>
  <dd class="It-tag">stop after N bogo pipe expand/shrink operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--opcode N</b></dt>
  <dd class="It-tag">start N workers that fork off children that execute
      randomly generated executable code. This will generate issues such as
      illegal instructions, bus errors, segmentation faults, traps, floating
      point errors that are handled gracefully by the stressor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--opcode-ops N</b></dt>
  <dd class="It-tag">stop after N attempts to executate illegal code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o N, --open N</b></dt>
  <dd class="It-tag">start N workers that perform open(2) and then close(2)
      operations on /dev/zero. The maximum opens at one time is system defined,
      so the test will run up to this maximum, or 65536 open file descriptors,
      which ever comes first.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--open-ops N</b></dt>
  <dd class="It-tag">stop the open stress workers after N bogo open
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--personality N</b></dt>
  <dd class="It-tag">start N workers that attempt to set personality and get all
      the available personality types (process execution domain types) via the
      personality(2) system call. (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--personality-ops N</b></dt>
  <dd class="It-tag">stop personality stress workers after N bogo personality
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p N, --pipe N</b></dt>
  <dd class="It-tag">start N workers that perform large pipe writes and reads to
      exercise pipe I/O. This exercises memory write and reads as well as
      context switching. Each worker has two processes, a reader and a
    writer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pipe-ops N</b></dt>
  <dd class="It-tag">stop pipe stress workers after N bogo pipe write
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pipe-data-size N</b></dt>
  <dd class="It-tag">specifies the size in bytes of each write to the pipe
      (range from 4 bytes to 4096 bytes). Setting a small data size will cause
      more writes to be buffered in the pipe, hence reducing the context switch
      rate between the pipe writer and pipe reader processes. Default size is
      the page size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pipe-size N</b></dt>
  <dd class="It-tag">specifies the size of the pipe in bytes (for systems that
      support the F_SETPIPE_SZ fcntl() command). Setting a small pipe size will
      cause the pipe to fill and block more frequently, hence increasing the
      context switch rate between the pipe writer and the pipe reader processes.
      Default size is 512 bytes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P N, --poll N</b></dt>
  <dd class="It-tag">start N workers that perform zero timeout polling via the
      poll(2), select(2) and sleep(3) calls. This wastes system and user time
      doing nothing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--poll-ops N</b></dt>
  <dd class="It-tag">stop poll stress workers after N bogo poll operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--procfs N</b></dt>
  <dd class="It-tag">start N workers that read files from /proc and recursively
      read files from /proc/self (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--procfs-ops N</b></dt>
  <dd class="It-tag">stop procfs reading after N bogo read operations. Note,
      since the number of entries may vary between kernels, this bogo ops metric
      is probably very misleading.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pthread N</b></dt>
  <dd class="It-tag">start N workers that iteratively creates and terminates
      multiple pthreads (the default is 1024 pthreads per worker). In each
      iteration, each newly created pthread waits until the worker has created
      all the pthreads and then they all terminate together.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pthread-ops N</b></dt>
  <dd class="It-tag">stop pthread workers after N bogo pthread create
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pthread-max N</b></dt>
  <dd class="It-tag">create N pthreads per worker. If the product of the number
      of pthreads by the number of workers is greater than the soft limit of
      allowed pthreads then the maximum is re-adjusted down to the maximum
      allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ptrace N</b></dt>
  <dd class="It-tag">start N workers that fork and trace system calls of a child
      process using ptrace(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ptrace-ops N</b></dt>
  <dd class="It-tag">stop ptracer workers after N bogo system calls are
    traced.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pty N</b></dt>
  <dd class="It-tag">start N workers that repeatedly attempt to open 65536
      pseudoterminals and perform various pty ioctls upon the ptys before
      closing them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pty-ops N</b></dt>
  <dd class="It-tag">stop pty workers after N pty bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Q, --qsort N</b></dt>
  <dd class="It-tag">start N workers that sort 32 bit integers using qsort.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--qsort-ops N</b></dt>
  <dd class="It-tag">stop qsort stress workers after N bogo qsorts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--qsort-size N</b></dt>
  <dd class="It-tag">specify number of 32 bit integers to sort, default is
      262144 (256 &#x00D7; 1024).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quota N</b></dt>
  <dd class="It-tag">start N workers that exercise the Q_GETQUOTA, Q_GETFMT,
      Q_GETINFO, Q_GETSTATS and Q_SYNC quotactl(2) commands on all the available
      mounted block based file systems.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quota-ops N</b></dt>
  <dd class="It-tag">stop quota stress workers after N bogo quotactl
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rdrand N</b></dt>
  <dd class="It-tag">start N workers that read the Intel hardware random number
      generator (Intel Ivybridge processors upwards).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rdrand-ops N</b></dt>
  <dd class="It-tag">stop rdrand stress workers after N bogo rdrand operations
      (1 bogo op = 2048 random bits successfully read).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--readahead N</b></dt>
  <dd class="It-tag">start N workers that randomly seeks and performs 512 byte
      read/write I/O operations on a file with readahead. The default file size
      is 1 GB. Readaheads and reads are batched into 16 readaheads and then 16
      reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--readahead-bytes N</b></dt>
  <dd class="It-tag">set the size of readahead file, the default is 1 GB. One
      can specify the size in units of Bytes, KBytes, MBytes and GBytes using
      the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--readahead-ops N</b></dt>
  <dd class="It-tag">stop readahead stress workers after N bogo read
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--remap N</b></dt>
  <dd class="It-tag">start N workers that map 512 pages and re-order these pages
      using the deprecated system call remap_file_pages(2). Several page
      re-orderings are exercised: forward, reverse, random and many pages to 1
      page.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--remap-ops N</b></dt>
  <dd class="It-tag">stop after N remapping bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R N, --rename N</b></dt>
  <dd class="It-tag">start N workers that each create a file and then repeatedly
      rename it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rename-ops N</b></dt>
  <dd class="It-tag">stop rename stress workers after N bogo rename
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--resources N</b></dt>
  <dd class="It-tag">start N workers that consume various system resources. Each
      worker will spawn 1024 child processes that iterate 1024 times consuming
      shared memory, heap, stack, temporary files and various file descriptors
      (eventfds, memoryfds,
    <br/>
     userfaultfds, pipes and sockets).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--resources-ops N</b></dt>
  <dd class="It-tag">stop after N resource child forks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rlimit N</b></dt>
  <dd class="It-tag">start N workers that exceed CPU and file size resource
      imits, generating SIGXCPU and SIGXFSZ signals.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rlimit-ops N</b></dt>
  <dd class="It-tag">stop after N bogo resource limited SIGXCPU and SIGXFSZ
      signals have been caught.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rmap N</b></dt>
  <dd class="It-tag">start N workers that exercise the VM reverse-mapping. This
      creates 16 processes per worker that write/read multiple file-backed
      memory mappings. There are 64 lots of 4 page mappings made onto the file,
      with each mapping overlapping the previous by 3 pages and at least 1 page
      of non-mapped memory between each of the mappings. Data is synchronously
      msync'd to the file 1 in every 256 iterations in a random manner.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rmap-ops N</b></dt>
  <dd class="It-tag">stop after N bogo rmap memory writes/reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rtc N</b></dt>
  <dd class="It-tag">start N workers that exercise the real time clock (RTC)
      interfaces via /dev/rtc and /sys/class/rtc/rtc0. No destructive writes
      (modifications) are performed on the RTC. This is a Linux only
    stressor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rtc-ops N</b></dt>
  <dd class="It-tag">stop after N bogo RTC interface accesses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sctp N</b></dt>
  <dd class="It-tag">start N workers that perform network sctp stress activity
      using the Stream Control Transmission Protocol (SCTP). This involves
      client/server processes performing rapid connect, send/receives and
      disconnects on the local host.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sctp-domain D</b></dt>
  <dd class="It-tag">specify the domain to use, the default is ipv4. Currently
      ipv4 and ipv6 are supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sctp-ops N</b></dt>
  <dd class="It-tag">stop sctp workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sctp-port P</b></dt>
  <dd class="It-tag">start at sctp port P. For N sctp worker processes, ports P
      to (P * 4) - 1 are used for ipv4, ipv6 domains and ports P to P - 1 are
      used for the unix domain.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seal N</b></dt>
  <dd class="It-tag">start N workers that exercise the fcntl(2) SEAL commands on
      a small anonymous file created using memfd_create(2). After each SEAL
      command is issued the stessor also sanity checks if the seal operation has
      sealed the file correctly. (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seal-ops N</b></dt>
  <dd class="It-tag">stop after N bogo seal operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seccomp N</b></dt>
  <dd class="It-tag">start N workers that exercise Secure Computing system call
      filtering. Each worker creates child processes that write a short message
      to /dev/null and then exits. 2% of the child processes have a seccomp
      filter that disallows the write system call and hence it is killed by
      seccomp with a SIGSYS. Note that this stressor can generate many audit log
      messages each time the child is killed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seccomp-ops N</b></dt>
  <dd class="It-tag">stop seccomp stress workers after N seccomp filter
    tests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seek N</b></dt>
  <dd class="It-tag">start N workers that randomly seeks and performs 512 byte
      read/write I/O operations on a file. The default file size is 16 GB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seek-ops N</b></dt>
  <dd class="It-tag">stop seek stress workers after N bogo seek operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seek-punch</b></dt>
  <dd class="It-tag">punch randomly located 8K holes into the file to cause more
      extents to force a more demanding seek stressor, (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seek-size N</b></dt>
  <dd class="It-tag">specify the size of the file in bytes. Small file sizes
      allow the I/O to occur in the cache, causing greater CPU load. Large file
      sizes force more I/O operations to drive causing more wait time and more
      I/O on the drive. One can specify the size in units of Bytes, KBytes,
      MBytes and GBytes using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sem N</b></dt>
  <dd class="It-tag">start N workers that perform POSIX semaphore wait and post
      operations. By default, a parent and 4 children are started per worker to
      provide some contention on the semaphore. This stresses fast semaphore
      operations and produces rapid context switching.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sem-ops N</b></dt>
  <dd class="It-tag">stop semaphore stress workers after N bogo semaphore
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sem-procs N</b></dt>
  <dd class="It-tag">start N child workers per worker to provide contention on
      the semaphore, the default is 4 and a maximum of 64 are allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sem-sysv N</b></dt>
  <dd class="It-tag">start N workers that perform System V semaphore wait and
      post operations. By default, a parent and 4 children are started per
      worker to provide some contention on the semaphore. This stresses fast
      semaphore operations and produces rapid context switching.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sem-sysv-ops N</b></dt>
  <dd class="It-tag">stop semaphore stress workers after N bogo System V
      semaphore operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sem-sysv-procs N</b></dt>
  <dd class="It-tag">start N child processes per worker to provide contention on
      the System V semaphore, the default is 4 and a maximum of 64 are
    allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sendfile N</b></dt>
  <dd class="It-tag">start N workers that send an empty file to /dev/null. This
      operation spends nearly all the time in the kernel. The default sendfile
      size is 4MB. The sendfile options are for Linux only.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sendfile-ops N</b></dt>
  <dd class="It-tag">stop sendfile workers after N sendfile bogo
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sendfile-size S</b></dt>
  <dd class="It-tag">specify the size to be copied with each sendfile call. The
      default size is 4MB. One can specify the size in units of Bytes, KBytes,
      MBytes and GBytes using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm N</b></dt>
  <dd class="It-tag">start N workers that open and allocate shared memory
      objects using the POSIX shared memory interfaces. By default, the test
      will repeatedly create and destroy 32 shared memory objects, each of which
      is 8MB in size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm-ops N</b></dt>
  <dd class="It-tag">stop after N POSIX shared memory create and destroy bogo
      operations are complete.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm-bytes N</b></dt>
  <dd class="It-tag">specify the size of the POSIX shared memory objects to be
      created. One can specify the size in units of Bytes, KBytes, MBytes and
      GBytes using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm-objs N</b></dt>
  <dd class="It-tag">specify the number of shared memory objects to be
    created.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm-sysv N</b></dt>
  <dd class="It-tag">start N workers that allocate shared memory using the
      System V shared memory interface. By default, the test will repeatedly
      create and destroy 8 shared memory segments, each of which is 8MB in
    size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm-sysv-ops N</b></dt>
  <dd class="It-tag">stop after N shared memory create and destroy bogo
      operations are complete.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm-sysv-bytes N</b></dt>
  <dd class="It-tag">specify the size of the shared memory segment to be
      created. One can specify the size in units of Bytes, KBytes, MBytes and
      GBytes using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shm-sysv-segs N</b></dt>
  <dd class="It-tag">specify the number of shared memory segments to be
    created.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigfd N</b></dt>
  <dd class="It-tag">start N workers that generate SIGRT signals and are handled
      by reads by a child process using a file descriptor set up using
      signalfd(2). (Linux only). This will generate a heavy context switch load
      when all CPUs are fully loaded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigfd-ops</b></dt>
  <dd class="It-tag">stop sigfd workers after N bogo SIGUSR1 signals are
    sent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigfpe N</b></dt>
  <dd class="It-tag">start N workers that rapidly cause division by zero SIGFPE
      faults.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigfpe-ops N</b></dt>
  <dd class="It-tag">stop sigfpe stress workers after N bogo SIGFPE faults.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigpending N</b></dt>
  <dd class="It-tag">start N workers that check if SIGUSR1 signals are pending.
      This stressor masks SIGUSR1, generates a SIGUSR1 signal and uses
      sigpending(2) to see if the signal is pending. Then it unmasks the signal
      and checks if the signal is no longer pending.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--signpending-ops N</b></dt>
  <dd class="It-tag">stop sigpending stress workers after N bogo sigpending
      pending/unpending checks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigsegv N</b></dt>
  <dd class="It-tag">start N workers that rapidly create and catch segmentation
      faults.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigsegv-ops N</b></dt>
  <dd class="It-tag">stop sigsegv stress workers after N bogo segmentation
      faults.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigsuspend N</b></dt>
  <dd class="It-tag">start N workers that each spawn off 4 child processes that
      wait for a SIGUSR1 signal from the parent using sigsuspend(2). The parent
      sends SIGUSR1 signals to each child in rapid succession. Each sigsuspend
      wakeup is counted as one bogo operation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigsuspend-ops N</b></dt>
  <dd class="It-tag">stop sigsuspend stress workers after N bogo sigsuspend
      wakeups.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigq N</b></dt>
  <dd class="It-tag">start N workers that rapidly send SIGUSR1 signals using
      sigqueue(3) to child processes that wait for the signal via
      sigwaitinfo(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sigq-ops N</b></dt>
  <dd class="It-tag">stop sigq stress workers after N bogo signal send
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sleep N</b></dt>
  <dd class="It-tag">start N workers that spawn off multiple threads that each
      perform multiple sleeps of ranges 1us to 0.1s. This creates multiple
      context switches and timer interrupts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sleep-ops N</b></dt>
  <dd class="It-tag">stop after N sleep bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sleep-max P</b></dt>
  <dd class="It-tag">start P threads per worker. The default is 1024, the
      maximum allowed is 30000.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S N, --sock N</b></dt>
  <dd class="It-tag">start N workers that perform various socket stress
      activity. This involves a pair of client/server processes performing rapid
      connect, send and receives and disconnects on the local host.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sock-domain D</b></dt>
  <dd class="It-tag">specify the domain to use, the default is ipv4. Currently
      ipv4, ipv6 and unix are supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sock-nodelay</b></dt>
  <dd class="It-tag">This disables the TCP Nagle algorithm, so data segments are
      always sent as soon as possible. This stops data from being buffered
      before being transmitted, hence resulting in poorer network utilisation
      and more context switches between the sender and receiver.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sock-port P</b></dt>
  <dd class="It-tag">start at socket port P. For N socket worker processes,
      ports P to P - 1 are used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sock-ops N</b></dt>
  <dd class="It-tag">stop socket stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sock-opts [ send | sendmsg | sendmmsg ]</b></dt>
  <dd class="It-tag">by default, messages are sent using send(2). This option
      allows one to specify the sending method using send(2), sendmsg(2) or
      sendmmsg(2). Note that sendmmsg is only available for Linux systems that
      support this system call.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sock-type [ stream | seqpacket ]</b></dt>
  <dd class="It-tag">specify the socket type to use. The default type is stream.
      seqpacket currently only works for the unix socket domain.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sockfd N</b></dt>
  <dd class="It-tag">start N workers that pass file descriptors over a UNIX
      domain socket using the CMSG(3) ancillary data mechanism. For each worker,
      pair of client/server processes are created, the server opens as many file
      descriptors on /dev/null as possible and passing these over the socket to
      a client that reads these from the CMSG data and immediately closes the
      files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sockfd-ops N</b></dt>
  <dd class="It-tag">stop sockfd stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sockfd-port P</b></dt>
  <dd class="It-tag">start at socket port P. For N socket worker processes,
      ports P to P - 1 are used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sockpair N</b></dt>
  <dd class="It-tag">start N workers that perform socket pair I/O read/writes.
      This involves a pair of client/server processes performing randomly sized
      socket I/O operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sockpair-ops N</b></dt>
  <dd class="It-tag">stop socket pair stress workers after N bogo
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--spawn N</b></dt>
  <dd class="It-tag">start N workers continually spawn children using
      posix_spawn(3) that exec stress-ng and then exit almost immediately.
      Currently Linux only.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--spawn-ops N</b></dt>
  <dd class="It-tag">stop spawn stress workers after N bogo spawns.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--splice N</b></dt>
  <dd class="It-tag">move data from /dev/zero to /dev/null through a pipe
      without any copying between kernel address space and user address space
      using splice(2). This is only available for Linux.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--splice-ops N</b></dt>
  <dd class="It-tag">stop after N bogo splice operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--splice-bytes N</b></dt>
  <dd class="It-tag">transfer N bytes per splice call, the default is 64K. One
      can specify the size in units of Bytes, KBytes, MBytes and GBytes using
      the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stack N</b></dt>
  <dd class="It-tag">start N workers that rapidly cause and catch stack
      overflows by use of alloca(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stack-fill</b></dt>
  <dd class="It-tag">the default action is to touch the lowest page on each
      stack allocation. This option touches all the pages by filling the new
      stack allocation with zeros which forces physical pages to be allocated
      and hence is more aggressive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stack-ops N</b></dt>
  <dd class="It-tag">stop stack stress workers after N bogo stack
    overflows.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stackmmap N</b></dt>
  <dd class="It-tag">start N workers that use a 2MB stack that is memory mapped
      onto a temporary file. A recursive function works down the stack and
      flushes dirty stack pages back to the memory mapped file using msync(2)
      until the end of the stack is reached (stack overflow). This exercises
      dirty page and stack exception handling.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stackmmap-ops N</b></dt>
  <dd class="It-tag">stop workers after N stack overflows have occurred.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--str N</b></dt>
  <dd class="It-tag">start N workers that exercise various libc string functions
      on random strings.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--str-method strfunc</b></dt>
  <dd class="It-tag">select a specific libc string function to stress. Available
      string functions to stress are: all, index, rindex, strcasecmp, strcat,
      strchr, strcoll, strcmp, strcpy, strlen, strncasecmp, strncat, strncmp,
      strrchr and strxfrm. See string(3) for more information on these string
      functions. The 'all' method is the default and will exercise all the
      string methods.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--str-ops N</b></dt>
  <dd class="It-tag">stop after N bogo string operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stream N</b></dt>
  <dd class="It-tag">start N workers exercising a memory bandwidth stressor
      loosely based on the STREAM &quot;Sustainable Memory Bandwidth in High
      Performance Computers&quot; benchmarking tool by John D. McCalpin, Ph.D.
      This stressor allocates buffers that are at least 4 times the size of the
      CPU L2 cache and continually performs rounds of following computations on
      large arrays of double precision floating point numbers:
    <table class="tbl">
      <colgroup>
        <col style="width: 9.00ex;"/>
        <col style="width: 29.00ex;"/>
      </colgroup>
      <tr>
        <td>Operation</td>
        <td>Description</td>
      </tr>
      <tr>
        <td>copy</td>
        <td>c[i] = a[i]</td>
      </tr>
      <tr>
        <td>scale</td>
        <td>b[i] = scalar * c[i]</td>
      </tr>
      <tr>
        <td>add</td>
        <td>c[i] = a[i] + b[i]</td>
      </tr>
      <tr>
        <td>triad</td>
        <td>a[i] = b[i] + (c[i] * scalar)</td>
      </tr>
    </table>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
Since this is loosely based on a variant of the STREAM benchmark code, DO NOT
  submit results based on this as it is intended to in stress-ng just to stress
  memory and compute and NOT intended for STREAM accurate tuned or non-tuned
  benchmarking whatsoever. Use the official STREAM benchmarking tool if you
  desire accurate and standardised STREAM benchmarks.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stream-ops N</b></dt>
  <dd class="It-tag">stop after N stream bogo operations, where a bogo operation
      is one round of copy, scale, add and triad operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stream-l3-size N</b></dt>
  <dd class="It-tag">Specify the CPU Level 3 cache size in bytes. One can
      specify the size in units of Bytes, KBytes, MBytes and GBytes using the
      suffix b, k, m or g. If the L3 cache size is not provided, then stress-ng
      will attempt to determine the cache size, and failing this, will default
      the size to 4MB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s N, --switch N</b></dt>
  <dd class="It-tag">start N workers that send messages via pipe to a child to
      force context switching.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--switch-ops N</b></dt>
  <dd class="It-tag">stop context switching workers after N bogo
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--symlink N</b></dt>
  <dd class="It-tag">start N workers creating and removing symbolic links.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--symlink-ops N</b></dt>
  <dd class="It-tag">stop symlink stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sync-file N</b></dt>
  <dd class="It-tag">start N workers that perform a range of data syncs across a
      file using sync_file_range(2). Three mixes of syncs are performed, from
      start to the end of the file, from end of the file to the start, and a
      random mix. A random selection of valid sync types are used, covering the
      SYNC_FILE_RANGE_WAIT_BEFORE, SYNC_FILE_RANGE_WRITE and
      SYNC_FILE_RANGE_WAIT_AFTER flag bits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sync-file-ops N</b></dt>
  <dd class="It-tag">stop sync-file workers after N bogo sync operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sync-file-bytes N</b></dt>
  <dd class="It-tag">specify the size of the file to be sync'd. One can specify
      the size in units of Bytes, KBytes, MBytes and GBytes using the suffix b,
      k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sysinfo N</b></dt>
  <dd class="It-tag">start N workers that continually read system and process
      specific information. This reads the process user and system times using
      the times(2) system call. For Linux systems, it also reads overall system
      statistics using the sysinfo(2) system call and also the file system
      statistics for all mounted file systems using statfs(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sysinfo-ops N</b></dt>
  <dd class="It-tag">stop the sysinfo workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sysfs N</b></dt>
  <dd class="It-tag">start N workers that recursively read files from /sys
      (Linux only). This may cause specific kernel drivers to emit messages into
      the kernel log.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sys-ops N</b></dt>
  <dd class="It-tag">stop sysfs reading after N bogo read operations. Note,
      since the number of entries may vary between kernels, this bogo ops metric
      is probably very misleading.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tee N</b></dt>
  <dd class="It-tag">move data from a writer process to a reader process through
      pipes and to /dev/null without any copying between kernel address space
      and user address space using tee(2). This is only available for
    Linux.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tee-ops N</b></dt>
  <dd class="It-tag">stop after N bogo tee operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T N, --timer N</b></dt>
  <dd class="It-tag">start N workers creating timer events at a default rate of
      1 MHz (Linux only); this can create a many thousands of timer clock
      interrupts. Each timer event is caught by a signal handler and counted as
      a bogo timer op.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timer-ops N</b></dt>
  <dd class="It-tag">stop timer stress workers after N bogo timer events (Linux
      only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timer-freq F</b></dt>
  <dd class="It-tag">run timers at F Hz; range from 1 to 1000000000 Hz (Linux
      only). By selecting an appropriate frequency stress-ng can generate
      hundreds of thousands of interrupts per second.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timer-rand</b></dt>
  <dd class="It-tag">select a timer frequency based around the timer frequency
      +/- 12.5% random jitter. This tries to force more variability in the timer
      interval to make the scheduling less predictable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timerfd N</b></dt>
  <dd class="It-tag">start N workers creating timerfd events at a default rate
      of 1 MHz (Linux only); this can create a many thousands of timer clock
      events. Timer events are waited for on the timer file descriptor using
      select(2) and then read and counted as a bogo timerfd op.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timerfd-ops N</b></dt>
  <dd class="It-tag">stop timerfd stress workers after N bogo timerfd events
      (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timerfd-freq F</b></dt>
  <dd class="It-tag">run timers at F Hz; range from 1 to 1000000000 Hz (Linux
      only). By selecting an appropriate frequency stress-ng can generate
      hundreds of thousands of interrupts per second.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timerfd-rand</b></dt>
  <dd class="It-tag">select a timerfd frequency based around the timer frequency
      +/- 12.5% random jitter. This tries to force more variability in the timer
      interval to make the scheduling less predictable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tlb-shootdown N</b></dt>
  <dd class="It-tag">start N workers that force Translation Lookaside Buffer
      (TLB) shootdowns. This is achieved by creating upto 16 child processes
      that all share a region of memory and these processes are shared amongst
      the available CPUs. The processes adjust the page mapping settings causing
      TLBs to be force flushed on the other processors, causing the TLB
      shootdowns.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tlb-shootdown-ops N</b></dt>
  <dd class="It-tag">stop after N bogo TLB shootdown operations are
    completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tsc N</b></dt>
  <dd class="It-tag">start N workers that read the Time Stamp Counter (TSC) 256
      times per loop iteration (bogo operation). Available only on Intel x86
      platforms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tsc-ops N</b></dt>
  <dd class="It-tag">stop the tsc workers after N bogo operations are
    completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tsearch N</b></dt>
  <dd class="It-tag">start N workers that insert, search and delete 32 bit
      integers on a binary tree using tsearch(3), tfind(3) and tdelete(3). By
      default, there are 65536 randomized integers used in the tree. This is a
      useful method to exercise random access of memory and processor
    cache.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tsearch-ops N</b></dt>
  <dd class="It-tag">stop the tsearch workers after N bogo tree operations are
      completed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tsearch-size N</b></dt>
  <dd class="It-tag">specify the size (number of 32 bit integers) in the array
      to tsearch. Size can be from 1K to 4M.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp N</b></dt>
  <dd class="It-tag">start N workers that transmit data using UDP. This involves
      a pair of client/server processes performing rapid connect, send and
      receives and disconnects on the local host.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp-domain D</b></dt>
  <dd class="It-tag">specify the domain to use, the default is ipv4. Currently
      ipv4, ipv6 and unix are supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp-lite</b></dt>
  <dd class="It-tag">use the UDP-Lite (RFC 3828) protocol (only for ipv4 and
      ipv4 domains).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp-ops N</b></dt>
  <dd class="It-tag">stop udp stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp-port P</b></dt>
  <dd class="It-tag">start at port P. For N udp worker processes, ports P to P -
      1 are used. By default, ports 7000 upwards are used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp-flood N</b></dt>
  <dd class="It-tag">start N workers that attempt to flood the host with UDP
      packets to random ports. The IP address of the packets are currently not
      spoofed. This is only available on systems that support AF_PACKET.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp-flood-domain D</b></dt>
  <dd class="It-tag">specify the domain to use, the default is ipv4. Currently
      ipv4 and ipv6 are supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--udp-flood-ops N</b></dt>
  <dd class="It-tag">stop udp-flood stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--unshare N</b></dt>
  <dd class="It-tag">start N workers that each fork off 32 child processes, each
      of which exercises the unshare(2) system call by disassociating parts of
      the process execution context. (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--unshare-ops N</b></dt>
  <dd class="It-tag">stop after N bogo unshare operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u N, --urandom N</b></dt>
  <dd class="It-tag">start N workers reading /dev/urandom (Linux only). This
      will load the kernel random number source.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--urandom-ops N</b></dt>
  <dd class="It-tag">stop urandom stress workers after N urandom bogo read
      operations (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--userfaultfd N</b></dt>
  <dd class="It-tag">start N workers that generate write page faults on a small
      anonymously mapped memory region and handle these faults using the user
      space fault handling via the userfaultfd mechanism. This will generate a
      large quanity of major page faults and also context switches during the
      handling of the page faults. (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--userfaultfd-ops N</b></dt>
  <dd class="It-tag">stop userfaultfd stress workers after N page faults.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--userfaultfd-bytes N</b></dt>
  <dd class="It-tag">mmap N bytes per userfaultfd worker to page fault on, the
      default is 16MB One can specify the size in units of Bytes, KBytes, MBytes
      and GBytes using the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--utime N</b></dt>
  <dd class="It-tag">start N workers updating file timestamps. This is mainly
      CPU bound when the default is used as the system flushes metadata changes
      only periodically.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--utime-ops N</b></dt>
  <dd class="It-tag">stop utime stress workers after N utime bogo
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--utime-fsync</b></dt>
  <dd class="It-tag">force metadata changes on each file timestamp update to be
      flushed to disk. This forces the test to become I/O bound and will result
      in many dirty metadata writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vecmath N</b></dt>
  <dd class="It-tag">start N workers that perform various unsigned integer math
      operations on various 128 bit vectors. A mix of vector math operations are
      performed on the following vectors: 16 &#x00D7; 8 bits, 8 &#x00D7; 16
      bits, 4 &#x00D7; 32 bits, 2 &#x00D7; 64 bits. The metrics produced by this
      mix depend on the processor architecture and the vector math optimisations
      produced by the compiler.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vecmath-ops N</b></dt>
  <dd class="It-tag">stop after N bogo vector integer math operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vfork N</b></dt>
  <dd class="It-tag">start N workers continually vforking children that
      immediately exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vfork-ops N</b></dt>
  <dd class="It-tag">stop vfork stress workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vfork-max P</b></dt>
  <dd class="It-tag">create P processes and then wait for them to exit per
      iteration. The default is just 1; higher values will create many temporary
      zombie processes that are waiting to be reaped. One can potentially fill
      up the the process table using high values for --vfork-max and
    --vfork.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m N, --vm N</b></dt>
  <dd class="It-tag">start N workers continuously calling mmap(2)/munmap(2) and
      writing to the allocated memory. Note that this can cause systems to trip
      the kernel OOM killer on Linux systems if not enough physical memory and
      swap is not available.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-bytes N</b></dt>
  <dd class="It-tag">mmap N bytes per vm worker, the default is 256MB. One can
      specify the size in units of Bytes, KBytes, MBytes and GBytes using the
      suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-ops N</b></dt>
  <dd class="It-tag">stop vm workers after N bogo operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-hang N</b></dt>
  <dd class="It-tag">sleep N seconds before unmapping memory, the default is
      zero seconds. Specifying 0 will do an infinite wait.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-keep</b></dt>
  <dd class="It-tag">do not continually unmap and map memory, just keep on
      re-writing to it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-locked</b></dt>
  <dd class="It-tag">Lock the pages of the mapped region into memory using mmap
      MAP_LOCKED (since Linux 2.5.37). This is similar to locking memory as
      described in mlock(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-method m</b></dt>
  <dd class="It-tag">specify a vm stress method. By default, all the stress
      methods are exercised sequentially, however one can specify just one
      method to be used if required. Each of the vm workers have 3 phases:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
1. Initialised. The anonymously memory mapped region is set to a known pattern.
<div class="Pp"></div>
2. Exercised. Memory is modified in a known predictable way. Some vm workers
  alter memory sequentially, some use small or large strides to step along
  memory.
<div class="Pp"></div>
3. Checked. The modified memory is checked to see if it matches the expected
  result.
<div class="Pp"></div>
The vm methods containing 'prime' in their name have a stride of the largest
  prime less than 2^64, allowing to them to thoroughly step through memory and
  touch all locations just once while also doing without touching memory cells
  next to each other. This strategy exercises the cache and page non-locality.
<div class="Pp"></div>
Since the memory being exercised is virtually mapped then there is no guarantee
  of touching page addresses in any particular physical order. These workers
  should not be used to test that all the system's memory is working correctly
  either, use tools such as memtest86 instead.
<div class="Pp"></div>
The vm stress methods are intended to exercise memory in ways to possibly find
  memory issues and to try to force thermal errors.
<div class="Pp"></div>
Available vm stress methods are described as follows:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 414.00ex;"/>
  </colgroup>
  <tr>
    <td>Method</td>
    <td>Description</td>
  </tr>
  <tr>
    <td>all</td>
    <td>iterate over all the vm stress methods as listed below.</td>
  </tr>
  <tr>
    <td>flip</td>
    <td>sequentially work through memory 8 times, each time just one bit in
      memory flipped (inverted). This will effectively invert each byte in 8
      passes.</td>
  </tr>
  <tr>
    <td>galpat-0</td>
    <td>galloping pattern zeros. This sets all bits to 0 and flips just 1 in
      4096 bits to 1. It then checks to see if the 1s are pulled down to 0 by
      their neighbours or of the neighbours have been pulled up to 1.</td>
  </tr>
  <tr>
    <td>galpat-1</td>
    <td>galloping pattern ones. This sets all bits to 1 and flips just 1 in 4096
      bits to 0. It then checks to see if the 0s are pulled up to 1 by their
      neighbours or of the neighbours have been pulled down to 0.</td>
  </tr>
  <tr>
    <td>gray</td>
    <td>fill the memory with sequential gray codes (these only change 1 bit at a
      time between adjacent bytes) and then check if they are set
      correctly.</td>
  </tr>
  <tr>
    <td>incdec</td>
    <td>work sequentially through memory twice, the first pass increments each
      byte by a specific value and the second pass decrements each byte back to
      the original start value. The increment/decrement value changes on each
      invocation of the stressor.</td>
  </tr>
  <tr>
    <td>inc-nybble</td>
    <td>initialise memory to a set value (that changes on each invocation of the
      stressor) and then sequentially work through each byte incrementing the
      bottom 4 bits by 1 and the top 4 bits by 15.</td>
  </tr>
  <tr>
    <td>rand-set</td>
    <td>sequentially work through memory in 64 bit chunks setting bytes in the
      chunk to the same 8 bit random value. The random value changes on each
      chunk. Check that the values have not changed.</td>
  </tr>
  <tr>
    <td>rand-sum</td>
    <td>sequentially set all memory to random values and then summate the number
      of bits that have changed from the original set values.</td>
  </tr>
  <tr>
    <td>read64</td>
    <td>sequentially read memory using 32 x 64 bit reads per bogo loop. Each
      loop equates to one bogo operation. This exercises raw memory reads.</td>
  </tr>
  <tr>
    <td>ror</td>
    <td>fill memory with a random pattern and then sequentially rotate 64 bits
      of memory right by one bit, then check the final load/rotate/stored
      values.</td>
  </tr>
  <tr>
    <td>swap</td>
    <td>fill memory in 64 byte chunks with random patterns. Then swap each 64
      chunk with a randomly chosen chunk. Finally, reverse the swap to put the
      chunks back to their original place and check if the data is correct. This
      exercises adjacent and random memory load/stores.</td>
  </tr>
  <tr>
    <td>move-inv</td>
    <td>sequentially fill memory 64 bits of memory at a time with random values,
      and then check if the memory is set correctly. Next, sequentially invert
      each 64 bit pattern and again check if the memory is set as expected.</td>
  </tr>
  <tr>
    <td>modulo-x</td>
    <td>fill memory over 23 iterations. Each iteration starts one byte further
      along from the start of the memory and steps along in 23 byte strides. In
      each stride, the first byte is set to a random pattern and all other bytes
      are set to the inverse. Then it checks see if the first byte contains the
      expected random pattern. This exercises cache store/reads as well as
      seeing if neighbouring cells influence each other.</td>
  </tr>
  <tr>
    <td>prime-0</td>
    <td>iterate 8 times by stepping through memory in very large prime strides
      clearing just on bit at a time in every byte. Then check to see if all
      bits are set to zero.</td>
  </tr>
  <tr>
    <td>prime-1</td>
    <td>iterate 8 times by stepping through memory in very large prime strides
      setting just on bit at a time in every byte. Then check to see if all bits
      are set to one.</td>
  </tr>
  <tr>
    <td>prime-gray-0</td>
    <td>first step through memory in very large prime strides clearing just on
      bit (based on a gray code) in every byte. Next, repeat this but clear the
      other 7 bits. Then check to see if all bits are set to zero.</td>
  </tr>
  <tr>
    <td>prime-gray-1</td>
    <td>first step through memory in very large prime strides setting just on
      bit (based on a gray code) in every byte. Next, repeat this but set the
      other 7 bits. Then check to see if all bits are set to one.</td>
  </tr>
  <tr>
    <td>rowhammer</td>
    <td>try to force memory corruption using the rowhammer memory stressor. This
      fetches two 32 bit integers from memory and forces a cache flush on the
      two addresses multiple times. This has been known to force bit flipping on
      some hardware, especially with lower frequency memory refresh cycles.</td>
  </tr>
  <tr>
    <td>walk-0d</td>
    <td>for each byte in memory, walk through each data line setting them to low
      (and the others are set high) and check that the written value is as
      expected. This checks if any data lines are stuck.</td>
  </tr>
  <tr>
    <td>walk-1d</td>
    <td>for each byte in memory, walk through each data line setting them to
      high (and the others are set low) and check that the written value is as
      expected. This checks if any data lines are stuck.</td>
  </tr>
  <tr>
    <td>walk-0a</td>
    <td>in the given memory mapping, work through a range of specially chosen
      addresses working through address lines to see if any address lines are
      stuck low. This works best with physical memory addressing, however,
      exercising these virtual addresses has some value too.</td>
  </tr>
  <tr>
    <td>walk-1a</td>
    <td>in the given memory mapping, work through a range of specially chosen
      addresses working through address lines to see if any address lines are
      stuck high. This works best with physical memory addressing, however,
      exercising these virtual addresses has some value too.</td>
  </tr>
  <tr>
    <td>write64</td>
    <td>sequentially write memory using 32 x 64 bit writes per bogo loop. Each
      loop equates to one bogo operation. This exercises raw memory writes. Note
      that memory writes are not checked at the end of each test iteration.</td>
  </tr>
  <tr>
    <td>zero-one</td>
    <td>set all memory bits to zero and then check if any bits are not zero.
      Next, set all the memory bits to one and check if any bits are not
      one.</td>
  </tr>
</table>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-populate</b></dt>
  <dd class="It-tag">populate (prefault) page tables for the memory mappings;
      this can stress swapping. Only available on systems that support
      MAP_POPULATE (since Linux 2.5.46).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-rw N</b></dt>
  <dd class="It-tag">start N workers that transfer memory to/from a parent/child
      using process_vm_writev(2) and process_vm_readv(2). This is feature is
      only supported on Linux. Memory transfers are only verified if the
      --verify option is enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-rw-ops N</b></dt>
  <dd class="It-tag">stop vm-rw workers after N memory read/writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-rw-bytes N</b></dt>
  <dd class="It-tag">mmap N bytes per vm-rw worker, the default is 16MB. One can
      specify the size in units of Bytes, KBytes, MBytes and GBytes using the
      suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-splice N</b></dt>
  <dd class="It-tag">move data from memory to /dev/null through a pipe without
      any copying between kernel address space and user address space using
      vmsplice(2) and splice(2). This is only available for Linux.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-splice-ops N</b></dt>
  <dd class="It-tag">stop after N bogo vm-splice operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vm-splice-bytes N</b></dt>
  <dd class="It-tag">transfer N bytes per vmsplice call, the default is 64K. One
      can specify the size in units of Bytes, KBytes, MBytes and GBytes using
      the suffix b, k, m or g.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--wait N</b></dt>
  <dd class="It-tag">start N workers that spawn off two children; one spins in a
      pause(2) loop, the other continually stops and continues the first. The
      controlling process waits on the first child to be resumed by the delivery
      of SIGCONT using waitpid(2) and waitid(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--wait-ops N</b></dt>
  <dd class="It-tag">stop after N bogo wait operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--wcs N</b></dt>
  <dd class="It-tag">start N workers that exercise various libc wide character
      string functions on random strings.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--wcs-method wcsfunc</b></dt>
  <dd class="It-tag">select a specific libc wide character string function to
      stress. Available string functions to stress are: all, wcscasecmp, wcscat,
      wcschr, wcscoll, wcscmp, wcscpy, wcslen, wcsncasecmp, wcsncat, wcsncmp,
      wcsrchr and wcsxfrm. The 'all' method is the default and will exercise all
      the string methods.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--wcs-ops N</b></dt>
  <dd class="It-tag">stop after N bogo wide character string operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xattr N</b></dt>
  <dd class="It-tag">start N workers that create, update and delete batches of
      extended attributes on a file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xattr-ops N</b></dt>
  <dd class="It-tag">stop after N bogo extended attribute operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-y N, --yield N</b></dt>
  <dd class="It-tag">start N workers that call sched_yield(2). This stressor
      ensures that at least 2 child processes per CPU exercice shield_yield(2)
      no matter how many workers are specified, thus always ensuring rapid
      context switching.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--yield-ops N</b></dt>
  <dd class="It-tag">stop yield stress workers after N sched_yield(2) bogo
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zero N</b></dt>
  <dd class="It-tag">start N workers reading /dev/zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zero-ops N</b></dt>
  <dd class="It-tag">stop zero stress workers after N /dev/zero bogo read
      operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zlib N</b></dt>
  <dd class="It-tag">start N workers compressing and decompressing random data
      using zlib. Each worker has two processes, one that compresses random data
      and pipes it to another process that decompresses the data. This stressor
      exercises CPU, cache and memory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zlib-ops N</b></dt>
  <dd class="It-tag">stop after N bogo compression operations, each bogo
      compression operation is a compression of 64K of random data at the
      highest compression level.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zombie N</b></dt>
  <dd class="It-tag">start N workers that create zombie processes. This will
      rapidly try to create a default of 8192 child processes that immediately
      die and wait in a zombie state until they are reaped. Once the maximum
      number of processes is reached (or fork fails because one has reached the
      maximum allowed number of children) the oldest child is reaped and a new
      process is then created in a first-in first-out manner, and then
    repeated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zombie-ops N</b></dt>
  <dd class="It-tag">stop zombie stress workers after N bogo zombie
    operations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zombie-max N</b></dt>
  <dd class="It-tag">try to create as many as N zombie processes. This may not
      be reached if the system limit is less than N.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
stress-ng --cpu 4 --io 2 --vm 1 --vm-bytes 1G --timeout 60s
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">runs for 60 seconds with 4 cpu stressors, 2 io stressors
      and 1 vm stressor using 1GB of virtual memory.</dd>
</dl>
<div class="Pp"></div>
stress-ng --cpu 8 --cpu-ops 800000
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">runs 8 cpu stressors and stops after 800000 bogo
      operations.</dd>
</dl>
<div class="Pp"></div>
stress-ng --sequential 2 --timeout 2m --metrics
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 2 simultaneous instances of all the stressors
      sequentially one by one, each for 2 minutes and summarise with performance
      metrics at the end.</dd>
</dl>
<div class="Pp"></div>
stress-ng --cpu 4 --cpu-method fft --cpu-ops 10000 --metrics-brief
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 4 FFT cpu stressors, stop after 10000 bogo operations
      and produce a summary just for the FFT results.</dd>
</dl>
<div class="Pp"></div>
stress-ng --cpu 0 --cpu-method all -t 1h
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run cpu stressors on all online CPUs working through all
      the available CPU stressors for 1 hour.</dd>
</dl>
<div class="Pp"></div>
stress-ng --all 4 --timeout 5m
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 4 instances of all the stressors for 5 minutes.</dd>
</dl>
<div class="Pp"></div>
stress-ng --random 64
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 64 stressors that are randomly chosen from all the
      available stressors.</dd>
</dl>
<div class="Pp"></div>
stress-ng --cpu 64 --cpu-method all --verify -t 10m --metrics-brief
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 64 instances of all the different cpu stressors and
      verify that the computations are correct for 10 minutes with a bogo
      operations summary at the end.</dd>
</dl>
<div class="Pp"></div>
stress-ng --sequential 0 -t 10m
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run all the stressors one by one for 10 minutes, with the
      number of instances of each stressor matching the number of online
    CPUs.</dd>
</dl>
<div class="Pp"></div>
stress-ng --sequential 8 --class io -t 5m --times
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run all the stressors in the io class one by one for 5
      minutes each, with 8 instances of each stressor running concurrently and
      show overall time utilisation statistics at the end of the run.</dd>
</dl>
<div class="Pp"></div>
stress-ng --all 0 --maximize --aggressive
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run all the stressors (1 instance of each per CPU)
      simultaneously, maximize the settings (memory sizes, file allocations,
      etc.) and select the most demanding/aggressive options.</dd>
</dl>
<div class="Pp"></div>
stress-ng --random 32 -x numa,hdd,key
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 32 randomly selected stressors and exclude the numa,
      hdd and key stressors</dd>
</dl>
<div class="Pp"></div>
stress-ng --sequential 4 --class vm --exclude bigheap,brk,stack
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 4 instances of the VM stressors one after each other,
      excluding the bigheap, brk and stack stressors</dd>
</dl>
<div class="Pp"></div>
stress-ng --taskset 0,2-3 --cpu 3
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">run 3 instances of the CPU stressor and pin them to CPUs 0,
      2 and 3.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
<table class="tbl">
  <colgroup>
    <col style="width: 10.00ex;"/>
    <col style="width: 180.00ex;"/>
  </colgroup>
  <tr>
    <td>Status</td>
    <td>Description</td>
  </tr>
  <tr>
    <td>0</td>
    <td>Success.</td>
  </tr>
  <tr>
    <td>1</td>
    <td>Error; incorrect user options or a fatal resource issue in the stress-ng
      stressor harness (for example, out of memory).</td>
  </tr>
  <tr>
    <td>2</td>
    <td>One or more stressors failed.</td>
  </tr>
  <tr>
    <td>3</td>
    <td>One or more stressors failed to initialise because of lack of resources,
      for example ENOMEM (no memory), ENOSPC (no space on file system) or a
      missing or unimplemented system call.</td>
  </tr>
  <tr>
    <td>4</td>
    <td>One or more stressors were not implemented on a specific architecture or
      operating system.</td>
  </tr>
</table>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
File bug reports at:
<br/>
 https://launchpad.net/ubuntu/+source/stress-ng/+filebug
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>cpuburn</b>(1), <b>perf</b>(1), <b>stress</b>(1), <b>taskset</b>(1)
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
stress-ng was written by Colin King &lt;colin.king@canonical.com&gt; and is a
  clean room re-implementation and extension of the original stress tool by Amos
  Waterland &lt;apw@rossby.metr.ou.edu&gt;. Thanks also for contributions from
  Christian Ehrhardt, James Hunt, Jim Rowan, Tim Gardner, Luca Pizzamiglio and
  Zhiyi Sun.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
Sending a SIGALRM, SIGINT or SIGHUP to stress-ng causes it to terminate all the
  stressor processes and ensures temporary files and shared memory segments are
  removed cleanly.
<div class="Pp"></div>
Sending a SIGUSR2 to stress-ng will dump out the current load average and memory
  statistics.
<div class="Pp"></div>
Note that the stress-ng cpu, io, vm and hdd tests are different implementations
  of the original stress tests and hence may produce different stress
  characteristics. stress-ng does not support any GPU stress tests.
<div class="Pp"></div>
The bogo operations metrics may change with each release because of bug fixes to
  the code, new features, compiler optimisations or changes in system call
  performance.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright &#x00A9; 2013-2016 Canonical Ltd.
<div>&#x00A0;</div>
This is free software; see the source for copying conditions. There is NO
  warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.</div>
<table class="foot">
  <tr>
    <td class="foot-date">November 11, 2016</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
