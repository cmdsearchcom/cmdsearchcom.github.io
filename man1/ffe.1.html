<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:09:28 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FFE(1) FFE(1)</p>

<p style="margin-top: 1em">NAME <br>
ffe - flat file extractor</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ffe [options]...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
ffe is a program for extracting fields from flat file
records and displaying them in different formats. ffe relies
on the configuration file to control input file structure
and <br>
the output format.</p>

<p style="margin-top: 1em">OPTIONS <br>
ffe accepts the following options:</p>

<p style="margin-top: 1em">-c, --configuration=file <br>
Read the configuration from file, default is ~/.fferc.</p>

<p style="margin-top: 1em">-s, --structure=STRUCTURE <br>
Input file is processed using the structure STRUCTURE.</p>

<p style="margin-top: 1em">-p, --print=FORMAT <br>
Use output format FORMAT for printing. All printing can be
suppressed using format no. Original data is printed using
format raw.</p>

<p style="margin-top: 1em">-o, --output=NAME <br>
Write output to NAME instead of standard output.</p>

<p style="margin-top: 1em">-f, --field-list=LIST <br>
Print only fields and constants specified in comma separated
list LIST.</p>

<p style="margin-top: 1em">-e, --expression=EXPRESSION <br>
Print only those records for which the EXPRESSION evaluates
to true.</p>

<p style="margin-top: 1em">-a, --and <br>
Expressions are combined with logical and, default is
logical or.</p>

<p style="margin-top: 1em">-X, --casecmp <br>
Expressions are evaluated case insensitive.</p>

<p style="margin-top: 1em">-v, --invert-match <br>
Print only those records which don&rsquo;t match the
expression.</p>

<p style="margin-top: 1em">-l, --loose <br>
An invalid input line does not cause program to abort.</p>

<p style="margin-top: 1em">-r, --replace=FIELD=VALUE <br>
Replace FIELDs contents with VALUE in output. VALUE can
contain same directives as output option data.</p>

<p style="margin-top: 1em">-d, --debug <br>
All invalid input lines are written to file
ffe_error_&lt;pid&gt;.log.</p>

<p style="margin-top: 1em">-I, --info <br>
Show the structure information in configuration file and
exit.</p>

<p style="margin-top: 1em">-?, --help <br>
List all available options and their meanings and exit.</p>

<p style="margin-top: 1em">-V, --version <br>
Show version of program and exit.</p>

<p style="margin-top: 1em">All remaining arguments are
names of input files; if no input files are specified, then
the standard input is read.</p>

<p style="margin-top: 1em">Expressions (option -e,
--expression) <br>
Expression can be used to select specific records comparing
field values.</p>

<p style="margin-top: 1em">If the value starts with string
&quot;file:&quot; then the rest of the value is considered
as a file name. Every line in the file is used as value in
comparison. Record will be selected if <br>
one or more values evaluates true.</p>

<p style="margin-top: 1em">Expression notation:</p>

<p style="margin-top: 1em">field=value <br>
A record will be selected if the field field is equal to the
value value.</p>

<p style="margin-top: 1em">field^value <br>
A record will be selected if the field field starts with the
value value.</p>

<p style="margin-top: 1em">field~value <br>
A record will be selected if the field field contains the
value value.</p>

<p style="margin-top: 1em">field!value <br>
A record will be selected if the field field is not equal to
the value value.</p>

<p style="margin-top: 1em">field?value <br>
A record will be selected if the field field matches the
regular expression in value.</p>

<p style="margin-top: 1em">FFE CONFIGURATION <br>
ffe uses the configuration file for extracting fields from
the input file and for formatting the fields for output.
Every line or binary block of the input file is considered
as <br>
a record. Default configuration file is ~/.fferc but another
file can be given with &rsquo;-c&rsquo; option.</p>

<p style="margin-top: 1em">Configuration file for ffe is a
text file. The file may contain empty lines. Commands are
case-sensitive. Comments begin with the #-character and end
at the end of the line. <br>
The string and char definitions can be enclosed in double
quotation &rsquo;&quot;&rsquo; characters. char is a single
character. string and char can contain following escape
codes:&rsquo;, &rsquo; <br>
&rsquo;&rsquo;,&rsquo;,&rsquo;,&rsquo;0,&rsquo;&rsquo;,
&rsquo;</p>

<p style="margin-top: 1em">Command Substitution allows the
output of a command to replace parts of the configuration
file. Syntax for command substitution is: <br>
&lsquo;command&lsquo; <br>
The command is executed and the &lsquo;command&lsquo; is
substituted with the standard output of the command, with
any trailing newlines deleted. Command substitutions may not
be nested.</p>

<p style="margin-top: 1em">Before executing the command ffe
sets few environment variables:</p>

<p style="margin-top: 1em">FFE_STRUCTURE <br>
The name of the structure given using -s,--structure.</p>

<p style="margin-top: 1em">FFE_OUIPUT <br>
The name of the output file given using -o,--output.</p>

<p style="margin-top: 1em">FFE_FORMAT <br>
The name of the output format given using -p,--print.</p>

<p style="margin-top: 1em">FFE_FIRST_FILE <br>
The name of the first input file.</p>

<p style="margin-top: 1em">FFE_FILES <br>
A list of all input files.</p>

<p style="margin-top: 1em">If variable is already set it
will not be replaced.</p>

<p style="margin-top: 1em">Input file structure <br>
Input file structures are specified with keyword
structure:</p>

<p style="margin-top: 1em">structure name {options...}</p>

<p style="margin-top: 1em">Options must be ended with
newline, options are:</p>

<p style="margin-top: 1em">type fixed|binary|separated
[char] [*] <br>
Fields in the input are fixed length text fields, fixed
length binary fields or text fields separated by char. If *
is given, multiple sequential separators are considered <br>
as one. Default separator is comma.</p>

<p style="margin-top: 1em">quoted [char] <br>
Fields may be quoted with char, default quotation mark is
double quotation mark &rsquo;&quot;&rsquo;. A quotation mark
is assumed to be escaped as in input. Non escaped quotation
marks are not preserved in output.</p>

<p style="margin-top: 1em">header first|all|no <br>
Controls the occurrence of the header line. Default is no.
If set as first or all, the first line of the first input
file is considered as header line containing the names <br>
of the fields. First means that only the first file has a
header, all means that all files have a header, although the
names are still taken from the header of the first <br>
file. Header line is handled according the record
definition, meaning that the name positions, separators etc.
are the same as for the fields.</p>

<p style="margin-top: 1em">output name <br>
All records belonging this structure are printed according
output format name. Default is to use output named as
&rsquo;default&rsquo;.</p>

<p style="margin-top: 1em">record name {options...} <br>
Defines one record for a structure. A structure can contain
several record types.</p>

<p style="margin-top: 1em">Record options: <br>
id position string</p>

<p style="margin-top: 1em">rid position regexp <br>
Identifies a record in the input file. Records are
identified by the string or by the regular expression in
regexp in input record position position. For fixed length
and <br>
binary input the position is the byte position of the input
record and for separated input the position means the
position&rsquo;th field of the input record. Positions start
<br>
from one.</p>

<p style="margin-top: 1em">Id&rsquo;s are required only if
input structure contains several record types with equal
lengths or field counts. Non printable characters can be
escaped as where nn is the <br>
hexadecimal value of the character.</p>

<p style="margin-top: 1em">A record definition can contain
several id&rsquo;s, then all id&rsquo;d must match the input
line (id&rsquo;s are combined with logical and).</p>

<p style="margin-top: 1em">In a multi-record binary
structure every record must have at least one id.</p>

<p style="margin-top: 1em">field name|FILLER|* [length]|*
[lookup]|* [output] <br>
Specifies one field in a text input structure. length is
mandatory for fixed length input structure except for the
last field. If the last field of a fixed length input <br>
structure has a * in place of length then the last field can
have arbitrary length.</p>

<p style="margin-top: 1em">Length is also used for printing
fields in fixed length format using the %D or %D directive.
The order of fields in configuration file is essential, it
specifies the field <br>
order in a record.</p>

<p style="margin-top: 1em">If &rsquo;*&rsquo; is given
instead of the name, then the &rsquo;name&rsquo; will be the
ordinal number of the field, or if the &rsquo;header&rsquo;
option has value &rsquo;first&rsquo; or &rsquo;all&rsquo;,
then the name of the <br>
field will taken from the header line (first line of the
input).</p>

<p style="margin-top: 1em">If lookup is given then the
fields contents is used to make a lookup in lookup table
lookup. If length is not needed (separated format) but
lookup is needed, use asterisk <br>
(*) in place of length definition.</p>

<p style="margin-top: 1em">If output is given field is
printed using output output. Use asterisk in place of lookup
if lookup is not needed.</p>

<p style="margin-top: 1em">Naming the field as FILLER
causes field not to be printed in output.</p>

<p style="margin-top: 1em">field name|FILLER|*
[length]|type [lookup]|* [output] <br>
Specifies one field in a binary input structure. All other
features are same as for the text structure except the type
parameter. type specifies field data type and <br>
length and can have the following values:</p>

<p style="margin-top: 1em">char Printable character.</p>

<p style="margin-top: 1em">short Short integer having
current system length and byte order.</p>

<p style="margin-top: 1em">int Integer having current
system length and byte order.</p>

<p style="margin-top: 1em">long Long integer having current
system length and byte order.</p>

<p style="margin-top: 1em">llong Long long integer having
current system length and byte order.</p>

<p style="margin-top: 1em">ushort Unsigned short integer
having current system length and byte order.</p>

<p style="margin-top: 1em">uint Unsigned integer having
current system length and byte order.</p>

<p style="margin-top: 1em">ulong Unsigned long integer
having current system length and byte order.</p>

<p style="margin-top: 1em">ullong Unsigned long long
integer having current system length and byte order.</p>

<p style="margin-top: 1em">int8 8 bit integer.</p>

<p style="margin-top: 1em">int16_be Big endian 16 bit
integer.</p>

<p style="margin-top: 1em">int32_be Big endian 32 bit
integer.</p>

<p style="margin-top: 1em">int64_be Big endian 64 bit
integer.</p>

<p style="margin-top: 1em">int16_le Little endian 16 bit
integer.</p>

<p style="margin-top: 1em">int32_le Little endian 32 bit
integer.</p>

<p style="margin-top: 1em">int64_le Little endian 64 bit
integer.</p>

<p style="margin-top: 1em">uint8 Unsigned 8 bit
integer.</p>

<p style="margin-top: 1em">uint16_be Unsigned big endian 16
bit integer.</p>

<p style="margin-top: 1em">uint32_be Unsigned big endian 32
bit integer.</p>

<p style="margin-top: 1em">uint64_be Unsigned big endian 64
bit integer.</p>

<p style="margin-top: 1em">uint16_le Unsigned little endian
16 bit integer.</p>

<p style="margin-top: 1em">uint32_le Unsigned little endian
32 bit integer.</p>

<p style="margin-top: 1em">uint64_le Unsigned little endian
64 bit integer.</p>

<p style="margin-top: 1em">float Float having current
system length and byte order.</p>

<p style="margin-top: 1em">float_be Float having current
system length and big endian byte order.</p>

<p style="margin-top: 1em">float_le Float having current
system length and little endian byte order.</p>

<p style="margin-top: 1em">double Double having current
system length and byte order.</p>

<p style="margin-top: 1em">double_be Double having current
system length and big endian byte order.</p>

<p style="margin-top: 1em">double_le Double having current
system length and little endian byte order.</p>

<p style="margin-top: 1em">bcd_be_len Bcd number having
length len and nybbles in big endian order.</p>

<p style="margin-top: 1em">bcd_le_len Bcd number having
length len and nybbles in little endian order.</p>

<p style="margin-top: 1em">hex_be_len Hexadecimal data in
big endian order having length len.</p>

<p style="margin-top: 1em">hex_le_len Hexadecimal data in
little endian order having length len.</p>

<p style="margin-top: 1em">If length is given instead of
the type, then the field is assumed to be a printable string
having length length. String is printed until length
characters are printed or <br>
NULL character is found.</p>

<p style="margin-top: 1em">Bcd number (bcd_be_len and
bcd_le_len) is printed until len bytes are read or a nybble
having hexadecimal value f is found. Bcd number having big
endian order is printed <br>
in order: most significant nybble first and least
significant nybble second and bcd number having little
endian order is printed in order: least significant nybble
first <br>
and most significant nybble second. Bytes are always read in
big endian order.</p>

<p style="margin-top: 1em">Hexadecimal data (hex_be_len and
hex_le_len) is printed as hexadecimal values. Big endian
data is printed starting from the lower address and little
endian data starting <br>
from the upper address.</p>

<p style="margin-top: 1em">field-count number <br>
Same effect as having field * number times. Because length
is not specified, this works only with separated
structure.</p>

<p style="margin-top: 1em">fields-from record <br>
Fields for this record are the same as for record
record.</p>

<p style="margin-top: 1em">output name <br>
This record is printed according output format name. Default
is to use output format specified in the structure.</p>

<p style="margin-top: 1em">level number [element_name|*]
[group_name] <br>
Level can be used if the contents of a file should be
printed as hierarchical multi-level nested form document.
Use * instead of the element name if it is not needed.
num&acirc; <br>
ber is the level of the record, starting from number one
(highest level), element_name is the name for the record,
group_name is used to group records in the same and <br>
lower levels. Only number is mandatory parameter.</p>

<p style="margin-top: 1em">record-length strict|minimum</p>

<p style="margin-top: 1em">strict Input record length and
field count must match the record definition in order to get
it processed. This is default value.</p>

<p style="margin-top: 1em">minimum Input record length and
field count can be the same or longer as defined for the
record. The rest of the input line is ignored.</p>

<p style="margin-top: 1em">Output definitions <br>
There can be several output definitions in the configuration
file. Format can be selected with &rsquo;-p&rsquo; option.
Default format is named as &rsquo;default&rsquo;.</p>

<p style="margin-top: 1em">output name|default {options...}
<br>
Defines one output format. Output named as
&rsquo;default&rsquo; will be used if none is given for
structure or record, or none is given with option
&rsquo;-p&rsquo;.</p>

<p style="margin-top: 1em">There is two predefined output
formats no and raw. no suppresses all printing and raw
prints the original input data.</p>

<p style="margin-top: 1em">Output options <br>
Pictures in output definition can contain printf-style
%-directives:</p>

<p style="margin-top: 1em">%f Name of the input file.</p>

<p style="margin-top: 1em">%s Name of the current
structure.</p>

<p style="margin-top: 1em">%r Name of the current
record.</p>

<p style="margin-top: 1em">%o Input record number in
current file.</p>

<p style="margin-top: 1em">%O Input record number starting
from the first file.</p>

<p style="margin-top: 1em">%i Byte offset of the current
record in the current file. Starts from zero.</p>

<p style="margin-top: 1em">%I Byte offset of the current
record starting from the first file. Starts from zero.</p>

<p style="margin-top: 1em">%n Field name.</p>

<p style="margin-top: 1em">%t Field contents, without
leading and trailing whitespaces.</p>

<p style="margin-top: 1em">%d Field contents. Binary
integer is printed as a decimal value. Floating point number
is printed in the style [-]ddd.ddd, where the number of
digits after the decimal-point <br>
character is 6. Bcd number is printed as a decimal number
and hexadecimal data as consecutive hexadecimal values.</p>

<p style="margin-top: 1em">%D Field contents, right padded
to the field length (requires length definition for the
field).</p>

<p style="margin-top: 1em">%C Field contents, right padded
to the field length (requires length definition for the
field). Output field is cutted if input field is longer that
field length.</p>

<p style="margin-top: 1em">%x Unsigned hexadecimal value of
a binary integer. Other fields are printed using directive
%d.</p>

<p style="margin-top: 1em">%l Value from lookup.</p>

<p style="margin-top: 1em">%L Value from lookup, right
padded to the field length (requires length definition for
the field).</p>

<p style="margin-top: 1em">%e Does not print anything,
causes still the &quot;field empty&quot; check to be
performed. Can be used when only the names of non-empty
fields should be printed.</p>

<p style="margin-top: 1em">%p Fields start position in a
record. For fixed structure this is field&rsquo;s byte
position in the input line and for separated structure this
is the ordinal number of the field. <br>
Starts from one.</p>

<p style="margin-top: 1em">%h Hexadecimal dump of a field.
Byte values are printed as consecutive xnn values, where the
nn is the hexadecimal value of a byte. Data is printed
before any endian conver&acirc; <br>
sion.</p>

<p style="margin-top: 1em">%g Group name given by the
keyword group_name in record definition.</p>

<p style="margin-top: 1em">%m Element name given by the
keyword element_name in record definition.</p>

<p style="margin-top: 1em">%% Percent sign.</p>

<p style="margin-top: 1em">file_header picture <br>
Picture is printed once before file contents.</p>

<p style="margin-top: 1em">file_trailer picture <br>
Picture is printed once after file contents.</p>

<p style="margin-top: 1em">header picture <br>
If specified, then the header line describing the field
names is printed before records. Every field name is printed
according the picture using the same separator and <br>
fields length as defined for the fields. Picture can contain
only %n directive.</p>

<p style="margin-top: 1em">data picture <br>
Field contents is printed according picture.</p>

<p style="margin-top: 1em">lookup picture <br>
If field is mapped to lookup table, this picture will be
used instead of picture from data option. If not given, then
picture from data will be used.</p>

<p style="margin-top: 1em">separator string <br>
All fields are terminated by string, except the last field
of the record. Default is not to print separator.</p>

<p style="margin-top: 1em">record_header picture <br>
picture is printed before the record content. Default is not
to print header.</p>

<p style="margin-top: 1em">record_trailer picture <br>
picture is printed after the record content. Default is
newline.</p>

<p style="margin-top: 1em">justify left|right|char <br>
Fields are left or right justified. char justifies output
according the first occurrence of char in the data picture.
Default is left.</p>

<p style="margin-top: 1em">indent string <br>
Record contents is intended by string. Field contents is
intended by two times the string. Default is not to
indent.</p>

<p style="margin-top: 1em">field-list name1,name2,... <br>
Only fields or constants named as name1,name2,... are
printed, same effect as has &rsquo;-f&rsquo; option. Default
is to print all the fields. Fields are also printed in the
same <br>
order as they are listed.</p>

<p style="margin-top: 1em">no-data-print yes|no <br>
When set as no and field-list is given, suppresses printing
of record_header and record_trailer in case where current
record contains none of the fields specified in <br>
field-list.</p>

<p style="margin-top: 1em">field-empty-print yes|no <br>
When set as no, nothing is printed for fields which consist
entirely of characters from empty-chars. If none of the
fields of a record are printed then the printing of <br>
record_trailer is also suppressed. Default is yes.</p>

<p style="margin-top: 1em">empty-chars string <br>
string specifies a set of characters which define an
&quot;empty&quot; field. Default is &quot; race, form-feed,
newline, carriage return, horizontal tab and vertical
tab).</p>

<p style="margin-top: 1em">output-file file <br>
Output is written to file instead of the default output. If
- is given the standard output is used.</p>

<p style="margin-top: 1em">group_header string <br>
If a record has a level and group name defined, string is
printed before the first record in the same group or if the
group name has changed in the same level</p>

<p style="margin-top: 1em">group_trailer string <br>
If a record has a level and group name defined, string is
printed after the records in lower levels or if the group
name has changed in the same level or if a higher level <br>
record is found.</p>

<p style="margin-top: 1em">element_header string <br>
If record has a level and header name defined, string is
printed before the records contents.</p>

<p style="margin-top: 1em">element_header string <br>
If record has a level and header name defined, string is
printed after the records contents.</p>

<p style="margin-top: 1em">hex-caps yes|no <br>
Print hexadecimal numbers in capital letters. Default is
no.</p>

<p style="margin-top: 1em">Lookup definitions <br>
lookup name {options...} <br>
Defines one lookup table.</p>

<p style="margin-top: 1em">Lookup options: <br>
search exact|longest <br>
The search type for lookup table.</p>

<p style="margin-top: 1em">default-value value <br>
value is printed if the lookup is not successful.</p>

<p style="margin-top: 1em">pair key value <br>
One key/value pair for the lookup table.</p>

<p style="margin-top: 1em">file name [separator] <br>
Key/value pairs are read from file name. Every line is
considered as a key/value pair separated by separator.
Default separator is semicolon.</p>

<p style="margin-top: 1em">Constants <br>
Additional to input fields constants values can be printed
using option -f,--field-list or output option field-list.
Constant will be printed using data output option.</p>

<p style="margin-top: 1em">Constants are specified as</p>

<p style="margin-top: 1em">const name value <br>
when the name appears in a field list, value will be printed
for every record as the name were one of the input
fields.</p>

<p style="margin-top: 1em">Input Preprocessor <br>
It is possible to define an input preprosessor for ffe. An
input preprocessor is simply an executable program which
writes the contents of the input file to standard output
which <br>
will be read by ffe. If the input preprosessor does not
write any characters on its standard output, then ffe uses
the original file.</p>

<p style="margin-top: 1em">To set up an input preprocessor,
set the FFEOPEN environment variable to a command line which
will invoke your input preprocessor. This command line
should include one occurrence <br>
of the string %s, which will be replaced by the input
filename when the input preprocessor command is invoked.</p>

<p style="margin-top: 1em">The input preprocessor is not
used if ffe is reading standard input.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Example of fixed length flat file containing fields
&rsquo;FirstName&rsquo;,&rsquo;LastName&rsquo; and
&rsquo;Age&rsquo;:</p>

<p style="margin-top: 1em">John Ripper 23 <br>
Scott Tiger 45 <br>
Mary Moore 41</p>

<p style="margin-top: 1em">This file can be printed in XML
with the following configuration:</p>

<p style="margin-top: 1em">structure personnel { <br>
type fixed <br>
output XML <br>
record person { <br>
field FirstName 9 <br>
field LastName 13 <br>
field Age 2 <br>
} <br>
}</p>

<p style="margin-top: 1em">output XML { <br>
file_header &quot;&lt;?xml version= <br>
data &quot;&lt;%n&gt;%d&lt;/%n&gt;0 <br>
record_header &quot;&lt;%r&gt;0 <br>
record_trailer &quot;&lt;/%r&gt;0 <br>
indent &quot; &quot; <br>
}</p>

<p style="margin-top: 1em">SEE ALSO <br>
More examples in Texinfo manual. If the info and ffe are
properly installed, the command</p>

<p style="margin-top: 1em">info ffe</p>

<p style="margin-top: 1em">should give more
information.</p>

<p style="margin-top: 1em">AUTHOR <br>
Timo Savinen &lt;tjsa@iki.fi &gt;</p>

<p style="margin-top: 1em">Timo Savinen 2011-04-06
FFE(1)</p>
<hr>
</body>
</html>
