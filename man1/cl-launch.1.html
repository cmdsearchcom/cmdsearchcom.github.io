<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:58:58 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CL-LAUNCH(1) Shell Scripting with Common Lisp
CL-LAUNCH(1)</p>

<p style="margin-top: 1em">Name <br>
cl-launch - shell wrapper for Common Lisp</p>

<p style="margin-top: 1em">Synopsis <br>
cl [options] &Acirc;&acute;(lisp (form) to
evaluate)&Acirc;&acute; <br>
evaluate specified form, print the results followed by
newline <br>
as in: cl -l sbcl -sp my-system-and-package
&Acirc;&acute;(some form)&Acirc;&acute;</p>

<p style="margin-top: 1em">cl [options] script-file
arguments... <br>
run specified Lisp script, passing arguments, as in a script
with <br>
#!/usr/bin/cl -sp my-system-and-package -E main</p>

<p style="margin-top: 1em">cl [options] [--execute]
[options] [-- arguments...] <br>
run the specified software without generating a script
(default)</p>

<p style="margin-top: 1em">cl [options] --output EXECUTABLE
[options] <br>
generate an executable script or binary from the software
specification</p>

<p style="margin-top: 1em">Special modes <br>
-h or -? --help display a short help message <br>
-H --more-help show complete help (you may use a $PAGER)
<br>
-V --version display cl-launch version and configuration
<br>
-u FILE --update FILE update a cl-launch script to current
version</p>

<p style="margin-top: 1em">Software specification <br>
-w CODE --wrap CODE shell wrapper CODE to run in cl-launch
<br>
-l LISP... --lisp LISP... try use these LISP implementations
<br>
-m IMAGE --image IMAGE build from Lisp image IMAGE <br>
-f FILE --file FILE include lisp FILE while building <br>
-L FILE --load FILE load lisp FILE while building <br>
-S X --source-registry X override source registry of asdf
systems <br>
-s SYSTEM --system SYSTEM load asdf SYSTEM while building
<br>
--load-system SYSTEM same as above (buildapp compatibility)
<br>
-p PACKAGE --package PACKAGE change current package to
PACKAGE <br>
-sp SP --system-package SP combination of -s SP and -p SP
<br>
-e FORM --eval FORM evaluate FORM while building <br>
--require MODULE require MODULE while building <br>
-DE N/F --dispatched-entry N/F if exec&Acirc;&acute;ed as N,
restart from (F argv) <br>
-i FORM --init FORM evaluate FORM at restart <br>
-ip FORM --print FORM evaluate and princ FORM at restart
<br>
-iw FORM --write FORM evaluate and write FORM at restart
<br>
-r FUNC --restart FUNC complete restart by calling (FUNC)
<br>
-E FUNC --entry FUNC complete restart by calling (FUNC argv)
<br>
-F FORM --final FORM evaluate FORM before dumping IMAGE <br>
-I PATH --include PATH runtime PATH to cl-launch
installation <br>
+I --no-include disable cl-launch installation feature <br>
-R --rc try read /etc/cl-launchrc, ~/.cl-launchrc <br>
+R --no-rc skip /etc/cl-launchrc, ~/.cl-launchrc <br>
-Q --quicklisp use quicklisp (see --more-help) <br>
+Q --no-quicklisp do not use quicklisp <br>
-b --clbuild use clbuild (see --more-help) <br>
+b --no-clbuild do not use clbuild <br>
-v --verbose be quite noisy while building <br>
-q --quiet be quite quiet while building (default)</p>

<p style="margin-top: 1em">Output options <br>
-x -o ! --execute run the specified software NOW (default)
<br>
-o FILE --output FILE create executable FILE <br>
-d IMAGE --dump IMAGE dump IMAGE for faster startup <br>
-X ... -- (see more help) use #!/.../cl-launch as script
interpreter <br>
-- -- end of arguments when using -x or -X</p>

<p style="margin-top: 1em">Invocation of cl-launch <br>
cl-launch will evaluate Common Lisp code or create shell
scripts or executable binaries that evaluate Common Lisp
code. cl-launch follows the invocation conventions of both
Unix <br>
script interpreters and Common Lisp implementations.</p>

<p style="margin-top: 1em">A suggested short-hand name for
cl-launch is cl (you may create a symlink if it
isn&Acirc;&acute;t included in your operating
system&Acirc;&acute;s cl-launch package). We&Acirc;&acute;d
like to homestead the path <br>
/usr/bin/cl while we can, so that script authors can
reasonably expect a script to work when it starts with:</p>

<p style="margin-top: 1em">&lsquo;#!/usr/bin/cl&lsquo;</p>

<p style="margin-top: 1em">(See Simple cl-launch scripts
below for caveats with #! scripts though.) Recent Linux
kernels support a script interpreter itself being a script;
BSD kernels don&Acirc;&acute;t and require a <br>
small C program cl-shim to be compiled and installed as
/usr/bin/cl to use cl-launch this way.</p>

<p style="margin-top: 1em">To work properly, cl-launch
4.1.4 depends on ASDF 3.1.2 or later, and on its portability
layer UIOP, to manage compilation and image life cycle.</p>

<p style="margin-top: 1em">The software is specified as the
evaluation of code in several phases; the distinction
matters most for creating executable binaries, but
understanding the evaluation model can <br>
avoid surprises in other cases too.</p>

<p style="margin-top: 1em">In the first phase, the Lisp
image is initialized:</p>

<p style="margin-top: 1em">&Acirc;&middot; optionally
having your Lisp start from a Lisp IMAGE (option -I
--image)</p>

<p style="margin-top: 1em">&Acirc;&middot; loading a small
header of code that provides common cl-launch
functionality</p>

<p style="margin-top: 1em">&Acirc;&middot; loading ASDF3.
The cl-launch header will try hard to load ASDF 3.1.2 or
later. If your implementation does not provide it via
(require &quot;asdf&quot;), you can configure your
imple&acirc; <br>
mentation&Acirc;&acute;s ASDF (if any) to find it. Or you
can put it in your home, under ~/common-lip/asdf/ and
cl-launch will find it. Or it may be installed in
/usr/share/com&acirc; <br>
mon-lisp/source/cl-asdf/ in which case cl-launch will also
find it. Failing any of the above, cl-launch will be unable
to proceed.</p>

<p style="margin-top: 1em">&Acirc;&middot; optionally
loading quicklisp http://beta.quicklisp.org/ (option -Q
--quicklisp)</p>

<p style="margin-top: 1em">In a second phase, your software
is built, based on the following options, in order of
appearance:</p>

<p style="margin-top: 1em">&Acirc;&middot; evaluating one
or several FORMS (option -e --eval) in the current package.
The series of forms is evaluated as by LOAD, in a context
where the *package* has been set to the <br>
current package (see below explanations on packages).</p>

<p style="margin-top: 1em">&Acirc;&middot; compiling a FILE
and load the fasl (option -L --load) Files are loaded with
*package* bound to the current package (see below).</p>

<p style="margin-top: 1em">&Acirc;&middot; including a
FILE, compiling it and loading the fasl (option -f --file)
The contents of the FILE, which will have be included in the
output script, will be compiled and the <br>
fasl loaded as if by option -L --load. The difference
matters mostly when creating an output script, as opposed to
executing the code immediately or dumping an image. Only
<br>
one file may be specified this way. If a filename specified
with -f --file is - (after stripping quotes), then the
standard input is used. You may thus concatenate several
<br>
files and feed them to cl-launch through a pipe. To use a
file named -, pass the argument ./- (same trick as for cat
and other Unix commands).</p>

<p style="margin-top: 1em">&Acirc;&middot; A script file,
as specified by -X ... -- or by use of #! or by following
options with an immediate filename that does not start with
( or -, counts as if preceded by --pack&acirc; <br>
age cl-user --load and followed by --execute --</p>

<p style="margin-top: 1em">&Acirc;&middot; requiring an
implementation-provided MODULE (option --require)</p>

<p style="margin-top: 1em">&Acirc;&middot; having ASDF3
compile and load a SYSTEM (option -s --system
--load-system). Option -sp --system-package loads the SYSTEM
like -s --system and also changes the current *pack&acirc;
<br>
age* like -p --package (see below on packages).</p>

<p style="margin-top: 1em">&Acirc;&middot; optionally
having your Lisp DUMP an image to restart from (option -d
--dump), and just before evaluating one or several FINAL
forms (option -F --final). See section Dumping <br>
images.</p>

<p style="margin-top: 1em">If you are creating a shell
script with option -o --output but without using option -d
--dump, then these first two phases only happen when the
script is invoked. If you are <br>
using option -d --dump, then these two phases happen
immediately, and no compilation happen when invoking the
output. Note that compiled files are cached, so that the
compilation <br>
only happens the first time a file is loaded via --load of
--system, or if the source file has been modified. This may
cause slower startup the first time over. The cache is
con&acirc; <br>
trolled by ASDF&Acirc;&acute;s output-translations
mechanism. See your ASDF manual regarding the configuration
of this cache, which is typically under
~/.cache/common-lisp/</p>

<p style="margin-top: 1em">In a third phase, your software
is run via UIOP:RESTORE-IMAGE. This happens immediately if
using option -x --execute or calling cl-launch as a Unix
interpreter on a script e.g. <br>
via #!; or it can happen later if you use option -o --output
in combination with (or without) option -d --dump to dump an
image (which gives you faster startup and single-file or
<br>
double-file delivery, at the expense of disk space), at
which point it happens when you invoke the executable output
file:</p>

<p style="margin-top: 1em">&Acirc;&middot; Hooks from
ASDF3&Acirc;&acute;s UIOP:*IMAGE-RESTORE-HOOK* are called
(in FIFO order).</p>

<p style="margin-top: 1em">&Acirc;&middot; a series of
FORMS specified via options -i --init, -ip --print, -iw
--write, stored as a text string, are read and evaluated in
order of appearance, each in the context of <br>
the package that was current at the time it was requested.
(Concatenated together with separating whitespace, these
forms constitute the UIOP:*IMAGE-PRELUDE* as handled by <br>
RESTORE-IMAGE). Arguments that start with an open
parenthesis are assumed to be FORMS that follow an implicit
--print. Loading from a stream means you don&Acirc;&acute;t
have to worry <br>
about nasty read-time issues; forms will be read by the
fully built Lisp image; however it also means that if you
care a lot about the very last drop of startup delay when
<br>
invoking a dumped image, you&Acirc;&acute;ll only use option
-r --restart or -E --entry and avoid using --init and its
variants. Option -ip --print specifies FORMS such that the
result of <br>
the last form will be printed as if by PRINC, followed by a
newline. Option -iw --write is similar to --print, using
WRITE instead of PRINC.</p>

<p style="margin-top: 1em">&Acirc;&middot; An optional
FUNCTION provided option -r --restart or -E --entry is
invoked after all init forms. If the function was provided
with option -r --restart (compatible with ear&acirc; <br>
lier versions of cl-launch), it will be called with no
argument. If it was provided with option -E --entry
(compatible with buildapp), it will be called with one
argument, <br>
being the list of arguments passed to the program, not
including argv[0], which is available on most
implementations via the function uiop:argv0 (available in
ASDF 3.1.2 and <br>
later). Using either option, the argument may be a function
name or a lambda expression, that is read from the current
package (see below option -p --package and -sp --sys&acirc;
<br>
tem-package). Only one restart or entry function may be
specified; if multiple are provided, the last one provided
overrides previous ones. If you want several functions to
<br>
be called, you may DEFUN one that calls them and use it as a
restart, or you may use multiple init forms as below. See
also below options -DE --dispatch-entry, -sm --sys&acirc;
<br>
tem-main, -Ds --dispatch-system that behave as if -E --entry
had been specified among other things.</p>

<p style="margin-top: 1em">&Acirc;&middot; If neither
restart nor entry function is provided, the program will
exit with status 0 (success). If a function was provided,
the program will exit after the function returns <br>
(if it returns), with status 0 if and only if the primary
return value of result is generalized boolean true, and with
status 1 if this value is NIL. See documentation for <br>
UIOP:RESTORE-IMAGE for details.</p>

<p style="margin-top: 1em">The current package can be
controlled by option -p --package and its variant -sp
--system-package that also behaves like -s --system. All
forms passed to --eval, --init, --print, <br>
--write, --final, --restart, --entry, etc., are read in the
current package. Files specified with -f --file --load are
read in the current package. Current means the package <br>
specified by the latest option -p --package or -sp
--system-package preceding the option being processed, or
cl-user if there was none. Note that multiple -i --init or
-F --final <br>
forms may be evaluated consecutively after a package has
been changed, and that if one of these form itself modifies
the package, or some other syntax control mechanism such as
<br>
the reader, it may adversely affect later forms in the same
category, but not those in other categories (if
reached).</p>

<p style="margin-top: 1em">The following derived options
work as if by a combination of simpler options:</p>

<p style="margin-top: 1em">&Acirc;&middot; As mentioned
above, option -sp --system-package combines --system and
--package in one option, so that given the argument SYSTEM,
the system is loaded as if by --system SYS&acirc; <br>
TEM that creates a package SYSTEM that then becomes the
current package.</p>

<p style="margin-top: 1em">&Acirc;&middot; If option -DE
--dispatch-entry is used, then the next argument must follow
the format NAME/ENTRY, where NAME is a name that the program
may be invoked as (the basename of the <br>
uiop:argv0 argument), and ENTRY is a function to be invoked
as if by --entry when that is the case. If the ENTRY is left
out, function main in current package is used. Sup&acirc;
<br>
port for option -DE --dispatch-entry is delegated to a
dispatch library, distributed with cl-launch but not part of
cl-launch itself, by (1) registering a dependency on the
<br>
dispatch library as if by --system cl-launch/dispatch (if
not already) (2) if neither --restart nor --entry was
specified yet, registering a default entry function as if by
<br>
--entry cl-launch/dispatch:dispatch-entry. (3) registering a
build-form that registers the dispatch entry as if by --eval
&Acirc;&acute;(cl-launch/dispatch:register-name/entry <br>
&quot;NAME/ENTRY&quot; :PACKAGE)&Acirc;&acute; where PACKAGE
is the current package. See the documentation of said
library for further details.</p>

<p style="margin-top: 1em">&Acirc;&middot; If option -Ds
--dispatch-system is used with SYSTEM as its argument, it is
as if option -s --system had been used with the same
argument, followed by option -DE --dis&acirc; <br>
patch-entry for the basename of the system (last / (slash)
separated component of the system name) and the function
main in the package of the system, but without otherwise
<br>
changing the current package.</p>

<p style="margin-top: 1em">&Acirc;&middot; If option -sm
--system-main is used with SYSTEM as its argument, it is as
if option -s --system had been used with the same argument,
followed by option -E --entry with the <br>
main function in the package of the system, but without
otherwise changing the current package.</p>

<p style="margin-top: 1em">General note on cl-launch
invocation: options are processed from left to right;
usually, repeated options accumulate their effects, with the
earlier instances taking effect <br>
before latter instances. In case of conflicting or redundant
options, the latter override the former.</p>

<p style="margin-top: 1em">cl-launch defines a package
cl-launch that exports the following symbol:
compile-and-load-file Runtime functionality formerly
provided by cl-launch is now provided by UIOP, the <br>
portability layer provided by ASDF3. See below section
cl-launch runtime API.</p>

<p style="margin-top: 1em">When the first non-recognized
option is a filename, cl-launch will try to load this
filename as a script, as if by --load, then execute it
immediately as if by --execute --, with <br>
the rest of the command line passed as arguments. The file
name may not start with the character - or a ( --- To use a
file with one of these (or something unknown) as a first
<br>
character, prepend ./ to the filename. Note that it is a
security risk to let adversaries control the names of files
passed to cl-launch or other commands.</p>

<p style="margin-top: 1em">When option --execute is
specified, the specified software is executed. Command-line
arguments may be given to software being executed by putting
them after a special marker --, <br>
that ends cl-launch option processing.</p>

<p style="margin-top: 1em">When option --output FILE is
used, code will be generated into the specified FILE. The
output file itself will be created atomically from complete
generated contents and may thus <br>
have the same pathname as the input file. The restart
function and init forms will not be evaluated, but kept for
when the output file is executed. If - (after quoting) is
speci&acirc; <br>
fied, then the standard output is used. If ! (after quoting)
is specified, then option --execute is assumed.</p>

<p style="margin-top: 1em">When no --output file is
specified, option --execute is implicitly assumed. The last
--output or --execute option takes precedence over the
previous ones.</p>

<p style="margin-top: 1em">If only one argument exists and
it doesn&Acirc;&acute;t start with - then the argument is
considered as if given to option -ip, to be evaluated and
printed immediately.</p>

<p style="margin-top: 1em">The ASDF3 source-registry
configuration can be overridden with option
--source-registry SOURCE_REGISTRY. The provided
configuration will take priority over anything provided by
<br>
the environment or configuration files, though it may
inherit from them as usual. See the ASDF3 manual about
that.</p>

<p style="margin-top: 1em">Options -l --lisp and -w --wrap
may be used to control the way that a Common Lisp
implementation is found when the software is run. Option -l
--lisp specifies the list of imple&acirc; <br>
mentations to try to use; the list is whitespace-separated,
and consists in nicknames recognized by cl-launch. Option -w
--wrap supplies arbitrary code to be evaluated by the <br>
shell wrapper, after it has read its configuration and
defined its internal functions, but before it tries to find
and run a Lisp implementation. Such wrapper code is
typically <br>
used to modify the variables that control the run-time
behaviour of generated scripts, as documented below. Use of
other internals of cl-launch is possible, but not supported,
<br>
which means that it is your responsibility to keep a copy of
the specific version of cl-launch with which your code works
and to update your code if you later make an upgrade to <br>
an incompatible cl-launch. For instance, --lisp &quot;foo
bar&quot; is equivalent to --wrap
&Acirc;&acute;LISPS=&quot;foo bar&quot;&Acirc;&acute;. See
below the documentation section on Lisp implementation
invocation.</p>

<p style="margin-top: 1em">Option --no-include specifies
that cl-launch should generate a standalone script that
includes the configuration, shell wrapper, Lisp header, and
user-provided Lisp code (from <br>
--file). If you can rely on the presence of a recent Lisp
implementation that provides ASDF, then the script is pretty
much standalone indeed and may be moved around the
filesys&acirc; <br>
tem and still used. However the size of the output will be
the size of the user Lisp code plus about 36KiB.</p>

<p style="margin-top: 1em">Option --include PATH specifies
that cl-launch should generate a very small script
(typically under 1KiB) that when run will read the cl-launch
shell wrapper and Lisp header from <br>
a specified installation directory PATH. Also, if option
--include is used, and Lisp code is specified with --file
and an absolute pathname starting with / as opposed to a
rela&acirc; <br>
tive pathname or to the standard input, then Lisp code will
also be loaded from the specified location at runtime rather
than embedded into the script at generation time. This <br>
option generates leaner scripts, but may not be applicable
when the very same script is to used in a variety of
situations that lack common coherent filesystem
management.</p>

<p style="margin-top: 1em">Which of --include or
--no-include is the default may depend on your cl-launch
installation. The version of cl-launch distributed by the
author uses --no-include by default, but <br>
the version of cl-launch available in your operating system
distribution may rely on a well-managed include path (this
is the case with debian for instance). You may query the
<br>
configuration of an instance of cl-launch with option
--version.</p>

<p style="margin-top: 1em">For instance, one may expect a
debian version of cl-launch to use:</p>


<p style="margin-top: 1em">&lsquo;/usr/share/common-lisp/source/cl-launch/&lsquo;</p>

<p style="margin-top: 1em">as a system-managed include
path. One may also expect that Lisp implementations managed
by the system would come with cl-launch precompiled in Lisp
images. Since cl-launch pro&acirc; <br>
vides feature :cl-launch, and since the cl-launch Lisp
header is conditionalized to not be read with this feature,
this would make cl-launch startup faster, while still
allowing <br>
non-system-managed Lisp implementations to run fine.</p>

<p style="margin-top: 1em">You may create an installation
of cl-launch with such a command as:</p>

<p style="margin-top: 1em">cl-launch --include
/usr/share/common-lisp/source/cl-launch --lisp
&Acirc;&acute;sbcl ccl clisp&Acirc;&acute; --rc --output
/usr/bin/cl-launch -B install</p>

<p style="margin-top: 1em">You can use command -B
install_bin if you only want to configure cl-launch (with a
different default for --lisp but no --include, for
instance), and command -B install_path if <br>
you only want to create support files. Note that the
--backdoor option -B must come last in your invocation.</p>

<p style="margin-top: 1em">Option +R --no-rc specifies that
cl-launch should not try to read resource files
/etc/cl-launchrc and ~/.cl-launchrc.</p>

<p style="margin-top: 1em">Option -R --rc specifies that
cl-launch should try to read resource files /etc/cl-launchrc
and ~/.cl-launchrc. These files are notably useful to define
override the value of <br>
$LISP depending on $SOFTWARE_SYSTEM. A shell function
system_preferred_lisps is provided so that your cl-launchrc
might contain lines as follows:</p>

<p style="margin-top: 1em">system_preferred_lisps stumpwm
cmucl sbcl clisp <br>
system_preferred_lisps exscribe clisp cmucl sbcl</p>

<p style="margin-top: 1em">Beware that for the sake of
parsing option --no-rc, the resource files are run after
options are processed, and that any overriding of internal
variables will thus preempt <br>
user-specified options. A warning will be printed on the
standard error output when such an override happens. Note
that such overrides only happen at script-creation time. A
<br>
script created by cl-launch will not try to read the
cl-launch resource files.</p>

<p style="margin-top: 1em">Option +Q --no-quicklisp
specifies that cl-launch should not use quicklisp. Option -Q
--quicklisp specifies that cl-launch should use quicklisp.
Which is the default depends on <br>
your installation. The default default is +Q. Quicklisp is
loaded from ~/quicklisp/setup.lisp if available, or else
~/.quicklisp/setup.lisp.</p>

<p style="margin-top: 1em">Option -b --clbuild specifies
that cl-launch should rely on clbuild to find and invoke the
Common Lisp implementation. Option +b --no-clbuild specifies
that cl-launch should not <br>
rely on clbuild to find and invoke the Common Lisp
implementation. Which is the default depends on your
installation. The default default is +b.</p>

<p style="margin-top: 1em">Files generated by cl-launch are
made of several well-identifiable sections. These sections
may thus be considered as distinct software, each available
under its own regime of <br>
intellectual property (if any). In case of an accident, you
may still retrieve the exact original code provided with
option --file by stripping the wrapper, as delimited by <br>
well-identified markers. Search for the marker string
&quot;BEGINS HERE:&quot;. Everything after it is not
cl-launch. This can be done automatically with backdoor
option -B <br>
extract_lisp_content. cl-launch uses this functionality
implicitly when embedding a file specified with the option
--file, so that you may process a script previously
generated <br>
by cl-launch and change the options with which it wraps the
embedded Lisp code into runnable software.</p>

<p style="margin-top: 1em">As an alternative, you may also
upgrade a previously generated script to use the current
version of cl-launch while preserving its original wrapping
options with option --update. <br>
In this case, software specification options are ignored.
Output options still apply. Specifying - (after quoting) as
the file to update means to read the contents to be read
<br>
from the standard input. This feature might not work with
scripts generated by very early versions of the cl-launch
utility. It should work with versions later than 1.47.</p>

<p style="margin-top: 1em">Supported Lisp implementations
<br>
The implementations supported by current version of
cl-launch are:</p>

<p style="margin-top: 1em">abcl allegro ccl clisp cmucl ecl
gcl lispworks sbcl scl xcl</p>

<p style="margin-top: 1em">Also defined are aliases:</p>

<p style="margin-top: 1em">clozurecl gclcvs lisp
openmcl</p>

<p style="margin-top: 1em">which are name variations for
ccl, gcl, cmucl and ccl again respectively.</p>

<p style="margin-top: 1em">Fully supported, including
standalone executables:</p>

<p style="margin-top: 1em">sbcl: SBCL 1.2.2 <br>
clisp: GNU CLISP 2.49 <br>
ecl: ECL 13.5.1 <br>
cmucl: CMUCL 20D <br>
ccl: ClozureCL 1.10 <br>
lispworks: LispWorks Professional 7.0.0 (no personal ed,
banner)</p>

<p style="margin-top: 1em">Fully supported, but no
standalone executables:</p>

<p style="margin-top: 1em">gcl (GCL 2.7): GCL 2.7.0 ansi
mode (get a very recent git checkout) <br>
allegro: Allegro 9.0 (also used to work with 5) <br>
scl: Scieneer CL 1.3.9</p>

<p style="margin-top: 1em">Incomplete support:</p>

<p style="margin-top: 1em">abcl: ABCL 1.3.1 (no image
dumping support, but you may use abcl-jar) <br>
xcl: XCL 0.0.0.291 (cannot dump an image) (get a recent
checkout)</p>

<p style="margin-top: 1em">GCL is only supported in ANSI
mode. cl-launch does export GCL_ANSI=t in the hope that the
gcl wrapper script does the right thing as it does in
Debian. Also ASDF3 requires a very <br>
recent GCL 2.7. Note that GCL seems to not be very actively
maintained anymore.</p>

<p style="margin-top: 1em">There are some issues regarding
standalone executables on CLISP. See below in the section
regarding Standalone executables.</p>

<p style="margin-top: 1em">LispWorks requires the
Professional Edition; the Personal Edition
isn&Acirc;&acute;t supported as it won&Acirc;&acute;t let
you either control the command line or dump images. Dumped
images will print a <br>
banner, unless you dump a standalone executable. To dump an
image, make sure you have a license file in your target
directory and/or to
.../lispworks/lib/7-0-0-0/config/lwlicense <br>
(or use a trampoline shell script to exec /path/to/lispworks
&quot;$@&quot;), create a build script with:</p>

<p style="margin-top: 1em">echo
&Acirc;&acute;(hcl:save-image &quot;lispworks-console&quot;
:environment nil)&Acirc;&acute; &gt; si.lisp <br>
lispworks-7-0-0-x86-linux -siteinit - -init - -build
si.lisp</p>

<p style="margin-top: 1em">There is no standard name for a
console-only variant of LispWorks; older versions of
cl-launch assume a default lispworks; since cl-launch
4.1.2.1, lispworks-console is assumed <br>
instead, to avoid conflicts. You can control the name you
use with the shell variable $LISPWORKS, or you can just
leave lispworks-console in your path, and use a symlink,
copy, <br>
shell alias or trivial wrapper script to enable your
favorite shorter name lispworks, lw, lwcon, lw-console,
etc.</p>

<p style="margin-top: 1em">Similarly, a mlisp image for
allegro can be created as follows:</p>

<p style="margin-top: 1em">alisp -e &Acirc;&acute;(progn
<br>
(build-lisp-image &quot;sys:mlisp.dxl&quot; <br>
:case-mode :case-sensitive-lower <br>
:include-ide nil :restart-app-function nil) <br>
(when (probe-file &quot;sys:mlisp&quot;) (delete-file
&quot;sys:mlisp&quot;)) <br>
(sys:copy-file &quot;sys:alisp&quot;
&quot;sys:mlisp&quot;))&Acirc;&acute;</p>

<p style="margin-top: 1em">Additionally, cl-launch supports
the use of clbuild as a wrapper to invoke the Lisp
implementation, with the --clbuild option.</p>

<p style="margin-top: 1em">Supported shells <br>
cl-launch was tested with all of posh 0.4.7, bash 2.05, bash
3.1, zsh 4.3.2, dash 0.5.3 and busybox 1.01 ash.</p>

<p style="margin-top: 1em">Lisp implementation invocation
<br>
When a cl-launch generated script is invoked, the cl-launch
shell wrapper will try to execute the Lisp code with the
first Common Lisp implementation it finds in a given list,
<br>
which can be specified through option --lisp. The runtime
behaviour of the cl-launch shell wrapper is very
configurable through a series of environment variables.
These variables <br>
can be controlled by the user by exporting them in his
environment, or they can be restricted at the time of script
generation by using cl-launch option --wrap.</p>

<p style="margin-top: 1em">If variable LISP is defined, the
shell wrapper will first try the implementation named by
variable LISP. If that fails, it will try the list of
implementations provided at script <br>
generation time. The list of implementations generated will
be the argument to option --lisp if specified. Otherwise,
cl-launch will supply its default value. This default value
<br>
for the current instance of cl-launch is:</p>

<p style="margin-top: 1em">sbcl ccl clisp abcl allegro
lispworks scl cmucl ecl mkcl gcl xcl</p>

<p style="margin-top: 1em">This LISP selection only happens
at system preparation time. If you dump an image then the
script will always use the Lisp implementation for which an
image was dumped. If you <br>
don&Acirc;&acute;t then the user may override the
implementation.</p>

<p style="margin-top: 1em">Note that these are nicknames
built into the cl-launch shell wrapper, and not necessarily
names of actual binary. You may control the mapping of
implementation nickname to actual <br>
binary pathname to call with an environment variable. For a
given implementation nickname, the environment variable will
be the capitalization of the given nickname. Hence,
vari&acirc; <br>
able $SBCL controls where to look for the sbcl
implementation, and variable $CMUCL controls where to look
for the cmucl implementation. If a binary is found with a
matching path&acirc; <br>
name (using the standard unix $PATH as required), then said
implementation will be used, using proper command line
options, that may be overridden with an environment variable
<br>
similar to the previous but with _OPTIONS appended to its
name. Hence, $CMUCL_OPTIONS for cmucl, $CLISP_OPTIONS for
clisp, etc. Sensible defaults are provided for each
implemen&acirc; <br>
tation, so as to execute the software in non-interactive
mode, with debugger disabled, without reading user-specific
configuration files, etc.</p>

<p style="margin-top: 1em">If you want to insist on using a
given implementation with given options, you may use option
--lisp and --wrap, as follows:</p>

<p style="margin-top: 1em">--lisp &Acirc;&acute;sbcl
clisp&Acirc;&acute; --wrap &Acirc;&acute; <br>
LISP= # do not allow the user to specify his implementation
<br>
SBCL=/usr/bin/sbcl # not any experimental thing by the user
<br>
SBCL_OPTIONS=&quot;--noinform --sysinit /dev/null --userinit
/dev/null --disable-debugger&quot; # predictable Lisp state
<br>
CLISP=/usr/bin/clisp # fall back on machines that lack SBCL
<br>
CLISP_OPTIONS=&quot; -norc --quiet --quiet&quot; <br>
# configure ASDF: <br>
CL_SOURCE_REGISTRY=/usr/local/share/common-lisp/source//:
<br>
# assuming precompiled fasls there: <br>
ASDF_OUTPUT_TRANSLATIONS=/my/cl/src:/my/fasl/cache: <br>
&Acirc;&acute;</p>

<p style="margin-top: 1em">If you dump an image, you need
not unset the LISP variable, but you might still want to
override any user-specified SBCL and SBCL_OPTIONS (or
corresponding variables for your <br>
selected implementation) from what the user may specify.</p>

<p style="margin-top: 1em">Note that you can use option
--wrap &quot;$(cat your_script)&quot; to embed into your
program a full fledged script from a file. Your script may
do arbitrary computations before the shell <br>
wrapper is run. It may make some consistency checks and
abort before to run Lisp. Or it may analyze invocation
arguments and make according adjustments to Lisp
implementation <br>
options. This can be useful for setting options that cannot
be set from the Lisp code, such the path to a runtime image,
interactive or non-interactive execution, size of heaps,
<br>
locale settings for source file encoding, etc.</p>

<p style="margin-top: 1em">Reading the source code of
cl-launch can be completely crazy. You may have great fun
understanding why things are how they are and adding
features without breaking anything! How&acirc; <br>
ever, adding support for a new CL implementation should be
straightforward enough: just search the sources for clisp or
sbcl and mimic what I did for them. Be sure to send me <br>
what will get your favorite Lisp flavor of the month
rolling.</p>

<p style="margin-top: 1em">Limited clbuild support <br>
cl-launch 2.12 and later support using clbuild as a wrapper
to configure your Lisp implementation, with option --clbuild
(which can be disabled with option --no-clbuild if it was
<br>
enabled by default in your cl-launch installation).</p>

<p style="margin-top: 1em">Note that when you use clbuild,
you can no longer override implementation options with say
SBCL_OPTIONS, as clbuild takes care of the options for you.
Any implementation banner <br>
will not be removed unless you instruct clbuild to do so.
Also, you cannot use clbuild with a non-executable image
different from clbuild&Acirc;&acute;s, which precludes image
dumping with <br>
cmucl or allegro (allegro could probably be updated, but I
don&Acirc;&acute;t have a recent licence to test and
develop).</p>

<p style="margin-top: 1em">clbuild support is not fully
tested at this point. Please report any bug.</p>

<p style="margin-top: 1em">Simple cl-launch scripts <br>
In simple cases, you may create a Common Lisp shell script
with cl-launch without a script generation step, just
because you&Acirc;&acute;ll spend a lot of time editing the
script and dis&acirc; <br>
tributing it, and little time waiting for script startup
time anyway. This notably is a good idea if
you&Acirc;&acute;re not spawning many instances of the same
version of a script on a given <br>
computer. If that&Acirc;&acute;s what you want, you may use
cl-launch as a script interpret the following way (stripping
leading spaces):</p>

<p style="margin-top: 1em">#!/path/to/cl-launch
...options...</p>

<p style="margin-top: 1em">For instance, you may write the
following script (stripping leading spaces):</p>

<p style="margin-top: 1em">#!/usr/bin/cl --entry main <br>
(defun main (argv) <br>
(format t &quot;Hello, World!~%~S~%&quot; argv))</p>

<p style="margin-top: 1em">On a recent Linux kernel, the
options may include spaces, parentheses, etc., provided they
are quoted as in a shell script. Also, using -X as your very
first option and -- as <br>
your last will ensure that the script works even if its name
starts with a ( or a -, in addition to working with older
versions of cl-launch.</p>

<p style="margin-top: 1em">Note however that Darwin (MacOS
X) and other BSD kernels or old Linux kernels
don&Acirc;&acute;t like the #! interpreter to itself be
interpreted. On these operating system kernels, the
sys&acirc; <br>
tem administrator must compile and install a small shim
written in C, cl-shim.c, that will handle the proper script
invocation.</p>

<p style="margin-top: 1em">Most kernels have restrictions
on how they handle arguments to a #! script, that prevent
e.g. using /usr/bin/env as a trampoline; however, you may
use the fully portable solution <br>
as follows, where the &quot;:&quot; ; ensures that the
script should remain valid bilingual shell and Lisp
code:</p>

<p style="margin-top: 1em">#!/bin/sh <br>
&quot;:&quot; ; exec cl-launch -X -sp my-package -E main --
&quot;$0&quot; ${1+&quot;$@&quot;} || exit</p>

<p style="margin-top: 1em">(Actually &quot;$@&quot; instead
of ${1+&quot;$@&quot;} should work just fine, unless you
have an antique shell.)</p>

<p style="margin-top: 1em">Note that if you
don&Acirc;&acute;t need Lisp code to be loaded from your
script, with everything happening in the build
specification, then you may instead use a simple #!/bin/sh
shell <br>
script from which you:</p>

<p style="margin-top: 1em">exec /path/to/cl-launch -x ...
-- &quot;$@&quot;.</p>

<p style="margin-top: 1em">Also, in case you
can&Acirc;&acute;t rely on cl-launch being at a fixed path,
or if your shell and/or kernel combination
doesn&Acirc;&acute;t support using cl-launch as a script
interpreter, then you may <br>
instead start your script with the following lines:</p>

<p style="margin-top: 1em">#!/bin/sh <br>
&quot;:&quot; ; exec cl-launch -X -- &quot;$0&quot;
&quot;$@&quot; || exit <br>
(format t &quot;It works!~%&quot;)</p>

<p style="margin-top: 1em">Note that a mainline Linux
kernel only supports the recursive #! implicit in
#!/usr/bin/cl-launch since 2.6.27.9.</p>

<p style="margin-top: 1em">Dumping images <br>
You can dump an image (for static compilation and fast
startup) with option --dump IMAGE where IMAGE specifies the
path where the image will be dumped.</p>

<p style="margin-top: 1em">If you use option --include PATH
then the image will be loaded back from that specified
directory instead of the directory where you dumped it. This
is useful if you&Acirc;&acute;re preparing <br>
a script to be installed at another place maybe on another
computer.</p>

<p style="margin-top: 1em">This option is currently
supported on all CL implementations available with
cl-launch.</p>

<p style="margin-top: 1em">As a limitation, LispWorks will
print a banner on standard output, unless you use the
standalone executable option below.</p>

<p style="margin-top: 1em">As another limitation, ECL will
not be able to dump an image when running from a previously
dumped image (with --image). This is because of the link
model of ECL, whereby you&Acirc;&acute;d <br>
need to be able to locate which object files were used in
linking the original image, keep track of these files, and
prepend the list of them to to the object files linked into
<br>
the dump. This is not conceptually impossible and patches
are welcome. However, we hope to support that someday with a
real build system that does it for you, such as XCVB.</p>

<p style="margin-top: 1em">Standalone executables <br>
You can create standalone executables with the option --dump
&Acirc;&acute;!&Acirc;&acute; (or by giving a --dump
argument identical to the --output argument).</p>

<p style="margin-top: 1em">This option is currently only
supported with SBCL, ECL, CLISP, CMUCL, CCL and LispWorks
Professional. Moreover CLISP has the issues below.</p>

<p style="margin-top: 1em">CLISP standalone executables
will react magically if invoked with options such as
--clisp-help or --clisp-x
&Acirc;&acute;(sys::main-loop)&Acirc;&acute;.
That&Acirc;&acute;s a pretty far-fetched thing to hit by
mis&acirc; <br>
take, and the CLISP maintainers consider it a feature (I
don&Acirc;&acute;t). Don&Acirc;&acute;t use such executables
as setuid, and don&Acirc;&acute;t let untrusted users
control arguments given to such executables <br>
that are run with extra privileges.</p>

<p style="margin-top: 1em">cl-launch runtime API <br>
cl-launch provides the following Lisp functions:</p>

<p style="margin-top: 1em">Function
cl-launch:compile-and-load-file takes as an argument a
source pathname designator, and keyword arguments
force-recompile (default NIL) and verbose (default NIL). It
will <br>
arrange to compile the specified source file if it is
explicitly requested, or if the file doesn&Acirc;&acute;t
exist, or if the fasl is not up-to-date. It will compile and
load with the <br>
specified verbosity. It will take use
uiop:compile-file-pathname* to determine the fasl
pathname.</p>

<p style="margin-top: 1em">The following variables and
functions previously provided by cl-launch have the
following replacement from ASDF and UIOP:</p>

<p style="margin-top: 1em">Variable cl-launch:*arguments*
is replaced by uiop:*command-line-arguments*.</p>

<p style="margin-top: 1em">Function cl-launch:getenv is
replaced by uiop:getenv.</p>

<p style="margin-top: 1em">Function cl-launch:load-system
is replaced by asdf:load-system.</p>

<p style="margin-top: 1em">Function cl-launch:quit is
replaced by uiop:quit (beware: the lambda-list is slightly
different).</p>

<p style="margin-top: 1em">Additionally, environment
variables CL_LAUNCH_PID and CL_LAUNCH_FILE will be set to
the process ID and the script invocation filename
respectively.</p>

<p style="margin-top: 1em">Verbose output mode <br>
If the shell variable CL_LAUNCH_VERBOSE is exported and
non-nil, then cl-launch and the scripts it generates will
produce an abundance of output, display such things as the
Lisp <br>
invocation command, compiling and loading files with
:verbose t and :print t, etc. This is only useful for
debugging cl-launch and/or your build process. Option
--verbose sets <br>
this variable, whereas option --quiet resets it.</p>

<p style="margin-top: 1em">Makefile examples <br>
### Automatically download of the current version of
cl-launch if not present <br>
cl-launch.sh: <br>
wget -O cl-launch.sh
http://fare.tunes.org/files/cl-launch/cl-launch.sh <br>
chmod a+x cl-launch.sh</p>

<p style="margin-top: 1em">### Making a shell script
executable from a simple Lisp file named foo.lisp <br>
foo.sh: cl-launch.sh foo.lisp <br>
./cl-launch.sh --output foo.sh --file foo.lisp</p>

<p style="margin-top: 1em">### A more complex example using
all options. <br>
run-foo.sh: cl-launch.sh preamble.lisp <br>
./cl-launch.sh --output run-foo.sh --file preamble.lisp
--system foo --init &quot;(foo:main
uiop:*command-line-arguments*)&quot; --source-registry
${PREFIX}/cl-foo/systems: --lisp &quot;ccl sbcl&quot; --wrap
&Acirc;&acute;SBCL=/usr/local/bin/sbcl-no-unicode&Acirc;&acute;
--no-include</p>

<p style="margin-top: 1em">### An example with horrible
nested makefile, shell and Lisp quoting <br>
hello: <br>
opera=wORlD ; ./cl-launch.sh --execute --init &quot;(format
t</p>

<p style="margin-top: 1em">Caveat Lispor <br>
cl-launch begins evaluation of your Lisp software in the
cl-user package, or whichever package you specify. By the
time your initialization forms are evaluated, the package
may <br>
or may not have changed, depending on the fine-grained
semantics of load. Be sure to use in-package if these things
matter. If you change the readtable, even weirder things may
<br>
happen.</p>

<p style="margin-top: 1em">There are lots of ways of making
mistakes by improperly quoting things when you write shell
commands. cl-launch does the right thing, but you still must
be careful with the <br>
nested quoting mechanisms of make, shell, and Lisp.</p>

<p style="margin-top: 1em">Here is a simple example use of
cl-launch to quickly compare the result of a same
computation on a variety of systems:</p>

<p style="margin-top: 1em">for l in sbcl cmucl clisp gcl
ccl ; do <br>
./cl-launch.sh --lisp $l --execute --init
&Acirc;&acute;(format t &quot;&Acirc;&acute;$l&Acirc;&acute;
~A~%&quot; most-positive-fixnum)&Acirc;&acute; ; done</p>

<p style="margin-top: 1em">Internally, cl-launch includes
many self-test functions. You may for instance try (from a
directory where it may create junk):</p>

<p style="margin-top: 1em">./cl-launch.sh -l
&Acirc;&acute;sbcl cmucl clisp gclcvs&Acirc;&acute; -B
tests</p>

<p style="margin-top: 1em">Share and Enjoy!</p>

<p style="margin-top: 1em">See our web page on:</p>


<p style="margin-top: 1em">&lt;http://www.cliki.net/cl-launch&gt;</p>

<p style="margin-top: 1em">Note: if this help is too long
for you, you may scroll back, or use:</p>

<p style="margin-top: 1em">cl --more-help | less</p>

<p style="margin-top: 1em">Francois-Rene Rideau July 2015
CL-LAUNCH(1)</p>
<hr>
</body>
</html>
