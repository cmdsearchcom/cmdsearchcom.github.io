<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>SEEDD(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">SEEDD(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">SEEDD(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
seedd - read entropy from BitBabbler hardware RNG devices
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>seedd</b> [<i>options</i>]
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <b>seedd</b> program can be run as a foreground process or as a daemon to
  collect entropy from one or more BitBabbler devices, either streaming it to
  <i>stdout</i> for general purpose use, making it available on a UDP socket, or
  directly seeding the kernel entropy pool with it on demand.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="USAGE"><a class="selflink" href="#USAGE">USAGE</a></h1>
The number of configurable options for <b>seedd</b> has now outgrown what most
  people will care about or want to use, which would normally be less than ideal
  for something like this, but it does have a rather diverse range of user
  needs, and it is important that we support those well.
<div style="height: 1.00em;">&#x00A0;</div>
Unless you fall into the special use category, then the following examples are
  probably about all (or still more than) you might ever need:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Show all available BitBabbler devices, in detail:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 seedd -sv (or --scan --verbose)
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Output 1 million bytes to a file, drawn from all available devices:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 seedd -b 1000000 &gt; random-bytes.out
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Stream entropy continuously to <i>stdout</i> (with no control socket):
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 seedd -o -c none | your-thing-reading-stdin
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Run as a daemon, feeding entropy to the OS kernel pool:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 seedd -k -d
<div style="height: 1.00em;">&#x00A0;</div>
To read from only specific devices, add the <b>--device-id</b> option too.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
The following options are available:
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s, --scan</b></dt>
  <dd class="It-tag">Scan the system for available BitBabbler devices, reporting
      them in a human readable format.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --shell-mr</b></dt>
  <dd class="It-tag">Scan the system for available BitBabbler devices, reporting
      them in a machine readable format that is suitable for importing into
      shell scripts.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i, --device-id=</b><i>id</i></dt>
  <dd class="It-tag">Select a BitBabbler device to read from by its unique ID.
      If no devices are explicitly specified then the default is to use all of
      them (including any devices that may be plugged in at a later time).
    <div style="height: 1.00em;">&#x00A0;</div>
    This option may be passed multiple times to attach to multiple devices. It
      is not an error to specify a device that is not currently present on the
      system. If hotplug support was enabled at compile time and available on
      the system at runtime, then such devices will be added to the pool at
      runtime if they are later plugged in.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>id</i> may be the device serial number, or its logical address in the
      form:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     [ <i>busnum</i>:]<i>devnum</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    or on systems where knowing the USB topology is supported, its physical
      address in the form
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     <i>busnum</i>-<i>port</i>[.<i>port</i>&#x00A0;...]
    <div style="height: 1.00em;">&#x00A0;</div>
    For a logical address the <i>busnum</i> part is optional, but if
      <i>devnum</i> is not unique across all buses, then exactly which device
      will be selected if it is not fully specified becomes a matter of chance.
      All of the available IDs which can be used to refer to a device will be
      reported by the <b>--scan</b> option. Bus, device, and port numbers are
      expected to be decimal integers.
    <div style="height: 1.00em;">&#x00A0;</div>
    The logical address isn't usually very useful to use when hotplug activity
      is expected, since it is allocated dynamically and is 'unpredictable' for
      most purposes here.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d, --daemon</b></dt>
  <dd class="It-tag">Fork to the background and run as a daemon process. If this
      option is not specified then <b>seedd</b> will remain in the foreground.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b, --bytes=</b><i>n</i></dt>
  <dd class="It-tag">Send <i>n</i> bytes of entropy to <i>stdout</i>. The
      process will exit when that is completed. This option will be ignored if
      either the <b>--kernel</b> or <b>--udp-out</b> options are used. A suffix
      of 'k', 'M', or 'G' will multiply <i>n</i> by the respective power of two.
      If this option is not used, then entropy will be output until the process
      is explicitly terminated (or receives SIGPIPE). Passing this option
      implies <b>--stdout</b>, and also <b>--control-socket=none</b> unless the
      control socket option is explicitly passed to enable it.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k, --kernel</b></dt>
  <dd class="It-tag">Feed entropy directly to the kernel <i>/dev/random</i> pool
      on demand.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u, --udp-out=</b><i>host</i><b>:</b><i>port</i></dt>
  <dd class="It-tag">Bind a UDP socket to the given address, which clients can
      use to request blocks of entropy directly from the internal pool. The
      <i>host</i> part can be a DNS hostname or address literal. If an IPv6
      address literal is used it should be enclosed in square brackets (e.g.
      [::1]:2020 to bind to port 2020 on the local IPv6 interface). The
      <i>port</i> can be a port number or a service name (as defined in
      <i>/etc/services</i> or other system name-service databases which are
      queried by <b>getaddrinfo</b>(3)).
    <div style="height: 1.00em;">&#x00A0;</div>
    To obtain entropy from this port, write the desired number of bytes to it as
      a two-octet network-order short integer. It will reply with a datagram
      containing the requested number of bytes of entropy. Requests for 1 to
      32768 bytes will be honored as soon as there is sufficient entropy in the
      internal pool to do so. Requests outside of that range are invalid and
      will simply be ignored. Note that no access control is placed on the
      socket, so if it uses a publicly accessible address anyone will be able to
      read entropy from it (and potentially to use it as a traffic amplifier if
      requests use a forged source address).
    <div style="height: 1.00em;">&#x00A0;</div>
    This facility is mainly provided for use on operating systems like Windows,
      where the native interfaces may be of questionable usefulness or quality
      and cannot be audited - but it is generic and so can be used on any system
      where obtaining entropy directly from the BitBabbler devices might be
      desirable. On Linux systems we do recommend using the system
      <i>/dev/(u)random</i> interfaces though, since that will mix in other
      entropy and transparently benefit all existing applications. They aren't
      mutually exclusive though, you can use both this and the <b>--kernel</b>
      option together too.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o, --stdout</b></dt>
  <dd class="It-tag">Stream entropy directly to <i>stdout</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P, --pool-size=</b><i>n</i></dt>
  <dd class="It-tag">Specify the size of the internal entropy pool. Entropy read
      from a BitBabbler will gather in that pool after health and sanity
      checking. When multiple BitBabbler devices are in use, entropy from each
      group of devices will be mixed into it. Entropy read from <i>stdout</i>,
      or the UDP socket, or delivered to the kernel will be drawn from this
      pool. Fresh entropy will continue to be mixed into it while it is not
      being drained faster than it can be filled. The default pool size is 64kB,
      which provides a reasonable balance between what a single BitBabbler
      running at 1Mbps can fill completely about twice per second, and what most
      reasonable consumers might ever want to draw from it 'instantly'. There
      probably aren't many good reasons to make it much larger, but making it
      smaller will increase the number of input bits mixed into each output bit
      if the pool is not being drained completely faster than it can fill. We do
      not rely on this mixing to obtain good quality entropy from each
      BitBabbler device but it doesn't hurt to be mixing more good entropy into
      it while the demand is exceeded by supply.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-G,
    --group-size=</b><i>group_number</i><b>:</b><i>size</i></dt>
  <dd class="It-tag">Set the size of a single pool group. When multiple
      BitBabbler devices are available, there is a choice of whether to optimise
      for throughput or for redundancy. For example a pair of devices both
      running at 1Mbps can together produce an effective throughput of 2Mbps of
      entropy if their streams are output independently of each other, but they
      can also be mixed together in parallel to provide a stronger guarantee of
      entropy at 1Mbps with the stream being at least as unpredictable as the
      most unpredictable device. With more than two devices a combination of
      both strategies may be used.
    <div style="height: 1.00em;">&#x00A0;</div>
    Devices that are placed in the same group will not add entropy to the pool
      until every device in that group has contributed at least <i>size</i>
      bytes to it. If the devices are not running at the same bit rate, the
      faster device(s) will continue to mix entropy into the group until every
      device has contributed. This option enables configuration of that block
      size. The <i>group_number</i> is an arbitrary integer identifier (which
      will be passed to the <b>--group</b> option for the device(s) to add to
      it). The <i>size</i> may be followed by a suffix of 'k', 'M', or 'G' to
      multiply it by the respective power of two. The group size will be rounded
      up to the nearest power of two. Default is for groups to be the same size
      as the pool, but they may be set either smaller or larger than it if
      desired. The two values are separated by a colon with no other space
      between them.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c, --control-socket=</b><i>path</i></dt>
  <dd class="It-tag">Set the filesystem path for the query and control socket
      that may be used to obtain information and statistics about the
      performance of the BitBabbler devices and control some aspects of the
      running process. The special value of 'none' may be passed to disable the
      creation of a control socket. Mostly this option is useful if you have
      more than one <b>seedd</b> process running which are each controlling
      different sets of devices.
    <div style="height: 1.00em;">&#x00A0;</div>
    On systems where unix domain sockets are not available, or if you wish to
      make the control socket visible to other machines on the network, you can
      instead use a string of the form <i>tcp:host:port</i>, where the
      <i>host</i> and <i>port</i> parts are as described in the <b>--udp-out</b>
      option above. Note that there is no access control when a TCP socket is
      used, so any user on any machine that is able to connect to this port will
      be able to do anything the control socket allows.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --socket-group=</b><i>group</i></dt>
  <dd class="It-tag">Permit access to the control socket by members of the named
      <i>group</i>. If this option is not specified, then only the owner of the
      <b>seedd</b> process will be able to connect to that socket. The
      <b>adm</b> group may be a reasonable choice to set this to on many systems
      (it is the default used by the Debian package init scripts), but you are
      free to use any group for this which best suits local access policies.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option has no effect if a TCP port is used for the control socket
      instead of a unix domain socket path.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>
    --watch=</b><i>path</i><b>:</b><i>delay</i><b>:</b><i>block_size</i><b>:</b><i>bytes</i></dt>
  <dd class="It-tag">Monitor an external device. This option does not directly
      effect the operation of collecting entropy from BitBabbler devices, or
      contribute in any way to the entropy that is output, either to
      <i>stderr</i> or the kernel. What it does do is leverage the quality
      assurance and health checking algorithms, and the trend monitoring
      functionality that this software provides, to also permit continuous
      supervision of other sources which are expected to be statistically
      random.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example it can be used to regularly sample from <i>/dev/urandom</i> or
      even from <i>/dev/random</i> to ensure the quality of their output is
      really what you expect it to be. There's little point to putting the most
      awesome entropy that the universe can conjure in, if what's coming out and
      feeding the applications that are consuming it is totally predictable
      garbage.
    <div style="height: 1.00em;">&#x00A0;</div>
    If this is used to monitor a limited source of blocking entropy, such as
      <i>/dev/random</i> then you'll want to be judicious in selecting the rate
      of reading from it, so as not to consume all the available entropy that
      you were aiming to gain by feeding it from a BitBabbler in the first. If
      it's reading from an 'unlimited' source backed by a PRNG, such as
      <i>/dev/urandom</i>, then the only real consideration is how much of the
      other system resources do you want to consume in drinking from the
      firehose.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>path</i> is the filesystem path to read from, it can be anything
      which can be opened and read from like a normal unix file. The
      <i>delay</i> is the amount of time, in milliseconds, to wait between
      reading blocks of data from it. The <i>block_size</i> is the number of
      bytes to read in a single block each time the watch process wakes up to
      read more. The total amount of data to read can by limited to
      <i>bytes</i>, once that limit is reached, the watch process for
      <i>path</i> will end (but all other processing will continue as per
      normal).
    <div style="height: 1.00em;">&#x00A0;</div>
    All qualifiers except the <i>path</i> are optional, and separated by colons
      with no other space between them, but all options must be explicitly set
      up to the last one that is provided. The <i>delay</i> may be followed by a
      suffix of 'k', 'M', or 'G' to multiply it by the respective power of 10,
      or by 'ki', 'Mi', or 'Gi' for powers of two if you're into that kind of
      thing. The <i>block_size</i> and <i>bytes</i> options may be similarly
      suffixed, but like all good sizes on computers are always a power of two
      if so.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --kernel-refill=</b><i>sec</i></dt>
  <dd class="It-tag">Set the maximum time in seconds before fresh entropy will
      be added to the OS kernel pool, even when it has not been drained below
      its usual refill threshold. This option has no effect unless the
      <b>--kernel</b> option is being used.
    <div style="height: 1.00em;">&#x00A0;</div>
    When feeding the OS pool, <b>seedd</b> will be woken to immediately add more
      entropy to it any time that it falls below the configured minimum
      watermark (which on Linux is set by
      <i>/proc/sys/kernel/random/write_wakeup_threshold</i> and can be
      configured persistently in <i>/etc/sysctl.d/bit-babbler-sysctl.conf</i>).
    <div style="height: 1.00em;">&#x00A0;</div>
    In addition to that, it will also wake up periodically to mix fresh entropy
      into the OS pool even if it is not being consumed (testing that the output
      of the device is still passing all the QA testing in the process). This
      option configures how long it will wait since the last time fresh entropy
      was added before doing that. If set to 0, then we will never add more
      entropy unless explicitly woken by the OS pool falling below its
      watermark. The default is 60 seconds, and there probably aren't many
      reasons to reduce that, but you may want to increase or disable it on low
      power systems which you don't want to be waking up just to do this.
    <div style="height: 1.00em;">&#x00A0;</div>
    The main downside to increasing it is that on relatively quiet systems it
      may take (significantly) longer for the long term QA tests (in particular
      the 16 bit tests) to accumulate enough results for analysis, and you lose
      some of the confidence that comes with a higher rate of continual sampling
      from the device. This option lets you choose the right balance for your
      own use. If unsure, leaving it at its default setting is probably the
      right answer.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v, --verbose</b></dt>
  <dd class="It-tag">Make more noise about what is going on internally. If used
      (once) with the <b>--scan</b> option this will show more information about
      each device, but otherwise it's mostly only information useful for
      debugging. It may be passed multiple times to get swamped with even more
      information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-?, --help</b></dt>
  <dd class="It-tag">Show a shorter version of all of this, which may fit on a
      single page, FSVO of page size.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --version</b></dt>
  <dd class="It-tag">Report the <b>seedd</b> release version.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Per_device_options"><a class="selflink" href="#Per_device_options">Per
  device options</a></h2>
The following options may be used multiple times to individually configure each
  device when more than one BitBabbler is available. If passed before any
  <b>--device-id</b> option, then they set new default values which will apply
  to every device. If passed after one of those options they will only be
  applied to the immediately preceding device.
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r, --bitrate=</b><i>Hz</i></dt>
  <dd class="It-tag">Select the device bitrate in bits per second. The available
      bitrates are determined by an integer clock divider, so not every rate is
      exactly achievable. An unsupported rate will be rounded up to the next
      higher rate. For convenience the rate may be followed by an SI multiplier
      (eg. 2.5M for 2500000).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --latency=</b><i>ms</i></dt>
  <dd class="It-tag">Override the calculated value for the USB latency timer.
      This controls the maximum amount of time that the device will wait if
      there is any data in its internal buffer (but less than a full packet),
      before sending it to the host. If this timer expires before a packet can
      be filled, then a short packet will be sent to the host. The default value
      is chosen to ensure that we do not send more short packets than necessary
      for the selected bitrate, since that will increase the number of packets
      sent and the amount of CPU time which must be spent processing them, to
      transfer the same amount of data.
    <div style="height: 1.00em;">&#x00A0;</div>
    Unless you are experimenting with changes to the low level code, there is
      probably no reason to ever use this option to override the latency
      manually.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f, --fold=</b><i>n</i></dt>
  <dd class="It-tag">Set the number of times to fold the BitBabbler output
      before adding it to the pool. Each fold will take the first half of the
      block that was read and XOR it with the bits in the second half. This will
      halve the throughput, but concentrate the available entropy more densely
      into the bits that remain.
    <div style="height: 1.00em;">&#x00A0;</div>
    There are two main things this is expected to do based on the BitBabbler
      design. It will better mix the low-frequency noise that is captured with
      that of the higher frequencies, allowing it to sample at higher bitrates
      without narrowing the noise bandwidth available to influence adjacent
      bits. It will help to break up any transient local correlations that might
      occur in the physical processes from which ambient environmental noise is
      collected.
    <div style="height: 1.00em;">&#x00A0;</div>
    Folding should never reduce the real entropy of each sample, but when all is
      working exactly as it should, it may not do anything to increase it
      either. Mathematically, an XOR summation is expected to exponentially
      smooth any bias in a stream of independent bits, with the result having at
      least as much entropy as the least predictable of either of the two inputs
      (in the same way that a one time pad is no less secure despite the
      plaintext having much less entropy than the pad does).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g, --group=</b><i>n</i></dt>
  <dd class="It-tag">The entropy pooling group to add this device to. See the
      <b>--group-size</b> option for a discussion of pool groups. You do not
      need to declare or define a group in any way before using this option,
      devices that have the same group number specified will be simply be
      grouped together. By default, all devices are placed in group 0 if this is
      not set explicitly for them.
    <div style="height: 1.00em;">&#x00A0;</div>
    The group 0 is special in that its size can be set explicitly, but it does
      not wait for all devices in it to have contributed entropy before mixing
      into the common pool, which is functionally equivalent to all of those
      devices being placed into separate groups that are the same size.
    <div style="height: 1.00em;">&#x00A0;</div>
    Normally if a single device in a group fails QA testing, then the entire
      group will stop contributing to the pool until it is removed or further
      extended testing confirms that failure to be an anomaly and not a
      persistent condition. For group 0 (and devices in other separate groups),
      a failed device will not prevent the remaining devices from continuing to
      contribute entropy if their own output is still passing the QA testing.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --enable=</b><i>mask</i></dt>
  <dd class="It-tag">Select a subset of the generators on BitBabbler devices
      with multiple entropy sources. The argument is a bitmask packed from the
      LSB, with each bit position controlling an individual source, enabling it
      when set to 1.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --idle-sleep=</b><i>initial</i><b>:</b><i>max</i></dt>
  <dd class="It-tag">This option permits tuning how the devices back off from
      generating entropy at the maximum rate, when it is not being consumed from
      the output pool. When the output pool is not full, entropy will be read
      from the devices as quickly as possible to try to refill it. Once it is
      full, they will begin to be throttled according to the following
      algorithm:
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>initial</i> value is the number of milliseconds to sleep when the
      output pool first becomes full again. If this value is 0, then the device
      will immediately remain idle until the output pool is no longer full.
      Otherwise, reading from the device will pause for either this number of
      milliseconds, or until the pool is no longer full, whichever comes first.
      If that timeout expires and the pool is still full, another block of
      entropy will be generated and mixed into the pool, then the timeout will
      be doubled. This process will continue until the timeout reaches the
      <i>max</i> value (which is also in milliseconds), at which point it will
      not increase any further. The device will always be woken immediately any
      time the output pool is not full, and the timeout cycle will begin again
      from the <i>initial</i> value each time that occurs.
    <div style="height: 1.00em;">&#x00A0;</div>
    As a special case, if the <i>max</i> value is set to 0, with an
      <i>initial</i> value that is not zero, the exponential back off will occur
      as above until the timeout reaches or exceeds 512 ms, at which point
      further activity will again be suspended indefinitely until the output
      pool is no longer full. This allows for a mode of operation where the
      device will still go into a hard suspend when no entropy is being consumed
      from the output pool, but only after mixing several blocks of entropy from
      each device that is configured this way into it.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default configuration used if this is not set explicitly is
      <i>initial</i>=100 and <i>max</i>=60000. Usually the only reason to change
      this is if you are trying to minimise the power usage on a low power
      system which you don't want continually waking up to generate entropy that
      nothing is using. For that use, if you are feeding the OS kernel pool, you
      will probably also want to set the <b>--kernel-refill</b> option to a
      suitable value, since it will cause the devices to wake up independently
      of what is set here (by reading from the output pool, making it be no
      longer full). Dialling the verbosity up to level 6 (with <b>-vvvvvv</b>)
      while tweaking this will let you watch how the reads from the devices are
      actually throttled.
    <div style="height: 1.00em;">&#x00A0;</div>
    When setting this, either of <i>initial</i> or <i>max</i> may be omitted (in
      which case they will retain their default value), but the ':' must always
      be included. It probably doesn't make a lot of sense to set this
      differently for each device (especially not for devices which are grouped
      together), but that is permitted if you really have some reason to want to
      do that.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --suspend-after=</b><i>ms</i></dt>
  <dd class="It-tag">Set the minimum expected device idle time for which we
      should allow the device to be suspended. On Linux, USB devices that are
      idle can automatically be suspended into a low power state, but in order
      to qualify as being 'idle' for that purpose, we need to release our claim
      on the device. Full details of the OS part of that can be found here:
    <div style="height: 1.00em;">&#x00A0;</div>
    https://www.kernel.org/doc/Documentation/usb/power-management.txt
    <div style="height: 1.00em;">&#x00A0;</div>
    The default is 0, which means <b>seedd</b> will never release a device it
      has claimed. The benefit of this is that no other process can claim it
      while it is released (accidentally or otherwise), which would prevent us
      from being able to use it again when we do require entropy from it. It
      also ensures there is minimal latency when we are woken up to read entropy
      from it again.
    <div style="height: 1.00em;">&#x00A0;</div>
    Setting this to a value greater than zero means that when the output pool is
      full, and we are expecting to sleep for at least that amount of time
      before reading from the device again, then the claim on the device will be
      released, and the OS will be able to suspend it until we need it again. If
      the pool is drained and requires more entropy before that time, then we
      will still reclaim the device immediately and begin reading from it again,
      but there will be a small amount of additional latency while it wakes up
      and is reinitialised for use. This option should usually be set in
      conjunction with <b>--idle-sleep</b> and <b>--kernel-refill</b> which
      control how often the device will be woken again to refresh the entropy
      pools when it might otherwise have remained idle. If they never allow it
      to sleep for longer than this time, then this option will have no effect.
    <div style="height: 1.00em;">&#x00A0;</div>
    It probably doesn't make much sense to set this below about 10000 (10
      seconds) otherwise the overhead of releasing, reclaiming, and
      reinitialising the device might actually use more power than suspending it
      saves. And it definitely doesn't make much sense to set it to a value less
      than what is configured for the <i>autosuspend_delay_ms</i> option in the
      kernel, since while we will release the device any time that we
      <i>expect</i> to sleep for this long (regardless of whether we actually do
      or not), the kernel will not actually suspend it until the
      <i>autosuspend_delay_ms</i> time has elapsed <i>after</i> we have released
      it. So if it doesn't get to actually suspend it, we would just be chewing
      extra CPU cycles, and adding extra latency to obtaining entropy when it is
      needed, for no net gain.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --low-power</b></dt>
  <dd class="It-tag">This is a convenience option, which is equivalent to
      setting:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     --kernel-refill=3600 --idle-sleep=100:0 --suspend-after=10000
    <div style="height: 1.00em;">&#x00A0;</div>
    And which in turn means:
    <div style="height: 1.00em;">&#x00A0;</div>
    We will wake up to mix more entropy into the kernel pool at least once an
      hour (though it is likely that most systems will already drain it below
      its threshold and so wake us to refill it before that time expires
      anyway).
    <div style="height: 1.00em;">&#x00A0;</div>
    We will mix at least 6 blocks of fresh entropy into the <b>seedd</b> output
      pool each time we are woken, before suspending indefinitely again (until
      either we are woken by the kernel needing entropy or by the timeout above
      expiring, or until something else consumes entropy from the output pool -
      such as from the UDP socket if that is enabled). This is based on doubling
      the <i>initial</i> <b>--idle-sleep</b> timeout each time the output pool
      remains full, until we exceed the minimum amount of time that really will
      perform a sleep (512ms), and then sleeping until explicitly woken again
      after that.
    <div style="height: 1.00em;">&#x00A0;</div>
    We will release the device, giving the OS the opportunity to suspend it,
      each time it does become fully idle (since an indefinite sleep is
      considered to be longer than any fixed amount of time).
    <div style="height: 1.00em;">&#x00A0;</div>
    Any or all of those options may still be customised by passing them
      explicitly <i>after</i> this option on the command line (in the same way
      that passing them twice would also override the first instance).
    <div style="height: 1.00em;">&#x00A0;</div>
    This isn't necessarily the configuration offering the lowest possible power
      consumption, but it's intended to strike a reasonable balance for systems
      where keeping idle power consumption low is more a important concern than
      continually mixing in additional fresh entropy or minimising the latency
      if demand for entropy suddenly surges (which is what the normal defaults
      are more oriented toward). At the very least it should be a reasonable
      starting point to begin experimenting from on low power systems.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b> --no-qa</b></dt>
  <dd class="It-tag">Disable gating entropy output on the result of quality and
      health checking. You pretty much never want to use this unless you are
      generating streams to <i>stdout</i> for no other reason than to analyse
      their quality with some other tool, such as <b>dieharder</b>(1) or the
      NIST test suite or similar. For that type of use we definitely don't want
      to be filtering out blocks which have already failed our own internal
      quality analysis, otherwise the value of such testing will be almost as
      tainted as that of the people who say &quot;after whitening our RNG with
      SHA-1 it now passes all of the statistical tests perfectly!&quot;, and
      there's already more than enough fossils in that tarpit.
    <div style="height: 1.00em;">&#x00A0;</div>
    It is not possible to disable this for data which is passed directly to the
      kernel entropy pool, there is absolutely no reason to ever want to do
      that, and this does not actually disable the QA checks from being
      performed (so the results of them will still be seen in the monitoring
      output and can generate external alerts if this mode was entered 'by
      accident'). It just permits any failing blocks to still pass through to
      <i>stdout</i>, so other tools can heap all the scorn on the output that it
      deserves if it is failing.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="CONTINUOUS_MONITORING"><a class="selflink" href="#CONTINUOUS_MONITORING">CONTINUOUS
  MONITORING</a></h1>
The query and control socket enables device performance and QA statistics to be
  examined in real-time. The <b>bbctl</b>(1) tool can be used to produce human
  readable reports on demand from the information it provides, but it can also
  be queried directly by other tools that want that information in a more
  machine readable form (see the <b>json_protocol</b> document for a full
  description of that). For users of <b>munin</b>, a plugin is provided which
  will continuously graph the status of each device, and which can be used to
  trigger an alert if an abnormal condition occurs.
<div style="height: 1.00em;">&#x00A0;</div>
The <b>munin</b> plugin requires the perl <b>JSON::XS</b> module (provided by
  the <b>libjson-xs-perl</b> package on Debian systems), and it must be
  explicitly enabled on each system where it is desired to run. Typically that
  will require doing something like this:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 # munin-node-configure --shell
 # ln -s /usr/share/munin/plugins/bit_babbler /etc/munin/plugins/bit_babbler
 # service munin-node restart
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
If <b>munin-node-configure</b> does not report that plugin autoconfiguration
  succeeded, the most likely reason is that <b>JSON::XS</b> is not available.
  There are a few options to configure the plugin's behaviour, these are all
  documented in <i>/etc/munin/plugin-conf.d/bit-babbler</i> (where they should
  be set if desired). The <b>munin-node</b> service needs to be restarted for
  changes to its plugins to take effect.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><i>/etc/default/seedd</i></dt>
  <dd class="It-tag">The optional configuration overrides for the init script,
      used when automatically starting as a daemon at system boot time.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>/var/run/bit-babbler/seedd.socket</i></dt>
  <dd class="It-tag">The default control socket path if not explicitly
      specified.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>/etc/sysctl.d/bit-babbler-sysctl.conf</i></dt>
  <dd class="It-tag">Configuration for kernel system variables. Mostly used to
      adjust the low-water mark for the kernel entropy pool, which controls when
      it will wake <b>seedd</b> for an immediate top up.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>/lib/udev/rules.d/60-bit-babbler.rules</i></dt>
  <dd class="It-tag">The default <b>udev</b>(7) rules granting direct device
      access to users in the group <b>bit-babbler</b>, enabling USB autosuspend
      when the device is idle, and invoking <b>bbvirt</b> to handle device
      hotplug for virtual machines. These can be overridden by creating
      <i>/etc/udev/rules.d/60-bit-babbler.rules</i> and populating it with your
      own rules.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>/etc/munin/plugin-conf.d/bit-babbler</i></dt>
  <dd class="It-tag">The <b>munin-node</b> configuration for continuous
      monitoring.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>bbctl</b>(1), <b>bbvirt</b>(1).
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
<b>seedd</b> was written by Ron &lt;ron@debian.org&gt;. You can send bug
  reports, feature requests, praise and complaints to support@bitbabbler.org.
<div style="height: 1.00em;">&#x00A0;</div>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 24, 2015</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
