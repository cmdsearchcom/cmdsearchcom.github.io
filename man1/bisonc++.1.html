<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:55:02 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>bisonc++(1) bisonc++ parser generator bisonc++(1)</p>

<p style="margin-top: 1em">NAME <br>
bisonc++ - Generate a C++ parser class and parsing
function</p>

<p style="margin-top: 1em">SYNOPSIS <br>
bisonc++ [OPTIONS] grammar-file</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Bisonc++ derives from previous work on bison by Alain
Coetmeur (coetmeur@icdc.fr), who created in the early
&acirc;90s a C++ class encapsulating the yyparse function as
generated by <br>
the GNU-bison parser generator.</p>

<p style="margin-top: 1em">Initial versions of bisonc++ (up
to version 0.92) wrapped Alain&acirc;s program in a program
offering a more modern user-interface, removing all
old-style (C) %define directives from <br>
bison++&acirc;s input specification file (see below for an
in-depth discussion of the differences between bison++ and
bisonc++). Starting with version 0.98, bisonc++ represents a
com&acirc; <br>
plete rebuilt of the parser generator, closely following
descriptions given in Aho, Sethi and Ullman&acirc;s Dragon
Book. Since version 0.98 bisonc++ is a C++ program, rather
than a C <br>
program generating C++ code.</p>

<p style="margin-top: 1em">Bisonc++ expands the concepts
initially implemented in bison and bison++, offering a
cleaner setup of the generated parser class. The parser
class is derived from a base-class, <br>
mainly containing the parser&acirc;s token- and
type-definitions as well as several member functions which
should not be modified by the programmer.</p>

<p style="margin-top: 1em">Most of these base-class members
might also be defined directly in the parser class, but were
defined in the parser&acirc;s base-class. This design
results in a very lean parser class, <br>
declaring only members that are actually defined by the
programmer or that have to be defined by bisonc++ itself
(e.g., the member function parse as well as some support
func&acirc; <br>
tions requiring access to facilities that are only available
in the parser class itself, rather than in the
parser&acirc;s base class).</p>

<p style="margin-top: 1em">This design does not require any
virtual members: the members which are not involved in the
actual parsing process may always be (re)implemented
directly by the programmer. Thus <br>
there is no need to apply or define virtual member
functions.</p>

<p style="margin-top: 1em">Before version 5.00.00 bisonc++
offered one single manual page. The advantage of one
man-page is of course that you never have to look for which
manual page contains which infor&acirc; <br>
mation. But on the other hand, bisonc++&acirc;s man-page
grew into a huge man-page of about 2000 lines in which it
was hard to find your way. From release 5.00.00 onward,
three <br>
man-pages. The following index relates manual pages to their
specific contents:</p>

<p style="margin-top: 1em">This man-page</p>

<p style="margin-top: 1em">This man-page concentrates on
the bisonc++ program itself, offering the following
sections:</p>

<p style="margin-top: 1em">o DESCRIPTION: a short
description of bisonc++ and its roots;</p>

<p style="margin-top: 1em">o OPTIONS: options supported by
bisonc++.</p>

<p style="margin-top: 1em">o QUICK START: a quick start
overview about how to use bisonc++;</p>

<p style="margin-top: 1em">o GENERATED FILES: files
generated by bisonc++ and their purposes</p>

<p style="margin-top: 1em">o FILES: skeleton files used by
bisonc++;</p>

<p style="margin-top: 1em">o SEE ALSO: references to other
programs and documentation;</p>

<p style="margin-top: 1em">o BUGS: some additional stuff
that should not qualify as bugs.</p>

<p style="margin-top: 1em">o ABOUT bisonc++: Some
history;</p>

<p style="margin-top: 1em">o AUTHOR: at the end of this
man-page. )</p>

<p style="margin-top: 1em">The bisonc++input(7) man-page
covers the details of the grammar-specification file. This
man-page offers these sections:</p>

<p style="margin-top: 1em">o DESCRIPTION: a short
description of bisonc++ and its grammar file(s);</p>

<p style="margin-top: 1em">o DIRECTIVES: bisonc++&acirc;s
grammar-specification directives;</p>

<p style="margin-top: 1em">o POLYMORPHIC SEMANTIC VALUES:
how to use polymorphic semantic values in parsers generated
by bisonc++;</p>

<p style="margin-top: 1em">o DOLLAR NOTATIONS: available
$-shorthand notations with single, union, and polymorphic
semantic value types.</p>

<p style="margin-top: 1em">o RESTRICTIONS ON TOKEN NAMES:
name restrictions for user-defined symbols;</p>

<p style="margin-top: 1em">o OBSOLETE SYMBOLS: symbols
available to bison(1), but not to bisonc++;</p>

<p style="margin-top: 1em">o EXAMPLE: an example of using
bisonc++;</p>

<p style="margin-top: 1em">o USING PARSER-CLASS SYMBOLS IN
LEXICAL SCANNERS: how to refer to tokens defined in the
grammar from within a lexical scanner;</p>

<p style="margin-top: 1em">o SEE ALSO: references to other
programs and documentation;</p>

<p style="margin-top: 1em">o AUTHOR: at the end of this
man-page.</p>

<p style="margin-top: 1em">The bisonc++api(3) describes the
application programmer&acirc;s interface, containing these
sections:</p>

<p style="margin-top: 1em">o DESCRIPTION: a short
description of bisonc++ and its application
programmer&acirc;s interface;</p>

<p style="margin-top: 1em">o PUBLIC MEMBERS AND -TYPES:
members and types that can be used by calling software;</p>

<p style="margin-top: 1em">o PRIVATE ENUMS AND -TYPES:
enumerations and types only available to the Parser
class;</p>

<p style="margin-top: 1em">o PRIVATE MEMBER FUNCTIONS:
member functions that are only available to the Parser
class;</p>

<p style="margin-top: 1em">o PRIVATE DATA MEMBERS: data
members that are only available to the Parser class;</p>

<p style="margin-top: 1em">o TYPES AND VARIABLES IN THE
ANONYMOUS NAMESPACE: an overview of the types and variables
that are used to define and store the grammar-tables
generated by bisonc++;</p>

<p style="margin-top: 1em">o SEE ALSO: references to other
programs and documentation;</p>

<p style="margin-top: 1em">o AUTHOR: at the end of this
man-page.</p>

<p style="margin-top: 1em">OPTIONS <br>
Where available, single letter options are listed between
parentheses beyond their associated long-option variants.
Single letter options require arguments if their associated
<br>
long options also require arguments. Options affecting the
class- or implementation header files are ignored if these
files already exist. Options accepting a
&lsquo;filename&acirc; do not <br>
accept path names, i.e., they cannot contain directory
separators (/); options accepting a &acirc;pathname&acirc;
may contain directory separators.</p>

<p style="margin-top: 1em">Some options may cause errors.
This happens when they conflict with the contents of a file
which bisonc++ cannot modify (e.g., a parser class header
file exists, but doesn&acirc;t <br>
define a namespace, but a --namespace option was
specified).</p>

<p style="margin-top: 1em">To solve the error the offending
option could be omitted; the existing file could be removed;
or the existing file could be hand-edited according to the
option&acirc;s specification.</p>

<p style="margin-top: 1em">Note that bisonc++ currently
does not handle the opposite error condition: if a
previously used option is omitted, then bisonc++ does not
report an inconsistency. In those cases <br>
compilation errors may be observed.</p>

<p style="margin-top: 1em">o --analyze-only (-A) <br>
Only analyze the grammar. No files are (re)written. This
option can be used to test the grammatic correctness of
modification &lsquo;in situ&acirc;, without overwriting
previously <br>
generated files. If the grammar contains syntactic errors
only syntax analysis is performed.</p>

<p style="margin-top: 1em">o --baseclass-header=filename
(-b) <br>
Filename defines the name of the file to contain the
parser&acirc;s base class. This class defines, e.g., the
parser&acirc;s symbolic tokens. Defaults to the name of the
parser class <br>
plus the suffix base.h. It is generated, unless otherwise
indicated (see --no-baseclass-header and
--dont-rewrite-baseclass-header below).</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already existing parser class header file does
not contain #include &quot;filename&quot;.</p>

<p style="margin-top: 1em">o
--baseclass-preinclude=pathname (-H) <br>
Pathname defines the path to the file preincluded in the
parser&acirc;s base-class header. This option is needed in
situations where the base class header file refers to types
<br>
which might not yet be known. E.g., with polymorphic
semantic values a std::string value type might be used.
Since the string header file is not by default included in
<br>
parserbase.h we somehow need to inform the compiler about
this and possibly other headers. The suggested procedure is
to use a pre-include header file declaring the <br>
required types. By default &lsquo;header&acirc; is
surrounded by double quotes: #include &quot;header&quot; is
used when the option -H header is specified. When the
argument is surrounded by <br>
pointed brackets #include &lt;header&gt; is included. In the
latter case, quotes might be required to escape
interpretation by the shell (e.g., using -H
&acirc;&lt;header&gt;&acirc;).</p>

<p style="margin-top: 1em">o --baseclass-skeleton=pathname
(-B) <br>
Pathname defines the path name to the file containing the
skeleton of the parser&acirc;s base class. It defaults to
the installation-defined default path name (e.g., <br>
/usr/share/bisonc++/ plus bisonc++base.h).</p>

<p style="margin-top: 1em">o --class-header=filename (-c)
<br>
Filename defines the name of the file to contain the parser
class. Defaults to the name of the parser class plus the
suffix .h</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already existing implementation header file does
not contain #include &quot;filename&quot;.</p>

<p style="margin-top: 1em">o --class-name className <br>
Defines the name of the C++ class that is generated. If
neither this option, nor the %class-name directory is
specified, then the default class name (Parser) is used.</p>

<p style="margin-top: 1em">It is an error if this option is
used and className differs from the name of the class that
is defined in an already existing parser-class header file
and/or if an already <br>
existing implementation header file does not define members
of the class &lsquo;className&acirc;.</p>

<p style="margin-top: 1em">o --class-skeleton=pathname (-C)
<br>
Pathname defines the path name to the file containing the
skeleton of the parser class. It defaults to the
installation-defined default path name (e.g., <br>
/usr/share/bisonc++/ plus bisonc++.h).</p>

<p style="margin-top: 1em">o --construction <br>
Details about the construction of the parsing tables are
written to the same file as written by the --verbose option
(i.e., &lt;grammar&gt;.output, where &lt;grammar&gt; is the
input <br>
file read by bisonc++). This information is primarily useful
for developers. It augments the information written to the
verbose grammar output file, generated by the <br>
--verbose option.</p>

<p style="margin-top: 1em">o --debug <br>
Provide the generated parse and its support functions with
debugging code, optionally showing the actual parsing
process on the standard output stream. When included, the
<br>
debugging output is active by default, but its activity may
be controlled using the setDebug(bool on-off) member.
Bisonc++ does not use #ifdef DEBUG macros. Rerun bisonc++
<br>
without the --debug option to remove the debugging code.</p>

<p style="margin-top: 1em">Note that this option does not
show the actions of bisonc++&acirc;s own parser, its own
lexical scanner or merely the numbers of the case-entries
executed by the parser&acirc;s parse <br>
function. If that is what you want, use the --own-debug,
--action-cases, --scanner-debug and/or --own-tokens
options.</p>

<p style="margin-top: 1em">When polymorphic semantic values
are used (see section POLYMORPHIC SEMANTIC VALUES) then the
generated parser might attempt to retrieve an incorrect
polymorphic value. In <br>
that case a fatal error is generated, ending
bisonc++&acirc;s run. The error message itself cannot refer
to the action block where the error occurred. If this
situation is <br>
encountered, rerun bisonc++, specifying --debug and call
parser.setDebug(Parser::ACTIONCASES): as a debugging aid the
generated parser then shows the executeAction <br>
switch&acirc;s case entry numbers just before their
execution.</p>

<p style="margin-top: 1em">o
--default-actions=off|quiet|warn (-d) <br>
When warn is specified (which is the default) an action
block executing $$ = $1 (or $$ = STYPE__{} for empty
production rules) is added to production rules that do not
<br>
explicitly define their own final action blocks, while
issuing a warning. When quiet is specified these action
blocks are silently added. It is an error when the types of
<br>
$$ and $1 differ (but it is OK if neither $$ nor $1 is
associated with a specific type). When off is specified no
action blocks are added (issuing a warning issued, unless
<br>
the option/directive tag-mismatches off has been
specified).</p>

<p style="margin-top: 1em">o --error-verbose <br>
When a syntactic error is reported, the generated parse
function dumps the parser&acirc;s state stack to the
standard output stream. The stack dump shows on separate
lines a <br>
stack index followed by the state stored at the indicated
stack element. The first stack element is the stack&acirc;s
top element.</p>

<p style="margin-top: 1em">o --filenames=filename (-f) <br>
Filename is a generic file name that is used for all header
files generated by bisonc++. Options defining specific file
names are also available (which then, in turn, <br>
overrule the name specified by this option).</p>

<p style="margin-top: 1em">o --flex <br>
Bisonc++ generates code calling d_scanner.yylex() to obtain
the next lexical token, and calling d_scanner.YYText() for
the matched text, unless overruled by options or <br>
directives explicitly defining these functions. By default,
the interface defined by flexc++(1) is used. This option is
only interpreted if the --scanner option or %scan&acirc;
<br>
ner directive is also used.</p>

<p style="margin-top: 1em">o --help (-h) <br>
Write basic usage information to the standard output stream
and terminate.</p>

<p style="margin-top: 1em">o
--implementation-header=filename (-i) <br>
Filename defines the name of the file to contain the
implementation header. It defaults to the name of the
generated parser class plus the suffix .ih.</p>

<p style="margin-top: 1em">The implementation header should
contain all directives and declarations only used by the
implementations of the parser&acirc;s member functions. It
is the only header file that <br>
is included by the source file containing parse&acirc;s
implementation. User defined implementation of other class
members may use the same convention, thus concentrating all
<br>
directives and declarations that are required for the
compilation of other source files belonging to the parser
class in one header file.</p>

<p style="margin-top: 1em">o
--implementation-skeleton=pathname (-I) <br>
Pathname defines the path name to the file containing the
skeleton of the implementation header. t defaults to the
installation-defined default path name (e.g., <br>
/usr/share/bisonc++/ plus bisonc++.ih).</p>

<p style="margin-top: 1em">o --insert-stype <br>
This option is only effective if the debug option (or %debug
directive) has been specified. When insert-stype has been
specified the parsing function&acirc;s debug output also
<br>
shows selected semantic values. It should only be used if
objects or variables of the semantic value type STYPE__ can
be inserted into ostreams.</p>

<p style="margin-top: 1em">o --max-inclusion-depth=value
<br>
Set the maximum number of nested grammar files. Defaults to
10.</p>

<p style="margin-top: 1em">o --namespace identifier <br>
Define all of the code generated by bisonc++ in the
namespace identifier. By default no namespace is defined. If
this options is used the implementation header is provided
<br>
with a commented out using namespace declaration for the
specified namespace. In addition, the parser and parser base
class header files also use the specified namespace <br>
to define their include guard directives.</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already existing parser-class header file and/or
implementation header file does not define namespace
identifier.</p>

<p style="margin-top: 1em">o --no-baseclass-header <br>
Do not write the file containing the parser class&acirc;
base class, even if that file doesn&acirc;t yet exist. By
default the file containing the parser&acirc;s base class is
(re)written <br>
each time bisonc++ is called. Note that this option should
normally be avoided, as the base class defines the symbolic
terminal tokens that are returned by the lexical <br>
scanner. When the construction of this file is suppressed,
modifications of these terminal tokens are not communicated
to the lexical scanner.</p>

<p style="margin-top: 1em">o --no-decoration (-D) <br>
Do not include user-defined or default actions when
generating the parser&acirc;s parse member. This effectively
generates a parser which merely performs syntax checks,
without <br>
performing the actions which are normally executed when
rules have been matched. This may be useful in situations
where a (partially or completely) decorated grammar is <br>
reorganized, and the syntactic correctness of the modified
grammar must be verified, or in situations where the grammar
has already been decorated, but functions which are <br>
called from the rules&acirc;s actions have not yet been
impleemented.</p>

<p style="margin-top: 1em">o --no-lines <br>
Do not put #line preprocessor directives in the file
containing the parser&acirc;s parse function. By default the
file containing the parser&acirc;s parse function also
contains #line <br>
preprocessor directives. This option allows the compiler and
debuggers to associate errors with lines in your grammar
specification file, rather than with the source file <br>
containing the parse function itself.</p>

<p style="margin-top: 1em">o --no-parse-member <br>
Do not write the file containing the parser&acirc;s
predefined parser member functions, even if that file
doesn&acirc;t yet exist. By default the file containing the
parser&acirc;s parse <br>
member function is (re)written each time bisonc++ is called.
Note that this option should normally be avoided, as this
file contains parsing tables which are altered when&acirc;
<br>
ever the grammar definition is modified.</p>

<p style="margin-top: 1em">o --own-debug <br>
Displays the actions performed by bisonc++&acirc;s parser
when it processes the grammar specification file(s) (lots of
output!). This implies the --verbose option.</p>

<p style="margin-top: 1em">o --own-tokens (-T) <br>
The tokens returned as well as the text matched by
bisonc++&acirc;s lexcial scanner are shown when this option
is used.</p>

<p style="margin-top: 1em">This option does not result in
the generated parsing function displaying returned tokens
and matched text. If that is what you want, use the
--print-tokens option.</p>

<p style="margin-top: 1em">o --parsefun-skeleton=pathname
(-P) <br>
Pathname defines the path name of the file containing the
parsing member function&acirc;s skeleton. It defaults to the
installation-defined default path name (e.g., <br>
/usr/share/bisonc++/ plus bisonc++.cc).</p>

<p style="margin-top: 1em">o --parsefun-source=filename
(-p) <br>
Filename defines the name of the source file to contain the
parser member function parse. Defaults to parse.cc.</p>

<p style="margin-top: 1em">o
--polymorphic-code-skeleton=pathname (-L) <br>
Pathname defines the path name of the file containing the
non-template members of the polymorphic Base class. It
defaults to the installation-defined default path name <br>
(e.g., /usr/share/bisonc++/ plus bisonc++polymorphic).</p>

<p style="margin-top: 1em">o --polymorphic-skeleton=pathame
(-M) <br>
Pathname defines the path name of the file containing the
skeleton of the polymorphic template classes. It defaults to
the installation-defined default path name (e.g., <br>
/usr/share/bisonc++/ plus bisonc++polymorphic.code).</p>

<p style="margin-top: 1em">o --print-tokens (-t) <br>
The generated parsing function implements a function print__
displaying (on the standard output stream) the tokens
returned by the parser&acirc;s scanner as well as the
corre&acirc; <br>
sponding matched text. This implementation is suppressed
when the parsing function is generated without using this
option. The member print__ is called from Parser::print,
<br>
which is defined in-line in the the parser&acirc;s class
header. Calling Parser::print__ can thus easily be
controlled from print, using, e.g., a variable that set by
the pro&acirc; <br>
gram using the parser generated by bisonc++.</p>

<p style="margin-top: 1em">This option does not show the
tokens returned and text matched by bisonc++ itself when it
is reading its input file(s). If that is what you want, use
the --own-tokens <br>
option.</p>

<p style="margin-top: 1em">o --required-tokens=number <br>
Following a syntactic error, require at least number
successfully processed tokens before another syntactic error
can be reported. By default number is zero.</p>

<p style="margin-top: 1em">o --scanner=pathname (-s) <br>
Pathname defines the path name to the file defining the
scanner&acirc;s class interface (e.g.,
&quot;../scanner/scanner.h&quot;). When this option is used
the parser&acirc;s member int lex() is <br>
predefined as</p>

<p style="margin-top: 1em">int Parser::lex() <br>
{ <br>
return d_scanner.lex(); <br>
}</p>

<p style="margin-top: 1em">and an object Scanner d_scanner
is composed into the parser (but see also option
scanner-class-name). The example shows the function
that&acirc;s called by default. When the <br>
--flex option (or %flex directive) is specified the function
d_scanner.yylex() is called. Any other function to call can
be specified using the --scanner-token-function <br>
option (or %scanner-token-function directive).</p>

<p style="margin-top: 1em">By default bisonc++ surrounds
pathname by double quotes (using, e.g., #include
&quot;pathname&quot;). When pathname is surrounded by
pointed brackets #include &lt;pathname&gt; is <br>
included.</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already existing parser class header file does
not include &lsquo;pathname&acirc;.</p>

<p style="margin-top: 1em">o --scanner-class-name
scannerClassName <br>
Defines the name of the scanner class, declared by the
pathname header file that is specified at the scanner option
or directive. By default the class name Scanner is <br>
used.</p>

<p style="margin-top: 1em">It is an error if this option is
used and either the scanner option was not provided, or the
parser class interface in an already existing parser class
header file does <br>
not declare a scanner class d_scanner object.</p>

<p style="margin-top: 1em">o --scanner-debug <br>
Show de scanner&acirc;s matched rules and returned tokens.
This extensively displays the rules and tokens matched and
returned by bisonc++&acirc;s scanner, instead of just
showing the <br>
tokens and matched text which are received by bisonc++. If
you want the latter, use the option --own-tokens.</p>

<p style="margin-top: 1em">o
--scanner-matched-text-function=function-call <br>
The scanner function returning the text that was matched at
the last call of the scanner&acirc;s token function. A
complete function call expression should be provided
(includ&acirc; <br>
ing a scanner object, if used). This option overrules the
d_scanner.matched() call used by default when the %scanner
directive is specified, and it overrules the d_scan&acirc;
<br>
ner.YYText() call used when the %flex directive is provided.
Example:</p>

<p style="margin-top: 1em">--scanner-matched-text-function
&quot;myScanner.matchedText()&quot;</p>

<p style="margin-top: 1em">o
--scanner-token-function=function-call <br>
The scanner function returning the next token, called from
the parser&acirc;s lex function. A complete function call
expression should be provided (including a scanner object,
<br>
if used). This option overrules the d_scanner.lex() call
used by default when the %scanner directive is specified,
and it overrules the d_scanner.yylex() call used when <br>
the %flex directive is provided. Example:</p>

<p style="margin-top: 1em">--scanner-token-function
&quot;myScanner.nextToken()&quot;</p>

<p style="margin-top: 1em">It is an error if this option is
used and the scanner token function is not called from the
code in an already existing implementation header.</p>

<p style="margin-top: 1em">o --show-filenames <br>
Writes the names of the generated files to the standard
error stream.</p>

<p style="margin-top: 1em">o --skeleton-directory=directory
(-S) <br>
Specifies the directory containing the skeleton files. In
addition to specifying a common names for the skeleton files
the locations of individual skeleton files can be <br>
specified using the options (-B -C, -H, -I, -L and -M).</p>

<p style="margin-top: 1em">o --stack-expansion(size) <br>
Defines the number of elements to be added to the generated
parser&acirc;s semantic value stack when it must be
enlarged. By default 10 elements are added to the stack.
This <br>
option/directive is interpreted only once, and only if size
at least equals the default stack expansion size of 10.</p>

<p style="margin-top: 1em">o --tag-mismatches off|on <br>
When on is specified (which is the default), a warning is
issued if no $$ assignment was detected in an action block,
or if adding a default $$ = ... action was suppressed <br>
(cf. the default-actions off option or directive).</p>

<p style="margin-top: 1em">o --target-directory=pathname
<br>
Pathname defines the directory where generated files should
be written. By default this is the directory where bisonc++
is called.</p>

<p style="margin-top: 1em">o --thread-safe <br>
No static data are modified, making bisonc++
thread-safe.</p>

<p style="margin-top: 1em">o --usage <br>
Writes basic usage information to the standard output stream
and terminates.</p>

<p style="margin-top: 1em">o --verbose (-V) <br>
Writes a file containing verbose descriptions of the parser
states and what is done for each type of look-ahead token in
that state. This file also describes all con&acirc; <br>
flicts detected in the grammar, both those resolved by
operator precedence and those that remain unresolved. It is
not created by default, but if requested the informa&acirc;
<br>
tion is written on &lt;grammar&gt;.output, where
&lt;grammar&gt; is the grammar specification file passed to
bisonc++.</p>

<p style="margin-top: 1em">o --version (-v) <br>
Displays bisonc++&acirc;s version number and terminates.</p>

<p style="margin-top: 1em">QUICK START <br>
Bisonc++ may be used as follows:</p>

<p style="margin-top: 1em">o First, define a grammar. The
reader is referred to bisonc++&acirc;s manual and other
sources (like Aho, Sethi and Ullman&acirc;s book) for
details about how to define and decorate <br>
grammars.</p>

<p style="margin-top: 1em">o No &lsquo;macro style&acirc;
%define declarations are required anymore. Instead, the
normal practice of defining class members in source files
and declaring them in class header files <br>
can be followed when using bisonc++. Bisonc++ concentrates
on its main tasks: defining a parser class and implementing
the parsing function int parse, leaving all other <br>
parts of the parser class&acirc; definition to the
programmer.</p>

<p style="margin-top: 1em">o Having defined a grammar and
(usually) some directives bisonc++ is run, generating the
essential elements of a parser class. See the next section
for details about the <br>
files generated by bisonc++.</p>

<p style="margin-top: 1em">o Next, members required in
addition to the bisonc++-generated member parse and its
support functions must be implemented by the programmer, and
declared in the parser&acirc;s <br>
class header. At the very least a member int lex must be
defined (a default implementation can be generated by
bisonc++).</p>

<p style="margin-top: 1em">o The generated parser can now
be used in a program. A very simple example would be:</p>

<p style="margin-top: 1em">int main() <br>
{ <br>
Parser parser; <br>
return parser.parse(); <br>
}</p>

<p style="margin-top: 1em">GENERATED FILES <br>
Bisonc++ may create the following files:</p>

<p style="margin-top: 1em">o A file containing the
implementation of the member function parse and its support
functions. The member parse is a public member that can be
called to parse a <br>
token-sequence according to a specified LALR1 type of
grammar. By default the implementations of these members are
written on the file parse.cc. The programmer should not <br>
modify the contents of this file; it is rewritten every time
bisonc++ is called.</p>

<p style="margin-top: 1em">o A file containing an initial
setup of the parser class, containing the declaration of the
public member parse and of its (private) support members.
New members may safely <br>
be declared in the parser class, as it is only created by
bisonc++ if not yet existing, using the filename
&lt;parser-class&gt;.h (where &lt;parser-class&gt; is the
the name of the <br>
defined parser class).</p>

<p style="margin-top: 1em">o A file containing the parser
class&acirc; base class. This base class should not be
modified by the programmer. It contains types defined by
bisonc++, as well as several (pro&acirc; <br>
tected) data members and member functions, which should not
be redefined by the programmer. All symbolic parser terminal
tokens are defined in this class, thereby escalat&acirc;
<br>
ing these definitions to a separate class (cf. Lakos,
(2001)), which in turn prevents circular dependencies
between the lexical scanner and the parser (here, circular
<br>
dependencies may easily be encountered, as the parser needs
access to the lexical scanner class when defining the
lexical scanner as one of its data members, whereas the <br>
lexical scanner needs access to the parser class to know
about the grammar&acirc;s symbolic terminal tokens;
escalation is a way out of such circular dependencies). By
default <br>
this file is (re)written any time bisonc++ is called, using
the filename &lt;parser-class&gt;base.h.</p>

<p style="margin-top: 1em">o A file containing an
implementation header. The implementation header rather than
the parser&acirc;s class header file should be included by
the parser&acirc;s source files implement&acirc; <br>
ing member functions declared by the programmer. The
implementation header first includes the parser
class&acirc;s header file, and then provides default in-line
implementations <br>
for its members error and print (which may be altered by the
programmer). The member lex may also receive a standard
in-line implementation. Alternatively, its implementa&acirc;
<br>
tion can be provided by the programmer (see below). Any
directives and/or namespace directives required for the
proper compilation of the parser&acirc;s additional member
func&acirc; <br>
tions should be declared next. The implementation header is
included by the file defining parse. By default the
implementation header is created if not yet existing, <br>
receiving the filename &lt;parser-class&gt;.ih.</p>

<p style="margin-top: 1em">o A verbose description of the
generated parser. This file is comparable to the verbose
output file originally generated by bison++. It is generated
when the option --ver&acirc; <br>
bose or -V is provided. If so, bisonc++ writes the file
&lt;grammar&gt;.output, where &lt;grammar&gt; is the name of
the file containing the grammar definition.</p>

<p style="margin-top: 1em">FILES <br>
o bisonc++base.h: skeleton of the parser&acirc;s base
class;</p>

<p style="margin-top: 1em">o bisonc++.h: skeleton of the
parser class;</p>

<p style="margin-top: 1em">o bisonc++.ih: skeleton of the
implementation header;</p>

<p style="margin-top: 1em">o bisonc++.cc: skeleton of the
member parse;</p>

<p style="margin-top: 1em">o bisonc++polymorphic: skeleton
of the declarations used by %polymorphic;</p>

<p style="margin-top: 1em">o bisonc++polymorphic.code:
skeleton of the non-inline implementations of the members
declared in bisonc++polymorphic.</p>

<p style="margin-top: 1em">o debugdecl.in: skeleton
declaring members of the parser&acirc;s base class that are
only required when the debug option or directive was
specified.</p>

<p style="margin-top: 1em">o debugfunctions1.in: skeleton
defining the members declared in debugdecl.in.</p>

<p style="margin-top: 1em">o debugfunctions2.in: skeleton
implementing symbol__, which is only needed when the
print-tokens option or directive was specified.</p>

<p style="margin-top: 1em">o debugfunctions3.in: skeleton
implementing errorVerbose__, which is only needed when the
error-verbose option or directive was specified.</p>

<p style="margin-top: 1em">o debugincludes.in: skeleton
specifying the header files #include directives that are
required when the debug option or directive was
specified.</p>

<p style="margin-top: 1em">o debuglookup.in: skeleton
containing extra code required in the Parser::lookup member
when the debug option of directive was specified.</p>

<p style="margin-top: 1em">o lex.in: skeleton implementing
the Parser::lex function.</p>

<p style="margin-top: 1em">o ltypedata.in: skeleton
declaring the location variables</p>

<p style="margin-top: 1em">o ltype.in: skeleton defining
the default or user defined LTYPE__.</p>

<p style="margin-top: 1em">o print.in: skeleton
implementing the actions of Parser::print if the
print-tokens option or directive was specified.</p>

<p style="margin-top: 1em">o threading.in: skeleton
defining the variables required for generating a thread-safe
parsing function.</p>

<p style="margin-top: 1em">SEE ALSO <br>
bison(1), bison++(1), bison++api(3), bison++input(7),
bison.info (using texinfo), flexc++(1),
https://fbb-git.github.io/bisoncpp/</p>

<p style="margin-top: 1em">Lakos, J. (2001) Large Scale C++
Software Design, Addison Wesley. <br>
Aho, A.V., Sethi, R., Ullman, J.D. (1986) Compilers, Addison
Wesley.</p>

<p style="margin-top: 1em">BUGS <br>
Parser-class header files (e.g., Parser.h) and parser-class
internal header files (e.g., Parser.ih) generated with
bisonc++ &lt; 4.02.00 require two hand-modifications when
used in <br>
combination with bisonc++ &gt;= 4.02.00. See the description
of exceptionHandler__ for details.</p>

<p style="margin-top: 1em">Discontinued options:</p>

<p style="margin-top: 1em">o --include-only</p>

<p style="margin-top: 1em">o --namespace</p>

<p style="margin-top: 1em">o
--polymorphic-inline-skeleton</p>

<p style="margin-top: 1em">To avoid collisions with names
defined by the parser&acirc;s (base) class, the following
identifiers should not be used as token names:</p>

<p style="margin-top: 1em">o Identifiers ending in two
underscores;</p>

<p style="margin-top: 1em">o Any of the following
identifiers: ABORT, ACCEPT, ERROR, clearin, debug, error, or
setDebug.</p>

<p style="margin-top: 1em">When re-using files generated by
bisonc++ before version 2.0.0, minor hand-modification may
be necessary. Refer to bisonc++&acirc;s git
(https://github.com/fbb-git/bisoncpp) for <br>
details.</p>

<p style="margin-top: 1em">The Semantic parser, mentioned
in bison++(1) is not implemented in bisonc++(1). According
to bison++(1) the semantic parser was not available in
bison++ either. Maybe a so-called <br>
pure parser is available through the --thread-safe
option.</p>

<p style="margin-top: 1em">ABOUT bisonc++ <br>
Bisonc++ was based on bison++, originally developed by Alain
Coetmeur (coetmeur@icdc.fr), R&amp;D department (RDT),
Informatique-CDC, France, who based his work on bison, GNU
version <br>
1.21.</p>

<p style="margin-top: 1em">Bisonc++ version 0.98 and beyond
is a complete rewrite of an LALR-1 parser generator, closely
following the construction process as described in Aho,
Sethi and Ullman&acirc;s (1986) <br>
book Compilers (i.e., the Dragon book). It uses the same
grammar specification as bison and bison++, and it uses
practically the same options and directives as bisonc++
versions <br>
earlier than 0.98. Variables, declarations and macros that
are obsolete were removed.</p>

<p style="margin-top: 1em">Compared to bison and bison++,
the number and functions of the various %define declarations
was thoroughly modified. All of bison&acirc;s %define
declarations were replaced by their <br>
(former) first arguments. Furthermore,
&lsquo;macro-style&acirc; declarations are not supported or
required. Finally, all directives only use lower-case
characters and do not contain under&acirc; <br>
score characters (but sometimes hyphens). E.g., %define
DEBUG is now declared as %debug; %define LSP_NEEDED is now
declared as %lsp-needed (note the hyphen).</p>

<p style="margin-top: 1em">AUTHOR <br>
Frank B. Brokken (f.b.brokken@rug.nl).</p>

<p style="margin-top: 1em">bisonc++.5.02.00.tar.gz
2005-2016 bisonc++(1)</p>
<hr>
</body>
</html>
