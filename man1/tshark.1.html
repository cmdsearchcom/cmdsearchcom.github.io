<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:40:56 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>TSHARK(1) The Wireshark Network Analyzer TSHARK(1)</p>

<p style="margin-top: 1em">NAME <br>
tshark - Dump and analyze network traffic</p>

<p style="margin-top: 1em">SYNOPSIS <br>
tshark [ -2 ] [ -a &lt;capture autostop condition&gt; ] ...
[ -b &lt;capture ring buffer option&gt;] ... [ -B
&lt;capture buffer size&gt; ] [ -c &lt;capture packet
count&gt; ] <br>
[ -C &lt;configuration profile&gt; ] [ -d &lt;layer
type&gt;==&lt;selector&gt;,&lt;decode-as protocol&gt; ] [ -D
] [ -e &lt;field&gt; ] [ -E &lt;field print option&gt; ] [
-f &lt;capture filter&gt; ] [ -F &lt;file format&gt; ] <br>
[ -g ] [ -h ] [ -H &lt;input hosts file&gt; ] [ -i
&lt;capture interface&gt;|- ] [ -I ] [ -K &lt;keytab&gt; ] [
-l ] [ -L ] [ -n ] [ -N &lt;name resolving flags&gt; ] [ -o
&lt;preference setting&gt; ] ... <br>
[ -O &lt;protocols&gt; ] [ -p ] [ -P ] [ -q ] [ -Q ] [ -r
&lt;infile&gt; ] [ -R &lt;Read filter&gt; ] [ -Y &lt;displaY
filter&gt; ] [ -s &lt;capture snaplen&gt; ] [ -S
&lt;separator&gt; ] [ -t a|ad|d|dd|e|r|u|ud ] <br>
[ -T pdml|psml|ps|text|fields ] [ -v ] [ -V ] [ -w
&lt;outfile&gt;|- ] [ -W &lt;file format option&gt;] [ -x ]
[ -X &lt;eXtension option&gt;] [ -y &lt;capture link
type&gt; ] [ -z &lt;statistics&gt; ] <br>
[ &lt;capture filter&gt; ]</p>

<p style="margin-top: 1em">tshark -G
[fields|protocols|values|decodes|defaultprefs|currentprefs]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
TShark is a network protocol analyzer. It lets you capture
packet data from a live network, or read packets from a
previously saved capture file, either printing a decoded
form <br>
of those packets to the standard output or writing the
packets to a file. TShark&rsquo;s native capture file format
is pcap format, which is also the format used by tcpdump and
<br>
various other tools.</p>

<p style="margin-top: 1em">Without any options set, TShark
will work much like tcpdump. It will use the pcap library to
capture traffic from the first available network interface
and displays a summary <br>
line on stdout for each received packet.</p>

<p style="margin-top: 1em">TShark is able to detect, read
and write the same capture files that are supported by
Wireshark. The input file doesn&rsquo;t need a specific
filename extension; the file format and <br>
an optional gzip compression will be automatically detected.
Near the beginning of the DESCRIPTION section of
wireshark(1) or <br>

&lt;http://www.wireshark.org/docs/man-pages/wireshark.html&gt;
is a detailed description of the way Wireshark handles this,
which is the same way Tshark handles this.</p>

<p style="margin-top: 1em">Compressed file support uses
(and therefore requires) the zlib library. If the zlib
library is not present, TShark will compile, but will be
unable to read compressed files.</p>

<p style="margin-top: 1em">If the -w option is not
specified, TShark writes to the standard output the text of
a decoded form of the packets it captures or reads. If the
-w option is specified, TShark <br>
writes to the file specified by that option the raw data of
the packets, along with the packets&rsquo; time stamps.</p>

<p style="margin-top: 1em">When writing a decoded form of
packets, TShark writes, by default, a summary line
containing the fields specified by the preferences file
(which are also the fields displayed in <br>
the packet list pane in Wireshark), although if it&rsquo;s
writing packets as it captures them, rather than writing
packets from a saved capture file, it won&rsquo;t show the
&quot;frame number&quot; <br>
field. If the -V option is specified, it writes instead a
view of the details of the packet, showing all the fields of
all protocols in the packet. If the -O option is <br>
specified, it will only show the full protocols specified.
Use the output of &quot;tshark -G protocols&quot; to find
the abbreviations of the protocols you can specify.</p>

<p style="margin-top: 1em">If you want to write the decoded
form of packets to a file, run TShark without the -w option,
and redirect its standard output to the file (do not use the
-w option).</p>

<p style="margin-top: 1em">When writing packets to a file,
TShark, by default, writes the file in pcap format, and
writes all of the packets it sees to the output file. The -F
option can be used to <br>
specify the format in which to write the file. This list of
available file formats is displayed by the -F flag without a
value. However, you can&rsquo;t specify a file format for a
<br>
live capture.</p>

<p style="margin-top: 1em">Read filters in TShark, which
allow you to select which packets are to be decoded or
written to a file, are very powerful; more fields are
filterable in TShark than in other <br>
protocol analyzers, and the syntax you can use to create
your filters is richer. As TShark progresses, expect more
and more protocol fields to be allowed in read filters.</p>

<p style="margin-top: 1em">Packet capturing is performed
with the pcap library. The capture filter syntax follows the
rules of the pcap library. This syntax is different from the
read filter syntax. A <br>
read filter can also be specified when capturing, and only
packets that pass the read filter will be displayed or saved
to the output file; note, however, that capture filters <br>
are much more efficient than read filters, and it may be
more difficult for TShark to keep up with a busy network if
a read filter is specified for a live capture.</p>

<p style="margin-top: 1em">A capture or read filter can
either be specified with the -f or -R option, respectively,
in which case the entire filter expression must be specified
as a single argument (which <br>
means that if it contains spaces, it must be quoted), or can
be specified with command-line arguments after the option
arguments, in which case all the arguments after the filter
<br>
arguments are treated as a filter expression. Capture
filters are supported only when doing a live capture; read
filters are supported when doing a live capture and when
reading <br>
a capture file, but require TShark to do more work when
filtering, so you might be more likely to lose packets under
heavy load if you&rsquo;re using a read filter. If the
filter is <br>
specified with command-line arguments after the option
arguments, it&rsquo;s a capture filter if a capture is being
done (i.e., if no -r option was specified) and a read filter
if a <br>
capture file is being read (i.e., if a -r option was
specified).</p>

<p style="margin-top: 1em">The -G option is a special mode
that simply causes Tshark to dump one of several types of
internal glossaries and then exit.</p>

<p style="margin-top: 1em">OPTIONS <br>
-2 Perform a two-pass analysis. This causes tshark to buffer
output until the entire first pass is done, but allows it to
fill in fields that require future knowledge, such as <br>
&rsquo;response in frame #&rsquo; fields. Also permits
reassembly frame dependencies to be calculated
correctly.</p>

<p style="margin-top: 1em">-a &lt;capture autostop
condition&gt; <br>
Specify a criterion that specifies when TShark is to stop
writing to a capture file. The criterion is of the form
test:value, where test is one of:</p>

<p style="margin-top: 1em">duration:value Stop writing to a
capture file after value seconds have elapsed.</p>

<p style="margin-top: 1em">filesize:value Stop writing to a
capture file after it reaches a size of value kB. If this
option is used together with the -b option, TShark will stop
writing to the <br>
current capture file and switch to the next one if filesize
is reached. When reading a capture file, TShark will stop
reading the file after the number of bytes read exceeds <br>
this number (the complete packet will be read, so more bytes
than this number may be read). Note that the filesize is
limited to a maximum value of 2 GiB.</p>

<p style="margin-top: 1em">files:value Stop writing to
capture files after value number of files were written.</p>

<p style="margin-top: 1em">-b &lt;capture ring buffer
option&gt; <br>
Cause TShark to run in &quot;multiple files&quot; mode. In
&quot;multiple files&quot; mode, TShark will write to
several capture files. When the first capture file fills up,
TShark will switch <br>
writing to the next file and so on.</p>

<p style="margin-top: 1em">The created filenames are based
on the filename given with the -w option, the number of the
file and on the creation date and time, e.g.
outfile_00001_20050604120117.pcap, <br>
outfile_00002_20050604120523.pcap, ...</p>

<p style="margin-top: 1em">With the files option it&rsquo;s
also possible to form a &quot;ring buffer&quot;. This will
fill up new files until the number of files specified, at
which point TShark will discard the <br>
data in the first file and start writing to that file and so
on. If the files option is not set, new files filled up
until one of the capture stop conditions match (or until
<br>
the disk is full).</p>

<p style="margin-top: 1em">The criterion is of the form
key:value, where key is one of:</p>

<p style="margin-top: 1em">duration:value switch to the
next file after value seconds have elapsed, even if the
current file is not completely filled up.</p>

<p style="margin-top: 1em">filesize:value switch to the
next file after it reaches a size of value kB. Note that the
filesize is limited to a maximum value of 2 GiB.</p>

<p style="margin-top: 1em">files:value begin again with the
first file after value number of files were written (form a
ring buffer). This value must be less than 100000. Caution
should be used when <br>
using large numbers of files: some filesystems do not handle
many files in a single directory well. The files criterion
requires either duration or filesize to be specified <br>
to control when to go to the next file. It should be noted
that each -b parameter takes exactly one criterion; to
specify two criterion, each must be preceded by the -b <br>
option.</p>

<p style="margin-top: 1em">Example: -b filesize:1000 -b
files:5 results in a ring buffer of five files of size one
megabyte each.</p>

<p style="margin-top: 1em">-B &lt;capture buffer size&gt;
<br>
Set capture buffer size (in MiB, default is 2 MiB). This is
used by the capture driver to buffer packet data until that
data can be written to disk. If you encounter packet <br>
drops while capturing, try to increase this size. Note that,
while Tshark attempts to set the buffer size to 2 MiB by
default, and can be told to set it to a larger value, <br>
the system or interface on which you&rsquo;re capturing
might silently limit the capture buffer size to a lower
value or raise it to a higher value.</p>

<p style="margin-top: 1em">This is available on UNIX
systems with libpcap 1.0.0 or later and on Windows. It is
not available on UNIX systems with earlier versions of
libpcap.</p>

<p style="margin-top: 1em">This option can occur multiple
times. If used before the first occurrence of the -i option,
it sets the default capture buffer size. If used after an -i
option, it sets the <br>
capture buffer size for the interface specified by the last
-i option occurring before this option. If the capture
buffer size is not set specifically, the default capture
<br>
buffer size is used instead.</p>

<p style="margin-top: 1em">-c &lt;capture packet count&gt;
<br>
Set the maximum number of packets to read when capturing
live data. If reading a capture file, set the maximum number
of packets to read.</p>

<p style="margin-top: 1em">-C &lt;configuration profile&gt;
<br>
Run with the given configuration profile.</p>

<p style="margin-top: 1em">-d &lt;layer
type&gt;==&lt;selector&gt;,&lt;decode-as protocol&gt; <br>
Like Wireshark&rsquo;s Decode As... feature, this lets you
specify how a layer type should be dissected. If the layer
type in question (for example, tcp.port or udp.port for a
TCP <br>
or UDP port number) has the specified selector value,
packets should be dissected as the specified protocol.</p>

<p style="margin-top: 1em">Example: -d tcp.port==8888,http
will decode any traffic running over TCP port 8888 as
HTTP.</p>

<p style="margin-top: 1em">Example: -d
tcp.port==8888:3,http will decode any traffic running over
TCP ports 8888, 8889 or 8890 as HTTP.</p>

<p style="margin-top: 1em">Example: -d
tcp.port==8888-8890,http will decode any traffic running
over TCP ports 8888, 8889 or 8890 as HTTP.</p>

<p style="margin-top: 1em">Using an invalid selector or
protocol will print out a list of valid selectors and
protocol names, respectively.</p>

<p style="margin-top: 1em">Example: -d . is a quick way to
get a list of valid selectors.</p>

<p style="margin-top: 1em">Example: -d ethertype==0x0800.
is a quick way to get a list of protocols that can be
selected with an ethertype.</p>

<p style="margin-top: 1em">-D Print a list of the
interfaces on which TShark can capture, and exit. For each
network interface, a number and an interface name, possibly
followed by a text description of <br>
the interface, is printed. The interface name or the number
can be supplied to the -i option to specify an interface on
which to capture.</p>

<p style="margin-top: 1em">This can be useful on systems
that don&rsquo;t have a command to list them (e.g., Windows
systems, or UNIX systems lacking ifconfig -a); the number
can be useful on Windows 2000 <br>
and later systems, where the interface name is a somewhat
complex string.</p>

<p style="margin-top: 1em">Note that &quot;can
capture&quot; means that TShark was able to open that device
to do a live capture. Depending on your system you may need
to run tshark from an account with special <br>
privileges (for example, as root) to be able to capture
network traffic. If TShark -D is not run from such an
account, it will not list any interfaces.</p>

<p style="margin-top: 1em">-e &lt;field&gt; <br>
Add a field to the list of fields to display if -T fields is
selected. This option can be used multiple times on the
command line. At least one field must be provided if <br>
the -T fields option is selected. Column names may be used
prefixed with &quot;col.&quot;</p>

<p style="margin-top: 1em">Example: -e frame.number -e
ip.addr -e udp -e col.info</p>

<p style="margin-top: 1em">Giving a protocol rather than a
single field will print multiple items of data about the
protocol as a single field. Fields are separated by tab
characters by default. -E <br>
controls the format of the printed fields.</p>

<p style="margin-top: 1em">-E &lt;field print option&gt;
<br>
Set an option controlling the printing of fields when -T
fields is selected.</p>

<p style="margin-top: 1em">Options are:</p>

<p style="margin-top: 1em">header=y|n If y, print a list of
the field names given using -e as the first line of the
output; the field name will be separated using the same
character as the field <br>
values. Defaults to n.</p>


<p style="margin-top: 1em">separator=/t|/s|&lt;character&gt;
Set the separator character to use for fields. If /t tab
will be used (this is the default), if /s, a single space
will be used. Otherwise any <br>
character that can be accepted by the command line as part
of the option may be used.</p>

<p style="margin-top: 1em">occurrence=f|l|a Select which
occurrence to use for fields that have multiple occurrences.
If f the first occurrence will be used, if l the last
occurrence will be used and <br>
if a all occurrences will be used (this is the default).</p>


<p style="margin-top: 1em">aggregator=,|/s|&lt;character&gt;
Set the aggregator character to use for fields that have
multiple occurrences. If , a comma will be used (this is the
default), if /s, a single <br>
space will be used. Otherwise any character that can be
accepted by the command line as part of the option may be
used.</p>

<p style="margin-top: 1em">quote=d|s|n Set the quote
character to use to surround fields. d uses double-quotes, s
single-quotes, n no quotes (the default).</p>

<p style="margin-top: 1em">-f &lt;capture filter&gt; <br>
Set the capture filter expression.</p>

<p style="margin-top: 1em">This option can occur multiple
times. If used before the first occurrence of the -i option,
it sets the default capture filter expression. If used after
an -i option, it <br>
sets the capture filter expression for the interface
specified by the last -i option occurring before this
option. If the capture filter expression is not set
specifically, <br>
the default capture filter expression is used if
provided.</p>

<p style="margin-top: 1em">-F &lt;file format&gt; <br>
Set the file format of the output capture file written using
the -w option. The output written with the -w option is raw
packet data, not text, so there is no -F option to <br>
request text output. The option -F without a value will list
the available formats.</p>

<p style="margin-top: 1em">-g This option causes the output
file(s) to be created with group-read permission (meaning
that the output file(s) can be read by other members of the
calling user&rsquo;s group).</p>

<p style="margin-top: 1em">-G
[fields|protocols|values|decodes|defaultprefs|currentprefs]
<br>
The -G option will cause Tshark to dump one of several types
of glossaries and then exit. If no specific glossary type is
specified, then the fields report will be generated <br>
by default.</p>

<p style="margin-top: 1em">The available report types
include:</p>

<p style="margin-top: 1em">fields Dumps the contents of the
registration database to stdout. An independent program can
take this output and format it into nice tables or HTML or
whatever. There is <br>
one record per line. Each record is either a protocol or a
header field, differentiated by the first field. The fields
are tab-delimited.</p>

<p style="margin-top: 1em">* Protocols <br>
* --------- <br>
* Field 1 = &rsquo;P&rsquo; <br>
* Field 2 = descriptive protocol name <br>
* Field 3 = protocol abbreviation <br>
* <br>
* Header Fields <br>
* ------------- <br>
* Field 1 = &rsquo;F&rsquo; <br>
* Field 2 = descriptive field name <br>
* Field 3 = field abbreviation <br>
* Field 4 = type ( textual representation of the ftenum type
) <br>
* Field 5 = parent protocol abbreviation <br>
* Field 6 = base for display (for integer types);
&quot;parent bitfield width&quot; for FT_BOOLEAN <br>
* Field 7 = bitmask: format: hex: 0x.... <br>
* Field 8 = blurb describing field</p>

<p style="margin-top: 1em">protocols Dumps the protocols in
the registration database to stdout. An independent program
can take this output and format it into nice tables or HTML
or whatever. There <br>
is one record per line. The fields are tab-delimited.</p>

<p style="margin-top: 1em">* Field 1 = protocol name <br>
* Field 2 = protocol short name <br>
* Field 3 = protocol filter name</p>

<p style="margin-top: 1em">values Dumps the value_strings,
range_strings or true/false strings for fields that have
them. There is one record per line. Fields are
tab-delimited. There are three <br>
types of records: Value String, Range String and True/False
String. The first field, &rsquo;V&rsquo;, &rsquo;R&rsquo; or
&rsquo;T&rsquo;, indicates the type of record.</p>

<p style="margin-top: 1em">* Value Strings <br>
* ------------- <br>
* Field 1 = &rsquo;V&rsquo; <br>
* Field 2 = field abbreviation to which this value string
corresponds <br>
* Field 3 = Integer value <br>
* Field 4 = String <br>
* <br>
* Range Strings <br>
* ------------- <br>
* Field 1 = &rsquo;R&rsquo; <br>
* Field 2 = field abbreviation to which this range string
corresponds <br>
* Field 3 = Integer value: lower bound <br>
* Field 4 = Integer value: upper bound <br>
* Field 5 = String <br>
* <br>
* True/False Strings <br>
* ------------------ <br>
* Field 1 = &rsquo;T&rsquo; <br>
* Field 2 = field abbreviation to which this true/false
string corresponds <br>
* Field 3 = True String <br>
* Field 4 = False String</p>

<p style="margin-top: 1em">decodes Dumps the &quot;layer
type&quot;/&quot;decode as&quot; associations to stdout.
There is one record per line. The fields are
tab-delimited.</p>

<p style="margin-top: 1em">* Field 1 = layer type, e.g.
&quot;tcp.port&quot; <br>
* Field 2 = selector in decimal <br>
* Field 3 = &quot;decode as&quot; name, e.g.
&quot;http&quot;</p>

<p style="margin-top: 1em">defaultprefs Dumps a default
preferences file to stdout.</p>

<p style="margin-top: 1em">currentprefs Dumps a copy of the
current preferences file to stdout.</p>

<p style="margin-top: 1em">-h Print the version and options
and exits.</p>

<p style="margin-top: 1em">-H &lt;input hosts file&gt; <br>
Read a list of entries from a &quot;hosts&quot; file, which
will then be written to a capture file. Implies -W n. Can be
called multiple times.</p>

<p style="margin-top: 1em">The &quot;hosts&quot; file
format is documented at
&lt;http://en.wikipedia.org/wiki/Hosts_(file)&gt;.</p>

<p style="margin-top: 1em">-i &lt;capture interface&gt; | -
<br>
Set the name of the network interface or pipe to use for
live packet capture.</p>

<p style="margin-top: 1em">Network interface names should
match one of the names listed in &quot;tshark -D&quot;
(described above); a number, as reported by &quot;tshark
-D&quot;, can also be used. If you&rsquo;re using UNIX, <br>
&quot;netstat -i&quot; or &quot;ifconfig -a&quot; might also
work to list interface names, although not all versions of
UNIX support the -a option to ifconfig.</p>

<p style="margin-top: 1em">If no interface is specified,
TShark searches the list of interfaces, choosing the first
non-loopback interface if there are any non-loopback
interfaces, and choosing the <br>
first loopback interface if there are no non-loopback
interfaces. If there are no interfaces at all, TShark
reports an error and doesn&rsquo;t start the capture.</p>

<p style="margin-top: 1em">Pipe names should be either the
name of a FIFO (named pipe) or &lsquo;&lsquo;-&rsquo;&rsquo;
to read data from the standard input. Data read from pipes
must be in standard pcap format.</p>

<p style="margin-top: 1em">This option can occur multiple
times. When capturing from multiple interfaces, the capture
file will be saved in pcap-ng format.</p>

<p style="margin-top: 1em">Note: the Win32 version of
TShark doesn&rsquo;t support capturing from pipes!</p>

<p style="margin-top: 1em">-I Put the interface in
&quot;monitor mode&quot;; this is supported only on IEEE
802.11 Wi-Fi interfaces, and supported only on some
operating systems.</p>

<p style="margin-top: 1em">Note that in monitor mode the
adapter might disassociate from the network with which
it&rsquo;s associated, so that you will not be able to use
any wireless networks with that <br>
adapter. This could prevent accessing files on a network
server, or resolving host names or network addresses, if you
are capturing in monitor mode and are not connected to <br>
another network with another adapter.</p>

<p style="margin-top: 1em">This option can occur multiple
times. If used before the first occurrence of the -i option,
it enables the monitor mode for all interfaces. If used
after an -i option, it <br>
enables the monitor mode for the interface specified by the
last -i option occurring before this option.</p>

<p style="margin-top: 1em">-K &lt;keytab&gt; <br>
Load kerberos crypto keys from the specified keytab file.
This option can be used multiple times to load keys from
several files.</p>

<p style="margin-top: 1em">Example: -K krb5.keytab</p>

<p style="margin-top: 1em">-l Flush the standard output
after the information for each packet is printed. (This is
not, strictly speaking, line-buffered if -V was specified;
however, it is the same as <br>
line-buffered if -V wasn&rsquo;t specified, as only one line
is printed for each packet, and, as -l is normally used when
piping a live capture to a program or script, so that <br>
output for a packet shows up as soon as the packet is seen
and dissected, it should work just as well as true
line-buffering. We do this as a workaround for a deficiency
in <br>
the Microsoft Visual C++ C library.)</p>

<p style="margin-top: 1em">This may be useful when piping
the output of TShark to another program, as it means that
the program to which the output is piped will see the
dissected data for a packet as <br>
soon as TShark sees the packet and generates that output,
rather than seeing it only when the standard output buffer
containing that data fills up.</p>

<p style="margin-top: 1em">-L List the data link types
supported by the interface and exit. The reported link types
can be used for the -y option.</p>

<p style="margin-top: 1em">-n Disable network object name
resolution (such as hostname, TCP and UDP port names); the
-N flag might override this one.</p>

<p style="margin-top: 1em">-N &lt;name resolving flags&gt;
<br>
Turn on name resolving only for particular types of
addresses and port numbers, with name resolving for other
types of addresses and port numbers turned off. This flag
<br>
overrides -n if both -N and -n are present. If both -N and
-n flags are not present, all name resolutions are turned
on.</p>

<p style="margin-top: 1em">The argument is a string that
may contain the letters:</p>

<p style="margin-top: 1em">m to enable MAC address
resolution</p>

<p style="margin-top: 1em">n to enable network address
resolution</p>

<p style="margin-top: 1em">N to enable using external
resolvers (e.g., DNS) for network address resolution</p>

<p style="margin-top: 1em">t to enable transport-layer port
number resolution</p>

<p style="margin-top: 1em">C to enable concurrent
(asynchronous) DNS lookups</p>

<p style="margin-top: 1em">-o
&lt;preference&gt;:&lt;value&gt; <br>
Set a preference value, overriding the default value and any
value read from a preference file. The argument to the
option is a string of the form prefname:value, where <br>
prefname is the name of the preference (which is the same
name that would appear in the preference file), and value is
the value to which it should be set.</p>

<p style="margin-top: 1em">-O &lt;protocols&gt; <br>
Similar to the -V option, but causes TShark to only show a
detailed view of the comma-separated list of protocols
specified, rather than a detailed view of all protocols.
<br>
Use the output of &quot;tshark -G protocols&quot; to find
the abbreviations of the protocols you can specify.</p>

<p style="margin-top: 1em">-p Don&rsquo;t put the interface
into promiscuous mode. Note that the interface might be in
promiscuous mode for some other reason; hence, -p cannot be
used to ensure that the only <br>
traffic that is captured is traffic sent to or from the
machine on which TShark is running, broadcast traffic, and
multicast traffic to addresses received by that machine.</p>

<p style="margin-top: 1em">This option can occur multiple
times. If used before the first occurrence of the -i option,
no interface will be put into the promiscuous mode. If used
after an -i option, <br>
the interface specified by the last -i option occurring
before this option will not be put into the promiscuous
mode.</p>

<p style="margin-top: 1em">-P Decode and display the packet
summary, even if writing raw packet data using the -w
option.</p>

<p style="margin-top: 1em">-q When capturing packets,
don&rsquo;t display the continuous count of packets captured
that is normally shown when saving a capture to a file;
instead, just display, at the end of <br>
the capture, a count of packets captured. On systems that
support the SIGINFO signal, such as various BSDs, you can
cause the current count to be displayed by typing your <br>
&quot;status&quot; character (typically control-T, although
it might be set to &quot;disabled&quot; by default on at
least some BSDs, so you&rsquo;d have to explicitly set it to
use it).</p>

<p style="margin-top: 1em">When reading a capture file, or
when capturing and not saving to a file, don&rsquo;t print
packet information; this is useful if you&rsquo;re using a
-z option to calculate statistics <br>
and don&rsquo;t want the packet information printed, just
the statistics.</p>

<p style="margin-top: 1em">-Q When capturing packets, only
display true errors. This outputs less than the -q option,
so the interface name and total packet count and the end of
a capture are not sent to <br>
stderr.</p>

<p style="margin-top: 1em">-r &lt;infile&gt; <br>
Read packet data from infile, can be any supported capture
file format (including gzipped files). It&rsquo;s not
possible to use named pipes or stdin here!</p>

<p style="margin-top: 1em">-R &lt;Read filter&gt; <br>
Cause the specified filter (which uses the syntax of
read/display filters, rather than that of capture filters)
to be applied during the first pass of analysis. Packets not
<br>
matching the filter are not considered for future passes.
Only makes sense with multiple passes, see -2. For regular
filtering on single-pass dissect see -Y instead.</p>

<p style="margin-top: 1em">Note that forward-looking fields
such as &rsquo;response in frame #&rsquo; cannot be used
with this filter, since they will not have been calculate
when this filter is applied.</p>

<p style="margin-top: 1em">-Y &lt;displaY filter&gt; <br>
Cause the specified filter (which uses the syntax of
read/display filters, rather than that of capture filters)
to be applied before printing a decoded form of packets or
<br>
writing packets to a file. Packets matching the filter are
printed or written to file; packets that the matching
packets depend upon (e.g., fragments), are not printed but
<br>
are written to file; packets not matching the filter nor
depended upon are discarded rather than being printed or
written.</p>

<p style="margin-top: 1em">Use this instead of -R for
filtering using single-pass analysis. If doing two-pass
analysis (see -2) then only packets matching the read filter
(if there is one) will be <br>
checked against this filter.</p>

<p style="margin-top: 1em">-s &lt;capture snaplen&gt; <br>
Set the default snapshot length to use when capturing live
data. No more than snaplen bytes of each network packet will
be read into memory, or saved to disk. A value of 0 <br>
specifies a snapshot length of 65535, so that the full
packet is captured; this is the default.</p>

<p style="margin-top: 1em">This option can occur multiple
times. If used before the first occurrence of the -i option,
it sets the default snapshot length. If used after an -i
option, it sets the <br>
snapshot length for the interface specified by the last -i
option occurring before this option. If the snapshot length
is not set specifically, the default snapshot length <br>
is used if provided.</p>

<p style="margin-top: 1em">-S &lt;separator&gt; <br>
Set the line separator to be printed between packets.</p>

<p style="margin-top: 1em">-t a|ad|d|dd|e|r|u|ud <br>
Set the format of the packet timestamp printed in summary
lines. The format can be one of:</p>

<p style="margin-top: 1em">a absolute: The absolute time is
the actual time the packet was captured, with no date
displayed</p>

<p style="margin-top: 1em">ad absolute with date: The
absolute date and time is the actual time and date the
packet was captured</p>

<p style="margin-top: 1em">d delta: The delta time is the
time since the previous packet was captured</p>

<p style="margin-top: 1em">dd delta_displayed: The
delta_displayed time is the time since the previous
displayed packet was captured</p>

<p style="margin-top: 1em">e epoch: The time in seconds
since epoch (Jan 1, 1970 00:00:00)</p>

<p style="margin-top: 1em">r relative: The relative time is
the time elapsed between the first packet and the current
packet</p>

<p style="margin-top: 1em">u UTC: The UTC time is the
actual time the packet was captured, with no date
displayed</p>

<p style="margin-top: 1em">ud UTC with date: The UTC date
and time is the actual time and date the packet was
captured</p>

<p style="margin-top: 1em">The default format is
relative.</p>

<p style="margin-top: 1em">-T pdml|psml|ps|text|fields <br>
Set the format of the output when viewing decoded packet
data. The options are one of:</p>

<p style="margin-top: 1em">pdml Packet Details Markup
Language, an XML-based format for the details of a decoded
packet. This information is equivalent to the packet details
printed with the -V flag.</p>

<p style="margin-top: 1em">psml Packet Summary Markup
Language, an XML-based format for the summary information of
a decoded packet. This information is equivalent to the
information shown in the one- <br>
line summary printed by default.</p>

<p style="margin-top: 1em">ps PostScript for a
human-readable one-line summary of each of the packets, or a
multi-line view of the details of each of the packets,
depending on whether the -V flag was <br>
specified.</p>

<p style="margin-top: 1em">text Text of a human-readable
one-line summary of each of the packets, or a multi-line
view of the details of each of the packets, depending on
whether the -V flag was <br>
specified. This is the default.</p>

<p style="margin-top: 1em">fields The values of fields
specified with the -e option, in a form specified by the -E
option. For example,</p>

<p style="margin-top: 1em">-T fields -E separator=, -E
quote=d</p>

<p style="margin-top: 1em">would generate comma-separated
values (CSV) output suitable for importing into your
favorite spreadsheet program.</p>

<p style="margin-top: 1em">-v Print the version and
exit.</p>

<p style="margin-top: 1em">-V Cause TShark to print a view
of the packet details.</p>

<p style="margin-top: 1em">-w &lt;outfile&gt; | - <br>
Write raw packet data to outfile or to the standard output
if outfile is &rsquo;-&rsquo;.</p>

<p style="margin-top: 1em">NOTE: -w provides raw packet
data, not text. If you want text output you need to redirect
stdout (e.g. using &rsquo;&gt;&rsquo;), don&rsquo;t use the
-w option for this.</p>

<p style="margin-top: 1em">-W &lt;file format option&gt;
<br>
Save extra information in the file if the format supports
it. For example,</p>

<p style="margin-top: 1em">-F pcapng -W n</p>

<p style="margin-top: 1em">will save host name resolution
records along with captured packets.</p>

<p style="margin-top: 1em">Future versions of Wireshark may
automatically change the capture format to pcapng as
needed.</p>

<p style="margin-top: 1em">The argument is a string that
may contain the following letter:</p>

<p style="margin-top: 1em">n write network address
resolution information (pcapng only)</p>

<p style="margin-top: 1em">-x Cause TShark to print a hex
and ASCII dump of the packet data after printing the summary
and/or details, if either are also being displayed.</p>

<p style="margin-top: 1em">-X &lt;eXtension options&gt;
<br>
Specify an option to be passed to a TShark module. The
eXtension option is in the form extension_key:value, where
extension_key can be:</p>

<p style="margin-top: 1em">lua_script:lua_script_filename
tells Wireshark to load the given script in addition to the
default Lua scripts.</p>

<p style="margin-top: 1em">-y &lt;capture link type&gt;
<br>
Set the data link type to use while capturing packets. The
values reported by -L are the values that can be used.</p>

<p style="margin-top: 1em">This option can occur multiple
times. If used before the first occurrence of the -i option,
it sets the default capture link type. If used after an -i
option, it sets the <br>
capture link type for the interface specified by the last -i
option occurring before this option. If the capture link
type is not set specifically, the default capture link <br>
type is used if provided.</p>

<p style="margin-top: 1em">-z &lt;statistics&gt; <br>
Get TShark to collect various types of statistics and
display the result after finishing reading the capture file.
Use the -q flag if you&rsquo;re reading a capture file and
only <br>
want the statistics printed, not any per-packet
information.</p>

<p style="margin-top: 1em">Note that the -z proto option is
different - it doesn&rsquo;t cause statistics to be gathered
and printed when the capture is complete, it modifies the
regular packet summary <br>
output to include the values of fields specified with the
option. Therefore you must not use the -q option, as that
option would suppress the printing of the regular packet
<br>
summary output, and must also not use the -V option, as that
would cause packet detail information rather than packet
summary information to be printed.</p>

<p style="margin-top: 1em">Currently implemented statistics
are:</p>

<p style="margin-top: 1em">-z help <br>
Display all possible values for -z.</p>

<p style="margin-top: 1em">-z afp,srt[,filter] <br>
-z camel,srt <br>
-z compare,start,stop,ttl[0|1],order[0|1],variance[,filter]
<br>
If the optional filter is specified, only those packets that
match the filter will be used in the calculations.</p>

<p style="margin-top: 1em">-z conv,type[,filter] <br>
Create a table that lists all conversations that could be
seen in the capture. type specifies the conversation
endpoint types for which we want to generate the <br>
statistics; currently the supported ones are:</p>

<p style="margin-top: 1em">&quot;eth&quot; Ethernet
addresses <br>
&quot;fc&quot; Fibre Channel addresses <br>
&quot;fddi&quot; FDDI addresses <br>
&quot;ip&quot; IPv4 addresses <br>
&quot;ipv6&quot; IPv6 addresses <br>
&quot;ipx&quot; IPX addresses <br>
&quot;tcp&quot; TCP/IP socket pairs Both IPv4 and IPv6 are
supported <br>
&quot;tr&quot; Token Ring addresses <br>
&quot;udp&quot; UDP/IP socket pairs Both IPv4 and IPv6 are
supported</p>

<p style="margin-top: 1em">If the optional filter is
specified, only those packets that match the filter will be
used in the calculations.</p>

<p style="margin-top: 1em">The table is presented with one
line for each conversation and displays the number of
packets/bytes in each direction as well as the total number
of packets/bytes. The <br>
table is sorted according to the total number of frames.</p>

<p style="margin-top: 1em">-z
dcerpc,srt,uuid,major.minor[,filter] <br>
Collect call/reply SRT (Service Response Time) data for
DCERPC interface uuid, version major.minor. Data collected
is the number of calls for each procedure, MinSRT, <br>
MaxSRT and AvgSRT.</p>

<p style="margin-top: 1em">Example: -z
dcerpc,srt,12345778-1234-abcd-ef00-0123456789ac,1.0 will
collect data for the CIFS SAMR Interface.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter.</p>

<p style="margin-top: 1em">Example: -z
dcerpc,srt,12345778-1234-abcd-ef00-0123456789ac,1.0,ip.addr==1.2.3.4
will collect SAMR SRT statistics for a specific host.</p>

<p style="margin-top: 1em">-z
diameter,avp[,cmd.code,field,field,...] <br>
This option enables extraction of most important diameter
fields from large capture files. Exactly one text line for
each diameter message with matched diameter.cmd.code <br>
will be printed.</p>

<p style="margin-top: 1em">Empty diameter command code or
&rsquo;*&rsquo; can be specified to mach any
diameter.cmd.code</p>

<p style="margin-top: 1em">Example: -z diameter,avp extract
default field set from diameter messages.</p>

<p style="margin-top: 1em">Example: -z diameter,avp,280
extract default field set from diameter DWR messages.</p>

<p style="margin-top: 1em">Example: -z diameter,avp,272
extract default field set from diameter CC messages.</p>

<p style="margin-top: 1em">Extract most important fields
from diameter CC messages:</p>

<p style="margin-top: 1em">tshark -r file.cap.gz -q -z
diameter,avp,272,CC-Request-Type,CC-Request-Number,Session-Id,Subscription-Id-Data,Rating-Group,Result-Code</p>

<p style="margin-top: 1em">Following fields will be printed
out for each diameter message:</p>

<p style="margin-top: 1em">&quot;frame&quot; Frame number.
<br>
&quot;time&quot; Unix time of the frame arrival. <br>
&quot;src&quot; Source address. <br>
&quot;srcport&quot; Source port. <br>
&quot;dst&quot; Destination address. <br>
&quot;dstport&quot; Destination port. <br>
&quot;proto&quot; Constant string &rsquo;diameter&rsquo;,
which can be used for post processing of tshark output. E.g.
grep/sed/awk. <br>
&quot;msgnr&quot; seq. number of diameter message within the
frame. E.g. &rsquo;2&rsquo; for the third diameter message
in the same frame. <br>
&quot;is_request&quot; &rsquo;0&rsquo; if message is a
request, &rsquo;1&rsquo; if message is an answer. <br>
&quot;cmd&quot; diameter.cmd_code, E.g. &rsquo;272&rsquo;
for credit control messages. <br>
&quot;req_frame&quot; Number of frame where matched request
was found or &rsquo;0&rsquo;. <br>
&quot;ans_frame&quot; Number of frame where matched answer
was found or &rsquo;0&rsquo;. <br>
&quot;resp_time&quot; response time in seconds,
&rsquo;0&rsquo; in case if matched Request/Answer is not
found in trace. E.g. in the begin or end of capture.</p>

<p style="margin-top: 1em">-z diameter,avp option is much
faster than -V -T text or -T pdml options.</p>

<p style="margin-top: 1em">-z diameter,avp option is more
powerful than -T field and -z proto,colinfo options.</p>

<p style="margin-top: 1em">Multiple diameter messages in
one frame are supported.</p>

<p style="margin-top: 1em">Several fields with same name
within one diameter message are supported, e.g.
diameter.Subscription-Id-Data or diameter.Rating-Group.</p>

<p style="margin-top: 1em">Note: tshark -q option is
recommended to suppress default tshark output.</p>

<p style="margin-top: 1em">-z
expert[,error|,warn|,note|,chat][,filter] <br>
Collects information about all expert info, and will display
them in order, grouped by severity.</p>

<p style="margin-top: 1em">Example: -z expert,sip will show
expert items of all severity for frames that match the sip
protocol.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter.</p>

<p style="margin-top: 1em">Example: -z
&quot;expert,note,tcp&quot; will only collect expert items
for frames that include the tcp protocol, with a severity of
note or higher.</p>

<p style="margin-top: 1em">-z
follow,prot,mode,filter[,range] <br>
Displays the contents of a TCP or UDP stream between two
nodes. The data sent by the second node is prefixed with a
tab to differentiate it from the data sent by the <br>
first node.</p>

<p style="margin-top: 1em">prot specifies the transport
protocol. It can be one of: <br>
tcp TCP <br>
udp UDP <br>
ssl SSL</p>

<p style="margin-top: 1em">mode specifies the output mode.
It can be one of: <br>
ascii ASCII output with dots for non-printable characters
<br>
hex Hexadecimal and ASCII data with offsets <br>
raw Hexadecimal data</p>

<p style="margin-top: 1em">Since the output in ascii mode
may contain newlines, the length of each section of output
plus a newline precedes each section of output.</p>

<p style="margin-top: 1em">filter specifies the stream to
be displayed. UDP streams are selected with IP address plus
port pairs. TCP streams are selected with either the stream
index or IP <br>
address plus port pairs. For example: <br>
ip-addr0:port0,ip-addr1:port1 <br>
tcp-stream-index</p>

<p style="margin-top: 1em">range optionally specifies which
&quot;chunks&quot; of the stream should be displayed.</p>

<p style="margin-top: 1em">Example: -z
&quot;follow,tcp,hex,1&quot; will display the contents of
the first TCP stream in &quot;hex&quot; format.</p>


<p style="margin-top: 1em">===================================================================
<br>
Follow: tcp,hex <br>
Filter: tcp.stream eq 1 <br>
Node 0: 200.57.7.197:32891 <br>
Node 1: 200.57.7.198:2906 <br>
00000000 00 00 00 22 00 00 00 07 00 0a 85 02 07 e9 00 02
...&quot;.... ........ <br>
00000010 07 e9 06 0f 00 0d 00 04 00 00 00 01 00 03 00 06
........ ........ <br>
00000020 1f 00 06 04 00 00 ...... <br>
00000000 00 01 00 00 .... <br>
00000026 00 02 00 00</p>

<p style="margin-top: 1em">Example: -z
&quot;follow,tcp,ascii,200.57.7.197:32891,200.57.7.198:2906&quot;
will display the contents of a TCP stream between
200.57.7.197 port 32891 and 200.57.7.98 port 2906.</p>


<p style="margin-top: 1em">===================================================================
<br>
Follow: tcp,ascii <br>
Filter: (ommitted for readability) <br>
Node 0: 200.57.7.197:32891 <br>
Node 1: 200.57.7.198:2906 <br>
38 <br>
...&quot;..... <br>
................ <br>
4 <br>
....</p>

<p style="margin-top: 1em">-z h225,counter[,filter] <br>
Count ITU-T H.225 messages and their reasons. In the first
column you get a list of H.225 messages and H.225 message
reasons, which occur in the current capture file. <br>
The number of occurrences of each message or reason is
displayed in the second column.</p>

<p style="margin-top: 1em">Example: -z h225,counter.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter. Example: use -z
&quot;h225,counter,ip.addr==1.2.3.4&quot; to only <br>
collect stats for H.225 packets exchanged by the host at IP
address 1.2.3.4 .</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">-z h225,srt[,filter] <br>
Collect requests/response SRT (Service Response Time) data
for ITU-T H.225 RAS. Data collected is number of calls of
each ITU-T H.225 RAS Message Type, Minimum SRT, <br>
Maximum SRT, Average SRT, Minimum in Packet, and Maximum in
Packet. You will also get the number of Open Requests
(Unresponded Requests), Discarded Responses (Responses <br>
without matching request) and Duplicate Messages.</p>

<p style="margin-top: 1em">Example: -z h225,srt</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter.</p>

<p style="margin-top: 1em">Example: -z
&quot;h225,srt,ip.addr==1.2.3.4&quot; will only collect
stats for ITU-T H.225 RAS packets exchanged by the host at
IP address 1.2.3.4 .</p>

<p style="margin-top: 1em">-z hosts[,ipv4][,ipv6] <br>
Dump any collected IPv4 and/or IPv6 addresses in
&quot;hosts&quot; format. Both IPv4 and IPv6 addresses are
dumped by default.</p>

<p style="margin-top: 1em">Addresses are collected from a
number of sources, including standard &quot;hosts&quot;
files and captured traffic.</p>

<p style="margin-top: 1em">-z http,stat, <br>
Calculate the HTTP statistics distribution. Displayed values
are the HTTP status codes and the HTTP request methods.</p>

<p style="margin-top: 1em">-z http,tree <br>
Calculate the HTTP packet distribution. Displayed values are
the HTTP request modes and the HTTP status codes.</p>

<p style="margin-top: 1em">-z http_req,tree <br>
Calculate the HTTP requests by server. Displayed values are
the server name and the URI path.</p>

<p style="margin-top: 1em">-z http_srv,tree <br>
Calculate the HTTP requests and responses by server. For the
HTTP requests, displayed values are the server IP address
and server hostname. For the HTTP responses, <br>
displayed values are the server IP address and status.</p>

<p style="margin-top: 1em">-z icmp,srt[,filter] <br>
Compute total ICMP echo requests, replies, loss, and percent
loss, as well as minimum, maximum, mean, median and sample
standard deviation SRT statistics typical of what <br>
ping provides.</p>

<p style="margin-top: 1em">Example: -z
icmp,srt,ip.src==1.2.3.4 will collect ICMP SRT statistics
for ICMP echo request packets originating from a specific
host.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">-z icmpv6,srt[,filter] <br>
Compute total ICMPv6 echo requests, replies, loss, and
percent loss, as well as minimum, maximum, mean, median and
sample standard deviation SRT statistics typical of <br>
what ping provides.</p>

<p style="margin-top: 1em">Example: -z
icmpv6,srt,ipv6.src==fe80::1 will collect ICMPv6 SRT
statistics for ICMPv6 echo request packets originating from
a specific host.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">-z io,phs[,filter] <br>
Create Protocol Hierarchy Statistics listing both number of
packets and bytes. If no filter is specified the statistics
will be calculated for all packets. If a filter <br>
is specified statistics will only be calculated for those
packets that match the filter.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">-z
io,stat,interval[,filter][,filter][,filter]... <br>
Collect packet/bytes statistics for the capture in intervals
of interval seconds. Interval can be specified either as a
whole or fractional second and can be specified <br>
with microsecond (us) resolution. If interval is 0, the
statistics will be calculated over all packets.</p>

<p style="margin-top: 1em">If no filter is specified the
statistics will be calculated for all packets. If one or
more filters are specified statistics will be calculated for
all filters and <br>
presented with one column of statistics for each filter.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">Example: -z
io,stat,1,ip.addr==1.2.3.4 will generate 1 second statistics
for all traffic to/from host 1.2.3.4.</p>

<p style="margin-top: 1em">Example: -z
&quot;io,stat,0.001,smb&amp;&amp;ip.addr==1.2.3.4&quot; will
generate 1ms statistics for all SMB packets to/from host
1.2.3.4.</p>

<p style="margin-top: 1em">The examples above all use the
standard syntax for generating statistics which only
calculates the number of packets and bytes in each
interval.</p>

<p style="margin-top: 1em">io,stat can also do much more
statistics and calculate COUNT(), SUM(), MIN(), MAX(), AVG()
and LOAD() using a slightly different filter syntax:</p>

<p style="margin-top: 1em">-z
io,stat,interval,&quot;[COUNT|SUM|MIN|MAX|AVG|LOAD](field)field
[and filter]&quot; <br>
NOTE: One important thing to note here is that the field
that the calculation is based on MUST also be part of the
filter string or else the calculation will fail.</p>

<p style="margin-top: 1em">So: -z
io,stat,0.010,AVG(smb.time) does not work. Use -z
io,stat,0.010,AVG(smb.time)smb.time instead. Also be aware
that a field can exist multiple times inside the <br>
same packet and will then be counted multiple times in those
packets.</p>

<p style="margin-top: 1em">NOTE: A second important thing
to note is that the system setting for decimal separator is
set to &quot;.&quot;! If it is set to &quot;,&quot; the
statistics will not be displayed per <br>
filter.</p>

<p style="margin-top: 1em">COUNT(field)field [and filter] -
Calculates the number of times that the field name (not its
value) appears per interval in the filtered packet list.
&rsquo;&rsquo;field&rsquo;&rsquo; can be <br>
any display filter name.</p>

<p style="margin-top: 1em">Example: -z
io,stat,0.010,&quot;COUNT(smb.sid)smb.sid&quot;</p>

<p style="margin-top: 1em">This will count the total number
of SIDs seen in each 10ms interval.</p>

<p style="margin-top: 1em">SUM(field)field [and filter] -
Unlike COUNT, the values of the specified field are summed
per time interval. &rsquo;&rsquo;field&rsquo;&rsquo; can
only be a named integer, float, double or <br>
relative time field.</p>

<p style="margin-top: 1em">Example: -z
io,stat,0.010,&quot;SUM(frame.len)frame.len&quot;</p>

<p style="margin-top: 1em">Reports the total number of
bytes that were transmitted bidirectionally in all the
packets within a 10 millisecond interval.</p>

<p style="margin-top: 1em">MIN/MAX/AVG(field)field [and
filter] - The minimum, maximum, or average field value in
each interval is calculated. The specified field must be a
named integer, float, <br>
double or relative time field. For relative time fields, the
output is presented in seconds with six decimal digits of
precision rounded to the nearest microsecond.</p>

<p style="margin-top: 1em">In the following example, the
time of the first Read_AndX call, the last Read_AndX
response values are displayed and the minimum, maximum, and
average Read response times <br>
(SRTs) are calculated. NOTE: If the DOS command shell line
continuation character, &rsquo;&rsquo;^&rsquo;&rsquo; is
used, each line cannot end in a comma so it is placed at the
beginning of <br>
each continuation line:</p>

<p style="margin-top: 1em">tshark -o
tcp.desegment_tcp_streams:FALSE -n -q -r smb_reads.cap -z
io,stat,0, <br>
&quot;MIN(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==0&quot;, <br>
&quot;MAX(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==1&quot;, <br>
&quot;MIN(smb.time)smb.time and smb.cmd==0x2e&quot;, <br>
&quot;MAX(smb.time)smb.time and smb.cmd==0x2e&quot;, <br>
&quot;AVG(smb.time)smb.time and smb.cmd==0x2e&quot;</p>


<p style="margin-top: 1em">======================================================================================================
<br>
IO Statistics <br>
Column #0: MIN(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==0 <br>
Column #1: MAX(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==1 <br>
Column #2: MIN(smb.time)smb.time and smb.cmd==0x2e <br>
Column #3: MAX(smb.time)smb.time and smb.cmd==0x2e <br>
Column #4: AVG(smb.time)smb.time and smb.cmd==0x2e <br>
| Column #0 | Column #1 | Column #2 | Column #3 | Column #4
| <br>
Time | MIN | MAX | MIN | MAX | AVG | <br>
000.000- 0.000000 7.704054 0.000072 0.005539 0.000295 <br>

======================================================================================================</p>

<p style="margin-top: 1em">The following command displays
the average SMB Read response PDU size, the total number of
read PDU bytes, the average SMB Write request PDU size, and
the total number of <br>
bytes transferred in SMB Write PDUs:</p>

<p style="margin-top: 1em">tshark -n -q -r
smb_reads_writes.cap -z io,stat,0, <br>
&quot;AVG(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2e and smb.response_to&quot;, <br>
&quot;SUM(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2e and smb.response_to&quot;, <br>
&quot;AVG(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2f and not smb.response_to&quot;, <br>
&quot;SUM(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2f and not smb.response_to&quot;</p>


<p style="margin-top: 1em">=====================================================================================
<br>
IO Statistics <br>
Column #0: AVG(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2e and smb.response_to <br>
Column #1: SUM(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2e and smb.response_to <br>
Column #2: AVG(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2f and not smb.response_to <br>
Column #3: SUM(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2f and not smb.response_to <br>
| Column #0 | Column #1 | Column #2 | Column #3 | <br>
Time | AVG | SUM | AVG | SUM | <br>
000.000- 30018 28067522 72 3240 <br>

=====================================================================================</p>

<p style="margin-top: 1em">LOAD(field)field [and filter] -
The LOAD/Queue-Depth in each interval is calculated. The
specified field must be a relative time field that
represents a response time. <br>
For example smb.time. For each interval the Queue-Depth for
the specified protocol is calculated.</p>

<p style="margin-top: 1em">The following command displays
the average SMB LOAD. A value of 1.0 represents one I/O in
flight.</p>

<p style="margin-top: 1em">tshark -n -q -r
smb_reads_writes.cap <br>
-z &quot;io,stat,0.001,LOAD(smb.time)smb.time&quot;</p>


<p style="margin-top: 1em">============================================================================
<br>
IO Statistics <br>
Interval: 0.001000 secs <br>
Column #0: LOAD(smb.time)smb.time <br>
| Column #0 | <br>
Time | LOAD | <br>
0000.000000-0000.001000 1.000000 <br>
0000.001000-0000.002000 0.741000 <br>
0000.002000-0000.003000 0.000000 <br>
0000.003000-0000.004000 1.000000</p>

<p style="margin-top: 1em">FRAMES | BYTES[()filter] -
Displays the total number of frames or bytes. The filter
field is optional but if included it must be prepended with
&rsquo;&rsquo;()&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">The following command displays
five columns: the total number of frames and bytes
(transferred bidirectionally) using a single comma, the same
two stats using the FRAMES <br>
and BYTES subcommands, the total number of frames containing
at least one SMB Read response, and the total number of
bytes transmitted to the client (unidirectionally) at <br>
IP address 10.1.0.64.</p>

<p style="margin-top: 1em">tshark -o
tcp.desegment_tcp_streams:FALSE -n -q -r smb_reads.cap -z
io,stat,0,,FRAMES,BYTES, <br>
&quot;FRAMES()smb.cmd==0x2e and
smb.response_to&quot;,&quot;BYTES()ip.dst==10.1.0.64&quot;</p>


<p style="margin-top: 1em">=======================================================================================================================
<br>
IO Statistics <br>
Column #0: <br>
Column #1: FRAMES <br>
Column #2: BYTES <br>
Column #3: FRAMES()smb.cmd==0x2e and smb.response_to <br>
Column #4: BYTES()ip.dst==10.1.0.64 <br>
| Column #0 | Column #1 | Column #2 | Column #3 | Column #4
| <br>
Time | Frames | Bytes | FRAMES | BYTES | FRAMES | BYTES |
<br>
000.000- 33576 29721685 33576 29721685 870 29004801 <br>

=======================================================================================================================</p>

<p style="margin-top: 1em">-z mac-lte,stat[,filter] <br>
This option will activate a counter for LTE MAC messages.
You will get information about the maximum number of
UEs/TTI, common messages and various counters for each UE
<br>
that appears in the log.</p>

<p style="margin-top: 1em">Example: -z mac-lte,stat.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated for those frames
that match that filter. Example: -z
&quot;mac-lte,stat,mac-lte.rnti3000&quot;&gt; will only <br>
collect stats for UEs with an assigned RNTI whose value is
more than 3000.</p>

<p style="margin-top: 1em">-z megaco,rtd[,filter] <br>
Collect requests/response RTD (Response Time Delay) data for
MEGACO. (This is similar to -z smb,srt). Data collected is
the number of calls for each known MEGACO Type, <br>
MinRTD, MaxRTD and AvgRTD. Additionally you get the number
of duplicate requests/responses, unresponded requests,
responses, which don&rsquo;t match with any request. <br>
Example: -z megaco,rtd.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter. Example: -z
&quot;megaco,rtd,ip.addr==1.2.3.4&quot; will only collect
<br>
stats for MEGACO packets exchanged by the host at IP address
1.2.3.4 .</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">-z mgcp,rtd[,filter] <br>
Collect requests/response RTD (Response Time Delay) data for
MGCP. (This is similar to -z smb,srt). Data collected is the
number of calls for each known MGCP Type, <br>
MinRTD, MaxRTD and AvgRTD. Additionally you get the number
of duplicate requests/responses, unresponded requests,
responses, which don&rsquo;t match with any request. <br>
Example: -z mgcp,rtd.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter. Example: -z
&quot;mgcp,rtd,ip.addr==1.2.3.4&quot; will only collect <br>
stats for MGCP packets exchanged by the host at IP address
1.2.3.4 .</p>

<p style="margin-top: 1em">-z proto,colinfo,filter,field
<br>
Append all field values for the packet to the Info column of
the one-line summary output. This feature can be used to
append arbitrary fields to the Info column in <br>
addition to the normal content of that column. field is the
display-filter name of a field which value should be placed
in the Info column. filter is a filter string <br>
that controls for which packets the field value will be
presented in the info column. field will only be presented
in the Info column for the packets which match filter.</p>

<p style="margin-top: 1em">NOTE: In order for TShark to be
able to extract the field value from the packet, field MUST
be part of the filter string. If not, TShark will not be
able to extract its <br>
value.</p>

<p style="margin-top: 1em">For a simple example to add the
&quot;nfs.fh.hash&quot; field to the Info column for all
packets containing the &quot;nfs.fh.hash&quot; field,
use</p>

<p style="margin-top: 1em">-z
proto,colinfo,nfs.fh.hash,nfs.fh.hash</p>

<p style="margin-top: 1em">To put &quot;nfs.fh.hash&quot;
in the Info column but only for packets coming from host
1.2.3.4 use:</p>

<p style="margin-top: 1em">-z
&quot;proto,colinfo,nfs.fh.hash &amp;&amp;
ip.src==1.2.3.4,nfs.fh.hash&quot;</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">-z rlc-lte,stat[,filter] <br>
This option will activate a counter for LTE RLC messages.
You will get information about common messages and various
counters for each UE that appears in the log.</p>

<p style="margin-top: 1em">Example: -z rlc-lte,stat.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated for those frames
that match that filter. Example: -z
&quot;rlc-lte,stat,rlc-lte.ueid3000&quot;&gt; will only <br>
collect stats for UEs with a UEId of more than 3000.</p>

<p style="margin-top: 1em">-z rpc,programs <br>
Collect call/reply SRT data for all known ONC-RPC
programs/versions. Data collected is number of calls for
each protocol/version, MinSRT, MaxSRT and AvgSRT. This
option <br>
can only be used once on the command line.</p>

<p style="margin-top: 1em">-z
rpc,srt,program,version[,filter] <br>
Collect call/reply SRT (Service Response Time) data for
program/version. Data collected is number of calls for each
procedure, MinSRT, MaxSRT and AvgSRT.</p>

<p style="margin-top: 1em">Example: -z rpc,srt,100003,3
will collect data for NFS v3.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter.</p>

<p style="margin-top: 1em">Example: -z
rpc,srt,100003,3,nfs.fh.hash==0x12345678 will collect NFS v3
SRT statistics for a specific file.</p>

<p style="margin-top: 1em">-z rtp,streams <br>
Collect statistics for all RTP streams and calculate max.
delta, max. and mean jitter and packet loss percentages.</p>

<p style="margin-top: 1em">-z scsi,srt,cmdset[,filter] <br>
Collect call/reply SRT (Service Response Time) data for SCSI
commandset cmdset.</p>

<p style="margin-top: 1em">Commandsets are 0:SBC 1:SSC
5:MMC</p>

<p style="margin-top: 1em">Data collected is the number of
calls for each procedure, MinSRT, MaxSRT and AvgSRT.</p>

<p style="margin-top: 1em">Example: -z scsi,srt,0 will
collect data for SCSI BLOCK COMMANDS (SBC).</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter.</p>

<p style="margin-top: 1em">Example: -z
scsi,srt,0,ip.addr==1.2.3.4 will collect SCSI SBC SRT
statistics for a specific iscsi/ifcp/fcip host.</p>

<p style="margin-top: 1em">-z sip,stat[,filter] <br>
This option will activate a counter for SIP messages. You
will get the number of occurrences of each SIP Method and of
each SIP Status-Code. Additionally you also get <br>
the number of resent SIP Messages (only for SIP over
UDP).</p>

<p style="margin-top: 1em">Example: -z sip,stat.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter. Example: -z
&quot;sip,stat,ip.addr==1.2.3.4&quot; will only collect <br>
stats for SIP packets exchanged by the host at IP address
1.2.3.4 .</p>

<p style="margin-top: 1em">-z smb,sids <br>
When this feature is used TShark will print a report with
all the discovered SID and account name mappings. Only those
SIDs where the account name is known will be <br>
presented in the table.</p>

<p style="margin-top: 1em">For this feature to work you
will need to either to enable
&quot;Edit/Preferences/Protocols/SMB/Snoop SID to name
mappings&quot; in the preferences or you can override the
<br>
preferences by specifying -o
&quot;smb.sid_name_snooping:TRUE&quot; on the TShark command
line.</p>

<p style="margin-top: 1em">The current method used by
TShark to find the SID-&gt;name mapping is relatively
restricted with a hope of future expansion.</p>

<p style="margin-top: 1em">-z smb,srt[,filter] <br>
Collect call/reply SRT (Service Response Time) data for SMB.
Data collected is number of calls for each SMB command,
MinSRT, MaxSRT and AvgSRT.</p>

<p style="margin-top: 1em">Example: -z smb,srt</p>

<p style="margin-top: 1em">The data will be presented as
separate tables for all normal SMB commands, all
Transaction2 commands and all NT Transaction commands. Only
those commands that are seen <br>
in the capture will have its stats displayed. Only the first
command in a xAndX command chain will be used in the
calculation. So for common SessionSetupAndX + <br>
TreeConnectAndX chains, only the SessionSetupAndX call will
be used in the statistics. This is a flaw that might be
fixed in the future.</p>

<p style="margin-top: 1em">This option can be used multiple
times on the command line.</p>

<p style="margin-top: 1em">If the optional filter is
provided, the stats will only be calculated on those calls
that match that filter.</p>

<p style="margin-top: 1em">Example: -z
&quot;smb,srt,ip.addr==1.2.3.4&quot; will only collect stats
for SMB packets exchanged by the host at IP address 1.2.3.4
.</p>

<p style="margin-top: 1em">CAPTURE FILTER SYNTAX <br>
See the manual page of pcap-filter(7) or, if that
doesn&rsquo;t exist, tcpdump(8), or, if that doesn&rsquo;t
exist, &lt;http://wiki.wireshark.org/CaptureFilters&gt;.</p>

<p style="margin-top: 1em">READ FILTER SYNTAX <br>
For a complete table of protocol and protocol fields that
are filterable in TShark see the wireshark-filter(4) manual
page.</p>

<p style="margin-top: 1em">FILES <br>
These files contains various Wireshark configuration
values.</p>

<p style="margin-top: 1em">Preferences <br>
The preferences files contain global (system-wide) and
personal preference settings. If the system-wide preference
file exists, it is read first, overriding the default <br>
settings. If the personal preferences file exists, it is
read next, overriding any previous values. Note: If the
command line option -o is used (possibly more than once),
<br>
it will in turn override values from the preferences
files.</p>

<p style="margin-top: 1em">The preferences settings are in
the form prefname:value, one per line, where prefname is the
name of the preference and value is the value to which it
should be set; white <br>
space is allowed between : and value. A preference setting
can be continued on subsequent lines by indenting the
continuation lines with white space. A # character starts a
<br>
comment that runs to the end of the line:</p>

<p style="margin-top: 1em"># Capture in promiscuous mode?
<br>
# TRUE or FALSE (case-insensitive). <br>
capture.prom_mode: TRUE</p>

<p style="margin-top: 1em">The global preferences file is
looked for in the wireshark directory under the share
subdirectory of the main installation directory (for
example, <br>
/usr/local/share/wireshark/preferences) on UNIX-compatible
systems, and in the main installation directory (for
example, C:Program FilesWiresharkreferences) on Windows <br>
systems.</p>

<p style="margin-top: 1em">The personal preferences file is
looked for in $HOME/.wireshark/preferences on
UNIX-compatible systems and %APPDATA%Wiresharkreferences
(or, if %APPDATA% isn&rsquo;t defined, <br>
%USERPROFILE%0lication DataWiresharkreferences) on Windows
systems.</p>

<p style="margin-top: 1em">Disabled (Enabled) Protocols
<br>
The disabled_protos files contain system-wide and personal
lists of protocols that have been disabled, so that their
dissectors are never called. The files contain protocol <br>
names, one per line, where the protocol name is the same
name that would be used in a display filter for the
protocol:</p>

<p style="margin-top: 1em">http <br>
tcp # a comment</p>

<p style="margin-top: 1em">The global disabled_protos file
uses the same directory as the global preferences file.</p>

<p style="margin-top: 1em">The personal disabled_protos
file uses the same directory as the personal preferences
file.</p>

<p style="margin-top: 1em">Name Resolution (hosts) <br>
If the personal hosts file exists, it is used to resolve
IPv4 and IPv6 addresses before any other attempts are made
to resolve them. The file has the standard hosts file <br>
syntax; each line contains one IP address and name,
separated by whitespace. The same directory as for the
personal preferences file is used.</p>

<p style="margin-top: 1em">Capture filter name resolution
is handled by libpcap on UNIX-compatible systems and WinPcap
on Windows. As such the Wireshark personal hosts file will
not be consulted for <br>
capture filter name resolution.</p>

<p style="margin-top: 1em">Name Resolution (ethers) <br>
The ethers files are consulted to correlate 6-byte hardware
addresses to names. First the personal ethers file is tried
and if an address is not found there the global <br>
ethers file is tried next.</p>

<p style="margin-top: 1em">Each line contains one hardware
address and name, separated by whitespace. The digits of the
hardware address are separated by colons (:), dashes (-) or
periods (.). The <br>
same separator character must be used consistently in an
address. The following three lines are valid lines of an
ethers file:</p>

<p style="margin-top: 1em">ff:ff:ff:ff:ff:ff Broadcast <br>
c0-00-ff-ff-ff-ff TR_broadcast <br>
00.00.00.00.00.00 Zero_broadcast</p>

<p style="margin-top: 1em">The global ethers file is looked
for in the /etc directory on UNIX-compatible systems, and in
the main installation directory (for example, C:Program
FilesWireshark) on <br>
Windows systems.</p>

<p style="margin-top: 1em">The personal ethers file is
looked for in the same directory as the personal preferences
file.</p>

<p style="margin-top: 1em">Capture filter name resolution
is handled by libpcap on UNIX-compatible systems and WinPcap
on Windows. As such the Wireshark personal ethers file will
not be consulted for <br>
capture filter name resolution.</p>

<p style="margin-top: 1em">Name Resolution (manuf) <br>
The manuf file is used to match the 3-byte vendor portion of
a 6-byte hardware address with the manufacturer&rsquo;s
name; it can also contain well-known MAC addresses and
address <br>
ranges specified with a netmask. The format of the file is
the same as the ethers files, except that entries of the
form:</p>

<p style="margin-top: 1em">00:00:0C Cisco</p>

<p style="margin-top: 1em">can be provided, with the 3-byte
OUI and the name for a vendor, and entries such as:</p>

<p style="margin-top: 1em">00-00-0C-07-AC/40
All-HSRP-routers</p>

<p style="margin-top: 1em">can be specified, with a MAC
address and a mask indicating how many bits of the address
must match. The above entry, for example, has 40 significant
bits, or 5 bytes, and <br>
would match addresses from 00-00-0C-07-AC-00 through
00-00-0C-07-AC-FF. The mask need not be a multiple of 8.</p>

<p style="margin-top: 1em">The manuf file is looked for in
the same directory as the global preferences file.</p>

<p style="margin-top: 1em">Name Resolution (ipxnets) <br>
The ipxnets files are used to correlate 4-byte IPX network
numbers to names. First the global ipxnets file is tried and
if that address is not found there the personal one <br>
is tried next.</p>

<p style="margin-top: 1em">The format is the same as the
ethers file, except that each address is four bytes instead
of six. Additionally, the address can be represented as a
single hexadecimal <br>
number, as is more common in the IPX world, rather than four
hex octets. For example, these four lines are valid lines of
an ipxnets file:</p>

<p style="margin-top: 1em">C0.A8.2C.00 HR <br>
c0-a8-1c-00 CEO <br>
00:00:BE:EF IT_Server1 <br>
110f FileServer3</p>

<p style="margin-top: 1em">The global ipxnets file is
looked for in the /etc directory on UNIX-compatible systems,
and in the main installation directory (for example,
C:Program FilesWireshark) on <br>
Windows systems.</p>

<p style="margin-top: 1em">The personal ipxnets file is
looked for in the same directory as the personal preferences
file.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
WIRESHARK_DEBUG_EP_NO_CHUNKS <br>
Normally per-packet memory is allocated in large
&quot;chunks.&quot; This behavior doesn&rsquo;t work well
with debugging tools such as Valgrind or ElectricFence.
Export this environment <br>
variable to force individual allocations. Note: disabling
chunks also disables canaries (see below).</p>

<p style="margin-top: 1em">WIRESHARK_DEBUG_SE_NO_CHUNKS
<br>
Normally per-file memory is allocated in large
&quot;chunks.&quot; This behavior doesn&rsquo;t work well
with debugging tools such as Valgrind or ElectricFence.
Export this environment <br>
variable to force individual allocations. Note: disabling
chunks also disables canaries (see below).</p>

<p style="margin-top: 1em">WIRESHARK_DEBUG_EP_NO_CANARY
<br>
Normally per-packet memory allocations are separated by
&quot;canaries&quot; which allow detection of memory
overruns. This comes at the expense of some extra memory
usage. Exporting <br>
this environment variable disables these canaries.</p>

<p style="margin-top: 1em">WIRESHARK_DEBUG_SE_USE_CANARY
<br>
Exporting this environment variable causes per-file memory
allocations to be protected with &quot;canaries&quot; which
allow for detection of memory overruns. This comes at the
<br>
expense of significant extra memory usage.</p>

<p style="margin-top: 1em">WIRESHARK_DEBUG_SCRUB_MEMORY
<br>
If this environment variable is set, the contents of
per-packet and per-file memory is initialized to 0xBADDCAFE
when the memory is allocated and is reset to 0xDEADBEEF when
<br>
the memory is freed. This functionality is useful mainly to
developers looking for bugs in the way memory is
handled.</p>

<p style="margin-top: 1em">WIRESHARK_DEBUG_WMEM_OVERRIDE
<br>
Setting this environment variable forces the wmem framework
to use the specified allocator backend for *all*
allocations, regardless of which backend is normally
specified by <br>
the code. This is mainly useful to developers when testing
or debugging. See README.wmem in the source distribution for
details.</p>


<p style="margin-top: 1em">WIRESHARK_RUN_FROM_BUILD_DIRECTORY
<br>
This environment variable causes the plugins and other data
files to be loaded from the build directory (where the
program was compiled) rather than from the standard <br>
locations. It has no effect when the program in question is
running with root (or setuid) permissions on *NIX.</p>

<p style="margin-top: 1em">WIRESHARK_DATA_DIR <br>
This environment variable causes the various data files to
be loaded from a directory other than the standard
locations. It has no effect when the program in question is
<br>
running with root (or setuid) permissions on *NIX.</p>

<p style="margin-top: 1em">WIRESHARK_PYTHON_DIR <br>
This environment variable points to an alternate location
for Python. It has no effect when the program in question is
running with root (or setuid) permissions on *NIX.</p>

<p style="margin-top: 1em">ERF_RECORDS_TO_CHECK <br>
This environment variable controls the number of ERF records
checked when deciding if a file really is in the ERF format.
Setting this environment variable a number higher <br>
than the default (20) would make false positives less
likely.</p>

<p style="margin-top: 1em">IPFIX_RECORDS_TO_CHECK <br>
This environment variable controls the number of IPFIX
records checked when deciding if a file really is in the
IPFIX format. Setting this environment variable a number
<br>
higher than the default (20) would make false positives less
likely.</p>


<p style="margin-top: 1em">WIRESHARK_ABORT_ON_DISSECTOR_BUG
<br>
If this environment variable is set, TShark will call
abort(3) when a dissector bug is encountered. abort(3) will
cause the program to exit abnormally; if you are running
<br>
TShark in a debugger, it should halt in the debugger and
allow inspection of the process, and, if you are not running
it in a debugger, it will, on some OSes, assuming your <br>
environment is configured correctly, generate a core dump
file. This can be useful to developers attempting to
troubleshoot a problem with a protocol dissector.</p>

<p style="margin-top: 1em">WIRESHARK_EP_VERIFY_POINTERS
<br>
This environment variable, if present, causes certain uses
of pointers to be audited to ensure they do not point to
memory that is deallocated after each packet has been <br>
fully dissected. This can be useful to developers writing or
auditing code.</p>

<p style="margin-top: 1em">WIRESHARK_SE_VERIFY_POINTERS
<br>
This environment variable, if present, causes certain uses
of pointers to be audited to ensure they do not point to
memory that is deallocated after when a capture file is <br>
closed. This can be useful to developers writing or auditing
code.</p>


<p style="margin-top: 1em">WIRESHARK_ABORT_ON_OUT_OF_MEMORY
<br>
This environment variable, if present, causes abort(3) to be
called if certain out-of-memory conditions (which normally
result in an exception and an explanatory error <br>
message) are experienced. This can be useful to developers
debugging out-of-memory conditions.</p>

<p style="margin-top: 1em">SEE ALSO <br>
wireshark-filter(4), wireshark(1), editcap(1), pcap(3),
dumpcap(1), text2pcap(1), mergecap(1), pcap-filter(7) or
tcpdump(8)</p>

<p style="margin-top: 1em">NOTES <br>
TShark is part of the Wireshark distribution. The latest
version of Wireshark can be found at
&lt;http://www.wireshark.org&gt;.</p>

<p style="margin-top: 1em">HTML versions of the Wireshark
project man pages are available at:
&lt;http://www.wireshark.org/docs/man-pages&gt;.</p>

<p style="margin-top: 1em">AUTHORS <br>
TShark uses the same packet dissection code that Wireshark
does, as well as using many other modules from Wireshark;
see the list of authors in the Wireshark man page for a list
<br>
of authors of that code.</p>

<p style="margin-top: 1em">1.10.14 2015-05-12 TSHARK(1)</p>
<hr>
</body>
</html>
