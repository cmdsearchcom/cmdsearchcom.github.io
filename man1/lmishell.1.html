<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:22:20 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>LMISHELL(1) OpenLMI Tools LMISHELL(1)</p>

<p style="margin-top: 1em">NAME <br>
lmishell - (non)interactive WBEM client and interpreter</p>

<p style="margin-top: 1em">OpenLMI Tools currently consist
of LMIShell and the content of the documentation itself is
devoted to the LMIShell.</p>

<p style="margin-top: 1em">LMISHELL <br>
LMIShell provides a (non)interactive way how to access CIM
objects provided by OpenPegasus or sblim-sfcb broker.</p>

<p style="margin-top: 1em">Synopsis <br>
lmishell [options] script [script-options]</p>

<p style="margin-top: 1em">Description <br>
LMIShell provides a (non)interactive or interactive way how
to access CIM objects provided by OpenPegasus or sblim-sfcb
CIMOM.</p>

<p style="margin-top: 1em">LMIShell is based on a python
interpreter and added logic, therefore what is possible to
do in pure python, it is possible in LMIShell. There are
classes added to manipulate with <br>
CIM classes, instance names, instances, etc. Additional
classes are added to fulfill wrapper pattern and expose only
those methods, which are necessary for the purpose of a <br>
shell.</p>

<p style="margin-top: 1em">Options <br>
The options may be given in any order before the first
positional argument, which stands for the script name.</p>

<p style="margin-top: 1em">-h, --help <br>
Print summary of usage, command line options and exit.</p>

<p style="margin-top: 1em">-i, --interact <br>
Enter interactive mode, when the script passed as the first
positional argument is executed.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Print log messages to stderr.</p>

<p style="margin-top: 1em">-m, --more-verbose <br>
Print all log messages to stderr.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Do not print any log messages to stderr.</p>

<p style="margin-top: 1em">-n, --noverify <br>
Do not verify server&rsquo;s certificate, if SSL used. By
default, the certificate validity check will be
performed.</p>

<p style="margin-top: 1em">By default, LMIShell prints out
log messages with Error severity. Options -v, -m and -q are
mutually exclusive and can not be used together.</p>

<p style="margin-top: 1em">Startup <br>
By running the following, you will gain an interactive
interface of the shell. The LMIShell is waiting for the end
of an input to quit -- by hitting &lt;ctrl+d&gt; you can
exit from <br>
it:</p>

<p style="margin-top: 1em">$ lmishell <br>
&gt; &lt;ctrl+d&gt; <br>
$</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">$ lmishell <br>
&gt; quit() <br>
$</p>

<p style="margin-top: 1em">Establish a connection <br>
Following examples demonstrate, how to connect to a CIMOM by
issuing a connect() call.</p>

<p style="margin-top: 1em">Username/Password authentication
<br>
Common means of performing the authentication is done by
providing a username and password to connect() function. See
the following example:</p>

<p style="margin-top: 1em">&gt; c =
connect(&quot;host&quot;, &quot;username&quot;) <br>
password: # &lt;not echoed&gt; <br>
&gt;</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">&gt; c =
connect(&quot;host&quot;, &quot;username&quot;,
&quot;password&quot;) <br>
&gt;</p>

<p style="margin-top: 1em">Certificate authentication <br>
LMIShell is capable of creating a connection by using a X509
certificate. For the purpose of creating a connection
object, it is necessary to provide two file names, which
con&acirc; <br>
tain a certificate and a private key.</p>

<p style="margin-top: 1em">See the following example:</p>

<p style="margin-top: 1em">&gt; c =
connect(&quot;host&quot;, key_file=&quot;key_file&quot;,
cert_file=&quot;cert_file&quot;) <br>
&gt;</p>

<p style="margin-top: 1em">Unix socket <br>
LMIShell can connect directly to the CIMOM using Unix
socket. For this type of connection, the shell needs to be
run under root user and the destination machine has to be
either <br>
localhost, 127.0.0.1 or ::1. This type of connection is
supported by TOG-Pegasus and there needs to be a Unix socket
file present at /var/run/tog-pegasus/cimxml.socket. If the
<br>
condition is not met, classic username/password method will
be used.</p>

<p style="margin-top: 1em">See following example:</p>

<p style="margin-top: 1em">&gt; c =
connect(&quot;localhost&quot;) <br>
&gt;</p>

<p style="margin-top: 1em">Credentials validation <br>
Function connect() returns either LMIConnection object, if
the connection can be established, otherwise None is
returned. Suppose, the LMIShell is run in verbose mode (-v,
--ver&acirc; <br>
bose, -m or --more-verbose is used). See following example
of creating a connection:</p>

<p style="margin-top: 1em">&gt; # correct username or
password <br>
&gt; c = connect(&quot;host&quot;, &quot;username&quot;,
&quot;password&quot;) <br>
INFO: Connected to host <br>
&gt; isinstance(c, LMIConnection) <br>
True <br>
&gt; # wrong login username or password <br>
&gt; c = connect(&quot;host&quot;,
&quot;wrong_username&quot;, &quot;wrong_password&quot;) <br>
ERROR: Error connecting to host, &lt;error message&gt; <br>
&gt; c is None <br>
True <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: By default, LMIShell
prints out only error messages, when calling a connect(); no
INFO messages will be print out. It is possible to suppress
all the messages by passing -q <br>
or --quiet).</p>

<p style="margin-top: 1em">Server&rsquo;s certificate
validation <br>
When using https transport protocol, LMIShell tries to
validate each server-side certificate against platform
provided CA trust store. It is necessary to copy the
server&rsquo;s cer&acirc; <br>
tificate from each CIMOM to the platform specific trust
store directory.</p>

<p style="margin-top: 1em">NOTE: It is possible to make
LMIShell skip the certificate validation process by lmishell
-n or --noverify.</p>

<p style="margin-top: 1em">See following example:</p>

<p style="margin-top: 1em">$ lmishell --noverify <br>
&gt;</p>

<p style="margin-top: 1em">Namespaces <br>
Namespaces in CIM and LMIShell provide a natural way, how to
organize all the available classes and their instances. In
the shell, they provide a hierarchic access point to other
<br>
namespaces and corresponding classes.</p>

<p style="margin-top: 1em">The root namespace plays a
special role in the managed system; it is the first entry
point from the connection object and provides the access to
other clamped namespaces.</p>

<p style="margin-top: 1em">Available namespaces <br>
To get a LMINamespace object for the root namespace of the
managed system, run following:</p>

<p style="margin-top: 1em">&gt; root_namespace = c.root
<br>
&gt;</p>

<p style="margin-top: 1em">To list all available namespace
from the root one, run following code:</p>

<p style="margin-top: 1em">&gt; c.root.print_namespaces()
<br>
... <br>
&gt; ns_lst = c.root.namespaces <br>
&gt;</p>

<p style="margin-top: 1em">If you want to access any
namespace deeper (e.g. cimv2), run this:</p>

<p style="margin-top: 1em">&gt; cimv2_namespace =
c.root.cimv2 <br>
&gt; cimv2_namespace =
c.get_namespace(&quot;root/cimv2&quot;) <br>
&gt;</p>

<p style="margin-top: 1em">Available classes <br>
Each namespace object can print its available classes. To
print/get the list of the classes, run this:</p>

<p style="margin-top: 1em">&gt;
c.root.cimv2.print_classes() <br>
... <br>
&gt; classes_lst = c.root.cimv2.classes() <br>
&gt;</p>

<p style="margin-top: 1em">Queries <br>
Using a LMINamespace object, it is possible to retrieve a
list of LMIInstance objects. The LMIShell supports 2 query
languages:</p>

<p style="margin-top: 1em">&Acirc;&middot; WQL</p>

<p style="margin-top: 1em">&Acirc;&middot; CQL</p>

<p style="margin-top: 1em">Following code illustrates, how
to execute WQL and CQL queries:</p>

<p style="margin-top: 1em">&gt; instances_lst =
namespace.wql(&quot;query&quot;) <br>
&gt; instances_lst = namespace.cql(&quot;query&quot;) <br>
&gt;</p>

<p style="margin-top: 1em">Classes <br>
Each class in LMIShell represents a class provided by a
CIMOM. You can get a list of its properties, methods,
instances, instance names and ValueMap properties. It is
also possi&acirc; <br>
ble to print a documentation string, create a new instance
or new instance name.</p>

<p style="margin-top: 1em">Getting a class object <br>
To get a class which is provided by a broker, you can do
following:</p>

<p style="margin-top: 1em">&gt; cls =
c.root.cimv2.ClassName <br>
&gt;</p>

<p style="margin-top: 1em">Fetching a class <br>
Objects of LMIClass use lazy fetching method, because some
methods do not need the CIMClass object.</p>

<p style="margin-top: 1em">To manually fetch the CIMClass
object, call following:</p>

<p style="margin-top: 1em">&gt; cls.fetch() <br>
&gt;</p>

<p style="margin-top: 1em">The methods, which need the
CIMClass object to be fetched from CIMOM, do this action
automatically, without the need of calling LMIClass.fetch()
method by hand.</p>

<p style="margin-top: 1em">Class Methods <br>
Following example illustrates, how to work with LMIClass
methods:</p>

<p style="margin-top: 1em">&gt; cls.print_methods() <br>
... <br>
&gt; cls_method_lst = cls.methods() <br>
&gt;</p>

<p style="margin-top: 1em">Class Properties <br>
To get a list of properties of a specific class, run
following code:</p>

<p style="margin-top: 1em">&gt; cls.print_properties() <br>
... <br>
&gt; cls_property_lst = cls.properties() <br>
&gt;</p>

<p style="margin-top: 1em">Instances <br>
Following part described basic work flow with LMIInstance
and LMIInstanceName objects.</p>

<p style="margin-top: 1em">Get Instances <br>
Using a class object, you can access its instances. You can
easily get a list of (filtered) instances, or the first one
from the list. The filtering is uses input dictionary, if
<br>
present, where the dictionary keys represent the instance
properties and the dictionary values represent your desired
instance property values.</p>

<p style="margin-top: 1em">To get LMIInstance object,
execute the following example:</p>

<p style="margin-top: 1em">&gt; inst = cls.first_instance()
<br>
&gt; inst_lst = cls.instances() <br>
&gt;</p>

<p style="margin-top: 1em">Get Instance Names <br>
The CIMInstanceName objects clearly identify CIMInstance
objects. LMIShell can retrieve LMIInstanceName objects, by
calling following:</p>

<p style="margin-top: 1em">&gt; inst_name =
cls.first_instance_name() <br>
&gt; inst_names_lst = cls.instance_names() <br>
&gt;</p>

<p style="margin-top: 1em">Filtering <br>
Both methods LMIClass.instances() or
LMIClass.instance_names() can filter returned objects by
their keys/values. The filtering is achieved by passing a
dictionary of {property : <br>
value} to the corresponding method. See following
example:</p>

<p style="margin-top: 1em">&gt; inst_lst =
cls.instances({&quot;FilterProperty&quot; : FilterValue})
<br>
&gt; inst_names_lst =
cls.instance_names({&quot;FilterProperty&quot; :
FilterValue}) <br>
&gt;</p>

<p style="margin-top: 1em">New Instance Name <br>
LMIShell is able to create a new wrapped CIMInstanceName, if
you know all the primary keys of a remote object. This
instance name object can be then used to retrieve the whole
<br>
instance object.</p>

<p style="margin-top: 1em">See the next example:</p>

<p style="margin-top: 1em">&gt; inst_name = cls({Property1
: Value1, Property2 : Value2, ...}) <br>
&gt; inst = inst_name.to_instance() <br>
&gt;</p>

<p style="margin-top: 1em">Creating a new instance <br>
LMIShell is able to create an object of specific class, if
the provider support this operation.</p>

<p style="margin-top: 1em">See the following example:</p>

<p style="margin-top: 1em">&gt;
cls.create_instance({&quot;Property1&quot; : Value1,
&quot;Property2&quot; : Value2}) <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: Value can be a LMIInstance
object, as well. LMIShell will auto-cast such object.</p>

<p style="margin-top: 1em">ValueMap Properties <br>
A CIM class may contain ValueMap properties (aliases for
constant values) in its MOF definition. These properties
contain constant values, which can be useful, when calling a
<br>
method, or checking a returned value.</p>

<p style="margin-top: 1em">ValueMap properties are formed
from 2 MOF properties of a class definition:</p>

<p style="margin-top: 1em">&Acirc;&middot; Values -- list
of string names of the &quot;constant&quot; values</p>

<p style="margin-top: 1em">&Acirc;&middot; ValueMap -- list
of values</p>

<p style="margin-top: 1em">Get ValueMap properties <br>
To get a list of all available constants, their values, use
the following code:</p>

<p style="margin-top: 1em">&gt;
cls.print_valuemap_properties() <br>
... <br>
&gt; valuemap_properties = cls.valuemap_properties() <br>
... <br>
&gt; cls.PropertyValues.print_values() <br>
... <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: The suffix
&quot;Values&quot; provides a way, how to access ValueMap
properties.</p>

<p style="margin-top: 1em">Get ValueMap property value <br>
Following example shows, how to retrieve a constant
value:</p>

<p style="margin-top: 1em">&gt; constant_value_names_lst =
cls.PropertyValues.values() <br>
&gt; cls.PropertyValues.ConstantValueName <br>
ConstantValue <br>
&gt; cls.PropertyValues.value(&quot;ConstantValueName&quot;)
<br>
ConstantValue <br>
&gt;</p>

<p style="margin-top: 1em">Get ValueMap property value name
<br>
LMIShell can also return string representing constant value.
See the following code:</p>

<p style="margin-top: 1em">&gt;
cls.PropertyValue.value_name(ConstantValue) <br>
&rsquo;ConstantValueName&rsquo; <br>
&gt;</p>

<p style="margin-top: 1em">Useful Properties <br>
Following part describes few useful LMIClass properties.</p>

<p style="margin-top: 1em">Class Name <br>
Every class object can return a name of the CIM class, see
following:</p>

<p style="margin-top: 1em">&gt; cls.classname <br>
ClassName <br>
&gt;</p>

<p style="margin-top: 1em">Namespace <br>
Every class belongs to certain namespace, to get a string
containing the corresponding namespace for each class, run
following:</p>

<p style="margin-top: 1em">&gt; cls.namespace <br>
Namespace <br>
&gt;</p>

<p style="margin-top: 1em">Connection Object <br>
This property returns a connection object, which was used to
retrieve the class (refer to startup_connection). See next
example:</p>

<p style="margin-top: 1em">&gt; cls.connection <br>
LMIConnection(URI=&rsquo;uri&rsquo;,
user=&rsquo;user&rsquo;...) <br>
&gt;</p>

<p style="margin-top: 1em">Wrapped Object <br>
This property returns a wrapped pywbem object. See the
example:</p>

<p style="margin-top: 1em">&gt; instance.wrapped_object
<br>
CIMClass(u&rsquo;ClassName&rsquo;, ...) <br>
&gt;</p>

<p style="margin-top: 1em">Documentation <br>
To see a class documentation (based on MOF definitions),
run:</p>

<p style="margin-top: 1em">&gt; cls.doc() <br>
# ... pretty verbose output displayed in a pages (can be
modified by <br>
# setting environment variable PAGER) ... <br>
&gt;</p>

<p style="margin-top: 1em">Instances <br>
Each instance in LMIShell represents a CIM instance provided
by a CIMOM.</p>

<p style="margin-top: 1em">Operations, that can be done
within a LMIInstance:</p>

<p style="margin-top: 1em">&Acirc;&middot; get and set
properties</p>

<p style="margin-top: 1em">&Acirc;&middot;
list/print/execute its methods</p>

<p style="margin-top: 1em">&Acirc;&middot; print a
documentation string</p>

<p style="margin-top: 1em">&Acirc;&middot; get a list of
associated objects</p>

<p style="margin-top: 1em">&Acirc;&middot; get a list of
association objects</p>

<p style="margin-top: 1em">&Acirc;&middot; push (update) a
modified object to CIMOM</p>

<p style="margin-top: 1em">&Acirc;&middot; delete a single
instance from the CIMOM.</p>

<p style="margin-top: 1em">Instance Methods <br>
To get a list of methods, run following:</p>

<p style="margin-top: 1em">&gt; instance.print_methods()
<br>
... <br>
&gt; method_lst = instance.methods() <br>
&gt;</p>

<p style="margin-top: 1em">To execute a method within an
object, run this:</p>

<p style="margin-top: 1em">&gt; instance.Method( <br>
... {&quot;Param1&quot; : value1, <br>
... &quot;Param2&quot; : value2, ...}) <br>
LMIReturnValue( <br>
rval=ReturnValue, <br>
rparams=ReturnParametersDictionary, <br>
errorstr=&quot;Possible error string&quot; <br>
) <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: Instances do not
auto-refresh after a method calls. It is necessary to
perform this operation by hand (See
instances_refreshing).</p>

<p style="margin-top: 1em">To get the result from a method
call, see following:</p>

<p style="margin-top: 1em">&gt; (rval, rparams, errorstr) =
instance.Method( <br>
... {&quot;Param1&quot; : value1, <br>
... &quot;Param2&quot; : value2, ...}) <br>
&gt;</p>

<p style="margin-top: 1em">The tuple in the previous
example will contain return value of the method call (rval),
returned parameters (rparams) and possible error string
(errorstr).</p>

<p style="margin-top: 1em">Synchronous methods <br>
LMIShell can perform synchronous method call, which means,
that the LMIShell is able to synchronously wait for a Job
object to change its state to Finished state and then return
<br>
the job&rsquo;s return parameters. LMIShell can perform the
synchronous method call, if the given method returns a
object of following classes:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LMI_StorageJob</p>

<p style="margin-top: 1em">&Acirc;&middot;
LMI_SoftwareInstallationJob</p>

<p style="margin-top: 1em">&Acirc;&middot;
LMI_SoftwareVerificationJob</p>

<p style="margin-top: 1em">&Acirc;&middot;
LMI_NetworkJob</p>

<p style="margin-top: 1em">LMIShell first tries to use
indications as the waiting method. If it fails, then it uses
polling method instead.</p>

<p style="margin-top: 1em">Following example illustrates,
how to perform a synchronous method call:</p>

<p style="margin-top: 1em">&gt; (rval, rparams, errorstr) =
instance.SyncMethod( <br>
... {&quot;Param1&quot; : value1, <br>
... &quot;Param2&quot; : value2, ...}) <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: See the prefix Sync of a
method name.</p>

<p style="margin-top: 1em">When a synchronous method call
is done:</p>

<p style="margin-top: 1em">&Acirc;&middot; rval will
contain the job&rsquo;s return value</p>

<p style="margin-top: 1em">&Acirc;&middot; rparams will
contain the job&rsquo;s return parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; errorstr will
contain job&rsquo;s possible error string</p>

<p style="margin-top: 1em">It is possible to force LMIShell
to use only polling method, see the next example:</p>

<p style="margin-top: 1em">&gt; (rval, rparams, errorstr) =
instance.SyncMethod( <br>
... {&quot;Param1&quot; : value1, <br>
... &quot;Param2&quot; : value2, ...}, <br>
... PreferPolling=True) <br>
&gt;</p>

<p style="margin-top: 1em">Signal handling <br>
LMIShell can properly handle SIGINT and SIGTERM, which
instruct the shell to cancel the synchronous call. When such
signal is received, the background job, for which the
LMIShell <br>
is waiting, will be asked to terminate, as well.</p>

<p style="margin-top: 1em">Instance Properties <br>
To get a list of properties, see following:</p>

<p style="margin-top: 1em">&gt; instance.print_properties()
<br>
... <br>
&gt; instance_prop_lst = instance.properties() <br>
&gt;</p>

<p style="margin-top: 1em">It is possible to access an
instance object properties. To get a property, see the
following example:</p>

<p style="margin-top: 1em">&gt; instance.Property <br>
PropertyValue <br>
&gt;</p>

<p style="margin-top: 1em">To modify a property, execute
following:</p>

<p style="margin-top: 1em">&gt; instance.Property =
NewPropertyValue <br>
&gt; instance.push() <br>
LMIReturnValue(rval=0, rparams={}, errorstr=&quot;&quot;)
<br>
&gt;</p>

<p style="margin-top: 1em">NOTE: If you change an instance
object property, you have to execute a LMIInstance.push()
method to propagate the change to the CIMOM.</p>

<p style="margin-top: 1em">ValueMap Parameters <br>
A CIM Method may contain ValueMap parameters (aliases for
constant values) in its MOF definition.</p>

<p style="margin-top: 1em">To access these parameters,
which contain constant values, see following code:</p>

<p style="margin-top: 1em">&gt;
instance.Method.print_valuemap_parameters() <br>
... <br>
&gt; valuemap_parameters =
instance.Method.valuemap_parameters() <br>
&gt;</p>

<p style="margin-top: 1em">Get ValueMap parameter value
<br>
By using a ValueMap parameters, you can retrieve a constant
value defined in the MOF file for a specific method.</p>

<p style="margin-top: 1em">To get a list of all available
constants, their values, use the following code:</p>

<p style="margin-top: 1em">&gt;
instance.Method.ParameterValues.print_values() <br>
... <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: The suffix Values provides
a way, how to access ValueMap parameters.</p>

<p style="margin-top: 1em">To retrieve a constant value,
see the next example:</p>

<p style="margin-top: 1em">&gt; constant_value_names_lst =
instance.Method.ParameterValues.values() <br>
&gt; instance.Method.ParameterValues.ConstantValueName <br>
ConstantValue <br>
&gt;
instance.Method.ParameterValues.value(&quot;ConstantValueName&quot;)
<br>
ConstantValue <br>
&gt;</p>

<p style="margin-top: 1em">Get ValueMap parameter <br>
Method can also contain a mapping between constant property
name and corresponding value. Following code demonstrates,
how to access such parameters:</p>

<p style="margin-top: 1em">&gt;
instance.Method.ConstantValueName <br>
&gt;</p>

<p style="margin-top: 1em">Get ValueMap parameter value
name <br>
LMIShell can also return string representing constant value.
See the following code:</p>

<p style="margin-top: 1em">&gt;
instance.Method.ParameterValue.value_name(ConstantValue)
<br>
ConstantValueName <br>
&gt;</p>

<p style="margin-top: 1em">Instance refreshing <br>
Local objects used by LMIShell, which represent CIM objects
at CIMOM side, can get outdated, if such object changes
while working with LMIShell&rsquo;s one.</p>

<p style="margin-top: 1em">To update object&rsquo;s
properties, methods, etc. follow the next example:</p>

<p style="margin-top: 1em">&gt; instance.refresh() <br>
LMIReturnValue(rval=True, rparams={}, errorstr=&quot;&quot;)
<br>
&gt;</p>

<p style="margin-top: 1em">Instance deletion <br>
A single instance can be removed from the CIMOM by
executing:</p>

<p style="margin-top: 1em">&gt; instance.delete() <br>
True <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: After executing the
LMIInstance.delete() method, all the object properties,
methods will become inaccessible.</p>

<p style="margin-top: 1em">Deletion of the instance can be
verified by:</p>

<p style="margin-top: 1em">&gt; instance.is_deleted <br>
True <br>
&gt;</p>

<p style="margin-top: 1em">Documentation <br>
For an instance object, you can also use a documentation
method, which will display verbose information of its
properties and values.</p>

<p style="margin-top: 1em">See next example:</p>

<p style="margin-top: 1em">&gt; instance.doc() <br>
# ... pretty verbose output displayed in a pages (can be
modified by <br>
# setting environment variable PAGER) ... <br>
&gt;</p>

<p style="margin-top: 1em">MOF representation <br>
An instance object can also print out its MOF
representation. This can be achieved by running:</p>

<p style="margin-top: 1em">&gt; instance.tomof() <br>
... verbose output of the instance in MOF syntax ... <br>
&gt;</p>

<p style="margin-top: 1em">Useful Properties <br>
Following part describes LMIInstance useful properties.</p>

<p style="margin-top: 1em">Class Name <br>
Each instance object provide a property, that returns its
class name. To get a string of the class name, run
following:</p>

<p style="margin-top: 1em">&gt; instance.classname <br>
ClassName <br>
&gt;</p>

<p style="margin-top: 1em">Namespace <br>
Each instance object also provides a property, that returns
a namespace name. To get a string of the namespace name, run
following:</p>

<p style="margin-top: 1em">&gt; instance.namespace <br>
Namespace <br>
&gt;</p>

<p style="margin-top: 1em">Path <br>
To retrieve a unique, wrapped, identification object for the
instance, LMIInstanceName, execute following:</p>

<p style="margin-top: 1em">&gt; instance.path <br>
LMIInstanceName(classname=&quot;ClassName&quot;...) <br>
&gt;</p>

<p style="margin-top: 1em">Connection Object <br>
This property returns a connection object, which was used to
retrieve the instance (refer to startup_connection). See
next example:</p>

<p style="margin-top: 1em">&gt; instance.connection <br>
LMIConnection(URI=&rsquo;uri&rsquo;,
user=&rsquo;user&rsquo;...) <br>
&gt;</p>

<p style="margin-top: 1em">Wrapped Object <br>
This property returns a wrapped pywbem object. See the
example:</p>

<p style="margin-top: 1em">&gt; instance.wrapped_object
<br>
CIMInstance(classname=u&rsquo;ClassName&rsquo;, ...) <br>
&gt;</p>

<p style="margin-top: 1em">Instance Names <br>
LMIInstanceName is a object, which holds a set of primary
keys and their values. This type of object exactly
identifies an instance.</p>

<p style="margin-top: 1em">Key properties <br>
To get a list of key properties, see following example:</p>

<p style="margin-top: 1em">&gt;
instance_name.print_key_properties() <br>
... <br>
&gt; instance_name.key_properties() <br>
... <br>
&gt; instance_name.SomeKeyProperty <br>
... <br>
&gt;</p>

<p style="margin-top: 1em">Conversion to a LMIInstance <br>
This type of object may be returned from a method call. Each
instance name can be converted into the instance, see next
example:</p>

<p style="margin-top: 1em">&gt; instance =
instance_name.to_instance() <br>
&gt;</p>

<p style="margin-top: 1em">Useful Properties <br>
Following part describes LMIInstanceName useful
properties.</p>

<p style="margin-top: 1em">Class Name <br>
The property returns a string representation of the class
name. See next example:</p>

<p style="margin-top: 1em">&gt; instance_name.classname
<br>
ClassName <br>
&gt;</p>

<p style="margin-top: 1em">Namespace <br>
The property returns a string representation of namesapce.
See next example:</p>

<p style="margin-top: 1em">&gt; instance_name.namespace
<br>
Namespace <br>
&gt;</p>

<p style="margin-top: 1em">Host Name <br>
This property returns a string representation of the host
name, where the CIM instance is located.</p>

<p style="margin-top: 1em">&gt; instance_name.hostname <br>
Hostname <br>
&gt;</p>

<p style="margin-top: 1em">Connection Object <br>
This property returns a connection object, which was used to
retrieve the instance name (refer to startup_connection).
See next example:</p>

<p style="margin-top: 1em">&gt; instance.connection <br>
LMIConnection(URI=&rsquo;uri&rsquo;,
user=&rsquo;user&rsquo;...) <br>
&gt;</p>

<p style="margin-top: 1em">Wrapped Object <br>
This property returns a wrapped pywbem object. See the
example:</p>

<p style="margin-top: 1em">&gt; instance.wrapped_object
<br>
CIMInstanceName(classname=u&rsquo;ClassName&rsquo;,
keybindings=NocaseDict(...), host=u&rsquo;hostname&rsquo;,
namespace=&rsquo;namespace&rsquo;) <br>
&gt;</p>

<p style="margin-top: 1em">Associated Objects <br>
CIM defines an association relationship between managed
objects. Following text describes the means of retrieving
associated objects within a given one.</p>

<p style="margin-top: 1em">Associated Instances <br>
To get a list of associated LMIInstance objects with a given
object, run following:</p>

<p style="margin-top: 1em">&gt; associated_objects =
instance.associators( <br>
... AssocClass=cls, <br>
... ResultClass=cls, <br>
... ResultRole=role, <br>
... IncludeQualifiers=include_qualifiers, <br>
... IncludeClassOrigin=include_class_origin, <br>
... PropertyList=property_lst) <br>
&gt; first_associated_object = instance.first_associator(
<br>
... AssocClass=cls, <br>
... ResultClass=cls, <br>
... ResultRole=role, <br>
... IncludeQualifiers=include_qualifiers, <br>
... IncludeClassOrigin=include_class_origin, <br>
... PropertyList=property_lst))</p>

<p style="margin-top: 1em">The list of returned associated
objects can be filtered by:</p>

<p style="margin-top: 1em">&Acirc;&middot; AssocClass --
Each returned object shall be associated to the source
object through an instance of this class or one of its
subclasses. Default value is None.</p>

<p style="margin-top: 1em">&Acirc;&middot; ResultClass --
Each returned object shall be either an instance of this
class (or one of its subclasses) or be this class (or one of
its subclasses). Default value is None.</p>

<p style="margin-top: 1em">&Acirc;&middot; Role -- Each
returned object shall be associated with the source object
through an association in which the source object plays the
specified role. That is, the name of the <br>
property in the association class that refers to the source
object shall match the value of this parameter. Default
value is None.</p>

<p style="margin-top: 1em">&Acirc;&middot; ResultRole --
Each returned object shall be associated to the source
object through an association in which the returned object
plays the specified role. That is, the name of <br>
the property in the association class that refers to the
returned object shall match the value of this parameter.
Default value is None.</p>

<p style="margin-top: 1em">Other parameters refer to:</p>

<p style="margin-top: 1em">&Acirc;&middot;
IncludeQualifiers -- Bool flag indicating, if all qualifiers
for each object (including qualifiers on the object and on
any returned properties) shall be included as
&lt;QUALI&acirc; <br>
FIER&gt; elements in the response. Default value is
False.</p>

<p style="margin-top: 1em">&Acirc;&middot;
IncludeClassOrigin -- Bool flag indicating, if the
CLASSORIGIN attribute shall be present on all appropriate
elements in each returned object. Default value is
False.</p>

<p style="margin-top: 1em">&Acirc;&middot; PropertyList --
The members of the array define one or more property names.
Each returned object shall not include elements for any
properties missing from this list. If Prop&acirc; <br>
ertyList is an empty list, no properties are included in
each returned object. If it is None, no additional filtering
is defined. Default value is None.</p>

<p style="margin-top: 1em">Associated Instance Names <br>
To get a list of associated LMIInstanceName objects with a
given object, run following:</p>

<p style="margin-top: 1em">&gt; associated_object_names =
instance.associator_names( <br>
... AssocClass=cls, <br>
... ResultClass=cls, <br>
... Role=role, <br>
... ResultRole=result_role) <br>
&gt; first_associated_object_name =
instance.first_associator_name( <br>
... AssocClass=cls, <br>
... ResultClass=cls, <br>
... Role=role, <br>
... ResultRole=result_role) <br>
&gt;</p>

<p style="margin-top: 1em">The list of returned associated
instance names can be filtered by:</p>

<p style="margin-top: 1em">&Acirc;&middot; AssocClass --
Each returned name identify an object that shall be
associated to the source object through an instance of this
class or one of its subclasses. Default value is <br>
None.</p>

<p style="margin-top: 1em">&Acirc;&middot; ResultClass --
Each returned name identify an object that shall be either
an instance of this class (or one of its subclasses) or be
this class (or one of its subclasses). <br>
Default value is None.</p>

<p style="margin-top: 1em">&Acirc;&middot; Role -- Each
returned name identify an object that shall be associated to
the source object through an association in which the source
object plays the specified role. That is, <br>
the name of the property in the association class that
refers to the source object shall match the value of this
parameter. Default value is None.</p>

<p style="margin-top: 1em">&Acirc;&middot; ResultRole --
Each returned name identify an object that shall be
associated to the source object through an association in
which the named returned object plays the specified <br>
role. That is, the name of the property in the association
class that refers to the returned object shall match the
value of this parameter. Default value is None.</p>

<p style="margin-top: 1em">Association Objects <br>
CIM defines an association relationship between managed
objects. Following text describes the means of retrieving
association objects within a given one. An association
object is <br>
the object, which defines the relationship between two other
objects.</p>

<p style="margin-top: 1em">Association Instances <br>
To get association LMIInstance objects that refer to a
particular target object, run following:</p>

<p style="margin-top: 1em">&gt; association_objects =
instance.references( <br>
... ResultClass=cls, <br>
... Role=role, <br>
... IncludeQualifiers=include_qualifiers, <br>
... IncludeClassOrigin=include_class_origin, <br>
... PropertyList=property_lst) <br>
&gt; first_association_object = instance.first_reference(
<br>
... ResultClass=cls, <br>
... Role=role, <br>
... IncludeQualifiers=include_qualifiers, <br>
... IncludeClassOrigin=include_class_origin, <br>
... PropertyList=property_lst) <br>
&gt;</p>

<p style="margin-top: 1em">The list of returned association
objects can be filtered by:</p>

<p style="margin-top: 1em">&Acirc;&middot; ResultClass --
Each returned object shall be an instance of this class (or
one of its subclasses) or this class (or one of its
subclasses). Default value is None.</p>

<p style="margin-top: 1em">&Acirc;&middot; Role -- Each
returned object shall refer to the target object through a
property with a name that matches the value of this
parameter. Default value is None.</p>

<p style="margin-top: 1em">Other parameters reffer to:</p>

<p style="margin-top: 1em">&Acirc;&middot;
IncludeQualifiers -- Each object (including qualifiers on
the object and on any returned properties) shall be included
as &lt;QUALIFIER&gt; elements in the response. Default value
is <br>
False.</p>

<p style="margin-top: 1em">&Acirc;&middot;
IncludeClassOrigin -- Flag indicating, if the CLASSORIGIN
attribute shall be present on all appropriate elements in
each returned object. Default value is False.</p>

<p style="margin-top: 1em">&Acirc;&middot; PropertyList --
The members of the list define one or more property names.
Each returned object shall not include elements for any
properties missing from this list. If Prop&acirc; <br>
ertyList is an empty list, no properties are included in
each returned object. If PropertyList is None, no additional
filtering is defined. Default value is None.</p>

<p style="margin-top: 1em">Association Instance Names <br>
To get a list of association LMIInstanceName objects, run
following:</p>

<p style="margin-top: 1em">&gt; association_object_names =
instance.reference_names( <br>
... ResultClass=cls, <br>
... Role=role) <br>
&gt; first_association_object_name =
instance.first_reference_name( <br>
... ResultClass=cls, <br>
... Role=role) <br>
&gt;</p>

<p style="margin-top: 1em">The list of returned association
instance names can be filtered by:</p>

<p style="margin-top: 1em">&Acirc;&middot; ResultClass --
Each returned Object Name identify an instance of this class
(or one of its subclasses) or this class (or one of its
subclasses). Default value is None.</p>

<p style="margin-top: 1em">&Acirc;&middot; Role -- Each
returned object name shall identify an object that refers to
the target instance through a property with a name that
matches the value of this parameter. Default <br>
value is None.</p>

<p style="margin-top: 1em">Indications <br>
Indication is a reaction to some specific event that occurs
in response to a change to a particular change in data.
LMIShell can perform a indication subscription, by which we
<br>
can receive such event responses.</p>

<p style="margin-top: 1em">Subscribing to an indication
<br>
The LMIShell is capable of creating an indication
subscription with the filter and handler objects in one
single step. This example is based upon sblim-cmpi-base
provider.</p>

<p style="margin-top: 1em">How to subscribe to an
indication, please, follow the next example:</p>

<p style="margin-top: 1em">&gt; c =
connect(&quot;host&quot;, &quot;privileged_user&quot;,
&quot;password&quot;) <br>
&gt; c.subscribe_indication( <br>
... QueryLanguage=&quot;WQL&quot;, <br>
... Query=&rsquo;SELECT * FROM CIM_InstModification&rsquo;,
<br>
... Name=&quot;cpu&quot;, <br>
... CreationNamespace=&quot;root/interop&quot;, <br>
...
SubscriptionCreationClassName=&quot;CIM_IndicationSubscription&quot;,
<br>
...
FilterCreationClassName=&quot;CIM_IndicationFilter&quot;,
<br>
...
FilterSystemCreationClassName=&quot;CIM_ComputerSystem&quot;,
<br>
... FilterSourceNamespace=&quot;root/cimv2&quot;, <br>
...
HandlerCreationClassName=&quot;CIM_IndicationHandlerCIMXML&quot;,
<br>
...
HandlerSystemCreationClassName=&quot;CIM_ComputerSystem&quot;,
<br>
... # destination computer, where the indications will be
delivered <br>
... Destination=&quot;http://192.168.122.1:5988&quot; <br>
... ) <br>
LMIReturnValue(rval=True, rparams={}, errorstr=&quot;&quot;)
<br>
&gt;</p>

<p style="margin-top: 1em">The previous code can be
simplified by omitting some optional parameters:</p>

<p style="margin-top: 1em">&Acirc;&middot; QueryLanguage:
DMTF:CQL</p>

<p style="margin-top: 1em">&Acirc;&middot;
CreationNamespace: root/interop</p>

<p style="margin-top: 1em">&Acirc;&middot;
SubscriptionCreationClassName:
CIM_IndicationSubscription</p>

<p style="margin-top: 1em">&Acirc;&middot;
FilterCreationClassName: CIM_IndicationFilter</p>

<p style="margin-top: 1em">&Acirc;&middot;
FilterSystemCreationClassName: CIM_ComputerSystem</p>

<p style="margin-top: 1em">&Acirc;&middot;
FilterSourceNamespace: root/cimv2</p>

<p style="margin-top: 1em">&Acirc;&middot;
HandlerCreationClassName: CIM_IndicationHandlerCIMXML</p>

<p style="margin-top: 1em">&Acirc;&middot;
HandlerSystemCreationClassName: CIM_ComputerSystem</p>

<p style="margin-top: 1em">Simplified subscription:</p>

<p style="margin-top: 1em">&gt; c =
connect(&quot;host&quot;, &quot;privileged_user&quot;,
&quot;password&quot;) <br>
&gt; c.subscribe_indication( <br>
... Name=&quot;cpu&quot;, <br>
... Query=&rsquo;SELECT * FROM CIM_InstModification&rsquo;,
<br>
... Destination=&quot;http://192.168.122.1:5988&quot; <br>
... ) <br>
LMIReturnValue(rval=True, rparams={}, errorstr=&quot;&quot;)
<br>
&gt;</p>

<p style="margin-top: 1em">NOTE: Make sure, that you are
logged-in with an account, which has write privileges in the
root/interop namespace.</p>

<p style="margin-top: 1em">In this state, we have a
indication subscription created.</p>

<p style="margin-top: 1em">Auto-delete subscriptions <br>
By default all subscriptions created by LMIShell will be
auto-deleted, when the shell quits. To change this behavior,
you can pass Permanent=True keyword parameter to
LMIConnec&acirc; <br>
tion.subscribe_indication() call, which will prevent
LMIShell from deleting the subscription.</p>

<p style="margin-top: 1em">Listing subscribed indications
<br>
To list all the subscribed indications, run following
code:</p>

<p style="margin-top: 1em">&gt;
c.print_subscribed_indications() <br>
... <br>
&gt; subscribed_ind_lst = c.subscribed_indications() <br>
&gt;</p>

<p style="margin-top: 1em">Unsubscribing from an
indications <br>
By default, the subscriptions created by the shell are
auto-deleted, when the shell quits.</p>

<p style="margin-top: 1em">If you want to delete the
subscriptions sooner, you can use following methods:</p>

<p style="margin-top: 1em">&gt;
c.unsubscribe_indication(indication_name) <br>
LMIReturnValue(rval=True, rparams={}, errorstr=&quot;&quot;)
<br>
&gt; c.unsubscribe_all_indications() <br>
&gt;</p>

<p style="margin-top: 1em">Indication handler <br>
In the previous example, there is a local computer specified
(the one, which runs the shell), now we need to start a
indication listener with our indication handler function
<br>
defined. This example continues (see previous one). It is
also possible to start another shell, script and start the
indication listener there.</p>

<p style="margin-top: 1em">See the following example:</p>

<p style="margin-top: 1em">&gt; def handler(ind, arg1,
arg2, **kwargs): <br>
... exported_objects = ind.exported_objects() <br>
... do_something_with(exported_objects) <br>
&gt; listener = LmiIndicationListener(&quot;0.0.0.0&quot;,
listening_port) <br>
&gt;
listener.add_handler(&quot;indication-name-XXXXXXXX&quot;,
handler, arg1, arg2, **kwargs) <br>
&gt; listener.start() <br>
&gt;</p>

<p style="margin-top: 1em">The first argument of the
handler is LMIIndication object, which contains list of
methods and objects exported by the indication. Other
parameters are user specific; those argu&acirc; <br>
ments need to be specified, when adding a handler to the
listener. In the example, there is a special string used in
the LMIIndicationListener.add_handler() call; note the eight
<br>
&quot;X&quot; characters. Those characters will be replaced
by random string, which is generated by the listeners to
avoid handler name clash. If you want to use that
random-based string, <br>
start indication listener first, then subscribe to an
indication, so the Destination property of a handler object
contains &lt;schema&gt;://&lt;hostname&gt;/&lt;random-based
string&gt;.</p>

<p style="margin-top: 1em">Return Values <br>
Method calls return an object, that represents a return
value of the given method. This type of object can be
converted into python&rsquo;s typical 3-item tuple and
consists of 3 <br>
items:</p>

<p style="margin-top: 1em">&Acirc;&middot; rval -- return
value</p>

<p style="margin-top: 1em">&Acirc;&middot; rparams --
return value parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; errorstr --
error string, if any</p>

<p style="margin-top: 1em">Following example shows, how to
use and convert LMIReturnValue object to tuple:</p>

<p style="margin-top: 1em">&gt; return_value =
instance.MethodCall() <br>
&gt; return_value.rval <br>
0 <br>
&gt; return_value.rparams <br>
[] <br>
&gt; return_value.errorstr</p>

<p style="margin-top: 1em">&gt; (rval, rparams, errorstr) =
return_value <br>
&gt; rval <br>
0 <br>
&gt; rparams <br>
[] <br>
&gt; errorstr</p>

<p style="margin-top: 1em">&gt;</p>

<p style="margin-top: 1em">Interactive Interface <br>
This section covers some features, that are present in the
interactive interface or are related to the LMIShell.</p>

<p style="margin-top: 1em">History <br>
When using the interactive interface of the LMIShell, you
can use up/down arrows to navigate in history of all the
commands you previously used.</p>

<p style="margin-top: 1em">Clearing the history <br>
If you want to clear the history, simply run:</p>

<p style="margin-top: 1em">&gt; clear_history() <br>
&gt;</p>

<p style="margin-top: 1em">Reversed search <br>
The LMIShell can also search in the history of commands by
hitting &lt;ctrl+r&gt; and typing the command prefix (as
your default shell does). See following:</p>


<p style="margin-top: 1em">(reverse-i-search)&rsquo;connect&rsquo;:
c = connect(&quot;host&quot;, &quot;username&quot;)</p>

<p style="margin-top: 1em">Exception handling <br>
Exception handling by the shell can be turned off -- since
then, all the exceptions need to be handled by your code. By
default, LMIShell handles the exceptions and uses C-like
<br>
return values (See section return_values) To allow all the
exceptions to propagate to your code, run this:</p>

<p style="margin-top: 1em">&gt; use_exceptions() <br>
&gt;</p>

<p style="margin-top: 1em">To turn exception handling by
the shell back on, run this:</p>

<p style="margin-top: 1em">&gt; use_exceptions(False) <br>
&gt;</p>

<p style="margin-top: 1em">Cache <br>
The LMIShell&rsquo;s connection objects use a temporary
cache for storing CIM class names and CIM classes to save
network communication.</p>

<p style="margin-top: 1em">The cache can be cleared, see
following example:</p>

<p style="margin-top: 1em">&gt; c.clear_cache() <br>
&gt;</p>

<p style="margin-top: 1em">The cache can be also turned
off, see next example:</p>

<p style="margin-top: 1em">&gt; c.use_cache(False) <br>
&gt;</p>

<p style="margin-top: 1em">Tab-completion <br>
Interactive interface also supports tab-completion for basic
programming structures and also for CIM objects (such as
namespace, classes, methods and properties completion,
etc).</p>

<p style="margin-top: 1em">Following code shows few
examples:</p>

<p style="margin-top: 1em">&gt; c = conn&lt;tab&gt; <br>
&gt; c = connect(</p>

<p style="margin-top: 1em">&gt; lmi_service_class =
c.root.c&lt;tab&gt; <br>
&gt; lmi_service_class = c.root.cimv2 <br>
&gt; lmi_service_class = c.root.cimv2.lmi_ser&lt;tab&gt;
<br>
&gt; lmi_service_class = c.root.cimv2.LMI_Service</p>

<p style="margin-top: 1em">&gt; sshd_service =
lmi_s&lt;tab&gt; <br>
&gt; sshd_service = lmi_service_class</p>

<p style="margin-top: 1em">&gt;
sshd_service.Stat&lt;tab&gt; <br>
&gt; sshd_service.Status</p>

<p style="margin-top: 1em">&gt; sshd_service.Res&lt;tab&gt;
<br>
&gt; sshd_service.RestartService(</p>

<p style="margin-top: 1em">&gt;
lmi_service_class.Req&lt;tab&gt; <br>
&gt; lmi_service_class.RequestedStateChangeValues <br>
&gt;
lmi_service_class.RequestesStateChangeValues.Sh&lt;tab&gt;
<br>
&gt; lmi_service_class.RequestedStateChangeValues.Shutdown
<br>
&gt; # similar for method calls, as well <br>
&gt;</p>

<p style="margin-top: 1em">Builtin features <br>
This section describes built-in features of the
LMIShell.</p>

<p style="margin-top: 1em">Configuration file <br>
The LMIShell has a tiny configuration file with location
~/.lmishellrc. In configuration file, you can set these
properties:</p>

<p style="margin-top: 1em"># location of the history used
by interactive mode <br>
history_file = &quot;~/.lmishell_history&quot; <br>
# length of history file, -1 for unlimited <br>
history_length = -1 <br>
# default value for cache usage <br>
use_cache = True <br>
# default value for exceptions <br>
use_exceptions = False</p>

<p style="margin-top: 1em">Inspecting a script <br>
If you want to inspect a script after it has been
interpreted by the LMIShell, run this:</p>

<p style="margin-top: 1em">$ lmishell -i some_script.lmi
<br>
# some stuff done <br>
&gt;</p>

<p style="margin-top: 1em">NOTE: Prefered extension of
LMIShell&rsquo;s scripts is .lmi.</p>

<p style="margin-top: 1em">LMI Is Instance <br>
LMIShell is able to verify, if a LMIInstance or
LMIInstanceName object passed to lmi_isinstance() is a
instance of LMIClass.</p>

<p style="margin-top: 1em">The function is similar to
python&rsquo;s isinstance():</p>

<p style="margin-top: 1em">&gt; lmi_isinstance(inst, cls)
<br>
True/False <br>
&gt;</p>

<p style="margin-top: 1em">LMI Associators <br>
LMIShell can speed up associated objects&rsquo; traversal by
manual joining, instead of calling
LMIInstance.associators(). The call needs to get a list of
association classes, for <br>
which the referenced objects will be joined. The list must
contain objects of LMIClass.</p>

<p style="margin-top: 1em">See following example:</p>

<p style="margin-top: 1em">&gt; associators =
lmi_associators(list_of_association_classes) <br>
&gt;</p>

<p style="margin-top: 1em">AUTHOR <br>
Peter Hatina &lt;phatina@redhat.com&gt;</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2012-2013, Red Hat Inc.</p>

<p style="margin-top: 1em">0.9 June 09, 2014
LMISHELL(1)</p>
<hr>
</body>
</html>
