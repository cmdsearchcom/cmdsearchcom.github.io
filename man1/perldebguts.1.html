<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:46 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLDEBGUTS(1) Perl Programmers Reference Guide
PERLDEBGUTS(1)</p>

<p style="margin-top: 1em">NAME <br>
perldebguts - Guts of Perl debugging</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This is not perldebug, which tells you how to use the
debugger. This manpage describes low-level details
concerning the debugger&rsquo;s internals, which range from
difficult to <br>
impossible to understand for anyone who isn&rsquo;t
incredibly intimate with Perl&rsquo;s guts. Caveat
lector.</p>

<p style="margin-top: 1em">Debugger Internals <br>
Perl has special debugging hooks at compile-time and
run-time used to create debugging environments. These hooks
are not to be confused with the perl -Dxxx command described
in <br>
perlrun, which is usable only if a special Perl is built per
the instructions in the INSTALL podpage in the Perl source
tree.</p>

<p style="margin-top: 1em">For example, whenever you call
Perl&rsquo;s built-in &quot;caller&quot; function from the
package &quot;DB&quot;, the arguments that the corresponding
stack frame was called with are copied to the <br>
@DB::args array. These mechanisms are enabled by calling
Perl with the -d switch. Specifically, the following
additional features are enabled (cf. &quot;$^P&quot; in
perlvar):</p>

<p style="margin-top: 1em">&Acirc;&middot; Perl inserts the
contents of $ENV{PERL5DB} (or &quot;BEGIN {require
&rsquo;perl5db.pl&rsquo;}&quot; if not present) before the
first line of your program.</p>

<p style="margin-top: 1em">&Acirc;&middot; Each array
&quot;@{&quot;_&lt;$filename&quot;}&quot; holds the lines of
$filename for a file compiled by Perl. The same is also true
for &quot;eval&quot;ed strings that contain subroutines, or
which are <br>
currently being executed. The $filename for
&quot;eval&quot;ed strings looks like &quot;(eval 34)&quot;.
Code assertions in regexes look like &quot;(re_eval
19)&quot;.</p>

<p style="margin-top: 1em">Values in this array are magical
in numeric context: they compare equal to zero only if the
line is not breakable.</p>

<p style="margin-top: 1em">&Acirc;&middot; Each hash
&quot;%{&quot;_&lt;$filename&quot;}&quot; contains
breakpoints and actions keyed by line number. Individual
entries (as opposed to the whole hash) are settable. Perl
only cares about <br>
Boolean true here, although the values used by perl5db.pl
have the form &quot;$break_condition $action&quot;.</p>

<p style="margin-top: 1em">The same holds for evaluated
strings that contain subroutines, or which are currently
being executed. The $filename for &quot;eval&quot;ed strings
looks like &quot;(eval 34)&quot; or &quot;(re_eval <br>
19)&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Each scalar
&quot;${&quot;_&lt;$filename&quot;}&quot; contains
&quot;_&lt;$filename&quot;. This is also the case for
evaluated strings that contain subroutines, or which are
currently being executed. The <br>
$filename for &quot;eval&quot;ed strings looks like
&quot;(eval 34)&quot; or &quot;(re_eval 19)&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; After each
&quot;require&quot;d file is compiled, but before it is
executed,
&quot;DB::postponed(*{&quot;_&lt;$filename&quot;})&quot; is
called if the subroutine &quot;DB::postponed&quot; exists.
Here, the $filename <br>
is the expanded name of the &quot;require&quot;d file, as
found in the values of %INC.</p>

<p style="margin-top: 1em">&Acirc;&middot; After each
subroutine &quot;subname&quot; is compiled, the existence of
$DB::postponed{subname} is checked. If this key exists,
&quot;DB::postponed(subname)&quot; is called if the <br>
&quot;DB::postponed&quot; subroutine also exists.</p>

<p style="margin-top: 1em">&Acirc;&middot; A hash %DB::sub
is maintained, whose keys are subroutine names and whose
values have the form &quot;filename:startline-endline&quot;.
&quot;filename&quot; has the form &quot;(eval 34)&quot; for
<br>
subroutines defined inside &quot;eval&quot;s, or
&quot;(re_eval 19)&quot; for those within regex code
assertions.</p>

<p style="margin-top: 1em">&Acirc;&middot; When the
execution of your program reaches a point that can hold a
breakpoint, the &quot;DB::DB()&quot; subroutine is called if
any of the variables $DB::trace, $DB::single, or <br>
$DB::signal is true. These variables are not
&quot;local&quot;izable. This feature is disabled when
executing inside &quot;DB::DB()&quot;, including functions
called from it unless &quot;$^D &amp; <br>
(1&lt;&lt;30)&quot; is true.</p>

<p style="margin-top: 1em">&Acirc;&middot; When execution
of the program reaches a subroutine call, a call to
&amp;DB::sub(args) is made instead, with $DB::sub holding
the name of the called subroutine. (This doesn&rsquo;t <br>
happen if the subroutine was compiled in the &quot;DB&quot;
package.)</p>

<p style="margin-top: 1em">Note that if &amp;DB::sub needs
external data for it to work, no subroutine call is possible
without it. As an example, the standard debugger&rsquo;s
&amp;DB::sub depends on the $DB::deep <br>
variable (it defines how many levels of recursion deep into
the debugger you can go before a mandatory break). If
$DB::deep is not defined, subroutine calls are not possible,
<br>
even though &amp;DB::sub exists.</p>

<p style="margin-top: 1em">Writing Your Own Debugger <br>
Environment Variables</p>

<p style="margin-top: 1em">The &quot;PERL5DB&quot;
environment variable can be used to define a debugger. For
example, the minimal &quot;working&quot; debugger (it
actually doesn&rsquo;t do anything) consists of one
line:</p>

<p style="margin-top: 1em">sub DB::DB {}</p>

<p style="margin-top: 1em">It can easily be defined like
this:</p>

<p style="margin-top: 1em">$ PERL5DB=&quot;sub DB::DB
{}&quot; perl -d your-script</p>

<p style="margin-top: 1em">Another brief debugger, slightly
more useful, can be created with only the line:</p>

<p style="margin-top: 1em">sub DB::DB {print ++$i; scalar
&lt;STDIN&gt;}</p>

<p style="margin-top: 1em">This debugger prints a number
which increments for each statement encountered and waits
for you to hit a newline before continuing to the next
statement.</p>

<p style="margin-top: 1em">The following debugger is
actually useful:</p>

<p style="margin-top: 1em">{ <br>
package DB; <br>
sub DB {} <br>
sub sub {print ++$i, &quot; $sub0; &amp;$sub} <br>
}</p>

<p style="margin-top: 1em">It prints the sequence number of
each subroutine call and the name of the called subroutine.
Note that &amp;DB::sub is being compiled into the package
&quot;DB&quot; through the use of the <br>
&quot;package&quot; directive.</p>

<p style="margin-top: 1em">When it starts, the debugger
reads your rc file (./.perldb or ~/.perldb under Unix),
which can set important options. (A subroutine
(&amp;afterinit) can be defined here as well; it <br>
is executed after the debugger completes its own
initialization.)</p>

<p style="margin-top: 1em">After the rc file is read, the
debugger reads the PERLDB_OPTS environment variable and uses
it to set debugger options. The contents of this variable
are treated as if they were <br>
the argument of an &quot;o ...&quot; debugger command (q.v.
in &quot;Configurable Options&quot; in perldebug).</p>

<p style="margin-top: 1em">Debugger Internal Variables</p>

<p style="margin-top: 1em">In addition to the file and
subroutine-related variables mentioned above, the debugger
also maintains various magical internal variables.</p>

<p style="margin-top: 1em">&Acirc;&middot; @DB::dbline is
an alias for &quot;@{&quot;::_&lt;current_file&quot;}&quot;,
which holds the lines of the currently-selected file
(compiled by Perl), either explicitly chosen with the
debugger&rsquo;s &quot;f&quot; <br>
command, or implicitly by flow of execution.</p>

<p style="margin-top: 1em">Values in this array are magical
in numeric context: they compare equal to zero only if the
line is not breakable.</p>

<p style="margin-top: 1em">&Acirc;&middot; %DB::dbline is
an alias for &quot;%{&quot;::_&lt;current_file&quot;}&quot;,
which contains breakpoints and actions keyed by line number
in the currently-selected file, either explicitly chosen
with <br>
the debugger&rsquo;s &quot;f&quot; command, or implicitly by
flow of execution.</p>

<p style="margin-top: 1em">As previously noted, individual
entries (as opposed to the whole hash) are settable. Perl
only cares about Boolean true here, although the values used
by perl5db.pl have the <br>
form &quot;$break_condition $action&quot;.</p>

<p style="margin-top: 1em">Debugger Customization
Functions</p>

<p style="margin-top: 1em">Some functions are provided to
simplify customization.</p>

<p style="margin-top: 1em">&Acirc;&middot; See
&quot;Configurable Options&quot; in perldebug for a
description of options parsed by
&quot;DB::parse_options(string)&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;DB::dump_trace(skip[,count])&quot; skips the specified
number of frames and returns a list containing information
about the calling frames (all of them, if &quot;count&quot;
is missing). <br>
Each entry is reference to a hash with keys
&quot;context&quot; (either &quot;.&quot;, &quot;$&quot;, or
&quot;@&quot;), &quot;sub&quot; (subroutine name, or info
about &quot;eval&quot;), &quot;args&quot; (&quot;undef&quot;
or a reference to an array), <br>
&quot;file&quot;, and &quot;line&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;DB::print_trace(FH, skip[, count[, short]])&quot;
prints formatted info about caller frames. The last two
functions may be convenient as arguments to
&quot;&lt;&quot;, &quot;&lt;&lt;&quot; commands.</p>

<p style="margin-top: 1em">Note that any variables and
functions that are not documented in this manpages (or in
perldebug) are considered for internal use only, and as such
are subject to change without <br>
notice.</p>

<p style="margin-top: 1em">Frame Listing Output Examples
<br>
The &quot;frame&quot; option can be used to control the
output of frame information. For example, contrast this
expression trace:</p>

<p style="margin-top: 1em">$ perl -de 42 <br>
Stack dump during die enabled outside of evals.</p>

<p style="margin-top: 1em">Loading DB routines from
perl5db.pl patch level 0.94 <br>
Emacs support available.</p>

<p style="margin-top: 1em">Enter h or &rsquo;h h&rsquo; for
help.</p>

<p style="margin-top: 1em">main::(-e:1): 0 <br>
DB&lt;1&gt; sub foo { 14 }</p>

<p style="margin-top: 1em">DB&lt;2&gt; sub bar { 3 }</p>

<p style="margin-top: 1em">DB&lt;3&gt; t print foo() *
bar() <br>
main::((eval 172):3): print foo() + bar(); <br>
main::foo((eval 168):2): <br>
main::bar((eval 170):2): <br>
42</p>

<p style="margin-top: 1em">with this one, once the
&quot;o&quot;ption &quot;frame=2&quot; has been set:</p>

<p style="margin-top: 1em">DB&lt;4&gt; o f=2 <br>
frame = &rsquo;2&rsquo; <br>
DB&lt;5&gt; t print foo() * bar() <br>
3: foo() * bar() <br>
entering main::foo <br>
2: sub foo { 14 }; <br>
exited main::foo <br>
entering main::bar <br>
2: sub bar { 3 }; <br>
exited main::bar <br>
42</p>

<p style="margin-top: 1em">By way of demonstration, we
present below a laborious listing resulting from setting
your &quot;PERLDB_OPTS&quot; environment variable to the
value &quot;f=n N&quot;, and running perl -d -V from the
<br>
command line. Examples using various values of &quot;n&quot;
are shown to give you a feel for the difference between
settings. Long though it may be, this is not a complete
listing, but <br>
only excerpts.</p>

<p style="margin-top: 1em">1. <br>
entering main::BEGIN <br>
entering Config::BEGIN <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
Package lib/Config.pm. <br>
entering Config::TIEHASH <br>
entering Exporter::import <br>
entering Exporter::export <br>
entering Config::myconfig <br>
entering Config::FETCH <br>
entering Config::FETCH <br>
entering Config::FETCH <br>
entering Config::FETCH</p>

<p style="margin-top: 1em">2. <br>
entering main::BEGIN <br>
entering Config::BEGIN <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
exited Config::BEGIN <br>
Package lib/Config.pm. <br>
entering Config::TIEHASH <br>
exited Config::TIEHASH <br>
entering Exporter::import <br>
entering Exporter::export <br>
exited Exporter::export <br>
exited Exporter::import <br>
exited main::BEGIN <br>
entering Config::myconfig <br>
entering Config::FETCH <br>
exited Config::FETCH <br>
entering Config::FETCH <br>
exited Config::FETCH <br>
entering Config::FETCH</p>

<p style="margin-top: 1em">3. <br>
in $=main::BEGIN() from /dev/null:0 <br>
in $=Config::BEGIN() from lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH(&rsquo;Config&rsquo;) from
lib/Config.pm:644 <br>
in $=Exporter::import(&rsquo;Config&rsquo;,
&rsquo;myconfig&rsquo;, &rsquo;config_vars&rsquo;) from
/dev/null:0 <br>
in $=Exporter::export(&rsquo;Config&rsquo;,
&rsquo;main&rsquo;, &rsquo;myconfig&rsquo;,
&rsquo;config_vars&rsquo;) from li <br>
in @=Config::myconfig() from /dev/null:0 <br>
in $=Config::FETCH(ref(Config), &rsquo;package&rsquo;) from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), &rsquo;baserev&rsquo;) from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), &rsquo;PERL_VERSION&rsquo;)
from lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config),
&rsquo;PERL_SUBVERSION&rsquo;) from lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), &rsquo;osname&rsquo;) from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), &rsquo;osvers&rsquo;) from
lib/Config.pm:574</p>

<p style="margin-top: 1em">4. <br>
in $=main::BEGIN() from /dev/null:0 <br>
in $=Config::BEGIN() from lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
out $=Config::BEGIN() from lib/Config.pm:0 <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH(&rsquo;Config&rsquo;) from
lib/Config.pm:644 <br>
out $=Config::TIEHASH(&rsquo;Config&rsquo;) from
lib/Config.pm:644 <br>
in $=Exporter::import(&rsquo;Config&rsquo;,
&rsquo;myconfig&rsquo;, &rsquo;config_vars&rsquo;) from
/dev/null:0 <br>
in $=Exporter::export(&rsquo;Config&rsquo;,
&rsquo;main&rsquo;, &rsquo;myconfig&rsquo;,
&rsquo;config_vars&rsquo;) from lib/ <br>
out $=Exporter::export(&rsquo;Config&rsquo;,
&rsquo;main&rsquo;, &rsquo;myconfig&rsquo;,
&rsquo;config_vars&rsquo;) from lib/ <br>
out $=Exporter::import(&rsquo;Config&rsquo;,
&rsquo;myconfig&rsquo;, &rsquo;config_vars&rsquo;) from
/dev/null:0 <br>
out $=main::BEGIN() from /dev/null:0 <br>
in @=Config::myconfig() from /dev/null:0 <br>
in $=Config::FETCH(ref(Config), &rsquo;package&rsquo;) from
lib/Config.pm:574 <br>
out $=Config::FETCH(ref(Config), &rsquo;package&rsquo;) from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), &rsquo;baserev&rsquo;) from
lib/Config.pm:574 <br>
out $=Config::FETCH(ref(Config), &rsquo;baserev&rsquo;) from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), &rsquo;PERL_VERSION&rsquo;)
from lib/Config.pm:574 <br>
out $=Config::FETCH(ref(Config), &rsquo;PERL_VERSION&rsquo;)
from lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config),
&rsquo;PERL_SUBVERSION&rsquo;) from lib/Config.pm:574</p>

<p style="margin-top: 1em">5. <br>
in $=main::BEGIN() from /dev/null:0 <br>
in $=Config::BEGIN() from lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
out $=Config::BEGIN() from lib/Config.pm:0 <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH(&rsquo;Config&rsquo;) from
lib/Config.pm:644 <br>
out $=Config::TIEHASH(&rsquo;Config&rsquo;) from
lib/Config.pm:644 <br>
in $=Exporter::import(&rsquo;Config&rsquo;,
&rsquo;myconfig&rsquo;, &rsquo;config_vars&rsquo;) from
/dev/null:0 <br>
in $=Exporter::export(&rsquo;Config&rsquo;,
&rsquo;main&rsquo;, &rsquo;myconfig&rsquo;,
&rsquo;config_vars&rsquo;) from lib/E <br>
out $=Exporter::export(&rsquo;Config&rsquo;,
&rsquo;main&rsquo;, &rsquo;myconfig&rsquo;,
&rsquo;config_vars&rsquo;) from lib/E <br>
out $=Exporter::import(&rsquo;Config&rsquo;,
&rsquo;myconfig&rsquo;, &rsquo;config_vars&rsquo;) from
/dev/null:0 <br>
out $=main::BEGIN() from /dev/null:0 <br>
in @=Config::myconfig() from /dev/null:0 <br>
in $=Config::FETCH(&rsquo;Config=HASH(0x1aa444)&rsquo;,
&rsquo;package&rsquo;) from lib/Config.pm:574 <br>
out $=Config::FETCH(&rsquo;Config=HASH(0x1aa444)&rsquo;,
&rsquo;package&rsquo;) from lib/Config.pm:574 <br>
in $=Config::FETCH(&rsquo;Config=HASH(0x1aa444)&rsquo;,
&rsquo;baserev&rsquo;) from lib/Config.pm:574 <br>
out $=Config::FETCH(&rsquo;Config=HASH(0x1aa444)&rsquo;,
&rsquo;baserev&rsquo;) from lib/Config.pm:574</p>

<p style="margin-top: 1em">6. <br>
in $=CODE(0x15eca4)() from /dev/null:0 <br>
in $=CODE(0x182528)() from lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
out $=CODE(0x182528)() from lib/Config.pm:0 <br>
scalar context return from CODE(0x182528): undef <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH(&rsquo;Config&rsquo;) from
lib/Config.pm:628 <br>
out $=Config::TIEHASH(&rsquo;Config&rsquo;) from
lib/Config.pm:628 <br>
scalar context return from Config::TIEHASH: empty hash <br>
in $=Exporter::import(&rsquo;Config&rsquo;,
&rsquo;myconfig&rsquo;, &rsquo;config_vars&rsquo;) from
/dev/null:0 <br>
in $=Exporter::export(&rsquo;Config&rsquo;,
&rsquo;main&rsquo;, &rsquo;myconfig&rsquo;,
&rsquo;config_vars&rsquo;) from lib/Exporter.pm:171 <br>
out $=Exporter::export(&rsquo;Config&rsquo;,
&rsquo;main&rsquo;, &rsquo;myconfig&rsquo;,
&rsquo;config_vars&rsquo;) from lib/Exporter.pm:171 <br>
scalar context return from Exporter::export: &rsquo;&rsquo;
<br>
out $=Exporter::import(&rsquo;Config&rsquo;,
&rsquo;myconfig&rsquo;, &rsquo;config_vars&rsquo;) from
/dev/null:0 <br>
scalar context return from Exporter::import:
&rsquo;&rsquo;</p>

<p style="margin-top: 1em">In all cases shown above, the
line indentation shows the call tree. If bit 2 of
&quot;frame&quot; is set, a line is printed on exit from a
subroutine as well. If bit 4 is set, the <br>
arguments are printed along with the caller info. If bit 8
is set, the arguments are printed even if they are tied or
references. If bit 16 is set, the return value is printed,
<br>
too.</p>

<p style="margin-top: 1em">When a package is compiled, a
line like this</p>

<p style="margin-top: 1em">Package lib/Carp.pm.</p>

<p style="margin-top: 1em">is printed with proper
indentation.</p>

<p style="margin-top: 1em">Debugging Regular Expressions
<br>
There are two ways to enable debugging output for regular
expressions.</p>

<p style="margin-top: 1em">If your perl is compiled with
&quot;-DDEBUGGING&quot;, you may use the -Dr flag on the
command line.</p>

<p style="margin-top: 1em">Otherwise, one can &quot;use re
&rsquo;debug&rsquo;&quot;, which has effects at compile time
and run time. Since Perl 5.9.5, this pragma is lexically
scoped.</p>

<p style="margin-top: 1em">Compile-time Output <br>
The debugging output at compile time looks like this:</p>

<p style="margin-top: 1em">Compiling REx
&rsquo;[bc]d(ef*g)+h[ij]k$&rsquo; <br>
size 45 Got 364 bytes for offset annotations. <br>
first at 1 <br>
rarest char g at 0 <br>
rarest char d at 0 <br>
1: ANYOF[bc](12) <br>
12: EXACT &lt;d&gt;(14) <br>
14: CURLYX[0] {1,32767}(28) <br>
16: OPEN1(18) <br>
18: EXACT &lt;e&gt;(20) <br>
20: STAR(23) <br>
21: EXACT &lt;f&gt;(0) <br>
23: EXACT &lt;g&gt;(25) <br>
25: CLOSE1(27) <br>
27: WHILEM[1/1](0) <br>
28: NOTHING(29) <br>
29: EXACT &lt;h&gt;(31) <br>
31: ANYOF[ij](42) <br>
42: EXACT &lt;k&gt;(44) <br>
44: EOL(45) <br>
45: END(0) <br>
anchored &rsquo;de&rsquo; at 1 floating &rsquo;gh&rsquo; at
3..2147483647 (checking floating) <br>
stclass &rsquo;ANYOF[bc]&rsquo; minlen 7 <br>
Offsets: [45] <br>
1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
<br>
0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1]
0[0] <br>
11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
<br>
0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0] <br>
Omitting $&lsquo; $&amp; $&rsquo; support.</p>

<p style="margin-top: 1em">The first line shows the
pre-compiled form of the regex. The second shows the size of
the compiled form (in arbitrary units, usually 4-byte words)
and the total number of bytes <br>
allocated for the offset/length table, usually
4+&quot;size&quot;*8. The next line shows the label id of
the first node that does a match.</p>

<p style="margin-top: 1em">The</p>

<p style="margin-top: 1em">anchored &rsquo;de&rsquo; at 1
floating &rsquo;gh&rsquo; at 3..2147483647 (checking
floating) <br>
stclass &rsquo;ANYOF[bc]&rsquo; minlen 7</p>

<p style="margin-top: 1em">line (split into two lines
above) contains optimizer information. In the example shown,
the optimizer found that the match should contain a
substring &quot;de&quot; at offset 1, plus <br>
substring &quot;gh&quot; at some offset between 3 and
infinity. Moreover, when checking for these substrings (to
abandon impossible matches quickly), Perl will check for the
substring <br>
&quot;gh&quot; before checking for the substring
&quot;de&quot;. The optimizer may also use the knowledge
that the match starts (at the &quot;first&quot; id) with a
character class, and no string shorter <br>
than 7 characters can possibly match.</p>

<p style="margin-top: 1em">The fields of interest which may
appear in this line are</p>

<p style="margin-top: 1em">&quot;anchored&quot; STRING
&quot;at&quot; POS <br>
&quot;floating&quot; STRING &quot;at&quot; POS1..POS2 <br>
See above.</p>

<p style="margin-top: 1em">&quot;matching
floating/anchored&quot; <br>
Which substring to check first.</p>

<p style="margin-top: 1em">&quot;minlen&quot; <br>
The minimal length of the match.</p>

<p style="margin-top: 1em">&quot;stclass&quot; TYPE <br>
Type of first matching node.</p>

<p style="margin-top: 1em">&quot;noscan&quot; <br>
Don&rsquo;t scan for the found substrings.</p>

<p style="margin-top: 1em">&quot;isall&quot; <br>
Means that the optimizer information is all that the regular
expression contains, and thus one does not need to enter the
regex engine at all.</p>

<p style="margin-top: 1em">&quot;GPOS&quot; <br>
Set if the pattern contains &quot;G&quot;.</p>

<p style="margin-top: 1em">&quot;plus&quot; <br>
Set if the pattern starts with a repeated char (as in
&quot;x+y&quot;).</p>

<p style="margin-top: 1em">&quot;implicit&quot; <br>
Set if the pattern starts with &quot;.*&quot;.</p>

<p style="margin-top: 1em">&quot;with eval&quot; <br>
Set if the pattern contain eval-groups, such as &quot;(?{
code })&quot; and &quot;(??{ code })&quot;.</p>

<p style="margin-top: 1em">&quot;anchored(TYPE)&quot; <br>
If the pattern may match only at a handful of places, with
&quot;TYPE&quot; being &quot;BOL&quot;, &quot;MBOL&quot;, or
&quot;GPOS&quot;. See the table below.</p>

<p style="margin-top: 1em">If a substring is known to match
at end-of-line only, it may be followed by &quot;$&quot;, as
in &quot;floating &rsquo;k&rsquo;$&quot;.</p>

<p style="margin-top: 1em">The optimizer-specific
information is used to avoid entering (a slow) regex engine
on strings that will not definitely match. If the
&quot;isall&quot; flag is set, a call to the regex <br>
engine may be avoided even when the optimizer found an
appropriate place for the match.</p>

<p style="margin-top: 1em">Above the optimizer section is
the list of nodes of the compiled form of the regex. Each
line has format</p>

<p style="margin-top: 1em">&quot; &quot;id: TYPE
OPTIONAL-INFO (next-id)</p>

<p style="margin-top: 1em">Types of Nodes <br>
Here are the possible types, with short descriptions:</p>

<p style="margin-top: 1em"># TYPE arg-description
[num-args] [longjump-len] DESCRIPTION</p>

<p style="margin-top: 1em"># Exit points <br>
END no End of program. <br>
SUCCEED no Return from a subroutine, basically.</p>

<p style="margin-top: 1em"># Anchors:</p>

<p style="margin-top: 1em">BOL no Match &quot;&quot; at
beginning of line. <br>
MBOL no Same, assuming multiline. <br>
SBOL no Same, assuming singleline. <br>
EOS no Match &quot;&quot; at end of string. <br>
EOL no Match &quot;&quot; at end of line. <br>
MEOL no Same, assuming multiline. <br>
SEOL no Same, assuming singleline. <br>
BOUND no Match &quot;&quot; at any word boundary using
native charset <br>
semantics for non-utf8 <br>
BOUNDL no Match &quot;&quot; at any locale word boundary
<br>
BOUNDU no Match &quot;&quot; at any word boundary using
Unicode semantics <br>
BOUNDA no Match &quot;&quot; at any word boundary using
ASCII semantics <br>
NBOUND no Match &quot;&quot; at any word non-boundary using
native charset <br>
semantics for non-utf8 <br>
NBOUNDL no Match &quot;&quot; at any locale word
non-boundary <br>
NBOUNDU no Match &quot;&quot; at any word non-boundary using
Unicode semantics <br>
NBOUNDA no Match &quot;&quot; at any word non-boundary using
ASCII semantics <br>
GPOS no Matches where last m//g left off.</p>

<p style="margin-top: 1em"># [Special] alternatives:</p>

<p style="margin-top: 1em">REG_ANY no Match any one
character (except newline). <br>
SANY no Match any one character. <br>
CANY no Match any one byte. <br>
ANYOF sv Match character in (or not in) this class, single
char <br>
match only <br>
ANYOFV sv Match character in (or not in) this class, can
<br>
match-multiple chars <br>
ALNUM no Match any alphanumeric character using native
charset <br>
semantics for non-utf8 <br>
ALNUML no Match any alphanumeric char in locale <br>
ALNUMU no Match any alphanumeric char using Unicode
semantics <br>
ALNUMA no Match [A-Za-z_0-9] <br>
NALNUM no Match any non-alphanumeric character using native
charset <br>
semantics for non-utf8 <br>
NALNUML no Match any non-alphanumeric char in locale <br>
NALNUMU no Match any non-alphanumeric char using Unicode
semantics <br>
NALNUMA no Match [^A-Za-z_0-9] <br>
SPACE no Match any whitespace character using native charset
<br>
semantics for non-utf8 <br>
SPACEL no Match any whitespace char in locale <br>
SPACEU no Match any whitespace char using Unicode semantics
] <br>
SPACEA no Match [ 0f <br>
NSPACE no Match any non-whitespace character using native
charset <br>
semantics for non-utf8 <br>
NSPACEL no Match any non-whitespace char in locale <br>
NSPACEU no Match any non-whitespace char using Unicode
semantics ] <br>
NSPACEA no Match [^ 0f <br>
DIGIT no Match any numeric character using native charset
semantics <br>
for non-utf8 <br>
DIGITL no Match any numeric character in locale <br>
DIGITA no Match [0-9] <br>
NDIGIT no Match any non-numeric character using native
charset <br>
i semantics for non-utf8 <br>
NDIGITL no Match any non-numeric character in locale <br>
NDIGITA no Match [^0-9] <br>
CLUMP no Match any extended grapheme cluster sequence</p>

<p style="margin-top: 1em"># Alternation</p>

<p style="margin-top: 1em"># BRANCH The set of branches
constituting a single choice are hooked <br>
# together with their &quot;next&quot; pointers, since
precedence prevents <br>
# anything being concatenated to any individual branch. The
<br>
# &quot;next&quot; pointer of the last BRANCH in a choice
points to the <br>
# thing following the whole choice. This is also where the
<br>
# final &quot;next&quot; pointer of each individual branch
points; each <br>
# branch starts with the operand node of a BRANCH node. <br>
# <br>
BRANCH node Match this alternative, or the next...</p>

<p style="margin-top: 1em"># Back pointer</p>

<p style="margin-top: 1em"># BACK Normal &quot;next&quot;
pointers all implicitly point forward; BACK <br>
# exists to make loop structures possible. <br>
# not used <br>
BACK no Match &quot;&quot;, &quot;next&quot; ptr points
backward.</p>

<p style="margin-top: 1em"># Literals</p>

<p style="margin-top: 1em">EXACT str Match this string
(preceded by length). <br>
EXACTF str Match this string, folded, native charset
semantics for <br>
non-utf8 (prec. by length). <br>
EXACTFL str Match this string, folded in locale (w/len).
<br>
EXACTFU str Match this string, folded, Unicode semantics for
non-utf8 <br>
(prec. by length). <br>
EXACTFA str Match this string, folded, Unicode semantics for
non-utf8, <br>
but no ASCII-range character matches outside ASCII (prec.
<br>
by length),.</p>

<p style="margin-top: 1em"># Do nothing types</p>

<p style="margin-top: 1em">NOTHING no Match empty string.
<br>
# A variant of above which delimits a group, thus stops
optimizations <br>
TAIL no Match empty string. Can jump here from outside.</p>

<p style="margin-top: 1em"># Loops</p>

<p style="margin-top: 1em"># STAR,PLUS &rsquo;?&rsquo;, and
complex &rsquo;*&rsquo; and &rsquo;+&rsquo;, are implemented
as circular <br>
# BRANCH structures using BACK. Simple cases (one character
<br>
# per match) are implemented with STAR and PLUS for speed
<br>
# and to minimize recursive plunges. <br>
# <br>
STAR node Match this (simple) thing 0 or more times. <br>
PLUS node Match this (simple) thing 1 or more times.</p>

<p style="margin-top: 1em">CURLY sv 2 Match this simple
thing {n,m} times. <br>
CURLYN no 2 Capture next-after-this simple thing <br>
CURLYM no 2 Capture this medium-complex thing {n,m} times.
<br>
CURLYX sv 2 Match this complex thing {n,m} times.</p>

<p style="margin-top: 1em"># This terminator creates a loop
structure for CURLYX <br>
WHILEM no Do curly processing and see if rest matches.</p>

<p style="margin-top: 1em"># Buffer related</p>

<p style="margin-top: 1em"># OPEN,CLOSE,GROUPP ...are
numbered at compile time. <br>
OPEN num 1 Mark this point in input as start of #n. <br>
CLOSE num 1 Analogous to OPEN.</p>

<p style="margin-top: 1em">REF num 1 Match some already
matched string <br>
REFF num 1 Match already matched string, folded using native
charset <br>
semantics for non-utf8 <br>
REFFL num 1 Match already matched string, folded in loc.
<br>
REFFU num 1 Match already matched string, folded using
unicode <br>
semantics for non-utf8 <br>
REFFA num 1 Match already matched string, folded using
unicode <br>
semantics for non-utf8, no mixing ASCII, non-ASCII</p>

<p style="margin-top: 1em"># Named references. Code in
regcomp.c assumes that these all are after the <br>
# numbered references <br>
NREF no-sv 1 Match some already matched string <br>
NREFF no-sv 1 Match already matched string, folded using
native charset <br>
semantics for non-utf8 <br>
NREFFL no-sv 1 Match already matched string, folded in loc.
<br>
NREFFU num 1 Match already matched string, folded using
unicode <br>
semantics for non-utf8 <br>
NREFFA num 1 Match already matched string, folded using
unicode <br>
semantics for non-utf8, no mixing ASCII, non-ASCII</p>

<p style="margin-top: 1em">IFMATCH off 1 2 Succeeds if the
following matches. <br>
UNLESSM off 1 2 Fails if the following matches. <br>
SUSPEND off 1 1 &quot;Independent&quot; sub-RE. <br>
IFTHEN off 1 1 Switch, should be preceded by switcher. <br>
GROUPP num 1 Whether the group matched.</p>

<p style="margin-top: 1em"># Support for long RE</p>

<p style="margin-top: 1em">LONGJMP off 1 1 Jump far away.
<br>
BRANCHJ off 1 1 BRANCH with long offset.</p>

<p style="margin-top: 1em"># The heavy worker</p>

<p style="margin-top: 1em">EVAL evl 1 Execute some Perl
code.</p>

<p style="margin-top: 1em"># Modifiers</p>

<p style="margin-top: 1em">MINMOD no Next operator is not
greedy. <br>
LOGICAL no Next opcode should set the flag only.</p>

<p style="margin-top: 1em"># This is not used yet <br>
RENUM off 1 1 Group with independently numbered parens.</p>

<p style="margin-top: 1em"># Trie Related</p>

<p style="margin-top: 1em"># Behave the same as
A|LIST|OF|WORDS would. The &rsquo;..C&rsquo; variants have
<br>
# inline charclass data (ascii only), the &rsquo;C&rsquo;
store it in the structure. <br>
# NOTE: the relative order of the TRIE-like regops is
significant</p>

<p style="margin-top: 1em">TRIE trie 1 Match many
EXACT(F[ALU]?)? at once. flags==type <br>
TRIEC charclass Same as TRIE, but with embedded charclass
data</p>

<p style="margin-top: 1em"># For start classes, contains an
added fail table. <br>
AHOCORASICK trie 1 Aho Corasick stclass. flags==type <br>
AHOCORASICKC charclass Same as AHOCORASICK, but with
embedded charclass data</p>

<p style="margin-top: 1em"># Regex Subroutines <br>
GOSUB num/ofs 2L recurse to paren arg1 at (signed) ofs arg2
<br>
GOSTART no recurse to start of pattern</p>

<p style="margin-top: 1em"># Special conditionals <br>
NGROUPP no-sv 1 Whether the group matched. <br>
INSUBP num 1 Whether we are in a specific recurse. <br>
DEFINEP none 1 Never execute directly.</p>

<p style="margin-top: 1em"># Backtracking Verbs <br>
ENDLIKE none Used only for the type field of verbs <br>
OPFAIL none Same as (?!) <br>
ACCEPT parno 1 Accepts the current matched string.</p>

<p style="margin-top: 1em"># Verbs With Arguments <br>
VERB no-sv 1 Used only for the type field of verbs <br>
PRUNE no-sv 1 Pattern fails at this startpoint if
no-backtracking through this <br>
MARKPOINT no-sv 1 Push the current location for rollback by
cut. <br>
SKIP no-sv 1 On failure skip forward (to the mark) before
retrying <br>
COMMIT no-sv 1 Pattern fails outright if backtracking
through this <br>
CUTGROUP no-sv 1 On failure go to the next alternation in
the group</p>

<p style="margin-top: 1em"># Control what to keep in
$&amp;. <br>
KEEPS no $&amp; begins here.</p>

<p style="margin-top: 1em"># New charclass like patterns
<br>
LNBREAK none generic newline pattern <br>
VERTWS none vertical whitespace (Perl 6) <br>
NVERTWS none not vertical whitespace (Perl 6) <br>
HORIZWS none horizontal whitespace (Perl 6) <br>
NHORIZWS none not horizontal whitespace (Perl 6)</p>

<p style="margin-top: 1em">FOLDCHAR codepoint 1 codepoint
with tricky case folding properties.</p>

<p style="margin-top: 1em"># SPECIAL REGOPS</p>

<p style="margin-top: 1em"># This is not really a node, but
an optimized away piece of a &quot;long&quot; node. <br>
# To simplify debugging output, we mark it as if it were a
node <br>
OPTIMIZED off Placeholder for dump.</p>

<p style="margin-top: 1em"># Special opcode with the
property that no opcode in a compiled program <br>
# will ever be of this type. Thus it can be used as a flag
value that <br>
# no other opcode has been seen. END is used similarly, in
that an END <br>
# node cant be optimized. So END implies
&quot;unoptimizable&quot; and PSEUDO mean <br>
# &quot;not seen anything to optimize yet&quot;. <br>
PSEUDO off Pseudo opcode for internal use.</p>

<p style="margin-top: 1em">Following the optimizer
information is a dump of the offset/length table, here split
across several lines:</p>

<p style="margin-top: 1em">Offsets: [45] <br>
1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
<br>
0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1]
0[0] <br>
11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
<br>
0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]</p>

<p style="margin-top: 1em">The first line here indicates
that the offset/length table contains 45 entries. Each entry
is a pair of integers, denoted by
&quot;offset[length]&quot;. Entries are numbered starting
<br>
with 1, so entry #1 here is &quot;1[4]&quot; and entry #12
is &quot;5[1]&quot;. &quot;1[4]&quot; indicates that the
node labeled &quot;1:&quot; (the &quot;1: ANYOF[bc]&quot;)
begins at character position 1 in the pre-compiled <br>
form of the regex, and has a length of 4 characters.
&quot;5[1]&quot; in position 12 indicates that the node
labeled &quot;12:&quot; (the &quot;12: EXACT
&lt;d&gt;&quot;) begins at character position 5 in the pre-
<br>
compiled form of the regex, and has a length of 1 character.
&quot;12[1]&quot; in position 14 indicates that the node
labeled &quot;14:&quot; (the &quot;14: CURLYX[0]
{1,32767}&quot;) begins at character <br>
position 12 in the pre-compiled form of the regex, and has a
length of 1 character---that is, it corresponds to the
&quot;+&quot; symbol in the precompiled regex.</p>

<p style="margin-top: 1em">&quot;0[0]&quot; items indicate
that there is no corresponding node.</p>

<p style="margin-top: 1em">Run-time Output <br>
First of all, when doing a match, one may get no run-time
output even if debugging is enabled. This means that the
regex engine was never entered and that all of the job was
<br>
therefore done by the optimizer.</p>

<p style="margin-top: 1em">If the regex engine was entered,
the output may look like this:</p>

<p style="margin-top: 1em">Matching
&rsquo;[bc]d(ef*g)+h[ij]k$&rsquo; against
&rsquo;abcdefg__gh__&rsquo; <br>
Setting an EVAL scope, savestack=3 <br>
2 &lt;ab&gt; &lt;cdefg__gh_&gt; | 1: ANYOF <br>
3 &lt;abc&gt; &lt;defg__gh_&gt; | 11: EXACT &lt;d&gt; <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 13: CURLYX {1,32767} <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 26: WHILEM <br>
0 out of 1..32767 cc=effff31c <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 15: OPEN1 <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 17: EXACT &lt;e&gt; <br>
5 &lt;abcde&gt; &lt;fg__gh_&gt; | 19: STAR <br>
EXACT &lt;f&gt; can match 1 times out of 32767... <br>
Setting an EVAL scope, savestack=3 <br>
6 &lt;bcdef&gt; &lt;g__gh__&gt; | 22: EXACT &lt;g&gt; <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 24: CLOSE1 <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 26: WHILEM <br>
1 out of 1..32767 cc=effff31c <br>
Setting an EVAL scope, savestack=12 <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 15: OPEN1 <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 17: EXACT &lt;e&gt; <br>
restoring 1 to 4(4)..7 <br>
failed, try continuation... <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 27: NOTHING <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 28: EXACT &lt;h&gt; <br>
failed... <br>
failed...</p>

<p style="margin-top: 1em">The most significant information
in the output is about the particular node of the compiled
regex that is currently being tested against the target
string. The format of these <br>
lines is</p>

<p style="margin-top: 1em">&quot; &quot;STRING-OFFSET
&lt;PRE-STRING&gt; &lt;POST-STRING&gt; |ID: TYPE</p>

<p style="margin-top: 1em">The TYPE info is indented with
respect to the backtracking level. Other incidental
information appears interspersed within.</p>

<p style="margin-top: 1em">Debugging Perl Memory Usage <br>
Perl is a profligate wastrel when it comes to memory use.
There is a saying that to estimate memory usage of Perl,
assume a reasonable algorithm for memory allocation,
multiply <br>
that estimate by 10, and while you still may miss the mark,
at least you won&rsquo;t be quite so astonished. This is not
absolutely true, but may provide a good grasp of what
happens.</p>

<p style="margin-top: 1em">Assume that an integer cannot
take less than 20 bytes of memory, a float cannot take less
than 24 bytes, a string cannot take less than 32 bytes (all
these examples assume 32-bit <br>
architectures, the result are quite a bit worse on 64-bit
architectures). If a variable is accessed in two of three
different ways (which require an integer, a float, or a <br>
string), the memory footprint may increase yet another 20
bytes. A sloppy malloc(3) implementation can inflate these
numbers dramatically.</p>

<p style="margin-top: 1em">On the opposite end of the
scale, a declaration like</p>

<p style="margin-top: 1em">sub foo;</p>

<p style="margin-top: 1em">may take up to 500 bytes of
memory, depending on which release of Perl you&rsquo;re
running.</p>

<p style="margin-top: 1em">Anecdotal estimates of
source-to-compiled code bloat suggest an eightfold increase.
This means that the compiled form of reasonable (normally
commented, properly indented etc.) <br>
code will take about eight times more space in memory than
the code took on disk.</p>

<p style="margin-top: 1em">The -DL command-line switch is
obsolete since circa Perl 5.6.0 (it was available only if
Perl was built with &quot;-DDEBUGGING&quot;). The switch was
used to track Perl&rsquo;s memory <br>
allocations and possible memory leaks. These days the use of
malloc debugging tools like Purify or valgrind is suggested
instead. See also &quot;PERL_MEM_LOG&quot; in
perlhacktips.</p>

<p style="margin-top: 1em">One way to find out how much
memory is being used by Perl data structures is to install
the Devel::Size module from CPAN: it gives you the minimum
number of bytes required to <br>
store a particular data structure. Please be mindful of the
difference between the size() and total_size().</p>

<p style="margin-top: 1em">If Perl has been compiled using
Perl&rsquo;s malloc you can analyze Perl memory usage by
setting $ENV{PERL_DEBUG_MSTATS}.</p>

<p style="margin-top: 1em">Using $ENV{PERL_DEBUG_MSTATS}
<br>
If your perl is using Perl&rsquo;s malloc() and was compiled
with the necessary switches (this is the default), then it
will print memory usage statistics after compiling your code
<br>
when &quot;$ENV{PERL_DEBUG_MSTATS} &gt; 1&quot;, and before
termination of the program when
&quot;$ENV{PERL_DEBUG_MSTATS} &gt;= 1&quot;. The report
format is similar to the following example:</p>

<p style="margin-top: 1em">$ PERL_DEBUG_MSTATS=2 perl -e
&quot;require Carp&quot; <br>
Memory allocation statistics after compilation: (buckets
4(4)..8188(8192) <br>
14216 free: 130 117 28 7 9 0 2 2 1 0 0 <br>
437 61 36 0 5 <br>
60924 used: 125 137 161 55 7 8 6 16 2 0 1 <br>
74 109 304 84 20 <br>
Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail:
0+636+0+2048. <br>
Memory allocation statistics after execution: (buckets
4(4)..8188(8192) <br>
30888 free: 245 78 85 13 6 2 1 3 2 0 1 <br>
315 162 39 42 11 <br>
175816 used: 265 176 1112 111 26 22 11 27 2 1 1 <br>
196 178 1066 798 39 <br>
Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail:
0+2192+0+6144.</p>

<p style="margin-top: 1em">It is possible to ask for such a
statistic at arbitrary points in your execution using the
mstat() function out of the standard Devel::Peek module.</p>

<p style="margin-top: 1em">Here is some explanation of that
format:</p>

<p style="margin-top: 1em">&quot;buckets
SMALLEST(APPROX)..GREATEST(APPROX)&quot; <br>
Perl&rsquo;s malloc() uses bucketed allocations. Every
request is rounded up to the closest bucket size available,
and a bucket is taken from the pool of buckets of that
size.</p>

<p style="margin-top: 1em">The line above describes the
limits of buckets currently in use. Each bucket has two
sizes: memory footprint and the maximal size of user data
that can fit into this bucket. <br>
Suppose in the above example that the smallest bucket were
size 4. The biggest bucket would have usable size 8188, and
the memory footprint would be 8192.</p>

<p style="margin-top: 1em">In a Perl built for debugging,
some buckets may have negative usable size. This means that
these buckets cannot (and will not) be used. For larger
buckets, the memory <br>
footprint may be one page greater than a power of 2. If so,
the corresponding power of two is printed in the
&quot;APPROX&quot; field above.</p>

<p style="margin-top: 1em">Free/Used <br>
The 1 or 2 rows of numbers following that correspond to the
number of buckets of each size between &quot;SMALLEST&quot;
and &quot;GREATEST&quot;. In the first row, the sizes
(memory footprints) <br>
of buckets are powers of two--or possibly one page greater.
In the second row, if present, the memory footprints of the
buckets are between the memory footprints of two <br>
buckets &quot;above&quot;.</p>

<p style="margin-top: 1em">For example, suppose under the
previous example, the memory footprints were</p>

<p style="margin-top: 1em">free: 8 16 32 64 128 256 512
1024 2048 4096 8192 <br>
4 12 24 48 80</p>

<p style="margin-top: 1em">With a non-&quot;DEBUGGING&quot;
perl, the buckets starting from 128 have a 4-byte overhead,
and thus an 8192-long bucket may take up to 8188-byte
allocations.</p>

<p style="margin-top: 1em">&quot;Total sbrk():
SBRKed/SBRKs:CONTINUOUS&quot; <br>
The first two fields give the total amount of memory perl
sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The
third number is what perl thinks about continuity of <br>
returned chunks. So long as this number is positive,
malloc() will assume that it is probable that sbrk(2) will
provide continuous memory.</p>

<p style="margin-top: 1em">Memory allocated by external
libraries is not counted.</p>

<p style="margin-top: 1em">&quot;pad: 0&quot; <br>
The amount of sbrk(2)ed memory needed to keep buckets
aligned.</p>

<p style="margin-top: 1em">&quot;heads: 2192&quot; <br>
Although memory overhead of bigger buckets is kept inside
the bucket, for smaller buckets, it is kept in separate
areas. This field gives the total size of these areas.</p>

<p style="margin-top: 1em">&quot;chain: 0&quot; <br>
malloc() may want to subdivide a bigger bucket into smaller
buckets. If only a part of the deceased bucket is left
unsubdivided, the rest is kept as an element of a linked
<br>
list. This field gives the total size of these chunks.</p>

<p style="margin-top: 1em">&quot;tail: 6144&quot; <br>
To minimize the number of sbrk(2)s, malloc() asks for more
memory. This field gives the size of the yet unused part,
which is sbrk(2)ed, but never touched.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perldebug, perlguts, perlrun re, and Devel::DProf.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLDEBGUTS(1)</p>
<hr>
</body>
</html>
