<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:45:02 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>ZSHZLE(1) General Commands Manual ZSHZLE(1)</p>

<p style="margin-top: 1em">NAME <br>
zshzle - zsh command line editor</p>

<p style="margin-top: 1em">DESCRIPTION <br>
If the ZLE option is set (which it is by default in
interactive shells) and the shell input is attached to the
terminal, the user is able to edit command lines.</p>

<p style="margin-top: 1em">There are two display modes. The
first, multiline mode, is the default. It only works if the
TERM parameter is set to a valid terminal type that can move
the cursor up. The <br>
second, single line mode, is used if TERM is invalid or
incapable of moving the cursor up, or if the SINGLE_LINE_ZLE
option is set. This mode is similar to ksh, and uses no <br>
termcap sequences. If TERM is &quot;emacs&quot;, the ZLE
option will be unset by default.</p>

<p style="margin-top: 1em">The parameters BAUD, COLUMNS,
and LINES are also used by the line editor. See Parameters
Used By The Shell in zshparam(1).</p>

<p style="margin-top: 1em">The parameter zle_highlight is
also used by the line editor; see Character Highlighting
below. Highlighting of special characters and the region
between the cursor and the mark <br>
(as set with set-mark-command in Emacs mode) is enabled by
default; consult this reference for more information.
Irascible conservatives will wish to know that all
highlighting <br>
may be disabled by the following setting:</p>

<p style="margin-top: 1em">zle_highlight=(none)</p>

<p style="margin-top: 1em">KEYMAPS <br>
A keymap in ZLE contains a set of bindings between key
sequences and ZLE commands. The empty key sequence cannot be
bound.</p>

<p style="margin-top: 1em">There can be any number of
keymaps at any time, and each keymap has one or more names.
If all of a keymap&rsquo;s names are deleted, it disappears.
bindkey can be used to manipulate <br>
keymap names.</p>

<p style="margin-top: 1em">Initially, there are six
keymaps:</p>

<p style="margin-top: 1em">emacs EMACS emulation <br>
viins vi emulation - insert mode <br>
vicmd vi emulation - command mode <br>
isearch <br>
incremental search mode <br>
command <br>
read a command name <br>
.safe fallback keymap</p>

<p style="margin-top: 1em">The &lsquo;.safe&rsquo; keymap
is special. It can never be altered, and the name can never
be removed. However, it can be linked to other names, which
can be removed. In the future other <br>
special keymaps may be added; users should avoid using names
beginning with &lsquo;.&rsquo; for their own keymaps.</p>

<p style="margin-top: 1em">In addition to these names,
either &lsquo;emacs&rsquo; or &lsquo;viins&rsquo; is also
linked to the name &lsquo;main&rsquo;. If one of the VISUAL
or EDITOR environment variables contain the string
&lsquo;vi&rsquo; when the <br>
shell starts up then it will be &lsquo;viins&rsquo;,
otherwise it will be &lsquo;emacs&rsquo;. bindkey&rsquo;s -e
and -v options provide a convenient way to override this
default choice.</p>

<p style="margin-top: 1em">When the editor starts up, it
will select the &lsquo;main&rsquo; keymap. If that keymap
doesn&rsquo;t exist, it will use &lsquo;.safe&rsquo;
instead.</p>

<p style="margin-top: 1em">In the &lsquo;.safe&rsquo;
keymap, each single key is bound to self-insert, except for
^J (line feed) and ^M (return) which are bound to
accept-line. This is deliberately not pleasant to <br>
use; if you are using it, it means you deleted the main
keymap, and you should put it back.</p>

<p style="margin-top: 1em">Reading Commands <br>
When ZLE is reading a command from the terminal, it may read
a sequence that is bound to some command and is also a
prefix of a longer bound string. In this case ZLE will wait
a <br>
certain time to see if more characters are typed, and if not
(or they don&rsquo;t match any longer string) it will
execute the binding. This timeout is defined by the
KEYTIMEOUT <br>
parameter; its default is 0.4 sec. There is no timeout if
the prefix string is not itself bound to a command.</p>

<p style="margin-top: 1em">The key timeout is also applied
when ZLE is reading the bytes from a multibyte character
string when it is in the appropriate mode. (This requires
that the shell was compiled <br>
with multibyte mode enabled; typically also the locale has
characters with the UTF-8 encoding, although any multibyte
encoding known to the operating system is supported.) If
<br>
the second or a subsequent byte is not read within the
timeout period, the shell acts as if ? were typed and resets
the input state.</p>

<p style="margin-top: 1em">As well as ZLE commands, key
sequences can be bound to other strings, by using
&lsquo;bindkey -s&rsquo;. When such a sequence is read, the
replacement string is pushed back as input, and <br>
the command reading process starts again using these fake
keystrokes. This input can itself invoke further replacement
strings, but in order to detect loops the process will be
<br>
stopped if there are twenty such replacements without a real
command being read.</p>

<p style="margin-top: 1em">A key sequence typed by the user
can be turned into a command name for use in user-defined
widgets with the read-command widget, described below.</p>

<p style="margin-top: 1em">ZLE BUILTINS <br>
The ZLE module contains three related builtin commands. The
bindkey command manipulates keymaps and key bindings; the
vared command invokes ZLE on the value of a shell parameter;
<br>
and the zle command manipulates editing widgets and allows
command line access to ZLE commands from within shell
functions.</p>

<p style="margin-top: 1em">bindkey [ options ] -l [ -L ] [
keymap ... ] <br>
bindkey [ options ] -d <br>
bindkey [ options ] -D keymap ... <br>
bindkey [ options ] -A old-keymap new-keymap <br>
bindkey [ options ] -N new-keymap [ old-keymap ] <br>
bindkey [ options ] -m <br>
bindkey [ options ] -r in-string ... <br>
bindkey [ options ] -s in-string out-string ... <br>
bindkey [ options ] in-string command ... <br>
bindkey [ options ] [ in-string ] <br>
bindkey&rsquo;s options can be divided into three
categories: keymap selection for the current command,
operation selection, and others. The keymap selection
options are:</p>

<p style="margin-top: 1em">-e Selects keymap
&lsquo;emacs&rsquo; for any operations by the current
command, and also links &lsquo;emacs&rsquo; to
&lsquo;main&rsquo; so that it is selected by default the
next time the editor <br>
starts.</p>

<p style="margin-top: 1em">-v Selects keymap
&lsquo;viins&rsquo; for any operations by the current
command, and also links &lsquo;viins&rsquo; to
&lsquo;main&rsquo; so that it is selected by default the
next time the editor <br>
starts.</p>

<p style="margin-top: 1em">-a Selects keymap
&lsquo;vicmd&rsquo; for any operations by the current
command.</p>

<p style="margin-top: 1em">-M keymap <br>
The keymap specifies a keymap name that is selected for any
operations by the current command.</p>

<p style="margin-top: 1em">If a keymap selection is
required and none of the options above are used, the
&lsquo;main&rsquo; keymap is used. Some operations do not
permit a keymap to be selected, namely:</p>

<p style="margin-top: 1em">-l List all existing keymap
names; if any arguments are given, list just those
keymaps.</p>

<p style="margin-top: 1em">If the -L option is also used,
list in the form of bindkey commands to create or link the
keymaps. &lsquo;bindkey -lL main&rsquo; shows which keymap
is linked to &lsquo;main&rsquo;, if <br>
any, and hence if the standard emacs or vi emulation is in
effect. This option does not show the .safe keymap because
it cannot be created in that fashion; how&acirc; <br>
ever, neither is &lsquo;bindkey -lL .safe&rsquo; reported as
an error, it simply outputs nothing.</p>

<p style="margin-top: 1em">-d Delete all existing keymaps
and reset to the default state.</p>

<p style="margin-top: 1em">-D keymap ... <br>
Delete the named keymaps.</p>

<p style="margin-top: 1em">-A old-keymap new-keymap <br>
Make the new-keymap name an alias for old-keymap, so that
both names refer to the same keymap. The names have equal
standing; if either is deleted, the other <br>
remains. If there is already a keymap with the new-keymap
name, it is deleted.</p>

<p style="margin-top: 1em">-N new-keymap [ old-keymap ]
<br>
Create a new keymap, named new-keymap. If a keymap already
has that name, it is deleted. If an old-keymap name is
given, the new keymap is initialized to be a <br>
duplicate of it, otherwise the new keymap will be empty.</p>

<p style="margin-top: 1em">To use a newly created keymap,
it should be linked to main. Hence the sequence of commands
to create and use a new keymap &lsquo;mymap&rsquo;
initialized from the emacs keymap (which <br>
remains unchanged) is:</p>

<p style="margin-top: 1em">bindkey -N mymap emacs <br>
bindkey -A mymap main</p>

<p style="margin-top: 1em">Note that while &lsquo;bindkey
-A newmap main&rsquo; will work when newmap is emacs or
viins, it will not work for vicmd, as switching from vi
insert to command mode becomes impossi&acirc; <br>
ble.</p>

<p style="margin-top: 1em">The following operations act on
the &lsquo;main&rsquo; keymap if no keymap selection option
was given:</p>

<p style="margin-top: 1em">-m Add the built-in set of
meta-key bindings to the selected keymap. Only keys that are
unbound or bound to self-insert are affected.</p>

<p style="margin-top: 1em">-r in-string ... <br>
Unbind the specified in-strings in the selected keymap. This
is exactly equivalent to binding the strings to
undefined-key.</p>

<p style="margin-top: 1em">When -R is also used, interpret
the in-strings as ranges.</p>

<p style="margin-top: 1em">When -p is also used, the
in-strings specify prefixes. Any binding that has the given
in-string as a prefix, not including the binding for the
in-string itself, if <br>
any, will be removed. For example,</p>

<p style="margin-top: 1em">bindkey -rpM viins
&rsquo;^[&rsquo;</p>

<p style="margin-top: 1em">will remove all bindings in the
vi-insert keymap beginning with an escape character
(probably cursor keys), but leave the binding for the escape
character itself <br>
(probably vi-cmd-mode). This is incompatible with the option
-R.</p>

<p style="margin-top: 1em">-s in-string out-string ... <br>
Bind each in-string to each out-string. When in-string is
typed, out-string will be pushed back and treated as input
to the line editor. When -R is also used, <br>
interpret the in-strings as ranges.</p>

<p style="margin-top: 1em">in-string command ... <br>
Bind each in-string to each command. When -R is used,
interpret the in-strings as ranges.</p>

<p style="margin-top: 1em">[ in-string ] <br>
List key bindings. If an in-string is specified, the binding
of that string in the selected keymap is displayed.
Otherwise, all key bindings in the selected <br>
keymap are displayed. (As a special case, if the -e or -v
option is used alone, the keymap is not displayed - the
implicit linking of keymaps is the only thing <br>
that happens.)</p>

<p style="margin-top: 1em">When the option -p is used, the
in-string must be present. The listing shows all bindings
which have the given key sequence as a prefix, not including
any bindings <br>
for the key sequence itself.</p>

<p style="margin-top: 1em">When the -L option is used, the
list is in the form of bindkey commands to create the key
bindings.</p>

<p style="margin-top: 1em">When the -R option is used as
noted above, a valid range consists of two characters, with
an optional &lsquo;-&rsquo; between them. All characters
between the two specified, inclusive, are <br>
bound as specified.</p>

<p style="margin-top: 1em">For either in-string or
out-string, the following escape sequences are
recognised:</p>

<p style="margin-top: 1em">bell character <br>
backspace <br>
\, &nbsp;escape <br>
form feed <br>
linefeed (newline) <br>
carriage return <br>
horizontal tab <br>
vertical tab <br>
character code in octal <br>
character code in hexadecimal <br>
X character with meta bit set <br>
control character <br>
^X control character</p>

<p style="margin-top: 1em">In all other cases,
&lsquo;&acute; escapes the following character. Delete is
written as &lsquo;^?&rsquo;. Note that &lsquo;?&rsquo; and
&lsquo;^&rsquo; are not the same, and that (unlike emacs),
the bindings &lsquo;X&rsquo; <br>
and &lsquo;\X&rsquo; are entirely distinct, although they
are initialized to the same bindings by &lsquo;bindkey
-m&rsquo;.</p>

<p style="margin-top: 1em">vared [ -Aache ] [ -p prompt ] [
-r rprompt ] <br>
[ -M main-keymap ] [ -m vicmd-keymap ] <br>
[ -t tty ] name <br>
The value of the parameter name is loaded into the edit
buffer, and the line editor is invoked. When the editor
exits, name is set to the string value returned by the <br>
editor. When the -c flag is given, the parameter is created
if it doesn&rsquo;t already exist. The -a flag may be given
with -c to create an array parameter, or the -A flag to <br>
create an associative array. If the type of an existing
parameter does not match the type to be created, the
parameter is unset and recreated.</p>

<p style="margin-top: 1em">If an array or array slice is
being edited, separator characters as defined in $IFS will
be shown quoted with a backslash, as will backslashes
themselves. Conversely, <br>
when the edited text is split into an array, a backslash
quotes an immediately following separator character or
backslash; no other special handling of backslashes, or any
<br>
handling of quotes, is performed.</p>

<p style="margin-top: 1em">Individual elements of existing
array or associative array parameters may be edited by using
subscript syntax on name. New elements are created
automatically, even with&acirc; <br>
out -c.</p>

<p style="margin-top: 1em">If the -p flag is given, the
following string will be taken as the prompt to display at
the left. If the -r flag is given, the following string
gives the prompt to dis&acirc; <br>
play at the right. If the -h flag is specified, the history
can be accessed from ZLE. If the -e flag is given, typing ^D
(Control-D) on an empty line causes vared to exit <br>
immediately with a non-zero return value.</p>

<p style="margin-top: 1em">The -M option gives a keymap to
link to the main keymap during editing, and the -m option
gives a keymap to link to the vicmd keymap during editing.
For vi-style editing, <br>
this allows a pair of keymaps to override viins and vicmd.
For emacs-style editing, only -M is normally needed but the
-m option may still be used. On exit, the previous <br>
keymaps will be restored.</p>

<p style="margin-top: 1em">If &lsquo;-t tty&rsquo; is
given, tty is the name of a terminal device to be used
instead of the default /dev/tty. If tty does not refer to a
terminal an error is reported.</p>

<p style="margin-top: 1em">zle <br>
zle -l [ -L | -a ] [ string ... ] <br>
zle -D widget ... <br>
zle -A old-widget new-widget <br>
zle -N widget [ function ] <br>
zle -C widget completion-widget function <br>
zle -R [ -c ] [ display-string ] [ string ... ] <br>
zle -M string <br>
zle -U string <br>
zle -K keymap <br>
zle -F [ -L ] [ fd [ handler ] ] <br>
zle -I <br>
zle -T [ tc function | -r tc | -L ] <br>
zle widget [ -n num ] [ -Nw ] [ -K keymap ] args ... <br>
The zle builtin performs a number of different actions
concerning ZLE.</p>

<p style="margin-top: 1em">With no options and no
arguments, only the return status will be set. It is zero if
ZLE is currently active and widgets could be invoked using
this builtin command and <br>
non-zero otherwise. Note that even if non-zero status is
returned, zle may still be active as part of the completion
system; this does not allow direct calls to ZLE wid&acirc;
<br>
gets.</p>

<p style="margin-top: 1em">Otherwise, which operation it
performs depends on its options:</p>

<p style="margin-top: 1em">-l [ -L | -a ] <br>
List all existing user-defined widgets. If the -L option is
used, list in the form of zle commands to create the
widgets.</p>

<p style="margin-top: 1em">When combined with the -a
option, all widget names are listed, including the builtin
ones. In this case the -L option is ignored.</p>

<p style="margin-top: 1em">If at least one string is given,
and -a is present or -L is not used, nothing will be
printed. The return status will be zero if all strings are
names of existing <br>
widgets and non-zero if at least one string is not a name of
a defined widget. If -a is also present, all widget names
are used for the comparison including <br>
builtin widgets, else only user-defined widgets are
used.</p>

<p style="margin-top: 1em">If at least one string is
present and the -L option is used, user-defined widgets
matching any string are listed in the form of zle commands
to create the widgets.</p>

<p style="margin-top: 1em">-D widget ... <br>
Delete the named widgets.</p>

<p style="margin-top: 1em">-A old-widget new-widget <br>
Make the new-widget name an alias for old-widget, so that
both names refer to the same widget. The names have equal
standing; if either is deleted, the other <br>
remains. If there is already a widget with the new-widget
name, it is deleted.</p>

<p style="margin-top: 1em">-N widget [ function ] <br>
Create a user-defined widget. If there is already a widget
with the specified name, it is overwritten. When the new
widget is invoked from within the editor, the <br>
specified shell function is called. If no function name is
specified, it defaults to the same name as the widget. For
further information, see the section Widgets <br>
in zshzle(1).</p>

<p style="margin-top: 1em">-C widget completion-widget
function <br>
Create a user-defined completion widget named widget. The
completion widget will behave like the built-in
completion-widget whose name is given as
completion-wid&acirc; <br>
get. To generate the completions, the shell function
function will be called. For further information, see
zshcompwid(1).</p>

<p style="margin-top: 1em">-R [ -c ] [ display-string ] [
string ... ] <br>
Redisplay the command line; this is to be called from within
a user-defined widget to allow changes to become visible. If
a display-string is given and not empty, <br>
this is shown in the status line (immediately below the line
being edited).</p>

<p style="margin-top: 1em">If the optional strings are
given they are listed below the prompt in the same way as
completion lists are printed. If no strings are given but
the -c option is <br>
used such a list is cleared.</p>

<p style="margin-top: 1em">Note that this option is only
useful for widgets that do not exit immediately after using
it because the strings displayed will be erased immediately
after return <br>
from the widget.</p>

<p style="margin-top: 1em">This command can safely be
called outside user defined widgets; if zle is active, the
display will be refreshed, while if zle is not active, the
command has no <br>
effect. In this case there will usually be no other
arguments.</p>

<p style="margin-top: 1em">The status is zero if zle was
active, else one.</p>

<p style="margin-top: 1em">-M string <br>
As with the -R option, the string will be displayed below
the command line; unlike the -R option, the string will not
be put into the status line but will instead <br>
be printed normally below the prompt. This means that the
string will still be displayed after the widget returns
(until it is overwritten by subsequent commands).</p>

<p style="margin-top: 1em">-U string <br>
This pushes the characters in the string onto the input
stack of ZLE. After the widget currently executed finishes
ZLE will behave as if the characters in the <br>
string were typed by the user.</p>

<p style="margin-top: 1em">As ZLE uses a stack, if this
option is used repeatedly the last string pushed onto the
stack will be processed first. However, the characters in
each string will <br>
be processed in the order in which they appear in the
string.</p>

<p style="margin-top: 1em">-K keymap <br>
Selects the keymap named keymap. An error message will be
displayed if there is no such keymap.</p>

<p style="margin-top: 1em">This keymap selection affects
the interpretation of following keystrokes within this
invocation of ZLE. Any following invocation (e.g., the next
command line) will <br>
start as usual with the &lsquo;main&rsquo; keymap
selected.</p>

<p style="margin-top: 1em">-F [ -L ] [ fd [ handler ] ]
<br>
Only available if your system supports one of the
&lsquo;poll&rsquo; or &lsquo;select&rsquo; system calls;
most modern systems do.</p>

<p style="margin-top: 1em">Installs handler (the name of a
shell function) to handle input from file descriptor fd.
When zle is attempting to read data, it will examine both
the terminal and <br>
the list of handled fd&rsquo;s. If data becomes available on
a handled fd, zle will call handler with the fd which is
ready for reading as the only argument. If the <br>
handler produces output to the terminal, it should call
&lsquo;zle -I&rsquo; before doing so (see below). The
handler should not attempt to read from the terminal. Note
that <br>
zle makes no attempt to check whether this fd is actually
readable when installing the handler. The user must make
their own arrangements for handling the file <br>
descriptor when zle is not active.</p>

<p style="margin-top: 1em">Any number of handlers for any
number of readable file descriptors may be installed.
Installing a handler for an fd which is already handled
causes the existing <br>
handler to be replaced.</p>

<p style="margin-top: 1em">If no handler is given, but an
fd is present, any handler for that fd is removed. If there
is none, an error message is printed and status 1 is
returned.</p>

<p style="margin-top: 1em">If no arguments are given, or
the -L option is supplied, a list of handlers is printed in
a form which can be stored for later execution.</p>

<p style="margin-top: 1em">An fd (but not a handler) may
optionally be given with the -L option; in this case, the
function will list the handler if any, else silently return
status 1.</p>

<p style="margin-top: 1em">Note that this feature should be
used with care. Activity on one of the fd&rsquo;s which is
not properly handled can cause the terminal to become
unusable.</p>

<p style="margin-top: 1em">Here is a simple example of
using this feature. A connection to a remote TCP port is
created using the ztcp command; see the description of the
zsh/net/tcp module <br>
in zshmodules(1). Then a handler is installed which simply
prints out any data which arrives on this connection. Note
that &lsquo;select&rsquo; will indicate that the file <br>
descriptor needs handling if the remote side has closed the
connection; we handle that by testing for a failed read.
<br>
if ztcp pwspc 2811; then <br>
tcpfd=$REPLY <br>
handler() { <br>
zle -I <br>
local line <br>
if ! read -r line &lt;&amp;$1; then <br>
# select marks this fd if we reach EOF, <br>
# so handle this specially. <br>
print &quot;[Read on fd $1 failed, removing.]&quot;
&gt;&amp;2 <br>
zle -F $1 <br>
return 1 <br>
fi <br>
print -r - $line <br>
} <br>
zle -F $tcpfd handler <br>
fi</p>

<p style="margin-top: 1em">-I Unusually, this option is
most useful outside ordinary widget functions, though it may
be used within if normal output to the terminal is required.
It invalidates <br>
the current zle display in preparation for output; typically
this will be from a trap function. It has no effect if zle
is not active. When a trap exits, the <br>
shell checks to see if the display needs restoring, hence
the following will print output in such a way as not to
disturb the line being edited:</p>

<p style="margin-top: 1em">TRAPUSR1() { <br>
# Invalidate zle display <br>
[[ -o zle ]] &amp;&amp; zle -I <br>
# Show output <br>
print Hello <br>
}</p>

<p style="margin-top: 1em">In general, the trap function
may need to test whether zle is active before using this
method (as shown in the example), since the zsh/zle module
may not even be <br>
loaded; if it is not, the command can be skipped.</p>

<p style="margin-top: 1em">It is possible to call
&lsquo;zle -I&rsquo; several times before control is
returned to the editor; the display will only be invalidated
the first time to minimise disruption.</p>

<p style="margin-top: 1em">Note that there are normally
better ways of manipulating the display from within zle
widgets; see, for example, &lsquo;zle -R&rsquo; above.</p>

<p style="margin-top: 1em">The returned status is zero if
zle was invalidated, even though this may have been by a
previous call to &lsquo;zle -I&rsquo; or by a system
notification. To test if a zle <br>
widget may be called at this point, execute zle with no
arguments and examine the return status.</p>

<p style="margin-top: 1em">-T This is used to add, list or
remove internal transformations on the processing performed
by the line editor. It is typically used only for debugging
or testing and <br>
is therefore of little interest to the general user.</p>

<p style="margin-top: 1em">&lsquo;zle -T transformation
func&rsquo; specifies that the given transformation (see
below) is effected by shell function func.</p>

<p style="margin-top: 1em">&lsquo;zle -Tr
transformation&rsquo; removes the given transformation if it
was present (it is not an error if none was).</p>

<p style="margin-top: 1em">&lsquo;zle -TL&rsquo; can be
used to list all transformations currently in operation.</p>

<p style="margin-top: 1em">Currently the only
transformation is tc. This is used instead of outputting
termcap codes to the terminal. When the transformation is in
operation the shell func&acirc; <br>
tion is passed the termcap code that would be output as its
first argument; if the operation required a numeric
argument, that is passed as a second argument. The <br>
function should set the shell variable REPLY to the
transformed termcap code. Typically this is used to produce
some simply formatted version of the code and <br>
optional argument for debugging or testing. Note that this
transformation is not applied to other non-printing
characters such as carriage returns and newlines.</p>

<p style="margin-top: 1em">widget [ -n num ] [ -Nw ] [ -K
keymap ] args ... <br>
Invoke the specified widget. This can only be done when ZLE
is active; normally this will be within a user-defined
widget.</p>

<p style="margin-top: 1em">With the options -n and -N, the
current numerical argument will be saved and then restored
after the call to widget; &lsquo;-n num&rsquo; sets the
numerical argument temporar&acirc; <br>
ily to num, while &lsquo;-N&rsquo; sets it to the default,
i.e. as if there were none.</p>

<p style="margin-top: 1em">With the option -K, keymap will
be used as the current keymap during the execution of the
widget. The previous keymap will be restored when the widget
exits.</p>

<p style="margin-top: 1em">Normally, calling a widget in
this way does not set the special parameter WIDGET and
related parameters, so that the environment appears as if
the top-level widget <br>
called by the user were still active. With the option -w,
WIDGET and related parameters are set to reflect the widget
being executed by the zle call.</p>

<p style="margin-top: 1em">Any further arguments will be
passed to the widget; note that as standard argument
handling is performed, any general argument list should be
preceded by --. If it <br>
is a shell function, these are passed down as positional
parameters; for builtin widgets it is up to the widget in
question what it does with them. Currently argu&acirc; <br>
ments are only handled by the incremental-search commands,
the history-search-forward and -backward and the
corresponding functions prefixed by vi-, and by
univer&acirc; <br>
sal-argument. No error is flagged if the command does not
use the arguments, or only uses some of them.</p>

<p style="margin-top: 1em">The return status reflects the
success or failure of the operation carried out by the
widget, or if it is a user-defined widget the return status
of the shell func&acirc; <br>
tion.</p>

<p style="margin-top: 1em">A non-zero return status causes
the shell to beep when the widget exits, unless the BEEP
options was unset or the widget was called via the zle
command. Thus if a <br>
user defined widget requires an immediate beep, it should
call the beep widget directly.</p>

<p style="margin-top: 1em">WIDGETS <br>
All actions in the editor are performed by
&lsquo;widgets&rsquo;. A widget&rsquo;s job is simply to
perform some small action. The ZLE commands that key
sequences in keymaps are bound to are in <br>
fact widgets. Widgets can be user-defined or built in.</p>

<p style="margin-top: 1em">The standard widgets built into
ZLE are listed in Standard Widgets below. Other built-in
widgets can be defined by other modules (see zshmodules(1)).
Each built-in widget has <br>
two names: its normal canonical name, and the same name
preceded by a &lsquo;.&rsquo;. The &lsquo;.&rsquo; name is
special: it can&rsquo;t be rebound to a different widget.
This makes the widget available <br>
even when its usual name has been redefined.</p>

<p style="margin-top: 1em">User-defined widgets are defined
using &lsquo;zle -N&rsquo;, and implemented as shell
functions. When the widget is executed, the corresponding
shell function is executed, and can perform <br>
editing (or other) actions. It is recommended that
user-defined widgets should not have names starting with
&lsquo;.&rsquo;.</p>

<p style="margin-top: 1em">USER-DEFINED WIDGETS <br>
User-defined widgets, being implemented as shell functions,
can execute any normal shell command. They can also run
other widgets (whether built-in or user-defined) using the
<br>
zle builtin command. The standard input of the function is
closed to prevent external commands from unintentionally
blocking ZLE by reading from the terminal, but read -k or
<br>
read -q can be used to read characters. Finally, they can
examine and edit the ZLE buffer being edited by reading and
setting the special parameters described below.</p>

<p style="margin-top: 1em">These special parameters are
always available in widget functions, but are not in any way
special outside ZLE. If they have some normal value outside
ZLE, that value is tempo&acirc; <br>
rarily inaccessible, but will return when the widget
function exits. These special parameters in fact have local
scope, like parameters created in a function using
local.</p>

<p style="margin-top: 1em">Inside completion widgets and
traps called while ZLE is active, these parameters are
available read-only.</p>

<p style="margin-top: 1em">BUFFER (scalar) <br>
The entire contents of the edit buffer. If it is written to,
the cursor remains at the same offset, unless that would put
it outside the buffer.</p>

<p style="margin-top: 1em">BUFFERLINES (integer) <br>
The number of screen lines needed for the edit buffer
currently displayed on screen (i.e. without any changes to
the preceding parameters done after the last redisplay);
<br>
read-only.</p>

<p style="margin-top: 1em">CONTEXT (scalar) <br>
The context in which zle was called to read a line;
read-only. One of the values: <br>
start The start of a command line (at prompt PS1).</p>

<p style="margin-top: 1em">cont A continuation to a command
line (at prompt PS2).</p>

<p style="margin-top: 1em">select In a select loop.</p>

<p style="margin-top: 1em">vared Editing a variable in
vared.</p>

<p style="margin-top: 1em">CURSOR (integer) <br>
The offset of the cursor, within the edit buffer. This is in
the range 0 to $#BUFFER, and is by definition equal to
$#LBUFFER. Attempts to move the cursor outside the <br>
buffer will result in the cursor being moved to the
appropriate end of the buffer.</p>

<p style="margin-top: 1em">CUTBUFFER (scalar) <br>
The last item cut using one of the &lsquo;kill-&rsquo;
commands; the string which the next yank would insert in the
line. Later entries in the kill ring are in the array
killring. <br>
Note that the command &lsquo;zle copy-region-as-kill
string&rsquo; can be used to set the text of the cut buffer
from a shell function and cycle the kill ring in the same
way as <br>
interactively killing text.</p>

<p style="margin-top: 1em">HISTNO (integer) <br>
The current history number. Setting this has the same effect
as moving up or down in the history to the corresponding
history line. An attempt to set it is ignored if <br>
the line is not stored in the history. Note this is not the
same as the parameter HISTCMD, which always gives the number
of the history line being added to the main <br>
shell&rsquo;s history. HISTNO refers to the line being
retrieved within zle.</p>

<p style="margin-top: 1em">KEYMAP (scalar) <br>
The name of the currently selected keymap; read-only.</p>

<p style="margin-top: 1em">KEYS (scalar) <br>
The keys typed to invoke this widget, as a literal string;
read-only.</p>

<p style="margin-top: 1em">killring (array) <br>
The array of previously killed items, with the most recently
killed first. This gives the items that would be retrieved
by a yank-pop in the same order. Note, however, <br>
that the most recently killed item is in $CUTBUFFER;
$killring shows the array of previous entries.</p>

<p style="margin-top: 1em">The default size for the kill
ring is eight, however the length may be changed by normal
array operations. Any empty string in the kill ring is
ignored by the yank-pop <br>
command, hence the size of the array effectively sets the
maximum length of the kill ring, while the number of
non-zero strings gives the current length, both as seen by
<br>
the user at the command line.</p>

<p style="margin-top: 1em">LASTABORTEDSEARCH (scalar) <br>
The last search string used by an interactive search that
was aborted by the user (status 3 returned by the search
widget).</p>

<p style="margin-top: 1em">LASTSEARCH (scalar) <br>
The last search string used by an interactive search;
read-only. This is set even if the search failed (status 0,
1 or 2 returned by the search widget), but not if it was
<br>
aborted by the user.</p>

<p style="margin-top: 1em">LASTWIDGET (scalar) <br>
The name of the last widget that was executed;
read-only.</p>

<p style="margin-top: 1em">LBUFFER (scalar) <br>
The part of the buffer that lies to the left of the cursor
position. If it is assigned to, only that part of the buffer
is replaced, and the cursor remains between the <br>
new $LBUFFER and the old $RBUFFER.</p>

<p style="margin-top: 1em">MARK (integer) <br>
Like CURSOR, but for the mark.</p>

<p style="margin-top: 1em">NUMERIC (integer) <br>
The numeric argument. If no numeric argument was given, this
parameter is unset. When this is set inside a widget
function, builtin widgets called with the zle builtin <br>
command will use the value assigned. If it is unset inside a
widget function, builtin widgets called behave as if no
numeric argument was given.</p>

<p style="margin-top: 1em">PENDING (integer) <br>
The number of bytes pending for input, i.e. the number of
bytes which have already been typed and can immediately be
read. On systems where the shell is not able to get <br>
this information, this parameter will always have a value of
zero. Read-only.</p>

<p style="margin-top: 1em">PREBUFFER (scalar) <br>
In a multi-line input at the secondary prompt, this
read-only parameter contains the contents of the lines
before the one the cursor is currently in.</p>

<p style="margin-top: 1em">PREDISPLAY (scalar) <br>
Text to be displayed before the start of the editable text
buffer. This does not have to be a complete line; to display
a complete line, a newline must be appended <br>
explicitly. The text is reset on each new invocation (but
not recursive invocation) of zle.</p>

<p style="margin-top: 1em">POSTDISPLAY (scalar) <br>
Text to be displayed after the end of the editable text
buffer. This does not have to be a complete line; to display
a complete line, a newline must be prepended explic&acirc;
<br>
itly. The text is reset on each new invocation (but not
recursive invocation) of zle.</p>

<p style="margin-top: 1em">RBUFFER (scalar) <br>
The part of the buffer that lies to the right of the cursor
position. If it is assigned to, only that part of the buffer
is replaced, and the cursor remains between the <br>
old $LBUFFER and the new $RBUFFER.</p>

<p style="margin-top: 1em">REGION_ACTIVE (integer) <br>
Indicates if the region is currently active. It can be
assigned 0 or 1 to deactivate and activate the region
respectively; see Character Highlighting below.</p>

<p style="margin-top: 1em">region_highlight (array) <br>
Each element of this array may be set to a string that
describes highlighting for an arbitrary region of the
command line that will take effect the next time the command
<br>
line is redisplayed. Highlighting of the non-editable parts
of the command line in PREDISPLAY and POSTDISPLAY are
possible, but note that the P flag is needed for
charac&acirc; <br>
ter indexing to include PREDISPLAY.</p>

<p style="margin-top: 1em">Each string consists of the
following parts:</p>

<p style="margin-top: 1em">Optionally, a &lsquo;P&rsquo; to
signify that the start and end offset that <br>
follow include any string set by the PREDISPLAY special
parameter; this is needed if the predisplay string itself is
to be highlighted. Whitespace may follow the <br>
&lsquo;P&rsquo;. <br>
A start offset in the same units as CURSOR, terminated by
<br>
whitespace. <br>
An end offset in the same units as CURSOR, terminated by
<br>
whitespace. <br>
A highlight specification in the same format as <br>
used for contexts in the parameter zle_highlight, see
Character Highlighting below; for example, standout or
fg=red,bold.</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">region_highlight=(&quot;P0 20
bold&quot;)</p>

<p style="margin-top: 1em">specifies that the first twenty
characters of the text including any predisplay string
should be highlighted in bold.</p>

<p style="margin-top: 1em">Note that the effect of
region_highlight is not saved and disappears as soon as the
line is accepted.</p>

<p style="margin-top: 1em">UNDO_CHANGE_NO (integer) <br>
A number representing the state of the undo history. The
only use of this is passing as an argument to the undo
widget in order to undo back to the recorded point. <br>
Read-only.</p>

<p style="margin-top: 1em">WIDGET (scalar) <br>
The name of the widget currently being executed;
read-only.</p>

<p style="margin-top: 1em">WIDGETFUNC (scalar) <br>
The name of the shell function that implements a widget
defined with either zle -N or zle -C. In the former case,
this is the second argument to the zle -N command that <br>
defined the widget, or the first argument if there was no
second argument. In the latter case this is the third
argument to the zle -C command that defined the widget. <br>
Read-only.</p>

<p style="margin-top: 1em">WIDGETSTYLE (scalar) <br>
Describes the implementation behind the completion widget
currently being executed; the second argument that followed
zle -C when the widget was defined. This is the name <br>
of a builtin completion widget. For widgets defined with zle
-N this is set to the empty string. Read-only.</p>

<p style="margin-top: 1em">ZLE_STATE (scalar) <br>
Contains a set of space-separated words that describe the
current zle state.</p>

<p style="margin-top: 1em">Currently, the states shown are
the insert mode as set by the overwrite-mode or vi-replace
widgets and whether history commands will visit imported
entries as controlled <br>
by the set-local-history widget. The string contains
&lsquo;insert&rsquo; if characters to be inserted on the
command line move existing characters to the right or
&lsquo;overwrite&rsquo; if <br>
characters to be inserted overwrite existing characters. It
contains &lsquo;localhistory&rsquo; if only local history
commands will be visited or &lsquo;globalhistory&rsquo; if
imported history <br>
commands will also be visited.</p>

<p style="margin-top: 1em">The substrings are sorted in
alphabetical order so that if you want to test for two
specific substrings in a future-proof way, you can do match
by doing:</p>

<p style="margin-top: 1em">if [[ $ZLE_STATE ==
*insert*globalhistory* ]]; then ...; fi</p>

<p style="margin-top: 1em">Special Widgets <br>
There are a few user-defined widgets which are special to
the shell. If they do not exist, no special action is taken.
The environment provided is identical to that for any <br>
other editing widget.</p>

<p style="margin-top: 1em">zle-isearch-exit <br>
Executed at the end of incremental search at the point where
the isearch prompt is removed from the display. See
zle-isearch-update for an example.</p>

<p style="margin-top: 1em">zle-isearch-update <br>
Executed within incremental search when the display is about
to be redrawn. Additional output below the incremental
search prompt can be generated by using &lsquo;zle -M&rsquo;
<br>
within the widget. For example,</p>

<p style="margin-top: 1em">zle-isearch-update() { zle -M
&quot;Line $HISTNO&quot;; } <br>
zle -N zle-isearch-update</p>

<p style="margin-top: 1em">Note the line output by
&lsquo;zle -M&rsquo; is not deleted on exit from incremental
search. This can be done from a zle-isearch-exit widget:</p>

<p style="margin-top: 1em">zle-isearch-exit() { zle -M
&quot;&quot;; } <br>
zle -N zle-isearch-exit</p>

<p style="margin-top: 1em">zle-line-init <br>
Executed every time the line editor is started to read a new
line of input. The following example puts the line editor
into vi command mode when it starts up.</p>

<p style="margin-top: 1em">zle-line-init() { zle -K vicmd;
} <br>
zle -N zle-line-init</p>

<p style="margin-top: 1em">(The command inside the function
sets the keymap directly; it is equivalent to zle
vi-cmd-mode.)</p>

<p style="margin-top: 1em">zle-line-finish <br>
This is similar to zle-line-init but is executed every time
the line editor has finished reading a line of input.</p>

<p style="margin-top: 1em">zle-history-line-set <br>
Executed when the history line changes.</p>

<p style="margin-top: 1em">zle-keymap-select <br>
Executed every time the keymap changes, i.e. the special
parameter KEYMAP is set to a different value, while the line
editor is active. Initialising the keymap when the <br>
line editor starts does not cause the widget to be
called.</p>

<p style="margin-top: 1em">The value $KEYMAP within the
function reflects the new keymap. The old keymap is passed
as the sole argument.</p>

<p style="margin-top: 1em">This can be used for detecting
switches between the vi command (vicmd) and insert (usually
main) keymaps.</p>

<p style="margin-top: 1em">STANDARD WIDGETS <br>
The following is a list of all the standard widgets, and
their default bindings in emacs mode, vi command mode and vi
insert mode (the &lsquo;emacs&rsquo;, &lsquo;vicmd&rsquo;
and &lsquo;viins&rsquo; keymaps, <br>
respectively).</p>

<p style="margin-top: 1em">Note that cursor keys are bound
to movement keys in all three keymaps; the shell assumes
that the cursor keys send the key sequences reported by the
terminal-handling library <br>
(termcap or terminfo). The key sequences shown in the list
are those based on the VT100, common on many modern
terminals, but in fact these are not necessarily bound. In
the <br>
case of the viins keymap, the initial escape character of
the sequences serves also to return to the vicmd keymap:
whether this happens is determined by the KEYTIMEOUT
parameter, <br>
see zshparam(1).</p>

<p style="margin-top: 1em">Movement <br>
vi-backward-blank-word (unbound) (B) (unbound) <br>
Move backward one word, where a word is defined as a series
of non-blank characters.</p>

<p style="margin-top: 1em">backward-char (^B ESC-[D)
(unbound) (unbound) <br>
Move backward one character.</p>

<p style="margin-top: 1em">vi-backward-char (unbound) (^H h
^?) (ESC-[D) <br>
Move backward one character, without changing lines.</p>

<p style="margin-top: 1em">backward-word (ESC-B ESC-b)
(unbound) (unbound) <br>
Move to the beginning of the previous word.</p>

<p style="margin-top: 1em">emacs-backward-word <br>
Move to the beginning of the previous word.</p>

<p style="margin-top: 1em">vi-backward-word (unbound) (b)
(unbound) <br>
Move to the beginning of the previous word, vi-style.</p>

<p style="margin-top: 1em">beginning-of-line (^A) (unbound)
(unbound) <br>
Move to the beginning of the line. If already at the
beginning of the line, move to the beginning of the previous
line, if any.</p>

<p style="margin-top: 1em">vi-beginning-of-line <br>
Move to the beginning of the line, without changing
lines.</p>

<p style="margin-top: 1em">end-of-line (^E) (unbound)
(unbound) <br>
Move to the end of the line. If already at the end of the
line, move to the end of the next line, if any.</p>

<p style="margin-top: 1em">vi-end-of-line (unbound) ($)
(unbound) <br>
Move to the end of the line. If an argument is given to this
command, the cursor will be moved to the end of the line
(argument - 1) lines down.</p>

<p style="margin-top: 1em">vi-forward-blank-word (unbound)
(W) (unbound) <br>
Move forward one word, where a word is defined as a series
of non-blank characters.</p>

<p style="margin-top: 1em">vi-forward-blank-word-end
(unbound) (E) (unbound) <br>
Move to the end of the current word, or, if at the end of
the current word, to the end of the next word, where a word
is defined as a series of non-blank characters.</p>

<p style="margin-top: 1em">forward-char (^F ESC-[C)
(unbound) (unbound) <br>
Move forward one character.</p>

<p style="margin-top: 1em">vi-forward-char (unbound) (space
l) (ESC-[C) <br>
Move forward one character.</p>

<p style="margin-top: 1em">vi-find-next-char (^X^F) (f)
(unbound) <br>
Read a character from the keyboard, and move to the next
occurrence of it in the line.</p>

<p style="margin-top: 1em">vi-find-next-char-skip (unbound)
(t) (unbound) <br>
Read a character from the keyboard, and move to the position
just before the next occurrence of it in the line.</p>

<p style="margin-top: 1em">vi-find-prev-char (unbound) (F)
(unbound) <br>
Read a character from the keyboard, and move to the previous
occurrence of it in the line.</p>

<p style="margin-top: 1em">vi-find-prev-char-skip (unbound)
(T) (unbound) <br>
Read a character from the keyboard, and move to the position
just after the previous occurrence of it in the line.</p>

<p style="margin-top: 1em">vi-first-non-blank (unbound) (^)
(unbound) <br>
Move to the first non-blank character in the line.</p>

<p style="margin-top: 1em">vi-forward-word (unbound) (w)
(unbound) <br>
Move forward one word, vi-style.</p>

<p style="margin-top: 1em">forward-word (ESC-F ESC-f)
(unbound) (unbound) <br>
Move to the beginning of the next word. The editor&rsquo;s
idea of a word is specified with the WORDCHARS
parameter.</p>

<p style="margin-top: 1em">emacs-forward-word <br>
Move to the end of the next word.</p>

<p style="margin-top: 1em">vi-forward-word-end (unbound)
(e) (unbound) <br>
Move to the end of the next word.</p>

<p style="margin-top: 1em">vi-goto-column (ESC-|) (|)
(unbound) <br>
Move to the column specified by the numeric argument.</p>

<p style="margin-top: 1em">vi-goto-mark (unbound) (&lsquo;)
(unbound) <br>
Move to the specified mark.</p>

<p style="margin-top: 1em">vi-goto-mark-line (unbound)
(&rsquo;) (unbound) <br>
Move to beginning of the line containing the specified
mark.</p>

<p style="margin-top: 1em">vi-repeat-find (unbound) (;)
(unbound) <br>
Repeat the last vi-find command.</p>

<p style="margin-top: 1em">vi-rev-repeat-find (unbound) (,)
(unbound) <br>
Repeat the last vi-find command in the opposite
direction.</p>

<p style="margin-top: 1em">History Control <br>
beginning-of-buffer-or-history (ESC-&lt;) (unbound)
(unbound) <br>
Move to the beginning of the buffer, or if already there,
move to the first event in the history list.</p>

<p style="margin-top: 1em">beginning-of-line-hist <br>
Move to the beginning of the line. If already at the
beginning of the buffer, move to the previous history
line.</p>

<p style="margin-top: 1em">beginning-of-history <br>
Move to the first event in the history list.</p>

<p style="margin-top: 1em">down-line-or-history (^N ESC-[B)
(j) (ESC-[B) <br>
Move down a line in the buffer, or if already at the bottom
line, move to the next event in the history list.</p>

<p style="margin-top: 1em">vi-down-line-or-history
(unbound) (+) (unbound) <br>
Move down a line in the buffer, or if already at the bottom
line, move to the next event in the history list. Then move
to the first non-blank character on the line.</p>

<p style="margin-top: 1em">down-line-or-search <br>
Move down a line in the buffer, or if already at the bottom
line, search forward in the history for a line beginning
with the first word in the buffer.</p>

<p style="margin-top: 1em">If called from a function by the
zle command with arguments, the first argument is taken as
the string for which to search, rather than the first word
in the buffer.</p>

<p style="margin-top: 1em">down-history (unbound) (^N)
(unbound) <br>
Move to the next event in the history list.</p>


<p style="margin-top: 1em">history-beginning-search-backward
<br>
Search backward in the history for a line beginning with the
current line up to the cursor. This leaves the cursor in its
original position.</p>

<p style="margin-top: 1em">end-of-buffer-or-history
(ESC-&gt;) (unbound) (unbound) <br>
Move to the end of the buffer, or if already there, move to
the last event in the history list.</p>

<p style="margin-top: 1em">end-of-line-hist <br>
Move to the end of the line. If already at the end of the
buffer, move to the next history line.</p>

<p style="margin-top: 1em">end-of-history <br>
Move to the last event in the history list.</p>

<p style="margin-top: 1em">vi-fetch-history (unbound) (G)
(unbound) <br>
Fetch the history line specified by the numeric argument.
This defaults to the current history line (i.e. the one that
isn&rsquo;t history yet).</p>


<p style="margin-top: 1em">history-incremental-search-backward
(^R ^Xr) (unbound) (unbound) <br>
Search backward incrementally for a specified string. The
search is case-insensitive if the search string does not
have uppercase letters and no numeric argument was <br>
given. The string may begin with &lsquo;^&rsquo; to anchor
the search to the beginning of the line. When called from a
user-defined function returns the following statuses: 0, if
<br>
the search succeeded; 1, if the search failed; 2, if the
search term was a bad pattern; 3, if the search was aborted
by the send-break command.</p>

<p style="margin-top: 1em">A restricted set of editing
functions is available in the mini-buffer. Keys are looked
up in the special isearch keymap, and if not found there in
the main keymap (note <br>
that by default the isearch keymap is empty). An interrupt
signal, as defined by the stty setting, will stop the search
and go back to the original line. An undefined <br>
key will have the same effect. Note that the following
always perform the same task within incremental searches and
cannot be replaced by user defined widgets, nor can <br>
the set of functions be extended. The supported functions
are:</p>

<p style="margin-top: 1em">accept-and-hold <br>
accept-and-infer-next-history <br>
accept-line <br>
accept-line-and-down-history <br>
Perform the usual function after exiting incremental search.
The command line displayed is executed.</p>

<p style="margin-top: 1em">backward-delete-char <br>
vi-backward-delete-char <br>
Back up one place in the search history. If the search has
been repeated this does not immediately erase a character in
the minibuffer.</p>

<p style="margin-top: 1em">accept-search <br>
Exit incremental search, retaining the command line but
performing no further action. Note that this function is not
bound by default and has no effect outside <br>
incremental search.</p>

<p style="margin-top: 1em">backward-delete-word <br>
backward-kill-word <br>
vi-backward-kill-word <br>
Back up one character in the minibuffer; if multiple
searches have been performed since the character was
inserted the search history is rewound to the point just
<br>
before the character was entered. Hence this has the effect
of repeating backward-delete-char.</p>

<p style="margin-top: 1em">clear-screen <br>
Clear the screen, remaining in incremental search mode.</p>


<p style="margin-top: 1em">history-incremental-search-backward
<br>
Find the next occurrence of the contents of the
mini-buffer.</p>


<p style="margin-top: 1em">history-incremental-search-forward
<br>
Invert the sense of the search.</p>

<p style="margin-top: 1em">magic-space <br>
Inserts a non-magical space.</p>

<p style="margin-top: 1em">quoted-insert <br>
vi-quoted-insert <br>
Quote the character to insert into the minibuffer.</p>

<p style="margin-top: 1em">redisplay <br>
Redisplay the command line, remaining in incremental search
mode.</p>

<p style="margin-top: 1em">vi-cmd-mode <br>
Toggle between the &lsquo;main&rsquo; and
&lsquo;vicmd&rsquo; keymaps; the &lsquo;main&rsquo; keymap
(insert mode) will be selected initially.</p>

<p style="margin-top: 1em">vi-repeat-search <br>
vi-rev-repeat-search <br>
Repeat the search. The direction of the search is indicated
in the mini-buffer.</p>

<p style="margin-top: 1em">Any character that is not bound
to one of the above functions, or self-insert or
self-insert-unmeta, will cause the mode to be exited. The
character is then looked up and <br>
executed in the keymap in effect at that point.</p>

<p style="margin-top: 1em">When called from a widget
function by the zle command, the incremental search commands
can take a string argument. This will be treated as a string
of keys, as for argu&acirc; <br>
ments to the bindkey command, and used as initial input for
the command. Any characters in the string which are unused
by the incremental search will be silently ignored. <br>
For example,</p>

<p style="margin-top: 1em">zle
history-incremental-search-backward forceps</p>

<p style="margin-top: 1em">will search backwards for
forceps, leaving the minibuffer containing the string
&lsquo;forceps&rsquo;.</p>


<p style="margin-top: 1em">history-incremental-search-forward
(^S ^Xs) (unbound) (unbound) <br>
Search forward incrementally for a specified string. The
search is case-insensitive if the search string does not
have uppercase letters and no numeric argument was <br>
given. The string may begin with &lsquo;^&rsquo; to anchor
the search to the beginning of the line. The functions
available in the mini-buffer are the same as for
history-incremen&acirc; <br>
tal-search-backward.</p>


<p style="margin-top: 1em">history-incremental-pattern-search-backward
<br>
history-incremental-pattern-search-forward <br>
These widgets behave similarly to the corresponding widgets
with no -pattern, but the search string typed by the user is
treated as a pattern, respecting the current set&acirc; <br>
tings of the various options affecting pattern matching. See
FILENAME GENERATION in zshexpn(1) for a description of
patterns. If no numeric argument was given lowercase <br>
letters in the search string may match uppercase letters in
the history. The string may begin with &lsquo;^&rsquo; to
anchor the search to the beginning of the line.</p>

<p style="margin-top: 1em">The prompt changes to indicate
an invalid pattern; this may simply indicate the pattern is
not yet complete.</p>

<p style="margin-top: 1em">Note that only non-overlapping
matches are reported, so an expression with wildcards may
return fewer matches on a line than are visible by
inspection.</p>

<p style="margin-top: 1em">history-search-backward (ESC-P
ESC-p) (unbound) (unbound) <br>
Search backward in the history for a line beginning with the
first word in the buffer.</p>

<p style="margin-top: 1em">If called from a function by the
zle command with arguments, the first argument is taken as
the string for which to search, rather than the first word
in the buffer.</p>

<p style="margin-top: 1em">vi-history-search-backward
(unbound) (/) (unbound) <br>
Search backward in the history for a specified string. The
string may begin with &lsquo;^&rsquo; to anchor the search
to the beginning of the line.</p>

<p style="margin-top: 1em">A restricted set of editing
functions is available in the mini-buffer. An interrupt
signal, as defined by the stty setting, will stop the
search. The functions avail&acirc; <br>
able in the mini-buffer are: accept-line,
backward-delete-char, vi-backward-delete-char,
backward-kill-word, vi-backward-kill-word, clear-screen,
redisplay, quoted-insert <br>
and vi-quoted-insert.</p>

<p style="margin-top: 1em">vi-cmd-mode is treated the same
as accept-line, and magic-space is treated as a space. Any
other character that is not bound to self-insert or
self-insert-unmeta will <br>
beep and be ignored. If the function is called from vi
command mode, the bindings of the current insert mode will
be used.</p>

<p style="margin-top: 1em">If called from a function by the
zle command with arguments, the first argument is taken as
the string for which to search, rather than the first word
in the buffer.</p>

<p style="margin-top: 1em">history-search-forward (ESC-N
ESC-n) (unbound) (unbound) <br>
Search forward in the history for a line beginning with the
first word in the buffer.</p>

<p style="margin-top: 1em">If called from a function by the
zle command with arguments, the first argument is taken as
the string for which to search, rather than the first word
in the buffer.</p>

<p style="margin-top: 1em">vi-history-search-forward
(unbound) (?) (unbound) <br>
Search forward in the history for a specified string. The
string may begin with &lsquo;^&rsquo; to anchor the search
to the beginning of the line. The functions available in the
<br>
mini-buffer are the same as for vi-history-search-backward.
Argument handling is also the same as for that command.</p>

<p style="margin-top: 1em">infer-next-history (^X^N)
(unbound) (unbound) <br>
Search in the history list for a line matching the current
one and fetch the event following it.</p>

<p style="margin-top: 1em">insert-last-word (ESC-_ ESC-.)
(unbound) (unbound) <br>
Insert the last word from the previous history event at the
cursor position. If a positive numeric argument is given,
insert that word from the end of the previous his&acirc;
<br>
tory event. If the argument is zero or negative insert that
word from the left (zero inserts the previous command word).
Repeating this command replaces the word just <br>
inserted with the last word from the history event prior to
the one just used; numeric arguments can be used in the same
way to pick a word from that event.</p>

<p style="margin-top: 1em">When called from a shell
function invoked from a user-defined widget, the command can
take one to three arguments. The first argument specifies a
history offset which <br>
applies to successive calls to this widget: if it is -1, the
default behaviour is used, while if it is 1, successive
calls will move forwards through the history. The <br>
value 0 can be used to indicate that the history line
examined by the previous execution of the command will be
reexamined. Note that negative numbers should be preceded
<br>
by a &lsquo;--&rsquo; argument to avoid confusing them with
options.</p>

<p style="margin-top: 1em">If two arguments are given, the
second specifies the word on the command line in normal
array index notation (as a more natural alternative to the
prefix argument). Hence <br>
1 is the first word, and -1 (the default) is the last
word.</p>

<p style="margin-top: 1em">If a third argument is given,
its value is ignored, but it is used to signify that the
history offset is relative to the current history line,
rather than the one remem&acirc; <br>
bered after the previous invocations of
insert-last-word.</p>

<p style="margin-top: 1em">For example, the default
behaviour of the command corresponds to</p>

<p style="margin-top: 1em">zle insert-last-word -- -1
-1</p>

<p style="margin-top: 1em">while the command</p>

<p style="margin-top: 1em">zle insert-last-word -- -1 1
-</p>

<p style="margin-top: 1em">always copies the first word of
the line in the history immediately before the line being
edited. This has the side effect that later invocations of
the widget will be <br>
relative to that line.</p>

<p style="margin-top: 1em">vi-repeat-search (unbound) (n)
(unbound) <br>
Repeat the last vi history search.</p>

<p style="margin-top: 1em">vi-rev-repeat-search (unbound)
(N) (unbound) <br>
Repeat the last vi history search, but in reverse.</p>

<p style="margin-top: 1em">up-line-or-history (^P ESC-[A)
(k) (ESC-[A) <br>
Move up a line in the buffer, or if already at the top line,
move to the previous event in the history list.</p>

<p style="margin-top: 1em">vi-up-line-or-history (unbound)
(-) (unbound) <br>
Move up a line in the buffer, or if already at the top line,
move to the previous event in the history list. Then move to
the first non-blank character on the line.</p>

<p style="margin-top: 1em">up-line-or-search <br>
Move up a line in the buffer, or if already at the top line,
search backward in the history for a line beginning with the
first word in the buffer.</p>

<p style="margin-top: 1em">If called from a function by the
zle command with arguments, the first argument is taken as
the string for which to search, rather than the first word
in the buffer.</p>

<p style="margin-top: 1em">up-history (unbound) (^P)
(unbound) <br>
Move to the previous event in the history list.</p>


<p style="margin-top: 1em">history-beginning-search-forward
<br>
Search forward in the history for a line beginning with the
current line up to the cursor. This leaves the cursor in its
original position.</p>

<p style="margin-top: 1em">set-local-history <br>
By default, history movement commands visit the imported
lines as well as the local lines. This widget lets you
toggle this on and off, or set it with the numeric
argu&acirc; <br>
ment. Zero for both local and imported lines and nonzero for
only local lines.</p>

<p style="margin-top: 1em">Modifying Text <br>
vi-add-eol (unbound) (A) (unbound) <br>
Move to the end of the line and enter insert mode.</p>

<p style="margin-top: 1em">vi-add-next (unbound) (a)
(unbound) <br>
Enter insert mode after the current cursor position, without
changing lines.</p>

<p style="margin-top: 1em">backward-delete-char (^H ^?)
(unbound) (unbound) <br>
Delete the character behind the cursor.</p>

<p style="margin-top: 1em">vi-backward-delete-char
(unbound) (X) (^H) <br>
Delete the character behind the cursor, without changing
lines. If in insert mode, this won&rsquo;t delete past the
point where insert mode was last entered.</p>

<p style="margin-top: 1em">backward-delete-word <br>
Delete the word behind the cursor.</p>

<p style="margin-top: 1em">backward-kill-line <br>
Kill from the beginning of the line to the cursor
position.</p>

<p style="margin-top: 1em">backward-kill-word (^W ESC-^H
ESC-^?) (unbound) (unbound) <br>
Kill the word behind the cursor.</p>

<p style="margin-top: 1em">vi-backward-kill-word (unbound)
(unbound) (^W) <br>
Kill the word behind the cursor, without going past the
point where insert mode was last entered.</p>

<p style="margin-top: 1em">capitalize-word (ESC-C ESC-c)
(unbound) (unbound) <br>
Capitalize the current word and move past it.</p>

<p style="margin-top: 1em">vi-change (unbound) (c)
(unbound) <br>
Read a movement command from the keyboard, and kill from the
cursor position to the endpoint of the movement. Then enter
insert mode. If the command is vi-change, change <br>
the current line.</p>

<p style="margin-top: 1em">vi-change-eol (unbound) (C)
(unbound) <br>
Kill to the end of the line and enter insert mode.</p>

<p style="margin-top: 1em">vi-change-whole-line (unbound)
(S) (unbound) <br>
Kill the current line and enter insert mode.</p>

<p style="margin-top: 1em">copy-region-as-kill (ESC-W
ESC-w) (unbound) (unbound) <br>
Copy the area from the cursor to the mark to the kill
buffer.</p>

<p style="margin-top: 1em">If called from a ZLE widget
function in the form &lsquo;zle copy-region-as-kill
string&rsquo; then string will be taken as the text to copy
to the kill buffer. The cursor, the mark <br>
and the text on the command line are not used in this
case.</p>

<p style="margin-top: 1em">copy-prev-word (ESC-^_)
(unbound) (unbound) <br>
Duplicate the word to the left of the cursor.</p>

<p style="margin-top: 1em">copy-prev-shell-word <br>
Like copy-prev-word, but the word is found by using shell
parsing, whereas copy-prev-word looks for blanks. This makes
a difference when the word is quoted and contains <br>
spaces.</p>

<p style="margin-top: 1em">vi-delete (unbound) (d)
(unbound) <br>
Read a movement command from the keyboard, and kill from the
cursor position to the endpoint of the movement. If the
command is vi-delete, kill the current line.</p>

<p style="margin-top: 1em">delete-char <br>
Delete the character under the cursor.</p>

<p style="margin-top: 1em">vi-delete-char (unbound) (x)
(unbound) <br>
Delete the character under the cursor, without going past
the end of the line.</p>

<p style="margin-top: 1em">delete-word <br>
Delete the current word.</p>

<p style="margin-top: 1em">down-case-word (ESC-L ESC-l)
(unbound) (unbound) <br>
Convert the current word to all lowercase and move past
it.</p>

<p style="margin-top: 1em">kill-word (ESC-D ESC-d)
(unbound) (unbound) <br>
Kill the current word.</p>

<p style="margin-top: 1em">gosmacs-transpose-chars <br>
Exchange the two characters behind the cursor.</p>

<p style="margin-top: 1em">vi-indent (unbound) (&gt;)
(unbound) <br>
Indent a number of lines.</p>

<p style="margin-top: 1em">vi-insert (unbound) (i)
(unbound) <br>
Enter insert mode.</p>

<p style="margin-top: 1em">vi-insert-bol (unbound) (I)
(unbound) <br>
Move to the first non-blank character on the line and enter
insert mode.</p>

<p style="margin-top: 1em">vi-join (^X^J) (J) (unbound)
<br>
Join the current line with the next one.</p>

<p style="margin-top: 1em">kill-line (^K) (unbound)
(unbound) <br>
Kill from the cursor to the end of the line. If already on
the end of the line, kill the newline character.</p>

<p style="margin-top: 1em">vi-kill-line (unbound) (unbound)
(^U) <br>
Kill from the cursor back to wherever insert mode was last
entered.</p>

<p style="margin-top: 1em">vi-kill-eol (unbound) (D)
(unbound) <br>
Kill from the cursor to the end of the line.</p>

<p style="margin-top: 1em">kill-region <br>
Kill from the cursor to the mark.</p>

<p style="margin-top: 1em">kill-buffer (^X^K) (unbound)
(unbound) <br>
Kill the entire buffer.</p>

<p style="margin-top: 1em">kill-whole-line (^U) (unbound)
(unbound) <br>
Kill the current line.</p>

<p style="margin-top: 1em">vi-match-bracket (^X^B) (%)
(unbound) <br>
Move to the bracket character (one of {}, () or []) that
matches the one under the cursor. If the cursor is not on a
bracket character, move forward without going past <br>
the end of the line to find one, and then go to the matching
bracket.</p>

<p style="margin-top: 1em">vi-open-line-above (unbound) (O)
(unbound) <br>
Open a line above the cursor and enter insert mode.</p>

<p style="margin-top: 1em">vi-open-line-below (unbound) (o)
(unbound) <br>
Open a line below the cursor and enter insert mode.</p>

<p style="margin-top: 1em">vi-oper-swap-case <br>
Read a movement command from the keyboard, and swap the case
of all characters from the cursor position to the endpoint
of the movement. If the movement command is <br>
vi-oper-swap-case, swap the case of all characters on the
current line.</p>

<p style="margin-top: 1em">overwrite-mode (^X^O) (unbound)
(unbound) <br>
Toggle between overwrite mode and insert mode.</p>

<p style="margin-top: 1em">vi-put-before (unbound) (P)
(unbound) <br>
Insert the contents of the kill buffer before the cursor. If
the kill buffer contains a sequence of lines (as opposed to
characters), paste it above the current line.</p>

<p style="margin-top: 1em">vi-put-after (unbound) (p)
(unbound) <br>
Insert the contents of the kill buffer after the cursor. If
the kill buffer contains a sequence of lines (as opposed to
characters), paste it below the current line.</p>

<p style="margin-top: 1em">quoted-insert (^V) (unbound)
(unbound) <br>
Insert the next character typed into the buffer literally.
An interrupt character will not be inserted.</p>

<p style="margin-top: 1em">vi-quoted-insert (unbound)
(unbound) (^Q ^V) <br>
Display a &lsquo;^&rsquo; at the cursor position, and insert
the next character typed into the buffer literally. An
interrupt character will not be inserted.</p>

<p style="margin-top: 1em">quote-line (ESC-&rsquo;)
(unbound) (unbound) <br>
Quote the current line; that is, put a &lsquo;&rsquo;&rsquo;
character at the beginning and the end, and convert all
&lsquo;&rsquo;&rsquo; characters to
&lsquo;&rsquo;&acute;&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">quote-region (ESC-&quot;)
(unbound) (unbound) <br>
Quote the region from the cursor to the mark.</p>

<p style="margin-top: 1em">vi-replace (unbound) (R)
(unbound) <br>
Enter overwrite mode.</p>

<p style="margin-top: 1em">vi-repeat-change (unbound) (.)
(unbound) <br>
Repeat the last vi mode text modification. If a count was
used with the modification, it is remembered. If a count is
given to this command, it overrides the remembered <br>
count, and is remembered for future uses of this command.
The cut buffer specification is similarly remembered.</p>

<p style="margin-top: 1em">vi-replace-chars (unbound) (r)
(unbound) <br>
Replace the character under the cursor with a character read
from the keyboard.</p>

<p style="margin-top: 1em">self-insert (printable
characters) (unbound) (printable characters and some control
characters) <br>
Insert a character into the buffer at the cursor
position.</p>

<p style="margin-top: 1em">self-insert-unmeta (ESC-^I
ESC-^J ESC-^M) (unbound) (unbound) <br>
Insert a character into the buffer after stripping the meta
bit and converting ^M to ^J.</p>

<p style="margin-top: 1em">vi-substitute (unbound) (s)
(unbound) <br>
Substitute the next character(s).</p>

<p style="margin-top: 1em">vi-swap-case (unbound) (~)
(unbound) <br>
Swap the case of the character under the cursor and move
past it.</p>

<p style="margin-top: 1em">transpose-chars (^T) (unbound)
(unbound) <br>
Exchange the two characters to the left of the cursor if at
end of line, else exchange the character under the cursor
with the character to the left.</p>

<p style="margin-top: 1em">transpose-words (ESC-T ESC-t)
(unbound) (unbound) <br>
Exchange the current word with the one before it.</p>

<p style="margin-top: 1em">vi-unindent (unbound) (&lt;)
(unbound) <br>
Unindent a number of lines.</p>

<p style="margin-top: 1em">up-case-word (ESC-U ESC-u)
(unbound) (unbound) <br>
Convert the current word to all caps and move past it.</p>

<p style="margin-top: 1em">yank (^Y) (unbound) (unbound)
<br>
Insert the contents of the kill buffer at the cursor
position.</p>

<p style="margin-top: 1em">yank-pop (ESC-y) (unbound)
(unbound) <br>
Remove the text just yanked, rotate the kill-ring (the
history of previously killed text) and yank the new top.
Only works following yank or yank-pop.</p>

<p style="margin-top: 1em">vi-yank (unbound) (y) (unbound)
<br>
Read a movement command from the keyboard, and copy the
region from the cursor position to the endpoint of the
movement into the kill buffer. If the command is vi-yank,
<br>
copy the current line.</p>

<p style="margin-top: 1em">vi-yank-whole-line (unbound) (Y)
(unbound) <br>
Copy the current line into the kill buffer.</p>

<p style="margin-top: 1em">vi-yank-eol <br>
Copy the region from the cursor position to the end of the
line into the kill buffer. Arguably, this is what Y should
do in vi, but it isn&rsquo;t what it actually does.</p>

<p style="margin-top: 1em">Arguments <br>
digit-argument (ESC-0..ESC-9) (1-9) (unbound) <br>
Start a new numeric argument, or add to the current one. See
also vi-digit-or-beginning-of-line. This only works if bound
to a key sequence ending in a decimal digit.</p>

<p style="margin-top: 1em">Inside a widget function, a call
to this function treats the last key of the key sequence
which called the widget as the digit.</p>

<p style="margin-top: 1em">neg-argument (ESC--) (unbound)
(unbound) <br>
Changes the sign of the following argument.</p>

<p style="margin-top: 1em">universal-argument <br>
Multiply the argument of the next command by 4.
Alternatively, if this command is followed by an integer
(positive or negative), use that as the argument for the
next <br>
command. Thus digits cannot be repeated using this command.
For example, if this command occurs twice, followed
immediately by forward-char, move forward sixteen spaces;
<br>
if instead it is followed by -2, then forward-char, move
backward two spaces.</p>

<p style="margin-top: 1em">Inside a widget function, if
passed an argument, i.e. &lsquo;zle universal-argument
num&rsquo;, the numerical argument will be set to num; this
is equivalent to &lsquo;NUMERIC=num&rsquo;.</p>

<p style="margin-top: 1em">argument-base <br>
Use the existing numeric argument as a numeric base, which
must be in the range 2 to 36 inclusive. Subsequent use of
digit-argument and universal-argument will input a <br>
new prefix in the given base. The usual hexadecimal
convention is used: the letter a or A corresponds to 10, and
so on. Arguments in bases requiring digits from 10 <br>
upwards are more conveniently input with universal-argument,
since ESC-a etc. are not usually bound to
digit-argument.</p>

<p style="margin-top: 1em">The function can be used with a
command argument inside a user-defined widget. The following
code sets the base to 16 and lets the user input a
hexadecimal argument until <br>
a key out of the digit range is typed:</p>

<p style="margin-top: 1em">zle argument-base 16 <br>
zle universal-argument</p>

<p style="margin-top: 1em">Completion <br>
accept-and-menu-complete <br>
In a menu completion, insert the current completion into the
buffer, and advance to the next possible completion.</p>

<p style="margin-top: 1em">complete-word <br>
Attempt completion on the current word.</p>

<p style="margin-top: 1em">delete-char-or-list (^D)
(unbound) (unbound) <br>
Delete the character under the cursor. If the cursor is at
the end of the line, list possible completions for the
current word.</p>

<p style="margin-top: 1em">expand-cmd-path <br>
Expand the current command to its full pathname.</p>

<p style="margin-top: 1em">expand-or-complete (TAB)
(unbound) (TAB) <br>
Attempt shell expansion on the current word. If that fails,
attempt completion.</p>

<p style="margin-top: 1em">expand-or-complete-prefix <br>
Attempt shell expansion on the current word up to
cursor.</p>

<p style="margin-top: 1em">expand-history (ESC-space ESC-!)
(unbound) (unbound) <br>
Perform history expansion on the edit buffer.</p>

<p style="margin-top: 1em">expand-word (^X*) (unbound)
(unbound) <br>
Attempt shell expansion on the current word.</p>

<p style="margin-top: 1em">list-choices (ESC-^D) (^D =)
(^D) <br>
List possible completions for the current word.</p>

<p style="margin-top: 1em">list-expand (^Xg ^XG) (^G) (^G)
<br>
List the expansion of the current word.</p>

<p style="margin-top: 1em">magic-space <br>
Perform history expansion and insert a space into the
buffer. This is intended to be bound to space.</p>

<p style="margin-top: 1em">menu-complete <br>
Like complete-word, except that menu completion is used. See
the MENU_COMPLETE option.</p>

<p style="margin-top: 1em">menu-expand-or-complete <br>
Like expand-or-complete, except that menu completion is
used.</p>

<p style="margin-top: 1em">reverse-menu-complete <br>
Perform menu completion, like menu-complete, except that if
a menu completion is already in progress, move to the
previous completion rather than the next.</p>

<p style="margin-top: 1em">end-of-list <br>
When a previous completion displayed a list below the
prompt, this widget can be used to move the prompt below the
list.</p>

<p style="margin-top: 1em">Miscellaneous <br>
accept-and-hold (ESC-A ESC-a) (unbound) (unbound) <br>
Push the contents of the buffer on the buffer stack and
execute it.</p>

<p style="margin-top: 1em">accept-and-infer-next-history
<br>
Execute the contents of the buffer. Then search the history
list for a line matching the current one and push the event
following onto the buffer stack.</p>

<p style="margin-top: 1em">accept-line (^J ^M) (^J ^M) (^J
^M) <br>
Finish editing the buffer. Normally this causes the buffer
to be executed as a shell command.</p>

<p style="margin-top: 1em">accept-line-and-down-history
(^O) (unbound) (unbound) <br>
Execute the current line, and push the next history event on
the buffer stack.</p>

<p style="margin-top: 1em">auto-suffix-remove <br>
If the previous action added a suffix (space, slash, etc.)
to the word on the command line, remove it. Otherwise do
nothing. Removing the suffix ends any active menu <br>
completion or menu selection.</p>

<p style="margin-top: 1em">This widget is intended to be
called from user-defined widgets to enforce a desired
suffix-removal behavior.</p>

<p style="margin-top: 1em">auto-suffix-retain <br>
If the previous action added a suffix (space, slash, etc.)
to the word on the command line, force it to be preserved.
Otherwise do nothing. Retaining the suffix ends any <br>
active menu completion or menu selection.</p>

<p style="margin-top: 1em">This widget is intended to be
called from user-defined widgets to enforce a desired
suffix-preservation behavior.</p>

<p style="margin-top: 1em">beep Beep, unless the BEEP
option is unset.</p>

<p style="margin-top: 1em">vi-cmd-mode (^X^V) (unbound)
(^[) <br>
Enter command mode; that is, select the &lsquo;vicmd&rsquo;
keymap. Yes, this is bound by default in emacs mode.</p>

<p style="margin-top: 1em">vi-caps-lock-panic <br>
Hang until any lowercase key is pressed. This is for vi
users without the mental capacity to keep track of their
caps lock key (like the author).</p>

<p style="margin-top: 1em">clear-screen (^L ESC-^L) (^L)
(^L) <br>
Clear the screen and redraw the prompt.</p>

<p style="margin-top: 1em">describe-key-briefly <br>
Reads a key sequence, then prints the function bound to that
sequence.</p>

<p style="margin-top: 1em">exchange-point-and-mark (^X^X)
(unbound) (unbound) <br>
Exchange the cursor position (point) with the position of
the mark. Unless a negative prefix argument is given, the
region between point and mark is activated so that it <br>
can be highlighted. If a zero prefix argument is given, the
region is activated but point and mark are not swapped.</p>

<p style="margin-top: 1em">execute-named-cmd (ESC-x) (:)
(unbound) <br>
Read the name of an editor command and execute it. A
restricted set of editing functions is available in the
mini-buffer. Keys are looked up in the special command <br>
keymap, and if not found there in the main keymap. An
interrupt signal, as defined by the stty setting, will abort
the function. Note that the following always perform <br>
the same task within the executed-named-cmd environment and
cannot be replaced by user defined widgets, nor can the set
of functions be extended. The allowed functions <br>
are: backward-delete-char, vi-backward-delete-char,
clear-screen, redisplay, quoted-insert, vi-quoted-insert,
backward-kill-word, vi-backward-kill-word, kill-whole-line,
<br>
vi-kill-line, backward-kill-line, list-choices,
delete-char-or-list, complete-word, accept-line,
expand-or-complete and expand-or-complete-prefix.</p>

<p style="margin-top: 1em">kill-region kills the last word,
and vi-cmd-mode is treated the same as accept-line. The
space and tab characters, if not bound to one of these
functions, will complete <br>
the name and then list the possibilities if the AUTO_LIST
option is set. Any other character that is not bound to
self-insert or self-insert-unmeta will beep and be <br>
ignored. The bindings of the current insert mode will be
used.</p>

<p style="margin-top: 1em">Currently this command may not
be redefined or called by name.</p>

<p style="margin-top: 1em">execute-last-named-cmd (ESC-z)
(unbound) (unbound) <br>
Redo the last function executed with execute-named-cmd.</p>

<p style="margin-top: 1em">Currently this command may not
be redefined or called by name.</p>

<p style="margin-top: 1em">get-line (ESC-G ESC-g) (unbound)
(unbound) <br>
Pop the top line off the buffer stack and insert it at the
cursor position.</p>

<p style="margin-top: 1em">pound-insert (unbound) (#)
(unbound) <br>
If there is no # character at the beginning of the buffer,
add one to the beginning of each line. If there is one,
remove a # from each line that has one. In either <br>
case, accept the current line. The INTERACTIVE_COMMENTS
option must be set for this to have any usefulness.</p>

<p style="margin-top: 1em">vi-pound-insert <br>
If there is no # character at the beginning of the current
line, add one. If there is one, remove it. The
INTERACTIVE_COMMENTS option must be set for this to have any
<br>
usefulness.</p>

<p style="margin-top: 1em">push-input <br>
Push the entire current multiline construct onto the buffer
stack and return to the top-level (PS1) prompt. If the
current parser construct is only a single line, this is <br>
exactly like push-line. Next time the editor starts up or is
popped with get-line, the construct will be popped off the
top of the buffer stack and loaded into the edit&acirc; <br>
ing buffer.</p>

<p style="margin-top: 1em">push-line (^Q ESC-Q ESC-q)
(unbound) (unbound) <br>
Push the current buffer onto the buffer stack and clear the
buffer. Next time the editor starts up, the buffer will be
popped off the top of the buffer stack and loaded <br>
into the editing buffer.</p>

<p style="margin-top: 1em">push-line-or-edit <br>
At the top-level (PS1) prompt, equivalent to push-line. At a
secondary (PS2) prompt, move the entire current multiline
construct into the editor buffer. The latter is <br>
equivalent to push-input followed by get-line.</p>

<p style="margin-top: 1em">read-command <br>
Only useful from a user-defined widget. A keystroke is read
just as in normal operation, but instead of the command
being executed the name of the command that would be <br>
executed is stored in the shell parameter REPLY. This can be
used as the argument of a future zle command. If the key
sequence is not bound, status 1 is returned; typi&acirc;
<br>
cally, however, REPLY is set to undefined-key to indicate a
useless key sequence.</p>

<p style="margin-top: 1em">recursive-edit <br>
Only useful from a user-defined widget. At this point in the
function, the editor regains control until one of the
standard widgets which would normally cause zle to exit <br>
(typically an accept-line caused by hitting the return key)
is executed. Instead, control returns to the user-defined
widget. The status returned is non-zero if the <br>
return was caused by an error, but the function still
continues executing and hence may tidy up. This makes it
safe for the user-defined widget to alter the command line
<br>
or key bindings temporarily.</p>

<p style="margin-top: 1em">The following widget, caps-lock,
serves as an example. <br>
self-insert-ucase() { <br>
LBUFFER+=${(U)KEYS[-1]} <br>
}</p>

<p style="margin-top: 1em">integer stat</p>

<p style="margin-top: 1em">zle -N self-insert
self-insert-ucase <br>
zle -A caps-lock save-caps-lock <br>
zle -A accept-line caps-lock</p>

<p style="margin-top: 1em">zle recursive-edit <br>
stat=$?</p>

<p style="margin-top: 1em">zle -A .self-insert self-insert
<br>
zle -A save-caps-lock caps-lock <br>
zle -D save-caps-lock</p>

<p style="margin-top: 1em">(( stat )) &amp;&amp; zle
send-break</p>

<p style="margin-top: 1em">return $stat <br>
This causes typed letters to be inserted capitalised until
either accept-line (i.e. typically the return key) is typed
or the caps-lock widget is invoked again; the later <br>
is handled by saving the old definition of caps-lock as
save-caps-lock and then rebinding it to invoke accept-line.
Note that an error from the recursive edit is detected <br>
as a non-zero return status and propagated by using the
send-break widget.</p>

<p style="margin-top: 1em">redisplay (unbound) (^R) (^R)
<br>
Redisplays the edit buffer.</p>

<p style="margin-top: 1em">reset-prompt (unbound) (unbound)
(unbound) <br>
Force the prompts on both the left and right of the screen
to be re-expanded, then redisplay the edit buffer. This
reflects changes both to the prompt variables them&acirc;
<br>
selves and changes in the expansion of the values (for
example, changes in time or directory, or changes to the
value of variables referred to by the prompt).</p>

<p style="margin-top: 1em">Otherwise, the prompt is only
expanded each time zle starts, and when the display as been
interrupted by output from another part of the shell (such
as a job notification) <br>
which causes the command line to be reprinted.</p>

<p style="margin-top: 1em">send-break (^G ESC-^G) (unbound)
(unbound) <br>
Abort the current editor function, e.g.
execute-named-command, or the editor itself, e.g. if you are
in vared. Otherwise abort the parsing of the current line;
in this <br>
case the aborted line is available in the shell variable
ZLE_LINE_ABORTED.</p>

<p style="margin-top: 1em">run-help (ESC-H ESC-h) (unbound)
(unbound) <br>
Push the buffer onto the buffer stack, and execute the
command &lsquo;run-help cmd&rsquo;, where cmd is the current
command. run-help is normally aliased to man.</p>

<p style="margin-top: 1em">vi-set-buffer (unbound) (&quot;)
(unbound) <br>
Specify a buffer to be used in the following command. There
are 35 buffers that can be specified: the 26
&lsquo;named&rsquo; buffers &quot;a to &quot;z and the nine
&lsquo;queued&rsquo; buffers &quot;1 to &quot;9. <br>
The named buffers can also be specified as &quot;A to
&quot;Z.</p>

<p style="margin-top: 1em">When a buffer is specified for a
cut command, the text being cut replaces the previous
contents of the specified buffer. If a named buffer is
specified using a capital, <br>
the newly cut text is appended to the buffer instead of
overwriting it.</p>

<p style="margin-top: 1em">If no buffer is specified for a
cut command, &quot;1 is used, and the contents of &quot;1 to
&quot;8 are each shifted along one buffer; the contents of
&quot;9 is lost.</p>

<p style="margin-top: 1em">vi-set-mark (unbound) (m)
(unbound) <br>
Set the specified mark at the cursor position.</p>

<p style="margin-top: 1em">set-mark-command (^@) (unbound)
(unbound) <br>
Set the mark at the cursor position. If called with a
negative prefix argument, do not set the mark but deactivate
the region so that it is no longer highlighted (it is <br>
still usable for other purposes). Otherwise the region is
marked as active.</p>

<p style="margin-top: 1em">spell-word (ESC-$ ESC-S ESC-s)
(unbound) (unbound) <br>
Attempt spelling correction on the current word.</p>

<p style="margin-top: 1em">undefined-key <br>
This command is executed when a key sequence that is not
bound to any command is typed. By default it beeps.</p>

<p style="margin-top: 1em">undo (^_ ^Xu ^X^U) (unbound)
(unbound) <br>
Incrementally undo the last text modification. When called
from a user-defined widget, takes an optional argument
indicating a previous state of the undo history as <br>
returned by the UNDO_CHANGE_NO variable; modifications are
undone until that state is reached.</p>

<p style="margin-top: 1em">redo Incrementally redo undone
text modifications.</p>

<p style="margin-top: 1em">vi-undo-change (unbound) (u)
(unbound) <br>
Undo the last text modification. If repeated, redo the
modification.</p>

<p style="margin-top: 1em">what-cursor-position (^X=)
(unbound) (unbound) <br>
Print the character under the cursor, its code as an octal,
decimal and hexadecimal number, the current cursor position
within the buffer and the column of the cursor in <br>
the current line.</p>

<p style="margin-top: 1em">where-is <br>
Read the name of an editor command and print the listing of
key sequences that invoke the specified command. A
restricted set of editing functions is available in the <br>
mini-buffer. Keys are looked up in the special command
keymap, and if not found there in the main keymap.</p>

<p style="margin-top: 1em">which-command (ESC-?) (unbound)
(unbound) <br>
Push the buffer onto the buffer stack, and execute the
command &lsquo;which-command cmd&rsquo;. where cmd is the
current command. which-command is normally aliased to
whence.</p>

<p style="margin-top: 1em">vi-digit-or-beginning-of-line
(unbound) (0) (unbound) <br>
If the last command executed was a digit as part of an
argument, continue the argument. Otherwise, execute
vi-beginning-of-line.</p>

<p style="margin-top: 1em">CHARACTER HIGHLIGHTING <br>
The line editor has the ability to highlight characters or
regions of the line that have a particular significance.
This is controlled by the array parameter zle_highlight, if
<br>
it has been set by the user.</p>

<p style="margin-top: 1em">If the parameter contains the
single entry none all highlighting is turned off. Note the
parameter is still expected to be an array.</p>

<p style="margin-top: 1em">Otherwise each entry of the
array should consist of a word indicating a context for
highlighting, then a colon, then a comma-separated list of
the types of highlighting to apply <br>
in that context.</p>

<p style="margin-top: 1em">The contexts available for
highlighting are the following:</p>

<p style="margin-top: 1em">default <br>
Any text within the command line not affected by any other
highlighting. Text outside the editable area of the command
line is not affected.</p>

<p style="margin-top: 1em">isearch <br>
When one of the incremental history search widgets is
active, the area of the command line matched by the search
string or pattern.</p>

<p style="margin-top: 1em">region The region between the
cursor (point) and the mark as set with set-mark-command.
The region is only highlighted if it is active, which is the
case if set-mark-command or <br>
exchange-point-and-mark has been called and the line has not
been subsequently modified. The region can be deactivated by
calling set-mark-command with a negative prefix <br>
argument, or reactivated by calling exchange-point-and-mark
with a zero prefix argument. Note that whether or not the
region is active has no effect on its use within <br>
widgets, it simply determines whether it is highlighted.</p>

<p style="margin-top: 1em">special <br>
Individual characters that have no direct printable
representation but are shown in a special manner by the line
editor. These characters are described below.</p>

<p style="margin-top: 1em">suffix This context is used in
completion for characters that are marked as suffixes that
will be removed if the completion ends at that point, the
most obvious example being a <br>
slash (/) after a directory name. Note that suffix removal
is configurable; the circumstances under which the suffix
will be removed may differ for different completions.</p>

<p style="margin-top: 1em">zle_highlight may contain
additional fields for controlling how terminal sequences to
change colours are output. Each of the following is followed
by a colon and a string in the <br>
same form as for key bindings. This will not be necessary
for the vast majority of terminals as the defaults shown in
parentheses are widely used.</p>

<p style="margin-top: 1em">fg_start_code (\[3) <br>
The start of the escape sequence for the foreground colour.
This is followed by an ASCII digit representing the
colour.</p>

<p style="margin-top: 1em">fg_default_code (9) <br>
The number to use instead of the colour to reset the default
foreground colour.</p>

<p style="margin-top: 1em">fg_end_code (m) <br>
The end of the escape sequence for the foreground
colour.</p>

<p style="margin-top: 1em">bg_start_code (\[4) <br>
The start of the escape sequence for the background colour.
This is followed by an ASCII digit representing the
colour.</p>

<p style="margin-top: 1em">bg_default_code (9) <br>
The number to use instead of the colour to reset the default
background colour.</p>

<p style="margin-top: 1em">bg_end_code (m) <br>
The end of the escape sequence for the background
colour.</p>

<p style="margin-top: 1em">The available types of
highlighting are the following. Note that not all types of
highlighting are available on all terminals:</p>

<p style="margin-top: 1em">none No highlighting is applied
to the given context. It is not useful for this to appear
with other types of highlighting; it is used to override a
default.</p>

<p style="margin-top: 1em">fg=colour <br>
The foreground colour should be set to colour, a decimal
integer or the name of one of the eight most
widely-supported colours.</p>

<p style="margin-top: 1em">Not all terminals support this
and, of those that do, not all provide facilities to test
the support, hence the user should decide based on the
terminal type. Most termi&acirc; <br>
nals support the colours black, red, green, yellow, blue,
magenta, cyan and white, which can be set by name. In
addition. default may be used to set the terminal&rsquo;s
<br>
default foreground colour. Abbreviations are allowed; b or
bl selects black. Some terminals may generate additional
colours if the bold attribute is also present.</p>

<p style="margin-top: 1em">On recent terminals and on
systems with an up-to-date terminal database the number of
colours supported may be tested by the command &lsquo;echotc
Co&rsquo;; if this succeeds, it <br>
indicates a limit on the number of colours which will be
enforced by the line editor. The number of colours is in any
case limited to 256 (i.e. the range 0 to 255).</p>

<p style="margin-top: 1em">Colour is also known as
color.</p>

<p style="margin-top: 1em">bg=colour <br>
The background colour should be set to colour. This works
similarly to the foreground colour, except the background is
not usually affected by the bold attribute.</p>

<p style="margin-top: 1em">bold The characters in the given
context are shown in a bold font. Not all terminals
distinguish bold fonts.</p>

<p style="margin-top: 1em">standout <br>
The characters in the given context are shown in the
terminal&rsquo;s standout mode. The actual effect is
specific to the terminal; on many terminals it is inverse
video. On <br>
some such terminals, where the cursor does not blink it
appears with standout mode negated, making it less than
clear where the cursor actually is. On such terminals one
<br>
of the other effects may be preferable for highlighting the
region and matched search string.</p>

<p style="margin-top: 1em">underline <br>
The characters in the given context are shown underlined.
Some terminals show the foreground in a different colour
instead; in this case whitespace will not be high&acirc;
<br>
lighted.</p>

<p style="margin-top: 1em">The characters described above
as &lsquo;special&rsquo; are as follows. The formatting
described here is used irrespective of whether the
characters are highlighted:</p>

<p style="margin-top: 1em">ASCII control characters <br>
Control characters in the ASCII range are shown as
&lsquo;^&rsquo; followed by the base character.</p>

<p style="margin-top: 1em">Unprintable multibyte characters
<br>
This item applies to control characters not in the ASCII
range, plus other characters as follows. If the MULTIBYTE
option is in effect, multibyte characters not in the <br>
ASCII character set that are reported as having zero width
are treated as combining characters when the option
COMBINING_CHARS is on. If the option is off, or if a
char&acirc; <br>
acter appears where a combining character is not valid, the
character is treated as unprintable.</p>

<p style="margin-top: 1em">Unprintable multibyte characters
are shown as a hexadecimal number between angle brackets.
The number is the code point of the character in the wide
character set; this <br>
may or may not be Unicode, depending on the operating
system.</p>

<p style="margin-top: 1em">Invalid multibyte characters
<br>
If the MULTIBYTE option is in effect, any sequence of one or
more bytes that does not form a valid character in the
current character set is treated as a series of bytes <br>
each shown as a special character. This case can be
distinguished from other unprintable characters as the bytes
are represented as two hexadecimal digits between angle <br>
brackets, as distinct from the four or eight digits that are
used for unprintable characters that are nonetheless valid
in the current character set.</p>

<p style="margin-top: 1em">Not all systems support this:
for it to work, the system&rsquo;s representation of wide
characters must be code values from the Universal Character
Set, as defined by IS0 10646 <br>
(also known as Unicode).</p>

<p style="margin-top: 1em">Wrapped double-width characters
<br>
When a double-width character appears in the final column of
a line, it is instead shown on the next line. The empty
space left in the original position is highlighted as <br>
a special character.</p>

<p style="margin-top: 1em">If zle_highlight is not set or
no value applies to a particular context, the defaults
applied are equivalent to</p>

<p style="margin-top: 1em">zle_highlight=(region:standout
special:standout <br>
suffix:bold isearch:underline)</p>

<p style="margin-top: 1em">i.e. both the region and special
characters are shown in standout mode.</p>

<p style="margin-top: 1em">Within widgets, arbitrary
regions may be highlighted by setting the special array
parameter region_highlight; see above.</p>

<p style="margin-top: 1em">zsh 5.0.2 December 21, 2012
ZSHZLE(1)</p>
<hr>
</body>
</html>
