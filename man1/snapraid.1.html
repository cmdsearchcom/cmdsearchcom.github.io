<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:38:14 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>SnapRAID Backup For Disk Arrays(1) General Commands
Manual SnapRAID Backup For Disk Arrays(1)</p>

<p style="margin-top: 1em">NAME <br>
snapraid - SnapRAID Backup For Disk Arrays</p>

<p style="margin-top: 1em">SYNOPSIS <br>
snapraid [-c, --conf CONFIG] <br>
[-f, --filter PATTERN] [-d, --filter-disk NAME] <br>
[-m, --filter-missing] [-e, --filter-error] <br>
[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR] <br>
[-p, --plan PERC|bad|new|full] <br>
[-o, --older-than DAYS] [-l, --log FILE] <br>
[-Z, --force-zero] [-E, --force-empty] <br>
[-U, --force-uuid] [-D, --force-device] <br>
[-N, --force-nocopy] [-F, --force-full] <br>
[-S, --start BLKSTART] [-B, --count BLKCOUNT] <br>
[-L, --error-limit NUMBER] <br>
[-v, --verbose] [-q, --quiet] <br>
status|smart|up|down|diff|sync|scrub|fix|check|list|dup <br>
|up|down|pool|devices|touch|rehash <br>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf
CONTENT] DESCRIPTION <br>
SnapRAID is a backup program for disk arrays. It stores
parity information of your data and it recovers from up to
six disk failures.</p>

<p style="margin-top: 1em">SnapRAID is mainly targeted for
a home media center, with a lot of big files that rarely
change.</p>

<p style="margin-top: 1em">Beside the ability to recover
from disk failures, other features of SnapRAID are: <br>
&Acirc;&middot; All your data is hashed to ensure data
integrity and to avoid silent corruption. <br>
&Acirc;&middot; If the failed disks are too many to allow a
recovery, you lose the data only on the failed disks. All
the data in the other disks is safe. <br>
&Acirc;&middot; If you accidentally delete some files in a
disk, you can recover them. <br>
&Acirc;&middot; You can start with already filled disks.
<br>
&Acirc;&middot; The disks can have different sizes. <br>
&Acirc;&middot; You can add disks at any time. <br>
&Acirc;&middot; It doesn&Acirc;&acute;t lock-in your data.
You can stop using SnapRAID at any time without the need to
reformat or move data. <br>
&Acirc;&middot; To access a file, a single disk needs to
spin, saving power and producing less noise.</p>

<p style="margin-top: 1em">The official site of SnapRAID
is:</p>

<p style="margin-top: 1em">http://www.snapraid.it/
LIMITATIONS <br>
SnapRAID is in between a RAID and a Backup program trying to
get the best benefits of them. Although it also has some
limitations that you should consider before using it.</p>

<p style="margin-top: 1em">The main one is that if a disk
fails, and you haven&Acirc;&acute;t recently synced, you may
be unable to do a complete recover. More specifically, you
may be unable to recover up to the size <br>
of the amount of the changed or deleted files from the last
sync operation. This happens even if the files changed or
deleted are not in the failed disk. This is the reason <br>
because SnapRAID is better suited for data that rarely
change.</p>

<p style="margin-top: 1em">Instead the new added files
don&Acirc;&acute;t prevent the recovering of the already
existing files. You may only lose the just added files, if
they are on the failed disk.</p>

<p style="margin-top: 1em">Other limitations are: <br>
&Acirc;&middot; You have different file-systems for each
disk. Using a RAID you have only a big file-system. <br>
&Acirc;&middot; It doesn&Acirc;&acute;t stripe data. With
RAID you get a speed boost with striping. <br>
&Acirc;&middot; It doesn&Acirc;&acute;t support real-time
recovery. With RAID you do not have to stop working when a
disk fails. <br>
&Acirc;&middot; It&Acirc;&acute;s able to recover damages
only from a limited number of disks. With a Backup you are
able to recover from a complete failure of the whole disk
array. <br>
&Acirc;&middot; Only file, time-stamps, symlinks and
hardlinks are saved. Permissions, ownership and extended
attributes are not saved.</p>

<p style="margin-top: 1em">GETTING STARTED <br>
To use SnapRAID you need to first select one disk of your
disk array to dedicate at the &quot;parity&quot;
information. With one disk for parity you will be able to
recover from a single <br>
disk failure, like RAID5.</p>

<p style="margin-top: 1em">If you want to be able to
recover from more disk failures, like RAID6, you must
reserve additional disks for parity. Any additional parity
disk allow to recover from one more <br>
disk failure.</p>

<p style="margin-top: 1em">As parity disks, you have to
pick the biggest disks in the array, as the parity
information may grow in size as the biggest data disk in the
array.</p>

<p style="margin-top: 1em">These disks will be dedicated to
store the &quot;parity&quot; files. You should not store
your data in them.</p>

<p style="margin-top: 1em">Then you have to define the
&quot;data&quot; disks that you want to protect with
SnapRAID. The protection is more effective if these disks
contain data that rarely change. For this reason <br>
it&Acirc;&acute;s better to DO NOT include the Windows
C:&nbsp;disk, or the Unix /home, /var and /tmp disks.</p>

<p style="margin-top: 1em">The list of files is saved in
the &quot;content&quot; files, usually stored in the data,
parity or boot disks. These files contain the details of
your backup, with all the check-sums to <br>
verify its integrity. The &quot;content&quot; file is stored
in multiple copies, and each one must be in a different
disk, to ensure that in even in case of multiple disk
failures at <br>
least one copy is available.</p>

<p style="margin-top: 1em">For example, suppose that you
are interested only at one parity level of protection, and
that your disks are present in:</p>

<p style="margin-top: 1em">/mnt/diskp &lt;- selected disk
for parity <br>
/mnt/disk1 &lt;- first disk to protect <br>
/mnt/disk2 &lt;- second disk to protect <br>
/mnt/disk3 &lt;- third disk to protect <br>
you have to create the configuration file /etc/snapraid.conf
with the following options:</p>

<p style="margin-top: 1em">parity
/mnt/diskp/snapraid.parity <br>
content /var/snapraid/snapraid.content <br>
content /mnt/disk1/snapraid.content <br>
content /mnt/disk2/snapraid.content <br>
data d1 /mnt/disk1/ <br>
data d2 /mnt/disk2/ <br>
data d3 /mnt/disk3/ <br>
If you are in Windows, you should use the Windows path
format, with drive letters and backslashes instead of
slashes.</p>

<p style="margin-top: 1em">parity E:praid.parity <br>
content C:praidpraid.content <br>
content F:rraypraid.content <br>
content G:rraypraid.content <br>
data d1 F:rray data d2 G:rray data d3 H:rray If you have
many disks, and you run out of drive letters, you can mount
disks directly in sub folders. See:</p>


<p style="margin-top: 1em">https://www.google.com/search?q=Windows+mount+point
<br>
At this point you are ready to start the &quot;sync&quot;
command to build the parity information.</p>

<p style="margin-top: 1em">snapraid sync <br>
This process may take some hours the first time, depending
on the size of the data already present in the disks. If the
disks are empty the process is immediate.</p>

<p style="margin-top: 1em">You can stop it at any time
pressing Ctrl+C, and at the next run it will start where
interrupted.</p>

<p style="margin-top: 1em">When this command completes,
your data is SAFE.</p>

<p style="margin-top: 1em">Now you can start using your
array as you like, and periodically update the parity
information running the &quot;sync&quot; command.</p>

<p style="margin-top: 1em">Scrubbing <br>
To periodically check the data and parity for errors, you
can run the &quot;scrub&quot; command.</p>

<p style="margin-top: 1em">snapraid scrub <br>
This command verifies the data in your array comparing it
with the hash computed in the &quot;sync&quot; command.</p>

<p style="margin-top: 1em">Every run of the command checks
about the 8% of the array, but not data already scrubbed in
the previous 10 days. You can use the -p, --plan option to
specify a different <br>
amount, and the -o, --older-than option to specify a
different age in days. For example, to check 5% of the array
older than 20 days use:</p>

<p style="margin-top: 1em">snapraid -p 5 -o 20 scrub <br>
If during the process, silent or input/output errors are
found, the corresponding blocks are marked as bad in the
&quot;content&quot; file, and listed in the
&quot;status&quot; command.</p>

<p style="margin-top: 1em">snapraid status <br>
To fix them, you can use the &quot;fix&quot; command
filtering for bad blocks with the -e, --filter-error
options:</p>

<p style="margin-top: 1em">snapraid -e fix <br>
At the next &quot;scrub&quot; the errors will disappear from
the &quot;status&quot; report if really fixed. To make it
fast, you can use -p bad to scrub only blocks marked as
bad.</p>

<p style="margin-top: 1em">snapraid -p bad scrub <br>
Take care that running &quot;scrub&quot; on a not synced
array may result in errors caused by removed or modified
files. These errors are reported in the &quot;scrub&quot;
result, but related blocks <br>
are not marked as bad.</p>

<p style="margin-top: 1em">Pooling <br>
To have all the files in your array shown in the same
directory tree, you can enable the &quot;pooling&quot;
feature. It consists in creating a read-only virtual view of
all the files in <br>
your array using symbolic links.</p>

<p style="margin-top: 1em">You can configure the
&quot;pooling&quot; directory in the configuration file
with:</p>

<p style="margin-top: 1em">pool /pool <br>
or, if you are in Windows, with:</p>

<p style="margin-top: 1em">pool C:ool <br>
and then run the &quot;pool&quot; command to create or
update the virtual view.</p>

<p style="margin-top: 1em">snapraid pool <br>
If you are using a Unix platform and you want to share such
directory in the network to either Windows or Unix machines,
you should add to your /etc/samba/smb.conf the following
<br>
options:</p>

<p style="margin-top: 1em"># In the global section of
smb.conf <br>
unix extensions = no <br>
# In the share section of smb.conf <br>
[pool] <br>
comment = Pool <br>
path = /pool <br>
read only = yes <br>
guest ok = yes <br>
wide links = yes <br>
follow symlinks = yes <br>
In Windows the same sharing operation is not so
straightforward, because Windows shares the symbolic links
as they are, and that requires the network clients to
resolve them <br>
remotely.</p>

<p style="margin-top: 1em">To make it working, besides
sharing in the network the pool directory, you must also
share all the disks independently, using as share points the
disk names as defined in the <br>
configuration file. You must also specify in the
&quot;share&quot; option of the configure file, the Windows
UNC path that remote clients needs to use to access such
shared disks.</p>

<p style="margin-top: 1em">For example, operating from a
server named &quot;darkstar&quot;, you can use the
options:</p>

<p style="margin-top: 1em">data d1 F:rray data d2 G:rray
data d3 H:rray pool C:ool <br>
share \darkstar <br>
and share the following dirs in the network:</p>

<p style="margin-top: 1em">\darkstarool -&gt; C:ool <br>
\darkstar1 -&gt; F:rray <br>
\darkstar2 -&gt; G:rray <br>
\darkstar3 -&gt; H:rray <br>
to allow remote clients to access all the files at
\darkstar\pool.</p>

<p style="margin-top: 1em">You may also need to configure
remote clients enablinh access at remote symlinks with the
command:</p>

<p style="margin-top: 1em">fsutil behavior set
SymlinkEvaluation L2L:1 R2R:1 L2R:1 R2L:1 <br>
Undeleting <br>
SnapRAID is more like a backup program than a RAID system,
and it can be used to restore or undelete files to their
previous state using the -f, --filter option :</p>

<p style="margin-top: 1em">snapraid fix -f FILE <br>
or for a directory:</p>

<p style="margin-top: 1em">snapraid fix -f DIR/ <br>
You can also use it to recover only accidentally deleted
files inside a directory using the -m, --filter-missing
option, that restores only missing files, leaving untouched
all <br>
the others.</p>

<p style="margin-top: 1em">snapraid fix -m -f DIR/ <br>
Or to recover all the deleted files in all the drives
with:</p>

<p style="margin-top: 1em">snapraid fix -m <br>
Recovering <br>
The worst happened, and you lost a disk!</p>

<p style="margin-top: 1em">DO NOT PANIC! You will be able
to recover it!</p>

<p style="margin-top: 1em">The first thing you have to do
is to avoid further changes at you disk array. Disable any
remote connection to it, any scheduled process, including
any scheduled SnapRAID <br>
nightly sync or scrub.</p>

<p style="margin-top: 1em">Then proceed with the following
steps.</p>

<p style="margin-top: 1em">STEP 1 -&gt; Reconfigure <br>
You need some space to recover, even better if you already
have an additional disk, but in case, also an external USB
or remote disk is enough.</p>

<p style="margin-top: 1em">Change the SnapRAID
configuration file to make the &quot;disk&quot; option of
the failed disk to point to the place where you have enough
empty space to recover the files.</p>

<p style="margin-top: 1em">For example, if you have that
disk &quot;d1&quot; failed, you can change from:</p>

<p style="margin-top: 1em">data d1 /mnt/disk1/ <br>
to:</p>

<p style="margin-top: 1em">data d1 /mnt/new_spare_disk/
<br>
STEP 2 -&gt; Fix <br>
Run the fix command, storing the log in an external file
with:</p>

<p style="margin-top: 1em">snapraid -d NAME -l fix.log fix
<br>
Where NAME is the name of the disk, like &quot;d1&quot; as
in our previous example.</p>

<p style="margin-top: 1em">This command will take a long
time.</p>

<p style="margin-top: 1em">Take care that you need also few
gigabytes free to store the fix.log file. Run it from a disk
with some free space.</p>

<p style="margin-top: 1em">Now you have recovered all the
recoverable. If some file is partially or totally
unrecoverable, it will be renamed adding the
&quot;.unrecoverable&quot; extension.</p>

<p style="margin-top: 1em">You can get a detailed list of
all the unrecoverable blocks in the fix.log file checking
all the lines starting with &quot;unrecoverable:&quot;</p>

<p style="margin-top: 1em">If you are not satisfied of the
recovering, you can retry it as many time you wish.</p>

<p style="margin-top: 1em">For example, if you have removed
files from the array after the last &quot;sync&quot;, this
may result in some other files not recovered. In this case,
you can retry the &quot;fix&quot; using the <br>
-i, --import option, specifying where these files are now,
to include them again in the recovering process.</p>

<p style="margin-top: 1em">If you are satisfied of the
recovering, you can now proceed further, but take care that
after syncing you cannot retry the &quot;fix&quot; command
anymore!</p>

<p style="margin-top: 1em">STEP 3 -&gt; Check <br>
As paranoid check, you can now run a &quot;check&quot;
command to ensure that everything is OK on the recovered
disk.</p>

<p style="margin-top: 1em">snapraid -d NAME -a check <br>
Where NAME is the name of the disk, like &quot;d1&quot; as
in our previous example.</p>

<p style="margin-top: 1em">The options -d and -a tell
SnapRAID to check only the specified disk, and ignore all
the parity data.</p>

<p style="margin-top: 1em">This command will take a long
time, but if you are not paranoid, you can skip it.</p>

<p style="margin-top: 1em">STEP 4 -&gt; Sync <br>
Run the &quot;sync&quot; command to resynchronize the array
with the new disk.</p>

<p style="margin-top: 1em">snapraid sync <br>
If everything is recovered, this command is immediate.</p>

<p style="margin-top: 1em">COMMANDS <br>
SnapRAID provides a few simple commands that allow to: <br>
&Acirc;&middot; Prints the status of the array -&gt;
&quot;status&quot; <br>
&Acirc;&middot; Controls the disks -&gt; &quot;smart&quot;,
&quot;up&quot;, &quot;down&quot; <br>
&Acirc;&middot; Makes a backup/snapshot -&gt;
&quot;sync&quot; <br>
&Acirc;&middot; Periodically checks data -&gt;
&quot;scrub&quot; <br>
&Acirc;&middot; Restore the last backup/snapshot -&gt;
&quot;fix&quot;.</p>

<p style="margin-top: 1em">Take care that the commands have
to be written in lower case.</p>

<p style="margin-top: 1em">status <br>
Prints a summary of the state of the disk array.</p>

<p style="margin-top: 1em">It includes information about
the parity fragmentation, how old are the blocks without
checking, and all the recorded silent errors encountered
while scrubbing.</p>

<p style="margin-top: 1em">Note that the information
presented refers at the latest time you run
&quot;sync&quot;. Later modifications are not taken into
account.</p>

<p style="margin-top: 1em">If bad blocks were detected,
their block numbers are listed. To fix them, you can use the
&quot;fix -e&quot; command.</p>

<p style="margin-top: 1em">It also shows a graph
representing the the last time each block was scrubbed or
synced. Scrubbed blocks are shown with
&Acirc;&acute;*&Acirc;&acute;, blocks synced but not yet
scrubbed with &Acirc;&acute;o&Acirc;&acute;.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">smart <br>
Prints a SMART report of all the disks of the array.</p>

<p style="margin-top: 1em">It includes an estimation of the
probability of failure in the next year allowing to plan
maintenance replacements of the disks that show suspicious
attributes.</p>

<p style="margin-top: 1em">This probability estimation
obtained correlating the SMART attributes of the disks, with
the Backblaze data available at:</p>


<p style="margin-top: 1em">https://www.backblaze.com/hard-drive-test-data.html
<br>
If SMART reports that a disk is failing, &quot;FAIL&quot; or
&quot;PREFAIL&quot; is printed for that disk, and SnapRAID
returns with an error. In this case an immediate replacement
of the disk is <br>
highly recommended.</p>

<p style="margin-top: 1em">Other possible strings are: <br>
logfail In the past some attributes were lower than the
threshold. <br>
logerr The device error log contains errors. <br>
selferr The device self-test log contains errors.</p>

<p style="margin-top: 1em">If the -v, --verbose option is
specified a deeper statistical analysis is provided. This
analysis can help you to decide if you need more or less
parity.</p>

<p style="margin-top: 1em">This command uses the
&quot;smartctl&quot; tool, and it&Acirc;&acute;s equivalent
to run &quot;smartctl -a&quot; on all the devices.</p>

<p style="margin-top: 1em">If your devices are not
auto-detected correctly, you can configure a custom command
using the &quot;smartctl&quot; option in the configuration
file.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">up <br>
Spins up all the disks of the array.</p>

<p style="margin-top: 1em">You can spin-up only some
specific disks using the -d, --filter-disk option.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">down <br>
Spins down all the disks of the array.</p>

<p style="margin-top: 1em">This command uses the
&quot;smartctl&quot; tool, and it&Acirc;&acute;s equivalent
to run &quot;smartctl -s standby,now&quot; on all the
devices.</p>

<p style="margin-top: 1em">You can spin-down only some
specific disks using the -d, --filter-disk option.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">diff <br>
Lists all the files modified from the last &quot;sync&quot;
that need to have their parity data recomputed.</p>

<p style="margin-top: 1em">This command
doesn&Acirc;&acute;t check the file data, but only the file
time-stamp size and inode.</p>

<p style="margin-top: 1em">At the end of the command,
you&Acirc;&acute;ll get a summary of the file changes
grouped by: <br>
equal Files equal at before. <br>
added Files added that were not present before. <br>
removed Files removed. <br>
updated Files with a different size or time-stamp, meaning
that they were modified. <br>
moved Files moved to a different directory of the same disk.
They are identified by having the same name, size,
time-stamp and inode, but different directory. <br>
copied Files copied in the same or different disk. Note that
if in true they are moved to a different disk,
you&Acirc;&acute;ll also have them counted in
&quot;removed&quot;. They are identified <br>
by having the same name, size, and time-stamp. But if the
sub-second time-stamp is zero, then the full path should
match, and not only the name. <br>
restored Files with a different inode but with name, size
and time-stamp matching. These are usually files restored
after being deleted.</p>

<p style="margin-top: 1em">If a &quot;sync&quot; is
required, the process return code is 2, instead of the
default 0. The return code 1 is instead for a generic error
condition.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">sync <br>
Updates the parity information. All the modified files in
the disk array are read, and the corresponding parity data
is updated.</p>

<p style="margin-top: 1em">You can stop this process at any
time pressing Ctrl+C, without losing the work already done.
At the next run the &quot;sync&quot; process will start
where interrupted.</p>

<p style="margin-top: 1em">If during the process, silent or
input/output errors are found, the corresponding blocks are
marked as bad.</p>

<p style="margin-top: 1em">Files are identified by path
and/or inode and checked by size and time-stamp. If the file
size or time-stamp are different, the parity data is
recomputed for the whole file. If <br>
the file is moved or renamed in the same disk, keeping the
same inode, the parity is not recomputed. If the file is
moved to another disk, the parity is recomputed, but the
pre&acirc; <br>
viously computed hash information is kept.</p>

<p style="margin-top: 1em">The &quot;content&quot; and
&quot;parity&quot; files are modified if necessary. The
files in the array are NOT modified.</p>

<p style="margin-top: 1em">scrub <br>
Scrubs the array, checking for silent or input/output errors
in data and parity disks.</p>

<p style="margin-top: 1em">For each command invocation,
about the 8% of the array is checked, but nothing that was
already scrubbed in the last 10 days. This means that
scrubbing once a week, every bit of <br>
data is checked at least one time every three months.</p>

<p style="margin-top: 1em">You can define a different scrub
plan or amount using the -p, --plan option that takes as
argument: bad - Scrub blocks marked bad. new - Scrub just
synced blocks not yet <br>
scrubbed. full - Scrub everything. 0-100 - Scrub the exact
percentage of blocks.</p>

<p style="margin-top: 1em">If you specify a percentage
amount, you can also use the -o, --older-than option to
define how old the block should be. The oldest blocks are
scrubbed first ensuring an optimal <br>
check. If instead you want to scrub the just synced blocks,
not yet scrubbed, you should use the &quot;-p new&quot;
option.</p>

<p style="margin-top: 1em">To get the details of the scrub
status use the &quot;status&quot; command.</p>

<p style="margin-top: 1em">For any silent or input/output
error found the corresponding blocks are marked as bad in
the &quot;content&quot; file. These bad blocks are listed in
&quot;status&quot;, and can be fixed with &quot;fix <br>
-e&quot;. After the fix, at the next scrub they will be
rechecked, and if found corrected, the bad mark will be
removed. To scrub only the bad blocks, you can use the
&quot;scrub -p bad&quot; <br>
command.</p>

<p style="margin-top: 1em">It&Acirc;&acute;s recommended to
run &quot;scrub&quot; only on a synced array, to avoid to
have reported error caused by unsynced data. These errors
are recognized as not being silent errors, and the <br>
blocks are not marked as bad, but such errors are reported
in the output of the command.</p>

<p style="margin-top: 1em">Files are identified only by
path, and not by inode.</p>

<p style="margin-top: 1em">The &quot;content&quot; file is
modified to update the time of the last check of each block,
and to mark bad blocks. The &quot;parity&quot; files are NOT
modified. The files in the array are NOT <br>
modified.</p>

<p style="margin-top: 1em">fix <br>
Fix all the files and the parity data.</p>

<p style="margin-top: 1em">All the files and the parity
data are compared with the snapshot state saved in the last
&quot;sync&quot;. If a difference is found,
it&Acirc;&acute;s reverted to the stored snapshot.</p>

<p style="margin-top: 1em">The &quot;fix&quot; command
doesn&Acirc;&acute;t differentiate between errors and
intentional modifications. It unconditionally reverts the
file state at the last &quot;sync&quot;.</p>

<p style="margin-top: 1em">If no other option is specified
the full array is processed. Use the filter options to
select a subset of files or disks to operate on.</p>

<p style="margin-top: 1em">To only fix the blocks marked
bad during &quot;sync&quot; and &quot;scrub&quot;, use the
-e, --filter-error option. As difference from other filter
options, with this one the fixes are applied only <br>
to files that are not modified from the the latest
&quot;sync&quot;.</p>

<p style="margin-top: 1em">All the files that cannot be
fixed are renamed adding the &quot;.unrecoverable&quot;
extension.</p>

<p style="margin-top: 1em">Before fixing, the full array is
scanned to find any moved file, after the last
&quot;sync&quot; operation. These files are identified by
their time-stamp, ignoring their name and direc&acirc; <br>
tory, and are used in the recovering process if necessary.
If you moved some of them outside the array, you can use the
-i, --import option to specify additional directories to
<br>
scan.</p>

<p style="margin-top: 1em">Files are identified only by
path, and not by inode.</p>

<p style="margin-top: 1em">The &quot;content&quot; file is
NOT modified. The &quot;parity&quot; files are modified if
necessary. The files in the array are modified if
necessary.</p>

<p style="margin-top: 1em">check <br>
Verify all the files and the parity data.</p>

<p style="margin-top: 1em">It works like &quot;fix&quot;,
but it only simulates a recovery and no change is written in
the array.</p>

<p style="margin-top: 1em">This command is mostly intended
for manual verifications, like after a recovery process or
in other special conditions. For periodic and scheduled
checks uses &quot;scrub&quot;.</p>

<p style="margin-top: 1em">If you use the -a, --audit-only
option, only the file data is checked, and the parity data
is ignored for a faster run.</p>

<p style="margin-top: 1em">Files are identified only by
path, and not by inode.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">list <br>
Lists all the files contained in the array at the time of
the last &quot;sync&quot;.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">dup <br>
Lists all the duplicate files. Two files are assumed equal
if their hashes are matching. The file data is not read, but
only the precomputed hashes are used.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">up <br>
Spins up all the disks of the array.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">down <br>
Spins down all the disks of the array.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">pool <br>
Creates or updates in the &quot;pooling&quot; directory a
virtual view of all the files of your disk array.</p>

<p style="margin-top: 1em">The files are not really copied
here, but just linked using symbolic links.</p>

<p style="margin-top: 1em">When updating, all the present
symbolic links and empty subdirectories are deleted and
replaced with the new view of the array. Any other regular
file is left in place.</p>

<p style="margin-top: 1em">Nothing is modified outside the
pool directory.</p>

<p style="margin-top: 1em">devices <br>
Prints the low level devices used by the array.</p>

<p style="margin-top: 1em">This command prints the devices
associations in place in the array, and it&Acirc;&acute;s
mainly intended as a script interface.</p>

<p style="margin-top: 1em">The first two columns are the
low level device id and path. The next two columns are the
high level device id and path. The latest column if the disk
name in the array.</p>

<p style="margin-top: 1em">In most cases you have one low
level device for each disk in the array, but in some more
complex configurations, you may have multiple low level
devices used by a single disk in <br>
the array.</p>

<p style="margin-top: 1em">Nothing is modified.</p>

<p style="margin-top: 1em">touch <br>
Sets arbitrarely the sub-second timestamp of all the files
that have it at zero.</p>

<p style="margin-top: 1em">This improves the SnapRAID
capability to recognize moved and copied files as it makes
the timestamp almost unique, removing possible
duplicates.</p>

<p style="margin-top: 1em">More specifically, if the
sub-second timestamp is not zero, a moved or copied file is
identified as such if it matches the name, size and
timestamp. If instead the sub-second <br>
timestamp is zero, it&Acirc;&acute;s cosidered a copy only
if it matches the full path, size and timestamp.</p>

<p style="margin-top: 1em">Note that the second precision
timestamp is not modified, and all the dates and times of
your files will be maintained.</p>

<p style="margin-top: 1em">rehash <br>
Schedules a rehash of the whole array.</p>

<p style="margin-top: 1em">This command changes the hash
kind used, typically when upgrading from a 32 bits system to
a 64 bits one, to switch from MurmurHash3 to the faster
SpookyHash.</p>

<p style="margin-top: 1em">If you are already using the
optimal hash, this command does nothing and tells you that
nothing has to be done.</p>

<p style="margin-top: 1em">The rehash isn&Acirc;&acute;t
done immediately, but it takes place progressively during
&quot;sync&quot; and &quot;scrub&quot;.</p>

<p style="margin-top: 1em">You can get the rehash state
using &quot;status&quot;.</p>

<p style="margin-top: 1em">During the rehash, SnapRAID
maintains full functionality, with the only exception of
&quot;dup&quot; not able to detect duplicated files using a
different hash.</p>

<p style="margin-top: 1em">OPTIONS <br>
SnapRAID provides the following options:</p>

<p style="margin-top: 1em">-c, --conf CONFIG <br>
Selects the configuration file. If not specified
it&Acirc;&acute;s assumed the file
&quot;/etc/snapraid.conf&quot; in Unix, and
&quot;snapraid.conf&quot; in the current directory in
Windows.</p>

<p style="margin-top: 1em">-f, --filter PATTERN <br>
Filters the files to process in &quot;check&quot; and
&quot;fix&quot;. Only the files matching the entered pattern
are processed. This option can be used many times. See the
PATTERN sec&acirc; <br>
tion for more details in the pattern specifications. In
Unix, ensure to quote globbing chars if used. This option
can be used only with &quot;check&quot; and &quot;fix&quot;.
Note that it <br>
cannot be used with &quot;sync&quot; and &quot;scrub&quot;,
because they always process the whole array.</p>

<p style="margin-top: 1em">-d, --filter-disk NAME <br>
Filters the disks to process in &quot;check&quot;,
&quot;fix&quot;, &quot;up&quot; and &quot;down&quot;. You
must specify a disk name as named in the configuration file.
You can also specify parity disks with <br>
the names: &quot;parity&quot;, &quot;2-parity&quot;,
&quot;3-parity&quot;, ... to limit the operations a specific
parity disk. If you combine more --filter, --filter-disk and
--filter-missing options, <br>
only files matching all the set of filters are selected.
This option can be used many times. This option can be used
only with &quot;check&quot;, &quot;fix&quot;, &quot;up&quot;
and &quot;down&quot;. Note <br>
that it cannot be used with &quot;sync&quot; and
&quot;scrub&quot;, because they always process the whole
array.</p>

<p style="margin-top: 1em">-m, --filter-missing <br>
Filters the files to process in &quot;check&quot; and
&quot;fix&quot;. Only the files missing/deleted from the
array are processed. When used with &quot;fix&quot;, this is
a kind of &quot;undelete&quot; com&acirc; <br>
mand. If you combine more --filter, --filter-disk and
--filter-missing options, only files matching all the set of
filters are selected. This option can be used only <br>
with &quot;check&quot; and &quot;fix&quot;. Note that it
cannot be used with &quot;sync&quot; and &quot;scrub&quot;,
because they always process the whole array.</p>

<p style="margin-top: 1em">-e, --filter-error <br>
Filters the blocks to process in &quot;check&quot; and
&quot;fix&quot;. It processes only the blocks marked with
silent or input/output errors during &quot;sync&quot; and
&quot;scrub&quot;, and listed in &quot;sta&acirc; <br>
tus&quot;. This option can be used only with
&quot;check&quot; and &quot;fix&quot;.</p>

<p style="margin-top: 1em">-p, --plan PERC|bad|new|full
<br>
Selects the scrub plan. If PERC is a numeric value from 0 to
100, it&Acirc;&acute;s interpreted as the percentage of
blocks to scrub. Instead of a percentage, you can also
specify a <br>
plan: &quot;bad&quot; scrubs bad blocks, &quot;new&quot; the
blocks not yet scrubbed, and &quot;full&quot; for
everything. This option can be used only with
&quot;scrub&quot;.</p>

<p style="margin-top: 1em">-o, --older-than DAYS <br>
Selects the older the part of the array to process in
&quot;scrub&quot;. DAYS is the minimum age in days for a
block to be scrubbed, default is 10. Blocks marked as bad
are always <br>
scrubbed despite this option. This option can be used only
with &quot;scrub&quot;.</p>

<p style="margin-top: 1em">-a, --audit-only <br>
In &quot;check&quot; verifies the hash of the files without
doing any kind of check on the parity data. If you are
interested in checking only the file data this option can
speedup <br>
a lot the checking process. This option can be used only
with &quot;check&quot;.</p>

<p style="margin-top: 1em">-h, --pre-hash <br>
In &quot;sync&quot; runs a preliminary hashing phase of all
the new data to have an additional verification before the
parity computation. Usually in &quot;sync&quot; no
preliminary hashing <br>
is done, and the new data is hashed just before the parity
computation when it&Acirc;&acute;s read for the first time.
Unfortunately, this process happens when the system is under
<br>
heavy load, with all disks spinning and with a busy CPU.
This is an extreme condition for the machine, and if it has
a latent hardware problem, it&Acirc;&acute;s possible to
encounter <br>
silent errors what cannot be detected because the data is
not yet hashed. To avoid this risk, you can enable the
&quot;pre-hash&quot; mode and have all the data read two
times to <br>
ensure its integrity. This option also verifies the files
moved inside the array, to ensure that the move operation
went successfully, and in case to block the sync and <br>
to allow to run a fix operation. This option can be used
only with &quot;sync&quot;.</p>

<p style="margin-top: 1em">-i, --import DIR <br>
Imports from the specified directory any file that you
deleted from the array after the last &quot;sync&quot;. If
you still have such files, they could be used by
&quot;check&quot; and &quot;fix&quot; <br>
to improve the recover process. The files are read also in
subdirectories and they are identified regardless of their
name. This option can be used only with &quot;check&quot;
and <br>
&quot;fix&quot;.</p>

<p style="margin-top: 1em">-Z, --force-zero <br>
Forces the insecure operation of syncing a file with zero
size that before was not. If SnapRAID detects a such
condition, it stops proceeding unless you specify this <br>
option. This allows to easily detect when after a system
crash, some accessed files were truncated. This is a
possible condition in Linux with the ext3/ext4
file-sys&acirc; <br>
tems. This option can be used only with
&quot;sync&quot;.</p>

<p style="margin-top: 1em">-E, --force-empty <br>
Forces the insecure operation of syncing a disk with all the
original files missing. If SnapRAID detects that all the
files originally present in the disk are missing or <br>
rewritten, it stops proceeding unless you specify this
option. This allows to easily detect when a data file-system
is not mounted. This option can be used only with <br>
&quot;sync&quot;.</p>

<p style="margin-top: 1em">-U, --force-uuid <br>
Forces the insecure operation of syncing, checking and
fixing with disks that have changed their UUID. If SnapRAID
detects that some disks have changed UUID, it stops <br>
proceeding unless you specify this option. This allows to
detect when your disks are mounted in the wrong mount
points. It&Acirc;&acute;s anyway allowed to have a single
UUID change <br>
with single parity, and more with multiple parity, because
it&Acirc;&acute;s the normal case of replacing disks after a
recovery. This option can be used only with
&quot;sync&quot;, &quot;check&quot; or <br>
&quot;fix&quot;.</p>

<p style="margin-top: 1em">-D, --force-device <br>
Forces the insecure operation of fixing with inaccessible
disks, or with disks on the same physical device. Like if
you lost two data disks, and you have a spare disk to <br>
recover only the first one, and you want to ignore the
second inaccessible disk. Or if you want to recover a disk
in the free space left in an already used disk, sharing <br>
the same physical device. This option can be used only with
&quot;fix&quot;.</p>

<p style="margin-top: 1em">-N, --force-nocopy <br>
In &quot;sync&quot;, &quot;check and &quot;fix&quot;,
disables the copy detection heuristic. Without this option
SnapRAID assumes that files with same attributes, like name,
size and time-stamp <br>
are copies with the same data. This allows to identify
copied or moved files from one disk to another, and to reuse
the already computed hash information to detect silent <br>
errors or to recover missing files. This behavior, in some
rare cases, may result in false positives, or in a slow
process due the many hash verifications, and this <br>
option allows to resolve them. This option can be used only
with &quot;sync&quot;, &quot;check&quot; and
&quot;fix&quot;.</p>

<p style="margin-top: 1em">-F, --force-full <br>
In &quot;sync&quot; forces a full rebuild of the parity.
This option can be used when you reverted back to an old
content file, but using a more recent parity data. Instead
of <br>
recomputing the parity from scratch, this allows to reuse
the hashes present in the content file to validate data, and
to maintain data protection during the &quot;sync&quot; <br>
process using the old content file and the parity data you
have. This option can be used only with
&quot;sync&quot;.</p>

<p style="margin-top: 1em">-l, --log FILE <br>
Write a detailed log in the specified file. If this option
is not specified, unexpected errors are printed on the
screen, likely resulting in too much output in case of <br>
many errors. When -l, --log is specified, on the screen, go
only fatal errors that makes SnapRAID to stop progress. If
the path starts with &Acirc;&acute;&gt;&gt;&Acirc;&acute;
the file is opened in <br>
append mode. Occurrences of &Acirc;&acute;%D&Acirc;&acute;
and &Acirc;&acute;%T&Acirc;&acute; in the name are replaced
with the date and time in the format YYYYMMDD and HHMMSS.
Note that in Windows batch files, you&Acirc;&acute;ll have
<br>
to double the &Acirc;&acute;%&Acirc;&acute; char, like
result-%%D.log. And to use
&Acirc;&acute;&gt;&gt;&Acirc;&acute; you&Acirc;&acute;ll
have to enclose the name in &quot;, like
&quot;&gt;&gt;result.log&quot;. To output the log to
standard output or standard <br>
error, you can use respectively &quot;&gt;&amp;1&quot; and
&quot;&gt;&amp;2&quot;.</p>

<p style="margin-top: 1em">-L, --error-limit <br>
Sets a new error limit before stopping execution. By default
SnapRAID stops if it encounters more than 100 Input/Output
errors, meaning that likely a disk is going to <br>
die. This options affects &quot;sync&quot; and
&quot;scrub&quot;, that are allowed to continue after the
first bunch of disk errors, to try to complete at most their
operations. Instead, <br>
&quot;check&quot; and &quot;fix&quot; always stop at the
first error.</p>

<p style="margin-top: 1em">-S, --start BLKSTART <br>
Starts the processing from the specified block number. It
could be useful to retry to check or fix some specific
block, in case of a damaged disk. It&Acirc;&acute;s present
mainly for <br>
advanced manual recovering.</p>

<p style="margin-top: 1em">-B, --count BLKCOUNT <br>
Processes only the specified number of blocks.
It&Acirc;&acute;s present mainly for advanced manual
recovering.</p>

<p style="margin-top: 1em">-C, --gen-conf CONTENT_FILE <br>
Generates a dummy configuration file from an existing
content file. The configuration file is written in the
standard output, and it doesn&Acirc;&acute;t overwrite an
existing one. <br>
This configuration file also contains the information needed
to reconstruct the disk mount points, in case you lose the
entire system.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Prints more information on the screen. If specified one
time, it prints excluded files and more stats. This option
has no effect on the log files.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Prints less information on the screen. If specified one
time, removes the progress bar, if two times, the running
operations, three times, the info messages, four times <br>
the status messages. Fatal errors are always printed on the
screen. This option has no effect on the log files.</p>

<p style="margin-top: 1em">-H, --help <br>
Prints a short help screen.</p>

<p style="margin-top: 1em">-V, --version <br>
Prints the program version.</p>

<p style="margin-top: 1em">CONFIGURATION <br>
SnapRAID requires a configuration file to know where your
disk array is located, and where storing the parity
information.</p>

<p style="margin-top: 1em">This configuration file is
located in /etc/snapraid.conf in Unix or in the execution
directory in Windows.</p>

<p style="margin-top: 1em">It should contain the following
options (case sensitive):</p>

<p style="margin-top: 1em">parity FILE <br>
Defines the file to use to store the parity information. The
parity enables the protection from a single disk failure,
like RAID5.</p>

<p style="margin-top: 1em">It must be placed in a disk
dedicated for this purpose with as much free space as the
biggest disk in the array. Leaving the parity disk reserved
for only this file ensures that <br>
it doesn&Acirc;&acute;t get fragmented, improving the
performance.</p>

<p style="margin-top: 1em">This option is mandatory and it
can be used only one time.</p>

<p style="margin-top: 1em">[2,3,4,5,6]-parity FILE <br>
Defines the files to use to store extra parity information.
For each parity file specified, one additional level of
protection is enabled: <br>
&Acirc;&middot; 2-parity enables RAID6 double parity. <br>
&Acirc;&middot; 3-parity enables triple parity <br>
&Acirc;&middot; 4-parity enables quad parity <br>
&Acirc;&middot; 5-parity enables penta (five) parity <br>
&Acirc;&middot; 6-parity enables hexa (six) parity</p>

<p style="margin-top: 1em">Each parity level requires also
all the files of the previous levels.</p>

<p style="margin-top: 1em">Each file must be placed in a
disk dedicated for this purpose with as much free space as
the biggest disk in the array. Leaving the parity disks
reserved for only these files <br>
ensures that they doesn&Acirc;&acute;t get fragmented,
improving the performance.</p>

<p style="margin-top: 1em">These options are optional and
they can be used only one time.</p>

<p style="margin-top: 1em">z-parity FILE <br>
Defines an alternate file and format to store the triple
parity.</p>

<p style="margin-top: 1em">This option is an alternative at
&Acirc;&acute;3-parity&Acirc;&acute; mainly intended for
low-end CPUs like ARM or AMD Phenom, Athlon and Opteron that
don&Acirc;&acute;t support the SSSE3 instructions set, and
in such <br>
case it provides a better performance.</p>

<p style="margin-top: 1em">This format is similar, but
faster, at the one used by the ZFS RAIDZ3, but it
doesn&Acirc;&acute;t work beyond triple parity.</p>

<p style="margin-top: 1em">When using
&Acirc;&acute;3-parity&Acirc;&acute; you will be warned if
it&Acirc;&acute;s recommended to use the
&Acirc;&acute;z-parity&Acirc;&acute; format for a
performance improvement.</p>

<p style="margin-top: 1em">It&Acirc;&acute;s possible to
convert from one format to another, adjusting the
configuration file with the wanted z-parity or 3-parity
file, and using &Acirc;&acute;fix&Acirc;&acute; to recreate
it.</p>

<p style="margin-top: 1em">content FILE <br>
Defines the file to use to store the list and check-sums of
all the files present in your disk array.</p>

<p style="margin-top: 1em">It can be placed in the disk
used to store data, parity, or any other disk available. If
you use a data disk, this file is automatically excluded
from the &quot;sync&quot; process.</p>

<p style="margin-top: 1em">This option is mandatory and it
can be used more times to save more copies of the same
files.</p>

<p style="margin-top: 1em">You have to store at least one
copy for each parity disk used plus one. Using some more
doesn&Acirc;&acute;t hurt.</p>

<p style="margin-top: 1em">data NAME DIR <br>
Defines the name and the mount point of the data disks of
the array. NAME is used to identify the disk, and it must be
unique. DIR is the mount point of the disk in the
file-sys&acirc; <br>
tem.</p>

<p style="margin-top: 1em">You can change the mount point
as you like, as long you keep the NAME fixed.</p>

<p style="margin-top: 1em">You should use one option for
each data disk of the array.</p>

<p style="margin-top: 1em">You can rename later a disk,
changing the NAME directly in the configuration file, and
then run a &Acirc;&acute;sync&Acirc;&acute; command. In the
rename case, the association is done using the stored <br>
UUID of the disks.</p>

<p style="margin-top: 1em">nohidden <br>
Excludes all the hidden files and directory. In Unix hidden
files are the ones starting with &quot;.&quot;. In Windows
they are the ones with the hidden attribute.</p>

<p style="margin-top: 1em">exclude/include PATTERN <br>
Defines the file or directory patterns to exclude and
include in the sync process. All the patterns are processed
in the specified order.</p>

<p style="margin-top: 1em">If the first pattern that
matches is an &quot;exclude&quot; one, the file is excluded.
If it&Acirc;&acute;s an &quot;include&quot; one, the file is
included. If no pattern matches, the file is excluded if the
<br>
last pattern specified is an &quot;include&quot;, or
included if the last pattern specified is an
&quot;exclude&quot;.</p>

<p style="margin-top: 1em">See the PATTERN section for more
details in the pattern specifications.</p>

<p style="margin-top: 1em">This option can be used many
times.</p>

<p style="margin-top: 1em">blocksize SIZE_IN_KIBIBYTES <br>
Defines the basic block size in kibi bytes of the parity.
One kibi bytes is 1024 bytes. The default blocksize is 256
and it should work for most cases.</p>

<p style="margin-top: 1em">A reason to use a different
blocksize is if your system has less than 4 GiB of memory.
As a rule of thumb, with 4 GiB or more memory use the
default 256, with 2 GiB use 512, and <br>
with 1 GiB use 1024.</p>

<p style="margin-top: 1em">In more details SnapRAID
requires about TS*17/BS bytes of RAM memory. Where TS is the
total size in bytes of your disk array, and BS is the block
size in bytes.</p>

<p style="margin-top: 1em">For example with 8 disks of 4 TB
and a block size of 256 KiB (1 KiB = 1024 bytes) you
have:</p>

<p style="margin-top: 1em">RAM = (8 * 4 * 10^12) * 17 /
(256 * 2^10) = 1.9 GiB <br>
Another reason to use a different blocksize is if you have a
lot of small files. In the order of many millions.</p>

<p style="margin-top: 1em">For each file, even of few
bytes, a whole block of parity is allocated, and with many
files this may result in a lot of unused parity space. And
when you completely fill the <br>
parity disk, you are not allowed to add more files in the
data disks. Anyway, the wasted parity doesn&Acirc;&acute;t
sum between data disks. Wasted space resulting from a high
number of <br>
files in a data disk, limits only the amount of data in such
data disk and not in others.</p>

<p style="margin-top: 1em">As approximation, you can assume
that half of the block size is wasted for each file. For
example, with 100000 files and a 256 KiB block size, you are
going to waste 13 GB of <br>
parity, that may result in 13 GB less space available in the
data disk.</p>

<p style="margin-top: 1em">You can get the amount of wasted
space in each disk using &quot;status&quot;. This is the
amount of space that you must leave free in the data disks,
or use for files not included in the <br>
array. If this value is negative, it means that your are
near to fill the parity, and it represents the space you can
still waste.</p>

<p style="margin-top: 1em">To avoid the problem, you can
use a bigger partition for parity. For example, if you have
the parity partition bigger than 13 GB than data disks, you
have enough extra space to <br>
handle up to 100000 files in each data disk.</p>

<p style="margin-top: 1em">A trick to get a bigger parity
partition in Linux, is to format it with the command:</p>

<p style="margin-top: 1em">mkfs.ext4 -m 0 -T largefile4
DEVICE <br>
This results in about 1.5% of extra space. Meaning about 60
GB for a 4 TB disk, that allows about 460000 files in each
data disk without any wasted space.</p>

<p style="margin-top: 1em">autosave SIZE_IN_GIGABYTES <br>
Automatically save the state when syncing or scrubbing after
the specified amount of GB processed. This option is useful
to avoid to restart from scratch long &quot;sync&quot;
commands <br>
interrupted by a machine crash, or any other event that may
interrupt SnapRAID.</p>

<p style="margin-top: 1em">pool DIR <br>
Defines the pooling directory where the virtual view of the
disk array is created using the &quot;pool&quot;
command.</p>

<p style="margin-top: 1em">The directory must already
exist.</p>

<p style="margin-top: 1em">share UNC_DIR <br>
Defines the Windows UNC path required to access the disks
remotely.</p>

<p style="margin-top: 1em">If this option is specified, the
symbolic links created in the pool directory use this UNC
path to access the disks. Without this option the symbolic
links generated use only <br>
local paths, not allowing to share the pool directory in the
network.</p>

<p style="margin-top: 1em">The symbolic links are formed
using the specified UNC path, adding the disk name as
specified in the &quot;disk&quot; option, and finally adding
the file dir and name.</p>

<p style="margin-top: 1em">This option is only required for
Windows.</p>

<p style="margin-top: 1em">smartctl DISK/PARITY OPTIONS...
<br>
Defines a custom smartctl command to obtain the SMART
attributes for each disk. This may be required for RAID
controllers and for some USB disk that cannot be
auto-detected.</p>

<p style="margin-top: 1em">DISK is the same disk name
specified in the &quot;disk&quot; option. PARITY is one of
the parity name as
&quot;parity,[1,2,3,4,5,6,z]-parity&quot;.</p>

<p style="margin-top: 1em">In the specified OPTIONS, the
&quot;%s&quot; string is replaced by the device name. Note
that in case of RAID controllers the device is likely fixed,
and you don&Acirc;&acute;t have to use &quot;%s&quot;.</p>

<p style="margin-top: 1em">Refers at the smartmontools
documentation about the possible options:</p>


<p style="margin-top: 1em">https://www.smartmontools.org/wiki/Supported_RAID-Controllers
<br>
https://www.smartmontools.org/wiki/Supported_USB-Devices
<br>
Examples <br>
An example of a typical configuration for Unix is:</p>

<p style="margin-top: 1em">parity
/mnt/diskp/snapraid.parity <br>
content /mnt/diskp/snapraid.content <br>
content /var/snapraid/snapraid.content <br>
data d1 /mnt/disk1/ <br>
data d2 /mnt/disk2/ <br>
data d3 /mnt/disk3/ <br>
exclude /lost+found/ <br>
exclude /tmp/ <br>
smartctl d1 -d sat %s <br>
smartctl d2 -d usbjmicron %s <br>
smartctl parity -d areca,1/1 /dev/sg0 <br>
smartctl 2-parity -d areca,2/1 /dev/sg0 <br>
An example of a typical configuration for Windows is:</p>

<p style="margin-top: 1em">parity E:praid.parity <br>
content E:praid.content <br>
content C:praidpraid.content <br>
data d1 G:rray data d2 H:rray data d3 I:rray exclude
Thumbs.db <br>
exclude ECYCLE.BIN <br>
exclude tem Volume Information <br>
smartctl d1 -d sat %s <br>
smartctl d2 -d usbjmicron %s <br>
smartctl parity -d areca,1/1 /dev/arcmsr0 <br>
smartctl 2-parity -d areca,2/1 /dev/arcmsr0 PATTERN <br>
Patterns are used to select a subset of files to exclude or
include in the process.</p>

<p style="margin-top: 1em">There are four different types
of patterns:</p>

<p style="margin-top: 1em">FILE Selects any file named as
FILE. You can use any globbing character like * and ?. This
pattern is applied only to files and not to directories.</p>

<p style="margin-top: 1em">DIR/ Selects any directory named
DIR and everything inside. You can use any globbing
character like * and ?. This pattern is applied only to
directories and not to files.</p>

<p style="margin-top: 1em">/PATH/FILE <br>
Selects the exact specified file path. You can use any
globbing character like * and ? but they never match a
directory slash. This pattern is applied only to files and
<br>
not to directories.</p>

<p style="margin-top: 1em">/PATH/DIR/ <br>
Selects the exact specified directory path and everything
inside. You can use any globbing character like * and ? but
they never match a directory slash. This pattern is <br>
applied only to directories and not to files.</p>

<p style="margin-top: 1em">Note that when you specify an
absolute path starting with /, it&Acirc;&acute;s applied at
the array root dir and not at the local file-system root
dir.</p>

<p style="margin-top: 1em">In Windows you can use the
backslash &nbsp;instead of the forward slash /. Note that
Windows system directories, junctions, mount points, and any
other Windows special directory are <br>
treated just as files, meaning that to exclude them you must
use a file rule, and not a directory one.</p>

<p style="margin-top: 1em">In the configuration file, you
can use different strategies to filter the files to process.
The simplest one is to use only &quot;exclude&quot; rules to
remove all the files and directo&acirc; <br>
ries you do not want to process. For example:</p>

<p style="margin-top: 1em"># Excludes any file named
&quot;*.unrecoverable&quot; <br>
exclude *.unrecoverable <br>
# Excludes the root directory &quot;/lost+found&quot; <br>
exclude /lost+found/ <br>
# Excludes any sub-directory named &quot;tmp&quot; <br>
exclude tmp/ <br>
The opposite way is to define only the file you want to
process, using only &quot;include&quot; rules. For
example:</p>

<p style="margin-top: 1em"># Includes only some directories
<br>
include /movies/ <br>
include /musics/ <br>
include /pictures/ <br>
The final way, is to mix &quot;exclude&quot; and
&quot;include&quot; rules. In this case take care that the
order of rules is important. Previous rules have the
precedence over the later ones. To <br>
get things simpler you can first have all the
&quot;exclude&quot; rules and then all the
&quot;include&quot; ones. For example:</p>

<p style="margin-top: 1em"># Excludes any file named
&quot;*.unrecoverable&quot; <br>
exclude *.unrecoverable <br>
# Excludes any sub-directory named &quot;tmp&quot; <br>
exclude tmp/ <br>
# Includes only some directories <br>
include /movies/ <br>
include /musics/ <br>
include /pictures/ <br>
On the command line, using the -f option, you can only use
&quot;include&quot; patterns. For example:</p>

<p style="margin-top: 1em"># Checks only the .mp3 files.
<br>
# Note the &quot;&quot; use to avoid globbing expansion by
the shell in Unix. <br>
snapraid -f &quot;*.mp3&quot; check <br>
In Unix, when using globbing chars in the command line, you
have to quote them. Otherwise the shell will try to expand
them.</p>

<p style="margin-top: 1em">CONTENT <br>
SnapRAID stores the list and check-sums of your files in the
content file.</p>

<p style="margin-top: 1em">It&Acirc;&acute;s a binary file,
listing all the files present in your disk array, with all
the check-sums to verify their integrity.</p>

<p style="margin-top: 1em">This file is read and written by
the &quot;sync&quot; and &quot;scrub&quot; commands, and
read by &quot;fix&quot;, &quot;check&quot; and
&quot;status&quot;.</p>

<p style="margin-top: 1em">PARITY <br>
SnapRAID stores the parity information of your array in the
parity files.</p>

<p style="margin-top: 1em">They are binary files,
containing the computed parity of all the blocks defined in
the &quot;content&quot; file.</p>

<p style="margin-top: 1em">These files are read and written
by the &quot;sync&quot; and &quot;fix&quot; commands, and
only read by &quot;scrub&quot; and &quot;check&quot;.</p>

<p style="margin-top: 1em">ENCODING <br>
SnapRAID in Unix ignores any encoding. It reads and stores
the file names with the same encoding used by the
file-system.</p>

<p style="margin-top: 1em">In Windows all the names read
from the file-system are converted and processed in the
UTF-8 format.</p>

<p style="margin-top: 1em">To have the file names printed
correctly you have to set the Windows console in the UTF-8
mode, with the command &quot;chcp 65001&quot;, and use a
TrueType font like &quot;Lucida Console&quot; as <br>
console font. Note that it has effect only on the printed
file names, if you redirect the console output to a file,
the resulting file is always in the UTF-8 format.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
This file is Copyright (C) 2011 Andrea Mazzoleni</p>

<p style="margin-top: 1em">SEE ALSO <br>
rsync(1)</p>

<p style="margin-top: 1em">SnapRAID Backup For Disk
Arrays(1)</p>
<hr>
</body>
</html>
