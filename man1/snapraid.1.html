<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>SnapRAID Backup For Disk Arrays(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">SnapRAID Backup For Disk Arrays(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">SnapRAID Backup For Disk Arrays(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
snapraid - SnapRAID Backup For Disk Arrays
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
snapraid [-c, --conf CONFIG]
<div class="Pp"></div>
	[-f, --filter PATTERN] [-d, --filter-disk NAME]
<div class="Pp"></div>
	[-m, --filter-missing] [-e, --filter-error]
<div class="Pp"></div>
	[-a, --audit-only] [-h, --pre-hash] [-i, --import DIR]
<div class="Pp"></div>
	[-p, --plan PERC|bad|new|full]
<div class="Pp"></div>
	[-o, --older-than DAYS] [-l, --log FILE]
<div class="Pp"></div>
	[-Z, --force-zero] [-E, --force-empty]
<div class="Pp"></div>
	[-U, --force-uuid] [-D, --force-device]
<div class="Pp"></div>
	[-N, --force-nocopy] [-F, --force-full]
<div class="Pp"></div>
	[-S, --start BLKSTART] [-B, --count BLKCOUNT]
<div class="Pp"></div>
	[-L, --error-limit NUMBER]
<div class="Pp"></div>
	[-v, --verbose] [-q, --quiet]
<div class="Pp"></div>
	status|smart|up|down|diff|sync|scrub|fix|check|list|dup
<div class="Pp"></div>
	|up|down|pool|devices|touch|rehash
<div class="Pp"></div>
<div class="Pp"></div>
snapraid [-V, --version] [-H, --help] [-C, --gen-conf CONTENT]
<div class="Pp"></div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
SnapRAID is a backup program for disk arrays. It stores parity information of
  your data and it recovers from up to six disk failures.
<div class="Pp"></div>
SnapRAID is mainly targeted for a home media center, with a lot of big files
  that rarely change.
<div class="Pp"></div>
Beside the ability to recover from disk failures, other features of SnapRAID
  are:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">All your data is hashed to ensure data integrity and to
      avoid silent corruption.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the failed disks are too many to allow a recovery, you
      lose the data only on the failed disks. All the data in the other disks is
      safe.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If you accidentally delete some files in a disk, you can
      recover them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can start with already filled disks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The disks can have different sizes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can add disks at any time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">It doesn&#x00B4;t lock-in your data. You can stop using
      SnapRAID at any time without the need to reformat or move data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">To access a file, a single disk needs to spin, saving power
      and producing less noise.</dd>
</dl>
<div class="Pp"></div>
The official site of SnapRAID is:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">http://www.snapraid.it/
<div class="Pp"></div>
</div>
<h1 class="Sh" title="Sh" id="LIMITATIONS"><a class="selflink" href="#LIMITATIONS">LIMITATIONS</a></h1>
SnapRAID is in between a RAID and a Backup program trying to get the best
  benefits of them. Although it also has some limitations that you should
  consider before using it.
<div class="Pp"></div>
The main one is that if a disk fails, and you haven&#x00B4;t recently synced,
  you may be unable to do a complete recover. More specifically, you may be
  unable to recover up to the size of the amount of the changed or deleted files
  from the last sync operation. This happens even if the files changed or
  deleted are not in the failed disk. This is the reason because SnapRAID is
  better suited for data that rarely change.
<div class="Pp"></div>
Instead the new added files don&#x00B4;t prevent the recovering of the already
  existing files. You may only lose the just added files, if they are on the
  failed disk.
<div class="Pp"></div>
Other limitations are:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You have different file-systems for each disk. Using a RAID
      you have only a big file-system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">It doesn&#x00B4;t stripe data. With RAID you get a speed
      boost with striping.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">It doesn&#x00B4;t support real-time recovery. With RAID you
      do not have to stop working when a disk fails.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">It&#x00B4;s able to recover damages only from a limited
      number of disks. With a Backup you are able to recover from a complete
      failure of the whole disk array.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Only file, time-stamps, symlinks and hardlinks are saved.
      Permissions, ownership and extended attributes are not saved.</dd>
</dl>
<h1 class="Sh" title="Sh" id="GETTING_STARTED"><a class="selflink" href="#GETTING_STARTED">GETTING
  STARTED</a></h1>
To use SnapRAID you need to first select one disk of your disk array to dedicate
  at the &quot;parity&quot; information. With one disk for parity you will be
  able to recover from a single disk failure, like RAID5.
<div class="Pp"></div>
If you want to be able to recover from more disk failures, like RAID6, you must
  reserve additional disks for parity. Any additional parity disk allow to
  recover from one more disk failure.
<div class="Pp"></div>
As parity disks, you have to pick the biggest disks in the array, as the parity
  information may grow in size as the biggest data disk in the array.
<div class="Pp"></div>
These disks will be dedicated to store the &quot;parity&quot; files. You should
  not store your data in them.
<div class="Pp"></div>
Then you have to define the &quot;data&quot; disks that you want to protect with
  SnapRAID. The protection is more effective if these disks contain data that
  rarely change. For this reason it&#x00B4;s better to DO NOT include the
  Windows C:\ disk, or the Unix /home, /var and /tmp disks.
<div class="Pp"></div>
The list of files is saved in the &quot;content&quot; files, usually stored in
  the data, parity or boot disks. These files contain the details of your
  backup, with all the check-sums to verify its integrity. The
  &quot;content&quot; file is stored in multiple copies, and each one must be in
  a different disk, to ensure that in even in case of multiple disk failures at
  least one copy is available.
<div class="Pp"></div>
For example, suppose that you are interested only at one parity level of
  protection, and that your disks are present in:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">/mnt/diskp &lt;- selected disk for parity
<div class="Pp"></div>
/mnt/disk1 &lt;- first disk to protect
<div class="Pp"></div>
/mnt/disk2 &lt;- second disk to protect
<div class="Pp"></div>
/mnt/disk3 &lt;- third disk to protect
<div class="Pp"></div>
</div>
<div class="Pp"></div>
you have to create the configuration file /etc/snapraid.conf with the following
  options:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">parity /mnt/diskp/snapraid.parity
<div class="Pp"></div>
content /var/snapraid/snapraid.content
<div class="Pp"></div>
content /mnt/disk1/snapraid.content
<div class="Pp"></div>
content /mnt/disk2/snapraid.content
<div class="Pp"></div>
data d1 /mnt/disk1/
<div class="Pp"></div>
data d2 /mnt/disk2/
<div class="Pp"></div>
data d3 /mnt/disk3/
<div class="Pp"></div>
</div>
<div class="Pp"></div>
If you are in Windows, you should use the Windows path format, with drive
  letters and backslashes instead of slashes.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">parity E:\snapraid.parity
<div class="Pp"></div>
content C:\snapraid\snapraid.content
<div class="Pp"></div>
content F:\array\snapraid.content
<div class="Pp"></div>
content G:\array\snapraid.content
<div class="Pp"></div>
data d1 F:\array\
<div class="Pp"></div>
data d2 G:\array\
<div class="Pp"></div>
data d3 H:\array\
<div class="Pp"></div>
</div>
<div class="Pp"></div>
If you have many disks, and you run out of drive letters, you can mount disks
  directly in sub folders. See:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">https://www.google.com/search?q=Windows+mount+point
<div class="Pp"></div>
</div>
<div class="Pp"></div>
At this point you are ready to start the &quot;sync&quot; command to build the
  parity information.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid sync
<div class="Pp"></div>
</div>
<div class="Pp"></div>
This process may take some hours the first time, depending on the size of the
  data already present in the disks. If the disks are empty the process is
  immediate.
<div class="Pp"></div>
You can stop it at any time pressing Ctrl+C, and at the next run it will start
  where interrupted.
<div class="Pp"></div>
When this command completes, your data is SAFE.
<div class="Pp"></div>
Now you can start using your array as you like, and periodically update the
  parity information running the &quot;sync&quot; command.
<h2 class="Ss" title="Ss" id="Scrubbing"><a class="selflink" href="#Scrubbing">Scrubbing</a></h2>
To periodically check the data and parity for errors, you can run the
  &quot;scrub&quot; command.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid scrub
<div class="Pp"></div>
</div>
<div class="Pp"></div>
This command verifies the data in your array comparing it with the hash computed
  in the &quot;sync&quot; command.
<div class="Pp"></div>
Every run of the command checks about the 8% of the array, but not data already
  scrubbed in the previous 10 days. You can use the -p, --plan option to specify
  a different amount, and the -o, --older-than option to specify a different age
  in days. For example, to check 5% of the array older than 20 days use:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid -p 5 -o 20 scrub
<div class="Pp"></div>
</div>
<div class="Pp"></div>
If during the process, silent or input/output errors are found, the
  corresponding blocks are marked as bad in the &quot;content&quot; file, and
  listed in the &quot;status&quot; command.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid status
<div class="Pp"></div>
</div>
<div class="Pp"></div>
To fix them, you can use the &quot;fix&quot; command filtering for bad blocks
  with the -e, --filter-error options:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid -e fix
<div class="Pp"></div>
</div>
<div class="Pp"></div>
At the next &quot;scrub&quot; the errors will disappear from the
  &quot;status&quot; report if really fixed. To make it fast, you can use -p bad
  to scrub only blocks marked as bad.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid -p bad scrub
<div class="Pp"></div>
</div>
<div class="Pp"></div>
Take care that running &quot;scrub&quot; on a not synced array may result in
  errors caused by removed or modified files. These errors are reported in the
  &quot;scrub&quot; result, but related blocks are not marked as bad.
<h2 class="Ss" title="Ss" id="Pooling"><a class="selflink" href="#Pooling">Pooling</a></h2>
To have all the files in your array shown in the same directory tree, you can
  enable the &quot;pooling&quot; feature. It consists in creating a read-only
  virtual view of all the files in your array using symbolic links.
<div class="Pp"></div>
You can configure the &quot;pooling&quot; directory in the configuration file
  with:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">pool /pool
<div class="Pp"></div>
</div>
<div class="Pp"></div>
or, if you are in Windows, with:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">pool C:\pool
<div class="Pp"></div>
</div>
<div class="Pp"></div>
and then run the &quot;pool&quot; command to create or update the virtual view.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid pool
<div class="Pp"></div>
</div>
<div class="Pp"></div>
If you are using a Unix platform and you want to share such directory in the
  network to either Windows or Unix machines, you should add to your
  /etc/samba/smb.conf the following options:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;"># In the global section of smb.conf
<div class="Pp"></div>
unix extensions = no
<div class="Pp"></div>
</div>
<div class="Pp"></div>
<div style="margin-left: 4.00ex;"># In the share section of smb.conf
<div class="Pp"></div>
[pool]
<div class="Pp"></div>
comment = Pool
<div class="Pp"></div>
path = /pool
<div class="Pp"></div>
read only = yes
<div class="Pp"></div>
guest ok = yes
<div class="Pp"></div>
wide links = yes
<div class="Pp"></div>
follow symlinks = yes
<div class="Pp"></div>
</div>
<div class="Pp"></div>
In Windows the same sharing operation is not so straightforward, because Windows
  shares the symbolic links as they are, and that requires the network clients
  to resolve them remotely.
<div class="Pp"></div>
To make it working, besides sharing in the network the pool directory, you must
  also share all the disks independently, using as share points the disk names
  as defined in the configuration file. You must also specify in the
  &quot;share&quot; option of the configure file, the Windows UNC path that
  remote clients needs to use to access such shared disks.
<div class="Pp"></div>
For example, operating from a server named &quot;darkstar&quot;, you can use the
  options:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">data d1 F:\array\
<div class="Pp"></div>
data d2 G:\array\
<div class="Pp"></div>
data d3 H:\array\
<div class="Pp"></div>
pool C:\pool
<div class="Pp"></div>
share \\darkstar
<div class="Pp"></div>
</div>
<div class="Pp"></div>
and share the following dirs in the network:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">\\darkstar\pool -&gt; C:\pool
<div class="Pp"></div>
\\darkstar\d1 -&gt; F:\array
<div class="Pp"></div>
\\darkstar\d2 -&gt; G:\array
<div class="Pp"></div>
\\darkstar\d3 -&gt; H:\array
<div class="Pp"></div>
</div>
<div class="Pp"></div>
to allow remote clients to access all the files at \\darkstar\\pool.
<div class="Pp"></div>
You may also need to configure remote clients enablinh access at remote symlinks
  with the command:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">fsutil behavior set SymlinkEvaluation L2L:1
  R2R:1 L2R:1 R2L:1
<div class="Pp"></div>
</div>
<h2 class="Ss" title="Ss" id="Undeleting"><a class="selflink" href="#Undeleting">Undeleting</a></h2>
SnapRAID is more like a backup program than a RAID system, and it can be used to
  restore or undelete files to their previous state using the -f, --filter
  option :
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid fix -f FILE
<div class="Pp"></div>
</div>
<div class="Pp"></div>
or for a directory:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid fix -f DIR/
<div class="Pp"></div>
</div>
<div class="Pp"></div>
You can also use it to recover only accidentally deleted files inside a
  directory using the -m, --filter-missing option, that restores only missing
  files, leaving untouched all the others.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid fix -m -f DIR/
<div class="Pp"></div>
</div>
<div class="Pp"></div>
Or to recover all the deleted files in all the drives with:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid fix -m
<div class="Pp"></div>
</div>
<h2 class="Ss" title="Ss" id="Recovering"><a class="selflink" href="#Recovering">Recovering</a></h2>
The worst happened, and you lost a disk!
<div class="Pp"></div>
DO NOT PANIC! You will be able to recover it!
<div class="Pp"></div>
The first thing you have to do is to avoid further changes at you disk array.
  Disable any remote connection to it, any scheduled process, including any
  scheduled SnapRAID nightly sync or scrub.
<div class="Pp"></div>
Then proceed with the following steps.
<h2 class="Ss" title="Ss" id="STEP_1_-&gt;_Reconfigure"><a class="selflink" href="#STEP_1_-&gt;_Reconfigure">STEP
  1 -&gt; Reconfigure</a></h2>
You need some space to recover, even better if you already have an additional
  disk, but in case, also an external USB or remote disk is enough.
<div class="Pp"></div>
Change the SnapRAID configuration file to make the &quot;disk&quot; option of
  the failed disk to point to the place where you have enough empty space to
  recover the files.
<div class="Pp"></div>
For example, if you have that disk &quot;d1&quot; failed, you can change from:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">data d1 /mnt/disk1/
<div class="Pp"></div>
</div>
<div class="Pp"></div>
to:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">data d1 /mnt/new_spare_disk/
<div class="Pp"></div>
</div>
<h2 class="Ss" title="Ss" id="STEP_2_-&gt;_Fix"><a class="selflink" href="#STEP_2_-&gt;_Fix">STEP
  2 -&gt; Fix</a></h2>
Run the fix command, storing the log in an external file with:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid -d NAME -l fix.log fix
<div class="Pp"></div>
</div>
<div class="Pp"></div>
Where NAME is the name of the disk, like &quot;d1&quot; as in our previous
  example.
<div class="Pp"></div>
This command will take a long time.
<div class="Pp"></div>
Take care that you need also few gigabytes free to store the fix.log file. Run
  it from a disk with some free space.
<div class="Pp"></div>
Now you have recovered all the recoverable. If some file is partially or totally
  unrecoverable, it will be renamed adding the &quot;.unrecoverable&quot;
  extension.
<div class="Pp"></div>
You can get a detailed list of all the unrecoverable blocks in the fix.log file
  checking all the lines starting with &quot;unrecoverable:&quot;
<div class="Pp"></div>
If you are not satisfied of the recovering, you can retry it as many time you
  wish.
<div class="Pp"></div>
For example, if you have removed files from the array after the last
  &quot;sync&quot;, this may result in some other files not recovered. In this
  case, you can retry the &quot;fix&quot; using the -i, --import option,
  specifying where these files are now, to include them again in the recovering
  process.
<div class="Pp"></div>
If you are satisfied of the recovering, you can now proceed further, but take
  care that after syncing you cannot retry the &quot;fix&quot; command anymore!
<h2 class="Ss" title="Ss" id="STEP_3_-&gt;_Check"><a class="selflink" href="#STEP_3_-&gt;_Check">STEP
  3 -&gt; Check</a></h2>
As paranoid check, you can now run a &quot;check&quot; command to ensure that
  everything is OK on the recovered disk.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid -d NAME -a check
<div class="Pp"></div>
</div>
<div class="Pp"></div>
Where NAME is the name of the disk, like &quot;d1&quot; as in our previous
  example.
<div class="Pp"></div>
The options -d and -a tell SnapRAID to check only the specified disk, and ignore
  all the parity data.
<div class="Pp"></div>
This command will take a long time, but if you are not paranoid, you can skip
  it.
<h2 class="Ss" title="Ss" id="STEP_4_-&gt;_Sync"><a class="selflink" href="#STEP_4_-&gt;_Sync">STEP
  4 -&gt; Sync</a></h2>
Run the &quot;sync&quot; command to resynchronize the array with the new disk.
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">snapraid sync
<div class="Pp"></div>
</div>
<div class="Pp"></div>
If everything is recovered, this command is immediate.
<h1 class="Sh" title="Sh" id="COMMANDS"><a class="selflink" href="#COMMANDS">COMMANDS</a></h1>
SnapRAID provides a few simple commands that allow to:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Prints the status of the array -&gt;
    &quot;status&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Controls the disks -&gt; &quot;smart&quot;, &quot;up&quot;,
      &quot;down&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Makes a backup/snapshot -&gt; &quot;sync&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Periodically checks data -&gt; &quot;scrub&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Restore the last backup/snapshot -&gt;
    &quot;fix&quot;.</dd>
</dl>
<div class="Pp"></div>
Take care that the commands have to be written in lower case.
<h2 class="Ss" title="Ss" id="status"><a class="selflink" href="#status">status</a></h2>
Prints a summary of the state of the disk array.
<div class="Pp"></div>
It includes information about the parity fragmentation, how old are the blocks
  without checking, and all the recorded silent errors encountered while
  scrubbing.
<div class="Pp"></div>
Note that the information presented refers at the latest time you run
  &quot;sync&quot;. Later modifications are not taken into account.
<div class="Pp"></div>
If bad blocks were detected, their block numbers are listed. To fix them, you
  can use the &quot;fix -e&quot; command.
<div class="Pp"></div>
It also shows a graph representing the the last time each block was scrubbed or
  synced. Scrubbed blocks are shown with &#x00B4;*&#x00B4;, blocks synced but
  not yet scrubbed with &#x00B4;o&#x00B4;.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="smart"><a class="selflink" href="#smart">smart</a></h2>
Prints a SMART report of all the disks of the array.
<div class="Pp"></div>
It includes an estimation of the probability of failure in the next year
  allowing to plan maintenance replacements of the disks that show suspicious
  attributes.
<div class="Pp"></div>
This probability estimation obtained correlating the SMART attributes of the
  disks, with the Backblaze data available at:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">https://www.backblaze.com/hard-drive-test-data.html
<div class="Pp"></div>
</div>
<div class="Pp"></div>
If SMART reports that a disk is failing, &quot;FAIL&quot; or &quot;PREFAIL&quot;
  is printed for that disk, and SnapRAID returns with an error. In this case an
  immediate replacement of the disk is highly recommended.
<div class="Pp"></div>
Other possible strings are:
<div style="margin-left: 4.00ex;">
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>logfail</i>
  In the past some attributes were lower than the threshold.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>logerr</i>
  The device error log contains errors.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>selferr</i>
  The device self-test log contains errors.</div>
</div>
<div class="Pp"></div>
If the -v, --verbose option is specified a deeper statistical analysis is
  provided. This analysis can help you to decide if you need more or less
  parity.
<div class="Pp"></div>
This command uses the &quot;smartctl&quot; tool, and it&#x00B4;s equivalent to
  run &quot;smartctl -a&quot; on all the devices.
<div class="Pp"></div>
If your devices are not auto-detected correctly, you can configure a custom
  command using the &quot;smartctl&quot; option in the configuration file.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="up"><a class="selflink" href="#up">up</a></h2>
Spins up all the disks of the array.
<div class="Pp"></div>
You can spin-up only some specific disks using the -d, --filter-disk option.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="down"><a class="selflink" href="#down">down</a></h2>
Spins down all the disks of the array.
<div class="Pp"></div>
This command uses the &quot;smartctl&quot; tool, and it&#x00B4;s equivalent to
  run &quot;smartctl -s standby,now&quot; on all the devices.
<div class="Pp"></div>
You can spin-down only some specific disks using the -d, --filter-disk option.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="diff"><a class="selflink" href="#diff">diff</a></h2>
Lists all the files modified from the last &quot;sync&quot; that need to have
  their parity data recomputed.
<div class="Pp"></div>
This command doesn&#x00B4;t check the file data, but only the file time-stamp
  size and inode.
<div class="Pp"></div>
At the end of the command, you&#x00B4;ll get a summary of the file changes
  grouped by:
<div style="margin-left: 4.00ex;">
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>equal</i>
  Files equal at before.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>added</i>
  Files added that were not present before.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>removed</i>
  Files removed.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>updated</i>
  Files with a different size or time-stamp, meaning that they were
  modified.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>moved</i>
  Files moved to a different directory of the same disk. They are identified by
  having the same name, size, time-stamp and inode, but different
  directory.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>copied</i>
  Files copied in the same or different disk. Note that if in true they are
  moved to a different disk, you&#x00B4;ll also have them counted in
  &quot;removed&quot;. They are identified by having the same name, size, and
  time-stamp. But if the sub-second time-stamp is zero, then the full path
  should match, and not only the name.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 4.00ex; text-indent: -4.00ex;"><i>restored</i>
  Files with a different inode but with name, size and time-stamp matching.
  These are usually files restored after being deleted.</div>
</div>
<div class="Pp"></div>
If a &quot;sync&quot; is required, the process return code is 2, instead of the
  default 0. The return code 1 is instead for a generic error condition.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="sync"><a class="selflink" href="#sync">sync</a></h2>
Updates the parity information. All the modified files in the disk array are
  read, and the corresponding parity data is updated.
<div class="Pp"></div>
You can stop this process at any time pressing Ctrl+C, without losing the work
  already done. At the next run the &quot;sync&quot; process will start where
  interrupted.
<div class="Pp"></div>
If during the process, silent or input/output errors are found, the
  corresponding blocks are marked as bad.
<div class="Pp"></div>
Files are identified by path and/or inode and checked by size and time-stamp. If
  the file size or time-stamp are different, the parity data is recomputed for
  the whole file. If the file is moved or renamed in the same disk, keeping the
  same inode, the parity is not recomputed. If the file is moved to another
  disk, the parity is recomputed, but the previously computed hash information
  is kept.
<div class="Pp"></div>
The &quot;content&quot; and &quot;parity&quot; files are modified if necessary.
  The files in the array are NOT modified.
<h2 class="Ss" title="Ss" id="scrub"><a class="selflink" href="#scrub">scrub</a></h2>
Scrubs the array, checking for silent or input/output errors in data and parity
  disks.
<div class="Pp"></div>
For each command invocation, about the 8% of the array is checked, but nothing
  that was already scrubbed in the last 10 days. This means that scrubbing once
  a week, every bit of data is checked at least one time every three months.
<div class="Pp"></div>
You can define a different scrub plan or amount using the -p, --plan option that
  takes as argument: bad - Scrub blocks marked bad. new - Scrub just synced
  blocks not yet scrubbed. full - Scrub everything. 0-100 - Scrub the exact
  percentage of blocks.
<div class="Pp"></div>
If you specify a percentage amount, you can also use the -o, --older-than option
  to define how old the block should be. The oldest blocks are scrubbed first
  ensuring an optimal check. If instead you want to scrub the just synced
  blocks, not yet scrubbed, you should use the &quot;-p new&quot; option.
<div class="Pp"></div>
To get the details of the scrub status use the &quot;status&quot; command.
<div class="Pp"></div>
For any silent or input/output error found the corresponding blocks are marked
  as bad in the &quot;content&quot; file. These bad blocks are listed in
  &quot;status&quot;, and can be fixed with &quot;fix -e&quot;. After the fix,
  at the next scrub they will be rechecked, and if found corrected, the bad mark
  will be removed. To scrub only the bad blocks, you can use the &quot;scrub -p
  bad&quot; command.
<div class="Pp"></div>
It&#x00B4;s recommended to run &quot;scrub&quot; only on a synced array, to
  avoid to have reported error caused by unsynced data. These errors are
  recognized as not being silent errors, and the blocks are not marked as bad,
  but such errors are reported in the output of the command.
<div class="Pp"></div>
Files are identified only by path, and not by inode.
<div class="Pp"></div>
The &quot;content&quot; file is modified to update the time of the last check of
  each block, and to mark bad blocks. The &quot;parity&quot; files are NOT
  modified. The files in the array are NOT modified.
<h2 class="Ss" title="Ss" id="fix"><a class="selflink" href="#fix">fix</a></h2>
Fix all the files and the parity data.
<div class="Pp"></div>
All the files and the parity data are compared with the snapshot state saved in
  the last &quot;sync&quot;. If a difference is found, it&#x00B4;s reverted to
  the stored snapshot.
<div class="Pp"></div>
The &quot;fix&quot; command doesn&#x00B4;t differentiate between errors and
  intentional modifications. It unconditionally reverts the file state at the
  last &quot;sync&quot;.
<div class="Pp"></div>
If no other option is specified the full array is processed. Use the filter
  options to select a subset of files or disks to operate on.
<div class="Pp"></div>
To only fix the blocks marked bad during &quot;sync&quot; and &quot;scrub&quot;,
  use the -e, --filter-error option. As difference from other filter options,
  with this one the fixes are applied only to files that are not modified from
  the the latest &quot;sync&quot;.
<div class="Pp"></div>
All the files that cannot be fixed are renamed adding the
  &quot;.unrecoverable&quot; extension.
<div class="Pp"></div>
Before fixing, the full array is scanned to find any moved file, after the last
  &quot;sync&quot; operation. These files are identified by their time-stamp,
  ignoring their name and directory, and are used in the recovering process if
  necessary. If you moved some of them outside the array, you can use the -i,
  --import option to specify additional directories to scan.
<div class="Pp"></div>
Files are identified only by path, and not by inode.
<div class="Pp"></div>
The &quot;content&quot; file is NOT modified. The &quot;parity&quot; files are
  modified if necessary. The files in the array are modified if necessary.
<h2 class="Ss" title="Ss" id="check"><a class="selflink" href="#check">check</a></h2>
Verify all the files and the parity data.
<div class="Pp"></div>
It works like &quot;fix&quot;, but it only simulates a recovery and no change is
  written in the array.
<div class="Pp"></div>
This command is mostly intended for manual verifications, like after a recovery
  process or in other special conditions. For periodic and scheduled checks uses
  &quot;scrub&quot;.
<div class="Pp"></div>
If you use the -a, --audit-only option, only the file data is checked, and the
  parity data is ignored for a faster run.
<div class="Pp"></div>
Files are identified only by path, and not by inode.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="list"><a class="selflink" href="#list">list</a></h2>
Lists all the files contained in the array at the time of the last
  &quot;sync&quot;.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="dup"><a class="selflink" href="#dup">dup</a></h2>
Lists all the duplicate files. Two files are assumed equal if their hashes are
  matching. The file data is not read, but only the precomputed hashes are used.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="up"><a class="selflink" href="#up">up</a></h2>
Spins up all the disks of the array.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="down"><a class="selflink" href="#down">down</a></h2>
Spins down all the disks of the array.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="pool"><a class="selflink" href="#pool">pool</a></h2>
Creates or updates in the &quot;pooling&quot; directory a virtual view of all
  the files of your disk array.
<div class="Pp"></div>
The files are not really copied here, but just linked using symbolic links.
<div class="Pp"></div>
When updating, all the present symbolic links and empty subdirectories are
  deleted and replaced with the new view of the array. Any other regular file is
  left in place.
<div class="Pp"></div>
Nothing is modified outside the pool directory.
<h2 class="Ss" title="Ss" id="devices"><a class="selflink" href="#devices">devices</a></h2>
Prints the low level devices used by the array.
<div class="Pp"></div>
This command prints the devices associations in place in the array, and
  it&#x00B4;s mainly intended as a script interface.
<div class="Pp"></div>
The first two columns are the low level device id and path. The next two columns
  are the high level device id and path. The latest column if the disk name in
  the array.
<div class="Pp"></div>
In most cases you have one low level device for each disk in the array, but in
  some more complex configurations, you may have multiple low level devices used
  by a single disk in the array.
<div class="Pp"></div>
Nothing is modified.
<h2 class="Ss" title="Ss" id="touch"><a class="selflink" href="#touch">touch</a></h2>
Sets arbitrarely the sub-second timestamp of all the files that have it at zero.
<div class="Pp"></div>
This improves the SnapRAID capability to recognize moved and copied files as it
  makes the timestamp almost unique, removing possible duplicates.
<div class="Pp"></div>
More specifically, if the sub-second timestamp is not zero, a moved or copied
  file is identified as such if it matches the name, size and timestamp. If
  instead the sub-second timestamp is zero, it&#x00B4;s cosidered a copy only if
  it matches the full path, size and timestamp.
<div class="Pp"></div>
Note that the second precision timestamp is not modified, and all the dates and
  times of your files will be maintained.
<h2 class="Ss" title="Ss" id="rehash"><a class="selflink" href="#rehash">rehash</a></h2>
Schedules a rehash of the whole array.
<div class="Pp"></div>
This command changes the hash kind used, typically when upgrading from a 32 bits
  system to a 64 bits one, to switch from MurmurHash3 to the faster SpookyHash.
<div class="Pp"></div>
If you are already using the optimal hash, this command does nothing and tells
  you that nothing has to be done.
<div class="Pp"></div>
The rehash isn&#x00B4;t done immediately, but it takes place progressively
  during &quot;sync&quot; and &quot;scrub&quot;.
<div class="Pp"></div>
You can get the rehash state using &quot;status&quot;.
<div class="Pp"></div>
During the rehash, SnapRAID maintains full functionality, with the only
  exception of &quot;dup&quot; not able to detect duplicated files using a
  different hash.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
SnapRAID provides the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c, --conf CONFIG</b></dt>
  <dd class="It-tag">Selects the configuration file. If not specified
      it&#x00B4;s assumed the file &quot;/etc/snapraid.conf&quot; in Unix, and
      &quot;snapraid.conf&quot; in the current directory in Windows.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f, --filter PATTERN</b></dt>
  <dd class="It-tag">Filters the files to process in &quot;check&quot; and
      &quot;fix&quot;. Only the files matching the entered pattern are
      processed. This option can be used many times. See the PATTERN section for
      more details in the pattern specifications. In Unix, ensure to quote
      globbing chars if used. This option can be used only with
      &quot;check&quot; and &quot;fix&quot;. Note that it cannot be used with
      &quot;sync&quot; and &quot;scrub&quot;, because they always process the
      whole array.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d, --filter-disk NAME</b></dt>
  <dd class="It-tag">Filters the disks to process in &quot;check&quot;,
      &quot;fix&quot;, &quot;up&quot; and &quot;down&quot;. You must specify a
      disk name as named in the configuration file. You can also specify parity
      disks with the names: &quot;parity&quot;, &quot;2-parity&quot;,
      &quot;3-parity&quot;, ... to limit the operations a specific parity disk.
      If you combine more --filter, --filter-disk and --filter-missing options,
      only files matching all the set of filters are selected. This option can
      be used many times. This option can be used only with &quot;check&quot;,
      &quot;fix&quot;, &quot;up&quot; and &quot;down&quot;. Note that it cannot
      be used with &quot;sync&quot; and &quot;scrub&quot;, because they always
      process the whole array.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m, --filter-missing</b></dt>
  <dd class="It-tag">Filters the files to process in &quot;check&quot; and
      &quot;fix&quot;. Only the files missing/deleted from the array are
      processed. When used with &quot;fix&quot;, this is a kind of
      &quot;undelete&quot; command. If you combine more --filter, --filter-disk
      and --filter-missing options, only files matching all the set of filters
      are selected. This option can be used only with &quot;check&quot; and
      &quot;fix&quot;. Note that it cannot be used with &quot;sync&quot; and
      &quot;scrub&quot;, because they always process the whole array.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e, --filter-error</b></dt>
  <dd class="It-tag">Filters the blocks to process in &quot;check&quot; and
      &quot;fix&quot;. It processes only the blocks marked with silent or
      input/output errors during &quot;sync&quot; and &quot;scrub&quot;, and
      listed in &quot;status&quot;. This option can be used only with
      &quot;check&quot; and &quot;fix&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p, --plan PERC|bad|new|full</b></dt>
  <dd class="It-tag">Selects the scrub plan. If PERC is a numeric value from 0
      to 100, it&#x00B4;s interpreted as the percentage of blocks to scrub.
      Instead of a percentage, you can also specify a plan: &quot;bad&quot;
      scrubs bad blocks, &quot;new&quot; the blocks not yet scrubbed, and
      &quot;full&quot; for everything. This option can be used only with
      &quot;scrub&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o, --older-than DAYS</b></dt>
  <dd class="It-tag">Selects the older the part of the array to process in
      &quot;scrub&quot;. DAYS is the minimum age in days for a block to be
      scrubbed, default is 10. Blocks marked as bad are always scrubbed despite
      this option. This option can be used only with &quot;scrub&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a, --audit-only</b></dt>
  <dd class="It-tag">In &quot;check&quot; verifies the hash of the files without
      doing any kind of check on the parity data. If you are interested in
      checking only the file data this option can speedup a lot the checking
      process. This option can be used only with &quot;check&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h, --pre-hash</b></dt>
  <dd class="It-tag">In &quot;sync&quot; runs a preliminary hashing phase of all
      the new data to have an additional verification before the parity
      computation. Usually in &quot;sync&quot; no preliminary hashing is done,
      and the new data is hashed just before the parity computation when
      it&#x00B4;s read for the first time. Unfortunately, this process happens
      when the system is under heavy load, with all disks spinning and with a
      busy CPU. This is an extreme condition for the machine, and if it has a
      latent hardware problem, it&#x00B4;s possible to encounter silent errors
      what cannot be detected because the data is not yet hashed. To avoid this
      risk, you can enable the &quot;pre-hash&quot; mode and have all the data
      read two times to ensure its integrity. This option also verifies the
      files moved inside the array, to ensure that the move operation went
      successfully, and in case to block the sync and to allow to run a fix
      operation. This option can be used only with &quot;sync&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i, --import DIR</b></dt>
  <dd class="It-tag">Imports from the specified directory any file that you
      deleted from the array after the last &quot;sync&quot;. If you still have
      such files, they could be used by &quot;check&quot; and &quot;fix&quot; to
      improve the recover process. The files are read also in subdirectories and
      they are identified regardless of their name. This option can be used only
      with &quot;check&quot; and &quot;fix&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Z, --force-zero</b></dt>
  <dd class="It-tag">Forces the insecure operation of syncing a file with zero
      size that before was not. If SnapRAID detects a such condition, it stops
      proceeding unless you specify this option. This allows to easily detect
      when after a system crash, some accessed files were truncated. This is a
      possible condition in Linux with the ext3/ext4 file-systems. This option
      can be used only with &quot;sync&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E, --force-empty</b></dt>
  <dd class="It-tag">Forces the insecure operation of syncing a disk with all
      the original files missing. If SnapRAID detects that all the files
      originally present in the disk are missing or rewritten, it stops
      proceeding unless you specify this option. This allows to easily detect
      when a data file-system is not mounted. This option can be used only with
      &quot;sync&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-U, --force-uuid</b></dt>
  <dd class="It-tag">Forces the insecure operation of syncing, checking and
      fixing with disks that have changed their UUID. If SnapRAID detects that
      some disks have changed UUID, it stops proceeding unless you specify this
      option. This allows to detect when your disks are mounted in the wrong
      mount points. It&#x00B4;s anyway allowed to have a single UUID change with
      single parity, and more with multiple parity, because it&#x00B4;s the
      normal case of replacing disks after a recovery. This option can be used
      only with &quot;sync&quot;, &quot;check&quot; or &quot;fix&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D, --force-device</b></dt>
  <dd class="It-tag">Forces the insecure operation of fixing with inaccessible
      disks, or with disks on the same physical device. Like if you lost two
      data disks, and you have a spare disk to recover only the first one, and
      you want to ignore the second inaccessible disk. Or if you want to recover
      a disk in the free space left in an already used disk, sharing the same
      physical device. This option can be used only with &quot;fix&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N, --force-nocopy</b></dt>
  <dd class="It-tag">In &quot;sync&quot;, &quot;check and &quot;fix&quot;,
      disables the copy detection heuristic. Without this option SnapRAID
      assumes that files with same attributes, like name, size and time-stamp
      are copies with the same data. This allows to identify copied or moved
      files from one disk to another, and to reuse the already computed hash
      information to detect silent errors or to recover missing files. This
      behavior, in some rare cases, may result in false positives, or in a slow
      process due the many hash verifications, and this option allows to resolve
      them. This option can be used only with &quot;sync&quot;,
      &quot;check&quot; and &quot;fix&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-F, --force-full</b></dt>
  <dd class="It-tag">In &quot;sync&quot; forces a full rebuild of the parity.
      This option can be used when you reverted back to an old content file, but
      using a more recent parity data. Instead of recomputing the parity from
      scratch, this allows to reuse the hashes present in the content file to
      validate data, and to maintain data protection during the &quot;sync&quot;
      process using the old content file and the parity data you have. This
      option can be used only with &quot;sync&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l, --log FILE</b></dt>
  <dd class="It-tag">Write a detailed log in the specified file. If this option
      is not specified, unexpected errors are printed on the screen, likely
      resulting in too much output in case of many errors. When -l, --log is
      specified, on the screen, go only fatal errors that makes SnapRAID to stop
      progress. If the path starts with &#x00B4;&gt;&gt;&#x00B4; the file is
      opened in append mode. Occurrences of &#x00B4;%D&#x00B4; and
      &#x00B4;%T&#x00B4; in the name are replaced with the date and time in the
      format YYYYMMDD and HHMMSS. Note that in Windows batch files,
      you&#x00B4;ll have to double the &#x00B4;%&#x00B4; char, like
      result-%%D.log. And to use &#x00B4;&gt;&gt;&#x00B4; you&#x00B4;ll have to
      enclose the name in &quot;, like &quot;&gt;&gt;result.log&quot;. To output
      the log to standard output or standard error, you can use respectively
      &quot;&gt;&amp;1&quot; and &quot;&gt;&amp;2&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L, --error-limit</b></dt>
  <dd class="It-tag">Sets a new error limit before stopping execution. By
      default SnapRAID stops if it encounters more than 100 Input/Output errors,
      meaning that likely a disk is going to die. This options affects
      &quot;sync&quot; and &quot;scrub&quot;, that are allowed to continue after
      the first bunch of disk errors, to try to complete at most their
      operations. Instead, &quot;check&quot; and &quot;fix&quot; always stop at
      the first error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S, --start BLKSTART</b></dt>
  <dd class="It-tag">Starts the processing from the specified block number. It
      could be useful to retry to check or fix some specific block, in case of a
      damaged disk. It&#x00B4;s present mainly for advanced manual
    recovering.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B, --count BLKCOUNT</b></dt>
  <dd class="It-tag">Processes only the specified number of blocks. It&#x00B4;s
      present mainly for advanced manual recovering.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C, --gen-conf CONTENT_FILE</b></dt>
  <dd class="It-tag">Generates a dummy configuration file from an existing
      content file. The configuration file is written in the standard output,
      and it doesn&#x00B4;t overwrite an existing one. This configuration file
      also contains the information needed to reconstruct the disk mount points,
      in case you lose the entire system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v, --verbose</b></dt>
  <dd class="It-tag">Prints more information on the screen. If specified one
      time, it prints excluded files and more stats. This option has no effect
      on the log files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q, --quiet</b></dt>
  <dd class="It-tag">Prints less information on the screen. If specified one
      time, removes the progress bar, if two times, the running operations,
      three times, the info messages, four times the status messages. Fatal
      errors are always printed on the screen. This option has no effect on the
      log files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-H, --help</b></dt>
  <dd class="It-tag">Prints a short help screen.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V, --version</b></dt>
  <dd class="It-tag">Prints the program version.</dd>
</dl>
<h1 class="Sh" title="Sh" id="CONFIGURATION"><a class="selflink" href="#CONFIGURATION">CONFIGURATION</a></h1>
SnapRAID requires a configuration file to know where your disk array is located,
  and where storing the parity information.
<div class="Pp"></div>
This configuration file is located in /etc/snapraid.conf in Unix or in the
  execution directory in Windows.
<div class="Pp"></div>
It should contain the following options (case sensitive):
<h2 class="Ss" title="Ss" id="parity_FILE"><a class="selflink" href="#parity_FILE">parity
  FILE</a></h2>
Defines the file to use to store the parity information. The parity enables the
  protection from a single disk failure, like RAID5.
<div class="Pp"></div>
It must be placed in a disk dedicated for this purpose with as much free space
  as the biggest disk in the array. Leaving the parity disk reserved for only
  this file ensures that it doesn&#x00B4;t get fragmented, improving the
  performance.
<div class="Pp"></div>
This option is mandatory and it can be used only one time.
<h2 class="Ss" title="Ss" id="[2,3,4,5,6]-parity_FILE"><a class="selflink" href="#[2,3,4,5,6]-parity_FILE">[2,3,4,5,6]-parity
  FILE</a></h2>
Defines the files to use to store extra parity information. For each parity file
  specified, one additional level of protection is enabled:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">2-parity enables RAID6 double parity.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">3-parity enables triple parity</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">4-parity enables quad parity</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">5-parity enables penta (five) parity</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">6-parity enables hexa (six) parity</dd>
</dl>
<div class="Pp"></div>
Each parity level requires also all the files of the previous levels.
<div class="Pp"></div>
Each file must be placed in a disk dedicated for this purpose with as much free
  space as the biggest disk in the array. Leaving the parity disks reserved for
  only these files ensures that they doesn&#x00B4;t get fragmented, improving
  the performance.
<div class="Pp"></div>
These options are optional and they can be used only one time.
<h2 class="Ss" title="Ss" id="z-parity_FILE"><a class="selflink" href="#z-parity_FILE">z-parity
  FILE</a></h2>
Defines an alternate file and format to store the triple parity.
<div class="Pp"></div>
This option is an alternative at &#x00B4;3-parity&#x00B4; mainly intended for
  low-end CPUs like ARM or AMD Phenom, Athlon and Opteron that don&#x00B4;t
  support the SSSE3 instructions set, and in such case it provides a better
  performance.
<div class="Pp"></div>
This format is similar, but faster, at the one used by the ZFS RAIDZ3, but it
  doesn&#x00B4;t work beyond triple parity.
<div class="Pp"></div>
When using &#x00B4;3-parity&#x00B4; you will be warned if it&#x00B4;s
  recommended to use the &#x00B4;z-parity&#x00B4; format for a performance
  improvement.
<div class="Pp"></div>
It&#x00B4;s possible to convert from one format to another, adjusting the
  configuration file with the wanted z-parity or 3-parity file, and using
  &#x00B4;fix&#x00B4; to recreate it.
<h2 class="Ss" title="Ss" id="content_FILE"><a class="selflink" href="#content_FILE">content
  FILE</a></h2>
Defines the file to use to store the list and check-sums of all the files
  present in your disk array.
<div class="Pp"></div>
It can be placed in the disk used to store data, parity, or any other disk
  available. If you use a data disk, this file is automatically excluded from
  the &quot;sync&quot; process.
<div class="Pp"></div>
This option is mandatory and it can be used more times to save more copies of
  the same files.
<div class="Pp"></div>
You have to store at least one copy for each parity disk used plus one. Using
  some more doesn&#x00B4;t hurt.
<h2 class="Ss" title="Ss" id="data_NAME_DIR"><a class="selflink" href="#data_NAME_DIR">data
  NAME DIR</a></h2>
Defines the name and the mount point of the data disks of the array. NAME is
  used to identify the disk, and it must be unique. DIR is the mount point of
  the disk in the file-system.
<div class="Pp"></div>
You can change the mount point as you like, as long you keep the NAME fixed.
<div class="Pp"></div>
You should use one option for each data disk of the array.
<div class="Pp"></div>
You can rename later a disk, changing the NAME directly in the configuration
  file, and then run a &#x00B4;sync&#x00B4; command. In the rename case, the
  association is done using the stored UUID of the disks.
<h2 class="Ss" title="Ss" id="nohidden"><a class="selflink" href="#nohidden">nohidden</a></h2>
Excludes all the hidden files and directory. In Unix hidden files are the ones
  starting with &quot;.&quot;. In Windows they are the ones with the hidden
  attribute.
<h2 class="Ss" title="Ss" id="exclude/include_PATTERN"><a class="selflink" href="#exclude/include_PATTERN">exclude/include
  PATTERN</a></h2>
Defines the file or directory patterns to exclude and include in the sync
  process. All the patterns are processed in the specified order.
<div class="Pp"></div>
If the first pattern that matches is an &quot;exclude&quot; one, the file is
  excluded. If it&#x00B4;s an &quot;include&quot; one, the file is included. If
  no pattern matches, the file is excluded if the last pattern specified is an
  &quot;include&quot;, or included if the last pattern specified is an
  &quot;exclude&quot;.
<div class="Pp"></div>
See the PATTERN section for more details in the pattern specifications.
<div class="Pp"></div>
This option can be used many times.
<h2 class="Ss" title="Ss" id="blocksize_SIZE_IN_KIBIBYTES"><a class="selflink" href="#blocksize_SIZE_IN_KIBIBYTES">blocksize
  SIZE_IN_KIBIBYTES</a></h2>
Defines the basic block size in kibi bytes of the parity. One kibi bytes is 1024
  bytes. The default blocksize is 256 and it should work for most cases.
<div class="Pp"></div>
A reason to use a different blocksize is if your system has less than 4 GiB of
  memory. As a rule of thumb, with 4 GiB or more memory use the default 256,
  with 2 GiB use 512, and with 1 GiB use 1024.
<div class="Pp"></div>
In more details SnapRAID requires about TS*17/BS bytes of RAM memory. Where TS
  is the total size in bytes of your disk array, and BS is the block size in
  bytes.
<div class="Pp"></div>
For example with 8 disks of 4 TB and a block size of 256 KiB (1 KiB = 1024
  bytes) you have:
<div class="Pp"></div>
RAM = (8 * 4 * 10^12) * 17 / (256 * 2^10) = 1.9 GiB
<div class="Pp"></div>
<div class="Pp"></div>
Another reason to use a different blocksize is if you have a lot of small files.
  In the order of many millions.
<div class="Pp"></div>
For each file, even of few bytes, a whole block of parity is allocated, and with
  many files this may result in a lot of unused parity space. And when you
  completely fill the parity disk, you are not allowed to add more files in the
  data disks. Anyway, the wasted parity doesn&#x00B4;t sum between data disks.
  Wasted space resulting from a high number of files in a data disk, limits only
  the amount of data in such data disk and not in others.
<div class="Pp"></div>
As approximation, you can assume that half of the block size is wasted for each
  file. For example, with 100000 files and a 256 KiB block size, you are going
  to waste 13 GB of parity, that may result in 13 GB less space available in the
  data disk.
<div class="Pp"></div>
You can get the amount of wasted space in each disk using &quot;status&quot;.
  This is the amount of space that you must leave free in the data disks, or use
  for files not included in the array. If this value is negative, it means that
  your are near to fill the parity, and it represents the space you can still
  waste.
<div class="Pp"></div>
To avoid the problem, you can use a bigger partition for parity. For example, if
  you have the parity partition bigger than 13 GB than data disks, you have
  enough extra space to handle up to 100000 files in each data disk.
<div class="Pp"></div>
A trick to get a bigger parity partition in Linux, is to format it with the
  command:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">mkfs.ext4 -m 0 -T largefile4 DEVICE
<div class="Pp"></div>
</div>
<div class="Pp"></div>
This results in about 1.5% of extra space. Meaning about 60 GB for a 4 TB disk,
  that allows about 460000 files in each data disk without any wasted space.
<h2 class="Ss" title="Ss" id="autosave_SIZE_IN_GIGABYTES"><a class="selflink" href="#autosave_SIZE_IN_GIGABYTES">autosave
  SIZE_IN_GIGABYTES</a></h2>
Automatically save the state when syncing or scrubbing after the specified
  amount of GB processed. This option is useful to avoid to restart from scratch
  long &quot;sync&quot; commands interrupted by a machine crash, or any other
  event that may interrupt SnapRAID.
<h2 class="Ss" title="Ss" id="pool_DIR"><a class="selflink" href="#pool_DIR">pool
  DIR</a></h2>
Defines the pooling directory where the virtual view of the disk array is
  created using the &quot;pool&quot; command.
<div class="Pp"></div>
The directory must already exist.
<h2 class="Ss" title="Ss" id="share_UNC_DIR"><a class="selflink" href="#share_UNC_DIR">share
  UNC_DIR</a></h2>
Defines the Windows UNC path required to access the disks remotely.
<div class="Pp"></div>
If this option is specified, the symbolic links created in the pool directory
  use this UNC path to access the disks. Without this option the symbolic links
  generated use only local paths, not allowing to share the pool directory in
  the network.
<div class="Pp"></div>
The symbolic links are formed using the specified UNC path, adding the disk name
  as specified in the &quot;disk&quot; option, and finally adding the file dir
  and name.
<div class="Pp"></div>
This option is only required for Windows.
<h2 class="Ss" title="Ss" id="smartctl_DISK/PARITY_OPTIONS..."><a class="selflink" href="#smartctl_DISK/PARITY_OPTIONS...">smartctl
  DISK/PARITY OPTIONS...</a></h2>
Defines a custom smartctl command to obtain the SMART attributes for each disk.
  This may be required for RAID controllers and for some USB disk that cannot be
  auto-detected.
<div class="Pp"></div>
DISK is the same disk name specified in the &quot;disk&quot; option. PARITY is
  one of the parity name as &quot;parity,[1,2,3,4,5,6,z]-parity&quot;.
<div class="Pp"></div>
In the specified OPTIONS, the &quot;%s&quot; string is replaced by the device
  name. Note that in case of RAID controllers the device is likely fixed, and
  you don&#x00B4;t have to use &quot;%s&quot;.
<div class="Pp"></div>
Refers at the smartmontools documentation about the possible options:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">https://www.smartmontools.org/wiki/Supported_RAID-Controllers
<div class="Pp"></div>
https://www.smartmontools.org/wiki/Supported_USB-Devices
<div class="Pp"></div>
</div>
<h2 class="Ss" title="Ss" id="Examples"><a class="selflink" href="#Examples">Examples</a></h2>
An example of a typical configuration for Unix is:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">parity /mnt/diskp/snapraid.parity
<div class="Pp"></div>
content /mnt/diskp/snapraid.content
<div class="Pp"></div>
content /var/snapraid/snapraid.content
<div class="Pp"></div>
data d1 /mnt/disk1/
<div class="Pp"></div>
data d2 /mnt/disk2/
<div class="Pp"></div>
data d3 /mnt/disk3/
<div class="Pp"></div>
exclude /lost+found/
<div class="Pp"></div>
exclude /tmp/
<div class="Pp"></div>
smartctl d1 -d sat %s
<div class="Pp"></div>
smartctl d2 -d usbjmicron %s
<div class="Pp"></div>
smartctl parity -d areca,1/1 /dev/sg0
<div class="Pp"></div>
smartctl 2-parity -d areca,2/1 /dev/sg0
<div class="Pp"></div>
</div>
<div class="Pp"></div>
An example of a typical configuration for Windows is:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;">parity E:\snapraid.parity
<div class="Pp"></div>
content E:\snapraid.content
<div class="Pp"></div>
content C:\snapraid\snapraid.content
<div class="Pp"></div>
data d1 G:\array\
<div class="Pp"></div>
data d2 H:\array\
<div class="Pp"></div>
data d3 I:\array\
<div class="Pp"></div>
exclude Thumbs.db
<div class="Pp"></div>
exclude \$RECYCLE.BIN
<div class="Pp"></div>
exclude \System Volume Information
<div class="Pp"></div>
smartctl d1 -d sat %s
<div class="Pp"></div>
smartctl d2 -d usbjmicron %s
<div class="Pp"></div>
smartctl parity -d areca,1/1 /dev/arcmsr0
<div class="Pp"></div>
smartctl 2-parity -d areca,2/1 /dev/arcmsr0
<div class="Pp"></div>
</div>
<h1 class="Sh" title="Sh" id="PATTERN"><a class="selflink" href="#PATTERN">PATTERN</a></h1>
Patterns are used to select a subset of files to exclude or include in the
  process.
<div class="Pp"></div>
There are four different types of patterns:
<dl class="Bl-tag">
  <dt class="It-tag"><b>FILE</b></dt>
  <dd class="It-tag">Selects any file named as FILE. You can use any globbing
      character like * and ?. This pattern is applied only to files and not to
      directories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>DIR/</b></dt>
  <dd class="It-tag">Selects any directory named DIR and everything inside. You
      can use any globbing character like * and ?. This pattern is applied only
      to directories and not to files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/PATH/FILE</b></dt>
  <dd class="It-tag">Selects the exact specified file path. You can use any
      globbing character like * and ? but they never match a directory slash.
      This pattern is applied only to files and not to directories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/PATH/DIR/</b></dt>
  <dd class="It-tag">Selects the exact specified directory path and everything
      inside. You can use any globbing character like * and ? but they never
      match a directory slash. This pattern is applied only to directories and
      not to files.</dd>
</dl>
<div class="Pp"></div>
Note that when you specify an absolute path starting with /, it&#x00B4;s applied
  at the array root dir and not at the local file-system root dir.
<div class="Pp"></div>
In Windows you can use the backslash \ instead of the forward slash /. Note that
  Windows system directories, junctions, mount points, and any other Windows
  special directory are treated just as files, meaning that to exclude them you
  must use a file rule, and not a directory one.
<div class="Pp"></div>
In the configuration file, you can use different strategies to filter the files
  to process. The simplest one is to use only &quot;exclude&quot; rules to
  remove all the files and directories you do not want to process. For example:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;"># Excludes any file named
  &quot;*.unrecoverable&quot;
<div class="Pp"></div>
exclude *.unrecoverable
<div class="Pp"></div>
# Excludes the root directory &quot;/lost+found&quot;
<div class="Pp"></div>
exclude /lost+found/
<div class="Pp"></div>
# Excludes any sub-directory named &quot;tmp&quot;
<div class="Pp"></div>
exclude tmp/
<div class="Pp"></div>
</div>
<div class="Pp"></div>
The opposite way is to define only the file you want to process, using only
  &quot;include&quot; rules. For example:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;"># Includes only some directories
<div class="Pp"></div>
include /movies/
<div class="Pp"></div>
include /musics/
<div class="Pp"></div>
include /pictures/
<div class="Pp"></div>
</div>
<div class="Pp"></div>
The final way, is to mix &quot;exclude&quot; and &quot;include&quot; rules. In
  this case take care that the order of rules is important. Previous rules have
  the precedence over the later ones. To get things simpler you can first have
  all the &quot;exclude&quot; rules and then all the &quot;include&quot; ones.
  For example:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;"># Excludes any file named
  &quot;*.unrecoverable&quot;
<div class="Pp"></div>
exclude *.unrecoverable
<div class="Pp"></div>
# Excludes any sub-directory named &quot;tmp&quot;
<div class="Pp"></div>
exclude tmp/
<div class="Pp"></div>
# Includes only some directories
<div class="Pp"></div>
include /movies/
<div class="Pp"></div>
include /musics/
<div class="Pp"></div>
include /pictures/
<div class="Pp"></div>
</div>
<div class="Pp"></div>
On the command line, using the -f option, you can only use &quot;include&quot;
  patterns. For example:
<div class="Pp"></div>
<div style="margin-left: 4.00ex;"># Checks only the .mp3 files.
<div class="Pp"></div>
# Note the &quot;&quot; use to avoid globbing expansion by the shell in Unix.
<div class="Pp"></div>
snapraid -f &quot;*.mp3&quot; check
<div class="Pp"></div>
</div>
<div class="Pp"></div>
In Unix, when using globbing chars in the command line, you have to quote them.
  Otherwise the shell will try to expand them.
<h1 class="Sh" title="Sh" id="CONTENT"><a class="selflink" href="#CONTENT">CONTENT</a></h1>
SnapRAID stores the list and check-sums of your files in the content file.
<div class="Pp"></div>
It&#x00B4;s a binary file, listing all the files present in your disk array,
  with all the check-sums to verify their integrity.
<div class="Pp"></div>
This file is read and written by the &quot;sync&quot; and &quot;scrub&quot;
  commands, and read by &quot;fix&quot;, &quot;check&quot; and
  &quot;status&quot;.
<h1 class="Sh" title="Sh" id="PARITY"><a class="selflink" href="#PARITY">PARITY</a></h1>
SnapRAID stores the parity information of your array in the parity files.
<div class="Pp"></div>
They are binary files, containing the computed parity of all the blocks defined
  in the &quot;content&quot; file.
<div class="Pp"></div>
These files are read and written by the &quot;sync&quot; and &quot;fix&quot;
  commands, and only read by &quot;scrub&quot; and &quot;check&quot;.
<h1 class="Sh" title="Sh" id="ENCODING"><a class="selflink" href="#ENCODING">ENCODING</a></h1>
SnapRAID in Unix ignores any encoding. It reads and stores the file names with
  the same encoding used by the file-system.
<div class="Pp"></div>
In Windows all the names read from the file-system are converted and processed
  in the UTF-8 format.
<div class="Pp"></div>
To have the file names printed correctly you have to set the Windows console in
  the UTF-8 mode, with the command &quot;chcp 65001&quot;, and use a TrueType
  font like &quot;Lucida Console&quot; as console font. Note that it has effect
  only on the printed file names, if you redirect the console output to a file,
  the resulting file is always in the UTF-8 format.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
This file is Copyright (C) 2011 Andrea Mazzoleni
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
rsync(1)</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
