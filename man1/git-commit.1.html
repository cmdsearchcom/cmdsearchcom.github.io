<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:13:19 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GIT-COMMIT(1) Git Manual GIT-COMMIT(1)</p>

<p style="margin-top: 1em">NAME <br>
git-commit - Record changes to the repository</p>

<p style="margin-top: 1em">SYNOPSIS <br>
git commit [-a | --interactive | --patch] [-s] [-v]
[-u&lt;mode&gt;] [--amend] <br>
[--dry-run] [(-c | -C | --fixup | --squash) &lt;commit&gt;]
<br>
[-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author]
[--allow-empty] <br>
[--allow-empty-message] [--no-verify] [-e]
[--author=&lt;author&gt;] <br>
[--date=&lt;date&gt;] [--cleanup=&lt;mode&gt;]
[--[no-]status] <br>
[-i | -o] [-S[&lt;keyid&gt;]] [--] [&lt;file&gt;...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Stores the current contents of the index in a new commit
along with a log message from the user describing the
changes.</p>

<p style="margin-top: 1em">The content to be added can be
specified in several ways:</p>

<p style="margin-top: 1em">1. by using git add to
incrementally &quot;add&quot; changes to the index before
using the commit command (Note: even modified files must be
&quot;added&quot;);</p>

<p style="margin-top: 1em">2. by using git rm to remove
files from the working tree and the index, again before
using the commit command;</p>

<p style="margin-top: 1em">3. by listing files as arguments
to the commit command, in which case the commit will ignore
changes staged in the index, and instead record the current
content of the listed <br>
files (which must already be known to Git);</p>

<p style="margin-top: 1em">4. by using the -a switch with
the commit command to automatically &quot;add&quot; changes
from all known files (i.e. all files that are already listed
in the index) and to automatically <br>
&quot;rm&quot; files in the index that have been removed
from the working tree, and then perform the actual
commit;</p>

<p style="margin-top: 1em">5. by using the --interactive or
--patch switches with the commit command to decide one by
one which files or hunks should be part of the commit,
before finalizing the <br>
operation. See the &acirc;Interactive Mode&acirc; section of
git-add(1) to learn how to operate these modes.</p>

<p style="margin-top: 1em">The --dry-run option can be used
to obtain a summary of what is included by any of the above
for the next commit by giving the same set of parameters
(options and paths).</p>

<p style="margin-top: 1em">If you make a commit and then
find a mistake immediately after that, you can recover from
it with git reset.</p>

<p style="margin-top: 1em">OPTIONS <br>
-a, --all <br>
Tell the command to automatically stage files that have been
modified and deleted, but new files you have not told Git
about are not affected.</p>

<p style="margin-top: 1em">-p, --patch <br>
Use the interactive patch selection interface to chose which
changes to commit. See git-add(1) for details.</p>

<p style="margin-top: 1em">-C &lt;commit&gt;,
--reuse-message=&lt;commit&gt; <br>
Take an existing commit object, and reuse the log message
and the authorship information (including the timestamp)
when creating the commit.</p>

<p style="margin-top: 1em">-c &lt;commit&gt;,
--reedit-message=&lt;commit&gt; <br>
Like -C, but with -c the editor is invoked, so that the user
can further edit the commit message.</p>

<p style="margin-top: 1em">--fixup=&lt;commit&gt; <br>
Construct a commit message for use with rebase --autosquash.
The commit message will be the subject line from the
specified commit with a prefix of &quot;fixup! &quot;. See
git- <br>
rebase(1) for details.</p>

<p style="margin-top: 1em">--squash=&lt;commit&gt; <br>
Construct a commit message for use with rebase --autosquash.
The commit message subject line is taken from the specified
commit with a prefix of &quot;squash! &quot;. Can be used
with <br>
additional commit message options (-m/-c/-C/-F). See
git-rebase(1) for details.</p>

<p style="margin-top: 1em">--reset-author <br>
When used with -C/-c/--amend options, or when committing
after a a conflicting cherry-pick, declare that the
authorship of the resulting commit now belongs of the
committer. <br>
This also renews the author timestamp.</p>

<p style="margin-top: 1em">--short <br>
When doing a dry-run, give the output in the short-format.
See git-status(1) for details. Implies --dry-run.</p>

<p style="margin-top: 1em">--branch <br>
Show the branch and tracking info even in short-format.</p>

<p style="margin-top: 1em">--porcelain <br>
When doing a dry-run, give the output in a porcelain-ready
format. See git-status(1) for details. Implies
--dry-run.</p>

<p style="margin-top: 1em">--long <br>
When doing a dry-run, give the output in a the long-format.
Implies --dry-run.</p>

<p style="margin-top: 1em">-z, --null <br>
When showing short or porcelain status output, terminate
entries in the status output with NUL, instead of LF. If no
format is given, implies the --porcelain output format.</p>

<p style="margin-top: 1em">-F &lt;file&gt;,
--file=&lt;file&gt; <br>
Take the commit message from the given file. Use - to read
the message from the standard input.</p>

<p style="margin-top: 1em">--author=&lt;author&gt; <br>
Override the commit author. Specify an explicit author using
the standard A U Thor &lt;author@example.com&gt; format.
Otherwise &lt;author&gt; is assumed to be a pattern and is
used to <br>
search for an existing commit by that author (i.e. rev-list
--all -i --author=&lt;author&gt;); the commit author is then
copied from the first such commit found.</p>

<p style="margin-top: 1em">--date=&lt;date&gt; <br>
Override the author date used in the commit.</p>

<p style="margin-top: 1em">-m &lt;msg&gt;,
--message=&lt;msg&gt; <br>
Use the given &lt;msg&gt; as the commit message. If multiple
-m options are given, their values are concatenated as
separate paragraphs.</p>

<p style="margin-top: 1em">-t &lt;file&gt;,
--template=&lt;file&gt; <br>
When editing the commit message, start the editor with the
contents in the given file. The commit.template
configuration variable is often used to give this option
implicitly <br>
to the command. This mechanism can be used by projects that
want to guide participants with some hints on what to write
in the message in what order. If the user exits the <br>
editor without editing the message, the commit is aborted.
This has no effect when a message is given by other means,
e.g. with the -m or -F options.</p>

<p style="margin-top: 1em">-s, --signoff <br>
Add Signed-off-by line by the committer at the end of the
commit log message.</p>

<p style="margin-top: 1em">-n, --no-verify <br>
This option bypasses the pre-commit and commit-msg hooks.
See also githooks(5).</p>

<p style="margin-top: 1em">--allow-empty <br>
Usually recording a commit that has the exact same tree as
its sole parent commit is a mistake, and the command
prevents you from making such a commit. This option bypasses
<br>
the safety, and is primarily for use by foreign SCM
interface scripts.</p>

<p style="margin-top: 1em">--allow-empty-message <br>
Like --allow-empty this command is primarily for use by
foreign SCM interface scripts. It allows you to create a
commit with an empty commit message without using plumbing
<br>
commands like git-commit-tree(1).</p>

<p style="margin-top: 1em">--cleanup=&lt;mode&gt; <br>
This option determines how the supplied commit message
should be cleaned up before committing. The &lt;mode&gt; can
be strip, whitespace, verbatim, or default.</p>

<p style="margin-top: 1em">strip <br>
Strip leading and trailing empty lines, trailing whitespace,
and #commentary and collapse consecutive empty lines.</p>

<p style="margin-top: 1em">whitespace <br>
Same as strip except #commentary is not removed.</p>

<p style="margin-top: 1em">verbatim <br>
Do not change the message at all.</p>

<p style="margin-top: 1em">default <br>
Same as strip if the message is to be edited. Otherwise
whitespace.</p>

<p style="margin-top: 1em">The default can be changed by
the commit.cleanup configuration variable (see
git-config(1)).</p>

<p style="margin-top: 1em">-e, --edit <br>
The message taken from file with -F, command line with -m,
and from commit object with -C are usually used as the
commit log message unmodified. This option lets you further
<br>
edit the message taken from these sources.</p>

<p style="margin-top: 1em">--no-edit <br>
Use the selected commit message without launching an editor.
For example, git commit --amend --no-edit amends a commit
without changing its commit message.</p>

<p style="margin-top: 1em">--amend <br>
Replace the tip of the current branch by creating a new
commit. The recorded tree is prepared as usual (including
the effect of the -i and -o options and explicit pathspec),
<br>
and the message from the original commit is used as the
starting point, instead of an empty message, when no other
message is specified from the command line via options such
<br>
as -m, -F, -c, etc. The new commit has the same parents and
author as the current one (the --reset-author option can
countermand this).</p>

<p style="margin-top: 1em">It is a rough equivalent
for:</p>

<p style="margin-top: 1em">$ git reset --soft HEAD^ <br>
$ ... do something else to come up with the right tree ...
<br>
$ git commit -c ORIG_HEAD</p>

<p style="margin-top: 1em">but can be used to amend a merge
commit.</p>

<p style="margin-top: 1em">You should understand the
implications of rewriting history if you amend a commit that
has already been published. (See the &quot;RECOVERING FROM
UPSTREAM REBASE&quot; section in git- <br>
rebase(1).)</p>

<p style="margin-top: 1em">--no-post-rewrite <br>
Bypass the post-rewrite hook.</p>

<p style="margin-top: 1em">-i, --include <br>
Before making a commit out of staged contents so far, stage
the contents of paths given on the command line as well.
This is usually not what you want unless you are <br>
concluding a conflicted merge.</p>

<p style="margin-top: 1em">-o, --only <br>
Make a commit only from the paths specified on the command
line, disregarding any contents that have been staged so
far. This is the default mode of operation of git commit
<br>
if any paths are given on the command line, in which case
this option can be omitted. If this option is specified
together with --amend, then no paths need to be specified,
<br>
which can be used to amend the last commit without
committing changes that have already been staged.</p>

<p style="margin-top: 1em">-u[&lt;mode&gt;],
--untracked-files[=&lt;mode&gt;] <br>
Show untracked files.</p>

<p style="margin-top: 1em">The mode parameter is optional
(defaults to all), and is used to specify the handling of
untracked files; when -u is not used, the default is normal,
i.e. show untracked <br>
files and directories.</p>

<p style="margin-top: 1em">The possible options are:</p>

<p style="margin-top: 1em">&Acirc;&middot; no - Show no
untracked files</p>

<p style="margin-top: 1em">&Acirc;&middot; normal - Shows
untracked files and directories</p>

<p style="margin-top: 1em">&Acirc;&middot; all - Also shows
individual files in untracked directories.</p>

<p style="margin-top: 1em">The default can be changed using
the status.showUntrackedFiles configuration variable
documented in git-config(1).</p>

<p style="margin-top: 1em">-v, --verbose <br>
Show unified diff between the HEAD commit and what would be
committed at the bottom of the commit message template. Note
that this diff output doesn&acirc;t have its lines prefixed
<br>
with #.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Suppress commit summary message.</p>

<p style="margin-top: 1em">--dry-run <br>
Do not create a commit, but show a list of paths that are to
be committed, paths with local changes that will be left
uncommitted and paths that are untracked.</p>

<p style="margin-top: 1em">--status <br>
Include the output of git-status(1) in the commit message
template when using an editor to prepare the commit message.
Defaults to on, but can be used to override <br>
configuration variable commit.status.</p>

<p style="margin-top: 1em">--no-status <br>
Do not include the output of git-status(1) in the commit
message template when using an editor to prepare the default
commit message.</p>

<p style="margin-top: 1em">-S[&lt;keyid&gt;],
--gpg-sign[=&lt;keyid&gt;] <br>
GPG-sign commit.</p>

<p style="margin-top: 1em">-- <br>
Do not interpret any more arguments as options.</p>

<p style="margin-top: 1em">&lt;file&gt;... <br>
When files are given on the command line, the command
commits the contents of the named files, without recording
the changes already staged. The contents of these files are
<br>
also staged for the next commit on top of what have been
staged before.</p>

<p style="margin-top: 1em">DATE FORMATS <br>
The GIT_AUTHOR_DATE, GIT_COMMITTER_DATE environment
variables and the --date option support the following date
formats:</p>

<p style="margin-top: 1em">Git internal format <br>
It is &lt;unix timestamp&gt; &lt;timezone offset&gt;, where
&lt;unix timestamp&gt; is the number of seconds since the
UNIX epoch. &lt;timezone offset&gt; is a positive or
negative offset from UTC. <br>
For example CET (which is 2 hours ahead UTC) is +0200.</p>

<p style="margin-top: 1em">RFC 2822 <br>
The standard email format as described by RFC 2822, for
example Thu, 07 Apr 2005 22:13:13 +0200.</p>

<p style="margin-top: 1em">ISO 8601 <br>
Time and date specified by the ISO 8601 standard, for
example 2005-04-07T22:13:13. The parser accepts a space
instead of the T character as well.</p>

<p style="margin-top: 1em">Note <br>
In addition, the date part is accepted in the following
formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.</p>

<p style="margin-top: 1em">EXAMPLES <br>
When recording your own work, the contents of modified files
in your working tree are temporarily stored to a staging
area called the &quot;index&quot; with git add. A file can
be reverted <br>
back, only in the index but not in the working tree, to that
of the last commit with git reset HEAD -- &lt;file&gt;,
which effectively reverts git add and prevents the changes
to this <br>
file from participating in the next commit. After building
the state to be committed incrementally with these commands,
git commit (without any pathname parameter) is used to <br>
record what has been staged so far. This is the most basic
form of the command. An example:</p>

<p style="margin-top: 1em">$ edit hello.c <br>
$ git rm goodbye.c <br>
$ git add hello.c <br>
$ git commit</p>

<p style="margin-top: 1em">Instead of staging files after
each individual change, you can tell git commit to notice
the changes to the files whose contents are tracked in your
working tree and do <br>
corresponding git add and git rm for you. That is, this
example does the same as the earlier example if there is no
other change in your working tree:</p>

<p style="margin-top: 1em">$ edit hello.c <br>
$ rm goodbye.c <br>
$ git commit -a</p>

<p style="margin-top: 1em">The command git commit -a first
looks at your working tree, notices that you have modified
hello.c and removed goodbye.c, and performs necessary git
add and git rm for you.</p>

<p style="margin-top: 1em">After staging changes to many
files, you can alter the order the changes are recorded in,
by giving pathnames to git commit. When pathnames are given,
the command makes a commit <br>
that only records the changes made to the named paths:</p>

<p style="margin-top: 1em">$ edit hello.c hello.h <br>
$ git add hello.c hello.h <br>
$ edit Makefile <br>
$ git commit Makefile</p>

<p style="margin-top: 1em">This makes a commit that records
the modification to Makefile. The changes staged for hello.c
and hello.h are not included in the resulting commit.
However, their changes are not <br>
lost &acirc; they are still staged and merely held back.
After the above sequence, if you do:</p>

<p style="margin-top: 1em">$ git commit</p>

<p style="margin-top: 1em">this second commit would record
the changes to hello.c and hello.h as expected.</p>

<p style="margin-top: 1em">After a merge (initiated by git
merge or git pull) stops because of conflicts, cleanly
merged paths are already staged to be committed for you, and
paths that conflicted are left <br>
in unmerged state. You would have to first check which paths
are conflicting with git status and after fixing them
manually in your working tree, you would stage the result as
<br>
usual with git add:</p>

<p style="margin-top: 1em">$ git status | grep unmerged
<br>
unmerged: hello.c <br>
$ edit hello.c <br>
$ git add hello.c</p>

<p style="margin-top: 1em">After resolving conflicts and
staging the result, git ls-files -u would stop mentioning
the conflicted path. When you are done, run git commit to
finally record the merge:</p>

<p style="margin-top: 1em">$ git commit</p>

<p style="margin-top: 1em">As with the case to record your
own changes, you can use -a option to save typing. One
difference is that during a merge resolution, you cannot use
git commit with pathnames to <br>
alter the order the changes are committed, because the merge
should be recorded as a single commit. In fact, the command
refuses to run when given pathnames (but see -i option).</p>

<p style="margin-top: 1em">DISCUSSION <br>
Though not required, it&acirc;s a good idea to begin the
commit message with a single short (less than 50 character)
line summarizing the change, followed by a blank line and
then a <br>
more thorough description. The text up to the first blank
line in a commit message is treated as the commit title, and
that title is used throughout Git. For example, git-format-
<br>
patch(1) turns a commit into email, and it uses the title on
the Subject line and the rest of the commit in the body.</p>

<p style="margin-top: 1em">At the core level, Git is
character encoding agnostic.</p>

<p style="margin-top: 1em">&Acirc;&middot; The pathnames
recorded in the index and in the tree objects are treated as
uninterpreted sequences of non-NUL bytes. What readdir(2)
returns are what are recorded and <br>
compared with the data Git keeps track of, which in turn are
expected to be what lstat(2) and creat(2) accepts. There is
no such thing as pathname encoding translation.</p>

<p style="margin-top: 1em">&Acirc;&middot; The contents of
the blob objects are uninterpreted sequences of bytes. There
is no encoding translation at the core level.</p>

<p style="margin-top: 1em">&Acirc;&middot; The commit log
messages are uninterpreted sequences of non-NUL bytes.</p>

<p style="margin-top: 1em">Although we encourage that the
commit log messages are encoded in UTF-8, both the core and
Git Porcelain are designed not to force UTF-8 on projects.
If all participants of a <br>
particular project find it more convenient to use legacy
encodings, Git does not forbid it. However, there are a few
things to keep in mind.</p>

<p style="margin-top: 1em">1. git commit and git
commit-tree issues a warning if the commit log message given
to it does not look like a valid UTF-8 string, unless you
explicitly say your project uses a <br>
legacy encoding. The way to say this is to have
i18n.commitencoding in .git/config file, like this:</p>

<p style="margin-top: 1em">[i18n] <br>
commitencoding = ISO-8859-1</p>

<p style="margin-top: 1em">Commit objects created with the
above setting record the value of i18n.commitencoding in its
encoding header. This is to help other people who look at
them later. Lack of <br>
this header implies that the commit log message is encoded
in UTF-8.</p>

<p style="margin-top: 1em">2. git log, git show, git blame
and friends look at the encoding header of a commit object,
and try to re-code the log message into UTF-8 unless
otherwise specified. You can <br>
specify the desired output encoding with
i18n.logoutputencoding in .git/config file, like this:</p>

<p style="margin-top: 1em">[i18n] <br>
logoutputencoding = ISO-8859-1</p>

<p style="margin-top: 1em">If you do not have this
configuration variable, the value of i18n.commitencoding is
used instead.</p>

<p style="margin-top: 1em">Note that we deliberately chose
not to re-code the commit log message when a commit is made
to force UTF-8 at the commit object level, because re-coding
to UTF-8 is not <br>
necessarily a reversible operation.</p>

<p style="margin-top: 1em">ENVIRONMENT AND CONFIGURATION
VARIABLES <br>
The editor used to edit the commit log message will be
chosen from the GIT_EDITOR environment variable, the
core.editor configuration variable, the VISUAL environment
variable, <br>
or the EDITOR environment variable (in that order). See
git-var(1) for details.</p>

<p style="margin-top: 1em">HOOKS <br>
This command can run commit-msg, prepare-commit-msg,
pre-commit, and post-commit hooks. See githooks(5) for more
information.</p>

<p style="margin-top: 1em">FILES <br>
$GIT_DIR/COMMIT_EDITMSG <br>
This file contains the commit message of a commit in
progress. If git commit exits due to an error before
creating a commit, any commit message that has been provided
by the <br>
user (e.g., in an editor session) will be available in this
file, but will be overwritten by the next invocation of git
commit.</p>

<p style="margin-top: 1em">SEE ALSO <br>
git-add(1), git-rm(1), git-mv(1), git-merge(1),
git-commit-tree(1)</p>

<p style="margin-top: 1em">GIT <br>
Part of the git(1) suite</p>

<p style="margin-top: 1em">Git 1.8.3.1 03/23/2016
GIT-COMMIT(1)</p>
<hr>
</body>
</html>
