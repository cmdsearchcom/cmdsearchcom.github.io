<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:34:42 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>QSF(1) User Manuals QSF(1)</p>

<p style="margin-top: 1em">NAME <br>
qsf - quick spam filter</p>

<p style="margin-top: 1em">SYNOPSIS <br>
Filtering: qsf [-snrAtav] [-d DB] [-g DB] <br>
[-L LVL] [-S SUBJ] [-H MARK] [-Q NUM] <br>
[-X NUM] <br>
Training: qsf -T SPAM NONSPAM [MAXROUNDS] [-d DB] <br>
Retraining: qsf -[m|M] [-d DB] [-w WEIGHT] [-ayN] <br>
Database: qsf -[p|D|R|O] [-d DB] <br>
Database merge: qsf -E OTHERDB [-d DB] <br>
Allowlist query: qsf -e EMAIL [-m|-M|-t] [-d DB] [-g DB]
<br>
Denylist query: qsf -y -e EMAIL [-m -m|-M -M|-t] [-d DB] [-g
DB] <br>
Help: qsf -[h|V]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
qsf reads a single email on standard input, and by default
outputs it on standard output. If the email is determined to
be spam, an additional header (&quot;X-Spam: YES&quot;) will
be <br>
added, and optionally the subject line can have
&quot;[SPAM]&quot; prepended to it.</p>

<p style="margin-top: 1em">qsf is intended to be used in a
procmail(1) recipe, in a ruleset such as this:</p>

<p style="margin-top: 1em">:0 wf <br>
| qsf -ra</p>

<p style="margin-top: 1em">:0 H: <br>
* X-Spam: YES <br>
$HOME/mail/spam</p>

<p style="margin-top: 1em">For more examples, including
sample procmail(1) recipes, see the EXAMPLES section
below.</p>

<p style="margin-top: 1em">TRAINING <br>
Before qsf can be used properly, it needs to be trained. A
good way to train qsf is to collect a copy of all your email
into two folders - one for spam, and one for non-spam. <br>
Once you have done this, you can use the training function,
like this:</p>

<p style="margin-top: 1em">qsf -aT spam-folder
non-spam-folder</p>

<p style="margin-top: 1em">This will generate a database
that can be used by qsf to guess whether email received in
the future is spam or not. Note that this initial training
run may take a long time, but <br>
you should only need to do it once.</p>

<p style="margin-top: 1em">To mark a single message as
spam, pipe it to qsf with the --mark-spam or -m (&quot;mark
as spam&quot;) option. This will update the database
accordingly and discard the email.</p>

<p style="margin-top: 1em">To mark a single message as
non-spam, pipe it to qsf with the --mark-nonspam or -M
(&quot;mark as non-spam&quot;) option. Again, this will
discard the email.</p>

<p style="margin-top: 1em">If a message has been
mis-tagged, simply send it to qsf as the opposite type, i.e.
if it has been mistakenly tagged as spam, pipe it into qsf
--mark-nonspam --weight=2 to add it <br>
to the non-spam side of the database with double the usual
weighting.</p>

<p style="margin-top: 1em">OPTIONS <br>
The qsf options are listed below.</p>

<p style="margin-top: 1em">-d, --database [TYPE:]FILE <br>
Use FILE as the spam/non-spam database. The default is to
use /var/lib/qsfdb and, if that is not available or is
read-only, $HOME/.qsfdb. This option can also be useful <br>
if there is a system-wide database but you do not want to
use it - specifying your own here will override the
default.</p>

<p style="margin-top: 1em">If you prefix the filename with
a TYPE, of the form btree:$HOME/.qsfdb, then this will
specify what kind of database FILE is, such as list, btree,
gdbm, sqlite and so on. <br>
Check the output of qsf -V to see which database backends
are available. The default is to auto-detect the type, or,
if the file does not already exist, use list. Note <br>
that TYPE is not case-sensitive.</p>

<p style="margin-top: 1em">-g, --global [TYPE:]FILE <br>
Use FILE as the default global database, instead of
/var/lib/qsfdb. If you also specify a database with -d, then
this &quot;global&quot; database will be used in read-only
mode in <br>
conjunction with the read-write database specified with -d.
The -g option can be used a second time to specify a third
database, which will also be used in read-only <br>
mode. Again, the filename can optionally be prefixed with a
TYPE which specifies the database type.</p>

<p style="margin-top: 1em">-P, --plain-map FILE <br>
Maintain a mapping of all database tokens to their
non-hashed counterparts in FILE, one token per line. This
can be useful if you want to be able to list the contents of
<br>
your database at a later date, for instance to get a list of
email addresses in your allow-list. Note that using this
option may slow qsf down, and only entries written <br>
to the database while this option is active will be stored
in FILE.</p>

<p style="margin-top: 1em">-s, --subject <br>
Rewrite the Subject line of any email that turns out to be
spam, adding &quot;[SPAM]&quot; to the start of the
line.</p>

<p style="margin-top: 1em">-S, --subject-marker SUBJECT
<br>
Instead of adding &quot;[SPAM]&quot;, add SUBJECT to the
Subject line of any email that turns out to be spam. Implies
-s.</p>

<p style="margin-top: 1em">-H, --header-marker MARK <br>
Instead of setting the X-Spam header to &quot;YES&quot;, set
it to MARK if email turns out to be spam. This can be useful
if your email client can only search all headers for a <br>
string, rather than one particular header (so searching for
&quot;YES&quot; might match more than just the output of
qsf).</p>

<p style="margin-top: 1em">-n, --no-header <br>
Do not add an X-Spam header to messages.</p>

<p style="margin-top: 1em">-r, --add-rating <br>
Insert an additional header X-Spam-Rating which is a rating
of the &quot;spamminess&quot; of a message from 0 to 100; 90
and above are counted as spam, anything under 90 is not
con&acirc; <br>
sidered spam. If combined with -t, then the rating (0-100)
will be output, on its own, on standard output.</p>

<p style="margin-top: 1em">-A, --asterisk <br>
Insert an additional header X-Spam-Level which will contain
between 0 and 20 asterisks (*), depending on the spam
rating.</p>

<p style="margin-top: 1em">-t, --test <br>
Instead of passing the message out on standard output,
output nothing, and exit 0 if the message is not spam, or
exit 1 if the message is spam. If combined with -r, then
<br>
the spam rating will be output on standard output.</p>

<p style="margin-top: 1em">-a, --allowlist <br>
Enable the allow-list. This causes the email addresses given
in the message&rsquo;s &quot;From:&quot; and
&quot;Return-Path:&quot; headers to be checked against a
list; if either one matches, then <br>
the message is always treated as non-spam, regardless of
what the token database says. When specified with a
retraining flag, -a -m (mark as spam) will remove that
address <br>
from the allow-list as well as marking the message as spam,
and -a -M (mark as non-spam) will add that address to the
allow-list as well as marking the message as non- <br>
spam. The idea is that you add all of your friends to the
allow-list, and then none of their messages ever get marked
as spam.</p>

<p style="margin-top: 1em">-y, --denylist <br>
Enable the deny-list. This causes the email addresses given
in the message&rsquo;s &quot;From:&quot; and
&quot;Return-Path:&quot; headers to be checked against a
second list; if either one <br>
matches, then theh message is always treated as spam.
Training works in the same way as with -a, except that you
must specify -m or -M twice to modify the deny-list <br>
instead of the allow-list, and with the reverse syntax: -y
-m -m (mark as spam) will add that address to the deny-list,
whereas -y -M -M (mark as non-spam) will remove <br>
that address from the deny-list. This double specification
is so that the usual retraining process never touches the
deny-list; the deny-list should be carefully main&acirc;
<br>
tained rather than automatically generated.</p>

<p style="margin-top: 1em">Normally you would not need to
use the deny-list.</p>

<p style="margin-top: 1em">-L, --level, --threshold LEVEL
<br>
Change the spam scoring threshold level which must be
reached before an email is classified as spam. The default
is 90.</p>

<p style="margin-top: 1em">-Q, --min-tokens NUM <br>
Only give a score if more than NUM tokens are found in the
message - otherwise the message is assumed to be non-spam,
and it is not modified in any way. The default is 0. <br>
This option might be useful if you find that very short
messages are being frequently miscategorised.</p>

<p style="margin-top: 1em">-e, --email, --email-only EMAIL
<br>
Query or update the allow-list entry for the email address
EMAIL. With no other options, this will simply output
&quot;YES&quot; if EMAIL is in the allow-list, or
&quot;NO&quot; if it is <br>
not. With -t, it will not output anything, but will exit 0
(success) if EMAIL is in the allow-list, or 1 (failure) if
it is not. With the -m (mark-spam) option, any previ&acirc;
<br>
ous allow-list entry for EMAIL will be removed. Finally,
with the -M (mark-nonspam) option, EMAIL will be added to
the allow-list if it is not already on it.</p>

<p style="margin-top: 1em">If EMAIL is just the word MSG on
its own, then an email will be read from standard input, and
the email addresses given in the &quot;From:&quot; and
&quot;Return-Path:&quot; headers will be <br>
used.</p>

<p style="margin-top: 1em">Using -e automatically switches
on -a.</p>

<p style="margin-top: 1em">If you also specify -y, then the
deny-list will be operated on. Remember that -m and -M are
reversed with the deny-list.</p>

<p style="margin-top: 1em">If you specify an email address
of the form @domain (nothing before the @), then the whole
domain will be allow or deny listed.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Add extra X-QSF-Info headers to any filtered email,
containing error messages and so on if applicable. Specify
-v more than once to increase verbosity.</p>

<p style="margin-top: 1em">-T, --train SPAM NONSPAM
[MAXROUNDS] <br>
Train the database using the two mbox folders SPAM and
NONSPAM, by testing each message in each folder and updating
the database each time a message is miscategorised. <br>
This is done several times, and may take a while to run.
Specify the -a (allow-list) flag to add every sender in the
NONSPAM folder to your allow-list as a side-effect of <br>
the training process. If MAXROUNDS is specified, training
will end after this number of rounds if the results are
still not good enough. The default is a maximum of 200 <br>
rounds.</p>

<p style="margin-top: 1em">-m, --mark-spam <br>
Instead of passing the message out on standard output, mark
its contents as spam and update the database accordingly. If
the allow-list (-a) is enabled, the message&rsquo;s <br>
&quot;From:&quot; and &quot;Return-Path:&quot; addresses are
removed from the allow-list. If the deny-list (-y) is
enabled and you specify -m twice, the message&rsquo;s
addresses are added to the <br>
deny-list instead.</p>

<p style="margin-top: 1em">-M, --mark-nonspam <br>
Instead of passing the message out on standard output, mark
its contents as non-spam and update the database
accordingly. If the allow-list (-a) is enabled, the
message&rsquo;s <br>
&quot;From:&quot; and &quot;Return-Path:&quot; addresses are
added to the allow-list (see the -a option above). If the
deny-list (-y) is enabled and you specify -M twice, the
message&rsquo;s <br>
addresses are removed from the deny-list instead.</p>

<p style="margin-top: 1em">-w, --weight WEIGHT <br>
When marking as spam or non-spam, update the database with a
weighting of WEIGHT per token instead of the default of 1.
Useful when correcting mistakes, eg a message that <br>
has been mistakenly detected as spam should be marked as
non-spam using a weighting of 2, i.e. double the usual
weighting, to counteract the error.</p>

<p style="margin-top: 1em">-D, --dump [FILE] <br>
Dump the contents of the database as a platform-independent
text file, suitable for archival, transfer to another
machine, and so on. The data is output on stdout or into
<br>
the given FILE.</p>

<p style="margin-top: 1em">-R, --restore [FILE] <br>
Rebuild the database from scratch from the text file on
stdin. If a FILE is given, data is read from there instead
of from stdin.</p>

<p style="margin-top: 1em">-O, --tokens <br>
Instead of filtering, output a list of the tokens found in
the message read from standard input, along with the number
of times each token was found. This is only useful <br>
if you want to use qsf as a general tokeniser for use with
another filtering package.</p>

<p style="margin-top: 1em">-E, --merge OTHERDB <br>
Merge the OTHERDB database into the current database. This
can be useful if you want to take one user&rsquo;s mailbox
and merge it into the system-wide one, for instance (this
<br>
would be done by, as root, doing qsf -d /var/lib/qsfdb -E
/home/user/.qsfdb and then removing /home/user/.qsfdb).</p>

<p style="margin-top: 1em">-B, --benchmark SPAM NONSPAM
[MAXROUNDS] <br>
Benchmark the training process using the two mbox folders
SPAM and NONSPAM. A temporary database is created and
trained using the first 75% of the messages in each <br>
folder, and then the entire contents of each folder is
tested to see how many false positives and false negatives
occur. Some timing information is also displayed.</p>

<p style="margin-top: 1em">This can be used to decide which
backend is best on your system. Use -d to select a backend,
eg qsf -B spam nonspam -d GDBM - this will create a
temporary database which <br>
is removed afterwards.</p>

<p style="margin-top: 1em">The exception to this is the
MySQL backend, where a full database specification must be
given (-d MySQL:database=db;host=localhost;...) and the
database table given will <br>
not be wiped beforehand or dropped afterwards.</p>

<p style="margin-top: 1em">As with -T, if MAXROUNDS is
specified, training will never be done for more than this
number of rounds; the default is 200.</p>

<p style="margin-top: 1em">-h, --help <br>
Print a usage message on standard output and exit
successfully.</p>

<p style="margin-top: 1em">-V, --version <br>
Print version information, including a list of available
database backends, on standard output and exit
successfully.</p>

<p style="margin-top: 1em">DEPRECATED OPTIONS <br>
The following options are only for use with the old binary
tree database backend or old databases that haven&rsquo;t
been upgraded to the new format that came in with version
1.1.0.</p>

<p style="margin-top: 1em">-N, --no-autoprune <br>
When marking as spam or nonspam, never automatically prune
the database. Usually the database is pruned after every 500
marks; if you would rather --prune manually, use <br>
-N to disable automatic pruning.</p>

<p style="margin-top: 1em">-p, --prune <br>
Remove redundant entries from the database and clean it up a
little. This is automatically done after several calls to
--mark-spam or --mark-nonspam, and during training <br>
with --train if the training takes a large number of rounds,
so it should rarely be necessary to use --prune manually
unless you are using -N / --no-autoprune.</p>

<p style="margin-top: 1em">-X, --prune-max NUM <br>
When the database is being pruned, no more than NUM entries
will be considered for removal. This is to prevent CPU and
memory resources being taken over. The default is <br>
100,000 but in some circumstances (if you find that pruning
takes too long) this option may be used to reduce it to a
more manageable number.</p>

<p style="margin-top: 1em">FILES <br>
/var/lib/qsfdb <br>
The default (system-wide) spam database. If you wish to
install qsf system-wide, this should be read-only to
everyone; there should be one user with write access who can
<br>
update the spam database with qsf --mark-spam and qsf
--mark-non-spam when necessary.</p>

<p style="margin-top: 1em">/var/lib/qsfdb2 <br>
A second, read-only, system-wide database. This can be
useful when installing qsf system-wide and using third-party
spam databases; the first global database can be <br>
updated with system-specific changes, and this second
database can be periodically updated when the third-party
spam database is updated.</p>

<p style="margin-top: 1em">$HOME/.qsfdb <br>
The default spam database for per-user data. Users without
write access to the system-wide database will have their
data written here, and the two databases will be read <br>
together. The per-user database will be given a weighting
equivalent to 10 times the weighting of the global
database.</p>

<p style="margin-top: 1em">NOTES <br>
Currently, you cannot use qsf to check for spam while the
database is being updated. This means that while an update
is in progress, all email is passed through as non-spam.</p>

<p style="margin-top: 1em">There is an upper size limit of
512Kb on incoming email; anything larger than this is just
passed through as non-spam, to avoid tying up machine
resources.</p>

<p style="margin-top: 1em">The plaintext token mapping
maintained by --plain-map will never shrink, only grow. It
is intended for use by housekeeping and user interface
scripts that, for instance, the <br>
user can use to list all email addresses on their
allow-list. These scripts should take care of weeding out
entries for tokens that are no longer in the database. If
you have <br>
no such scripts, there is probably no point in using
--plain-map anyway.</p>

<p style="margin-top: 1em">Avoid using the deny-list (-y)
in any automated retraining, as it can be cause the filter
to reject mail unnecessarily. In general the deny-list is
probably best left unused <br>
unless explicitly required by your particular setup.</p>

<p style="margin-top: 1em">If both the allow-list and the
deny-list are enabled, then email addresses will first be
checked against the deny-list, then the allow-list, then the
domain of the email address <br>
will be checked for matching &quot;@domain&quot; entries in
the deny-list and then in the allow-list.</p>

<p style="margin-top: 1em">EXAMPLES <br>
To filter all of your mail through qsf, with the allow-list
enabled and the &quot;spam rating&quot; header being added,
add this to your .procmailrc file:</p>

<p style="margin-top: 1em">:0 wf <br>
| qsf -ra</p>

<p style="margin-top: 1em">If you want qsf to add
&quot;[SPAM]&quot; to the subject line of any messages it
thinks are spam, do this instead:</p>

<p style="margin-top: 1em">:0 wf <br>
| qsf -sra</p>

<p style="margin-top: 1em">To automatically mark any email
sent to spambox@yourdomain.com as spam (this is the
&quot;naive&quot; version):</p>

<p style="margin-top: 1em">:0 H <br>
* ^To:.*spambox@yourdomain.com <br>
| qsf -am</p>

<p style="margin-top: 1em">To do the same, but cleverly, so
that only email to spambox@yourdomain.com which qsf does NOT
already classify as spam gets marked as spam in the database
(this stops the data&acirc; <br>
base getting too heavily weighted):</p>

<p style="margin-top: 1em"># If sent to
spambox@yourdomain.com: <br>
:0 <br>
* ^To:.*spambox@yourdomain.com <br>
{ <br>
:0 wf <br>
| qsf -a</p>

<p style="margin-top: 1em"># The above two lines can be
skipped if you&rsquo;ve <br>
# already piped the message through qsf.</p>

<p style="margin-top: 1em"># If the qsf database says
it&rsquo;s not spam, <br>
# mark it as spam! <br>
:0 H <br>
* ^X-Spam: NO <br>
| qsf -am <br>
}</p>

<p style="margin-top: 1em">Remove the -a option in the
above examples if you don&rsquo;t want to use the
allow-list.</p>

<p style="margin-top: 1em">A more complicated filtering
example - this will only run qsf on messages which
don&rsquo;t have a subject line saying &quot;your
&lt;something&gt; is on fire&quot; and which don&rsquo;t
have a sender <br>
address ending in &quot;@foobar.com&quot;, meaning that
messages with that subject line OR that sender address will
NEVER be marked as spam, no matter what:</p>

<p style="margin-top: 1em">:0 wf <br>
* ! ^Subject: Your .* is on fire <br>
* ! ^From: .*@foobar.com <br>
| qsf -ra</p>

<p style="margin-top: 1em">For more on procmail(1) recipes,
see the procmailrc(5) and procmailex(5) manual pages.</p>

<p style="margin-top: 1em">A couple of macros to add to
your .muttrc file, if you use mutt(1) as a mail user
agent:</p>

<p style="margin-top: 1em"># Press F5 to mark a message as
spam and delete it <br>
macro index &lt;f5&gt; &quot;&lt;pipe-message&gt;qsf
-am0delete-message&gt;&quot; <br>
macro pager &lt;f5&gt; &quot;&lt;pipe-message&gt;qsf
-am0delete-message&gt;&quot;</p>

<p style="margin-top: 1em"># Press F9 to mark a message as
non-spam <br>
macro index &lt;f9&gt; &quot;&lt;pipe-message&gt;qsf -aM0
<br>
macro pager &lt;f9&gt; &quot;&lt;pipe-message&gt;qsf
-aM0</p>

<p style="margin-top: 1em">Again, remove the -a option in
the above examples if you don&rsquo;t want to use the
allow-list.</p>

<p style="margin-top: 1em">Note, however, that the above
macros won&rsquo;t work when operating on multiple tagged
messages. For that, you&rsquo;d need something like
this:</p>

<p style="margin-top: 1em">macro index &lt;f5&gt;
&quot;:set pipe_split0tag-prefix&gt;&lt;pipe-message&gt;qsf
-am0tag-prefix&gt;&lt;delete-message&gt;0unset
pipe_split0</p>

<p style="margin-top: 1em">If you use qmail(7), then to get
procmail working with it you will need to put a line
containing just DEFAULT=./Maildir/ at the top of your
~/.procmailrc file, so that procmail <br>
delivers to your Maildir folder instead of trying to deliver
to /var/spool/mail/$USER, and you will need to put this in
your ~/.qmail file:</p>

<p style="margin-top: 1em">| preline procmail</p>

<p style="margin-top: 1em">This will cause all your mail to
be delivered via procmail instead of being delivered
directly into your mail directory.</p>

<p style="margin-top: 1em">See the qmail(7) documentation
for more about mail delivery with qmail.</p>

<p style="margin-top: 1em">If you use postfix(1), you can
set up a system-wide mail filter by creating a user account
for the purpose of filtering mail, populating that
account&rsquo;s .qsfdb, and then creating <br>
a shell script, to run as that user, which runs qsf on stdin
and passes stdout to sendmail(8).</p>

<p style="margin-top: 1em">Doing this requires some
knowledge of postfix configuration and care needs to be
taken to avoid mail loops. One qsf user&rsquo;s full HOWTO
is included in the doc/ directory with this <br>
package.</p>

<p style="margin-top: 1em">THE ALLOW-LIST <br>
A feature called the &quot;allow-list&quot; can be switched
on by specifying the --allowlist or -a option. This causes
messages&rsquo; &quot;From:&quot; and
&quot;Return-Path:&quot; addresses to be checked against
<br>
a list of people you have said to allow all messages from,
and if a message&rsquo;s &quot;From:&quot; or
&quot;Return-Path:&quot; address is in the list, it is never
marked as spam. This means you can <br>
add all your friends to an &quot;allow-list&quot; and qsf
will then never mis-file their messages - a quick way to do
this is to use -a with -T (train); everyone in your non-spam
folder <br>
who has sent you an email will be added to the allow-list
automatically during training.</p>

<p style="margin-top: 1em">You can manually add and remove
addresses to and from the allow-list using the -e (email)
option. For instance, to add foo@bar.com to the allow-list,
do this:</p>

<p style="margin-top: 1em">qsf -e foo@bar.com -M</p>

<p style="margin-top: 1em">To remove bad@nasty.com from the
allow-list, do this:</p>

<p style="margin-top: 1em">qsf -e bad@nasty.com -m</p>

<p style="margin-top: 1em">And to see whether
someone@somewhere.com is in the allow-list or not, just do
this:</p>

<p style="margin-top: 1em">qsf -e someone@somewhere.com</p>

<p style="margin-top: 1em">In general, you probably always
want to enable the allow-list, so always specify the -a
option when using qsf. This will automatically maintain the
allow-list based on what you <br>
classify as spam or non-spam.</p>

<p style="margin-top: 1em">The only times you might want to
turn it off are when people on your allow-list are prone to
getting viruses or if a virus is causing email to be sent to
you that is pretending <br>
to be from someone on your allow-list.</p>

<p style="margin-top: 1em">BACKUP AND RESTORE <br>
Because the database format is platform-specific, it is a
good idea to periodically dump the database to a text file
using qsf -D so that, if necessary, it can be transferred to
<br>
another machine and restored with qsf -R later on.</p>

<p style="margin-top: 1em">Also note that since the actual
contents of email messages are never stored in the database
(see TECHNICAL DETAILS), you can safely share your qsf
database with friends - simply <br>
dump your database to a file, like this:</p>

<p style="margin-top: 1em">qsf -D &gt;
your-database-dump.txt</p>

<p style="margin-top: 1em">Once you have sent
your-database-dump.txt to another person, they can do
this:</p>

<p style="margin-top: 1em">qsf -R &lt;
your-database-dump.txt</p>

<p style="margin-top: 1em">They will then have an identical
database to yours.</p>

<p style="margin-top: 1em">TECHNICAL DETAILS <br>
When a message is passed to qsf, any attachments are
decoded, all HTML elements are removed, and the message text
is then broken up into &quot;tokens&quot;, where a
&quot;token&quot; is a single <br>
word or URL. Each token is hashed using the MD5 algorithm
(see below for why), and that hash is then used to look up
each token in the qsf database.</p>

<p style="margin-top: 1em">For full details of which parts
of an email (headers, body, attachments, etc) are used to
calculate the spam rating, see the TOKENISATION section
below.</p>

<p style="margin-top: 1em">Within the database, each token
has two numbers associated with it: the number of times that
token has been seen in spam, and the number of times it has
been seen in non-spam. <br>
These two numbers, along with the total number of spam and
non-spam messages seen, are then used to give a
&quot;spamminess&quot; value for that particular token. This
&quot;spamminess&quot; value <br>
ranges from &quot;definitely not spammy&quot; at one end of
the scale, through &quot;neutral&quot; in the middle, up to
&quot;definitely spammy&quot; at the other end.</p>

<p style="margin-top: 1em">Once a &quot;spamminess&quot;
value has been calculated for all of the tokens in the
message, a summary calculation is made to give an overall
&quot;is this spam?&quot; probability rating for the <br>
message. If the overall probability is 0.9 or above, the
message is flagged as spam.</p>

<p style="margin-top: 1em">In addition to the probability
test is the &quot;allow-list&quot;. If enabled (with the -a
option), the whole probability check is skipped if the
sender of the message is listed in the <br>
allow-list, and the message is not marked as spam.</p>

<p style="margin-top: 1em">When training the database, a
message is split up into tokens as described above, and then
the numbers in the database for each token are simply added
to: if you tell qsf that a <br>
message is spam, it adds one to the &quot;number of times
seen in spam&quot; counter for each token, and if you tell
it a message is not spam, it adds one to the &quot;number of
times seen in <br>
non-spam&quot; counter for each token. If you specify a
weight, with -w, then the number you specify is added
instead of one.</p>

<p style="margin-top: 1em">To stop the database growing
uncontrollably, the database keeps track of when a token was
last used. Underused tokens are automatically removed from
the database. (The old <br>
method was to &quot;prune&quot; every 500 updates).</p>

<p style="margin-top: 1em">Finally, the reason MD5 hashes
were used is privacy. If the actual tokens from the
messages, and the actual email addresses in the allow-list,
were stored, you could not share a <br>
single qsf database between multiple users because bits of
everyone&rsquo;s messages would be in the database - things
like emailed passwords, keywords relating to personal
gossip, and <br>
so on. So a hash is stored instead. A hash is a
&quot;one-way&quot; function; it is easy to turn a token
into a hash but very hard (some might say impossible) to
turn a hash back into <br>
the token that created it. This means that you end up with a
database with no personal information in it.</p>

<p style="margin-top: 1em">TOKENISATION <br>
When a message is broken up into tokens, various parts of
the message are treated in different ways.</p>

<p style="margin-top: 1em">First, all header fields are
discarded, except for the important ones: From, Return-Path,
Sender, To, Reply-To, and Subject.</p>

<p style="margin-top: 1em">Next, any MIME-encoded
attachments are decoded. Any attachments whose MIME type
starts with &quot;text/&quot; (i.e. HTML and text) are
tokenised, after having any HTML tags stripped. Any <br>
non-textual attachments are replaced with their MD5 hash
(such that two identical attachments will have the same
hash), and that hash is then used as a token.</p>

<p style="margin-top: 1em">In addition to single-word
tokens from textual message parts, qsf adds doubled-up
tokens so that word pairs get added to the database. This
makes the database a bit bigger <br>
(although the automatic pruning tends to take care of that)
but makes matching more exact.</p>

<p style="margin-top: 1em">SPECIAL FILTERS <br>
As well as using the textual content of email to detect
spam, qsf also uses special filters which create
&quot;pseudo-tokens&quot; based on various rules. This means
that specific pat&acirc; <br>
terns, not just individual words, can be used to determine
whether a message is spam or not.</p>

<p style="margin-top: 1em">For example, if a message
contains lots of words with multiple consonants, like
&quot;ashjkbnxcsdjh&quot;, then each time a word like that
is seen the special token &quot;.GIBBERISH-CONSO&acirc; <br>
NANTS.&quot; is added to the list of tokens found in the
message. If it turns out that most messages with words that
trigger this filter rule are spam, then other messages with
gib&acirc; <br>
berish consonant strings will be more likely to be flagged
as spam.</p>

<p style="margin-top: 1em">Currently the special filters
are:</p>

<p style="margin-top: 1em">GTUBE Flags any message
containing the string
XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X
as spam - useful for testing that your qsf installation is
<br>
working.</p>

<p style="margin-top: 1em">ATTACH-SCR</p>

<p style="margin-top: 1em">ATTACH-PIF</p>

<p style="margin-top: 1em">ATTACH-EXE</p>

<p style="margin-top: 1em">ATTACH-VBS</p>

<p style="margin-top: 1em">ATTACH-VBA</p>

<p style="margin-top: 1em">ATTACH-LNK</p>

<p style="margin-top: 1em">ATTACH-COM</p>

<p style="margin-top: 1em">ATTACH-BAT <br>
Adds a token for every attachment whose filename ends in
&quot;.scr&quot;, &quot;.pif&quot;, &quot;.exe&quot;,
&quot;.vbs&quot;, &quot;.vba&quot;, &quot;.lnk&quot;,
&quot;.com&quot;, and &quot;.bat&quot; respectively (these
are often viruses).</p>

<p style="margin-top: 1em">ATTACH-GIF</p>

<p style="margin-top: 1em">ATTACH-JPG</p>

<p style="margin-top: 1em">ATTACH-PNG <br>
Adds a token for every attachment whose filename ends in
&quot;.gif&quot;, &quot;.jpg&quot; or &quot;.jpeg&quot;, and
&quot;.png&quot; respectively.</p>

<p style="margin-top: 1em">ATTACH-DOC</p>

<p style="margin-top: 1em">ATTACH-XLS</p>

<p style="margin-top: 1em">ATTACH-PDF <br>
Adds a token for every attachment whose filename ends in
&quot;.doc&quot;, &quot;.xls&quot;, or &quot;.pdf&quot;
respectively (these tend to indicate a non-spam email).</p>

<p style="margin-top: 1em">SINGLE-IMAGE <br>
Adds a token if the message contains exactly one attached
image.</p>

<p style="margin-top: 1em">MULTIPLE-IMAGES <br>
Adds a token if the message contains more than one attached
image.</p>

<p style="margin-top: 1em">GIBBERISH-CONSONANTS <br>
Adds a token for every word found that has multiple
consonants in a row, as described above. Spam often contains
strings of gibberish.</p>

<p style="margin-top: 1em">GIBBERISH-VOWELS <br>
Adds a token for every word found that has multiple vowels
in a row, eg &quot;aeaiaiaeeio&quot;.</p>

<p style="margin-top: 1em">GIBBERISH-FROMCONS <br>
Like GIBBERISH-CONSONANTS, but only for the
&quot;From:&quot; and &quot;Return-Path:&quot; addresses on
their own.</p>

<p style="margin-top: 1em">GIBBERISH-FROMVOWL <br>
Like GIBBERISH-VOWELS, but only for the &quot;From:&quot;
and &quot;Return-Path:&quot; addresses on their own.</p>

<p style="margin-top: 1em">GIBBERISH-BADSTART <br>
Adds a token for every word that starts with a bad character
such as %.</p>

<p style="margin-top: 1em">GIBBERISH-HYPHENS <br>
Adds a token for every word with more than three hyphens or
underscores in it.</p>

<p style="margin-top: 1em">GIBBERISH-LONGWORDS <br>
Adds a token for every word with over 30 characters in it
(but less than 60).</p>

<p style="margin-top: 1em">HTML-COMMENTS-IN-WORDS <br>
Adds a token for every HTML comment found in the middle of a
word. Spam often contains HTML inside words, like this:
w&lt;!--dsgfhsdgjgh--&gt;ord</p>

<p style="margin-top: 1em">HTML-EXTERNAL-IMG <br>
Adds a token for every HTML &lt;img&gt; (image) tag found
that contains :// (i.e. it refers to an external image).</p>

<p style="margin-top: 1em">HTML-FONT <br>
Adds a token for every HTML &lt;font&gt; tag found.</p>

<p style="margin-top: 1em">HTML-IP-IN-URLS <br>
Adds a token for every URL found containing an IP
address.</p>

<p style="margin-top: 1em">HTML-INT-IN-URL <br>
Adds a token for every URL found containing an integer in
its hostname.</p>

<p style="margin-top: 1em">HTML-URLENCODED-URL <br>
Adds a token for every URL found containing a % sign in its
hostname.</p>

<p style="margin-top: 1em">Normally, filters will just
cause a token to be added, and these tokens are processed by
the normal weighting algorithm. However the GTUBE filter
will immediately flag any <br>
matching message as spam, bypassing the token matching.</p>

<p style="margin-top: 1em">DATABASE BACKENDS <br>
The inbuilt &quot;list&quot; database backend will not
necessarily provide the best performance, but is provided
because using it requires no external libraries.</p>

<p style="margin-top: 1em">If, when qsf was compiled, the
correct libraries were available, then it will be possible
to use qsf with alternative database backends. To find out
which backends you have <br>
available, run qsf -V (capital V) and read the second line
of output. To see how well a backend performs, collect some
spam and non-spam and use qsf -d BACKEND -B SPAM NONSPAM
<br>
(see the entry for -B above).</p>

<p style="margin-top: 1em">Some people find that they get
the best performance out of the gdbm backend; this is a
library that is widely available on many systems.</p>

<p style="margin-top: 1em">To efficiently share a qsf
database across multiple machines, you may find the MySQL
backend useful. However, using it is a little more
complicated.</p>

<p style="margin-top: 1em">To use the MySQL backend you
will need to create a table with the fields key1, key2,
token, value1, value2 and value3. The token, value1, value2,
and value3 fields must be VAR&acirc; <br>
CHAR(64), BIGINT or INT, and BIGINT or INT respectively, and
indexing on the token field is a good idea. The key1 and
key2 fields can be anything, but they must be present.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">USE mydatabase; <br>
CREATE TABLE qsfdb ( <br>
key1 BIGINT UNSIGNED NOT NULL, <br>
key2 BIGINT UNSIGNED NOT NULL, <br>
token VARCHAR(64) DEFAULT &rsquo;&rsquo; NOT NULL, <br>
value1 INT UNSIGNED NOT NULL, <br>
value2 INT UNSIGNED NOT NULL, <br>
value3 INT UNSIGNED NOT NULL, <br>
PRIMARY KEY (key1,key2,token), <br>
KEY (key1), <br>
KEY (key2), <br>
KEY (token) <br>
);</p>

<p style="margin-top: 1em">The key1 and key2 fields allow
you to have multiple qsf databases in one table, by
specifying different key1 and key2 values on invocation.</p>

<p style="margin-top: 1em">Instead of specifying a database
file with the --database / -d option, you must specify
either a specification string as described below, or the
name of a file containing such a <br>
string on its first line.</p>

<p style="margin-top: 1em">The specification string is as
follows:</p>


<p style="margin-top: 1em">database=DATABASE;host=HOST;port=PORT;
<br>
user=USER;pass=PASS;table=TABLE; <br>
key1=KEY1;key2=KEY2</p>

<p style="margin-top: 1em">This string must be all on one
line, with no spaces.</p>

<p style="margin-top: 1em">DATABASE <br>
is the name of the MySQL database.</p>

<p style="margin-top: 1em">HOST is the hostname of the
database server (eg &quot;localhost&quot;).</p>

<p style="margin-top: 1em">PORT is the TCP port to connect
on (eg 3306).</p>

<p style="margin-top: 1em">USER is the username to connect
with.</p>

<p style="margin-top: 1em">PASS is the password to connect
with.</p>

<p style="margin-top: 1em">TABLE is the database table to
use. If a table with this name does not exist when qsf is
called in update or training mode, then it will be created
if permissions allow this to <br>
be done.</p>

<p style="margin-top: 1em">KEY1 is the value to use for the
key1 field.</p>

<p style="margin-top: 1em">KEY2 is the value to use for the
key2 field.</p>

<p style="margin-top: 1em">Since command lines can be seen
in the process list, it is probably best to specify a
filename (eg qsf -d mysql:qsfdb.spec) and put the
specification string inside that file.</p>

<p style="margin-top: 1em">TROUBLESHOOTING <br>
If you have problems with qsf, please check the list below;
if this does not help, go to the qsf home page and
investigate the mailing lists, or email the author.</p>

<p style="margin-top: 1em">Nothing is being marked as spam.
<br>
First, use the -r option to switch on the X-Spam-Rating
header, and check that this header appears in email passed
through qsf. If it does not, then it is likely that qsf <br>
is not being run at all - check your configuration of
procmail(1) or its equivalent.</p>

<p style="margin-top: 1em">If you are seeing X-Spam-Rating
headers, and different emails have different scores, then
you may simply need to retrain your database a little more.
Take more spam email <br>
and pass it to qsf -m.</p>

<p style="margin-top: 1em">If you are seeing X-Spam-Rating
headers but they all give the same spam rating, then the
most likely reason is that qsf is not reading any database.
Make sure that what&acirc; <br>
ever is processing the email has read permissions on
/var/lib/qsfdb and/or ~/.qsfdb - and make sure that, if you
are using ~/.qsfdb, what your database creator thought was
<br>
~ ($HOME) is the same as it is for whatever is processing
the email.</p>

<p style="margin-top: 1em">Retraining sometimes takes a
very long time. <br>
With the obtree backend or 2-column MySQL or SQLite tables,
every 500th retrain (-m or -M), the database is pruned. On
some systems this may take some time, and during <br>
this time the database is locked (except when using the
MySQL or SQLite backends). If you constantly do a lot of
retraining and want to avoid this, then use the -N option
<br>
to suppress auto-pruning, and then have a cron(8) job or
something run a manual prune (qsf -p) every now and
again.</p>

<p style="margin-top: 1em">Running qsf from procmail fails
with an error. <br>
If you can run qsf from the command line, but in your
procmail log file you get errors about &quot;qsf: cannot
execute binary file&quot;, then contact your system
administrator for <br>
help. It may be that incoming email is handled by a
different server to the one you normally shell into, and
either they are of a different architecture or operating
sys&acirc; <br>
tem, or the mail server is not permitted to execute
user-owned binaries.</p>

<p style="margin-top: 1em">ACKNOWLEDGEMENTS <br>
The following people have contributed suggestions, comments,
patches, and testing:</p>

<p style="margin-top: 1em">Tom Parker
&lt;http://www.bits.bris.ac.uk/palfrey/&gt; <br>
Dr Kelly A. Parker <br>
Vesselin Mladenov &lt;http://www.antipodes.bg/&gt; <br>
Glyn Faulkner <br>
Mark Reynolds <br>
Sam Roberts <br>
Scott Allen <br>
Karsten Kankowski <br>
M. Kolbl <br>
Micha Holzmann <br>
Jef Poskanzer &lt;http://www.acme.com/jef/&gt; <br>
Clemens Fischer &lt;http://ino-waiting.gmxhome.de/&gt; <br>
Nelson A. de Oliveira <br>
Michal Vitecek <br>
Tommy Pettersson &lt;http://www.lysator.liu.se/~ptp/&gt;</p>

<p style="margin-top: 1em">AUTHOR <br>
The author:</p>

<p style="margin-top: 1em">Andrew Wood
&lt;andrew.wood@ivarch.com&gt; <br>
http://www.ivarch.com/</p>

<p style="margin-top: 1em">Project home page:</p>


<p style="margin-top: 1em">http://www.ivarch.com/programs/qsf/</p>

<p style="margin-top: 1em">BUGS <br>
If you find any bugs, please contact the author, either by
email or by using the contact form on the web site.</p>

<p style="margin-top: 1em">SEE ALSO <br>
procmail(1), procmailrc(5), procmailex(5)</p>

<p style="margin-top: 1em">Someone has written a guide to
using qsf with KMail that can be found at: <br>

http://www.softwaredesign.co.uk/Information.SpamFilters.html</p>

<p style="margin-top: 1em">LICENSE <br>
This is free software, distributed under the ARTISTIC 2.0
license.</p>

<p style="margin-top: 1em">Linux August 2007 QSF(1)</p>
<hr>
</body>
</html>
