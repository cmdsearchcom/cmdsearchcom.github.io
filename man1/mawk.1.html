<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:24:05 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAWK(1) USER COMMANDS MAWK(1)</p>

<p style="margin-top: 1em">NAME <br>
mawk - pattern scanning and text processing language</p>

<p style="margin-top: 1em">SYNOPSIS <br>
mawk [-W option] [-F value] [-v var=value] [--]
&rsquo;program text&rsquo; [file ...] <br>
mawk [-W option] [-F value] [-v var=value] [-f program-file]
[--] [file ...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
mawk is an interpreter for the AWK Programming Language. The
AWK language is useful for manipulation of data files, text
retrieval and processing, and for prototyping and
exper&acirc; <br>
imenting with algorithms. mawk is a new awk meaning it
implements the AWK language as defined in Aho, Kernighan and
Weinberger, The AWK Programming Language, Addison-Wesley
Pub&acirc; <br>
lishing, 1988. (Hereafter referred to as the AWK book.) mawk
conforms to the Posix 1003.2 (draft 11.3) definition of the
AWK language which contains a few features not <br>
described in the AWK book, and mawk provides a small number
of extensions.</p>

<p style="margin-top: 1em">An AWK program is a sequence of
pattern {action} pairs and function definitions. Short
programs are entered on the command line usually enclosed in
&rsquo; &rsquo; to avoid shell interpre&acirc; <br>
tation. Longer programs can be read in from a file with the
-f option. Data input is read from the list of files on the
command line or from standard input when the list is <br>
empty. The input is broken into records as determined by the
record separator variable, RS. Initially, RS = &quot;0 and
records are synonymous with lines. Each record is compared
<br>
against each pattern and if it matches, the program text for
{action} is executed.</p>

<p style="margin-top: 1em">OPTIONS <br>
-F value sets the field separator, FS, to value.</p>

<p style="margin-top: 1em">-f file Program text is read
from file instead of from the command line. Multiple -f
options are allowed.</p>

<p style="margin-top: 1em">-v var=value assigns value to
program variable var.</p>

<p style="margin-top: 1em">-- indicates the unambiguous end
of options.</p>

<p style="margin-top: 1em">The above options will be
available with any Posix compatible implementation of AWK,
and implementation specific options are prefaced with -W.
mawk provides six:</p>

<p style="margin-top: 1em">-W version mawk writes its
version and copyright to stdout and compiled limits to
stderr and exits 0.</p>

<p style="margin-top: 1em">-W dump writes an assembler like
listing of the internal representation of the program to
stdout and exits 0 (on successful compilation).</p>

<p style="margin-top: 1em">-W interactive sets unbuffered
writes to stdout and line buffered reads from stdin. Records
from stdin are lines regardless of the value of RS.</p>

<p style="margin-top: 1em">-W exec file Program text is
read from file and this is the last option. Useful on
systems that support the #! &quot;magic number&quot;
convention for executable scripts.</p>

<p style="margin-top: 1em">-W sprintf=num adjusts the size
of mawk&rsquo;s internal sprintf buffer to num bytes. More
than rare use of this option indicates mawk should be
recompiled.</p>

<p style="margin-top: 1em">-W posix_space forces mawk not
to consider &rsquo;0 to be space.</p>

<p style="margin-top: 1em">The short forms -W[vdiesp] are
recognized and on some systems -We is mandatory to avoid
command line length limitations.</p>

<p style="margin-top: 1em">THE AWK LANGUAGE <br>
1. Program structure <br>
An AWK program is a sequence of pattern {action} pairs and
user function definitions.</p>

<p style="margin-top: 1em">A pattern can be: <br>
BEGIN <br>
END <br>
expression <br>
expression , expression</p>

<p style="margin-top: 1em">One, but not both, of pattern
{action} can be omitted. If {action} is omitted it is
implicitly { print }. If pattern is omitted, then it is
implicitly matched. BEGIN and END <br>
patterns require an action.</p>

<p style="margin-top: 1em">Statements are terminated by
newlines, semi-colons or both. Groups of statements such as
actions or loop bodies are blocked via { ... } as in C. The
last statement in a block <br>
doesn&rsquo;t need a terminator. Blank lines have no
meaning; an empty statement is terminated with a semi-colon.
Long statements can be continued with a backslash, . A
statement <br>
can be broken without a backslash after a comma, left brace,
&amp;&amp;, ||, do, else, the right parenthesis of an if,
while or for statement, and the right parenthesis of a
function <br>
definition. A comment starts with # and extends to, but does
not include the end of line.</p>

<p style="margin-top: 1em">The following statements control
program flow inside blocks.</p>

<p style="margin-top: 1em">if ( expr ) statement</p>

<p style="margin-top: 1em">if ( expr ) statement else
statement</p>

<p style="margin-top: 1em">while ( expr ) statement</p>

<p style="margin-top: 1em">do statement while ( expr )</p>

<p style="margin-top: 1em">for ( opt_expr ; opt_expr ;
opt_expr ) statement</p>

<p style="margin-top: 1em">for ( var in array )
statement</p>

<p style="margin-top: 1em">continue</p>

<p style="margin-top: 1em">break</p>

<p style="margin-top: 1em">2. Data types, conversion and
comparison <br>
There are two basic data types, numeric and string. Numeric
constants can be integer like -2, decimal like 1.08, or in
scientific notation like -1.1e4 or .28E-3. All numbers <br>
are represented internally and all computations are done in
floating point arithmetic. So for example, the expression
0.2e2 == 20 is true and true is represented as 1.0.</p>

<p style="margin-top: 1em">String constants are enclosed in
double quotes.</p>

<p style="margin-top: 1em">&quot;This is a string with a
newline at the end.0</p>

<p style="margin-top: 1em">Strings can be continued across
a line by escaping ( the newline. The following escape
sequences are recognized.</p>

<p style="margin-top: 1em">\ <br>
alert, ascii 7 <br>
backspace, ascii 8 <br>
tab, ascii 9 <br>
newline, ascii 10 <br>
vertical tab, ascii 11 <br>
formfeed, ascii 12 <br>
carriage return, ascii 13 <br>
dd 1, 2 or 3 octal digits for ascii ddd <br>
1 or 2 hex digits for ascii hh</p>

<p style="margin-top: 1em">If you escape any other
character <br>
There are really three basic data types; the third is number
and string which has both a numeric value and a string value
at the same time. User defined variables come into <br>
existence when first referenced and are initialized to null,
a number and string value which has numeric value 0 and
string value &quot;&quot;. Non-trivial number and string
typed data <br>
come from input and are typically stored in fields. (See
section 4).</p>

<p style="margin-top: 1em">The type of an expression is
determined by its context and automatic type conversion
occurs if needed. For example, to evaluate the
statements</p>

<p style="margin-top: 1em">y = x + 2 ; z = x
&quot;hello&quot;</p>

<p style="margin-top: 1em">The value stored in variable y
will be typed numeric. If x is not numeric, the value read
from x is converted to numeric before it is added to 2 and
stored in y. The value <br>
stored in variable z will be typed string, and the value of
x will be converted to string if necessary and concatenated
with &quot;hello&quot;. (Of course, the value and type
stored in x <br>
is not changed by any conversions.) A string expression is
converted to numeric using its longest numeric prefix as
with atof(3). A numeric expression is converted to string by
<br>
replacing expr with sprintf(CONVFMT, expr), unless expr can
be represented on the host machine as an exact integer then
it is converted to sprintf(&quot;%d&quot;, expr). Sprintf()
is an <br>
AWK built-in that duplicates the functionality of
sprintf(3), and CONVFMT is a built-in variable used for
internal conversion from number to string and initialized to
&quot;%.6g&quot;. <br>
Explicit type conversions can be forced, expr &quot;&quot;
is string and expr+0 is numeric.</p>

<p style="margin-top: 1em">To evaluate, expr1 rel-op expr2,
if both operands are numeric or number and string then the
comparison is numeric; if both operands are string the
comparison is string; if one <br>
operand is string, the non-string operand is converted and
the comparison is string. The result is numeric, 1 or 0.</p>

<p style="margin-top: 1em">In boolean contexts such as, if
( expr ) statement, a string expression evaluates true if
and only if it is not the empty string &quot;&quot;; numeric
values if and only if not numerically <br>
zero.</p>

<p style="margin-top: 1em">3. Regular expressions <br>
In the AWK language, records, fields and strings are often
tested for matching a regular expression. Regular
expressions are enclosed in slashes, and</p>

<p style="margin-top: 1em">expr ~ /r/</p>

<p style="margin-top: 1em">is an AWK expression that
evaluates to 1 if expr &quot;matches&quot; r, which means a
substring of expr is in the set of strings defined by r.
With no match the expression evaluates to 0; <br>
replacing ~ with the &quot;not match&quot; operator, !~ ,
reverses the meaning. As pattern-action pairs,</p>

<p style="margin-top: 1em">/r/ { action } and $0 ~ /r/ {
action }</p>

<p style="margin-top: 1em">are the same, and for each input
record that matches r, action is executed. In fact, /r/ is
an AWK expression that is equivalent to ($0 ~ /r/) anywhere
except when on the right <br>
side of a match operator or passed as an argument to a
built-in function that expects a regular expression
argument.</p>

<p style="margin-top: 1em">AWK uses extended regular
expressions as with egrep(1). The regular expression
metacharacters, i.e., those with special meaning in regular
expressions are</p>

<p style="margin-top: 1em">^ $ . [ ] | ( ) * + ?</p>

<p style="margin-top: 1em">Regular expressions are built up
from characters as follows:</p>

<p style="margin-top: 1em">c matches any non-metacharacter
c.</p>

<p style="margin-top: 1em">. matches any character
(including newline).</p>

<p style="margin-top: 1em">^ matches the front of a
string.</p>

<p style="margin-top: 1em">$ matches the back of a
string.</p>

<p style="margin-top: 1em">[c1c2c3...] matches any
character in the class c1c2c3... . An interval of characters
is denoted c1-c2 inside a class [...].</p>

<p style="margin-top: 1em">[^c1c2c3...] matches any
character not in the class c1c2c3...</p>

<p style="margin-top: 1em">Regular expressions are built up
from other regular expressions as follows:</p>

<p style="margin-top: 1em">r1r2 matches r1 followed
immediately by r2 (concatenation).</p>

<p style="margin-top: 1em">r1 | r2 matches r1 or r2
(alternation).</p>

<p style="margin-top: 1em">r* matches r repeated zero or
more times.</p>

<p style="margin-top: 1em">r+ matches r repeated one or
more times.</p>

<p style="margin-top: 1em">r? matches r zero or once.</p>

<p style="margin-top: 1em">(r) matches r, providing
grouping.</p>

<p style="margin-top: 1em">The increasing precedence of
operators is alternation, concatenation and unary (*, + or
?).</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">/^[_a-zA-Z][_a-zA-Z0-9]*$/ and
<br>
/^[-+]?([0-9]+.?|.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/</p>

<p style="margin-top: 1em">are matched by AWK identifiers
and AWK numeric constants respectively. Note that . has to
be escaped to be recognized as a decimal point, and that
metacharacters are not special <br>
inside character classes.</p>

<p style="margin-top: 1em">Any expression can be used on
the right hand side of the ~ or !~ operators or passed to a
built-in that expects a regular expression. If needed, it is
converted to string, and <br>
then interpreted as a regular expression. For example,</p>

<p style="margin-top: 1em">BEGIN { identifier =
&quot;[_a-zA-Z][_a-zA-Z0-9]*&quot; }</p>

<p style="margin-top: 1em">$0 ~ &quot;^&quot;
identifier</p>

<p style="margin-top: 1em">prints all lines that start with
an AWK identifier.</p>

<p style="margin-top: 1em">mawk recognizes the empty
regular expression, //, which matches the empty string and
hence is matched by any string at the front, back and
between every character. For example,</p>

<p style="margin-top: 1em">echo abc | mawk { gsub(//,
&quot;X&quot;) ; print } <br>
XaXbXcX</p>

<p style="margin-top: 1em">4. Records and fields <br>
Records are read in one at a time, and stored in the field
variable $0. The record is split into fields which are
stored in $1, $2, ..., $NF. The built-in variable NF is set
to <br>
the number of fields, and NR and FNR are incremented by 1.
Fields above $NF are set to &quot;&quot;.</p>

<p style="margin-top: 1em">Assignment to $0 causes the
fields and NF to be recomputed. Assignment to NF or to a
field causes $0 to be reconstructed by concatenating the
$i&rsquo;s separated by OFS. Assignment <br>
to a field with index greater than NF, increases NF and
causes $0 to be reconstructed.</p>

<p style="margin-top: 1em">Data input stored in fields is
string, unless the entire field has numeric form and then
the type is number and string. For example,</p>

<p style="margin-top: 1em">echo 24 24E | <br>
mawk &rsquo;{ print($1&gt;100, $1&gt;&quot;100&quot;,
$2&gt;100, $2&gt;&quot;100&quot;) }&rsquo; <br>
0 1 1 1</p>

<p style="margin-top: 1em">$0 and $2 are string and $1 is
number and string. The first comparison is numeric, the
second is string, the third is string (100 is converted to
&quot;100&quot;), and the last is string.</p>

<p style="margin-top: 1em">5. Expressions and operators
<br>
The expression syntax is similar to C. Primary expressions
are numeric constants, string constants, variables, fields,
arrays and function calls. The identifier for a variable,
<br>
array or function can be a sequence of letters, digits and
underscores, that does not start with a digit. Variables are
not declared; they exist when first referenced and are <br>
initialized to null.</p>

<p style="margin-top: 1em">New expressions are composed
with the following operators in order of increasing
precedence.</p>

<p style="margin-top: 1em">assignment = += -= *= /= %= ^=
<br>
conditional ? : <br>
logical or || <br>
logical and &amp;&amp; <br>
array membership in <br>
matching ~ !~ <br>
relational &lt; &gt; &lt;= &gt;= == != <br>
concatenation (no explicit operator) <br>
add ops + - <br>
mul ops * / % <br>
unary + - <br>
logical not ! <br>
exponentiation ^ <br>
inc and dec ++ -- (both post and pre) <br>
field $</p>

<p style="margin-top: 1em">Assignment, conditional and
exponentiation associate right to left; the other operators
associate left to right. Any expression can be
parenthesized.</p>

<p style="margin-top: 1em">6. Arrays <br>
Awk provides one-dimensional arrays. Array elements are
expressed as array[expr]. Expr is internally converted to
string type, so, for example, A[1] and A[&quot;1&quot;] are
the same <br>
element and the actual index is &quot;1&quot;. Arrays
indexed by strings are called associative arrays. Initially
an array is empty; elements exist when first accessed. An
expression, <br>
expr in array evaluates to 1 if array[expr] exists, else to
0.</p>

<p style="margin-top: 1em">There is a form of the for
statement that loops over each index of an array.</p>

<p style="margin-top: 1em">for ( var in array )
statement</p>

<p style="margin-top: 1em">sets var to each index of array
and executes statement. The order that var transverses the
indices of array is not defined.</p>

<p style="margin-top: 1em">The statement, delete
array[expr], causes array[expr] not to exist. mawk supports
an extension, delete array, which deletes all elements of
array.</p>

<p style="margin-top: 1em">Multidimensional arrays are
synthesized with concatenation using the built-in variable
SUBSEP. array[expr1,expr2] is equivalent to array[expr1
SUBSEP expr2]. Testing for a mul&acirc; <br>
tidimensional element uses a parenthesized index, such
as</p>

<p style="margin-top: 1em">if ( (i, j) in A ) print A[i,
j]</p>

<p style="margin-top: 1em">7. Builtin-variables <br>
The following variables are built-in and initialized before
program execution.</p>

<p style="margin-top: 1em">ARGC number of command line
arguments.</p>

<p style="margin-top: 1em">ARGV array of command line
arguments, 0..ARGC-1.</p>

<p style="margin-top: 1em">CONVFMT format for internal
conversion of numbers to string, initially =
&quot;%.6g&quot;.</p>

<p style="margin-top: 1em">ENVIRON array indexed by
environment variables. An environment string, var=value is
stored as ENVIRON[var] = value.</p>

<p style="margin-top: 1em">FILENAME name of the current
input file.</p>

<p style="margin-top: 1em">FNR current record number in
FILENAME.</p>

<p style="margin-top: 1em">FS splits records into fields as
a regular expression.</p>

<p style="margin-top: 1em">NF number of fields in the
current record.</p>

<p style="margin-top: 1em">NR current record number in the
total input stream.</p>

<p style="margin-top: 1em">OFMT format for printing
numbers; initially = &quot;%.6g&quot;.</p>

<p style="margin-top: 1em">OFS inserted between fields on
output, initially = &quot; &quot;.</p>

<p style="margin-top: 1em">ORS terminates each record on
output, initially = &quot;0.</p>

<p style="margin-top: 1em">RLENGTH length set by the last
call to the built-in function, match().</p>

<p style="margin-top: 1em">RS input record separator,
initially = &quot;0.</p>

<p style="margin-top: 1em">RSTART index set by the last
call to match().</p>

<p style="margin-top: 1em">SUBSEP used to build multiple
array subscripts, initially = &quot; 34&quot;.</p>

<p style="margin-top: 1em">8. Built-in functions <br>
String functions</p>

<p style="margin-top: 1em">gsub(r,s,t) gsub(r,s) <br>
Global substitution, every match of regular expression r in
variable t is replaced by string s. The number of
replacements is returned. If t is omitted, $0 is <br>
used. An &amp; in the replacement string s is replaced by
the matched substring of t. and \ put literal &amp; and
respectively, in the replacement string.</p>

<p style="margin-top: 1em">index(s,t) <br>
If t is a substring of s, then the position where t starts
is returned, else 0 is returned. The first character of s is
in position 1.</p>

<p style="margin-top: 1em">length(s) <br>
Returns the length of string s.</p>

<p style="margin-top: 1em">match(s,r) <br>
Returns the index of the first longest match of regular
expression r in string s. Returns 0 if no match. As a side
effect, RSTART is set to the return value. <br>
RLENGTH is set to the length of the match or -1 if no match.
If the empty string is matched, RLENGTH is set to 0, and 1
is returned if the match is at the front, <br>
and length(s)+1 is returned if the match is at the back.</p>

<p style="margin-top: 1em">split(s,A,r) split(s,A) <br>
String s is split into fields by regular expression r and
the fields are loaded into array A. The number of fields is
returned. See section 11 below for more <br>
detail. If r is omitted, FS is used.</p>

<p style="margin-top: 1em">sprintf(format,expr-list) <br>
Returns a string constructed from expr-list according to
format. See the description of printf() below.</p>

<p style="margin-top: 1em">sub(r,s,t) sub(r,s) <br>
Single substitution, same as gsub() except at most one
substitution.</p>

<p style="margin-top: 1em">substr(s,i,n) substr(s,i) <br>
Returns the substring of string s, starting at index i, of
length n. If n is omitted, the suffix of s, starting at i is
returned.</p>

<p style="margin-top: 1em">tolower(s) <br>
Returns a copy of s with all upper case characters converted
to lower case.</p>

<p style="margin-top: 1em">toupper(s) <br>
Returns a copy of s with all lower case characters converted
to upper case.</p>

<p style="margin-top: 1em">Arithmetic functions</p>

<p style="margin-top: 1em">atan2(y,x) Arctan of y/x between
-pi and pi.</p>

<p style="margin-top: 1em">cos(x) Cosine function, x in
radians.</p>

<p style="margin-top: 1em">exp(x) Exponential function.</p>

<p style="margin-top: 1em">int(x) Returns x truncated
towards zero.</p>

<p style="margin-top: 1em">log(x) Natural logarithm.</p>

<p style="margin-top: 1em">rand() Returns a random number
between zero and one.</p>

<p style="margin-top: 1em">sin(x) Sine function, x in
radians.</p>

<p style="margin-top: 1em">sqrt(x) Returns square root of
x.</p>

<p style="margin-top: 1em">srand(expr) srand() <br>
Seeds the random number generator, using the clock if expr
is omitted, and returns the value of the previous seed. mawk
seeds the random number generator from the <br>
clock at startup so there is no real need to call srand().
Srand(expr) is useful for repeating pseudo random
sequences.</p>

<p style="margin-top: 1em">9. Input and output <br>
There are two output statements, print and printf.</p>

<p style="margin-top: 1em">print writes $0 ORS to standard
output.</p>

<p style="margin-top: 1em">print expr1, expr2, ..., exprn
<br>
writes expr1 OFS expr2 OFS ... exprn ORS to standard output.
Numeric expressions are converted to string with OFMT.</p>

<p style="margin-top: 1em">printf format, expr-list <br>
duplicates the printf C library function writing to standard
output. The complete ANSI C format specifications are
recognized with conversions %c, %d, %e, %E, %f, <br>
%g, %G, %i, %o, %s, %u, %x, %X and %%, and conversion
qualifiers h and l.</p>

<p style="margin-top: 1em">The argument list to print or
printf can optionally be enclosed in parentheses. Print
formats numbers using OFMT or &quot;%d&quot; for exact
integers. &quot;%c&quot; with a numeric argument prints <br>
the corresponding 8 bit character, with a string argument it
prints the first character of the string. The output of
print and printf can be redirected to a file or command by
<br>
appending &gt; file, &gt;&gt; file or | command to the end
of the print statement. Redirection opens file or command
only once, subsequent redirections append to the already
open stream. <br>
By convention, mawk associates the filename
&quot;/dev/stderr&quot; with stderr which allows print and
printf to be redirected to stderr. mawk also associates
&quot;-&quot; and &quot;/dev/stdout&quot; with <br>
stdin and stdout which allows these streams to be passed to
functions.</p>

<p style="margin-top: 1em">The input function getline has
the following variations.</p>

<p style="margin-top: 1em">getline <br>
reads into $0, updates the fields, NF, NR and FNR.</p>

<p style="margin-top: 1em">getline &lt; file <br>
reads into $0 from file, updates the fields and NF.</p>

<p style="margin-top: 1em">getline var <br>
reads the next record into var, updates NR and FNR.</p>

<p style="margin-top: 1em">getline var &lt; file <br>
reads the next record of file into var.</p>

<p style="margin-top: 1em">command | getline <br>
pipes a record from command into $0 and updates the fields
and NF.</p>

<p style="margin-top: 1em">command | getline var <br>
pipes a record from command into var.</p>

<p style="margin-top: 1em">Getline returns 0 on
end-of-file, -1 on error, otherwise 1.</p>

<p style="margin-top: 1em">Commands on the end of pipes are
executed by /bin/sh.</p>

<p style="margin-top: 1em">The function close(expr) closes
the file or pipe associated with expr. Close returns 0 if
expr is an open file, the exit status if expr is a piped
command, and -1 otherwise. <br>
Close is used to reread a file or command, make sure the
other end of an output pipe is finished or conserve file
resources.</p>

<p style="margin-top: 1em">The function fflush(expr)
flushes the output file or pipe associated with expr. Fflush
returns 0 if expr is an open output stream else -1. Fflush
without an argument flushes <br>
stdout. Fflush with an empty argument (&quot;&quot;) flushes
all open output.</p>

<p style="margin-top: 1em">The function system(expr) uses
/bin/sh to execute expr and returns the exit status of the
command expr. Changes made to the ENVIRON array are not
passed to commands executed <br>
with system or pipes.</p>

<p style="margin-top: 1em">10. User defined functions <br>
The syntax for a user defined function is</p>

<p style="margin-top: 1em">function name( args ) {
statements }</p>

<p style="margin-top: 1em">The function body can contain a
return statement</p>

<p style="margin-top: 1em">return opt_expr</p>

<p style="margin-top: 1em">A return statement is not
required. Function calls may be nested or recursive.
Functions are passed expressions by value and arrays by
reference. Extra arguments serve as <br>
local variables and are initialized to null. For example,
csplit(s,A) puts each character of s into array A and
returns the length of s.</p>

<p style="margin-top: 1em">function csplit(s, A, n, i) <br>
{ <br>
n = length(s) <br>
for( i = 1 ; i &lt;= n ; i++ ) A[i] = substr(s, i, 1) <br>
return n <br>
}</p>

<p style="margin-top: 1em">Putting extra space between
passed arguments and local variables is conventional.
Functions can be referenced before they are defined, but the
function name and the &rsquo;(&rsquo; of the <br>
arguments must touch to avoid confusion with
concatenation.</p>

<p style="margin-top: 1em">11. Splitting strings, records
and files <br>
Awk programs use the same algorithm to split strings into
arrays with split(), and records into fields on FS. mawk
uses essentially the same algorithm to split files into <br>
records on RS.</p>

<p style="margin-top: 1em">Split(expr,A,sep) works as
follows:</p>

<p style="margin-top: 1em">(1) If sep is omitted, it is
replaced by FS. Sep can be an expression or regular
expression. If it is an expression of non-string type, it is
converted to string.</p>

<p style="margin-top: 1em">(2) If sep = &quot; &quot; (a
single space), then &lt;SPACE&gt; is trimmed from the front
and back of expr, and sep becomes &lt;SPACE&gt;. mawk
defines &lt;SPACE&gt; as the regular expression <br>
/[ 0+/. Otherwise sep is treated as a regular expression,
except that meta-characters are ignored for a string of
length 1, e.g., split(x, A, &quot;*&quot;) and split(x, <br>
A, /) are the same.</p>

<p style="margin-top: 1em">(3) If expr is not string, it is
converted to string. If expr is then the empty string
&quot;&quot;, split() returns 0 and A is set empty.
Otherwise, all non-overlapping, non- <br>
null and longest matches of sep in expr, separate expr into
fields which are loaded into A. The fields are placed in
A[1], A[2], ..., A[n] and split() returns n, <br>
the number of fields which is the number of matches plus
one. Data placed in A that looks numeric is typed number and
string.</p>

<p style="margin-top: 1em">Splitting records into fields
works the same except the pieces are loaded into $1, $2,...,
$NF. If $0 is empty, NF is set to 0 and all $i to
&quot;&quot;.</p>

<p style="margin-top: 1em">mawk splits files into records
by the same algorithm, but with the slight difference that
RS is really a terminator instead of a separator. (ORS is
really a terminator too).</p>

<p style="margin-top: 1em">E.g., if FS = &quot;:+&quot; and
$0 = &quot;a::b:&quot; , then NF = 3 and $1 = &quot;a&quot;,
$2 = &quot;b&quot; and $3 = &quot;&quot;, but if
&quot;a::b:&quot; is the contents of an input file and RS =
&quot;:+&quot;, then there are two <br>
records &quot;a&quot; and &quot;b&quot;.</p>

<p style="margin-top: 1em">RS = &quot; &quot; is not
special.</p>

<p style="margin-top: 1em">If FS = &quot;&quot;, then mawk
breaks the record into individual characters, and,
similarly, split(s,A,&quot;&quot;) places the individual
characters of s into A.</p>

<p style="margin-top: 1em">12. Multi-line records <br>
Since mawk interprets RS as a regular expression, multi-line
records are easy. Setting RS = &quot;0, makes one or more
blank lines separate records. If FS = &quot; &quot; (the
default), <br>
then single newlines, by the rules for &lt;SPACE&gt; above,
become space and single newlines are field separators.</p>

<p style="margin-top: 1em">For example, if a file is
&quot;a b00, RS = &quot;0 and FS = &quot; &quot;, then there
is one record &quot;a b0&quot; with three fields
&quot;a&quot;, &quot;b&quot; and &quot;c&quot;. Changing FS
= &quot;0, gives two <br>
fields &quot;a b&quot; and &quot;c&quot;; changing FS =
&quot;&quot;, gives one field identical to the record.</p>

<p style="margin-top: 1em">If you want lines with spaces or
tabs to be considered blank, set RS = &quot;]*0+&quot;. For
compatibility with other awks, setting RS = &quot;&quot; has
the same effect as if blank lines <br>
are stripped from the front and back of files and then
records are determined as if RS = &quot;0. Posix requires
that &quot;0 always separates records when RS = &quot;&quot;
regardless of <br>
the value of FS. mawk does not support this convention,
because defining &quot;0 as &lt;SPACE&gt; makes it
unnecessary.</p>

<p style="margin-top: 1em">Most of the time when you change
RS for multi-line records, you will also want to change ORS
to &quot;0 so the record spacing is preserved on output.</p>

<p style="margin-top: 1em">13. Program execution <br>
This section describes the order of program execution. First
ARGC is set to the total number of command line arguments
passed to the execution phase of the program. ARGV[0] is
<br>
set the name of the AWK interpreter and ARGV[1] ...
ARGV[ARGC-1] holds the remaining command line arguments
exclusive of options and program source. For example
with</p>

<p style="margin-top: 1em">mawk -f prog v=1 A t=hello B</p>

<p style="margin-top: 1em">ARGC = 5 with ARGV[0] =
&quot;mawk&quot;, ARGV[1] = &quot;v=1&quot;, ARGV[2] =
&quot;A&quot;, ARGV[3] = &quot;t=hello&quot; and ARGV[4] =
&quot;B&quot;.</p>

<p style="margin-top: 1em">Next, each BEGIN block is
executed in order. If the program consists entirely of BEGIN
blocks, then execution terminates, else an input stream is
opened and execution continues. <br>
If ARGC equals 1, the input stream is set to stdin, else the
command line arguments ARGV[1] ... ARGV[ARGC-1] are examined
for a file argument.</p>

<p style="margin-top: 1em">The command line arguments
divide into three sets: file arguments, assignment arguments
and empty strings &quot;&quot;. An assignment has the form
var=string. When an ARGV[i] is examined <br>
as a possible file argument, if it is empty it is skipped;
if it is an assignment argument, the assignment to var takes
place and i skips to the next argument; else ARGV[i] is <br>
opened for input. If it fails to open, execution terminates
with exit code 2. If no command line argument is a file
argument, then input comes from stdin. Getline in a BEGIN
<br>
action opens input. &quot;-&quot; as a file argument denotes
stdin.</p>

<p style="margin-top: 1em">Once an input stream is open,
each input record is tested against each pattern, and if it
matches, the associated action is executed. An expression
pattern matches if it is <br>
boolean true (see the end of section 2). A BEGIN pattern
matches before any input has been read, and an END pattern
matches after all input has been read. A range pattern, <br>
expr1,expr2 , matches every record between the match of
expr1 and the match expr2 inclusively.</p>

<p style="margin-top: 1em">When end of file occurs on the
input stream, the remaining command line arguments are
examined for a file argument, and if there is one it is
opened, else the END pattern is con&acirc; <br>
sidered matched and all END actions are executed.</p>

<p style="margin-top: 1em">In the example, the assignment
v=1 takes place after the BEGIN actions are executed, and
the data placed in v is typed number and string. Input is
then read from file A. On end <br>
of file A, t is set to the string &quot;hello&quot;, and B
is opened for input. On end of file B, the END actions are
executed.</p>

<p style="margin-top: 1em">Program flow at the pattern
{action} level can be changed with the</p>

<p style="margin-top: 1em">next <br>
exit opt_expr</p>

<p style="margin-top: 1em">statements. A next statement
causes the next input record to be read and pattern testing
to restart with the first pattern {action} pair in the
program. An exit statement <br>
causes immediate execution of the END actions or program
termination if there are none or if the exit occurs in an
END action. The opt_expr sets the exit value of the program
<br>
unless overridden by a later exit or subsequent error.</p>

<p style="margin-top: 1em">EXAMPLES <br>
1. emulate cat.</p>

<p style="margin-top: 1em">{ print }</p>

<p style="margin-top: 1em">2. emulate wc.</p>

<p style="margin-top: 1em">{ chars += length($0) + 1 # add
one for the <br>
words += NF <br>
}</p>

<p style="margin-top: 1em">END{ print NR, words, chars
}</p>

<p style="margin-top: 1em">3. count the number of unique
&quot;real words&quot;.</p>

<p style="margin-top: 1em">BEGIN { FS =
&quot;[^A-Za-z]+&quot; }</p>

<p style="margin-top: 1em">{ for(i = 1 ; i &lt;= NF ; i++)
word[$i] = &quot;&quot; }</p>

<p style="margin-top: 1em">END { delete word[&quot;&quot;]
<br>
for ( i in word ) cnt++ <br>
print cnt <br>
}</p>

<p style="margin-top: 1em">4. sum the second field of every
record based on the first field.</p>

<p style="margin-top: 1em">$1 ~ /credit|gain/ { sum += $2 }
<br>
$1 ~ /debit|loss/ { sum -= $2 }</p>

<p style="margin-top: 1em">END { print sum }</p>

<p style="margin-top: 1em">5. sort a file, comparing as
string</p>

<p style="margin-top: 1em">{ line[NR] = $0 &quot;&quot; } #
make sure of comparison type <br>
# in case some lines look numeric</p>

<p style="margin-top: 1em">END { isort(line, NR) <br>
for(i = 1 ; i &lt;= NR ; i++) print line[i] <br>
}</p>

<p style="margin-top: 1em">#insertion sort of A[1..n] <br>
function isort( A, n, i, j, hold) <br>
{ <br>
for( i = 2 ; i &lt;= n ; i++) <br>
{ <br>
hold = A[j = i] <br>
while ( A[j-1] &gt; hold ) <br>
{ j-- ; A[j+1] = A[j] } <br>
A[j] = hold <br>
} <br>
# sentinel A[0] = &quot;&quot; will be created if needed
<br>
}</p>

<p style="margin-top: 1em">COMPATIBILITY ISSUES <br>
The Posix 1003.2(draft 11.3) definition of the AWK language
is AWK as described in the AWK book with a few extensions
that appeared in SystemVR4 nawk. The extensions are:</p>

<p style="margin-top: 1em">New functions: toupper() and
tolower().</p>

<p style="margin-top: 1em">New variables: ENVIRON[] and
CONVFMT.</p>

<p style="margin-top: 1em">ANSI C conversion specifications
for printf() and sprintf().</p>

<p style="margin-top: 1em">New command options: -v
var=value, multiple -f options and implementation options as
arguments to -W.</p>

<p style="margin-top: 1em">Posix AWK is oriented to operate
on files a line at a time. RS can be changed from &quot;0 to
another single character, but it is hard to find any use for
this &acirc; there are no exam&acirc; <br>
ples in the AWK book. By convention, RS = &quot;&quot;,
makes one or more blank lines separate records, allowing
multi-line records. When RS = &quot;&quot;, &quot;0 is
always a field separator <br>
regardless of the value in FS.</p>

<p style="margin-top: 1em">mawk, on the other hand, allows
RS to be a regular expression. When &quot;0 appears in
records, it is treated as space, and FS always determines
fields.</p>

<p style="margin-top: 1em">Removing the line at a time
paradigm can make some programs simpler and can often
improve performance. For example, redoing example 3 from
above,</p>

<p style="margin-top: 1em">BEGIN { RS =
&quot;[^A-Za-z]+&quot; }</p>

<p style="margin-top: 1em">{ word[ $0 ] = &quot;&quot;
}</p>

<p style="margin-top: 1em">END { delete word[ &quot;&quot;
] <br>
for( i in word ) cnt++ <br>
print cnt <br>
}</p>

<p style="margin-top: 1em">counts the number of unique
words by making each word a record. On moderate size files,
mawk executes twice as fast, because of the simplified inner
loop.</p>

<p style="margin-top: 1em">The following program replaces
each comment by a single space in a C program file,</p>

<p style="margin-top: 1em">BEGIN { <br>
RS = &quot;/*]|[^/*])*/&quot; <br>
# comment is record separator <br>
ORS = &quot; &quot; <br>
getline hold <br>
}</p>

<p style="margin-top: 1em">{ print hold ; hold = $0 }</p>

<p style="margin-top: 1em">END { printf &quot;%s&quot; ,
hold }</p>

<p style="margin-top: 1em">Buffering one record is needed
to avoid terminating the last record with a space.</p>

<p style="margin-top: 1em">With mawk, the following are all
equivalent,</p>

<p style="margin-top: 1em">x ~ /a+b/ x ~ &quot;a+b&quot; x
~ &quot;a\+b&quot;</p>

<p style="margin-top: 1em">The strings get scanned twice,
once as string and once as regular expression. On the string
scan, mawk ignores the escape on non-escape characters while
the AWK book advocates <br>
must run under a variety of awks to use the more portable
but less readable, double escape.</p>

<p style="margin-top: 1em">Posix AWK does not recognize
&quot;/dev/std{out,err}&quot; or hex escape sequences in
strings. Unlike ANSI C, mawk limits the number of digits
that follows to two as the current <br>
implementation only supports 8 bit characters. The built-in
fflush first appeared in a recent (1993) AT&amp;T awk
released to netlib, and is not part of the posix standard.
Aggre&acirc; <br>
gate deletion with delete array is not part of the posix
standard.</p>

<p style="margin-top: 1em">Posix explicitly leaves the
behavior of FS = &quot;&quot; undefined, and mentions
splitting the record into characters as a possible
interpretation, but currently this use is not portable <br>
across implementations.</p>

<p style="margin-top: 1em">Finally, here is how mawk
handles exceptional cases not discussed in the AWK book or
the Posix draft. It is unsafe to assume consistency across
awks and safe to skip to the next <br>
section.</p>

<p style="margin-top: 1em">substr(s, i, n) returns the
characters of s in the intersection of the closed interval
[1, length(s)] and the half-open interval [i, i+n). When
this intersection is <br>
empty, the empty string is returned; so
substr(&quot;ABC&quot;, 1, 0) = &quot;&quot; and
substr(&quot;ABC&quot;, -4, 6) = &quot;A&quot;.</p>

<p style="margin-top: 1em">Every string, including the
empty string, matches the empty string at the front so, s ~
// and s ~ &quot;&quot;, are always 1 as is match(s, //) and
match(s, &quot;&quot;). The last two set <br>
RLENGTH to 0.</p>

<p style="margin-top: 1em">index(s, t) is always the same
as match(s, t1) where t1 is the same as t with
metacharacters escaped. Hence consistency with match
requires that index(s, &quot;&quot;) always <br>
returns 1. Also the condition, index(s,t) != 0 if and only t
is a substring of s, requires
index(&quot;&quot;,&quot;&quot;) = 1.</p>

<p style="margin-top: 1em">If getline encounters end of
file, getline var, leaves var unchanged. Similarly, on entry
to the END actions, $0, the fields and NF have their value
unaltered from the <br>
last record.</p>

<p style="margin-top: 1em">SEE ALSO <br>
egrep(1)</p>

<p style="margin-top: 1em">Aho, Kernighan and Weinberger,
The AWK Programming Language, Addison-Wesley Publishing,
1988, (the AWK book), defines the language, opening with a
tutorial and advancing to many <br>
interesting programs that delve into issues of software
design and analysis relevant to programming in any
language.</p>

<p style="margin-top: 1em">The GAWK Manual, The Free
Software Foundation, 1991, is a tutorial and language
reference that does not attempt the depth of the AWK book
and assumes the reader may be a novice <br>
programmer. The section on AWK arrays is excellent. It also
discusses Posix requirements for AWK.</p>

<p style="margin-top: 1em">BUGS <br>
mawk cannot handle ascii NUL in the source or data files.
You can output NUL using printf with %c, and any other 8 bit
character is acceptable input.</p>

<p style="margin-top: 1em">mawk implements printf() and
sprintf() using the C library functions, printf and sprintf,
so full ANSI compatibility requires an ANSI C library. In
practice this means the h <br>
conversion qualifier may not be available. Also mawk
inherits any bugs or limitations of the library
functions.</p>

<p style="margin-top: 1em">Implementors of the AWK language
have shown a consistent lack of imagination when naming
their programs.</p>

<p style="margin-top: 1em">AUTHOR <br>
Mike Brennan (brennan@whidbey.com).</p>

<p style="margin-top: 1em">Version 1.2 Dec 22 1994
MAWK(1)</p>
<hr>
</body>
</html>
