<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAWK(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAWK(1)</td>
    <td class="head-vol">USER COMMANDS</td>
    <td class="head-rtitle">MAWK(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
mawk - pattern scanning and text processing language
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>mawk</b> [- <b>W</b> <i>option</i>] [- <b>F</b> <i>value</i>] [- <b>v</b>
  <i>var=value</i>] [--] 'program text' [file ...]
<div>&#x00A0;</div>
<b>mawk</b> [- <b>W</b> <i>option</i>] [- <b>F</b> <i>value</i>] [- <b>v</b>
  <i>var=value</i>] [- <b>f</b> <i>program-file</i>] [--] [file ...]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>mawk</b> is an interpreter for the AWK Programming Language. The AWK language
  is useful for manipulation of data files, text retrieval and processing, and
  for prototyping and experimenting with algorithms. <b>mawk</b> is a <i>new
  awk</i> meaning it implements the AWK language as defined in Aho, Kernighan
  and Weinberger, <i>The AWK Programming Language,</i> Addison-Wesley
  Publishing, 1988. (Hereafter referred to as the AWK book.) <b>mawk</b>
  conforms to the Posix 1003.2 (draft 11.3) definition of the AWK language which
  contains a few features not described in the AWK book, and <b>mawk</b>
  provides a small number of extensions.
<div class="Pp"></div>
An AWK program is a sequence of <i>pattern {action}</i> pairs and function
  definitions. Short programs are entered on the command line usually enclosed
  in ' ' to avoid shell interpretation. Longer programs can be read in from a
  file with the -f option. Data input is read from the list of files on the
  command line or from standard input when the list is empty. The input is
  broken into records as determined by the record separator variable, <b>RS</b>.
  Initially, <b>RS</b> = &quot;\n&quot; and records are synonymous with lines.
  Each record is compared against each <i>pattern</i> and if it matches, the
  program text for <i>{action}</i> is executed.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>F </b><i>value</i><b></b></dt>
  <dd class="It-tag">sets the field separator, <b>FS</b>, to <i>value</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>f </b><i>file</i></dt>
  <dd class="It-tag">Program text is read from <i>file</i> instead of from the
      command line. Multiple <b>-f</b> options are allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>v </b><i>var=value</i></dt>
  <dd class="It-tag">assigns <i>value</i> to program variable <i>var</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--</dt>
  <dd class="It-tag">indicates the unambiguous end of options.</dd>
</dl>
<div class="Pp"></div>
The above options will be available with any Posix compatible implementation of
  AWK, and implementation specific options are prefaced with <b>-W</b>.
  <b>mawk</b> provides six:
<dl class="Bl-tag">
  <dt class="It-tag">-<b>W </b>version</dt>
  <dd class="It-tag"><b>mawk</b> writes its version and copyright to stdout and
      compiled limits to stderr and exits 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>W </b>dump</dt>
  <dd class="It-tag">writes an assembler like listing of the internal
      representation of the program to stdout and exits 0 (on successful
      compilation).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>W </b>interactive</dt>
  <dd class="It-tag">sets unbuffered writes to stdout and line buffered reads
      from stdin. Records from stdin are lines regardless of the value of
      <b>RS</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>W </b>exec <i>file</i></dt>
  <dd class="It-tag">Program text is read from <i>file</i> and this is the last
      option. Useful on systems that support the <b>#!</b> &quot;magic
      number&quot; convention for executable scripts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>W </b>sprintf=<i>num</i></dt>
  <dd class="It-tag">adjusts the size of <b>mawk's</b> internal sprintf buffer
      to <i>num</i> bytes. More than rare use of this option indicates
      <b>mawk</b> should be recompiled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-<b>W </b>posix_space</dt>
  <dd class="It-tag">forces <b>mawk</b> not to consider '\n' to be space.</dd>
</dl>
<div class="Pp"></div>
The short forms <b>-W</b>[vdiesp] are recognized and on some systems <b>-W</b>e
  is mandatory to avoid command line length limitations.
<h1 class="Sh" title="Sh" id="THE_AWK_LANGUAGE"><a class="selflink" href="#THE_AWK_LANGUAGE">THE
  AWK LANGUAGE</a></h1>
<h2 class="Ss" title="Ss" id="1._Program_structure"><a class="selflink" href="#1._Program_structure"><b>1.
  Program structure</b></a></h2>
An AWK program is a sequence of <i>pattern {action}</i> pairs and user function
  definitions.
<div class="Pp"></div>
A pattern can be:
<div style="margin-left: 5.00ex;">
<pre>
<b>BEGIN</b>
<b>END</b>
expression
expression , expression
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
</div>
<br/>
One, but not both, of <i>pattern {action}</i> can be omitted. If <i>{action}</i>
  is omitted it is implicitly { print }. If <i>pattern</i> is omitted, then it
  is implicitly matched. <b>BEGIN</b> and <b>END</b> patterns require an action.
<div class="Pp"></div>
Statements are terminated by newlines, semi-colons or both. Groups of statements
  such as actions or loop bodies are blocked via { ... } as in C. The last
  statement in a block doesn't need a terminator. Blank lines have no meaning;
  an empty statement is terminated with a semi-colon. Long statements can be
  continued with a backslash, \. A statement can be broken without a backslash
  after a comma, left brace, &amp;&amp;, ||, <b>do</b>, <b>else</b>, the right
  parenthesis of an <b>if</b>, <b>while</b> or <b>for</b> statement, and the
  right parenthesis of a function definition. A comment starts with # and
  extends to, but does not include the end of line.
<div class="Pp"></div>
The following statements control program flow inside blocks.
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
<b>if</b> ( <i>expr</i> ) <i>statement</i>
<div class="Pp"></div>
<b>if</b> ( <i>expr</i> ) <i>statement</i> <b>else</b> <i>statement</i>
<div class="Pp"></div>
<b>while</b> ( <i>expr</i> ) <i>statement</i>
<div class="Pp"></div>
<b>do</b> <i>statement</i> <b>while</b> ( <i>expr</i> )
<div class="Pp"></div>
<b>for</b> ( <i>opt_expr</i> ; <i>opt_expr</i> ; <i>opt_expr</i> )
  <i>statement</i>
<div class="Pp"></div>
<b>for</b> ( <i>var </i><b>in </b><i>array</i> ) <i>statement</i>
<div class="Pp"></div>
<b>continue</b>
<div class="Pp"></div>
<b>break</b></div>
<h2 class="Ss" title="Ss" id="2._Data_types,_conversion_and_comparison"><a class="selflink" href="#2._Data_types,_conversion_and_comparison"><b>2.
  Data types, conversion and comparison</b></a></h2>
There are two basic data types, numeric and string. Numeric constants can be
  integer like -2, decimal like 1.08, or in scientific notation like -1.1e4 or
  .28E-3. All numbers are represented internally and all computations are done
  in floating point arithmetic. So for example, the expression 0.2e2 == 20 is
  true and true is represented as 1.0.
<div class="Pp"></div>
String constants are enclosed in double quotes.
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
&quot;This is a string with a newline at the end.\n&quot;
<div style="height: 1.00em;">&#x00A0;
<div>&#x00A0;</div>
</div>
Strings can be continued across a line by escaping (\) the newline. The
  following escape sequences are recognized.
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	\\		\
	\&quot;		&quot;
	\a		alert, ascii 7
	\b		backspace, ascii 8
	\t		tab, ascii 9
	\n		newline, ascii 10
	\v		vertical tab, ascii 11
	\f		formfeed, ascii 12
	\r		carriage return, ascii 13
	\ddd		1, 2 or 3 octal digits for ascii ddd
	\xhh		1 or 2 hex digits for ascii  hh
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
If you escape any other character \c, you get \c, i.e., <b>mawk</b> ignores the
  escape.
<div class="Pp"></div>
There are really three basic data types; the third is <i>number and string</i>
  which has both a numeric value and a string value at the same time. User
  defined variables come into existence when first referenced and are
  initialized to <i>null</i>, a number and string value which has numeric value
  0 and string value &quot;&quot;. Non-trivial number and string typed data come
  from input and are typically stored in fields. (See section 4).
<div class="Pp"></div>
The type of an expression is determined by its context and automatic type
  conversion occurs if needed. For example, to evaluate the statements
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	y = x + 2  ;  z = x  &quot;hello&quot;
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
The value stored in variable y will be typed numeric. If x is not numeric, the
  value read from x is converted to numeric before it is added to 2 and stored
  in y. The value stored in variable z will be typed string, and the value of x
  will be converted to string if necessary and concatenated with
  &quot;hello&quot;. (Of course, the value and type stored in x is not changed
  by any conversions.) A string expression is converted to numeric using its
  longest numeric prefix as with <i>atof</i>(3). A numeric expression is
  converted to string by replacing <i>expr</i> with <b>sprintf(CONVFMT</b>,
  <i>expr</i>), unless <i>expr</i> can be represented on the host machine as an
  exact integer then it is converted to <b>sprintf</b>(&quot;%d&quot;,
  <i>expr</i>). <b>Sprintf()</b> is an AWK built-in that duplicates the
  functionality of <i>sprintf</i>(3), and <b>CONVFMT</b> is a built-in variable
  used for internal conversion from number to string and initialized to
  &quot;%.6g&quot;. Explicit type conversions can be forced, <i>expr</i>
  &quot;&quot; is string and <i>expr</i>+0 is numeric.
<div class="Pp"></div>
To evaluate, <i>expr</i>1 <b>rel-op </b><i>expr</i>2, if both operands are
  numeric or number and string then the comparison is numeric; if both operands
  are string the comparison is string; if one operand is string, the non-string
  operand is converted and the comparison is string. The result is numeric, 1 or
  0.
<div class="Pp"></div>
In boolean contexts such as, <b>if</b> ( <i>expr</i> ) <i>statement</i>, a
  string expression evaluates true if and only if it is not the empty string
  &quot;&quot;; numeric values if and only if not numerically zero.
<h2 class="Ss" title="Ss" id="3._Regular_expressions"><a class="selflink" href="#3._Regular_expressions"><b>3.
  Regular expressions</b></a></h2>
In the AWK language, records, fields and strings are often tested for matching a
  <i>regular expression</i>. Regular expressions are enclosed in slashes, and
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	 <i>expr</i> ~ /<i>r</i>/
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
is an AWK expression that evaluates to 1 if <i>expr</i> &quot;matches&quot;
  <i>r</i>, which means a substring of <i>expr</i> is in the set of strings
  defined by <i>r</i>. With no match the expression evaluates to 0; replacing ~
  with the &quot;not match&quot; operator, !~ , reverses the meaning. As
  pattern-action pairs,
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	/ <i>r</i>/ { <i>action</i> }   and   <b>$0</b> ~ /<i>r</i>/ { <i>action</i> }
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
are the same, and for each input record that matches <i>r</i>, <i>action</i> is
  executed. In fact, / <i>r</i>/ is an AWK expression that is equivalent to (
  <b>$0</b> ~ /<i>r</i>/) anywhere except when on the right side of a match
  operator or passed as an argument to a built-in function that expects a
  regular expression argument.
<div class="Pp"></div>
AWK uses extended regular expressions as with <i>egrep</i>(1). The regular
  expression metacharacters, i.e., those with special meaning in regular
  expressions are
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	&#x00A0;^ $ . [ ] | ( ) * + ?
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
Regular expressions are built up from characters as follows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>c</i></dt>
  <dd class="It-tag">matches any non-metacharacter <i>c</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\<i>c</i></dt>
  <dd class="It-tag">matches a character defined by the same escape sequences
      used in string constants or the literal character <i>c</i> if \ <i>c</i>
      is not an escape sequence.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">.</dt>
  <dd class="It-tag">matches any character (including newline).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">^</dt>
  <dd class="It-tag">matches the front of a string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$</dt>
  <dd class="It-tag">matches the back of a string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[c1c2c3...]</dt>
  <dd class="It-tag">matches any character in the class c1c2c3... . An interval
      of characters is denoted c1-c2 inside a class [...].</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[^c1c2c3...]</dt>
  <dd class="It-tag">matches any character not in the class c1c2c3...</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
Regular expressions are built up from other regular expressions as follows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>r</i>1<i>r</i>2</dt>
  <dd class="It-tag">matches <i>r</i>1 followed immediately by <i>r</i>2
      (concatenation).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>r</i>1 | <i>r</i>2</dt>
  <dd class="It-tag">matches <i>r</i>1 or <i>r</i>2 (alternation).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>r</i>*</dt>
  <dd class="It-tag">matches <i>r</i> repeated zero or more times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>r</i>+</dt>
  <dd class="It-tag">matches <i>r</i> repeated one or more times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>r</i>?</dt>
  <dd class="It-tag">matches <i>r</i> zero or once.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(<i>r</i>)</dt>
  <dd class="It-tag">matches <i>r</i>, providing grouping.</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The increasing precedence of operators is alternation, concatenation and unary
  (*, + or ?).
<div class="Pp"></div>
For example,
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	/^[_a-zA-Z][_a-zA-Z0-9]*$/  and
	/^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
are matched by AWK identifiers and AWK numeric constants respectively. Note that
  . has to be escaped to be recognized as a decimal point, and that
  metacharacters are not special inside character classes.
<div class="Pp"></div>
Any expression can be used on the right hand side of the ~ or !~ operators or
  passed to a built-in that expects a regular expression. If needed, it is
  converted to string, and then interpreted as a regular expression. For
  example,
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	BEGIN { identifier = &quot;[_a-zA-Z][_a-zA-Z0-9]*&quot; }
<div class="Pp"></div>
	$0 ~ &quot;^&quot; identifier
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
prints all lines that start with an AWK identifier.
<div class="Pp"></div>
<b>mawk</b> recognizes the empty regular expression, //, which matches the empty
  string and hence is matched by any string at the front, back and between every
  character. For example,
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	echo  abc | mawk { gsub(//, &quot;X&quot;) ; print }
	XaXbXcX
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
<h2 class="Ss" title="Ss" id="4._Records_and_fields"><a class="selflink" href="#4._Records_and_fields"><b>4.
  Records and fields</b></a></h2>
Records are read in one at a time, and stored in the <i>field</i> variable
  <b>$0</b>. The record is split into <i>fields</i> which are stored in
  <b>$1</b>, <b>$2</b>, ..., <b>$NF</b>. The built-in variable <b>NF</b> is set
  to the number of fields, and <b>NR</b> and <b>FNR</b> are incremented by 1.
  Fields above <b>$NF</b> are set to &quot;&quot;.
<div class="Pp"></div>
Assignment to <b>$0</b> causes the fields and <b>NF</b> to be recomputed.
  Assignment to <b>NF</b> or to a field causes <b>$0</b> to be reconstructed by
  concatenating the <b>$i's</b> separated by <b>OFS</b>. Assignment to a field
  with index greater than <b>NF</b>, increases <b>NF</b> and causes <b>$0</b> to
  be reconstructed.
<div class="Pp"></div>
Data input stored in fields is string, unless the entire field has numeric form
  and then the type is number and string. For example,
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
	echo 24 24E | 
	mawk '{ print($1&gt;100, $1&gt;&quot;100&quot;, $2&gt;100, $2&gt;&quot;100&quot;) }'
	0 1 1 1
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<b>$0</b> and <b>$2</b> are string and <b>$1</b> is number and string. The first
  comparison is numeric, the second is string, the third is string (100 is
  converted to &quot;100&quot;), and the last is string.
<h2 class="Ss" title="Ss" id="5._Expressions_and_operators"><a class="selflink" href="#5._Expressions_and_operators"><b>5.
  Expressions and operators</b></a></h2>
The expression syntax is similar to C. Primary expressions are numeric
  constants, string constants, variables, fields, arrays and function calls. The
  identifier for a variable, array or function can be a sequence of letters,
  digits and underscores, that does not start with a digit. Variables are not
  declared; they exist when first referenced and are initialized to <i>null</i>.
<div class="Pp"></div>
New expressions are composed with the following operators in order of increasing
  precedence.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<i>assignment</i>		=  +=  -=  *=  /=  %=  ^=
<i>conditional</i>		?  :
<i>logical or</i>		||
<i>logical and</i>		&amp;&amp;
<i>array membership</i>	<b>in</b>
<b></b><i>matching</i>		~   !~
<i>relational</i>		&lt;  &gt;   &lt;=  &gt;=  ==  !=
<i>concatenation</i>		(no explicit operator)
<i>add ops</i>			+  -
<i>mul ops</i>			*  /  % 
<i>unary</i>			+  -
<i>logical not</i>		!
<i>exponentiation</i>		^
<i>inc and dec</i>		++ -- (both post and pre)
<i>field</i>			$
</pre>
</div>
<div class="Pp"></div>
<br/>
Assignment, conditional and exponentiation associate right to left; the other
  operators associate left to right. Any expression can be parenthesized.
<h2 class="Ss" title="Ss" id="6._Arrays"><a class="selflink" href="#6._Arrays"><b>6.
  Arrays</b></a></h2>
Awk provides one-dimensional arrays. Array elements are expressed as
  <i>array</i>[ <i>expr</i>]. <i>Expr</i> is internally converted to string
  type, so, for example, A[1] and A[&quot;1&quot;] are the same element and the
  actual index is &quot;1&quot;. Arrays indexed by strings are called
  associative arrays. Initially an array is empty; elements exist when first
  accessed. An expression, <i>expr</i><b> in</b><i> array</i> evaluates to 1 if
  <i>array</i>[<i>expr</i>] exists, else to 0.
<div class="Pp"></div>
There is a form of the <b>for</b> statement that loops over each index of an
  array.
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	 <b>for</b> ( <i>var</i><b> in </b><i>array </i>) <i>statement</i>
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
sets <i>var</i> to each index of <i>array</i> and executes <i>statement</i>. The
  order that <i>var</i> transverses the indices of <i>array</i> is not defined.
<div class="Pp"></div>
The statement, <b>delete</b> <i>array</i>[<i>expr</i>], causes
  <i>array</i>[<i>expr</i>] not to exist. <b>mawk</b> supports an extension,
  <b>delete</b> <i>array</i>, which deletes all elements of <i>array</i>.
<div class="Pp"></div>
Multidimensional arrays are synthesized with concatenation using the built-in
  variable <b>SUBSEP</b>. <i>array</i>[<i>expr</i>1,<i>expr</i>2] is equivalent
  to <i>array</i>[<i>expr</i>1 <b>SUBSEP </b><i>expr</i>2]. Testing for a
  multidimensional element uses a parenthesized index, such as
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
	if ( (i, j) in A )  print A[i, j]
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="7._Builtin-variables"><a class="selflink" href="#7._Builtin-variables"><b>7.
  Builtin-variables</b></a></h2>
The following variables are built-in and initialized before program execution.
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>ARGC</b></dt>
  <dd class="It-tag">number of command line arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ARGV</b></dt>
  <dd class="It-tag">array of command line arguments, 0..ARGC-1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>CONVFMT</b></dt>
  <dd class="It-tag">format for internal conversion of numbers to string,
      initially = &quot;%.6g&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ENVIRON</b></dt>
  <dd class="It-tag">array indexed by environment variables. An environment
      string, <i>var=value</i> is stored as <b>ENVIRON</b>[<i>var</i>] =
      <i>value</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>FILENAME</b></dt>
  <dd class="It-tag">name of the current input file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>FNR</b></dt>
  <dd class="It-tag">current record number in <b>FILENAME</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>FS</b></dt>
  <dd class="It-tag">splits records into fields as a regular expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>NF</b></dt>
  <dd class="It-tag">number of fields in the current record.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>NR</b></dt>
  <dd class="It-tag">current record number in the total input stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>OFMT</b></dt>
  <dd class="It-tag">format for printing numbers; initially =
    &quot;%.6g&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>OFS</b></dt>
  <dd class="It-tag">inserted between fields on output, initially = &quot;
      &quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ORS</b></dt>
  <dd class="It-tag">terminates each record on output, initially =
      &quot;\n&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>RLENGTH</b></dt>
  <dd class="It-tag">length set by the last call to the built-in function,
      <b>match()</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>RS</b></dt>
  <dd class="It-tag">input record separator, initially = &quot;\n&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>RSTART</b></dt>
  <dd class="It-tag">index set by the last call to <b>match()</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SUBSEP</b></dt>
  <dd class="It-tag">used to build multiple array subscripts, initially =
      &quot;\034&quot;.</dd>
</dl>
</div>
<h2 class="Ss" title="Ss" id="8._Built-in_functions"><a class="selflink" href="#8._Built-in_functions"><b>8.
  Built-in functions</b></a></h2>
String functions
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">gsub(<i>r,s,t</i>) gsub(<i>r,s</i>)</dt>
  <dd class="It-tag">Global substitution, every match of regular expression
      <i>r</i> in variable <i>t</i> is replaced by string <i>s</i>. The number
      of replacements is returned. If <i>t</i> is omitted, <b>$0</b> is used. An
      &amp; in the replacement string <i>s</i> is replaced by the matched
      substring of <i>t</i>. \&amp; and \\ put literal &amp; and \,
      respectively, in the replacement string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">index(<i>s,t</i>)</dt>
  <dd class="It-tag">If <i>t</i> is a substring of <i>s</i>, then the position
      where <i>t</i> starts is returned, else 0 is returned. The first character
      of <i>s</i> is in position 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">length(<i>s</i>)</dt>
  <dd class="It-tag">Returns the length of string <i>s</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">match(<i>s,r</i>)</dt>
  <dd class="It-tag">Returns the index of the first longest match of regular
      expression <i>r</i> in string <i>s</i>. Returns 0 if no match. As a side
      effect, <b>RSTART</b> is set to the return value. <b>RLENGTH</b> is set to
      the length of the match or -1 if no match. If the empty string is matched,
      <b>RLENGTH</b> is set to 0, and 1 is returned if the match is at the
      front, and length( <i>s</i>)+1 is returned if the match is at the
    back.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">split(<i>s,A,r</i>) split(<i>s,A</i>)</dt>
  <dd class="It-tag">String <i>s</i> is split into fields by regular expression
      <i>r</i> and the fields are loaded into array <i>A</i>. The number of
      fields is returned. See section 11 below for more detail. If <i>r</i> is
      omitted, <b>FS</b> is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sprintf(<i>format,expr-list</i>)</dt>
  <dd class="It-tag">Returns a string constructed from <i>expr-list</i>
      according to <i>format</i>. See the description of printf() below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sub(<i>r,s,t</i>) sub(<i>r,s</i>)</dt>
  <dd class="It-tag">Single substitution, same as gsub() except at most one
      substitution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">substr(<i>s,i,n</i>) substr(<i>s,i</i>)</dt>
  <dd class="It-tag">Returns the substring of string <i>s</i>, starting at index
      <i>i</i>, of length <i>n</i>. If <i>n</i> is omitted, the suffix of
      <i>s</i>, starting at <i>i</i> is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">tolower(<i>s</i>)</dt>
  <dd class="It-tag">Returns a copy of <i>s</i> with all upper case characters
      converted to lower case.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">toupper(<i>s</i>)</dt>
  <dd class="It-tag">Returns a copy of <i>s</i> with all lower case characters
      converted to upper case.</dd>
</dl>
</div>
<div class="Pp"></div>
Arithmetic functions
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
<pre>
atan2( <i>y,x</i>)	Arctan of <i>y</i>/<i>x</i> between -pi and pi.
</pre>
<div class="Pp"></div>
<pre>
cos( <i>x</i>)		Cosine function, <i>x</i> in radians.
</pre>
<div class="Pp"></div>
<pre>
exp( <i>x</i>)		Exponential function.
</pre>
<div class="Pp"></div>
<pre>
int( <i>x</i>)		Returns <i>x</i> truncated towards zero.
</pre>
<div class="Pp"></div>
<pre>
log( <i>x</i>)		Natural logarithm.
</pre>
<div class="Pp"></div>
<pre>
rand()		Returns a random number between zero and one.
</pre>
<div class="Pp"></div>
<pre>
sin( <i>x</i>)		Sine function, <i>x</i> in radians.
</pre>
<div class="Pp"></div>
<pre>
sqrt( <i>x</i>)		Returns square root of <i>x</i>.
</pre>
<dl class="Bl-tag">
  <dt class="It-tag">srand(<i>expr</i>) srand()</dt>
  <dd class="It-tag">Seeds the random number generator, using the clock if
      <i>expr</i> is omitted, and returns the value of the previous seed.
      <b>mawk</b> seeds the random number generator from the clock at startup so
      there is no real need to call srand(). Srand( <i>expr</i>) is useful for
      repeating pseudo random sequences.</dd>
</dl>
</div>
<h2 class="Ss" title="Ss" id="9._Input_and_output"><a class="selflink" href="#9._Input_and_output"><b>9.
  Input and output</b></a></h2>
There are two output statements, <b>print</b> and <b>printf</b>.
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">print</dt>
  <dd class="It-tag">writes <b>$0 ORS</b> to standard output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">print <i>expr</i>1, <i>expr</i>2, ..., <i>expr</i>n</dt>
  <dd class="It-tag">writes <i>expr</i>1 <b>OFS </b><i>expr</i>2 <b>OFS</b> ...
      <i>expr</i>n <b>ORS</b> to standard output. Numeric expressions are
      converted to string with <b>OFMT</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">printf <i>format, expr-list</i></dt>
  <dd class="It-tag">duplicates the printf C library function writing to
      standard output. The complete ANSI C format specifications are recognized
      with conversions %c, %d, %e, %E, %f, %g, %G, %i, %o, %s, %u, %x, %X and
      %%, and conversion qualifiers h and l.</dd>
</dl>
</div>
<div class="Pp"></div>
The argument list to print or printf can optionally be enclosed in parentheses.
  Print formats numbers using <b>OFMT</b> or &quot;%d&quot; for exact integers.
  &quot;%c&quot; with a numeric argument prints the corresponding 8 bit
  character, with a string argument it prints the first character of the string.
  The output of print and printf can be redirected to a file or command by
  appending &gt; <i>file</i>, &gt;&gt; <i>file</i> or | <i>command</i> to the
  end of the print statement. Redirection opens <i>file</i> or <i>command</i>
  only once, subsequent redirections append to the already open stream. By
  convention, <b>mawk</b> associates the filename &quot;/dev/stderr&quot; with
  stderr which allows print and printf to be redirected to stderr. <b>mawk</b>
  also associates &quot;-&quot; and &quot;/dev/stdout&quot; with stdin and
  stdout which allows these streams to be passed to functions.
<div class="Pp"></div>
The input function <b>getline</b> has the following variations.
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">getline</dt>
  <dd class="It-tag">reads into <b>$0</b>, updates the fields, <b>NF</b>,
      <b>NR</b> and <b>FNR</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">getline &lt; <i>file</i></dt>
  <dd class="It-tag">reads into <b>$0</b> from <i>file</i>, updates the fields
      and <b>NF</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">getline <i>var</i></dt>
  <dd class="It-tag">reads the next record into <i>var</i>, updates <b>NR</b>
      and <b>FNR</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">getline <i>var</i> &lt; <i>file</i></dt>
  <dd class="It-tag">reads the next record of <i>file</i> into <i>var</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i> command</i> | getline</dt>
  <dd class="It-tag">pipes a record from <i>command</i> into <b>$0</b> and
      updates the fields and <b>NF</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i> command</i> | getline <i>var</i></dt>
  <dd class="It-tag">pipes a record from <i>command</i> into <i>var</i>.</dd>
</dl>
</div>
<div class="Pp"></div>
Getline returns 0 on end-of-file, -1 on error, otherwise 1.
<div class="Pp"></div>
Commands on the end of pipes are executed by /bin/sh.
<div class="Pp"></div>
The function <b>close</b>(<i>expr</i>) closes the file or pipe associated with
  <i>expr</i>. Close returns 0 if <i>expr</i> is an open file, the exit status
  if <i>expr</i> is a piped command, and -1 otherwise. Close is used to reread a
  file or command, make sure the other end of an output pipe is finished or
  conserve file resources.
<div class="Pp"></div>
The function <b>fflush</b>(<i>expr</i>) flushes the output file or pipe
  associated with <i>expr</i>. Fflush returns 0 if <i>expr</i> is an open output
  stream else -1. Fflush without an argument flushes stdout. Fflush with an
  empty argument (&quot;&quot;) flushes all open output.
<div class="Pp"></div>
The function <b>system</b>(<i>expr</i>) uses /bin/sh to execute <i>expr</i> and
  returns the exit status of the command <i>expr</i>. Changes made to the
  <b>ENVIRON</b> array are not passed to commands executed with <b>system</b> or
  pipes.
<h2 class="Ss" title="Ss" id="10._User_defined_functions"><a class="selflink" href="#10._User_defined_functions"><b>10.</b>
  <b>User</b> <b>defined</b> <b>functions</b></a></h2>
The syntax for a user defined function is
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	 <b>function</b> name( <i>args</i> ) { <i>statements</i> }
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
The function body can contain a return statement
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	 <b>return</b><i> opt_expr</i>
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
A return statement is not required. Function calls may be nested or recursive.
  Functions are passed expressions by value and arrays by reference. Extra
  arguments serve as local variables and are initialized to <i>null</i>. For
  example, csplit( <i>s,A</i>) puts each character of <i>s</i> into array
  <i>A</i> and returns the length of <i>s</i>.
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	function csplit(s, A,	n, i)
	{
	  n = length(s)
	  for( i = 1 ; i &lt;= n ; i++ ) A[i] = substr(s, i, 1)
	  return n
	}
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
Putting extra space between passed arguments and local variables is
  conventional. Functions can be referenced before they are defined, but the
  function name and the '(' of the arguments must touch to avoid confusion with
  concatenation.
<h2 class="Ss" title="Ss" id="11._Splitting_strings,_records_and_files"><a class="selflink" href="#11._Splitting_strings,_records_and_files"><b>11.
  Splitting strings, records and files</b></a></h2>
Awk programs use the same algorithm to split strings into arrays with split(),
  and records into fields on <b>FS</b>. <b>mawk</b> uses essentially the same
  algorithm to split files into records on <b>RS</b>.
<div class="Pp"></div>
Split( <i>expr,A,sep</i>) works as follows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">(1)</dt>
  <dd class="It-tag">If <i>sep</i> is omitted, it is replaced by <b>FS</b>.
      <i>Sep</i> can be an expression or regular expression. If it is an
      expression of non-string type, it is converted to string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(2)</dt>
  <dd class="It-tag">If <i>sep</i> = &quot; &quot; (a single space), then
      &lt;SPACE&gt; is trimmed from the front and back of <i>expr</i>, and
      <i>sep</i> becomes &lt;SPACE&gt;. <b>mawk</b> defines &lt;SPACE&gt; as the
      regular expression /[&#x00A0;\t\n]+/. Otherwise <i>sep</i> is treated as a
      regular expression, except that meta-characters are ignored for a string
      of length 1, e.g., split(x, A, &quot;*&quot;) and split(x, A, /\*/) are
      the same.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(3)</dt>
  <dd class="It-tag">If <i>expr</i> is not string, it is converted to string. If
      <i>expr</i> is then the empty string &quot;&quot;, split() returns 0 and
      <i>A</i> is set empty. Otherwise, all non-overlapping, non-null and
      longest matches of <i>sep</i> in <i>expr</i>, separate <i>expr</i> into
      fields which are loaded into <i>A</i>. The fields are placed in A[1],
      A[2], ..., A[n] and split() returns n, the number of fields which is the
      number of matches plus one. Data placed in <i>A</i> that looks numeric is
      typed number and string.</dd>
</dl>
</div>
<div class="Pp"></div>
Splitting records into fields works the same except the pieces are loaded into
  <b>$1</b>, <b>$2</b>,..., <b>$NF</b>. If <b>$0</b> is empty, <b>NF</b> is set
  to 0 and all <b>$i</b> to &quot;&quot;.
<div class="Pp"></div>
<b>mawk</b> splits files into records by the same algorithm, but with the slight
  difference that <b>RS</b> is really a terminator instead of a separator. (
  <b>ORS</b> is really a terminator too).
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
E.g., if <b>FS</b> = &quot;:+&quot; and <b>$0</b> = &quot;a::b:&quot; , then
  <b>NF</b> = 3 and <b>$1</b> = &quot;a&quot;, <b>$2</b> = &quot;b&quot; and
  <b>$3</b> = &quot;&quot;, but if &quot;a::b:&quot; is the contents of an input
  file and <b>RS</b> = &quot;:+&quot;, then there are two records &quot;a&quot;
  and &quot;b&quot;.</div>
<div class="Pp"></div>
<b>RS</b> = &quot; &quot; is not special.
<div class="Pp"></div>
If <b>FS</b> = &quot;&quot;, then <b>mawk</b> breaks the record into individual
  characters, and, similarly, split( <i>s,A,</i>&quot;&quot;) places the
  individual characters of <i>s</i> into <i>A</i>.
<h2 class="Ss" title="Ss" id="12._Multi-line_records"><a class="selflink" href="#12._Multi-line_records"><b>12.
  Multi-line records</b></a></h2>
Since <b>mawk</b> interprets <b>RS</b> as a regular expression, multi-line
  records are easy. Setting <b>RS</b> = &quot;\n\n+&quot;, makes one or more
  blank lines separate records. If <b>FS</b> = &quot; &quot; (the default), then
  single newlines, by the rules for &lt;SPACE&gt; above, become space and single
  newlines are field separators.
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
For example, if a file is &quot;a&#x00A0;b\nc\n\n&quot;, <b>RS</b> =
  &quot;\n\n+&quot; and <b>FS</b> = &quot;&#x00A0;&quot;, then there is one
  record &quot;a&#x00A0;b\nc&quot; with three fields &quot;a&quot;,
  &quot;b&quot; and &quot;c&quot;. Changing <b>FS</b> = &quot;\n&quot;, gives
  two fields &quot;a b&quot; and &quot;c&quot;; changing <b>FS</b> =
  &quot;&quot;, gives one field identical to the record.</div>
<div class="Pp"></div>
If you want lines with spaces or tabs to be considered blank, set <b>RS</b> =
  &quot;\n([&#x00A0;\t]*\n)+&quot;. For compatibility with other awks, setting
  <b>RS</b> = &quot;&quot; has the same effect as if blank lines are stripped
  from the front and back of files and then records are determined as if
  <b>RS</b> = &quot;\n\n+&quot;. Posix requires that &quot;\n&quot; always
  separates records when <b>RS</b> = &quot;&quot; regardless of the value of
  <b>FS</b>. <b>mawk</b> does not support this convention, because defining
  &quot;\n&quot; as &lt;SPACE&gt; makes it unnecessary.
<div class="Pp"></div>
Most of the time when you change <b>RS</b> for multi-line records, you will also
  want to change <b>ORS</b> to &quot;\n\n&quot; so the record spacing is
  preserved on output.
<h2 class="Ss" title="Ss" id="13._Program_execution"><a class="selflink" href="#13._Program_execution"><b>13.
  Program execution</b></a></h2>
This section describes the order of program execution. First <b>ARGC</b> is set
  to the total number of command line arguments passed to the execution phase of
  the program. <b>ARGV[0]</b> is set the name of the AWK interpreter and
  <b>ARGV[1]</b> ... <b>ARGV[ARGC-1]</b> holds the remaining command line
  arguments exclusive of options and program source. For example with
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	mawk  -f  prog  v=1  A  t=hello  B
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
<b>ARGC</b> = 5 with <b>ARGV[0]</b> = &quot;mawk&quot;, <b>ARGV[1]</b> =
  &quot;v=1&quot;, <b>ARGV[2]</b> = &quot;A&quot;, <b>ARGV[3]</b> =
  &quot;t=hello&quot; and <b>ARGV[4]</b> = &quot;B&quot;.
<div class="Pp"></div>
Next, each <b>BEGIN</b> block is executed in order. If the program consists
  entirely of <b>BEGIN</b> blocks, then execution terminates, else an input
  stream is opened and execution continues. If <b>ARGC</b> equals 1, the input
  stream is set to stdin, else the command line arguments <b>ARGV[1]</b> ...
  <b>ARGV[ARGC-1]</b> are examined for a file argument.
<div class="Pp"></div>
The command line arguments divide into three sets: file arguments, assignment
  arguments and empty strings &quot;&quot;. An assignment has the form
  <i>var</i>= <i>string</i>. When an <b>ARGV[i]</b> is examined as a possible
  file argument, if it is empty it is skipped; if it is an assignment argument,
  the assignment to <i>var</i> takes place and <b>i</b> skips to the next
  argument; else <b>ARGV[i]</b> is opened for input. If it fails to open,
  execution terminates with exit code 2. If no command line argument is a file
  argument, then input comes from stdin. Getline in a <b>BEGIN</b> action opens
  input. &quot;-&quot; as a file argument denotes stdin.
<div class="Pp"></div>
Once an input stream is open, each input record is tested against each
  <i>pattern</i>, and if it matches, the associated <i>action</i> is executed.
  An expression pattern matches if it is boolean true (see the end of section
  2). A <b>BEGIN</b> pattern matches before any input has been read, and an
  <b>END</b> pattern matches after all input has been read. A range pattern,
  <i>expr</i>1, <i>expr</i>2 , matches every record between the match of
  <i>expr</i>1 and the match <i>expr</i>2 inclusively.
<div class="Pp"></div>
When end of file occurs on the input stream, the remaining command line
  arguments are examined for a file argument, and if there is one it is opened,
  else the <b>END</b> <i>pattern</i> is considered matched and all <b>END</b>
  <i>actions</i> are executed.
<div class="Pp"></div>
In the example, the assignment v=1 takes place after the <b>BEGIN</b>
  <i>actions</i> are executed, and the data placed in v is typed number and
  string. Input is then read from file A. On end of file A, t is set to the
  string &quot;hello&quot;, and B is opened for input. On end of file B, the
  <b>END</b> <i>actions</i> are executed.
<div class="Pp"></div>
Program flow at the <i>pattern</i> <i>{action}</i> level can be changed with the
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	 <b>next</b>
<b>	</b><b>exit  </b><i>opt_expr</i>
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
statements. A <b>next</b> statement causes the next input record to be read and
  pattern testing to restart with the first <i>pattern {action}</i> pair in the
  program. An <b>exit</b> statement causes immediate execution of the <b>END</b>
  actions or program termination if there are none or if the <b>exit</b> occurs
  in an <b>END</b> action. The <i>opt_expr</i> sets the exit value of the
  program unless overridden by a later <b>exit</b> or subsequent error.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>
1. emulate cat.
<div class="Pp"></div>
	{ print }
<div class="Pp"></div>
2. emulate wc.
<div class="Pp"></div>
	{ chars += length($0) + 1  # add one for the \n
	  words += NF
	}
<div class="Pp"></div>
	END{ print NR, words, chars }
<div class="Pp"></div>
3. count the number of unique &quot;real words&quot;.
<div class="Pp"></div>
	BEGIN { FS = &quot;[^A-Za-z]+&quot; }
<div class="Pp"></div>
	{ for(i = 1 ; i &lt;= NF ; i++)  word[$i] = &quot;&quot; }
<div class="Pp"></div>
	END { delete word[&quot;&quot;]
	      for ( i in word )  cnt++
	      print cnt
	}
<div class="Pp"></div>
</pre>
4. sum the second field of every record based on the first field.
<pre>
<div class="Pp"></div>
	$1 ~ /credit|gain/ { sum += $2 }
	$1 ~ /debit|loss/  { sum -= $2 }
<div class="Pp"></div>
	END { print sum }
<div class="Pp"></div>
5. sort a file, comparing as string
<div class="Pp"></div>
	{ line[NR] = $0 &quot;&quot; }  # make sure of comparison type
			      # in case some lines look numeric
<div class="Pp"></div>
	END {  isort(line, NR)
	  for(i = 1 ; i &lt;= NR ; i++) print line[i]
	}
<div class="Pp"></div>
	#insertion sort of A[1..n]
	function isort( A, n,	i, j, hold)
	{
	  for( i = 2 ; i &lt;= n ; i++)
	  {
	    hold = A[j = i]
	    while ( A[j-1] &gt; hold )
	    { j-- ; A[j+1] = A[j] }
	    A[j] = hold
	  }
	  # sentinel A[0] = &quot;&quot; will be created if needed
	}
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="COMPATIBILITY_ISSUES"><a class="selflink" href="#COMPATIBILITY_ISSUES">COMPATIBILITY
  ISSUES</a></h1>
The Posix 1003.2(draft 11.3) definition of the AWK language is AWK as described
  in the AWK book with a few extensions that appeared in SystemVR4 nawk. The
  extensions are:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">New functions: toupper() and tolower().
<div style="height: 1.00em;">&#x00A0;</div>
New variables: ENVIRON[] and CONVFMT.
<div style="height: 1.00em;">&#x00A0;</div>
ANSI C conversion specifications for printf() and sprintf().
<div style="height: 1.00em;">&#x00A0;</div>
New command options: -v var=value, multiple -f options and implementation
  options as arguments to -W.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
Posix AWK is oriented to operate on files a line at a time. <b>RS</b> can be
  changed from &quot;\n&quot; to another single character, but it is hard to
  find any use for this &#x2014; there are no examples in the AWK book. By
  convention, <b>RS</b> = &quot;&quot;, makes one or more blank lines separate
  records, allowing multi-line records. When <b>RS</b> = &quot;&quot;,
  &quot;\n&quot; is always a field separator regardless of the value in
  <b>FS</b>.
<div class="Pp"></div>
<b>mawk</b>, on the other hand, allows <b>RS</b> to be a regular expression.
  When &quot;\n&quot; appears in records, it is treated as space, and <b>FS</b>
  always determines fields.
<div class="Pp"></div>
Removing the line at a time paradigm can make some programs simpler and can
  often improve performance. For example, redoing example 3 from above,
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	BEGIN { RS = &quot;[^A-Za-z]+&quot; }
<div class="Pp"></div>
	{ word[ $0 ] = &quot;&quot; }
<div class="Pp"></div>
	END { delete  word[ &quot;&quot; ]
	  for( i in word )  cnt++
	  print cnt
	}
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
counts the number of unique words by making each word a record. On moderate size
  files, <b>mawk</b> executes twice as fast, because of the simplified inner
  loop.
<div class="Pp"></div>
The following program replaces each comment by a single space in a C program
  file,
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	BEGIN {
	  RS = &quot;/\*([^*]|\*+[^/*])*\*+/&quot;
		# comment is record separator
	  ORS = &quot; &quot;
	  getline  hold
       }
<div class="Pp"></div>
       { print hold ; hold = $0 }
<div class="Pp"></div>
       END { printf &quot;%s&quot; , hold }
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
Buffering one record is needed to avoid terminating the last record with a
  space.
<div class="Pp"></div>
With <b>mawk</b>, the following are all equivalent,
<pre>
<div style="height: 1.00em;">&#x00A0;</div>
	x ~ /a\+b/    x ~ &quot;a\+b&quot;     x ~ &quot;a\\+b&quot;
<div style="height: 1.00em;">&#x00A0;</div>
</pre>
The strings get scanned twice, once as string and once as regular expression. On
  the string scan, <b>mawk</b> ignores the escape on non-escape characters while
  the AWK book advocates <i>\c</i> be recognized as <i>c</i> which necessitates
  the double escaping of meta-characters in strings. Posix explicitly declines
  to define the behavior which passively forces programs that must run under a
  variety of awks to use the more portable but less readable, double escape.
<div class="Pp"></div>
Posix AWK does not recognize &quot;/dev/std{out,err}&quot; or \x hex escape
  sequences in strings. Unlike ANSI C, <b>mawk</b> limits the number of digits
  that follows \x to two as the current implementation only supports 8 bit
  characters. The built-in <b>fflush</b> first appeared in a recent (1993)
  AT&amp;T awk released to netlib, and is not part of the posix standard.
  Aggregate deletion with <b>delete</b> <i>array</i> is not part of the posix
  standard.
<div class="Pp"></div>
Posix explicitly leaves the behavior of <b>FS</b> = &quot;&quot; undefined, and
  mentions splitting the record into characters as a possible interpretation,
  but currently this use is not portable across implementations.
<div class="Pp"></div>
Finally, here is how <b>mawk</b> handles exceptional cases not discussed in the
  AWK book or the Posix draft. It is unsafe to assume consistency across awks
  and safe to skip to the next section.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">substr(s, i, n) returns the characters of s in
  the intersection of the closed interval [1, length(s)] and the half-open
  interval [i, i+n). When this intersection is empty, the empty string is
  returned; so substr(&quot;ABC&quot;, 1, 0) = &quot;&quot; and
  substr(&quot;ABC&quot;, -4, 6) = &quot;A&quot;.
<div class="Pp"></div>
Every string, including the empty string, matches the empty string at the front
  so, s ~ // and s ~ &quot;&quot;, are always 1 as is match(s, //) and match(s,
  &quot;&quot;). The last two set <b>RLENGTH</b> to 0.
<div class="Pp"></div>
index(s, t) is always the same as match(s, t1) where t1 is the same as t with
  metacharacters escaped. Hence consistency with match requires that index(s,
  &quot;&quot;) always returns 1. Also the condition, index(s,t) != 0 if and
  only t is a substring of s, requires index(&quot;&quot;,&quot;&quot;) = 1.
<div class="Pp"></div>
If getline encounters end of file, getline var, leaves var unchanged. Similarly,
  on entry to the <b>END</b> actions, <b>$0</b>, the fields and <b>NF</b> have
  their value unaltered from the last record.</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>egrep</i>(1)
<div class="Pp"></div>
Aho, Kernighan and Weinberger, <i>The AWK Programming Language</i>,
  Addison-Wesley Publishing, 1988, (the AWK book), defines the language, opening
  with a tutorial and advancing to many interesting programs that delve into
  issues of software design and analysis relevant to programming in any
  language.
<div class="Pp"></div>
<i>The GAWK Manual</i>, The Free Software Foundation, 1991, is a tutorial and
  language reference that does not attempt the depth of the AWK book and assumes
  the reader may be a novice programmer. The section on AWK arrays is excellent.
  It also discusses Posix requirements for AWK.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
<b>mawk</b> cannot handle ascii NUL \0 in the source or data files. You can
  output NUL using printf with %c, and any other 8 bit character is acceptable
  input.
<div class="Pp"></div>
<b>mawk</b> implements printf() and sprintf() using the C library functions,
  printf and sprintf, so full ANSI compatibility requires an ANSI C library. In
  practice this means the h conversion qualifier may not be available. Also
  <b>mawk</b> inherits any bugs or limitations of the library functions.
<div class="Pp"></div>
Implementors of the AWK language have shown a consistent lack of imagination
  when naming their programs.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Mike Brennan (brennan@whidbey.com).</div>
<table class="foot">
  <tr>
    <td class="foot-date">Dec 22 1994</td>
    <td class="foot-os">Version 1.2</td>
  </tr>
</table>
</body>
</html>
