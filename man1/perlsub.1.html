<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:07 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLSUB(1) Perl Programmers Reference Guide
PERLSUB(1)</p>

<p style="margin-top: 1em">NAME <br>
perlsub - Perl subroutines</p>

<p style="margin-top: 1em">SYNOPSIS <br>
To declare subroutines:</p>

<p style="margin-top: 1em">sub NAME; # A
&quot;forward&quot; declaration. <br>
sub NAME(PROTO); # ditto, but with prototypes <br>
sub NAME : ATTRS; # with attributes <br>
sub NAME(PROTO) : ATTRS; # with attributes and
prototypes</p>

<p style="margin-top: 1em">sub NAME BLOCK # A declaration
and a definition. <br>
sub NAME(PROTO) BLOCK # ditto, but with prototypes <br>
sub NAME : ATTRS BLOCK # with attributes <br>
sub NAME(PROTO) : ATTRS BLOCK # with prototypes and
attributes</p>

<p style="margin-top: 1em">To define an anonymous
subroutine at runtime:</p>

<p style="margin-top: 1em">$subref = sub BLOCK; # no proto
<br>
$subref = sub (PROTO) BLOCK; # with proto <br>
$subref = sub : ATTRS BLOCK; # with attributes <br>
$subref = sub (PROTO) : ATTRS BLOCK; # with proto and
attributes</p>

<p style="margin-top: 1em">To import subroutines:</p>

<p style="margin-top: 1em">use MODULE qw(NAME1 NAME2
NAME3);</p>

<p style="margin-top: 1em">To call subroutines:</p>

<p style="margin-top: 1em">NAME(LIST); # &amp; is optional
with parentheses. <br>
NAME LIST; # Parentheses optional if predeclared/imported.
<br>
&amp;NAME(LIST); # Circumvent prototypes. <br>
&amp;NAME; # Makes current @_ visible to called
subroutine.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Like many languages, Perl provides for user-defined
subroutines. These may be located anywhere in the main
program, loaded in from other files via the &quot;do&quot;,
&quot;require&quot;, or &quot;use&quot; <br>
keywords, or generated on the fly using &quot;eval&quot; or
anonymous subroutines. You can even call a function
indirectly using a variable containing its name or a CODE
reference.</p>

<p style="margin-top: 1em">The Perl model for function call
and return values is simple: all functions are passed as
parameters one single flat list of scalars, and all
functions likewise return to their <br>
caller one single flat list of scalars. Any arrays or hashes
in these call and return lists will collapse, losing their
identities--but you may always use pass-by-reference <br>
instead to avoid this. Both call and return lists may
contain as many or as few scalar elements as you&rsquo;d
like. (Often a function without an explicit return statement
is called <br>
a subroutine, but there&rsquo;s really no difference from
Perl&rsquo;s perspective.)</p>

<p style="margin-top: 1em">Any arguments passed in show up
in the array @_. Therefore, if you called a function with
two arguments, those would be stored in $_[0] and $_[1]. The
array @_ is a local <br>
array, but its elements are aliases for the actual scalar
parameters. In particular, if an element $_[0] is updated,
the corresponding argument is updated (or an error occurs if
<br>
it is not updatable). If an argument is an array or hash
element which did not exist when the function was called,
that element is created only when (and if) it is modified or
a <br>
reference to it is taken. (Some earlier versions of Perl
created the element whether or not the element was assigned
to.) Assigning to the whole array @_ removes that aliasing,
<br>
and does not update any arguments.</p>

<p style="margin-top: 1em">A &quot;return&quot; statement
may be used to exit a subroutine, optionally specifying the
returned value, which will be evaluated in the appropriate
context (list, scalar, or void) <br>
depending on the context of the subroutine call. If you
specify no return value, the subroutine returns an empty
list in list context, the undefined value in scalar context,
or <br>
nothing in void context. If you return one or more
aggregates (arrays and hashes), these will be flattened
together into one large indistinguishable list.</p>

<p style="margin-top: 1em">If no &quot;return&quot; is
found and if the last statement is an expression, its value
is returned. If the last statement is a loop control
structure like a &quot;foreach&quot; or a &quot;while&quot;,
the <br>
returned value is unspecified. The empty sub returns the
empty list.</p>

<p style="margin-top: 1em">Perl does not have named formal
parameters. In practice all you do is assign to a
&quot;my()&quot; list of these. Variables that aren&rsquo;t
declared to be private are global variables. For <br>
gory details on creating private variables, see
&quot;Private Variables via my()&quot; and &quot;Temporary
Values via local()&quot;. To create protected environments
for a set of functions in a <br>
separate package (and probably a separate file), see
&quot;Packages&quot; in perlmod.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">sub max { <br>
my $max = shift(@_); <br>
foreach $foo (@_) { <br>
$max = $foo if $max &lt; $foo; <br>
} <br>
return $max; <br>
} <br>
$bestday = max($mon,$tue,$wed,$thu,$fri);</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># get a line, combining
continuation lines <br>
# that start with whitespace</p>

<p style="margin-top: 1em">sub get_line { <br>
$thisline = $lookahead; # global variables! <br>
LINE: while (defined($lookahead = &lt;STDIN&gt;)) { <br>
if ($lookahead =~ /^[ ]/) { <br>
$thisline .= $lookahead; <br>
} <br>
else { <br>
last LINE; <br>
} <br>
} <br>
return $thisline; <br>
}</p>

<p style="margin-top: 1em">$lookahead = &lt;STDIN&gt;; #
get first line <br>
while (defined($line = get_line())) { <br>
... <br>
}</p>

<p style="margin-top: 1em">Assigning to a list of private
variables to name your arguments:</p>

<p style="margin-top: 1em">sub maybeset { <br>
my($key, $value) = @_; <br>
$Foo{$key} = $value unless $Foo{$key}; <br>
}</p>

<p style="margin-top: 1em">Because the assignment copies
the values, this also has the effect of turning
call-by-reference into call-by-value. Otherwise a function
is free to do in-place modifications of <br>
@_ and change its caller&rsquo;s values.</p>

<p style="margin-top: 1em">upcase_in($v1, $v2); # this
changes $v1 and $v2 <br>
sub upcase_in { <br>
for (@_) { tr/a-z/A-Z/ } <br>
}</p>

<p style="margin-top: 1em">You aren&rsquo;t allowed to
modify constants in this way, of course. If an argument were
actually literal and you tried to change it, you&rsquo;d
take a (presumably fatal) exception. For <br>
example, this won&rsquo;t work:</p>


<p style="margin-top: 1em">upcase_in(&quot;frederick&quot;);</p>

<p style="margin-top: 1em">It would be much safer if the
&quot;upcase_in()&quot; function were written to return a
copy of its parameters instead of changing them in
place:</p>

<p style="margin-top: 1em">($v3, $v4) = upcase($v1, $v2); #
this doesn&rsquo;t change $v1 and $v2 <br>
sub upcase { <br>
return unless defined wantarray; # void context, do nothing
<br>
my @parms = @_; <br>
for (@parms) { tr/a-z/A-Z/ } <br>
return wantarray ? @parms : $parms[0]; <br>
}</p>

<p style="margin-top: 1em">Notice how this (unprototyped)
function doesn&rsquo;t care whether it was passed real
scalars or arrays. Perl sees all arguments as one big, long,
flat parameter list in @_. This is <br>
one area where Perl&rsquo;s simple argument-passing style
shines. The &quot;upcase()&quot; function would work
perfectly well without changing the &quot;upcase()&quot;
definition even if we fed it things <br>
like this:</p>

<p style="margin-top: 1em">@newlist = upcase(@list1,
@list2); <br>
@newlist = upcase( split /:/, $var );</p>

<p style="margin-top: 1em">Do not, however, be tempted to
do this:</p>

<p style="margin-top: 1em">(@a, @b) = upcase(@list1,
@list2);</p>

<p style="margin-top: 1em">Like the flattened incoming
parameter list, the return list is also flattened on return.
So all you have managed to do here is stored everything in
@a and made @b empty. See <br>
&quot;Pass by Reference&quot; for alternatives.</p>

<p style="margin-top: 1em">A subroutine may be called using
an explicit &quot;&amp;&quot; prefix. The &quot;&amp;&quot;
is optional in modern Perl, as are parentheses if the
subroutine has been predeclared. The &quot;&amp;&quot; is
not optional <br>
when just naming the subroutine, such as when it&rsquo;s
used as an argument to defined() or undef(). Nor is it
optional when you want to do an indirect subroutine call
with a <br>
subroutine name or reference using the
&quot;&amp;$subref()&quot; or &quot;&amp;{$subref}()&quot;
constructs, although the &quot;$subref-&gt;()&quot; notation
solves that problem. See perlref for more about all
that.</p>

<p style="margin-top: 1em">Subroutines may be called
recursively. If a subroutine is called using the
&quot;&amp;&quot; form, the argument list is optional, and
if omitted, no @_ array is set up for the subroutine: the
<br>
@_ array at the time of the call is visible to subroutine
instead. This is an efficiency mechanism that new users may
wish to avoid.</p>

<p style="margin-top: 1em">&amp;foo(1,2,3); # pass three
arguments <br>
foo(1,2,3); # the same</p>

<p style="margin-top: 1em">foo(); # pass a null list <br>
&amp;foo(); # the same</p>

<p style="margin-top: 1em">&amp;foo; # foo() get current
args, like foo(@_) !! <br>
foo; # like foo() IFF sub foo predeclared, else
&quot;foo&quot;</p>

<p style="margin-top: 1em">Not only does the
&quot;&amp;&quot; form make the argument list optional, it
also disables any prototype checking on arguments you do
provide. This is partly for historical reasons, and <br>
partly for having a convenient way to cheat if you know what
you&rsquo;re doing. See &quot;Prototypes&quot; below.</p>

<p style="margin-top: 1em">Since Perl 5.16.0, the
&quot;__SUB__&quot; token is available under &quot;use
feature &rsquo;current_sub&rsquo;&quot; and &quot;use
5.16.0&quot;. It will evaluate to a reference to the
currently-running sub, which <br>
allows for recursive calls without knowing your
subroutine&rsquo;s name.</p>

<p style="margin-top: 1em">use 5.16.0; <br>
my $factorial = sub { <br>
my ($x) = @_; <br>
return 1 if $x == 1; <br>
return($x * __SUB__-&gt;( $x - 1 ) ); <br>
};</p>

<p style="margin-top: 1em">Subroutines whose names are in
all upper case are reserved to the Perl core, as are modules
whose names are in all lower case. A subroutine in all
capitals is a loosely-held <br>
convention meaning it will be called indirectly by the
run-time system itself, usually due to a triggered event.
Subroutines that do special, pre-defined things include <br>
&quot;AUTOLOAD&quot;, &quot;CLONE&quot;, &quot;DESTROY&quot;
plus all functions mentioned in perltie and PerlIO::via.</p>

<p style="margin-top: 1em">The &quot;BEGIN&quot;,
&quot;UNITCHECK&quot;, &quot;CHECK&quot;, &quot;INIT&quot;
and &quot;END&quot; subroutines are not so much subroutines
as named special code blocks, of which you can have more
than one in a package, and <br>
which you can not call explicitly. See &quot;BEGIN,
UNITCHECK, CHECK, INIT and END&quot; in perlmod</p>

<p style="margin-top: 1em">Private Variables via my() <br>
Synopsis:</p>

<p style="margin-top: 1em">my $foo; # declare $foo
lexically local <br>
my (@wid, %get); # declare list of variables local <br>
my $foo = &quot;flurp&quot;; # declare $foo lexical, and
init it <br>
my @oof = @bar; # declare @oof lexical, and init it <br>
my $x : Foo = $y; # similar, with an attribute applied</p>

<p style="margin-top: 1em">WARNING: The use of attribute
lists on &quot;my&quot; declarations is still evolving. The
current semantics and interface are subject to change. See
attributes and Attribute::Handlers.</p>

<p style="margin-top: 1em">The &quot;my&quot; operator
declares the listed variables to be lexically confined to
the enclosing block, conditional
(&quot;if/unless/elsif/else&quot;), loop
(&quot;for/foreach/while/until/continue&quot;), <br>
subroutine, &quot;eval&quot;, or
&quot;do/require/use&quot;&rsquo;d file. If more than one
value is listed, the list must be placed in parentheses. All
listed elements must be legal lvalues. Only <br>
alphanumeric identifiers may be lexically scoped--magical
built-ins like $/ must currently be &quot;local&quot;ized
with &quot;local&quot; instead.</p>

<p style="margin-top: 1em">Unlike dynamic variables created
by the &quot;local&quot; operator, lexical variables
declared with &quot;my&quot; are totally hidden from the
outside world, including any called subroutines. This <br>
is true if it&rsquo;s the same subroutine called from itself
or elsewhere--every call gets its own copy.</p>

<p style="margin-top: 1em">This doesn&rsquo;t mean that a
&quot;my&quot; variable declared in a statically enclosing
lexical scope would be invisible. Only dynamic scopes are
cut off. For example, the &quot;bumpx()&quot; <br>
function below has access to the lexical $x variable because
both the &quot;my&quot; and the &quot;sub&quot; occurred at
the same scope, presumably file scope.</p>

<p style="margin-top: 1em">my $x = 10; <br>
sub bumpx { $x++ }</p>

<p style="margin-top: 1em">An &quot;eval()&quot;, however,
can see lexical variables of the scope it is being evaluated
in, so long as the names aren&rsquo;t hidden by declarations
within the &quot;eval()&quot; itself. See <br>
perlref.</p>

<p style="margin-top: 1em">The parameter list to my() may
be assigned to if desired, which allows you to initialize
your variables. (If no initializer is given for a particular
variable, it is created <br>
with the undefined value.) Commonly this is used to name
input parameters to a subroutine. Examples:</p>

<p style="margin-top: 1em">$arg = &quot;fred&quot;; #
&quot;global&quot; variable <br>
$n = cube_root(27); <br>
print &quot;$arg thinks the root is $n0; <br>
fred thinks the root is 3</p>

<p style="margin-top: 1em">sub cube_root { <br>
my $arg = shift; # name doesn&rsquo;t matter <br>
$arg **= 1/3; <br>
return $arg; <br>
}</p>

<p style="margin-top: 1em">The &quot;my&quot; is simply a
modifier on something you might assign to. So when you do
assign to variables in its argument list, &quot;my&quot;
doesn&rsquo;t change whether those variables are viewed <br>
as a scalar or an array. So</p>

<p style="margin-top: 1em">my ($foo) = &lt;STDIN&gt;; #
WRONG? <br>
my @FOO = &lt;STDIN&gt;;</p>

<p style="margin-top: 1em">both supply a list context to
the right-hand side, while</p>

<p style="margin-top: 1em">my $foo = &lt;STDIN&gt;;</p>

<p style="margin-top: 1em">supplies a scalar context. But
the following declares only one variable:</p>

<p style="margin-top: 1em">my $foo, $bar = 1; # WRONG</p>

<p style="margin-top: 1em">That has the same effect as</p>

<p style="margin-top: 1em">my $foo; <br>
$bar = 1;</p>

<p style="margin-top: 1em">The declared variable is not
introduced (is not visible) until after the current
statement. Thus,</p>

<p style="margin-top: 1em">my $x = $x;</p>

<p style="margin-top: 1em">can be used to initialize a new
$x with the value of the old $x, and the expression</p>

<p style="margin-top: 1em">my $x = 123 and $x == 123</p>

<p style="margin-top: 1em">is false unless the old $x
happened to have the value 123.</p>

<p style="margin-top: 1em">Lexical scopes of control
structures are not bounded precisely by the braces that
delimit their controlled blocks; control expressions are
part of that scope, too. Thus in the <br>
loop</p>

<p style="margin-top: 1em">while (my $line = &lt;&gt;) {
<br>
$line = lc $line; <br>
} continue { <br>
print $line; <br>
}</p>

<p style="margin-top: 1em">the scope of $line extends from
its declaration throughout the rest of the loop construct
(including the &quot;continue&quot; clause), but not beyond
it. Similarly, in the conditional</p>

<p style="margin-top: 1em">if ((my $answer = &lt;STDIN&gt;)
=~ /^yes$/i) { <br>
user_agrees(); <br>
} elsif ($answer =~ /^no$/i) { <br>
user_disagrees(); <br>
} else { <br>
chomp $answer; <br>
die &quot;&rsquo;$answer&rsquo; is neither &rsquo;yes&rsquo;
nor &rsquo;no&rsquo;&quot;; <br>
}</p>

<p style="margin-top: 1em">the scope of $answer extends
from its declaration through the rest of that conditional,
including any &quot;elsif&quot; and &quot;else&quot;
clauses, but not beyond it. See &quot;Simple
Statements&quot; in <br>
perlsyn for information on the scope of variables in
statements with modifiers.</p>

<p style="margin-top: 1em">The &quot;foreach&quot; loop
defaults to scoping its index variable dynamically in the
manner of &quot;local&quot;. However, if the index variable
is prefixed with the keyword &quot;my&quot;, or if there is
<br>
already a lexical by that name in scope, then a new lexical
is created instead. Thus in the loop</p>

<p style="margin-top: 1em">for my $i (1, 2, 3) { <br>
some_function(); <br>
}</p>

<p style="margin-top: 1em">the scope of $i extends to the
end of the loop, but not beyond it, rendering the value of
$i inaccessible within &quot;some_function()&quot;.</p>

<p style="margin-top: 1em">Some users may wish to encourage
the use of lexically scoped variables. As an aid to catching
implicit uses to package variables, which are always global,
if you say</p>

<p style="margin-top: 1em">use strict
&rsquo;vars&rsquo;;</p>

<p style="margin-top: 1em">then any variable mentioned from
there to the end of the enclosing block must either refer to
a lexical variable, be predeclared via &quot;our&quot; or
&quot;use vars&quot;, or else must be fully <br>
qualified with the package name. A compilation error results
otherwise. An inner block may countermand this with &quot;no
strict &rsquo;vars&rsquo;&quot;.</p>

<p style="margin-top: 1em">A &quot;my&quot; has both a
compile-time and a run-time effect. At compile time, the
compiler takes notice of it. The principal usefulness of
this is to quiet &quot;use strict &rsquo;vars&rsquo;&quot;,
but it <br>
is also essential for generation of closures as detailed in
perlref. Actual initialization is delayed until run time,
though, so it gets executed at the appropriate time, such
<br>
as each time through a loop, for example.</p>

<p style="margin-top: 1em">Variables declared with
&quot;my&quot; are not part of any package and are therefore
never fully qualified with the package name. In particular,
you&rsquo;re not allowed to try to make a <br>
package variable (or other global) lexical:</p>

<p style="margin-top: 1em">my $pack::var; # ERROR! Illegal
syntax</p>

<p style="margin-top: 1em">In fact, a dynamic variable
(also known as package or global variables) are still
accessible using the fully qualified &quot;::&quot; notation
even while a lexical of the same name is also <br>
visible:</p>

<p style="margin-top: 1em">package main; <br>
local $x = 10; <br>
my $x = 20; <br>
print &quot;$x and $::x0;</p>

<p style="margin-top: 1em">That will print out 20 and
10.</p>

<p style="margin-top: 1em">You may declare &quot;my&quot;
variables at the outermost scope of a file to hide any such
identifiers from the world outside that file. This is
similar in spirit to C&rsquo;s static variables <br>
when they are used at the file level. To do this with a
subroutine requires the use of a closure (an anonymous
function that accesses enclosing lexicals). If you want to
create <br>
a private subroutine that cannot be called from outside that
block, it can declare a lexical variable containing an
anonymous sub reference:</p>

<p style="margin-top: 1em">my $secret_version =
&rsquo;1.001-beta&rsquo;; <br>
my $secret_sub = sub { print $secret_version }; <br>
&amp;$secret_sub();</p>

<p style="margin-top: 1em">As long as the reference is
never returned by any function within the module, no outside
module can see the subroutine, because its name is not in
any package&rsquo;s symbol table. <br>
Remember that it&rsquo;s not REALLY called
$some_pack::secret_version or anything; it&rsquo;s just
$secret_version, unqualified and unqualifiable.</p>

<p style="margin-top: 1em">This does not work with object
methods, however; all object methods have to be in the
symbol table of some package to be found. See &quot;Function
Templates&quot; in perlref for something <br>
of a work-around to this.</p>

<p style="margin-top: 1em">Persistent Private Variables
<br>
There are two ways to build persistent private variables in
Perl 5.10. First, you can simply use the &quot;state&quot;
feature. Or, you can use closures, if you want to stay
compatible <br>
with releases older than 5.10.</p>

<p style="margin-top: 1em">Persistent variables via
state()</p>

<p style="margin-top: 1em">Beginning with Perl 5.9.4, you
can declare variables with the &quot;state&quot; keyword in
place of &quot;my&quot;. For that to work, though, you must
have enabled that feature beforehand, either <br>
by using the &quot;feature&quot; pragma, or by using
&quot;-E&quot; on one-liners (see feature). Beginning with
Perl 5.16, the &quot;CORE::state&quot; form does not require
the &quot;feature&quot; pragma.</p>

<p style="margin-top: 1em">For example, the following code
maintains a private counter, incremented each time the
gimme_another() function is called:</p>

<p style="margin-top: 1em">use feature &rsquo;state&rsquo;;
<br>
sub gimme_another { state $x; return ++$x }</p>

<p style="margin-top: 1em">Also, since $x is lexical, it
can&rsquo;t be reached or modified by any Perl code
outside.</p>

<p style="margin-top: 1em">When combined with variable
declaration, simple scalar assignment to &quot;state&quot;
variables (as in &quot;state $x = 42&quot;) is executed only
the first time. When such statements are <br>
evaluated subsequent times, the assignment is ignored. The
behavior of this sort of assignment to non-scalar variables
is undefined.</p>

<p style="margin-top: 1em">Persistent variables with
closures</p>

<p style="margin-top: 1em">Just because a lexical variable
is lexically (also called statically) scoped to its
enclosing block, &quot;eval&quot;, or &quot;do&quot; FILE,
this doesn&rsquo;t mean that within a function it works like
<br>
a C static. It normally works more like a C auto, but with
implicit garbage collection.</p>

<p style="margin-top: 1em">Unlike local variables in C or
C++, Perl&rsquo;s lexical variables don&rsquo;t necessarily
get recycled just because their scope has exited. If
something more permanent is still aware of <br>
the lexical, it will stick around. So long as something else
references a lexical, that lexical won&rsquo;t be
freed--which is as it should be. You wouldn&rsquo;t want
memory being free <br>
until you were done using it, or kept around once you were
done. Automatic garbage collection takes care of this for
you.</p>

<p style="margin-top: 1em">This means that you can pass
back or save away references to lexical variables, whereas
to return a pointer to a C auto is a grave error. It also
gives us a way to simulate C&rsquo;s <br>
function statics. Here&rsquo;s a mechanism for giving a
function private variables with both lexical scoping and a
static lifetime. If you do want to create something like
C&rsquo;s static <br>
variables, just enclose the whole function in an extra
block, and put the static variable outside the function but
in the block.</p>

<p style="margin-top: 1em">{ <br>
my $secret_val = 0; <br>
sub gimme_another { <br>
return ++$secret_val; <br>
} <br>
} <br>
# $secret_val now becomes unreachable by the outside <br>
# world, but retains its value between calls to
gimme_another</p>

<p style="margin-top: 1em">If this function is being
sourced in from a separate file via &quot;require&quot; or
&quot;use&quot;, then this is probably just fine. If
it&rsquo;s all in the main program, you&rsquo;ll need to
arrange for <br>
the &quot;my&quot; to be executed early, either by putting
the whole block above your main program, or more likely,
placing merely a &quot;BEGIN&quot; code block around it to
make sure it gets <br>
executed before your program starts to run:</p>

<p style="margin-top: 1em">BEGIN { <br>
my $secret_val = 0; <br>
sub gimme_another { <br>
return ++$secret_val; <br>
} <br>
}</p>

<p style="margin-top: 1em">See &quot;BEGIN, UNITCHECK,
CHECK, INIT and END&quot; in perlmod about the special
triggered code blocks, &quot;BEGIN&quot;,
&quot;UNITCHECK&quot;, &quot;CHECK&quot;, &quot;INIT&quot;
and &quot;END&quot;.</p>

<p style="margin-top: 1em">If declared at the outermost
scope (the file scope), then lexicals work somewhat like
C&rsquo;s file statics. They are available to all functions
in that same file declared below <br>
them, but are inaccessible from outside that file. This
strategy is sometimes used in modules to create private
variables that the whole module can see.</p>

<p style="margin-top: 1em">Temporary Values via local()
<br>
WARNING: In general, you should be using &quot;my&quot;
instead of &quot;local&quot;, because it&rsquo;s faster and
safer. Exceptions to this include the global punctuation
variables, global filehandles <br>
and formats, and direct manipulation of the Perl symbol
table itself. &quot;local&quot; is mostly used when the
current value of a variable must be visible to called
subroutines.</p>

<p style="margin-top: 1em">Synopsis:</p>

<p style="margin-top: 1em"># localization of values</p>

<p style="margin-top: 1em">local $foo; # make $foo
dynamically local <br>
local (@wid, %get); # make list of variables local <br>
local $foo = &quot;flurp&quot;; # make $foo dynamic, and
init it <br>
local @oof = @bar; # make @oof dynamic, and init it</p>

<p style="margin-top: 1em">local $hash{key} =
&quot;val&quot;; # sets a local value for this hash entry
<br>
delete local $hash{key}; # delete this entry for the current
block <br>
local ($cond ? $v1 : $v2); # several types of lvalues
support <br>
# localization</p>

<p style="margin-top: 1em"># localization of symbols</p>

<p style="margin-top: 1em">local *FH; # localize $FH, @FH,
%FH, &amp;FH ... <br>
local *merlyn = *randal; # now $merlyn is really $randal,
plus <br>
# @merlyn is really @randal, etc <br>
local *merlyn = &rsquo;randal&rsquo;; # SAME THING: promote
&rsquo;randal&rsquo; to *randal <br>
local *merlyn = andal; # just alias $merlyn, not @merlyn
etc</p>

<p style="margin-top: 1em">A &quot;local&quot; modifies its
listed variables to be &quot;local&quot; to the enclosing
block, &quot;eval&quot;, or &quot;do FILE&quot;--and to any
subroutine called from within that block. A
&quot;local&quot; just gives <br>
temporary values to global (meaning package) variables. It
does not create a local variable. This is known as dynamic
scoping. Lexical scoping is done with &quot;my&quot;, which
works <br>
more like C&rsquo;s auto declarations.</p>

<p style="margin-top: 1em">Some types of lvalues can be
localized as well: hash and array elements and slices,
conditionals (provided that their result is always
localizable), and symbolic references. As <br>
for simple variables, this creates new, dynamically scoped
values.</p>

<p style="margin-top: 1em">If more than one variable or
expression is given to &quot;local&quot;, they must be
placed in parentheses. This operator works by saving the
current values of those variables in its <br>
argument list on a hidden stack and restoring them upon
exiting the block, subroutine, or eval. This means that
called subroutines can also reference the local variable,
but not <br>
the global one. The argument list may be assigned to if
desired, which allows you to initialize your local
variables. (If no initializer is given for a particular
variable, it <br>
is created with an undefined value.)</p>

<p style="margin-top: 1em">Because &quot;local&quot; is a
run-time operator, it gets executed each time through a
loop. Consequently, it&rsquo;s more efficient to localize
your variables outside the loop.</p>

<p style="margin-top: 1em">Grammatical note on local()</p>

<p style="margin-top: 1em">A &quot;local&quot; is simply a
modifier on an lvalue expression. When you assign to a
&quot;local&quot;ized variable, the &quot;local&quot;
doesn&rsquo;t change whether its list is viewed as a scalar
or an array. <br>
So</p>

<p style="margin-top: 1em">local($foo) = &lt;STDIN&gt;;
<br>
local @FOO = &lt;STDIN&gt;;</p>

<p style="margin-top: 1em">both supply a list context to
the right-hand side, while</p>

<p style="margin-top: 1em">local $foo = &lt;STDIN&gt;;</p>

<p style="margin-top: 1em">supplies a scalar context.</p>

<p style="margin-top: 1em">Localization of special
variables</p>

<p style="margin-top: 1em">If you localize a special
variable, you&rsquo;ll be giving a new value to it, but its
magic won&rsquo;t go away. That means that all side-effects
related to this magic still work with the <br>
localized value.</p>

<p style="margin-top: 1em">This feature allows code like
this to work :</p>

<p style="margin-top: 1em"># Read the whole contents of
FILE in $slurp <br>
{ local $/ = undef; $slurp = &lt;FILE&gt;; }</p>

<p style="margin-top: 1em">Note, however, that this
restricts localization of some values ; for example, the
following statement dies, as of perl 5.9.0, with an error
Modification of a read-only value <br>
attempted, because the $1 variable is magical and read-only
:</p>

<p style="margin-top: 1em">local $1 = 2;</p>

<p style="margin-top: 1em">One exception is the default
scalar variable: starting with perl 5.14
&quot;local($_)&quot; will always strip all magic from $_,
to make it possible to safely reuse $_ in a subroutine.</p>

<p style="margin-top: 1em">WARNING: Localization of tied
arrays and hashes does not currently work as described. This
will be fixed in a future release of Perl; in the meantime,
avoid code that relies on <br>
any particular behaviour of localising tied arrays or hashes
(localising individual elements is still okay). See
&quot;Localising Tied Arrays and Hashes Is Broken&quot; in
perl58delta for <br>
more details.</p>

<p style="margin-top: 1em">Localization of globs</p>

<p style="margin-top: 1em">The construct</p>

<p style="margin-top: 1em">local *name;</p>

<p style="margin-top: 1em">creates a whole new symbol table
entry for the glob &quot;name&quot; in the current package.
That means that all variables in its glob slot ($name,
@name, %name, &amp;name, and the &quot;name&quot; <br>
filehandle) are dynamically reset.</p>

<p style="margin-top: 1em">This implies, among other
things, that any magic eventually carried by those variables
is locally lost. In other words, saying &quot;local */&quot;
will not have any effect on the <br>
internal value of the input record separator.</p>

<p style="margin-top: 1em">Localization of elements of
composite types</p>

<p style="margin-top: 1em">It&rsquo;s also worth taking a
moment to explain what happens when you &quot;local&quot;ize
a member of a composite type (i.e. an array or hash
element). In this case, the element is <br>
&quot;local&quot;ized by name. This means that when the
scope of the &quot;local()&quot; ends, the saved value will
be restored to the hash element whose key was named in the
&quot;local()&quot;, or the array <br>
element whose index was named in the &quot;local()&quot;. If
that element was deleted while the &quot;local()&quot; was
in effect (e.g. by a &quot;delete()&quot; from a hash or a
&quot;shift()&quot; of an array), it <br>
will spring back into existence, possibly extending an array
and filling in the skipped elements with &quot;undef&quot;.
For instance, if you say</p>

<p style="margin-top: 1em">%hash = ( &rsquo;This&rsquo;
=&gt; &rsquo;is&rsquo;, &rsquo;a&rsquo; =&gt;
&rsquo;test&rsquo; ); <br>
@ary = ( 0..5 ); <br>
{ <br>
local($ary[5]) = 6; <br>
local($hash{&rsquo;a&rsquo;}) = &rsquo;drill&rsquo;; <br>
while (my $e = pop(@ary)) { <br>
print &quot;$e . . .0; <br>
last unless $e &gt; 3; <br>
} <br>
if (@ary) { <br>
$hash{&rsquo;only a&rsquo;} = &rsquo;test&rsquo;; <br>
delete $hash{&rsquo;a&rsquo;}; <br>
} <br>
} <br>
print join(&rsquo; &rsquo;, map { &quot;$_ $hash{$_}&quot; }
sort keys %hash),&quot;.0; <br>
print &quot;The array has &quot;,scalar(@ary),&quot;
elements: &quot;, <br>
join(&rsquo;, &rsquo;, map { defined $_ ? $_ :
&rsquo;undef&rsquo; } @ary),&quot;0;</p>

<p style="margin-top: 1em">Perl will print</p>

<p style="margin-top: 1em">6 . . . <br>
4 . . . <br>
3 . . . <br>
This is a test only a test. <br>
The array has 6 elements: 0, 1, 2, undef, undef, 5</p>

<p style="margin-top: 1em">The behavior of local() on
non-existent members of composite types is subject to change
in future.</p>

<p style="margin-top: 1em">Localized deletion of elements
of composite types</p>

<p style="margin-top: 1em">You can use the &quot;delete
local $array[$idx]&quot; and &quot;delete local
$hash{key}&quot; constructs to delete a composite type entry
for the current block and restore it when it ends. They <br>
return the array/hash value before the localization, which
means that they are respectively equivalent to</p>

<p style="margin-top: 1em">do { <br>
my $val = $array[$idx]; <br>
local $array[$idx]; <br>
delete $array[$idx]; <br>
$val <br>
}</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">do { <br>
my $val = $hash{key}; <br>
local $hash{key}; <br>
delete $hash{key}; <br>
$val <br>
}</p>

<p style="margin-top: 1em">except that for those the
&quot;local&quot; is scoped to the &quot;do&quot; block.
Slices are also accepted.</p>

<p style="margin-top: 1em">my %hash = ( <br>
a =&gt; [ 7, 8, 9 ], <br>
b =&gt; 1, <br>
)</p>

<p style="margin-top: 1em">{ <br>
my $a = delete local $hash{a}; <br>
# $a is [ 7, 8, 9 ] <br>
# %hash is (b =&gt; 1)</p>

<p style="margin-top: 1em">{ <br>
my @nums = delete local @$a[0, 2] <br>
# @nums is (7, 9) <br>
# $a is [ undef, 8 ]</p>

<p style="margin-top: 1em">$a[0] = 999; # will be erased
when the scope ends <br>
} <br>
# $a is back to [ 7, 8, 9 ]</p>

<p style="margin-top: 1em">} <br>
# %hash is back to its original state</p>

<p style="margin-top: 1em">Lvalue subroutines <br>
WARNING: Lvalue subroutines are still experimental and the
implementation may change in future versions of Perl.</p>

<p style="margin-top: 1em">It is possible to return a
modifiable value from a subroutine. To do this, you have to
declare the subroutine to return an lvalue.</p>

<p style="margin-top: 1em">my $val; <br>
sub canmod : lvalue { <br>
$val; # or: return $val; <br>
} <br>
sub nomod { <br>
$val; <br>
}</p>

<p style="margin-top: 1em">canmod() = 5; # assigns to $val
<br>
nomod() = 5; # ERROR</p>

<p style="margin-top: 1em">The scalar/list context for the
subroutine and for the right-hand side of assignment is
determined as if the subroutine call is replaced by a
scalar. For example, consider:</p>

<p style="margin-top: 1em">data(2,3) = get_data(3,4);</p>

<p style="margin-top: 1em">Both subroutines here are called
in a scalar context, while in:</p>

<p style="margin-top: 1em">(data(2,3)) = get_data(3,4);</p>

<p style="margin-top: 1em">and in:</p>

<p style="margin-top: 1em">(data(2),data(3)) =
get_data(3,4);</p>

<p style="margin-top: 1em">all the subroutines are called
in a list context.</p>

<p style="margin-top: 1em">Lvalue subroutines are
EXPERIMENTAL <br>
They appear to be convenient, but there is at least one
reason to be circumspect.</p>

<p style="margin-top: 1em">They violate encapsulation. A
normal mutator can check the supplied argument before
setting the attribute it is protecting, an lvalue subroutine
never gets that chance. <br>
Consider;</p>

<p style="margin-top: 1em">my $some_array_ref = []; #
protected by mutators ??</p>

<p style="margin-top: 1em">sub set_arr { # normal mutator
<br>
my $val = shift; <br>
die(&quot;expected array, you supplied &quot;, ref $val)
<br>
unless ref $val eq &rsquo;ARRAY&rsquo;; <br>
$some_array_ref = $val; <br>
} <br>
sub set_arr_lv : lvalue { # lvalue mutator <br>
$some_array_ref; <br>
}</p>

<p style="margin-top: 1em"># set_arr_lv cannot stop this !
<br>
set_arr_lv() = { a =&gt; 1 };</p>

<p style="margin-top: 1em">Passing Symbol Table Entries
(typeglobs) <br>
WARNING: The mechanism described in this section was
originally the only way to simulate pass-by-reference in
older versions of Perl. While it still works fine in modern
<br>
versions, the new reference mechanism is generally easier to
work with. See below.</p>

<p style="margin-top: 1em">Sometimes you don&rsquo;t want
to pass the value of an array to a subroutine but rather the
name of it, so that the subroutine can modify the global
copy of it rather than working with <br>
a local copy. In perl you can refer to all objects of a
particular name by prefixing the name with a star: *foo.
This is often known as a &quot;typeglob&quot;, because the
star on the <br>
front can be thought of as a wildcard match for all the
funny prefix characters on variables and subroutines and
such.</p>

<p style="margin-top: 1em">When evaluated, the typeglob
produces a scalar value that represents all the objects of
that name, including any filehandle, format, or subroutine.
When assigned to, it causes <br>
the name mentioned to refer to whatever &quot;*&quot; value
was assigned to it. Example:</p>

<p style="margin-top: 1em">sub doubleary { <br>
local(*someary) = @_; <br>
foreach $elem (@someary) { <br>
$elem *= 2; <br>
} <br>
} <br>
doubleary(*foo); <br>
doubleary(*bar);</p>

<p style="margin-top: 1em">Scalars are already passed by
reference, so you can modify scalar arguments without using
this mechanism by referring explicitly to $_[0] etc. You can
modify all the elements of <br>
an array by passing all the elements as scalars, but you
have to use the &quot;*&quot; mechanism (or the equivalent
reference mechanism) to &quot;push&quot;, &quot;pop&quot;,
or change the size of an array. <br>
It will certainly be faster to pass the typeglob (or
reference).</p>

<p style="margin-top: 1em">Even if you don&rsquo;t want to
modify an array, this mechanism is useful for passing
multiple arrays in a single LIST, because normally the LIST
mechanism will merge all the array <br>
values so that you can&rsquo;t extract out the individual
arrays. For more on typeglobs, see &quot;Typeglobs and
Filehandles&quot; in perldata.</p>

<p style="margin-top: 1em">When to Still Use local() <br>
Despite the existence of &quot;my&quot;, there are still
three places where the &quot;local&quot; operator still
shines. In fact, in these three places, you must use
&quot;local&quot; instead of &quot;my&quot;.</p>

<p style="margin-top: 1em">1. You need to give a global
variable a temporary value, especially $_.</p>

<p style="margin-top: 1em">The global variables, like @ARGV
or the punctuation variables, must be &quot;local&quot;ized
with &quot;local()&quot;. This block reads in /etc/motd, and
splits it up into chunks separated by <br>
lines of equal signs, which are placed in @Fields.</p>

<p style="margin-top: 1em">{ <br>
local @ARGV = (&quot;/etc/motd&quot;); <br>
local $/ = undef; <br>
local $_ = &lt;&gt;; <br>
@Fields = split /^=+$/; <br>
}</p>

<p style="margin-top: 1em">It particular, it&rsquo;s
important to &quot;local&quot;ize $_ in any routine that
assigns to it. Look out for implicit assignments in
&quot;while&quot; conditionals.</p>

<p style="margin-top: 1em">2. You need to create a local
file or directory handle or a local function.</p>

<p style="margin-top: 1em">A function that needs a
filehandle of its own must use &quot;local()&quot; on a
complete typeglob. This can be used to create new symbol
table entries:</p>

<p style="margin-top: 1em">sub ioqueue { <br>
local (*READER, *WRITER); # not my! <br>
pipe (READER, WRITER) or die &quot;pipe: $!&quot;; <br>
return (*READER, *WRITER); <br>
} <br>
($head, $tail) = ioqueue();</p>

<p style="margin-top: 1em">See the Symbol module for a way
to create anonymous symbol table entries.</p>

<p style="margin-top: 1em">Because assignment of a
reference to a typeglob creates an alias, this can be used
to create what is effectively a local function, or at least,
a local alias.</p>

<p style="margin-top: 1em">{ <br>
local *grow = shrink; # only until this block exits <br>
grow(); # really calls shrink() <br>
move(); # if move() grow()s, it shrink()s too <br>
} <br>
grow(); # get the real grow() again</p>

<p style="margin-top: 1em">See &quot;Function
Templates&quot; in perlref for more about manipulating
functions by name in this way.</p>

<p style="margin-top: 1em">3. You want to temporarily
change just one element of an array or hash.</p>

<p style="margin-top: 1em">You can &quot;local&quot;ize
just one element of an aggregate. Usually this is done on
dynamics:</p>

<p style="margin-top: 1em">{ <br>
local $SIG{INT} = &rsquo;IGNORE&rsquo;; <br>
funct(); # uninterruptible <br>
} <br>
# interruptibility automatically restored here</p>

<p style="margin-top: 1em">But it also works on lexically
declared aggregates. Prior to 5.005, this operation could on
occasion misbehave.</p>

<p style="margin-top: 1em">Pass by Reference <br>
If you want to pass more than one array or hash into a
function--or return them from it--and have them maintain
their integrity, then you&rsquo;re going to have to use an
explicit <br>
pass-by-reference. Before you do that, you need to
understand references as detailed in perlref. This section
may not make much sense to you otherwise.</p>

<p style="margin-top: 1em">Here are a few simple examples.
First, let&rsquo;s pass in several arrays to a function and
have it &quot;pop&quot; all of then, returning a new list of
all their former last elements:</p>

<p style="margin-top: 1em">@tailings = popmany ( @a, @b,
@c, @d );</p>

<p style="margin-top: 1em">sub popmany { <br>
my $aref; <br>
my @retlist = (); <br>
foreach $aref ( @_ ) { <br>
push @retlist, pop @$aref; <br>
} <br>
return @retlist; <br>
}</p>

<p style="margin-top: 1em">Here&rsquo;s how you might write
a function that returns a list of keys occurring in all the
hashes passed to it:</p>

<p style="margin-top: 1em">@common = inter( foo, bar, joe
); <br>
sub inter { <br>
my ($k, $href, %seen); # locals <br>
foreach $href (@_) { <br>
while ( $k = each %$href ) { <br>
$seen{$k}++; <br>
} <br>
} <br>
return grep { $seen{$_} == @_ } keys %seen; <br>
}</p>

<p style="margin-top: 1em">So far, we&rsquo;re using just
the normal list return mechanism. What happens if you want
to pass or return a hash? Well, if you&rsquo;re using only
one of them, or you don&rsquo;t mind them <br>
concatenating, then the normal calling convention is ok,
although a little expensive.</p>

<p style="margin-top: 1em">Where people get into trouble is
here:</p>

<p style="margin-top: 1em">(@a, @b) = func(@c, @d); <br>
or <br>
(%a, %b) = func(%c, %d);</p>

<p style="margin-top: 1em">That syntax simply won&rsquo;t
work. It sets just @a or %a and clears the @b or %b. Plus
the function didn&rsquo;t get passed into two separate
arrays or hashes: it got one long list in <br>
@_, as always.</p>

<p style="margin-top: 1em">If you can arrange for everyone
to deal with this through references, it&rsquo;s cleaner
code, although not so nice to look at. Here&rsquo;s a
function that takes two array references as <br>
arguments, returning the two array elements in order of how
many elements they have in them:</p>

<p style="margin-top: 1em">($aref, $bref) = func(@c, @d);
<br>
print &quot;@$aref has more than @$bref0; <br>
sub func { <br>
my ($cref, $dref) = @_; <br>
if (@$cref &gt; @$dref) { <br>
return ($cref, $dref); <br>
} else { <br>
return ($dref, $cref); <br>
} <br>
}</p>

<p style="margin-top: 1em">It turns out that you can
actually do this also:</p>

<p style="margin-top: 1em">(*a, *b) = func(@c, @d); <br>
print &quot;@a has more than @b0; <br>
sub func { <br>
local (*c, *d) = @_; <br>
if (@c &gt; @d) { <br>
return (@c, @d); <br>
} else { <br>
return (@d, @c); <br>
} <br>
}</p>

<p style="margin-top: 1em">Here we&rsquo;re using the
typeglobs to do symbol table aliasing. It&rsquo;s a tad
subtle, though, and also won&rsquo;t work if you&rsquo;re
using &quot;my&quot; variables, because only globals (even
in disguise <br>
as &quot;local&quot;s) are in the symbol table.</p>

<p style="margin-top: 1em">If you&rsquo;re passing around
filehandles, you could usually just use the bare typeglob,
like *STDOUT, but typeglobs references work, too. For
example:</p>

<p style="margin-top: 1em">splutter(TDOUT); <br>
sub splutter { <br>
my $fh = shift; <br>
print $fh &quot;her um well a hmmm0; <br>
}</p>

<p style="margin-top: 1em">$rec = get_rec(TDIN); <br>
sub get_rec { <br>
my $fh = shift; <br>
return scalar &lt;$fh&gt;; <br>
}</p>

<p style="margin-top: 1em">If you&rsquo;re planning on
generating new filehandles, you could do this. Notice to
pass back just the bare *FH, not its reference.</p>

<p style="margin-top: 1em">sub openit { <br>
my $path = shift; <br>
local *FH; <br>
return open (FH, $path) ? *FH : undef; <br>
}</p>

<p style="margin-top: 1em">Prototypes <br>
Perl supports a very limited kind of compile-time argument
checking using function prototyping. If you declare</p>

<p style="margin-top: 1em">sub mypush (+@)</p>

<p style="margin-top: 1em">then &quot;mypush()&quot; takes
arguments exactly like &quot;push()&quot; does. The function
declaration must be visible at compile time. The prototype
affects only interpretation of new-style <br>
calls to the function, where new-style is defined as not
using the &quot;&amp;&quot; character. In other words, if
you call it like a built-in function, then it behaves like a
built-in <br>
function. If you call it like an old-fashioned subroutine,
then it behaves like an old-fashioned subroutine. It
naturally falls out from this rule that prototypes have no
<br>
influence on subroutine references like &quot;foo&quot; or
on indirect subroutine calls like &quot;&amp;{$subref}&quot;
or &quot;$subref-&gt;()&quot;.</p>

<p style="margin-top: 1em">Method calls are not influenced
by prototypes either, because the function to be called is
indeterminate at compile time, since the exact code called
depends on inheritance.</p>

<p style="margin-top: 1em">Because the intent of this
feature is primarily to let you define subroutines that work
like built-in functions, here are prototypes for some other
functions that parse almost <br>
exactly like the corresponding built-in.</p>

<p style="margin-top: 1em">Declared as Called as</p>

<p style="margin-top: 1em">sub mylink ($$) mylink $old,
$new <br>
sub myvec ($$$) myvec $var, $offset, 1 <br>
sub myindex ($$;$) myindex &amp;getstring,
&quot;substr&quot; <br>
sub mysyswrite ($$$;$) mysyswrite $buf, 0, length($buf) -
$off, $off <br>
sub myreverse (@) myreverse $a, $b, $c <br>
sub myjoin ($@) myjoin &quot;:&quot;, $a, $b, $c <br>
sub mypop (+) mypop @array <br>
sub mysplice (+$$@) mysplice @array, 0, 2, @pushme <br>
sub mykeys (+) mykeys %{$hashref} <br>
sub myopen (*;$) myopen HANDLE, $name <br>
sub mypipe (**) mypipe READHANDLE, WRITEHANDLE <br>
sub mygrep (&amp;@) mygrep { /foo/ } $a, $b, $c <br>
sub myrand (;$) myrand 42 <br>
sub mytime () mytime</p>

<p style="margin-top: 1em">Any backslashed prototype
character represents an actual argument that must start with
that character (optionally preceded by &quot;my&quot;,
&quot;our&quot; or &quot;local&quot;), with the exception of
&quot;$&quot;, <br>
which will accept any scalar lvalue expression, such as
&quot;$foo = 7&quot; or &quot;my_function()-&gt;[0]&quot;.
The value passed as part of @_ will be a reference to the
actual argument given in the <br>
subroutine call, obtained by applying &quot;</p>

<p style="margin-top: 1em">You can use the &quot;&quot;
backslash group notation to specify more than one allowed
argument type. For example:</p>

<p style="margin-top: 1em">sub myref ()</p>

<p style="margin-top: 1em">will allow calling myref()
as</p>

<p style="margin-top: 1em">myref $var <br>
myref @array <br>
myref %hash <br>
myref &amp;sub <br>
myref *glob</p>

<p style="margin-top: 1em">and the first argument of
myref() will be a reference to a scalar, an array, a hash, a
code, or a glob.</p>

<p style="margin-top: 1em">Unbackslashed prototype
characters have special meanings. Any unbackslashed
&quot;@&quot; or &quot;%&quot; eats all remaining arguments,
and forces list context. An argument represented by
&quot;$&quot; <br>
forces scalar context. An &quot;&amp;&quot; requires an
anonymous subroutine, which, if passed as the first
argument, does not require the &quot;sub&quot; keyword or a
subsequent comma.</p>

<p style="margin-top: 1em">A &quot;*&quot; allows the
subroutine to accept a bareword, constant, scalar
expression, typeglob, or a reference to a typeglob in that
slot. The value will be available to the subroutine <br>
either as a simple scalar, or (in the latter two cases) as a
reference to the typeglob. If you wish to always convert
such arguments to a typeglob reference, use <br>
Symbol::qualify_to_ref() as follows:</p>

<p style="margin-top: 1em">use Symbol
&rsquo;qualify_to_ref&rsquo;;</p>

<p style="margin-top: 1em">sub foo (*) { <br>
my $fh = qualify_to_ref(shift, caller); <br>
... <br>
}</p>

<p style="margin-top: 1em">The &quot;+&quot; prototype is a
special alternative to &quot;$&quot; that will act like
&quot;&quot; when given a literal array or hash variable,
but will otherwise force scalar context on the argument.
<br>
This is useful for functions which should accept either a
literal array or an array reference as the argument:</p>

<p style="margin-top: 1em">sub mypush (+@) { <br>
my $aref = shift; <br>
die &quot;Not an array or arrayref&quot; unless ref $aref eq
&rsquo;ARRAY&rsquo;; <br>
push @$aref, @_; <br>
}</p>

<p style="margin-top: 1em">When using the &quot;+&quot;
prototype, your function must check that the argument is of
an acceptable type.</p>

<p style="margin-top: 1em">A semicolon (&quot;;&quot;)
separates mandatory arguments from optional arguments. It is
redundant before &quot;@&quot; or &quot;%&quot;, which
gobble up everything else.</p>

<p style="margin-top: 1em">As the last character of a
prototype, or just before a semicolon, a &quot;@&quot; or a
&quot;%&quot;, you can use &quot;_&quot; in place of
&quot;$&quot;: if this argument is not provided, $_ will be
used instead.</p>

<p style="margin-top: 1em">Note how the last three examples
in the table above are treated specially by the parser.
&quot;mygrep()&quot; is parsed as a true list operator,
&quot;myrand()&quot; is parsed as a true unary <br>
operator with unary precedence the same as
&quot;rand()&quot;, and &quot;mytime()&quot; is truly
without arguments, just like &quot;time()&quot;. That is, if
you say</p>

<p style="margin-top: 1em">mytime +2;</p>

<p style="margin-top: 1em">you&rsquo;ll get &quot;mytime()
+ 2&quot;, not mytime(2), which is how it would be parsed
without a prototype. If you want to force a unary function
to have the same precedence as a list <br>
operator, add &quot;;&quot; to the end of the prototype:</p>

<p style="margin-top: 1em">sub mygetprotobynumber($;); <br>
mygetprotobynumber $a &gt; $b; # parsed as
mygetprotobynumber($a &gt; $b)</p>

<p style="margin-top: 1em">The interesting thing about
&quot;&amp;&quot; is that you can generate new syntax with
it, provided it&rsquo;s in the initial position:</p>

<p style="margin-top: 1em">sub try (&amp;@) { <br>
my($try,$catch) = @_; <br>
eval { &amp;$try }; <br>
if ($@) { <br>
local $_ = $@; <br>
&amp;$catch; <br>
} <br>
} <br>
sub catch (&amp;) { $_[0] }</p>

<p style="margin-top: 1em">try { <br>
die &quot;phooey&quot;; <br>
} catch { <br>
/phooey/ and print &quot;unphooey0; <br>
};</p>

<p style="margin-top: 1em">That prints
&quot;unphooey&quot;. (Yes, there are still unresolved
issues having to do with visibility of @_. I&rsquo;m
ignoring that question for the moment. (But note that if we
make @_ <br>
lexically scoped, those anonymous subroutines can act like
closures... (Gee, is this sounding a little Lispish? (Never
mind.))))</p>

<p style="margin-top: 1em">And here&rsquo;s a
reimplementation of the Perl &quot;grep&quot; operator:</p>

<p style="margin-top: 1em">sub mygrep (&amp;@) { <br>
my $code = shift; <br>
my @result; <br>
foreach $_ (@_) { <br>
push(@result, $_) if &amp;$code; <br>
} <br>
@result; <br>
}</p>

<p style="margin-top: 1em">Some folks would prefer full
alphanumeric prototypes. Alphanumerics have been
intentionally left out of prototypes for the express purpose
of someday in the future adding named, <br>
formal parameters. The current mechanism&rsquo;s main goal
is to let module writers provide better diagnostics for
module users. Larry feels the notation quite understandable
to Perl <br>
programmers, and that it will not intrude greatly upon the
meat of the module, nor make it harder to read. The line
noise is visually encapsulated into a small pill
that&rsquo;s easy <br>
to swallow.</p>

<p style="margin-top: 1em">If you try to use an
alphanumeric sequence in a prototype you will generate an
optional warning - &quot;Illegal character in
prototype...&quot;. Unfortunately earlier versions of Perl
<br>
allowed the prototype to be used as long as its prefix was a
valid prototype. The warning may be upgraded to a fatal
error in a future version of Perl once the majority of <br>
offending code is fixed.</p>

<p style="margin-top: 1em">It&rsquo;s probably best to
prototype new functions, not retrofit prototyping into older
ones. That&rsquo;s because you must be especially careful
about silent impositions of differing list <br>
versus scalar contexts. For example, if you decide that a
function should take just one parameter, like this:</p>

<p style="margin-top: 1em">sub func ($) { <br>
my $n = shift; <br>
print &quot;you gave me $n0; <br>
}</p>

<p style="margin-top: 1em">and someone has been calling it
with an array or expression returning a list:</p>

<p style="margin-top: 1em">func(@foo); <br>
func( split /:/ );</p>

<p style="margin-top: 1em">Then you&rsquo;ve just supplied
an automatic &quot;scalar&quot; in front of their argument,
which can be more than a bit surprising. The old @foo which
used to hold one thing doesn&rsquo;t get passed <br>
in. Instead, &quot;func()&quot; now gets passed in a 1; that
is, the number of elements in @foo. And the
&quot;split&quot; gets called in scalar context so it starts
scribbling on your @_ <br>
parameter list. Ouch!</p>

<p style="margin-top: 1em">This is all very powerful, of
course, and should be used only in moderation to make the
world a better place.</p>

<p style="margin-top: 1em">Constant Functions <br>
Functions with a prototype of &quot;()&quot; are potential
candidates for inlining. If the result after optimization
and constant folding is either a constant or a
lexically-scoped scalar <br>
which has no other references, then it will be used in place
of function calls made without &quot;&amp;&quot;. Calls made
using &quot;&amp;&quot; are never inlined. (See constant.pm
for an easy way to <br>
declare most constants.)</p>

<p style="margin-top: 1em">The following functions would
all be inlined:</p>

<p style="margin-top: 1em">sub pi () { 3.14159 } # Not
exact, but close. <br>
sub PI () { 4 * atan2 1, 1 } # As good as it gets, <br>
# and it&rsquo;s inlined, too! <br>
sub ST_DEV () { 0 } <br>
sub ST_INO () { 1 }</p>

<p style="margin-top: 1em">sub FLAG_FOO () { 1 &lt;&lt; 8 }
<br>
sub FLAG_BAR () { 1 &lt;&lt; 9 } <br>
sub FLAG_MASK () { FLAG_FOO | FLAG_BAR }</p>

<p style="margin-top: 1em">sub OPT_BAZ () { not (0x1B58
&amp; FLAG_MASK) }</p>

<p style="margin-top: 1em">sub N () { int(OPT_BAZ) / 3
}</p>

<p style="margin-top: 1em">sub FOO_SET () { 1 if FLAG_MASK
&amp; FLAG_FOO }</p>

<p style="margin-top: 1em">Be aware that these will not be
inlined; as they contain inner scopes, the constant folding
doesn&rsquo;t reduce them to a single constant:</p>

<p style="margin-top: 1em">sub foo_set () { if (FLAG_MASK
&amp; FLAG_FOO) { 1 } }</p>

<p style="margin-top: 1em">sub baz_val () { <br>
if (OPT_BAZ) { <br>
return 23; <br>
} <br>
else { <br>
return 42; <br>
} <br>
}</p>

<p style="margin-top: 1em">If you redefine a subroutine
that was eligible for inlining, you&rsquo;ll get a warning
by default. (You can use this warning to tell whether or not
a particular subroutine is <br>
considered constant.) The warning is considered severe
enough not to be affected by the -w switch (or its absence)
because previously compiled invocations of the function will
<br>
still be using the old value of the function. If you need to
be able to redefine the subroutine, you need to ensure that
it isn&rsquo;t inlined, either by dropping the
&quot;()&quot; prototype <br>
(which changes calling semantics, so beware) or by thwarting
the inlining mechanism in some other way, such as</p>

<p style="margin-top: 1em">sub not_inlined () { <br>
23 if $]; <br>
}</p>

<p style="margin-top: 1em">Overriding Built-in Functions
<br>
Many built-in functions may be overridden, though this
should be tried only occasionally and for good reason.
Typically this might be done by a package attempting to
emulate <br>
missing built-in functionality on a non-Unix system.</p>

<p style="margin-top: 1em">Overriding may be done only by
importing the name from a module at compile time--ordinary
predeclaration isn&rsquo;t good enough. However, the
&quot;use subs&quot; pragma lets you, in effect, <br>
predeclare subs via the import syntax, and these names may
then override built-in ones:</p>

<p style="margin-top: 1em">use subs &rsquo;chdir&rsquo;,
&rsquo;chroot&rsquo;, &rsquo;chmod&rsquo;,
&rsquo;chown&rsquo;; <br>
chdir $somewhere; <br>
sub chdir { ... }</p>

<p style="margin-top: 1em">To unambiguously refer to the
built-in form, precede the built-in name with the special
package qualifier &quot;CORE::&quot;. For example, saying
&quot;CORE::open()&quot; always refers to the <br>
built-in &quot;open()&quot;, even if the current package has
imported some other subroutine called
&quot;&amp;open()&quot; from elsewhere. Even though it looks
like a regular function call, it isn&rsquo;t: <br>
the CORE:: prefix in that case is part of Perl&rsquo;s
syntax, and works for any keyword, regardless of what is in
the CORE package. Taking a reference to it, that is,
&quot;CORE::open&quot;, <br>
only works for some keywords. See CORE.</p>

<p style="margin-top: 1em">Library modules should not in
general export built-in names like &quot;open&quot; or
&quot;chdir&quot; as part of their default @EXPORT list,
because these may sneak into someone else&rsquo;s namespace
<br>
and change the semantics unexpectedly. Instead, if the
module adds that name to @EXPORT_OK, then it&rsquo;s
possible for a user to import the name explicitly, but not
implicitly. <br>
That is, they could say</p>

<p style="margin-top: 1em">use Module
&rsquo;open&rsquo;;</p>

<p style="margin-top: 1em">and it would import the
&quot;open&quot; override. But if they said</p>

<p style="margin-top: 1em">use Module;</p>

<p style="margin-top: 1em">they would get the default
imports without overrides.</p>

<p style="margin-top: 1em">The foregoing mechanism for
overriding built-in is restricted, quite deliberately, to
the package that requests the import. There is a second
method that is sometimes applicable <br>
when you wish to override a built-in everywhere, without
regard to namespace boundaries. This is achieved by
importing a sub into the special namespace
&quot;CORE::GLOBAL::&quot;. Here <br>
is an example that quite brazenly replaces the
&quot;glob&quot; operator with something that understands
regular expressions.</p>

<p style="margin-top: 1em">package REGlob; <br>
require Exporter; <br>
@ISA = &rsquo;Exporter&rsquo;; <br>
@EXPORT_OK = &rsquo;glob&rsquo;;</p>

<p style="margin-top: 1em">sub import { <br>
my $pkg = shift; <br>
return unless @_; <br>
my $sym = shift; <br>
my $where = ($sym =~ s/^GLOBAL_// ?
&rsquo;CORE::GLOBAL&rsquo; : caller(0)); <br>
$pkg-&gt;export($where, $sym, @_); <br>
}</p>

<p style="margin-top: 1em">sub glob { <br>
my $pat = shift; <br>
my @got; <br>
if (opendir my $d, &rsquo;.&rsquo;) { <br>
@got = grep /$pat/, readdir $d; <br>
closedir $d; <br>
} <br>
return @got; <br>
} <br>
1;</p>

<p style="margin-top: 1em">And here&rsquo;s how it could be
(ab)used:</p>

<p style="margin-top: 1em">#use REGlob
&rsquo;GLOBAL_glob&rsquo;; # override glob() in ALL
namespaces <br>
package Foo; <br>
use REGlob &rsquo;glob&rsquo;; # override glob() in Foo::
only <br>
print for &lt;^[a-z_]+.pm; # show all pragmatic modules</p>

<p style="margin-top: 1em">The initial comment shows a
contrived, even dangerous example. By overriding
&quot;glob&quot; globally, you would be forcing the new (and
subversive) behavior for the &quot;glob&quot; operator for
<br>
every namespace, without the complete cognizance or
cooperation of the modules that own those namespaces.
Naturally, this should be done with extreme caution--if it
must be done <br>
at all.</p>

<p style="margin-top: 1em">The &quot;REGlob&quot; example
above does not implement all the support needed to cleanly
override perl&rsquo;s &quot;glob&quot; operator. The
built-in &quot;glob&quot; has different behaviors depending
on whether <br>
it appears in a scalar or list context, but our
&quot;REGlob&quot; doesn&rsquo;t. Indeed, many perl built-in
have such context sensitive behaviors, and these must be
adequately supported by a <br>
properly written override. For a fully functional example of
overriding &quot;glob&quot;, study the implementation of
&quot;File::DosGlob&quot; in the standard library.</p>

<p style="margin-top: 1em">When you override a built-in,
your replacement should be consistent (if possible) with the
built-in native syntax. You can achieve this by using a
suitable prototype. To get <br>
the prototype of an overridable built-in, use the
&quot;prototype&quot; function with an argument of
&quot;CORE::builtin_name&quot; (see &quot;prototype&quot; in
perlfunc).</p>

<p style="margin-top: 1em">Note however that some built-ins
can&rsquo;t have their syntax expressed by a prototype (such
as &quot;system&quot; or &quot;chomp&quot;). If you override
them you won&rsquo;t be able to fully mimic their <br>
original syntax.</p>

<p style="margin-top: 1em">The built-ins &quot;do&quot;,
&quot;require&quot; and &quot;glob&quot; can also be
overridden, but due to special magic, their original syntax
is preserved, and you don&rsquo;t have to define a prototype
for their <br>
replacements. (You can&rsquo;t override the &quot;do
BLOCK&quot; syntax, though).</p>

<p style="margin-top: 1em">&quot;require&quot; has special
additional dark magic: if you invoke your
&quot;require&quot; replacement as &quot;require
Foo::Bar&quot;, it will actually receive the argument
&quot;Foo/Bar.pm&quot; in @_. See <br>
&quot;require&quot; in perlfunc.</p>

<p style="margin-top: 1em">And, as you&rsquo;ll have
noticed from the previous example, if you override
&quot;glob&quot;, the &quot;&lt;*&gt;&quot; glob operator is
overridden as well.</p>

<p style="margin-top: 1em">In a similar fashion, overriding
the &quot;readline&quot; function also overrides the
equivalent I/O operator &quot;&lt;FILEHANDLE&gt;&quot;.
Also, overriding &quot;readpipe&quot; also overrides the
operators &quot;&lsquo;&lsquo;&quot; <br>
and &quot;qx//&quot;.</p>

<p style="margin-top: 1em">Finally, some built-ins (e.g.
&quot;exists&quot; or &quot;grep&quot;) can&rsquo;t be
overridden.</p>

<p style="margin-top: 1em">Autoloading <br>
If you call a subroutine that is undefined, you would
ordinarily get an immediate, fatal error complaining that
the subroutine doesn&rsquo;t exist. (Likewise for
subroutines being <br>
used as methods, when the method doesn&rsquo;t exist in any
base class of the class&rsquo;s package.) However, if an
&quot;AUTOLOAD&quot; subroutine is defined in the package or
packages used to <br>
locate the original subroutine, then that
&quot;AUTOLOAD&quot; subroutine is called with the arguments
that would have been passed to the original subroutine. The
fully qualified name of <br>
the original subroutine magically appears in the global
$AUTOLOAD variable of the same package as the
&quot;AUTOLOAD&quot; routine. The name is not passed as an
ordinary argument because, <br>
er, well, just because, that&rsquo;s why. (As an exception,
a method call to a nonexistent &quot;import&quot; or
&quot;unimport&quot; method is just skipped instead. Also,
if the AUTOLOAD subroutine is <br>
an XSUB, there are other ways to retrieve the subroutine
name. See &quot;Autoloading with XSUBs&quot; in perlguts for
details.)</p>

<p style="margin-top: 1em">Many &quot;AUTOLOAD&quot;
routines load in a definition for the requested subroutine
using eval(), then execute that subroutine using a special
form of goto() that erases the stack frame <br>
of the &quot;AUTOLOAD&quot; routine without a trace. (See
the source to the standard module documented in AutoLoader,
for example.) But an &quot;AUTOLOAD&quot; routine can also
just emulate the <br>
routine and never define it. For example, let&rsquo;s
pretend that a function that wasn&rsquo;t defined should
just invoke &quot;system&quot; with those arguments. All
you&rsquo;d do is:</p>

<p style="margin-top: 1em">sub AUTOLOAD { <br>
my $program = $AUTOLOAD; <br>
$program =~ s/.*:://; <br>
system($program, @_); <br>
} <br>
date(); <br>
who(&rsquo;am&rsquo;, &rsquo;i&rsquo;); <br>
ls(&rsquo;-l&rsquo;);</p>

<p style="margin-top: 1em">In fact, if you predeclare
functions you want to call that way, you don&rsquo;t even
need parentheses:</p>

<p style="margin-top: 1em">use subs qw(date who ls); <br>
date; <br>
who &quot;am&quot;, &quot;i&quot;; <br>
ls &rsquo;-l&rsquo;;</p>

<p style="margin-top: 1em">A more complete example of this
is the Shell module on CPAN, which can treat undefined
subroutine calls as calls to external programs.</p>

<p style="margin-top: 1em">Mechanisms are available to help
modules writers split their modules into autoloadable files.
See the standard AutoLoader module described in AutoLoader
and in AutoSplit, the <br>
standard SelfLoader modules in SelfLoader, and the document
on adding C functions to Perl code in perlxs.</p>

<p style="margin-top: 1em">Subroutine Attributes <br>
A subroutine declaration or definition may have a list of
attributes associated with it. If such an attribute list is
present, it is broken up at space or colon boundaries and
<br>
treated as though a &quot;use attributes&quot; had been
seen. See attributes for details about what attributes are
currently supported. Unlike the limitation with the
obsolescent &quot;use <br>
attrs&quot;, the &quot;sub : ATTRLIST&quot; syntax works to
associate the attributes with a pre-declaration, and not
just with a subroutine definition.</p>

<p style="margin-top: 1em">The attributes must be valid as
simple identifier names (without any punctuation other than
the &rsquo;_&rsquo; character). They may have a parameter
list appended, which is only checked <br>
for whether its parentheses
(&rsquo;(&rsquo;,&rsquo;)&rsquo;) nest properly.</p>

<p style="margin-top: 1em">Examples of valid syntax (even
though the attributes are unknown):</p>

<p style="margin-top: 1em">sub fnord (&amp;) :
switch(10,foo(7,3)) : expensive; <br>
sub plugh () : Ugly(&rsquo; :Bad; <br>
sub xyzzy : _5x5 { ... }</p>

<p style="margin-top: 1em">Examples of invalid syntax:</p>

<p style="margin-top: 1em">sub fnord : switch(10,foo(); #
()-string not balanced <br>
sub snoid : Ugly(&rsquo;(&rsquo;); # ()-string not balanced
<br>
sub xyzzy : 5x5; # &quot;5x5&quot; not a valid identifier
<br>
sub plugh : Y2::north; # &quot;Y2::north&quot; not a simple
identifier <br>
sub snurt : foo + bar; # &quot;+&quot; not a colon or
space</p>

<p style="margin-top: 1em">The attribute list is passed as
a list of constant strings to the code which associates them
with the subroutine. In particular, the second example of
valid syntax above <br>
currently looks like this in terms of how it&rsquo;s parsed
and invoked:</p>

<p style="margin-top: 1em">use attributes __PACKAGE__,
plugh, q[Ugly(&rsquo;], &rsquo;Bad&rsquo;;</p>

<p style="margin-top: 1em">For further details on attribute
lists and their manipulation, see attributes and
Attribute::Handlers.</p>

<p style="margin-top: 1em">SEE ALSO <br>
See &quot;Function Templates&quot; in perlref for more about
references and closures. See perlxs if you&rsquo;d like to
learn about calling C subroutines from Perl. See perlembed
if you&rsquo;d like <br>
to learn about calling Perl subroutines from C. See perlmod
to learn about bundling up your functions in separate files.
See perlmodlib to learn what library modules come <br>
standard on your system. See perlootut to learn how to make
object method calls.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLSUB(1)</p>
<hr>
</body>
</html>
