<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLSUB(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLSUB(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLSUB(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlsub - Perl subroutines
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
To declare subroutines:
<div class="Pp"></div>
<pre>
    sub NAME;                     # A &quot;forward&quot; declaration.
    sub NAME(PROTO);              #  ditto, but with prototypes
    sub NAME : ATTRS;             #  with attributes
    sub NAME(PROTO) : ATTRS;      #  with attributes and prototypes
    sub NAME BLOCK                # A declaration and a definition.
    sub NAME(PROTO) BLOCK         #  ditto, but with prototypes
    sub NAME : ATTRS BLOCK        #  with attributes
    sub NAME(PROTO) : ATTRS BLOCK #  with prototypes and attributes
</pre>
<div class="Pp"></div>
To define an anonymous subroutine at runtime:
<div class="Pp"></div>
<pre>
    $subref = sub BLOCK;                 # no proto
    $subref = sub (PROTO) BLOCK;         # with proto
    $subref = sub : ATTRS BLOCK;         # with attributes
    $subref = sub (PROTO) : ATTRS BLOCK; # with proto and attributes
</pre>
<div class="Pp"></div>
To import subroutines:
<div class="Pp"></div>
<pre>
    use MODULE qw(NAME1 NAME2 NAME3);
</pre>
<div class="Pp"></div>
To call subroutines:
<div class="Pp"></div>
<pre>
    NAME(LIST);    # &amp; is optional with parentheses.
    NAME LIST;     # Parentheses optional if predeclared/imported.
    &amp;NAME(LIST);   # Circumvent prototypes.
    &amp;NAME;         # Makes current @_ visible to called subroutine.
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Like many languages, Perl provides for user-defined subroutines. These may be
  located anywhere in the main program, loaded in from other files via the
  &quot;do&quot;, &quot;require&quot;, or &quot;use&quot; keywords, or generated
  on the fly using &quot;eval&quot; or anonymous subroutines. You can even call
  a function indirectly using a variable containing its name or a CODE
  reference.
<div class="Pp"></div>
The Perl model for function call and return values is simple: all functions are
  passed as parameters one single flat list of scalars, and all functions
  likewise return to their caller one single flat list of scalars. Any arrays or
  hashes in these call and return lists will collapse, losing their
  identities--but you may always use pass-by-reference instead to avoid this.
  Both call and return lists may contain as many or as few scalar elements as
  you'd like. (Often a function without an explicit return statement is called a
  subroutine, but there's really no difference from Perl's perspective.)
<div class="Pp"></div>
Any arguments passed in show up in the array @_. Therefore, if you called a
  function with two arguments, those would be stored in $_[0] and $_[1]. The
  array @_ is a local array, but its elements are aliases for the actual scalar
  parameters. In particular, if an element $_[0] is updated, the corresponding
  argument is updated (or an error occurs if it is not updatable). If an
  argument is an array or hash element which did not exist when the function was
  called, that element is created only when (and if) it is modified or a
  reference to it is taken. (Some earlier versions of Perl created the element
  whether or not the element was assigned to.) Assigning to the whole array @_
  removes that aliasing, and does not update any arguments.
<div class="Pp"></div>
A &quot;return&quot; statement may be used to exit a subroutine, optionally
  specifying the returned value, which will be evaluated in the appropriate
  context (list, scalar, or void) depending on the context of the subroutine
  call. If you specify no return value, the subroutine returns an empty list in
  list context, the undefined value in scalar context, or nothing in void
  context. If you return one or more aggregates (arrays and hashes), these will
  be flattened together into one large indistinguishable list.
<div class="Pp"></div>
If no &quot;return&quot; is found and if the last statement is an expression,
  its value is returned. If the last statement is a loop control structure like
  a &quot;foreach&quot; or a &quot;while&quot;, the returned value is
  unspecified. The empty sub returns the empty list.
<div class="Pp"></div>
Perl does not have named formal parameters. In practice all you do is assign to
  a &quot;my()&quot; list of these. Variables that aren't declared to be private
  are global variables. For gory details on creating private variables, see
  &quot;Private Variables via <i>my()</i>&quot; and &quot;Temporary Values via
  <i>local()</i>&quot;. To create protected environments for a set of functions
  in a separate package (and probably a separate file), see &quot;Packages&quot;
  in perlmod.
<div class="Pp"></div>
Example:
<div class="Pp"></div>
<pre>
    sub max {
        my $max = shift(@_);
        foreach $foo (@_) {
            $max = $foo if $max &lt; $foo;
        }
        return $max;
    }
    $bestday = max($mon,$tue,$wed,$thu,$fri);
</pre>
<div class="Pp"></div>
Example:
<div class="Pp"></div>
<pre>
    # get a line, combining continuation lines
    #  that start with whitespace
    sub get_line {
        $thisline = $lookahead;  # global variables!
        LINE: while (defined($lookahead = &lt;STDIN&gt;)) {
            if ($lookahead =~ /^[ \t]/) {
                $thisline .= $lookahead;
            }
            else {
                last LINE;
            }
        }
        return $thisline;
    }
    $lookahead = &lt;STDIN&gt;;       # get first line
    while (defined($line = get_line())) {
        ...
    }
</pre>
<div class="Pp"></div>
Assigning to a list of private variables to name your arguments:
<div class="Pp"></div>
<pre>
    sub maybeset {
        my($key, $value) = @_;
        $Foo{$key} = $value unless $Foo{$key};
    }
</pre>
<div class="Pp"></div>
Because the assignment copies the values, this also has the effect of turning
  call-by-reference into call-by-value. Otherwise a function is free to do
  in-place modifications of @_ and change its caller's values.
<div class="Pp"></div>
<pre>
    upcase_in($v1, $v2);  # this changes $v1 and $v2
    sub upcase_in {
        for (@_) { tr/a-z/A-Z/ }
    }
</pre>
<div class="Pp"></div>
You aren't allowed to modify constants in this way, of course. If an argument
  were actually literal and you tried to change it, you'd take a (presumably
  fatal) exception. For example, this won't work:
<div class="Pp"></div>
<pre>
    upcase_in(&quot;frederick&quot;);
</pre>
<div class="Pp"></div>
It would be much safer if the &quot;upcase_in()&quot; function were written to
  return a copy of its parameters instead of changing them in place:
<div class="Pp"></div>
<pre>
    ($v3, $v4) = upcase($v1, $v2);  # this doesn't change $v1 and $v2
    sub upcase {
        return unless defined wantarray;  # void context, do nothing
        my @parms = @_;
        for (@parms) { tr/a-z/A-Z/ }
        return wantarray ? @parms : $parms[0];
    }
</pre>
<div class="Pp"></div>
Notice how this (unprototyped) function doesn't care whether it was passed real
  scalars or arrays. Perl sees all arguments as one big, long, flat parameter
  list in @_. This is one area where Perl's simple argument-passing style
  shines. The &quot;upcase()&quot; function would work perfectly well without
  changing the &quot;upcase()&quot; definition even if we fed it things like
  this:
<div class="Pp"></div>
<pre>
    @newlist   = upcase(@list1, @list2);
    @newlist   = upcase( split /:/, $var );
</pre>
<div class="Pp"></div>
Do not, however, be tempted to do this:
<div class="Pp"></div>
<pre>
    (@a, @b)   = upcase(@list1, @list2);
</pre>
<div class="Pp"></div>
Like the flattened incoming parameter list, the return list is also flattened on
  return. So all you have managed to do here is stored everything in @a and made
  @b empty. See &quot;Pass by Reference&quot; for alternatives.
<div class="Pp"></div>
A subroutine may be called using an explicit &quot;&amp;&quot; prefix. The
  &quot;&amp;&quot; is optional in modern Perl, as are parentheses if the
  subroutine has been predeclared. The &quot;&amp;&quot; is <i>not</i> optional
  when just naming the subroutine, such as when it's used as an argument to
  <i>defined()</i> or <i>undef()</i>. Nor is it optional when you want to do an
  indirect subroutine call with a subroutine name or reference using the
  &quot;&amp;$subref()&quot; or &quot;&amp;{$subref}()&quot; constructs,
  although the &quot;$subref-&gt;()&quot; notation solves that problem. See
  perlref for more about all that.
<div class="Pp"></div>
Subroutines may be called recursively. If a subroutine is called using the
  &quot;&amp;&quot; form, the argument list is optional, and if omitted, no @_
  array is set up for the subroutine: the @_ array at the time of the call is
  visible to subroutine instead. This is an efficiency mechanism that new users
  may wish to avoid.
<div class="Pp"></div>
<pre>
    &amp;foo(1,2,3);        # pass three arguments
    foo(1,2,3);         # the same
    foo();              # pass a null list
    &amp;foo();             # the same
    &amp;foo;               # foo() get current args, like foo(@_) !!
    foo;                # like foo() IFF sub foo predeclared, else &quot;foo&quot;
</pre>
<div class="Pp"></div>
Not only does the &quot;&amp;&quot; form make the argument list optional, it
  also disables any prototype checking on arguments you do provide. This is
  partly for historical reasons, and partly for having a convenient way to cheat
  if you know what you're doing. See &quot;Prototypes&quot; below.
<div class="Pp"></div>
Since Perl 5.16.0, the &quot;__SUB__&quot; token is available under &quot;use
  feature 'current_sub'&quot; and &quot;use 5.16.0&quot;. It will evaluate to a
  reference to the currently-running sub, which allows for recursive calls
  without knowing your subroutine's name.
<div class="Pp"></div>
<pre>
    use 5.16.0;
    my $factorial = sub {
      my ($x) = @_;
      return 1 if $x == 1;
      return($x * __SUB__-&gt;( $x - 1 ) );
    };
</pre>
<div class="Pp"></div>
Subroutines whose names are in all upper case are reserved to the Perl core, as
  are modules whose names are in all lower case. A subroutine in all capitals is
  a loosely-held convention meaning it will be called indirectly by the run-time
  system itself, usually due to a triggered event. Subroutines that do special,
  pre-defined things include &quot;AUTOLOAD&quot;, &quot;CLONE&quot;,
  &quot;DESTROY&quot; plus all functions mentioned in perltie and PerlIO::via.
<div class="Pp"></div>
The &quot;BEGIN&quot;, &quot;UNITCHECK&quot;, &quot;CHECK&quot;,
  &quot;INIT&quot; and &quot;END&quot; subroutines are not so much subroutines
  as named special code blocks, of which you can have more than one in a
  package, and which you can <b>not</b> call explicitly. See &quot;BEGIN,
  UNITCHECK, CHECK, INIT and END&quot; in perlmod
<h2 class="Ss" title="Ss" id="Private_Variables_via_my()"><a class="selflink" href="#Private_Variables_via_my()">Private
  Variables via <i>my()</i></a></h2>
Synopsis:
<div class="Pp"></div>
<pre>
    my $foo;            # declare $foo lexically local
    my (@wid, %get);    # declare list of variables local
    my $foo = &quot;flurp&quot;;  # declare $foo lexical, and init it
    my @oof = @bar;     # declare @oof lexical, and init it
    my $x : Foo = $y;   # similar, with an attribute applied
</pre>
<div class="Pp"></div>
<b>WARNING</b>: The use of attribute lists on &quot;my&quot; declarations is
  still evolving. The current semantics and interface are subject to change. See
  attributes and Attribute::Handlers.
<div class="Pp"></div>
The &quot;my&quot; operator declares the listed variables to be lexically
  confined to the enclosing block, conditional
  (&quot;if/unless/elsif/else&quot;), loop
  (&quot;for/foreach/while/until/continue&quot;), subroutine, &quot;eval&quot;,
  or &quot;do/require/use&quot;'d file. If more than one value is listed, the
  list must be placed in parentheses. All listed elements must be legal lvalues.
  Only alphanumeric identifiers may be lexically scoped--magical built-ins like
  $/ must currently be &quot;local&quot;ized with &quot;local&quot; instead.
<div class="Pp"></div>
Unlike dynamic variables created by the &quot;local&quot; operator, lexical
  variables declared with &quot;my&quot; are totally hidden from the outside
  world, including any called subroutines. This is true if it's the same
  subroutine called from itself or elsewhere--every call gets its own copy.
<div class="Pp"></div>
This doesn't mean that a &quot;my&quot; variable declared in a statically
  enclosing lexical scope would be invisible. Only dynamic scopes are cut off.
  For example, the &quot;bumpx()&quot; function below has access to the lexical
  $x variable because both the &quot;my&quot; and the &quot;sub&quot; occurred
  at the same scope, presumably file scope.
<div class="Pp"></div>
<pre>
    my $x = 10;
    sub bumpx { $x++ }
</pre>
<div class="Pp"></div>
An &quot;eval()&quot;, however, can see lexical variables of the scope it is
  being evaluated in, so long as the names aren't hidden by declarations within
  the &quot;eval()&quot; itself. See perlref.
<div class="Pp"></div>
The parameter list to <i>my()</i> may be assigned to if desired, which allows
  you to initialize your variables. (If no initializer is given for a particular
  variable, it is created with the undefined value.) Commonly this is used to
  name input parameters to a subroutine. Examples:
<div class="Pp"></div>
<pre>
    $arg = &quot;fred&quot;;        # &quot;global&quot; variable
    $n = cube_root(27);
    print &quot;$arg thinks the root is $n\n&quot;;
 fred thinks the root is 3
    sub cube_root {
        my $arg = shift;  # name doesn't matter
        $arg **= 1/3;
        return $arg;
    }
</pre>
<div class="Pp"></div>
The &quot;my&quot; is simply a modifier on something you might assign to. So
  when you do assign to variables in its argument list, &quot;my&quot; doesn't
  change whether those variables are viewed as a scalar or an array. So
<div class="Pp"></div>
<pre>
    my ($foo) = &lt;STDIN&gt;;                # WRONG?
    my @FOO = &lt;STDIN&gt;;
</pre>
<div class="Pp"></div>
both supply a list context to the right-hand side, while
<div class="Pp"></div>
<pre>
    my $foo = &lt;STDIN&gt;;
</pre>
<div class="Pp"></div>
supplies a scalar context. But the following declares only one variable:
<div class="Pp"></div>
<pre>
    my $foo, $bar = 1;                  # WRONG
</pre>
<div class="Pp"></div>
That has the same effect as
<div class="Pp"></div>
<pre>
    my $foo;
    $bar = 1;
</pre>
<div class="Pp"></div>
The declared variable is not introduced (is not visible) until after the current
  statement. Thus,
<div class="Pp"></div>
<pre>
    my $x = $x;
</pre>
<div class="Pp"></div>
can be used to initialize a new $x with the value of the old $x, and the
  expression
<div class="Pp"></div>
<pre>
    my $x = 123 and $x == 123
</pre>
<div class="Pp"></div>
is false unless the old $x happened to have the value 123.
<div class="Pp"></div>
Lexical scopes of control structures are not bounded precisely by the braces
  that delimit their controlled blocks; control expressions are part of that
  scope, too. Thus in the loop
<div class="Pp"></div>
<pre>
    while (my $line = &lt;&gt;) {
        $line = lc $line;
    } continue {
        print $line;
    }
</pre>
<div class="Pp"></div>
the scope of $line extends from its declaration throughout the rest of the loop
  construct (including the &quot;continue&quot; clause), but not beyond it.
  Similarly, in the conditional
<div class="Pp"></div>
<pre>
    if ((my $answer = &lt;STDIN&gt;) =~ /^yes$/i) {
        user_agrees();
    } elsif ($answer =~ /^no$/i) {
        user_disagrees();
    } else {
        chomp $answer;
        die &quot;'$answer' is neither 'yes' nor 'no'&quot;;
    }
</pre>
<div class="Pp"></div>
the scope of $answer extends from its declaration through the rest of that
  conditional, including any &quot;elsif&quot; and &quot;else&quot; clauses, but
  not beyond it. See &quot;Simple Statements&quot; in perlsyn for information on
  the scope of variables in statements with modifiers.
<div class="Pp"></div>
The &quot;foreach&quot; loop defaults to scoping its index variable dynamically
  in the manner of &quot;local&quot;. However, if the index variable is prefixed
  with the keyword &quot;my&quot;, or if there is already a lexical by that name
  in scope, then a new lexical is created instead. Thus in the loop
<div class="Pp"></div>
<pre>
    for my $i (1, 2, 3) {
        some_function();
    }
</pre>
<div class="Pp"></div>
the scope of $i extends to the end of the loop, but not beyond it, rendering the
  value of $i inaccessible within &quot;some_function()&quot;.
<div class="Pp"></div>
Some users may wish to encourage the use of lexically scoped variables. As an
  aid to catching implicit uses to package variables, which are always global,
  if you say
<div class="Pp"></div>
<pre>
    use strict 'vars';
</pre>
<div class="Pp"></div>
then any variable mentioned from there to the end of the enclosing block must
  either refer to a lexical variable, be predeclared via &quot;our&quot; or
  &quot;use vars&quot;, or else must be fully qualified with the package name. A
  compilation error results otherwise. An inner block may countermand this with
  &quot;no strict 'vars'&quot;.
<div class="Pp"></div>
A &quot;my&quot; has both a compile-time and a run-time effect. At compile time,
  the compiler takes notice of it. The principal usefulness of this is to quiet
  &quot;use strict 'vars'&quot;, but it is also essential for generation of
  closures as detailed in perlref. Actual initialization is delayed until run
  time, though, so it gets executed at the appropriate time, such as each time
  through a loop, for example.
<div class="Pp"></div>
Variables declared with &quot;my&quot; are not part of any package and are
  therefore never fully qualified with the package name. In particular, you're
  not allowed to try to make a package variable (or other global) lexical:
<div class="Pp"></div>
<pre>
    my $pack::var;      # ERROR!  Illegal syntax
</pre>
<div class="Pp"></div>
In fact, a dynamic variable (also known as package or global variables) are
  still accessible using the fully qualified &quot;::&quot; notation even while
  a lexical of the same name is also visible:
<div class="Pp"></div>
<pre>
    package main;
    local $x = 10;
    my    $x = 20;
    print &quot;$x and $::x\n&quot;;
</pre>
<div class="Pp"></div>
That will print out 20 and 10.
<div class="Pp"></div>
You may declare &quot;my&quot; variables at the outermost scope of a file to
  hide any such identifiers from the world outside that file. This is similar in
  spirit to C's static variables when they are used at the file level. To do
  this with a subroutine requires the use of a closure (an anonymous function
  that accesses enclosing lexicals). If you want to create a private subroutine
  that cannot be called from outside that block, it can declare a lexical
  variable containing an anonymous sub reference:
<div class="Pp"></div>
<pre>
    my $secret_version = '1.001-beta';
    my $secret_sub = sub { print $secret_version };
    &amp;$secret_sub();
</pre>
<div class="Pp"></div>
As long as the reference is never returned by any function within the module, no
  outside module can see the subroutine, because its name is not in any
  package's symbol table. Remember that it's not <i>REALLY</i> called
  $some_pack::secret_version or anything; it's just $secret_version, unqualified
  and unqualifiable.
<div class="Pp"></div>
This does not work with object methods, however; all object methods have to be
  in the symbol table of some package to be found. See &quot;Function
  Templates&quot; in perlref for something of a work-around to this.
<h2 class="Ss" title="Ss" id="Persistent_Private_Variables"><a class="selflink" href="#Persistent_Private_Variables">Persistent
  Private Variables</a></h2>
There are two ways to build persistent private variables in Perl 5.10. First,
  you can simply use the &quot;state&quot; feature. Or, you can use closures, if
  you want to stay compatible with releases older than 5.10.
<div class="Pp"></div>
<i>Persistent variables via </i><i>state()</i><i></i>
<div class="Pp"></div>
Beginning with Perl 5.9.4, you can declare variables with the &quot;state&quot;
  keyword in place of &quot;my&quot;. For that to work, though, you must have
  enabled that feature beforehand, either by using the &quot;feature&quot;
  pragma, or by using &quot;-E&quot; on one-liners (see feature). Beginning with
  Perl 5.16, the &quot;CORE::state&quot; form does not require the
  &quot;feature&quot; pragma.
<div class="Pp"></div>
For example, the following code maintains a private counter, incremented each
  time the <i>gimme_another()</i> function is called:
<div class="Pp"></div>
<pre>
    use feature 'state';
    sub gimme_another { state $x; return ++$x }
</pre>
<div class="Pp"></div>
Also, since $x is lexical, it can't be reached or modified by any Perl code
  outside.
<div class="Pp"></div>
When combined with variable declaration, simple scalar assignment to
  &quot;state&quot; variables (as in &quot;state $x = 42&quot;) is executed only
  the first time. When such statements are evaluated subsequent times, the
  assignment is ignored. The behavior of this sort of assignment to non-scalar
  variables is undefined.
<div class="Pp"></div>
<i>Persistent variables with closures</i>
<div class="Pp"></div>
Just because a lexical variable is lexically (also called statically) scoped to
  its enclosing block, &quot;eval&quot;, or &quot;do&quot; FILE, this doesn't
  mean that within a function it works like a C static. It normally works more
  like a C auto, but with implicit garbage collection.
<div class="Pp"></div>
Unlike local variables in C or C++, Perl's lexical variables don't necessarily
  get recycled just because their scope has exited. If something more permanent
  is still aware of the lexical, it will stick around. So long as something else
  references a lexical, that lexical won't be freed--which is as it should be.
  You wouldn't want memory being free until you were done using it, or kept
  around once you were done. Automatic garbage collection takes care of this for
  you.
<div class="Pp"></div>
This means that you can pass back or save away references to lexical variables,
  whereas to return a pointer to a C auto is a grave error. It also gives us a
  way to simulate C's function statics. Here's a mechanism for giving a function
  private variables with both lexical scoping and a static lifetime. If you do
  want to create something like C's static variables, just enclose the whole
  function in an extra block, and put the static variable outside the function
  but in the block.
<div class="Pp"></div>
<pre>
    {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }
    # $secret_val now becomes unreachable by the outside
    # world, but retains its value between calls to gimme_another
</pre>
<div class="Pp"></div>
If this function is being sourced in from a separate file via
  &quot;require&quot; or &quot;use&quot;, then this is probably just fine. If
  it's all in the main program, you'll need to arrange for the &quot;my&quot; to
  be executed early, either by putting the whole block above your main program,
  or more likely, placing merely a &quot;BEGIN&quot; code block around it to
  make sure it gets executed before your program starts to run:
<div class="Pp"></div>
<pre>
    BEGIN {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }
</pre>
<div class="Pp"></div>
See &quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod about the
  special triggered code blocks, &quot;BEGIN&quot;, &quot;UNITCHECK&quot;,
  &quot;CHECK&quot;, &quot;INIT&quot; and &quot;END&quot;.
<div class="Pp"></div>
If declared at the outermost scope (the file scope), then lexicals work somewhat
  like C's file statics. They are available to all functions in that same file
  declared below them, but are inaccessible from outside that file. This
  strategy is sometimes used in modules to create private variables that the
  whole module can see.
<h2 class="Ss" title="Ss" id="Temporary_Values_via_local()"><a class="selflink" href="#Temporary_Values_via_local()">Temporary
  Values via <i>local()</i></a></h2>
<b>WARNING</b>: In general, you should be using &quot;my&quot; instead of
  &quot;local&quot;, because it's faster and safer. Exceptions to this include
  the global punctuation variables, global filehandles and formats, and direct
  manipulation of the Perl symbol table itself. &quot;local&quot; is mostly used
  when the current value of a variable must be visible to called subroutines.
<div class="Pp"></div>
Synopsis:
<div class="Pp"></div>
<pre>
    # localization of values
    local $foo;                 # make $foo dynamically local
    local (@wid, %get);         # make list of variables local
    local $foo = &quot;flurp&quot;;       # make $foo dynamic, and init it
    local @oof = @bar;          # make @oof dynamic, and init it
    local $hash{key} = &quot;val&quot;;   # sets a local value for this hash entry
    delete local $hash{key};    # delete this entry for the current block
    local ($cond ? $v1 : $v2);  # several types of lvalues support
                                # localization
    # localization of symbols
    local *FH;                  # localize $FH, @FH, %FH, &amp;FH  ...
    local *merlyn = *randal;    # now $merlyn is really $randal, plus
                                #     @merlyn is really @randal, etc
    local *merlyn = 'randal';   # SAME THING: promote 'randal' to *randal
    local *merlyn = \$randal;   # just alias $merlyn, not @merlyn etc
</pre>
<div class="Pp"></div>
A &quot;local&quot; modifies its listed variables to be &quot;local&quot; to the
  enclosing block, &quot;eval&quot;, or &quot;do FILE&quot;--and to <i>any
  subroutine</i> <i>called from within that block</i>. A &quot;local&quot; just
  gives temporary values to global (meaning package) variables. It does
  <i>not</i> create a local variable. This is known as dynamic scoping. Lexical
  scoping is done with &quot;my&quot;, which works more like C's auto
  declarations.
<div class="Pp"></div>
Some types of lvalues can be localized as well: hash and array elements and
  slices, conditionals (provided that their result is always localizable), and
  symbolic references. As for simple variables, this creates new, dynamically
  scoped values.
<div class="Pp"></div>
If more than one variable or expression is given to &quot;local&quot;, they must
  be placed in parentheses. This operator works by saving the current values of
  those variables in its argument list on a hidden stack and restoring them upon
  exiting the block, subroutine, or eval. This means that called subroutines can
  also reference the local variable, but not the global one. The argument list
  may be assigned to if desired, which allows you to initialize your local
  variables. (If no initializer is given for a particular variable, it is
  created with an undefined value.)
<div class="Pp"></div>
Because &quot;local&quot; is a run-time operator, it gets executed each time
  through a loop. Consequently, it's more efficient to localize your variables
  outside the loop.
<div class="Pp"></div>
<i>Grammatical note on </i><i>local()</i><i></i>
<div class="Pp"></div>
A &quot;local&quot; is simply a modifier on an lvalue expression. When you
  assign to a &quot;local&quot;ized variable, the &quot;local&quot; doesn't
  change whether its list is viewed as a scalar or an array. So
<div class="Pp"></div>
<pre>
    local($foo) = &lt;STDIN&gt;;
    local @FOO = &lt;STDIN&gt;;
</pre>
<div class="Pp"></div>
both supply a list context to the right-hand side, while
<div class="Pp"></div>
<pre>
    local $foo = &lt;STDIN&gt;;
</pre>
<div class="Pp"></div>
supplies a scalar context.
<div class="Pp"></div>
<i>Localization of special variables</i>
<div class="Pp"></div>
If you localize a special variable, you'll be giving a new value to it, but its
  magic won't go away. That means that all side-effects related to this magic
  still work with the localized value.
<div class="Pp"></div>
This feature allows code like this to work :
<div class="Pp"></div>
<pre>
    # Read the whole contents of FILE in $slurp
    { local $/ = undef; $slurp = &lt;FILE&gt;; }
</pre>
<div class="Pp"></div>
Note, however, that this restricts localization of some values ; for example,
  the following statement dies, as of perl 5.9.0, with an error <i>Modification
  of a read-only value attempted</i>, because the $1 variable is magical and
  read-only :
<div class="Pp"></div>
<pre>
    local $1 = 2;
</pre>
<div class="Pp"></div>
One exception is the default scalar variable: starting with perl 5.14
  &quot;local($_)&quot; will always strip all magic from $_, to make it possible
  to safely reuse $_ in a subroutine.
<div class="Pp"></div>
<b>WARNING</b>: Localization of tied arrays and hashes does not currently work
  as described. This will be fixed in a future release of Perl; in the meantime,
  avoid code that relies on any particular behaviour of localising tied arrays
  or hashes (localising individual elements is still okay). See &quot;Localising
  Tied Arrays and Hashes Is Broken&quot; in perl58delta for more details.
<div class="Pp"></div>
<i>Localization of globs</i>
<div class="Pp"></div>
The construct
<div class="Pp"></div>
<pre>
    local *name;
</pre>
<div class="Pp"></div>
creates a whole new symbol table entry for the glob &quot;name&quot; in the
  current package. That means that all variables in its glob slot ($name, @name,
  %name, &amp;name, and the &quot;name&quot; filehandle) are dynamically reset.
<div class="Pp"></div>
This implies, among other things, that any magic eventually carried by those
  variables is locally lost. In other words, saying &quot;local */&quot; will
  not have any effect on the internal value of the input record separator.
<div class="Pp"></div>
<i>Localization of elements of composite types</i>
<div class="Pp"></div>
It's also worth taking a moment to explain what happens when you
  &quot;local&quot;ize a member of a composite type (i.e. an array or hash
  element). In this case, the element is &quot;local&quot;ized <i>by name</i>.
  This means that when the scope of the &quot;local()&quot; ends, the saved
  value will be restored to the hash element whose key was named in the
  &quot;local()&quot;, or the array element whose index was named in the
  &quot;local()&quot;. If that element was deleted while the &quot;local()&quot;
  was in effect (e.g. by a &quot;delete()&quot; from a hash or a
  &quot;shift()&quot; of an array), it will spring back into existence, possibly
  extending an array and filling in the skipped elements with &quot;undef&quot;.
  For instance, if you say
<div class="Pp"></div>
<pre>
    %hash = ( 'This' =&gt; 'is', 'a' =&gt; 'test' );
    @ary  = ( 0..5 );
    {
         local($ary[5]) = 6;
         local($hash{'a'}) = 'drill';
         while (my $e = pop(@ary)) {
             print &quot;$e . . .\n&quot;;
             last unless $e &gt; 3;
         }
         if (@ary) {
             $hash{'only a'} = 'test';
             delete $hash{'a'};
         }
    }
    print join(' ', map { &quot;$_ $hash{$_}&quot; } sort keys %hash),&quot;.\n&quot;;
    print &quot;The array has &quot;,scalar(@ary),&quot; elements: &quot;,
          join(', ', map { defined $_ ? $_ : 'undef' } @ary),&quot;\n&quot;;
</pre>
<div class="Pp"></div>
Perl will print
<div class="Pp"></div>
<pre>
    6 . . .
    4 . . .
    3 . . .
    This is a test only a test.
    The array has 6 elements: 0, 1, 2, undef, undef, 5
</pre>
<div class="Pp"></div>
The behavior of <i>local()</i> on non-existent members of composite types is
  subject to change in future.
<div class="Pp"></div>
<i>Localized deletion of elements of composite types</i>
<div class="Pp"></div>
You can use the &quot;delete local $array[$idx]&quot; and &quot;delete local
  $hash{key}&quot; constructs to delete a composite type entry for the current
  block and restore it when it ends. They return the array/hash value before the
  localization, which means that they are respectively equivalent to
<div class="Pp"></div>
<pre>
    do {
        my $val = $array[$idx];
        local  $array[$idx];
        delete $array[$idx];
        $val
    }
</pre>
<div class="Pp"></div>
and
<div class="Pp"></div>
<pre>
    do {
        my $val = $hash{key};
        local  $hash{key};
        delete $hash{key};
        $val
    }
</pre>
<div class="Pp"></div>
except that for those the &quot;local&quot; is scoped to the &quot;do&quot;
  block. Slices are also accepted.
<div class="Pp"></div>
<pre>
    my %hash = (
     a =&gt; [ 7, 8, 9 ],
     b =&gt; 1,
    )
    {
     my $a = delete local $hash{a};
     # $a is [ 7, 8, 9 ]
     # %hash is (b =&gt; 1)
     {
      my @nums = delete local @$a[0, 2]
      # @nums is (7, 9)
      # $a is [ undef, 8 ]
      $a[0] = 999; # will be erased when the scope ends
     }
     # $a is back to [ 7, 8, 9 ]
    }
    # %hash is back to its original state
</pre>
<h2 class="Ss" title="Ss" id="Lvalue_subroutines"><a class="selflink" href="#Lvalue_subroutines">Lvalue
  subroutines</a></h2>
<b>WARNING</b>: Lvalue subroutines are still experimental and the implementation
  may change in future versions of Perl.
<div class="Pp"></div>
It is possible to return a modifiable value from a subroutine. To do this, you
  have to declare the subroutine to return an lvalue.
<div class="Pp"></div>
<pre>
    my $val;
    sub canmod : lvalue {
        $val;  # or:  return $val;
    }
    sub nomod {
        $val;
    }
    canmod() = 5;   # assigns to $val
    nomod()  = 5;   # ERROR
</pre>
<div class="Pp"></div>
The scalar/list context for the subroutine and for the right-hand side of
  assignment is determined as if the subroutine call is replaced by a scalar.
  For example, consider:
<div class="Pp"></div>
<pre>
    data(2,3) = get_data(3,4);
</pre>
<div class="Pp"></div>
Both subroutines here are called in a scalar context, while in:
<div class="Pp"></div>
<pre>
    (data(2,3)) = get_data(3,4);
</pre>
<div class="Pp"></div>
and in:
<div class="Pp"></div>
<pre>
    (data(2),data(3)) = get_data(3,4);
</pre>
<div class="Pp"></div>
all the subroutines are called in a list context.
<dl class="Bl-tag">
  <dt class="It-tag">Lvalue subroutines are EXPERIMENTAL</dt>
  <dd class="It-tag">They appear to be convenient, but there is at least one
      reason to be circumspect.
    <div style="height: 1.00em;">&#x00A0;</div>
    They violate encapsulation. A normal mutator can check the supplied argument
      before setting the attribute it is protecting, an lvalue subroutine never
      gets that chance. Consider;
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    my $some_array_ref = [];    # protected by mutators ??
    sub set_arr {               # normal mutator
        my $val = shift;
        die(&quot;expected array, you supplied &quot;, ref $val)
           unless ref $val eq 'ARRAY';
        $some_array_ref = $val;
    }
    sub set_arr_lv : lvalue {   # lvalue mutator
        $some_array_ref;
    }
    # set_arr_lv cannot stop this !
    set_arr_lv() = { a =&gt; 1 };
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Passing_Symbol_Table_Entries_(typeglobs)"><a class="selflink" href="#Passing_Symbol_Table_Entries_(typeglobs)">Passing
  Symbol Table Entries (typeglobs)</a></h2>
<b>WARNING</b>: The mechanism described in this section was originally the only
  way to simulate pass-by-reference in older versions of Perl. While it still
  works fine in modern versions, the new reference mechanism is generally easier
  to work with. See below.
<div class="Pp"></div>
Sometimes you don't want to pass the value of an array to a subroutine but
  rather the name of it, so that the subroutine can modify the global copy of it
  rather than working with a local copy. In perl you can refer to all objects of
  a particular name by prefixing the name with a star: *foo. This is often known
  as a &quot;typeglob&quot;, because the star on the front can be thought of as
  a wildcard match for all the funny prefix characters on variables and
  subroutines and such.
<div class="Pp"></div>
When evaluated, the typeglob produces a scalar value that represents all the
  objects of that name, including any filehandle, format, or subroutine. When
  assigned to, it causes the name mentioned to refer to whatever &quot;*&quot;
  value was assigned to it. Example:
<div class="Pp"></div>
<pre>
    sub doubleary {
        local(*someary) = @_;
        foreach $elem (@someary) {
            $elem *= 2;
        }
    }
    doubleary(*foo);
    doubleary(*bar);
</pre>
<div class="Pp"></div>
Scalars are already passed by reference, so you can modify scalar arguments
  without using this mechanism by referring explicitly to $_[0] etc. You can
  modify all the elements of an array by passing all the elements as scalars,
  but you have to use the &quot;*&quot; mechanism (or the equivalent reference
  mechanism) to &quot;push&quot;, &quot;pop&quot;, or change the size of an
  array. It will certainly be faster to pass the typeglob (or reference).
<div class="Pp"></div>
Even if you don't want to modify an array, this mechanism is useful for passing
  multiple arrays in a single LIST, because normally the LIST mechanism will
  merge all the array values so that you can't extract out the individual
  arrays. For more on typeglobs, see &quot;Typeglobs and Filehandles&quot; in
  perldata.
<h2 class="Ss" title="Ss" id="When_to_Still_Use_local()"><a class="selflink" href="#When_to_Still_Use_local()">When
  to Still Use <i>local()</i></a></h2>
Despite the existence of &quot;my&quot;, there are still three places where the
  &quot;local&quot; operator still shines. In fact, in these three places, you
  <i>must</i> use &quot;local&quot; instead of &quot;my&quot;.
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">You need to give a global variable a temporary value,
      especially $_.
    <div style="height: 1.00em;">&#x00A0;</div>
    The global variables, like @ARGV or the punctuation variables, must be
      &quot;local&quot;ized with &quot;local()&quot;. This block reads in
      <i>/etc/motd</i>, and splits it up into chunks separated by lines of equal
      signs, which are placed in @Fields.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    {
        local @ARGV = (&quot;/etc/motd&quot;);
        local $/ = undef;
        local $_ = &lt;&gt;;  
        @Fields = split /^\s*=+\s*$/;
    }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It particular, it's important to &quot;local&quot;ize $_ in any routine that
      assigns to it. Look out for implicit assignments in &quot;while&quot;
      conditionals.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">You need to create a local file or directory handle or a
      local function.
    <div style="height: 1.00em;">&#x00A0;</div>
    A function that needs a filehandle of its own must use &quot;local()&quot;
      on a complete typeglob. This can be used to create new symbol table
      entries:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub ioqueue {
        local  (*READER, *WRITER);    # not my!
        pipe    (READER,  WRITER)     or die &quot;pipe: $!&quot;;
        return (*READER, *WRITER);
    }
    ($head, $tail) = ioqueue();
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See the Symbol module for a way to create anonymous symbol table entries.
    <div style="height: 1.00em;">&#x00A0;</div>
    Because assignment of a reference to a typeglob creates an alias, this can
      be used to create what is effectively a local function, or at least, a
      local alias.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    {
        local *grow = \&amp;shrink; # only until this block exits
        grow();                 # really calls shrink()
        move();                 # if move() grow()s, it shrink()s too
    }
    grow();                     # get the real grow() again
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;Function Templates&quot; in perlref for more about manipulating
      functions by name in this way.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">You want to temporarily change just one element of an array
      or hash.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can &quot;local&quot;ize just one element of an aggregate. Usually this
      is done on dynamics:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    {
        local $SIG{INT} = 'IGNORE';
        funct();                            # uninterruptible
    } 
    # interruptibility automatically restored here
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    But it also works on lexically declared aggregates. Prior to 5.005, this
      operation could on occasion misbehave.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Pass_by_Reference"><a class="selflink" href="#Pass_by_Reference">Pass
  by Reference</a></h2>
If you want to pass more than one array or hash into a function--or return them
  from it--and have them maintain their integrity, then you're going to have to
  use an explicit pass-by-reference. Before you do that, you need to understand
  references as detailed in perlref. This section may not make much sense to you
  otherwise.
<div class="Pp"></div>
Here are a few simple examples. First, let's pass in several arrays to a
  function and have it &quot;pop&quot; all of then, returning a new list of all
  their former last elements:
<div class="Pp"></div>
<pre>
    @tailings = popmany ( \@a, \@b, \@c, \@d );
    sub popmany {
        my $aref;
        my @retlist = ();
        foreach $aref ( @_ ) {
            push @retlist, pop @$aref;
        }
        return @retlist;
    }
</pre>
<div class="Pp"></div>
Here's how you might write a function that returns a list of keys occurring in
  all the hashes passed to it:
<div class="Pp"></div>
<pre>
    @common = inter( \%foo, \%bar, \%joe );
    sub inter {
        my ($k, $href, %seen); # locals
        foreach $href (@_) {
            while ( $k = each %$href ) {
                $seen{$k}++;
            }
        }
        return grep { $seen{$_} == @_ } keys %seen;
    }
</pre>
<div class="Pp"></div>
So far, we're using just the normal list return mechanism. What happens if you
  want to pass or return a hash? Well, if you're using only one of them, or you
  don't mind them concatenating, then the normal calling convention is ok,
  although a little expensive.
<div class="Pp"></div>
Where people get into trouble is here:
<div class="Pp"></div>
<pre>
    (@a, @b) = func(@c, @d);
or
    (%a, %b) = func(%c, %d);
</pre>
<div class="Pp"></div>
That syntax simply won't work. It sets just @a or %a and clears the @b or %b.
  Plus the function didn't get passed into two separate arrays or hashes: it got
  one long list in @_, as always.
<div class="Pp"></div>
If you can arrange for everyone to deal with this through references, it's
  cleaner code, although not so nice to look at. Here's a function that takes
  two array references as arguments, returning the two array elements in order
  of how many elements they have in them:
<div class="Pp"></div>
<pre>
    ($aref, $bref) = func(\@c, \@d);
    print &quot;@$aref has more than @$bref\n&quot;;
    sub func {
        my ($cref, $dref) = @_;
        if (@$cref &gt; @$dref) {
            return ($cref, $dref);
        } else {
            return ($dref, $cref);
        }
    }
</pre>
<div class="Pp"></div>
It turns out that you can actually do this also:
<div class="Pp"></div>
<pre>
    (*a, *b) = func(\@c, \@d);
    print &quot;@a has more than @b\n&quot;;
    sub func {
        local (*c, *d) = @_;
        if (@c &gt; @d) {
            return (\@c, \@d);
        } else {
            return (\@d, \@c);
        }
    }
</pre>
<div class="Pp"></div>
Here we're using the typeglobs to do symbol table aliasing. It's a tad subtle,
  though, and also won't work if you're using &quot;my&quot; variables, because
  only globals (even in disguise as &quot;local&quot;s) are in the symbol table.
<div class="Pp"></div>
If you're passing around filehandles, you could usually just use the bare
  typeglob, like *STDOUT, but typeglobs references work, too. For example:
<div class="Pp"></div>
<pre>
    splutter(\*STDOUT);
    sub splutter {
        my $fh = shift;
        print $fh &quot;her um well a hmmm\n&quot;;
    }
    $rec = get_rec(\*STDIN);
    sub get_rec {
        my $fh = shift;
        return scalar &lt;$fh&gt;;
    }
</pre>
<div class="Pp"></div>
If you're planning on generating new filehandles, you could do this. Notice to
  pass back just the bare *FH, not its reference.
<div class="Pp"></div>
<pre>
    sub openit {
        my $path = shift;
        local *FH;
        return open (FH, $path) ? *FH : undef;
    }
</pre>
<h2 class="Ss" title="Ss" id="Prototypes"><a class="selflink" href="#Prototypes">Prototypes</a></h2>
Perl supports a very limited kind of compile-time argument checking using
  function prototyping. If you declare
<div class="Pp"></div>
<pre>
    sub mypush (+@)
</pre>
<div class="Pp"></div>
then &quot;mypush()&quot; takes arguments exactly like &quot;push()&quot; does.
  The function declaration must be visible at compile time. The prototype
  affects only interpretation of new-style calls to the function, where
  new-style is defined as not using the &quot;&amp;&quot; character. In other
  words, if you call it like a built-in function, then it behaves like a
  built-in function. If you call it like an old-fashioned subroutine, then it
  behaves like an old-fashioned subroutine. It naturally falls out from this
  rule that prototypes have no influence on subroutine references like
  &quot;\&amp;foo&quot; or on indirect subroutine calls like
  &quot;&amp;{$subref}&quot; or &quot;$subref-&gt;()&quot;.
<div class="Pp"></div>
Method calls are not influenced by prototypes either, because the function to be
  called is indeterminate at compile time, since the exact code called depends
  on inheritance.
<div class="Pp"></div>
Because the intent of this feature is primarily to let you define subroutines
  that work like built-in functions, here are prototypes for some other
  functions that parse almost exactly like the corresponding built-in.
<div class="Pp"></div>
<pre>
    Declared as                 Called as
    sub mylink ($$)          mylink $old, $new
    sub myvec ($$$)          myvec $var, $offset, 1
    sub myindex ($$;$)       myindex &amp;getstring, &quot;substr&quot;
    sub mysyswrite ($$$;$)   mysyswrite $buf, 0, length($buf) - $off, $off
    sub myreverse (@)        myreverse $a, $b, $c
    sub myjoin ($@)          myjoin &quot;:&quot;, $a, $b, $c
    sub mypop (+)            mypop @array
    sub mysplice (+$$@)      mysplice @array, 0, 2, @pushme
    sub mykeys (+)           mykeys %{$hashref}
    sub myopen (*;$)         myopen HANDLE, $name
    sub mypipe (**)          mypipe READHANDLE, WRITEHANDLE
    sub mygrep (&amp;@)          mygrep { /foo/ } $a, $b, $c
    sub myrand (;$)          myrand 42
    sub mytime ()            mytime
</pre>
<div class="Pp"></div>
Any backslashed prototype character represents an actual argument that must
  start with that character (optionally preceded by &quot;my&quot;,
  &quot;our&quot; or &quot;local&quot;), with the exception of &quot;$&quot;,
  which will accept any scalar lvalue expression, such as &quot;$foo = 7&quot;
  or &quot;my_function()-&gt;[0]&quot;. The value passed as part of @_ will be a
  reference to the actual argument given in the subroutine call, obtained by
  applying &quot;\&quot; to that argument.
<div class="Pp"></div>
You can use the &quot;\[]&quot; backslash group notation to specify more than
  one allowed argument type. For example:
<div class="Pp"></div>
<pre>
    sub myref (\[$@%&amp;*])
</pre>
<div class="Pp"></div>
will allow calling <i>myref()</i> as
<div class="Pp"></div>
<pre>
    myref $var
    myref @array
    myref %hash
    myref &amp;sub
    myref *glob
</pre>
<div class="Pp"></div>
and the first argument of <i>myref()</i> will be a reference to a scalar, an
  array, a hash, a code, or a glob.
<div class="Pp"></div>
Unbackslashed prototype characters have special meanings. Any unbackslashed
  &quot;@&quot; or &quot;%&quot; eats all remaining arguments, and forces list
  context. An argument represented by &quot;$&quot; forces scalar context. An
  &quot;&amp;&quot; requires an anonymous subroutine, which, if passed as the
  first argument, does not require the &quot;sub&quot; keyword or a subsequent
  comma.
<div class="Pp"></div>
A &quot;*&quot; allows the subroutine to accept a bareword, constant, scalar
  expression, typeglob, or a reference to a typeglob in that slot. The value
  will be available to the subroutine either as a simple scalar, or (in the
  latter two cases) as a reference to the typeglob. If you wish to always
  convert such arguments to a typeglob reference, use
  <i>Symbol::qualify_to_ref()</i> as follows:
<div class="Pp"></div>
<pre>
    use Symbol 'qualify_to_ref';
    sub foo (*) {
        my $fh = qualify_to_ref(shift, caller);
        ...
    }
</pre>
<div class="Pp"></div>
The &quot;+&quot; prototype is a special alternative to &quot;$&quot; that will
  act like &quot;\[@%]&quot; when given a literal array or hash variable, but
  will otherwise force scalar context on the argument. This is useful for
  functions which should accept either a literal array or an array reference as
  the argument:
<div class="Pp"></div>
<pre>
    sub mypush (+@) {
        my $aref = shift;
        die &quot;Not an array or arrayref&quot; unless ref $aref eq 'ARRAY';
        push @$aref, @_;
    }
</pre>
<div class="Pp"></div>
When using the &quot;+&quot; prototype, your function must check that the
  argument is of an acceptable type.
<div class="Pp"></div>
A semicolon (&quot;;&quot;) separates mandatory arguments from optional
  arguments. It is redundant before &quot;@&quot; or &quot;%&quot;, which gobble
  up everything else.
<div class="Pp"></div>
As the last character of a prototype, or just before a semicolon, a
  &quot;@&quot; or a &quot;%&quot;, you can use &quot;_&quot; in place of
  &quot;$&quot;: if this argument is not provided, $_ will be used instead.
<div class="Pp"></div>
Note how the last three examples in the table above are treated specially by the
  parser. &quot;mygrep()&quot; is parsed as a true list operator,
  &quot;myrand()&quot; is parsed as a true unary operator with unary precedence
  the same as &quot;rand()&quot;, and &quot;mytime()&quot; is truly without
  arguments, just like &quot;time()&quot;. That is, if you say
<div class="Pp"></div>
<pre>
    mytime +2;
</pre>
<div class="Pp"></div>
you'll get &quot;mytime() + 2&quot;, not mytime(2), which is how it would be
  parsed without a prototype. If you want to force a unary function to have the
  same precedence as a list operator, add &quot;;&quot; to the end of the
  prototype:
<div class="Pp"></div>
<pre>
    sub mygetprotobynumber($;);
    mygetprotobynumber $a &gt; $b; # parsed as mygetprotobynumber($a &gt; $b)
</pre>
<div class="Pp"></div>
The interesting thing about &quot;&amp;&quot; is that you can generate new
  syntax with it, provided it's in the initial position:
<div class="Pp"></div>
<pre>
    sub try (&amp;@) {
        my($try,$catch) = @_;
        eval { &amp;$try };
        if ($@) {
            local $_ = $@;
            &amp;$catch;
        }
    }
    sub catch (&amp;) { $_[0] }
    try {
        die &quot;phooey&quot;;
    } catch {
        /phooey/ and print &quot;unphooey\n&quot;;
    };
</pre>
<div class="Pp"></div>
That prints &quot;unphooey&quot;. (Yes, there are still unresolved issues having
  to do with visibility of @_. I'm ignoring that question for the moment. (But
  note that if we make @_ lexically scoped, those anonymous subroutines can act
  like closures... (Gee, is this sounding a little Lispish? (Never mind.))))
<div class="Pp"></div>
And here's a reimplementation of the Perl &quot;grep&quot; operator:
<div class="Pp"></div>
<pre>
    sub mygrep (&amp;@) {
        my $code = shift;
        my @result;
        foreach $_ (@_) {
            push(@result, $_) if &amp;$code;
        }
        @result;
    }
</pre>
<div class="Pp"></div>
Some folks would prefer full alphanumeric prototypes. Alphanumerics have been
  intentionally left out of prototypes for the express purpose of someday in the
  future adding named, formal parameters. The current mechanism's main goal is
  to let module writers provide better diagnostics for module users. Larry feels
  the notation quite understandable to Perl programmers, and that it will not
  intrude greatly upon the meat of the module, nor make it harder to read. The
  line noise is visually encapsulated into a small pill that's easy to swallow.
<div class="Pp"></div>
If you try to use an alphanumeric sequence in a prototype you will generate an
  optional warning - &quot;Illegal character in prototype...&quot;.
  Unfortunately earlier versions of Perl allowed the prototype to be used as
  long as its prefix was a valid prototype. The warning may be upgraded to a
  fatal error in a future version of Perl once the majority of offending code is
  fixed.
<div class="Pp"></div>
It's probably best to prototype new functions, not retrofit prototyping into
  older ones. That's because you must be especially careful about silent
  impositions of differing list versus scalar contexts. For example, if you
  decide that a function should take just one parameter, like this:
<div class="Pp"></div>
<pre>
    sub func ($) {
        my $n = shift;
        print &quot;you gave me $n\n&quot;;
    }
</pre>
<div class="Pp"></div>
and someone has been calling it with an array or expression returning a list:
<div class="Pp"></div>
<pre>
    func(@foo);
    func( split /:/ );
</pre>
<div class="Pp"></div>
Then you've just supplied an automatic &quot;scalar&quot; in front of their
  argument, which can be more than a bit surprising. The old @foo which used to
  hold one thing doesn't get passed in. Instead, &quot;func()&quot; now gets
  passed in a 1; that is, the number of elements in @foo. And the
  &quot;split&quot; gets called in scalar context so it starts scribbling on
  your @_ parameter list. Ouch!
<div class="Pp"></div>
This is all very powerful, of course, and should be used only in moderation to
  make the world a better place.
<h2 class="Ss" title="Ss" id="Constant_Functions"><a class="selflink" href="#Constant_Functions">Constant
  Functions</a></h2>
Functions with a prototype of &quot;()&quot; are potential candidates for
  inlining. If the result after optimization and constant folding is either a
  constant or a lexically-scoped scalar which has no other references, then it
  will be used in place of function calls made without &quot;&amp;&quot;. Calls
  made using &quot;&amp;&quot; are never inlined. (See <i>constant.pm</i> for an
  easy way to declare most constants.)
<div class="Pp"></div>
The following functions would all be inlined:
<div class="Pp"></div>
<pre>
    sub pi ()           { 3.14159 }             # Not exact, but close.
    sub PI ()           { 4 * atan2 1, 1 }      # As good as it gets,
                                                # and it's inlined, too!
    sub ST_DEV ()       { 0 }
    sub ST_INO ()       { 1 }
    sub FLAG_FOO ()     { 1 &lt;&lt; 8 }
    sub FLAG_BAR ()     { 1 &lt;&lt; 9 }
    sub FLAG_MASK ()    { FLAG_FOO | FLAG_BAR }
    sub OPT_BAZ ()      { not (0x1B58 &amp; FLAG_MASK) }
    sub N () { int(OPT_BAZ) / 3 }
    sub FOO_SET () { 1 if FLAG_MASK &amp; FLAG_FOO }
</pre>
<div class="Pp"></div>
Be aware that these will not be inlined; as they contain inner scopes, the
  constant folding doesn't reduce them to a single constant:
<div class="Pp"></div>
<pre>
    sub foo_set () { if (FLAG_MASK &amp; FLAG_FOO) { 1 } }
    sub baz_val () {
        if (OPT_BAZ) {
            return 23;
        }
        else {
            return 42;
        }
    }
</pre>
<div class="Pp"></div>
If you redefine a subroutine that was eligible for inlining, you'll get a
  warning by default. (You can use this warning to tell whether or not a
  particular subroutine is considered constant.) The warning is considered
  severe enough not to be affected by the <b>-w</b> switch (or its absence)
  because previously compiled invocations of the function will still be using
  the old value of the function. If you need to be able to redefine the
  subroutine, you need to ensure that it isn't inlined, either by dropping the
  &quot;()&quot; prototype (which changes calling semantics, so beware) or by
  thwarting the inlining mechanism in some other way, such as
<div class="Pp"></div>
<pre>
    sub not_inlined () {
        23 if $];
    }
</pre>
<h2 class="Ss" title="Ss" id="Overriding_Built-in_Functions"><a class="selflink" href="#Overriding_Built-in_Functions">Overriding
  Built-in Functions</a></h2>
Many built-in functions may be overridden, though this should be tried only
  occasionally and for good reason. Typically this might be done by a package
  attempting to emulate missing built-in functionality on a non-Unix system.
<div class="Pp"></div>
Overriding may be done only by importing the name from a module at compile
  time--ordinary predeclaration isn't good enough. However, the &quot;use
  subs&quot; pragma lets you, in effect, predeclare subs via the import syntax,
  and these names may then override built-in ones:
<div class="Pp"></div>
<pre>
    use subs 'chdir', 'chroot', 'chmod', 'chown';
    chdir $somewhere;
    sub chdir { ... }
</pre>
<div class="Pp"></div>
To unambiguously refer to the built-in form, precede the built-in name with the
  special package qualifier &quot;CORE::&quot;. For example, saying
  &quot;CORE::open()&quot; always refers to the built-in &quot;open()&quot;,
  even if the current package has imported some other subroutine called
  &quot;&amp;open()&quot; from elsewhere. Even though it looks like a regular
  function call, it isn't: the CORE:: prefix in that case is part of Perl's
  syntax, and works for any keyword, regardless of what is in the CORE package.
  Taking a reference to it, that is, &quot;\&amp;CORE::open&quot;, only works
  for some keywords. See CORE.
<div class="Pp"></div>
Library modules should not in general export built-in names like
  &quot;open&quot; or &quot;chdir&quot; as part of their default @EXPORT list,
  because these may sneak into someone else's namespace and change the semantics
  unexpectedly. Instead, if the module adds that name to @EXPORT_OK, then it's
  possible for a user to import the name explicitly, but not implicitly. That
  is, they could say
<div class="Pp"></div>
<pre>
    use Module 'open';
</pre>
<div class="Pp"></div>
and it would import the &quot;open&quot; override. But if they said
<div class="Pp"></div>
<pre>
    use Module;
</pre>
<div class="Pp"></div>
they would get the default imports without overrides.
<div class="Pp"></div>
The foregoing mechanism for overriding built-in is restricted, quite
  deliberately, to the package that requests the import. There is a second
  method that is sometimes applicable when you wish to override a built-in
  everywhere, without regard to namespace boundaries. This is achieved by
  importing a sub into the special namespace &quot;CORE::GLOBAL::&quot;. Here is
  an example that quite brazenly replaces the &quot;glob&quot; operator with
  something that understands regular expressions.
<div class="Pp"></div>
<pre>
    package REGlob;
    require Exporter;
    @ISA = 'Exporter';
    @EXPORT_OK = 'glob';
    sub import {
        my $pkg = shift;
        return unless @_;
        my $sym = shift;
        my $where = ($sym =~ s/^GLOBAL_// ? 'CORE::GLOBAL' : caller(0));
        $pkg-&gt;export($where, $sym, @_);
    }
    sub glob {
        my $pat = shift;
        my @got;
        if (opendir my $d, '.') { 
            @got = grep /$pat/, readdir $d; 
            closedir $d;   
        }
        return @got;
    }
    1;
</pre>
<div class="Pp"></div>
And here's how it could be (ab)used:
<div class="Pp"></div>
<pre>
    #use REGlob 'GLOBAL_glob';      # override glob() in ALL namespaces
    package Foo;
    use REGlob 'glob';              # override glob() in Foo:: only
    print for &lt;^[a-z_]+\.pm\$&gt;;     # show all pragmatic modules
</pre>
<div class="Pp"></div>
The initial comment shows a contrived, even dangerous example. By overriding
  &quot;glob&quot; globally, you would be forcing the new (and subversive)
  behavior for the &quot;glob&quot; operator for <i>every</i> namespace, without
  the complete cognizance or cooperation of the modules that own those
  namespaces. Naturally, this should be done with extreme caution--if it must be
  done at all.
<div class="Pp"></div>
The &quot;REGlob&quot; example above does not implement all the support needed
  to cleanly override perl's &quot;glob&quot; operator. The built-in
  &quot;glob&quot; has different behaviors depending on whether it appears in a
  scalar or list context, but our &quot;REGlob&quot; doesn't. Indeed, many perl
  built-in have such context sensitive behaviors, and these must be adequately
  supported by a properly written override. For a fully functional example of
  overriding &quot;glob&quot;, study the implementation of
  &quot;File::DosGlob&quot; in the standard library.
<div class="Pp"></div>
When you override a built-in, your replacement should be consistent (if
  possible) with the built-in native syntax. You can achieve this by using a
  suitable prototype. To get the prototype of an overridable built-in, use the
  &quot;prototype&quot; function with an argument of
  &quot;CORE::builtin_name&quot; (see &quot;prototype&quot; in perlfunc).
<div class="Pp"></div>
Note however that some built-ins can't have their syntax expressed by a
  prototype (such as &quot;system&quot; or &quot;chomp&quot;). If you override
  them you won't be able to fully mimic their original syntax.
<div class="Pp"></div>
The built-ins &quot;do&quot;, &quot;require&quot; and &quot;glob&quot; can also
  be overridden, but due to special magic, their original syntax is preserved,
  and you don't have to define a prototype for their replacements. (You can't
  override the &quot;do BLOCK&quot; syntax, though).
<div class="Pp"></div>
&quot;require&quot; has special additional dark magic: if you invoke your
  &quot;require&quot; replacement as &quot;require Foo::Bar&quot;, it will
  actually receive the argument &quot;Foo/Bar.pm&quot; in @_. See
  &quot;require&quot; in perlfunc.
<div class="Pp"></div>
And, as you'll have noticed from the previous example, if you override
  &quot;glob&quot;, the &quot;&lt;*&gt;&quot; glob operator is overridden as
  well.
<div class="Pp"></div>
In a similar fashion, overriding the &quot;readline&quot; function also
  overrides the equivalent I/O operator &quot;&lt;FILEHANDLE&gt;&quot;. Also,
  overriding &quot;readpipe&quot; also overrides the operators &quot;``&quot;
  and &quot;qx//&quot;.
<div class="Pp"></div>
Finally, some built-ins (e.g. &quot;exists&quot; or &quot;grep&quot;) can't be
  overridden.
<h2 class="Ss" title="Ss" id="Autoloading"><a class="selflink" href="#Autoloading">Autoloading</a></h2>
If you call a subroutine that is undefined, you would ordinarily get an
  immediate, fatal error complaining that the subroutine doesn't exist.
  (Likewise for subroutines being used as methods, when the method doesn't exist
  in any base class of the class's package.) However, if an &quot;AUTOLOAD&quot;
  subroutine is defined in the package or packages used to locate the original
  subroutine, then that &quot;AUTOLOAD&quot; subroutine is called with the
  arguments that would have been passed to the original subroutine. The fully
  qualified name of the original subroutine magically appears in the global
  $AUTOLOAD variable of the same package as the &quot;AUTOLOAD&quot; routine.
  The name is not passed as an ordinary argument because, er, well, just
  because, that's why. (As an exception, a method call to a nonexistent
  &quot;import&quot; or &quot;unimport&quot; method is just skipped instead.
  Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve
  the subroutine name. See &quot;Autoloading with XSUBs&quot; in perlguts for
  details.)
<div class="Pp"></div>
Many &quot;AUTOLOAD&quot; routines load in a definition for the requested
  subroutine using <i>eval()</i>, then execute that subroutine using a special
  form of <i>goto()</i> that erases the stack frame of the &quot;AUTOLOAD&quot;
  routine without a trace. (See the source to the standard module documented in
  AutoLoader, for example.) But an &quot;AUTOLOAD&quot; routine can also just
  emulate the routine and never define it. For example, let's pretend that a
  function that wasn't defined should just invoke &quot;system&quot; with those
  arguments. All you'd do is:
<div class="Pp"></div>
<pre>
    sub AUTOLOAD {
        my $program = $AUTOLOAD;
        $program =~ s/.*:://;
        system($program, @_);
    }
    date();
    who('am', 'i');
    ls('-l');
</pre>
<div class="Pp"></div>
In fact, if you predeclare functions you want to call that way, you don't even
  need parentheses:
<div class="Pp"></div>
<pre>
    use subs qw(date who ls);
    date;
    who &quot;am&quot;, &quot;i&quot;;
    ls '-l';
</pre>
<div class="Pp"></div>
A more complete example of this is the Shell module on CPAN, which can treat
  undefined subroutine calls as calls to external programs.
<div class="Pp"></div>
Mechanisms are available to help modules writers split their modules into
  autoloadable files. See the standard AutoLoader module described in AutoLoader
  and in AutoSplit, the standard SelfLoader modules in SelfLoader, and the
  document on adding C functions to Perl code in perlxs.
<h2 class="Ss" title="Ss" id="Subroutine_Attributes"><a class="selflink" href="#Subroutine_Attributes">Subroutine
  Attributes</a></h2>
A subroutine declaration or definition may have a list of attributes associated
  with it. If such an attribute list is present, it is broken up at space or
  colon boundaries and treated as though a &quot;use attributes&quot; had been
  seen. See attributes for details about what attributes are currently
  supported. Unlike the limitation with the obsolescent &quot;use attrs&quot;,
  the &quot;sub : ATTRLIST&quot; syntax works to associate the attributes with a
  pre-declaration, and not just with a subroutine definition.
<div class="Pp"></div>
The attributes must be valid as simple identifier names (without any punctuation
  other than the '_' character). They may have a parameter list appended, which
  is only checked for whether its parentheses ('(',')') nest properly.
<div class="Pp"></div>
Examples of valid syntax (even though the attributes are unknown):
<div class="Pp"></div>
<pre>
    sub fnord (&amp;\%) : switch(10,foo(7,3))  :  expensive;
    sub plugh () : Ugly('\(&quot;) :Bad;
    sub xyzzy : _5x5 { ... }
</pre>
<div class="Pp"></div>
Examples of invalid syntax:
<div class="Pp"></div>
<pre>
    sub fnord : switch(10,foo(); # ()-string not balanced
    sub snoid : Ugly('(');        # ()-string not balanced
    sub xyzzy : 5x5;              # &quot;5x5&quot; not a valid identifier
    sub plugh : Y2::north;        # &quot;Y2::north&quot; not a simple identifier
    sub snurt : foo + bar;        # &quot;+&quot; not a colon or space
</pre>
<div class="Pp"></div>
The attribute list is passed as a list of constant strings to the code which
  associates them with the subroutine. In particular, the second example of
  valid syntax above currently looks like this in terms of how it's parsed and
  invoked:
<div class="Pp"></div>
<pre>
    use attributes __PACKAGE__, \&amp;plugh, q[Ugly('\(&quot;)], 'Bad';
</pre>
<div class="Pp"></div>
For further details on attribute lists and their manipulation, see attributes
  and Attribute::Handlers.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
See &quot;Function Templates&quot; in perlref for more about references and
  closures. See perlxs if you'd like to learn about calling C subroutines from
  Perl. See perlembed if you'd like to learn about calling Perl subroutines from
  C. See perlmod to learn about bundling up your functions in separate files.
  See perlmodlib to learn what library modules come standard on your system. See
  perlootut to learn how to make object method calls.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
