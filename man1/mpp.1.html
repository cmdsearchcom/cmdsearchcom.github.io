<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:26:09 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKEPP(1) Makepp MAKEPP(1)</p>

<p style="margin-top: 1em">NAME <br>
makepp -- Compatible but improved replacement for make</p>

<p style="margin-top: 1em">SYNOPSIS <br>
makepp [ -e ] [ -C dir ] [ -f makefile] [ -F makefile_or_dir
] <br>
[ -j n] [ -k ] [ -m method ] [ --noremake-makefiles ] <br>
[ --nowarn ] [ -q ] [ -R dir] [ --traditional-recursive-make
] <br>
[ -v ] [ --version ] [ VAR=value ... ] [ target ... ]</p>

<p style="margin-top: 1em">mpp [-options] [ VAR=value ... ]
[ target ... ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Makepp, a build program which has a number of features that
allow for reliable builds and simpler build files, is a
drop-in replacement for GNU make. It supports almost all of
<br>
the syntax that GNU make supports, and can be used with
makefiles produced by utilities such as automake. It is
called makepp (or make++) because it was designed with
special <br>
support for C++, which has since been extended to other
languages like Swig or embedded SQL. Also its relationship
to make is analogous to C++&rsquo;s relationship to C: it is
almost <br>
100% backward compatible but adds a number of new features
and much better ways to write makefiles.</p>

<p style="margin-top: 1em">Makepp passes an extensive
test-suite, and is used in several big projects. If you have
any issues with the latest CVS version, holler, and
we&rsquo;ll try to fix it quickly. Makepp <br>
runs with any version of Perl since 5.8.</p>

<p style="margin-top: 1em">The following manual pages
contain further information on how to use makepp:</p>

<p style="margin-top: 1em">Tutorial <br>
How to write a makefile. This is mostly intended for someone
with little or no experience using any implementation of
make.</p>

<p style="margin-top: 1em">Compilation Tutorial <br>
What the Unix compilation commands do.</p>

<p style="margin-top: 1em">Release Notes <br>
What changed with each release.</p>

<p style="margin-top: 1em">Incompatibilities <br>
What works differently between GNU make and makepp.</p>

<p style="margin-top: 1em">Speedup <br>
Various tips for making makepp go much faster.</p>

<p style="margin-top: 1em">Perl Performance <br>
Various tips for making Perl programming (within your
makefiles and elsewhere) go faster.</p>

<p style="margin-top: 1em">Cookbook <br>
Quick answers to &quot;How do I ...?&quot; or
&quot;What&rsquo;s the best way to ...?&quot;</p>

<p style="margin-top: 1em">FAQ Quick answers to questions
people have stumbled upon.</p>

<p style="margin-top: 1em">Build Algorithm <br>
How makepp&rsquo;s build algorithm differs in fundamental
ways from traditional make.</p>

<p style="margin-top: 1em">Build Cache <br>
A build cache is a directory that stores the results of
prior builds in case they are needed again in the same
directory, or in a separate build in a different
directory.</p>

<p style="margin-top: 1em">Build Check Methods <br>
How makepp decides when to build.</p>

<p style="margin-top: 1em">Builtin Commands <br>
Powerful, efficient commands available everwhere makepp 2.0
or newer is.</p>

<p style="margin-top: 1em">Builtin Rules <br>
For very simple programs, you may not need a makefile at
all! These are the builtin rules that makepp knows
about.</p>

<p style="margin-top: 1em">Compatibility <br>
Where and and with what version of Perl makepp works.</p>

<p style="margin-top: 1em">Extending <br>
How you can add functions to makepp by writing your own Perl
code.</p>

<p style="margin-top: 1em">Functions <br>
Functions for text manipulation and various other
purposes.</p>

<p style="margin-top: 1em">Repositories <br>
Repositories are a technique that simplifies both variant
builds and keeping a central set of sources.</p>

<p style="margin-top: 1em">Rules <br>
Specifying rules to build files.</p>

<p style="margin-top: 1em">Sandboxes <br>
Using sandboxes to partition the build.</p>

<p style="margin-top: 1em">Scanning <br>
How makepp scans for dependencies like include files.</p>

<p style="margin-top: 1em">Signatures <br>
How makepp decides when files have changed.</p>

<p style="margin-top: 1em">Statements <br>
Additional directives to control makepp.</p>

<p style="margin-top: 1em">Variables <br>
Using variables to simplify rules.</p>

<p style="margin-top: 1em">makepp, mpp <br>
Command line syntax of the main utility.</p>

<p style="margin-top: 1em">makeppclean, mppc <br>
An efficient stand-alone cleanup script to remove files
generated by makepp.</p>

<p style="margin-top: 1em">makeppgraph, mppg <br>
A stand-alone utility to graphically analyze dependencies
and the reasons for a rebuild.</p>

<p style="margin-top: 1em">makeppinfo, mppi <br>
A stand-alone utility to readably dump the build info makepp
remembers about each file.</p>

<p style="margin-top: 1em">makepplog, mppl <br>
A stand-alone utility to analyze dependencies and the
reasons for a rebuild.</p>

<p style="margin-top: 1em">makeppreplay, mppr <br>
A stand-alone utility to repeat things makepp has done, but
much faster.</p>

<p style="margin-top: 1em">Index <br>
All keywords, functions and operators in makepp.</p>

<p style="margin-top: 1em">Features <br>
Automatic scanning for include files <br>
Makepp scans automatically for include files. This obviates
the need for tools like makedepend. Makepp&rsquo;s scanner
works even if the included files don&rsquo;t exist yet but
have <br>
to be built. (This is true no matter where on the include
path they come from, unlike programs that depend on
gcc&rsquo;s &quot;-MM -MG&quot; option.) Makepp has a
flexible system for <br>
doing this which is based on scanning the build command; you
can adapt it for other languages or build commands by
writing a Perl subroutine.</p>

<p style="margin-top: 1em">Better system for hierarchical
builds <br>
Makepp has a better system for handling builds involving
multiple directories and multiple makefiles. The traditional
technique is to have make invoke itself recursively in <br>
each directory. Depending on how complicated the
interdependencies are, several recursive passes are
sometimes needed. This makes the makefiles very complicated
if they <br>
guarantee a correct build. The real problem is that unless
dependencies are trivial (e.g., just one library file), it
is almost impossible to express accurately dependencies <br>
of targets in one makefile in terms of targets from the
other makefile. Unix make isn&rsquo;t smart enough to
realize that a target in one makefile depends on a file that
is a <br>
target in a lower-level makefile; it can&rsquo;t take build
commands from the lower-level makefile while it is trying to
build the target in the upper-level makefile. So the usual
<br>
solution is to build everything that can be built with the
lower-level makefiles, hoping that that&rsquo;s adequate to
build everything that&rsquo;s needed for the upper-level
makefile.</p>

<p style="margin-top: 1em">Makepp loads all the needed
makefiles in at once, so it has no problem dealing with
situations where a file from one makefile depends on a file
produced by a different <br>
makefile. Makepp cd&rsquo;s automatically to the directory
containing the makefile before executing a command from a
makefile, so each makefile may be written independently <br>
without knowledge of the top-level build directory. But if
access to the root of your build tree is important (e.g.
because that&rsquo;s where your include directory resides),
you <br>
can name the makefile in that directory specially. Then
makepp gives you the path to that directory in a
variable.</p>

<p style="margin-top: 1em">Makepp also can figure out where
all the makefiles for the entire project are without being
told, if each makefile is in the same directory as the files
it is supposed to <br>
produce. This can also simplify makefiles a great deal.</p>

<p style="margin-top: 1em">For more details on building
with multiple directories, see &quot;Tips for multiple
directories&quot; in makepp_cookbook.</p>

<p style="margin-top: 1em">Reliable wildcards <br>
Makefiles can use wildcards reliably, because wild cards
match either files that exist, or files that do not yet
exist but makepp knows how to build. So even for a program
<br>
with dozens of modules, your entire makefile could simply
read something like this:</p>

<p style="margin-top: 1em">CXX = g++ <br>
CXXFLAGS = -g</p>

<p style="margin-top: 1em">%.o : %.c <br>
$(CXX) $(CXXFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">my_program: *.o <br>
$(CXX) $(inputs) -o $(output)</p>

<p style="margin-top: 1em">and this will work even if none
of the &quot;.o&quot; files have been built yet.</p>

<p style="margin-top: 1em">Reliable builds: remembers build
command <br>
Makepp keeps track of the build commands, so that if
compilation options change, files are automatically rebuilt.
This is important to guarantee correct builds. (This idea
<br>
was taken from Bob Sidebothem&rsquo;s &quot;cons&quot;
utility, which was described in the Perl Journal in 1998 and
is available from CPAN.)</p>

<p style="margin-top: 1em">To illustrate why this is
important, consider the following structure definition:</p>

<p style="margin-top: 1em">class ABC { <br>
int x; <br>
#ifndef SPECIAL_OPTION <br>
int y; <br>
#endif <br>
int z; <br>
};</p>

<p style="margin-top: 1em">Now suppose you decide to turn
on the &quot;SPECIAL_OPTION&quot; option by adding
&quot;-DSPECIAL_OPTION&quot; to the command line. A
recompilation of everything is needed, but a traditional
<br>
Unix make will not detect this, and will only recompile
source files which have actually changed. As a result, some
of your modules will be compiled with -DSPECIAL_OPTION, <br>
and others won&rsquo;t. After a very frustrating debugging
session, you will discover that all that needs to be done is
to rebuild everything. Then you will curse make and <br>
hopefully switch to an improved implementation of it, like
makepp. At least, that&rsquo;s what I did.</p>

<p style="margin-top: 1em">As another example, suppose that
you are working on a project which is pretty well debugged,
so it&rsquo;s usually compiled with &quot;-O2&quot;. Now you
run into a bug which you need to <br>
look at in the debugger. Code compiled with optimization is
difficult to examine in the debugger, so you want to
recompile your code so that you can look at it. If your <br>
makefile is set up to store the compiler options in the
usual variables, you can just do this:</p>

<p style="margin-top: 1em">makepp CFLAGS=-g CXXFLAGS=-g</p>

<p style="margin-top: 1em">and makepp will know that the
command line has changed for all the modules. Then when
you&rsquo;ve found your bug, just type</p>

<p style="margin-top: 1em">makepp</p>

<p style="margin-top: 1em">and it will be recompiled with
optimization. You don&rsquo;t need to type &quot;make
clean&quot; when you change build options.</p>

<p style="margin-top: 1em">Some makefiles (e.g., those for
the Linux kernel) go to incredible lengths to force
recompilation when the compile command changes. With makepp,
it&rsquo;s taken care of <br>
automatically--you don&rsquo;t have to do anything.</p>

<p style="margin-top: 1em">Reliable builds: exact matching
of signature <br>
By default, makepp doesn&rsquo;t merely ensure that all
targets are newer than all dependencies; if you replace a
dependency with an older file, makepp knows that it has to
rebuild <br>
the target, simply because the input file has changed. This
is another important feature to guarantee correct builds
which was taken from the &quot;cons&quot; utility.</p>

<p style="margin-top: 1em">Smart signature calculations
<br>
Some modifications to source files do not actually require a
rebuild. For example, if you just change a comment line, or
if you reindent some code, there is no particular <br>
reason to force a compilation. For C/C++ compilation, makepp
determines whether a file needs recompilation by computing a
cryptographic checksum of the file&rsquo;s contents, <br>
ignoring comments and whitespace, instead of looking at the
file time.</p>

<p style="margin-top: 1em">This is particularly useful if
you have include files that are generated by files that
change, and yet the generated include files themselves
seldom change. Suppose you have <br>
a complicated yacc grammar in your program, with a build
rule like this:</p>

<p style="margin-top: 1em">y.tab.c y.tab.h: parser.y <br>
yacc -d parser.y</p>

<p style="margin-top: 1em">Ordinarily, every time you make
even a tiny change to &quot;parser.y&quot;, every file that
depends on &quot;y.tab.h&quot; must be rebuilt since the
file time of &quot;y.tab.h&quot; has changed. However, <br>
most changes to &quot;parser.y&quot; won&rsquo;t actually
change the contents of &quot;y.tab.h&quot; (except possibly
a comment), so all that recompilation is unnecessary.</p>

<p style="margin-top: 1em">Repositories <br>
Makepp can automatically incorporate files from a different
directory tree (the &quot;repository&quot;) into the current
build tree as needed. (This idea was also taken from the
<br>
&quot;cons&quot; program.) This has several interesting
uses:</p>

<p style="margin-top: 1em">Variant builds <br>
Suppose you have been compiling your program with
optimization on and debugging off. Now a bug crops up and
you have to recompile everything with debugging enabled.
<br>
Once you find the bug, however, you&rsquo;re going to turn
debugging off and optimization back on, and with most make
programs you would have to recompile all the sources <br>
again, even the ones that did not change. The procedure
would look like this:</p>

<p style="margin-top: 1em">% makepp CFLAGS=-O2 # Compile
everything. <br>
# oops, bug discovered here <br>
% makepp CFLAGS=-g # Recompiles everything again. <br>
gdb my_program <br>
# ... find the bug <br>
% makepp CFLAGS=-O2 # Recompiles everything a third
time.</p>

<p style="margin-top: 1em">With makepp, you can simply cd
to an empty directory, and specify your original directory
as a repository. This will create new object files in the
empty directory, <br>
while leaving your old object files intact. Now you can find
the bug in the directory compiled with debug, fix it in your
original sources, and then go back to your <br>
original directory. Now only the few files that you changed
actually need to be recompiled.</p>

<p style="margin-top: 1em">The entire procedure would look
like this:</p>

<p style="margin-top: 1em">% makepp CFLAGS=-O2 # Compile
everything. <br>
# oops, bug discovered here <br>
% mkdir debugging <br>
% cd debugging <br>
% makepp -R .. CFLAGS=-g # Compile with debugging enabled,
but <br>
# put objects in debugging subdir. <br>
% gdb my_program <br>
# ... find the bug <br>
% cd .. # Back to original directory. <br>
% makepp CFLAGS=-O2 # Recompiles only those files <br>
# that you changed.</p>

<p style="margin-top: 1em">This can be a tremendous savings
in time if there are many modules.</p>

<p style="margin-top: 1em">Development team with common
sources <br>
Suppose you have a team of developers working on a standard
set of sources. Each developer is making independent
changes, but doesn&rsquo;t need to have a copy of the whole
<br>
source tree. Using makepp&rsquo;s repositories, you can have
each developer have copies only of the files he has changed.
Makepp will automatically and temporarily create <br>
symbolic links for the other files that have not been
changed to the corresponding files in the repository. It can
even do this for object files which exist in the <br>
repository and do not need to be recompiled in the
developer&rsquo;s individual directory.</p>

<p style="margin-top: 1em">Guarantee correct rules <br>
If your rules do somthing which you didn&rsquo;t tell makepp
about, the repository mechanism will not know to fetch those
things. So something that builds normally but fails <br>
from a repository tells you to fix your rules.</p>

<p style="margin-top: 1em">Automatic inference of needed
&quot;.o&quot; files <br>
Makepp can often infer exactly which objects are actually
necessary without being explicitly told. If you use this
feature, then if one of your source file includes
&quot;xx.h&quot;, <br>
and there is a file called &quot;xx.o&quot; that makepp
knows how to make, then makepp adds &quot;xx.o&quot; to the
link command line. I don&rsquo;t use non-shared libraries
now in many places where <br>
I used to, because makepp can automatically pick out the
modules I need.</p>

<p style="margin-top: 1em">Correct handling of aliases for
directories <br>
Makepp won&rsquo;t be confused by soft links to a directory
or by different relative filenames that refer to the same
file. All directory paths to a file are recognized,
including <br>
foo, ./foo, ../src/foo, /auto_mnt/somedisk/bob/src/foo, and
/users/bob/src/foo.</p>

<p style="margin-top: 1em">Filenames with special
characters <br>
Makepp can support filenames with colons or spaces or other
special characters that cause trouble for the traditional
make. Just surround the filename with quotes. (See <br>
&quot;Special characters&quot; in makepp_rules for
details.)</p>

<p style="margin-top: 1em">Extensible textual substutition
functions <br>
Makepp can use arbitrary Perl subroutines for textual
substitution in the makefile. If you know Perl, you are not
constrained at all by the set of makepp&rsquo;s builtin
textual <br>
manipulation functions.</p>

<p style="margin-top: 1em">You can also simply write Perl
code in your makefile. You can manipulate Make variables
with the full power of the entire Perl language. See
makepp_variables for details.</p>

<p style="margin-top: 1em">Logging of build decisions <br>
By default, makepp makes a log-file viewable with makepplog,
mppl that contains a description of every file that it tried
to build, what rule was used to build it, what it <br>
depended on, and (if the file was rebuilt) why. This can be
extremely useful for debugging a makefile--if you&rsquo;re
wondering why makepp decided to rebuild a file, or why it
<br>
didn&rsquo;t, you can just look in the log file where it
explains the decisions.</p>

<p style="margin-top: 1em">Improved support for parallel
builds <br>
Makepp supports parallel compilations, but (unlike other
make implementations) it won&rsquo;t mix output from
separate processes which are running simultaneously.</p>

<p style="margin-top: 1em">Synonyms for cryptic variables
<br>
Makepp supports easier-to-remember synonyms for the cryptic
make variables $@, $^, and $&lt;. See makepp_variables for
details.</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
MAKEPP(1)</p>
<hr>
</body>
</html>
