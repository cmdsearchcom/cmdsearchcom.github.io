<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:34:17 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PUNGI(1) Pungi PUNGI(1)</p>

<p style="margin-top: 1em">NAME <br>
pungi - Pungi Documentation</p>

<p style="margin-top: 1em">Contents:</p>

<p style="margin-top: 1em">ABOUT PUNGI <br>
[image: Pungi Logo] [image]</p>

<p style="margin-top: 1em">Pungi is a distribution compose
tool.</p>

<p style="margin-top: 1em">Composes are release snapshots
that contain release deliverables such as:</p>

<p style="margin-top: 1em">&Acirc;&middot; installation
trees</p>

<p style="margin-top: 1em">&Acirc;&middot; RPMs</p>

<p style="margin-top: 1em">&Acirc;&middot; repodata</p>

<p style="margin-top: 1em">&Acirc;&middot; comps</p>

<p style="margin-top: 1em">&Acirc;&middot; (bootable)
ISOs</p>

<p style="margin-top: 1em">&Acirc;&middot; kickstart
trees</p>

<p style="margin-top: 1em">&Acirc;&middot; anaconda
images</p>

<p style="margin-top: 1em">&Acirc;&middot; images for PXE
boot</p>

<p style="margin-top: 1em">Tool overview <br>
Pungi consists of multiple separate executables backed by a
common library.</p>

<p style="margin-top: 1em">The main entry-point is the
pungi-koji script. It loads the compose configuration and
kicks off the process. Composing itself is done in phases.
Each phase is responsible for <br>
generating some artifacts on disk and updating the compose
object that is threaded through all the phases.</p>

<p style="margin-top: 1em">Pungi itself does not actually
do that much. Most of the actual work is delegated to
separate executables. Pungi just makes sure that all the
commands are invoked in the appro&acirc; <br>
priate order and with correct arguments. It also moves the
artifacts to correct locations.</p>

<p style="margin-top: 1em">Links <br>
&Acirc;&middot; Upstream GIT: https://pagure.io/pungi/</p>

<p style="margin-top: 1em">&Acirc;&middot; Issue tracker:
https://pagure.io/pungi/issues</p>

<p style="margin-top: 1em">&Acirc;&middot; Questions can be
asked on #fedora-releng IRC channel on FreeNode</p>

<p style="margin-top: 1em">Origin of name <br>
The name Pungi comes from the instrument used to charm
snakes. Anaconda being the software Pungi was manipulating,
and anaconda being a snake, led to the referential
naming.</p>

<p style="margin-top: 1em">The first name, which was
suggested by Seth Vidal, was FIST, Fedora Installation
&lt;Something&gt; Tool. That name was quickly discarded and
replaced with Pungi.</p>

<p style="margin-top: 1em">There was also a bit of an
inside joke that when said aloud, it could sound like punji,
which is a sharpened stick at the bottom of a trap. Kind of
like software&acirc;&brvbar;</p>

<p style="margin-top: 1em">CONTRIBUTING TO PUNGI <br>
Set up development environment <br>
In order to work on Pungi, you should install recent version
of Fedora. These packages will have to installed:</p>

<p style="margin-top: 1em">&Acirc;&middot; createrepo</p>

<p style="margin-top: 1em">&Acirc;&middot; createrepo_c</p>

<p style="margin-top: 1em">&Acirc;&middot; cvs</p>

<p style="margin-top: 1em">&Acirc;&middot; genisoimage</p>

<p style="margin-top: 1em">&Acirc;&middot; gettext</p>

<p style="margin-top: 1em">&Acirc;&middot; git</p>

<p style="margin-top: 1em">&Acirc;&middot; isomd5sum</p>

<p style="margin-top: 1em">&Acirc;&middot; jigdo</p>

<p style="margin-top: 1em">&Acirc;&middot; kobo</p>

<p style="margin-top: 1em">&Acirc;&middot; kobo-rpmlib</p>

<p style="margin-top: 1em">&Acirc;&middot; koji</p>

<p style="margin-top: 1em">&Acirc;&middot;
libselinux-python</p>

<p style="margin-top: 1em">&Acirc;&middot; lorax</p>

<p style="margin-top: 1em">&Acirc;&middot;
python-jsonschema</p>

<p style="margin-top: 1em">&Acirc;&middot;
python-kickstart</p>

<p style="margin-top: 1em">&Acirc;&middot;
python-lockfile</p>

<p style="margin-top: 1em">&Acirc;&middot; python-lxml</p>

<p style="margin-top: 1em">&Acirc;&middot;
python2-multilib</p>

<p style="margin-top: 1em">&Acirc;&middot;
python-productmd</p>

<p style="margin-top: 1em">&Acirc;&middot; repoview</p>

<p style="margin-top: 1em">&Acirc;&middot; syslinux</p>

<p style="margin-top: 1em">&Acirc;&middot; yum</p>

<p style="margin-top: 1em">&Acirc;&middot; yum-utils</p>

<p style="margin-top: 1em">For running unit tests, these
packages are recommended as well:</p>

<p style="margin-top: 1em">&Acirc;&middot; python-mock</p>

<p style="margin-top: 1em">&Acirc;&middot; python-nose</p>

<p style="margin-top: 1em">&Acirc;&middot;
python-nose-cov</p>

<p style="margin-top: 1em">While being difficult, it is
possible to work on Pungi using virtualenv. Install
python-virtualenvwrapper and use following steps. It will
link system libraries into the virtual <br>
environment and install all packages preferably from PyPI or
from tarball. You will still need to install all of the
non-Python packages above as they are used by calling an
exe&acirc; <br>
cutable.</p>

<p style="margin-top: 1em">$ mkvirtualenv pungienv <br>
$ for pkg in koji rpm rpmUtils pykickstart selinux
createrepo yum urlgrabber; do ln -vs &quot;$(deactivate
&amp;&amp; python -c &rsquo;import os, &rsquo;$pkg&rsquo;;
print
os.path.dirname(&rsquo;$pkg&rsquo;.__file__)&rsquo;)&quot;
&quot;$(virtualenvwrapper_get_site_packages_dir)&quot;; done
<br>
$ for pkg in _selinux deltarpm _deltarpm krbV sqlitecachec
_sqlitecache; do ln -vs &quot;$(deactivate &amp;&amp; python
-c &rsquo;import os, &rsquo;$pkg&rsquo;; print
&rsquo;$pkg&rsquo;.__file__&rsquo;)&quot;
&quot;$(virtualenvwrapper_get_site_packages_dir)&quot;; done
<br>
$ PYCURL_SSL_LIBRARY=nss pip install pycurl --no-binary
:all: <br>
$ pip install lxml pyopenssl mock sphinx setuptools nose
nose-cov productmd jsonschema requests lockfile
python-multilib kobo</p>

<p style="margin-top: 1em">Now you should be able to run
all existing tests.</p>

<p style="margin-top: 1em">Developing <br>
Currently the development workflow for Pungi is on master
branch:</p>

<p style="margin-top: 1em">&Acirc;&middot; Make your own
fork at https://pagure.io/pungi</p>

<p style="margin-top: 1em">&Acirc;&middot; Clone your fork
locally (replacing $USERNAME with your own):</p>

<p style="margin-top: 1em">git clone
git@pagure.io:forks/$USERNAME/pungi.git</p>

<p style="margin-top: 1em">&Acirc;&middot; cd into your
local clone and add the remote upstream for rebasing:</p>

<p style="margin-top: 1em">cd pungi <br>
git remote add upstream git@pagure.io:pungi.git</p>

<p style="margin-top: 1em">NOTE: <br>
This workflow assumes that you never git commit directly to
the master branch of your fork. This will make more sense
when we cover rebasing below.</p>

<p style="margin-top: 1em">&Acirc;&middot; create a topic
branch based on master:</p>

<p style="margin-top: 1em">git branch my_topic_branch
master <br>
git checkout my_topic_branch</p>

<p style="margin-top: 1em">&Acirc;&middot; Make edits,
changes, add new features, etc. and then make sure to pull
from upstream master and rebase before submitting a pull
request:</p>

<p style="margin-top: 1em"># lets just say you edited
setup.py for sake of argument <br>
git checkout my_topic_branch</p>

<p style="margin-top: 1em"># make changes to setup.py <br>
git add setup.py <br>
git commit -s -m &quot;added awesome feature to
setup.py&quot;</p>

<p style="margin-top: 1em"># now we rebase <br>
git checkout master <br>
git pull --rebase upstream master <br>
git push origin master <br>
git push origin --tags <br>
git checkout my_topic_branch <br>
git rebase master</p>

<p style="margin-top: 1em"># resolve merge conflicts if any
as a result of your development in <br>
# your topic branch <br>
git push origin my_topic_branch</p>

<p style="margin-top: 1em">NOTE: <br>
In order to for your commit to be merged, you must sign-off
on it. Use -s option when running git commit.</p>

<p style="margin-top: 1em">&Acirc;&middot; Create pull
request in the pagure.io web UI</p>

<p style="margin-top: 1em">&Acirc;&middot; For convenience,
here is a bash shell function that can be placed in your
~/.bashrc and called such as pullupstream pungi-4-devel that
will automate a large portion of the <br>
rebase steps from above:</p>

<p style="margin-top: 1em">pullupstream () { <br>
if [[ -z &quot;$1&quot; ]]; then <br>
printf &quot;Error: must specify a branch name (e.g. -
master, devel)0 <br>
else <br>
pullup_startbranch=$(git describe --contains --all HEAD)
<br>
git checkout $1 <br>
git pull --rebase upstream master <br>
git push origin $1 <br>
git push origin --tags <br>
git checkout ${pullup_startbranch} <br>
fi <br>
}</p>

<p style="margin-top: 1em">Testing <br>
You must write unit tests for any new code (except for
trivial changes). Any code without sufficient test coverage
may not be merged.</p>

<p style="margin-top: 1em">To run all existing tests,
suggested method is to use nosetests. With additional
options, it can generate code coverage. To make sure even
tests from executable files are run, <br>
don&rsquo;t forget to use the --exe option.</p>

<p style="margin-top: 1em">$ make test <br>
$ make test-cover</p>

<p style="margin-top: 1em"># Running single test file <br>
$ python tests/test_arch.py [TestCase...]</p>

<p style="margin-top: 1em">In the tests/ directory there is
a shell script test_compose.sh that you can use to try and
create a miniature compose on dummy data. The actual data
will be created by running <br>
make test-data in project root.</p>

<p style="margin-top: 1em">$ make test-data <br>
$ make test-commpose</p>

<p style="margin-top: 1em">This testing compose does not
actually use all phases that are available, and there is no
checking that the result is correct. It only tells you
whether it crashed or not.</p>

<p style="margin-top: 1em">NOTE: <br>
Even when it finishes successfully, it may print errors
about repoclosure on Server-Gluster.x86_64 in test phase.
This is not a bug.</p>

<p style="margin-top: 1em">Documenting <br>
You must write documentation for any new features and
functional changes. Any code without sufficient
documentation may not be merged.</p>

<p style="margin-top: 1em">To generate the documentation,
run make doc in project root.</p>

<p style="margin-top: 1em">TESTING PUNGI <br>
Test Data <br>
Tests require test data and not all of it is available in
git. You must create test repositories before running the
tests:</p>

<p style="margin-top: 1em">make test-data</p>

<p style="margin-top: 1em">Requirements: createrepo_c,
rpmbuild</p>

<p style="margin-top: 1em">Unit Tests <br>
Unit tests cover functionality of Pungi python modules. You
can run all of them at once:</p>

<p style="margin-top: 1em">make test</p>

<p style="margin-top: 1em">which is shortcut to:</p>

<p style="margin-top: 1em">python2 setup.py test <br>
python3 setup.py test</p>

<p style="margin-top: 1em">You can alternatively run
individual tests:</p>

<p style="margin-top: 1em">cd tests <br>
./&lt;test&gt;.py [&lt;class&gt;[.&lt;test&gt;]]</p>

<p style="margin-top: 1em">Functional Tests <br>
Because compose is quite complex process and not everything
is covered with unit tests yet, the easiest way how to test
if your changes did not break anything badly is to start a
<br>
compose on a relatively small and well defined package
set:</p>

<p style="margin-top: 1em">cd tests <br>
./test_compose.sh</p>

<p style="margin-top: 1em">CONFIG FILE FORMAT <br>
The configuration file parser is provided by kobo</p>

<p style="margin-top: 1em">The file follows a Python-like
format. It consists of a sequence of variables that have a
value assigned to them.</p>

<p style="margin-top: 1em">variable = value</p>

<p style="margin-top: 1em">The variable names must follow
the same convention as Python code: start with a letter and
consist of letters, digits and underscores only.</p>

<p style="margin-top: 1em">The values can be either an
integer, float, boolean (True or False), a string or None.
Strings must be enclosed in either single or double
quotes.</p>

<p style="margin-top: 1em">Complex types are supported as
well.</p>

<p style="margin-top: 1em">A list is enclosed in square
brackets and items are separated with commas. There can be a
comma after the last item as well.</p>

<p style="margin-top: 1em">a_list = [1, <br>
2, <br>
3, <br>
]</p>

<p style="margin-top: 1em">A tuple works like a list, but
is enclosed in parenthesis.</p>

<p style="margin-top: 1em">a_tuple = (1,
&quot;one&quot;)</p>

<p style="margin-top: 1em">A dictionary is wrapped in
brackets, and consists of key: value pairs separated by
commas. The keys can only be formed from basic types (int,
float, string).</p>

<p style="margin-top: 1em">a_dict = { <br>
&rsquo;foo&rsquo;: &rsquo;bar&rsquo;, <br>
1: None <br>
}</p>

<p style="margin-top: 1em">The value assigned to a variable
can also be taken from another variable.</p>

<p style="margin-top: 1em">one = 1 <br>
another = one</p>

<p style="margin-top: 1em">Anything on a line after a #
symbol is ignored and functions as a comment.</p>

<p style="margin-top: 1em">Importing other files <br>
It is possible to include another configuration file. The
files are looked up relative to the currently processed
file.</p>

<p style="margin-top: 1em">The general structure of import
is:</p>

<p style="margin-top: 1em">from FILENAME import WHAT</p>

<p style="margin-top: 1em">The FILENAME should be just the
base name of the file without extension (which must be
.conf). WHAT can either be a comma separated list of
variables or *.</p>

<p style="margin-top: 1em"># Opens constants.conf and
brings PI and E into current scope. <br>
from constants import PI, E</p>

<p style="margin-top: 1em"># Opens common.conf and brings
everything defined in that file into current <br>
# file as well. <br>
from common import *</p>

<p style="margin-top: 1em">NOTE: <br>
Pungi will copy the configuration file given on command line
into the logs/ directory. Only this single file will be
copied, not any included ones. (Copying included files <br>
requires a fix in kobo library.)</p>

<p style="margin-top: 1em">The JSON-formatted dump of
configuration is correct though.</p>

<p style="margin-top: 1em">Formatting strings <br>
String interpolation is available as well. It uses a
%-encoded format. See Python documentation for more
details.</p>

<p style="margin-top: 1em">joined = &quot;%s %s&quot; %
(var_a, var_b)</p>

<p style="margin-top: 1em">a_dict = { <br>
&quot;fst&quot;: 1, <br>
&quot;snd&quot;: 2, <br>
} <br>
another = &quot;%(fst)s %(snd)s&quot; % a_dict</p>

<p style="margin-top: 1em">CONFIGURATION <br>
Please read productmd documentation for terminology and
other release and compose related details.</p>

<p style="margin-top: 1em">Minimal Config Example <br>
# RELEASE <br>
release_name = &quot;Fedora&quot; <br>
release_short = &quot;Fedora&quot; <br>
release_version = &quot;23&quot;</p>

<p style="margin-top: 1em"># GENERAL SETTINGS <br>
comps_file = &quot;comps-f23.xml&quot; <br>
variants_file = &quot;variants-f23.xml&quot;</p>

<p style="margin-top: 1em"># KOJI <br>
koji_profile = &quot;koji&quot; <br>
runroot = False</p>

<p style="margin-top: 1em"># PKGSET <br>
sigkeys = [None] <br>
pkgset_source = &quot;koji&quot; <br>
pkgset_koji_tag = &quot;f23&quot;</p>

<p style="margin-top: 1em"># CREATEREPO <br>
createrepo_checksum = &quot;sha256&quot;</p>

<p style="margin-top: 1em"># GATHER <br>
gather_source = &quot;comps&quot; <br>
gather_method = &quot;deps&quot; <br>
greedy_method = &quot;build&quot; <br>
check_deps = False</p>

<p style="margin-top: 1em"># BUILDINSTALL <br>
bootable = True <br>
buildinstall_method = &quot;lorax&quot;</p>

<p style="margin-top: 1em">Release <br>
Following mandatory options describe a release.</p>

<p style="margin-top: 1em">Options <br>
release_name [mandatory] <br>
(str) -- release name</p>

<p style="margin-top: 1em">release_short [mandatory] <br>
(str) -- release short name, without spaces and special
characters</p>

<p style="margin-top: 1em">release_version [mandatory] <br>
(str) -- release version</p>

<p style="margin-top: 1em">release_type = &quot;ga&quot;
<br>
(str) -- release type, &quot;ga&quot; or
&quot;updates&quot;</p>

<p style="margin-top: 1em">release_is_layered = False <br>
(bool) -- typically False for an operating system, True
otherwise</p>

<p style="margin-top: 1em">release_internal = False <br>
(bool) -- whether the compose is meant for public
consumption</p>

<p style="margin-top: 1em">Example <br>
release_name = &quot;Fedora&quot; <br>
release_short = &quot;Fedora&quot; <br>
release_version = &quot;23&quot; <br>
# release_type = &quot;ga&quot;</p>

<p style="margin-top: 1em">Base Product <br>
Base product options are optional and we need to them only
if we&rsquo;re composing a layered product built on another
(base) product.</p>

<p style="margin-top: 1em">Options <br>
base_product_name <br>
(str) -- base product name</p>

<p style="margin-top: 1em">base_product_short <br>
(str) -- base product short name, without spaces and special
characters</p>

<p style="margin-top: 1em">base_product_version <br>
(str) -- base product major version</p>

<p style="margin-top: 1em">base_product_type =
&quot;ga&quot; <br>
(str) -- base product type, &quot;ga&quot;,
&quot;updates&quot; etc., for full list see documentation of
productmd.</p>

<p style="margin-top: 1em">Example <br>
release_name = &quot;RPM Fusion&quot; <br>
release_short = &quot;rf&quot; <br>
release_version = &quot;23.0&quot;</p>

<p style="margin-top: 1em">release_is_layered = True</p>

<p style="margin-top: 1em">base_product_name =
&quot;Fedora&quot; <br>
base_product_short = &quot;Fedora&quot; <br>
base_product_version = &quot;23&quot;</p>

<p style="margin-top: 1em">General Settings <br>
Options <br>
comps_file [mandatory] <br>
(scm_dict, str or None) -- reference to comps XML file with
installation groups</p>

<p style="margin-top: 1em">variants_file [mandatory] <br>
(scm_dict or str) -- reference to variants XML file that
defines release variants and architectures</p>

<p style="margin-top: 1em">failable_deliverables [optional]
<br>
(list) -- list which deliverables on which variant and
architecture can fail and not abort the whole compose. This
only applies to buildinstall and iso parts. All other <br>
artifacts can be configured in their respective part of
configuration.</p>

<p style="margin-top: 1em">Please note that * as a wildcard
matches all architectures but src.</p>

<p style="margin-top: 1em">comps_filter_environments
[optional] <br>
(bool) -- When set to False, the comps files for variants
will not have their environments filtered to match the
variant.</p>

<p style="margin-top: 1em">tree_arches <br>
([str]) -- list of architectures which should be included;
if undefined, all architectures from variants.xml will be
included</p>

<p style="margin-top: 1em">tree_variants <br>
([str]) -- list of variants which should be included; if
undefined, all variants from variants.xml will be
included</p>

<p style="margin-top: 1em">repoclosure_backend <br>
(str) -- Select which tool should be used to run repoclosure
over created repositories. By default yum is used, but you
can switch to dnf. Please note that when dnf is <br>
used, the build dependencies check is skipped.</p>

<p style="margin-top: 1em">Example <br>
comps_file = { <br>
&quot;scm&quot;: &quot;git&quot;, <br>
&quot;repo&quot;:
&quot;https://git.fedorahosted.org/git/comps.git&quot;, <br>
&quot;branch&quot;: None, <br>
&quot;file&quot;: &quot;comps-f23.xml.in&quot;, <br>
}</p>

<p style="margin-top: 1em">variants_file = { <br>
&quot;scm&quot;: &quot;git&quot;, <br>
&quot;repo&quot;: &quot;https://pagure.io/pungi-fedora.git
&quot;, <br>
&quot;branch&quot;: None, <br>
&quot;file&quot;: &quot;variants-fedora.xml&quot;, <br>
}</p>

<p style="margin-top: 1em">failable_deliverables = [ <br>
(&rsquo;^.*$&rsquo;, { <br>
# Buildinstall can fail on any variant and any arch <br>
&rsquo;*&rsquo;: [&rsquo;buildinstall&rsquo;], <br>
&rsquo;src&rsquo;: [&rsquo;buildinstall&rsquo;], <br>
# Nothing on i386 blocks the compose <br>
&rsquo;i386&rsquo;: [&rsquo;buildinstall&rsquo;,
&rsquo;iso&rsquo;, &rsquo;live&rsquo;], <br>
}) <br>
]</p>

<p style="margin-top: 1em">tree_arches =
[&quot;x86_64&quot;] <br>
tree_variants = [&quot;Server&quot;]</p>

<p style="margin-top: 1em">Image Naming <br>
Both image name and volume id are generated based on the
configuration. Since the volume id is limited to 32
characters, there are more settings available. The process
for gen&acirc; <br>
erating volume id is to get a list of possible formats and
try them sequentially until one fits in the length limit. If
substitutions are configured, each attempted volume id <br>
will be modified by it.</p>

<p style="margin-top: 1em">For layered products, the
candidate formats are first
image_volid_layered_product_formats followed by
image_volid_formats. Otherwise, only image_volid_formats are
tried.</p>

<p style="margin-top: 1em">If no format matches the length
limit, an error will be reported and compose aborted.</p>

<p style="margin-top: 1em">Options <br>
There a couple common format specifiers available for both
the options:</p>

<p style="margin-top: 1em">&Acirc;&middot; compose_id</p>

<p style="margin-top: 1em">&Acirc;&middot;
release_short</p>

<p style="margin-top: 1em">&Acirc;&middot; version</p>

<p style="margin-top: 1em">&Acirc;&middot; date</p>

<p style="margin-top: 1em">&Acirc;&middot; respin</p>

<p style="margin-top: 1em">&Acirc;&middot; type</p>

<p style="margin-top: 1em">&Acirc;&middot; type_suffix</p>

<p style="margin-top: 1em">&Acirc;&middot; label</p>

<p style="margin-top: 1em">&Acirc;&middot;
label_major_version</p>

<p style="margin-top: 1em">&Acirc;&middot; variant</p>

<p style="margin-top: 1em">&Acirc;&middot; arch</p>

<p style="margin-top: 1em">&Acirc;&middot; disc_type</p>

<p style="margin-top: 1em">image_name_format [optional]
<br>
(str) -- Python&rsquo;s format string to serve as template
for image names</p>

<p style="margin-top: 1em">This format will be used for all
phases generating images. Currently that means createiso,
live_images and buildinstall.</p>

<p style="margin-top: 1em">Available extra keys are:</p>

<p style="margin-top: 1em">&Acirc;&middot; disc_num</p>

<p style="margin-top: 1em">&Acirc;&middot; suffix</p>

<p style="margin-top: 1em">image_volid_formats [optional]
<br>
(list) -- A list of format strings for generating volume
id.</p>

<p style="margin-top: 1em">The extra available keys
are:</p>

<p style="margin-top: 1em">&Acirc;&middot;
base_product_short</p>

<p style="margin-top: 1em">&Acirc;&middot;
base_product_version</p>


<p style="margin-top: 1em">image_volid_layered_product_formats
[optional] <br>
(list) -- A list of format strings for generating volume id
for layered products. The keys available are the same as for
image_volid_formats.</p>

<p style="margin-top: 1em">volume_id_substitutions
[optional] <br>
(dict) -- A mapping of string replacements to shorten the
volume id.</p>

<p style="margin-top: 1em">disc_types [optional] <br>
(dict) -- A mapping for customizing disc_type used in image
names.</p>

<p style="margin-top: 1em">Available keys are:</p>

<p style="margin-top: 1em">&Acirc;&middot; boot -- for
boot.iso images created in buildinstall phase</p>

<p style="margin-top: 1em">&Acirc;&middot; live -- for
images created by live_images phase</p>

<p style="margin-top: 1em">&Acirc;&middot; dvd -- for
images created by createiso phase</p>

<p style="margin-top: 1em">&Acirc;&middot; ostree -- for
ostree installer images</p>

<p style="margin-top: 1em">Default values are the same as
the keys.</p>

<p style="margin-top: 1em">Example <br>
# Image name respecting Fedora&rsquo;s image naming policy
<br>
image_name_format =
&quot;%(release_short)s-%(variant)s-%(disc_type)s-%(arch)s-%(version)s%(suffix)s&quot;
<br>
# Use the same format for volume id <br>
image_volid_formats = [ <br>

&quot;%(release_short)s-%(variant)s-%(disc_type)s-%(arch)s-%(version)s&quot;
<br>
] <br>
# No special handling for layered products, use same format
as for regular images <br>
image_volid_layered_product_formats = [] <br>
# Replace &quot;Cloud&quot; with &quot;C&quot; in volume id
etc. <br>
volume_id_substitutions = { <br>
&rsquo;Cloud&rsquo;: &rsquo;C&rsquo;, <br>
&rsquo;Alpha&rsquo;: &rsquo;A&rsquo;, <br>
&rsquo;Beta&rsquo;: &rsquo;B&rsquo;, <br>
&rsquo;TC&rsquo;: &rsquo;T&rsquo;, <br>
}</p>

<p style="margin-top: 1em">disc_types = { <br>
&rsquo;boot&rsquo;: &rsquo;netinst&rsquo;, <br>
&rsquo;live&rsquo;: &rsquo;Live&rsquo;, <br>
&rsquo;dvd&rsquo;: &rsquo;DVD&rsquo;, <br>
}</p>

<p style="margin-top: 1em">Signing <br>
If you want to sign deliverables generated during pungi run
like RPM wrapped images. You must provide few configuration
options:</p>

<p style="margin-top: 1em">signing_command [optional] <br>
(str) -- Command that will be run with a koji build as a
single argument. This command must not require any user
interaction. If you need to pass a password for a signing
<br>
key to the command, do this via command line option of the
command and use string formatting syntax
%(signing_key_password)s. (See
signing_key_password_file).</p>

<p style="margin-top: 1em">signing_key_id [optional] <br>
(str) -- ID of the key that will be used for the signing.
This ID will be used when crafting koji paths to signed
files (kojipkgs.fedoraproject.org/pack&acirc; <br>
ages/NAME/VER/REL/data/signed/KEYID/..).</p>

<p style="margin-top: 1em">signing_key_password_file
[optional] <br>
(str) -- Path to a file with password that will be formatted
into signing_command string via %(signing_key_password)s
string format syntax (if used). Because pungi config <br>
is usualy stored in git and is part of compose logs we
don&rsquo;t want password to be included directly in the
config. Note: If - string is used instead of a filename,
then <br>
you will be asked for the password interactivelly right
after pungi starts.</p>

<p style="margin-top: 1em">Example <br>
signing_command =
&rsquo;~/git/releng/scripts/sigulsign_unsigned.py -vv
--password=%(signing_key_password)s fedora-24&rsquo; <br>
signing_key_id = &rsquo;81b46521&rsquo; <br>
signing_key_password_file =
&rsquo;~/password_for_fedora-24_key&rsquo;</p>

<p style="margin-top: 1em">Git URLs <br>
In multiple places the config requires URL of a Git
repository to download some file from. This URL is passed on
to Koji. It is possible to specify which commit to use using
this <br>
syntax:</p>


<p style="margin-top: 1em">git://git.example.com/git/repo-name.git?#&lt;rev_spec&gt;</p>

<p style="margin-top: 1em">The &lt;rev_spec&gt; pattern can
be replaced with actual commit SHA, a tag name, HEAD to
indicate that tip of default branch should be used or
origin/&lt;branch_name&gt; to use tip of arbi&acirc; <br>
trary branch.</p>

<p style="margin-top: 1em">If the URL specifies a branch or
HEAD, Pungi will replace it with the actual commit SHA. This
will later show up in Koji tasks and help with tracing what
particular inputs were <br>
used.</p>

<p style="margin-top: 1em">NOTE: <br>
The origin must be specified because of the way Koji works
with the repository. It will clone the repository then
switch to requested state with git reset --hard REF. Since
no <br>
local branches are created, we need to use full
specification including the name of the remote.</p>

<p style="margin-top: 1em">Createrepo Settings <br>
Options <br>
createrepo_checksum <br>
(str) -- specify checksum type for createrepo; expected
values: sha512, sha256, sha. Defaults to sha256.</p>

<p style="margin-top: 1em">createrepo_c = True <br>
(bool) -- use createrepo_c (True) or legacy createrepo
(False)</p>

<p style="margin-top: 1em">createrepo_deltas = False <br>
(bool) -- generate delta RPMs against an older compose. This
needs to be used together with --old-composes command line
argument.</p>

<p style="margin-top: 1em">createrepo_use_xz = False <br>
(bool) -- whether to pass --xz to the createrepo command.
This will cause the SQLite databases to be compressed with
xz.</p>

<p style="margin-top: 1em">product_id = None <br>
(scm_dict) -- If specified, it should point to a directory
with certificates &lt;variant_uid&gt;-&lt;arch&gt;-*.pem.
This certificate will be injected into the repository.</p>

<p style="margin-top: 1em">product_id_allow_missing = False
<br>
(bool) -- When product_id is used and a certificate for some
variant is missing, an error will be reported by default.
Use this option to instead ignore the missing cer&acirc;
<br>
tificate.</p>

<p style="margin-top: 1em">Example <br>
createrepo_checksum = &quot;sha&quot;</p>

<p style="margin-top: 1em">Package Set Settings <br>
Options <br>
sigkeys <br>
([str or None]) -- priority list of sigkeys, None means
unsigned</p>

<p style="margin-top: 1em">pkgset_source [mandatory] <br>
(str) -- &quot;koji&quot; (any koji instance) or
&quot;repos&quot; (arbitrary yum repositories)</p>

<p style="margin-top: 1em">pkgset_koji_tag [mandatory] <br>
(str|[str]) -- tag(s) to read package set from</p>

<p style="margin-top: 1em">pkgset_koji_inherit = True <br>
(bool) -- inherit builds from parent tags; we can turn it
off only if we have all builds tagged in a single tag</p>

<p style="margin-top: 1em">pkgset_repos <br>
(dict) -- A mapping of architectures to repositories with
RPMs: {arch: [repo]}. Only use when pkgset_source =
&quot;repos&quot;.</p>

<p style="margin-top: 1em">Example <br>
sigkeys = [None] <br>
pkgset_source = &quot;koji&quot; <br>
pkgset_koji_tag = &quot;f23&quot;</p>

<p style="margin-top: 1em">Buildinstall Settings <br>
Script or process that creates bootable images with Anaconda
installer is historically called buildinstall.</p>

<p style="margin-top: 1em">Options <br>
bootable <br>
(bool) -- whether to run the buildinstall phase</p>

<p style="margin-top: 1em">buildinstall_method <br>
(str) -- &quot;lorax&quot; (f16+, rhel7+) or
&quot;buildinstall&quot; (older releases)</p>

<p style="margin-top: 1em">buildinstall_upgrade_image
[deprecated] <br>
(bool) -- use noupgrade with lorax_options instead</p>

<p style="margin-top: 1em">lorax_options <br>
(list) -- special options passed on to lorax.</p>

<p style="margin-top: 1em">Format: [(variant_uid_regex,
{arch|*: {option: name}})].</p>

<p style="margin-top: 1em">Recognized options are:</p>

<p style="margin-top: 1em">&Acirc;&middot; bugurl -- str
(default None)</p>

<p style="margin-top: 1em">&Acirc;&middot; nomacboot --
bool (default True)</p>

<p style="margin-top: 1em">&Acirc;&middot; noupgrade --
bool (default True)</p>

<p style="margin-top: 1em">buildinstall_kickstart <br>
(scm_dict) -- If specified, this kickstart file will be
copied into each file and pointed to in boot
configuration.</p>

<p style="margin-top: 1em">Example <br>
bootable = True <br>
buildinstall_method = &quot;lorax&quot;</p>

<p style="margin-top: 1em"># Enables macboot on x86_64 for
all variants and builds upgrade images <br>
# everywhere. <br>
lorax_options = [ <br>
(&quot;^.*$&quot;, { <br>
&quot;x86_64&quot;: { <br>
&quot;nomacboot&quot;: False <br>
} <br>
&quot;*&quot;: { <br>
&quot;noupgrade&quot;: False <br>
} <br>
}) <br>
]</p>

<p style="margin-top: 1em">NOTE: <br>
It is advised to run buildinstall (lorax) in koji, i.e. with
runroot enabled for clean build environments, better
logging, etc.</p>

<p style="margin-top: 1em">WARNING: <br>
Lorax installs RPMs into a chroot. This involves running
%post scriptlets and they frequently run executables in the
chroot. If we&rsquo;re composing for multiple architectures,
we <br>
must use runroot for this reason.</p>

<p style="margin-top: 1em">Gather Settings <br>
Options <br>
gather_source [mandatory] <br>
(str) -- from where to read initial package list; expected
values: &quot;comps&quot;, &quot;none&quot;</p>

<p style="margin-top: 1em">gather_method [mandatory] <br>
(str) -- Options are deps and nodeps. Specifies whether
package dependencies should be pulled in as well.</p>

<p style="margin-top: 1em">gather_fulltree = False <br>
(bool) -- When set to True all RPMs built from an SRPM will
always be included. Only use when gather_method =
&quot;deps&quot;.</p>

<p style="margin-top: 1em">gather_selfhosting = False <br>
(bool) -- When set to True, Pungi will build a self-hosting
tree by following build dependencies. Only use when
gather_method = &quot;deps&quot;.</p>

<p style="margin-top: 1em">greedy_method <br>
(str) -- This option controls how package requirements are
satisfied in case a particular Requires has multiple
candidates.</p>

<p style="margin-top: 1em">&Acirc;&middot; none -- the best
packages is selected to satisfy the dependency and only that
one is pulled into the compose</p>

<p style="margin-top: 1em">&Acirc;&middot; all -- packages
that provide the symbol are pulled in</p>

<p style="margin-top: 1em">&Acirc;&middot; build -- the
best package is selected, and then all packages from the
same build that provide the symbol are pulled in</p>

<p style="margin-top: 1em">NOTE: <br>
As an example let&rsquo;s work with this situation: a
package in the compose has Requires: foo. There are three
packages with Provides: foo: pkg-a, pkg-b-provider-1 and
<br>
pkg-b-provider-2. The pkg-b-* packages are build from the
same source package. Best match determines pkg-b-provider-1
as best matching package.</p>

<p style="margin-top: 1em">&Acirc;&middot; With
greedy_method = &quot;none&quot; only pkg-b-provider-1 will
be pulled in.</p>

<p style="margin-top: 1em">&Acirc;&middot; With
greedy_method = &quot;all&quot; all three packages will be
pulled in.</p>

<p style="margin-top: 1em">&Acirc;&middot; With
greedy_method = &quot;build&quot;
&lsquo;&lsquo;pkg-b-provider-1 and pkg-b-provider-2 will be
pulled in.</p>

<p style="margin-top: 1em">gather_backend = yum <br>
(str) -- Either yum or dnf. This changes the entire codebase
doing dependency solving, so it can change the result in
unpredictable ways.</p>

<p style="margin-top: 1em">Particularly the multilib work
is performed differently by using python-multilib library.
Please refer to multilib option to see the differences.</p>

<p style="margin-top: 1em">multilib_methods [deprecated]
<br>
([str]) -- use multilib instead to configure this
per-variant</p>

<p style="margin-top: 1em">multilib_arches [deprecated]
<br>
([str] or None) -- use multilib to implicitly configure
this: if a variant on any arch has non-empty multilib
methods, it is automatically eligible</p>

<p style="margin-top: 1em">multilib <br>
(list) -- mapping of variant regexes and arches to list of
multilib methods</p>

<p style="margin-top: 1em">Available methods are:</p>

<p style="margin-top: 1em">&Acirc;&middot; none -- no
package matches this method</p>

<p style="margin-top: 1em">&Acirc;&middot; all -- all
packages match this method</p>

<p style="margin-top: 1em">&Acirc;&middot; runtime --
packages that install some shared object file (*.so.*) will
match.</p>

<p style="margin-top: 1em">&Acirc;&middot; devel --
packages whose name ends with -devel or --static suffix will
be matched. When dnf is used, this method automatically
enables runtime method as well. With <br>
yum backend this method also uses a hardcoded blacklist and
whitelist.</p>

<p style="margin-top: 1em">&Acirc;&middot; kernel --
packages providing kernel or kernel-devel match this method
(only in yum backend)</p>

<p style="margin-top: 1em">&Acirc;&middot; yaboot -- only
yaboot package on ppc arch matches this (only in yum
backend)</p>

<p style="margin-top: 1em">additional_packages <br>
(list) -- additional packages to be included in a variant
and architecture; format: [(variant_uid_regex, {arch|*:
[package_globs]})]</p>

<p style="margin-top: 1em">filter_packages <br>
(list) -- packages to be excluded from a variant and
architecture; format: [(variant_uid_regex, {arch|*:
[package_globs]})]</p>

<p style="margin-top: 1em">filter_system_release_packages
<br>
(bool) -- for each variant, figure out the best system
release package and filter out all others. This will not
work if a variant needs more than one system release
pack&acirc; <br>
age. In such case, set this option to False.</p>

<p style="margin-top: 1em">gather_prepopulate = None <br>
(scm_dict) -- If specified, you can use this to add
additional packages. The format of the file pointed to by
this option is a JSON mapping {variant_uid: {arch: {build:
<br>
[package]}}}. Packages added through this option can not be
removed by filter_packages.</p>

<p style="margin-top: 1em">multilib_blacklist <br>
(dict) -- multilib blacklist; format: {arch|*:
[package_globs]}. The patterns are tested with fnmatch, so
shell globbing is used (not regular expression).</p>

<p style="margin-top: 1em">multilib_whitelist <br>
(dict) -- multilib blacklist; format: {arch|*:
[package_names]}. The whitelist must contain exact package
names; there are no wildcards or pattern matching.</p>

<p style="margin-top: 1em">gather_lookaside_repos = [] <br>
(list) -- lookaside repositories used for package gathering;
format: [(variant_uid_regex, {arch|*: [repo_urls]})]</p>

<p style="margin-top: 1em">hashed_directories = False <br>
(bool) -- put packages into &quot;hashed&quot; directories,
for example Packages/k/kernel-4.0.4-301.fc22.x86_64.rpm</p>

<p style="margin-top: 1em">check_deps = True <br>
(bool) -- Set to False if you don&rsquo;t want the compose
to abort when some package has broken dependencies.</p>

<p style="margin-top: 1em">gather_source_mapping <br>
(str) -- Only use when gather_source = &quot;json&quot;. The
value should be a path to JSON file with following mapping:
{variant: {arch: {rpm_name: [rpm_arch|None]}}}.</p>

<p style="margin-top: 1em">Example <br>
gather_source = &quot;comps&quot; <br>
gather_method = &quot;deps&quot; <br>
greedy_method = &quot;build&quot; <br>
check_deps = False <br>
hashed_directories = True</p>

<p style="margin-top: 1em">additional_packages = [ <br>
# bz#123456 <br>
(&rsquo;^(Workstation|Server)$&rsquo;, { <br>
&rsquo;*&rsquo;: [ <br>
&rsquo;grub2&rsquo;, <br>
&rsquo;kernel&rsquo;, <br>
], <br>
}), <br>
]</p>

<p style="margin-top: 1em">filter_packages = [ <br>
# bz#111222 <br>
(&rsquo;^.*$&rsquo;, { <br>
&rsquo;*&rsquo;: [ <br>
&rsquo;kernel-doc&rsquo;, <br>
], <br>
}), <br>
]</p>

<p style="margin-top: 1em">multilib = [ <br>
(&rsquo;^Server$&rsquo;, { <br>
&rsquo;x86_64&rsquo;: [&rsquo;devel&rsquo;,
&rsquo;runtime&rsquo;] <br>
}) <br>
]</p>

<p style="margin-top: 1em">multilib_blacklist = { <br>
&quot;*&quot;: [ <br>
&quot;gcc&quot;, <br>
], <br>
}</p>

<p style="margin-top: 1em">multilib_whitelist = { <br>
&quot;*&quot;: [ <br>
&quot;alsa-plugins-*&quot;, <br>
], <br>
}</p>

<p style="margin-top: 1em"># gather_lookaside_repos = [
<br>
# (&rsquo;^.*$&rsquo;, { <br>
# &rsquo;x86_64&rsquo;: [ <br>
#
&quot;https://dl.fedoraproject.org/pub/fedora/linux/releases/22/Everything/x86_64/os/&quot;,
<br>
#
&quot;https://dl.fedoraproject.org/pub/fedora/linux/releases/22/Everything/source/SRPMS/&quot;,
<br>
# ] <br>
# }), <br>
# ]</p>

<p style="margin-top: 1em">NOTE: <br>
It is a good practice to attach bug/ticket numbers to
additional_packages, filter_packages, multilib_blacklist and
multilib_whitelist to track decisions.</p>

<p style="margin-top: 1em">Koji Settings <br>
Options <br>
koji_profile <br>
(str) -- koji profile name</p>

<p style="margin-top: 1em">runroot [mandatory] <br>
(bool) -- run some tasks such as buildinstall or createiso
in koji build root (True) or locally (False)</p>

<p style="margin-top: 1em">runroot_channel <br>
(str) -- name of koji channel</p>

<p style="margin-top: 1em">runroot_tag <br>
(str) -- name of koji build tag used for runroot</p>

<p style="margin-top: 1em">runroot_weights <br>
(dict) -- customize task weights for various runroot tasks.
The values in the mapping should be integers, the keys can
be selected from the following list. By default no <br>
weight is assigned and Koji picks the default one according
to policy.</p>

<p style="margin-top: 1em">&Acirc;&middot; buildinstall</p>

<p style="margin-top: 1em">&Acirc;&middot; createiso</p>

<p style="margin-top: 1em">&Acirc;&middot; ostree</p>

<p style="margin-top: 1em">&Acirc;&middot;
ostree_installer</p>

<p style="margin-top: 1em">Example <br>
koji_profile = &quot;koji&quot; <br>
runroot = True <br>
runroot_channel = &quot;runroot&quot; <br>
runroot_tag = &quot;f23-build&quot;</p>

<p style="margin-top: 1em">Extra Files Settings <br>
Options <br>
extra_files <br>
(list) -- references to external files to be placed in os/
directory and media; format: [(variant_uid_regex, {arch|*:
[scm_dicts]})]</p>

<p style="margin-top: 1em">Example <br>
extra_files = [ <br>
(&rsquo;^.*$&rsquo;, { <br>
&rsquo;*&rsquo;: [ <br>
# GPG keys <br>
{ <br>
&quot;scm&quot;: &quot;rpm&quot;, <br>
&quot;repo&quot;: &quot;fedora-repos&quot;, <br>
&quot;branch&quot;: None, <br>
&quot;file&quot;: [ <br>
&quot;/etc/pki/rpm-gpg/RPM-GPG-KEY-22-fedora&quot;, <br>
], <br>
&quot;target&quot;: &quot;&quot;, <br>
}, <br>
# GPL <br>
{ <br>
&quot;scm&quot;: &quot;git&quot;, <br>
&quot;repo&quot;:
&quot;https://pagure.io/pungi-fedora&quot;, <br>
&quot;branch&quot;: None, <br>
&quot;file&quot;: [ <br>
&quot;GPL&quot;, <br>
], <br>
&quot;target&quot;: &quot;&quot;, <br>
}, <br>
], <br>
}), <br>
]</p>

<p style="margin-top: 1em">Extra Files Metadata <br>
If extra files are specified a metadata file,
extra_files.json, is placed in the os/ directory and media.
The checksums generated are determined by media_checksums
option. This <br>
metadata file is in the format:</p>

<p style="margin-top: 1em">{ <br>
&quot;header&quot;: {&quot;version&quot;: &quot;1.0}, <br>
&quot;data&quot;: [ <br>
{ <br>
&quot;file&quot;: &quot;GPL&quot;, <br>
&quot;checksums&quot;: { <br>
&quot;sha256&quot;:
&quot;8177f97513213526df2cf6184d8ff986c675afb514d4e68a404010521b880643&quot;
<br>
}, <br>
&quot;size&quot;: 18092 <br>
}, <br>
{ <br>
&quot;file&quot;: &quot;release-notes/notes.html&quot;, <br>
&quot;checksums&quot;: { <br>
&quot;sha256&quot;:
&quot;82b1ba8db522aadf101dca6404235fba179e559b95ea24ff39ee1e5d9a53bdcb&quot;
<br>
}, <br>
&quot;size&quot;: 1120 <br>
} <br>
] <br>
}</p>

<p style="margin-top: 1em">Productimg Settings <br>
Product images are placed on installation media and provide
additional branding and Anaconda changes specific to product
variants.</p>

<p style="margin-top: 1em">Options <br>
productimg = False <br>
(bool) -- create product images; requires bootable=True</p>

<p style="margin-top: 1em">productimg_install_class <br>
(scm_dict, str) -- reference to install class file</p>

<p style="margin-top: 1em">productimg_po_files <br>
(scm_dict, str) -- reference to a directory with po files
for install class translations</p>

<p style="margin-top: 1em">Example <br>
productimg = True <br>
productimg_install_class = { <br>
&quot;scm&quot;: &quot;git&quot;, <br>
&quot;repo&quot;:
&quot;http://git.example.com/productimg.git&quot;, <br>
&quot;branch&quot;: None, <br>
&quot;file&quot;: &quot;fedora23/%(variant_id)s.py&quot;,
<br>
} <br>
productimg_po_files = { <br>
&quot;scm&quot;: &quot;git&quot;, <br>
&quot;repo&quot;:
&quot;http://git.example.com/productimg.git&quot;, <br>
&quot;branch&quot;: None, <br>
&quot;dir&quot;: &quot;po&quot;, <br>
}</p>

<p style="margin-top: 1em">CreateISO Settings <br>
Options <br>
createiso_skip = False <br>
(list) -- mapping that defines which variants and arches to
skip during createiso; format: [(variant_uid_regex, {arch|*:
True})]</p>

<p style="margin-top: 1em">create_jigdo = True <br>
(bool) -- controls the creation of jigdo from ISO</p>

<p style="margin-top: 1em">create_optional_isos = False
<br>
(bool) -- when set to True, ISOs will be created even for
optional variants. By default only variants with type
variant or layered-product will get ISOs.</p>

<p style="margin-top: 1em">iso_size = 4700000000 <br>
(int|str) -- size of ISO image. The value should either be
an integer meaning size in bytes, or it can be a string with
k, M, G suffix (using multiples of 1024).</p>

<p style="margin-top: 1em">split_iso_reserve = 10MiB <br>
(int|str) -- how much free space should be left on each
disk. The format is the same as for iso_size option.</p>

<p style="margin-top: 1em">NOTE: <br>
Source architecture needs to be listed explicitly. Excluding
&rsquo;*&rsquo; applies only on binary arches. Jigdo causes
significant increase of time to ISO creation.</p>

<p style="margin-top: 1em">Example <br>
createiso_skip = [ <br>
(&rsquo;^Workstation$&rsquo;, { <br>
&rsquo;*&rsquo;: True, <br>
&rsquo;src&rsquo;: True <br>
}), <br>
]</p>

<p style="margin-top: 1em">Automatic generation of version
and release <br>
Version and release values for certain artifacts can be
generated automatically based on release version, compose
label, date, type and respin. This can be used to shorten
the <br>
config and keep it the same for multiple uses.</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;Compose ID &acirc; Label &acirc; Version &acirc;
Release &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;F-Rawhide-20170406.n.0 &acirc; - &acirc; Rawhide
&acirc; 20170406.n.0 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;F-26-20170329.1 &acirc; Alpha-1.6 &acirc; 26_Alpha
&acirc; 1.6 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;F-Atomic-25-20170407.0 &acirc; RC-20170407.0 &acirc;
25 &acirc; 20170407.0 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;F-Atomic-25-20170407.0 &acirc; - &acirc; 25 &acirc;
20170407.0 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">All non-RC milestones from label
get appended to the version. For release either label is
used or date, type and respin.</p>

<p style="margin-top: 1em">Common options for Live Images,
Live Media and Image Build <br>
All images can have ksurl, version, release and target
specified. Since this can create a lot of duplication, there
are global options that can be used instead.</p>

<p style="margin-top: 1em">For each of the phases, if the
option is not specified for a particular deliverable, an
option named &lt;PHASE_NAME&gt;_&lt;OPTION&gt; is checked.
If that is not specified either, the last <br>
fallback is global_&lt;OPTION&gt;. If even that is unset,
the value is considered to not be specified.</p>

<p style="margin-top: 1em">The kickstart URL is configured
by these options.</p>

<p style="margin-top: 1em">&Acirc;&middot; global_ksurl --
global fallback setting</p>

<p style="margin-top: 1em">&Acirc;&middot;
live_media_ksurl</p>

<p style="margin-top: 1em">&Acirc;&middot;
image_build_ksurl</p>

<p style="margin-top: 1em">&Acirc;&middot;
live_images_ksurl</p>

<p style="margin-top: 1em">Target is specified by these
settings. For live images refer to live_target.</p>

<p style="margin-top: 1em">&Acirc;&middot; global_target --
global fallback setting</p>

<p style="margin-top: 1em">&Acirc;&middot;
live_media_target</p>

<p style="margin-top: 1em">&Acirc;&middot;
image_build_target</p>

<p style="margin-top: 1em">Version is specified by these
options. If no version is set, a default value will be
provided according to automatic versioning.</p>

<p style="margin-top: 1em">&Acirc;&middot; global_version
-- global fallback setting</p>

<p style="margin-top: 1em">&Acirc;&middot;
live_media_version</p>

<p style="margin-top: 1em">&Acirc;&middot;
image_build_version</p>

<p style="margin-top: 1em">&Acirc;&middot;
live_images_version</p>

<p style="margin-top: 1em">Release is specified by these
options. If set to a magic value to
!RELEASE_FROM_LABEL_DATE_TYPE_RESPIN, a value will be
generated according to automatic versioning.</p>

<p style="margin-top: 1em">&Acirc;&middot; global_release
-- global fallback setting</p>

<p style="margin-top: 1em">&Acirc;&middot;
live_media_release</p>

<p style="margin-top: 1em">&Acirc;&middot;
image_build_release</p>

<p style="margin-top: 1em">&Acirc;&middot;
live_images_release</p>

<p style="margin-top: 1em">Each configuration block can
also optionally specify a failable key. For live images it
should have a boolean value. For live media and image build
it should be a list of strings <br>
containing architectures that are optional. If any
deliverable fails on an optional architecture, it will not
abort the whole compose. If the list contains only
&quot;*&quot;, all arches <br>
will be substituted.</p>

<p style="margin-top: 1em">Live Images Settings <br>
live_target <br>
(str) -- Koji build target for which to build the images.
This gets passed to koji spin-livecd.</p>

<p style="margin-top: 1em">live_images <br>
(list) -- Configuration for the particular image. The
elements of the list should be tuples (variant_uid_regex,
{arch|*: config}). The config should be a dict with these
<br>
keys:</p>

<p style="margin-top: 1em">&Acirc;&middot; kickstart
(str)</p>

<p style="margin-top: 1em">&Acirc;&middot; ksurl (str)
[optional] -- where to get the kickstart from</p>

<p style="margin-top: 1em">&Acirc;&middot; name (str)</p>

<p style="margin-top: 1em">&Acirc;&middot; version
(str)</p>

<p style="margin-top: 1em">&Acirc;&middot; repo (str|[str])
-- repos specified by URL or variant UID</p>

<p style="margin-top: 1em">&Acirc;&middot; specfile (str)
-- for images wrapped in RPM</p>

<p style="margin-top: 1em">&Acirc;&middot; scratch (bool)
-- only RPM-wrapped images can use scratch builds, but by
default this is turned off</p>

<p style="margin-top: 1em">&Acirc;&middot; type (str) --
what kind of task to start in Koji. Defaults to live meaning
koji spin-livecd will be used. Alternative option is
appliance corresponding to koji <br>
spin-appliance.</p>

<p style="margin-top: 1em">&Acirc;&middot; sign (bool) --
only RPM-wrapped images can be signed</p>

<p style="margin-top: 1em">Deprecated options:</p>

<p style="margin-top: 1em">&Acirc;&middot; additional_repos
-- deprecated, use repo instead</p>

<p style="margin-top: 1em">&Acirc;&middot; repo_from --
deprecated, use repo instead</p>

<p style="margin-top: 1em">live_images_no_rename <br>
(bool) -- When set to True, filenames generated by Koji will
be used. When False, filenames will be generated based on
image_name_format configuration option.</p>

<p style="margin-top: 1em">Live Media Settings <br>
live_media <br>
(dict) -- configuration for koji spin-livemedia; format:
{variant_uid_regex: [{opt:value}]}</p>

<p style="margin-top: 1em">Required options:</p>

<p style="margin-top: 1em">&Acirc;&middot; name (str)</p>

<p style="margin-top: 1em">&Acirc;&middot; version
(str)</p>

<p style="margin-top: 1em">&Acirc;&middot; target (str)</p>

<p style="margin-top: 1em">&Acirc;&middot; arches ([str])
-- what architectures to build the media for; by default
uses all arches for the variant.</p>

<p style="margin-top: 1em">&Acirc;&middot; kickstart (str)
-- name of the kickstart file</p>

<p style="margin-top: 1em">Available options:</p>

<p style="margin-top: 1em">&Acirc;&middot; ksurl (str)</p>

<p style="margin-top: 1em">&Acirc;&middot; ksversion
(str)</p>

<p style="margin-top: 1em">&Acirc;&middot; scratch
(bool)</p>

<p style="margin-top: 1em">&Acirc;&middot; release (str) --
a string with the release, or
!RELEASE_FROM_LABEL_DATE_TYPE_RESPIN to automatically
generate a suitable value. See automatic versioning for
details.</p>

<p style="margin-top: 1em">&Acirc;&middot; skip_tag
(bool)</p>

<p style="margin-top: 1em">&Acirc;&middot; repo (str|[str])
-- repos specified by URL or variant UID</p>

<p style="margin-top: 1em">&Acirc;&middot; title (str)</p>

<p style="margin-top: 1em">&Acirc;&middot;
install_tree_from (str) -- variant to take install tree
from</p>

<p style="margin-top: 1em">Deprecated options:</p>

<p style="margin-top: 1em">&Acirc;&middot; repo_from --
deprecated, use repo instead</p>

<p style="margin-top: 1em">Image Build Settings <br>
image_build <br>
(dict) -- config for koji image-build; format:
{variant_uid_regex: [{opt: value}]}</p>

<p style="margin-top: 1em">By default, images will be built
for each binary arch valid for the variant. The config can
specify a list of arches to narrow this down.</p>

<p style="margin-top: 1em">NOTE: <br>
Config can contain anything what is accepted by koji
image-build --config configfile.ini</p>

<p style="margin-top: 1em">Repo can be specified either as
a string or a list of strings. It will be automatically
transformed into format suitable for koji. A repo for the
currently built variant will <br>
be added as well.</p>

<p style="margin-top: 1em">If you explicitly set release to
!RELEASE_FROM_LABEL_DATE_TYPE_RESPIN, it will be replaced
with a value generated as described in automatic
versioning.</p>

<p style="margin-top: 1em">Please don&rsquo;t set
install_tree. This gets automatically set by pungi based on
current variant. You can use install_tree_from key to use
install tree from another variant.</p>

<p style="margin-top: 1em">The format attr is
[(&rsquo;image_type&rsquo;, &rsquo;image_suffix&rsquo;),
...]. See productmd documentation for list of supported
types and suffixes.</p>

<p style="margin-top: 1em">If ksurl ends with #HEAD, Pungi
will figure out the SHA1 hash of current HEAD and use that
instead.</p>

<p style="margin-top: 1em">Setting scratch to True will run
the koji tasks as scratch builds.</p>

<p style="margin-top: 1em">Example <br>
image_build = { <br>
&rsquo;^Server$&rsquo;: [ <br>
{ <br>
&rsquo;image-build&rsquo;: { <br>
&rsquo;format&rsquo;: [(&rsquo;docker&rsquo;,
&rsquo;tar.gz&rsquo;), (&rsquo;qcow2&rsquo;,
&rsquo;qcow2&rsquo;)] <br>
&rsquo;name&rsquo;:
&rsquo;fedora-qcow-and-docker-base&rsquo;, <br>
&rsquo;target&rsquo;: &rsquo;koji-target-name&rsquo;, <br>
&rsquo;ksversion&rsquo;: &rsquo;F23&rsquo;, # value from
pykickstart <br>
&rsquo;version&rsquo;: &rsquo;23&rsquo;, <br>
# correct SHA1 hash will be put into the URL below
automatically <br>
&rsquo;ksurl&rsquo;:
&rsquo;https://git.fedorahosted.org/git/spin-kickstarts.git?somedirectoryifany#HEAD&rsquo;,
<br>
&rsquo;kickstart&rsquo;: &quot;fedora-docker-base.ks&quot;,
<br>
&rsquo;repo&rsquo;:
[&quot;http://someextrarepos.org/repo&quot;,
&quot;ftp://rekcod.oi/repo&quot;], <br>
&rsquo;distro&rsquo;: &rsquo;Fedora-20&rsquo;, <br>
&rsquo;disk_size&rsquo;: 3,</p>

<p style="margin-top: 1em"># this is set automatically by
pungi to os_dir for given variant <br>
# &rsquo;install_tree&rsquo;: &rsquo;http://somepath&rsquo;,
<br>
}, <br>
&rsquo;factory-parameters&rsquo;: { <br>
&rsquo;docker_cmd&rsquo;: &quot;[ &rsquo;/bin/bash&rsquo;
]&quot;, <br>
&rsquo;docker_env&rsquo;: &quot;[
&rsquo;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&rsquo;
]&quot;, <br>
&rsquo;docker_labels&rsquo;: &quot;{&rsquo;Name&rsquo;:
&rsquo;fedora-docker-base&rsquo;, &rsquo;License&rsquo;:
u&rsquo;GPLv2&rsquo;, &rsquo;RUN&rsquo;: &rsquo;docker run
-it --rm ${OPT1} --privileged -v `pwd`:/atomicapp -v
/run:/run -v /:/host --net=host --name ${NAME} -e
NAME=${NAME} -e IMAGE=${IMAGE} ${IMAGE} -v ${OPT2} run
${OPT3} /atomicapp&rsquo;, &rsquo;Vendor&rsquo;:
&rsquo;Fedora Project&rsquo;, &rsquo;Version&rsquo;:
&rsquo;23&rsquo;, &rsquo;Architecture&rsquo;:
&rsquo;x86_64&rsquo; }&quot;, <br>
} <br>
}, <br>
{ <br>
&rsquo;image-build&rsquo;: { <br>
&rsquo;format&rsquo;: [(&rsquo;docker&rsquo;,
&rsquo;tar.gz&rsquo;), (&rsquo;qcow2&rsquo;,
&rsquo;qcow2&rsquo;)] <br>
&rsquo;name&rsquo;:
&rsquo;fedora-qcow-and-docker-base&rsquo;, <br>
&rsquo;target&rsquo;: &rsquo;koji-target-name&rsquo;, <br>
&rsquo;ksversion&rsquo;: &rsquo;F23&rsquo;, # value from
pykickstart <br>
&rsquo;version&rsquo;: &rsquo;23&rsquo;, <br>
# correct SHA1 hash will be put into the URL below
automatically <br>
&rsquo;ksurl&rsquo;:
&rsquo;https://git.fedorahosted.org/git/spin-kickstarts.git?somedirectoryifany#HEAD&rsquo;,
<br>
&rsquo;kickstart&rsquo;: &quot;fedora-docker-base.ks&quot;,
<br>
&rsquo;repo&rsquo;:
[&quot;http://someextrarepos.org/repo&quot;,
&quot;ftp://rekcod.oi/repo&quot;], <br>
&rsquo;distro&rsquo;: &rsquo;Fedora-20&rsquo;, <br>
&rsquo;disk_size&rsquo;: 3,</p>

<p style="margin-top: 1em"># this is set automatically by
pungi to os_dir for given variant <br>
# &rsquo;install_tree&rsquo;: &rsquo;http://somepath&rsquo;,
<br>
} <br>
}, <br>
{ <br>
&rsquo;image-build&rsquo;: { <br>
&rsquo;format&rsquo;:
[(&rsquo;qcow2&rsquo;,&rsquo;qcow2&rsquo;)] <br>
&rsquo;name&rsquo;: &rsquo;fedora-qcow-base&rsquo;, <br>
&rsquo;target&rsquo;: &rsquo;koji-target-name&rsquo;, <br>
&rsquo;ksversion&rsquo;: &rsquo;F23&rsquo;, # value from
pykickstart <br>
&rsquo;version&rsquo;: &rsquo;23&rsquo;, <br>
&rsquo;ksurl&rsquo;:
&rsquo;https://git.fedorahosted.org/git/spin-kickstarts.git?somedirectoryifany#HEAD&rsquo;,
<br>
&rsquo;kickstart&rsquo;: &quot;fedora-docker-base.ks&quot;,
<br>
&rsquo;distro&rsquo;: &rsquo;Fedora-23&rsquo;,</p>

<p style="margin-top: 1em"># only build this type of image
on x86_64 <br>
&rsquo;arches&rsquo;: [&rsquo;x86_64&rsquo;]</p>

<p style="margin-top: 1em"># Use install tree and repo from
Everything variant. <br>
&rsquo;install_tree_from&rsquo;: &rsquo;Everything&rsquo;,
<br>
&rsquo;repo&rsquo;: [&rsquo;Everything&rsquo;],</p>

<p style="margin-top: 1em"># Set release automatically.
<br>
&rsquo;release&rsquo;:
&rsquo;!RELEASE_FROM_LABEL_DATE_TYPE_RESPIN&rsquo;, <br>
} <br>
} <br>
] <br>
}</p>

<p style="margin-top: 1em">OSTree Settings <br>
The ostree phase of Pungi can create ostree repositories.
This is done by running rpm-ostree compose in a Koji runroot
environment. The ostree repository itself is not part of
<br>
the compose and should be located in another directory. Any
new packages in the compose will be added to the repository
with a new commit.</p>

<p style="margin-top: 1em">ostree (dict) -- a variant/arch
mapping of configuration. The format should be
[(variant_uid_regex, {arch|*: config_dict})].</p>

<p style="margin-top: 1em">The configuration dict for each
variant arch pair must have these keys:</p>

<p style="margin-top: 1em">&Acirc;&middot; treefile --
(str) Filename of configuration for rpm-ostree.</p>

<p style="margin-top: 1em">&Acirc;&middot; config_url --
(str) URL for Git repository with the treefile.</p>

<p style="margin-top: 1em">&Acirc;&middot; repo --
(str|dict|[str|dict]) repos specified by URL or variant UID
or a dict of repo options, baseurl is required in the
dict.</p>

<p style="margin-top: 1em">&Acirc;&middot; ostree_repo --
(str) Where to put the ostree repository</p>

<p style="margin-top: 1em">These keys are optional:</p>

<p style="margin-top: 1em">&Acirc;&middot;
keep_original_sources -- (bool) Keep the existing source
repos in the tree config file. If not enabled, all the
original source repos will be removed from the tree
con&acirc; <br>
fig file.</p>

<p style="margin-top: 1em">&Acirc;&middot; config_branch --
(str) Git branch of the repo to use. Defaults to master.</p>

<p style="margin-top: 1em">&Acirc;&middot; failable --
([str]) List of architectures for which this deliverable is
not release blocking.</p>

<p style="margin-top: 1em">&Acirc;&middot; update_summary
-- (bool) Update summary metadata after tree composing.
Defaults to False.</p>

<p style="margin-top: 1em">&Acirc;&middot; version -- (str)
Version string to be added as versioning metadata. If this
option is set to
!OSTREE_VERSION_FROM_LABEL_DATE_TYPE_RESPIN, a value will be
generated <br>
automatically as $VERSION.$RELEASE. See how those values are
created.</p>

<p style="margin-top: 1em">&Acirc;&middot; tag_ref --
(bool, default True) If set to False, a git reference will
not be created.</p>

<p style="margin-top: 1em">Deprecated options:</p>

<p style="margin-top: 1em">&Acirc;&middot; repo_from --
Deprecated, use repo instead.</p>

<p style="margin-top: 1em">&Acirc;&middot; source_repo_from
-- Deprecated, use repo instead.</p>

<p style="margin-top: 1em">&Acirc;&middot;
extra_source_repos -- Deprecated, use repo instead.</p>

<p style="margin-top: 1em">Example config <br>
ostree = [ <br>
(&quot;^Atomic$&quot;, { <br>
&quot;x86_64&quot;: { <br>
&quot;treefile&quot;:
&quot;fedora-atomic-docker-host.json&quot;, <br>
&quot;config_url&quot;:
&quot;https://git.fedorahosted.org/git/fedora-atomic.git&quot;,
<br>
&quot;repo&quot;: [ <br>
&quot;Server&quot;, <br>
&quot;http://example.com/repo/x86_64/os&quot;, <br>
{&quot;baseurl&quot;: &quot;Everything&quot;}, <br>
{&quot;baseurl&quot;:
&quot;http://example.com/linux/repo&quot;,
&quot;exclude&quot;: &quot;systemd-container&quot;}, <br>
], <br>
&quot;keep_original_sources&quot;: True, <br>
&quot;ostree_repo&quot;:
&quot;/mnt/koji/compose/atomic/Rawhide/&quot;, <br>
&quot;update_summary&quot;: True, <br>
# Automatically generate a reasonable version <br>
&quot;version&quot;:
&quot;!OSTREE_VERSION_FROM_LABEL_DATE_TYPE_RESPIN&quot;,
<br>
} <br>
}) <br>
]</p>

<p style="margin-top: 1em">Ostree Installer Settings <br>
The ostree_installer phase of Pungi can produce installer
image bundling an OSTree repository. This always runs in
Koji as a runroot task.</p>

<p style="margin-top: 1em">ostree_installer <br>
(dict) -- a variant/arch mapping of configuration. The
format should be [(variant_uid_regex, {arch|*:
config_dict})].</p>

<p style="margin-top: 1em">The configuration dict for each
variant arch pair must have this key:</p>

<p style="margin-top: 1em">These keys are optional:</p>

<p style="margin-top: 1em">&Acirc;&middot; repo --
(str|[str]) repos specified by URL or variant UID</p>

<p style="margin-top: 1em">&Acirc;&middot; release -- (str)
Release value to set for the installer image. Set to
!RELEASE_FROM_LABEL_DATE_TYPE_RESPIN to generate the value
automatically.</p>

<p style="margin-top: 1em">&Acirc;&middot; failable --
([str]) List of architectures for which this deliverable is
not release blocking.</p>

<p style="margin-top: 1em">These optional keys are passed
to lorax to customize the build.</p>

<p style="margin-top: 1em">&Acirc;&middot; installpkgs --
([str])</p>

<p style="margin-top: 1em">&Acirc;&middot; add_template --
([str])</p>

<p style="margin-top: 1em">&Acirc;&middot;
add_arch_template -- ([str])</p>

<p style="margin-top: 1em">&Acirc;&middot; add_template_var
-- ([str])</p>

<p style="margin-top: 1em">&Acirc;&middot;
add_arch_template_var -- ([str])</p>

<p style="margin-top: 1em">&Acirc;&middot; rootfs_size --
([str])</p>

<p style="margin-top: 1em">&Acirc;&middot; template_repo --
(str) Git repository with extra templates.</p>

<p style="margin-top: 1em">&Acirc;&middot; template_branch
-- (str) Branch to use from template_repo.</p>

<p style="margin-top: 1em">The templates can either be
absolute paths, in which case they will be used as
configured; or they can be relative paths, in which case
template_repo needs to point to a <br>
Git repository from which to take the templates.</p>

<p style="margin-top: 1em">Deprecated options:</p>

<p style="margin-top: 1em">&Acirc;&middot; repo_from --
Deprecated, use repo instead.</p>

<p style="margin-top: 1em">&Acirc;&middot; source_repo_from
-- Deprecated, use repo instead.</p>

<p style="margin-top: 1em">Example config <br>
ostree_installer = [ <br>
(&quot;^Atomic$&quot;, { <br>
&quot;x86_64&quot;: { <br>
&quot;repo&quot;: [ <br>
&quot;Everything&quot;, <br>
&quot;https://example.com/extra-repo1.repo&quot;, <br>
&quot;https://example.com/extra-repo2.repo&quot;, <br>
], <br>
&quot;release&quot;:
&quot;!RELEASE_FROM_LABEL_DATE_TYPE_RESPIN&quot;, <br>
&quot;installpkgs&quot;:
[&quot;fedora-productimg-atomic&quot;], <br>
&quot;add_template&quot;:
[&quot;atomic-installer/lorax-configure-repo.tmpl&quot;],
<br>
&quot;add_template_var&quot;: [ <br>
&quot;ostree_osname=fedora-atomic&quot;, <br>

&quot;ostree_ref=fedora-atomic/Rawhide/x86_64/docker-host&quot;,
<br>
], <br>
&quot;add_arch_template&quot;:
[&quot;atomic-installer/lorax-embed-repo.tmpl&quot;], <br>
&quot;add_arch_template_var&quot;: [ <br>

&quot;ostree_repo=https://kojipkgs.fedoraproject.org/compose/atomic/Rawhide/&quot;,
<br>
&quot;ostree_osname=fedora-atomic&quot;, <br>

&quot;ostree_ref=fedora-atomic/Rawhide/x86_64/docker-host&quot;,
<br>
] <br>
&rsquo;template_repo&rsquo;:
&rsquo;https://git.fedorahosted.org/git/spin-kickstarts.git&rsquo;,
<br>
&rsquo;template_branch&rsquo;: &rsquo;f24&rsquo;, <br>
} <br>
}) <br>
]</p>

<p style="margin-top: 1em">OSBS Settings <br>
Pungi can build docker images in OSBS. The build is
initiated through Koji container-build plugin. The base
image will be using RPMs from the current compose and a
Dockerfile <br>
from specified Git repository.</p>

<p style="margin-top: 1em">Please note that the image is
uploaded to a Docker v2 registry and not exported into
compose directory. There will be a metadata file in
compose/metadata/osbs.json with details <br>
about the built images (assuming they are not scratch
builds).</p>

<p style="margin-top: 1em">osbs (dict) -- a mapping from
variant regexes to configuration blocks. The format should
be {variant_uid_regex: [config_dict]}.</p>

<p style="margin-top: 1em">The configuration for each image
must have at least these keys:</p>

<p style="margin-top: 1em">&Acirc;&middot; url -- (str) URL
pointing to a Git repository with Dockerfile. Please see Git
URLs section for more details.</p>

<p style="margin-top: 1em">&Acirc;&middot; target -- (str)
A Koji target to build the image for.</p>

<p style="margin-top: 1em">&Acirc;&middot; git_branch --
(str) A branch in SCM for the Dockerfile. This is required
by OSBS to avoid race conditions when multiple builds from
the same repo are submitted at the <br>
same time. Please note that url should contain the branch or
tag name as well, so that it can be resolved to a particular
commit hash.</p>

<p style="margin-top: 1em">Optionally you can specify
failable. If it has a truthy value, failure to create the
image will not abort the whole compose.</p>

<p style="margin-top: 1em">NOTE: <br>
Once OSBS gains support for multiple architectures, the
usage of this option will most likely change to list
architectures that are allowed to fail.</p>

<p style="margin-top: 1em">The configuration will pass
other attributes directly to the Koji task. This includes
name, version, scratch and priority.</p>

<p style="margin-top: 1em">A value for yum_repourls will be
created automatically and point at a repository in the
current compose. You can add extra repositories with repo
key having a list of urls <br>
pointing to .repo files or just variant uid, Pungi will
create the .repo file for that variant. gpgkey can be
specified to enable gpgcheck in repo files for variants.</p>

<p style="margin-top: 1em">Example config <br>
osbs = { <br>
&quot;^Server$&quot;: { <br>
# required <br>
&quot;url&quot;:
&quot;git://example.com/dockerfiles.git?#HEAD&quot;, <br>
&quot;target&quot;: &quot;f24-docker-candidate&quot;, <br>
&quot;git_branch&quot;: &quot;f24-docker&quot;,</p>

<p style="margin-top: 1em"># optional <br>
&quot;name&quot;: &quot;fedora-docker-base&quot;, <br>
&quot;version&quot;: &quot;24&quot;, <br>
&quot;repo&quot;: [&quot;Everything&quot;,
&quot;https://example.com/extra-repo.repo&quot;], <br>
# This will result in three repo urls being passed to the
task. <br>
# They will be in this order: Server, Everything,
example.com/ <br>
&quot;gpgkey&quot;:
&rsquo;file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release&rsquo;,
<br>
} <br>
}</p>

<p style="margin-top: 1em">Media Checksums Settings <br>
media_checksums <br>
(list) -- list of checksum types to compute, allowed values
are anything supported by Python&rsquo;s hashlib module (see
documentation for details).</p>

<p style="margin-top: 1em">media_checksum_one_file <br>
(bool) -- when True, only one CHECKSUM file will be created
per directory; this option requires media_checksums to only
specify one type</p>

<p style="margin-top: 1em">media_checksum_base_filename
<br>
(str) -- when not set, all checksums will be save to a file
named either CHECKSUM or based on the digest type; this
option allows adding any prefix to that name</p>

<p style="margin-top: 1em">It is possible to use format
strings that will be replace by actual values. The allowed
keys are:</p>

<p style="margin-top: 1em">&Acirc;&middot; arch</p>

<p style="margin-top: 1em">&Acirc;&middot; compose_id</p>

<p style="margin-top: 1em">&Acirc;&middot; date</p>

<p style="margin-top: 1em">&Acirc;&middot; label</p>

<p style="margin-top: 1em">&Acirc;&middot;
label_major_version</p>

<p style="margin-top: 1em">&Acirc;&middot;
release_short</p>

<p style="margin-top: 1em">&Acirc;&middot; respin</p>

<p style="margin-top: 1em">&Acirc;&middot; type</p>

<p style="margin-top: 1em">&Acirc;&middot; type_suffix</p>

<p style="margin-top: 1em">&Acirc;&middot; version</p>

<p style="margin-top: 1em">&Acirc;&middot; version</p>

<p style="margin-top: 1em">For example, for Fedora the
prefix should be
%(release_short)s-%(variant)s-%(version)s-%(date)s%(type_suffix)s.%(respin)s.</p>

<p style="margin-top: 1em">Translate Paths Settings <br>
translate_paths <br>
(list) -- list of paths to translate; format: [(path,
translated_path)]</p>

<p style="margin-top: 1em">NOTE: <br>
This feature becomes useful when you need to transform
compose location into e.g. a HTTP repo which is can be
passed to koji image-build. The path part is normalized via
<br>
os.path.normpath().</p>

<p style="margin-top: 1em">Example config <br>
translate_paths = [ <br>
(&quot;/mnt/a&quot;, &quot;http://b/dir&quot;), <br>
]</p>

<p style="margin-top: 1em">Example usage <br>
&gt;&gt;&gt; from pungi.util import translate_paths <br>
&gt;&gt;&gt; print
translate_paths(compose_object_with_mapping,
&quot;/mnt/a/c/somefile&quot;) <br>
http://b/dir/c/somefile</p>

<p style="margin-top: 1em">Miscelanous Settings <br>
paths_module <br>
(str) -- Name of Python module implementing the same
interface as pungi.paths. This module can be used to
override where things are placed.</p>

<p style="margin-top: 1em">link_type = hardlink-or-copy
<br>
(str) -- Method of putting packages into compose
directory.</p>

<p style="margin-top: 1em">Available options:</p>

<p style="margin-top: 1em">&Acirc;&middot;
hardlink-or-copy</p>

<p style="margin-top: 1em">&Acirc;&middot; hardlink</p>

<p style="margin-top: 1em">&Acirc;&middot; copy</p>

<p style="margin-top: 1em">&Acirc;&middot; symlink</p>

<p style="margin-top: 1em">&Acirc;&middot;
abspath-symlink</p>

<p style="margin-top: 1em">skip_phases <br>
(list) -- List of phase names that should be skipped. The
same functionality is available via a command line
option.</p>

<p style="margin-top: 1em">release_discinfo_description
<br>
(str) -- Override description in .discinfo files. The value
is a format string accepting %(variant_name)s and %(arch)s
placeholders.</p>

<p style="margin-top: 1em">symlink_isos_to <br>
(str) -- If set, the ISO files from buildinstall, createiso
and live_images phases will be put into this destination,
and a symlink pointing to this location will be cre&acirc;
<br>
ated in actual compose directory.</p>

<p style="margin-top: 1em">PROGRESS NOTIFICATION <br>
Pungi has the ability to emit notification messages about
progress and general status of the compose. These can be
used to e.g. send messages to fedmsg. This is implemented by
<br>
actually calling a separate script.</p>

<p style="margin-top: 1em">The script will be called with
one argument describing action that just happened. A
JSON-encoded object will be passed to standard input to
provide more information about the <br>
event. At the very least, the object will contain a
compose_id key.</p>

<p style="margin-top: 1em">The script is invoked in compose
directory and can read other information there.</p>

<p style="margin-top: 1em">Currently these messages are
sent:</p>

<p style="margin-top: 1em">&Acirc;&middot; status-change --
when composing starts, finishes or fails; a status key is
provided to indicate details</p>

<p style="margin-top: 1em">&Acirc;&middot; phase-start --
on start of a phase</p>

<p style="margin-top: 1em">&Acirc;&middot; phase-stop --
when phase is finished</p>

<p style="margin-top: 1em">&Acirc;&middot;
createiso-targets -- with a list of images to be created</p>

<p style="margin-top: 1em">&Acirc;&middot;
createiso-imagedone -- when any single image is finished</p>

<p style="margin-top: 1em">&Acirc;&middot;
createiso-imagefail -- when any single image fails to
create</p>

<p style="margin-top: 1em">&Acirc;&middot; fail-to-start --
when there are incorrect CLI options or errors in
configuration file; this message does not contain compose_id
nor is it started in the compose directory <br>
(which does not exist yet)</p>

<p style="margin-top: 1em">&Acirc;&middot; ostree -- when a
new commit is created, this message will announce its hash
and the name of ref it is meant for.</p>

<p style="margin-top: 1em">For phase related messages
phase_name key is provided as well.</p>

<p style="margin-top: 1em">A pungi-fedmsg-notification
script is provided and understands this interface.</p>

<p style="margin-top: 1em">Setting it up <br>
The script should be provided as a command line argument
--notification-script.</p>


<p style="margin-top: 1em">--notification-script=pungi-fedmsg-notification</p>

<p style="margin-top: 1em">PHASES <br>
Each invocation of punji-koji consists of a set of phases.
[image: phase diagram] [image]</p>

<p style="margin-top: 1em">Most of the phases run
sequentially (left-to-right in the diagram), but there are
use cases where multiple phases run in parallel. This
happens for phases whose main point is to <br>
wait for a Koji task to finish.</p>

<p style="margin-top: 1em">Init <br>
The first phase to ever run. Can not be skipped. It prepares
the comps files for variants (by filtering out groups and
packages that should not be there).</p>

<p style="margin-top: 1em">Pkgset <br>
This phase loads a set of packages that should be composed.
It has two separate results: it prepares repos with packages
in work/ directory (one per arch) for further processing,
<br>
and it returns a data structure with mapping of packages to
architectures.</p>

<p style="margin-top: 1em">Buildinstall <br>
Spawns a bunch of threads, each of which runs either lorax
or buildinstall command (the latter coming from anaconda
package). The commands create boot.iso and other boot
configu&acirc; <br>
ration files. The image is finally linked into the compose/
directory as netinstall media.</p>

<p style="margin-top: 1em">The created images are also
needed for creating live media or other images in later
phases.</p>

<p style="margin-top: 1em">With lorax this phase runs one
task per variant.arch combination. For buildinstall command
there is only one task per architecture and product.img
should be used to customize the <br>
results.</p>

<p style="margin-top: 1em">Gather <br>
This phase uses data collected by pkgset phase and figures
out what packages should be in each variant. The basic
mapping can come from comps file, a JSON mapping or
addi&acirc; <br>
tional_packages config option. This inputs can then be
enriched by adding all dependencies. See gathering for
details.</p>

<p style="margin-top: 1em">Once the mapping is finalized,
the packages are linked to appropriate places and the
rpms.json manifest is created.</p>

<p style="margin-top: 1em">ExtraFiles <br>
This phase collects extra files from the configuration and
copies them to the compose directory. The files are
described by a JSON file in the compose subtree where the
files are <br>
copied. This metadata is meant to be distributed with the
data (on ISO images).</p>

<p style="margin-top: 1em">Createrepo <br>
This phase creates RPM repositories for each variant.arch
tree. It is actually reading the rpms.json manifest to
figure out which packages should be included.</p>

<p style="margin-top: 1em">OSTree <br>
Updates an ostree repository with a new commit with packages
from the compose. The repository lives outside of the
compose and is updated immediately. If the compose fails in
a <br>
later stage, the commit will not be reverted.</p>

<p style="margin-top: 1em">Implementation wise, this phase
runs rpm-ostree command in Koji runroot (to allow running on
different arches).</p>

<p style="margin-top: 1em">Productimg <br>
Creates product.img files for customizing the bootable media
created in buildinstall phase.</p>

<p style="margin-top: 1em">Createiso <br>
Generates ISO files and accumulates enough metadata to be
able to create image.json manifest. The file is however not
created in this phase, instead it is dumped in the <br>
pungi-koji script itself.</p>

<p style="margin-top: 1em">The files include a repository
with all RPMs from the variant. There will be multiple
images if the packages do not fit on a single image.</p>

<p style="margin-top: 1em">The image will be bootable if
buildinstall phase is enabled and the packages fit on a
single image.</p>

<p style="margin-top: 1em">There can also be images with
source repositories. These are never bootable.</p>

<p style="margin-top: 1em">LiveImages, LiveMedia <br>
Creates media in Koji with koji spin-livecd, koji
spin-appliance or koji spin-livemedia command. When the
media are finished, the images are copied into the compose/
directory <br>
and metadata for images is updated.</p>

<p style="margin-top: 1em">ImageBuild <br>
This phase wraps up koji image-build. It also updates the
metadata ultimately responsible for images.json
manifest.</p>

<p style="margin-top: 1em">OSBS <br>
This phase builds docker base images in OSBS.</p>

<p style="margin-top: 1em">The finished images are
available in registry provided by OSBS, but not downloaded
directly into the compose. The is metadata about the created
image in compose/meta&acirc; <br>
data/osbs.json.</p>

<p style="margin-top: 1em">OSTreeInstaller <br>
Creates bootable media that carry an ostree repository as a
payload. These images are created by running lorax with
special templates. Again it runs in Koji runroot.</p>

<p style="margin-top: 1em">ImageChecksum <br>
Responsible for generating checksums for the images. The
checksums are stored in image manifest as well as files on
disk. The list of images to be processed is obtained from
the <br>
image manifest. This way all images will get the same
checksums irrespective of the phase that created them.</p>

<p style="margin-top: 1em">Test <br>
This phase is supposed to run some sanity checks on the
finished compose.</p>

<p style="margin-top: 1em">The first test is to run
repoclosure on each repository. However, even if it fails,
the compose will still be considered a success. The actual
error has to be looked up in the <br>
compose logs directory.</p>

<p style="margin-top: 1em">The other test is to check all
images listed the metadata and verify that they look sane.
For ISO files headers are checked to verify the format is
correct, and for bootable <br>
media a check is run to verify they have properties that
allow booting.</p>

<p style="margin-top: 1em">GATHERING PACKAGES <br>
A compose created by Pungi consists of one or more variants.
A variant contains a subset of the content targeted at a
particular use case.</p>

<p style="margin-top: 1em">There are different types of
variants. The type affects how packages are gathered into
the variant.</p>

<p style="margin-top: 1em">The inputs for gathering are
defined by the gather_source option. It provides a list of
package names, comps groups names and a list of packages
that should be filtered out.</p>

<p style="margin-top: 1em">Next, gather_method defines how
the list is processed. For nodeps, the results from source
are used pretty much as is [1]. For deps method, a process
will be launched to figure <br>
out what dependencies are needed and those will be pulled
in.</p>

<p style="margin-top: 1em">[1] The lists are filtered based
on what packages are available in the package set, but
nothing else will be pulled in.</p>

<p style="margin-top: 1em">Variant types <br>
Variant <br>
is a base type that has no special behaviour.</p>

<p style="margin-top: 1em">Addon is built on top of a
regular variant. Any packages that should go to both the
addon and its parent will be removed from addon. Packages
that are only in addon but pulled <br>
in because of gather_fulltree option will be moved to
parent.</p>

<p style="margin-top: 1em">Integrated Layered Product <br>
works similarly to addon. Additionally, all packages from
addons on the same parent variant are removed integrated
layered products.</p>

<p style="margin-top: 1em">The main difference between an
addon and integrated layered product is that integrated
layered product has its own identity in the metadata
(defined with product name and <br>
version).</p>

<p style="margin-top: 1em">NOTE: <br>
There&rsquo;s also Layered Product as a term, but this is
not related to variants. It&rsquo;s used to describe a
product that is not a standalone operating system and is
instead <br>
meant to be used on some other base system.</p>

<p style="margin-top: 1em">Optional <br>
contains packages that complete the base variants&rsquo;
package set. It always has fulltree and selfhosting enabled,
so it contains build dependencies and packages which were
<br>
not specifically requested for base variant.</p>

<p style="margin-top: 1em">Some configuration options are
overridden for particular variant types.</p>

<p style="margin-top: 1em">Depsolving configuration <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;Variant &acirc; Fulltree &acirc; Selfhosting &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;base &acirc; configurable &acirc; configurable
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;addon/ILP &acirc; enabled &acirc; disabled &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;optional &acirc; enabled &acirc; enabled &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">AUTHOR <br>
Daniel Mach</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2016, Red Hat, Inc.</p>

<p style="margin-top: 1em">4.1 Jul 17, 2017 PUNGI(1)</p>
<hr>
</body>
</html>
