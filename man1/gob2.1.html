<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GOB2(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GOB2(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">GOB2(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
GOB2 - The GObject Builder
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>gob2</b> [ option ] ... file
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
GObject Builder is a simple preprocessor for easily creating GObject objects. It
  does not parse any C code and ignores any C errors. It is in spirit similar to
  things like lex or yacc. In some ways it also resembles java. But it is really
  just a simple preprocessor for creating GObjects for use in C or C++ and it is
  not a programming language.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-? -h --help</b></dt>
  <dd class="It-tag">Display a simple help screen.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag">Display version information</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w --exit-on-warn</b></dt>
  <dd class="It-tag">Exit with an error code even when you encounter a
    warning.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-exit-on-warn</b></dt>
  <dd class="It-tag">Exit with an error only on errors, not on warnings, this is
      the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--for-cpp</b></dt>
  <dd class="It-tag">Generate C++ code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-extern-c</b></dt>
  <dd class="It-tag">Never add the extern &quot;C&quot; to the header.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-gnu</b></dt>
  <dd class="It-tag">Never generate any code with GNU C extensions. However all
      the GNU C extensions are always wrapped in #ifdef __GNUC__, so code using
      them compiles correctly even on non-GNU compilers. This option is for
      purists only. (using GNU extensions some warnings are eliminated, some
      ugly hacks and there is better argument type safety, so it&#x00B4;s good
      to use them)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-touch</b></dt>
  <dd class="It-tag">Don&#x00B4;t touch output files unless they really changed
      (implies --no-touch-headers). Be careful with automake, see section
      PREVENTING SPURIOUS BUILDS.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-touch-headers</b></dt>
  <dd class="It-tag">Don&#x00B4;t touch the generated header file unless it
      really changed, this avoids spurious rebuilds, but can confuse some make
      systems (automake in particular), so it is not enabled by default. Private
      header is still touched even if unchanged however.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--always-private-header</b></dt>
  <dd class="It-tag">Always create a <b>&lt;basename&gt;-private.h</b> file,
      even if it would be empty.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ondemand-private-header</b></dt>
  <dd class="It-tag">Create the private header only if it would have something
      in it, that is, if there are some private data members or protected
      methods. This is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-private-header</b></dt>
  <dd class="It-tag">Never create a private header file. If we use any private
      data members, define the private data structure at the point in the .c
      source where the class definition begins.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--m4</b></dt>
  <dd class="It-tag">Preprocess source with m4. Following args will be passed to
      m4.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--m4-dir</b></dt>
  <dd class="It-tag">Print directory that will be searched for m4 files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n --no-write</b></dt>
  <dd class="It-tag">Do not write any output files, just check syntax of the
      input file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-lines</b></dt>
  <dd class="It-tag">Do not print out the &#x00B4;#line&#x00B4; statements into
      the output. Useful for debugging the auto-generated generated code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-self-alias</b></dt>
  <dd class="It-tag">Do not create the Self and SelfClass type aliases and the
      SELF, IS_SELF and SELF_CLASS macros.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-kill-underscores</b></dt>
  <dd class="It-tag">Do not remove the initial underscore from method
    names.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--always-private-struct</b></dt>
  <dd class="It-tag">Always include the private pointer in the public header
      file. This is useful for files which are part of a library and you want to
      reserve the right to add some private data members without breaking binary
      compatibility.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o --output-dir</b></dt>
  <dd class="It-tag">The directory into which output should be placed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--file-sep[=c]</b></dt>
  <dd class="It-tag">Replace default &#x00B4;-&#x00B4; file name separator. If
      no separator character is given then none is used. Only one character can
      be used.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="TYPENAMES"><a class="selflink" href="#TYPENAMES">TYPENAMES</a></h1>
Because we need to parse out different parts of the typename, sometimes you need
  to specify the typename with some special syntax. Types are specified in
  capitalized form and words are separated by &#x00B4;:&#x00B4;. The first word
  of the type (which can be empty) is the &quot;namespace&quot;. This fact is
  for example used for the type checking macro and the type macro. For
  &quot;Gtk:New:Button&quot;, the macros will be GTK_IS_NEW_BUTTON and
  GTK_TYPE_NEW_BUTTON. This colon separated format of typenames is used in the
  class declaration header and for method argument types.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OUTPUT_FILES"><a class="selflink" href="#OUTPUT_FILES">OUTPUT
  FILES</a></h1>
The filenames are created from the typename. The words are separated by
  &#x00B4;-&#x00B4; (this can be changed with <b>--file-sep</b> option) and all
  in lower case. For example for an object named &quot;Gtk:New:Button&quot;, the
  files are <b>gtk-new-button.c</b> and <b>gtk-new-button.h</b>. If you are
  using C++ mode, the output .c file will in fact be a .cc file. If you have any
  private data members, a private header file will also be created, called
  <b>&lt;basename&gt;-private.h</b> (for the example above it would be
  gtk-new-button-private.h). The public header file is created to be human
  readable and to be used as a reference to the object. The .c source file is
  not created as a human readable source and is littered with #line statements,
  which make the compiler attempt to point you to the right line in your .gob
  file in case of parsing errors. The output should not be edited by hand, and
  you should only edit the .gob file.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="INCLUDING_NORMAL_C_CODE_IN_THE_OUTPUT_FILES"><a class="selflink" href="#INCLUDING_NORMAL_C_CODE_IN_THE_OUTPUT_FILES">INCLUDING
  NORMAL C CODE IN THE OUTPUT FILES</a></h1>
To include some code directly in the output C file begin with &#x00B4;%{&#x00B4;
  on an empty line and end the code with a &#x00B4;%}&#x00B4; on an empty line.
  These sections will appear in the output files in the order they are given.
  There are several other <i>sections</i> to which you can put code. You can put
  it in the &#x00B4;header&#x00B4; section (which can be abbreviated
  &#x00B4;h&#x00B4;) and it will go into the public header file. You can also
  put it in the &#x00B4;privateheader&#x00B4; section (abbreviated
  &#x00B4;ph&#x00B4;) which will make the code go into the private header file.
  Sometimes you want some code (other includes) to appear before the extern
  &quot;C&quot; and the protecting define. To do this you can put them into the
  &#x00B4;headertop&#x00B4; (or &#x00B4;ht&#x00B4;) section. You may wish to
  include code or comments in all the files, which you can do by putting them
  into the &#x00B4;all&#x00B4; (or &#x00B4;a&#x00B4;) section. Similarly, code
  you wish to appear at the top of all files go in the &#x00B4;alltop&#x00B4;
  (or &#x00B4;at&#x00B4;) section. When you want code to appear as in alltop but
  only in the cfile you use the &#x00B4;ctop&#x00B4; (or &#x00B4;ct&#x00B4;)
  section. Note that ctop requires 2.0.18. Finally, &#x00B4;afterdecls&#x00B4;
  includes code between the declarations and the method implementations, but
  note that &#x00B4;afterdecls&#x00B4; requires version 2.0.16. For example:
<pre>
<div class="Pp"></div>
  %alltop{
        /* this will be at the very top of all output files */
  %}
<div class="Pp"></div>
  %ctop{
        /* this will be at the very top of the C file */
        /* Requires 2.0.18 */
  %}
<div class="Pp"></div>
  %headertop{
        /* this will be on top of the public header */
  %}
<div class="Pp"></div>
  %privateheader{
        /* this will go into the private header file */
  %}
<div class="Pp"></div>
  %h{
        /* will be included in the header */
        void somefunc(int i);
  %}
<div class="Pp"></div>
  %a{
        /* will be included in all files */
  %}
<div class="Pp"></div>
  %afterdecls{
        /* between the declarations and the method implementations */
        /* Requires gob version 2.0.16 */
  %}
<div class="Pp"></div>
  %{
        /* will be included in the C file */
        void somefunc(int i)
        {
              /* some code */
        }
  %}
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="INCLUDE_FILES"><a class="selflink" href="#INCLUDE_FILES">INCLUDE
  FILES</a></h1>
Gob will automatically include the class header file at the top of the .c source
  file. If you wish to include it somewhere else, put the include into some %{
  %} section above the class definition, and gob will not include it
  automatically. This way you can avoid circular includes and control where in
  the file do you want to include the header.
<div class="Pp"></div>
If you made any data members private, gob will also create a source file that
  will be called <b>&lt;basename&gt;-private.h</b>. Same rule as above applies
  for this just as it does for the regular header file. If you do explicitly
  include the regular header file, you should always include this private header
  file below it. That is, if you use any private data members. If you
  don&#x00B4;t, the private header file automatically includes the public header
  file, and thus the public header file will be indirectly included at the very
  top of the file.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="THE_CLASS_HEADER"><a class="selflink" href="#THE_CLASS_HEADER">THE
  CLASS HEADER</a></h1>
There can be only one class per input file. Defining a class is sort of like in
  Java, you define the class and write inline code directly into the class
  definition. To define a class you need to specify the new object name and the
  name of the object from which it is derived from, such as this &quot;class
  &lt;new type&gt; from &lt;parent type&gt; { &lt;class code&gt; }&quot;. For
  example:
<pre>
<div class="Pp"></div>
  class Gtk:New:Button from Gtk:Button {
	  &lt;class code&gt;
  }
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
To make an abstract class (to pass G_TYPE_FLAG_ABSTRACT) add
  &#x00B4;(abstract)&#x00B4; before the curly braces above. This works since
  version 2.0.13.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DATA_MEMBERS"><a class="selflink" href="#DATA_MEMBERS">DATA
  MEMBERS</a></h1>
There are five types of data members. Three of them are normal data members, one
  is class wide (global) in scope and one is a virtual one, usually linked to a
  normal data member or a class wide data member. The three normal data members
  are public, protected and private. Public and protected are basically just
  entries in the object structure, while private has it&#x00B4;s own dynamically
  allocated private structure. Protected members are always put after the public
  one in the structure and are marked protected in the header file. There is
  only one identifier allowed per typename unlike in normal C. Example:
<pre>
<div class="Pp"></div>
  public int i;
  private GtkWidget *h;
  protected long k;
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
Public and protected data members are accessed normally as members of the object
  struct. Example where &#x00B4;i&#x00B4; is as above a public data member:
<pre>
<div class="Pp"></div>
  object-&gt;i = 1;
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
The private data members are defined in a structure which is only available
  inside the .c file, or by including a private header file. You must access
  them using the structure _priv. Example where &#x00B4;h&#x00B4; is the private
  data member (as in the above example):
<pre>
<div class="Pp"></div>
  object-&gt;_priv-&gt;h = NULL;
<div class="Pp"></div>
</pre>
The _priv structure is defined in the <b>&lt;basename&gt;-private.h</b>. This
  file is automatically included if you don&#x00B4;t include it yourself. You
  should always explicitly include it in your .gob file if you explicitly also
  include the main header file. The reason it is a separate header file is that
  you can also include it in other places that need to access this objects
  private data, such as if you have the majority of functionality of an object
  in a separate .c file. Or if a derived object needs to access the protected
  methods.
<div class="Pp"></div>
In case you use the <b>--no-private-header</b> option, no private header file is
  created and you can only access the _priv pointer below the class definition
  in the .gob file.
<div class="Pp"></div>
Also note that this structure is dynamically allocated, and is freed in the
  finalize handler. If you override the finalized handler, your code will be run
  first and only then will the _priv structure be freed.
<div class="Pp"></div>
<b>Classwide data members:</b>
<div class="Pp"></div>
Sometimes you want a datamember to be shared by all objects. You then need the
  &quot;classwide&quot; scope keyword. So for example the following adds a
  global member foo:
<pre>
<div class="Pp"></div>
  classwide int foo;
<div class="Pp"></div>
</pre>
To access the member you can use the SELF_GET_CLASS macro (or
  YOUR_OBJECT_NAME_GET_CLASS) to get at the class. Thus the following would
  work:
<pre>
<div class="Pp"></div>
  SELF_GET_CLASS(object)-&gt;foo = 20;
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
<b>Automatic Initialization:</b>
<div class="Pp"></div>
You can automatically initialize the public private and protected data members
  without having to add an init method. The advantage here is that
  initialization is kept close to the definition of the data member and thus
  it&#x00B4;s easier to check. To do this, just add a &#x00B4;=&#x00B4; followed
  by a number or a token. It is also possible to include arbitrary C code for
  more elaborate initializations by putting it all in curly braces. Note that
  the curly braces will not be printed into the output, but since gob does not C
  parsing it needs them to figure out where the C code ends. The code will be
  inserted into the init method, above the user defined body. So for example the
  following will initialize an integer to -1 and a string with a newly allocated
  string of &quot;hello&quot;.
<pre>
<div class="Pp"></div>
  public int foo = -1;
  private char *bar = {g_strdup(&quot;hello&quot;)};
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
<b>Automatic Destruction:</b>
<div class="Pp"></div>
Most data stored as pointers needs to have a function called when the object is
  finalized to either free the data. Gob will let you define a function to be
  called on the data the object is finalized. This is achieved by putting
  &#x00B4;destroywith&#x00B4; followed by a function name after the variable
  definition. It is only called if the data you defined this on is not NULL, so
  you cans specify functions which do not handle NULL. It is very much like the
  GDestroyNotify function used in GTK+ and glib in many places. Unlike many
  other places, gob will not enforce any kind of type safety here so be a little
  bit more careful. Any function you give it will be called as a &quot;void
  function(void *)&quot;. It will in fact be cast into such a form before
  called. This is to avoid spurious warnings for gtk calls to subclass methods.
  The function needs not be of that form exactly, it just has to take one
  argument which is the pointer to the data. You should also not define this on
  any non-pointer data as the results may be undefined. Example:
<pre>
<div class="Pp"></div>
  public char *foo = {g_strdup(&quot;bar&quot;)}
          destroywith g_free;
<div class="Pp"></div>
</pre>
Note that the function name you give must be a real function and not macro. Also
  note that this is always called in the &quot;finalize&quot; method of GObject.
  It is always called after any user defined body of the finalize handler.
<div class="Pp"></div>
Sometimes you may want to run arbitrary code on destruction. While this can be
  perfectly well done in the finalize handler. Depending on the style you may
  want to include all destruction/initialization code together with the
  definition of the data member. Thus you may want to put arbitrary code which
  will then be inserted into the &quot;finalize&quot; method of GObject. This
  can be done with the &quot;destroy&quot; keyword followed by arbitrary code in
  curly braces. Inside this code a macro called VAR will be define which refers
  to your variable. So for example destroying a GString can be either done with
  a helper routine or the following code:
<pre>
<div class="Pp"></div>
  public GString *string = {g_string_new(NULL)}
          destroy {
	          if(VAR) g_string_free(VAR, TRUE);
	  };
<div class="Pp"></div>
</pre>
The thing to remember with these is that there are many ways to do this and
  you&#x00B4;d better be consistent in your code in how you use the above
  things. Also defining a helper routine that will do the destruction will be a
  nicer thing to do if that&#x00B4;s a possibility. The &quot;destroy&quot;
  keyword with code does take up more space in the file and it may become more
  cluttered.
<div class="Pp"></div>
The data is zeroed out after being destroyed. This is to make debugging easier
  in case your code might try to access an already finalized object. In case you
  have overridden the finalize method, your code will be run first and only then
  will the destructors be called. You should not however make any assumptions
  about the order at which the destructors are called. If you have
  interdependencies between destructors for different data members, you will
  have to do this in your own finalize override function.
<div class="Pp"></div>
<b>Automatic Unreffing:</b>
<div class="Pp"></div>
This is very much like the automatic destruction, but is instead run in the
  dispose method (it is among other places called from the &quot;destroy&quot;
  method of GtkObject). All data and other objects that you need to unref should
  be done here, and not at finalize time. The semantics are otherwise the same
  as for the &quot;destroywith&quot; and &quot;destroy&quot; keywords, except
  that you use &quot;unrefwith&quot; and &quot;unref&quot;.
<pre>
<div class="Pp"></div>
  public G:Object *foo = NULL
          unrefwith g_object_unref;
  public G:Object *bar = NULL
          unref {
		g_object_unref (VAR);
	  };
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="GOBJECT_PROPERTIES"><a class="selflink" href="#GOBJECT_PROPERTIES">GOBJECT
  PROPERTIES</a></h1>
The fourth type of a data member a property type. It is a named data member
  which is one of the features of the GObject system. It just defines a way to
  get and set some data, but you have to take care of storing that data
  somewhere. So it is normal to also have a normal private (or public) data
  member where you store the real data. You normally need to define a get and a
  set handler. They are fragments of C code that will be used to get the value
  or set the value of the argument. Inside them you can use the define VAL to
  which you assign the data or get the data. You should treat this VAL as a
  GValue which stores the data of the correct type. You can also use the
  identifier &quot;self&quot; as pointer to the object instance. The type is
  defined as one of the GObject type enums, but without the G_TYPE_ prefix.
  There are also some attributes of a property which you can set. For example
  the following is a definition of an integer property &#x00B4;height&#x00B4;
  which will be synchronized with a private integer data member also of the name
  &#x00B4;height&#x00B4;.
<pre>
<div class="Pp"></div>
  private int height;
  property INT height
         (nick = _(&quot;Short nickname&quot;),
          blurb = _(&quot;Long description&quot;),
          minimum = 10,
          maximum = 200,
          default_value = 100)
        set { self-&gt;_priv-&gt;height = g_value_get_int (VAL); }
        get { g_value_set_int (VAL, self-&gt;_priv-&gt;height); };
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
The attributes are really optional though you should at least set some of them.
  All property types have a &#x00B4;nick&#x00B4; and a &#x00B4;blurb&#x00B4;
  attribute and you should set those accordingly. This will make runtime
  querying the object nicer as things such as gui editors and class browsers can
  be more verbose about the class itself. You can use the
  &#x00B4;_(&quot;string&quot;)&#x00B4; notation instead of just
  &quot;string&quot;, and that will mark the string for translation.
<div class="Pp"></div>
Almost all types also have a &#x00B4;default_value&#x00B4; attribute which sets
  the initial value of this property (on object initialization, the set handler
  will be run automatically with this value). This value will be overridden if
  the user sets a value of this property on the call to g_object_new.
<div class="Pp"></div>
All the numeric types (including CHAR) have &#x00B4;minimum&#x00B4; and
  &#x00B4;maximum&#x00B4; attributes which can restrict the range. If you do not
  specify these the range will be the full range that the data type can handle.
<div class="Pp"></div>
Types such as UNICHAR and BOOLEAN only have the &#x00B4;nick&#x00B4;,
  &#x00B4;blurb&#x00B4; and &#x00B4;default_value&#x00B4; attributes.
<div class="Pp"></div>
The ENUM type has an &#x00B4;enum_type&#x00B4; attribute which is the exact type
  of the enum. This is so that the property knows which exact type you can set,
  rather then just knowing it is an enum. You should always create an enum type
  specific for the enum itself (see section on the enum types)
<div class="Pp"></div>
Similarly FLAGS type has a &#x00B4;flags_type&#x00B4; which again you should set
  to the specific type of this flags data member.
<div class="Pp"></div>
There is a STRING type which has only the extra &#x00B4;default_value&#x00B4;
  attribute.
<div class="Pp"></div>
The OBJECT type is one of the types that doesn&#x00B4;t have a
  &#x00B4;default_value&#x00B4; and it only has an &#x00B4;object_type&#x00B4;
  attribute (in addition to nick and blurb of course) that is the exact object
  type that this property accepts. The object_type should be as a type, that is
  for example &#x00B4;Gtk:Button&#x00B4;.
<div class="Pp"></div>
There is a BOXED type which is a pointer which has a boxed type defined (such
  that GObject knows how to copy and destroy this pointer). Here you will need
  to specify the &#x00B4;boxed_type&#x00B4; attribute with the specific type of
  the boxed pointer.
<div class="Pp"></div>
There is also a POINTER type, which has only the &#x00B4;nick&#x00B4; and
  &#x00B4;blurb&#x00B4; attributes. This is for storing arbitrary pointers. You
  should be careful with this one, as GObject knows nothing about the data
  stored at this pointer. It is somewhat like a &#x00B4;void *&#x00B4; type.
<div class="Pp"></div>
There is also the PARAM type for storing parameters with a
  &#x00B4;param_type&#x00B4; attribute.
<div class="Pp"></div>
You should notice that this list is pretty much like the list of g_param_spec_*
  functions from gobject/gparamspecs.h, and the attributes are like the
  arguments of those functions. Note however that value array is NOT supported
  yet.
<div class="Pp"></div>
You can also specify extra flags, such as CONSTRUCT or CONSTRUCT_ONLY using the
  &#x00B4;flags&#x00B4; attribute. You can specify multiple flags by oring them
  together with &#x00B4;|&#x00B4;. These flags correspond to the GParamFlags
  enumeration except do not include the G_PARAM_ prefix. So for example to
  define an enumeration property, which is a CONSTRUCT_ONLY property, we could
  do the following:
<pre>
<div class="Pp"></div>
  private SomeEnumerationType foo;
  property ENUM foo
         (nick = _(&quot;Short nickname&quot;),
          blurb = _(&quot;Long description&quot;),
          enum_type = Some:Enumeration:Type
          default_value = SOME_ENUMERATION_VALUE,
          flags = CONSTRUCT_ONLY,
          link);
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
The above example also gives an example of automatic linking to a standard data
  memember. By including the attribute &#x00B4;link&#x00B4; a get and set
  handlers will be automatically added without having to type them by hand. This
  is useful for a vast majority data types that are just linked to some standard
  data member and do not need to do anything extra on get or set.
<div class="Pp"></div>
Another extra feature of properties is the possibility of automatically exporing
  methods to get and set the property. That is without having to use
  g_object_set and g_object_get. This is achieved by adding an
  &#x00B4;export&#x00B4; attribute to the list of property attributes.
<div class="Pp"></div>
If you do not define a set or get handler, the property will automatically be
  only readable or writable as appropriate.
<div class="Pp"></div>
Gob2 also creates macros which can be used for type safe access to properties
  through g_object_set and g_object_get. The macros are called
  &lt;type&gt;_PROP_&lt;argument name&gt;(x) and
  &lt;type&gt;_GET_PROP_&lt;argument name&gt;(x). They define both the string
  and the value part of the argument. So for setting an argument of height, one
  would use (for object type My:Object):
<pre>
<div class="Pp"></div>
  g_object_set (G_OBJECT (object),
		MY_OBJECT_PROP_HEIGHT (7),
		NULL);
<div class="Pp"></div>
</pre>
And for getting, you would use:
<pre>
<div class="Pp"></div>
  int height;
  g_object_get (G_OBJECT (object),
		MY_OBJECT_GET_PROP_HEIGHT (&amp;height),
		NULL);
<div class="Pp"></div>
</pre>
Note however that the type safety only works completely on GNU C compilers. The
  code will compile on other compilers but with minimal type safety. For
  complete type safety it is useful to use the get/set methods that are defined
  by using the &#x00B4;export&#x00B4; attribute.
<div class="Pp"></div>
To get bettery type safety on some of the property types, you can specify the
  &#x00B4;type&#x00B4; attribute which will add casts where appropriate in code
  dealing with this property. This is especially useful for POINTER and OBJECT
  types. But even for others.
<div class="Pp"></div>
You can also override properties from parent objects (that is override their
  implementation, not their attributes). Do this by adding the special
  &#x00B4;override&#x00B4; attribute. For example if the parent object had a
  &#x00B4;height&#x00B4; property then you could override it by
<pre>
<div class="Pp"></div>
  private int height;
  property INT height
         (override)
        set { self-&gt;_priv-&gt;height = g_value_get_int (VAL); }
        get { g_value_set_int (VAL, self-&gt;_priv-&gt;height); };
<div class="Pp"></div>
</pre>
Overriding is supported since gob 2.0.10.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="METHODS"><a class="selflink" href="#METHODS">METHODS</a></h1>
There is a whole array of possible methods. The three normal,
  &quot;familiar&quot; method types are private, protected and public. Public
  are defined as normal functions with a prototype in the header file. Protected
  methods are defined as normal methods (which you can call from other files),
  but their prototype is placed in the private header file. Private methods are
  defined as static functions with prototypes at the top of the .c file. Then
  there are signal, virtual and override methods. More on those later. You can
  also define init and class_init methods with a special definition if you want
  to add code to the constructors or you can just leave them out. You can also
  not define a body for a method, by just using &#x00B4;;&#x00B4; instead of a
  body. This will define an empty function. You can&#x00B4;t do this for
  non-void regular public, private or protected methods, however it is
  acceptable for non-void virtual, signal and override methods.
<div class="Pp"></div>
<b>Function argument lists:</b>
<div class="Pp"></div>
For all but the init and class_init methods, you use the following syntax for
  arguments. The first argument can be just &quot;self&quot;, which gob will
  translate into a pointer to the object instance. The rest of the arguments are
  very similar to normal C arguments. If the typename is an object pointer you
  should use the syntax defined above with the words separated by
  &#x00B4;:&#x00B4;
<pre>
&lt;type&gt; &lt;argument id&gt;
or
&lt;type&gt; &lt;argument id&gt; (check &lt;list of checks&gt;)
</pre>
<div class="Pp"></div>
The checks are glib type preconditions, and can be the following:
  &quot;null&quot;, which tests pointers for being NULL, &quot;type&quot; which
  checks GTK+ object pointers for being the right type, &quot;&lt;test&gt;
  &lt;number&gt;&quot; which tests numeric arguments for being a certain value.
  The test can be a &lt;,&gt;,&lt;=,&gt;= != or ==. Example:
<pre>
  
  public int
  foo (self,
       int h (check &gt; 0 &lt; 11),
       Gtk:Widget *w (check null type))
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
This will be the prototype of a function which has a self pointer as the first
  argument, an integer argument which will be checked and has to be more then 0
  and less then 11, and a pointer to a GtkWidget object instance and it is
  checked for being null and the type will also be checked.
<div class="Pp"></div>
<b>Function attributes:</b>
<div class="Pp"></div>
For method that aren't virtual, signal or override methods, and aren't init or
  class_init, GLib function attribute macros G_GNUC_PRINTF, G_GNUC_SCANF, and
  G_GNUC_FORMAT can optionally be included after the argument list. Simply
  include an &#x00B4;attr&#x00B4; keyword and the C code to include in the file.
  You have to include braces and anything inside the braces will be printed into
  the header file after the function declaration and before the trailing
  semicolon. The braces themselves are not printed. For example:
<pre>
<div class="Pp"></div>
  public void
  print (self, const char *format (check null), ...)
    attr {G_GNUC_PRINTF(2, 3)}
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
This will produce a prototype which will generate a warning at compile time if
  the contents of the format argument (argument number 2) aren't consistent with
  the types and number of the subsequent variadic arguments (the first of which
  is argument number 3). Only one &#x00B4;attr&#x00B4; keyword per method is
  allowed. If you have more than one attribute to include, you should put them
  all within the braces. Note that function attributes were aded in version
  2.0.16.
<div class="Pp"></div>
<b>Error return:</b>
<div class="Pp"></div>
Methods which have a return value, there also has to be something returned if
  there is an error, such as if a precondition is not met. The default is 0,
  casted to the type of the method. If you need to return something else then
  you can specify an &#x00B4;onerror&#x00B4; keyword after the prototype and any
  optional function attribute macros, and after that a number, a token (an
  identifier) or a bit of C code enclosed in braces {}. The braces will not be
  printed into the output, they just delimit the string. For example:
<pre>
<div class="Pp"></div>
  public void * get_something (self, int i (check &gt;= 0)) onerror NULL {
	  ...
  }
<div class="Pp"></div>
</pre>
The onerror value is also used in overrides that have a return value, in case
  there isn&#x00B4;t a parent method, PARENT_HANDLER will return it. More about
  this later.
<div class="Pp"></div>
<b>Default return:</b>
<div class="Pp"></div>
Some signal and virtual methods have a return type. But what happens if there is
  no default handler and no one connects to a signal. GOB2 will normally have
  the wrappers return whatever you specify with onerror or &#x00B4;0&#x00B4; if
  you haven&#x00B4;t specified anything. You can also specify a default return
  value with the keyword &#x00B4;defreturn&#x00B4;. It&#x00B4;s use is identical
  to the use of onerror, and you can in fact use both at the same time. Example
<pre>
<div class="Pp"></div>
  virtual int get_some_int (self) onerror -1 defreturn 10 ;
<div class="Pp"></div>
</pre>
That is an empty virtual method (in C++ terms a pure virtual). If you never
  specify any handler for it in the derived children it will just return 10.
<div class="Pp"></div>
<b>Constructor methods:</b>
<div class="Pp"></div>
There are two methods that handle the construction of an object, init and
  class_init. You define them by just using the init or class_init keyword with
  an untyped argument in the argument list. The argument will be usable in your
  function as a pointer to your object or class depending if it&#x00B4;s init or
  class_init. For example:
<pre>
<div class="Pp"></div>
  init (self) {
          /* initialize the object here */
          self-&gt;a = 9;
          self-&gt;b = 9;
  }
<div class="Pp"></div>
  class_init (class) {
          /* initialize the class, this is rarely needed */
          class-&gt;blah = NULL;
  }
<div class="Pp"></div>
</pre>
The class_init function is very rarely needed as all standard class
  initialization is taken care of for you by gob itself. The init function
  should on the other hand be used whenever you need to construct or initialize
  anything in the object to put it into a sane state.
<div class="Pp"></div>
<b>Constructor, dispose, finalize methods:</b>
<div class="Pp"></div>
Since 2.0.16, you can also easily add code to the object's constructor, dispose,
  and finalize methods. See GObject documentation on how these are run. The code
  you add will be run before calling the parents function for dispose and
  finalize, and after the parent function for constructor. The syntax is just
  like init and class_init. For example:
<pre>
<div class="Pp"></div>
  constructor (self) {
	/* constructor method */
  }
<div class="Pp"></div>
  dispose (self) {
	/* dispose method */
  }
<div class="Pp"></div>
  finalize (self) {
	/* finalize method */
  }
<div class="Pp"></div>
</pre>
You can also just override those methods as usual, but the above is much easier
  and nearly as flexible.
<div class="Pp"></div>
<b>Virtual methods:</b>
<div class="Pp"></div>
Virtual methods are basically pointers in the class structure, so that one can
  override the method in derived methods. That is to implement the method in a
  derived class, you must then use an override method (more on those later).
  They can be empty (if you put &#x00B4;;&#x00B4; instead of the C code). A
  wrapper will also be defined which makes calling the methods he same as public
  methods. This type of method is just a little bit &quot;slower&quot; then
  normal functions, but not as slow as signals. You define them by using
  &quot;virtual&quot; keyword before the prototype. If you put the keyword
  &quot;private&quot; right after the &quot;virtual&quot; keyword, the wrapper
  will not be a public method, but a private one. You can do the same with
  &quot;protected&quot; to make a protected wrapper.
<div class="Pp"></div>
<b>Signals:</b>
<div class="Pp"></div>
Signals are methods to which the user can bind other handlers and override the
  default handler. The default handler is basically the method body. This is the
  most versatile and flexible type of a method and also the slowest. You need to
  specify a whole bunch of things when you define a signal. One thing is when
  the default handler will be run, first or last. You specify that by
  &quot;first&quot; or &quot;last&quot; right after the &quot;signal&quot;
  keyword. Then you need to define the GObject enum types (again without the
  G_TYPE_ prefix). For that you define the return types and the types of
  arguments after the &quot;self&quot; pointer (not including the
  &quot;self&quot; pointer). You put it in the following syntax &quot;&lt;return
  type&gt; (&lt;list of arguments&gt;)&quot;. If the return type is void, the
  type should be &quot;NONE&quot;, the same should be for the argument list. The
  rest of the prototype is the same as for other method types. The body can also
  be empty, and also there is a public method wrapper which you can use for
  calling the signal just like a public method. Example:
<pre>
<div class="Pp"></div>
  signal first INT (POINTER, INT)
  int do_something (self, Gtk:Widget *w (check null type), int length)
  {
	  ...
  }
  
</pre>
or
<pre>
<div class="Pp"></div>
  signal last NONE (NONE) void foo (self);
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
If you don&#x00B4;t want the wrapper that emits the signal to be public, you can
  include the keyword &quot;private&quot; after the &quot;signal&quot; keyword.
  This will make the wrapper a normal private method. You can also make a
  protected wrapper by using &quot;protected&quot; instead of
  &quot;private&quot;.
<div class="Pp"></div>
If you don&#x00B4;t define a &quot;first&quot; or a &quot;last&quot;, the
  default will be taken as &quot;last&quot;.
<div class="Pp"></div>
You can also add additional flags. You do this just like with the argument
  flags, although this is probably very rare. These are the G_SIGNAL_* flags,
  and you can add them without the G_SIGNAL_ prefix into a parenthesis, just
  after the &quot;signal&quot; keyword. By default all public signals are
  G_SIGNAL_ACTION.
<div class="Pp"></div>
Also gob2 creates a wrapper macros for typesafe signal connection. That is you
  will be warned by the compiler if you pass a callback that is not the correct
  prototype. This will again only warn you on gcc, but it will compile without
  warning on another compiler. So as with all the typesafety hacks in gob, it is
  better to test your objects under gcc to get any warnings even if you are
  using a different compiler in the end.
<div class="Pp"></div>
The methods that are created for you are:
<pre>
<div class="Pp"></div>
  &lt;class_name&gt;_connect__&lt;signal_name&gt; (&lt;object&gt;, &lt;callback&gt;, &lt;data&gt;)
  &lt;class_name&gt;_connect_after__&lt;signal_name&gt; (&lt;object&gt;, &lt;callback&gt;, &lt;data&gt;)
  &lt;class_name&gt;_connect_data__&lt;signal_name&gt; (&lt;object&gt;, &lt;callback&gt;, &lt;data&gt;,
                                            &lt;destroy_notify&gt;, &lt;flags&gt;)
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
These three functions correspond to the g_signal_connect, g_signal_connect_after
  and g_signal_connect_data functions that you would normally use, except they
  are for a specific signal. Also do note the two underscores between the method
  name and the signal name. For example to connect the signal &quot;foo&quot; on
  the object &quot;Test:Object&quot; you would do:
<pre>
<div class="Pp"></div>
  test_object_connect__foo (object, callback, data);
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
To use BOXED in the signal arguments you need to tell gob which type of boxed
  argument you want to use. For this you can just add BOXED_GTK_TYPE_STRING
  instead of BOXED. For example BOXED_GTK_TYPE_TREE_ITER for GtkTreeIter. This
  works since version 2.0.13.
<div class="Pp"></div>
<b>Override methods:</b>
<div class="Pp"></div>
If you need to override some method (a signal or a virtual method of some class
  in the parent tree of the new object), you can define and override method.
  After the &quot;override&quot; keyword, you should put the typename of the
  class you are overriding a method from. Other then that it is the same as for
  other methods. The &quot;self&quot; pointer in this case should be the type of
  the method you are overriding so that you don&#x00B4;t get warnings during
  compilation. Also to call the method of the parent class, you can use the
  PARENT_HANDLER macro with your arguments. Example:
<pre>
<div class="Pp"></div>
  override (Gtk:Container) void
  add (Gtk:Container *self (check null type), Gtk:Widget *wid (check null type))
  {
          /* some code here */
          PARENT_HANDLER(self, wid);
  }
<div class="Pp"></div>
</pre>
If the function has a return value, then PARENT_HANDLER is an expression that
  you can use. It will return whatever the parent handler returned, or the
  &quot;onerror&quot; expression if there was no parent handler.
<div class="Pp"></div>
<b>Method names:</b>
<div class="Pp"></div>
Inside the code, aliases are set for the methods, so that you don&#x00B4;t have
  to type the class name before each call, just type <b>self_</b> instead of the
  name of the class. So to call a method called <b>blah</b>, you would use the
  name <b>self_blah</b>. Example:
<pre>
<div class="Pp"></div>
  private int
  foo (self)
  {
	  return self-&gt;len;
  }
  
  private int
  bar (self, int i)
  {
	  return self_foo (self) + i;
  }
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="MAKING_NEW_OBJECTS"><a class="selflink" href="#MAKING_NEW_OBJECTS">MAKING
  NEW OBJECTS</a></h1>
You should define a new method which should be a normal public method. Inside
  this method, you can use the GET_NEW macro that is defined for you and that
  will fetch a new object, so a fairly standard new method would look like:
<pre>
<div class="Pp"></div>
  public GObject *
  new (void) {
	  GObject *ret = GET_NEW;
	  return G_OBJECT (ret);
  }
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
You should not a subtle peculiarity of the GObject system here. If there is any
  code inside the G_OBJECT macro argument, it will get executed multiple times.
  This means that things such as G_OBJECT(GET_NEW) would actually create 4
  objects, leaking 3 of them. A good rule (as with anywhere in C) is to be
  careful with all macros.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SELF_REFERENCES"><a class="selflink" href="#SELF_REFERENCES">SELF
  REFERENCES</a></h1>
<b>Self alias casts:</b>
<div class="Pp"></div>
There are some standard casts defined for you. Instead of using the full macros
  inside the .c file, you can use SELF, IS_SELF and SELF_CLASS. Using these
  makes it easier to for example change class names around.
<div class="Pp"></div>
<b>Self alias types:</b>
<div class="Pp"></div>
There are also the Self and SelfClass types inside your .c file. These serve the
  same function as the above, they make it easier to type and easier to change
  typenames around which can help a lot during prototyping stage. However you
  should note that the Self type should not be used in function prototypes as
  one of the arguments or as a return value type. This is because this is a
  simple C typedef which is only available inside your .c file and not in the
  header files. You can disable both the self casting macros and the self type
  aliases by passing --no-self-alias to gob.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DEALING_WITH_DIFFERENT_GOB_VERSIONS"><a class="selflink" href="#DEALING_WITH_DIFFERENT_GOB_VERSIONS">DEALING
  WITH DIFFERENT GOB VERSIONS</a></h1>
<b>Defines:</b>
<div class="Pp"></div>
In your generated C file, you can use the defines GOB_VERSION_MAJOR
  GOB_VERSION_MINOR and GOB_VERSION_PATCHLEVEL if you wish to for example use a
  feature that is only available in some newer gob version. Note however that
  you can only use these defines in the C code portions of your .gob file, and
  #ifdef&#x00B4;s cannot span multiple functions. Check the BUGS section for
  more on using the C preprocessor and gob.
<div class="Pp"></div>
<b>Minimum version requires:</b>
<div class="Pp"></div>
You can also make your .gob file require at least certain version of gob. You do
  this by putting &#x00B4;requires x.y.z&#x00B4; (where x.y.z is the version
  number) outside of any C block, comment or class, usually you should make this
  the first line in the file or close to the top. If gob finds this and the
  version of gob used to compile the code is lower then that listed in the
  require, gob will generate an error and exit. For example to require that gob2
  version 2.0.0 or higher be used to compile a file, put this at the top of that
  file:
<pre>
<div class="Pp"></div>
  requires 2.0.0
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="CREATING_NEW_ENUM,_FLAGS_and_ERROR_TYPES"><a class="selflink" href="#CREATING_NEW_ENUM,_FLAGS_and_ERROR_TYPES">CREATING
  NEW ENUM, FLAGS and ERROR TYPES</a></h1>
You can create new GObject ENUM, FLAGS and GError types for use in your classes
  easily. Glib includes some utilities for handling these, however it may be
  cleaner to use the below specified way in your classes. It also then
  doesn&#x00B4;t require any Makefile setup. Make sure this is defined in the
  same section as the class, that is not in any of the &#x00B4;%?{&#x00B4;
  &#x00B4;%}&#x00B4; sections.
<div class="Pp"></div>
You use the keywords &#x00B4;enum&#x00B4; &#x00B4;flags&#x00B4; and
  &#x00B4;error&#x00B4; as you would use the &#x00B4;class&#x00B4; keyword. Then
  you give a prefix for the values in the enumeration. Then you define a list of
  values just like in C. For &#x00B4;enum&#x00B4; types you can also specify the
  values assigned to each string. Then you specify the type in the standard gob
  style of specifying types. Here are a few examples of all of these:
<pre>
<div class="Pp"></div>
  enum LAME_CLIENT {
        IS_CONNECTED,
        NONE = 9,
        LAST
  } Test:Enum;
<div class="Pp"></div>
  flags BUGA_BUGA {
        ONE,
        TWO,
        MANY,
  } Some:Flags;
<div class="Pp"></div>
  error TEST_OBJECT_ERROR {
        BAD_THIS,
        BAD_THAT
  } Test:Object:Error;
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
This will for example define an enum that is equivalent to the following C code:
<pre>
<div class="Pp"></div>
  typedef enum {
        LAME_CLIENT_IS_CONNECTED,
        LAME_CLIENT_NONE = 9,
        LAME_CLIENT_LAST
  } TestEnum;
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="C++_MODE"><a class="selflink" href="#C++_MODE">C++
  MODE</a></h1>
There is a C++ mode so that gob creates C++ compiler friendly files. You need to
  use the --for-cpp argument to gob. This will make the generated file have a
  .cc instead of a .c extension, and several things will be adjusted to make it
  all work for a C++ compiler. One thing that will be missing is an alias to the
  new method, as that clashes with C++, so instead you&#x00B4;ll have to use the
  full name of the method inside your code. Also note that gob does not use any
  C++ features, this option will just make the generated code compile with a C++
  compiler.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OVERRIDING_THE_GET_TYPE_METHOD"><a class="selflink" href="#OVERRIDING_THE_GET_TYPE_METHOD">OVERRIDING
  THE GET_TYPE METHOD</a></h1>
The get_type is not really a method, but a function which initializes your
  object. Recently objects appeared which require you to make a custom get_type
  function. So it is possible to override this function. To do so, just define a
  new public method called get_type, with no arguments. Example:
<pre>
<div class="Pp"></div>
  public GType
  get_type (void)
  {
	/* code goes here */
	return some_type;
  }
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="INTERFACES"><a class="selflink" href="#INTERFACES">INTERFACES</a></h1>
Currently gob will only allow you to implement interfaces (that is, define new
  classes which implement an interface) and doesn&#x00B4;t yet have support for
  making new interfaces, but this will be coming at some point in the future.
<div class="Pp"></div>
To define a class that implements an interface add a class flag
  &#x00B4;interface&#x00B4; with the type name of the interface as an argument.
  Then to implement a specific method of the interface, just add
  &#x00B4;interface &lt;typename&gt;&#x00B4; before the method definition. The
  method can, and probably should be, private.
<div class="Pp"></div>
The following example implements a new object, that implements the
  Gtk:Tree:Model interface and implements the get_flags method of that
  interface. Do note that except for standard (GTK+ and glib) specific
  interfaces which seem to have a non-standard name for the interface structure,
  the structure should end with and Iface, if you are implementing an interface.
  That is for example for the Gtk:Tree:Model, the structure containing the table
  of methods should be named GtkTreeModelIface.
<pre>
  class Some:Object from G:Object
          (interface Gtk:Tree:Model)
  {
          /* function implemented for the Gtk:Tree:Model interface */
          interface Gtk:Tree:Model
          private GtkTreeModelFlags
          get_flags (Gtk:Tree:Model *self (check null type))
          {
          	/* Here would be the implementation */
          	return (GtkTreeModelFlags)0;
          }
  }
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
If you want to implement multiple interfaces just list more class flag lines as
  follows:
<pre>
<div class="Pp"></div>
  class Some:Object from G:Object
          (interface Gtk:Tree:Model)
          (interface Gtk:Editable)
  {
          /* ... */
  }
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DIRECT_BonoboObject_SUPPORT"><a class="selflink" href="#DIRECT_BonoboObject_SUPPORT">DIRECT
  BonoboObject SUPPORT</a></h1>
If you want to build a BonoboObject class gob2 has direct support for these.
  Just create a new object that derives from Bonobo:Object. Then use a
  &quot;BonoboObject&quot; class flag with the interface name as an argument.
  The interface name should be as you would type it in C, that is with
  underscores as namespace separators. Then you add the methods (using exact
  same names as in the idl file) and prepend those methods with a BonoboObject
  keyword. For example imagine you have an interface GNOME/Foo/SomeInterface,
  with a method fooBar that takes a single string:
<pre>
<div class="Pp"></div>
  class Foo:Some:Interface from Bonobo:Object
    (BonoboObject GNOME_Foo_SomeInterface) {
<div class="Pp"></div>
          BonoboObject
          private void
          fooBar (PortableServer_Servant servant,
                  const CORBA_char *string,
                  CORBA_Environment *ev)
          {
                  Self *self = SELF (bonobo_object_from_servant (servant));
<div class="Pp"></div>
                  /* your code here */
          }
<div class="Pp"></div>
          /* rest of class */
  }
<div class="Pp"></div>
</pre>
Note that the implementation method can be private, in fact that&#x00B4;s
  probably a good idea to do. It won&#x00B4;t work to make this a signal, it can
  however be a virtual. Note that the method prototype must match the one from
  the interface header file, or you will get a bad assignment warning. You
  should check the header file generated by orbit-idl and see the epv structure
  for the correct prototypes if you can&#x00B4;t figure them out from the idl
  itself. Also note that the first argument is not &quot;self&quot;, but the
  servant and you must use bonobo_object_from_servant function to get the actual
  object pointer.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DIRECT_LIBGLADE_SUPPORT"><a class="selflink" href="#DIRECT_LIBGLADE_SUPPORT">DIRECT
  LIBGLADE SUPPORT</a></h1>
Gob can simplify writing a libglade class. Just create a new object that derives
  from a GtkContainer widget. Then use a &quot;GladeXML&quot; class flag with
  the glade file name, root widget and optional domain as arguments between
  double quotes. For example:
<pre>
<div class="Pp"></div>
class My:Glade from Gtk:Window (GladeXML &quot;gob-libglade.glade&quot; &quot;root&quot;)
{
  ....
}
<div class="Pp"></div>
</pre>
Note however that then &quot;gob-libglade.glade&quot; would have to be in the
  current directory. You could specify a path, but that may not work for all
  installations. You can replace the glade filename with a token to be used in
  the generated .c file and you can then have a macro with the filename, as
  follows:
<pre>
<div class="Pp"></div>
class My:Glade from Gtk:Window (GladeXML GLADE_FILE &quot;root&quot;)
{
  ....
}
<div class="Pp"></div>
</pre>
And somewhere in your header files you would have
<pre>
<div class="Pp"></div>
#define GLADE_FILE &quot;/path/to/file.glade&quot;
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
You can declare widgets as data members by adding a 'GladeXML' to the
  definition.
<pre>
<div class="Pp"></div>
private Gtk:Button * button1 GladeXML;
<div class="Pp"></div>
</pre>
This will automatically set the &quot;button1&quot; from the GladeXML file.
<div style="height: 1.00em;">&#x00A0;</div>
All signals created with glade are automatically connected if you defined those
  class methods in your class. For example suppose in glade that we set the
  &quot;connect&quot; signal on button1 to go to on_button1_clicked, then in our
  gob file we can just write:
<pre>
<div class="Pp"></div>
public void
on_button1_clicked(self, GtkButton * button)
{
}
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
See the examples directory for a full example. Note that this feature requires
  version at least 2.0.12.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="IDENTIFIER_CONFLICTS"><a class="selflink" href="#IDENTIFIER_CONFLICTS">IDENTIFIER
  CONFLICTS</a></h1>
Gob will need to define some local variables and functions in the generated
  files, so you need to take some precaution not to conflict with these. The
  general rule of thumb is that all of these start with three underscores. There
  is one, &quot;parent_class&quot; which doesn&#x00B4;t because it&#x00B4;s
  intended for use in your code. For virtuals or signals, you cannot use the
  identifier __parent__ which is used for the parent of the object. You should
  actually never access __parent__ either as it not guaranteed that it will stay
  named this way. Data members cannot be named __parent__ nor _priv. For
  methods, you cannot use the identifiers &quot;init&quot; or
  &quot;class_init&quot; unless you mean the constructor methods. You
  shouldn&#x00B4;t generally use 3 underscores even in override method argument
  lists and virtual and signal method names as it might confuse the
  PARENT_HANDLER macro. In fact avoiding all names with three underscores is the
  best policy when working with gob.
<div class="Pp"></div>
There are a couple of defines which you shouldn&#x00B4;t be redefining in the
  code or other headers. These are SELF, IS_SELF, SELF_CLASS, SELF_TYPE, ARG,
  VAR, PARENT_HANDLER, GET_NEW, GOB_VERSION_MAJOR, GOB_VERSION_MINOR and
  GOB_VERSION_PATCHLEVEL.
<div class="Pp"></div>
As for types, there are Self and SelfClass types which are only defined in your
  source files. Their generation (just like the generation of the SELF macros)
  can be turned off, see command line options.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="USING_GTK-DOC_STYLE_INLINE_DOCUMENTATION"><a class="selflink" href="#USING_GTK-DOC_STYLE_INLINE_DOCUMENTATION">USING
  GTK-DOC STYLE INLINE DOCUMENTATION</a></h1>
If you want to use gtk-doc style inline documentation for your objects, you can
  do one of two things. First, you could include the inline documentation
  comments in your %{ %} section which will then be put verbatim into the output
  source file. This is the way you should use for functions you define outside
  of the class.
<div class="Pp"></div>
For class methods, you should use a gtk+ style comment, however it can be
  indented any number of tabs or spaces and you can use the short method name
  without the type prefix. Gob will automatically try to extract these and
  translate to full names and put them in the output source file. An example
  would be:
<pre>
<div class="Pp"></div>
  class Gtk:Button:Example from Gtk:Button {
          /**
           * new:
           *
           * Makes a new #GtkButtonExample widget
           *
           * Returns: a new widget
           **/
          public
          GtkWidget *
          new(void)
          {
                  return (GtkWidget *)GET_NEW;
          }
  } 
<div class="Pp"></div>
</pre>
If the function you are documenting is a signal or a virtual then it will be
  documenting the wrapper that starts that virtual function or emits that
  signal.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DEALING_WITH_CIRCULAR_HEADERS"><a class="selflink" href="#DEALING_WITH_CIRCULAR_HEADERS">DEALING
  WITH CIRCULAR HEADERS</a></h1>
Sometimes you may need to use an object of type MyObjectA in the MyObjectB class
  and vice versa. Obviously you can&#x00B4;t include headers for both. So you
  need to just declare the typedef in the header of A for B, and the other way
  around as well. The headers generated include a protecting define before it
  declares the typedef. This define is the __TYPEDEF_&lt;upper case object
  name&gt;__. So inside my-object-a.h there will be this:
<pre>
<div class="Pp"></div>
  #ifndef __TYPEDEF_MY_OBJECT_A__
  #define __TYPEDEF_MY_OBJECT_A__
  typedef struct _MyObjectA MyObjectA;
  #endif
<div class="Pp"></div>
</pre>
Now instead of including my-object-a.h in the header section of my-object-b.gob,
  just copy the above code there and you&#x00B4;re set for using MyObjectA as a
  type in the method parameters and public types.
<div class="Pp"></div>
Another way to get out of this problem is if you can use those types only in the
  private members, in which case they won&#x00B4;t be in the generated public
  header.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="BUILDING_WITH_MAKE"><a class="selflink" href="#BUILDING_WITH_MAKE">BUILDING
  WITH MAKE</a></h1>
If you are using normal makefiles, what you need to do is to add a generic rule
  for .gob files. So you would include the following in the Makefile and then
  just use the .c and .h files as usual (make sure the space before the
  &#x00B4;gob2&#x00B4; is a tab, not spaces):
<pre>
<div class="Pp"></div>
  %.c %.h %-private.h: %.gob
          gob2 $&lt;
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="BUILDING_WITH_AUTOCONF_and_AUTOMAKE"><a class="selflink" href="#BUILDING_WITH_AUTOCONF_and_AUTOMAKE">BUILDING
  WITH AUTOCONF and AUTOMAKE</a></h1>
This is a little bit more involved. Basically the first thing to do is to check
  for GOB2 in your configure.in file. You can use the supplied m4 macro which
  will also check the version of gob. Basically you include this:
<pre>
<div class="Pp"></div>
  GOB2_CHECK([2.0.0])
<div class="Pp"></div>
</pre>
This will replace @GOB2@ in your makefiles with the full path of gob2. Thus when
  adding the generic rule to your Makefile.am file, it should look like:
<pre>
<div class="Pp"></div>
  %.c %.h %-private.h: %.gob
          @GOB2@ $&lt;
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
For Makefile.am you have to set up a couple more things. First you have to
  include the generated .c and .h files into BUILT_SOURCES variable. You have to
  include both the .gob and the .c and .h files in the SOURCES for your program.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="PREVENTING_SPURIOUS_BUILDS"><a class="selflink" href="#PREVENTING_SPURIOUS_BUILDS">PREVENTING
  SPURIOUS BUILDS</a></h1>
When nothing has changed you might not really want to rebuild everything and gob
  provides options --no-touch (since 2.0.13) and --no-touch-headers to avoid
  this. When working with build systems such as automake you have to be more
  careful as just using those options can cause automake to get confused and you
  will need to use something like the following:
<pre>
<div class="Pp"></div>
  foo_SOURCES = foo.gob foo.gob.stamp foo.c foo.h foo-private.h
  BUILT_SOURCES = foo.gob.stamp
  MAINTAINERCLEANFILES = foo.gob.stamp
<div class="Pp"></div>
  %.gob.stamp: %.gob
          @GOB2@ --no-touch $&lt;
          @touch $@
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DEBUGGING"><a class="selflink" href="#DEBUGGING">DEBUGGING</a></h1>
GOB does several things to make debugging the code easier. First it adds
  preprocessor commands into the output c file that point to the correct places
  in your .gob input file. However sometimes there might be some bigger
  confusion and this is just not helpful. In this case you will probably want to
  have gcc point you directly at the generated files. For this use the
  --no-lines command line option. You should also note that these commands are
  not generated for the public header file at all. If there is an error which
  points you to the public header file, make sure you fix this error in the .gob
  file, otherwise your changes will not have any effect after gob recompiles the
  sources again.
<div class="Pp"></div>
Sometimes you might want to know which method you are in for some debugging
  output. GOB will define __GOB_FUNCTION__ macro, which is just a string
  constant with a pretty name of the method.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="M4_SUPPORT"><a class="selflink" href="#M4_SUPPORT">M4
  SUPPORT</a></h1>
It is possible to have your .gob file also preprocessed by m4. This is useful if
  you have a lot of files and you&#x00B4;d like to have some preprocessor put in
  some common features. All you have to do is add --m4 to the command line of
  gob2 and gob2 will first run your file through m4. You can print the directory
  that is searched for m4 files by running &quot;gob2 --m4-dir&quot;
<div class="Pp"></div>
All the arguments after --m4 will be passed to m4 itself, so it has to be the
  last gob2 argument on the command line. This way you can specify arbitrary
  options to pass to m4.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
The lexer does not actually parse the C code, so I&#x00B4;m sure that some
  corner cases or maybe even some not so corner cases of C syntax might confuse
  gob completely. If you find any, send me the source that makes it go gaga and
  I&#x00B4;ll try to make the lexer try to handle it properly, but no promises.
<div class="Pp"></div>
Another thing is that gob ignores preprocessor macros. Since gob counts braces,
  the following code won&#x00B4;t work:
<pre>
<div class="Pp"></div>
  #ifdef SOME_DEFINE
  if(foo) {
  #else
  if(bar) {
  #endif
          blah();
  }
<div class="Pp"></div>
</pre>
To make this work, you&#x00B4;d have to do this:
<pre>
<div class="Pp"></div>
  #ifdef SOME_DEFINE
  if(foo)
  #else
  if(bar)
  #endif
  {
          blah();
  }
<div class="Pp"></div>
</pre>
There is no real good way we can handle this without parsing C code, so we
  probably never will. In the future, I might add #if 0 as a comment but
  that&#x00B4;s about as far as I can really take it and even that is
  problematic. Basically, if you use gob, just don&#x00B4;t use the C
  preprocessor too extensively. And if you use it make sure that you do not
  cross the boundaries of the C code segments.
<div class="Pp"></div>
Comments will not get through to the generated files unless inside C code. This
  is not the case for gtk-doc style comments which are supported.
<div class="Pp"></div>
The short name aliases are actually implemented as pointers to functions. Thus
  if you want to get the pointer of a function using the short name alias you
  can&#x00B4;t use the &#x00B4;&amp;&#x00B4;. Thus:
<pre>
<div class="Pp"></div>
  void (*foo)(Self *);
<div class="Pp"></div>
  /* this will NOT work */
  foo = &amp;self_short_name;
<div class="Pp"></div>
  /* this will work */
  foo = self_short_name;
<div class="Pp"></div>
  /* Both of these will work */
  foo = &amp;my_class_long_name;
  foo = my_class_long_name;
<div class="Pp"></div>
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
George Lebl &lt;jirka@5z.com&gt;
<div class="Pp"></div>
GOB2 Homepage: http://www.jirka.org/gob.html</div>
<table class="foot">
  <tr>
    <td class="foot-date">GOB2 2.0.19</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
