<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:14:42 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GOB2(1) General Commands Manual GOB2(1)</p>

<p style="margin-top: 1em">NAME <br>
GOB2 - The GObject Builder</p>

<p style="margin-top: 1em">SYNOPSIS <br>
gob2 [ option ] ... file</p>

<p style="margin-top: 1em">DESCRIPTION <br>
GObject Builder is a simple preprocessor for easily creating
GObject objects. It does not parse any C code and ignores
any C errors. It is in spirit similar to things like lex
<br>
or yacc. In some ways it also resembles java. But it is
really just a simple preprocessor for creating GObjects for
use in C or C++ and it is not a programming language.</p>

<p style="margin-top: 1em">OPTIONS <br>
-? -h --help <br>
Display a simple help screen.</p>

<p style="margin-top: 1em">--version <br>
Display version information</p>

<p style="margin-top: 1em">-w --exit-on-warn <br>
Exit with an error code even when you encounter a
warning.</p>

<p style="margin-top: 1em">--no-exit-on-warn <br>
Exit with an error only on errors, not on warnings, this is
the default.</p>

<p style="margin-top: 1em">--for-cpp <br>
Generate C++ code.</p>

<p style="margin-top: 1em">--no-extern-c <br>
Never add the extern &quot;C&quot; to the header.</p>

<p style="margin-top: 1em">--no-gnu <br>
Never generate any code with GNU C extensions. However all
the GNU C extensions are always wrapped in #ifdef __GNUC__,
so code using them compiles correctly even on non- <br>
GNU compilers. This option is for purists only. (using GNU
extensions some warnings are eliminated, some ugly hacks and
there is better argument type safety, so it&Acirc;&acute;s
<br>
good to use them)</p>

<p style="margin-top: 1em">--no-touch <br>
Don&Acirc;&acute;t touch output files unless they really
changed (implies --no-touch-headers). Be careful with
automake, see section PREVENTING SPURIOUS BUILDS.</p>

<p style="margin-top: 1em">--no-touch-headers <br>
Don&Acirc;&acute;t touch the generated header file unless it
really changed, this avoids spurious rebuilds, but can
confuse some make systems (automake in particular), so it is
not <br>
enabled by default. Private header is still touched even if
unchanged however.</p>

<p style="margin-top: 1em">--always-private-header <br>
Always create a &lt;basename&gt;-private.h file, even if it
would be empty.</p>

<p style="margin-top: 1em">--ondemand-private-header <br>
Create the private header only if it would have something in
it, that is, if there are some private data members or
protected methods. This is the default.</p>

<p style="margin-top: 1em">--no-private-header <br>
Never create a private header file. If we use any private
data members, define the private data structure at the point
in the .c source where the class definition begins.</p>

<p style="margin-top: 1em">--m4 Preprocess source with m4.
Following args will be passed to m4.</p>

<p style="margin-top: 1em">--m4-dir <br>
Print directory that will be searched for m4 files.</p>

<p style="margin-top: 1em">-n --no-write <br>
Do not write any output files, just check syntax of the
input file.</p>

<p style="margin-top: 1em">--no-lines <br>
Do not print out the &Acirc;&acute;#line&Acirc;&acute;
statements into the output. Useful for debugging the
auto-generated generated code.</p>

<p style="margin-top: 1em">--no-self-alias <br>
Do not create the Self and SelfClass type aliases and the
SELF, IS_SELF and SELF_CLASS macros.</p>

<p style="margin-top: 1em">--no-kill-underscores <br>
Do not remove the initial underscore from method names.</p>

<p style="margin-top: 1em">--always-private-struct <br>
Always include the private pointer in the public header
file. This is useful for files which are part of a library
and you want to reserve the right to add some private <br>
data members without breaking binary compatibility.</p>

<p style="margin-top: 1em">-o --output-dir <br>
The directory into which output should be placed.</p>

<p style="margin-top: 1em">--file-sep[=c] <br>
Replace default &Acirc;&acute;-&Acirc;&acute; file name
separator. If no separator character is given then none is
used. Only one character can be used.</p>

<p style="margin-top: 1em">TYPENAMES <br>
Because we need to parse out different parts of the
typename, sometimes you need to specify the typename with
some special syntax. Types are specified in capitalized form
and <br>
words are separated by &Acirc;&acute;:&Acirc;&acute;. The
first word of the type (which can be empty) is the
&quot;namespace&quot;. This fact is for example used for the
type checking macro and the type macro. <br>
For &quot;Gtk:New:Button&quot;, the macros will be
GTK_IS_NEW_BUTTON and GTK_TYPE_NEW_BUTTON. This colon
separated format of typenames is used in the class
declaration header and for <br>
method argument types.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
The filenames are created from the typename. The words are
separated by &Acirc;&acute;-&Acirc;&acute; (this can be
changed with --file-sep option) and all in lower case. For
example for an object named <br>
&quot;Gtk:New:Button&quot;, the files are gtk-new-button.c
and gtk-new-button.h. If you are using C++ mode, the output
.c file will in fact be a .cc file. If you have any private
data <br>
members, a private header file will also be created, called
&lt;basename&gt;-private.h (for the example above it would
be gtk-new-button-private.h). The public header file is
created <br>
to be human readable and to be used as a reference to the
object. The .c source file is not created as a human
readable source and is littered with #line statements, which
make <br>
the compiler attempt to point you to the right line in your
.gob file in case of parsing errors. The output should not
be edited by hand, and you should only edit the .gob
file.</p>

<p style="margin-top: 1em">INCLUDING NORMAL C CODE IN THE
OUTPUT FILES <br>
To include some code directly in the output C file begin
with &Acirc;&acute;%{&Acirc;&acute; on an empty line and end
the code with a &Acirc;&acute;%}&Acirc;&acute; on an empty
line. These sections will appear in the output files <br>
in the order they are given. There are several other
sections to which you can put code. You can put it in the
&Acirc;&acute;header&Acirc;&acute; section (which can be
abbreviated &Acirc;&acute;h&Acirc;&acute;) and it will go
<br>
into the public header file. You can also put it in the
&Acirc;&acute;privateheader&Acirc;&acute; section
(abbreviated &Acirc;&acute;ph&Acirc;&acute;) which will make
the code go into the private header file. Sometimes you want
<br>
some code (other includes) to appear before the extern
&quot;C&quot; and the protecting define. To do this you can
put them into the &Acirc;&acute;headertop&Acirc;&acute; (or
&Acirc;&acute;ht&Acirc;&acute;) section. You may wish to
<br>
include code or comments in all the files, which you can do
by putting them into the &Acirc;&acute;all&Acirc;&acute; (or
&Acirc;&acute;a&Acirc;&acute;) section. Similarly, code you
wish to appear at the top of all files go in the <br>
&Acirc;&acute;alltop&Acirc;&acute; (or
&Acirc;&acute;at&Acirc;&acute;) section. When you want code
to appear as in alltop but only in the cfile you use the
&Acirc;&acute;ctop&Acirc;&acute; (or
&Acirc;&acute;ct&Acirc;&acute;) section. Note that ctop
requires 2.0.18. Finally, <br>
&Acirc;&acute;afterdecls&Acirc;&acute; includes code between
the declarations and the method implementations, but note
that &Acirc;&acute;afterdecls&Acirc;&acute; requires version
2.0.16. For example:</p>

<p style="margin-top: 1em">%alltop{ <br>
/* this will be at the very top of all output files */ <br>
%}</p>

<p style="margin-top: 1em">%ctop{ <br>
/* this will be at the very top of the C file */ <br>
/* Requires 2.0.18 */ <br>
%}</p>

<p style="margin-top: 1em">%headertop{ <br>
/* this will be on top of the public header */ <br>
%}</p>

<p style="margin-top: 1em">%privateheader{ <br>
/* this will go into the private header file */ <br>
%}</p>

<p style="margin-top: 1em">%h{ <br>
/* will be included in the header */ <br>
void somefunc(int i); <br>
%}</p>

<p style="margin-top: 1em">%a{ <br>
/* will be included in all files */ <br>
%}</p>

<p style="margin-top: 1em">%afterdecls{ <br>
/* between the declarations and the method implementations
*/ <br>
/* Requires gob version 2.0.16 */ <br>
%}</p>

<p style="margin-top: 1em">%{ <br>
/* will be included in the C file */ <br>
void somefunc(int i) <br>
{ <br>
/* some code */ <br>
} <br>
%}</p>

<p style="margin-top: 1em">INCLUDE FILES <br>
Gob will automatically include the class header file at the
top of the .c source file. If you wish to include it
somewhere else, put the include into some %{ %} section
above <br>
the class definition, and gob will not include it
automatically. This way you can avoid circular includes and
control where in the file do you want to include the
header.</p>

<p style="margin-top: 1em">If you made any data members
private, gob will also create a source file that will be
called &lt;basename&gt;-private.h. Same rule as above
applies for this just as it does for the <br>
regular header file. If you do explicitly include the
regular header file, you should always include this private
header file below it. That is, if you use any private data
<br>
members. If you don&Acirc;&acute;t, the private header file
automatically includes the public header file, and thus the
public header file will be indirectly included at the very
top of the <br>
file.</p>

<p style="margin-top: 1em">THE CLASS HEADER <br>
There can be only one class per input file. Defining a class
is sort of like in Java, you define the class and write
inline code directly into the class definition. To define a
<br>
class you need to specify the new object name and the name
of the object from which it is derived from, such as this
&quot;class &lt;new type&gt; from &lt;parent type&gt; {
&lt;class code&gt; }&quot;. For <br>
example:</p>

<p style="margin-top: 1em">class Gtk:New:Button from
Gtk:Button { <br>
&lt;class code&gt; <br>
}</p>

<p style="margin-top: 1em">To make an abstract class (to
pass G_TYPE_FLAG_ABSTRACT) add
&Acirc;&acute;(abstract)&Acirc;&acute; before the curly
braces above. This works since version 2.0.13.</p>

<p style="margin-top: 1em">DATA MEMBERS <br>
There are five types of data members. Three of them are
normal data members, one is class wide (global) in scope and
one is a virtual one, usually linked to a normal data member
<br>
or a class wide data member. The three normal data members
are public, protected and private. Public and protected are
basically just entries in the object structure, while <br>
private has it&Acirc;&acute;s own dynamically allocated
private structure. Protected members are always put after
the public one in the structure and are marked protected in
the header file. <br>
There is only one identifier allowed per typename unlike in
normal C. Example:</p>

<p style="margin-top: 1em">public int i; <br>
private GtkWidget *h; <br>
protected long k;</p>

<p style="margin-top: 1em">Public and protected data
members are accessed normally as members of the object
struct. Example where &Acirc;&acute;i&Acirc;&acute; is as
above a public data member:</p>

<p style="margin-top: 1em">object-&gt;i = 1;</p>

<p style="margin-top: 1em">The private data members are
defined in a structure which is only available inside the .c
file, or by including a private header file. You must access
them using the structure <br>
_priv. Example where &Acirc;&acute;h&Acirc;&acute; is the
private data member (as in the above example):</p>

<p style="margin-top: 1em">object-&gt;_priv-&gt;h =
NULL;</p>

<p style="margin-top: 1em">The _priv structure is defined
in the &lt;basename&gt;-private.h. This file is
automatically included if you don&Acirc;&acute;t include it
yourself. You should always explicitly include it in <br>
your .gob file if you explicitly also include the main
header file. The reason it is a separate header file is that
you can also include it in other places that need to access
<br>
this objects private data, such as if you have the majority
of functionality of an object in a separate .c file. Or if a
derived object needs to access the protected methods.</p>

<p style="margin-top: 1em">In case you use the
--no-private-header option, no private header file is
created and you can only access the _priv pointer below the
class definition in the .gob file.</p>

<p style="margin-top: 1em">Also note that this structure is
dynamically allocated, and is freed in the finalize handler.
If you override the finalized handler, your code will be run
first and only then <br>
will the _priv structure be freed.</p>

<p style="margin-top: 1em">Classwide data members:</p>

<p style="margin-top: 1em">Sometimes you want a datamember
to be shared by all objects. You then need the
&quot;classwide&quot; scope keyword. So for example the
following adds a global member foo:</p>

<p style="margin-top: 1em">classwide int foo;</p>

<p style="margin-top: 1em">To access the member you can use
the SELF_GET_CLASS macro (or YOUR_OBJECT_NAME_GET_CLASS) to
get at the class. Thus the following would work:</p>

<p style="margin-top: 1em">SELF_GET_CLASS(object)-&gt;foo =
20;</p>

<p style="margin-top: 1em">Automatic Initialization:</p>

<p style="margin-top: 1em">You can automatically initialize
the public private and protected data members without having
to add an init method. The advantage here is that
initialization is kept close to <br>
the definition of the data member and thus it&Acirc;&acute;s
easier to check. To do this, just add a
&Acirc;&acute;=&Acirc;&acute; followed by a number or a
token. It is also possible to include arbitrary C code for
<br>
more elaborate initializations by putting it all in curly
braces. Note that the curly braces will not be printed into
the output, but since gob does not C parsing it needs them
<br>
to figure out where the C code ends. The code will be
inserted into the init method, above the user defined body.
So for example the following will initialize an integer to
-1 <br>
and a string with a newly allocated string of
&quot;hello&quot;.</p>

<p style="margin-top: 1em">public int foo = -1; <br>
private char *bar = {g_strdup(&quot;hello&quot;)};</p>

<p style="margin-top: 1em">Automatic Destruction:</p>

<p style="margin-top: 1em">Most data stored as pointers
needs to have a function called when the object is finalized
to either free the data. Gob will let you define a function
to be called on the data <br>
the object is finalized. This is achieved by putting
&Acirc;&acute;destroywith&Acirc;&acute; followed by a
function name after the variable definition. It is only
called if the data you defined this on <br>
is not NULL, so you cans specify functions which do not
handle NULL. It is very much like the GDestroyNotify
function used in GTK+ and glib in many places. Unlike many
other <br>
places, gob will not enforce any kind of type safety here so
be a little bit more careful. Any function you give it will
be called as a &quot;void function(void *)&quot;. It will in
fact <br>
be cast into such a form before called. This is to avoid
spurious warnings for gtk calls to subclass methods. The
function needs not be of that form exactly, it just has to
<br>
take one argument which is the pointer to the data. You
should also not define this on any non-pointer data as the
results may be undefined. Example:</p>

<p style="margin-top: 1em">public char *foo =
{g_strdup(&quot;bar&quot;)} <br>
destroywith g_free;</p>

<p style="margin-top: 1em">Note that the function name you
give must be a real function and not macro. Also note that
this is always called in the &quot;finalize&quot; method of
GObject. It is always called after <br>
any user defined body of the finalize handler.</p>

<p style="margin-top: 1em">Sometimes you may want to run
arbitrary code on destruction. While this can be perfectly
well done in the finalize handler. Depending on the style
you may want to include all <br>
destruction/initialization code together with the definition
of the data member. Thus you may want to put arbitrary code
which will then be inserted into the &quot;finalize&quot;
method <br>
of GObject. This can be done with the &quot;destroy&quot;
keyword followed by arbitrary code in curly braces. Inside
this code a macro called VAR will be define which refers to
your <br>
variable. So for example destroying a GString can be either
done with a helper routine or the following code:</p>

<p style="margin-top: 1em">public GString *string =
{g_string_new(NULL)} <br>
destroy { <br>
if(VAR) g_string_free(VAR, TRUE); <br>
};</p>

<p style="margin-top: 1em">The thing to remember with these
is that there are many ways to do this and
you&Acirc;&acute;d better be consistent in your code in how
you use the above things. Also defining a helper rou&acirc;
<br>
tine that will do the destruction will be a nicer thing to
do if that&Acirc;&acute;s a possibility. The
&quot;destroy&quot; keyword with code does take up more
space in the file and it may become more <br>
cluttered.</p>

<p style="margin-top: 1em">The data is zeroed out after
being destroyed. This is to make debugging easier in case
your code might try to access an already finalized object.
In case you have overridden <br>
the finalize method, your code will be run first and only
then will the destructors be called. You should not however
make any assumptions about the order at which the
destruc&acirc; <br>
tors are called. If you have interdependencies between
destructors for different data members, you will have to do
this in your own finalize override function.</p>

<p style="margin-top: 1em">Automatic Unreffing:</p>

<p style="margin-top: 1em">This is very much like the
automatic destruction, but is instead run in the dispose
method (it is among other places called from the
&quot;destroy&quot; method of GtkObject). All data and <br>
other objects that you need to unref should be done here,
and not at finalize time. The semantics are otherwise the
same as for the &quot;destroywith&quot; and
&quot;destroy&quot; keywords, except <br>
that you use &quot;unrefwith&quot; and
&quot;unref&quot;.</p>

<p style="margin-top: 1em">public G:Object *foo = NULL <br>
unrefwith g_object_unref; <br>
public G:Object *bar = NULL <br>
unref { <br>
g_object_unref (VAR); <br>
};</p>

<p style="margin-top: 1em">GOBJECT PROPERTIES <br>
The fourth type of a data member a property type. It is a
named data member which is one of the features of the
GObject system. It just defines a way to get and set some
data, <br>
but you have to take care of storing that data somewhere. So
it is normal to also have a normal private (or public) data
member where you store the real data. You normally need <br>
to define a get and a set handler. They are fragments of C
code that will be used to get the value or set the value of
the argument. Inside them you can use the define VAL to <br>
which you assign the data or get the data. You should treat
this VAL as a GValue which stores the data of the correct
type. You can also use the identifier &quot;self&quot; as
pointer to <br>
the object instance. The type is defined as one of the
GObject type enums, but without the G_TYPE_ prefix. There
are also some attributes of a property which you can set.
For <br>
example the following is a definition of an integer property
&Acirc;&acute;height&Acirc;&acute; which will be
synchronized with a private integer data member also of the
name &Acirc;&acute;height&Acirc;&acute;.</p>

<p style="margin-top: 1em">private int height; <br>
property INT height <br>
(nick = _(&quot;Short nickname&quot;), <br>
blurb = _(&quot;Long description&quot;), <br>
minimum = 10, <br>
maximum = 200, <br>
default_value = 100) <br>
set { self-&gt;_priv-&gt;height = g_value_get_int (VAL); }
<br>
get { g_value_set_int (VAL, self-&gt;_priv-&gt;height);
};</p>

<p style="margin-top: 1em">The attributes are really
optional though you should at least set some of them. All
property types have a &Acirc;&acute;nick&Acirc;&acute; and a
&Acirc;&acute;blurb&Acirc;&acute; attribute and you should
set those accordingly. <br>
This will make runtime querying the object nicer as things
such as gui editors and class browsers can be more verbose
about the class itself. You can use the
&Acirc;&acute;_(&quot;string&quot;)&Acirc;&acute;
nota&acirc; <br>
tion instead of just &quot;string&quot;, and that will mark
the string for translation.</p>

<p style="margin-top: 1em">Almost all types also have a
&Acirc;&acute;default_value&Acirc;&acute; attribute which
sets the initial value of this property (on object
initialization, the set handler will be run automatically
with <br>
this value). This value will be overridden if the user sets
a value of this property on the call to g_object_new.</p>

<p style="margin-top: 1em">All the numeric types (including
CHAR) have &Acirc;&acute;minimum&Acirc;&acute; and
&Acirc;&acute;maximum&Acirc;&acute; attributes which can
restrict the range. If you do not specify these the range
will be the full range that <br>
the data type can handle.</p>

<p style="margin-top: 1em">Types such as UNICHAR and
BOOLEAN only have the &Acirc;&acute;nick&Acirc;&acute;,
&Acirc;&acute;blurb&Acirc;&acute; and
&Acirc;&acute;default_value&Acirc;&acute; attributes.</p>

<p style="margin-top: 1em">The ENUM type has an
&Acirc;&acute;enum_type&Acirc;&acute; attribute which is the
exact type of the enum. This is so that the property knows
which exact type you can set, rather then just knowing it is
<br>
an enum. You should always create an enum type specific for
the enum itself (see section on the enum types)</p>

<p style="margin-top: 1em">Similarly FLAGS type has a
&Acirc;&acute;flags_type&Acirc;&acute; which again you
should set to the specific type of this flags data
member.</p>

<p style="margin-top: 1em">There is a STRING type which has
only the extra &Acirc;&acute;default_value&Acirc;&acute;
attribute.</p>

<p style="margin-top: 1em">The OBJECT type is one of the
types that doesn&Acirc;&acute;t have a
&Acirc;&acute;default_value&Acirc;&acute; and it only has an
&Acirc;&acute;object_type&Acirc;&acute; attribute (in
addition to nick and blurb of course) that is the exact <br>
object type that this property accepts. The object_type
should be as a type, that is for example
&Acirc;&acute;Gtk:Button&Acirc;&acute;.</p>

<p style="margin-top: 1em">There is a BOXED type which is a
pointer which has a boxed type defined (such that GObject
knows how to copy and destroy this pointer). Here you will
need to specify the <br>
&Acirc;&acute;boxed_type&Acirc;&acute; attribute with the
specific type of the boxed pointer.</p>

<p style="margin-top: 1em">There is also a POINTER type,
which has only the &Acirc;&acute;nick&Acirc;&acute; and
&Acirc;&acute;blurb&Acirc;&acute; attributes. This is for
storing arbitrary pointers. You should be careful with this
one, as GObject knows <br>
nothing about the data stored at this pointer. It is
somewhat like a &Acirc;&acute;void *&Acirc;&acute; type.</p>

<p style="margin-top: 1em">There is also the PARAM type for
storing parameters with a
&Acirc;&acute;param_type&Acirc;&acute; attribute.</p>

<p style="margin-top: 1em">You should notice that this list
is pretty much like the list of g_param_spec_* functions
from gobject/gparamspecs.h, and the attributes are like the
arguments of those func&acirc; <br>
tions. Note however that value array is NOT supported
yet.</p>

<p style="margin-top: 1em">You can also specify extra
flags, such as CONSTRUCT or CONSTRUCT_ONLY using the
&Acirc;&acute;flags&Acirc;&acute; attribute. You can specify
multiple flags by oring them together with
&Acirc;&acute;|&Acirc;&acute;. These flags <br>
correspond to the GParamFlags enumeration except do not
include the G_PARAM_ prefix. So for example to define an
enumeration property, which is a CONSTRUCT_ONLY property, we
<br>
could do the following:</p>

<p style="margin-top: 1em">private SomeEnumerationType foo;
<br>
property ENUM foo <br>
(nick = _(&quot;Short nickname&quot;), <br>
blurb = _(&quot;Long description&quot;), <br>
enum_type = Some:Enumeration:Type <br>
default_value = SOME_ENUMERATION_VALUE, <br>
flags = CONSTRUCT_ONLY, <br>
link);</p>

<p style="margin-top: 1em">The above example also gives an
example of automatic linking to a standard data memember. By
including the attribute &Acirc;&acute;link&Acirc;&acute; a
get and set handlers will be automatically added <br>
without having to type them by hand. This is useful for a
vast majority data types that are just linked to some
standard data member and do not need to do anything extra on
get <br>
or set.</p>

<p style="margin-top: 1em">Another extra feature of
properties is the possibility of automatically exporing
methods to get and set the property. That is without having
to use g_object_set and <br>
g_object_get. This is achieved by adding an
&Acirc;&acute;export&Acirc;&acute; attribute to the list of
property attributes.</p>

<p style="margin-top: 1em">If you do not define a set or
get handler, the property will automatically be only
readable or writable as appropriate.</p>

<p style="margin-top: 1em">Gob2 also creates macros which
can be used for type safe access to properties through
g_object_set and g_object_get. The macros are called
&lt;type&gt;_PROP_&lt;argument name&gt;(x) and <br>
&lt;type&gt;_GET_PROP_&lt;argument name&gt;(x). They define
both the string and the value part of the argument. So for
setting an argument of height, one would use (for object
type <br>
My:Object):</p>

<p style="margin-top: 1em">g_object_set (G_OBJECT (object),
<br>
MY_OBJECT_PROP_HEIGHT (7), <br>
NULL);</p>

<p style="margin-top: 1em">And for getting, you would
use:</p>

<p style="margin-top: 1em">int height; <br>
g_object_get (G_OBJECT (object), <br>
MY_OBJECT_GET_PROP_HEIGHT (&amp;height), <br>
NULL);</p>

<p style="margin-top: 1em">Note however that the type
safety only works completely on GNU C compilers. The code
will compile on other compilers but with minimal type
safety. For complete type safety it <br>
is useful to use the get/set methods that are defined by
using the &Acirc;&acute;export&Acirc;&acute; attribute.</p>

<p style="margin-top: 1em">To get bettery type safety on
some of the property types, you can specify the
&Acirc;&acute;type&Acirc;&acute; attribute which will add
casts where appropriate in code dealing with this property.
This is <br>
especially useful for POINTER and OBJECT types. But even for
others.</p>

<p style="margin-top: 1em">You can also override properties
from parent objects (that is override their implementation,
not their attributes). Do this by adding the special
&Acirc;&acute;override&Acirc;&acute; attribute. For <br>
example if the parent object had a
&Acirc;&acute;height&Acirc;&acute; property then you could
override it by</p>

<p style="margin-top: 1em">private int height; <br>
property INT height <br>
(override) <br>
set { self-&gt;_priv-&gt;height = g_value_get_int (VAL); }
<br>
get { g_value_set_int (VAL, self-&gt;_priv-&gt;height);
};</p>

<p style="margin-top: 1em">Overriding is supported since
gob 2.0.10.</p>

<p style="margin-top: 1em">METHODS <br>
There is a whole array of possible methods. The three
normal, &quot;familiar&quot; method types are private,
protected and public. Public are defined as normal functions
with a prototype <br>
in the header file. Protected methods are defined as normal
methods (which you can call from other files), but their
prototype is placed in the private header file. Private <br>
methods are defined as static functions with prototypes at
the top of the .c file. Then there are signal, virtual and
override methods. More on those later. You can also <br>
define init and class_init methods with a special definition
if you want to add code to the constructors or you can just
leave them out. You can also not define a body for a <br>
method, by just using &Acirc;&acute;;&Acirc;&acute; instead
of a body. This will define an empty function. You
can&Acirc;&acute;t do this for non-void regular public,
private or protected methods, however it is <br>
acceptable for non-void virtual, signal and override
methods.</p>

<p style="margin-top: 1em">Function argument lists:</p>

<p style="margin-top: 1em">For all but the init and
class_init methods, you use the following syntax for
arguments. The first argument can be just &quot;self&quot;,
which gob will translate into a pointer to the <br>
object instance. The rest of the arguments are very similar
to normal C arguments. If the typename is an object pointer
you should use the syntax defined above with the words <br>
separated by &Acirc;&acute;:&Acirc;&acute; <br>
&lt;type&gt; &lt;argument id&gt; <br>
or <br>
&lt;type&gt; &lt;argument id&gt; (check &lt;list of
checks&gt;)</p>

<p style="margin-top: 1em">The checks are glib type
preconditions, and can be the following: &quot;null&quot;,
which tests pointers for being NULL, &quot;type&quot; which
checks GTK+ object pointers for being the right type, <br>
&quot;&lt;test&gt; &lt;number&gt;&quot; which tests numeric
arguments for being a certain value. The test can be a
&lt;,&gt;,&lt;=,&gt;= != or ==. Example:</p>

<p style="margin-top: 1em">public int <br>
foo (self, <br>
int h (check &gt; 0 &lt; 11), <br>
Gtk:Widget *w (check null type))</p>

<p style="margin-top: 1em">This will be the prototype of a
function which has a self pointer as the first argument, an
integer argument which will be checked and has to be more
then 0 and less then 11, and <br>
a pointer to a GtkWidget object instance and it is checked
for being null and the type will also be checked.</p>

<p style="margin-top: 1em">Function attributes:</p>

<p style="margin-top: 1em">For method that aren&rsquo;t
virtual, signal or override methods, and aren&rsquo;t init
or class_init, GLib function attribute macros G_GNUC_PRINTF,
G_GNUC_SCANF, and G_GNUC_FORMAT can <br>
optionally be included after the argument list. Simply
include an &Acirc;&acute;attr&Acirc;&acute; keyword and the
C code to include in the file. You have to include braces
and anything inside the <br>
braces will be printed into the header file after the
function declaration and before the trailing semicolon. The
braces themselves are not printed. For example:</p>

<p style="margin-top: 1em">public void <br>
print (self, const char *format (check null), ...) <br>
attr {G_GNUC_PRINTF(2, 3)}</p>

<p style="margin-top: 1em">This will produce a prototype
which will generate a warning at compile time if the
contents of the format argument (argument number 2)
aren&rsquo;t consistent with the types and number <br>
of the subsequent variadic arguments (the first of which is
argument number 3). Only one
&Acirc;&acute;attr&Acirc;&acute; keyword per method is
allowed. If you have more than one attribute to include,
<br>
you should put them all within the braces. Note that
function attributes were aded in version 2.0.16.</p>

<p style="margin-top: 1em">Error return:</p>

<p style="margin-top: 1em">Methods which have a return
value, there also has to be something returned if there is
an error, such as if a precondition is not met. The default
is 0, casted to the type of <br>
the method. If you need to return something else then you
can specify an &Acirc;&acute;onerror&Acirc;&acute; keyword
after the prototype and any optional function attribute
macros, and after that a num&acirc; <br>
ber, a token (an identifier) or a bit of C code enclosed in
braces {}. The braces will not be printed into the output,
they just delimit the string. For example:</p>

<p style="margin-top: 1em">public void * get_something
(self, int i (check &gt;= 0)) onerror NULL { <br>
... <br>
}</p>

<p style="margin-top: 1em">The onerror value is also used
in overrides that have a return value, in case there
isn&Acirc;&acute;t a parent method, PARENT_HANDLER will
return it. More about this later.</p>

<p style="margin-top: 1em">Default return:</p>

<p style="margin-top: 1em">Some signal and virtual methods
have a return type. But what happens if there is no default
handler and no one connects to a signal. GOB2 will normally
have the wrappers return <br>
whatever you specify with onerror or
&Acirc;&acute;0&Acirc;&acute; if you haven&Acirc;&acute;t
specified anything. You can also specify a default return
value with the keyword
&Acirc;&acute;defreturn&Acirc;&acute;. It&Acirc;&acute;s use
is identical to <br>
the use of onerror, and you can in fact use both at the same
time. Example</p>

<p style="margin-top: 1em">virtual int get_some_int (self)
onerror -1 defreturn 10 ;</p>

<p style="margin-top: 1em">That is an empty virtual method
(in C++ terms a pure virtual). If you never specify any
handler for it in the derived children it will just return
10.</p>

<p style="margin-top: 1em">Constructor methods:</p>

<p style="margin-top: 1em">There are two methods that
handle the construction of an object, init and class_init.
You define them by just using the init or class_init keyword
with an untyped argument in <br>
the argument list. The argument will be usable in your
function as a pointer to your object or class depending if
it&Acirc;&acute;s init or class_init. For example:</p>

<p style="margin-top: 1em">init (self) { <br>
/* initialize the object here */ <br>
self-&gt;a = 9; <br>
self-&gt;b = 9; <br>
}</p>

<p style="margin-top: 1em">class_init (class) { <br>
/* initialize the class, this is rarely needed */ <br>
class-&gt;blah = NULL; <br>
}</p>

<p style="margin-top: 1em">The class_init function is very
rarely needed as all standard class initialization is taken
care of for you by gob itself. The init function should on
the other hand be used <br>
whenever you need to construct or initialize anything in the
object to put it into a sane state.</p>

<p style="margin-top: 1em">Constructor, dispose, finalize
methods:</p>

<p style="margin-top: 1em">Since 2.0.16, you can also
easily add code to the object&rsquo;s constructor, dispose,
and finalize methods. See GObject documentation on how these
are run. The code you add will be <br>
run before calling the parents function for dispose and
finalize, and after the parent function for constructor. The
syntax is just like init and class_init. For example:</p>

<p style="margin-top: 1em">constructor (self) { <br>
/* constructor method */ <br>
}</p>

<p style="margin-top: 1em">dispose (self) { <br>
/* dispose method */ <br>
}</p>

<p style="margin-top: 1em">finalize (self) { <br>
/* finalize method */ <br>
}</p>

<p style="margin-top: 1em">You can also just override those
methods as usual, but the above is much easier and nearly as
flexible.</p>

<p style="margin-top: 1em">Virtual methods:</p>

<p style="margin-top: 1em">Virtual methods are basically
pointers in the class structure, so that one can override
the method in derived methods. That is to implement the
method in a derived class, you <br>
must then use an override method (more on those later). They
can be empty (if you put &Acirc;&acute;;&Acirc;&acute;
instead of the C code). A wrapper will also be defined which
makes calling the methods <br>
he same as public methods. This type of method is just a
little bit &quot;slower&quot; then normal functions, but not
as slow as signals. You define them by using
&quot;virtual&quot; keyword <br>
before the prototype. If you put the keyword
&quot;private&quot; right after the &quot;virtual&quot;
keyword, the wrapper will not be a public method, but a
private one. You can do the same with <br>
&quot;protected&quot; to make a protected wrapper.</p>

<p style="margin-top: 1em">Signals:</p>

<p style="margin-top: 1em">Signals are methods to which the
user can bind other handlers and override the default
handler. The default handler is basically the method body.
This is the most versatile and <br>
flexible type of a method and also the slowest. You need to
specify a whole bunch of things when you define a signal.
One thing is when the default handler will be run, first
<br>
or last. You specify that by &quot;first&quot; or
&quot;last&quot; right after the &quot;signal&quot; keyword.
Then you need to define the GObject enum types (again
without the G_TYPE_ prefix). For that <br>
you define the return types and the types of arguments after
the &quot;self&quot; pointer (not including the
&quot;self&quot; pointer). You put it in the following
syntax &quot;&lt;return type&gt; (&lt;list of <br>
arguments&gt;)&quot;. If the return type is void, the type
should be &quot;NONE&quot;, the same should be for the
argument list. The rest of the prototype is the same as for
other method types. <br>
The body can also be empty, and also there is a public
method wrapper which you can use for calling the signal just
like a public method. Example:</p>

<p style="margin-top: 1em">signal first INT (POINTER, INT)
<br>
int do_something (self, Gtk:Widget *w (check null type), int
length) <br>
{ <br>
... <br>
}</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">signal last NONE (NONE) void foo
(self);</p>

<p style="margin-top: 1em">If you don&Acirc;&acute;t want
the wrapper that emits the signal to be public, you can
include the keyword &quot;private&quot; after the
&quot;signal&quot; keyword. This will make the wrapper a
normal private <br>
method. You can also make a protected wrapper by using
&quot;protected&quot; instead of &quot;private&quot;.</p>

<p style="margin-top: 1em">If you don&Acirc;&acute;t define
a &quot;first&quot; or a &quot;last&quot;, the default will
be taken as &quot;last&quot;.</p>

<p style="margin-top: 1em">You can also add additional
flags. You do this just like with the argument flags,
although this is probably very rare. These are the
G_SIGNAL_* flags, and you can add them <br>
without the G_SIGNAL_ prefix into a parenthesis, just after
the &quot;signal&quot; keyword. By default all public
signals are G_SIGNAL_ACTION.</p>

<p style="margin-top: 1em">Also gob2 creates a wrapper
macros for typesafe signal connection. That is you will be
warned by the compiler if you pass a callback that is not
the correct prototype. This <br>
will again only warn you on gcc, but it will compile without
warning on another compiler. So as with all the typesafety
hacks in gob, it is better to test your objects under gcc
<br>
to get any warnings even if you are using a different
compiler in the end.</p>

<p style="margin-top: 1em">The methods that are created for
you are:</p>


<p style="margin-top: 1em">&lt;class_name&gt;_connect__&lt;signal_name&gt;
(&lt;object&gt;, &lt;callback&gt;, &lt;data&gt;) <br>
&lt;class_name&gt;_connect_after__&lt;signal_name&gt;
(&lt;object&gt;, &lt;callback&gt;, &lt;data&gt;) <br>
&lt;class_name&gt;_connect_data__&lt;signal_name&gt;
(&lt;object&gt;, &lt;callback&gt;, &lt;data&gt;, <br>
&lt;destroy_notify&gt;, &lt;flags&gt;)</p>

<p style="margin-top: 1em">These three functions correspond
to the g_signal_connect, g_signal_connect_after and
g_signal_connect_data functions that you would normally use,
except they are for a specific <br>
signal. Also do note the two underscores between the method
name and the signal name. For example to connect the signal
&quot;foo&quot; on the object &quot;Test:Object&quot; you
would do:</p>

<p style="margin-top: 1em">test_object_connect__foo
(object, callback, data);</p>

<p style="margin-top: 1em">To use BOXED in the signal
arguments you need to tell gob which type of boxed argument
you want to use. For this you can just add
BOXED_GTK_TYPE_STRING instead of BOXED. For <br>
example BOXED_GTK_TYPE_TREE_ITER for GtkTreeIter. This works
since version 2.0.13.</p>

<p style="margin-top: 1em">Override methods:</p>

<p style="margin-top: 1em">If you need to override some
method (a signal or a virtual method of some class in the
parent tree of the new object), you can define and override
method. After the &quot;override&quot; <br>
keyword, you should put the typename of the class you are
overriding a method from. Other then that it is the same as
for other methods. The &quot;self&quot; pointer in this case
should <br>
be the type of the method you are overriding so that you
don&Acirc;&acute;t get warnings during compilation. Also to
call the method of the parent class, you can use the
PARENT_HANDLER macro <br>
with your arguments. Example:</p>

<p style="margin-top: 1em">override (Gtk:Container) void
<br>
add (Gtk:Container *self (check null type), Gtk:Widget *wid
(check null type)) <br>
{ <br>
/* some code here */ <br>
PARENT_HANDLER(self, wid); <br>
}</p>

<p style="margin-top: 1em">If the function has a return
value, then PARENT_HANDLER is an expression that you can
use. It will return whatever the parent handler returned, or
the &quot;onerror&quot; expression if <br>
there was no parent handler.</p>

<p style="margin-top: 1em">Method names:</p>

<p style="margin-top: 1em">Inside the code, aliases are set
for the methods, so that you don&Acirc;&acute;t have to type
the class name before each call, just type self_ instead of
the name of the class. So to call a <br>
method called blah, you would use the name self_blah.
Example:</p>

<p style="margin-top: 1em">private int <br>
foo (self) <br>
{ <br>
return self-&gt;len; <br>
}</p>

<p style="margin-top: 1em">private int <br>
bar (self, int i) <br>
{ <br>
return self_foo (self) + i; <br>
}</p>

<p style="margin-top: 1em">MAKING NEW OBJECTS <br>
You should define a new method which should be a normal
public method. Inside this method, you can use the GET_NEW
macro that is defined for you and that will fetch a new <br>
object, so a fairly standard new method would look like:</p>

<p style="margin-top: 1em">public GObject * <br>
new (void) { <br>
GObject *ret = GET_NEW; <br>
return G_OBJECT (ret); <br>
}</p>

<p style="margin-top: 1em">You should not a subtle
peculiarity of the GObject system here. If there is any code
inside the G_OBJECT macro argument, it will get executed
multiple times. This means that <br>
things such as G_OBJECT(GET_NEW) would actually create 4
objects, leaking 3 of them. A good rule (as with anywhere in
C) is to be careful with all macros.</p>

<p style="margin-top: 1em">SELF REFERENCES <br>
Self alias casts:</p>

<p style="margin-top: 1em">There are some standard casts
defined for you. Instead of using the full macros inside the
.c file, you can use SELF, IS_SELF and SELF_CLASS. Using
these makes it easier to for <br>
example change class names around.</p>

<p style="margin-top: 1em">Self alias types:</p>

<p style="margin-top: 1em">There are also the Self and
SelfClass types inside your .c file. These serve the same
function as the above, they make it easier to type and
easier to change typenames around <br>
which can help a lot during prototyping stage. However you
should note that the Self type should not be used in
function prototypes as one of the arguments or as a return
value <br>
type. This is because this is a simple C typedef which is
only available inside your .c file and not in the header
files. You can disable both the self casting macros and the
<br>
self type aliases by passing --no-self-alias to gob.</p>

<p style="margin-top: 1em">DEALING WITH DIFFERENT GOB
VERSIONS <br>
Defines:</p>

<p style="margin-top: 1em">In your generated C file, you
can use the defines GOB_VERSION_MAJOR GOB_VERSION_MINOR and
GOB_VERSION_PATCHLEVEL if you wish to for example use a
feature that is only available <br>
in some newer gob version. Note however that you can only
use these defines in the C code portions of your .gob file,
and #ifdef&Acirc;&acute;s cannot span multiple functions.
Check the <br>
BUGS section for more on using the C preprocessor and
gob.</p>

<p style="margin-top: 1em">Minimum version requires:</p>

<p style="margin-top: 1em">You can also make your .gob file
require at least certain version of gob. You do this by
putting &Acirc;&acute;requires x.y.z&Acirc;&acute; (where
x.y.z is the version number) outside of any C block, <br>
comment or class, usually you should make this the first
line in the file or close to the top. If gob finds this and
the version of gob used to compile the code is lower then
<br>
that listed in the require, gob will generate an error and
exit. For example to require that gob2 version 2.0.0 or
higher be used to compile a file, put this at the top of
that <br>
file:</p>

<p style="margin-top: 1em">requires 2.0.0</p>

<p style="margin-top: 1em">CREATING NEW ENUM, FLAGS and
ERROR TYPES <br>
You can create new GObject ENUM, FLAGS and GError types for
use in your classes easily. Glib includes some utilities for
handling these, however it may be cleaner to use the <br>
below specified way in your classes. It also then
doesn&Acirc;&acute;t require any Makefile setup. Make sure
this is defined in the same section as the class, that is
not in any of the <br>
&Acirc;&acute;%?{&Acirc;&acute;
&Acirc;&acute;%}&Acirc;&acute; sections.</p>

<p style="margin-top: 1em">You use the keywords
&Acirc;&acute;enum&Acirc;&acute;
&Acirc;&acute;flags&Acirc;&acute; and
&Acirc;&acute;error&Acirc;&acute; as you would use the
&Acirc;&acute;class&Acirc;&acute; keyword. Then you give a
prefix for the values in the enumeration. Then you define a
list of values <br>
just like in C. For &Acirc;&acute;enum&Acirc;&acute; types
you can also specify the values assigned to each string.
Then you specify the type in the standard gob style of
specifying types. Here are a <br>
few examples of all of these:</p>

<p style="margin-top: 1em">enum LAME_CLIENT { <br>
IS_CONNECTED, <br>
NONE = 9, <br>
LAST <br>
} Test:Enum;</p>

<p style="margin-top: 1em">flags BUGA_BUGA { <br>
ONE, <br>
TWO, <br>
MANY, <br>
} Some:Flags;</p>

<p style="margin-top: 1em">error TEST_OBJECT_ERROR { <br>
BAD_THIS, <br>
BAD_THAT <br>
} Test:Object:Error;</p>

<p style="margin-top: 1em">This will for example define an
enum that is equivalent to the following C code:</p>

<p style="margin-top: 1em">typedef enum { <br>
LAME_CLIENT_IS_CONNECTED, <br>
LAME_CLIENT_NONE = 9, <br>
LAME_CLIENT_LAST <br>
} TestEnum;</p>

<p style="margin-top: 1em">C++ MODE <br>
There is a C++ mode so that gob creates C++ compiler
friendly files. You need to use the --for-cpp argument to
gob. This will make the generated file have a .cc instead of
a .c <br>
extension, and several things will be adjusted to make it
all work for a C++ compiler. One thing that will be missing
is an alias to the new method, as that clashes with C++, so
<br>
instead you&Acirc;&acute;ll have to use the full name of the
method inside your code. Also note that gob does not use any
C++ features, this option will just make the generated code
compile <br>
with a C++ compiler.</p>

<p style="margin-top: 1em">OVERRIDING THE GET_TYPE METHOD
<br>
The get_type is not really a method, but a function which
initializes your object. Recently objects appeared which
require you to make a custom get_type function. So it is
pos&acirc; <br>
sible to override this function. To do so, just define a new
public method called get_type, with no arguments.
Example:</p>

<p style="margin-top: 1em">public GType <br>
get_type (void) <br>
{ <br>
/* code goes here */ <br>
return some_type; <br>
}</p>

<p style="margin-top: 1em">INTERFACES <br>
Currently gob will only allow you to implement interfaces
(that is, define new classes which implement an interface)
and doesn&Acirc;&acute;t yet have support for making new
interfaces, but <br>
this will be coming at some point in the future.</p>

<p style="margin-top: 1em">To define a class that
implements an interface add a class flag
&Acirc;&acute;interface&Acirc;&acute; with the type name of
the interface as an argument. Then to implement a specific
method of the inter&acirc; <br>
face, just add &Acirc;&acute;interface
&lt;typename&gt;&Acirc;&acute; before the method definition.
The method can, and probably should be, private.</p>

<p style="margin-top: 1em">The following example implements
a new object, that implements the Gtk:Tree:Model interface
and implements the get_flags method of that interface. Do
note that except for stan&acirc; <br>
dard (GTK+ and glib) specific interfaces which seem to have
a non-standard name for the interface structure, the
structure should end with and Iface, if you are implementing
an <br>
interface. That is for example for the Gtk:Tree:Model, the
structure containing the table of methods should be named
GtkTreeModelIface. <br>
class Some:Object from G:Object <br>
(interface Gtk:Tree:Model) <br>
{ <br>
/* function implemented for the Gtk:Tree:Model interface */
<br>
interface Gtk:Tree:Model <br>
private GtkTreeModelFlags <br>
get_flags (Gtk:Tree:Model *self (check null type)) <br>
{ <br>
/* Here would be the implementation */ <br>
return (GtkTreeModelFlags)0; <br>
} <br>
}</p>

<p style="margin-top: 1em">If you want to implement
multiple interfaces just list more class flag lines as
follows:</p>

<p style="margin-top: 1em">class Some:Object from G:Object
<br>
(interface Gtk:Tree:Model) <br>
(interface Gtk:Editable) <br>
{ <br>
/* ... */ <br>
}</p>

<p style="margin-top: 1em">DIRECT BonoboObject SUPPORT <br>
If you want to build a BonoboObject class gob2 has direct
support for these. Just create a new object that derives
from Bonobo:Object. Then use a &quot;BonoboObject&quot;
class flag with <br>
the interface name as an argument. The interface name should
be as you would type it in C, that is with underscores as
namespace separators. Then you add the methods (using <br>
exact same names as in the idl file) and prepend those
methods with a BonoboObject keyword. For example imagine you
have an interface GNOME/Foo/SomeInterface, with a method
foo&acirc; <br>
Bar that takes a single string:</p>

<p style="margin-top: 1em">class Foo:Some:Interface from
Bonobo:Object <br>
(BonoboObject GNOME_Foo_SomeInterface) {</p>

<p style="margin-top: 1em">BonoboObject <br>
private void <br>
fooBar (PortableServer_Servant servant, <br>
const CORBA_char *string, <br>
CORBA_Environment *ev) <br>
{ <br>
Self *self = SELF (bonobo_object_from_servant
(servant));</p>

<p style="margin-top: 1em">/* your code here */ <br>
}</p>

<p style="margin-top: 1em">/* rest of class */ <br>
}</p>

<p style="margin-top: 1em">Note that the implementation
method can be private, in fact that&Acirc;&acute;s probably
a good idea to do. It won&Acirc;&acute;t work to make this a
signal, it can however be a virtual. Note that the <br>
method prototype must match the one from the interface
header file, or you will get a bad assignment warning. You
should check the header file generated by orbit-idl and see
the <br>
epv structure for the correct prototypes if you
can&Acirc;&acute;t figure them out from the idl itself. Also
note that the first argument is not &quot;self&quot;, but
the servant and you must use <br>
bonobo_object_from_servant function to get the actual object
pointer.</p>

<p style="margin-top: 1em">DIRECT LIBGLADE SUPPORT <br>
Gob can simplify writing a libglade class. Just create a new
object that derives from a GtkContainer widget. Then use a
&quot;GladeXML&quot; class flag with the glade file name,
root <br>
widget and optional domain as arguments between double
quotes. For example:</p>

<p style="margin-top: 1em">class My:Glade from Gtk:Window
(GladeXML &quot;gob-libglade.glade&quot; &quot;root&quot;)
<br>
{ <br>
.... <br>
}</p>

<p style="margin-top: 1em">Note however that then
&quot;gob-libglade.glade&quot; would have to be in the
current directory. You could specify a path, but that may
not work for all installations. You can replace <br>
the glade filename with a token to be used in the generated
.c file and you can then have a macro with the filename, as
follows:</p>

<p style="margin-top: 1em">class My:Glade from Gtk:Window
(GladeXML GLADE_FILE &quot;root&quot;) <br>
{ <br>
.... <br>
}</p>

<p style="margin-top: 1em">And somewhere in your header
files you would have</p>

<p style="margin-top: 1em">#define GLADE_FILE
&quot;/path/to/file.glade&quot;</p>

<p style="margin-top: 1em">You can declare widgets as data
members by adding a &rsquo;GladeXML&rsquo; to the
definition.</p>

<p style="margin-top: 1em">private Gtk:Button * button1
GladeXML;</p>

<p style="margin-top: 1em">This will automatically set the
&quot;button1&quot; from the GladeXML file.</p>

<p style="margin-top: 1em">All signals created with glade
are automatically connected if you defined those class
methods in your class. For example suppose in glade that we
set the &quot;connect&quot; signal on <br>
button1 to go to on_button1_clicked, then in our gob file we
can just write:</p>

<p style="margin-top: 1em">public void <br>
on_button1_clicked(self, GtkButton * button) <br>
{ <br>
}</p>

<p style="margin-top: 1em">See the examples directory for a
full example. Note that this feature requires version at
least 2.0.12.</p>

<p style="margin-top: 1em">IDENTIFIER CONFLICTS <br>
Gob will need to define some local variables and functions
in the generated files, so you need to take some precaution
not to conflict with these. The general rule of thumb is
<br>
that all of these start with three underscores. There is
one, &quot;parent_class&quot; which doesn&Acirc;&acute;t
because it&Acirc;&acute;s intended for use in your code. For
virtuals or signals, you cannot use <br>
the identifier __parent__ which is used for the parent of
the object. You should actually never access __parent__
either as it not guaranteed that it will stay named this
way. <br>
Data members cannot be named __parent__ nor _priv. For
methods, you cannot use the identifiers &quot;init&quot; or
&quot;class_init&quot; unless you mean the constructor
methods. You shouldn&Acirc;&acute;t <br>
generally use 3 underscores even in override method argument
lists and virtual and signal method names as it might
confuse the PARENT_HANDLER macro. In fact avoiding all names
<br>
with three underscores is the best policy when working with
gob.</p>

<p style="margin-top: 1em">There are a couple of defines
which you shouldn&Acirc;&acute;t be redefining in the code
or other headers. These are SELF, IS_SELF, SELF_CLASS,
SELF_TYPE, ARG, VAR, PARENT_HANDLER, GET_NEW, <br>
GOB_VERSION_MAJOR, GOB_VERSION_MINOR and
GOB_VERSION_PATCHLEVEL.</p>

<p style="margin-top: 1em">As for types, there are Self and
SelfClass types which are only defined in your source files.
Their generation (just like the generation of the SELF
macros) can be turned off, <br>
see command line options.</p>

<p style="margin-top: 1em">USING GTK-DOC STYLE INLINE
DOCUMENTATION <br>
If you want to use gtk-doc style inline documentation for
your objects, you can do one of two things. First, you could
include the inline documentation comments in your %{ %} <br>
section which will then be put verbatim into the output
source file. This is the way you should use for functions
you define outside of the class.</p>

<p style="margin-top: 1em">For class methods, you should
use a gtk+ style comment, however it can be indented any
number of tabs or spaces and you can use the short method
name without the type prefix. <br>
Gob will automatically try to extract these and translate to
full names and put them in the output source file. An
example would be:</p>

<p style="margin-top: 1em">class Gtk:Button:Example from
Gtk:Button { <br>
/** <br>
* new: <br>
* <br>
* Makes a new #GtkButtonExample widget <br>
* <br>
* Returns: a new widget <br>
**/ <br>
public <br>
GtkWidget * <br>
new(void) <br>
{ <br>
return (GtkWidget *)GET_NEW; <br>
} <br>
}</p>

<p style="margin-top: 1em">If the function you are
documenting is a signal or a virtual then it will be
documenting the wrapper that starts that virtual function or
emits that signal.</p>

<p style="margin-top: 1em">DEALING WITH CIRCULAR HEADERS
<br>
Sometimes you may need to use an object of type MyObjectA in
the MyObjectB class and vice versa. Obviously you
can&Acirc;&acute;t include headers for both. So you need to
just declare the <br>
typedef in the header of A for B, and the other way around
as well. The headers generated include a protecting define
before it declares the typedef. This define is the
__TYPE&acirc; <br>
DEF_&lt;upper case object name&gt;__. So inside
my-object-a.h there will be this:</p>

<p style="margin-top: 1em">#ifndef __TYPEDEF_MY_OBJECT_A__
<br>
#define __TYPEDEF_MY_OBJECT_A__ <br>
typedef struct _MyObjectA MyObjectA; <br>
#endif</p>

<p style="margin-top: 1em">Now instead of including
my-object-a.h in the header section of my-object-b.gob, just
copy the above code there and you&Acirc;&acute;re set for
using MyObjectA as a type in the method parame&acirc; <br>
ters and public types.</p>

<p style="margin-top: 1em">Another way to get out of this
problem is if you can use those types only in the private
members, in which case they won&Acirc;&acute;t be in the
generated public header.</p>

<p style="margin-top: 1em">BUILDING WITH MAKE <br>
If you are using normal makefiles, what you need to do is to
add a generic rule for .gob files. So you would include the
following in the Makefile and then just use the .c and <br>
.h files as usual (make sure the space before the
&Acirc;&acute;gob2&Acirc;&acute; is a tab, not spaces):</p>

<p style="margin-top: 1em">%.c %.h %-private.h: %.gob <br>
gob2 $&lt;</p>

<p style="margin-top: 1em">BUILDING WITH AUTOCONF and
AUTOMAKE <br>
This is a little bit more involved. Basically the first
thing to do is to check for GOB2 in your configure.in file.
You can use the supplied m4 macro which will also check the
<br>
version of gob. Basically you include this:</p>

<p style="margin-top: 1em">GOB2_CHECK([2.0.0])</p>

<p style="margin-top: 1em">This will replace @GOB2@ in your
makefiles with the full path of gob2. Thus when adding the
generic rule to your Makefile.am file, it should look
like:</p>

<p style="margin-top: 1em">%.c %.h %-private.h: %.gob <br>
@GOB2@ $&lt;</p>

<p style="margin-top: 1em">For Makefile.am you have to set
up a couple more things. First you have to include the
generated .c and .h files into BUILT_SOURCES variable. You
have to include both the .gob <br>
and the .c and .h files in the SOURCES for your program.</p>

<p style="margin-top: 1em">PREVENTING SPURIOUS BUILDS <br>
When nothing has changed you might not really want to
rebuild everything and gob provides options --no-touch
(since 2.0.13) and --no-touch-headers to avoid this. When
working <br>
with build systems such as automake you have to be more
careful as just using those options can cause automake to
get confused and you will need to use something like the
follow&acirc; <br>
ing:</p>

<p style="margin-top: 1em">foo_SOURCES = foo.gob
foo.gob.stamp foo.c foo.h foo-private.h <br>
BUILT_SOURCES = foo.gob.stamp <br>
MAINTAINERCLEANFILES = foo.gob.stamp</p>

<p style="margin-top: 1em">%.gob.stamp: %.gob <br>
@GOB2@ --no-touch $&lt; <br>
@touch $@</p>

<p style="margin-top: 1em">DEBUGGING <br>
GOB does several things to make debugging the code easier.
First it adds preprocessor commands into the output c file
that point to the correct places in your .gob input file.
<br>
However sometimes there might be some bigger confusion and
this is just not helpful. In this case you will probably
want to have gcc point you directly at the generated files.
<br>
For this use the --no-lines command line option. You should
also note that these commands are not generated for the
public header file at all. If there is an error which points
<br>
you to the public header file, make sure you fix this error
in the .gob file, otherwise your changes will not have any
effect after gob recompiles the sources again.</p>

<p style="margin-top: 1em">Sometimes you might want to know
which method you are in for some debugging output. GOB will
define __GOB_FUNCTION__ macro, which is just a string
constant with a pretty name of <br>
the method.</p>

<p style="margin-top: 1em">M4 SUPPORT <br>
It is possible to have your .gob file also preprocessed by
m4. This is useful if you have a lot of files and
you&Acirc;&acute;d like to have some preprocessor put in
some common features. <br>
All you have to do is add --m4 to the command line of gob2
and gob2 will first run your file through m4. You can print
the directory that is searched for m4 files by running <br>
&quot;gob2 --m4-dir&quot;</p>

<p style="margin-top: 1em">All the arguments after --m4
will be passed to m4 itself, so it has to be the last gob2
argument on the command line. This way you can specify
arbitrary options to pass to m4.</p>

<p style="margin-top: 1em">BUGS <br>
The lexer does not actually parse the C code, so
I&Acirc;&acute;m sure that some corner cases or maybe even
some not so corner cases of C syntax might confuse gob
completely. If you find <br>
any, send me the source that makes it go gaga and
I&Acirc;&acute;ll try to make the lexer try to handle it
properly, but no promises.</p>

<p style="margin-top: 1em">Another thing is that gob
ignores preprocessor macros. Since gob counts braces, the
following code won&Acirc;&acute;t work:</p>

<p style="margin-top: 1em">#ifdef SOME_DEFINE <br>
if(foo) { <br>
#else <br>
if(bar) { <br>
#endif <br>
blah(); <br>
}</p>

<p style="margin-top: 1em">To make this work,
you&Acirc;&acute;d have to do this:</p>

<p style="margin-top: 1em">#ifdef SOME_DEFINE <br>
if(foo) <br>
#else <br>
if(bar) <br>
#endif <br>
{ <br>
blah(); <br>
}</p>

<p style="margin-top: 1em">There is no real good way we can
handle this without parsing C code, so we probably never
will. In the future, I might add #if 0 as a comment but
that&Acirc;&acute;s about as far as I can <br>
really take it and even that is problematic. Basically, if
you use gob, just don&Acirc;&acute;t use the C preprocessor
too extensively. And if you use it make sure that you do not
cross the <br>
boundaries of the C code segments.</p>

<p style="margin-top: 1em">Comments will not get through to
the generated files unless inside C code. This is not the
case for gtk-doc style comments which are supported.</p>

<p style="margin-top: 1em">The short name aliases are
actually implemented as pointers to functions. Thus if you
want to get the pointer of a function using the short name
alias you can&Acirc;&acute;t use the
&Acirc;&acute;&amp;&Acirc;&acute;. <br>
Thus:</p>

<p style="margin-top: 1em">void (*foo)(Self *);</p>

<p style="margin-top: 1em">/* this will NOT work */ <br>
foo = &amp;self_short_name;</p>

<p style="margin-top: 1em">/* this will work */ <br>
foo = self_short_name;</p>

<p style="margin-top: 1em">/* Both of these will work */
<br>
foo = &amp;my_class_long_name; <br>
foo = my_class_long_name;</p>

<p style="margin-top: 1em">AUTHOR <br>
George Lebl &lt;jirka@5z.com&gt;</p>

<p style="margin-top: 1em">GOB2 Homepage:
http://www.jirka.org/gob.html</p>

<p style="margin-top: 1em">GOB2 2.0.19 GOB2(1)</p>
<hr>
</body>
</html>
