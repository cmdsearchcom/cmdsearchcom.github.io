<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:13:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GIT-SVN(1) Git Manual GIT-SVN(1)</p>

<p style="margin-top: 1em">NAME <br>
git-svn - Bidirectional operation between a Subversion
repository and Git</p>

<p style="margin-top: 1em">SYNOPSIS <br>
git svn &lt;command&gt; [options] [arguments]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
git svn is a simple conduit for changesets between
Subversion and Git. It provides a bidirectional flow of
changes between a Subversion and a Git repository.</p>

<p style="margin-top: 1em">git svn can track a standard
Subversion repository, following the common
&quot;trunk/branches/tags&quot; layout, with the --stdlayout
option. It can also follow branches and tags in any <br>
layout with the -T/-t/-b options (see options to init below,
and also the clone command).</p>

<p style="margin-top: 1em">Once tracking a Subversion
repository (with any of the above methods), the Git
repository can be updated from Subversion by the fetch
command and Subversion updated from Git by <br>
the dcommit command.</p>

<p style="margin-top: 1em">COMMANDS <br>
init <br>
Initializes an empty Git repository with additional metadata
directories for git svn. The Subversion URL may be specified
as a command-line argument, or as full URL arguments <br>
to -T/-t/-b. Optionally, the target directory to operate on
can be specified as a second argument. Normally this command
initializes the current directory.</p>

<p style="margin-top: 1em">-T&lt;trunk_subdir&gt;,
--trunk=&lt;trunk_subdir&gt;, -t&lt;tags_subdir&gt;,
--tags=&lt;tags_subdir&gt;, -b&lt;branches_subdir&gt;,
--branches=&lt;branches_subdir&gt;, -s, --stdlayout <br>
These are optional command-line options for init. Each of
these flags can point to a relative repository path
(--tags=project/tags) or a full url <br>
(--tags=https://foo.org/project/tags). You can specify more
than one --tags and/or --branches options, in case your
Subversion repository places tags or branches under <br>
multiple paths. The option --stdlayout is a shorthand way of
setting trunk,tags,branches as the relative paths, which is
the Subversion default. If any of the other <br>
options are given as well, they take precedence.</p>

<p style="margin-top: 1em">--no-metadata <br>
Set the noMetadata option in the [svn-remote] config. This
option is not recommended, please read the svn.noMetadata
section of this manpage before using this option.</p>

<p style="margin-top: 1em">--use-svm-props <br>
Set the useSvmProps option in the [svn-remote] config.</p>

<p style="margin-top: 1em">--use-svnsync-props <br>
Set the useSvnsyncProps option in the [svn-remote]
config.</p>

<p style="margin-top: 1em">--rewrite-root=&lt;URL&gt; <br>
Set the rewriteRoot option in the [svn-remote] config.</p>

<p style="margin-top: 1em">--rewrite-uuid=&lt;UUID&gt; <br>
Set the rewriteUUID option in the [svn-remote] config.</p>

<p style="margin-top: 1em">--username=&lt;user&gt; <br>
For transports that SVN handles authentication for (http,
https, and plain svn), specify the username. For other
transports (eg svn+ssh://), you must include the username
<br>
in the URL, eg svn+ssh://foo@svn.bar.com/project</p>

<p style="margin-top: 1em">--prefix=&lt;prefix&gt; <br>
This allows one to specify a prefix which is prepended to
the names of remotes if trunk/branches/tags are specified.
The prefix does not automatically include a trailing <br>
slash, so be sure you include one in the argument if that is
what you want. If --branches/-b is specified, the prefix
must include a trailing slash. Setting a prefix is <br>
useful if you wish to track multiple projects that share a
common repository.</p>

<p style="margin-top: 1em">--ignore-paths=&lt;regex&gt;
<br>
When passed to init or clone this regular expression will be
preserved as a config key. See fetch for a description of
--ignore-paths.</p>

<p style="margin-top: 1em">--include-paths=&lt;regex&gt;
<br>
When passed to init or clone this regular expression will be
preserved as a config key. See fetch for a description of
--include-paths.</p>

<p style="margin-top: 1em">--no-minimize-url <br>
When tracking multiple directories (using --stdlayout,
--branches, or --tags options), git svn will attempt to
connect to the root (or highest allowed level) of the <br>
Subversion repository. This default allows better tracking
of history if entire projects are moved within a repository,
but may cause issues on repositories where read <br>
access restrictions are in place. Passing --no-minimize-url
will allow git svn to accept URLs as-is without attempting
to connect to a higher level directory. This option <br>
is off by default when only one URL/branch is tracked (it
would do little good).</p>

<p style="margin-top: 1em">fetch <br>
Fetch unfetched revisions from the Subversion remote we are
tracking. The name of the [svn-remote &quot;...&quot;]
section in the .git/config file may be specified as an
optional <br>
command-line argument.</p>

<p style="margin-top: 1em">--localtime <br>
Store Git commit times in the local timezone instead of UTC.
This makes git log (even without --date=local) show the same
times that svn log would in the local timezone.</p>

<p style="margin-top: 1em">This doesn&acirc;t interfere
with interoperating with the Subversion repository you
cloned from, but if you wish for your local Git repository
to be able to interoperate with <br>
someone else&acirc;s local Git repository, either
don&acirc;t use this option or you should both use it in the
same local timezone.</p>

<p style="margin-top: 1em">--parent <br>
Fetch only from the SVN parent of the current HEAD.</p>

<p style="margin-top: 1em">--ignore-paths=&lt;regex&gt;
<br>
This allows one to specify a Perl regular expression that
will cause skipping of all matching paths from checkout from
SVN. The --ignore-paths option should match for <br>
every fetch (including automatic fetches due to clone,
dcommit, rebase, etc) on a given repository.</p>

<p style="margin-top: 1em">config key:
svn-remote.&lt;name&gt;.ignore-paths</p>

<p style="margin-top: 1em">If the ignore-paths config key
is set and the command line option is also given, both
regular expressions will be used.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">Skip &quot;doc*&quot; directory
for every fetch</p>


<p style="margin-top: 1em">--ignore-paths=&quot;^doc&quot;</p>

<p style="margin-top: 1em">Skip &quot;branches&quot; and
&quot;tags&quot; of first level directories</p>


<p style="margin-top: 1em">--ignore-paths=&quot;^[^/]+/(?:branches|tags)&quot;</p>

<p style="margin-top: 1em">--include-paths=&lt;regex&gt;
<br>
This allows one to specify a Perl regular expression that
will cause the inclusion of only matching paths from
checkout from SVN. The --include-paths option should match
<br>
for every fetch (including automatic fetches due to clone,
dcommit, rebase, etc) on a given repository. --ignore-paths
takes precedence over --include-paths.</p>

<p style="margin-top: 1em">--log-window-size=&lt;n&gt; <br>
Fetch &lt;n&gt; log entries per request when scanning
Subversion history. The default is 100. For very large
Subversion repositories, larger values may be needed for
<br>
clone/fetch to complete in reasonable time. But overly large
values may lead to higher memory usage and request
timeouts.</p>

<p style="margin-top: 1em">clone <br>
Runs init and fetch. It will automatically create a
directory based on the basename of the URL passed to it; or
if a second argument is passed; it will create a directory
and <br>
work within that. It accepts all arguments that the init and
fetch commands accept; with the exception of --fetch-all and
--parent. After a repository is cloned, the fetch <br>
command will be able to update revisions without affecting
the working tree; and the rebase command will be able to
update the working tree with the latest changes.</p>

<p style="margin-top: 1em">--preserve-empty-dirs <br>
Create a placeholder file in the local Git repository for
each empty directory fetched from Subversion. This includes
directories that become empty by removing all <br>
entries in the Subversion repository (but not the directory
itself). The placeholder files are also tracked and removed
when no longer necessary.</p>


<p style="margin-top: 1em">--placeholder-filename=&lt;filename&gt;
<br>
Set the name of placeholder files created by
--preserve-empty-dirs. Default: &quot;.gitignore&quot;</p>

<p style="margin-top: 1em">rebase <br>
This fetches revisions from the SVN parent of the current
HEAD and rebases the current (uncommitted to SVN) work
against it.</p>

<p style="margin-top: 1em">This works similarly to svn
update or git pull except that it preserves linear history
with git rebase instead of git merge for ease of dcommitting
with git svn.</p>

<p style="margin-top: 1em">This accepts all options that
git svn fetch and git rebase accept. However, --fetch-all
only fetches from the current [svn-remote], and not all
[svn-remote] definitions.</p>

<p style="margin-top: 1em">Like git rebase; this requires
that the working tree be clean and have no uncommitted
changes.</p>

<p style="margin-top: 1em">-l, --local <br>
Do not fetch remotely; only run git rebase against the last
fetched commit from the upstream SVN.</p>

<p style="margin-top: 1em">dcommit <br>
Commit each diff from the current branch directly to the SVN
repository, and then rebase or reset (depending on whether
or not there is a diff between SVN and head). This <br>
will create a revision in SVN for each commit in Git.</p>

<p style="margin-top: 1em">When an optional Git branch name
(or a Git commit object name) is specified as an argument,
the subcommand works on the specified branch, not on the
current branch.</p>

<p style="margin-top: 1em">Use of dcommit is preferred to
set-tree (below).</p>

<p style="margin-top: 1em">--no-rebase <br>
After committing, do not rebase or reset.</p>

<p style="margin-top: 1em">--commit-url &lt;URL&gt; <br>
Commit to this SVN URL (the full path). This is intended to
allow existing git svn repositories created with one
transport method (e.g. svn:// or http:// for anonymous <br>
read) to be reused if a user is later given access to an
alternate transport method (e.g. svn+ssh:// or https://) for
commit.</p>

<p style="margin-top: 1em">config key:
svn-remote.&lt;name&gt;.commiturl <br>
config key: svn.commiturl (overwrites all
svn-remote.&lt;name&gt;.commiturl options)</p>

<p style="margin-top: 1em">Using this option for any other
purpose (don&acirc;t ask) is very strongly discouraged.</p>

<p style="margin-top: 1em">--mergeinfo=&lt;mergeinfo&gt;
<br>
Add the given merge information during the dcommit (e.g.
--mergeinfo=&quot;/branches/foo:1-10&quot;). All svn server
versions can store this information (as a property), and svn
<br>
clients starting from version 1.5 can make use of it. To
specify merge information from multiple branches, use a
single space character between the branches <br>
(--mergeinfo=&quot;/branches/foo:1-10
/branches/bar:3,5-6,8&quot;)</p>

<p style="margin-top: 1em">config key:
svn.pushmergeinfo</p>

<p style="margin-top: 1em">This option will cause git-svn
to attempt to automatically populate the svn:mergeinfo
property in the SVN repository when possible. Currently,
this can only be done when <br>
dcommitting non-fast-forward merges where all parents but
the first have already been pushed into SVN.</p>

<p style="margin-top: 1em">--interactive <br>
Ask the user to confirm that a patch set should actually be
sent to SVN. For each patch, one may answer &quot;yes&quot;
(accept this patch), &quot;no&quot; (discard this patch),
&quot;all&quot; <br>
(accept all patches), or &quot;quit&quot;. git svn dcommit
returns immediately if answer if &quot;no&quot; or
&quot;quit&quot;, without committing anything to SVN.</p>

<p style="margin-top: 1em">branch <br>
Create a branch in the SVN repository.</p>

<p style="margin-top: 1em">-m, --message <br>
Allows to specify the commit message.</p>

<p style="margin-top: 1em">-t, --tag <br>
Create a tag by using the tags_subdir instead of the
branches_subdir specified during git svn init.</p>

<p style="margin-top: 1em">-d&lt;path&gt;,
--destination=&lt;path&gt; <br>
If more than one --branches (or --tags) option was given to
the init or clone command, you must provide the location of
the branch (or tag) you wish to create in the SVN <br>
repository. &lt;path&gt; specifies which path to use to
create the branch or tag and should match the pattern on the
left-hand side of one of the configured branches or tags
<br>
refspecs. You can see these refspecs with the commands</p>

<p style="margin-top: 1em">git config --get-all
svn-remote.&lt;name&gt;.branches <br>
git config --get-all svn-remote.&lt;name&gt;.tags</p>

<p style="margin-top: 1em">where &lt;name&gt; is the name
of the SVN repository as specified by the -R option to init
(or &quot;svn&quot; by default).</p>

<p style="margin-top: 1em">--username <br>
Specify the SVN username to perform the commit as. This
option overrides the username configuration property.</p>

<p style="margin-top: 1em">--commit-url <br>
Use the specified URL to connect to the destination
Subversion repository. This is useful in cases where the
source SVN repository is read-only. This option overrides
<br>
configuration property commiturl.</p>

<p style="margin-top: 1em">git config --get-all
svn-remote.&lt;name&gt;.commiturl</p>

<p style="margin-top: 1em">--parents <br>
Create parent folders. This parameter is equivalent to the
parameter --parents on svn cp commands and is useful for
non-standard repository layouts.</p>

<p style="margin-top: 1em">tag <br>
Create a tag in the SVN repository. This is a shorthand for
branch -t.</p>

<p style="margin-top: 1em">log <br>
This should make it easy to look up svn log messages when
svn users refer to -r/--revision numbers.</p>

<p style="margin-top: 1em">The following features from
&acirc;svn log&acirc; are supported:</p>

<p style="margin-top: 1em">-r &lt;n&gt;[:&lt;n&gt;],
--revision=&lt;n&gt;[:&lt;n&gt;] <br>
is supported, non-numeric args are not: HEAD, NEXT, BASE,
PREV, etc ...</p>

<p style="margin-top: 1em">-v, --verbose <br>
it&acirc;s not completely compatible with the --verbose
output in svn log, but reasonably close.</p>

<p style="margin-top: 1em">--limit=&lt;n&gt; <br>
is NOT the same as --max-count, doesn&acirc;t count
merged/excluded commits</p>

<p style="margin-top: 1em">--incremental <br>
supported</p>

<p style="margin-top: 1em">New features:</p>

<p style="margin-top: 1em">--show-commit <br>
shows the Git commit sha1, as well</p>

<p style="margin-top: 1em">--oneline <br>
our version of --pretty=oneline</p>

<p style="margin-top: 1em">Note <br>
SVN itself only stores times in UTC and nothing else. The
regular svn client converts the UTC time to the local time
(or based on the TZ= environment). This command has <br>
the same behaviour. <br>
Any other arguments are passed directly to git log</p>

<p style="margin-top: 1em">blame <br>
Show what revision and author last modified each line of a
file. The output of this mode is format-compatible with the
output of &acirc;svn blame&acirc; by default. Like the SVN
blame <br>
command, local uncommitted changes in the working tree are
ignored; the version of the file in the HEAD revision is
annotated. Unknown arguments are passed directly to git <br>
blame.</p>

<p style="margin-top: 1em">--git-format <br>
Produce output in the same format as git blame, but with SVN
revision numbers instead of Git commit hashes. In this mode,
changes that haven&acirc;t been committed to SVN <br>
(including local working-copy edits) are shown as revision
0.</p>

<p style="margin-top: 1em">find-rev <br>
When given an SVN revision number of the form rN, returns
the corresponding Git commit hash (this can optionally be
followed by a tree-ish to specify which branch should be
<br>
searched). When given a tree-ish, returns the corresponding
SVN revision number.</p>

<p style="margin-top: 1em">--before <br>
Don&acirc;t require an exact match if given an SVN revision,
instead find the commit corresponding to the state of the
SVN repository (on the current branch) at the specified <br>
revision.</p>

<p style="margin-top: 1em">--after <br>
Don&acirc;t require an exact match if given an SVN revision;
if there is not an exact match return the closest match
searching forward in the history.</p>

<p style="margin-top: 1em">set-tree <br>
You should consider using dcommit instead of this command.
Commit specified commit or tree objects to SVN. This relies
on your imported fetch data being up-to-date. This <br>
makes absolutely no attempts to do patching when committing
to SVN, it simply overwrites files with those specified in
the tree or commit. All merging is assumed to have <br>
taken place independently of git svn functions.</p>

<p style="margin-top: 1em">create-ignore <br>
Recursively finds the svn:ignore property on directories and
creates matching .gitignore files. The resulting files are
staged to be committed, but are not committed. Use <br>
-r/--revision to refer to a specific revision.</p>

<p style="margin-top: 1em">show-ignore <br>
Recursively finds and lists the svn:ignore property on
directories. The output is suitable for appending to the
$GIT_DIR/info/exclude file.</p>

<p style="margin-top: 1em">mkdirs <br>
Attempts to recreate empty directories that core Git cannot
track based on information in
$GIT_DIR/svn/&lt;refname&gt;/unhandled.log files. Empty
directories are automatically <br>
recreated when using &quot;git svn clone&quot; and &quot;git
svn rebase&quot;, so &quot;mkdirs&quot; is intended for use
after commands like &quot;git checkout&quot; or &quot;git
reset&quot;. (See the <br>
svn-remote.&lt;name&gt;.automkdirs config file option for
more information.)</p>

<p style="margin-top: 1em">commit-diff <br>
Commits the diff of two tree-ish arguments from the
command-line. This command does not rely on being inside an
git svn init-ed repository. This command takes three <br>
arguments, (a) the original tree to diff against, (b) the
new tree result, (c) the URL of the target Subversion
repository. The final argument (URL) may be omitted if you
are <br>
working from a git svn-aware repository (that has been
init-ed with git svn). The -r&lt;revision&gt; option is
required for this.</p>

<p style="margin-top: 1em">info <br>
Shows information about a file or directory similar to what
&acirc;svn info&acirc; provides. Does not currently support
a -r/--revision argument. Use the --url option to output
only the <br>
value of the URL: field.</p>

<p style="margin-top: 1em">proplist <br>
Lists the properties stored in the Subversion repository
about a given file or directory. Use -r/--revision to refer
to a specific Subversion revision.</p>

<p style="margin-top: 1em">propget <br>
Gets the Subversion property given as the first argument,
for a file. A specific revision can be specified with
-r/--revision.</p>

<p style="margin-top: 1em">show-externals <br>
Shows the Subversion externals. Use -r/--revision to specify
a specific revision.</p>

<p style="margin-top: 1em">gc <br>
Compress $GIT_DIR/svn/&lt;refname&gt;/unhandled.log files in
.git/svn and remove $GIT_DIR/svn/&lt;refname&gt;index files
in .git/svn.</p>

<p style="margin-top: 1em">reset <br>
Undoes the effects of fetch back to the specified revision.
This allows you to re-fetch an SVN revision. Normally the
contents of an SVN revision should never change and <br>
reset should not be necessary. However, if SVN permissions
change, or if you alter your --ignore-paths option, a fetch
may fail with &quot;not found in commit&quot; (file not <br>
previously visible) or &quot;checksum mismatch&quot; (missed
a modification). If the problem file cannot be ignored
forever (with --ignore-paths) the only way to repair the
repo is to <br>
use reset.</p>

<p style="margin-top: 1em">Only the rev_map and
refs/remotes/git-svn are changed. Follow reset with a fetch
and then git reset or git rebase to move local branches onto
the new tree.</p>

<p style="margin-top: 1em">-r &lt;n&gt;,
--revision=&lt;n&gt; <br>
Specify the most recent revision to keep. All later
revisions are discarded.</p>

<p style="margin-top: 1em">-p, --parent <br>
Discard the specified revision as well, keeping the nearest
parent instead.</p>

<p style="margin-top: 1em">Example: <br>
Assume you have local changes in &quot;master&quot;, but you
need to refetch &quot;r2&quot;.</p>

<p style="margin-top: 1em">r1---r2---r3 remotes/git-svn
<br>
A---B master</p>

<p style="margin-top: 1em">Fix the ignore-paths or SVN
permissions problem that caused &quot;r2&quot; to be
incomplete in the first place. Then:</p>

<p style="margin-top: 1em">git svn reset -r2 -p <br>
git svn fetch</p>

<p style="margin-top: 1em">r1---r2&rsquo;--r3&rsquo;
remotes/git-svn <br>
r2---r3---A---B master</p>

<p style="margin-top: 1em">Then fixup &quot;master&quot;
with git rebase. Do NOT use git merge or your history will
not be compatible with a future dcommit!</p>

<p style="margin-top: 1em">git rebase --onto
remotes/git-svn A^ master</p>

<p style="margin-top: 1em">r1---r2&rsquo;--r3&rsquo;
remotes/git-svn <br>
A&rsquo;--B&rsquo; master</p>

<p style="margin-top: 1em">OPTIONS <br>
--shared[=(false|true|umask|group|all|world|everybody)],
--template=&lt;template_directory&gt; <br>
Only used with the init command. These are passed directly
to git init.</p>

<p style="margin-top: 1em">-r &lt;arg&gt;, --revision
&lt;arg&gt; <br>
Used with the fetch command.</p>

<p style="margin-top: 1em">This allows revision ranges for
partial/cauterized history to be supported. $NUMBER,
$NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and
BASE:$NUMBER are all supported.</p>

<p style="margin-top: 1em">This can allow you to make
partial mirrors when running fetch; but is generally not
recommended because history will be skipped and lost.</p>

<p style="margin-top: 1em">-, --stdin <br>
Only used with the set-tree command.</p>

<p style="margin-top: 1em">Read a list of commits from
stdin and commit them in reverse order. Only the leading
sha1 is read from each line, so git rev-list
--pretty=oneline output can be used.</p>

<p style="margin-top: 1em">--rmdir <br>
Only used with the dcommit, set-tree and commit-diff
commands.</p>

<p style="margin-top: 1em">Remove directories from the SVN
tree if there are no files left behind. SVN can version
empty directories, and they are not removed by default if
there are no files left in <br>
them. Git cannot version empty directories. Enabling this
flag will make the commit to SVN act like Git.</p>

<p style="margin-top: 1em">config key: svn.rmdir</p>

<p style="margin-top: 1em">-e, --edit <br>
Only used with the dcommit, set-tree and commit-diff
commands.</p>

<p style="margin-top: 1em">Edit the commit message before
committing to SVN. This is off by default for objects that
are commits, and forced on when committing tree objects.</p>

<p style="margin-top: 1em">config key: svn.edit</p>

<p style="margin-top: 1em">-l&lt;num&gt;,
--find-copies-harder <br>
Only used with the dcommit, set-tree and commit-diff
commands.</p>

<p style="margin-top: 1em">They are both passed directly to
git diff-tree; see git-diff-tree(1) for more
information.</p>

<p style="margin-top: 1em">config key: svn.l <br>
config key: svn.findcopiesharder</p>

<p style="margin-top: 1em">-A&lt;filename&gt;,
--authors-file=&lt;filename&gt; <br>
Syntax is compatible with the file used by git
cvsimport:</p>

<p style="margin-top: 1em">loginname = Joe User
&lt;user@example.com&gt;</p>

<p style="margin-top: 1em">If this option is specified and
git svn encounters an SVN committer name that does not exist
in the authors-file, git svn will abort operation. The user
will then have to add <br>
the appropriate entry. Re-running the previous git svn
command after the authors-file is modified should continue
operation.</p>

<p style="margin-top: 1em">config key: svn.authorsfile</p>

<p style="margin-top: 1em">--authors-prog=&lt;filename&gt;
<br>
If this option is specified, for each SVN committer name
that does not exist in the authors file, the given file is
executed with the committer name as the first argument. <br>
The program is expected to return a single line of the form
&quot;Name &lt;email&gt;&quot;, which will be treated as if
included in the authors file.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Make git svn less verbose. Specify a second time to make it
even less verbose.</p>

<p style="margin-top: 1em">--repack[=&lt;n&gt;],
--repack-flags=&lt;flags&gt; <br>
These should help keep disk usage sane for large fetches
with many revisions.</p>

<p style="margin-top: 1em">--repack takes an optional
argument for the number of revisions to fetch before
repacking. This defaults to repacking every 1000 commits
fetched if no argument is specified.</p>

<p style="margin-top: 1em">--repack-flags are passed
directly to git repack.</p>

<p style="margin-top: 1em">config key: svn.repack <br>
config key: svn.repackflags</p>

<p style="margin-top: 1em">-m, --merge, -s&lt;strategy&gt;,
--strategy=&lt;strategy&gt;, -p, --preserve-merges <br>
These are only used with the dcommit and rebase
commands.</p>

<p style="margin-top: 1em">Passed directly to git rebase
when using dcommit if a git reset cannot be used (see
dcommit).</p>

<p style="margin-top: 1em">-n, --dry-run <br>
This can be used with the dcommit, rebase, branch and tag
commands.</p>

<p style="margin-top: 1em">For dcommit, print out the
series of Git arguments that would show which diffs would be
committed to SVN.</p>

<p style="margin-top: 1em">For rebase, display the local
branch associated with the upstream svn repository
associated with the current branch and the URL of svn
repository that will be fetched from.</p>

<p style="margin-top: 1em">For branch and tag, display the
urls that will be used for copying when creating the branch
or tag.</p>

<p style="margin-top: 1em">--use-log-author <br>
When retrieving svn commits into Git (as part of fetch,
rebase, or dcommit operations), look for the first From: or
Signed-off-by: line in the log message and use that as the
<br>
author string.</p>

<p style="margin-top: 1em">--add-author-from <br>
When committing to svn from Git (as part of commit-diff,
set-tree or dcommit operations), if the existing log message
doesn&acirc;t already have a From: or Signed-off-by: line,
<br>
append a From: line based on the Git commit&acirc;s author
string. If you use this, then --use-log-author will retrieve
a valid author string for all commits.</p>

<p style="margin-top: 1em">ADVANCED OPTIONS <br>
-i&lt;GIT_SVN_ID&gt;, --id &lt;GIT_SVN_ID&gt; <br>
This sets GIT_SVN_ID (instead of using the environment).
This allows the user to override the default refname to
fetch from when tracking a single URL. The log and dcommit
<br>
commands no longer require this switch as an argument.</p>

<p style="margin-top: 1em">-R&lt;remote name&gt;,
--svn-remote &lt;remote name&gt; <br>
Specify the [svn-remote &quot;&lt;remote name&gt;&quot;]
section to use, this allows SVN multiple repositories to be
tracked. Default: &quot;svn&quot;</p>

<p style="margin-top: 1em">--follow-parent <br>
This option is only relevant if we are tracking branches
(using one of the repository layout options --trunk, --tags,
--branches, --stdlayout). For each tracked branch, try <br>
to find out where its revision was copied from, and set a
suitable parent in the first Git commit for the branch. This
is especially helpful when we&acirc;re tracking a directory
<br>
that has been moved around within the repository. If this
feature is disabled, the branches created by git svn will
all be linear and not share any history, meaning that <br>
there will be no information on where branches were branched
off or merged. However, following long/convoluted histories
can take a long time, so disabling this feature may <br>
speed up the cloning process. This feature is enabled by
default, use --no-follow-parent to disable it.</p>

<p style="margin-top: 1em">config key: svn.followparent</p>

<p style="margin-top: 1em">CONFIG FILE-ONLY OPTIONS <br>
svn.noMetadata, svn-remote.&lt;name&gt;.noMetadata <br>
This gets rid of the git-svn-id: lines at the end of every
commit.</p>

<p style="margin-top: 1em">This option can only be used for
one-shot imports as git svn will not be able to fetch again
without metadata. Additionally, if you lose your
.git/svn/*/.rev_map. files, git <br>
svn will not be able to rebuild them.</p>

<p style="margin-top: 1em">The git svn log command will not
work on repositories using this, either. Using this
conflicts with the useSvmProps option for (hopefully)
obvious reasons.</p>

<p style="margin-top: 1em">This option is NOT recommended
as it makes it difficult to track down old references to SVN
revision numbers in existing documentation, bug reports and
archives. If you plan <br>
to eventually migrate from SVN to Git and are certain about
dropping SVN history, consider git-filter-branch(1) instead.
filter-branch also allows reformatting of metadata <br>
for ease-of-reading and rewriting authorship info for
non-&quot;svn.authorsFile&quot; users.</p>

<p style="margin-top: 1em">svn.useSvmProps,
svn-remote.&lt;name&gt;.useSvmProps <br>
This allows git svn to re-map repository URLs and UUIDs from
mirrors created using SVN::Mirror (or svk) for metadata.</p>

<p style="margin-top: 1em">If an SVN revision has a
property, &quot;svm:headrev&quot;, it is likely that the
revision was created by SVN::Mirror (also used by SVK). The
property contains a repository UUID and a <br>
revision. We want to make it look like we are mirroring the
original URL, so introduce a helper function that returns
the original identity URL and UUID, and use it when <br>
generating metadata in commit messages.</p>

<p style="margin-top: 1em">svn.useSvnsyncProps,
svn-remote.&lt;name&gt;.useSvnsyncprops <br>
Similar to the useSvmProps option; this is for users of the
svnsync(1) command distributed with SVN 1.4.x and later.</p>


<p style="margin-top: 1em">svn-remote.&lt;name&gt;.rewriteRoot
<br>
This allows users to create repositories from alternate
URLs. For example, an administrator could run git svn on the
server locally (accessing via file://) but wish to <br>
distribute the repository with a public http:// or svn://
URL in the metadata so users of it will see the public
URL.</p>


<p style="margin-top: 1em">svn-remote.&lt;name&gt;.rewriteUUID
<br>
Similar to the useSvmProps option; this is for users who
need to remap the UUID manually. This may be useful in
situations where the original UUID is not available via
either <br>
useSvmProps or useSvnsyncProps.</p>

<p style="margin-top: 1em">svn-remote.&lt;name&gt;.pushurl
<br>
Similar to Git&acirc;s remote.&lt;name&gt;.pushurl, this key
is designed to be used in cases where url points to an SVN
repository via a read-only transport, to provide an
alternate <br>
read/write transport. It is assumed that both keys point to
the same repository. Unlike commiturl, pushurl is a base
path. If either commiturl or pushurl could be used, <br>
commiturl takes precedence.</p>

<p style="margin-top: 1em">svn.brokenSymlinkWorkaround <br>
This disables potentially expensive checks to workaround
broken symlinks checked into SVN by broken clients. Set this
option to &quot;false&quot; if you track a SVN repository
with <br>
many empty blobs that are not symlinks. This option may be
changed while git svn is running and take effect on the next
revision fetched. If unset, git svn assumes this <br>
option to be &quot;true&quot;.</p>

<p style="margin-top: 1em">svn.pathnameencoding <br>
This instructs git svn to recode pathnames to a given
encoding. It can be used by windows users and by those who
work in non-utf8 locales to avoid corrupted file names with
<br>
non-ASCII characters. Valid encodings are the ones supported
by Perl&acirc;s Encode module.</p>


<p style="margin-top: 1em">svn-remote.&lt;name&gt;.automkdirs
<br>
Normally, the &quot;git svn clone&quot; and &quot;git svn
rebase&quot; commands attempt to recreate empty directories
that are in the Subversion repository. If this option is set
to &quot;false&quot;, <br>
then empty directories will only be created if the &quot;git
svn mkdirs&quot; command is run explicitly. If unset, git
svn assumes this option to be &quot;true&quot;.</p>

<p style="margin-top: 1em">Since the noMetadata,
rewriteRoot, rewriteUUID, useSvnsyncProps and useSvmProps
options all affect the metadata generated and used by git
svn; they must be set in the <br>
configuration file before any history is imported and these
settings should never be changed once they are set.</p>

<p style="margin-top: 1em">Additionally, only one of these
options can be used per svn-remote section because they
affect the git-svn-id: metadata line, except for rewriteRoot
and rewriteUUID which can be <br>
used together.</p>

<p style="margin-top: 1em">BASIC EXAMPLES <br>
Tracking and contributing to the trunk of a
Subversion-managed project (ignoring tags and branches):</p>

<p style="margin-top: 1em"># Clone a repo (like git clone):
<br>
git svn clone http://svn.example.com/project/trunk <br>
# Enter the newly cloned directory: <br>
cd trunk <br>
# You should be on master branch, double-check with
&rsquo;git branch&rsquo; <br>
git branch <br>
# Do some work and commit locally to Git: <br>
git commit ... <br>
# Something is committed to SVN, rebase your local changes
against the <br>
# latest changes in SVN: <br>
git svn rebase <br>
# Now commit your changes (that were committed previously
using Git) to SVN, <br>
# as well as automatically updating your working HEAD: <br>
git svn dcommit <br>
# Append svn:ignore settings to the default Git exclude
file: <br>
git svn show-ignore &gt;&gt; .git/info/exclude</p>

<p style="margin-top: 1em">Tracking and contributing to an
entire Subversion-managed project (complete with a trunk,
tags and branches):</p>

<p style="margin-top: 1em"># Clone a repo with standard SVN
directory layout (like git clone): <br>
git svn clone http://svn.example.com/project --stdlayout
<br>
# Or, if the repo uses a non-standard directory layout: <br>
git svn clone http://svn.example.com/project -T tr -b branch
-t tag <br>
# View all branches and tags you have cloned: <br>
git branch -r <br>
# Create a new branch in SVN <br>
git svn branch waldo <br>
# Reset your master to trunk (or any other branch, replacing
&rsquo;trunk&rsquo; <br>
# with the appropriate name): <br>
git reset --hard remotes/trunk <br>
# You may only dcommit to one branch/tag/trunk at a time.
The usage <br>
# of dcommit/rebase/show-ignore should be the same as
above.</p>

<p style="margin-top: 1em">The initial git svn clone can be
quite time-consuming (especially for large Subversion
repositories). If multiple people (or one person with
multiple machines) want to use git <br>
svn to interact with the same Subversion repository, you can
do the initial git svn clone to a repository on a server and
have each person clone that repository with git clone:</p>

<p style="margin-top: 1em"># Do the initial import on a
server <br>
ssh server &quot;cd /pub &amp;&amp; git svn clone
http://svn.example.com/project <br>
# Clone locally - make sure the refs/remotes/ space matches
the server <br>
mkdir project <br>
cd project <br>
git init <br>
git remote add origin server:/pub/project <br>
git config --replace-all remote.origin.fetch
&rsquo;+refs/remotes/*:refs/remotes/*&rsquo; <br>
git fetch <br>
# Prevent fetch/pull from remote Git server in the future,
<br>
# we only want to use git svn for future updates <br>
git config --remove-section remote.origin <br>
# Create a local branch from one of the branches just
fetched <br>
git checkout -b master FETCH_HEAD <br>
# Initialize &rsquo;git svn&rsquo; locally (be sure to use
the same URL and -T/-b/-t options as were used on server)
<br>
git svn init http://svn.example.com/project <br>
# Pull the latest changes from Subversion <br>
git svn rebase</p>

<p style="margin-top: 1em">REBASE VS. PULL/MERGE <br>
Prefer to use git svn rebase or git rebase, rather than git
pull or git merge to synchronize unintegrated commits with a
git svn branch. Doing so will keep the history of <br>
unintegrated commits linear with respect to the upstream SVN
repository and allow the use of the preferred git svn
dcommit subcommand to push unintegrated commits back into
SVN.</p>

<p style="margin-top: 1em">Originally, git svn recommended
that developers pulled or merged from the git svn branch.
This was because the author favored git svn set-tree B to
commit a single head rather <br>
than the git svn set-tree A..B notation to commit multiple
commits. Use of git pull or git merge with git svn set-tree
A..B will cause non-linear history to be flattened when <br>
committing into SVN and this can lead to merge commits
unexpectedly reversing previous commits in SVN.</p>

<p style="margin-top: 1em">MERGE TRACKING <br>
While git svn can track copy history (including branches and
tags) for repositories adopting a standard layout, it cannot
yet represent merge history that happened inside git <br>
back upstream to SVN users. Therefore it is advised that
users keep history as linear as possible inside Git to ease
compatibility with SVN (see the CAVEATS section below).</p>

<p style="margin-top: 1em">HANDLING OF SVN BRANCHES <br>
If git svn is configured to fetch branches (and
--follow-branches is in effect), it sometimes creates
multiple Git branches for one SVN branch, where the
additional branches have <br>
names of the form branchname@nnn (with nnn an SVN revision
number). These additional branches are created if git svn
cannot find a parent commit for the first commit in an SVN
<br>
branch, to connect the branch to the history of the other
branches.</p>

<p style="margin-top: 1em">Normally, the first commit in an
SVN branch consists of a copy operation. git svn will read
this commit to get the SVN revision the branch was created
from. It will then try to <br>
find the Git commit that corresponds to this SVN revision,
and use that as the parent of the branch. However, it is
possible that there is no suitable Git commit to serve as
<br>
parent. This will happen, among other reasons, if the SVN
branch is a copy of a revision that was not fetched by git
svn (e.g. because it is an old revision that was skipped
with <br>
--revision), or if in SVN a directory was copied that is not
tracked by git svn (such as a branch that is not tracked at
all, or a subdirectory of a tracked branch). In these <br>
cases, git svn will still create a Git branch, but instead
of using an existing Git commit as the parent of the branch,
it will read the SVN history of the directory the branch
<br>
was copied from and create appropriate Git commits. This is
indicated by the message &quot;Initializing parent:
&lt;branchname&gt;&quot;.</p>

<p style="margin-top: 1em">Additionally, it will create a
special branch named
&lt;branchname&gt;@&lt;SVN-Revision&gt;, where
&lt;SVN-Revision&gt; is the SVN revision number the branch
was copied from. This branch will <br>
point to the newly created parent commit of the branch. If
in SVN the branch was deleted and later recreated from a
different version, there will be multiple such branches with
<br>
an @.</p>

<p style="margin-top: 1em">Note that this may mean that
multiple Git commits are created for a single SVN
revision.</p>

<p style="margin-top: 1em">An example: in an SVN repository
with a standard trunk/tags/branches layout, a directory
trunk/sub is created in r.100. In r.200, trunk/sub is
branched by copying it to <br>
branches/. git svn clone -s will then create a branch sub.
It will also create new Git commits for r.100 through r.199
and use these as the history of branch sub. Thus there will
<br>
be two Git commits for each revision from r.100 to r.199
(one containing trunk/, one containing trunk/sub/). Finally,
it will create a branch sub@200 pointing to the new parent
<br>
commit of branch sub (i.e. the commit for r.200 and
trunk/sub/).</p>

<p style="margin-top: 1em">CAVEATS <br>
For the sake of simplicity and interoperating with
Subversion, it is recommended that all git svn users clone,
fetch and dcommit directly from the SVN server, and avoid
all git <br>
clone/pull/merge/push operations between Git repositories
and branches. The recommended method of exchanging code
between Git branches and users is git format-patch and git
am, <br>
or just &rsquo;dcommit&acirc;ing to the SVN repository.</p>

<p style="margin-top: 1em">Running git merge or git pull is
NOT recommended on a branch you plan to dcommit from because
Subversion users cannot see any merges you&acirc;ve made.
Furthermore, if you merge or <br>
pull from a Git branch that is a mirror of an SVN branch,
dcommit may commit to the wrong branch.</p>

<p style="margin-top: 1em">If you do merge, note the
following rule: git svn dcommit will attempt to commit on
top of the SVN commit named in</p>

<p style="margin-top: 1em">git log --grep=^git-svn-id:
--first-parent -1</p>

<p style="margin-top: 1em">You must therefore ensure that
the most recent commit of the branch you want to dcommit to
is the first parent of the merge. Chaos will ensue
otherwise, especially if the first <br>
parent is an older commit on the same SVN branch.</p>

<p style="margin-top: 1em">git clone does not clone
branches under the refs/remotes/ hierarchy or any git svn
metadata, or config. So repositories created and managed
with using git svn should use rsync <br>
for cloning, if cloning is to be done at all.</p>

<p style="margin-top: 1em">Since dcommit uses rebase
internally, any Git branches you git push to before dcommit
on will require forcing an overwrite of the existing ref on
the remote repository. This is <br>
generally considered bad practice, see the git-push(1)
documentation for details.</p>

<p style="margin-top: 1em">Do not use the --amend option of
git-commit(1) on a change you&acirc;ve already dcommitted.
It is considered bad practice to --amend commits
you&acirc;ve already pushed to a remote <br>
repository for other users, and dcommit with SVN is
analogous to that.</p>

<p style="margin-top: 1em">When cloning an SVN repository,
if none of the options for describing the repository layout
is used (--trunk, --tags, --branches, --stdlayout), git svn
clone will create a Git <br>
repository with completely linear history, where branches
and tags appear as separate directories in the working copy.
While this is the easiest way to get a copy of a complete
<br>
repository, for projects with many branches it will lead to
a working copy many times larger than just the trunk. Thus
for projects using the standard directory structure <br>
(trunk/branches/tags), it is recommended to clone with
option --stdlayout. If the project uses a non-standard
structure, and/or if branches and tags are not required, it
is <br>
easiest to only clone one directory (typically trunk),
without giving any repository layout options. If the full
history with branches and tags is required, the options
--trunk / <br>
--branches / --tags must be used.</p>

<p style="margin-top: 1em">When using multiple --branches
or --tags, git svn does not automatically handle name
collisions (for example, if two branches from different
paths have the same name, or if a <br>
branch and a tag have the same name). In these cases, use
init to set up your Git repository then, before your first
fetch, edit the .git/config file so that the branches and
<br>
tags are associated with different name spaces. For
example:</p>

<p style="margin-top: 1em">branches =
stable/*:refs/remotes/svn/stable/* <br>
branches = debug/*:refs/remotes/svn/debug/*</p>

<p style="margin-top: 1em">BUGS <br>
We ignore all SVN properties except svn:executable. Any
unhandled properties are logged to
$GIT_DIR/svn/&lt;refname&gt;/unhandled.log</p>

<p style="margin-top: 1em">Renamed and copied directories
are not detected by Git and hence not tracked when
committing to SVN. I do not plan on adding support for this
as it&acirc;s quite difficult and <br>
time-consuming to get working for all the possible corner
cases (Git doesn&acirc;t do it, either). Committing renamed
and copied files is fully supported if they&acirc;re similar
enough for <br>
Git to detect them.</p>

<p style="margin-top: 1em">In SVN, it is possible (though
discouraged) to commit changes to a tag (because a tag is
just a directory copy, thus technically the same as a
branch). When cloning an SVN <br>
repository, git svn cannot know if such a commit to a tag
will happen in the future. Thus it acts conservatively and
imports all SVN tags as branches, prefixing the tag name
with <br>
tags/.</p>

<p style="margin-top: 1em">CONFIGURATION <br>
git svn stores [svn-remote] configuration information in the
repository .git/config file. It is similar the core Git
[remote] sections except fetch keys do not accept glob <br>
arguments; but they are instead handled by the branches and
tags keys. Since some SVN repositories are oddly configured
with multiple projects glob expansions such those listed
<br>
below are allowed:</p>

<p style="margin-top: 1em">[svn-remote
&quot;project-a&quot;] <br>
url = http://server.org/svn <br>
fetch = trunk/project-a:refs/remotes/project-a/trunk <br>
branches =
branches/*/project-a:refs/remotes/project-a/branches/* <br>
tags = tags/*/project-a:refs/remotes/project-a/tags/*</p>

<p style="margin-top: 1em">Keep in mind that the *
(asterisk) wildcard of the local ref (right of the :) must
be the farthest right path component; however the remote
wildcard may be anywhere as long as <br>
it&acirc;s an independent path component (surrounded by / or
EOL). This type of configuration is not automatically
created by init and should be manually entered with a
text-editor or <br>
using git config.</p>

<p style="margin-top: 1em">It is also possible to fetch a
subset of branches or tags by using a comma-separated list
of names within braces. For example:</p>

<p style="margin-top: 1em">[svn-remote
&quot;huge-project&quot;] <br>
url = http://server.org/svn <br>
fetch = trunk/src:refs/remotes/trunk <br>
branches = branches/{red,green}/src:refs/remotes/branches/*
<br>
tags = tags/{1.0,2.0}/src:refs/remotes/tags/*</p>

<p style="margin-top: 1em">Multiple fetch, branches, and
tags keys are supported:</p>

<p style="margin-top: 1em">[svn-remote
&quot;messy-repo&quot;] <br>
url = http://server.org/svn <br>
fetch = trunk/project-a:refs/remotes/project-a/trunk <br>
fetch =
branches/demos/june-project-a-demo:refs/remotes/project-a/demos/june-demo
<br>
branches =
branches/server/*:refs/remotes/project-a/branches/* <br>
branches =
branches/demos/2011/*:refs/remotes/project-a/2011-demos/*
<br>
tags = tags/server/*:refs/remotes/project-a/tags/*</p>

<p style="margin-top: 1em">Creating a branch in such a
configuration requires disambiguating which location to use
using the -d or --destination flag:</p>

<p style="margin-top: 1em">$ git svn branch -d
branches/server release-2-3-0</p>

<p style="margin-top: 1em">Note that git-svn keeps track of
the highest revision in which a branch or tag has appeared.
If the subset of branches or tags is changed after fetching,
then .git/svn/.metadata <br>
must be manually edited to remove (or reset) branches-maxRev
and/or tags-maxRev as appropriate.</p>

<p style="margin-top: 1em">SEE ALSO <br>
git-rebase(1)</p>

<p style="margin-top: 1em">GIT <br>
Part of the git(1) suite</p>

<p style="margin-top: 1em">Git 1.8.3.1 03/23/2016
GIT-SVN(1)</p>
<hr>
</body>
</html>
