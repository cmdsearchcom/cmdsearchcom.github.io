<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:59 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>JQ(1) JQ(1)</p>

<p style="margin-top: 1em">NAME <br>
jq - Command-line JSON processor</p>

<p style="margin-top: 1em">SYNOPSIS <br>
jq [options...] filter [files...]</p>

<p style="margin-top: 1em">jq can transform JSON in various
ways, by selecting, iterating, reducing and otherwise
mangling JSON documents. For instance, running the command
jq &Acirc;&acute;map(.price) | add&Acirc;&acute; will take
<br>
an array of JSON objects as input and return the sum of
their &quot;price&quot; fields.</p>

<p style="margin-top: 1em">jq can accept text input as
well, but by default, jq reads a stream of JSON entities
(including numbers and other literals) from stdin.
Whitespace is only needed to separate <br>
entities such as 1 and 2, and true and false. One or more
files may be specified, in which case jq will read input
from those instead.</p>

<p style="margin-top: 1em">The options are described in the
INVOKING JQ section; they mostly concern input and output
formatting. The filter is written in the jq language and
specifies how to transform the <br>
input file or document.</p>

<p style="margin-top: 1em">FILTERS <br>
A jq program is a &quot;filter&quot;: it takes an input, and
produces an output. There are a lot of builtin filters for
extracting a particular field of an object, or converting a
number <br>
to a string, or various other standard tasks.</p>

<p style="margin-top: 1em">Filters can be combined in
various ways - you can pipe the output of one filter into
another filter, or collect the output of a filter into an
array.</p>

<p style="margin-top: 1em">Some filters produce multiple
results, for instance there&Acirc;&acute;s one that produces
all the elements of its input array. Piping that filter into
a second runs the second filter for <br>
each element of the array. Generally, things that would be
done with loops and iteration in other languages are just
done by gluing filters together in jq.</p>

<p style="margin-top: 1em">It&Acirc;&acute;s important to
remember that every filter has an input and an output. Even
literals like &quot;hello&quot; or 42 are filters - they
take an input but always produce the same literal as <br>
output. Operations that combine two filters, like addition,
generally feed the same input to both and combine the
results. So, you can implement an averaging filter as add /
<br>
length - feeding the input array both to the add filter and
the length filter and then performing the division.</p>

<p style="margin-top: 1em">But that&Acirc;&acute;s getting
ahead of ourselves. :) Let&Acirc;&acute;s start with
something simpler:</p>

<p style="margin-top: 1em">INVOKING JQ <br>
jq filters run on a stream of JSON data. The input to jq is
parsed as a sequence of whitespace-separated JSON values
which are passed through the provided filter one at a time.
<br>
The output(s) of the filter are written to standard out,
again as a sequence of whitespace-separated JSON data.</p>

<p style="margin-top: 1em">Note: it is important to mind
the shell&Acirc;&acute;s quoting rules. As a general rule
it&Acirc;&acute;s best to always quote (with single-quote
characters) the jq program, as too many characters with <br>
special meaning to jq are also shell meta-characters. For
example, jq &quot;foo&quot; will fail on most Unix shells
because that will be the same as jq foo, which will
generally fail <br>
because foo is not defined. When using the Windows command
shell (cmd.exe) it&Acirc;&acute;s best to use double quotes
around your jq program when given on the command-line
(instead of the -f <br>
program-file option), but then double-quotes in the jq
program need backslash escaping.</p>

<p style="margin-top: 1em">You can affect how jq reads and
writes its input and output using some command-line
options:</p>

<p style="margin-top: 1em">&Acirc;&middot; --version:</p>

<p style="margin-top: 1em">Output the jq version and exit
with zero.</p>

<p style="margin-top: 1em">&Acirc;&middot; --seq:</p>

<p style="margin-top: 1em">Use the application/json-seq
MIME type scheme for separating JSON texts in
jq&Acirc;&acute;s input and output. This means that an ASCII
RS (record separator) character is printed before <br>
each value on output and an ASCII LF (line feed) is printed
after every output. Input JSON texts that fail to parse are
ignored (but warned about), discarding all subsequent <br>
input until the next RS. This more also parses the output of
jq without the --seq option.</p>

<p style="margin-top: 1em">&Acirc;&middot; --stream:</p>

<p style="margin-top: 1em">Parse the input in streaming
fashion, outputing arrays of path and leaf values (scalars
and empty arrays or empty objects). For example,
&quot;a&quot; becomes [[],&quot;a&quot;], and <br>
[[],&quot;a&quot;,[&quot;b&quot;]] becomes [[0],[]],
[[1],&quot;a&quot;], and [[1,0],&quot;b&quot;].</p>

<p style="margin-top: 1em">This is useful for processing
very large inputs. Use this in conjunction with filtering
and the reduce and foreach syntax to reduce large inputs
incrementally.</p>

<p style="margin-top: 1em">&Acirc;&middot; --slurp/-s:</p>

<p style="margin-top: 1em">Instead of running the filter
for each JSON object in the input, read the entire input
stream into a large array and run the filter just once.</p>

<p style="margin-top: 1em">&Acirc;&middot;
--raw-input/-R:</p>

<p style="margin-top: 1em">Don&Acirc;&acute;t parse the
input as JSON. Instead, each line of text is passed to the
filter as a string. If combined with --slurp, then the
entire input is passed to the filter as a <br>
single long string.</p>

<p style="margin-top: 1em">&Acirc;&middot;
--null-input/-n:</p>

<p style="margin-top: 1em">Don&Acirc;&acute;t read any
input at all! Instead, the filter is run once using null as
the input. This is useful when using jq as a simple
calculator or to construct JSON data from <br>
scratch.</p>

<p style="margin-top: 1em">&Acirc;&middot; --compact-output
/ -c:</p>

<p style="margin-top: 1em">By default, jq pretty-prints
JSON output. Using this option will result in more compact
output by instead putting each JSON object on a single
line.</p>

<p style="margin-top: 1em">&Acirc;&middot; --tab:</p>

<p style="margin-top: 1em">Use a tab for each indentation
level instead of two spaces.</p>

<p style="margin-top: 1em">&Acirc;&middot; --indent n:</p>

<p style="margin-top: 1em">Use the given number of spaces
(no more than 8) for indentation.</p>

<p style="margin-top: 1em">&Acirc;&middot; --color-output /
-C and --monochrome-output / -M:</p>

<p style="margin-top: 1em">By default, jq outputs colored
JSON if writing to a terminal. You can force it to produce
color even if writing to a pipe or a file using -C, and
disable color with -M.</p>

<p style="margin-top: 1em">&Acirc;&middot; --ascii-output /
-a:</p>

<p style="margin-top: 1em">jq usually outputs non-ASCII
Unicode codepoints as UTF-8, even if the input specified
them as escape sequences (like &quot;03bc&quot;). Using this
option, you can force jq to produce <br>
pure ASCII output with every non-ASCII character replaced
with the equivalent escape sequence.</p>

<p style="margin-top: 1em">&Acirc;&middot; --unbuffered</p>

<p style="margin-top: 1em">Flush the output after each JSON
object is printed (useful if you&Acirc;&acute;re piping a
slow data source into jq and piping jq&Acirc;&acute;s output
elsewhere).</p>

<p style="margin-top: 1em">&Acirc;&middot; --sort-keys /
-S:</p>

<p style="margin-top: 1em">Output the fields of each object
with the keys in sorted order.</p>

<p style="margin-top: 1em">&Acirc;&middot; --raw-output /
-r:</p>

<p style="margin-top: 1em">With this option, if the
filter&Acirc;&acute;s result is a string then it will be
written directly to standard output rather than being
formatted as a JSON string with quotes. This can be <br>
useful for making jq filters talk to non-JSON-based
systems.</p>

<p style="margin-top: 1em">&Acirc;&middot; --join-output /
-j:</p>

<p style="margin-top: 1em">Like -r but jq
won&Acirc;&acute;t print a newline after each output.</p>

<p style="margin-top: 1em">&Acirc;&middot; -f filename /
--from-file filename:</p>

<p style="margin-top: 1em">Read filter from the file rather
than from a command line, like awk&Acirc;&acute;s -f option.
You can also use &Acirc;&acute;#&Acirc;&acute; to make
comments.</p>

<p style="margin-top: 1em">&Acirc;&middot; -Ldirectory / -L
directory:</p>

<p style="margin-top: 1em">Prepend directory to the search
list for modules. If this option is used then no builtin
search list is used. See the section on modules below.</p>

<p style="margin-top: 1em">&Acirc;&middot; -e /
--exit-status:</p>

<p style="margin-top: 1em">Sets the exit status of jq to 0
if the last output values was neither false nor null, 1 if
the last output value was either false or null, or 4 if no
valid result was ever <br>
produced. Normally jq exits with 2 if there was any usage
problem or system error, 3 if there was a jq program compile
error, or 0 if the jq program ran.</p>

<p style="margin-top: 1em">&Acirc;&middot; --arg name
value:</p>

<p style="margin-top: 1em">This option passes a value to
the jq program as a predefined variable. If you run jq with
--arg foo bar, then $foo is available in the program and has
the value &quot;bar&quot;. Note <br>
that value will be treated as a string, so --arg foo 123
will bind $foo to &quot;123&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; --argjson name
JSON-text:</p>

<p style="margin-top: 1em">This option passes a
JSON-encoded value to the jq program as a predefined
variable. If you run jq with --argjson foo 123, then $foo is
available in the program and has the <br>
value 123.</p>

<p style="margin-top: 1em">&Acirc;&middot; --slurpfile
variable-name filename:</p>

<p style="margin-top: 1em">This option reads all the JSON
texts in the named file and binds an array of the parsed
JSON values to the given global variable. If you run jq with
--argfile foo bar, then <br>
$foo is available in the program and has an array whose
elements correspond to the texts in the file named bar.</p>

<p style="margin-top: 1em">&Acirc;&middot; --argfile
variable-name filename:</p>

<p style="margin-top: 1em">Do not use. Use --slurpfile
instead.</p>

<p style="margin-top: 1em">(This option is like
--slurpfile, but when the file has just one text, then that
is used, else an array of texts is used as in
--slurpfile.)</p>

<p style="margin-top: 1em">&Acirc;&middot; --run-tests
[filename]:</p>

<p style="margin-top: 1em">Runs the tests in the given file
or standard input. This must be the last option given and
does not honor all preceding options. The input consists of
comment lines, empty <br>
lines, and program lines followed by one input line, as many
lines of output as are expected (one per output), and a
terminating empty line. Compilation failure tests start <br>
with a line containing only &quot;%%FAIL&quot;, then a line
containing the program to compile, then a line containing an
error message to compare to the actual.</p>

<p style="margin-top: 1em">Be warned that this option can
change backwards-incompatibly.</p>

<p style="margin-top: 1em">BASIC FILTERS <br>
. <br>
The absolute simplest (and least interesting) filter is ..
This is a filter that takes its input and produces it
unchanged as output.</p>

<p style="margin-top: 1em">Since jq by default
pretty-prints all output, this trivial program can be a
useful way of formatting JSON output from, say, curl.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.&Acirc;&acute;
<br>
&quot;Hello, world!&quot; <br>
=&gt; &quot;Hello, world!&quot;</p>

<p style="margin-top: 1em">.foo, .foo.bar <br>
The simplest useful filter is .foo. When given a JSON object
(aka dictionary or hash) as input, it produces the value at
the key &quot;foo&quot;, or null if there&Acirc;&acute;s
none present.</p>

<p style="margin-top: 1em">If the key contains special
characters, you need to surround it with double quotes like
this: .&quot;foo$&quot;.</p>

<p style="margin-top: 1em">A filter of the form .foo.bar is
equivalent to .foo|.bar.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.foo&Acirc;&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less
interesting data&quot;} <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.foo&Acirc;&acute; <br>
{&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false}
<br>
=&gt; null</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[&quot;foo&quot;]&Acirc;&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; 42</p>

<p style="margin-top: 1em">.foo? <br>
Just like .foo, but does not output even an error when . is
not an array or an object.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.foo?&Acirc;&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less
interesting data&quot;} <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.foo?&Acirc;&acute; <br>
{&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false}
<br>
=&gt; null</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[&quot;foo&quot;]?&Acirc;&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; 42</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.foo?]&Acirc;&acute; <br>
[1,2] <br>
=&gt; []</p>

<p style="margin-top: 1em">.[&lt;string&gt;], .[2],
.[10:15] <br>
You can also look up fields of an object using syntax like
.[&quot;foo&quot;] (.foo above is a shorthand version of
this). This one works for arrays as well, if the key is an
integer. <br>
Arrays are zero-based (like javascript), so .[2] returns the
third element of the array.</p>

<p style="margin-top: 1em">The .[10:15] syntax can be used
to return a subarray of an array or substring of a string.
The array returned by .[10:15] will be of length 5,
containing the elements from index <br>
10 (inclusive) to index 15 (exclusive). Either index may be
negative (in which case it counts backwards from the end of
the array), or omitted (in which case it refers to the <br>
start or end of the array).</p>

<p style="margin-top: 1em">The .[2] syntax can be used to
return the element at the given index. Negative indices are
allowed, with -1 referring to the last element, -2 referring
to the next to last ele&acirc; <br>
ment, and so on.</p>

<p style="margin-top: 1em">The .foo syntax only works for
simply keys i.e. keys that are all alphanumeric characters.
.[&lt;string&gt;] works with keys that contain special
characters such as colons and dots. <br>
For example .[&quot;foo::bar&quot;] and
.[&quot;foo.bar&quot;] work while .foo::bar and .foo.bar
would not.</p>

<p style="margin-top: 1em">The ? &quot;operator&quot; can
also be used with the slice operator, as in .[10:15]?, which
outputs values where the inputs are slice-able.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[0]&Acirc;&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; {&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[2]&Acirc;&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; null</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[2:4]&Acirc;&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;c&quot;, &quot;d&quot;]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[2:4]&Acirc;&acute; <br>
&quot;abcdefghi&quot; <br>
=&gt; &quot;cd&quot;</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[:3]&Acirc;&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[-2:]&Acirc;&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;d&quot;, &quot;e&quot;]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[-2]&Acirc;&acute; <br>
[1,2,3] <br>
=&gt; 2</p>

<p style="margin-top: 1em">.[] <br>
If you use the .[index] syntax, but omit the index entirely,
it will return all of the elements of an array. Running .[]
with the input [1,2,3] will produce the numbers as three
<br>
separate results, rather than as a single array.</p>

<p style="margin-top: 1em">You can also use this on an
object, and it will return all the values of the object.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[]&Acirc;&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; {&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;,
&quot;good&quot;:false}</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[]&Acirc;&acute; <br>
[] <br>
=&gt;</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[]&Acirc;&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 1} <br>
=&gt; 1, 1</p>

<p style="margin-top: 1em">.[]? <br>
Like .[], but no errors will be output if . is not an array
or object.</p>

<p style="margin-top: 1em">, <br>
If two filters are separated by a comma, then the input will
be fed into both and there will be multiple outputs: first,
all of the outputs produced by the left expression, and <br>
then all of the outputs produced by the right. For instance,
filter .foo, .bar, produces both the &quot;foo&quot; fields
and &quot;bar&quot; fields as separate outputs.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.foo,
.bar&Acirc;&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;something
else&quot;, &quot;baz&quot;: true} <br>
=&gt; 42, &quot;something else&quot;</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.user,
.projects[]&Acirc;&acute; <br>
{&quot;user&quot;:&quot;stedolan&quot;,
&quot;projects&quot;: [&quot;jq&quot;,
&quot;wikiflow&quot;]} <br>
=&gt; &quot;stedolan&quot;, &quot;jq&quot;,
&quot;wikiflow&quot;</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[4,2]&Acirc;&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; &quot;e&quot;, &quot;c&quot;</p>

<p style="margin-top: 1em">| <br>
The | operator combines two filters by feeding the output(s)
of the one on the left into the input of the one on the
right. It&Acirc;&acute;s pretty much the same as the Unix
shell&Acirc;&acute;s pipe, if <br>
you&Acirc;&acute;re used to that.</p>

<p style="margin-top: 1em">If the one on the left produces
multiple results, the one on the right will be run for each
of those results. So, the expression .[] | .foo retrieves
the &quot;foo&quot; field of each ele&acirc; <br>
ment of the input array.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] |
.name&Acirc;&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; &quot;JSON&quot;, &quot;XML&quot;</p>

<p style="margin-top: 1em">TYPES AND VALUES <br>
jq supports the same set of datatypes as JSON - numbers,
strings, booleans, arrays, objects (which in JSON-speak are
hashes with only string keys), and &quot;null&quot;.</p>

<p style="margin-top: 1em">Booleans, null, strings and
numbers are written the same way as in javascript. Just like
everything else in jq, these simple values take an input and
produce an output - 42 is a <br>
valid jq expression that takes an input, ignores it, and
returns 42 instead.</p>

<p style="margin-top: 1em">Array construction - [] <br>
As in JSON, [] is used to construct arrays, as in [1,2,3].
The elements of the arrays can be any jq expression. All of
the results produced by all of the expressions are
col&acirc; <br>
lected into one big array. You can use it to construct an
array out of a known quantity of values (as in [.foo, .bar,
.baz]) or to &quot;collect&quot; all the results of a filter
into an <br>
array (as in [.items[].name])</p>

<p style="margin-top: 1em">Once you understand the
&quot;,&quot; operator, you can look at jq&Acirc;&acute;s
array syntax in a different light: the expression [1,2,3] is
not using a built-in syntax for comma-separated arrays, <br>
but is instead applying the [] operator (collect results) to
the expression 1,2,3 (which produces three different
results).</p>

<p style="margin-top: 1em">If you have a filter X that
produces four results, then the expression [X] will produce
a single result, an array of four elements.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;[.user,
.projects[]]&Acirc;&acute; <br>
{&quot;user&quot;:&quot;stedolan&quot;,
&quot;projects&quot;: [&quot;jq&quot;,
&quot;wikiflow&quot;]} <br>
=&gt; [&quot;stedolan&quot;, &quot;jq&quot;,
&quot;wikiflow&quot;]</p>

<p style="margin-top: 1em">Objects - {} <br>
Like JSON, {} is for constructing objects (aka dictionaries
or hashes), as in: {&quot;a&quot;: 42, &quot;b&quot;:
17}.</p>

<p style="margin-top: 1em">If the keys are
&quot;sensible&quot; (all alphabetic characters), then the
quotes can be left off. The value can be any expression
(although you may need to wrap it in parentheses if
it&Acirc;&acute;s <br>
a complicated one), which gets applied to the {}
expression&Acirc;&acute;s input (remember, all filters have
an input and an output).</p>

<p style="margin-top: 1em">{foo: .bar}</p>

<p style="margin-top: 1em">will produce the JSON object
{&quot;foo&quot;: 42} if given the JSON object
{&quot;bar&quot;:42, &quot;baz&quot;:43}. You can use this
to select particular fields of an object: if the input is an
object with <br>
&quot;user&quot;, &quot;title&quot;, &quot;id&quot;, and
&quot;content&quot; fields and you just want
&quot;user&quot; and &quot;title&quot;, you can write</p>

<p style="margin-top: 1em">{user: .user, title: .title}</p>

<p style="margin-top: 1em">Because that&Acirc;&acute;s so
common, there&Acirc;&acute;s a shortcut syntax: {user,
title}.</p>

<p style="margin-top: 1em">If one of the expressions
produces multiple results, multiple dictionaries will be
produced. If the input&Acirc;&acute;s</p>


<p style="margin-top: 1em">{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]}</p>

<p style="margin-top: 1em">then the expression</p>

<p style="margin-top: 1em">{user, title: .titles[]}</p>

<p style="margin-top: 1em">will produce two outputs:</p>


<p style="margin-top: 1em">{&quot;user&quot;:&quot;stedolan&quot;,
&quot;title&quot;: &quot;JQ Primer&quot;} <br>
{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;:
&quot;More JQ&quot;}</p>

<p style="margin-top: 1em">Putting parentheses around the
key means it will be evaluated as an expression. With the
same input as above,</p>

<p style="margin-top: 1em">{(.user): .titles}</p>

<p style="margin-top: 1em">produces</p>

<p style="margin-top: 1em">{&quot;stedolan&quot;: [&quot;JQ
Primer&quot;, &quot;More JQ&quot;]}</p>

<p style="margin-top: 1em">jq &Acirc;&acute;{user, title:
.titles[]}&Acirc;&acute; <br>

{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]} <br>
=&gt; {&quot;user&quot;:&quot;stedolan&quot;,
&quot;title&quot;: &quot;JQ Primer&quot;},
{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;:
&quot;More JQ&quot;}</p>

<p style="margin-top: 1em">jq &Acirc;&acute;{(.user):
.titles}&Acirc;&acute; <br>

{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]} <br>
=&gt; {&quot;stedolan&quot;: [&quot;JQ Primer&quot;,
&quot;More JQ&quot;]}</p>

<p style="margin-top: 1em">BUILTIN OPERATORS AND FUNCTIONS
<br>
Some jq operator (for instance, +) do different things
depending on the type of their arguments (arrays, numbers,
etc.). However, jq never does implicit type conversions. If
you <br>
try to add a string to an object you&Acirc;&acute;ll get an
error message and no result.</p>

<p style="margin-top: 1em">Addition - + <br>
The operator + takes two filters, applies them both to the
same input, and adds the results together. What
&quot;adding&quot; means depends on the types involved:</p>

<p style="margin-top: 1em">&Acirc;&middot; Numbers are
added by normal arithmetic.</p>

<p style="margin-top: 1em">&Acirc;&middot; Arrays are added
by being concatenated into a larger array.</p>

<p style="margin-top: 1em">&Acirc;&middot; Strings are
added by being joined into a larger string.</p>

<p style="margin-top: 1em">&Acirc;&middot; Objects are
added by merging, that is, inserting all the key-value pairs
from both objects into a single combined object. If both
objects contain a value for the same key, <br>
the object on the right of the + wins. (For recursive merge
use the * operator.)</p>

<p style="margin-top: 1em">null can be added to any value,
and returns the other value unchanged.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.a +
1&Acirc;&acute; <br>
{&quot;a&quot;: 7} <br>
=&gt; 8</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.a +
.b&Acirc;&acute; <br>
{&quot;a&quot;: [1,2], &quot;b&quot;: [3,4]} <br>
=&gt; [1,2,3,4]</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.a +
null&Acirc;&acute; <br>
{&quot;a&quot;: 1} <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.a +
1&Acirc;&acute; <br>
{} <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &Acirc;&acute;{a: 1} + {b: 2}
+ {c: 3} + {a: 42}&Acirc;&acute; <br>
null <br>
=&gt; {&quot;a&quot;: 42, &quot;b&quot;: 2, &quot;c&quot;:
3}</p>

<p style="margin-top: 1em">Subtraction - - <br>
As well as normal arithmetic subtraction on numbers, the -
operator can be used on arrays to remove all occurrences of
the second array&Acirc;&acute;s elements from the first
array.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;4 -
.a&Acirc;&acute; <br>
{&quot;a&quot;:3} <br>
=&gt; 1</p>

<p style="margin-top: 1em">jq &Acirc;&acute;. -
[&quot;xml&quot;, &quot;yaml&quot;]&Acirc;&acute; <br>
[&quot;xml&quot;, &quot;yaml&quot;, &quot;json&quot;] <br>
=&gt; [&quot;json&quot;]</p>

<p style="margin-top: 1em">Multiplication, division, modulo
- *, /, and % <br>
These infix operators behave as expected when given two
numbers. Division by zero raises an error. x % y computes x
modulo y.</p>

<p style="margin-top: 1em">Multiplying a string by a number
produces the concatenation of that string that many times.
&quot;x&quot; * 0 produces null.</p>

<p style="margin-top: 1em">Dividing a string by another
splits the first using the second as separators.</p>

<p style="margin-top: 1em">Multiplying two objects will
merge them recursively: this works like addition but if both
objects contain a value for the same key, and the values are
objects, the two are merged <br>
with the same strategy.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;10 / . *
3&Acirc;&acute; <br>
5 <br>
=&gt; 6</p>

<p style="margin-top: 1em">jq &Acirc;&acute;. / &quot;,
&quot;&Acirc;&acute; <br>
&quot;a, b,c,d, e&quot; <br>
=&gt; [&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;]</p>

<p style="margin-top: 1em">jq &Acirc;&acute;{&quot;k&quot;:
{&quot;a&quot;: 1, &quot;b&quot;: 2}} * {&quot;k&quot;:
{&quot;a&quot;: 0,&quot;c&quot;: 3}}&Acirc;&acute; <br>
null <br>
=&gt; {&quot;k&quot;: {&quot;a&quot;: 0, &quot;b&quot;: 2,
&quot;c&quot;: 3}}</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] | (1 /
.)?&Acirc;&acute; <br>
[1,0,-1] <br>
=&gt; 1, -1</p>

<p style="margin-top: 1em">length <br>
The builtin function length gets the length of various
different types of value:</p>

<p style="margin-top: 1em">&Acirc;&middot; The length of a
string is the number of Unicode codepoints it contains
(which will be the same as its JSON-encoded length in bytes
if it&Acirc;&acute;s pure ASCII).</p>

<p style="margin-top: 1em">&Acirc;&middot; The length of an
array is the number of elements.</p>

<p style="margin-top: 1em">&Acirc;&middot; The length of an
object is the number of key-value pairs.</p>

<p style="margin-top: 1em">&Acirc;&middot; The length of
null is zero.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] |
length&Acirc;&acute; [[1,2], &quot;string&quot;,
{&quot;a&quot;:2}, null] =&gt; 2, 6, 1, 0</p>

<p style="margin-top: 1em">keys, keys_unsorted <br>
The builtin function keys, when given an object, returns its
keys in an array.</p>

<p style="margin-top: 1em">The keys are sorted
&quot;alphabetically&quot;, by unicode codepoint order. This
is not an order that makes particular sense in any
particular language, but you can count on it being the <br>
same for any two objects with the same set of keys,
regardless of locale settings.</p>

<p style="margin-top: 1em">When keys is given an array, it
returns the valid indices for that array: the integers from
0 to length-1.</p>

<p style="margin-top: 1em">The keys_unsorted function is
just like keys, but if the input is an object then the keys
will not be sorted, instead the keys will roughly be in
insertion order.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;keys&Acirc;&acute; <br>
{&quot;abc&quot;: 1, &quot;abcd&quot;: 2, &quot;Foo&quot;:
3} <br>
=&gt; [&quot;Foo&quot;, &quot;abc&quot;,
&quot;abcd&quot;]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;keys&Acirc;&acute; <br>
[42,3,35] <br>
=&gt; [0,1,2]</p>

<p style="margin-top: 1em">has(key) <br>
The builtin function has returns whether the input object
has the given key, or the input array has an element at the
given index.</p>

<p style="margin-top: 1em">has($key) has the same effect as
checking whether $key is a member of the array returned by
keys, although has will be faster.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;map(has(&quot;foo&quot;))&Acirc;&acute; <br>
[{&quot;foo&quot;: 42}, {}] <br>
=&gt; [true, false]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;map(has(2))&Acirc;&acute; <br>
[[0,1], [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]] <br>
=&gt; [false, true]</p>

<p style="margin-top: 1em">in <br>
The builtin function in returns the input key is in the
given object, or the input index corresponds to an element
in the given array. It is, essentially, an inversed version
of <br>
has.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] |
in({&quot;foo&quot;: 42})&Acirc;&acute; <br>
[&quot;foo&quot;, &quot;bar&quot;] <br>
=&gt; true, false</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;map(in([0,1]))&Acirc;&acute; <br>
[2, 0] <br>
=&gt; [false, true]</p>

<p style="margin-top: 1em">path(path_expression) <br>
Outputs array representations of the given path expression
in .. The outputs are arrays of strings (keys in objects0
and/or numbers (array indices.</p>

<p style="margin-top: 1em">Path expressions are jq
expressions like .a, but also .[]. There are two types of
path expressions: ones that can match exactly, and ones that
cannot. For example, .a.b.c is an <br>
exact match path expression, while .a[].b is not.</p>

<p style="margin-top: 1em">path(exact_path_expression) will
produce the array representation of the path expression even
if it does not exist in ., if . is null or an array or an
object.</p>

<p style="margin-top: 1em">path(pattern) will produce array
representations of the paths matching pattern if the paths
exist in ..</p>

<p style="margin-top: 1em">Note that the path expressions
are not different from normal expressions. The expression
path(..|select(type==&quot;boolean&quot;)) outputs all the
paths to boolean values in ., and only <br>
those paths.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;path(.a[0].b)&Acirc;&acute; <br>
null <br>
=&gt; [&quot;a&quot;,0,&quot;b&quot;]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[path(..)]&Acirc;&acute; <br>
{&quot;a&quot;:[{&quot;b&quot;:1}]} <br>
=&gt;
[[],[&quot;a&quot;],[&quot;a&quot;,0],[&quot;a&quot;,0,&quot;b&quot;]]</p>

<p style="margin-top: 1em">del(path_expression) <br>
The builtin function del removes a key and its corresponding
value from an object.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;del(.foo)&Acirc;&acute; <br>
{&quot;foo&quot;: 42, &quot;bar&quot;: 9001,
&quot;baz&quot;: 42} <br>
=&gt; {&quot;bar&quot;: 9001, &quot;baz&quot;: 42}</p>

<p style="margin-top: 1em">jq &Acirc;&acute;del(.[1,
2])&Acirc;&acute; <br>
[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;] <br>
=&gt; [&quot;foo&quot;]</p>

<p style="margin-top: 1em">to_entries, from_entries,
with_entries <br>
These functions convert between an object and an array of
key-value pairs. If to_entries is passed an object, then for
each k: v entry in the input, the output array includes <br>
{&quot;key&quot;: k, &quot;value&quot;: v}.</p>

<p style="margin-top: 1em">from_entries does the opposite
conversion, and with_entries(foo) is a shorthand for
to_entries | map(foo) | from_entries, useful for doing some
operation to all keys and values <br>
of an object. from_entries accepts key, Key, Name, value and
Value as keys.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;to_entries&Acirc;&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 2} <br>
=&gt; [{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1},
{&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;from_entries&Acirc;&acute; <br>
[{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1},
{&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}] <br>
=&gt; {&quot;a&quot;: 1, &quot;b&quot;: 2}</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;with_entries(.key |= &quot;KEY_&quot; +
.)&Acirc;&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 2} <br>
=&gt; {&quot;KEY_a&quot;: 1, &quot;KEY_b&quot;: 2}</p>

<p style="margin-top: 1em">select(boolean_expression) <br>
The function select(foo) produces its input unchanged if foo
returns true for that input, and produces no output
otherwise.</p>

<p style="margin-top: 1em">It&Acirc;&acute;s useful for
filtering lists: [1,2,3] | map(select(. &gt;= 2)) will give
you [2,3].</p>

<p style="margin-top: 1em">jq &Acirc;&acute;map(select(.
&gt;= 2))&Acirc;&acute; <br>
[1,5,3,0,7] <br>
=&gt; [5,3,7]</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] |
select(.id == &quot;second&quot;)&Acirc;&acute; <br>
[{&quot;id&quot;: &quot;first&quot;, &quot;val&quot;: 1},
{&quot;id&quot;: &quot;second&quot;, &quot;val&quot;: 2}]
<br>
=&gt; {&quot;id&quot;: &quot;second&quot;, &quot;val&quot;:
2}</p>

<p style="margin-top: 1em">arrays, objects, iterables,
booleans, numbers, normals, finites, strings, nulls, values,
scalars <br>
These built-ins select only inputs that are arrays, objects,
iterables (arrays or objects), booleans, numbers, normal
numbers, finite numbers, strings, null, non-null values, and
<br>
non-iterables, respectively.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;.[]|numbers&Acirc;&acute; <br>
[[],{},1,&quot;foo&quot;,null,true,false] <br>
=&gt; 1</p>

<p style="margin-top: 1em">empty <br>
empty returns no results. None at all. Not even null.</p>

<p style="margin-top: 1em">It&Acirc;&acute;s useful on
occasion. You&Acirc;&acute;ll know if you need it :)</p>

<p style="margin-top: 1em">jq &Acirc;&acute;1, empty,
2&Acirc;&acute; <br>
null <br>
=&gt; 1, 2</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[1,2,empty,3]&Acirc;&acute; <br>
null <br>
=&gt; [1,2,3]</p>

<p style="margin-top: 1em">error(message) <br>
Produces an error, just like .a applied to values other than
null and objects would, but with the given message as the
error&Acirc;&acute;s value.</p>

<p style="margin-top: 1em">$__loc__ <br>
Produces an object with a &quot;file&quot; key and a
&quot;line&quot; key, with the filename and line number
where $__loc__ occurs, as values.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;try
error(&quot;_loc__)&quot;) catch .&Acirc;&acute; <br>
null <br>
=&gt; &quot;{</p>

<p style="margin-top: 1em">map(x), map_values(x) <br>
For any filter x, map(x) will run that filter for each
element of the input array, and produce the outputs a new
array. map(.+1) will increment each element of an array of
num&acirc; <br>
bers.</p>

<p style="margin-top: 1em">Similarly, map_values(x) will
run that filter for each element, but it will return an
object when an object is passed.</p>

<p style="margin-top: 1em">map(x) is equivalent to [.[] |
x]. In fact, this is how it&Acirc;&acute;s defined.
Similarly, map_values(x) is defined as .[] |= x.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;map(.+1)&Acirc;&acute; <br>
[1,2,3] <br>
=&gt; [2,3,4]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;map_values(.+1)&Acirc;&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3} <br>
=&gt; {&quot;a&quot;: 2, &quot;b&quot;: 3, &quot;c&quot;:
4}</p>

<p style="margin-top: 1em">paths, paths(node_filter),
leaf_paths <br>
paths outputs the paths to all the elements in its input
(except it does not output the empty list, representing .
itself).</p>

<p style="margin-top: 1em">paths(f) outputs the paths to
any values for which f is true. That is, paths(numbers)
outputs the paths to all numeric values.</p>

<p style="margin-top: 1em">leaf_paths is an alias of
paths(scalars); leaf_paths is deprecated and will be removed
in the next major release.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[paths]&Acirc;&acute; <br>
[1,[[],{&quot;a&quot;:2}]] <br>
=&gt; [[0],[1],[1,0],[1,1],[1,1,&quot;a&quot;]]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[paths(scalars)]&Acirc;&acute; <br>
[1,[[],{&quot;a&quot;:2}]] <br>
=&gt; [[0],[1,1,&quot;a&quot;]]</p>

<p style="margin-top: 1em">add <br>
The filter add takes as input an array, and produces as
output the elements of the array added together. This might
mean summed, concatenated or merged depending on the types
of <br>
the elements of the input array - the rules are the same as
those for the + operator (described above).</p>

<p style="margin-top: 1em">If the input is an empty array,
add returns null.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;add&Acirc;&acute; <br>
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] <br>
=&gt; &quot;abc&quot;</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;add&Acirc;&acute; <br>
[1, 2, 3] <br>
=&gt; 6</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;add&Acirc;&acute; <br>
[] <br>
=&gt; null</p>

<p style="margin-top: 1em">any, any(condition),
any(generator; condition) <br>
The filter any takes as input an array of boolean values,
and produces true as output if any of the the elements of
the array is true.</p>

<p style="margin-top: 1em">If the input is an empty array,
any returns false.</p>

<p style="margin-top: 1em">The any(condition) form applies
the given condition to the elements of the input array.</p>

<p style="margin-top: 1em">The any(generator; condition)
form applies the given condition to all the outputs of the
given generator.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;any&Acirc;&acute; <br>
[true, false] <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;any&Acirc;&acute; <br>
[false, false] <br>
=&gt; false</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;any&Acirc;&acute; <br>
[] <br>
=&gt; false</p>

<p style="margin-top: 1em">all, all(condition),
all(generator; condition) <br>
The filter all takes as input an array of boolean values,
and produces true as output if all of the the elements of
the array are true.</p>

<p style="margin-top: 1em">The all(condition) form applies
the given condition to the elements of the input array.</p>

<p style="margin-top: 1em">The all(generator; condition)
form applies the given condition to all the outputs of the
given generator.</p>

<p style="margin-top: 1em">If the input is an empty array,
all returns true.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;all&Acirc;&acute; <br>
[true, false] <br>
=&gt; false</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;all&Acirc;&acute; <br>
[true, true] <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;all&Acirc;&acute; <br>
[] <br>
=&gt; true</p>

<p style="margin-top: 1em">[Requires 1.5] flatten,
flatten(depth) <br>
The filter flatten takes as input an array of nested arrays,
and produces a flat array in which all arrays inside the
original array have been recursively replaced by their
val&acirc; <br>
ues. You can pass an argument to it to specify how many
levels of nesting to flatten.</p>

<p style="margin-top: 1em">flatten(2) is like flatten, but
going only up to two levels deep.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;flatten&Acirc;&acute; <br>
[1, [2], [[3]]] <br>
=&gt; [1, 2, 3]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;flatten(1)&Acirc;&acute; <br>
[1, [2], [[3]]] <br>
=&gt; [1, 2, [3]]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;flatten&Acirc;&acute; <br>
[[]] <br>
=&gt; []</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;flatten&Acirc;&acute; <br>
[{&quot;foo&quot;: &quot;bar&quot;}, [{&quot;foo&quot;:
&quot;baz&quot;}]] <br>
=&gt; [{&quot;foo&quot;: &quot;bar&quot;}, {&quot;foo&quot;:
&quot;baz&quot;}]</p>

<p style="margin-top: 1em">range(upto), range(from;upto)
range(from;upto;by) <br>
The range function produces a range of numbers. range(4;10)
produces 6 numbers, from 4 (inclusive) to 10 (exclusive).
The numbers are produced as separate outputs. Use <br>
[range(4;10)] to get a range as an array.</p>

<p style="margin-top: 1em">The one argument form generates
numbers from 0 to the given number, with an increment of
1.</p>

<p style="margin-top: 1em">The two argument form generates
numbers from from to upto with an increment of 1.</p>

<p style="margin-top: 1em">The three argument form
generates numbers from to upto with an increment of by.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;range(2;4)&Acirc;&acute; <br>
null <br>
=&gt; 2, 3</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[range(2;4)]&Acirc;&acute; <br>
null <br>
=&gt; [2,3]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[range(4)]&Acirc;&acute; <br>
null <br>
=&gt; [0,1,2,3]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[range(0;10;3)]&Acirc;&acute; <br>
null <br>
=&gt; [0,3,6,9]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[range(0;10;-1)]&Acirc;&acute; <br>
null <br>
=&gt; []</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[range(0;-5;-1)]&Acirc;&acute; <br>
null <br>
=&gt; [0,-1,-2,-3,-4]</p>

<p style="margin-top: 1em">floor <br>
The floor function returns the floor of its numeric
input.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;floor&Acirc;&acute; <br>
3.14159 <br>
=&gt; 3</p>

<p style="margin-top: 1em">sqrt <br>
The sqrt function returns the square root of its numeric
input.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;sqrt&Acirc;&acute; <br>
9 <br>
=&gt; 3</p>

<p style="margin-top: 1em">tonumber <br>
The tonumber function parses its input as a number. It will
convert correctly-formatted strings to their numeric
equivalent, leave numbers alone, and give an error on all
other <br>
input.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] |
tonumber&Acirc;&acute; <br>
[1, &quot;1&quot;] <br>
=&gt; 1, 1</p>

<p style="margin-top: 1em">tostring <br>
The tostring function prints its input as a string. Strings
are left unchanged, and all other values are
JSON-encoded.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] |
tostring&Acirc;&acute; <br>
[1, &quot;1&quot;, [1]] <br>
=&gt; &quot;1&quot;, &quot;1&quot;, &quot;[1]&quot;</p>

<p style="margin-top: 1em">type <br>
The type function returns the type of its argument as a
string, which is one of null, boolean, number, string, array
or object.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;map(type)&Acirc;&acute; <br>
[0, false, [], {}, null, &quot;hello&quot;] <br>
=&gt; [&quot;number&quot;, &quot;boolean&quot;,
&quot;array&quot;, &quot;object&quot;, &quot;null&quot;,
&quot;string&quot;]</p>

<p style="margin-top: 1em">infinite, nan, isinfinite,
isnan, isfinite, isnormal <br>
Some arithmetic operations can yield infinities and
&quot;not a number&quot; (NaN) values. The isinfinite
builtin returns true if its input is infinite. The isnan
builtin returns true if <br>
its input is a NaN. The infinite builtin returns a positive
infinite value. The nan builtin returns a NaN. The isnormal
builtin returns true if its input is a normal number.</p>

<p style="margin-top: 1em">Note that division by zero
raises an error.</p>

<p style="margin-top: 1em">Currently most arithmetic
operations operating on infinities, NaNs, and sub-normals do
not raise errors.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] | (infinite
* .) &lt; 0&Acirc;&acute; <br>
[-1, 1] <br>
=&gt; true, false</p>

<p style="margin-top: 1em">jq &Acirc;&acute;infinite, nan |
type&Acirc;&acute; <br>
null <br>
=&gt; &quot;number&quot;, &quot;number&quot;</p>

<p style="margin-top: 1em">sort, sort_by(path_expression)
<br>
The sort functions sorts its input, which must be an array.
Values are sorted in the following order:</p>

<p style="margin-top: 1em">&Acirc;&middot; null</p>

<p style="margin-top: 1em">&Acirc;&middot; false</p>

<p style="margin-top: 1em">&Acirc;&middot; true</p>

<p style="margin-top: 1em">&Acirc;&middot; numbers</p>

<p style="margin-top: 1em">&Acirc;&middot; strings, in
alphabetical order (by unicode codepoint value)</p>

<p style="margin-top: 1em">&Acirc;&middot; arrays, in
lexical order</p>

<p style="margin-top: 1em">&Acirc;&middot; objects</p>

<p style="margin-top: 1em">The ordering for objects is a
little complex: first they&Acirc;&acute;re compared by
comparing their sets of keys (as arrays in sorted order),
and if their keys are equal then the values are <br>
compared key by key.</p>

<p style="margin-top: 1em">sort may be used to sort by a
particular field of an object, or by applying any jq
filter.</p>

<p style="margin-top: 1em">sort_by(foo) compares two
elements by comparing the result of foo on each element.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;sort&Acirc;&acute; <br>
[8,3,null,6] <br>
=&gt; [null,3,6,8]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;sort_by(.foo)&Acirc;&acute; <br>
[{&quot;foo&quot;:4, &quot;bar&quot;:10},
{&quot;foo&quot;:3, &quot;bar&quot;:100},
{&quot;foo&quot;:2, &quot;bar&quot;:1}] <br>
=&gt; [{&quot;foo&quot;:2, &quot;bar&quot;:1},
{&quot;foo&quot;:3, &quot;bar&quot;:100},
{&quot;foo&quot;:4, &quot;bar&quot;:10}]</p>

<p style="margin-top: 1em">group_by(path_expression) <br>
group_by(.foo) takes as input an array, groups the elements
having the same .foo field into separate arrays, and
produces all of these arrays as elements of a larger array,
<br>
sorted by the value of the .foo field.</p>

<p style="margin-top: 1em">Any jq expression, not just a
field access, may be used in place of .foo. The sorting
order is the same as described in the sort function
above.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;group_by(.foo)&Acirc;&acute; <br>
[{&quot;foo&quot;:1, &quot;bar&quot;:10},
{&quot;foo&quot;:3, &quot;bar&quot;:100},
{&quot;foo&quot;:1, &quot;bar&quot;:1}] <br>
=&gt; [[{&quot;foo&quot;:1, &quot;bar&quot;:10},
{&quot;foo&quot;:1, &quot;bar&quot;:1}],
[{&quot;foo&quot;:3, &quot;bar&quot;:100}]]</p>

<p style="margin-top: 1em">min, max, min_by(path_exp),
max_by(path_exp) <br>
Find the minimum or maximum element of the input array.</p>

<p style="margin-top: 1em">The min_by(path_exp) and
max_by(path_exp) functions allow you to specify a particular
field or property to examine, e.g. min_by(.foo) finds the
object with the smallest foo <br>
field.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;min&Acirc;&acute; <br>
[5,4,2,7] <br>
=&gt; 2</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;max_by(.foo)&Acirc;&acute; <br>
[{&quot;foo&quot;:1, &quot;bar&quot;:14},
{&quot;foo&quot;:2, &quot;bar&quot;:3}] <br>
=&gt; {&quot;foo&quot;:2, &quot;bar&quot;:3}</p>

<p style="margin-top: 1em">unique, unique_by(path_exp) <br>
The unique function takes as input an array and produces an
array of the same elements, in sorted order, with duplicates
removed.</p>

<p style="margin-top: 1em">The unique_by(path_exp) function
will keep only one element for each value obtained by
applying the argument. Think of it as making an array by
taking one element out of every <br>
group produced by group.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;unique&Acirc;&acute; <br>
[1,2,5,3,5,3,1,3] <br>
=&gt; [1,2,3,5]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;unique_by(.foo)&Acirc;&acute; <br>
[{&quot;foo&quot;: 1, &quot;bar&quot;: 2}, {&quot;foo&quot;:
1, &quot;bar&quot;: 3}, {&quot;foo&quot;: 4,
&quot;bar&quot;: 5}] <br>
=&gt; [{&quot;foo&quot;: 1, &quot;bar&quot;: 2},
{&quot;foo&quot;: 4, &quot;bar&quot;: 5}]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;unique_by(length)&Acirc;&acute; <br>
[&quot;chunky&quot;, &quot;bacon&quot;, &quot;kitten&quot;,
&quot;cicada&quot;, &quot;asparagus&quot;] <br>
=&gt; [&quot;bacon&quot;, &quot;chunky&quot;,
&quot;asparagus&quot;]</p>

<p style="margin-top: 1em">reverse <br>
This function reverses an array.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;reverse&Acirc;&acute; <br>
[1,2,3,4] <br>
=&gt; [4,3,2,1]</p>

<p style="margin-top: 1em">contains(element) <br>
The filter contains(b) will produce true if b is completely
contained within the input. A string B is contained in a
string A if B is a substring of A. An array B is contained
in <br>
an array A if all elements in B are contained in any element
in A. An object B is contained in object A if all of the
values in B are contained in the value in A with the same
<br>
key. All other types are assumed to be contained in each
other if they are equal.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;contains(&quot;bar&quot;)&Acirc;&acute; <br>
&quot;foobar&quot; <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;contains([&quot;baz&quot;,
&quot;bar&quot;])&Acirc;&acute; <br>
[&quot;foobar&quot;, &quot;foobaz&quot;, &quot;blarp&quot;]
<br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;contains([&quot;bazzzzz&quot;,
&quot;bar&quot;])&Acirc;&acute; <br>
[&quot;foobar&quot;, &quot;foobaz&quot;, &quot;blarp&quot;]
<br>
=&gt; false</p>

<p style="margin-top: 1em">jq &Acirc;&acute;contains({foo:
12, bar: [{barp: 12}]})&Acirc;&acute; <br>
{&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]} <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &Acirc;&acute;contains({foo:
12, bar: [{barp: 15}]})&Acirc;&acute; <br>
{&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]} <br>
=&gt; false</p>

<p style="margin-top: 1em">indices(s) <br>
Outputs an array containing the indices in . where s occurs.
The input may be an array, in which case if s is an array
then the indices output will be those where all elements in
<br>
. match those of s.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;indices(&quot;,
&quot;)&Acirc;&acute; <br>
&quot;a,b, cd, efg, hijk&quot; <br>
=&gt; [3,7,12]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;indices(1)&Acirc;&acute; <br>
[0,1,2,1,3,1,4] <br>
=&gt; [1,3,5]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;indices([1,2])&Acirc;&acute; <br>
[0,1,2,3,1,4,2,5,1,2,6,7] <br>
=&gt; [1,8]</p>

<p style="margin-top: 1em">index(s), rindex(s) <br>
Outputs the index of the first (index) or last (rindex)
occurrence of s in the input.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;index(&quot;,
&quot;)&Acirc;&acute; <br>
&quot;a,b, cd, efg, hijk&quot; <br>
=&gt; 3</p>

<p style="margin-top: 1em">jq &Acirc;&acute;rindex(&quot;,
&quot;)&Acirc;&acute; <br>
&quot;a,b, cd, efg, hijk&quot; <br>
=&gt; 12</p>

<p style="margin-top: 1em">inside <br>
The filter inside(b) will produce true if the input is
completely contained within b. It is, essentially, an
inversed version of contains.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;inside(&quot;foobar&quot;)&Acirc;&acute; <br>
&quot;bar&quot; <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;inside([&quot;foobar&quot;,
&quot;foobaz&quot;, &quot;blarp&quot;])&Acirc;&acute; <br>
[&quot;baz&quot;, &quot;bar&quot;] <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;inside([&quot;foobar&quot;,
&quot;foobaz&quot;, &quot;blarp&quot;])&Acirc;&acute; <br>
[&quot;bazzzzz&quot;, &quot;bar&quot;] <br>
=&gt; false</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;inside({&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]})&Acirc;&acute; <br>
{&quot;foo&quot;: 12, &quot;bar&quot;: [{&quot;barp&quot;:
12}]} <br>
=&gt; true</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;inside({&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]})&Acirc;&acute; <br>
{&quot;foo&quot;: 12, &quot;bar&quot;: [{&quot;barp&quot;:
15}]} <br>
=&gt; false</p>

<p style="margin-top: 1em">startswith(str) <br>
Outputs true if . starts with the given string argument.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|startswith(&quot;foo&quot;)]&Acirc;&acute;
<br>
[&quot;fo&quot;, &quot;foo&quot;, &quot;barfoo&quot;,
&quot;foobar&quot;, &quot;barfoob&quot;] <br>
=&gt; [false, true, false, true, false]</p>

<p style="margin-top: 1em">endswith(str) <br>
Outputs true if . ends with the given string argument.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|endswith(&quot;foo&quot;)]&Acirc;&acute;
<br>
[&quot;foobar&quot;, &quot;barfoo&quot;] <br>
=&gt; [false, true]</p>

<p style="margin-top: 1em">combinations, combinations(n)
<br>
Outputs all combinations of the elements of the arrays in
the input array. If given an argument n, it outputs all
combinations of n repetitions of the input array.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;combinations&Acirc;&acute; <br>
[[1,2], [3, 4]] <br>
=&gt; [1, 3], [1, 4], [2, 3], [2, 4]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;combinations(2)&Acirc;&acute; <br>
[0, 1] <br>
=&gt; [0, 0], [0, 1], [1, 0], [1, 1]</p>

<p style="margin-top: 1em">ltrimstr(str) <br>
Outputs its input with the given prefix string removed, if
it starts with it.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|ltrimstr(&quot;foo&quot;)]&Acirc;&acute;
<br>
[&quot;fo&quot;, &quot;foo&quot;, &quot;barfoo&quot;,
&quot;foobar&quot;, &quot;afoo&quot;] <br>
=&gt;
[&quot;fo&quot;,&quot;&quot;,&quot;barfoo&quot;,&quot;bar&quot;,&quot;afoo&quot;]</p>

<p style="margin-top: 1em">rtrimstr(str) <br>
Outputs its input with the given suffix string removed, if
it ends with it.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|rtrimstr(&quot;foo&quot;)]&Acirc;&acute;
<br>
[&quot;fo&quot;, &quot;foo&quot;, &quot;barfoo&quot;,
&quot;foobar&quot;, &quot;foob&quot;] <br>
=&gt;
[&quot;fo&quot;,&quot;&quot;,&quot;bar&quot;,&quot;foobar&quot;,&quot;foob&quot;]</p>

<p style="margin-top: 1em">explode <br>
Converts an input string into an array of the
string&Acirc;&acute;s codepoint numbers.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;explode&Acirc;&acute; <br>
&quot;foobar&quot; <br>
=&gt; [102,111,111,98,97,114]</p>

<p style="margin-top: 1em">implode <br>
The inverse of explode.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;implode&Acirc;&acute; <br>
[65, 66, 67] <br>
=&gt; &quot;ABC&quot;</p>

<p style="margin-top: 1em">split <br>
Splits an input string on the separator argument.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;split(&quot;,
&quot;)&Acirc;&acute; <br>
&quot;a, b,c,d, e, &quot; <br>
=&gt;
[&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;,&quot;&quot;]</p>

<p style="margin-top: 1em">join(str) <br>
Joins the array of elements given as input, using the
argument as separator. It is the inverse of split: that is,
running split(&quot;foo&quot;) | join(&quot;foo&quot;) over
any input string returns <br>
said input string.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;join(&quot;,
&quot;)&Acirc;&acute; <br>
[&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;] <br>
=&gt; &quot;a, b,c,d, e&quot;</p>

<p style="margin-top: 1em">ascii_downcase, ascii_upcase
<br>
Emit a copy of the input string with its alphabetic
characters (a-z and A-Z) converted to the specified
case.</p>

<p style="margin-top: 1em">while(cond; update) <br>
The while(cond; update) function allows you to repeatedly
apply an update to . until cond is false.</p>

<p style="margin-top: 1em">Note that while(cond; update) is
internally defined as a recursive jq function. Recursive
calls within while will not consume additional memory if
update produces at most one <br>
output for each input. See advanced topics below.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[while(.&lt;100; .*2)]&Acirc;&acute; <br>
1 <br>
=&gt; [1,2,4,8,16,32,64]</p>

<p style="margin-top: 1em">until(cond; next) <br>
The until(cond; next) function allows you to repeatedly
apply the expression next, initially to . then to its own
output, until cond is true. For example, this can be used to
<br>
implement a factorial function (see below).</p>

<p style="margin-top: 1em">Note that until(cond; next) is
internally defined as a recursive jq function. Recursive
calls within until() will not consume additional memory if
next produces at most one out&acirc; <br>
put for each input. See advanced topics below.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.,1]|until(.[0] &lt; 1; [.[0] - 1, .[1] *
.[0]])|.[1]&Acirc;&acute; <br>
4 <br>
=&gt; 24</p>

<p style="margin-top: 1em">recurse(f), recurse, recurse(f;
condition), recurse_down <br>
The recurse(f) function allows you to search through a
recursive structure, and extract interesting data from all
levels. Suppose your input represents a filesystem:</p>

<p style="margin-top: 1em">{&quot;name&quot;:
&quot;/&quot;, &quot;children&quot;: [ <br>
{&quot;name&quot;: &quot;/bin&quot;, &quot;children&quot;: [
<br>
{&quot;name&quot;: &quot;/bin/ls&quot;,
&quot;children&quot;: []}, <br>
{&quot;name&quot;: &quot;/bin/sh&quot;,
&quot;children&quot;: []}]}, <br>
{&quot;name&quot;: &quot;/home&quot;, &quot;children&quot;:
[ <br>
{&quot;name&quot;: &quot;/home/stephen&quot;,
&quot;children&quot;: [ <br>
{&quot;name&quot;: &quot;/home/stephen/jq&quot;,
&quot;children&quot;: []}]}]}]}</p>

<p style="margin-top: 1em">Now suppose you want to extract
all of the filenames present. You need to retrieve .name,
.children[].name, .children[].children[].name, and so on.
You can do this with:</p>

<p style="margin-top: 1em">recurse(.children[]) | .name</p>

<p style="margin-top: 1em">When called without an argument,
recurse is equivalent to recurse(.[]?).</p>

<p style="margin-top: 1em">recurse(f) is identical to
recurse(f; . != null) and can be used without concerns about
recursion depth.</p>

<p style="margin-top: 1em">recurse(f; condition) is a
generator which begins by emitting . and then emits in turn
.|f, .|f|f, .|f|f|f, ... so long as the computed value
satisfies the condition. For exam&acirc; <br>
ple, to generate all the integers, at least in principle,
one could write recurse(.+1; true).</p>

<p style="margin-top: 1em">For legacy reasons, recurse_down
exists as an alias to calling recurse without arguments.
This alias is considered deprecated and will be removed in
the next major release.</p>

<p style="margin-top: 1em">The recursive calls in recurse
will not consume additional memory whenever f produces at
most a single output for each input.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;recurse(.foo[])&Acirc;&acute; <br>
{&quot;foo&quot;:[{&quot;foo&quot;: []},
{&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]} <br>
=&gt;
{&quot;foo&quot;:[{&quot;foo&quot;:[]},{&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]},
{&quot;foo&quot;:[]},
{&quot;foo&quot;:[{&quot;foo&quot;:[]}]},
{&quot;foo&quot;:[]}</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;recurse&Acirc;&acute; <br>
{&quot;a&quot;:0,&quot;b&quot;:[1]} <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:[1]}, 0, [1], 1</p>

<p style="margin-top: 1em">jq &Acirc;&acute;recurse(. * .;
. &lt; 20)&Acirc;&acute; <br>
2 <br>
=&gt; 2, 4, 16</p>

<p style="margin-top: 1em">.. <br>
Short-hand for recurse without arguments. This is intended
to resemble the XPath // operator. Note that ..a does not
work; use ..|a instead. In the example below we use ..|.a?
to <br>
find all the values of object keys &quot;a&quot; in any
object found &quot;below&quot; ..</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;..|.a?&Acirc;&acute; <br>
[[{&quot;a&quot;:1}]] <br>
=&gt; 1</p>

<p style="margin-top: 1em">env <br>
Outputs an object representing jq&Acirc;&acute;s
environment.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;env.PAGER&Acirc;&acute; <br>
null <br>
=&gt; &quot;less&quot;</p>

<p style="margin-top: 1em">transpose <br>
Transpose a possibly jagged matrix (an array of arrays).
Rows are padded with nulls so the result is always
rectangular.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;transpose&Acirc;&acute; <br>
[[1], [2,3]] <br>
=&gt; [[1,2],[null,3]]</p>

<p style="margin-top: 1em">bsearch(x) <br>
bsearch(x) conducts a binary search for x in the input
array. If the input is sorted and contains x, then
bsearch(x) will return its index in the array; otherwise, if
the array <br>
is sorted, it will return (-1 - ix) where ix is an insertion
point such that the array would still be sorted after the
insertion of x at ix. If the array is not sorted, <br>
bsearch(x) will return an integer that is probably of no
interest.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;bsearch(0)&Acirc;&acute; <br>
[0,1] <br>
=&gt; 0</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;bsearch(0)&Acirc;&acute; <br>
[1,2,3] <br>
=&gt; -1</p>

<p style="margin-top: 1em">jq &Acirc;&acute;bsearch(4) as
$ix | if $ix &lt; 0 then .[-(1+$ix)] = 4 else .
end&Acirc;&acute; <br>
[1,2,3] <br>
=&gt; [1,2,3,4]</p>

<p style="margin-top: 1em">String interpolation -
&lsaquo;o) <br>
Inside a string, you can put an expression inside parens
after a backslash. Whatever the expression returns will be
interpolated into the string.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;&quot;The input
was , which is one less than 1)&quot;&Acirc;&acute; <br>
42 <br>
=&gt; &quot;The input was 42, which is one less than
43&quot;</p>

<p style="margin-top: 1em">Convert to/from JSON <br>
The tojson and fromjson builtins dump values as JSON texts
or parse JSON texts into values, respectively. The tojson
builtin differs from tostring in that tostring returns <br>
strings unmodified, while tojson encodes strings as JSON
strings.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|tostring]&Acirc;&acute; <br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt; [&quot;1&quot;,&quot;foo&quot;,&quot;[</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|tojson]&Acirc;&acute; <br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt; [&quot;1&quot;,&quot;</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|tojson|fromjson]&Acirc;&acute; <br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt; [1,&quot;foo&quot;,[&quot;foo&quot;]]</p>

<p style="margin-top: 1em">Format strings and escaping <br>
The @foo syntax is used to format and escape strings, which
is useful for building URLs, documents in a language like
HTML or XML, and so forth. @foo can be used as a filter on
<br>
its own, the possible escapings are:</p>

<p style="margin-top: 1em">@text:</p>

<p style="margin-top: 1em">Calls tostring, see that
function for details.</p>

<p style="margin-top: 1em">@json:</p>

<p style="margin-top: 1em">Serializes the input as
JSON.</p>

<p style="margin-top: 1em">@html:</p>

<p style="margin-top: 1em">Applies HTML/XML escaping, by
mapping the characters &lt;&gt;&amp;&Acirc;&acute;&quot; to
their entity equivalents &amp;lt;, &amp;gt;, &amp;amp;,
&amp;apos;, &amp;quot;.</p>

<p style="margin-top: 1em">@uri:</p>

<p style="margin-top: 1em">Applies percent-encoding, by
mapping all reserved URI characters to a %XX sequence.</p>

<p style="margin-top: 1em">@csv:</p>

<p style="margin-top: 1em">The input must be an array, and
it is rendered as CSV with double quotes for strings, and
quotes escaped by repetition.</p>

<p style="margin-top: 1em">@tsv:</p>

<p style="margin-top: 1em">The input must be an array, and
it is rendered as TSV (tab-separated values). Each input
array will be printed as a single line. Fields are separated
by a single tab <br>
(ascii 0x09). Input characters line-feed (ascii 0x0a),
carriage-return (ascii 0x0d), tab (ascii 0x09) and,
backslash (ascii 0x5c) will be output as escape sequences 0
<br>
, \ respectively.</p>

<p style="margin-top: 1em">@sh:</p>

<p style="margin-top: 1em">The input is escaped suitable
for use in a command-line for a POSIX shell. If the input is
an array, the output will be a series of space-separated
strings.</p>

<p style="margin-top: 1em">@base64:</p>

<p style="margin-top: 1em">The input is converted to base64
as specified by RFC 4648.</p>

<p style="margin-top: 1em">This syntax can be combined with
string interpolation in a useful way. You can follow a @foo
token with a string literal. The contents of the string
literal will not be escaped. <br>
However, all interpolations made inside that string literal
will be escaped. For instance,</p>

<p style="margin-top: 1em">@uri
&quot;https://www.google.com/search?q=earch)&quot;</p>

<p style="margin-top: 1em">will produce the following
output for the input {&quot;search&quot;:&quot;what is
jq?&quot;}:</p>


<p style="margin-top: 1em">&quot;https://www.google.com/search?q=what%20is%20jq%3F&quot;</p>

<p style="margin-top: 1em">Note that the slashes, question
mark, etc. in the URL are not escaped, as they were part of
the string literal.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;@html&Acirc;&acute; <br>
&quot;This works if x &lt; y&quot; <br>
=&gt; &quot;This works if x &amp;lt; y&quot;</p>

<p style="margin-top: 1em">jq &Acirc;&acute;@sh &quot;echo
&quot;&Acirc;&acute; <br>
&quot;O&Acirc;&acute;Hara&Acirc;&acute;s Ale&quot; <br>
=&gt; &quot;echo
&Acirc;&acute;O&Acirc;&acute;\&Acirc;&acute;&Acirc;&acute;Hara&Acirc;&acute;\&Acirc;&acute;&Acirc;&acute;s
Ale&Acirc;&acute;&quot;</p>

<p style="margin-top: 1em">Dates <br>
jq provides some basic date handling functionality, with
some high-level and low-level builtins. In all cases these
builtins deal exclusively with time in UTC.</p>

<p style="margin-top: 1em">The fromdateiso8601 builtin
parses datetimes in the ISO 8601 format to a number of
seconds since the Unix epoch (1970-01-01T00:00:00Z). The
todateiso8601 builtin does the <br>
inverse.</p>

<p style="margin-top: 1em">The fromdate builtin parses
datetime strings. Currently fromdate only supports ISO 8601
datetime strings, but in the future it will attempt to parse
datetime strings in more for&acirc; <br>
mats.</p>

<p style="margin-top: 1em">The todate builtin is an alias
for todateiso8601.</p>

<p style="margin-top: 1em">The now builtin outputs the
current time, in seconds since the Unix epoch.</p>

<p style="margin-top: 1em">Low-level jq interfaces to the
C-library time functions are also provided: strptime,
strftime, mktime, and gmtime. Refer to your host operating
system&Acirc;&acute;s documentation for the <br>
format strings used by strptime and strftime. Note: these
are not necessarily stable interfaces in jq, particularly as
to their localization functionality.</p>

<p style="margin-top: 1em">The gmtime builtin consumes a
number of seconds since the Unix epoch and outputs a
&quot;broken down time&quot; representation of time as an
array of numbers representing (in this order): <br>
the year, the month (zero-based), the day of the month, the
hour of the day, the minute of the hour, the second of the
minute, the day of the week, and the day of the year -- all
<br>
one-based unless otherwise stated.</p>

<p style="margin-top: 1em">The mktime builtin consumes
&quot;broken down time&quot; representations of time output
by gmtime and strptime.</p>

<p style="margin-top: 1em">The strptime(fmt) builtin parses
input strings matching the fmt argument. The output is in
the &quot;broken down time&quot; representation consumed by
gmtime and output by mktime.</p>

<p style="margin-top: 1em">The strftime(fmt) builtin
formats a time with the given format.</p>

<p style="margin-top: 1em">The format strings for strptime
and strftime are described in typical C library
documentation. The format string for ISO 8601 datetime is
&quot;%Y-%m-%dT%H:%M:%SZ&quot;.</p>

<p style="margin-top: 1em">jq may not support some or all
of this date functionality on some systems.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;fromdate&Acirc;&acute; <br>
&quot;2015-03-05T23:51:47Z&quot; <br>
=&gt; 1425599507</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;strptime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)&Acirc;&acute;
<br>
&quot;2015-03-05T23:51:47Z&quot; <br>
=&gt; [2015,2,5,23,51,47,4,63]</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;strptime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)|mktime&Acirc;&acute;
<br>
&quot;2015-03-05T23:51:47Z&quot; <br>
=&gt; 1425599507</p>

<p style="margin-top: 1em">CONDITIONALS AND COMPARISONS
<br>
==, != <br>
The expression &Acirc;&acute;a == b&Acirc;&acute; will
produce &Acirc;&acute;true&Acirc;&acute; if the result of a
and b are equal (that is, if they represent equivalent JSON
documents) and &Acirc;&acute;false&Acirc;&acute; otherwise.
In particular, <br>
strings are never considered equal to numbers. If
you&Acirc;&acute;re coming from Javascript,
jq&Acirc;&acute;s == is like Javascript&Acirc;&acute;s === -
considering values equal only when they have the same type
as <br>
well as the same value.</p>

<p style="margin-top: 1em">!= is &quot;not equal&quot;, and
&Acirc;&acute;a != b&Acirc;&acute; returns the opposite
value of &Acirc;&acute;a == b&Acirc;&acute;</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] ==
1&Acirc;&acute; <br>
[1, 1.0, &quot;1&quot;, &quot;banana&quot;] <br>
=&gt; true, true, false, false</p>

<p style="margin-top: 1em">if-then-else <br>
if A then B else C end will act the same as B if A produces
a value other than false or null, but act the same as C
otherwise.</p>

<p style="margin-top: 1em">Checking for false or null is a
simpler notion of &quot;truthiness&quot; than is found in
Javascript or Python, but it means that you&Acirc;&acute;ll
sometimes have to be more explicit about the condi&acirc;
<br>
tion you want: you can&Acirc;&acute;t test whether, e.g. a
string is empty using if .name then A else B end,
you&Acirc;&acute;ll need something more like if (.name |
length) &gt; 0 then A else B end instead.</p>

<p style="margin-top: 1em">If the condition A produces
multiple results, it is considered &quot;true&quot; if any
of those results is not false or null. If it produces zero
results, it&Acirc;&acute;s considered false.</p>

<p style="margin-top: 1em">More cases can be added to an if
using elif A then B syntax.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;if . == 0
then</p>

<p style="margin-top: 1em">&quot;zero&quot; elif . == 1
then &quot;one&quot; else &quot;many&quot; end&Acirc;&acute;
2 =&gt; &quot;many&quot;</p>

<p style="margin-top: 1em">&gt;, &gt;=, &lt;=, &lt; <br>
The comparison operators &gt;, &gt;=, &lt;=, &lt; return
whether their left argument is greater than, greater than or
equal to, less than or equal to or less than their right
argument <br>
(respectively).</p>

<p style="margin-top: 1em">The ordering is the same as that
described for sort, above.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;. &lt;
5&Acirc;&acute; <br>
2 <br>
=&gt; true</p>

<p style="margin-top: 1em">and/or/not <br>
jq supports the normal Boolean operators and/or/not. They
have the same standard of truth as if expressions - false
and null are considered &quot;false values&quot;, and
anything else is a <br>
&quot;true value&quot;.</p>

<p style="margin-top: 1em">If an operand of one of these
operators produces multiple results, the operator itself
will produce a result for each input.</p>

<p style="margin-top: 1em">not is in fact a builtin
function rather than an operator, so it is called as a
filter to which things can be piped rather than with special
syntax, as in .foo and .bar | not.</p>

<p style="margin-top: 1em">These three only produce the
values &quot;true&quot; and &quot;false&quot;, and so are
only useful for genuine Boolean operations, rather than the
common Perl/Python/Ruby idiom of <br>
&quot;value_that_may_be_null or default&quot;. If you want
to use this form of &quot;or&quot;, picking between two
values rather than evaluating a condition, see the
&quot;//&quot; operator below.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;42 and &quot;a
string&quot;&Acirc;&acute; <br>
null <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &Acirc;&acute;(true, false)
or false&Acirc;&acute; <br>
null <br>
=&gt; true, false</p>

<p style="margin-top: 1em">jq &Acirc;&acute;(true, true)
and (true, false)&Acirc;&acute; <br>
null <br>
=&gt; true, false, true, false</p>

<p style="margin-top: 1em">jq &Acirc;&acute;[true, false |
not]&Acirc;&acute; <br>
null <br>
=&gt; [false, true]</p>

<p style="margin-top: 1em">Alternative operator - // <br>
A filter of the form a // b produces the same results as a,
if a produces results other than false and null. Otherwise,
a // b produces the same results as b.</p>

<p style="margin-top: 1em">This is useful for providing
defaults: .foo // 1 will evaluate to 1 if
there&Acirc;&acute;s no .foo element in the input.
It&Acirc;&acute;s similar to how or is sometimes used in
Python (jq&Acirc;&acute;s or operator <br>
is reserved for strictly Boolean operations).</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.foo //
42&Acirc;&acute; <br>
{&quot;foo&quot;: 19} <br>
=&gt; 19</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.foo //
42&Acirc;&acute; <br>
{} <br>
=&gt; 42</p>

<p style="margin-top: 1em">try-catch <br>
Errors can be caught by using try EXP catch EXP. The first
expression is executed, and if it fails then the second is
executed with the error message. The output of the handler,
<br>
if any, is output as if it had been the output of the
expression to try.</p>

<p style="margin-top: 1em">The try EXP form uses empty as
the exception handler.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;try .a catch
&quot;. is not an object&quot;&Acirc;&acute; <br>
true <br>
=&gt; &quot;. is not an object&quot;</p>

<p style="margin-top: 1em">jq &Acirc;&acute;[.[]|try
.a]&Acirc;&acute; <br>
[{}, true, {&quot;a&quot;:1}] <br>
=&gt; [null, 1]</p>

<p style="margin-top: 1em">jq &Acirc;&acute;try
error(&quot;some exception&quot;) catch .&Acirc;&acute; <br>
true <br>
=&gt; &quot;some exception&quot;</p>

<p style="margin-top: 1em">Breaking out of control
structures <br>
A convenient use of try/catch is to break out of control
structures like reduce, foreach, while, and so on.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em"># Repeat an expression until it
raises &quot;break&quot; as an <br>
# error, then stop repeating without re-raising the error.
<br>
# But if the error caught is not &quot;break&quot; then
re-raise it. <br>
try repeat(exp) catch .==&quot;break&quot; then empty else
error;</p>

<p style="margin-top: 1em">jq has a syntax for named
lexical labels to &quot;break&quot; or &quot;go (back)
to&quot;:</p>

<p style="margin-top: 1em">label $out | ... break $out
...</p>

<p style="margin-top: 1em">The break $label_name expression
will cause the program to to act as though the nearest (to
the left) label $label_name produced empty.</p>

<p style="margin-top: 1em">The relationship between the
break and corresponding label is lexical: the label has to
be &quot;visible&quot; from the break.</p>

<p style="margin-top: 1em">To break out of a reduce, for
example:</p>

<p style="margin-top: 1em">label $out | reduce .[] as $item
(null; if .==false then break $out else ... end)</p>

<p style="margin-top: 1em">The following jq program
produces a syntax error:</p>

<p style="margin-top: 1em">break $out</p>

<p style="margin-top: 1em">because no label $out is
visible.</p>

<p style="margin-top: 1em">? operator <br>
The ? operator, used as EXP?, is shorthand for try EXP.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[.[]|(.a)?]&Acirc;&acute; <br>
[{}, true, {&quot;a&quot;:1}] <br>
=&gt; [null, 1]</p>

<p style="margin-top: 1em">REGULAR EXPRESSIONS (PCRE) <br>
jq uses the Oniguruma regular expression library, as do php,
ruby, TextMate, Sublime Text, etc, so the description here
will focus on jq specifics.</p>

<p style="margin-top: 1em">The jq regex filters are defined
so that they can be used using one of these patterns:</p>

<p style="margin-top: 1em">STRING | FILTER( REGEX ) <br>
STRING | FILTER( REGEX; FLAGS ) <br>
STRING | FILTER( [REGEX] ) <br>
STRING | FILTER( [REGEX, FLAGS] )</p>

<p style="margin-top: 1em">where: * STRING, REGEX and FLAGS
are jq strings and subject to jq string interpolation; *
REGEX, after string interpolation, should be a valid PCRE
regex; * FILTER is one of <br>
test, match, or capture, as described below.</p>

<p style="margin-top: 1em">FLAGS is a string consisting of
one of more of the supported flags:</p>

<p style="margin-top: 1em">&Acirc;&middot; g - Global
search (find all matches, not just the first)</p>

<p style="margin-top: 1em">&Acirc;&middot; i - Case
insensitive search</p>

<p style="margin-top: 1em">&Acirc;&middot; m - Multi line
mode (&Acirc;&acute;.&Acirc;&acute; will match newlines)</p>

<p style="margin-top: 1em">&Acirc;&middot; n - Ignore empty
matches</p>

<p style="margin-top: 1em">&Acirc;&middot; p - Both s and m
modes are enabled</p>

<p style="margin-top: 1em">&Acirc;&middot; s - Single line
mode (&Acirc;&acute;^&Acirc;&acute; -&gt;
&Acirc;&acute;0&acute;$&Acirc;&acute; -&gt;
&Acirc;&acute;&acute;)</p>

<p style="margin-top: 1em">&Acirc;&middot; l - Find longest
possible matches</p>

<p style="margin-top: 1em">&Acirc;&middot; x - Extended
regex format (ignore whitespace and comments)</p>

<p style="margin-top: 1em">To match whitespace in an x
pattern use an escape such as .g.</p>

<p style="margin-top: 1em">&Acirc;&middot; test( &quot;a,
&quot;x&quot; ).</p>

<p style="margin-top: 1em">Note that certain flags may also
be specified within REGEX, e.g.</p>

<p style="margin-top: 1em">&Acirc;&middot; jq -n
&Acirc;&acute;(&quot;test&quot;, &quot;TEst&quot;,
&quot;teST&quot;, &quot;TEST&quot;) | test(
&quot;(?i)te(?-i)st&quot; )&Acirc;&acute;</p>

<p style="margin-top: 1em">evaluates to: true, true, false,
false.</p>

<p style="margin-top: 1em">[Requires 1.5] test(val),
test(regex; flags) <br>
Like match, but does not return match objects, only true or
false for whether or not the regex matches the input.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;test(&quot;foo&quot;)&Acirc;&acute; <br>
&quot;foo&quot; <br>
=&gt; true</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] |
test(&quot;a b c # spaces are ignored&quot;;
&quot;ix&quot;)&Acirc;&acute; <br>
[&quot;xabcd&quot;, &quot;ABC&quot;] <br>
=&gt; true, true</p>

<p style="margin-top: 1em">[Requires 1.5] match(val),
match(regex; flags) <br>
match outputs an object for each match it finds. Matches
have the following fields:</p>

<p style="margin-top: 1em">&Acirc;&middot; offset - offset
in UTF-8 codepoints from the beginning of the input</p>

<p style="margin-top: 1em">&Acirc;&middot; length - length
in UTF-8 codepoints of the match</p>

<p style="margin-top: 1em">&Acirc;&middot; string - the
string that it matched</p>

<p style="margin-top: 1em">&Acirc;&middot; captures - an
array of objects representing capturing groups.</p>

<p style="margin-top: 1em">Capturing group objects have the
following fields:</p>

<p style="margin-top: 1em">&Acirc;&middot; offset - offset
in UTF-8 codepoints from the beginning of the input</p>

<p style="margin-top: 1em">&Acirc;&middot; length - length
in UTF-8 codepoints of this capturing group</p>

<p style="margin-top: 1em">&Acirc;&middot; string - the
string that was captured</p>

<p style="margin-top: 1em">&Acirc;&middot; name - the name
of the capturing group (or null if it was unnamed)</p>

<p style="margin-top: 1em">Capturing groups that did not
match anything return an offset of -1</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;match(&quot;(abc)+&quot;;
&quot;g&quot;)&Acirc;&acute; <br>
&quot;abc abc&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;captures&quot;:
[{&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;name&quot;:
null}]}, {&quot;offset&quot;: 4, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;captures&quot;:
[{&quot;offset&quot;: 4, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;name&quot;:
null}]}</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;match(&quot;foo&quot;)&Acirc;&acute; <br>
&quot;foo bar foo&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;foo&quot;, &quot;captures&quot;:
[]}</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;match([&quot;foo&quot;,
&quot;ig&quot;])&Acirc;&acute; <br>
&quot;foo bar FOO&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;foo&quot;, &quot;captures&quot;:
[]}, {&quot;offset&quot;: 8, &quot;length&quot;: 3,
&quot;string&quot;: &quot;FOO&quot;, &quot;captures&quot;:
[]}</p>

<p style="margin-top: 1em">jq &Acirc;&acute;match(&quot;foo
(?&lt;bar123&gt;bar)? foo&quot;;
&quot;ig&quot;)&Acirc;&acute; <br>
&quot;foo bar foo foo foo&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 11,
&quot;string&quot;: &quot;foo bar foo&quot;,
&quot;captures&quot;: [{&quot;offset&quot;: 4,
&quot;length&quot;: 3, &quot;string&quot;: &quot;bar&quot;,
&quot;name&quot;: &quot;bar123&quot;}]},
{&quot;offset&quot;: 12, &quot;length&quot;: 8,
&quot;string&quot;: &quot;foo foo&quot;,
&quot;captures&quot;: [{&quot;offset&quot;: -1,
&quot;length&quot;: 0, &quot;string&quot;: null,
&quot;name&quot;: &quot;bar123&quot;}]}</p>

<p style="margin-top: 1em">jq &Acirc;&acute;[
match(&quot;.&quot;; &quot;g&quot;)] | length&Acirc;&acute;
<br>
&quot;abc&quot; <br>
=&gt; 3</p>

<p style="margin-top: 1em">[Requires 1.5] capture(val),
capture(regex; flags) <br>
Collects the named captures in a JSON object, with the name
of each capture as the key, and the matched string as the
corresponding value.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;capture(&quot;(?&lt;a&gt;[a-z]+)-(?&lt;n&gt;[0-9]+)&quot;)&Acirc;&acute;
<br>
&quot;xyzzy-14&quot; <br>
=&gt; { &quot;a&quot;: &quot;xyzzy&quot;, &quot;n&quot;:
&quot;14&quot; }</p>

<p style="margin-top: 1em">[Requires 1.5] scan(regex),
scan(regex; flags) <br>
Emit a stream of the non-overlapping substrings of the input
that match the regex in accordance with the flags, if any
have been specified. If there is no match, the stream is
<br>
empty. To capture all the matches for each input string, use
the idiom [ expr ], e.g. [ scan(regex) ].</p>

<p style="margin-top: 1em">split(regex; flags) <br>
For backwards compatibility, split splits on a string, not a
regex.</p>

<p style="margin-top: 1em">[Requires 1.5] splits(regex),
splits(regex; flags) <br>
These provide the same results as their split counterparts,
but as a stream instead of an array.</p>

<p style="margin-top: 1em">[Requires 1.5] sub(regex;
tostring) sub(regex; string; flags) <br>
Emit the string obtained by replacing the first match of
regex in the input string with tostring, after
interpolation. tostring should be a jq string, and may
contain references <br>
to named captures. The named captures are, in effect,
presented as a JSON object (as constructed by capture) to
tostring, so a reference to a captured variable named
&quot;x&quot; would <br>
take the form: &quot;(.x)&quot;.</p>

<p style="margin-top: 1em">[Requires 1.5] gsub(regex;
string), gsub(regex; string; flags) <br>
gsub is like sub but all the non-overlapping occurrences of
the regex are replaced by the string, after
interpolation.</p>

<p style="margin-top: 1em">ADVANCED FEATURES <br>
Variables are an absolute necessity in most programming
languages, but they&Acirc;&acute;re relegated to an
&quot;advanced feature&quot; in jq.</p>

<p style="margin-top: 1em">In most languages, variables are
the only means of passing around data. If you calculate a
value, and you want to use it more than once,
you&Acirc;&acute;ll need to store it in a variable. To <br>
pass a value to another part of the program,
you&Acirc;&acute;ll need that part of the program to define
a variable (as a function parameter, object member, or
whatever) in which to place the <br>
data.</p>

<p style="margin-top: 1em">It is also possible to define
functions in jq, although this is is a feature whose biggest
use is defining jq&Acirc;&acute;s standard library (many jq
functions such as map and find are in <br>
fact written in jq).</p>

<p style="margin-top: 1em">jq has reduction operators,
which are very powerful but a bit tricky. Again, these are
mostly used internally, to define some useful bits of
jq&Acirc;&acute;s standard library.</p>

<p style="margin-top: 1em">It may not be obvious at first,
but jq is all about generators (yes, as often found in other
languages). Some utilities are provided to help deal with
generators.</p>

<p style="margin-top: 1em">Some minimal I/O support
(besides reading JSON from standard input, and writing JSON
to standard output) is available.</p>

<p style="margin-top: 1em">Finally, there is a
module/library system.</p>

<p style="margin-top: 1em">Variables <br>
In jq, all filters have an input and an output, so manual
plumbing is not necessary to pass a value from one part of a
program to the next. Many expressions, for instance a + b,
<br>
pass their input to two distinct subexpressions (here a and
b are both passed the same input), so variables
aren&Acirc;&acute;t usually necessary in order to use a
value twice.</p>

<p style="margin-top: 1em">For instance, calculating the
average value of an array of numbers requires a few
variables in most languages - at least one to hold the
array, perhaps one for each element or <br>
for a loop counter. In jq, it&Acirc;&acute;s simply add /
length - the add expression is given the array and produces
its sum, and the length expression is given the array and
produces its <br>
length.</p>

<p style="margin-top: 1em">So, there&Acirc;&acute;s
generally a cleaner way to solve most problems in jq than
defining variables. Still, sometimes they do make things
easier, so jq lets you define variables using <br>
expression as $variable. All variable names start with $.
Here&Acirc;&acute;s a slightly uglier version of the
array-averaging example:</p>

<p style="margin-top: 1em">length as $array_length | add /
$array_length</p>

<p style="margin-top: 1em">We&Acirc;&acute;ll need a more
complicated problem to find a situation where using
variables actually makes our lives easier.</p>

<p style="margin-top: 1em">Suppose we have an array of blog
posts, with &quot;author&quot; and &quot;title&quot; fields,
and another object which is used to map author usernames to
real names. Our input looks like:</p>

<p style="margin-top: 1em">{&quot;posts&quot;:
[{&quot;title&quot;: &quot;Frist psot&quot;,
&quot;author&quot;: &quot;anon&quot;}, <br>
{&quot;title&quot;: &quot;A well-written article&quot;,
&quot;author&quot;: &quot;person1&quot;}], <br>
&quot;realnames&quot;: {&quot;anon&quot;: &quot;Anonymous
Coward&quot;, <br>
&quot;person1&quot;: &quot;Person McPherson&quot;}}</p>

<p style="margin-top: 1em">We want to produce the posts
with the author field containing a real name, as in:</p>

<p style="margin-top: 1em">{&quot;title&quot;: &quot;Frist
psot&quot;, &quot;author&quot;: &quot;Anonymous
Coward&quot;} <br>
{&quot;title&quot;: &quot;A well-written article&quot;,
&quot;author&quot;: &quot;Person McPherson&quot;}</p>

<p style="margin-top: 1em">We use a variable, $names, to
store the realnames object, so that we can refer to it later
when looking up author usernames:</p>

<p style="margin-top: 1em">.realnames as $names | .posts[]
| {title, author: $names[.author]}</p>

<p style="margin-top: 1em">The expression exp as $x | ...
means: for each value of expression exp, run the rest of the
pipeline with the entire original input, and with $x set to
that value. Thus as func&acirc; <br>
tions as something of a foreach loop.</p>

<p style="margin-top: 1em">Just as {foo} is a handy way of
writing {foo: .foo}, so {$foo} is a handy way of writing
{foo:$foo}.</p>

<p style="margin-top: 1em">Multiple variables may be
declared using a single as expression by providing a pattern
that matches the structure of the input (this is known as
&quot;destructuring&quot;):</p>

<p style="margin-top: 1em">. as {realnames: $names, posts:
[$first, $second]} | ...</p>

<p style="margin-top: 1em">The variable declarations in
array patterns (e.g., . as [$first, $second]) bind to the
elements of the array in from the element at index zero on
up, in order. When there is no <br>
value at the index for an array pattern element, null is
bound to that variable.</p>

<p style="margin-top: 1em">Variables are scoped over the
rest of the expression that defines them, so</p>

<p style="margin-top: 1em">.realnames as $names | (.posts[]
| {title, author: $names[.author]})</p>

<p style="margin-top: 1em">will work, but</p>

<p style="margin-top: 1em">(.realnames as $names |
.posts[]) | {title, author: $names[.author]}</p>

<p style="margin-top: 1em">won&Acirc;&acute;t.</p>

<p style="margin-top: 1em">For programming language
theorists, it&Acirc;&acute;s more accurate to say that jq
variables are lexically-scoped bindings. In particular
there&Acirc;&acute;s no way to change the value of a
binding; one <br>
can only setup a new binding with the same name, but which
will not be visible where the old one was.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.bar as $x |
.foo | . + $x&Acirc;&acute; <br>
{&quot;foo&quot;:10, &quot;bar&quot;:200} <br>
=&gt; 210</p>

<p style="margin-top: 1em">jq &Acirc;&acute;. as $i|[(.*2|.
as $i| $i), $i]&Acirc;&acute; <br>
5 <br>
=&gt; [10,5]</p>

<p style="margin-top: 1em">jq &Acirc;&acute;. as [$a, $b,
{c: $c}] | $a + $b + $c&Acirc;&acute; <br>
[2, 3, {&quot;c&quot;: 4, &quot;d&quot;: 5}] <br>
=&gt; 9</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.[] as [$a, $b]
| {a: $a, b: $b}&Acirc;&acute; <br>
[[0], [0, 1], [2, 1, 0]] <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:null},
{&quot;a&quot;:0,&quot;b&quot;:1},
{&quot;a&quot;:2,&quot;b&quot;:1}</p>

<p style="margin-top: 1em">Defining Functions <br>
You can give a filter a name using &quot;def&quot;
syntax:</p>

<p style="margin-top: 1em">def increment: . + 1;</p>

<p style="margin-top: 1em">From then on, increment is
usable as a filter just like a builtin function (in fact,
this is how some of the builtins are defined). A function
may take arguments:</p>

<p style="margin-top: 1em">def map(f): [.[] | f];</p>

<p style="margin-top: 1em">Arguments are passed as filters,
not as values. The same argument may be referenced multiple
times with different inputs (here f is run for each element
of the input array). <br>
Arguments to a function work more like callbacks than like
value arguments. This is important to understand.
Consider:</p>

<p style="margin-top: 1em">def foo(f): f|f; <br>
5|foo(.*2)</p>

<p style="margin-top: 1em">The result will be 20 because f
is .*2, and during the first invocation of f . will be 5,
and the second time it will be 10 (5 * 2), so the result
will be 20. Function arguments <br>
are filters, and filters expect an input when invoked.</p>

<p style="margin-top: 1em">If you want the value-argument
behaviour for defining simple functions, you can just use a
variable:</p>

<p style="margin-top: 1em">def addvalue(f): f as $f | map(.
+ $f);</p>

<p style="margin-top: 1em">Or use the short-hand:</p>

<p style="margin-top: 1em">def addvalue($f): ...;</p>

<p style="margin-top: 1em">With either definition,
addvalue(.foo) will add the current input&Acirc;&acute;s
.foo field to each element of the array.</p>

<p style="margin-top: 1em">Multiple definitions using the
same function name are allowed. Each re-definition replaces
the previous one for the same number of function arguments,
but only for references <br>
from functions (or main program) subsequent to the
re-definition.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;def
addvalue(f): . + [f]; map(addvalue(.[0]))&Acirc;&acute; <br>
[[1,2],[10,20]] <br>
=&gt; [[1,2,1], [10,20,10]]</p>

<p style="margin-top: 1em">jq &Acirc;&acute;def
addvalue(f): f as $x | map(. + $x);
addvalue(.[0])&Acirc;&acute; <br>
[[1,2],[10,20]] <br>
=&gt; [[1,2,1,2], [10,20,1,2]]</p>

<p style="margin-top: 1em">Reduce <br>
The reduce syntax in jq allows you to combine all of the
results of an expression by accumulating them into a single
answer. As an example, we&Acirc;&acute;ll pass [3,2,1] to
this expression:</p>

<p style="margin-top: 1em">reduce .[] as $item (0; . +
$item)</p>

<p style="margin-top: 1em">For each result that .[]
produces, . + $item is run to accumulate a running total,
starting from 0. In this example, .[] produces the results
3, 2, and 1, so the effect is simi&acirc; <br>
lar to running something like this:</p>

<p style="margin-top: 1em">0 | (3 as $item | . + $item) |
<br>
(2 as $item | . + $item) | <br>
(1 as $item | . + $item)</p>

<p style="margin-top: 1em">jq &Acirc;&acute;reduce .[] as
$item (0; . + $item)&Acirc;&acute; <br>
[10,2,5,3] <br>
=&gt; 20</p>

<p style="margin-top: 1em">limit(n; exp) <br>
The limit function extracts up to n outputs from exp.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[limit(3;.[])]&Acirc;&acute; <br>
[0,1,2,3,4,5,6,7,8,9] <br>
=&gt; [0,1,2]</p>

<p style="margin-top: 1em">first(expr), last(expr), nth(n;
expr) <br>
The first(expr) and last(expr) functions extract the first
and last values from expr, respectively.</p>

<p style="margin-top: 1em">The nth(n; expr) function
extracts the nth value output by expr. This can be defined
as def nth(n; expr): last(limit(n + 1; expr));. Note that
nth(n; expr) doesn&Acirc;&acute;t support nega&acirc; <br>
tive values of n.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[first(range(.)), last(range(.)), nth(./2;
range(.))]&Acirc;&acute; <br>
10 <br>
=&gt; [0,9,5]</p>

<p style="margin-top: 1em">first, last, nth(n) <br>
The first and last functions extract the first and last
values from any array at ..</p>

<p style="margin-top: 1em">The nth(n) function extracts the
nth value of any array at ..</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[range(.)]|[first, last, nth(5)]&Acirc;&acute;
<br>
10 <br>
=&gt; [0,9,5]</p>

<p style="margin-top: 1em">foreach <br>
The foreach syntax is similar to reduce, but intended to
allow the construction of limit and reducers that produce
intermediate results (see example).</p>

<p style="margin-top: 1em">The form is foreach EXP as $var
(INIT; UPDATE; EXTRACT). Like reduce, INIT is evaluated once
to produce a state value, then each output of EXP is bound
to $var, UPDATE is evalu&acirc; <br>
ated for each output of EXP with the current state and with
$var visible. Each value output by UPDATE replaces the
previous state. Finally, EXTRACT is evaluated for each new
<br>
state to extract an output of foreach.</p>

<p style="margin-top: 1em">This is mostly useful only for
constructing reduce- and limit-like functions. But it is
much more general, as it allows for partial reductions (see
the example below).</p>

<p style="margin-top: 1em">jq &Acirc;&acute;[foreach .[] as
$item ([[],[]]; if $item == null then [[],.[0]] else [(.[0]
+ [$item]),[]] end; if $item == null then .[1] else empty
end)]&Acirc;&acute; <br>
[1,2,3,4,null,&quot;a&quot;,&quot;b&quot;,null] <br>
=&gt; [[1,2,3,4],[&quot;a&quot;,&quot;b&quot;]]</p>

<p style="margin-top: 1em">Recursion <br>
As described above, recurse uses recursion, and any jq
function can be recursive. The while builtin is also
implemented in terms of recursion.</p>

<p style="margin-top: 1em">Tail calls are optimized
whenever the expression to the left of the recursive call
outputs its last value. In practice this means that the
expression to the left of the recursive <br>
call should not produce more than one output for each
input.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">def recurse(f): def r: ., (f |
select(. != null) | r); r;</p>

<p style="margin-top: 1em">def while(cond; update): <br>
def _while: <br>
if cond then ., (update | _while) else empty end; <br>
_while;</p>

<p style="margin-top: 1em">def repeat(exp): <br>
def _repeat: <br>
exp, _repeat; <br>
_repeat;</p>

<p style="margin-top: 1em">Generators and iterators <br>
Some jq operators and functions are actually generators in
that they can produce zero, one, or more values for each
input, just as one might expect in other programming
languages <br>
that have generators. For example, .[] generates all the
values in its input (which must be an array or an object),
range(0; 10) generates the integers between 0 and 10, and so
<br>
on.</p>

<p style="margin-top: 1em">Even the comma operator is a
generator, generating first the values generated by the
expression to the left of the comma, then for each of those,
the values generate by the <br>
expression on the right of the comma.</p>

<p style="margin-top: 1em">The empty builtin is the
generator that produces zero outputs. The empty builtin
backtracks to the preceding generator expression.</p>

<p style="margin-top: 1em">All jq functions can be
generators just by using builtin generators. It is also
possible to define new generators using only recursion and
the comma operator. If the recursive <br>
call(s) is(are) &quot;in tail position&quot; then the
generator will be efficient. In the example below the
recursive call by _range to itself is in tail position. The
example shows off <br>
three advanced topics: tail recursion, generator
construction, and sub-functions.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;def range(init;
upto; by): def _range: if (by &gt; 0 and . &lt; upto) or (by
&lt; 0 and . &gt; upto) then ., ((.+by)|_range) else . end;
if by == 0 then init else init|_range end | select((by &gt;
0 and . &lt; upto) or (by &lt; 0 and . &gt; upto)); range(0;
10; 3)&Acirc;&acute; <br>
null <br>
=&gt; 0, 3, 6, 9</p>

<p style="margin-top: 1em">jq &Acirc;&acute;def while(cond;
update): def _while: if cond then ., (update | _while) else
empty end; _while; [while(.&lt;100; .*2)]&Acirc;&acute; <br>
1 <br>
=&gt; [1,2,4,8,16,32,64]</p>

<p style="margin-top: 1em">MATH <br>
jq currently only has IEEE754 double-precision (64-bit)
floating point number support.</p>

<p style="margin-top: 1em">Besides simple arithmetic
operators such as +, jq also has most standard math
functions from the C math library. C math functions that
take a single input argument (e.g., sin()) <br>
are available as zero-argument jq functions. C math
functions that take two input arguments (e.g., pow()) are
available as two-argument jq functions that ignore ..</p>

<p style="margin-top: 1em">Availability of standard math
functions depends on the availability of the corresponding
math functions in your operating system and C math library.
Unavailable math functions <br>
will be defined but will raise an error.</p>

<p style="margin-top: 1em">I/O <br>
At this time jq has minimal support for I/O, mostly in the
form of control over when inputs are read. Two builtins
functions are provided for this, input and inputs, that read
<br>
from the same sources (e.g., stdin, files named on the
command-line) as jq itself. These two builtins, and
jq&Acirc;&acute;s own reading actions, can be interleaved
with each other.</p>

<p style="margin-top: 1em">One builtin provides minimal
output capabilities, debug. (Recall that a jq
program&Acirc;&acute;s output values are always output as
JSON texts on stdout.) The debug builtin can have
applica&acirc; <br>
tion-specific behavior, such as for executables that use the
libjq C API but aren&Acirc;&acute;t the jq executable
itself.</p>

<p style="margin-top: 1em">input <br>
Outputs one new input.</p>

<p style="margin-top: 1em">inputs <br>
Outputs all remaining inputs, one by one.</p>

<p style="margin-top: 1em">This is primarily useful for
reductions over a program&Acirc;&acute;s inputs.</p>

<p style="margin-top: 1em">debug <br>
Causes a debug message based on the input value to be
produced. The jq executable wraps the input value with
[&quot;DEBUG:&quot;, &lt;input-value&gt;] and prints that
and a newline on stderr, <br>
compactly. This may change in the future.</p>

<p style="margin-top: 1em">input_filename <br>
Returns the name of the file whose input is currently being
filtered. Note that this will not work well unless jq is
running in a UTF-8 locale.</p>

<p style="margin-top: 1em">input_line_number <br>
Returns the line number of the input currently being
filtered.</p>

<p style="margin-top: 1em">STREAMING <br>
With the --stream option jq can parse input texts in a
streaming fashion, allowing jq programs to start processing
large JSON texts immediately rather than after the parse
com&acirc; <br>
pletes. If you have a single JSON text that is 1GB in size,
streaming it will allow you to process it much more
quickly.</p>

<p style="margin-top: 1em">However, streaming
isn&Acirc;&acute;t easy to deal with as the jq program will
have [&lt;path&gt;, &lt;leaf-value&gt;] (and a few other
forms) as inputs.</p>

<p style="margin-top: 1em">Several builtins are provided to
make handling streams easier.</p>

<p style="margin-top: 1em">The examples below use the the
streamed form of [0,[1]], which is
[[0],0],[[1,0],1],[[1,0]],[[1]].</p>

<p style="margin-top: 1em">Streaming forms include
[&lt;path&gt;, &lt;leaf-value&gt;] (to indicate any scalar
value, empty array, or empty object), and [&lt;path&gt;] (to
indicate the end of an array or object). Future ver&acirc;
<br>
sions of jq run with --stream and -seq may output additional
forms such as [&quot;error message&quot;] when an input text
fails to parse.</p>


<p style="margin-top: 1em">truncate_stream(stream_expression)
<br>
Consumes a number as input and truncates the corresponding
number of path elements from the left of the outputs of the
given streaming expression.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;[1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]])]&Acirc;&acute;
<br>
1 <br>
=&gt; [[[0],2],[[0]]]</p>

<p style="margin-top: 1em">fromstream(stream_expression)
<br>
Outputs values corresponding to the stream
expression&Acirc;&acute;s outputs.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;fromstream(1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]]))&Acirc;&acute;
<br>
null <br>
=&gt; [2]</p>

<p style="margin-top: 1em">tostream <br>
The tostream builtin outputs the streamed form of its
input.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;. as
$dot|fromstream($dot|tostream)|.==$dot&Acirc;&acute; <br>
[0,[1,{&quot;a&quot;:1},{&quot;b&quot;:2}]] <br>
=&gt; true</p>

<p style="margin-top: 1em">ASSIGNMENT <br>
Assignment works a little differently in jq than in most
programming languages. jq doesn&Acirc;&acute;t distinguish
between references to and copies of something - two objects
or arrays are <br>
either equal or not equal, without any further notion of
being &quot;the same object&quot; or &quot;not the same
object&quot;.</p>

<p style="margin-top: 1em">If an object has two fields
which are arrays, .foo and .bar, and you append something to
.foo, then .bar will not get bigger. Even if
you&Acirc;&acute;ve just set .bar = .foo. If
you&Acirc;&acute;re used <br>
to programming in languages like Python, Java, Ruby,
Javascript, etc. then you can think of it as though jq does
a full deep copy of every object before it does the
assignment <br>
(for performance, it doesn&Acirc;&acute;t actually do that,
but that&Acirc;&acute;s the general idea).</p>

<p style="margin-top: 1em">All the assignment operators in
jq have path expressions on the left-hand side.</p>

<p style="margin-top: 1em">= <br>
The filter .foo = 1 will take as input an object and produce
as output an object with the &quot;foo&quot; field set to 1.
There is no notion of &quot;modifying&quot; or
&quot;changing&quot; something in jq - <br>
all jq values are immutable. For instance,</p>

<p style="margin-top: 1em">.foo = .bar | .foo.baz = 1</p>

<p style="margin-top: 1em">will not have the side-effect of
setting .bar.baz to be set to 1, as the similar-looking
program in Javascript, Python, Ruby or other languages
would. Unlike these languages (but <br>
like Haskell and some other functional languages), there is
no notion of two arrays or objects being &quot;the same
array&quot; or &quot;the same object&quot;. They can be
equal, or not equal, but <br>
if we change one of them in no circumstances will the other
change behind our backs.</p>

<p style="margin-top: 1em">This means that
it&Acirc;&acute;s impossible to build circular values in jq
(such as an array whose first element is itself). This is
quite intentional, and ensures that anything a jq program
<br>
can produce can be represented in JSON.</p>

<p style="margin-top: 1em">Note that the left-hand side of
&Acirc;&acute;=&Acirc;&acute; refers to a value in .. Thus
$var.foo = 1 won&Acirc;&acute;t work as expected ($var.foo
is not a valid or useful path expression in .); use $var |
.foo = 1 <br>
instead.</p>

<p style="margin-top: 1em">If the right-hand side of
&Acirc;&acute;=&Acirc;&acute; produces multiple values, then
for each such value jq will set the paths on the left-hand
side to the value and then it will output the modified ..
<br>
For example, (.a,.b)=range(2) outputs
{&quot;a&quot;:0,&quot;b&quot;:0}, then
{&quot;a&quot;:1,&quot;b&quot;:1}. The &quot;update&quot;
assignment forms (see below) do not do this.</p>

<p style="margin-top: 1em">Note too that .a,.b=0 does not
set .a and .b, but (.a,.b)=0 sets both.</p>

<p style="margin-top: 1em">|= <br>
As well as the assignment operator
&Acirc;&acute;=&Acirc;&acute;, jq provides the
&quot;update&quot; operator &Acirc;&acute;|=&Acirc;&acute;,
which takes a filter on the right-hand side and works out
the new value for the property of . <br>
being assigned to by running the old value through this
expression. For instance, .foo |= .+1 will build an object
with the &quot;foo&quot; field set to the
input&Acirc;&acute;s &quot;foo&quot; plus 1.</p>

<p style="margin-top: 1em">This example should show the
difference between &Acirc;&acute;=&Acirc;&acute; and
&Acirc;&acute;|=&Acirc;&acute;:</p>

<p style="margin-top: 1em">Provide input
&Acirc;&acute;{&quot;a&quot;: {&quot;b&quot;: 10},
&quot;b&quot;: 20}&Acirc;&acute; to the programs:</p>

<p style="margin-top: 1em">.a = .b .a |= .b</p>

<p style="margin-top: 1em">The former will set the
&quot;a&quot; field of the input to the &quot;b&quot; field
of the input, and produce the output {&quot;a&quot;: 20}.
The latter will set the &quot;a&quot; field of the input to
the &quot;a&quot; field&Acirc;&acute;s <br>
&quot;b&quot; field, producing {&quot;a&quot;: 10}.</p>

<p style="margin-top: 1em">The left-hand side can be any
general path expression; see path().</p>

<p style="margin-top: 1em">Note that the left-hand side of
&Acirc;&acute;|=&Acirc;&acute; refers to a value in .. Thus
$var.foo |= . + 1 won&Acirc;&acute;t work as expected
($var.foo is not a valid or useful path expression in .);
use $var | <br>
.foo |= . + 1 instead.</p>

<p style="margin-top: 1em">If the right-hand side outputs
multiple values, only the last one will be used.</p>

<p style="margin-top: 1em">jq
&Acirc;&acute;(..|select(type==&quot;boolean&quot;)) |= if .
then 1 else 0 end&Acirc;&acute; <br>
[true,false,[5,true,[true,[false]],false]] <br>
=&gt; [1,0,[5,1,[1,[0]],0]]</p>

<p style="margin-top: 1em">+=, -=, *=, /=, %=, //= <br>
jq has a few operators of the form a op= b, which are all
equivalent to a |= . op b. So, += 1 can be used to increment
values.</p>

<p style="margin-top: 1em">jq &Acirc;&acute;.foo +=
1&Acirc;&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; {&quot;foo&quot;: 43}</p>

<p style="margin-top: 1em">Complex assignments <br>
Lots more things are allowed on the left-hand side of a jq
assignment than in most languages. We&Acirc;&acute;ve
already seen simple field accesses on the left hand side,
and it&Acirc;&acute;s no surprise <br>
that array accesses work just as well:</p>

<p style="margin-top: 1em">.posts[0].title = &quot;JQ
Manual&quot;</p>

<p style="margin-top: 1em">What may come as a surprise is
that the expression on the left may produce multiple
results, referring to different points in the input
document:</p>

<p style="margin-top: 1em">.posts[].comments |= . +
[&quot;this is great&quot;]</p>

<p style="margin-top: 1em">That example appends the string
&quot;this is great&quot; to the &quot;comments&quot; array
of each post in the input (where the input is an object with
a field &quot;posts&quot; which is an array of posts).</p>

<p style="margin-top: 1em">When jq encounters an assignment
like &Acirc;&acute;a = b&Acirc;&acute;, it records the
&quot;path&quot; taken to select a part of the input
document while executing a. This path is then used to find
which part of <br>
the input to change while executing the assignment. Any
filter may be used on the left-hand side of an equals -
whichever paths it selects from the input will be where the
<br>
assignment is performed.</p>

<p style="margin-top: 1em">This is a very powerful
operation. Suppose we wanted to add a comment to blog posts,
using the same &quot;blog&quot; input above. This time, we
only want to comment on the posts written by <br>
&quot;stedolan&quot;. We can find those posts using the
&quot;select&quot; function described earlier:</p>

<p style="margin-top: 1em">.posts[] | select(.author ==
&quot;stedolan&quot;)</p>

<p style="margin-top: 1em">The paths provided by this
operation point to each of the posts that
&quot;stedolan&quot; wrote, and we can comment on each of
them in the same way that we did before:</p>

<p style="margin-top: 1em">(.posts[] | select(.author ==
&quot;stedolan&quot;) | .comments) |= <br>
. + [&quot;terrible.&quot;]</p>

<p style="margin-top: 1em">MODULES <br>
jq has a library/module system. Modules are files whose
names end in .jq.</p>

<p style="margin-top: 1em">Modules imported by a program
are searched for in a default search path (see below). The
import and include directives allow the importer to alter
this path.</p>

<p style="margin-top: 1em">Paths in the a search path are
subject to various substitutions.</p>

<p style="margin-top: 1em">For paths starting with
&quot;~/&quot;, the user&Acirc;&acute;s home directory is
substituted for &quot;~&quot;.</p>

<p style="margin-top: 1em">For paths starting with
&quot;$ORIGIN/&quot;, the path of the jq executable is
substituted for &quot;$ORIGIN&quot;.</p>

<p style="margin-top: 1em">For paths starting with
&quot;./&quot; or paths that are &quot;.&quot;, the path of
the including file is substituted for &quot;.&quot;. For
top-level programs given on the command-line, the current
directory <br>
is used.</p>

<p style="margin-top: 1em">Import directives can optionally
specify a search path to which the default is appended.</p>

<p style="margin-top: 1em">The default search path is the
search path given to the -L command-line option, else
[&quot;~/.jq&quot;, &quot;$ORIGIN/../lib/jq&quot;,
&quot;$ORIGIN/../lib&quot;].</p>

<p style="margin-top: 1em">Null and empty string path
elements terminate search path processing.</p>

<p style="margin-top: 1em">A dependency with relative path
&quot;foo/bar&quot; would be searched for in
&quot;foo/bar.jq&quot; and &quot;foo/bar/bar.jq&quot; in the
given search path. This is intended to allow modules to be
placed in a <br>
directory along with, for example, version control files,
README files, and so on, but also to allow for single-file
modules.</p>

<p style="margin-top: 1em">Consecutive components with the
same name are not allowed to avoid ambiguities (e.g.,
&quot;foo/foo&quot;).</p>

<p style="margin-top: 1em">For example, with -L$HOME/.jq a
module foo can be found in $HOME/.jq/foo.jq and
$HOME/.jq/foo/foo.jq.</p>

<p style="margin-top: 1em">If &quot;$HOME/.jq&quot; is a
file, it is sourced into the main program.</p>

<p style="margin-top: 1em">import RelativePathString as
NAME [&lt;metadata&gt;]; <br>
Imports a module found at the given path relative to a
directory in a search path. A &quot;.jq&quot; suffix will be
added to the relative path string. The module&Acirc;&acute;s
symbols are prefixed <br>
with &quot;NAME::&quot;.</p>

<p style="margin-top: 1em">The optional metadata must be a
constant jq expression. It should be an object with keys
like &quot;homepage&quot; and so on. At this time jq only
uses the &quot;search&quot; key/value of the meta&acirc;
<br>
data. The metadata is also made available to users via the
modulemeta builtin.</p>

<p style="margin-top: 1em">The &quot;search&quot; key in
the metadata, if present, should have a string or array
value (array of strings); this is the search path to be
prefixed to the top-level search path.</p>

<p style="margin-top: 1em">include RelativePathString
[&lt;metadata&gt;]; <br>
Imports a module found at the given path relative to a
directory in a search path as if it were included in place.
A &quot;.jq&quot; suffix will be added to the relative path
string. The <br>
module&Acirc;&acute;s symbols are imported into the
caller&Acirc;&acute;s namespace as if the
module&Acirc;&acute;s content had been included
directly.</p>

<p style="margin-top: 1em">The optional metadata must be a
constant jq expression. It should be an object with keys
like &quot;homepage&quot; and so on. At this time jq only
uses the &quot;search&quot; key/value of the meta&acirc;
<br>
data. The metadata is also made available to users via the
modulemeta builtin.</p>

<p style="margin-top: 1em">import RelativePathString as
$NAME [&lt;metadata&gt;]; <br>
Imports a JSON file found at the given path relative to a
directory in a search path. A &quot;.json&quot; suffix will
be added to the relative path string. The
file&Acirc;&acute;s data will be avail&acirc; <br>
able as $NAME::NAME.</p>

<p style="margin-top: 1em">The optional metadata must be a
constant jq expression. It should be an object with keys
like &quot;homepage&quot; and so on. At this time jq only
uses the &quot;search&quot; key/value of the meta&acirc;
<br>
data. The metadata is also made available to users via the
modulemeta builtin.</p>

<p style="margin-top: 1em">The &quot;search&quot; key in
the metadata, if present, should have a string or array
value (array of strings); this is the search path to be
prefixed to the top-level search path.</p>

<p style="margin-top: 1em">module &lt;metadata&gt;; <br>
This directive is entirely optional. It&Acirc;&acute;s not
required for proper operation. It serves only the purpose of
providing metadata that can be read with the modulemeta
builtin.</p>

<p style="margin-top: 1em">The metadata must be a constant
jq expression. It should be an object with keys like
&quot;homepage&quot;. At this time jq doesn&Acirc;&acute;t
use this metadata, but it is made available to users via
<br>
the modulemeta builtin.</p>

<p style="margin-top: 1em">modulemeta <br>
Takes a module name as input and outputs the
module&Acirc;&acute;s metadata as an object, with the
module&Acirc;&acute;s imports (including metadata) as an
array value for the &quot;deps&quot; key.</p>

<p style="margin-top: 1em">Programs can use this to query a
module&Acirc;&acute;s metadata, which they could then use
to, for example, search for, download, and install missing
dependencies.</p>

<p style="margin-top: 1em">BUGS <br>
Presumably. Report them or discuss them at:</p>


<p style="margin-top: 1em">https://github.com/stedolan/jq/issues</p>

<p style="margin-top: 1em">AUTHOR <br>
Stephen Dolan &lt;mu@netsoc.tcd.ie&gt;</p>

<p style="margin-top: 1em">January 2017 JQ(1)</p>
<hr>
</body>
</html>
