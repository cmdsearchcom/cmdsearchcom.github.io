<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>LIBIRCCLIENT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LIBIRCCLIENT(1)</td>
    <td class="head-vol">Libircclient</td>
    <td class="head-rtitle">LIBIRCCLIENT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
libircclient - Libircclient Documentation
<h1 class="Sh" title="Sh" id="INTRODUCTION"><a class="selflink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<h2 class="Ss" title="Ss" id="Introduction"><a class="selflink" href="#Introduction">Introduction</a></h2>
<h2 class="Ss" title="Ss" id="Overview"><a class="selflink" href="#Overview">Overview</a></h2>
Libircclient is a small but extremely powerful library which implements the
  client IRC protocol. It is designed to be small, fast, portable and compatible
  with the RFC standards as well as non-standard but popular features. It is
  perfect for building the IRC clients and bots.
<h2 class="Ss" title="Ss" id="Features"><a class="selflink" href="#Features">Features</a></h2>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Comprehensive C API;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Full coverage of the IRC protocol using providing
      functions;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Supports multiple simultaneous connection to different IRC
      servers or even to the same server;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Supports both plain and SSL connections to the IRC servers
      with the optional certificate check;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Full multi-threading support, the library is
    thread-safe;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">All the processing could be handled by a single thread even
      if multiple connections are used;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Non-blocking, asynchronous event-based interface
      implemented with callbacks;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Extra support for the socket-based applications, which use
      select();</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">CTCP support with optional build-in reply code;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Supports CTCP PING necessary to pass the &#x201C;spoof
      check&#x201D; implemented by most IRC servers;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Flexible DCC support, including both DCC chat, and DCC file
      transfer;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Can both initiate and react to initiated DCC;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Can accept or decline DCC sessions asynchronously;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Written in plain C, very small binary size (around 30K
      depending on platform);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Compatible all tested IRC clients;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Free software licensed under the LGPLv3 license;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Supports Linux as well as any POSIX-compliant Unix, Mac OS
      X and Microsoft Windows;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Supports 32/64bit architectures as well as non-x86
      architectures;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">IPv6 support (optional, must be compiled in);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">OpenSSL support (optional, must be compiled in);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Cocoa interface by Nathan Ollerenshaw;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Comprehensive documentation, examples and the FAQ;</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Known_issues"><a class="selflink" href="#Known_issues">Known
  issues</a></h2>
Even though possible by using multiple sessions, the library is not suitable to
  connect to a large number of IRC servers simultaneously. If you still want to
  use it, you'd have to overcome the following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You cannot use the main loop in <b>irc_run()</b> because it
      only supports one session. You would have to use
      <b>irc_add_select_descriptors()</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You'd have to handle reconnections separately by processing
      the relevant <b>irc_process_select_descriptors()</b> return values</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If you wish to use poll/epoll() instead of select() you'd
      have to write more logic as it is not directly supported. See the
      <i>FAQ</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The library is not optimized to have a low per-connection
      memory footprint, each non-SSL connection uses at least 4K, with around
      32K per connection for SSL.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Author"><a class="selflink" href="#Author">Author</a></h2>
This library is created by George Yunaev, copyright 2004-2013.
<h2 class="Ss" title="Ss" id="License"><a class="selflink" href="#License">License</a></h2>
Libircclient is licensed under Lesser General Public License version 3 or
  higher. The complete license text is provided in the Appendix.
<h1 class="Sh" title="Sh" id="INTEGRATION"><a class="selflink" href="#INTEGRATION">INTEGRATION</a></h1>
<h2 class="Ss" title="Ss" id="Integration"><a class="selflink" href="#Integration">Integration</a></h2>
<h2 class="Ss" title="Ss" id="Requirements"><a class="selflink" href="#Requirements">Requirements</a></h2>
<h2 class="Ss" title="Ss" id="Supported_operating_systems_and_compilers"><a class="selflink" href="#Supported_operating_systems_and_compilers">Supported
  operating systems and compilers</a></h2>
The library has been extensively tested on Linux x86 and x86_64. It has also
  been tested on Solaris x86, Linux on ARM and Linux on MIPS platforms, on Mac
  OS X on x86 and on various versions of Microsoft Windows.
<h2 class="Ss" title="Ss" id="Compilation"><a class="selflink" href="#Compilation">Compilation</a></h2>
On Linux, FreeBSD and Mac OS X the library has to be compiled and installed
  before use unless you use a precompiled package provided by your operating
  system distribution. If it is provided, you are recommended to use it as it
  would be updated from the central repository when the bugs are fixed.
<div style="height: 1.00em;">&#x00A0;</div>
On Microsoft Windows the official library binaries are provided, so you do not
  have to build it. Unless you have experience building with Cygwin, you're
  advised not to build from source and use the official binary.
<h2 class="Ss" title="Ss" id="Required_libraries"><a class="selflink" href="#Required_libraries">Required
  libraries</a></h2>
The library depends only on libc (glibc-devel on Linux) and gcc, although the
  examples require also libstdc++ (libstdc++-devel) and g++. Minimum supported
  version is glibc 2.2, although if IPv6 is requested, at least glibc 2.4 is
  required.
<div style="height: 1.00em;">&#x00A0;</div>
If the library is built with SSL support, the openssl development package
  (openssl-devel) needs to be installed.
<div style="height: 1.00em;">&#x00A0;</div>
On Microsoft Windows the Cygwin with necessary development packages must be
  installed (and openssl-devel as well).
<h2 class="Ss" title="Ss" id="Compiling"><a class="selflink" href="#Compiling">Compiling</a></h2>
The library is configured and built the standard Unix way:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
./configure [--enable-openssl] [--enable-ipv6]
make
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Installing"><a class="selflink" href="#Installing">Installing</a></h2>
Although no install is necessary to use the libraries, the install target is
  provided for convenience and could be invoked via <b>sudo make install</b>
<h2 class="Ss" title="Ss" id="Linking"><a class="selflink" href="#Linking">Linking</a></h2>
Link your application with either libircclient.a or libircclient.so depending on
  your needs. If you use the system-provided library, please link with
  libircclient.so.
<div style="height: 1.00em;">&#x00A0;</div>
If you have built the library with SSL support, you will need to link with
  OpenSSL libraries; add <b>-lcrypto -lssl</b> to your LDFLAGS
<div style="height: 1.00em;">&#x00A0;</div>
On Microsoft Windows please link with libircclient.lib which implicitly links
  with libircclient.dll
<h2 class="Ss" title="Ss" id="Coding"><a class="selflink" href="#Coding">Coding</a></h2>
<h2 class="Ss" title="Ss" id="Initialization"><a class="selflink" href="#Initialization">Initialization</a></h2>
<h2 class="Ss" title="Ss" id="Include_the_headers"><a class="selflink" href="#Include_the_headers">Include
  the headers</a></h2>
Before using the library you need to include the library header
  <i>libircclient.h</i>. You may also want to include <i>libirc_rfcnumeric.h</i>
  which provides the RFC codes:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
#include &quot;libircclient.h&quot;
#include &quot;libirc_rfcnumeric.h&quot;
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Create_event_handlers"><a class="selflink" href="#Create_event_handlers">Create
  event handlers</a></h2>
Unlike most network protocols such as HTTP or SMTP, the IRC protocol is
  event-based. The events come from server asynchronously. Some events are
  triggered by your action (such as joining the channel or changing your nick),
  some are triggered by other IRC users (such as sending you a message), and
  some are triggered by the IRC server itself (such as sending operation notes
  or invoking NickServ services).
<div style="height: 1.00em;">&#x00A0;</div>
Libircclient helps handling those events by providing the <b>event handling
  structure</b>. It declares the events you can define in your application, and
  when such event is received from the server, the appropriate callback will be
  called. The number of events you need to handle depending on the complexity of
  your client and the functionality it supports.
<div style="height: 1.00em;">&#x00A0;</div>
Generally there are only two events you must handle to provide a bare minimum
  functionality: <b>event_connect</b> and <b>event_numeric</b>. However it is
  recommended to create an event dump function and use it for all unused events
  to make sure you do not miss an important event because you expected a wrong
  one. See function <b>dump_event</b> in the file examples/irctest.c
<h2 class="Ss" title="Ss" id="Windows-specific_initialization"><a class="selflink" href="#Windows-specific_initialization">Windows-specific
  initialization</a></h2>
If you link with the <b>static</b> library on Microsoft Windows, you need to
  initialize the Winsock2 library before calling the library functions. It could
  be done by following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
WSADATA wsaData;
<div class="Pp"></div>
if ( WSAStartup ( MAKEWORD (2, 2), &amp;wsaData) != 0 )
    // report an error
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
However if you link with the <b>dynamic</b> library (libircclient.dll) which is
  default if you use the official build, this is not needed because the DLL
  initializes it automatically on load.
<h2 class="Ss" title="Ss" id="Create_an_IRC_session"><a class="selflink" href="#Create_an_IRC_session">Create
  an IRC session</a></h2>
To use the library at least one <b>IRC session</b> needs to be created. One
  session could be used to establish a single connection to one IRC server for
  one nick. However more than one session could be created if needed.
<div style="height: 1.00em;">&#x00A0;</div>
To create a session, call the <b>irc_create_session()</b> function:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// The IRC callbacks structure
irc_callbacks_t callbacks;
<div class="Pp"></div>
// Init it
memset ( &amp;callbacks, 0, sizeof(callbacks) );
<div class="Pp"></div>
// Set up the mandatory events
callbacks.event_connect = event_connect;
callbacks.event_numeric = event_numeric;
<div class="Pp"></div>
// Set up the rest of events
<div class="Pp"></div>
// Now create the session
irc_session_t * session = irc_create_session( &amp;callbacks );
<div class="Pp"></div>
if ( !session )
    // Handle the error
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This code could be repeated as many times as needed to create multiple sessions.
  The same callback structure could be reused for multiple sessions.
<h2 class="Ss" title="Ss" id="Set_options"><a class="selflink" href="#Set_options">Set
  options</a></h2>
Besides debugging there are two options you may need to use. The
  <b>LIBIRC_OPTION_STRIPNICKS</b> enables automatic parsing of nicknames, and
  since it is hard to imagine the case when it should not be enabled, we enable
  it:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
irc_option_set( session, LIBIRC_OPTION_STRIPNICKS );
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The second option you may need if you use SSL connections and plan to connect to
  the servers which use self-signed certificates. See the documentation for
  <b>LIBIRC_OPTION_SSL_NO_VERIFY</b>
<h2 class="Ss" title="Ss" id="Connect_to_the_server"><a class="selflink" href="#Connect_to_the_server">Connect
  to the server</a></h2>
To initiate the connection to the IRC server, call the <b>irc_connect()</b>
  function:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Connect to a regular IRC server
if ( irc_connect (session, &quot;irc.example.com&quot;, 6667, 0, &quot;mynick&quot;, &quot;myusername&quot;, &quot;myrealname&quot; ) )
  // Handle the error: irc_strerror() and irc_errno()
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To initiate the connection to the IRC server over SSL, call the
  <b>irc_connect()</b> function and prefix the host name or IP address with a
  hash symbol:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Connect to the SSL server; #192.168.1.1 is also possible
if ( irc_connect (session, &quot;#irc.example.com&quot;, 6669, 0, &quot;mynick&quot;, &quot;myusername&quot;, &quot;myrealname&quot; ) )
  // Handle the error: irc_strerror() and irc_errno()
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This function only initiates the connection, so when it successfully returns the
  connection is only initiated, but not established yet. Then one of the
  following happens after you invoke the networking handler:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the connection is established, you will receive the
      <b>event_connect</b> - this is why it is important to handle it</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the connection failed, the networking handler function
      will return failure</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Connect_to_the_IPv6_server"><a class="selflink" href="#Connect_to_the_IPv6_server">Connect
  to the IPv6 server</a></h2>
To initiate the connection to the IPv6 server, call the <b>irc_connect6()</b>
  function:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
if ( irc_connect6 (session, &quot;2001:0db8:85a3:0042:1000:8a2e:0370:7334&quot;, 6669, 0, &quot;mynick&quot;, &quot;myusername&quot;, &quot;myrealname&quot; ) )
  // Handle the error: irc_strerror() and irc_errno()
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The rest of the details, including the return value and the SSL are the same as
  with regular connect.
<h2 class="Ss" title="Ss" id="Start_the_networking_loop"><a class="selflink" href="#Start_the_networking_loop">Start
  the networking loop</a></h2>
To let the library handle the events, there are two scenarios. You can either
  invoke the built-in networking loop which will handle the networking and call
  your events, or you can write your own loop.
<div style="height: 1.00em;">&#x00A0;</div>
Invoking the build-in networking loop is simpler but limited. Since it loops
  until the connection terminates, it is not an option for a GUI application
  (unless you start the loop in a separate thread which you can do). And since
  this loop only can handle one session, it is impossible to use it if you want
  to handle multiple IRC sessions. In those cases the custom networking loop,
  described below, should be used.
<div style="height: 1.00em;">&#x00A0;</div>
To start the event loop call the <b>irc_run()</b> function:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
if ( irc_run (s) )
  // Either the connection to the server could not be established or terminated. See irc_errno()
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Remember that irc_run() call <b>will not return</b> until the server connection
  is not active anymore.
<h2 class="Ss" title="Ss" id="Use_the_custom_networking_loop"><a class="selflink" href="#Use_the_custom_networking_loop">Use
  the custom networking loop</a></h2>
If you use multiple sessions or have your own socket handler, you can use the
  custom networking loop. In this case your application must be select()-based (
  <i>see the FAQ</i> if you want to use other polling methods). And you need to
  run the following loop:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Make sure that all the IRC sessions are connected
if ( !irc_is_connected(session) )
  // reconnect it, or abort
<div class="Pp"></div>
// Create the structures for select()
struct timeval tv;
fd_set in_set, out_set;
int maxfd = 0;
<div class="Pp"></div>
// Wait 0.25 sec for the events - you can wait longer if you want to, but the library has internal timeouts
// so it needs to be called periodically even if there are no network events
tv.tv_usec = 250000;
tv.tv_sec = 0;
<div class="Pp"></div>
// Initialize the sets
FD_ZERO (&amp;in_set);
FD_ZERO (&amp;out_set);
<div class="Pp"></div>
// Add your own descriptors you need to wait for, if any
...
<div class="Pp"></div>
// Add the IRC session descriptors - call irc_add_select_descriptors() for each active session
irc_add_select_descriptors( session, &amp;in_set, &amp;out_set, &amp;maxfd );
<div class="Pp"></div>
// Call select()
if ( select (maxfd + 1, &amp;in_set, &amp;out_set, 0, &amp;tv) &lt; 0 )
   // Error
<div class="Pp"></div>
// You may also check if any descriptor is active, but again the library needs to handle internal timeouts,
// so you need to call irc_process_select_descriptors() for each session at least once in a few seconds
...
<div class="Pp"></div>
// Call irc_process_select_descriptors() for each session with the descriptor set
if ( irc_process_select_descriptors (session, &amp;in_set, &amp;out_set) )
    // The connection failed, or the server disconnected. Handle it.
<div class="Pp"></div>
// Do it again
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Channels_and_users"><a class="selflink" href="#Channels_and_users">Channels
  and users</a></h2>
Before calling any of those functions make sure you have connected to the
  server.
<h2 class="Ss" title="Ss" id="Join_and_leave_a_channel"><a class="selflink" href="#Join_and_leave_a_channel">Join
  and leave a channel</a></h2>
To join the channel call the <b>irc_cmd_join()</b> function with the channel
  name:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Join the channel #linux
if ( irc_cmd_join( session, &quot;#linux&quot;, 0 ) )
  // most likely connection error
<div class="Pp"></div>
// Join the channel $science protected by the secret key *superpassword*
if ( irc_cmd_join( session, &quot;$science&quot;, &quot;superpassword&quot; ) )
  // most likely connection error
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
You can join as many channels as you want, although the serer may restrict the
  number of channels you can join simultaneously.
<div style="height: 1.00em;">&#x00A0;</div>
If the join was successful you will receive the <b>event_join</b> event. You
  need to wait for this event before you can perform any channel operations
  (such as sending the messages). However you do NOT have to wait for this event
  to issue a second JOIN command as shown in the example above.
<div style="height: 1.00em;">&#x00A0;</div>
If the join was not successful, you will receive the error via
  <b>event_numeric</b>.
<div style="height: 1.00em;">&#x00A0;</div>
To leave the channel call the <b>irc_cmd_part()</b> function with the channel
  name:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Leave the channel #linux
if ( irc_cmd_part( session, &quot;#linux&quot; ) )
  // most likely connection error
<div class="Pp"></div>
// Leave the channel $science
if ( irc_cmd_part( session, &quot;$science&quot; ) )
  // most likely connection error
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Send_a_message_to_a_channel_or_to_a_user"><a class="selflink" href="#Send_a_message_to_a_channel_or_to_a_user">Send
  a message to a channel or to a user</a></h2>
After you have joined the channel, you can send a message to the channel by
  using the <b>irc_cmd_msg()</b> function with the channel name:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Say &quot;Hi!&quot; to everyone in the channel #linux
if ( irc_cmd_msg( session, &quot;#linux&quot;, &quot;Hi!&quot; ) )
  // most likely connection error
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Technically the protocol does not require one to join the channel to send the
  messages into the channel. However most servers by default set the channel
  mode which prevents the users who did not join the channel from sending the
  message into the channel.
<div style="height: 1.00em;">&#x00A0;</div>
Same function is used to send a &quot;private&quot; message to another user. The
  &quot;private&quot; messages do not go through the channels, but they still go
  through the IRC server (sometime multiple servers) and can be seen or even
  logged by the IRC network operators.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Say &quot;Hi!&quot; to IRC user john
if ( irc_cmd_msg( session, &quot;john&quot;, &quot;Hi!&quot; ) )
  // most likely connection error
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If the message was sent successfully you will not receive any confirmation or
  event. You will only receive the error via <b>event_numeric</b> if the message
  was not sent.
<h2 class="Ss" title="Ss" id="Receive_messages_from_a_channel_or_from_a_user"><a class="selflink" href="#Receive_messages_from_a_channel_or_from_a_user">Receive
  messages from a channel or from a user</a></h2>
You receive the channel messages by handling the <b>event_channel</b>. Each time
  someone says something in the channel this event is called.
<div style="height: 1.00em;">&#x00A0;</div>
You receive the &quot;private&quot; messages from other users by handling the
  <b>event_privmsg</b>.
<div style="height: 1.00em;">&#x00A0;</div>
Those event handlers should be created in your application and passed to the
  library when you <i>create an IRC session</i>
<h2 class="Ss" title="Ss" id="Send_an_action_message"><a class="selflink" href="#Send_an_action_message">Send
  an action message</a></h2>
&quot;Action&quot; messages, also called /me messages, are specially formatted
  CTCP messages. However the library contains a special function to send them,
  <b>irc_cmd_me()</b>. Actions sent by other people are handled by the
  <b>event_ctcp_action</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
Same as with sending messages no confirmation is received on success.
<h2 class="Ss" title="Ss" id="Send_a_CTCP_request"><a class="selflink" href="#Send_a_CTCP_request">Send
  a CTCP request</a></h2>
Other CTCP requests such as PING, VERSION etc should be sent by calling
  <b>irc_cmd_ctcp_request()</b>. If the CTCP response is received, it is handled
  by the <b>event_ctcp_rep</b> event.
<h2 class="Ss" title="Ss" id="Handling_DCC_chat"><a class="selflink" href="#Handling_DCC_chat">Handling
  DCC chat</a></h2>
<h2 class="Ss" title="Ss" id="Implementing_the_DCC_callback"><a class="selflink" href="#Implementing_the_DCC_callback">Implementing
  the DCC callback</a></h2>
No matter whether you plan to initiate DCC chats or respond to them you must
  implement the <b>DCC callback</b>:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
void dcc_callback (irc_session_t * session, irc_dcc_t id, int status, void * ctx, const char * data, unsigned int length)
{
   if ( status )
   {
       // If status is LIBIRC_ERR_CLOSED, the chat has been closed by the remote party.
       // Otherwise it is an error; the CHAT either terminated or could not be established. status is the error code; see irc_strerror(status)
   }
   else if ( length == 0 )
   {
       // The remote side has accepted the chat request, send &quot;hello&quot; something to them
       irc_dcc_text( session, id, &quot;Hello!&quot; );
   }
   else
   {
       // We have received the chat message from the remote party
       printf (&quot;Remote party said: %s\n&quot;, data );
   }
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This callback should be passed to either <b>irc_dcc_chat()</b> function which
  initiates the request, or to <b>irc_dcc_accept()</b> function which accepts
  the DCC CHAT request initiated by another user.
<h2 class="Ss" title="Ss" id="Initiating_the_DCC_CHAT"><a class="selflink" href="#Initiating_the_DCC_CHAT">Initiating
  the DCC CHAT</a></h2>
You can initiate the DCC chat with another user by calling
  <b>irc_dcc_chat()</b>:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// The DCC chat session id will be returned in this variable
irc_dcc_t dccid;
<div class="Pp"></div>
// Initiate the DCC chat with the IRC user &quot;john&quot;
if ( irc_dcc_chat( session, 0, &quot;john&quot;, dcc_callback, &amp;dccid ) )
  // report error
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Now you can proceed with other tasks. When John accepts or declines the chat,
  the dcc_callback() will be called, and it will be possible to use the
  <b>irc_dcc_text()</b> function to send the chat messages. The callback will
  also be called each time a new chat message is received, or when the chat is
  finished or terminated because of network error.
<h2 class="Ss" title="Ss" id="Responding_to_DCC_CHAT_requests"><a class="selflink" href="#Responding_to_DCC_CHAT_requests">Responding
  to DCC CHAT requests</a></h2>
To respond to the DCC CHAT equests your application should implement for the
  <b>event_dcc_chat_req</b> event. The callback could be implemented as
  following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
void callback_event_dcc_chat( irc_session_t * session, const char * nick, const char * addr, irc_dcc_t dccid )
{
    // User 'nick' from the IP address 'addr' tries to initiate the DCC chat with us.
    // Store this information in the application internal queue together with the dccid so the callback can return
    dcc_queue.store( dccid, &quot;CHAT from &quot; + nick + &quot; IP address: &quot; + addr  );
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
and registered when the IRC session is created. If your application does not
  handle DCC at all you can just call the <b>irc_dcc_decline()</b> function
  inside the callback.
<div style="height: 1.00em;">&#x00A0;</div>
If it does, we only store this information in the callback, and return. This is
  because the event processing will stop until the callback returns, so popping
  up the dialog asking for the user confirmation would stop further events such
  as channel messages from being processed. Even if your application is
  automatic and doesn't pop up dialogs it is still better to separate the chat
  logic from the callback logic.
<div style="height: 1.00em;">&#x00A0;</div>
Somewhere later the application would check the queue in the GUI thread, get
  this information, and pop up the dialog asking the user feedback. Then if the
  chat request was accepted, the application would call the
  <b>irc_dcc_accept()</b> function, and if it was declined, the application
  would call the <b>irc_dcc_decline()</b> function. Both functions will accept
  the <i>dccid</i> which identifies this specific request:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Somewhere in the GUI thread
if ( !dcc_queue.empty() )
{
    // Get the DCC information and show the dialog to the user
    irc_dcc_t dccid = dcc_chat_queue.top().dccid;
<div class="Pp"></div>
    ...
<div class="Pp"></div>
    // React to the user entry
    if ( dialog.isAccepted() )
        irc_dcc_accept( session, dccid, 0, dcc_callback );
    else
        irc_dcc_decline( session, dccid );
}
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Send_CHAT_messages"><a class="selflink" href="#Send_CHAT_messages">Send
  CHAT messages</a></h2>
Once the chat session is established, you can send the chat messages using
  <b>irc_dcc_text()</b> function. Note that you need to pass the dcc session id
  instead of nick:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
irc_dcc_text( session, dccid, &quot;Hello there!&quot; );
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Handling_DCC_file_transfer"><a class="selflink" href="#Handling_DCC_file_transfer">Handling
  DCC file transfer</a></h2>
This section covers handling sending and receiving files via DCC.
<h2 class="Ss" title="Ss" id="Implementing_the_callback"><a class="selflink" href="#Implementing_the_callback">Implementing
  the callback</a></h2>
No matter whether you plan to send or receive files via dcc you must implement
  the <b>DCC callback</b>. While the same callback may be used both for sending
  and receiving, this is not recommended since the logic is different. Therefore
  the suggested implementation would be to use different callbacks as suggested:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// This callback is used when we send a file to the remote party
void callback_dcc_send_file (irc_session_t * session, irc_dcc_t id, int status, void * ctx, const char * data, unsigned int length)
{
   if ( status )
   {
       // It is an error; the send operation was either terminated or the connection could not be established. status is the error code; see irc_strerror(status)
   }
   else
   {
       // We have sent some data to the remote party, 'length' indicates how much data was sent
       printf (&quot;Sent bytes: %d\n&quot;, length );
   }
}
<div class="Pp"></div>
// This callback is used when we receive a file from the remote party
void callback_dcc_recv_file (irc_session_t * session, irc_dcc_t id, int status, void * ctx, const char * data, unsigned int length)
{
   if ( status )
   {
       // It is an error; the send operation was either terminated or the connection could not be established. status is the error code; see irc_strerror(status)
   }
   else if ( data == 0 )
   {
       // File transfer has been finished
       printf (&quot;File has been received successfully\n&quot; );
   }
   else
   {
       // More file content has been received. Store it in memory, write to disk or something
       printf (&quot;Received %d bytes of data\n&quot;, length );
   }
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This callback should be passed to either <b>irc_dcc_sendfile()</b> function
  which initiates the request, or to <b>irc_dcc_accept()</b> function which
  accepts the DCC RECVFILE request initiated by another user.
<h2 class="Ss" title="Ss" id="Sending_the_file_via_DCC"><a class="selflink" href="#Sending_the_file_via_DCC">Sending
  the file via DCC</a></h2>
You can initiate sending the file via DCC to another user by calling
  <b>irc_dcc_sendfile()</b>:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// The DCC session id will be returned in this variable
irc_dcc_t dccid;
<div class="Pp"></div>
// Initiate sending of file &quot;/etc/passwd&quot; via DCC chat to the IRC user &quot;john&quot;
if ( irc_dcc_sendfile( session, 0, &quot;john&quot;, &quot;/etc/passwd&quot;, callback_dcc_send_file, &amp;dccid ) )
  // report error
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Now you can proceed with other tasks. When John accepts the request, the file
  will be sent and callback_dcc_send_file() will be called each time a piece of
  file is sent. The callback will also be called when the file has been sent, or
  when sending was terminated because of network error.
<h2 class="Ss" title="Ss" id="Receive_a_file_via_DCC"><a class="selflink" href="#Receive_a_file_via_DCC">Receive
  a file via DCC</a></h2>
To receive the file via DCC a remote user must initiate the DCC request to send
  you a file. To receive this request your application should implement the
  <b>event_dcc_send_req</b> event. The callback could be implemented as
  following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
void callback_event_dcc_file( irc_session_t * session, const char * nick, const char * addr, const char * filename, unsigned long size, irc_dcc_t dccid )
{
    // User 'nick' from the IP address 'addr' tries to initiate the DCC chat with us.
    // Store this information in the application internal queue together with the dccid so the callback can return
    dcc_queue.store( dccid, &quot;CHAT from &quot; + nick + &quot; IP address: &quot; + addr + &quot;, filename &quot; + filename  );
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If your application does not handle DCC at all you can just call the
  <b>irc_dcc_decline()</b> function inside the callback.
<div style="height: 1.00em;">&#x00A0;</div>
If it does, we only store this information in the callback, and return. This is
  because the event processing will stop until the callback returns, so popping
  up the dialog asking for the user confirmation would stop further events such
  as channel messages from being processed. Even if your application is
  automatic and doesn't pop up dialogs it is still better to separate the chat
  logic from the callback logic.
<div style="height: 1.00em;">&#x00A0;</div>
Somewhere later the application would check the queue in the GUI thread, get
  this information, and pop up the dialog asking the user feedback. Then if the
  chat request was accepted, the application would call the
  <b>irc_dcc_accept()</b> function, and if it was declined, the application
  would call the <b>irc_dcc_decline()</b> function. Both functions will accept
  the <i>dccid</i> which identifies this specific request:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
// Somewhere in the GUI thread
if ( !dcc_queue.empty() )
{
    // Get the DCC information and show the dialog to the user
    irc_dcc_t dccid = dcc_chat_queue.top().dccid;
<div class="Pp"></div>
    ...
<div class="Pp"></div>
    // React to the user entry
    if ( dialog.isAccepted() )
        irc_dcc_accept( session, dccid, 0, dcc_callback );
    else
        irc_dcc_decline( session, dccid );
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Note that it is not possible to request a remote user to send you a file.
<h2 class="Ss" title="Ss" id="Handling_colors"><a class="selflink" href="#Handling_colors">Handling
  colors</a></h2>
<h2 class="Ss" title="Ss" id="Stripping_colors_from_the_message"><a class="selflink" href="#Stripping_colors_from_the_message">Stripping
  colors from the message</a></h2>
If your bot reacts on the text messages, you need to strip down the colors from
  the text messages before processing them. Otherwise the user sending the
  colored message won't get the same reaction as the user who doesn't use
  colors, and some users use colors by default.
<div style="height: 1.00em;">&#x00A0;</div>
Use the <b>irc_color_strip_from_mirc()</b> function to strip the ANSI colors
  from the text message. It does not modify the message which doesn't use
  colors.
<h2 class="Ss" title="Ss" id="Color_conversion"><a class="selflink" href="#Color_conversion">Color
  conversion</a></h2>
The library supports color translation, and can convert colors between the ANSI
  colors used by the IRC clients and their textual representation. Colors usage
  is typically limited to the messages and user specified reasons. You cannot
  use colors as part of your nick or channel name.
<div style="height: 1.00em;">&#x00A0;</div>
Use the <b>irc_color_convert_from_mirc()</b> function to convert colors from
  ANSI to the library textual representation, and
  <b>irc_color_convert_to_mirc()</b> to convert the library textual
  representation of colors into ANSI.
<div style="height: 1.00em;">&#x00A0;</div>
Do not forget to free() the returned pointer once it is not used anymore.
<h2 class="Ss" title="Ss" id="Miscellaneous"><a class="selflink" href="#Miscellaneous">Miscellaneous</a></h2>
<h2 class="Ss" title="Ss" id="Tracking_user_nicks"><a class="selflink" href="#Tracking_user_nicks">Tracking
  user nicks</a></h2>
If your application maintains some user-specific quotas, it is important to
  track the nick changes. Since the nick is the only identifier available to
  you, each time the user changes the nick you need to update your quota
  database. To do so you need to intercept the <b>event_nick</b> event. See the
  examples/censor.c for details.
<h1 class="Sh" title="Sh" id="API_REFERENCE"><a class="selflink" href="#API_REFERENCE">API
  REFERENCE</a></h1>
<h2 class="Ss" title="Ss" id="Callbacks"><a class="selflink" href="#Callbacks">Callbacks</a></h2>
This section describes the callbacks supported by the library.
<h2 class="Ss" title="Ss" id="irc_event_callback_t"><a class="selflink" href="#irc_event_callback_t">irc_event_callback_t</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef void (*irc_event_callback_t)(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;event</i>, const char
    *<i>&#x00A0;origin</i>, const char ** <i>&#x00A0;params</i>, unsigned
    int<i>&#x00A0;count</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 260.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>The IRC session, which generated the event</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>event</i></td>
    <td>The text name of the event. Useful in case a single event handler is
      used to handle multiple events</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The originator of the event. Depends on the event.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>Extra parameters, if any, for this event. The number of extra parameters
      depends on the event, and may be zero. Each parameter is a NULL-terminated
      text string. None of the params can be NULL, but the <i>params</i> pointer
      itself could be NULL for some events.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>count</i></td>
    <td>The number of entries in the <i>params</i> argument supplied.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Every IRC event generates a callback. This type of callback is universal and is
  used by almost all IRC events. Depending on the event nature, it can have zero
  or more parameters. For each type of event, the number of provided parameters
  is fixed, and their meaning is described in the <b>irc_callbacks_t</b>
  structure.
<div style="height: 1.00em;">&#x00A0;</div>
Every event has an origin (i.e. who originated the event). In some cases the
  <i>origin</i> variable may be NULL, which indicates that event origin is
  unknown. The origin usually looks like <i>nick!host@ircserver</i>, i.e. like
  <i>tim!home@irc.server.net</i>. Such origins can not be used in IRC commands,
  and need to be stripped (i.e. host and server part should be cut off) before
  using. This can be done either manually, by calling
  <b>irc_target_get_nick()</b>, or automatically for all the events - by setting
  the <b>LIBIRC_OPTION_STRIPNICKS</b> option with <b>irc_option_set()</b>.
<h2 class="Ss" title="Ss" id="irc_event_dcc_chat_t"><a class="selflink" href="#irc_event_dcc_chat_t">irc_event_dcc_chat_t</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef void (*irc_event_dcc_chat_t)(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;nick</i>, const char
    *<i>&#x00A0;addr</i>, irc_dcc_t <i>&#x00A0;dccid</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 128.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session, which generates an event (the one returned by
      irc_create_session)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>User who requested the chat</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>addr</i></td>
    <td>IP address of the person such as 189.12.34.56</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>Identifier associated with this request which should be passed to the
      <b>irc_dcc_accept()</b> / <b>irc_dcc_decline()</b> functions</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This callback is called when someone requests DCC CHAT with you. DCC CHAT is the
  type of chat which goes directly between the clients, instead of going through
  the IRC server. Since the TCP connection must be established for it to happen,
  typically the initiator must either have the public IP or special software on
  the firewall which handles the necessary port forwarding.
<div style="height: 1.00em;">&#x00A0;</div>
You must respond to the chat request either by calling <b>irc_dcc_accept()</b>
  to accept it, or by calling <b>irc_dcc_decline()</b> to decline it.
<h2 class="Ss" title="Ss" id="irc_event_dcc_send_t"><a class="selflink" href="#irc_event_dcc_send_t">irc_event_dcc_send_t</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef void (*irc_event_dcc_send_t)(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;nick</i>, const char
    *<i>&#x00A0;addr</i>, const char * <i>&#x00A0;filename</i>, unsigned
    long<i>&#x00A0;size</i>, irc_dcc_t <i>&#x00A0;dccid</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 14.00ex;"/>
    <col style="width: 128.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>The IRC session, which generates an event (the one returned by
      irc_create_session)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>The user who requested the chat</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>addr</i></td>
    <td>The IP address of the person such as 189.12.34.56</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>filename</i></td>
    <td>The name of the file the user is trying to send you</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>size</i></td>
    <td>The size of the file</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>Identifier associated with this request which should be passed to the
      <b>irc_dcc_accept()</b> / <b>irc_dcc_decline()</b> functions</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This callback is called when someone wants to send you a file by using DCC SEND.
  DCC SEND goes directly between the clients, and requires the TCP connection to
  be established established for it to happen. Therefore the initiator must
  either have the public IP or special software on the firewall which handles
  the necessary port forwarding.
<div style="height: 1.00em;">&#x00A0;</div>
You must respond to the chat request either by calling <b>irc_dcc_accept()</b>
  to accept it, or by calling <b>irc_dcc_decline()</b> to decline it.
<h2 class="Ss" title="Ss" id="irc_dcc_callback_t"><a class="selflink" href="#irc_dcc_callback_t">irc_dcc_callback_t</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef void (*irc_dcc_callback_t)(irc_session_t
    *<i>&#x00A0;session</i>, irc_dcc_t <i>&#x00A0;id</i>,
    int<i>&#x00A0;status</i>, void * <i>&#x00A0;ctx</i>, const char
    *<i>&#x00A0;data</i>, unsigned int <i>&#x00A0;length</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 86.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>The IRC session, which generates an event (the one returned by
      irc_create_session)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>id</i></td>
    <td>The DCC session id</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>status</i></td>
    <td>The DCC connection status. 0 means there is no error, otherwise contains
      an error code</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>ctx</i></td>
    <td>The user-provided context</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>data</i></td>
    <td>Data received (if available), otherwise NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>length</i></td>
    <td>Size of the data received if any data</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This callback is called for all DCC functions when state change occurs.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>For DCC CHAT, the callback is called as
    following:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is <b>LIBIRC_ERR_CLOSED</b>: connection is
      closed by remote peer. After returning from the callback, the DCC session
      is automatically destroyed</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is nonzero but not <b>LIBIRC_ERR_CLOSED</b>:
      socket I/O error (connect error, accept error, recv error, send error).
      After returning from the callback, the DCC session is automatically
      destroyed</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is zero and <i>length</i> is zero: the remote
      side accepted the chat request</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is zero and <i>length</i> is nonzero: new
      chat message received, <i>data</i> contains the message (a null-terminated
      string), <i>length</i> contains the string length without null
    terminator</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag"><b>For DCC SEND, while file is being sent, the callback is
    called as following:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is nonzero: socket I/O error (connect error,
      accept error, recv error, send error). After returning from the callback,
      the DCC session is automatically destroyed</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is zero: another data packet has been sent,
      <i>length</i> contains the total amount of data sent so far, <i>data</i>
      is NULL</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag"><b>For DCC RECV, while file is being sending, callback
    called as following:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is nonzero: socket I/O error (connect error,
      accept error, recv error, send error). After returning from the callback,
      the DCC session is automatically destroyed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is zero, and <i>data</i> is NULL: the file
      has been received successfully. After returning from the callback, the DCC
      session is automatically destroyed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>status</i> is zero, and <i>data</i> is not NULL: new
      data received, <i>data</i> contains the data received, <i>length</i>
      contains the amount of data received.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="irc_eventcode_callback_t"><a class="selflink" href="#irc_eventcode_callback_t">irc_eventcode_callback_t</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef void (*irc_eventcode_callback_t)(irc_session_t
    *<i>&#x00A0;session</i>, unsigned int<i>&#x00A0;event</i>, const char
    *<i>&#x00A0;origin</i>, const char ** <i>&#x00A0;params</i>, unsigned
    int<i>&#x00A0;count</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 260.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>The IRC session, which generates an event (the one returned by
      irc_create_session)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>event</i></td>
    <td>The numeric code of the event. Useful in case a single event handler is
      used to handle multiple events</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The originator of the event. Depends on the event.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>Extra parameters, if any, for this event. The number of extra parameters
      depends on the event, and may be zero. Each parameter is a NULL-terminated
      text string. None of the params can be NULL, but the <i>params</i> pointer
      itself could be NULL for some events.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>count</i></td>
    <td>The number of entries in the <i>params</i> argument supplied.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This is an advanced callback for those who want to handle events deeper. Most
  times the IRC server replies to your actions with numeric events. Most of
  those events are error codes, and some are list-start and list-stop markers.
  Every code has its own set of params; for details you can either experiment,
  or read RFC 1459 (don't expect servers to follow it closely though).
<div style="height: 1.00em;">&#x00A0;</div>
Every event has an origin (i.e. who originated the event). In some cases the
  <i>origin</i> variable may be NULL, which indicates that event origin is
  unknown. The origin usually looks like <i>nick!host@ircserver</i>, i.e. like
  <i>tim!home@irc.server.net</i>. Such origins can not be used in IRC commands,
  and need to be stripped (i.e. host and server part should be cut off) before
  using. This can be done either manually, by calling
  <b>irc_target_get_nick()</b>, or automatically for all the events - by setting
  the <b>LIBIRC_OPTION_STRIPNICKS</b> option with <b>irc_option_set()</b>.
<h2 class="Ss" title="Ss" id="Functions"><a class="selflink" href="#Functions">Functions</a></h2>
This section describes the functions defined in the library which are grouped by
  the purpose.
<h2 class="Ss" title="Ss" id="Library_initialization_and_shutdown"><a class="selflink" href="#Library_initialization_and_shutdown">Library
  initialization and shutdown</a></h2>
<h2 class="Ss" title="Ss" id="irc_create_session"><a class="selflink" href="#irc_create_session">irc_create_session</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>irc_session_t * irc_create_session(irc_callbacks_t
    *<i>&#x00A0;callbacks</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 137.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>callbacks</i> | Event callbacks structure, which defines several
      callbacks, which will be called on appropriate events. Cannot be
      NULL.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Creates and initiates a new IRC session. Every session represents a single user
  connection to a single IRC server, and possibly to one or more users via DCC.
  Almost every library function requires this object to be passed to, and
  therefore this function should be called first. Multiple sessions could be
  allocated to support multiple connections.
<div style="height: 1.00em;">&#x00A0;</div>
When it is not needed anymore, the session must be destroyed by calling the
  <b>irc_destroy_session()</b> function.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
An <b>irc_session_t</b> object, or 0 if creation failed. Usually, failure is
  caused by out of memory error.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads. Same callback
  structure may be reused by multiple threads.
<h2 class="Ss" title="Ss" id="irc_destroy_session"><a class="selflink" href="#irc_destroy_session">irc_destroy_session</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_destroy_session(irc_session_t
    *<i>&#x00A0;session</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 38.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i> | The IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function destroys an IRC session, closes the connection to the IRC server,
  and frees all the used resources. After calling this function you should not
  use this session object anymore.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="Connecting,_disconnecting_and_running_the_main_event_loop"><a class="selflink" href="#Connecting,_disconnecting_and_running_the_main_event_loop">Connecting,
  disconnecting and running the main event loop</a></h2>
<h2 class="Ss" title="Ss" id="irc_connect6"><a class="selflink" href="#irc_connect6">irc_connect6</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_connect6(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;server</i>, unsigned short<i>&#x00A0;port</i>, const
    char * <i>&#x00A0;password</i>, const char *<i>&#x00A0;nick</i>, const char
    * <i>&#x00A0;username</i>, const char *<i>&#x00A0;realname</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<h2 class="Ss" title="Ss" id="irc_connect"><a class="selflink" href="#irc_connect">irc_connect</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_connect(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;server</i>, unsigned short<i>&#x00A0;port</i>, const
    char * <i>&#x00A0;password</i>, const char *<i>&#x00A0;nick</i>, const char
    * <i>&#x00A0;username</i>, const char *<i>&#x00A0;realname</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 14.00ex;"/>
    <col style="width: 326.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>server</i></td>
    <td>IP address or the host name of the server. If prefixed with #, the
      library will try to establish the SSL connection IPv4 address should be in
      numeric form such as 154.23.112.33; IPv6 address should be in IPv6
      form</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>port</i></td>
    <td>Port number to connect to, usually 6667</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>password</i></td>
    <td>IRC server password, if the server requires it. May be NULL, in this
      case password will not be send to the IRC server. Vast majority of IRC
      servers do not require passwords. This is NOT NickServ/ChanServ
      password</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Nick which will be used to log into the IRC server. Cannot be NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>username</i></td>
    <td>Username of the Unix account which is used to connect to the IRC server.
      This is for information only, will be shown in &quot;user properties&quot;
      dialogs and returned by /whois request. Can be NULL in which case
      &quot;nobody&quot; would be used</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>realname</i></td>
    <td>A real name of the person, who connects to the IRC. In reality nobody
      uses this field for that. Instead this field is used as user
      self-description, advertising, or other purposes. This information also
      will be shown in &quot;user properties&quot; dialogs and returned by
      /whois request. May be NULL, in this case &quot;noname&quot; will be
      used</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function initiates the connection to the IPv4 (irc_connect) or IPv6
  (irc_connect6) IRC server. The server could be specified either by an IP
  address or by the DNS name. The irc_connect6 works only if the library was
  built with the IPv6 support.
<div style="height: 1.00em;">&#x00A0;</div>
If the library was built with the OpenSSL support, and the IP address or the
  host name is prefixed by a hash, such as <b>&quot;#irc.example.com&quot;</b>,
  the library attempts to establish the SSL connection.
<div style="height: 1.00em;">&#x00A0;</div>
The connection is established asynchronously, and the <b>event_connect</b> is
  called once the connection is established.
<div style="height: 1.00em;">&#x00A0;</div>
A single IRC session object can only be connected to a single IRC server and
  only with a single nick, meaning it is not possible to have multiple nicks
  sharing a single connection.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Returns 0 if the connection is initiated successfully. This doesn't mean the
  connection is established - the <b>event_connect</b> is called when it
  happens. If the connection cannot be established, either <b>irc_run()</b> or
  <b>irc_process_select_descriptors()</b> will return an error.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads, but not using
  the same session object.
<h2 class="Ss" title="Ss" id="irc_disconnect"><a class="selflink" href="#irc_disconnect">irc_disconnect</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_disconnect(irc_session_t
    *<i>&#x00A0;session</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 36.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i> | IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function closes the IRC connection. After that connection is closed, if the
  libirc was looped in the <b>irc_run()</b> loop, it automatically leaves the
  loop and <b>irc_run()</b> returns.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads, but not using
  the same session object.
<h2 class="Ss" title="Ss" id="irc_is_connected"><a class="selflink" href="#irc_is_connected">irc_is_connected</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_is_connected(irc_session_t
    *<i>&#x00A0;session</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 18.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function returns 1 if the connection to the IRC server is established or 0
  if it is not.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_run"><a class="selflink" href="#irc_run">irc_run</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_run(irc_session_t
    *<i>&#x00A0;session</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 18.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function enters into forever loop, processing the IRC events, and calling
  the relevant callbacks. This function will not return until the server
  connection is terminated - either by server, or by calling
  <b>irc_cmd_quit</b>. This function should only be used if you use a single IRC
  session and don't need asynchronous request processing (i.e. your bot just
  reacts on the events, and doesn't generate it asynchronously). Even in last
  case, you still can call this function and start the asynchronous thread in
  <b>event_connect</b> handler. See the examples.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function returns a nonzero value if the connection to the IRC server could
  not be established, or was terminated.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function cannot be called from multiple threads. Use
  <b>irc_add_select_descriptors()</b> and
  <b>irc_process_select_descriptors()</b> instead.
<h2 class="Ss" title="Ss" id="irc_add_select_descriptors"><a class="selflink" href="#irc_add_select_descriptors">irc_add_select_descriptors</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_add_select_descriptors(irc_session_t
    *<i>&#x00A0;session</i>, fd_set <i>&#x00A0;*in_set</i>,
    fd_set<i>&#x00A0;*out_set</i>, int * <i>&#x00A0;maxfd</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 108.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>in_set</i></td>
    <td>fd_set input descriptor set for select()</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>out_set</i></td>
    <td>fd_set output descriptor set for select()</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>maxfd</i></td>
    <td>Largest descriptor already in all the sets. Will be updated if libirc
      adds larger number to the FD_SET array</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function should be used after you called <b>irc_connect()</b>. It is useful
  when you have your own select-based event processing loop. To use it you
  should put your own descriptors into the sets, call this function to add the
  library descriptor(s) into the set, and then call select(). When it returns,
  you should call <b>irc_process_select_descriptors()</b> which will handle the
  events and calls your callbacks(!). Then you can process your sockets events
  from set. See the example.
<div style="height: 1.00em;">&#x00A0;</div>
What if you use epoll? <i>See the FAQ</i>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function returns a nonzero value if the <b>irc_connect()</b> was not called
  before calling this function.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads, but it rarely
  makes sense.
<h2 class="Ss" title="Ss" id="irc_process_select_descriptors"><a class="selflink" href="#irc_process_select_descriptors">irc_process_select_descriptors</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_process_select_descriptors(irc_session_t
    *<i>&#x00A0;session</i>, fd_set <i>&#x00A0;*in_set</i>,
    fd_set<i>&#x00A0;*out_set</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 41.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>in_set</i></td>
    <td>fd_set input descriptor set for select()</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>out_set</i></td>
    <td>fd_set output descriptor set for select()</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function should be used in pair with <b>irc_add_select_descriptors()</b>
  function, which documentation describes how they work together.
<div style="height: 1.00em;">&#x00A0;</div>
Note that while processing the events this function calls your callbacks and it
  will not return until all your callbacks return. Keep that in mind if you pop
  up a dialog in your application, such as a DCC CHAT or DCC SEND confirmation
  dialog.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means success. Other value means error, the error code may be
  obtained through irc_errno().
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads for different
  IRC session objects only.
<h2 class="Ss" title="Ss" id="Managing_the_IRC_channels:_joining,_leaving,_inviting"><a class="selflink" href="#Managing_the_IRC_channels:_joining,_leaving,_inviting">Managing
  the IRC channels: joining, leaving, inviting</a></h2>
<h2 class="Ss" title="Ss" id="irc_cmd_join"><a class="selflink" href="#irc_cmd_join">irc_cmd_join</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_join(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;channel</i>, const char
    *<i>&#x00A0;key</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 53.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>Channel name to join. Cannot be NULL.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>key</i></td>
    <td>Secret key for the channel. Can be NULL if not needed</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Use this function to join the new IRC channel. If the channel does not exist, it
  will be automatically created by the IRC server. Note that to JOIN the
  password-protected channel, you must know the password, and specify it in the
  key argument. If join is successful, the <b>event_join</b> will be called
  (with your nick as the origin), then typically the <b>event_topic</b> is be
  called and then you receive the list of users who are on the channel (by using
  LIBIRC_RFC_RPL_NAMREPLY), which will include the user who just joined.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_BANNEDFROMCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_INVITEONLYCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_BADCHANNELKEY</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CHANNELISFULL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_BADCHANMASK</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYCHANNELS</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_part"><a class="selflink" href="#irc_cmd_part">irc_cmd_part</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_part(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;channel</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 38.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>Channel name to leave. Cannot be NULL.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Use this function to leave the IRC channel you've already joined to. An attempt
  to leave the channel you aren't in results a LIBIRC_RFC_ERR_NOTONCHANNEL
  server error.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_invite"><a class="selflink" href="#irc_cmd_invite">irc_cmd_invite</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_invite(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;nick</i>, const char
    *<i>&#x00A0;channel</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 36.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Nick name of the user to invite</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>Channel name to join. Cannot be NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to invite someone to invite-only channel.
  &quot;Invite-only&quot; is a channel mode, which restricts anyone, except
  invided, to join this channel. After invitation, the user could join this
  channel. The user, who is invited, will receive the <b>event_invite</b> event.
  Note that you must be a channel operator to invite the users.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>On success one of the following replies
    returned:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_INVITING</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_AWAY</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NEEDMOREPARAMS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_ERR_USERONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_ERR_CHANOPRIVSNEEDED</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_names"><a class="selflink" href="#irc_cmd_names">irc_cmd_names</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_names (irc_session_t * session, const char *
    channel);</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 90.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>A channel name(s) to obtain user list. Multiple channel names must be
      separated by a comma</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to to ask the IRC server for the list of the users who are
  joined the specified channel. You can list all nicknames that are visible to
  you on any channel that you can see. The list of users will be returned using
  LIBIRC_RFC_RPL_NAMREPLY and LIBIRC_RFC_RPL_ENDOFNAMES numeric codes.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>The channel names are returned by <b>event_numeric</b>
    event using the following reply codes:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_NAMREPLY</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_ENDOFNAMES</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_list"><a class="selflink" href="#irc_cmd_list">irc_cmd_list</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_list(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;channel</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 112.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>A channel name(s) to list. Multiple channel names must be separated by a
      comma. If NULL, all channels are listed</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to ask the IRC server for the active (existing) channels
  list. The list will be returned using the LIBIRC_RFC_RPL_LISTSTART, multiple
  LIBIRC_RFC_RPL_LIST, and LIBIRC_RFC_RPL_LISTEND event sequence. Note that
  &quot;private&quot; channels are listed (without their topics) as channel
  &quot;Prv&quot; unless the client generating the LIST query is actually on
  that channel. Likewise, secret channels are not listed at all unless the
  client is active at the channel in question.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>The list of channels is returned by <b>event_numeric</b>
    event using the following reply codes:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_LISTSTART</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_LISTEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_LIST</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_topic"><a class="selflink" href="#irc_cmd_topic">irc_cmd_topic</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_topic(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;channel</i>, const char
    *<i>&#x00A0;topic</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 117.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>A channel name</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>topic</i></td>
    <td>A new channel topic. If NULL, the old topic would be returned and
      nothing would change. To set the empty topic use &quot;&quot;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to change or view the topic (title) of a channel. Note
  that depending on <i>+t</i> channel mode, you may be required to be a channel
  operator to change the channel topic.
<div style="height: 1.00em;">&#x00A0;</div>
If the command succeeds, the IRC server will generate a LIBIRC_RFC_RPL_NOTOPIC
  or LIBIRC_RFC_RPL_TOPIC message, containing either the old or changed topic.
  Also the IRC server can (but does not have to) generate the non-RFC
  LIBIRC_RFC_RPL_TOPIC_EXTRA message, containing the nick of person who changed
  the topic, and the date/time of the last change.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>The topic information is returned using one of following
    reply codes:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_NOTOPIC</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_TOPIC</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If the topic change was requested and it was successfully changed, the
  <b>event_topic</b> is generated as well.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NEEDMOREPARAMS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_channel_mode"><a class="selflink" href="#irc_cmd_channel_mode">irc_cmd_channel_mode</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_channel_mode(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;channel</i>, const char
    *<i>&#x00A0;mode</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 87.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>A channel name</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>mode</i></td>
    <td>A mode to change. If NULL, the channel mode is not changed but the old
      mode is returned</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to is used to change or view the channel modes. Note that
  only the channel operators can change the channel mode.
<div style="height: 1.00em;">&#x00A0;</div>
Channel mode is represended by the multiple letters combination. Every letter
  has its own meaning in channel modes. Most channel mode letters are boolean
  (i.e. could only be set or reset), but a few channel mode letters accept a
  parameter. All channel options are set by adding a plus sign before the
  letter, and reset by adding a minus sign before the letter.
<div style="height: 1.00em;">&#x00A0;</div>
Here is the list of 'standard' channel modes:
<table class="tbl">
  <colgroup>
    <col style="width: 10.00ex;"/>
    <col style="width: 203.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>o nickname</td>
    <td>gives (+o nickname) to, or takes (-o nickname) the channel operator
      privileges from a <i>nickname</i>. This mode affects the users in channel,
      not the channel itself. Examples: &quot;+o tim&quot;, &quot;-o
      watson&quot;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>p</td>
    <td>sets (+p) or resets (-p) private channel flag. Private channels are
      shown in channel list as 'Prv', without the topic</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>s</td>
    <td>sets (+s) or resets (-s) secret channel flag. Secret channels aren't
      shown in channel list at all</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>i</td>
    <td>sets (+i) or resets (-i) invite-only channel flag. When the flag is set,
      only the people who are invited by the <b>irc_cmd_invite()</b> can join
      this channel</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>t</td>
    <td>allows (+t) or denies (-t) changing the topic by the non-channel
      operator users. When the flag is set, only the channel operators can
      change the channel topic</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>n</td>
    <td>sets (+n) or resets (-n) the protection from the users who did not join
      the channel. When the +n mode is set, only the users who have joined the
      channel can send the messages to the channel</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>m</td>
    <td>sets (+m) or resets (-m) the moderation of the channel. When the
      moderation mode is set, only channel operators and the users who have +v
      user mode can speak in the channel</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>v nickname</td>
    <td>gives (+v nick) or takes (-v nick) from user the ability to speak on a
      moderated channel. Examples: &quot;+v bob&quot;, &quot;-v joy&quot;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>l number</td>
    <td>sets (+l 20) or removes (-l) the restriction of maximum number of users
      allowed in channel. When the restriction is set and there is a number of
      users in the channel, no one can join the channel anymore</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>k key</td>
    <td>sets (+k password) or removes (-k) the password from the channel. When
      the restriction is set, any user joining the channel required to provide a
      channel key</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>b mask</td>
    <td>sets (+b <i>!*@</i>.mil) or removes (-b <i>!*@</i>.mil) the ban mask on
      a user to keep him out of channel. Note that to remove the ban you must
      specify the ban mask to remove, not just &quot;-b&quot;.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
Note that the actual list of channel modes depends on the IRC server, and can be
  bigger. If you know the popular channel modes which aren't listed here -
  please contact me
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>The old mode information is returned by using following
    numeric codes:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_CHANNELMODEIS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_BANLIST</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_ENDOFBANLIST</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NEEDMOREPARAMS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_KEYSET</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_UNKNOWNMODE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHCHANNEL</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_user_mode"><a class="selflink" href="#irc_cmd_user_mode">irc_cmd_user_mode</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_user_mode(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;mode</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 84.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>mode</i></td>
    <td>A mode to change. If NULL, the user mode is not changed but the old mode
      is returned</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to change or view the user modes. Note that, unlike
  channel modes, some user modes cannot be changed at all.
<div style="height: 1.00em;">&#x00A0;</div>
User mode is represended by the letters combination. All the user mode letters
  are boolean (i.e. could only be set or reset), they are set by adding a plus
  sign before the letter, and reset by adding a minus sign before the letter.
<div style="height: 1.00em;">&#x00A0;</div>
Here is the list of 'standard' user modes:
<table class="tbl">
  <colgroup>
    <col style="width: 1.00ex;"/>
    <col style="width: 124.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>o</td>
    <td>represents an IRC operator status. Could not be set directly (but can be
      reset though), to set it use the IRC a OPER command</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>i</td>
    <td>if set, marks a user as 'invisible' - that is, not seen by lookups if
      the user is not in a channel</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>w</td>
    <td>if set, marks a user as 'receiving wallops' - special messages generated
      by IRC operators using WALLOPS command</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>s</td>
    <td>if set, marks a user for receipt of server notices</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>r</td>
    <td>NON-STANDARD MODE. If set, user has been authenticated with the NickServ
      IRC service</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>x</td>
    <td>NON-STANDARD MODE. If set, user's real IP is masked by the IRC
      server</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
Note that the actual list of user modes depends on the IRC server, and can be
  bigger. If you know the popular user modes, which aren't mentioned here -
  please contact me.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
The old mode information is returned by using the numeric code
  LIBIRC_RFC_RPL_UMODEIS:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NEEDMOREPARAMS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_UNKNOWNMODE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_USERSDONTMATCH</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_UMODEUNKNOWNFLAG</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_kick"><a class="selflink" href="#irc_cmd_kick">irc_cmd_kick</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_kick (irc_session_t * session, const char *
    nick, const char * channel, const char * reason);</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 40.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>The nick to kick</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>channel</i></td>
    <td>The channel to kick the nick from</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>If not NULL, the reason to kick the user</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to kick a person out of channel. Note that you must be a
  channel operator to kick anyone from a channel.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
If the command succeed, the <b>event_kick</b> will be generated.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>If the command failed, one of the following
    <b>event_numeric</b> responses will be generated:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NEEDMOREPARAMS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_BADCHANMASK</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="Sending_the_messages,_notices,_/me_messages_and_working_with_CTCP"><a class="selflink" href="#Sending_the_messages,_notices,_/me_messages_and_working_with_CTCP">Sending
  the messages, notices, /me messages and working with CTCP</a></h2>
<h2 class="Ss" title="Ss" id="irc_cmd_msg"><a class="selflink" href="#irc_cmd_msg">irc_cmd_msg</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_msg(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;nch</i>, const char *<i>&#x00A0;text</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 29.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nch</i></td>
    <td>Target nick or target channel</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>text</i></td>
    <td>Message text</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to send the message to the channel or privately to another
  nick. &quot;Privately&quot; here means the message is not posted to the
  public, but the message still goes through the IRC server and could be seen by
  the IRC netwrk operators. The message target is determined by the <i>nch</i>
  argument: if it is a nick, this will be a private message, but if it is a
  channel name it will be posted into the channel.
<div style="height: 1.00em;">&#x00A0;</div>
The protocol does not require you to join the channel to post the message into
  it, but most channels set the channel mode preventing you from posting into a
  channel unless you join it.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed. You need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
If the command succeed, no event is typically generated except the possibility
  of LIBIRC_RFC_RPL_AWAY.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>However if the command failed, one of the following
    numeric events may be generated:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NORECIPIENT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTEXTTOSEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_WILDTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYTARGETS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_me"><a class="selflink" href="#irc_cmd_me">irc_cmd_me</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_me(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;nch</i>, const char *<i>&#x00A0;text</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 29.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nch</i></td>
    <td>Target nick or target channel</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>text</i></td>
    <td>Message text</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to send the /me message (CTCP ACTION) to the channel or
  privately to another nick. &quot;Privately&quot; here means the message is not
  posted to the public, but the message still goes through the IRC server and
  could be seen by the IRC netwrk operators. The message target is determined by
  the <i>nch</i> argument: if it is a nick, this will be a private message, but
  if it is a channel name it will be posted into the channel.
<div style="height: 1.00em;">&#x00A0;</div>
The protocol does not require you to join the channel to post the message into
  it, but most channels set the channel mode preventing you from posting into a
  channel unless you join it.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed. You need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
If the command succeed, no event is typically generated except the possibility
  of LIBIRC_RFC_RPL_AWAY.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>However if the command failed, one of the following
    numeric events may be generated:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NORECIPIENT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTEXTTOSEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_WILDTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYTARGETS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_notice"><a class="selflink" href="#irc_cmd_notice">irc_cmd_notice</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_notice(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;nch</i>, const char
    *<i>&#x00A0;text</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 29.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nch</i></td>
    <td>Target nick or target channel</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>text</i></td>
    <td>Message text</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to send the notice to the channel or privately to another
  nick. &quot;Privately&quot; here means the message is not posted to the
  public, but the message still goes through the IRC server and could be seen by
  the IRC netwrk operators. The message target is determined by the <i>nch</i>
  argument: if it is a nick, this will be a private message, but if it is a
  channel name it will be posted into the channel.
<div style="height: 1.00em;">&#x00A0;</div>
The protocol does not require you to join the channel to post the notice into
  it, but most channels set the channel mode preventing you from posting into a
  channel unless you join it.
<div style="height: 1.00em;">&#x00A0;</div>
The only difference between a message and a notice is that the RFC explicitly
  says the automatic bots must not reply to NOTICE automatically.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
If the command succeed, no event is typically generated except the possibility
  of LIBIRC_RFC_RPL_AWAY.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>However if the command failed, one of the following
    numeric events may be generated:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NORECIPIENT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTEXTTOSEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_WILDTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYTARGETS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_ctcp_request"><a class="selflink" href="#irc_cmd_ctcp_request">irc_cmd_ctcp_request</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_ctcp_request(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;nick</i>, const char
    *<i>&#x00A0;request</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 18.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Target nick</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>request</i></td>
    <td>CTCP request tex</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to send a CTCP request. There are four CTCP requests
  supported by most IRC clients:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">VERSION - get the client software name and version</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">FINGER - get the client username, host and real name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">PING - get the client delay.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">TIME - get the client local time.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Some clients may support other requests. The RFC does not list the requests and
  does not mandate any CTCP support.
<div style="height: 1.00em;">&#x00A0;</div>
If you send the CTCP request, make sure you define the handler for the
  <b>event_ctcp_rep</b> to process the reply;
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NORECIPIENT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTEXTTOSEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_WILDTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYTARGETS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_ctcp_reply"><a class="selflink" href="#irc_cmd_ctcp_reply">irc_cmd_ctcp_reply</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_ctcp_reply(irc_session_t
    *<i>&#x00A0;session</i>, const char * <i>&#x00A0;nick</i>, const char
    *<i>&#x00A0;reply</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 18.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Target nick</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>reply</i></td>
    <td>CTCP reply</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to send a reply to the CTCP request received from
  <b>event_ctcp_req</b> event. Note that you will not receive this event unless
  you specify your own handler during the IRC session initialization.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NORECIPIENT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTEXTTOSEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_WILDTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYTARGETS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="Miscellaneous:_library_version,_raw_data,_changing_nick,_quitting"><a class="selflink" href="#Miscellaneous:_library_version,_raw_data,_changing_nick,_quitting">Miscellaneous:
  library version, raw data, changing nick, quitting</a></h2>
<h2 class="Ss" title="Ss" id="irc_cmd_nick"><a class="selflink" href="#irc_cmd_nick">irc_cmd_nick</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_nick(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;newnick</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 18.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>New nick</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to change your current nick to another nick. Note that
  such a change is not always possible; for example you cannot change nick to
  the existing nick, or (on some servers) to the registered nick.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>If the operation succeed, the server will send the
    <b>event_nick</b> event. If not, it will send a numeric error. Possible
    error responces for this command from the RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NONICKNAMEGIVEN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_ERRONEUSNICKNAME</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NICKNAMEINUSE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NICKCOLLISION</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_whois"><a class="selflink" href="#irc_cmd_whois">irc_cmd_whois</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_whois(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;nick</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 69.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Nick or comma-separated list of nicks to query the information
      about</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function queries various information about the nick. The amount of
  information depends on the IRC server but typically includes username, real
  name (as defined by the client at login), the IRC server used, the channels
  user is in, idle time, away mode and so on.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>If the request succeed, the information is returned
    through the following numeric codes which return the information:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_WHOISUSER</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_WHOISCHANNELS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_WHOISSERVER</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_AWAY</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_WHOISOPERATOR</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_WHOISIDLE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_RPL_ENDOFWHOIS - this event terminates the WHOIS
      information</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHSERVER</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NONICKNAMEGIVEN</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_cmd_quit"><a class="selflink" href="#irc_cmd_quit">irc_cmd_quit</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_cmd_quit(irc_session_t *<i>&#x00A0;session</i>,
    const char * <i>&#x00A0;reason</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 31.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>reason</i></td>
    <td>If not NULL, the reason to quit</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b> This function sends the QUIT command to the IRC server. This
  command forces the IRC server to close the IRC connection, and terminate the
  session.
<div style="height: 1.00em;">&#x00A0;</div>
The difference between this command and calling the irc_disconnect is that this
  command allows to specify the reason to quit which will be shown to all the
  users in the channels you joined. Also it would make it clear that you left
  the IRC channels by purpose, and not merely got disconnected.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_send_raw"><a class="selflink" href="#irc_send_raw">irc_send_raw</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_send_raw (irc_session_t * session, const char *
    format, ...);</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 63.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>format</i></td>
    <td>printf-type formatting string followed by the format arguments</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function sends the raw data as-is to the IRC server. Use it to generate a
  server command, which is not (yet) provided by libircclient directly.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_target_get_nick"><a class="selflink" href="#irc_target_get_nick">irc_target_get_nick</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_target_get_nick(const char
    *<i>&#x00A0;origin</i>, char <i>&#x00A0;*nick</i>,
    size_t<i>&#x00A0;size</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 101.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>Nick in the common IRC server format such as tim!root@mycomain.com</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Buffer to retrieve the parsed nick name</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>size</i></td>
    <td>Size of the <i>nick</i> buffer. If the parsed nick is larger than the
      buffer size it will be truncated</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
For most events IRC server returns 'origin' (i.e. the person, who generated this
  event) in so-called &quot;common&quot; form, like <i>nick!host@domain</i>.
  However, all the irc_cmd_* functions require just a nick. This function parses
  this origin, and retrieves the nick, storing it into the user-provided buffer.
<div style="height: 1.00em;">&#x00A0;</div>
A buffer of size 128 should be enough for most nicks.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_target_get_host"><a class="selflink" href="#irc_target_get_host">irc_target_get_host</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_target_get_host(const char
    *<i>&#x00A0;target</i>, char <i>&#x00A0;*host</i>,
    size_t<i>&#x00A0;size</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 101.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>Nick in the common IRC server format such as tim!root@mycomain.com</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>host</i></td>
    <td>Buffer to retrieve the parsed hostname</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>size</i></td>
    <td>Size of the <i>host</i> buffer. If the parsed nick is larger than the
      buffer size it will be truncated</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
For most events IRC server returns 'origin' (i.e. the person, who generated this
  event) in so-called &quot;common&quot; form, like nick!host@domain. This
  function parses this origin, and retrieves the host, storing it into the
  user-provided buffer.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="DCC_initiating_and_accepting_chat_sessions,_sending_and_receiving_files"><a class="selflink" href="#DCC_initiating_and_accepting_chat_sessions,_sending_and_receiving_files">DCC
  initiating and accepting chat sessions, sending and receiving files</a></h2>
<h2 class="Ss" title="Ss" id="irc_dcc_chat"><a class="selflink" href="#irc_dcc_chat">irc_dcc_chat</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_dcc_chat(irc_session_t *<i>&#x00A0;session</i>,
    void * <i>&#x00A0;ctx</i>, const char *<i>&#x00A0;nick</i>,
    irc_dcc_callback_t <i>&#x00A0;callback</i>, irc_dcc_t
    *<i>&#x00A0;dccid</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 14.00ex;"/>
    <col style="width: 77.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>ctx</i></td>
    <td>User-defined context which will be passed to the callback. May be
      NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Target nick</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>callback</i></td>
    <td>DCC callback which will be used for DCC and chat events</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>If this function succeeds, the DCC session identifier is stored in this
      field</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function requests a DCC CHAT between you and other IRC user. DCC CHAT is
  like private chat, but it goes directly between two users, and bypasses the
  IRC server. DCC CHAT request must be accepted by other side before you can
  send anything.
<div style="height: 1.00em;">&#x00A0;</div>
When the chat is accepted, declined, terminated, or some data is received, the
  <i>callback</i> function is called. To be specific, the callback will be
  called when:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The chat request is accepted;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The chat request is denied;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The new chat message is received;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The chat is terminated by the remote party;</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
See the details in <b>irc_dcc_callback_t</b> declaration.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NORECIPIENT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTEXTTOSEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_WILDTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYTARGETS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_dcc_msg"><a class="selflink" href="#irc_dcc_msg">irc_dcc_msg</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_dcc_msg(irc_session_t *<i>&#x00A0;session</i>,
    irc_dcc_t <i>&#x00A0;dccid</i>, const char *<i>&#x00A0;text</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 63.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>DCC session identifier for the DCC CHAT session which is active</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>text</i></td>
    <td>NULL-terminated message to send</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function is used to send the DCC CHAT message to an active DCC CHAT. To be
  active, DCC CHAT request must be initiated by one side and accepted by another
  side.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means success. Other value means error, the error code may be
  obtained through irc_errno().
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_dcc_accept"><a class="selflink" href="#irc_dcc_accept">irc_dcc_accept</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_dcc_accept(irc_session_t
    *<i>&#x00A0;session</i>, irc_dcc_t <i>&#x00A0;dccid</i>, void
    *<i>&#x00A0;ctx</i>, irc_dcc_callback_t <i>&#x00A0;callback</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 14.00ex;"/>
    <col style="width: 71.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>DCC session identifier returned by the callback</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>ctx</i></td>
    <td>User-defined context which will be passed to the callback. May be
      NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>callback</i></td>
    <td>DCC callback which will be used for DCC and chat events</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function accepts a remote DCC chat or file transfer request. After the
  request is accepted the <i>callback</i> will be called for the further DCC
  events, including the termination of the DCC session. See the <b>DCC callback
  information</b>.
<div style="height: 1.00em;">&#x00A0;</div>
This function should be called only after either <b>event_dcc_chat_req</b> or
  <b>event_dcc_send_req</b> events are received. You don't have to call
  irc_dcc_accept() or irc_dcc_decline() immediately in the event processing
  function - you may just store the <i>dccid</i> and return, and call those
  functions later. However to prevent memory leaks you must call either
  irc_dcc_decline() or irc_dcc_accept() for any incoming DCC request within 60
  seconds after receiving it.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means success. Other value means error, the error code may be
  obtained through <b>irc_errno()</b>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_dcc_decline"><a class="selflink" href="#irc_dcc_decline">irc_dcc_decline</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_dcc_decline(irc_session_t
    *<i>&#x00A0;session</i>, irc_dcc_t <i>&#x00A0;dccid</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 47.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>DCC session identifier returned by the callback</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function declines a remote DCC chat or file transfer request.
<div style="height: 1.00em;">&#x00A0;</div>
This function should be called only after either <b>event_dcc_chat_req</b> or
  <b>event_dcc_send_req</b> events are received. You don't have to call
  irc_dcc_accept() or irc_dcc_decline() immediately in the event processing
  function - you may just store the <i>dccid</i> and return, and call those
  functions later. However to prevent memory leaks you must call either
  irc_dcc_decline() or irc_dcc_accept() for any incoming DCC request within 60
  seconds after receiving it.
<div style="height: 1.00em;">&#x00A0;</div>
Do not use this function to forecefully close the previously accepted or
  initiated DCC session. Use <b>irc_dcc_destroy()</b> instead.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means success. Other value means error, the error code may be
  obtained through <b>irc_errno()</b>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_dcc_sendfile"><a class="selflink" href="#irc_dcc_sendfile">irc_dcc_sendfile</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_dcc_sendfile(irc_session_t
    *<i>&#x00A0;session</i>, void * <i>&#x00A0;ctx</i>, const char
    *<i>&#x00A0;nick</i>, const char * <i>&#x00A0;filename</i>,
    irc_dcc_callback_t <i>&#x00A0;callback</i>, irc_dcc_t
    *<i>&#x00A0;dccid</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 14.00ex;"/>
    <col style="width: 77.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>ctx</i></td>
    <td>User-defined context which will be passed to the callback. May be
      NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>nick</i></td>
    <td>Target nick</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>filename</i></td>
    <td>Full path to the file which will be sent. Must be an existing file</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>callback</i></td>
    <td>DCC callback which will be used for DCC and chat events</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>If this function succeeds, the DCC session identifier is stored in this
      field</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function generates a DCC SEND request to send the file. When it is
  accepted, the file is sent to the remote party, and the DCC session is closed.
  The send operation progress and result can be checked in the callback. See the
  <b>DCC callback information</b>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means the command was sent to the IRC server successfully. This
  does not mean the operation succeed, and you need to wait for the appropriate
  event or for the error code via <b>event_numeric</b> event.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Possible error responces for this command from the
    RFC1459:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NORECIPIENT</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTEXTTOSEND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTONCHANNEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_WILDTOPLEVEL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_TOOMANYTARGETS</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIBIRC_RFC_ERR_NOSUCHNICK</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_dcc_destroy"><a class="selflink" href="#irc_dcc_destroy">irc_dcc_destroy</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_dcc_destroy(irc_session_t
    *<i>&#x00A0;session</i>, irc_dcc_t <i>&#x00A0;dccid</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 46.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>dccid</i></td>
    <td>DCC session identifier of a session to destroy</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function closes the DCC connection (if available), and destroys the DCC
  session, freeing the used resources. It can be called anytime, even from
  callbacks or from different threads.
<div style="height: 1.00em;">&#x00A0;</div>
Note that when DCC session is finished (either with success or failure), you
  should not destroy it - it will be destroyed automatically.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Return code 0 means success. Other value means error, the error code may be
  obtained through <b>irc_errno()</b>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="Handling_the_colored_messages"><a class="selflink" href="#Handling_the_colored_messages">Handling
  the colored messages</a></h2>
<h2 class="Ss" title="Ss" id="irc_color_strip_from_mirc"><a class="selflink" href="#irc_color_strip_from_mirc">irc_color_strip_from_mirc</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>char * irc_color_strip_from_mirc(const char
    *<i>&#x00A0;message</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 28.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>message</i></td>
    <td>Original message with colors</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function strips all the ANSI color codes from the message, and returns a
  new message with no color information. Useful for the bots which react to
  strings, to make sure the bot is not confused if the string uses colors.
<div style="height: 1.00em;">&#x00A0;</div>
This function does not modify the message which doesn't use colors.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Returns a new message with stripped color codes. Note that the memory for the
  new message is allocated using malloc(), so you should free it using free()
  when it is not used anymore. If memory allocation failed, returns 0.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_color_convert_from_mirc"><a class="selflink" href="#irc_color_convert_from_mirc">irc_color_convert_from_mirc</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>char * irc_color_convert_from_mirc(const char
    *<i>&#x00A0;message</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 28.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>message</i></td>
    <td>Original message with colors</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function converts all the color codes and format options to libircclient
  internal colors.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Returns a pointer to the new message with converted ANSI color codes and format
  options. See the <i>irc_color_convert_to_mirc</i> help for details.
<div style="height: 1.00em;">&#x00A0;</div>
Note that the memory for the new message is allocated using malloc(), so you
  should free it using free() when it is not used anymore. If memory allocation
  failed, returns 0.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_color_convert_to_mirc"><a class="selflink" href="#irc_color_convert_to_mirc">irc_color_convert_to_mirc</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>char * irc_color_convert_to_mirc(const char
    *<i>&#x00A0;message</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 28.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>message</i></td>
    <td>Original message with colors</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function converts all the color codes and format options from internal
  libircclient colors to ANSI used by mIRC and other IRC clients.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Returns a new message with converted color codes and format options, or 0 if
  memory could not be allocated. Note that the memory for the new message is
  allocated using malloc(), so you should free it using free() when it is not
  used anymore.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<div style="height: 1.00em;">&#x00A0;</div>
The color system of libircclient is designed to be easy to use, and portable
  between different IRC clients. Every color or format option is described using
  plain text commands written between square brackets.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>The possible codes are:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">[B] ... [/B] - bold format mode. Everything between [B] and
      [/B] is written in <b>bold</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">[I] ... [/I] - italic/reverse format mode. Everything
      between [I] and [/I] is written in <i>italic</i>, or reversed (however,
      because some clients are incapable of rendering italic text, most clients
      display this as normal text with the background and foreground colors
      swapped).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">[U] ... [/U] - underline format mode. Everything between
      [U] and [/U] is written underlined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">[COLOR=RED] ... [/COLOR] - write the text using specified
      foreground color. The color is set by using the COLOR keyword, and equal
      sign followed by text color code (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">[COLOR=RED/BLUE] ... [/COLOR] - write the text using
      specified foreground and background color. The color is set by using the
      COLOR keyword, an equal sign followed by text foreground color code, a
      dash and a text background color code.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag"><b>The following colors are supported:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">WHITE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">BLACK</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">DARKBLUE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">DARKGREEN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">RED</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">BROWN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">PURPLE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">OLIVE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">YELLOW</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">GREEN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">TEAL</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">CYAN</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">BLUE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">MAGENTA</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">DARKGRAY</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LIGHTGRAY</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Examples of color sequences:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
Hello, [B]Tim[/B].
[U]Arsenal[/U] got a [COLOR=RED]red card[/COLOR]
The tree[U]s[/U] are [COLOR=GREEN/BLACK]green[/COLOR]
</pre>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Changing_the_library_options"><a class="selflink" href="#Changing_the_library_options">Changing
  the library options</a></h2>
<h2 class="Ss" title="Ss" id="irc_get_version"><a class="selflink" href="#irc_get_version">irc_get_version</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_get_version(unsigned int *<i>&#x00A0;high</i>,
    unsigned int * <i>&#x00A0;low</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 10.00ex;"/>
    <col style="width: 30.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>high</i></td>
    <td>Stores the high version number</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>low</i></td>
    <td>Stores the low version number</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function returns the libircclient version. You can use the version either
  to check whether required options are available, or to output the version. The
  preferred printf-like format string to output the version is:
<div style="height: 1.00em;">&#x00A0;</div>
<b>printf (&quot;Version: %d.%02d&quot;, high, low);</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_set_ctx"><a class="selflink" href="#irc_set_ctx">irc_set_ctx</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_set_ctx(irc_session_t *<i>&#x00A0;session</i>,
    void * <i>&#x00A0;ctx</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 21.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>ctx</i></td>
    <td>User-defined context</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function sets the user-defined context for this IRC session. This context
  is not used by libircclient. Its purpose is to store session-specific user
  data, which may be obtained later by calling <i>irc_get_ctx</i>. Note that
  libircclient just carries out this pointer. If you allocate some memory, and
  store its address in ctx (most common usage), it is your responsibility to
  free it before calling <b>irc_destroy_session()</b>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_get_ctx"><a class="selflink" href="#irc_get_ctx">irc_get_ctx</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void * irc_get_ctx(irc_session_t
    *<i>&#x00A0;session</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 18.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function returns the IRC session context, which was set by
  <i>irc_set_ctx</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
If no context was set, this function returns NULL.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_option_set"><a class="selflink" href="#irc_option_set">irc_option_set</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_option_set(irc_session_t
    *<i>&#x00A0;session</i>, unsigned int <i>&#x00A0;option</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 38.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>option</i></td>
    <td>One of the <i>Libirc options</i> to set</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function sets the libircclient option, changing libircclient behavior. See
  the <i>options</i> list for the meaning for every option.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="irc_option_reset"><a class="selflink" href="#irc_option_reset">irc_option_reset</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>void irc_option_reset(irc_session_t
    *<i>&#x00A0;session</i>, unsigned int <i>&#x00A0;option</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 38.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>option</i></td>
    <td>One of the <i>Libirc options</i> to set</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function resets the libircclient option, changing libircclient behavior.
  See the <i>options</i> list for the meaning for every option.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="Handling_the_errors"><a class="selflink" href="#Handling_the_errors">Handling
  the errors</a></h2>
<h2 class="Ss" title="Ss" id="irc_errno"><a class="selflink" href="#irc_errno">irc_errno</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>int irc_errno(irc_session_t
    *<i>&#x00A0;session</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 18.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>session</i></td>
    <td>IRC session handle</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function returns the last error code associated with last operation of this
  IRC session. Possible error codes are defined in libirc_errors.h
<div style="height: 1.00em;">&#x00A0;</div>
As usual, typical errno rules apply:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">irc_errno() should be called ONLY if the called function
      fails;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">irc_errno() doesn't return 0 if function succeed; actually,
      the return value will be undefined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">you should call irc_errno() IMMEDIATELY after function
      fails, before calling any other libircclient function.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
The error code.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads. Local error
  code is per IRC context, not per thread.
<h2 class="Ss" title="Ss" id="irc_strerror"><a class="selflink" href="#irc_strerror">irc_strerror</a></h2>
<b>Prototype:</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>const char *
    irc_strerror(int<i>&#x00A0;ircerrno</i>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Parameters:</b>
<table class="tbl">
  <colgroup>
    <col style="width: 14.00ex;"/>
    <col style="width: 44.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>ircerrno</i></td>
    <td>IRC error code returned by <b>irc_errno()</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Description:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function returns the text representation of the given error code.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Return value:</b>
<div style="height: 1.00em;">&#x00A0;</div>
Returns an internal English string with a short description of the error code.
<div style="height: 1.00em;">&#x00A0;</div>
<b>Thread safety:</b>
<div style="height: 1.00em;">&#x00A0;</div>
This function can be called simultaneously from multiple threads.
<h2 class="Ss" title="Ss" id="Types"><a class="selflink" href="#Types">Types</a></h2>
This section describes various types defined by the library.
<h2 class="Ss" title="Ss" id="irc_session_t"><a class="selflink" href="#irc_session_t">irc_session_t</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef struct irc_session_s irc_session_t</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The IRC session handle created by callind <b>irc_create_session()</b>. Most of
  the library function calls expect this handle as a parameter. You can create
  as many handles as you want. Each handle could be used to establish a single
  IRC connection to an IRC server as a single user.
<div style="height: 1.00em;">&#x00A0;</div>
Once the handle is not used anymore, it should be destroyed by calling
  <b>irc_destroy_session()</b>.
<h2 class="Ss" title="Ss" id="irc_dcc_session_t"><a class="selflink" href="#irc_dcc_session_t">irc_dcc_session_t</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef struct irc_dcc_session_s
    irc_dcc_session_t</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This structure describes a DCC session used by libircclient. Its members are
  internal to libircclient, and should not be used directly.
<h2 class="Ss" title="Ss" id="irc_dcc_t"><a class="selflink" href="#irc_dcc_t">irc_dcc_t</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef unsigned int irc_dcc_t</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This type is a DCC session identifier, used to identify the DCC sessions in
  callbacks and various functions.
<h2 class="Ss" title="Ss" id="irc_callbacks_t"><a class="selflink" href="#irc_callbacks_t">irc_callbacks_t</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>typedef struct irc_callbacks_t</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
typedef struct
{
  irc_event_callback_t         event_connect;
  irc_event_callback_t         event_nick;
  irc_event_callback_t         event_quit;
  irc_event_callback_t         event_join;
  irc_event_callback_t         event_part;
  irc_event_callback_t         event_mode;
  irc_event_callback_t         event_umode;
  irc_event_callback_t         event_topic;
  irc_event_callback_t         event_kick;
  irc_event_callback_t         event_channel;
  irc_event_callback_t         event_privmsg;
  irc_event_callback_t         event_notice;
  irc_event_callback_t         event_channel_notice;
  irc_event_callback_t         event_invite;
  irc_event_callback_t         event_ctcp_req;
  irc_event_callback_t         event_ctcp_rep;
  irc_event_callback_t         event_ctcp_action;
  irc_event_callback_t         event_unknown;
  irc_eventcode_callback_t     event_numeric;
  irc_event_dcc_chat_t         event_dcc_chat_req;
  irc_event_dcc_send_t         event_dcc_send_req;
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Describes the event callbacks structure which is used in registering the
  callbacks.
<div style="height: 1.00em;">&#x00A0;</div>
All the communication with the IRC network is based on events. Generally
  speaking, event is anything generated by someone else in the network, or by
  the IRC server itself. &quot;Someone sends you a message&quot;, &quot;Someone
  has joined the channel&quot;, &quot;Someone has quits IRC&quot; - all these
  messages are events.
<div style="height: 1.00em;">&#x00A0;</div>
Every event has its own event handler, which is called when the appropriate
  event is received. You don't have to define all the event handlers; define
  only the handlers for the events you need to intercept, and set the remaining
  handler pointers to NULL.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_connect</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered when the connection to the IRC server is successfully
  established, and the MOTD is received. Depending on the server it may also be
  possible to send the commands before this event.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 19.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>Unused, set to NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>Unused, set to NULL</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_nick</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered when the NICK message is received. It happens when one
  of the users (including you) in one of the channels you are watching (have
  joined) changed their nick.
<div style="height: 1.00em;">&#x00A0;</div>
Changing your own nick will also generate this event. Note that the server may
  change your nick independently, so you must track this event.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 33.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The original nick (may be yours!)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains a new nick.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_quit</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered when the QUIT message is received. It happens when one
  of the users in one of the channels you are watching (have joined)
  disconnected from the IRC server.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 66.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who disconnected</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] is optional, contains the user-specified reason to quit</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_join</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a JOIN message. It happens when a new
  user joins the channel you are watching (have joined). It also happens when
  you joined the new channel.
<div style="height: 1.00em;">&#x00A0;</div>
Note that you may be &quot;forced&quot; to join the channel (and therefore
  receive this event) without issuing the JOIN command. A typical case is when
  the NickServ bot on the server is configured to auto-join you to specific
  channels.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 50.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who joined the channel (this may be you!)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_part</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a PART message. It happens when a user
  leaves the channel you are watching (have joined). It also happens when you
  leave a channel.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 97.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who left the channel (this may be you!)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name params[1] is optional and contains
      the user-specified reason</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_mode</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a channel MODE message. It happens when
  someone changed the mode(s) of the channel you are watching (have joined).
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 201.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who performed the change</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name params[1] contains the channel mode
      changes, such as &quot;+t&quot;, &quot;-i&quot; params[2] optional,
      contains the argument for the channel mode (for example, a nick for the +o
      mode)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_umode</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a user MODE message. It happens when
  your user mode is changed.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 97.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who performed the change</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name params[1] contains the user mode
      changes, such as &quot;+t&quot;, &quot;-i&quot;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_topic</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a TOPIC message. It happens when someone
  changed the topic on the channel you are watching (have joined).
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 78.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who performed the change</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name params[1] optional, contains the new
      topic</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_kick</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a KICK message. It happens when someone
  (including you) kicked someone (including you) from the channel you are
  watching (have joined).
<div style="height: 1.00em;">&#x00A0;</div>
It is possible to kick yourself from the channel.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 140.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who performed the action (may be you)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name params[1] optional, contains the
      nick of the kicked params[2] optional, contains the reason for the
      kick</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_channel</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a PRIVMSG message sent to the channel.
  It happens when someone (but not you) sent a message to the channel you are
  watching (have joined).
<div style="height: 1.00em;">&#x00A0;</div>
Your own messages do not trigger this event. However the server can still
  &quot;force&quot; you to send a message to the channel by generating this
  event.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 81.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who sent a message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name params[1] optional, contains the
      message text</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_privmsg</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a PRIVMSG message sent privately to you.
  It happens when someone sent you a message.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 74.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who sent a message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains your nick params[1] optional, contains the message
      text</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_notice</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a NOTICE message. This message is
  similar to PRIVMSG and matches the <i>event_privmsg</i>. According to RFC
  1459, the only difference between NOTICE and PRIVMSG is that you should NEVER
  automatically reply to NOTICE messages. Unfortunately, this rule is frequently
  violated by IRC servers itself - for example, NICKSERV messages require reply,
  and are sent as NOTICE.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 85.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who sent a message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the target nick name params[1] optional, contains the
      message text</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_channel_notice</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of a NOTICE message. This message is
  similar to PRIVMSG and matches the <i>event_channel</i>. According to RFC
  1459, the only difference between NOTICE and PRIVMSG is that you should NEVER
  automatically reply to NOTICE messages. Unfortunately, this rule is frequently
  violated by IRC servers itself - for example, NICKSERV messages require reply,
  and are sent as NOTICE.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 81.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who sent a message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the channel name params[1] optional, contains the
      message text</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_invite</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of an INVITE message. It happens when
  someone invited you to a channel which has +i (invite-only) mode.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 74.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who invited you</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains your nick params[1] optional, contains the channel
      name</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
See also: <b>irc_cmd_invite()</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_ctcp_req</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of an CTCP request. By default, the
  built-in CTCP request handler is used.
<div style="height: 1.00em;">&#x00A0;</div>
Mirc generates <i>PING</i>, <i>FINGER</i>, <i>VERSION</i>, <i>TIME</i> and
  <i>ACTION</i> messages which are automatically handled by the library if this
  event is not handled by your application. Those messages are replied
  automatically except the ACTION message which triggers
  <i>event_ctcp_action</i> event. If you need to handle more types of the
  message, define this event handler, and check the source code of
  <b>libirc_event_ctcp_internal</b> function to see how to write your own CTCP
  request handler. Note that you must support at least CTCP PING to pass the
  spoof check by some IRC servers.
<div style="height: 1.00em;">&#x00A0;</div>
Also you may find useful this question in FAQ: ref faq4
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 44.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who generated the message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the complete CTCP message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_ctcp_rep</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of an CTCP response. Thus if you generate
  the CTCP message and the remote user responded, this event handler will be
  called.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 44.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who generated the message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the complete CTCP message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_ctcp_action</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of an CTCP ACTION message. It is only
  invoked if you did not define the <i>event_ctcp_req</i> event handler.
<div style="height: 1.00em;">&#x00A0;</div>
Such messages typically look like that in the IRC client:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>::</b></dt>
  <dd class="It-tag">[08:32:55] * Michael is having fun [08:32:55] * Bobby's
      getting jealous</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 48.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who generated the message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>params[0] contains the content of ACTION message</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_unknown</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of an unknown message which is not handled
  by the library.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses <b>irc_event_callback_t</b> callback with the following values:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 47.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>origin</i></td>
    <td>The user who generated the event</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><i>params</i></td>
    <td>Zero or more parameters provided with the event</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_numeric</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered upon receipt of every numeric message from the server.
  The incomplete list of those responses could be found in RFC 1429. This event
  is necessary to handle for any meaningful client.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses the dedicated
<pre>
irc_eventcode_callback_t_
</pre>
 callback. See the callback documentation.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_dcc_chat_req</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered when someone attempts to establish the DCC CHAT with
  you.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses the dedicated <b>irc_event_dcc_chat_t</b> callback. See the
  callback documentation.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>event_dcc_send_req</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This event is triggered when someone attempts to send you the file via DCC SEND.
<div style="height: 1.00em;">&#x00A0;</div>
This event uses the dedicated <b>irc_event_dcc_send_t</b> callback. See the
  callback documentation.
<h2 class="Ss" title="Ss" id="Constants"><a class="selflink" href="#Constants">Constants</a></h2>
This section describes contstants such as options and the error codes.
<h2 class="Ss" title="Ss" id="Errors"><a class="selflink" href="#Errors">Errors</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_OK</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(0): No error
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_INVAL</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(1): An invalid value was given for one of the arguments to a function. For
  example, supplying the NULL value as a channel argument of
  <b>irc_cmd_join()</b> produces this error.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_RESOLV</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(2): The host name supplied for <b>irc_connect()</b> function could not be
  resolved into valid IP address.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_SOCKET</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(3): The new socket could not be created or made non-blocking. Usually means
  that the server is out of resources, or (hopefully not) a bug in libircclient.
  See also <i>faq_err_socket</i>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_CONNECT</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(4): The socket could not connect to the IRC server, or to the destination DCC
  part. Usually means that either the IRC server is down or its address is
  invalid. For DCC the reason usually is the firewall on your or destination
  computer, which refuses DCC transfer.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_CLOSED</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(5): The IRC connection was closed by the IRC server (which could mean that an
  IRC operator just have banned you from the server - test your client before
  connecting to a public server), or the DCC connection was closed by remote
  peer - for example, the other side just terminates the IRC application.
  Usually it is not an error.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_NOMEM</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(6): There are two possible reasons for this error. First is that memory could
  not be allocated for libircclient internal use, and this error is usually
  fatal. Second reason is that the command buffer (which queues the commands
  ready to be sent to the IRC server) is full, and could not accept more
  commands yet. In the last case you should just wait, and repeat the command
  later.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_ACCEPT</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(7): A DCC chat/send connection from the remote peer could not be accepted.
  Either the connection was just terminated before it is accepted, or there is a
  bug in libircclient.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_NODCCSEND</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(9): A filename supplied to <b>irc_dcc_sendfile()</b> could not be sent. Either
  is is not a regular file (a directory or a socket, for example), or it could
  not be read. See also <b>LIBIRC_ERR_OPENFILE</b>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_READ</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(10): Either a DCC file could not be read (for example, was truncated during
  sending), or a DCC socket returns a read error, which usually means that the
  network connection is terminated.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_WRITE</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(11): Either a DCC file could not be written (for example, there is no free
  space on disk), or a DCC socket returns a write error, which usually means
  that the network connection is terminated.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_STATE</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(12): The function is called when it is not allowed to be called. For example,
  <b>irc_cmd_join()</b> was called before the connection to IRC server succeed,
  and <b>event_connect</b> is called.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_TIMEOUT</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(13): The DCC request is timed out. There is a timer for each DCC request, which
  tracks connecting, accepting and non-accepted/declined DCC requests. For every
  request this timer is currently set to 60 seconds. If the DCC request was not
  connected, accepted or declined during this time, it will be terminated with
  this error.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_OPENFILE</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(14): The file specified in <b>irc_dcc_sendfile()</b> could not be opened.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_TERMINATED</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(15): The connection to the IRC server was terminated.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_NOIPV6</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(16): The function which requires IPv6 support was called, but the IPv6 support
  was not compiled into the application
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_SSL_NOT_SUPPORTED</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(17): The SSL connection was required but the library was not compiled with SSL
  support
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_SSL_INIT_FAILED</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(18): The SSL library could not be initialized.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_CONNECT_SSL_FAILED</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(19): SSL handshare failed when attempting to connect to the server. Typically
  this means you're trying to use SSL but attempting to connect to a non-SSL
  port.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_ERR_SSL_CERT_VERIFY_FAILED</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(20): The server is using an invalid or the self-signed certificate. Use
  <b>LIBIRC_OPTION_SSL_NO_VERIFY</b> option to connect to it.
<h2 class="Ss" title="Ss" id="Options"><a class="selflink" href="#Options">Options</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_OPTION_DEBUG</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If set, enables additional debug output which goes to STDOUT.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_OPTION_STRIPNICKS</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If set, strips the event origins automatically. Every event has an origin (i.e.
  who originated the event). The origin usually looks like
  <i>nick!host@ircserver</i>, i.e. like <i>tim!home@irc.server.net</i>. Such
  origins can not be used in IRC commands, and need to be stripped (i.e. host
  and server part should be cut off) before using. This can be done either
  manually by calling <b>irc_target_get_nick()</b>, or automatically for all the
  events if this option is set.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>LIBIRC_OPTION_SSL_NO_VERIFY</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
By default the SSL connection is authenticated by verifying that the certificate
  presented by the server is signed by a known trusted certificate authority.
  Since those typically cost money, some IRC servers use the self-signed
  certificates. They provide the benefits of the SSL connection but since they
  are not signed by the Certificate Authority, their authencity cannot be
  verified. This option, if set, disables the certificate verification - the
  library will accept any certificate presented by the server.
<div style="height: 1.00em;">&#x00A0;</div>
This option must be set before the <b>irc_connect</b> function is called.
<h1 class="Sh" title="Sh" id="APPENDIX"><a class="selflink" href="#APPENDIX">APPENDIX</a></h1>
<h2 class="Ss" title="Ss" id="Frequently_asked_questions"><a class="selflink" href="#Frequently_asked_questions">Frequently
  asked questions</a></h2>
<h2 class="Ss" title="Ss" id="Why_do_I_get_a_LIBIRC_ERR_SOCKET_error_under_Win32_when_using_a_static_library?"><a class="selflink" href="#Why_do_I_get_a_LIBIRC_ERR_SOCKET_error_under_Win32_when_using_a_static_library?">Why
  do I get a LIBIRC_ERR_SOCKET error under Win32 when using a static
  library?</a></h2>
Because on Win32 you have to initialize the Winsock API before using it:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
WSADATA wsaData;
<div class="Pp"></div>
if ( WSAStartup ( MAKEWORD (2, 2), &amp;wsaData) != 0 )
    // report an error
<div class="Pp"></div>
// Now you can use libircclient
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
You have to do it ONCE in your application, and since libircclient does not know
  whether you already initialized it or not, it does not contain any Winsock
  initialization code.
<h2 class="Ss" title="Ss" id="What_does_it_mean_that_the_IRC_protocol_is_event-based?"><a class="selflink" href="#What_does_it_mean_that_the_IRC_protocol_is_event-based?">What
  does it mean that the IRC protocol is event-based?</a></h2>
The IRC protocol itself is asynchronous and server-driven. For you, this means
  the following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For any IRC command, it is not possible to obtain an
      immediate response whether the command succeed or not. Instead the server
      will send the reply in a short (or long) period of time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For some IRC command there is no &#x2018;success&#x2019;
      response at all. For example, when you send a text message, IRC server
      will not send anything to confirm that the message is already sent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can send several commands to the IRC server, and then
      receive several replies regarding every command. The order of the replies
      you receive is generally undefined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A lot of IRC events sent to you is generated by other
      users, or the IRC server itself, and are sent to you just when they are
      generated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Long lists (for example, channel lists) are also sent as
      events. Moreover, these events could be separated by other events (message
      or notices). And it is your responsibility to separate the data (using
      event codes), and use some sort of data structure that will hold it until
      the data is complete. It is not possible to simply query the list of
      channels, and expect that its content will immediately arrive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You may send the request, and not receive a response in
      case of success (such as when you send a message). You may send the
      request and it will only succeed when you receive a response (which may be
      after you receive ten more unrelated events). Or you can receive a
      response without even sending a request, as it is the case with JOIN - it
      is possible for the server to JOIN you to a specific channel
    implicitly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You should be prepared to expect the unexpected from the
      IRC server. For example, the server can change your nick (seen on most
      servers, which use nickserv authentication. You can be
      &#x201C;forced&#x201D; to join the channel, to say something, to leave a
      channel, to change your usermode and so on. Listen what IRC server tells
      you, and do so.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Why_the_irc_cmd_join_function_does_not_return_an_error?"><a class="selflink" href="#Why_the_irc_cmd_join_function_does_not_return_an_error?">Why
  the irc_cmd_join function does not return an error?</a></h2>
A typical example is the <b>irc_cmd_join()</b> call always returns success even
  when you attempt to join a password-protected channel. Then some time later
  the IRC server returns an error. This is because the irc_cmd family of
  functions return success when the command is sent to the IRC server. The
  asynchronous nature of IRC makes it impossible to obtain the command result
  immediately. Please read the question above.
<h2 class="Ss" title="Ss" id="How_to_register/auth_with_NICKSERV?"><a class="selflink" href="#How_to_register/auth_with_NICKSERV?">How
  to register/auth with NICKSERV?</a></h2>
There is no &#x2018;standard&#x2019; way. NICKSERV, CHANSERV and so on are not
  specified by the RFC. They are IRC extensions which behave exactly like the
  other IRC users but with more power. Typically their messages are sent via
  Notice events, so you can use following algorithm to handle Nickserv
  registration:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
static void event_notice (irc_session_t * session, const char * event,
                                                 const char * origin, const char ** params, unsigned int count)
{
        char buf[256];
<div class="Pp"></div>
        if ( !origin )
                return;
<div class="Pp"></div>
        if ( strcasecmp (origin, &quot;nickserv&quot;) )
                return;
<div class="Pp"></div>
        if ( strstr (params[1], &quot;This nick is not registered&quot;) == params[1] )
        {
                sprintf (buf, &quot;REGISTER %s NOMAIL&quot;, gCfg.irc_nickserv_password);
                irc_cmd_msg(session, &quot;nickserv&quot;, buf);
        }
        else if ( strstr (params[1], &quot;This nickname is registered and protected&quot;) == params[1] )
        {
                sprintf (buf, &quot;IDENTIFY %s&quot;, gCfg.irc_nickserv_password);
                irc_cmd_msg(session, &quot;nickserv&quot;, buf);
        }
        else if ( strstr (params[1], &quot;Password accepted - you are now recognized&quot;) == params[1] )
                printf (&quot;Nickserv authentication succeed.&quot;);
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The idea is to parse the messages sent from NICKSERV, and if they&#x2019;re
  matched the specific patterns, react on them appropriately.
<h2 class="Ss" title="Ss" id="What_is_CTCP?"><a class="selflink" href="#What_is_CTCP?">What
  is CTCP?</a></h2>
CTCP abbreviature is deciphered as &#x201C;Client-to-Client Protocol&#x201D;. It
  is used between the IRC clients to query the remote client for some data, or
  to send some information &#x2013; for example, /me messages are sent via CTCP.
<div style="height: 1.00em;">&#x00A0;</div>
There is no standard list of possible CTCP requests, and different IRC clients
  often add their own CTCP codes. The built-in handler reacts on TIME, VERSION,
  PING and FINGER CTCP queries. If you need to react on other requests,
  you&#x2019;ll have to write your own CTCP handler. See the source code of
  libirc_event_ctcp_internal function to get an idea how to write it.
<h2 class="Ss" title="Ss" id="When_I_am_made_a_chanop_(+o)_why_do_I_not_receive_the_event_umode?"><a class="selflink" href="#When_I_am_made_a_chanop_(+o)_why_do_I_not_receive_the_event_umode?">When
  I am made a chanop (+o) why do I not receive the event_umode?</a></h2>
Becoming a channel operator channes the <b>channel mode</b>, not user mode.
  Therefore you will receive <b>event_mode</b> and not <b>event_umode</b>
<div style="height: 1.00em;">&#x00A0;</div>
If you receive the event_umode with +o this means your user is an IRC server
  operator.
<h2 class="Ss" title="Ss" id="What_if_my_application_uses_epoll?"><a class="selflink" href="#What_if_my_application_uses_epoll?">What
  if my application uses epoll?</a></h2>
The library only directly supports the select()-based loops for historic
  reasons, so epoll and other polling methods are not supported directly by the
  library. However but if necessart, it could be emulated by converting
  descriptors between select and epoll as following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Call irc_add_select_descriptors with an empty FD_SET</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Extract the descriptors from the fd_set arrays (remember
      fd_array is a bitarray, not the value array). There may be more than one
      descriptor in case there are DCC sessions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Pass those descriptors to poll/epoll using relevant events
      (i.e. use the EPOLLIN for the descriptors in the <i>in_set</i>)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">For those descriptors which triggered the events, fill up
      the relevant in_set and out_set structures (again, remember the bitmasks!)
      and pass them to <b>irc_process_select_descriptors()</b></dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
While this is cumbersome, the operations are very simple (basically bitmask
  operations on a small structure) and will not add any significant slowdown to
  your application.
<h2 class="Ss" title="Ss" id="GNU_LESSER_GENERAL_PUBLIC_LICENSE"><a class="selflink" href="#GNU_LESSER_GENERAL_PUBLIC_LICENSE">GNU
  LESSER GENERAL PUBLIC LICENSE</a></h2>
Version 3, 29 June 2007
<div style="height: 1.00em;">&#x00A0;</div>
Copyright &#x00A9; 2007 Free Software Foundation, Inc. &lt;
  <i>http://fsf.org/</i>&gt;
<div style="height: 1.00em;">&#x00A0;</div>
Everyone is permitted to copy and distribute verbatim copies of this license
  document, but changing it is not allowed.
<div style="height: 1.00em;">&#x00A0;</div>
This version of the GNU Lesser General Public License incorporates the terms and
  conditions of version 3 of the GNU General Public License, supplemented by the
  additional permissions listed below.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">0.</dt>
  <dd class="It-tag">Additional Definitions.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
As used herein, &#x201C;this License&#x201D; refers to version 3 of the GNU
  Lesser General Public License, and the &#x201C;GNU GPL&#x201D; refers to
  version 3 of the GNU General Public License.
<div style="height: 1.00em;">&#x00A0;</div>
&#x201C;The Library&#x201D; refers to a covered work governed by this License,
  other than an Application or a Combined Work as defined below.
<div style="height: 1.00em;">&#x00A0;</div>
An &#x201C;Application&#x201D; is any work that makes use of an interface
  provided by the Library, but which is not otherwise based on the Library.
  Defining a subclass of a class defined by the Library is deemed a mode of
  using an interface provided by the Library.
<div style="height: 1.00em;">&#x00A0;</div>
A &#x201C;Combined Work&#x201D; is a work produced by combining or linking an
  Application with the Library. The particular version of the Library with which
  the Combined Work was made is also called the &#x201C;Linked Version&#x201D;.
<div style="height: 1.00em;">&#x00A0;</div>
The &#x201C;Minimal Corresponding Source&#x201D; for a Combined Work means the
  Corresponding Source for the Combined Work, excluding any source code for
  portions of the Combined Work that, considered in isolation, are based on the
  Application, and not on the Linked Version.
<div style="height: 1.00em;">&#x00A0;</div>
The &#x201C;Corresponding Application Code&#x201D; for a Combined Work means the
  object code and/or source code for the Application, including any data and
  utility programs needed for reproducing the Combined Work from the
  Application, but excluding the System Libraries of the Combined Work. 1.
  Exception to Section 3 of the GNU GPL.
<div style="height: 1.00em;">&#x00A0;</div>
You may convey a covered work under sections 3 and 4 of this License without
  being bound by section 3 of the GNU GPL. 2. Conveying Modified Versions.
<div style="height: 1.00em;">&#x00A0;</div>
If you modify a copy of the Library, and, in your modifications, a facility
  refers to a function or data to be supplied by an Application that uses the
  facility (other than as an argument passed when the facility is invoked), then
  you may convey a copy of the modified version:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">a.</dt>
  <dd class="It-tag">under this License, provided that you make a good faith
      effort to ensure that, in the event an Application does not supply the
      function or data, the facility still operates, and performs whatever part
      of its purpose remains meaningful, or</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b.</dt>
  <dd class="It-tag">under the GNU GPL, with none of the additional permissions
      of this License applicable to that copy.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Object Code Incorporating Material from Library Header
      Files.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The object code form of an Application may incorporate material from a header
  file that is part of the Library. You may convey such object code under terms
  of your choice, provided that, if the incorporated material is not limited to
  numerical parameters, data structure layouts and accessors, or small macros,
  inline functions and templates (ten or fewer lines in length), you do both of
  the following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">a.</dt>
  <dd class="It-tag">Give prominent notice with each copy of the object code
      that the Library is used in it and that the Library and its use are
      covered by this License.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b.</dt>
  <dd class="It-tag">Accompany the object code with a copy of the GNU GPL and
      this license document.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">Combined Works.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
You may convey a Combined Work under terms of your choice that, taken together,
  effectively do not restrict modification of the portions of the Library
  contained in the Combined Work and reverse engineering for debugging such
  modifications, if you also do each of the following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">a.</dt>
  <dd class="It-tag">Give prominent notice with each copy of the Combined Work
      that the Library is used in it and that the Library and its use are
      covered by this License.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b.</dt>
  <dd class="It-tag">Accompany the Combined Work with a copy of the GNU GPL and
      this license document.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">c.</dt>
  <dd class="It-tag">For a Combined Work that displays copyright notices during
      execution, include the copyright notice for the Library among these
      notices, as well as a reference directing the user to the copies of the
      GNU GPL and this license document.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">d.</dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 3.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Do one of the following:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">0.</dt>
  <dd class="It-tag">Convey the Minimal Corresponding Source under the terms of
      this License, and the Corresponding Application Code in a form suitable
      for, and under terms that permit, the user to recombine or relink the
      Application with a modified version of the Linked Version to produce a
      modified Combined Work, in the manner specified by section 6 of the GNU
      GPL for conveying Corresponding Source.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Use a suitable shared library mechanism for linking with
      the Library. A suitable mechanism is one that (a) uses at run time a copy
      of the Library already present on the user's computer system, and (b) will
      operate properly with a modified version of the Library that is
      interface-compatible with the Linked Version.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag">e.</dt>
  <dd class="It-tag">Provide Installation Information, but only if you would
      otherwise be required to provide such information under section 6 of the
      GNU GPL, and only to the extent that such information is necessary to
      install and execute a modified version of the Combined Work produced by
      recombining or relinking the Application with a modified version of the
      Linked Version. (If you use option 4d0, the Installation Information must
      accompany the Minimal Corresponding Source and Corresponding Application
      Code. If you use option 4d1, you must provide the Installation Information
      in the manner specified by section 6 of the GNU GPL for conveying
      Corresponding Source.)</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">Combined Libraries.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
You may place library facilities that are a work based on the Library side by
  side in a single library together with other library facilities that are not
  Applications and are not covered by this License, and convey such a combined
  library under terms of your choice, if you do both of the following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">a.</dt>
  <dd class="It-tag">Accompany the combined library with a copy of the same work
      based on the Library, uncombined with any other library facilities,
      conveyed under the terms of this License.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b.</dt>
  <dd class="It-tag">Give prominent notice with the combined library that part
      of it is a work based on the Library, and explaining where to find the
      accompanying uncombined form of the same work.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">6.</dt>
  <dd class="It-tag">Revised Versions of the GNU Lesser General Public
    License.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The Free Software Foundation may publish revised and/or new versions of the GNU
  Lesser General Public License from time to time. Such new versions will be
  similar in spirit to the present version, but may differ in detail to address
  new problems or concerns.
<div style="height: 1.00em;">&#x00A0;</div>
Each version is given a distinguishing version number. If the Library as you
  received it specifies that a certain numbered version of the GNU Lesser
  General Public License &#x201C;or any later version&#x201D; applies to it, you
  have the option of following the terms and conditions either of that published
  version or of any later version published by the Free Software Foundation. If
  the Library as you received it does not specify a version number of the GNU
  Lesser General Public License, you may choose any version of the GNU Lesser
  General Public License ever published by the Free Software Foundation.
<div style="height: 1.00em;">&#x00A0;</div>
If the Library as you received it specifies that a proxy can decide whether
  future versions of the GNU Lesser General Public License shall apply, that
  proxy's public statement of acceptance of any version is permanent
  authorization for you to choose that version for the Library.
<h2 class="Ss" title="Ss" id="Indices_and_tables"><a class="selflink" href="#Indices_and_tables">Indices
  and tables</a></h2>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>genindex</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>modindex</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>search</i></dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
George Yunaev
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2013, George Yunaev</div>
<table class="foot">
  <tr>
    <td class="foot-date">May 9, 2014</td>
    <td class="foot-os">1.7</td>
  </tr>
</table>
</body>
</html>
