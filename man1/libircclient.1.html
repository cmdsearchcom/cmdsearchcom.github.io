<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:21:49 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>LIBIRCCLIENT(1) Libircclient LIBIRCCLIENT(1)</p>

<p style="margin-top: 1em">NAME <br>
libircclient - Libircclient Documentation</p>

<p style="margin-top: 1em">INTRODUCTION <br>
Introduction <br>
Overview <br>
Libircclient is a small but extremely powerful library which
implements the client IRC protocol. It is designed to be
small, fast, portable and compatible with the RFC standards
<br>
as well as non-standard but popular features. It is perfect
for building the IRC clients and bots.</p>

<p style="margin-top: 1em">Features <br>
&Acirc;&middot; Comprehensive C API;</p>

<p style="margin-top: 1em">&Acirc;&middot; Full coverage of
the IRC protocol using providing functions;</p>

<p style="margin-top: 1em">&Acirc;&middot; Supports
multiple simultaneous connection to different IRC servers or
even to the same server;</p>

<p style="margin-top: 1em">&Acirc;&middot; Supports both
plain and SSL connections to the IRC servers with the
optional certificate check;</p>

<p style="margin-top: 1em">&Acirc;&middot; Full
multi-threading support, the library is thread-safe;</p>

<p style="margin-top: 1em">&Acirc;&middot; All the
processing could be handled by a single thread even if
multiple connections are used;</p>

<p style="margin-top: 1em">&Acirc;&middot; Non-blocking,
asynchronous event-based interface implemented with
callbacks;</p>

<p style="margin-top: 1em">&Acirc;&middot; Extra support
for the socket-based applications, which use select();</p>

<p style="margin-top: 1em">&Acirc;&middot; CTCP support
with optional build-in reply code;</p>

<p style="margin-top: 1em">&Acirc;&middot; Supports CTCP
PING necessary to pass the &acirc;spoof check&acirc;
implemented by most IRC servers;</p>

<p style="margin-top: 1em">&Acirc;&middot; Flexible DCC
support, including both DCC chat, and DCC file transfer;</p>

<p style="margin-top: 1em">&Acirc;&middot; Can both
initiate and react to initiated DCC;</p>

<p style="margin-top: 1em">&Acirc;&middot; Can accept or
decline DCC sessions asynchronously;</p>

<p style="margin-top: 1em">&Acirc;&middot; Written in plain
C, very small binary size (around 30K depending on
platform);</p>

<p style="margin-top: 1em">&Acirc;&middot; Compatible all
tested IRC clients;</p>

<p style="margin-top: 1em">&Acirc;&middot; Free software
licensed under the LGPLv3 license;</p>

<p style="margin-top: 1em">&Acirc;&middot; Supports Linux
as well as any POSIX-compliant Unix, Mac OS X and Microsoft
Windows;</p>

<p style="margin-top: 1em">&Acirc;&middot; Supports
32/64bit architectures as well as non-x86 architectures;</p>

<p style="margin-top: 1em">&Acirc;&middot; IPv6 support
(optional, must be compiled in);</p>

<p style="margin-top: 1em">&Acirc;&middot; OpenSSL support
(optional, must be compiled in);</p>

<p style="margin-top: 1em">&Acirc;&middot; Cocoa interface
by Nathan Ollerenshaw;</p>

<p style="margin-top: 1em">&Acirc;&middot; Comprehensive
documentation, examples and the FAQ;</p>

<p style="margin-top: 1em">Known issues <br>
Even though possible by using multiple sessions, the library
is not suitable to connect to a large number of IRC servers
simultaneously. If you still want to use it, you&rsquo;d
have <br>
to overcome the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; You cannot use
the main loop in irc_run() because it only supports one
session. You would have to use
irc_add_select_descriptors()</p>

<p style="margin-top: 1em">&Acirc;&middot; You&rsquo;d have
to handle reconnections separately by processing the
relevant irc_process_select_descriptors() return values</p>

<p style="margin-top: 1em">&Acirc;&middot; If you wish to
use poll/epoll() instead of select() you&rsquo;d have to
write more logic as it is not directly supported. See the
FAQ.</p>

<p style="margin-top: 1em">&Acirc;&middot; The library is
not optimized to have a low per-connection memory footprint,
each non-SSL connection uses at least 4K, with around 32K
per connection for SSL.</p>

<p style="margin-top: 1em">Author <br>
This library is created by George Yunaev, copyright
2004-2013.</p>

<p style="margin-top: 1em">License <br>
Libircclient is licensed under Lesser General Public License
version 3 or higher. The complete license text is provided
in the Appendix.</p>

<p style="margin-top: 1em">INTEGRATION <br>
Integration <br>
Requirements <br>
Supported operating systems and compilers <br>
The library has been extensively tested on Linux x86 and
x86_64. It has also been tested on Solaris x86, Linux on ARM
and Linux on MIPS platforms, on Mac OS X on x86 and on
vari&acirc; <br>
ous versions of Microsoft Windows.</p>

<p style="margin-top: 1em">Compilation <br>
On Linux, FreeBSD and Mac OS X the library has to be
compiled and installed before use unless you use a
precompiled package provided by your operating system
distribution. If it <br>
is provided, you are recommended to use it as it would be
updated from the central repository when the bugs are
fixed.</p>

<p style="margin-top: 1em">On Microsoft Windows the
official library binaries are provided, so you do not have
to build it. Unless you have experience building with
Cygwin, you&rsquo;re advised not to build from <br>
source and use the official binary.</p>

<p style="margin-top: 1em">Required libraries <br>
The library depends only on libc (glibc-devel on Linux) and
gcc, although the examples require also libstdc++
(libstdc++-devel) and g++. Minimum supported version is
glibc 2.2, <br>
although if IPv6 is requested, at least glibc 2.4 is
required.</p>

<p style="margin-top: 1em">If the library is built with SSL
support, the openssl development package (openssl-devel)
needs to be installed.</p>

<p style="margin-top: 1em">On Microsoft Windows the Cygwin
with necessary development packages must be installed (and
openssl-devel as well).</p>

<p style="margin-top: 1em">Compiling <br>
The library is configured and built the standard Unix
way:</p>

<p style="margin-top: 1em">./configure [--enable-openssl]
[--enable-ipv6] <br>
make</p>

<p style="margin-top: 1em">Installing <br>
Although no install is necessary to use the libraries, the
install target is provided for convenience and could be
invoked via sudo make install</p>

<p style="margin-top: 1em">Linking <br>
Link your application with either libircclient.a or
libircclient.so depending on your needs. If you use the
system-provided library, please link with
libircclient.so.</p>

<p style="margin-top: 1em">If you have built the library
with SSL support, you will need to link with OpenSSL
libraries; add -lcrypto -lssl to your LDFLAGS</p>

<p style="margin-top: 1em">On Microsoft Windows please link
with libircclient.lib which implicitly links with
libircclient.dll</p>

<p style="margin-top: 1em">Coding <br>
Initialization <br>
Include the headers <br>
Before using the library you need to include the library
header libircclient.h. You may also want to include
libirc_rfcnumeric.h which provides the RFC codes:</p>

<p style="margin-top: 1em">#include
&quot;libircclient.h&quot; <br>
#include &quot;libirc_rfcnumeric.h&quot;</p>

<p style="margin-top: 1em">Create event handlers <br>
Unlike most network protocols such as HTTP or SMTP, the IRC
protocol is event-based. The events come from server
asynchronously. Some events are triggered by your action
(such as <br>
joining the channel or changing your nick), some are
triggered by other IRC users (such as sending you a
message), and some are triggered by the IRC server itself
(such as send&acirc; <br>
ing operation notes or invoking NickServ services).</p>

<p style="margin-top: 1em">Libircclient helps handling
those events by providing the event handling structure. It
declares the events you can define in your application, and
when such event is received <br>
from the server, the appropriate callback will be called.
The number of events you need to handle depending on the
complexity of your client and the functionality it
supports.</p>

<p style="margin-top: 1em">Generally there are only two
events you must handle to provide a bare minimum
functionality: event_connect and event_numeric. However it
is recommended to create an event dump <br>
function and use it for all unused events to make sure you
do not miss an important event because you expected a wrong
one. See function dump_event in the file
examples/irctest.c</p>

<p style="margin-top: 1em">Windows-specific initialization
<br>
If you link with the static library on Microsoft Windows,
you need to initialize the Winsock2 library before calling
the library functions. It could be done by following:</p>

<p style="margin-top: 1em">WSADATA wsaData;</p>

<p style="margin-top: 1em">if ( WSAStartup ( MAKEWORD (2,
2), &amp;wsaData) != 0 ) <br>
// report an error</p>

<p style="margin-top: 1em">However if you link with the
dynamic library (libircclient.dll) which is default if you
use the official build, this is not needed because the DLL
initializes it automatically on <br>
load.</p>

<p style="margin-top: 1em">Create an IRC session <br>
To use the library at least one IRC session needs to be
created. One session could be used to establish a single
connection to one IRC server for one nick. However more than
one <br>
session could be created if needed.</p>

<p style="margin-top: 1em">To create a session, call the
irc_create_session() function:</p>

<p style="margin-top: 1em">// The IRC callbacks structure
<br>
irc_callbacks_t callbacks;</p>

<p style="margin-top: 1em">// Init it <br>
memset ( &amp;callbacks, 0, sizeof(callbacks) );</p>

<p style="margin-top: 1em">// Set up the mandatory events
<br>
callbacks.event_connect = event_connect; <br>
callbacks.event_numeric = event_numeric;</p>

<p style="margin-top: 1em">// Set up the rest of events</p>

<p style="margin-top: 1em">// Now create the session <br>
irc_session_t * session = irc_create_session( &amp;callbacks
);</p>

<p style="margin-top: 1em">if ( !session ) <br>
// Handle the error</p>

<p style="margin-top: 1em">This code could be repeated as
many times as needed to create multiple sessions. The same
callback structure could be reused for multiple
sessions.</p>

<p style="margin-top: 1em">Set options <br>
Besides debugging there are two options you may need to use.
The LIBIRC_OPTION_STRIPNICKS enables automatic parsing of
nicknames, and since it is hard to imagine the case when it
<br>
should not be enabled, we enable it:</p>

<p style="margin-top: 1em">irc_option_set( session,
LIBIRC_OPTION_STRIPNICKS );</p>

<p style="margin-top: 1em">The second option you may need
if you use SSL connections and plan to connect to the
servers which use self-signed certificates. See the
documentation for <br>
LIBIRC_OPTION_SSL_NO_VERIFY</p>

<p style="margin-top: 1em">Connect to the server <br>
To initiate the connection to the IRC server, call the
irc_connect() function:</p>

<p style="margin-top: 1em">// Connect to a regular IRC
server <br>
if ( irc_connect (session, &quot;irc.example.com&quot;,
6667, 0, &quot;mynick&quot;, &quot;myusername&quot;,
&quot;myrealname&quot; ) ) <br>
// Handle the error: irc_strerror() and irc_errno()</p>

<p style="margin-top: 1em">To initiate the connection to
the IRC server over SSL, call the irc_connect() function and
prefix the host name or IP address with a hash symbol:</p>

<p style="margin-top: 1em">// Connect to the SSL server;
#192.168.1.1 is also possible <br>
if ( irc_connect (session, &quot;#irc.example.com&quot;,
6669, 0, &quot;mynick&quot;, &quot;myusername&quot;,
&quot;myrealname&quot; ) ) <br>
// Handle the error: irc_strerror() and irc_errno()</p>

<p style="margin-top: 1em">This function only initiates the
connection, so when it successfully returns the connection
is only initiated, but not established yet. Then one of the
following happens after <br>
you invoke the networking handler:</p>

<p style="margin-top: 1em">&Acirc;&middot; If the
connection is established, you will receive the
event_connect - this is why it is important to handle it</p>

<p style="margin-top: 1em">&Acirc;&middot; If the
connection failed, the networking handler function will
return failure</p>

<p style="margin-top: 1em">Connect to the IPv6 server <br>
To initiate the connection to the IPv6 server, call the
irc_connect6() function:</p>

<p style="margin-top: 1em">if ( irc_connect6 (session,
&quot;2001:0db8:85a3:0042:1000:8a2e:0370:7334&quot;, 6669,
0, &quot;mynick&quot;, &quot;myusername&quot;,
&quot;myrealname&quot; ) ) <br>
// Handle the error: irc_strerror() and irc_errno()</p>

<p style="margin-top: 1em">The rest of the details,
including the return value and the SSL are the same as with
regular connect.</p>

<p style="margin-top: 1em">Start the networking loop <br>
To let the library handle the events, there are two
scenarios. You can either invoke the built-in networking
loop which will handle the networking and call your events,
or you <br>
can write your own loop.</p>

<p style="margin-top: 1em">Invoking the build-in networking
loop is simpler but limited. Since it loops until the
connection terminates, it is not an option for a GUI
application (unless you start the loop <br>
in a separate thread which you can do). And since this loop
only can handle one session, it is impossible to use it if
you want to handle multiple IRC sessions. In those cases
<br>
the custom networking loop, described below, should be
used.</p>

<p style="margin-top: 1em">To start the event loop call the
irc_run() function:</p>

<p style="margin-top: 1em">if ( irc_run (s) ) <br>
// Either the connection to the server could not be
established or terminated. See irc_errno()</p>

<p style="margin-top: 1em">Remember that irc_run() call
will not return until the server connection is not active
anymore.</p>

<p style="margin-top: 1em">Use the custom networking loop
<br>
If you use multiple sessions or have your own socket
handler, you can use the custom networking loop. In this
case your application must be select()-based (see the FAQ if
you <br>
want to use other polling methods). And you need to run the
following loop:</p>

<p style="margin-top: 1em">// Make sure that all the IRC
sessions are connected <br>
if ( !irc_is_connected(session) ) <br>
// reconnect it, or abort</p>

<p style="margin-top: 1em">// Create the structures for
select() <br>
struct timeval tv; <br>
fd_set in_set, out_set; <br>
int maxfd = 0;</p>

<p style="margin-top: 1em">// Wait 0.25 sec for the events
- you can wait longer if you want to, but the library has
internal timeouts <br>
// so it needs to be called periodically even if there are
no network events <br>
tv.tv_usec = 250000; <br>
tv.tv_sec = 0;</p>

<p style="margin-top: 1em">// Initialize the sets <br>
FD_ZERO (&amp;in_set); <br>
FD_ZERO (&amp;out_set);</p>

<p style="margin-top: 1em">// Add your own descriptors you
need to wait for, if any <br>
...</p>

<p style="margin-top: 1em">// Add the IRC session
descriptors - call irc_add_select_descriptors() for each
active session <br>
irc_add_select_descriptors( session, &amp;in_set,
&amp;out_set, &amp;maxfd );</p>

<p style="margin-top: 1em">// Call select() <br>
if ( select (maxfd + 1, &amp;in_set, &amp;out_set, 0,
&amp;tv) &lt; 0 ) <br>
// Error</p>

<p style="margin-top: 1em">// You may also check if any
descriptor is active, but again the library needs to handle
internal timeouts, <br>
// so you need to call irc_process_select_descriptors() for
each session at least once in a few seconds <br>
...</p>

<p style="margin-top: 1em">// Call
irc_process_select_descriptors() for each session with the
descriptor set <br>
if ( irc_process_select_descriptors (session, &amp;in_set,
&amp;out_set) ) <br>
// The connection failed, or the server disconnected. Handle
it.</p>

<p style="margin-top: 1em">// Do it again</p>

<p style="margin-top: 1em">Channels and users <br>
Before calling any of those functions make sure you have
connected to the server.</p>

<p style="margin-top: 1em">Join and leave a channel <br>
To join the channel call the irc_cmd_join() function with
the channel name:</p>

<p style="margin-top: 1em">// Join the channel #linux <br>
if ( irc_cmd_join( session, &quot;#linux&quot;, 0 ) ) <br>
// most likely connection error</p>

<p style="margin-top: 1em">// Join the channel $science
protected by the secret key *superpassword* <br>
if ( irc_cmd_join( session, &quot;$science&quot;,
&quot;superpassword&quot; ) ) <br>
// most likely connection error</p>

<p style="margin-top: 1em">You can join as many channels as
you want, although the serer may restrict the number of
channels you can join simultaneously.</p>

<p style="margin-top: 1em">If the join was successful you
will receive the event_join event. You need to wait for this
event before you can perform any channel operations (such as
sending the messages). <br>
However you do NOT have to wait for this event to issue a
second JOIN command as shown in the example above.</p>

<p style="margin-top: 1em">If the join was not successful,
you will receive the error via event_numeric.</p>

<p style="margin-top: 1em">To leave the channel call the
irc_cmd_part() function with the channel name:</p>

<p style="margin-top: 1em">// Leave the channel #linux <br>
if ( irc_cmd_part( session, &quot;#linux&quot; ) ) <br>
// most likely connection error</p>

<p style="margin-top: 1em">// Leave the channel $science
<br>
if ( irc_cmd_part( session, &quot;$science&quot; ) ) <br>
// most likely connection error</p>

<p style="margin-top: 1em">Send a message to a channel or
to a user <br>
After you have joined the channel, you can send a message to
the channel by using the irc_cmd_msg() function with the
channel name:</p>

<p style="margin-top: 1em">// Say &quot;Hi!&quot; to
everyone in the channel #linux <br>
if ( irc_cmd_msg( session, &quot;#linux&quot;,
&quot;Hi!&quot; ) ) <br>
// most likely connection error</p>

<p style="margin-top: 1em">Technically the protocol does
not require one to join the channel to send the messages
into the channel. However most servers by default set the
channel mode which prevents the <br>
users who did not join the channel from sending the message
into the channel.</p>

<p style="margin-top: 1em">Same function is used to send a
&quot;private&quot; message to another user. The
&quot;private&quot; messages do not go through the channels,
but they still go through the IRC server (sometime
mul&acirc; <br>
tiple servers) and can be seen or even logged by the IRC
network operators.</p>

<p style="margin-top: 1em">// Say &quot;Hi!&quot; to IRC
user john <br>
if ( irc_cmd_msg( session, &quot;john&quot;, &quot;Hi!&quot;
) ) <br>
// most likely connection error</p>

<p style="margin-top: 1em">If the message was sent
successfully you will not receive any confirmation or event.
You will only receive the error via event_numeric if the
message was not sent.</p>

<p style="margin-top: 1em">Receive messages from a channel
or from a user <br>
You receive the channel messages by handling the
event_channel. Each time someone says something in the
channel this event is called.</p>

<p style="margin-top: 1em">You receive the
&quot;private&quot; messages from other users by handling
the event_privmsg.</p>

<p style="margin-top: 1em">Those event handlers should be
created in your application and passed to the library when
you create an IRC session</p>

<p style="margin-top: 1em">Send an action message <br>
&quot;Action&quot; messages, also called /me messages, are
specially formatted CTCP messages. However the library
contains a special function to send them, irc_cmd_me().
Actions sent by <br>
other people are handled by the event_ctcp_action event.</p>

<p style="margin-top: 1em">Same as with sending messages no
confirmation is received on success.</p>

<p style="margin-top: 1em">Send a CTCP request <br>
Other CTCP requests such as PING, VERSION etc should be sent
by calling irc_cmd_ctcp_request(). If the CTCP response is
received, it is handled by the event_ctcp_rep event.</p>

<p style="margin-top: 1em">Handling DCC chat <br>
Implementing the DCC callback <br>
No matter whether you plan to initiate DCC chats or respond
to them you must implement the DCC callback:</p>

<p style="margin-top: 1em">void dcc_callback (irc_session_t
* session, irc_dcc_t id, int status, void * ctx, const char
* data, unsigned int length) <br>
{ <br>
if ( status ) <br>
{ <br>
// If status is LIBIRC_ERR_CLOSED, the chat has been closed
by the remote party. <br>
// Otherwise it is an error; the CHAT either terminated or
could not be established. status is the error code; see
irc_strerror(status) <br>
} <br>
else if ( length == 0 ) <br>
{ <br>
// The remote side has accepted the chat request, send
&quot;hello&quot; something to them <br>
irc_dcc_text( session, id, &quot;Hello!&quot; ); <br>
} <br>
else <br>
{ <br>
// We have received the chat message from the remote party
<br>
printf (&quot;Remote party said: %s0, data ); <br>
} <br>
}</p>

<p style="margin-top: 1em">This callback should be passed
to either irc_dcc_chat() function which initiates the
request, or to irc_dcc_accept() function which accepts the
DCC CHAT request initiated by <br>
another user.</p>

<p style="margin-top: 1em">Initiating the DCC CHAT <br>
You can initiate the DCC chat with another user by calling
irc_dcc_chat():</p>

<p style="margin-top: 1em">// The DCC chat session id will
be returned in this variable <br>
irc_dcc_t dccid;</p>

<p style="margin-top: 1em">// Initiate the DCC chat with
the IRC user &quot;john&quot; <br>
if ( irc_dcc_chat( session, 0, &quot;john&quot;,
dcc_callback, &amp;dccid ) ) <br>
// report error</p>

<p style="margin-top: 1em">Now you can proceed with other
tasks. When John accepts or declines the chat, the
dcc_callback() will be called, and it will be possible to
use the irc_dcc_text() function to <br>
send the chat messages. The callback will also be called
each time a new chat message is received, or when the chat
is finished or terminated because of network error.</p>

<p style="margin-top: 1em">Responding to DCC CHAT requests
<br>
To respond to the DCC CHAT equests your application should
implement for the event_dcc_chat_req event. The callback
could be implemented as following:</p>

<p style="margin-top: 1em">void callback_event_dcc_chat(
irc_session_t * session, const char * nick, const char *
addr, irc_dcc_t dccid ) <br>
{ <br>
// User &rsquo;nick&rsquo; from the IP address
&rsquo;addr&rsquo; tries to initiate the DCC chat with us.
<br>
// Store this information in the application internal queue
together with the dccid so the callback can return <br>
dcc_queue.store( dccid, &quot;CHAT from &quot; + nick +
&quot; IP address: &quot; + addr ); <br>
}</p>

<p style="margin-top: 1em">and registered when the IRC
session is created. If your application does not handle DCC
at all you can just call the irc_dcc_decline() function
inside the callback.</p>

<p style="margin-top: 1em">If it does, we only store this
information in the callback, and return. This is because the
event processing will stop until the callback returns, so
popping up the dialog asking <br>
for the user confirmation would stop further events such as
channel messages from being processed. Even if your
application is automatic and doesn&rsquo;t pop up dialogs it
is still <br>
better to separate the chat logic from the callback
logic.</p>

<p style="margin-top: 1em">Somewhere later the application
would check the queue in the GUI thread, get this
information, and pop up the dialog asking the user feedback.
Then if the chat request was <br>
accepted, the application would call the irc_dcc_accept()
function, and if it was declined, the application would call
the irc_dcc_decline() function. Both functions will accept
<br>
the dccid which identifies this specific request:</p>

<p style="margin-top: 1em">// Somewhere in the GUI thread
<br>
if ( !dcc_queue.empty() ) <br>
{ <br>
// Get the DCC information and show the dialog to the user
<br>
irc_dcc_t dccid = dcc_chat_queue.top().dccid;</p>

<p style="margin-top: 1em">...</p>

<p style="margin-top: 1em">// React to the user entry <br>
if ( dialog.isAccepted() ) <br>
irc_dcc_accept( session, dccid, 0, dcc_callback ); <br>
else <br>
irc_dcc_decline( session, dccid ); <br>
}</p>

<p style="margin-top: 1em">Send CHAT messages <br>
Once the chat session is established, you can send the chat
messages using irc_dcc_text() function. Note that you need
to pass the dcc session id instead of nick:</p>

<p style="margin-top: 1em">irc_dcc_text( session, dccid,
&quot;Hello there!&quot; );</p>

<p style="margin-top: 1em">Handling DCC file transfer <br>
This section covers handling sending and receiving files via
DCC.</p>

<p style="margin-top: 1em">Implementing the callback <br>
No matter whether you plan to send or receive files via dcc
you must implement the DCC callback. While the same callback
may be used both for sending and receiving, this is not <br>
recommended since the logic is different. Therefore the
suggested implementation would be to use different callbacks
as suggested:</p>

<p style="margin-top: 1em">// This callback is used when we
send a file to the remote party <br>
void callback_dcc_send_file (irc_session_t * session,
irc_dcc_t id, int status, void * ctx, const char * data,
unsigned int length) <br>
{ <br>
if ( status ) <br>
{ <br>
// It is an error; the send operation was either terminated
or the connection could not be established. status is the
error code; see irc_strerror(status) <br>
} <br>
else <br>
{ <br>
// We have sent some data to the remote party,
&rsquo;length&rsquo; indicates how much data was sent <br>
printf (&quot;Sent bytes: %d0, length ); <br>
} <br>
}</p>

<p style="margin-top: 1em">// This callback is used when we
receive a file from the remote party <br>
void callback_dcc_recv_file (irc_session_t * session,
irc_dcc_t id, int status, void * ctx, const char * data,
unsigned int length) <br>
{ <br>
if ( status ) <br>
{ <br>
// It is an error; the send operation was either terminated
or the connection could not be established. status is the
error code; see irc_strerror(status) <br>
} <br>
else if ( data == 0 ) <br>
{ <br>
// File transfer has been finished <br>
printf (&quot;File has been received successfully0 ); <br>
} <br>
else <br>
{ <br>
// More file content has been received. Store it in memory,
write to disk or something <br>
printf (&quot;Received %d bytes of data0, length ); <br>
} <br>
}</p>

<p style="margin-top: 1em">This callback should be passed
to either irc_dcc_sendfile() function which initiates the
request, or to irc_dcc_accept() function which accepts the
DCC RECVFILE request initiated <br>
by another user.</p>

<p style="margin-top: 1em">Sending the file via DCC <br>
You can initiate sending the file via DCC to another user by
calling irc_dcc_sendfile():</p>

<p style="margin-top: 1em">// The DCC session id will be
returned in this variable <br>
irc_dcc_t dccid;</p>

<p style="margin-top: 1em">// Initiate sending of file
&quot;/etc/passwd&quot; via DCC chat to the IRC user
&quot;john&quot; <br>
if ( irc_dcc_sendfile( session, 0, &quot;john&quot;,
&quot;/etc/passwd&quot;, callback_dcc_send_file, &amp;dccid
) ) <br>
// report error</p>

<p style="margin-top: 1em">Now you can proceed with other
tasks. When John accepts the request, the file will be sent
and callback_dcc_send_file() will be called each time a
piece of file is sent. The <br>
callback will also be called when the file has been sent, or
when sending was terminated because of network error.</p>

<p style="margin-top: 1em">Receive a file via DCC <br>
To receive the file via DCC a remote user must initiate the
DCC request to send you a file. To receive this request your
application should implement the event_dcc_send_req <br>
event. The callback could be implemented as following:</p>

<p style="margin-top: 1em">void callback_event_dcc_file(
irc_session_t * session, const char * nick, const char *
addr, const char * filename, unsigned long size, irc_dcc_t
dccid ) <br>
{ <br>
// User &rsquo;nick&rsquo; from the IP address
&rsquo;addr&rsquo; tries to initiate the DCC chat with us.
<br>
// Store this information in the application internal queue
together with the dccid so the callback can return <br>
dcc_queue.store( dccid, &quot;CHAT from &quot; + nick +
&quot; IP address: &quot; + addr + &quot;, filename &quot; +
filename ); <br>
}</p>

<p style="margin-top: 1em">If your application does not
handle DCC at all you can just call the irc_dcc_decline()
function inside the callback.</p>

<p style="margin-top: 1em">If it does, we only store this
information in the callback, and return. This is because the
event processing will stop until the callback returns, so
popping up the dialog asking <br>
for the user confirmation would stop further events such as
channel messages from being processed. Even if your
application is automatic and doesn&rsquo;t pop up dialogs it
is still <br>
better to separate the chat logic from the callback
logic.</p>

<p style="margin-top: 1em">Somewhere later the application
would check the queue in the GUI thread, get this
information, and pop up the dialog asking the user feedback.
Then if the chat request was <br>
accepted, the application would call the irc_dcc_accept()
function, and if it was declined, the application would call
the irc_dcc_decline() function. Both functions will accept
<br>
the dccid which identifies this specific request:</p>

<p style="margin-top: 1em">// Somewhere in the GUI thread
<br>
if ( !dcc_queue.empty() ) <br>
{ <br>
// Get the DCC information and show the dialog to the user
<br>
irc_dcc_t dccid = dcc_chat_queue.top().dccid;</p>

<p style="margin-top: 1em">...</p>

<p style="margin-top: 1em">// React to the user entry <br>
if ( dialog.isAccepted() ) <br>
irc_dcc_accept( session, dccid, 0, dcc_callback ); <br>
else <br>
irc_dcc_decline( session, dccid ); <br>
}</p>

<p style="margin-top: 1em">Note that it is not possible to
request a remote user to send you a file.</p>

<p style="margin-top: 1em">Handling colors <br>
Stripping colors from the message <br>
If your bot reacts on the text messages, you need to strip
down the colors from the text messages before processing
them. Otherwise the user sending the colored message
won&rsquo;t get <br>
the same reaction as the user who doesn&rsquo;t use colors,
and some users use colors by default.</p>

<p style="margin-top: 1em">Use the
irc_color_strip_from_mirc() function to strip the ANSI
colors from the text message. It does not modify the message
which doesn&rsquo;t use colors.</p>

<p style="margin-top: 1em">Color conversion <br>
The library supports color translation, and can convert
colors between the ANSI colors used by the IRC clients and
their textual representation. Colors usage is typically
lim&acirc; <br>
ited to the messages and user specified reasons. You cannot
use colors as part of your nick or channel name.</p>

<p style="margin-top: 1em">Use the
irc_color_convert_from_mirc() function to convert colors
from ANSI to the library textual representation, and
irc_color_convert_to_mirc() to convert the library textual
<br>
representation of colors into ANSI.</p>

<p style="margin-top: 1em">Do not forget to free() the
returned pointer once it is not used anymore.</p>

<p style="margin-top: 1em">Miscellaneous <br>
Tracking user nicks <br>
If your application maintains some user-specific quotas, it
is important to track the nick changes. Since the nick is
the only identifier available to you, each time the user
<br>
changes the nick you need to update your quota database. To
do so you need to intercept the event_nick event. See the
examples/censor.c for details.</p>

<p style="margin-top: 1em">API REFERENCE <br>
Callbacks <br>
This section describes the callbacks supported by the
library.</p>

<p style="margin-top: 1em">irc_event_callback_t <br>
Prototype:</p>

<p style="margin-top: 1em">typedef void
(*irc_event_callback_t)(irc_session_t * session, const char
* event, const char * origin, const char ** params, unsigned
int count)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; The IRC session, which generated the
event &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">&acirc;event &acirc; The text
name of the event. Useful in case a single event han&acirc;
&acirc; <br>
&acirc; &acirc; dler is used to handle multiple events
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;origin &acirc; The originator of the event. Depends
on the event. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; Extra parameters, if any, for this
event. The number of extra &acirc; <br>
&acirc; &acirc; parameters depends on the event, and may be
zero. Each param&acirc; &acirc; <br>
&acirc; &acirc; eter is a NULL-terminated text string. None
of the params can &acirc; <br>
&acirc; &acirc; be NULL, but the params pointer itself could
be NULL for some &acirc; <br>
&acirc; &acirc; events. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;count &acirc; The number of entries in the params
argument supplied. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">Every IRC event generates a
callback. This type of callback is universal and is used by
almost all IRC events. Depending on the event nature, it can
have zero or more parameters. <br>
For each type of event, the number of provided parameters is
fixed, and their meaning is described in the irc_callbacks_t
structure.</p>

<p style="margin-top: 1em">Every event has an origin (i.e.
who originated the event). In some cases the origin variable
may be NULL, which indicates that event origin is unknown.
The origin usually looks <br>
like nick!host@ircserver, i.e. like tim!home@irc.server.net.
Such origins can not be used in IRC commands, and need to be
stripped (i.e. host and server part should be cut off) <br>
before using. This can be done either manually, by calling
irc_target_get_nick(), or automatically for all the events -
by setting the LIBIRC_OPTION_STRIPNICKS option with <br>
irc_option_set().</p>

<p style="margin-top: 1em">irc_event_dcc_chat_t <br>
Prototype:</p>

<p style="margin-top: 1em">typedef void
(*irc_event_dcc_chat_t)(irc_session_t * session, const char
* nick, const char * addr, irc_dcc_t dccid)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session, which generates an event
(the one returned by &acirc; <br>
&acirc; &acirc; irc_create_session) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; User who requested the chat &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;addr &acirc; IP address of the person such as
189.12.34.56 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; Identifier associated with this request
which should be passed &acirc; <br>
&acirc; &acirc; to the irc_dcc_accept() / irc_dcc_decline()
functions &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This callback is called when
someone requests DCC CHAT with you. DCC CHAT is the type of
chat which goes directly between the clients, instead of
going through the IRC server. <br>
Since the TCP connection must be established for it to
happen, typically the initiator must either have the public
IP or special software on the firewall which handles the
neces&acirc; <br>
sary port forwarding.</p>

<p style="margin-top: 1em">You must respond to the chat
request either by calling irc_dcc_accept() to accept it, or
by calling irc_dcc_decline() to decline it.</p>

<p style="margin-top: 1em">irc_event_dcc_send_t <br>
Prototype:</p>

<p style="margin-top: 1em">typedef void
(*irc_event_dcc_send_t)(irc_session_t * session, const char
* nick, const char * addr, const char * filename, unsigned
long size, irc_dcc_t dccid)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; The IRC session, which generates an
event (the one returned by &acirc; <br>
&acirc; &acirc; irc_create_session) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; The user who requested the chat &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;addr &acirc; The IP address of the person such as
189.12.34.56 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">&acirc;filename &acirc; The name
of the file the user is trying to send you &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;size &acirc; The size of the file &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; Identifier associated with this request
which should be passed &acirc; <br>
&acirc; &acirc; to the irc_dcc_accept() / irc_dcc_decline()
functions &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This callback is called when
someone wants to send you a file by using DCC SEND. DCC SEND
goes directly between the clients, and requires the TCP
connection to be established <br>
established for it to happen. Therefore the initiator must
either have the public IP or special software on the
firewall which handles the necessary port forwarding.</p>

<p style="margin-top: 1em">You must respond to the chat
request either by calling irc_dcc_accept() to accept it, or
by calling irc_dcc_decline() to decline it.</p>

<p style="margin-top: 1em">irc_dcc_callback_t <br>
Prototype:</p>

<p style="margin-top: 1em">typedef void
(*irc_dcc_callback_t)(irc_session_t * session, irc_dcc_t id,
int status, void * ctx, const char * data, unsigned int
length)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; The IRC session, which generates an
event (the one returned by &acirc; <br>
&acirc; &acirc; irc_create_session) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;id &acirc; The DCC session id &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;status &acirc; The DCC connection status. 0 means
there is no error, other&acirc; &acirc; <br>
&acirc; &acirc; wise contains an error code &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;ctx &acirc; The user-provided context &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;data &acirc; Data received (if available), otherwise
NULL &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;length &acirc; Size of the data received if any data
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This callback is called for all
DCC functions when state change occurs.</p>

<p style="margin-top: 1em">For DCC CHAT, the callback is
called as following:</p>

<p style="margin-top: 1em">&Acirc;&middot; status is
LIBIRC_ERR_CLOSED: connection is closed by remote peer.
After returning from the callback, the DCC session is
automatically destroyed</p>

<p style="margin-top: 1em">&Acirc;&middot; status is
nonzero but not LIBIRC_ERR_CLOSED: socket I/O error (connect
error, accept error, recv error, send error). After
returning from the callback, the DCC session <br>
is automatically destroyed</p>

<p style="margin-top: 1em">&Acirc;&middot; status is zero
and length is zero: the remote side accepted the chat
request</p>

<p style="margin-top: 1em">&Acirc;&middot; status is zero
and length is nonzero: new chat message received, data
contains the message (a null-terminated string), length
contains the string length without null <br>
terminator</p>

<p style="margin-top: 1em">For DCC SEND, while file is
being sent, the callback is called as following:</p>

<p style="margin-top: 1em">&Acirc;&middot; status is
nonzero: socket I/O error (connect error, accept error, recv
error, send error). After returning from the callback, the
DCC session is automatically destroyed</p>

<p style="margin-top: 1em">&Acirc;&middot; status is zero:
another data packet has been sent, length contains the total
amount of data sent so far, data is NULL</p>

<p style="margin-top: 1em">For DCC RECV, while file is
being sending, callback called as following:</p>

<p style="margin-top: 1em">&Acirc;&middot; status is
nonzero: socket I/O error (connect error, accept error, recv
error, send error). After returning from the callback, the
DCC session is automatically destroyed.</p>

<p style="margin-top: 1em">&Acirc;&middot; status is zero,
and data is NULL: the file has been received successfully.
After returning from the callback, the DCC session is
automatically destroyed.</p>

<p style="margin-top: 1em">&Acirc;&middot; status is zero,
and data is not NULL: new data received, data contains the
data received, length contains the amount of data
received.</p>

<p style="margin-top: 1em">irc_eventcode_callback_t <br>
Prototype:</p>

<p style="margin-top: 1em">typedef void
(*irc_eventcode_callback_t)(irc_session_t * session,
unsigned int event, const char * origin, const char **
params, unsigned int count)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; The IRC session, which generates an
event (the one returned by &acirc; <br>
&acirc; &acirc; irc_create_session) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;event &acirc; The numeric code of the event. Useful
in case a single event &acirc; <br>
&acirc; &acirc; handler is used to handle multiple events
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;origin &acirc; The originator of the event. Depends
on the event. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; Extra parameters, if any, for this
event. The number of extra &acirc; <br>
&acirc; &acirc; parameters depends on the event, and may be
zero. Each param&acirc; &acirc; <br>
&acirc; &acirc; eter is a NULL-terminated text string. None
of the params can &acirc; <br>
&acirc; &acirc; be NULL, but the params pointer itself could
be NULL for some &acirc; <br>
&acirc; &acirc; events. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;count &acirc; The number of entries in the params
argument supplied. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This is an advanced callback for
those who want to handle events deeper. Most times the IRC
server replies to your actions with numeric events. Most of
those events are error <br>
codes, and some are list-start and list-stop markers. Every
code has its own set of params; for details you can either
experiment, or read RFC 1459 (don&rsquo;t expect servers to
fol&acirc; <br>
low it closely though).</p>

<p style="margin-top: 1em">Every event has an origin (i.e.
who originated the event). In some cases the origin variable
may be NULL, which indicates that event origin is unknown.
The origin usually looks <br>
like nick!host@ircserver, i.e. like tim!home@irc.server.net.
Such origins can not be used in IRC commands, and need to be
stripped (i.e. host and server part should be cut off) <br>
before using. This can be done either manually, by calling
irc_target_get_nick(), or automatically for all the events -
by setting the LIBIRC_OPTION_STRIPNICKS option with <br>
irc_option_set().</p>

<p style="margin-top: 1em">Functions <br>
This section describes the functions defined in the library
which are grouped by the purpose.</p>

<p style="margin-top: 1em">Library initialization and
shutdown <br>
irc_create_session <br>
Prototype:</p>

<p style="margin-top: 1em">irc_session_t *
irc_create_session(irc_callbacks_t * callbacks)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;callbacks | Event callbacks structure, which defines
several callbacks, which will be called &acirc; <br>
&acirc;on appropriate events. Cannot be NULL. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">Creates and initiates a new IRC
session. Every session represents a single user connection
to a single IRC server, and possibly to one or more users
via DCC. Almost every <br>
library function requires this object to be passed to, and
therefore this function should be called first. Multiple
sessions could be allocated to support multiple
connections.</p>

<p style="margin-top: 1em">When it is not needed anymore,
the session must be destroyed by calling the
irc_destroy_session() function.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">An irc_session_t object, or 0 if
creation failed. Usually, failure is caused by out of memory
error.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads. Same callback
structure may be reused by multiple threads.</p>

<p style="margin-top: 1em">irc_destroy_session <br>
Prototype:</p>

<p style="margin-top: 1em">void
irc_destroy_session(irc_session_t * session)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session | The IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function destroys an IRC
session, closes the connection to the IRC server, and frees
all the used resources. After calling this function you
should not use this session <br>
object anymore.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">Connecting, disconnecting and
running the main event loop <br>
irc_connect6 <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_connect6(irc_session_t *
session, const char * server, unsigned short port, const
char * password, const char * nick, const char * username,
const char * realname)</p>

<p style="margin-top: 1em">irc_connect <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_connect(irc_session_t *
session, const char * server, unsigned short port, const
char * password, const char * nick, const char * username,
const char * realname)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;server &acirc; IP address or the host name of the
server. If prefixed with #, &acirc; <br>
&acirc; &acirc; the library will try to establish the SSL
connection IPv4 &acirc; <br>
&acirc; &acirc; address should be in numeric form such as
154.23.112.33; IPv6 &acirc; <br>
&acirc; &acirc; address should be in IPv6 form &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;port &acirc; Port number to connect to, usually 6667
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;password &acirc; IRC server password, if the server
requires it. May be NULL, &acirc; <br>
&acirc; &acirc; in this case password will not be send to
the IRC server. Vast &acirc; <br>
&acirc; &acirc; majority of IRC servers do not require
passwords. This is NOT &acirc; <br>
&acirc; &acirc; NickServ/ChanServ password &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Nick which will be used to log into the
IRC server. Cannot be &acirc; <br>
&acirc; &acirc; NULL &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;username &acirc; Username of the Unix account which
is used to connect to the &acirc; <br>
&acirc; &acirc; IRC server. This is for information only,
will be shown in &acirc; <br>
&acirc; &acirc; &quot;user properties&quot; dialogs and
returned by /whois request. Can &acirc; <br>
&acirc; &acirc; be NULL in which case &quot;nobody&quot;
would be used &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;realname &acirc; A real name of the person, who
connects to the IRC. In reality &acirc; <br>
&acirc; &acirc; nobody uses this field for that. Instead
this field is used as &acirc; <br>
&acirc; &acirc; user self-description, advertising, or other
purposes. This &acirc; <br>
&acirc; &acirc; information also will be shown in &quot;user
properties&quot; dialogs &acirc; <br>
&acirc; &acirc; and returned by /whois request. May be NULL,
in this case &quot;no&acirc; &acirc; <br>
&acirc; &acirc; name&quot; will be used &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function initiates the
connection to the IPv4 (irc_connect) or IPv6 (irc_connect6)
IRC server. The server could be specified either by an IP
address or by the DNS name. The <br>
irc_connect6 works only if the library was built with the
IPv6 support.</p>

<p style="margin-top: 1em">If the library was built with
the OpenSSL support, and the IP address or the host name is
prefixed by a hash, such as &quot;#irc.example.com&quot;,
the library attempts to establish the <br>
SSL connection.</p>

<p style="margin-top: 1em">The connection is established
asynchronously, and the event_connect is called once the
connection is established.</p>

<p style="margin-top: 1em">A single IRC session object can
only be connected to a single IRC server and only with a
single nick, meaning it is not possible to have multiple
nicks sharing a single connec&acirc; <br>
tion.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Returns 0 if the connection is
initiated successfully. This doesn&rsquo;t mean the
connection is established - the event_connect is called when
it happens. If the connection cannot be <br>
established, either irc_run() or
irc_process_select_descriptors() will return an error.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads, but not using the same
session object.</p>

<p style="margin-top: 1em">irc_disconnect <br>
Prototype:</p>

<p style="margin-top: 1em">void
irc_disconnect(irc_session_t * session)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session | IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function closes the IRC
connection. After that connection is closed, if the libirc
was looped in the irc_run() loop, it automatically leaves
the loop and irc_run() returns.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads, but not using the same
session object.</p>

<p style="margin-top: 1em">irc_is_connected <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_is_connected(irc_session_t * session)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">This function returns 1 if the
connection to the IRC server is established or 0 if it is
not.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_run <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_run(irc_session_t *
session)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function enters into
forever loop, processing the IRC events, and calling the
relevant callbacks. This function will not return until the
server connection is terminated - <br>
either by server, or by calling irc_cmd_quit. This function
should only be used if you use a single IRC session and
don&rsquo;t need asynchronous request processing (i.e. your
bot just <br>
reacts on the events, and doesn&rsquo;t generate it
asynchronously). Even in last case, you still can call this
function and start the asynchronous thread in event_connect
handler. <br>
See the examples.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">This function returns a nonzero
value if the connection to the IRC server could not be
established, or was terminated.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function cannot be called
from multiple threads. Use irc_add_select_descriptors() and
irc_process_select_descriptors() instead.</p>

<p style="margin-top: 1em">irc_add_select_descriptors <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_add_select_descriptors(irc_session_t * session, fd_set
*in_set, fd_set *out_set, int * maxfd)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;in_set &acirc; fd_set input descriptor set for
select() &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;out_set &acirc; fd_set output descriptor set for
select() &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;maxfd &acirc; Largest descriptor already in all the
sets. Will be updated if &acirc; <br>
&acirc; &acirc; libirc adds larger number to the FD_SET
array &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function should be used
after you called irc_connect(). It is useful when you have
your own select-based event processing loop. To use it you
should put your own descriptors <br>
into the sets, call this function to add the library
descriptor(s) into the set, and then call select(). When it
returns, you should call irc_process_select_descriptors()
which <br>
will handle the events and calls your callbacks(!). Then you
can process your sockets events from set. See the
example.</p>

<p style="margin-top: 1em">What if you use epoll? See the
FAQ</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">This function returns a nonzero
value if the irc_connect() was not called before calling
this function.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads, but it rarely makes
sense.</p>

<p style="margin-top: 1em">irc_process_select_descriptors
<br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_process_select_descriptors(irc_session_t * session,
fd_set *in_set, fd_set *out_set)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;in_set &acirc; fd_set input descriptor set for
select() &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;out_set &acirc; fd_set output descriptor set for
select() &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function should be used in
pair with irc_add_select_descriptors() function, which
documentation describes how they work together.</p>

<p style="margin-top: 1em">Note that while processing the
events this function calls your callbacks and it will not
return until all your callbacks return. Keep that in mind if
you pop up a dialog in your <br>
application, such as a DCC CHAT or DCC SEND confirmation
dialog.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means success.
Other value means error, the error code may be obtained
through irc_errno().</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads for different IRC
session objects only.</p>

<p style="margin-top: 1em">Managing the IRC channels:
joining, leaving, inviting <br>
irc_cmd_join <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_join(irc_session_t *
session, const char * channel, const char * key)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;channel &acirc; Channel name to join. Cannot be NULL.
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;key &acirc; Secret key for the channel. Can be NULL
if not needed &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">Use this function to join the
new IRC channel. If the channel does not exist, it will be
automatically created by the IRC server. Note that to JOIN
the password-protected chan&acirc; <br>
nel, you must know the password, and specify it in the key
argument. If join is successful, the event_join will be
called (with your nick as the origin), then typically the
<br>
event_topic is be called and then you receive the list of
users who are on the channel (by using
LIBIRC_RFC_RPL_NAMREPLY), which will include the user who
just joined.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_BANNEDFROMCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_INVITEONLYCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_BADCHANNELKEY</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CHANNELISFULL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_BADCHANMASK</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYCHANNELS</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_part <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_part(irc_session_t *
session, const char * channel)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;channel &acirc; Channel name to leave. Cannot be
NULL. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">Use this function to leave the
IRC channel you&rsquo;ve already joined to. An attempt to
leave the channel you aren&rsquo;t in results a
LIBIRC_RFC_ERR_NOTONCHANNEL server error.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_invite <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_invite(irc_session_t
* session, const char * nick, const char * channel)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Nick name of the user to invite &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;channel &acirc; Channel name to join. Cannot be NULL
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to invite
someone to invite-only channel. &quot;Invite-only&quot; is a
channel mode, which restricts anyone, except invided, to
join this channel. After invitation, <br>
the user could join this channel. The user, who is invited,
will receive the event_invite event. Note that you must be a
channel operator to invite the users.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">On success one of the following
replies returned:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_INVITING</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_AWAY</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NEEDMOREPARAMS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_ERR_USERONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_ERR_CHANOPRIVSNEEDED</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_names <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_names (irc_session_t
* session, const char * channel);</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">&acirc;channel &acirc; A channel
name(s) to obtain user list. Multiple channel names &acirc;
<br>
&acirc; &acirc; must be separated by a comma &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to to ask
the IRC server for the list of the users who are joined the
specified channel. You can list all nicknames that are
visible to you on any channel <br>
that you can see. The list of users will be returned using
LIBIRC_RFC_RPL_NAMREPLY and LIBIRC_RFC_RPL_ENDOFNAMES
numeric codes.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">The channel names are returned
by event_numeric event using the following reply codes:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_NAMREPLY</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_ENDOFNAMES</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_list <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_list(irc_session_t *
session, const char * channel)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;channel &acirc; A channel name(s) to list. Multiple
channel names must be sep&acirc; &acirc; <br>
&acirc; &acirc; arated by a comma. If NULL, all channels are
listed &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to ask the
IRC server for the active (existing) channels list. The list
will be returned using the LIBIRC_RFC_RPL_LISTSTART,
multiple LIBIRC_RFC_RPL_LIST, <br>
and LIBIRC_RFC_RPL_LISTEND event sequence. Note that
&quot;private&quot; channels are listed (without their
topics) as channel &quot;Prv&quot; unless the client
generating the LIST query is actually <br>
on that channel. Likewise, secret channels are not listed at
all unless the client is active at the channel in
question.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">The list of channels is returned
by event_numeric event using the following reply codes:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_LISTSTART</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_LISTEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_LIST</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_topic <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_topic(irc_session_t
* session, const char * channel, const char * topic)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;channel &acirc; A channel name &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;topic &acirc; A new channel topic. If NULL, the old
topic would be returned &acirc; <br>
&acirc; &acirc; and nothing would change. To set the empty
topic use &quot;&quot; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to change
or view the topic (title) of a channel. Note that depending
on +t channel mode, you may be required to be a channel
operator to change the channel <br>
topic.</p>

<p style="margin-top: 1em">If the command succeeds, the IRC
server will generate a LIBIRC_RFC_RPL_NOTOPIC or
LIBIRC_RFC_RPL_TOPIC message, containing either the old or
changed topic. Also the IRC server <br>
can (but does not have to) generate the non-RFC
LIBIRC_RFC_RPL_TOPIC_EXTRA message, containing the nick of
person who changed the topic, and the date/time of the last
change.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">The topic information is
returned using one of following reply codes:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_NOTOPIC</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_TOPIC</p>

<p style="margin-top: 1em">If the topic change was
requested and it was successfully changed, the event_topic
is generated as well.</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NEEDMOREPARAMS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_channel_mode <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_cmd_channel_mode(irc_session_t * session, const char *
channel, const char * mode)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;channel &acirc; A channel name &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;mode &acirc; A mode to change. If NULL, the channel
mode is not changed but &acirc; <br>
&acirc; &acirc; the old mode is returned &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to is used
to change or view the channel modes. Note that only the
channel operators can change the channel mode.</p>

<p style="margin-top: 1em">Channel mode is represended by
the multiple letters combination. Every letter has its own
meaning in channel modes. Most channel mode letters are
boolean (i.e. could only be set <br>
or reset), but a few channel mode letters accept a
parameter. All channel options are set by adding a plus sign
before the letter, and reset by adding a minus sign before
the <br>
letter.</p>

<p style="margin-top: 1em">Here is the list of
&rsquo;standard&rsquo; channel modes:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;o nickname &acirc; gives (+o nickname) to, or takes
(-o nickname) the channel &acirc; <br>
&acirc; &acirc; operator privileges from a nickname. This
mode affects the &acirc; <br>
&acirc; &acirc; users in channel, not the channel itself.
Examples: &quot;+o tim&quot;, &acirc; <br>
&acirc; &acirc; &quot;-o watson&quot; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;p &acirc; sets (+p) or resets (-p) private channel
flag. Private chan&acirc; &acirc; <br>
&acirc; &acirc; nels are shown in channel list as
&rsquo;Prv&rsquo;, without the topic &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;s &acirc; sets (+s) or resets (-s) secret channel
flag. Secret channels &acirc; <br>
&acirc; &acirc; aren&rsquo;t shown in channel list at all
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;i &acirc; sets (+i) or resets (-i) invite-only
channel flag. When the &acirc; <br>
&acirc; &acirc; flag is set, only the people who are invited
by the &acirc; <br>
&acirc; &acirc; irc_cmd_invite() can join this channel
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;t &acirc; allows (+t) or denies (-t) changing the
topic by the non-chan&acirc; &acirc; <br>
&acirc; &acirc; nel operator users. When the flag is set,
only the channel &acirc; <br>
&acirc; &acirc; operators can change the channel topic
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;n &acirc; sets (+n) or resets (-n) the protection
from the users who did &acirc; <br>
&acirc; &acirc; not join the channel. When the +n mode is
set, only the users &acirc; <br>
&acirc; &acirc; who have joined the channel can send the
messages to the chan&acirc; &acirc; <br>
&acirc; &acirc; nel &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;m &acirc; sets (+m) or resets (-m) the moderation of
the channel. When &acirc; <br>
&acirc; &acirc; the moderation mode is set, only channel
operators and the &acirc; <br>
&acirc; &acirc; users who have +v user mode can speak in the
channel &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;v nickname &acirc; gives (+v nick) or takes (-v nick)
from user the ability to &acirc; <br>
&acirc; &acirc; speak on a moderated channel. Examples:
&quot;+v bob&quot;, &quot;-v joy&quot; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;l number &acirc; sets (+l 20) or removes (-l) the
restriction of maximum number &acirc; <br>
&acirc; &acirc; of users allowed in channel. When the
restriction is set and &acirc; <br>
&acirc; &acirc; there is a number of users in the channel,
no one can join the &acirc; <br>
&acirc; &acirc; channel anymore &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;k key &acirc; sets (+k password) or removes (-k) the
password from the chan&acirc; &acirc; <br>
&acirc; &acirc; nel. When the restriction is set, any user
joining the channel &acirc; <br>
&acirc; &acirc; required to provide a channel key &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;b mask &acirc; sets (+b !*@.mil) or removes (-b
!*@.mil) the ban mask on a &acirc; <br>
&acirc; &acirc; user to keep him out of channel. Note that
to remove the ban &acirc; <br>
&acirc; &acirc; you must specify the ban mask to remove, not
just &quot;-b&quot;. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Note that the actual list of
channel modes depends on the IRC server, and can be bigger.
If you know the popular channel modes which aren&rsquo;t
listed here - please contact me</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">The old mode information is
returned by using following numeric codes:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_CHANNELMODEIS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_BANLIST</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_ENDOFBANLIST</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NEEDMOREPARAMS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_KEYSET</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_UNKNOWNMODE</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHCHANNEL</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_user_mode <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_cmd_user_mode(irc_session_t * session, const char *
mode)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;mode &acirc; A mode to change. If NULL, the user mode
is not changed but &acirc; <br>
&acirc; &acirc; the old mode is returned &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to change
or view the user modes. Note that, unlike channel modes,
some user modes cannot be changed at all.</p>

<p style="margin-top: 1em">User mode is represended by the
letters combination. All the user mode letters are boolean
(i.e. could only be set or reset), they are set by adding a
plus sign before the let&acirc; <br>
ter, and reset by adding a minus sign before the letter.</p>

<p style="margin-top: 1em">Here is the list of
&rsquo;standard&rsquo; user modes:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;o &acirc; represents an IRC operator status. Could
not be set directly &acirc; <br>
&acirc; &acirc; (but can be reset though), to set it use the
IRC a OPER com&acirc; &acirc; <br>
&acirc; &acirc; mand &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;i &acirc; if set, marks a user as
&rsquo;invisible&rsquo; - that is, not seen by &acirc; <br>
&acirc; &acirc; lookups if the user is not in a channel
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;w &acirc; if set, marks a user as &rsquo;receiving
wallops&rsquo; - special messages &acirc; <br>
&acirc; &acirc; generated by IRC operators using WALLOPS
command &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;s &acirc; if set, marks a user for receipt of server
notices &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;r &acirc; NON-STANDARD MODE. If set, user has been
authenticated with &acirc; <br>
&acirc; &acirc; the NickServ IRC service &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;x &acirc; NON-STANDARD MODE. If set, user&rsquo;s
real IP is masked by the IRC &acirc; <br>
&acirc; &acirc; server &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Note that the actual list of
user modes depends on the IRC server, and can be bigger. If
you know the popular user modes, which aren&rsquo;t
mentioned here - please contact me.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">The old mode information is
returned by using the numeric code
LIBIRC_RFC_RPL_UMODEIS:</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NEEDMOREPARAMS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_UNKNOWNMODE</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_USERSDONTMATCH</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_UMODEUNKNOWNFLAG</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_kick <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_kick (irc_session_t
* session, const char * nick, const char * channel, const
char * reason);</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; The nick to kick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;channel &acirc; The channel to kick the nick from
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; If not NULL, the reason to kick the user
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to kick a
person out of channel. Note that you must be a channel
operator to kick anyone from a channel.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">If the command succeed, the
event_kick will be generated.</p>

<p style="margin-top: 1em">If the command failed, one of
the following event_numeric responses will be generated:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NEEDMOREPARAMS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_BADCHANMASK</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">Sending the messages, notices,
/me messages and working with CTCP <br>
irc_cmd_msg <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_msg(irc_session_t *
session, const char * nch, const char * text)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nch &acirc; Target nick or target channel &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;text &acirc; Message text &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to send
the message to the channel or privately to another nick.
&quot;Privately&quot; here means the message is not posted
to the public, but the message still goes <br>
through the IRC server and could be seen by the IRC netwrk
operators. The message target is determined by the nch
argument: if it is a nick, this will be a private message,
but <br>
if it is a channel name it will be posted into the
channel.</p>

<p style="margin-top: 1em">The protocol does not require
you to join the channel to post the message into it, but
most channels set the channel mode preventing you from
posting into a channel unless you <br>
join it.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed. You need to wait for the appropriate
event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">If the command succeed, no event
is typically generated except the possibility of
LIBIRC_RFC_RPL_AWAY.</p>

<p style="margin-top: 1em">However if the command failed,
one of the following numeric events may be generated:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NORECIPIENT</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTEXTTOSEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_WILDTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYTARGETS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_me <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_me(irc_session_t *
session, const char * nch, const char * text)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nch &acirc; Target nick or target channel &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;text &acirc; Message text &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to send
the /me message (CTCP ACTION) to the channel or privately to
another nick. &quot;Privately&quot; here means the message
is not posted to the public, but the <br>
message still goes through the IRC server and could be seen
by the IRC netwrk operators. The message target is
determined by the nch argument: if it is a nick, this will
be a <br>
private message, but if it is a channel name it will be
posted into the channel.</p>

<p style="margin-top: 1em">The protocol does not require
you to join the channel to post the message into it, but
most channels set the channel mode preventing you from
posting into a channel unless you <br>
join it.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed. You need to wait for the appropriate
event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">If the command succeed, no event
is typically generated except the possibility of
LIBIRC_RFC_RPL_AWAY.</p>

<p style="margin-top: 1em">However if the command failed,
one of the following numeric events may be generated:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NORECIPIENT</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTEXTTOSEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_WILDTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYTARGETS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_notice <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_notice(irc_session_t
* session, const char * nch, const char * text)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nch &acirc; Target nick or target channel &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;text &acirc; Message text &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to send
the notice to the channel or privately to another nick.
&quot;Privately&quot; here means the message is not posted
to the public, but the message still goes <br>
through the IRC server and could be seen by the IRC netwrk
operators. The message target is determined by the nch
argument: if it is a nick, this will be a private message,
but <br>
if it is a channel name it will be posted into the
channel.</p>

<p style="margin-top: 1em">The protocol does not require
you to join the channel to post the notice into it, but most
channels set the channel mode preventing you from posting
into a channel unless you <br>
join it.</p>

<p style="margin-top: 1em">The only difference between a
message and a notice is that the RFC explicitly says the
automatic bots must not reply to NOTICE automatically.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">If the command succeed, no event
is typically generated except the possibility of
LIBIRC_RFC_RPL_AWAY.</p>

<p style="margin-top: 1em">However if the command failed,
one of the following numeric events may be generated:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NORECIPIENT</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTEXTTOSEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_WILDTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYTARGETS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_ctcp_request <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_cmd_ctcp_request(irc_session_t * session, const char *
nick, const char * request)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Target nick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;request &acirc; CTCP request tex &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to send a
CTCP request. There are four CTCP requests supported by most
IRC clients:</p>

<p style="margin-top: 1em">&Acirc;&middot; VERSION - get
the client software name and version</p>

<p style="margin-top: 1em">&Acirc;&middot; FINGER - get the
client username, host and real name.</p>

<p style="margin-top: 1em">&Acirc;&middot; PING - get the
client delay.</p>

<p style="margin-top: 1em">&Acirc;&middot; TIME - get the
client local time.</p>

<p style="margin-top: 1em">Some clients may support other
requests. The RFC does not list the requests and does not
mandate any CTCP support.</p>

<p style="margin-top: 1em">If you send the CTCP request,
make sure you define the handler for the event_ctcp_rep to
process the reply;</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NORECIPIENT</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTEXTTOSEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_WILDTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYTARGETS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_ctcp_reply <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_cmd_ctcp_reply(irc_session_t * session, const char *
nick, const char * reply)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Target nick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;reply &acirc; CTCP reply &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to send a
reply to the CTCP request received from event_ctcp_req
event. Note that you will not receive this event unless you
specify your own handler during <br>
the IRC session initialization.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NORECIPIENT</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTEXTTOSEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_WILDTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYTARGETS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">Miscellaneous: library version,
raw data, changing nick, quitting <br>
irc_cmd_nick <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_nick(irc_session_t *
session, const char * newnick)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; New nick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to change
your current nick to another nick. Note that such a change
is not always possible; for example you cannot change nick
to the existing nick, or (on <br>
some servers) to the registered nick.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">If the operation succeed, the
server will send the event_nick event. If not, it will send
a numeric error. Possible error responces for this command
from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NONICKNAMEGIVEN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_ERRONEUSNICKNAME</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NICKNAMEINUSE</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NICKCOLLISION</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_whois <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_whois(irc_session_t
* session, const char * nick)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Nick or comma-separated list of nicks to
query the information &acirc; <br>
&acirc; &acirc; about &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function queries various
information about the nick. The amount of information
depends on the IRC server but typically includes username,
real name (as defined by the client <br>
at login), the IRC server used, the channels user is in,
idle time, away mode and so on.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event_numeric event.</p>

<p style="margin-top: 1em">If the request succeed, the
information is returned through the following numeric codes
which return the information:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_WHOISUSER</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_WHOISCHANNELS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_WHOISSERVER</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_AWAY</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_WHOISOPERATOR</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_WHOISIDLE</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_RPL_ENDOFWHOIS - this event terminates the WHOIS
information</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHSERVER</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NONICKNAMEGIVEN</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_cmd_quit <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_cmd_quit(irc_session_t *
session, const char * reason)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;reason &acirc; If not NULL, the reason to quit
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description: This function sends
the QUIT command to the IRC server. This command forces the
IRC server to close the IRC connection, and terminate the
session.</p>

<p style="margin-top: 1em">The difference between this
command and calling the irc_disconnect is that this command
allows to specify the reason to quit which will be shown to
all the users in the channels <br>
you joined. Also it would make it clear that you left the
IRC channels by purpose, and not merely got
disconnected.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_send_raw <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_send_raw (irc_session_t
* session, const char * format, ...);</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;format &acirc; printf-type formatting string followed
by the format arguments &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function sends the raw data
as-is to the IRC server. Use it to generate a server
command, which is not (yet) provided by libircclient
directly.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_target_get_nick <br>
Prototype:</p>

<p style="margin-top: 1em">void irc_target_get_nick(const
char * origin, char *nick, size_t size)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; Nick in the common IRC server format
such as tim!root@myco&acirc; &acirc; <br>
&acirc; &acirc; main.com &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Buffer to retrieve the parsed nick name
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;size &acirc; Size of the nick buffer. If the parsed
nick is larger than the &acirc; <br>
&acirc; &acirc; buffer size it will be truncated &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">For most events IRC server
returns &rsquo;origin&rsquo; (i.e. the person, who generated
this event) in so-called &quot;common&quot; form, like
nick!host@domain. However, all the irc_cmd_* functions <br>
require just a nick. This function parses this origin, and
retrieves the nick, storing it into the user-provided
buffer.</p>

<p style="margin-top: 1em">A buffer of size 128 should be
enough for most nicks.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_target_get_host <br>
Prototype:</p>

<p style="margin-top: 1em">void irc_target_get_host(const
char * target, char *host, size_t size)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; Nick in the common IRC server format
such as tim!root@myco&acirc; &acirc; <br>
&acirc; &acirc; main.com &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;host &acirc; Buffer to retrieve the parsed hostname
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;size &acirc; Size of the host buffer. If the parsed
nick is larger than the &acirc; <br>
&acirc; &acirc; buffer size it will be truncated &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">For most events IRC server
returns &rsquo;origin&rsquo; (i.e. the person, who generated
this event) in so-called &quot;common&quot; form, like
nick!host@domain. This function parses this origin, and <br>
retrieves the host, storing it into the user-provided
buffer.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">DCC initiating and accepting
chat sessions, sending and receiving files <br>
irc_dcc_chat <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_dcc_chat(irc_session_t *
session, void * ctx, const char * nick, irc_dcc_callback_t
callback, irc_dcc_t * dccid)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;ctx &acirc; User-defined context which will be passed
to the callback. May &acirc; <br>
&acirc; &acirc; be NULL &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Target nick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;callback &acirc; DCC callback which will be used for
DCC and chat events &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; If this function succeeds, the DCC
session identifier is &acirc; <br>
&acirc; &acirc; stored in this field &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function requests a DCC
CHAT between you and other IRC user. DCC CHAT is like
private chat, but it goes directly between two users, and
bypasses the IRC server. DCC CHAT <br>
request must be accepted by other side before you can send
anything.</p>

<p style="margin-top: 1em">When the chat is accepted,
declined, terminated, or some data is received, the callback
function is called. To be specific, the callback will be
called when:</p>

<p style="margin-top: 1em">&Acirc;&middot; The chat request
is accepted;</p>

<p style="margin-top: 1em">&Acirc;&middot; The chat request
is denied;</p>

<p style="margin-top: 1em">&Acirc;&middot; The new chat
message is received;</p>

<p style="margin-top: 1em">&Acirc;&middot; The chat is
terminated by the remote party;</p>

<p style="margin-top: 1em">See the details in
irc_dcc_callback_t declaration.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NORECIPIENT</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTEXTTOSEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_WILDTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYTARGETS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_dcc_msg <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_dcc_msg(irc_session_t *
session, irc_dcc_t dccid, const char * text)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; DCC session identifier for the DCC CHAT
session which is &acirc; <br>
&acirc; &acirc; active &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;text &acirc; NULL-terminated message to send &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function is used to send
the DCC CHAT message to an active DCC CHAT. To be active,
DCC CHAT request must be initiated by one side and accepted
by another side.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means success.
Other value means error, the error code may be obtained
through irc_errno().</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_dcc_accept <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_dcc_accept(irc_session_t
* session, irc_dcc_t dccid, void * ctx, irc_dcc_callback_t
callback)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; DCC session identifier returned by the
callback &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;ctx &acirc; User-defined context which will be passed
to the callback. May &acirc; <br>
&acirc; &acirc; be NULL &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;callback &acirc; DCC callback which will be used for
DCC and chat events &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function accepts a remote
DCC chat or file transfer request. After the request is
accepted the callback will be called for the further DCC
events, including the termination <br>
of the DCC session. See the DCC callback information.</p>

<p style="margin-top: 1em">This function should be called
only after either event_dcc_chat_req or event_dcc_send_req
events are received. You don&rsquo;t have to call
irc_dcc_accept() or irc_dcc_decline() imme&acirc; <br>
diately in the event processing function - you may just
store the dccid and return, and call those functions later.
However to prevent memory leaks you must call either <br>
irc_dcc_decline() or irc_dcc_accept() for any incoming DCC
request within 60 seconds after receiving it.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means success.
Other value means error, the error code may be obtained
through irc_errno().</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_dcc_decline <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_dcc_decline(irc_session_t * session, irc_dcc_t
dccid)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; DCC session identifier returned by the
callback &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function declines a remote
DCC chat or file transfer request.</p>

<p style="margin-top: 1em">This function should be called
only after either event_dcc_chat_req or event_dcc_send_req
events are received. You don&rsquo;t have to call
irc_dcc_accept() or irc_dcc_decline() imme&acirc; <br>
diately in the event processing function - you may just
store the dccid and return, and call those functions later.
However to prevent memory leaks you must call either <br>
irc_dcc_decline() or irc_dcc_accept() for any incoming DCC
request within 60 seconds after receiving it.</p>

<p style="margin-top: 1em">Do not use this function to
forecefully close the previously accepted or initiated DCC
session. Use irc_dcc_destroy() instead.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means success.
Other value means error, the error code may be obtained
through irc_errno().</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_dcc_sendfile <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_dcc_sendfile(irc_session_t * session, void * ctx, const
char * nick, const char * filename, irc_dcc_callback_t
callback, irc_dcc_t * dccid)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;ctx &acirc; User-defined context which will be passed
to the callback. May &acirc; <br>
&acirc; &acirc; be NULL &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;nick &acirc; Target nick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;filename &acirc; Full path to the file which will be
sent. Must be an existing &acirc; <br>
&acirc; &acirc; file &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;callback &acirc; DCC callback which will be used for
DCC and chat events &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; If this function succeeds, the DCC
session identifier is &acirc; <br>
&acirc; &acirc; stored in this field &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function generates a DCC
SEND request to send the file. When it is accepted, the file
is sent to the remote party, and the DCC session is closed.
The send operation progress <br>
and result can be checked in the callback. See the DCC
callback information.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means the command
was sent to the IRC server successfully. This does not mean
the operation succeed, and you need to wait for the
appropriate event or for the error <br>
code via event_numeric event.</p>

<p style="margin-top: 1em">Possible error responces for
this command from the RFC1459:</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NORECIPIENT</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTEXTTOSEND</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTONCHANNEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_WILDTOPLEVEL</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_TOOMANYTARGETS</p>

<p style="margin-top: 1em">&Acirc;&middot;
LIBIRC_RFC_ERR_NOSUCHNICK</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_dcc_destroy <br>
Prototype:</p>

<p style="margin-top: 1em">int
irc_dcc_destroy(irc_session_t * session, irc_dcc_t
dccid)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dccid &acirc; DCC session identifier of a session to
destroy &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function closes the DCC
connection (if available), and destroys the DCC session,
freeing the used resources. It can be called anytime, even
from callbacks or from different <br>
threads.</p>

<p style="margin-top: 1em">Note that when DCC session is
finished (either with success or failure), you should not
destroy it - it will be destroyed automatically.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Return code 0 means success.
Other value means error, the error code may be obtained
through irc_errno().</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">Handling the colored messages
<br>
irc_color_strip_from_mirc <br>
Prototype:</p>

<p style="margin-top: 1em">char *
irc_color_strip_from_mirc(const char * message)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;message &acirc; Original message with colors &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function strips all the
ANSI color codes from the message, and returns a new message
with no color information. Useful for the bots which react
to strings, to make sure the <br>
bot is not confused if the string uses colors.</p>

<p style="margin-top: 1em">This function does not modify
the message which doesn&rsquo;t use colors.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Returns a new message with
stripped color codes. Note that the memory for the new
message is allocated using malloc(), so you should free it
using free() when it is not used any&acirc; <br>
more. If memory allocation failed, returns 0.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_color_convert_from_mirc <br>
Prototype:</p>

<p style="margin-top: 1em">char *
irc_color_convert_from_mirc(const char * message)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;message &acirc; Original message with colors &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function converts all the
color codes and format options to libircclient internal
colors.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Returns a pointer to the new
message with converted ANSI color codes and format options.
See the irc_color_convert_to_mirc help for details.</p>

<p style="margin-top: 1em">Note that the memory for the new
message is allocated using malloc(), so you should free it
using free() when it is not used anymore. If memory
allocation failed, returns 0.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_color_convert_to_mirc <br>
Prototype:</p>

<p style="margin-top: 1em">char *
irc_color_convert_to_mirc(const char * message)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;message &acirc; Original message with colors &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function converts all the
color codes and format options from internal libircclient
colors to ANSI used by mIRC and other IRC clients.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Returns a new message with
converted color codes and format options, or 0 if memory
could not be allocated. Note that the memory for the new
message is allocated using malloc(), <br>
so you should free it using free() when it is not used
anymore.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">The color system of libircclient
is designed to be easy to use, and portable between
different IRC clients. Every color or format option is
described using plain text commands <br>
written between square brackets.</p>

<p style="margin-top: 1em">The possible codes are:</p>

<p style="margin-top: 1em">&Acirc;&middot; [B] ... [/B] -
bold format mode. Everything between [B] and [/B] is written
in bold.</p>

<p style="margin-top: 1em">&Acirc;&middot; [I] ... [/I] -
italic/reverse format mode. Everything between [I] and [/I]
is written in italic, or reversed (however, because some
clients are incapable of rendering <br>
italic text, most clients display this as normal text with
the background and foreground colors swapped).</p>

<p style="margin-top: 1em">&Acirc;&middot; [U] ... [/U] -
underline format mode. Everything between [U] and [/U] is
written underlined.</p>

<p style="margin-top: 1em">&Acirc;&middot; [COLOR=RED] ...
[/COLOR] - write the text using specified foreground color.
The color is set by using the COLOR keyword, and equal sign
followed by text color code (see <br>
below).</p>

<p style="margin-top: 1em">&Acirc;&middot; [COLOR=RED/BLUE]
... [/COLOR] - write the text using specified foreground and
background color. The color is set by using the COLOR
keyword, an equal sign followed by <br>
text foreground color code, a dash and a text background
color code.</p>

<p style="margin-top: 1em">The following colors are
supported:</p>

<p style="margin-top: 1em">&Acirc;&middot; WHITE</p>

<p style="margin-top: 1em">&Acirc;&middot; BLACK</p>

<p style="margin-top: 1em">&Acirc;&middot; DARKBLUE</p>

<p style="margin-top: 1em">&Acirc;&middot; DARKGREEN</p>

<p style="margin-top: 1em">&Acirc;&middot; RED</p>

<p style="margin-top: 1em">&Acirc;&middot; BROWN</p>

<p style="margin-top: 1em">&Acirc;&middot; PURPLE</p>

<p style="margin-top: 1em">&Acirc;&middot; OLIVE</p>

<p style="margin-top: 1em">&Acirc;&middot; YELLOW</p>

<p style="margin-top: 1em">&Acirc;&middot; GREEN</p>

<p style="margin-top: 1em">&Acirc;&middot; TEAL</p>

<p style="margin-top: 1em">&Acirc;&middot; CYAN</p>

<p style="margin-top: 1em">&Acirc;&middot; BLUE</p>

<p style="margin-top: 1em">&Acirc;&middot; MAGENTA</p>

<p style="margin-top: 1em">&Acirc;&middot; DARKGRAY</p>

<p style="margin-top: 1em">&Acirc;&middot; LIGHTGRAY</p>

<p style="margin-top: 1em">Examples of color sequences:</p>

<p style="margin-top: 1em">Hello, [B]Tim[/B]. <br>
[U]Arsenal[/U] got a [COLOR=RED]red card[/COLOR] <br>
The tree[U]s[/U] are [COLOR=GREEN/BLACK]green[/COLOR]</p>

<p style="margin-top: 1em">Changing the library options
<br>
irc_get_version <br>
Prototype:</p>

<p style="margin-top: 1em">void irc_get_version(unsigned
int * high, unsigned int * low)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;high &acirc; Stores the high version number &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;low &acirc; Stores the low version number &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function returns the
libircclient version. You can use the version either to
check whether required options are available, or to output
the version. The preferred <br>
printf-like format string to output the version is:</p>

<p style="margin-top: 1em">printf (&quot;Version:
%d.%02d&quot;, high, low);</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_set_ctx <br>
Prototype:</p>

<p style="margin-top: 1em">void irc_set_ctx(irc_session_t *
session, void * ctx)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;ctx &acirc; User-defined context &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function sets the
user-defined context for this IRC session. This context is
not used by libircclient. Its purpose is to store
session-specific user data, which may be <br>
obtained later by calling irc_get_ctx. Note that
libircclient just carries out this pointer. If you allocate
some memory, and store its address in ctx (most common
usage), it is <br>
your responsibility to free it before calling
irc_destroy_session().</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_get_ctx <br>
Prototype:</p>

<p style="margin-top: 1em">void * irc_get_ctx(irc_session_t
* session)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function returns the IRC
session context, which was set by irc_set_ctx.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">If no context was set, this
function returns NULL.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_option_set <br>
Prototype:</p>

<p style="margin-top: 1em">void
irc_option_set(irc_session_t * session, unsigned int
option)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;option &acirc; One of the Libirc options to set
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function sets the
libircclient option, changing libircclient behavior. See the
options list for the meaning for every option.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">irc_option_reset <br>
Prototype:</p>

<p style="margin-top: 1em">void
irc_option_reset(irc_session_t * session, unsigned int
option)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;option &acirc; One of the Libirc options to set
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function resets the
libircclient option, changing libircclient behavior. See the
options list for the meaning for every option.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">Handling the errors <br>
irc_errno <br>
Prototype:</p>

<p style="margin-top: 1em">int irc_errno(irc_session_t *
session)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;session &acirc; IRC session handle &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function returns the last
error code associated with last operation of this IRC
session. Possible error codes are defined in
libirc_errors.h</p>

<p style="margin-top: 1em">As usual, typical errno rules
apply:</p>

<p style="margin-top: 1em">&Acirc;&middot; irc_errno()
should be called ONLY if the called function fails;</p>

<p style="margin-top: 1em">&Acirc;&middot; irc_errno()
doesn&rsquo;t return 0 if function succeed; actually, the
return value will be undefined.</p>

<p style="margin-top: 1em">&Acirc;&middot; you should call
irc_errno() IMMEDIATELY after function fails, before calling
any other libircclient function.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">The error code.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads. Local error code is
per IRC context, not per thread.</p>

<p style="margin-top: 1em">irc_strerror <br>
Prototype:</p>

<p style="margin-top: 1em">const char * irc_strerror(int
ircerrno)</p>

<p style="margin-top: 1em">Parameters:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;ircerrno &acirc; IRC error code returned by
irc_errno() &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">Description:</p>

<p style="margin-top: 1em">This function returns the text
representation of the given error code.</p>

<p style="margin-top: 1em">Return value:</p>

<p style="margin-top: 1em">Returns an internal English
string with a short description of the error code.</p>

<p style="margin-top: 1em">Thread safety:</p>

<p style="margin-top: 1em">This function can be called
simultaneously from multiple threads.</p>

<p style="margin-top: 1em">Types <br>
This section describes various types defined by the
library.</p>

<p style="margin-top: 1em">irc_session_t <br>
typedef struct irc_session_s irc_session_t</p>

<p style="margin-top: 1em">The IRC session handle created
by callind irc_create_session(). Most of the library
function calls expect this handle as a parameter. You can
create as many handles as you want. <br>
Each handle could be used to establish a single IRC
connection to an IRC server as a single user.</p>

<p style="margin-top: 1em">Once the handle is not used
anymore, it should be destroyed by calling
irc_destroy_session().</p>

<p style="margin-top: 1em">irc_dcc_session_t <br>
typedef struct irc_dcc_session_s irc_dcc_session_t</p>

<p style="margin-top: 1em">This structure describes a DCC
session used by libircclient. Its members are internal to
libircclient, and should not be used directly.</p>

<p style="margin-top: 1em">irc_dcc_t <br>
typedef unsigned int irc_dcc_t</p>

<p style="margin-top: 1em">This type is a DCC session
identifier, used to identify the DCC sessions in callbacks
and various functions.</p>

<p style="margin-top: 1em">irc_callbacks_t <br>
typedef struct irc_callbacks_t</p>

<p style="margin-top: 1em">typedef struct <br>
{ <br>
irc_event_callback_t event_connect; <br>
irc_event_callback_t event_nick; <br>
irc_event_callback_t event_quit; <br>
irc_event_callback_t event_join; <br>
irc_event_callback_t event_part; <br>
irc_event_callback_t event_mode; <br>
irc_event_callback_t event_umode; <br>
irc_event_callback_t event_topic; <br>
irc_event_callback_t event_kick; <br>
irc_event_callback_t event_channel; <br>
irc_event_callback_t event_privmsg; <br>
irc_event_callback_t event_notice; <br>
irc_event_callback_t event_channel_notice; <br>
irc_event_callback_t event_invite; <br>
irc_event_callback_t event_ctcp_req; <br>
irc_event_callback_t event_ctcp_rep; <br>
irc_event_callback_t event_ctcp_action; <br>
irc_event_callback_t event_unknown; <br>
irc_eventcode_callback_t event_numeric; <br>
irc_event_dcc_chat_t event_dcc_chat_req; <br>
irc_event_dcc_send_t event_dcc_send_req; <br>
}</p>

<p style="margin-top: 1em">Describes the event callbacks
structure which is used in registering the callbacks.</p>

<p style="margin-top: 1em">All the communication with the
IRC network is based on events. Generally speaking, event is
anything generated by someone else in the network, or by the
IRC server itself. <br>
&quot;Someone sends you a message&quot;, &quot;Someone has
joined the channel&quot;, &quot;Someone has quits IRC&quot;
- all these messages are events.</p>

<p style="margin-top: 1em">Every event has its own event
handler, which is called when the appropriate event is
received. You don&rsquo;t have to define all the event
handlers; define only the handlers for the <br>
events you need to intercept, and set the remaining handler
pointers to NULL.</p>

<p style="margin-top: 1em">event_connect</p>

<p style="margin-top: 1em">This event is triggered when the
connection to the IRC server is successfully established,
and the MOTD is received. Depending on the server it may
also be possible to send the <br>
commands before this event.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; Unused, set to NULL &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; Unused, set to NULL &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_nick</p>

<p style="margin-top: 1em">This event is triggered when the
NICK message is received. It happens when one of the users
(including you) in one of the channels you are watching
(have joined) changed their <br>
nick.</p>

<p style="margin-top: 1em">Changing your own nick will also
generate this event. Note that the server may change your
nick independently, so you must track this event.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The original nick (may be yours!)
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains a new nick. &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_quit</p>

<p style="margin-top: 1em">This event is triggered when the
QUIT message is received. It happens when one of the users
in one of the channels you are watching (have joined)
disconnected from the IRC <br>
server.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who disconnected &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] is optional, contains the
user-specified reason to &acirc; <br>
&acirc; &acirc; quit &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_join</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a JOIN message. It happens when a new user joins
the channel you are watching (have joined). It also happens
when you joined the new chan&acirc; <br>
nel.</p>

<p style="margin-top: 1em">Note that you may be
&quot;forced&quot; to join the channel (and therefore
receive this event) without issuing the JOIN command. A
typical case is when the NickServ bot on the server is <br>
configured to auto-join you to specific channels.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who joined the channel (this
may be you!) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the channel name
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_part</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a PART message. It happens when a user leaves the
channel you are watching (have joined). It also happens when
you leave a channel.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who left the channel (this
may be you!) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the channel name
params[1] is optional and &acirc; <br>
&acirc; &acirc; contains the user-specified reason &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_mode</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a channel MODE message. It happens when someone
changed the mode(s) of the channel you are watching (have
joined).</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who performed the change
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">&acirc;params &acirc; params[0]
contains the channel name params[1] contains the &acirc;
<br>
&acirc; &acirc; channel mode changes, such as
&quot;+t&quot;, &quot;-i&quot; params[2] optional, &acirc;
<br>
&acirc; &acirc; contains the argument for the channel mode
(for example, a &acirc; <br>
&acirc; &acirc; nick for the +o mode) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_umode</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a user MODE message. It happens when your user
mode is changed.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who performed the change
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the channel name
params[1] contains the &acirc; <br>
&acirc; &acirc; user mode changes, such as &quot;+t&quot;,
&quot;-i&quot; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_topic</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a TOPIC message. It happens when someone changed
the topic on the channel you are watching (have joined).</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who performed the change
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the channel name
params[1] optional, con&acirc; &acirc; <br>
&acirc; &acirc; tains the new topic &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_kick</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a KICK message. It happens when someone
(including you) kicked someone (including you) from the
channel you are watching (have joined).</p>

<p style="margin-top: 1em">It is possible to kick yourself
from the channel.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who performed the action (may
be you) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the channel name
params[1] optional, con&acirc; &acirc; <br>
&acirc; &acirc; tains the nick of the kicked params[2]
optional, contains the &acirc; <br>
&acirc; &acirc; reason for the kick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_channel</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a PRIVMSG message sent to the channel. It happens
when someone (but not you) sent a message to the channel you
are watching (have joined).</p>

<p style="margin-top: 1em">Your own messages do not trigger
this event. However the server can still &quot;force&quot;
you to send a message to the channel by generating this
event.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who sent a message &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the channel name
params[1] optional, con&acirc; &acirc; <br>
&acirc; &acirc; tains the message text &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_privmsg</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a PRIVMSG message sent privately to you. It
happens when someone sent you a message.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who sent a message &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains your nick params[1]
optional, contains the &acirc; <br>
&acirc; &acirc; message text &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_notice</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a NOTICE message. This message is similar to
PRIVMSG and matches the event_privmsg. According to RFC
1459, the only difference between <br>
NOTICE and PRIVMSG is that you should NEVER automatically
reply to NOTICE messages. Unfortunately, this rule is
frequently violated by IRC servers itself - for example,
NICKSERV <br>
messages require reply, and are sent as NOTICE.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who sent a message &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the target nick
name params[1] optional, &acirc; <br>
&acirc; &acirc; contains the message text &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_channel_notice</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of a NOTICE message. This message is similar to
PRIVMSG and matches the event_channel. According to RFC
1459, the only difference between <br>
NOTICE and PRIVMSG is that you should NEVER automatically
reply to NOTICE messages. Unfortunately, this rule is
frequently violated by IRC servers itself - for example,
NICKSERV <br>
messages require reply, and are sent as NOTICE.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who sent a message &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the channel name
params[1] optional, con&acirc; &acirc; <br>
&acirc; &acirc; tains the message text &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_invite</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of an INVITE message. It happens when someone
invited you to a channel which has +i (invite-only)
mode.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who invited you &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains your nick params[1]
optional, contains the &acirc; <br>
&acirc; &acirc; channel name &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">See also: irc_cmd_invite()</p>

<p style="margin-top: 1em">event_ctcp_req</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of an CTCP request. By default, the built-in CTCP
request handler is used.</p>

<p style="margin-top: 1em">Mirc generates PING, FINGER,
VERSION, TIME and ACTION messages which are automatically
handled by the library if this event is not handled by your
application. Those messages are <br>
replied automatically except the ACTION message which
triggers event_ctcp_action event. If you need to handle more
types of the message, define this event handler, and check
<br>
the source code of libirc_event_ctcp_internal function to
see how to write your own CTCP request handler. Note that
you must support at least CTCP PING to pass the spoof check
<br>
by some IRC servers.</p>

<p style="margin-top: 1em">Also you may find useful this
question in FAQ: ref faq4</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who generated the message
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the complete CTCP
message &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_ctcp_rep</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of an CTCP response. Thus if you generate the CTCP
message and the remote user responded, this event handler
will be called.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who generated the message
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the complete CTCP
message &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_ctcp_action</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of an CTCP ACTION message. It is only invoked if you
did not define the event_ctcp_req event handler.</p>

<p style="margin-top: 1em">Such messages typically look
like that in the IRC client:</p>

<p style="margin-top: 1em">:: [08:32:55] * Michael is
having fun [08:32:55] * Bobby&rsquo;s getting jealous</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who generated the message
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; params[0] contains the content of
ACTION message &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_unknown</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of an unknown message which is not handled by the
library.</p>

<p style="margin-top: 1em">This event uses
irc_event_callback_t callback with the following values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;origin &acirc; The user who generated the event
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;params &acirc; Zero or more parameters provided with
the event &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">event_numeric</p>

<p style="margin-top: 1em">This event is triggered upon
receipt of every numeric message from the server. The
incomplete list of those responses could be found in RFC
1429. This event is necessary to han&acirc; <br>
dle for any meaningful client.</p>

<p style="margin-top: 1em">This event uses the dedicated
<br>
irc_eventcode_callback_t_ <br>
callback. See the callback documentation.</p>

<p style="margin-top: 1em">event_dcc_chat_req</p>

<p style="margin-top: 1em">This event is triggered when
someone attempts to establish the DCC CHAT with you.</p>

<p style="margin-top: 1em">This event uses the dedicated
irc_event_dcc_chat_t callback. See the callback
documentation.</p>

<p style="margin-top: 1em">event_dcc_send_req</p>

<p style="margin-top: 1em">This event is triggered when
someone attempts to send you the file via DCC SEND.</p>

<p style="margin-top: 1em">This event uses the dedicated
irc_event_dcc_send_t callback. See the callback
documentation.</p>

<p style="margin-top: 1em">Constants <br>
This section describes contstants such as options and the
error codes.</p>

<p style="margin-top: 1em">Errors <br>
LIBIRC_ERR_OK</p>

<p style="margin-top: 1em">(0): No error</p>

<p style="margin-top: 1em">LIBIRC_ERR_INVAL</p>

<p style="margin-top: 1em">(1): An invalid value was given
for one of the arguments to a function. For example,
supplying the NULL value as a channel argument of
irc_cmd_join() produces this error.</p>

<p style="margin-top: 1em">LIBIRC_ERR_RESOLV</p>

<p style="margin-top: 1em">(2): The host name supplied for
irc_connect() function could not be resolved into valid IP
address.</p>

<p style="margin-top: 1em">LIBIRC_ERR_SOCKET</p>

<p style="margin-top: 1em">(3): The new socket could not be
created or made non-blocking. Usually means that the server
is out of resources, or (hopefully not) a bug in
libircclient. See also <br>
faq_err_socket</p>

<p style="margin-top: 1em">LIBIRC_ERR_CONNECT</p>

<p style="margin-top: 1em">(4): The socket could not
connect to the IRC server, or to the destination DCC part.
Usually means that either the IRC server is down or its
address is invalid. For DCC the rea&acirc; <br>
son usually is the firewall on your or destination computer,
which refuses DCC transfer.</p>

<p style="margin-top: 1em">LIBIRC_ERR_CLOSED</p>

<p style="margin-top: 1em">(5): The IRC connection was
closed by the IRC server (which could mean that an IRC
operator just have banned you from the server - test your
client before connecting to a public <br>
server), or the DCC connection was closed by remote peer -
for example, the other side just terminates the IRC
application. Usually it is not an error.</p>

<p style="margin-top: 1em">LIBIRC_ERR_NOMEM</p>

<p style="margin-top: 1em">(6): There are two possible
reasons for this error. First is that memory could not be
allocated for libircclient internal use, and this error is
usually fatal. Second reason is <br>
that the command buffer (which queues the commands ready to
be sent to the IRC server) is full, and could not accept
more commands yet. In the last case you should just wait,
<br>
and repeat the command later.</p>

<p style="margin-top: 1em">LIBIRC_ERR_ACCEPT</p>

<p style="margin-top: 1em">(7): A DCC chat/send connection
from the remote peer could not be accepted. Either the
connection was just terminated before it is accepted, or
there is a bug in libircclient.</p>

<p style="margin-top: 1em">LIBIRC_ERR_NODCCSEND</p>

<p style="margin-top: 1em">(9): A filename supplied to
irc_dcc_sendfile() could not be sent. Either is is not a
regular file (a directory or a socket, for example), or it
could not be read. See also <br>
LIBIRC_ERR_OPENFILE</p>

<p style="margin-top: 1em">LIBIRC_ERR_READ</p>

<p style="margin-top: 1em">(10): Either a DCC file could
not be read (for example, was truncated during sending), or
a DCC socket returns a read error, which usually means that
the network connection is <br>
terminated.</p>

<p style="margin-top: 1em">LIBIRC_ERR_WRITE</p>

<p style="margin-top: 1em">(11): Either a DCC file could
not be written (for example, there is no free space on
disk), or a DCC socket returns a write error, which usually
means that the network connec&acirc; <br>
tion is terminated.</p>

<p style="margin-top: 1em">LIBIRC_ERR_STATE</p>

<p style="margin-top: 1em">(12): The function is called
when it is not allowed to be called. For example,
irc_cmd_join() was called before the connection to IRC
server succeed, and event_connect is <br>
called.</p>

<p style="margin-top: 1em">LIBIRC_ERR_TIMEOUT</p>

<p style="margin-top: 1em">(13): The DCC request is timed
out. There is a timer for each DCC request, which tracks
connecting, accepting and non-accepted/declined DCC
requests. For every request this <br>
timer is currently set to 60 seconds. If the DCC request was
not connected, accepted or declined during this time, it
will be terminated with this error.</p>

<p style="margin-top: 1em">LIBIRC_ERR_OPENFILE</p>

<p style="margin-top: 1em">(14): The file specified in
irc_dcc_sendfile() could not be opened.</p>

<p style="margin-top: 1em">LIBIRC_ERR_TERMINATED</p>

<p style="margin-top: 1em">(15): The connection to the IRC
server was terminated.</p>

<p style="margin-top: 1em">LIBIRC_ERR_NOIPV6</p>

<p style="margin-top: 1em">(16): The function which
requires IPv6 support was called, but the IPv6 support was
not compiled into the application</p>


<p style="margin-top: 1em">LIBIRC_ERR_SSL_NOT_SUPPORTED</p>

<p style="margin-top: 1em">(17): The SSL connection was
required but the library was not compiled with SSL
support</p>

<p style="margin-top: 1em">LIBIRC_ERR_SSL_INIT_FAILED</p>

<p style="margin-top: 1em">(18): The SSL library could not
be initialized.</p>


<p style="margin-top: 1em">LIBIRC_ERR_CONNECT_SSL_FAILED</p>

<p style="margin-top: 1em">(19): SSL handshare failed when
attempting to connect to the server. Typically this means
you&rsquo;re trying to use SSL but attempting to connect to
a non-SSL port.</p>


<p style="margin-top: 1em">LIBIRC_ERR_SSL_CERT_VERIFY_FAILED</p>

<p style="margin-top: 1em">(20): The server is using an
invalid or the self-signed certificate. Use
LIBIRC_OPTION_SSL_NO_VERIFY option to connect to it.</p>

<p style="margin-top: 1em">Options <br>
LIBIRC_OPTION_DEBUG</p>

<p style="margin-top: 1em">If set, enables additional debug
output which goes to STDOUT.</p>

<p style="margin-top: 1em">LIBIRC_OPTION_STRIPNICKS</p>

<p style="margin-top: 1em">If set, strips the event origins
automatically. Every event has an origin (i.e. who
originated the event). The origin usually looks like
nick!host@ircserver, i.e. like <br>
tim!home@irc.server.net. Such origins can not be used in IRC
commands, and need to be stripped (i.e. host and server part
should be cut off) before using. This can be done <br>
either manually by calling irc_target_get_nick(), or
automatically for all the events if this option is set.</p>

<p style="margin-top: 1em">LIBIRC_OPTION_SSL_NO_VERIFY</p>

<p style="margin-top: 1em">By default the SSL connection is
authenticated by verifying that the certificate presented by
the server is signed by a known trusted certificate
authority. Since those typi&acirc; <br>
cally cost money, some IRC servers use the self-signed
certificates. They provide the benefits of the SSL
connection but since they are not signed by the Certificate
Authority, <br>
their authencity cannot be verified. This option, if set,
disables the certificate verification - the library will
accept any certificate presented by the server.</p>

<p style="margin-top: 1em">This option must be set before
the irc_connect function is called.</p>

<p style="margin-top: 1em">APPENDIX <br>
Frequently asked questions <br>
Why do I get a LIBIRC_ERR_SOCKET error under Win32 when
using a static library? <br>
Because on Win32 you have to initialize the Winsock API
before using it:</p>

<p style="margin-top: 1em">WSADATA wsaData;</p>

<p style="margin-top: 1em">if ( WSAStartup ( MAKEWORD (2,
2), &amp;wsaData) != 0 ) <br>
// report an error</p>

<p style="margin-top: 1em">// Now you can use
libircclient</p>

<p style="margin-top: 1em">You have to do it ONCE in your
application, and since libircclient does not know whether
you already initialized it or not, it does not contain any
Winsock initialization code.</p>

<p style="margin-top: 1em">What does it mean that the IRC
protocol is event-based? <br>
The IRC protocol itself is asynchronous and server-driven.
For you, this means the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; For any IRC
command, it is not possible to obtain an immediate response
whether the command succeed or not. Instead the server will
send the reply in a short (or long) <br>
period of time.</p>

<p style="margin-top: 1em">&Acirc;&middot; For some IRC
command there is no &acirc;success&acirc; response at all.
For example, when you send a text message, IRC server will
not send anything to confirm that the message is <br>
already sent.</p>

<p style="margin-top: 1em">&Acirc;&middot; You can send
several commands to the IRC server, and then receive several
replies regarding every command. The order of the replies
you receive is generally undefined.</p>

<p style="margin-top: 1em">&Acirc;&middot; A lot of IRC
events sent to you is generated by other users, or the IRC
server itself, and are sent to you just when they are
generated.</p>

<p style="margin-top: 1em">&Acirc;&middot; Long lists (for
example, channel lists) are also sent as events. Moreover,
these events could be separated by other events (message or
notices). And it is your responsibil&acirc; <br>
ity to separate the data (using event codes), and use some
sort of data structure that will hold it until the data is
complete. It is not possible to simply query the list <br>
of channels, and expect that its content will immediately
arrive.</p>

<p style="margin-top: 1em">&Acirc;&middot; You may send the
request, and not receive a response in case of success (such
as when you send a message). You may send the request and it
will only succeed when you <br>
receive a response (which may be after you receive ten more
unrelated events). Or you can receive a response without
even sending a request, as it is the case with JOIN - it
<br>
is possible for the server to JOIN you to a specific channel
implicitly.</p>

<p style="margin-top: 1em">&Acirc;&middot; You should be
prepared to expect the unexpected from the IRC server. For
example, the server can change your nick (seen on most
servers, which use nickserv authentication. <br>
You can be &acirc;forced&acirc; to join the channel, to say
something, to leave a channel, to change your usermode and
so on. Listen what IRC server tells you, and do so.</p>

<p style="margin-top: 1em">Why the irc_cmd_join function
does not return an error? <br>
A typical example is the irc_cmd_join() call always returns
success even when you attempt to join a password-protected
channel. Then some time later the IRC server returns an <br>
error. This is because the irc_cmd family of functions
return success when the command is sent to the IRC server.
The asynchronous nature of IRC makes it impossible to obtain
the <br>
command result immediately. Please read the question
above.</p>

<p style="margin-top: 1em">How to register/auth with
NICKSERV? <br>
There is no &acirc;standard&acirc; way. NICKSERV, CHANSERV
and so on are not specified by the RFC. They are IRC
extensions which behave exactly like the other IRC users but
with more power. <br>
Typically their messages are sent via Notice events, so you
can use following algorithm to handle Nickserv
registration:</p>

<p style="margin-top: 1em">static void event_notice
(irc_session_t * session, const char * event, <br>
const char * origin, const char ** params, unsigned int
count) <br>
{ <br>
char buf[256];</p>

<p style="margin-top: 1em">if ( !origin ) <br>
return;</p>

<p style="margin-top: 1em">if ( strcasecmp (origin,
&quot;nickserv&quot;) ) <br>
return;</p>

<p style="margin-top: 1em">if ( strstr (params[1],
&quot;This nick is not registered&quot;) == params[1] ) <br>
{ <br>
sprintf (buf, &quot;REGISTER %s NOMAIL&quot;,
gCfg.irc_nickserv_password); <br>
irc_cmd_msg(session, &quot;nickserv&quot;, buf); <br>
} <br>
else if ( strstr (params[1], &quot;This nickname is
registered and protected&quot;) == params[1] ) <br>
{ <br>
sprintf (buf, &quot;IDENTIFY %s&quot;,
gCfg.irc_nickserv_password); <br>
irc_cmd_msg(session, &quot;nickserv&quot;, buf); <br>
} <br>
else if ( strstr (params[1], &quot;Password accepted - you
are now recognized&quot;) == params[1] ) <br>
printf (&quot;Nickserv authentication succeed.&quot;); <br>
}</p>

<p style="margin-top: 1em">The idea is to parse the
messages sent from NICKSERV, and if they&acirc;re matched
the specific patterns, react on them appropriately.</p>

<p style="margin-top: 1em">What is CTCP? <br>
CTCP abbreviature is deciphered as &acirc;Client-to-Client
Protocol&acirc;. It is used between the IRC clients to query
the remote client for some data, or to send some information
&acirc; for <br>
example, /me messages are sent via CTCP.</p>

<p style="margin-top: 1em">There is no standard list of
possible CTCP requests, and different IRC clients often add
their own CTCP codes. The built-in handler reacts on TIME,
VERSION, PING and FINGER CTCP <br>
queries. If you need to react on other requests,
you&acirc;ll have to write your own CTCP handler. See the
source code of libirc_event_ctcp_internal function to get an
idea how to <br>
write it.</p>

<p style="margin-top: 1em">When I am made a chanop (+o) why
do I not receive the event_umode? <br>
Becoming a channel operator channes the channel mode, not
user mode. Therefore you will receive event_mode and not
event_umode</p>

<p style="margin-top: 1em">If you receive the event_umode
with +o this means your user is an IRC server operator.</p>

<p style="margin-top: 1em">What if my application uses
epoll? <br>
The library only directly supports the select()-based loops
for historic reasons, so epoll and other polling methods are
not supported directly by the library. However but if <br>
necessart, it could be emulated by converting descriptors
between select and epoll as following:</p>

<p style="margin-top: 1em">&Acirc;&middot; Call
irc_add_select_descriptors with an empty FD_SET</p>

<p style="margin-top: 1em">&Acirc;&middot; Extract the
descriptors from the fd_set arrays (remember fd_array is a
bitarray, not the value array). There may be more than one
descriptor in case there are DCC sessions.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pass those
descriptors to poll/epoll using relevant events (i.e. use
the EPOLLIN for the descriptors in the in_set)</p>

<p style="margin-top: 1em">&Acirc;&middot; For those
descriptors which triggered the events, fill up the relevant
in_set and out_set structures (again, remember the
bitmasks!) and pass them to <br>
irc_process_select_descriptors()</p>

<p style="margin-top: 1em">While this is cumbersome, the
operations are very simple (basically bitmask operations on
a small structure) and will not add any significant slowdown
to your application.</p>

<p style="margin-top: 1em">GNU LESSER GENERAL PUBLIC
LICENSE <br>
Version 3, 29 June 2007</p>

<p style="margin-top: 1em">Copyright &Acirc;&copy; 2007
Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</p>

<p style="margin-top: 1em">Everyone is permitted to copy
and distribute verbatim copies of this license document, but
changing it is not allowed.</p>

<p style="margin-top: 1em">This version of the GNU Lesser
General Public License incorporates the terms and conditions
of version 3 of the GNU General Public License, supplemented
by the additional permis&acirc; <br>
sions listed below.</p>

<p style="margin-top: 1em">0. Additional Definitions.</p>

<p style="margin-top: 1em">As used herein, &acirc;this
License&acirc; refers to version 3 of the GNU Lesser General
Public License, and the &acirc;GNU GPL&acirc; refers to
version 3 of the GNU General Public License.</p>

<p style="margin-top: 1em">&acirc;The Library&acirc; refers
to a covered work governed by this License, other than an
Application or a Combined Work as defined below.</p>

<p style="margin-top: 1em">An &acirc;Application&acirc; is
any work that makes use of an interface provided by the
Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by <br>
the Library is deemed a mode of using an interface provided
by the Library.</p>

<p style="margin-top: 1em">A &acirc;Combined Work&acirc; is
a work produced by combining or linking an Application with
the Library. The particular version of the Library with
which the Combined Work was made is also <br>
called the &acirc;Linked Version&acirc;.</p>

<p style="margin-top: 1em">The &acirc;Minimal Corresponding
Source&acirc; for a Combined Work means the Corresponding
Source for the Combined Work, excluding any source code for
portions of the Combined Work that, <br>
considered in isolation, are based on the Application, and
not on the Linked Version.</p>

<p style="margin-top: 1em">The &acirc;Corresponding
Application Code&acirc; for a Combined Work means the object
code and/or source code for the Application, including any
data and utility programs needed for repro&acirc; <br>
ducing the Combined Work from the Application, but excluding
the System Libraries of the Combined Work. 1. Exception to
Section 3 of the GNU GPL.</p>

<p style="margin-top: 1em">You may convey a covered work
under sections 3 and 4 of this License without being bound
by section 3 of the GNU GPL. 2. Conveying Modified
Versions.</p>

<p style="margin-top: 1em">If you modify a copy of the
Library, and, in your modifications, a facility refers to a
function or data to be supplied by an Application that uses
the facility (other than as an <br>
argument passed when the facility is invoked), then you may
convey a copy of the modified version:</p>

<p style="margin-top: 1em">a. under this License, provided
that you make a good faith effort to ensure that, in the
event an Application does not supply the function or data,
the facility still oper&acirc; <br>
ates, and performs whatever part of its purpose remains
meaningful, or</p>

<p style="margin-top: 1em">b. under the GNU GPL, with none
of the additional permissions of this License applicable to
that copy.</p>

<p style="margin-top: 1em">3. Object Code Incorporating
Material from Library Header Files.</p>

<p style="margin-top: 1em">The object code form of an
Application may incorporate material from a header file that
is part of the Library. You may convey such object code
under terms of your choice, pro&acirc; <br>
vided that, if the incorporated material is not limited to
numerical parameters, data structure layouts and accessors,
or small macros, inline functions and templates (ten or <br>
fewer lines in length), you do both of the following:</p>

<p style="margin-top: 1em">a. Give prominent notice with
each copy of the object code that the Library is used in it
and that the Library and its use are covered by this
License.</p>

<p style="margin-top: 1em">b. Accompany the object code
with a copy of the GNU GPL and this license document.</p>

<p style="margin-top: 1em">4. Combined Works.</p>

<p style="margin-top: 1em">You may convey a Combined Work
under terms of your choice that, taken together, effectively
do not restrict modification of the portions of the Library
contained in the Combined <br>
Work and reverse engineering for debugging such
modifications, if you also do each of the following:</p>

<p style="margin-top: 1em">a. Give prominent notice with
each copy of the Combined Work that the Library is used in
it and that the Library and its use are covered by this
License.</p>

<p style="margin-top: 1em">b. Accompany the Combined Work
with a copy of the GNU GPL and this license document.</p>

<p style="margin-top: 1em">c. For a Combined Work that
displays copyright notices during execution, include the
copyright notice for the Library among these notices, as
well as a reference directing the <br>
user to the copies of the GNU GPL and this license
document.</p>

<p style="margin-top: 1em">d.</p>

<p style="margin-top: 1em">Do one of the following:</p>

<p style="margin-top: 1em">0. Convey the Minimal
Corresponding Source under the terms of this License, and
the Corresponding Application Code in a form suitable for,
and under terms that per&acirc; <br>
mit, the user to recombine or relink the Application with a
modified version of the Linked Version to produce a modified
Combined Work, in the manner specified <br>
by section 6 of the GNU GPL for conveying Corresponding
Source.</p>

<p style="margin-top: 1em">1. Use a suitable shared library
mechanism for linking with the Library. A suitable mechanism
is one that (a) uses at run time a copy of the Library
already present <br>
on the user&rsquo;s computer system, and (b) will operate
properly with a modified version of the Library that is
interface-compatible with the Linked Version.</p>

<p style="margin-top: 1em">e. Provide Installation
Information, but only if you would otherwise be required to
provide such information under section 6 of the GNU GPL, and
only to the extent that such <br>
information is necessary to install and execute a modified
version of the Combined Work produced by recombining or
relinking the Application with a modified version of the
<br>
Linked Version. (If you use option 4d0, the Installation
Information must accompany the Minimal Corresponding Source
and Corresponding Application Code. If you use option <br>
4d1, you must provide the Installation Information in the
manner specified by section 6 of the GNU GPL for conveying
Corresponding Source.)</p>

<p style="margin-top: 1em">5. Combined Libraries.</p>

<p style="margin-top: 1em">You may place library facilities
that are a work based on the Library side by side in a
single library together with other library facilities that
are not Applications and are <br>
not covered by this License, and convey such a combined
library under terms of your choice, if you do both of the
following:</p>

<p style="margin-top: 1em">a. Accompany the combined
library with a copy of the same work based on the Library,
uncombined with any other library facilities, conveyed under
the terms of this License.</p>

<p style="margin-top: 1em">b. Give prominent notice with
the combined library that part of it is a work based on the
Library, and explaining where to find the accompanying
uncombined form of the same <br>
work.</p>

<p style="margin-top: 1em">6. Revised Versions of the GNU
Lesser General Public License.</p>

<p style="margin-top: 1em">The Free Software Foundation may
publish revised and/or new versions of the GNU Lesser
General Public License from time to time. Such new versions
will be similar in spirit to <br>
the present version, but may differ in detail to address new
problems or concerns.</p>

<p style="margin-top: 1em">Each version is given a
distinguishing version number. If the Library as you
received it specifies that a certain numbered version of the
GNU Lesser General Public License &acirc;or <br>
any later version&acirc; applies to it, you have the option
of following the terms and conditions either of that
published version or of any later version published by the
Free Soft&acirc; <br>
ware Foundation. If the Library as you received it does not
specify a version number of the GNU Lesser General Public
License, you may choose any version of the GNU Lesser
Gen&acirc; <br>
eral Public License ever published by the Free Software
Foundation.</p>

<p style="margin-top: 1em">If the Library as you received
it specifies that a proxy can decide whether future versions
of the GNU Lesser General Public License shall apply, that
proxy&rsquo;s public statement of <br>
acceptance of any version is permanent authorization for you
to choose that version for the Library.</p>

<p style="margin-top: 1em">Indices and tables <br>
&Acirc;&middot; genindex</p>

<p style="margin-top: 1em">&Acirc;&middot; modindex</p>

<p style="margin-top: 1em">&Acirc;&middot; search</p>

<p style="margin-top: 1em">AUTHOR <br>
George Yunaev</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2013, George Yunaev</p>

<p style="margin-top: 1em">1.7 May 09, 2014
LIBIRCCLIENT(1)</p>
<hr>
</body>
</html>
