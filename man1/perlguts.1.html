<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLGUTS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLGUTS(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLGUTS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlguts - Introduction to the Perl API
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document attempts to describe how to use the Perl API, as well as to
  provide some info on the basic workings of the Perl core. It is far from
  complete and probably contains many errors. Please refer any questions or
  comments to the author below.
<h1 class="Sh" title="Sh" id="Variables"><a class="selflink" href="#Variables">Variables</a></h1>
<h2 class="Ss" title="Ss" id="Datatypes"><a class="selflink" href="#Datatypes">Datatypes</a></h2>
Perl has three typedefs that handle Perl's three main data types:
<div class="Pp"></div>
<pre>
    SV  Scalar Value
    AV  Array Value
    HV  Hash Value
</pre>
<div class="Pp"></div>
Each typedef has specific routines that manipulate the various data types.
<h2 class="Ss" title="Ss" id="What_is_an_&quot;IV&quot;?"><a class="selflink" href="#What_is_an_&quot;IV&quot;?">What
  is an &quot;IV&quot;?</a></h2>
Perl uses a special typedef IV which is a simple signed integer type that is
  guaranteed to be large enough to hold a pointer (as well as an integer).
  Additionally, there is the UV, which is simply an unsigned IV.
<div class="Pp"></div>
Perl also uses two special typedefs, I32 and I16, which will always be at least
  32-bits and 16-bits long, respectively. (Again, there are U32 and U16, as
  well.) They will usually be exactly 32 and 16 bits long, but on Crays they
  will both be 64 bits.
<h2 class="Ss" title="Ss" id="Working_with_SVs"><a class="selflink" href="#Working_with_SVs">Working
  with SVs</a></h2>
An SV can be created and loaded with one command. There are five types of values
  that can be loaded: an integer value (IV), an unsigned integer value (UV), a
  double (NV), a string (PV), and another scalar (SV).
<div class="Pp"></div>
The seven routines are:
<div class="Pp"></div>
<pre>
    SV*  newSViv(IV);
    SV*  newSVuv(UV);
    SV*  newSVnv(double);
    SV*  newSVpv(const char*, STRLEN);
    SV*  newSVpvn(const char*, STRLEN);
    SV*  newSVpvf(const char*, ...);
    SV*  newSVsv(SV*);
</pre>
<div class="Pp"></div>
&quot;STRLEN&quot; is an integer type (Size_t, usually defined as size_t in
  <i>config.h</i>) guaranteed to be large enough to represent the size of any
  string that perl can handle.
<div class="Pp"></div>
In the unlikely case of a SV requiring more complex initialisation, you can
  create an empty SV with newSV(len). If &quot;len&quot; is 0 an empty SV of
  type NULL is returned, else an SV of type PV is returned with len + 1 (for the
  NUL) bytes of storage allocated, accessible via SvPVX. In both cases the SV
  has the undef value.
<div class="Pp"></div>
<pre>
    SV *sv = newSV(0);   /* no storage allocated  */
    SV *sv = newSV(10);  /* 10 (+1) bytes of uninitialised storage
                          * allocated */
</pre>
<div class="Pp"></div>
To change the value of an <i>already-existing</i> SV, there are eight routines:
<div class="Pp"></div>
<pre>
    void  sv_setiv(SV*, IV);
    void  sv_setuv(SV*, UV);
    void  sv_setnv(SV*, double);
    void  sv_setpv(SV*, const char*);
    void  sv_setpvn(SV*, const char*, STRLEN)
    void  sv_setpvf(SV*, const char*, ...);
    void  sv_vsetpvfn(SV*, const char*, STRLEN, va_list *,
                                                    SV **, I32, bool *);
    void  sv_setsv(SV*, SV*);
</pre>
<div class="Pp"></div>
Notice that you can choose to specify the length of the string to be assigned by
  using &quot;sv_setpvn&quot;, &quot;newSVpvn&quot;, or &quot;newSVpv&quot;, or
  you may allow Perl to calculate the length by using &quot;sv_setpv&quot; or by
  specifying 0 as the second argument to &quot;newSVpv&quot;. Be warned, though,
  that Perl will determine the string's length by using &quot;strlen&quot;,
  which depends on the string terminating with a NUL character, and not
  otherwise containing NULs.
<div class="Pp"></div>
The arguments of &quot;sv_setpvf&quot; are processed like &quot;sprintf&quot;,
  and the formatted output becomes the value.
<div class="Pp"></div>
&quot;sv_vsetpvfn&quot; is an analogue of &quot;vsprintf&quot;, but it allows
  you to specify either a pointer to a variable argument list or the address and
  length of an array of SVs. The last argument points to a boolean; on return,
  if that boolean is true, then locale-specific information has been used to
  format the string, and the string's contents are therefore untrustworthy (see
  perlsec). This pointer may be NULL if that information is not important. Note
  that this function requires you to specify the length of the format.
<div class="Pp"></div>
The &quot;sv_set*()&quot; functions are not generic enough to operate on values
  that have &quot;magic&quot;. See &quot;Magic Virtual Tables&quot; later in
  this document.
<div class="Pp"></div>
All SVs that contain strings should be terminated with a NUL character. If it is
  not NUL-terminated there is a risk of core dumps and corruptions from code
  which passes the string to C functions or system calls which expect a
  NUL-terminated string. Perl's own functions typically add a trailing NUL for
  this reason. Nevertheless, you should be very careful when you pass a string
  stored in an SV to a C function or system call.
<div class="Pp"></div>
To access the actual value that an SV points to, you can use the macros:
<div class="Pp"></div>
<pre>
    SvIV(SV*)
    SvUV(SV*)
    SvNV(SV*)
    SvPV(SV*, STRLEN len)
    SvPV_nolen(SV*)
</pre>
<div class="Pp"></div>
which will automatically coerce the actual scalar type into an IV, UV, double,
  or string.
<div class="Pp"></div>
In the &quot;SvPV&quot; macro, the length of the string returned is placed into
  the variable &quot;len&quot; (this is a macro, so you do <i>not</i> use
  &amp;len). If you do not care what the length of the data is, use the
  &quot;SvPV_nolen&quot; macro. Historically the &quot;SvPV&quot; macro with the
  global variable &quot;PL_na&quot; has been used in this case. But that can be
  quite inefficient because &quot;PL_na&quot; must be accessed in thread-local
  storage in threaded Perl. In any case, remember that Perl allows arbitrary
  strings of data that may both contain NULs and might not be terminated by a
  NUL.
<div class="Pp"></div>
Also remember that C doesn't allow you to safely say &quot;foo(SvPV(s, len),
  len);&quot;. It might work with your compiler, but it won't work for everyone.
  Break this sort of statement up into separate assignments:
<div class="Pp"></div>
<pre>
    SV *s;
    STRLEN len;
    char *ptr;
    ptr = SvPV(s, len);
    foo(ptr, len);
</pre>
<div class="Pp"></div>
If you want to know if the scalar value is TRUE, you can use:
<div class="Pp"></div>
<pre>
    SvTRUE(SV*)
</pre>
<div class="Pp"></div>
Although Perl will automatically grow strings for you, if you need to force Perl
  to allocate more memory for your SV, you can use the macro
<div class="Pp"></div>
<pre>
    SvGROW(SV*, STRLEN newlen)
</pre>
<div class="Pp"></div>
which will determine if more memory needs to be allocated. If so, it will call
  the function &quot;sv_grow&quot;. Note that &quot;SvGROW&quot; can only
  increase, not decrease, the allocated memory of an SV and that it does not
  automatically add space for the trailing NUL byte (perl's own string functions
  typically do &quot;SvGROW(sv, len + 1)&quot;).
<div class="Pp"></div>
If you have an SV and want to know what kind of data Perl thinks is stored in
  it, you can use the following macros to check the type of SV you have.
<div class="Pp"></div>
<pre>
    SvIOK(SV*)
    SvNOK(SV*)
    SvPOK(SV*)
</pre>
<div class="Pp"></div>
You can get and set the current length of the string stored in an SV with the
  following macros:
<div class="Pp"></div>
<pre>
    SvCUR(SV*)
    SvCUR_set(SV*, I32 val)
</pre>
<div class="Pp"></div>
You can also get a pointer to the end of the string stored in the SV with the
  macro:
<div class="Pp"></div>
<pre>
    SvEND(SV*)
</pre>
<div class="Pp"></div>
But note that these last three macros are valid only if &quot;SvPOK()&quot; is
  true.
<div class="Pp"></div>
If you want to append something to the end of string stored in an
  &quot;SV*&quot;, you can use the following functions:
<div class="Pp"></div>
<pre>
    void  sv_catpv(SV*, const char*);
    void  sv_catpvn(SV*, const char*, STRLEN);
    void  sv_catpvf(SV*, const char*, ...);
    void  sv_vcatpvfn(SV*, const char*, STRLEN, va_list *, SV **,
                                                             I32, bool);
    void  sv_catsv(SV*, SV*);
</pre>
<div class="Pp"></div>
The first function calculates the length of the string to be appended by using
  &quot;strlen&quot;. In the second, you specify the length of the string
  yourself. The third function processes its arguments like &quot;sprintf&quot;
  and appends the formatted output. The fourth function works like
  &quot;vsprintf&quot;. You can specify the address and length of an array of
  SVs instead of the va_list argument. The fifth function extends the string
  stored in the first SV with the string stored in the second SV. It also forces
  the second SV to be interpreted as a string.
<div class="Pp"></div>
The &quot;sv_cat*()&quot; functions are not generic enough to operate on values
  that have &quot;magic&quot;. See &quot;Magic Virtual Tables&quot; later in
  this document.
<div class="Pp"></div>
If you know the name of a scalar variable, you can get a pointer to its SV by
  using the following:
<div class="Pp"></div>
<pre>
    SV*  get_sv(&quot;package::varname&quot;, 0);
</pre>
<div class="Pp"></div>
This returns NULL if the variable does not exist.
<div class="Pp"></div>
If you want to know if this variable (or any other SV) is actually
  &quot;defined&quot;, you can call:
<div class="Pp"></div>
<pre>
    SvOK(SV*)
</pre>
<div class="Pp"></div>
The scalar &quot;undef&quot; value is stored in an SV instance called
  &quot;PL_sv_undef&quot;.
<div class="Pp"></div>
Its address can be used whenever an &quot;SV*&quot; is needed. Make sure that
  you don't try to compare a random sv with &amp;PL_sv_undef. For example when
  interfacing Perl code, it'll work correctly for:
<div class="Pp"></div>
<pre>
  foo(undef);
</pre>
<div class="Pp"></div>
But won't work when called as:
<div class="Pp"></div>
<pre>
  $x = undef;
  foo($x);
</pre>
<div class="Pp"></div>
So to repeat always use <i>SvOK()</i> to check whether an sv is defined.
<div class="Pp"></div>
Also you have to be careful when using &amp;PL_sv_undef as a value in AVs or HVs
  (see &quot;AVs, HVs and undefined values&quot;).
<div class="Pp"></div>
There are also the two values &quot;PL_sv_yes&quot; and &quot;PL_sv_no&quot;,
  which contain boolean TRUE and FALSE values, respectively. Like
  &quot;PL_sv_undef&quot;, their addresses can be used whenever an
  &quot;SV*&quot; is needed.
<div class="Pp"></div>
Do not be fooled into thinking that &quot;(SV *) 0&quot; is the same as
  &amp;PL_sv_undef. Take this code:
<div class="Pp"></div>
<pre>
    SV* sv = (SV*) 0;
    if (I-am-to-return-a-real-value) {
            sv = sv_2mortal(newSViv(42));
    }
    sv_setsv(ST(0), sv);
</pre>
<div class="Pp"></div>
This code tries to return a new SV (which contains the value 42) if it should
  return a real value, or undef otherwise. Instead it has returned a NULL
  pointer which, somewhere down the line, will cause a segmentation violation,
  bus error, or just weird results. Change the zero to &amp;PL_sv_undef in the
  first line and all will be well.
<div class="Pp"></div>
To free an SV that you've created, call &quot;SvREFCNT_dec(SV*)&quot;. Normally
  this call is not necessary (see &quot;Reference Counts and Mortality&quot;).
<h2 class="Ss" title="Ss" id="Offsets"><a class="selflink" href="#Offsets">Offsets</a></h2>
Perl provides the function &quot;sv_chop&quot; to efficiently remove characters
  from the beginning of a string; you give it an SV and a pointer to somewhere
  inside the PV, and it discards everything before the pointer. The efficiency
  comes by means of a little hack: instead of actually removing the characters,
  &quot;sv_chop&quot; sets the flag &quot;OOK&quot; (offset OK) to signal to
  other functions that the offset hack is in effect, and it puts the number of
  bytes chopped off into the IV field of the SV. It then moves the PV pointer
  (called &quot;SvPVX&quot;) forward that many bytes, and adjusts
  &quot;SvCUR&quot; and &quot;SvLEN&quot;.
<div class="Pp"></div>
Hence, at this point, the start of the buffer that we allocated lives at
  &quot;SvPVX(sv) - SvIV(sv)&quot; in memory and the PV pointer is pointing into
  the middle of this allocated storage.
<div class="Pp"></div>
This is best demonstrated by example:
<div class="Pp"></div>
<pre>
  % ./perl -Ilib -MDevel::Peek -le '$a=&quot;12345&quot;; $a=~s/.//; Dump($a)'
  SV = PVIV(0x8128450) at 0x81340f0
    REFCNT = 1
    FLAGS = (POK,OOK,pPOK)
    IV = 1  (OFFSET)
    PV = 0x8135781 ( &quot;1&quot; . ) &quot;2345&quot;\0
    CUR = 4
    LEN = 5
</pre>
<div class="Pp"></div>
Here the number of bytes chopped off (1) is put into IV, and
  &quot;Devel::Peek::Dump&quot; helpfully reminds us that this is an offset. The
  portion of the string between the &quot;real&quot; and the &quot;fake&quot;
  beginnings is shown in parentheses, and the values of &quot;SvCUR&quot; and
  &quot;SvLEN&quot; reflect the fake beginning, not the real one.
<div class="Pp"></div>
Something similar to the offset hack is performed on AVs to enable efficient
  shifting and splicing off the beginning of the array; while
  &quot;AvARRAY&quot; points to the first element in the array that is visible
  from Perl, &quot;AvALLOC&quot; points to the real start of the C array. These
  are usually the same, but a &quot;shift&quot; operation can be carried out by
  increasing &quot;AvARRAY&quot; by one and decreasing &quot;AvFILL&quot; and
  &quot;AvMAX&quot;. Again, the location of the real start of the C array only
  comes into play when freeing the array. See &quot;av_shift&quot; in
  <i>av.c</i>.
<h2 class="Ss" title="Ss" id="What's_Really_Stored_in_an_SV?"><a class="selflink" href="#What's_Really_Stored_in_an_SV?">What's
  Really Stored in an SV?</a></h2>
Recall that the usual method of determining the type of scalar you have is to
  use &quot;Sv*OK&quot; macros. Because a scalar can be both a number and a
  string, usually these macros will always return TRUE and calling the
  &quot;Sv*V&quot; macros will do the appropriate conversion of string to
  integer/double or integer/double to string.
<div class="Pp"></div>
If you <i>really</i> need to know if you have an integer, double, or string
  pointer in an SV, you can use the following three macros instead:
<div class="Pp"></div>
<pre>
    SvIOKp(SV*)
    SvNOKp(SV*)
    SvPOKp(SV*)
</pre>
<div class="Pp"></div>
These will tell you if you truly have an integer, double, or string pointer
  stored in your SV. The &quot;p&quot; stands for private.
<div class="Pp"></div>
There are various ways in which the private and public flags may differ. For
  example, a tied SV may have a valid underlying value in the IV slot (so SvIOKp
  is true), but the data should be accessed via the FETCH routine rather than
  directly, so SvIOK is false. Another is when numeric conversion has occurred
  and precision has been lost: only the private flag is set on 'lossy' values.
  So when an NV is converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will
  be set, while SvIOK wont be.
<div class="Pp"></div>
In general, though, it's best to use the &quot;Sv*V&quot; macros.
<h2 class="Ss" title="Ss" id="Working_with_AVs"><a class="selflink" href="#Working_with_AVs">Working
  with AVs</a></h2>
There are two ways to create and load an AV. The first method creates an empty
  AV:
<div class="Pp"></div>
<pre>
    AV*  newAV();
</pre>
<div class="Pp"></div>
The second method both creates the AV and initially populates it with SVs:
<div class="Pp"></div>
<pre>
    AV*  av_make(I32 num, SV **ptr);
</pre>
<div class="Pp"></div>
The second argument points to an array containing &quot;num&quot;
  &quot;SV*&quot;'s. Once the AV has been created, the SVs can be destroyed, if
  so desired.
<div class="Pp"></div>
Once the AV has been created, the following operations are possible on it:
<div class="Pp"></div>
<pre>
    void  av_push(AV*, SV*);
    SV*   av_pop(AV*);
    SV*   av_shift(AV*);
    void  av_unshift(AV*, I32 num);
</pre>
<div class="Pp"></div>
These should be familiar operations, with the exception of
  &quot;av_unshift&quot;. This routine adds &quot;num&quot; elements at the
  front of the array with the &quot;undef&quot; value. You must then use
  &quot;av_store&quot; (described below) to assign values to these new elements.
<div class="Pp"></div>
Here are some other functions:
<div class="Pp"></div>
<pre>
    I32   av_len(AV*);
    SV**  av_fetch(AV*, I32 key, I32 lval);
    SV**  av_store(AV*, I32 key, SV* val);
</pre>
<div class="Pp"></div>
The &quot;av_len&quot; function returns the highest index value in an array
  (just like $#array in Perl). If the array is empty, -1 is returned. The
  &quot;av_fetch&quot; function returns the value at index &quot;key&quot;, but
  if &quot;lval&quot; is non-zero, then &quot;av_fetch&quot; will store an undef
  value at that index. The &quot;av_store&quot; function stores the value
  &quot;val&quot; at index &quot;key&quot;, and does not increment the reference
  count of &quot;val&quot;. Thus the caller is responsible for taking care of
  that, and if &quot;av_store&quot; returns NULL, the caller will have to
  decrement the reference count to avoid a memory leak. Note that
  &quot;av_fetch&quot; and &quot;av_store&quot; both return &quot;SV**&quot;'s,
  not &quot;SV*&quot;'s as their return value.
<div class="Pp"></div>
A few more:
<div class="Pp"></div>
<pre>
    void  av_clear(AV*);
    void  av_undef(AV*);
    void  av_extend(AV*, I32 key);
</pre>
<div class="Pp"></div>
The &quot;av_clear&quot; function deletes all the elements in the AV* array, but
  does not actually delete the array itself. The &quot;av_undef&quot; function
  will delete all the elements in the array plus the array itself. The
  &quot;av_extend&quot; function extends the array so that it contains at least
  &quot;key+1&quot; elements. If &quot;key+1&quot; is less than the currently
  allocated length of the array, then nothing is done.
<div class="Pp"></div>
If you know the name of an array variable, you can get a pointer to its AV by
  using the following:
<div class="Pp"></div>
<pre>
    AV*  get_av(&quot;package::varname&quot;, 0);
</pre>
<div class="Pp"></div>
This returns NULL if the variable does not exist.
<div class="Pp"></div>
See &quot;Understanding the Magic of Tied Hashes and Arrays&quot; for more
  information on how to use the array access functions on tied arrays.
<h2 class="Ss" title="Ss" id="Working_with_HVs"><a class="selflink" href="#Working_with_HVs">Working
  with HVs</a></h2>
To create an HV, you use the following routine:
<div class="Pp"></div>
<pre>
    HV*  newHV();
</pre>
<div class="Pp"></div>
Once the HV has been created, the following operations are possible on it:
<div class="Pp"></div>
<pre>
    SV**  hv_store(HV*, const char* key, U32 klen, SV* val, U32 hash);
    SV**  hv_fetch(HV*, const char* key, U32 klen, I32 lval);
</pre>
<div class="Pp"></div>
The &quot;klen&quot; parameter is the length of the key being passed in (Note
  that you cannot pass 0 in as a value of &quot;klen&quot; to tell Perl to
  measure the length of the key). The &quot;val&quot; argument contains the SV
  pointer to the scalar being stored, and &quot;hash&quot; is the precomputed
  hash value (zero if you want &quot;hv_store&quot; to calculate it for you).
  The &quot;lval&quot; parameter indicates whether this fetch is actually a part
  of a store operation, in which case a new undefined value will be added to the
  HV with the supplied key and &quot;hv_fetch&quot; will return as if the value
  had already existed.
<div class="Pp"></div>
Remember that &quot;hv_store&quot; and &quot;hv_fetch&quot; return
  &quot;SV**&quot;'s and not just &quot;SV*&quot;. To access the scalar value,
  you must first dereference the return value. However, you should check to make
  sure that the return value is not NULL before dereferencing it.
<div class="Pp"></div>
The first of these two functions checks if a hash table entry exists, and the
  second deletes it.
<div class="Pp"></div>
<pre>
    bool  hv_exists(HV*, const char* key, U32 klen);
    SV*   hv_delete(HV*, const char* key, U32 klen, I32 flags);
</pre>
<div class="Pp"></div>
If &quot;flags&quot; does not include the &quot;G_DISCARD&quot; flag then
  &quot;hv_delete&quot; will create and return a mortal copy of the deleted
  value.
<div class="Pp"></div>
And more miscellaneous functions:
<div class="Pp"></div>
<pre>
    void   hv_clear(HV*);
    void   hv_undef(HV*);
</pre>
<div class="Pp"></div>
Like their AV counterparts, &quot;hv_clear&quot; deletes all the entries in the
  hash table but does not actually delete the hash table. The
  &quot;hv_undef&quot; deletes both the entries and the hash table itself.
<div class="Pp"></div>
Perl keeps the actual data in a linked list of structures with a typedef of HE.
  These contain the actual key and value pointers (plus extra administrative
  overhead). The key is a string pointer; the value is an &quot;SV*&quot;.
  However, once you have an &quot;HE*&quot;, to get the actual key and value,
  use the routines specified below.
<div class="Pp"></div>
<pre>
    I32    hv_iterinit(HV*);
            /* Prepares starting point to traverse hash table */
    HE*    hv_iternext(HV*);
            /* Get the next entry, and return a pointer to a
               structure that has both the key and value */
    char*  hv_iterkey(HE* entry, I32* retlen);
            /* Get the key from an HE structure and also return
               the length of the key string */
    SV*    hv_iterval(HV*, HE* entry);
            /* Return an SV pointer to the value of the HE
               structure */
    SV*    hv_iternextsv(HV*, char** key, I32* retlen);
            /* This convenience routine combines hv_iternext,
               hv_iterkey, and hv_iterval.  The key and retlen
               arguments are return values for the key and its
               length.  The value is returned in the SV* argument */
</pre>
<div class="Pp"></div>
If you know the name of a hash variable, you can get a pointer to its HV by
  using the following:
<div class="Pp"></div>
<pre>
    HV*  get_hv(&quot;package::varname&quot;, 0);
</pre>
<div class="Pp"></div>
This returns NULL if the variable does not exist.
<div class="Pp"></div>
The hash algorithm is defined in the &quot;PERL_HASH(hash, key, klen)&quot;
  macro:
<div class="Pp"></div>
<pre>
    hash = 0;
    while (klen--)
        hash = (hash * 33) + *key++;
    hash = hash + (hash &gt;&gt; 5);                  /* after 5.6 */
</pre>
<div class="Pp"></div>
The last step was added in version 5.6 to improve distribution of lower bits in
  the resulting hash value.
<div class="Pp"></div>
See &quot;Understanding the Magic of Tied Hashes and Arrays&quot; for more
  information on how to use the hash access functions on tied hashes.
<h2 class="Ss" title="Ss" id="Hash_API_Extensions"><a class="selflink" href="#Hash_API_Extensions">Hash
  API Extensions</a></h2>
Beginning with version 5.004, the following functions are also supported:
<div class="Pp"></div>
<pre>
    HE*     hv_fetch_ent  (HV* tb, SV* key, I32 lval, U32 hash);
    HE*     hv_store_ent  (HV* tb, SV* key, SV* val, U32 hash);
    bool    hv_exists_ent (HV* tb, SV* key, U32 hash);
    SV*     hv_delete_ent (HV* tb, SV* key, I32 flags, U32 hash);
    SV*     hv_iterkeysv  (HE* entry);
</pre>
<div class="Pp"></div>
Note that these functions take &quot;SV*&quot; keys, which simplifies writing of
  extension code that deals with hash structures. These functions also allow
  passing of &quot;SV*&quot; keys to &quot;tie&quot; functions without forcing
  you to stringify the keys (unlike the previous set of functions).
<div class="Pp"></div>
They also return and accept whole hash entries (&quot;HE*&quot;), making their
  use more efficient (since the hash number for a particular string doesn't have
  to be recomputed every time). See perlapi for detailed descriptions.
<div class="Pp"></div>
The following macros must always be used to access the contents of hash entries.
  Note that the arguments to these macros must be simple variables, since they
  may get evaluated more than once. See perlapi for detailed descriptions of
  these macros.
<div class="Pp"></div>
<pre>
    HePV(HE* he, STRLEN len)
    HeVAL(HE* he)
    HeHASH(HE* he)
    HeSVKEY(HE* he)
    HeSVKEY_force(HE* he)
    HeSVKEY_set(HE* he, SV* sv)
</pre>
<div class="Pp"></div>
These two lower level macros are defined, but must only be used when dealing
  with keys that are not &quot;SV*&quot;s:
<div class="Pp"></div>
<pre>
    HeKEY(HE* he)
    HeKLEN(HE* he)
</pre>
<div class="Pp"></div>
Note that both &quot;hv_store&quot; and &quot;hv_store_ent&quot; do not
  increment the reference count of the stored &quot;val&quot;, which is the
  caller's responsibility. If these functions return a NULL value, the caller
  will usually have to decrement the reference count of &quot;val&quot; to avoid
  a memory leak.
<h2 class="Ss" title="Ss" id="AVs,_HVs_and_undefined_values"><a class="selflink" href="#AVs,_HVs_and_undefined_values">AVs,
  HVs and undefined values</a></h2>
Sometimes you have to store undefined values in AVs or HVs. Although this may be
  a rare case, it can be tricky. That's because you're used to using
  &amp;PL_sv_undef if you need an undefined SV.
<div class="Pp"></div>
For example, intuition tells you that this XS code:
<div class="Pp"></div>
<pre>
    AV *av = newAV();
    av_store( av, 0, &amp;PL_sv_undef );
</pre>
<div class="Pp"></div>
is equivalent to this Perl code:
<div class="Pp"></div>
<pre>
    my @av;
    $av[0] = undef;
</pre>
<div class="Pp"></div>
Unfortunately, this isn't true. AVs use &amp;PL_sv_undef as a marker for
  indicating that an array element has not yet been initialized. Thus,
  &quot;exists $av[0]&quot; would be true for the above Perl code, but false for
  the array generated by the XS code.
<div class="Pp"></div>
Other problems can occur when storing &amp;PL_sv_undef in HVs:
<div class="Pp"></div>
<pre>
    hv_store( hv, &quot;key&quot;, 3, &amp;PL_sv_undef, 0 );
</pre>
<div class="Pp"></div>
This will indeed make the value &quot;undef&quot;, but if you try to modify the
  value of &quot;key&quot;, you'll get the following error:
<div class="Pp"></div>
<pre>
    Modification of non-creatable hash value attempted
</pre>
<div class="Pp"></div>
In perl 5.8.0, &amp;PL_sv_undef was also used to mark placeholders in restricted
  hashes. This caused such hash entries not to appear when iterating over the
  hash or when checking for the keys with the &quot;hv_exists&quot; function.
<div class="Pp"></div>
You can run into similar problems when you store &amp;PL_sv_yes or &amp;PL_sv_no
  into AVs or HVs. Trying to modify such elements will give you the following
  error:
<div class="Pp"></div>
<pre>
    Modification of a read-only value attempted
</pre>
<div class="Pp"></div>
To make a long story short, you can use the special variables &amp;PL_sv_undef,
  &amp;PL_sv_yes and &amp;PL_sv_no with AVs and HVs, but you have to make sure
  you know what you're doing.
<div class="Pp"></div>
Generally, if you want to store an undefined value in an AV or HV, you should
  not use &amp;PL_sv_undef, but rather create a new undefined value using the
  &quot;newSV&quot; function, for example:
<div class="Pp"></div>
<pre>
    av_store( av, 42, newSV(0) );
    hv_store( hv, &quot;foo&quot;, 3, newSV(0), 0 );
</pre>
<h2 class="Ss" title="Ss" id="References"><a class="selflink" href="#References">References</a></h2>
References are a special type of scalar that point to other data types
  (including other references).
<div class="Pp"></div>
To create a reference, use either of the following functions:
<div class="Pp"></div>
<pre>
    SV* newRV_inc((SV*) thing);
    SV* newRV_noinc((SV*) thing);
</pre>
<div class="Pp"></div>
The &quot;thing&quot; argument can be any of an &quot;SV*&quot;,
  &quot;AV*&quot;, or &quot;HV*&quot;. The functions are identical except that
  &quot;newRV_inc&quot; increments the reference count of the &quot;thing&quot;,
  while &quot;newRV_noinc&quot; does not. For historical reasons,
  &quot;newRV&quot; is a synonym for &quot;newRV_inc&quot;.
<div class="Pp"></div>
Once you have a reference, you can use the following macro to dereference the
  reference:
<div class="Pp"></div>
<pre>
    SvRV(SV*)
</pre>
<div class="Pp"></div>
then call the appropriate routines, casting the returned &quot;SV*&quot; to
  either an &quot;AV*&quot; or &quot;HV*&quot;, if required.
<div class="Pp"></div>
To determine if an SV is a reference, you can use the following macro:
<div class="Pp"></div>
<pre>
    SvROK(SV*)
</pre>
<div class="Pp"></div>
To discover what type of value the reference refers to, use the following macro
  and then check the return value.
<div class="Pp"></div>
<pre>
    SvTYPE(SvRV(SV*))
</pre>
<div class="Pp"></div>
The most useful types that will be returned are:
<div class="Pp"></div>
<pre>
    SVt_IV    Scalar
    SVt_NV    Scalar
    SVt_PV    Scalar
    SVt_RV    Scalar
    SVt_PVAV  Array
    SVt_PVHV  Hash
    SVt_PVCV  Code
    SVt_PVGV  Glob (possibly a file handle)
    SVt_PVMG  Blessed or Magical Scalar
</pre>
<div class="Pp"></div>
See the <i>sv.h</i> header file for more details.
<h2 class="Ss" title="Ss" id="Blessed_References_and_Class_Objects"><a class="selflink" href="#Blessed_References_and_Class_Objects">Blessed
  References and Class Objects</a></h2>
References are also used to support object-oriented programming. In perl's OO
  lexicon, an object is simply a reference that has been blessed into a package
  (or class). Once blessed, the programmer may now use the reference to access
  the various methods in the class.
<div class="Pp"></div>
A reference can be blessed into a package with the following function:
<div class="Pp"></div>
<pre>
    SV* sv_bless(SV* sv, HV* stash);
</pre>
<div class="Pp"></div>
The &quot;sv&quot; argument must be a reference value. The &quot;stash&quot;
  argument specifies which class the reference will belong to. See &quot;Stashes
  and Globs&quot; for information on converting class names into stashes.
<div class="Pp"></div>
/* Still under construction */
<div class="Pp"></div>
The following function upgrades rv to reference if not already one. Creates a
  new SV for rv to point to. If &quot;classname&quot; is non-null, the SV is
  blessed into the specified class. SV is returned.
<div class="Pp"></div>
<pre>
        SV* newSVrv(SV* rv, const char* classname);
</pre>
<div class="Pp"></div>
The following three functions copy integer, unsigned integer or double into an
  SV whose reference is &quot;rv&quot;. SV is blessed if &quot;classname&quot;
  is non-null.
<div class="Pp"></div>
<pre>
        SV* sv_setref_iv(SV* rv, const char* classname, IV iv);
        SV* sv_setref_uv(SV* rv, const char* classname, UV uv);
        SV* sv_setref_nv(SV* rv, const char* classname, NV iv);
</pre>
<div class="Pp"></div>
The following function copies the pointer value ( <i>the address, not the</i>
  <i>string!</i>) into an SV whose reference is rv. SV is blessed if
  &quot;classname&quot; is non-null.
<div class="Pp"></div>
<pre>
        SV* sv_setref_pv(SV* rv, const char* classname, void* pv);
</pre>
<div class="Pp"></div>
The following function copies a string into an SV whose reference is
  &quot;rv&quot;. Set length to 0 to let Perl calculate the string length. SV is
  blessed if &quot;classname&quot; is non-null.
<div class="Pp"></div>
<pre>
    SV* sv_setref_pvn(SV* rv, const char* classname, char* pv,
                                                         STRLEN length);
</pre>
<div class="Pp"></div>
The following function tests whether the SV is blessed into the specified class.
  It does not check inheritance relationships.
<div class="Pp"></div>
<pre>
        int  sv_isa(SV* sv, const char* name);
</pre>
<div class="Pp"></div>
The following function tests whether the SV is a reference to a blessed object.
<div class="Pp"></div>
<pre>
        int  sv_isobject(SV* sv);
</pre>
<div class="Pp"></div>
The following function tests whether the SV is derived from the specified class.
  SV can be either a reference to a blessed object or a string containing a
  class name. This is the function implementing the &quot;UNIVERSAL::isa&quot;
  functionality.
<div class="Pp"></div>
<pre>
        bool sv_derived_from(SV* sv, const char* name);
</pre>
<div class="Pp"></div>
To check if you've got an object derived from a specific class you have to
  write:
<div class="Pp"></div>
<pre>
        if (sv_isobject(sv) &amp;&amp; sv_derived_from(sv, class)) { ... }
</pre>
<h2 class="Ss" title="Ss" id="Creating_New_Variables"><a class="selflink" href="#Creating_New_Variables">Creating
  New Variables</a></h2>
To create a new Perl variable with an undef value which can be accessed from
  your Perl script, use the following routines, depending on the variable type.
<div class="Pp"></div>
<pre>
    SV*  get_sv(&quot;package::varname&quot;, GV_ADD);
    AV*  get_av(&quot;package::varname&quot;, GV_ADD);
    HV*  get_hv(&quot;package::varname&quot;, GV_ADD);
</pre>
<div class="Pp"></div>
Notice the use of GV_ADD as the second parameter. The new variable can now be
  set, using the routines appropriate to the data type.
<div class="Pp"></div>
There are additional macros whose values may be bitwise OR'ed with the
  &quot;GV_ADD&quot; argument to enable certain extra features. Those bits are:
<dl class="Bl-tag">
  <dt class="It-tag">GV_ADDMULTI</dt>
  <dd class="It-tag">Marks the variable as multiply defined, thus preventing
      the:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  Name &lt;varname&gt; used only once: possible typo
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    warning.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">GV_ADDWARN</dt>
  <dd class="It-tag">Issues the warning:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  Had to create &lt;varname&gt; unexpectedly
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    if the variable did not exist before the function was called.</dd>
</dl>
<div class="Pp"></div>
If you do not specify a package name, the variable is created in the current
  package.
<h2 class="Ss" title="Ss" id="Reference_Counts_and_Mortality"><a class="selflink" href="#Reference_Counts_and_Mortality">Reference
  Counts and Mortality</a></h2>
Perl uses a reference count-driven garbage collection mechanism. SVs, AVs, or
  HVs (xV for short in the following) start their life with a reference count of
  1. If the reference count of an xV ever drops to 0, then it will be destroyed
  and its memory made available for reuse.
<div class="Pp"></div>
This normally doesn't happen at the Perl level unless a variable is undef'ed or
  the last variable holding a reference to it is changed or overwritten. At the
  internal level, however, reference counts can be manipulated with the
  following macros:
<div class="Pp"></div>
<pre>
    int SvREFCNT(SV* sv);
    SV* SvREFCNT_inc(SV* sv);
    void SvREFCNT_dec(SV* sv);
</pre>
<div class="Pp"></div>
However, there is one other function which manipulates the reference count of
  its argument. The &quot;newRV_inc&quot; function, you will recall, creates a
  reference to the specified argument. As a side effect, it increments the
  argument's reference count. If this is not what you want, use
  &quot;newRV_noinc&quot; instead.
<div class="Pp"></div>
For example, imagine you want to return a reference from an XSUB function.
  Inside the XSUB routine, you create an SV which initially has a reference
  count of one. Then you call &quot;newRV_inc&quot;, passing it the just-created
  SV. This returns the reference as a new SV, but the reference count of the SV
  you passed to &quot;newRV_inc&quot; has been incremented to two. Now you
  return the reference from the XSUB routine and forget about the SV. But Perl
  hasn't! Whenever the returned reference is destroyed, the reference count of
  the original SV is decreased to one and nothing happens. The SV will hang
  around without any way to access it until Perl itself terminates. This is a
  memory leak.
<div class="Pp"></div>
The correct procedure, then, is to use &quot;newRV_noinc&quot; instead of
  &quot;newRV_inc&quot;. Then, if and when the last reference is destroyed, the
  reference count of the SV will go to zero and it will be destroyed, stopping
  any memory leak.
<div class="Pp"></div>
There are some convenience functions available that can help with the
  destruction of xVs. These functions introduce the concept of
  &quot;mortality&quot;. An xV that is mortal has had its reference count marked
  to be decremented, but not actually decremented, until &quot;a short time
  later&quot;. Generally the term &quot;short time later&quot; means a single
  Perl statement, such as a call to an XSUB function. The actual determinant for
  when mortal xVs have their reference count decremented depends on two macros,
  SAVETMPS and FREETMPS. See perlcall and perlxs for more details on these
  macros.
<div class="Pp"></div>
&quot;Mortalization&quot; then is at its simplest a deferred
  &quot;SvREFCNT_dec&quot;. However, if you mortalize a variable twice, the
  reference count will later be decremented twice.
<div class="Pp"></div>
&quot;Mortal&quot; SVs are mainly used for SVs that are placed on perl's stack.
  For example an SV which is created just to pass a number to a called sub is
  made mortal to have it cleaned up automatically when it's popped off the
  stack. Similarly, results returned by XSUBs (which are pushed on the stack)
  are often made mortal.
<div class="Pp"></div>
To create a mortal variable, use the functions:
<div class="Pp"></div>
<pre>
    SV*  sv_newmortal()
    SV*  sv_2mortal(SV*)
    SV*  sv_mortalcopy(SV*)
</pre>
<div class="Pp"></div>
The first call creates a mortal SV (with no value), the second converts an
  existing SV to a mortal SV (and thus defers a call to
  &quot;SvREFCNT_dec&quot;), and the third creates a mortal copy of an existing
  SV. Because &quot;sv_newmortal&quot; gives the new SV no value, it must
  normally be given one via &quot;sv_setpv&quot;, &quot;sv_setiv&quot;, etc. :
<div class="Pp"></div>
<pre>
    SV *tmp = sv_newmortal();
    sv_setiv(tmp, an_integer);
</pre>
<div class="Pp"></div>
As that is multiple C statements it is quite common so see this idiom instead:
<div class="Pp"></div>
<pre>
    SV *tmp = sv_2mortal(newSViv(an_integer));
</pre>
<div class="Pp"></div>
You should be careful about creating mortal variables. Strange things can happen
  if you make the same value mortal within multiple contexts, or if you make a
  variable mortal multiple times. Thinking of &quot;Mortalization&quot; as
  deferred &quot;SvREFCNT_dec&quot; should help to minimize such problems. For
  example if you are passing an SV which you <i>know</i> has a high enough
  REFCNT to survive its use on the stack you need not do any mortalization. If
  you are not sure then doing an &quot;SvREFCNT_inc&quot; and
  &quot;sv_2mortal&quot;, or making a &quot;sv_mortalcopy&quot; is safer.
<div class="Pp"></div>
The mortal routines are not just for SVs; AVs and HVs can be made mortal by
  passing their address (type-casted to &quot;SV*&quot;) to the
  &quot;sv_2mortal&quot; or &quot;sv_mortalcopy&quot; routines.
<h2 class="Ss" title="Ss" id="Stashes_and_Globs"><a class="selflink" href="#Stashes_and_Globs">Stashes
  and Globs</a></h2>
A <b>stash</b> is a hash that contains all variables that are defined within a
  package. Each key of the stash is a symbol name (shared by all the different
  types of objects that have the same name), and each value in the hash table is
  a GV (Glob Value). This GV in turn contains references to the various objects
  of that name, including (but not limited to) the following:
<div class="Pp"></div>
<pre>
    Scalar Value
    Array Value
    Hash Value
    I/O Handle
    Format
    Subroutine
</pre>
<div class="Pp"></div>
There is a single stash called &quot;PL_defstash&quot; that holds the items that
  exist in the &quot;main&quot; package. To get at the items in other packages,
  append the string &quot;::&quot; to the package name. The items in the
  &quot;Foo&quot; package are in the stash &quot;Foo::&quot; in PL_defstash. The
  items in the &quot;Bar::Baz&quot; package are in the stash &quot;Baz::&quot;
  in &quot;Bar::&quot;'s stash.
<div class="Pp"></div>
To get the stash pointer for a particular package, use the function:
<div class="Pp"></div>
<pre>
    HV*  gv_stashpv(const char* name, I32 flags)
    HV*  gv_stashsv(SV*, I32 flags)
</pre>
<div class="Pp"></div>
The first function takes a literal string, the second uses the string stored in
  the SV. Remember that a stash is just a hash table, so you get back an
  &quot;HV*&quot;. The &quot;flags&quot; flag will create a new package if it is
  set to GV_ADD.
<div class="Pp"></div>
The name that &quot;gv_stash*v&quot; wants is the name of the package whose
  symbol table you want. The default package is called &quot;main&quot;. If you
  have multiply nested packages, pass their names to &quot;gv_stash*v&quot;,
  separated by &quot;::&quot; as in the Perl language itself.
<div class="Pp"></div>
Alternately, if you have an SV that is a blessed reference, you can find out the
  stash pointer by using:
<div class="Pp"></div>
<pre>
    HV*  SvSTASH(SvRV(SV*));
</pre>
<div class="Pp"></div>
then use the following to get the package name itself:
<div class="Pp"></div>
<pre>
    char*  HvNAME(HV* stash);
</pre>
<div class="Pp"></div>
If you need to bless or re-bless an object you can use the following function:
<div class="Pp"></div>
<pre>
    SV*  sv_bless(SV*, HV* stash)
</pre>
<div class="Pp"></div>
where the first argument, an &quot;SV*&quot;, must be a reference, and the
  second argument is a stash. The returned &quot;SV*&quot; can now be used in
  the same way as any other SV.
<div class="Pp"></div>
For more information on references and blessings, consult perlref.
<h2 class="Ss" title="Ss" id="Double-Typed_SVs"><a class="selflink" href="#Double-Typed_SVs">Double-Typed
  SVs</a></h2>
Scalar variables normally contain only one type of value, an integer, double,
  pointer, or reference. Perl will automatically convert the actual scalar data
  from the stored type into the requested type.
<div class="Pp"></div>
Some scalar variables contain more than one type of scalar data. For example,
  the variable $! contains either the numeric value of &quot;errno&quot; or its
  string equivalent from either &quot;strerror&quot; or
  &quot;sys_errlist[]&quot;.
<div class="Pp"></div>
To force multiple data values into an SV, you must do two things: use the
  &quot;sv_set*v&quot; routines to add the additional scalar type, then set a
  flag so that Perl will believe it contains more than one type of data. The
  four macros to set the flags are:
<div class="Pp"></div>
<pre>
        SvIOK_on
        SvNOK_on
        SvPOK_on
        SvROK_on
</pre>
<div class="Pp"></div>
The particular macro you must use depends on which &quot;sv_set*v&quot; routine
  you called first. This is because every &quot;sv_set*v&quot; routine turns on
  only the bit for the particular type of data being set, and turns off all the
  rest.
<div class="Pp"></div>
For example, to create a new Perl variable called &quot;dberror&quot; that
  contains both the numeric and descriptive string error values, you could use
  the following code:
<div class="Pp"></div>
<pre>
    extern int  dberror;
    extern char *dberror_list;
    SV* sv = get_sv(&quot;dberror&quot;, GV_ADD);
    sv_setiv(sv, (IV) dberror);
    sv_setpv(sv, dberror_list[dberror]);
    SvIOK_on(sv);
</pre>
<div class="Pp"></div>
If the order of &quot;sv_setiv&quot; and &quot;sv_setpv&quot; had been reversed,
  then the macro &quot;SvPOK_on&quot; would need to be called instead of
  &quot;SvIOK_on&quot;.
<h2 class="Ss" title="Ss" id="Magic_Variables"><a class="selflink" href="#Magic_Variables">Magic
  Variables</a></h2>
[This section still under construction. Ignore everything here. Post no bills.
  Everything not permitted is forbidden.]
<div class="Pp"></div>
Any SV may be magical, that is, it has special features that a normal SV does
  not have. These features are stored in the SV structure in a linked list of
  &quot;struct magic&quot;'s, typedef'ed to &quot;MAGIC&quot;.
<div class="Pp"></div>
<pre>
    struct magic {
        MAGIC*      mg_moremagic;
        MGVTBL*     mg_virtual;
        U16         mg_private;
        char        mg_type;
        U8          mg_flags;
        I32         mg_len;
        SV*         mg_obj;
        char*       mg_ptr;
    };
</pre>
<div class="Pp"></div>
Note this is current as of patchlevel 0, and could change at any time.
<h2 class="Ss" title="Ss" id="Assigning_Magic"><a class="selflink" href="#Assigning_Magic">Assigning
  Magic</a></h2>
Perl adds magic to an SV using the sv_magic function:
<div class="Pp"></div>
<pre>
  void sv_magic(SV* sv, SV* obj, int how, const char* name, I32 namlen);
</pre>
<div class="Pp"></div>
The &quot;sv&quot; argument is a pointer to the SV that is to acquire a new
  magical feature.
<div class="Pp"></div>
If &quot;sv&quot; is not already magical, Perl uses the &quot;SvUPGRADE&quot;
  macro to convert &quot;sv&quot; to type &quot;SVt_PVMG&quot;. Perl then
  continues by adding new magic to the beginning of the linked list of magical
  features. Any prior entry of the same type of magic is deleted. Note that this
  can be overridden, and multiple instances of the same type of magic can be
  associated with an SV.
<div class="Pp"></div>
The &quot;name&quot; and &quot;namlen&quot; arguments are used to associate a
  string with the magic, typically the name of a variable. &quot;namlen&quot; is
  stored in the &quot;mg_len&quot; field and if &quot;name&quot; is non-null
  then either a &quot;savepvn&quot; copy of &quot;name&quot; or &quot;name&quot;
  itself is stored in the &quot;mg_ptr&quot; field, depending on whether
  &quot;namlen&quot; is greater than zero or equal to zero respectively. As a
  special case, if &quot;(name &amp;&amp; namlen == HEf_SVKEY)&quot; then
  &quot;name&quot; is assumed to contain an &quot;SV*&quot; and is stored as-is
  with its REFCNT incremented.
<div class="Pp"></div>
The sv_magic function uses &quot;how&quot; to determine which, if any,
  predefined &quot;Magic Virtual Table&quot; should be assigned to the
  &quot;mg_virtual&quot; field. See the &quot;Magic Virtual Tables&quot; section
  below. The &quot;how&quot; argument is also stored in the &quot;mg_type&quot;
  field. The value of &quot;how&quot; should be chosen from the set of macros
  &quot;PERL_MAGIC_foo&quot; found in <i>perl.h</i>. Note that before these
  macros were added, Perl internals used to directly use character literals, so
  you may occasionally come across old code or documentation referring to 'U'
  magic rather than &quot;PERL_MAGIC_uvar&quot; for example.
<div class="Pp"></div>
The &quot;obj&quot; argument is stored in the &quot;mg_obj&quot; field of the
  &quot;MAGIC&quot; structure. If it is not the same as the &quot;sv&quot;
  argument, the reference count of the &quot;obj&quot; object is incremented. If
  it is the same, or if the &quot;how&quot; argument is
  &quot;PERL_MAGIC_arylen&quot;, or if it is a NULL pointer, then
  &quot;obj&quot; is merely stored, without the reference count being
  incremented.
<div class="Pp"></div>
See also &quot;sv_magicext&quot; in perlapi for a more flexible way to add magic
  to an SV.
<div class="Pp"></div>
There is also a function to add magic to an &quot;HV&quot;:
<div class="Pp"></div>
<pre>
    void hv_magic(HV *hv, GV *gv, int how);
</pre>
<div class="Pp"></div>
This simply calls &quot;sv_magic&quot; and coerces the &quot;gv&quot; argument
  into an &quot;SV&quot;.
<div class="Pp"></div>
To remove the magic from an SV, call the function sv_unmagic:
<div class="Pp"></div>
<pre>
    int sv_unmagic(SV *sv, int type);
</pre>
<div class="Pp"></div>
The &quot;type&quot; argument should be equal to the &quot;how&quot; value when
  the &quot;SV&quot; was initially made magical.
<div class="Pp"></div>
However, note that &quot;sv_unmagic&quot; removes all magic of a certain
  &quot;type&quot; from the &quot;SV&quot;. If you want to remove only certain
  magic of a &quot;type&quot; based on the magic virtual table, use
  &quot;sv_unmagicext&quot; instead:
<div class="Pp"></div>
<pre>
    int sv_unmagicext(SV *sv, int type, MGVTBL *vtbl);
</pre>
<h2 class="Ss" title="Ss" id="Magic_Virtual_Tables"><a class="selflink" href="#Magic_Virtual_Tables">Magic
  Virtual Tables</a></h2>
The &quot;mg_virtual&quot; field in the &quot;MAGIC&quot; structure is a pointer
  to an &quot;MGVTBL&quot;, which is a structure of function pointers and stands
  for &quot;Magic Virtual Table&quot; to handle the various operations that
  might be applied to that variable.
<div class="Pp"></div>
The &quot;MGVTBL&quot; has five (or sometimes eight) pointers to the following
  routine types:
<div class="Pp"></div>
<pre>
    int  (*svt_get)(SV* sv, MAGIC* mg);
    int  (*svt_set)(SV* sv, MAGIC* mg);
    U32  (*svt_len)(SV* sv, MAGIC* mg);
    int  (*svt_clear)(SV* sv, MAGIC* mg);
    int  (*svt_free)(SV* sv, MAGIC* mg);
    int  (*svt_copy)(SV *sv, MAGIC* mg, SV *nsv,
                                          const char *name, I32 namlen);
    int  (*svt_dup)(MAGIC *mg, CLONE_PARAMS *param);
    int  (*svt_local)(SV *nsv, MAGIC *mg);
</pre>
<div class="Pp"></div>
This MGVTBL structure is set at compile-time in <i>perl.h</i> and there are
  currently 32 types. These different structures contain pointers to various
  routines that perform additional actions depending on which function is being
  called.
<div class="Pp"></div>
<pre>
   Function pointer    Action taken
   ----------------    ------------
   svt_get             Do something before the value of the SV is
                       retrieved.
   svt_set             Do something after the SV is assigned a value.
   svt_len             Report on the SV's length.
   svt_clear           Clear something the SV represents.
   svt_free            Free any extra storage associated with the SV.
   svt_copy            copy tied variable magic to a tied element
   svt_dup             duplicate a magic structure during thread cloning
   svt_local           copy magic to local value during 'local'
</pre>
<div class="Pp"></div>
For instance, the MGVTBL structure called &quot;vtbl_sv&quot; (which corresponds
  to an &quot;mg_type&quot; of &quot;PERL_MAGIC_sv&quot;) contains:
<div class="Pp"></div>
<pre>
    { magic_get, magic_set, magic_len, 0, 0 }
</pre>
<div class="Pp"></div>
Thus, when an SV is determined to be magical and of type
  &quot;PERL_MAGIC_sv&quot;, if a get operation is being performed, the routine
  &quot;magic_get&quot; is called. All the various routines for the various
  magical types begin with &quot;magic_&quot;. NOTE: the magic routines are not
  considered part of the Perl API, and may not be exported by the Perl library.
<div class="Pp"></div>
The last three slots are a recent addition, and for source code compatibility
  they are only checked for if one of the three flags MGf_COPY, MGf_DUP or
  MGf_LOCAL is set in mg_flags. This means that most code can continue declaring
  a vtable as a 5-element value. These three are currently used exclusively by
  the threading code, and are highly subject to change.
<div class="Pp"></div>
The current kinds of Magic Virtual Tables are:
<div class="Pp"></div>
<pre>
 mg_type
 (old-style char and macro)   MGVTBL          Type of magic
 --------------------------   ------          -------------
 \0 PERL_MAGIC_sv             vtbl_sv         Special scalar variable
 #  PERL_MAGIC_arylen         vtbl_arylen     Array length ($#ary)
 %  PERL_MAGIC_rhash          (none)          extra data for restricted
                                              hashes
 .  PERL_MAGIC_pos            vtbl_pos        pos() lvalue
 :  PERL_MAGIC_symtab         (none)          extra data for symbol
                                              tables
 &lt;  PERL_MAGIC_backref        vtbl_backref    for weak ref data
 @  PERL_MAGIC_arylen_p       (none)          to move arylen out of
                                              XPVAV
 A  PERL_MAGIC_overload       vtbl_amagic     %OVERLOAD hash
 a  PERL_MAGIC_overload_elem  vtbl_amagicelem %OVERLOAD hash element
 B  PERL_MAGIC_bm             vtbl_regexp     Boyer-Moore 
                                              (fast string search)
 c  PERL_MAGIC_overload_table vtbl_ovrld      Holds overload table 
                                              (AMT) on stash
 D  PERL_MAGIC_regdata        vtbl_regdata    Regex match position data 
                                              (@+ and @- vars)
 d  PERL_MAGIC_regdatum       vtbl_regdatum   Regex match position data
                                              element
 E  PERL_MAGIC_env            vtbl_env        %ENV hash
 e  PERL_MAGIC_envelem        vtbl_envelem    %ENV hash element
 f  PERL_MAGIC_fm             vtbl_regdata    Formline 
                                              ('compiled' format)
 G  PERL_MAGIC_study          vtbl_regexp     study()ed string
 g  PERL_MAGIC_regex_global   vtbl_mglob      m//g target
 H  PERL_MAGIC_hints          vtbl_hints      %^H hash
 h  PERL_MAGIC_hintselem      vtbl_hintselem  %^H hash element
 I  PERL_MAGIC_isa            vtbl_isa        @ISA array
 i  PERL_MAGIC_isaelem        vtbl_isaelem    @ISA array element
 k  PERL_MAGIC_nkeys          vtbl_nkeys      scalar(keys()) lvalue
 L  PERL_MAGIC_dbfile         (none)          Debugger %_&lt;filename
 l  PERL_MAGIC_dbline         vtbl_dbline     Debugger %_&lt;filename
                                              element
 N  PERL_MAGIC_shared         (none)          Shared between threads
 n  PERL_MAGIC_shared_scalar  (none)          Shared between threads
 o  PERL_MAGIC_collxfrm       vtbl_collxfrm   Locale transformation
 P  PERL_MAGIC_tied           vtbl_pack       Tied array or hash
 p  PERL_MAGIC_tiedelem       vtbl_packelem   Tied array or hash element
 q  PERL_MAGIC_tiedscalar     vtbl_packelem   Tied scalar or handle
 r  PERL_MAGIC_qr             vtbl_regexp     precompiled qr// regex
 S  PERL_MAGIC_sig            (none)          %SIG hash
 s  PERL_MAGIC_sigelem        vtbl_sigelem    %SIG hash element
 t  PERL_MAGIC_taint          vtbl_taint      Taintedness
 U  PERL_MAGIC_uvar           vtbl_uvar       Available for use by
                                              extensions
 u  PERL_MAGIC_uvar_elem      (none)          Reserved for use by
                                              extensions
 V  PERL_MAGIC_vstring        vtbl_vstring    SV was vstring literal
 v  PERL_MAGIC_vec            vtbl_vec        vec() lvalue
 w  PERL_MAGIC_utf8           vtbl_utf8       Cached UTF-8 information
 x  PERL_MAGIC_substr         vtbl_substr     substr() lvalue
 y  PERL_MAGIC_defelem        vtbl_defelem    Shadow &quot;foreach&quot; iterator
                                              variable / smart parameter
                                              vivification
 ]  PERL_MAGIC_checkcall      (none)          inlining/mutation of call
                                              to this CV
 ~  PERL_MAGIC_ext            (none)          Available for use by
                                              extensions
</pre>
<div class="Pp"></div>
When an uppercase and lowercase letter both exist in the table, then the
  uppercase letter is typically used to represent some kind of composite type (a
  list or a hash), and the lowercase letter is used to represent an element of
  that composite type. Some internals code makes use of this case relationship.
  However, 'v' and 'V' (vec and v-string) are in no way related.
<div class="Pp"></div>
The &quot;PERL_MAGIC_ext&quot; and &quot;PERL_MAGIC_uvar&quot; magic types are
  defined specifically for use by extensions and will not be used by perl
  itself. Extensions can use &quot;PERL_MAGIC_ext&quot; magic to 'attach'
  private information to variables (typically objects). This is especially
  useful because there is no way for normal perl code to corrupt this private
  information (unlike using extra elements of a hash object).
<div class="Pp"></div>
Similarly, &quot;PERL_MAGIC_uvar&quot; magic can be used much like <i>tie()</i>
  to call a C function any time a scalar's value is used or changed. The
  &quot;MAGIC&quot;'s &quot;mg_ptr&quot; field points to a &quot;ufuncs&quot;
  structure:
<div class="Pp"></div>
<pre>
    struct ufuncs {
        I32 (*uf_val)(pTHX_ IV, SV*);
        I32 (*uf_set)(pTHX_ IV, SV*);
        IV uf_index;
    };
</pre>
<div class="Pp"></div>
When the SV is read from or written to, the &quot;uf_val&quot; or
  &quot;uf_set&quot; function will be called with &quot;uf_index&quot; as the
  first arg and a pointer to the SV as the second. A simple example of how to
  add &quot;PERL_MAGIC_uvar&quot; magic is shown below. Note that the ufuncs
  structure is copied by sv_magic, so you can safely allocate it on the stack.
<div class="Pp"></div>
<pre>
    void
    Umagic(sv)
        SV *sv;
    PREINIT:
        struct ufuncs uf;
    CODE:
        uf.uf_val   = &amp;my_get_fn;
        uf.uf_set   = &amp;my_set_fn;
        uf.uf_index = 0;
        sv_magic(sv, 0, PERL_MAGIC_uvar, (char*)&amp;uf, sizeof(uf));
</pre>
<div class="Pp"></div>
Attaching &quot;PERL_MAGIC_uvar&quot; to arrays is permissible but has no
  effect.
<div class="Pp"></div>
For hashes there is a specialized hook that gives control over hash keys (but
  not values). This hook calls &quot;PERL_MAGIC_uvar&quot; 'get' magic if the
  &quot;set&quot; function in the &quot;ufuncs&quot; structure is NULL. The hook
  is activated whenever the hash is accessed with a key specified as an
  &quot;SV&quot; through the functions &quot;hv_store_ent&quot;,
  &quot;hv_fetch_ent&quot;, &quot;hv_delete_ent&quot;, and
  &quot;hv_exists_ent&quot;. Accessing the key as a string through the functions
  without the &quot;..._ent&quot; suffix circumvents the hook. See
  &quot;GUTS&quot; in Hash::Util::FieldHash for a detailed description.
<div class="Pp"></div>
Note that because multiple extensions may be using &quot;PERL_MAGIC_ext&quot; or
  &quot;PERL_MAGIC_uvar&quot; magic, it is important for extensions to take
  extra care to avoid conflict. Typically only using the magic on objects
  blessed into the same class as the extension is sufficient. For
  &quot;PERL_MAGIC_ext&quot; magic, it is usually a good idea to define an
  &quot;MGVTBL&quot;, even if all its fields will be 0, so that individual
  &quot;MAGIC&quot; pointers can be identified as a particular kind of magic
  using their magic virtual table. &quot;mg_findext&quot; provides an easy way
  to do that:
<div class="Pp"></div>
<pre>
    STATIC MGVTBL my_vtbl = { 0, 0, 0, 0, 0, 0, 0, 0 };
    MAGIC *mg;
    if ((mg = mg_findext(sv, PERL_MAGIC_ext, &amp;my_vtbl))) {
        /* this is really ours, not another module's PERL_MAGIC_ext */
        my_priv_data_t *priv = (my_priv_data_t *)mg-&gt;mg_ptr;
        ...
    }
</pre>
<div class="Pp"></div>
Also note that the &quot;sv_set*()&quot; and &quot;sv_cat*()&quot; functions
  described earlier do <b>not</b> invoke 'set' magic on their targets. This must
  be done by the user either by calling the &quot;SvSETMAGIC()&quot; macro after
  calling these functions, or by using one of the &quot;sv_set*_mg()&quot; or
  &quot;sv_cat*_mg()&quot; functions. Similarly, generic C code must call the
  &quot;SvGETMAGIC()&quot; macro to invoke any 'get' magic if they use an SV
  obtained from external sources in functions that don't handle magic. See
  perlapi for a description of these functions. For example, calls to the
  &quot;sv_cat*()&quot; functions typically need to be followed by
  &quot;SvSETMAGIC()&quot;, but they don't need a prior &quot;SvGETMAGIC()&quot;
  since their implementation handles 'get' magic.
<h2 class="Ss" title="Ss" id="Finding_Magic"><a class="selflink" href="#Finding_Magic">Finding
  Magic</a></h2>
<pre>
    MAGIC *mg_find(SV *sv, int type); /* Finds the magic pointer of that
                                       * type */
</pre>
<div class="Pp"></div>
This routine returns a pointer to a &quot;MAGIC&quot; structure stored in the
  SV. If the SV does not have that magical feature, &quot;NULL&quot; is
  returned. If the SV has multiple instances of that magical feature, the first
  one will be returned. &quot;mg_findext&quot; can be used to find a
  &quot;MAGIC&quot; structure of an SV based on both its magic type and its
  magic virtual table:
<div class="Pp"></div>
<pre>
    MAGIC *mg_findext(SV *sv, int type, MGVTBL *vtbl);
</pre>
<div class="Pp"></div>
Also, if the SV passed to &quot;mg_find&quot; or &quot;mg_findext&quot; is not
  of type SVt_PVMG, Perl may core dump.
<div class="Pp"></div>
<pre>
    int mg_copy(SV* sv, SV* nsv, const char* key, STRLEN klen);
</pre>
<div class="Pp"></div>
This routine checks to see what types of magic &quot;sv&quot; has. If the
  mg_type field is an uppercase letter, then the mg_obj is copied to
  &quot;nsv&quot;, but the mg_type field is changed to be the lowercase letter.
<h2 class="Ss" title="Ss" id="Understanding_the_Magic_of_Tied_Hashes_and_Arrays"><a class="selflink" href="#Understanding_the_Magic_of_Tied_Hashes_and_Arrays">Understanding
  the Magic of Tied Hashes and Arrays</a></h2>
Tied hashes and arrays are magical beasts of the &quot;PERL_MAGIC_tied&quot;
  magic type.
<div class="Pp"></div>
WARNING: As of the 5.004 release, proper usage of the array and hash access
  functions requires understanding a few caveats. Some of these caveats are
  actually considered bugs in the API, to be fixed in later releases, and are
  bracketed with [MAYCHANGE] below. If you find yourself actually applying such
  information in this section, be aware that the behavior may change in the
  future, umm, without warning.
<div class="Pp"></div>
The perl tie function associates a variable with an object that implements the
  various GET, SET, etc methods. To perform the equivalent of the perl tie
  function from an XSUB, you must mimic this behaviour. The code below carries
  out the necessary steps - firstly it creates a new hash, and then creates a
  second hash which it blesses into the class which will implement the tie
  methods. Lastly it ties the two hashes together, and returns a reference to
  the new tied hash. Note that the code below does NOT call the TIEHASH method
  in the MyTie class - see &quot;Calling Perl Routines from within C
  Programs&quot; for details on how to do this.
<div class="Pp"></div>
<pre>
    SV*
    mytie()
    PREINIT:
        HV *hash;
        HV *stash;
        SV *tie;
    CODE:
        hash = newHV();
        tie = newRV_noinc((SV*)newHV());
        stash = gv_stashpv(&quot;MyTie&quot;, GV_ADD);
        sv_bless(tie, stash);
        hv_magic(hash, (GV*)tie, PERL_MAGIC_tied);
        RETVAL = newRV_noinc(hash);
    OUTPUT:
        RETVAL
</pre>
<div class="Pp"></div>
The &quot;av_store&quot; function, when given a tied array argument, merely
  copies the magic of the array onto the value to be &quot;stored&quot;, using
  &quot;mg_copy&quot;. It may also return NULL, indicating that the value did
  not actually need to be stored in the array. [MAYCHANGE] After a call to
  &quot;av_store&quot; on a tied array, the caller will usually need to call
  &quot;mg_set(val)&quot; to actually invoke the perl level &quot;STORE&quot;
  method on the TIEARRAY object. If &quot;av_store&quot; did return NULL, a call
  to &quot;SvREFCNT_dec(val)&quot; will also be usually necessary to avoid a
  memory leak. [/MAYCHANGE]
<div class="Pp"></div>
The previous paragraph is applicable verbatim to tied hash access using the
  &quot;hv_store&quot; and &quot;hv_store_ent&quot; functions as well.
<div class="Pp"></div>
&quot;av_fetch&quot; and the corresponding hash functions &quot;hv_fetch&quot;
  and &quot;hv_fetch_ent&quot; actually return an undefined mortal value whose
  magic has been initialized using &quot;mg_copy&quot;. Note the value so
  returned does not need to be deallocated, as it is already mortal. [MAYCHANGE]
  But you will need to call &quot;mg_get()&quot; on the returned value in order
  to actually invoke the perl level &quot;FETCH&quot; method on the underlying
  TIE object. Similarly, you may also call &quot;mg_set()&quot; on the return
  value after possibly assigning a suitable value to it using
  &quot;sv_setsv&quot;, which will invoke the &quot;STORE&quot; method on the
  TIE object. [/MAYCHANGE]
<div class="Pp"></div>
[MAYCHANGE] In other words, the array or hash fetch/store functions don't really
  fetch and store actual values in the case of tied arrays and hashes. They
  merely call &quot;mg_copy&quot; to attach magic to the values that were meant
  to be &quot;stored&quot; or &quot;fetched&quot;. Later calls to
  &quot;mg_get&quot; and &quot;mg_set&quot; actually do the job of invoking the
  TIE methods on the underlying objects. Thus the magic mechanism currently
  implements a kind of lazy access to arrays and hashes.
<div class="Pp"></div>
Currently (as of perl version 5.004), use of the hash and array access functions
  requires the user to be aware of whether they are operating on
  &quot;normal&quot; hashes and arrays, or on their tied variants. The API may
  be changed to provide more transparent access to both tied and normal data
  types in future versions. [/MAYCHANGE]
<div class="Pp"></div>
You would do well to understand that the TIEARRAY and TIEHASH interfaces are
  mere sugar to invoke some perl method calls while using the uniform hash and
  array syntax. The use of this sugar imposes some overhead (typically about two
  to four extra opcodes per FETCH/STORE operation, in addition to the creation
  of all the mortal variables required to invoke the methods). This overhead
  will be comparatively small if the TIE methods are themselves substantial, but
  if they are only a few statements long, the overhead will not be
  insignificant.
<h2 class="Ss" title="Ss" id="Localizing_changes"><a class="selflink" href="#Localizing_changes">Localizing
  changes</a></h2>
Perl has a very handy construction
<div class="Pp"></div>
<pre>
  {
    local $var = 2;
    ...
  }
</pre>
<div class="Pp"></div>
This construction is <i>approximately</i> equivalent to
<div class="Pp"></div>
<pre>
  {
    my $oldvar = $var;
    $var = 2;
    ...
    $var = $oldvar;
  }
</pre>
<div class="Pp"></div>
The biggest difference is that the first construction would reinstate the
  initial value of $var, irrespective of how control exits the block:
  &quot;goto&quot;, &quot;return&quot;, &quot;die&quot;/&quot;eval&quot;, etc.
  It is a little bit more efficient as well.
<div class="Pp"></div>
There is a way to achieve a similar task from C via Perl API: create a
  <i>pseudo-block</i>, and arrange for some changes to be automatically undone
  at the end of it, either explicit, or via a non-local exit (via <i>die()</i>).
  A <i>block</i>-like construct is created by a pair of
  &quot;ENTER&quot;/&quot;LEAVE&quot; macros (see &quot;Returning a Scalar&quot;
  in perlcall). Such a construct may be created specially for some important
  localized task, or an existing one (like boundaries of enclosing Perl
  subroutine/block, or an existing pair for freeing TMPs) may be used. (In the
  second case the overhead of additional localization must be almost
  negligible.) Note that any XSUB is automatically enclosed in an
  &quot;ENTER&quot;/&quot;LEAVE&quot; pair.
<div class="Pp"></div>
Inside such a <i>pseudo-block</i> the following service is available:
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEINT(int i)&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEIV(IV i)&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEI32(I32 i)&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVELONG(long i)&quot;</dt>
  <dd class="It-tag">These macros arrange things to restore the value of integer
      variable &quot;i&quot; at the end of enclosing <i>pseudo-block</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">SAVESPTR(s)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">SAVEPPTR(p)</dt>
  <dd class="It-tag">These macros arrange things to restore the value of
      pointers &quot;s&quot; and &quot;p&quot;. &quot;s&quot; must be a pointer
      of a type which survives conversion to &quot;SV*&quot; and back,
      &quot;p&quot; should be able to survive conversion to &quot;char*&quot;
      and back.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEFREESV(SV *sv)&quot;</dt>
  <dd class="It-tag">The refcount of &quot;sv&quot; would be decremented at the
      end of <i>pseudo-block</i>. This is similar to &quot;sv_2mortal&quot; in
      that it is also a mechanism for doing a delayed &quot;SvREFCNT_dec&quot;.
      However, while &quot;sv_2mortal&quot; extends the lifetime of
      &quot;sv&quot; until the beginning of the next statement,
      &quot;SAVEFREESV&quot; extends it until the end of the enclosing scope.
      These lifetimes can be wildly different.
    <div style="height: 1.00em;">&#x00A0;</div>
    Also compare &quot;SAVEMORTALIZESV&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEMORTALIZESV(SV *sv)&quot;</dt>
  <dd class="It-tag">Just like &quot;SAVEFREESV&quot;, but mortalizes
      &quot;sv&quot; at the end of the current scope instead of decrementing its
      reference count. This usually has the effect of keeping &quot;sv&quot;
      alive until the statement that called the currently live scope has
      finished executing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEFREEOP(OP *op)&quot;</dt>
  <dd class="It-tag">The &quot;OP *&quot; is <i>op_free()</i>ed at the end of
      <i>pseudo-block</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">SAVEFREEPV(p)</dt>
  <dd class="It-tag">The chunk of memory which is pointed to by &quot;p&quot; is
      <i>Safefree()</i>ed at the end of <i>pseudo-block</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVECLEARSV(SV *sv)&quot;</dt>
  <dd class="It-tag">Clears a slot in the current scratchpad which corresponds
      to &quot;sv&quot; at the end of <i>pseudo-block</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEDELETE(HV *hv, char *key, I32 length)&quot;</dt>
  <dd class="It-tag">The key &quot;key&quot; of &quot;hv&quot; is deleted at the
      end of <i>pseudo-block</i>. The string pointed to by &quot;key&quot; is
      <i>Safefree()</i>ed. If one has a <i>key</i> in short-lived storage, the
      corresponding string may be reallocated like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  SAVEDELETE(PL_defstash, savepv(tmpbuf), strlen(tmpbuf));
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void
    *p)&quot;</dt>
  <dd class="It-tag">At the end of <i>pseudo-block</i> the function
      &quot;f&quot; is called with the only argument &quot;p&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void
    *p)&quot;</dt>
  <dd class="It-tag">At the end of <i>pseudo-block</i> the function
      &quot;f&quot; is called with the implicit context argument (if any), and
      &quot;p&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SAVESTACK_POS()&quot;</dt>
  <dd class="It-tag">The current offset on the Perl internal stack (cf.
      &quot;SP&quot;) is restored at the end of <i>pseudo-block</i>.</dd>
</dl>
<div class="Pp"></div>
The following API list contains functions, thus one needs to provide pointers to
  the modifiable data explicitly (either C pointers, or Perlish &quot;GV
  *&quot;s). Where the above macros take &quot;int&quot;, a similar function
  takes &quot;int *&quot;.
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SV* save_scalar(GV *gv)&quot;</dt>
  <dd class="It-tag">Equivalent to Perl code &quot;local $gv&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;AV* save_ary(GV *gv)&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;HV* save_hash(GV *gv)&quot;</dt>
  <dd class="It-tag">Similar to &quot;save_scalar&quot;, but localize @gv and
      %gv.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void save_item(SV *item)&quot;</dt>
  <dd class="It-tag">Duplicates the current value of &quot;SV&quot;, on the exit
      from the current &quot;ENTER&quot;/&quot;LEAVE&quot; <i>pseudo-block</i>
      will restore the value of &quot;SV&quot; using the stored value. It
      doesn't handle magic. Use &quot;save_scalar&quot; if magic is
    affected.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void save_list(SV **sarg, I32 maxsarg)&quot;</dt>
  <dd class="It-tag">A variant of &quot;save_item&quot; which takes multiple
      arguments via an array &quot;sarg&quot; of &quot;SV*&quot; of length
      &quot;maxsarg&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;SV* save_svref(SV **sptr)&quot;</dt>
  <dd class="It-tag">Similar to &quot;save_scalar&quot;, but will reinstate an
      &quot;SV *&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void save_aptr(AV **aptr)&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void save_hptr(HV **hptr)&quot;</dt>
  <dd class="It-tag">Similar to &quot;save_svref&quot;, but localize &quot;AV
      *&quot; and &quot;HV *&quot;.</dd>
</dl>
<div class="Pp"></div>
The &quot;Alias&quot; module implements localization of the basic types within
  the <i>caller's scope</i>. People who are interested in how to localize things
  in the containing scope should take a look there too.
<h1 class="Sh" title="Sh" id="Subroutines"><a class="selflink" href="#Subroutines">Subroutines</a></h1>
<h2 class="Ss" title="Ss" id="XSUBs_and_the_Argument_Stack"><a class="selflink" href="#XSUBs_and_the_Argument_Stack">XSUBs
  and the Argument Stack</a></h2>
The XSUB mechanism is a simple way for Perl programs to access C subroutines. An
  XSUB routine will have a stack that contains the arguments from the Perl
  program, and a way to map from the Perl data structures to a C equivalent.
<div class="Pp"></div>
The stack arguments are accessible through the ST(n) macro, which returns the
  &quot;n&quot;'th stack argument. Argument 0 is the first argument passed in
  the Perl subroutine call. These arguments are &quot;SV*&quot;, and can be used
  anywhere an &quot;SV*&quot; is used.
<div class="Pp"></div>
Most of the time, output from the C routine can be handled through use of the
  RETVAL and OUTPUT directives. However, there are some cases where the argument
  stack is not already long enough to handle all the return values. An example
  is the POSIX <i>tzname()</i> call, which takes no arguments, but returns two,
  the local time zone's standard and summer time abbreviations.
<div class="Pp"></div>
To handle this situation, the PPCODE directive is used and the stack is extended
  using the macro:
<div class="Pp"></div>
<pre>
    EXTEND(SP, num);
</pre>
<div class="Pp"></div>
where &quot;SP&quot; is the macro that represents the local copy of the stack
  pointer, and &quot;num&quot; is the number of elements the stack should be
  extended by.
<div class="Pp"></div>
Now that there is room on the stack, values can be pushed on it using
  &quot;PUSHs&quot; macro. The pushed values will often need to be
  &quot;mortal&quot; (See &quot;Reference Counts and Mortality&quot;):
<div class="Pp"></div>
<pre>
    PUSHs(sv_2mortal(newSViv(an_integer)))
    PUSHs(sv_2mortal(newSVuv(an_unsigned_integer)))
    PUSHs(sv_2mortal(newSVnv(a_double)))
    PUSHs(sv_2mortal(newSVpv(&quot;Some String&quot;,0)))
    /* Although the last example is better written as the more
     * efficient: */
    PUSHs(newSVpvs_flags(&quot;Some String&quot;, SVs_TEMP))
</pre>
<div class="Pp"></div>
And now the Perl program calling &quot;tzname&quot;, the two values will be
  assigned as in:
<div class="Pp"></div>
<pre>
    ($standard_abbrev, $summer_abbrev) = POSIX::tzname;
</pre>
<div class="Pp"></div>
An alternate (and possibly simpler) method to pushing values on the stack is to
  use the macro:
<div class="Pp"></div>
<pre>
    XPUSHs(SV*)
</pre>
<div class="Pp"></div>
This macro automatically adjusts the stack for you, if needed. Thus, you do not
  need to call &quot;EXTEND&quot; to extend the stack.
<div class="Pp"></div>
Despite their suggestions in earlier versions of this document the macros
  &quot;(X)PUSH[iunp]&quot; are <i>not</i> suited to XSUBs which return multiple
  results. For that, either stick to the &quot;(X)PUSHs&quot; macros shown
  above, or use the new &quot;m(X)PUSH[iunp]&quot; macros instead; see
  &quot;Putting a C value on Perl stack&quot;.
<div class="Pp"></div>
For more information, consult perlxs and perlxstut.
<h2 class="Ss" title="Ss" id="Autoloading_with_XSUBs"><a class="selflink" href="#Autoloading_with_XSUBs">Autoloading
  with XSUBs</a></h2>
If an AUTOLOAD routine is an XSUB, as with Perl subroutines, Perl puts the
  fully-qualified name of the autoloaded subroutine in the $AUTOLOAD variable of
  the XSUB's package.
<div class="Pp"></div>
But it also puts the same information in certain fields of the XSUB itself:
<div class="Pp"></div>
<pre>
    HV *stash           = CvSTASH(cv);
    const char *subname = SvPVX(cv);
    STRLEN name_length  = SvCUR(cv); /* in bytes */
    U32 is_utf8         = SvUTF8(cv);
</pre>
<div class="Pp"></div>
&quot;SvPVX(cv)&quot; contains just the sub name itself, not including the
  package. For an AUTOLOAD routine in UNIVERSAL or one of its superclasses,
  &quot;CvSTASH(cv)&quot; returns NULL during a method call on a nonexistent
  package.
<div class="Pp"></div>
<b>Note</b>: Setting $AUTOLOAD stopped working in 5.6.1, which did not support
  XS AUTOLOAD subs at all. Perl 5.8.0 introduced the use of fields in the XSUB
  itself. Perl 5.16.0 restored the setting of $AUTOLOAD. If you need to support
  5.8-5.14, use the XSUB's fields.
<h2 class="Ss" title="Ss" id="Calling_Perl_Routines_from_within_C_Programs"><a class="selflink" href="#Calling_Perl_Routines_from_within_C_Programs">Calling
  Perl Routines from within C Programs</a></h2>
There are four routines that can be used to call a Perl subroutine from within a
  C program. These four are:
<div class="Pp"></div>
<pre>
    I32  call_sv(SV*, I32);
    I32  call_pv(const char*, I32);
    I32  call_method(const char*, I32);
    I32  call_argv(const char*, I32, register char**);
</pre>
<div class="Pp"></div>
The routine most often used is &quot;call_sv&quot;. The &quot;SV*&quot; argument
  contains either the name of the Perl subroutine to be called, or a reference
  to the subroutine. The second argument consists of flags that control the
  context in which the subroutine is called, whether or not the subroutine is
  being passed arguments, how errors should be trapped, and how to treat return
  values.
<div class="Pp"></div>
All four routines return the number of arguments that the subroutine returned on
  the Perl stack.
<div class="Pp"></div>
These routines used to be called &quot;perl_call_sv&quot;, etc., before Perl
  v5.6.0, but those names are now deprecated; macros of the same name are
  provided for compatibility.
<div class="Pp"></div>
When using any of these routines (except &quot;call_argv&quot;), the programmer
  must manipulate the Perl stack. These include the following macros and
  functions:
<div class="Pp"></div>
<pre>
    dSP
    SP
    PUSHMARK()
    PUTBACK
    SPAGAIN
    ENTER
    SAVETMPS
    FREETMPS
    LEAVE
    XPUSH*()
    POP*()
</pre>
<div class="Pp"></div>
For a detailed description of calling conventions from C to Perl, consult
  perlcall.
<h2 class="Ss" title="Ss" id="Memory_Allocation"><a class="selflink" href="#Memory_Allocation">Memory
  Allocation</a></h2>
<i>Allocation</i>
<div class="Pp"></div>
All memory meant to be used with the Perl API functions should be manipulated
  using the macros described in this section. The macros provide the necessary
  transparency between differences in the actual malloc implementation that is
  used within perl.
<div class="Pp"></div>
It is suggested that you enable the version of malloc that is distributed with
  Perl. It keeps pools of various sizes of unallocated memory in order to
  satisfy allocation requests more quickly. However, on some platforms, it may
  cause spurious malloc or free errors.
<div class="Pp"></div>
The following three macros are used to initially allocate memory :
<div class="Pp"></div>
<pre>
    Newx(pointer, number, type);
    Newxc(pointer, number, type, cast);
    Newxz(pointer, number, type);
</pre>
<div class="Pp"></div>
The first argument &quot;pointer&quot; should be the name of a variable that
  will point to the newly allocated memory.
<div class="Pp"></div>
The second and third arguments &quot;number&quot; and &quot;type&quot; specify
  how many of the specified type of data structure should be allocated. The
  argument &quot;type&quot; is passed to &quot;sizeof&quot;. The final argument
  to &quot;Newxc&quot;, &quot;cast&quot;, should be used if the
  &quot;pointer&quot; argument is different from the &quot;type&quot; argument.
<div class="Pp"></div>
Unlike the &quot;Newx&quot; and &quot;Newxc&quot; macros, the &quot;Newxz&quot;
  macro calls &quot;memzero&quot; to zero out all the newly allocated memory.
<div class="Pp"></div>
<i>Reallocation</i>
<div class="Pp"></div>
<pre>
    Renew(pointer, number, type);
    Renewc(pointer, number, type, cast);
    Safefree(pointer)
</pre>
<div class="Pp"></div>
These three macros are used to change a memory buffer size or to free a piece of
  memory no longer needed. The arguments to &quot;Renew&quot; and
  &quot;Renewc&quot; match those of &quot;New&quot; and &quot;Newc&quot; with
  the exception of not needing the &quot;magic cookie&quot; argument.
<div class="Pp"></div>
<i>Moving</i>
<div class="Pp"></div>
<pre>
    Move(source, dest, number, type);
    Copy(source, dest, number, type);
    Zero(dest, number, type);
</pre>
<div class="Pp"></div>
These three macros are used to move, copy, or zero out previously allocated
  memory. The &quot;source&quot; and &quot;dest&quot; arguments point to the
  source and destination starting points. Perl will move, copy, or zero out
  &quot;number&quot; instances of the size of the &quot;type&quot; data
  structure (using the &quot;sizeof&quot; function).
<h2 class="Ss" title="Ss" id="PerlIO"><a class="selflink" href="#PerlIO">PerlIO</a></h2>
The most recent development releases of Perl have been experimenting with
  removing Perl's dependency on the &quot;normal&quot; standard I/O suite and
  allowing other stdio implementations to be used. This involves creating a new
  abstraction layer that then calls whichever implementation of stdio Perl was
  compiled with. All XSUBs should now use the functions in the PerlIO
  abstraction layer and not make any assumptions about what kind of stdio is
  being used.
<div class="Pp"></div>
For a complete description of the PerlIO abstraction, consult perlapio.
<h2 class="Ss" title="Ss" id="Putting_a_C_value_on_Perl_stack"><a class="selflink" href="#Putting_a_C_value_on_Perl_stack">Putting
  a C value on Perl stack</a></h2>
A lot of opcodes (this is an elementary operation in the internal perl stack
  machine) put an SV* on the stack. However, as an optimization the
  corresponding SV is (usually) not recreated each time. The opcodes reuse
  specially assigned SVs ( <i>target</i>s) which are (as a corollary) not
  constantly freed/created.
<div class="Pp"></div>
Each of the targets is created only once (but see &quot;Scratchpads and
  recursion&quot; below), and when an opcode needs to put an integer, a double,
  or a string on stack, it just sets the corresponding parts of its
  <i>target</i> and puts the <i>target</i> on stack.
<div class="Pp"></div>
The macro to put this target on stack is &quot;PUSHTARG&quot;, and it is
  directly used in some opcodes, as well as indirectly in zillions of others,
  which use it via &quot;(X)PUSH[iunp]&quot;.
<div class="Pp"></div>
Because the target is reused, you must be careful when pushing multiple values
  on the stack. The following code will not do what you think:
<div class="Pp"></div>
<pre>
    XPUSHi(10);
    XPUSHi(20);
</pre>
<div class="Pp"></div>
This translates as &quot;set &quot;TARG&quot; to 10, push a pointer to
  &quot;TARG&quot; onto the stack; set &quot;TARG&quot; to 20, push a pointer to
  &quot;TARG&quot; onto the stack&quot;. At the end of the operation, the stack
  does not contain the values 10 and 20, but actually contains two pointers to
  &quot;TARG&quot;, which we have set to 20.
<div class="Pp"></div>
If you need to push multiple different values then you should either use the
  &quot;(X)PUSHs&quot; macros, or else use the new &quot;m(X)PUSH[iunp]&quot;
  macros, none of which make use of &quot;TARG&quot;. The &quot;(X)PUSHs&quot;
  macros simply push an SV* on the stack, which, as noted under &quot;XSUBs and
  the Argument Stack&quot;, will often need to be &quot;mortal&quot;. The new
  &quot;m(X)PUSH[iunp]&quot; macros make this a little easier to achieve by
  creating a new mortal for you (via &quot;(X)PUSHmortal&quot;), pushing that
  onto the stack (extending it if necessary in the case of the
  &quot;mXPUSH[iunp]&quot; macros), and then setting its value. Thus, instead of
  writing this to &quot;fix&quot; the example above:
<div class="Pp"></div>
<pre>
    XPUSHs(sv_2mortal(newSViv(10)))
    XPUSHs(sv_2mortal(newSViv(20)))
</pre>
<div class="Pp"></div>
you can simply write:
<div class="Pp"></div>
<pre>
    mXPUSHi(10)
    mXPUSHi(20)
</pre>
<div class="Pp"></div>
On a related note, if you do use &quot;(X)PUSH[iunp]&quot;, then you're going to
  need a &quot;dTARG&quot; in your variable declarations so that the
  &quot;*PUSH*&quot; macros can make use of the local variable &quot;TARG&quot;.
  See also &quot;dTARGET&quot; and &quot;dXSTARG&quot;.
<h2 class="Ss" title="Ss" id="Scratchpads"><a class="selflink" href="#Scratchpads">Scratchpads</a></h2>
The question remains on when the SVs which are <i>target</i>s for opcodes are
  created. The answer is that they are created when the current unit--a
  subroutine or a file (for opcodes for statements outside of subroutines)--is
  compiled. During this time a special anonymous Perl array is created, which is
  called a scratchpad for the current unit.
<div class="Pp"></div>
A scratchpad keeps SVs which are lexicals for the current unit and are targets
  for opcodes. One can deduce that an SV lives on a scratchpad by looking on its
  flags: lexicals have &quot;SVs_PADMY&quot; set, and <i>target</i>s have
  &quot;SVs_PADTMP&quot; set.
<div class="Pp"></div>
The correspondence between OPs and <i>target</i>s is not 1-to-1. Different OPs
  in the compile tree of the unit can use the same target, if this would not
  conflict with the expected life of the temporary.
<h2 class="Ss" title="Ss" id="Scratchpads_and_recursion"><a class="selflink" href="#Scratchpads_and_recursion">Scratchpads
  and recursion</a></h2>
In fact it is not 100% true that a compiled unit contains a pointer to the
  scratchpad AV. In fact it contains a pointer to an AV of (initially) one
  element, and this element is the scratchpad AV. Why do we need an extra level
  of indirection?
<div class="Pp"></div>
The answer is <b>recursion</b>, and maybe <b>threads</b>. Both these can create
  several execution pointers going into the same subroutine. For the
  subroutine-child not write over the temporaries for the subroutine-parent
  (lifespan of which covers the call to the child), the parent and the child
  should have different scratchpads. ( <i>And</i> the lexicals should be
  separate anyway!)
<div class="Pp"></div>
So each subroutine is born with an array of scratchpads (of length 1). On each
  entry to the subroutine it is checked that the current depth of the recursion
  is not more than the length of this array, and if it is, new scratchpad is
  created and pushed into the array.
<div class="Pp"></div>
The <i>target</i>s on this scratchpad are &quot;undef&quot;s, but they are
  already marked with correct flags.
<h1 class="Sh" title="Sh" id="Compiled_code"><a class="selflink" href="#Compiled_code">Compiled
  code</a></h1>
<h2 class="Ss" title="Ss" id="Code_tree"><a class="selflink" href="#Code_tree">Code
  tree</a></h2>
Here we describe the internal form your code is converted to by Perl. Start with
  a simple example:
<div class="Pp"></div>
<pre>
  $a = $b + $c;
</pre>
<div class="Pp"></div>
This is converted to a tree similar to this one:
<div class="Pp"></div>
<pre>
             assign-to
           /           \
          +             $a
        /   \
      $b     $c
</pre>
<div class="Pp"></div>
(but slightly more complicated). This tree reflects the way Perl parsed your
  code, but has nothing to do with the execution order. There is an additional
  &quot;thread&quot; going through the nodes of the tree which shows the order
  of execution of the nodes. In our simplified example above it looks like:
<div class="Pp"></div>
<pre>
     $b ---&gt; $c ---&gt; + ---&gt; $a ---&gt; assign-to
</pre>
<div class="Pp"></div>
But with the actual compile tree for &quot;$a = $b + $c&quot; it is different:
  some nodes <i>optimized away</i>. As a corollary, though the actual tree
  contains more nodes than our simplified example, the execution order is the
  same as in our example.
<h2 class="Ss" title="Ss" id="Examining_the_tree"><a class="selflink" href="#Examining_the_tree">Examining
  the tree</a></h2>
If you have your perl compiled for debugging (usually done with
  &quot;-DDEBUGGING&quot; on the &quot;Configure&quot; command line), you may
  examine the compiled tree by specifying &quot;-Dx&quot; on the Perl command
  line. The output takes several lines per node, and for &quot;$b+$c&quot; it
  looks like this:
<div class="Pp"></div>
<pre>
    5           TYPE = add  ===&gt; 6
                TARG = 1
                FLAGS = (SCALAR,KIDS)
                {
                    TYPE = null  ===&gt; (4)
                      (was rv2sv)
                    FLAGS = (SCALAR,KIDS)
                    {
    3                   TYPE = gvsv  ===&gt; 4
                        FLAGS = (SCALAR)
                        GV = main::b
                    }
                }
                {
                    TYPE = null  ===&gt; (5)
                      (was rv2sv)
                    FLAGS = (SCALAR,KIDS)
                    {
    4                   TYPE = gvsv  ===&gt; 5
                        FLAGS = (SCALAR)
                        GV = main::c
                    }
                }
</pre>
<div class="Pp"></div>
This tree has 5 nodes (one per &quot;TYPE&quot; specifier), only 3 of them are
  not optimized away (one per number in the left column). The immediate children
  of the given node correspond to &quot;{}&quot; pairs on the same level of
  indentation, thus this listing corresponds to the tree:
<div class="Pp"></div>
<pre>
                   add
                 /     \
               null    null
                |       |
               gvsv    gvsv
</pre>
<div class="Pp"></div>
The execution order is indicated by &quot;===&gt;&quot; marks, thus it is
  &quot;3 4 5 6&quot; (node 6 is not included into above listing), i.e.,
  &quot;gvsv gvsv add whatever&quot;.
<div class="Pp"></div>
Each of these nodes represents an op, a fundamental operation inside the Perl
  core. The code which implements each operation can be found in the
  <i>pp*.c</i> files; the function which implements the op with type
  &quot;gvsv&quot; is &quot;pp_gvsv&quot;, and so on. As the tree above shows,
  different ops have different numbers of children: &quot;add&quot; is a binary
  operator, as one would expect, and so has two children. To accommodate the
  various different numbers of children, there are various types of op data
  structure, and they link together in different ways.
<div class="Pp"></div>
The simplest type of op structure is &quot;OP&quot;: this has no children. Unary
  operators, &quot;UNOP&quot;s, have one child, and this is pointed to by the
  &quot;op_first&quot; field. Binary operators (&quot;BINOP&quot;s) have not
  only an &quot;op_first&quot; field but also an &quot;op_last&quot; field. The
  most complex type of op is a &quot;LISTOP&quot;, which has any number of
  children. In this case, the first child is pointed to by &quot;op_first&quot;
  and the last child by &quot;op_last&quot;. The children in between can be
  found by iteratively following the &quot;op_sibling&quot; pointer from the
  first child to the last.
<div class="Pp"></div>
There are also two other op types: a &quot;PMOP&quot; holds a regular
  expression, and has no children, and a &quot;LOOP&quot; may or may not have
  children. If the &quot;op_children&quot; field is non-zero, it behaves like a
  &quot;LISTOP&quot;. To complicate matters, if a &quot;UNOP&quot; is actually a
  &quot;null&quot; op after optimization (see &quot;Compile pass 2: context
  propagation&quot;) it will still have children in accordance with its former
  type.
<div class="Pp"></div>
Another way to examine the tree is to use a compiler back-end module, such as
  B::Concise.
<h2 class="Ss" title="Ss" id="Compile_pass_1:_check_routines"><a class="selflink" href="#Compile_pass_1:_check_routines">Compile
  pass 1: check routines</a></h2>
The tree is created by the compiler while <i>yacc</i> code feeds it the
  constructions it recognizes. Since <i>yacc</i> works bottom-up, so does the
  first pass of perl compilation.
<div class="Pp"></div>
What makes this pass interesting for perl developers is that some optimization
  may be performed on this pass. This is optimization by so-called &quot;check
  routines&quot;. The correspondence between node names and corresponding check
  routines is described in <i>opcode.pl</i> (do not forget to run &quot;make
  regen_headers&quot; if you modify this file).
<div class="Pp"></div>
A check routine is called when the node is fully constructed except for the
  execution-order thread. Since at this time there are no back-links to the
  currently constructed node, one can do most any operation to the top-level
  node, including freeing it and/or creating new nodes above/below it.
<div class="Pp"></div>
The check routine returns the node which should be inserted into the tree (if
  the top-level node was not modified, check routine returns its argument).
<div class="Pp"></div>
By convention, check routines have names &quot;ck_*&quot;. They are usually
  called from &quot;new*OP&quot; subroutines (or &quot;convert&quot;) (which in
  turn are called from <i>perly.y</i>).
<h2 class="Ss" title="Ss" id="Compile_pass_1a:_constant_folding"><a class="selflink" href="#Compile_pass_1a:_constant_folding">Compile
  pass 1a: constant folding</a></h2>
Immediately after the check routine is called the returned node is checked for
  being compile-time executable. If it is (the value is judged to be constant)
  it is immediately executed, and a <i>constant</i> node with the &quot;return
  value&quot; of the corresponding subtree is substituted instead. The subtree
  is deleted.
<div class="Pp"></div>
If constant folding was not performed, the execution-order thread is created.
<h2 class="Ss" title="Ss" id="Compile_pass_2:_context_propagation"><a class="selflink" href="#Compile_pass_2:_context_propagation">Compile
  pass 2: context propagation</a></h2>
When a context for a part of compile tree is known, it is propagated down
  through the tree. At this time the context can have 5 values (instead of 2 for
  runtime context): void, boolean, scalar, list, and lvalue. In contrast with
  the pass 1 this pass is processed from top to bottom: a node's context
  determines the context for its children.
<div class="Pp"></div>
Additional context-dependent optimizations are performed at this time. Since at
  this moment the compile tree contains back-references (via &quot;thread&quot;
  pointers), nodes cannot be <i>free()</i>d now. To allow optimized-away nodes
  at this stage, such nodes are <i>null()</i>ified instead of <i>free()</i>ing
  (i.e. their type is changed to OP_NULL).
<h2 class="Ss" title="Ss" id="Compile_pass_3:_peephole_optimization"><a class="selflink" href="#Compile_pass_3:_peephole_optimization">Compile
  pass 3: peephole optimization</a></h2>
After the compile tree for a subroutine (or for an &quot;eval&quot; or a file)
  is created, an additional pass over the code is performed. This pass is
  neither top-down or bottom-up, but in the execution order (with additional
  complications for conditionals). Optimizations performed at this stage are
  subject to the same restrictions as in the pass 2.
<div class="Pp"></div>
Peephole optimizations are done by calling the function pointed to by the global
  variable &quot;PL_peepp&quot;. By default, &quot;PL_peepp&quot; just calls the
  function pointed to by the global variable &quot;PL_rpeepp&quot;. By default,
  that performs some basic op fixups and optimisations along the execution-order
  op chain, and recursively calls &quot;PL_rpeepp&quot; for each side chain of
  ops (resulting from conditionals). Extensions may provide additional
  optimisations or fixups, hooking into either the per-subroutine or recursive
  stage, like this:
<div class="Pp"></div>
<pre>
    static peep_t prev_peepp;
    static void my_peep(pTHX_ OP *o)
    {
        /* custom per-subroutine optimisation goes here */
        prev_peepp(o);
        /* custom per-subroutine optimisation may also go here */
    }
    BOOT:
        prev_peepp = PL_peepp;
        PL_peepp = my_peep;
    static peep_t prev_rpeepp;
    static void my_rpeep(pTHX_ OP *o)
    {
        OP *orig_o = o;
        for(; o; o = o-&gt;op_next) {
            /* custom per-op optimisation goes here */
        }
        prev_rpeepp(orig_o);
    }
    BOOT:
        prev_rpeepp = PL_rpeepp;
        PL_rpeepp = my_rpeep;
</pre>
<h2 class="Ss" title="Ss" id="Pluggable_runops"><a class="selflink" href="#Pluggable_runops">Pluggable
  runops</a></h2>
The compile tree is executed in a runops function. There are two runops
  functions, in <i>run.c</i> and in <i>dump.c</i>. &quot;Perl_runops_debug&quot;
  is used with DEBUGGING and &quot;Perl_runops_standard&quot; is used otherwise.
  For fine control over the execution of the compile tree it is possible to
  provide your own runops function.
<div class="Pp"></div>
It's probably best to copy one of the existing runops functions and change it to
  suit your needs. Then, in the BOOT section of your XS file, add the line:
<div class="Pp"></div>
<pre>
  PL_runops = my_runops;
</pre>
<div class="Pp"></div>
This function should be as efficient as possible to keep your programs running
  as fast as possible.
<h2 class="Ss" title="Ss" id="Compile-time_scope_hooks"><a class="selflink" href="#Compile-time_scope_hooks">Compile-time
  scope hooks</a></h2>
As of perl 5.14 it is possible to hook into the compile-time lexical scope
  mechanism using &quot;Perl_blockhook_register&quot;. This is used like this:
<div class="Pp"></div>
<pre>
    STATIC void my_start_hook(pTHX_ int full);
    STATIC BHK my_hooks;
    BOOT:
        BhkENTRY_set(&amp;my_hooks, bhk_start, my_start_hook);
        Perl_blockhook_register(aTHX_ &amp;my_hooks);
</pre>
<div class="Pp"></div>
This will arrange to have &quot;my_start_hook&quot; called at the start of
  compiling every lexical scope. The available hooks are:
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void bhk_start(pTHX_ int full)&quot;</dt>
  <dd class="It-tag">This is called just after starting a new lexical scope.
      Note that Perl code like
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    if ($x) { ... }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    creates two scopes: the first starts at the &quot;(&quot; and has &quot;full
      == 1&quot;, the second starts at the &quot;{&quot; and has &quot;full ==
      0&quot;. Both end at the &quot;}&quot;, so calls to &quot;start&quot; and
      &quot;pre/post_end&quot; will match. Anything pushed onto the save stack
      by this hook will be popped just before the scope ends (between the
      &quot;pre_&quot; and &quot;post_end&quot; hooks, in fact).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void bhk_pre_end(pTHX_ OP **o)&quot;</dt>
  <dd class="It-tag">This is called at the end of a lexical scope, just before
      unwinding the stack. <i>o</i> is the root of the optree representing the
      scope; it is a double pointer so you can replace the OP if you need
    to.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void bhk_post_end(pTHX_ OP **o)&quot;</dt>
  <dd class="It-tag">This is called at the end of a lexical scope, just after
      unwinding the stack. <i>o</i> is as above. Note that it is possible for
      calls to &quot;pre_&quot; and &quot;post_end&quot; to nest, if there is
      something on the save stack that calls string eval.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;void bhk_eval(pTHX_ OP *const o)&quot;</dt>
  <dd class="It-tag">This is called just before starting to compile an
      &quot;eval STRING&quot;, &quot;do FILE&quot;, &quot;require&quot; or
      &quot;use&quot;, after the eval has been set up. <i>o</i> is the OP that
      requested the eval, and will normally be an &quot;OP_ENTEREVAL&quot;,
      &quot;OP_DOFILE&quot; or &quot;OP_REQUIRE&quot;.</dd>
</dl>
<div class="Pp"></div>
Once you have your hook functions, you need a &quot;BHK&quot; structure to put
  them in. It's best to allocate it statically, since there is no way to free it
  once it's registered. The function pointers should be inserted into this
  structure using the &quot;BhkENTRY_set&quot; macro, which will also set flags
  indicating which entries are valid. If you do need to allocate your
  &quot;BHK&quot; dynamically for some reason, be sure to zero it before you
  start.
<div class="Pp"></div>
Once registered, there is no mechanism to switch these hooks off, so if that is
  necessary you will need to do this yourself. An entry in &quot;%^H&quot; is
  probably the best way, so the effect is lexically scoped; however it is also
  possible to use the &quot;BhkDISABLE&quot; and &quot;BhkENABLE&quot; macros to
  temporarily switch entries on and off. You should also be aware that generally
  speaking at least one scope will have opened before your extension is loaded,
  so you will see some &quot;pre/post_end&quot; pairs that didn't have a
  matching &quot;start&quot;.
<h1 class="Sh" title="Sh" id="Examining_internal_data_structures_with_the_&quot;dump&quot;_functions"><a class="selflink" href="#Examining_internal_data_structures_with_the_&quot;dump&quot;_functions">Examining
  internal data structures with the &quot;dump&quot; functions</a></h1>
To aid debugging, the source file <i>dump.c</i> contains a number of functions
  which produce formatted output of internal data structures.
<div class="Pp"></div>
The most commonly used of these functions is &quot;Perl_sv_dump&quot;; it's used
  for dumping SVs, AVs, HVs, and CVs. The &quot;Devel::Peek&quot; module calls
  &quot;sv_dump&quot; to produce debugging output from Perl-space, so users of
  that module should already be familiar with its format.
<div class="Pp"></div>
&quot;Perl_op_dump&quot; can be used to dump an &quot;OP&quot; structure or any
  of its derivatives, and produces output similar to &quot;perl -Dx&quot;; in
  fact, &quot;Perl_dump_eval&quot; will dump the main root of the code being
  evaluated, exactly like &quot;-Dx&quot;.
<div class="Pp"></div>
Other useful functions are &quot;Perl_dump_sub&quot;, which turns a
  &quot;GV&quot; into an op tree, &quot;Perl_dump_packsubs&quot; which calls
  &quot;Perl_dump_sub&quot; on all the subroutines in a package like so:
  (Thankfully, these are all xsubs, so there is no op tree)
<div class="Pp"></div>
<pre>
    (gdb) print Perl_dump_packsubs(PL_defstash)
    SUB attributes::bootstrap = (xsub 0x811fedc 0)
    SUB UNIVERSAL::can = (xsub 0x811f50c 0)
    SUB UNIVERSAL::isa = (xsub 0x811f304 0)
    SUB UNIVERSAL::VERSION = (xsub 0x811f7ac 0)
    SUB DynaLoader::boot_DynaLoader = (xsub 0x805b188 0)
</pre>
<div class="Pp"></div>
and &quot;Perl_dump_all&quot;, which dumps all the subroutines in the stash and
  the op tree of the main root.
<h1 class="Sh" title="Sh" id="How_multiple_interpreters_and_concurrency_are_supported"><a class="selflink" href="#How_multiple_interpreters_and_concurrency_are_supported">How
  multiple interpreters and concurrency are supported</a></h1>
<h2 class="Ss" title="Ss" id="Background_and_PERL_IMPLICIT_CONTEXT"><a class="selflink" href="#Background_and_PERL_IMPLICIT_CONTEXT">Background
  and PERL_IMPLICIT_CONTEXT</a></h2>
The Perl interpreter can be regarded as a closed box: it has an API for feeding
  it code or otherwise making it do things, but it also has functions for its
  own use. This smells a lot like an object, and there are ways for you to build
  Perl so that you can have multiple interpreters, with one interpreter
  represented either as a C structure, or inside a thread-specific structure.
  These structures contain all the context, the state of that interpreter.
<div class="Pp"></div>
One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY
  build has a C structure that packages all the interpreter state. With
  multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined,
  and enables the support for passing in a &quot;hidden&quot; first argument
  that represents all three data structures. MULTIPLICITY makes multi-threaded
  perls possible (with the ithreads threading model, related to the macro
  USE_ITHREADS.)
<div class="Pp"></div>
Two other &quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT and
  PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the former
  turns on MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the internal
  variables of Perl to be wrapped inside a single global struct, struct
  perl_vars, accessible as (globals) &amp;PL_Vars or PL_VarsPtr or the function
  <i>Perl_GetVars()</i>. The PERL_GLOBAL_STRUCT_PRIVATE goes one step further,
  there is still a single struct (allocated in <i>main()</i> either from heap or
  from stack) but there are no global data symbols pointing to it. In either
  case the global struct should be initialised as the very first thing in
  <i>main()</i> using <i>Perl_init_global_struct()</i> and correspondingly tear
  it down after <i>perl_free()</i> using <i>Perl_free_global_struct()</i>,
  please see <i>miniperlmain.c</i> for usage details. You may also need to use
  &quot;dVAR&quot; in your coding to &quot;declare the global variables&quot;
  when you are using them. dTHX does this for you automatically.
<div class="Pp"></div>
To see whether you have non-const data you can use a BSD-compatible
  &quot;nm&quot;:
<div class="Pp"></div>
<pre>
  nm libperl.a | grep -v ' [TURtr] '
</pre>
<div class="Pp"></div>
If this displays any &quot;D&quot; or &quot;d&quot; symbols, you have non-const
  data.
<div class="Pp"></div>
For backward compatibility reasons defining just PERL_GLOBAL_STRUCT doesn't
  actually hide all symbols inside a big global struct: some PerlIO_xxx vtables
  are left visible. The PERL_GLOBAL_STRUCT_PRIVATE then hides everything (see
  how the PERLIO_FUNCS_DECL is used).
<div class="Pp"></div>
All this obviously requires a way for the Perl internal functions to be either
  subroutines taking some kind of structure as the first argument, or
  subroutines taking nothing as the first argument. To enable these two very
  different ways of building the interpreter, the Perl source (as it does in so
  many other situations) makes heavy use of macros and subroutine naming
  conventions.
<div class="Pp"></div>
First problem: deciding which functions will be public API functions and which
  will be private. All functions whose names begin &quot;S_&quot; are private
  (think &quot;S&quot; for &quot;secret&quot; or &quot;static&quot;). All other
  functions begin with &quot;Perl_&quot;, but just because a function begins
  with &quot;Perl_&quot; does not mean it is part of the API. (See
  &quot;Internal Functions&quot;.) The easiest way to be <b>sure</b> a function
  is part of the API is to find its entry in perlapi. If it exists in perlapi,
  it's part of the API. If it doesn't, and you think it should be (i.e., you
  need it for your extension), send mail via perlbug explaining why you think it
  should be.
<div class="Pp"></div>
Second problem: there must be a syntax so that the same subroutine declarations
  and calls can pass a structure as their first argument, or pass nothing. To
  solve this, the subroutines are named and declared in a particular way. Here's
  a typical start of a static function used within the Perl guts:
<div class="Pp"></div>
<pre>
  STATIC void
  S_incline(pTHX_ char *s)
</pre>
<div class="Pp"></div>
STATIC becomes &quot;static&quot; in C, and may be #define'd to nothing in some
  configurations in the future.
<div class="Pp"></div>
A public function (i.e. part of the internal API, but not necessarily sanctioned
  for use in extensions) begins like this:
<div class="Pp"></div>
<pre>
  void
  Perl_sv_setiv(pTHX_ SV* dsv, IV num)
</pre>
<div class="Pp"></div>
&quot;pTHX_&quot; is one of a number of macros (in <i>perl.h</i>) that hide the
  details of the interpreter's context. THX stands for &quot;thread&quot;,
  &quot;this&quot;, or &quot;thingy&quot;, as the case may be. (And no, George
  Lucas is not involved. :-) The first character could be 'p' for a
  <b>p</b>rototype, 'a' for <b>a</b>rgument, or 'd' for <b>d</b>eclaration, so
  we have &quot;pTHX&quot;, &quot;aTHX&quot; and &quot;dTHX&quot;, and their
  variants.
<div class="Pp"></div>
When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no
  first argument containing the interpreter's context. The trailing underscore
  in the pTHX_ macro indicates that the macro expansion needs a comma after the
  context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT
  is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to
  take the extra argument. The form of the macro without the trailing underscore
  is used when there are no additional explicit arguments.
<div class="Pp"></div>
When a core function calls another, it must pass the context. This is normally
  hidden via macros. Consider &quot;sv_setiv&quot;. It expands into something
  like this:
<div class="Pp"></div>
<pre>
    #ifdef PERL_IMPLICIT_CONTEXT
      #define sv_setiv(a,b)      Perl_sv_setiv(aTHX_ a, b)
      /* can't do this for vararg functions, see below */
    #else
      #define sv_setiv           Perl_sv_setiv
    #endif
</pre>
<div class="Pp"></div>
This works well, and means that XS authors can gleefully write:
<div class="Pp"></div>
<pre>
    sv_setiv(foo, bar);
</pre>
<div class="Pp"></div>
and still have it work under all the modes Perl could have been compiled with.
<div class="Pp"></div>
This doesn't work so cleanly for varargs functions, though, as macros imply that
  the number of arguments is known in advance. Instead we either need to spell
  them out fully, passing &quot;aTHX_&quot; as the first argument (the Perl core
  tends to do this with functions like Perl_warner), or use a context-free
  version.
<div class="Pp"></div>
The context-free version of Perl_warner is called Perl_warner_nocontext, and
  does not take the extra argument. Instead it does dTHX; to get the context
  from thread-local storage. We &quot;#define warner Perl_warner_nocontext&quot;
  so that extensions get source compatibility at the expense of performance.
  (Passing an arg is cheaper than grabbing it from thread-local storage.)
<div class="Pp"></div>
You can ignore [pad]THXx when browsing the Perl headers/sources. Those are
  strictly for use within the core. Extensions and embedders need only be aware
  of [pad]THX.
<h2 class="Ss" title="Ss" id="So_what_happened_to_dTHR?"><a class="selflink" href="#So_what_happened_to_dTHR?">So
  what happened to dTHR?</a></h2>
&quot;dTHR&quot; was introduced in perl 5.005 to support the older thread model.
  The older thread model now uses the &quot;THX&quot; mechanism to pass context
  pointers around, so &quot;dTHR&quot; is not useful any more. Perl 5.6.0 and
  later still have it for backward source compatibility, but it is defined to be
  a no-op.
<h2 class="Ss" title="Ss" id="How_do_I_use_all_this_in_extensions?"><a class="selflink" href="#How_do_I_use_all_this_in_extensions?">How
  do I use all this in extensions?</a></h2>
When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any
  functions in the Perl API will need to pass the initial context argument
  somehow. The kicker is that you will need to write it in such a way that the
  extension still compiles when Perl hasn't been built with
  PERL_IMPLICIT_CONTEXT enabled.
<div class="Pp"></div>
There are three ways to do this. First, the easy but inefficient way, which is
  also the default, in order to maintain source compatibility with extensions:
  whenever <i>XSUB.h</i> is #included, it redefines the aTHX and aTHX_ macros to
  call a function that will return the context. Thus, something like:
<div class="Pp"></div>
<pre>
        sv_setiv(sv, num);
</pre>
<div class="Pp"></div>
in your extension will translate to this when PERL_IMPLICIT_CONTEXT is in
  effect:
<div class="Pp"></div>
<pre>
        Perl_sv_setiv(Perl_get_context(), sv, num);
</pre>
<div class="Pp"></div>
or to this otherwise:
<div class="Pp"></div>
<pre>
        Perl_sv_setiv(sv, num);
</pre>
<div class="Pp"></div>
You don't have to do anything new in your extension to get this; since the Perl
  library provides <i>Perl_get_context()</i>, it will all just work.
<div class="Pp"></div>
The second, more efficient way is to use the following template for your Foo.xs:
<div class="Pp"></div>
<pre>
        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
        #include &quot;EXTERN.h&quot;
        #include &quot;perl.h&quot;
        #include &quot;XSUB.h&quot;
        STATIC void my_private_function(int arg1, int arg2);
        STATIC void
        my_private_function(int arg1, int arg2)
        {
            dTHX;       /* fetch context */
            ... call many Perl API functions ...
        }
        [... etc ...]
        MODULE = Foo            PACKAGE = Foo
        /* typical XSUB */
        void
        my_xsub(arg)
                int arg
            CODE:
                my_private_function(arg, 10);
</pre>
<div class="Pp"></div>
Note that the only two changes from the normal way of writing an extension is
  the addition of a &quot;#define PERL_NO_GET_CONTEXT&quot; before including the
  Perl headers, followed by a &quot;dTHX;&quot; declaration at the start of
  every function that will call the Perl API. (You'll know which functions need
  this, because the C compiler will complain that there's an undeclared
  identifier in those functions.) No changes are needed for the XSUBs
  themselves, because the <i>XS()</i> macro is correctly defined to pass in the
  implicit context if needed.
<div class="Pp"></div>
The third, even more efficient way is to ape how it is done within the Perl
  guts:
<div class="Pp"></div>
<pre>
        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
        #include &quot;EXTERN.h&quot;
        #include &quot;perl.h&quot;
        #include &quot;XSUB.h&quot;
        /* pTHX_ only needed for functions that call Perl API */
        STATIC void my_private_function(pTHX_ int arg1, int arg2);
        STATIC void
        my_private_function(pTHX_ int arg1, int arg2)
        {
            /* dTHX; not needed here, because THX is an argument */
            ... call Perl API functions ...
        }
        [... etc ...]
        MODULE = Foo            PACKAGE = Foo
        /* typical XSUB */
        void
        my_xsub(arg)
                int arg
            CODE:
                my_private_function(aTHX_ arg, 10);
</pre>
<div class="Pp"></div>
This implementation never has to fetch the context using a function call, since
  it is always passed as an extra argument. Depending on your needs for
  simplicity or efficiency, you may mix the previous two approaches freely.
<div class="Pp"></div>
Never add a comma after &quot;pTHX&quot; yourself--always use the form of the
  macro with the underscore for functions that take explicit arguments, or the
  form without the argument for functions with no explicit arguments.
<div class="Pp"></div>
If one is compiling Perl with the &quot;-DPERL_GLOBAL_STRUCT&quot; the
  &quot;dVAR&quot; definition is needed if the Perl global variables (see
  <i>perlvars.h</i> or <i>globvar.sym</i>) are accessed in the function and
  &quot;dTHX&quot; is not used (the &quot;dTHX&quot; includes the
  &quot;dVAR&quot; if necessary). One notices the need for &quot;dVAR&quot; only
  with the said compile-time define, because otherwise the Perl global variables
  are visible as-is.
<h2 class="Ss" title="Ss" id="Should_I_do_anything_special_if_I_call_perl_from_multiple_threads?"><a class="selflink" href="#Should_I_do_anything_special_if_I_call_perl_from_multiple_threads?">Should
  I do anything special if I call perl from multiple threads?</a></h2>
If you create interpreters in one thread and then proceed to call them in
  another, you need to make sure perl's own Thread Local Storage (TLS) slot is
  initialized correctly in each of those threads.
<div class="Pp"></div>
The &quot;perl_alloc&quot; and &quot;perl_clone&quot; API functions will
  automatically set the TLS slot to the interpreter they created, so that there
  is no need to do anything special if the interpreter is always accessed in the
  same thread that created it, and that thread did not create or call any other
  interpreters afterwards. If that is not the case, you have to set the TLS slot
  of the thread before calling any functions in the Perl API on that particular
  interpreter. This is done by calling the &quot;PERL_SET_CONTEXT&quot; macro in
  that thread as the first thing you do:
<div class="Pp"></div>
<pre>
        /* do this before doing anything else with some_perl */
        PERL_SET_CONTEXT(some_perl);
        ... other Perl API calls on some_perl go here ...
</pre>
<h2 class="Ss" title="Ss" id="Future_Plans_and_PERL_IMPLICIT_SYS"><a class="selflink" href="#Future_Plans_and_PERL_IMPLICIT_SYS">Future
  Plans and PERL_IMPLICIT_SYS</a></h2>
Just as PERL_IMPLICIT_CONTEXT provides a way to bundle up everything that the
  interpreter knows about itself and pass it around, so too are there plans to
  allow the interpreter to bundle up everything it knows about the environment
  it's running on. This is enabled with the PERL_IMPLICIT_SYS macro. Currently
  it only works with USE_ITHREADS on Windows.
<div class="Pp"></div>
This allows the ability to provide an extra pointer (called the &quot;host&quot;
  environment) for all the system calls. This makes it possible for all the
  system stuff to maintain their own state, broken down into seven C structures.
  These are thin wrappers around the usual system calls (see
  <i>win32/perllib.c</i>) for the default perl executable, but for a more
  ambitious host (like the one that would do <i>fork()</i> emulation) all the
  extra work needed to pretend that different interpreters are actually
  different &quot;processes&quot;, would be done here.
<div class="Pp"></div>
The Perl engine/interpreter and the host are orthogonal entities. There could be
  one or more interpreters in a process, and one or more &quot;hosts&quot;, with
  free association between them.
<h1 class="Sh" title="Sh" id="Internal_Functions"><a class="selflink" href="#Internal_Functions">Internal
  Functions</a></h1>
All of Perl's internal functions which will be exposed to the outside world are
  prefixed by &quot;Perl_&quot; so that they will not conflict with XS functions
  or functions used in a program in which Perl is embedded. Similarly, all
  global variables begin with &quot;PL_&quot;. (By convention, static functions
  start with &quot;S_&quot;.)
<div class="Pp"></div>
Inside the Perl core (&quot;PERL_CORE&quot; defined), you can get at the
  functions either with or without the &quot;Perl_&quot; prefix, thanks to a
  bunch of defines that live in <i>embed.h</i>. Note that extension code should
  <i>not</i> set &quot;PERL_CORE&quot;; this exposes the full perl internals,
  and is likely to cause breakage of the XS in each new perl release.
<div class="Pp"></div>
The file <i>embed.h</i> is generated automatically from <i>embed.pl</i> and
  <i>embed.fnc</i>. <i>embed.pl</i> also creates the prototyping header files
  for the internal functions, generates the documentation and a lot of other
  bits and pieces. It's important that when you add a new function to the core
  or change an existing one, you change the data in the table in
  <i>embed.fnc</i> as well. Here's a sample entry from that table:
<div class="Pp"></div>
<pre>
    Apd |SV**   |av_fetch   |AV* ar|I32 key|I32 lval
</pre>
<div class="Pp"></div>
The second column is the return type, the third column the name. Columns after
  that are the arguments. The first column is a set of flags:
<dl class="Bl-tag">
  <dt class="It-tag">A</dt>
  <dd class="It-tag">This function is a part of the public API. All such
      functions should also have 'd', very few do not.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">p</dt>
  <dd class="It-tag">This function has a &quot;Perl_&quot; prefix; i.e. it is
      defined as &quot;Perl_av_fetch&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">d</dt>
  <dd class="It-tag">This function has documentation using the
      &quot;apidoc&quot; feature which we'll look at in a second. Some functions
      have 'd' but not 'A'; docs are good.</dd>
</dl>
<div class="Pp"></div>
Other available flags are:
<dl class="Bl-tag">
  <dt class="It-tag">s</dt>
  <dd class="It-tag">This is a static function and is defined as &quot;STATIC
      S_whatever&quot;, and usually called within the sources as
      &quot;whatever(...)&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">n</dt>
  <dd class="It-tag">This does not need an interpreter context, so the
      definition has no &quot;pTHX&quot;, and it follows that callers don't use
      &quot;aTHX&quot;. (See &quot;Background and
    PERL_IMPLICIT_CONTEXT&quot;.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">r</dt>
  <dd class="It-tag">This function never returns; &quot;croak&quot;,
      &quot;exit&quot; and friends.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">f</dt>
  <dd class="It-tag">This function takes a variable number of arguments,
      &quot;printf&quot; style. The argument list should end with
      &quot;...&quot;, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    Afprd   |void   |croak          |const char* pat|...
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">M</dt>
  <dd class="It-tag">This function is part of the experimental development API,
      and may change or disappear without notice.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">This function should not have a compatibility macro to
      define, say, &quot;Perl_parse&quot; to &quot;parse&quot;. It must be
      called as &quot;Perl_parse&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">x</dt>
  <dd class="It-tag">This function isn't exported out of the Perl core.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">m</dt>
  <dd class="It-tag">This is implemented as a macro.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">X</dt>
  <dd class="It-tag">This function is explicitly exported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">E</dt>
  <dd class="It-tag">This function is visible to extensions included in the Perl
      core.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b</dt>
  <dd class="It-tag">Binary backward compatibility; this function is a macro but
      also has a &quot;Perl_&quot; implementation (which is exported).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">others</dt>
  <dd class="It-tag">See the comments at the top of &quot;embed.fnc&quot; for
      others.</dd>
</dl>
<div class="Pp"></div>
If you edit <i>embed.pl</i> or <i>embed.fnc</i>, you will need to run &quot;make
  regen_headers&quot; to force a rebuild of <i>embed.h</i> and other
  auto-generated files.
<h2 class="Ss" title="Ss" id="Formatted_Printing_of_IVs,_UVs,_and_NVs"><a class="selflink" href="#Formatted_Printing_of_IVs,_UVs,_and_NVs">Formatted
  Printing of IVs, UVs, and NVs</a></h2>
If you are printing IVs, UVs, or NVS instead of the <i>stdio</i>(3) style
  formatting codes like %d, %ld, %f, you should use the following macros for
  portability
<div class="Pp"></div>
<pre>
        IVdf            IV in decimal
        UVuf            UV in decimal
        UVof            UV in octal
        UVxf            UV in hexadecimal
        NVef            NV %e-like
        NVff            NV %f-like
        NVgf            NV %g-like
</pre>
<div class="Pp"></div>
These will take care of 64-bit integers and long doubles. For example:
<div class="Pp"></div>
<pre>
        printf(&quot;IV is %&quot;IVdf&quot;\n&quot;, iv);
</pre>
<div class="Pp"></div>
The IVdf will expand to whatever is the correct format for the IVs.
<div class="Pp"></div>
If you are printing addresses of pointers, use UVxf combined with
  <i>PTR2UV()</i>, do not use %lx or %p.
<h2 class="Ss" title="Ss" id="Pointer-To-Integer_and_Integer-To-Pointer"><a class="selflink" href="#Pointer-To-Integer_and_Integer-To-Pointer">Pointer-To-Integer
  and Integer-To-Pointer</a></h2>
Because pointer size does not necessarily equal integer size, use the follow
  macros to do it right.
<div class="Pp"></div>
<pre>
        PTR2UV(pointer)
        PTR2IV(pointer)
        PTR2NV(pointer)
        INT2PTR(pointertotype, integer)
</pre>
<div class="Pp"></div>
For example:
<div class="Pp"></div>
<pre>
        IV  iv = ...;
        SV *sv = INT2PTR(SV*, iv);
</pre>
<div class="Pp"></div>
and
<div class="Pp"></div>
<pre>
        AV *av = ...;
        UV  uv = PTR2UV(av);
</pre>
<h2 class="Ss" title="Ss" id="Exception_Handling"><a class="selflink" href="#Exception_Handling">Exception
  Handling</a></h2>
There are a couple of macros to do very basic exception handling in XS modules.
  You have to define &quot;NO_XSLOCKS&quot; before including <i>XSUB.h</i> to be
  able to use these macros:
<div class="Pp"></div>
<pre>
        #define NO_XSLOCKS
        #include &quot;XSUB.h&quot;
</pre>
<div class="Pp"></div>
You can use these macros if you call code that may croak, but you need to do
  some cleanup before giving control back to Perl. For example:
<div class="Pp"></div>
<pre>
        dXCPT;    /* set up necessary variables */
        XCPT_TRY_START {
          code_that_may_croak();
        } XCPT_TRY_END
        XCPT_CATCH
        {
          /* do cleanup here */
          XCPT_RETHROW;
        }
</pre>
<div class="Pp"></div>
Note that you always have to rethrow an exception that has been caught. Using
  these macros, it is not possible to just catch the exception and ignore it. If
  you have to ignore the exception, you have to use the &quot;call_*&quot;
  function.
<div class="Pp"></div>
The advantage of using the above macros is that you don't have to setup an extra
  function for &quot;call_*&quot;, and that using these macros is faster than
  using &quot;call_*&quot;.
<h2 class="Ss" title="Ss" id="Source_Documentation"><a class="selflink" href="#Source_Documentation">Source
  Documentation</a></h2>
There's an effort going on to document the internal functions and automatically
  produce reference manuals from them - perlapi is one such manual which details
  all the functions which are available to XS writers. perlintern is the
  autogenerated manual for the functions which are not part of the API and are
  supposedly for internal use only.
<div class="Pp"></div>
Source documentation is created by putting POD comments into the C source, like
  this:
<div class="Pp"></div>
<pre>
 /*
 =for apidoc sv_setiv
 Copies an integer into the given SV.  Does not handle 'set' magic.  See
 C&lt;sv_setiv_mg&gt;.
 =cut
 */
</pre>
<div class="Pp"></div>
Please try and supply some documentation if you add functions to the Perl core.
<h2 class="Ss" title="Ss" id="Backwards_compatibility"><a class="selflink" href="#Backwards_compatibility">Backwards
  compatibility</a></h2>
The Perl API changes over time. New functions are added or the interfaces of
  existing functions are changed. The &quot;Devel::PPPort&quot; module tries to
  provide compatibility code for some of these changes, so XS writers don't have
  to code it themselves when supporting multiple versions of Perl.
<div class="Pp"></div>
&quot;Devel::PPPort&quot; generates a C header file <i>ppport.h</i> that can
  also be run as a Perl script. To generate <i>ppport.h</i>, run:
<div class="Pp"></div>
<pre>
    perl -MDevel::PPPort -eDevel::PPPort::WriteFile
</pre>
<div class="Pp"></div>
Besides checking existing XS code, the script can also be used to retrieve
  compatibility information for various API calls using the
  &quot;--api-info&quot; command line switch. For example:
<div class="Pp"></div>
<pre>
  % perl ppport.h --api-info=sv_magicext
</pre>
<div class="Pp"></div>
For details, see &quot;perldoc ppport.h&quot;.
<h1 class="Sh" title="Sh" id="Unicode_Support"><a class="selflink" href="#Unicode_Support">Unicode
  Support</a></h1>
Perl 5.6.0 introduced Unicode support. It's important for porters and XS writers
  to understand this support and make sure that the code they write does not
  corrupt Unicode data.
<h2 class="Ss" title="Ss" id="What_is_Unicode,_anyway?"><a class="selflink" href="#What_is_Unicode,_anyway?">What
  <b>is</b> Unicode, anyway?</a></h2>
In the olden, less enlightened times, we all used to use ASCII. Most of us did,
  anyway. The big problem with ASCII is that it's American. Well, no, that's not
  actually the problem; the problem is that it's not particularly useful for
  people who don't use the Roman alphabet. What used to happen was that
  particular languages would stick their own alphabet in the upper range of the
  sequence, between 128 and 255. Of course, we then ended up with plenty of
  variants that weren't quite ASCII, and the whole point of it being a standard
  was lost.
<div class="Pp"></div>
Worse still, if you've got a language like Chinese or Japanese that has hundreds
  or thousands of characters, then you really can't fit them into a mere 256, so
  they had to forget about ASCII altogether, and build their own systems using
  pairs of numbers to refer to one character.
<div class="Pp"></div>
To fix this, some people formed Unicode, Inc. and produced a new character set
  containing all the characters you can possibly think of and more. There are
  several ways of representing these characters, and the one Perl uses is called
  UTF-8. UTF-8 uses a variable number of bytes to represent a character. You can
  learn more about Unicode and Perl's Unicode model in perlunicode.
<h2 class="Ss" title="Ss" id="How_can_I_recognise_a_UTF-8_string?"><a class="selflink" href="#How_can_I_recognise_a_UTF-8_string?">How
  can I recognise a UTF-8 string?</a></h2>
You can't. This is because UTF-8 data is stored in bytes just like non-UTF-8
  data. The Unicode character 200, (0xC8 for you hex types) capital E with a
  grave accent, is represented by the two bytes &quot;v196.172&quot;.
  Unfortunately, the non-Unicode string &quot;chr(196).chr(172)&quot; has that
  byte sequence as well. So you can't tell just by looking - this is what makes
  Unicode input an interesting problem.
<div class="Pp"></div>
In general, you either have to know what you're dealing with, or you have to
  guess. The API function &quot;is_utf8_string&quot; can help; it'll tell you if
  a string contains only valid UTF-8 characters. However, it can't do the work
  for you. On a character-by-character basis, &quot;is_utf8_char&quot; will tell
  you whether the current character in a string is valid UTF-8.
<h2 class="Ss" title="Ss" id="How_does_UTF-8_represent_Unicode_characters?"><a class="selflink" href="#How_does_UTF-8_represent_Unicode_characters?">How
  does UTF-8 represent Unicode characters?</a></h2>
As mentioned above, UTF-8 uses a variable number of bytes to store a character.
  Characters with values 0...127 are stored in one byte, just like good ol'
  ASCII. Character 128 is stored as &quot;v194.128&quot;; this continues up to
  character 191, which is &quot;v194.191&quot;. Now we've run out of bits (191
  is binary 10111111) so we move on; 192 is &quot;v195.128&quot;. And so it goes
  on, moving to three bytes at character 2048.
<div class="Pp"></div>
Assuming you know you're dealing with a UTF-8 string, you can find out how long
  the first character in it is with the &quot;UTF8SKIP&quot; macro:
<div class="Pp"></div>
<pre>
    char *utf = &quot;\305\233\340\240\201&quot;;
    I32 len;
    len = UTF8SKIP(utf); /* len is 2 here */
    utf += len;
    len = UTF8SKIP(utf); /* len is 3 here */
</pre>
<div class="Pp"></div>
Another way to skip over characters in a UTF-8 string is to use
  &quot;utf8_hop&quot;, which takes a string and a number of characters to skip
  over. You're on your own about bounds checking, though, so don't use it
  lightly.
<div class="Pp"></div>
All bytes in a multi-byte UTF-8 character will have the high bit set, so you can
  test if you need to do something special with this character like this (the
  <i>UTF8_IS_INVARIANT()</i> is a macro that tests whether the byte can be
  encoded as a single byte even in UTF-8):
<div class="Pp"></div>
<pre>
    U8 *utf;
    U8 *utf_end; /* 1 beyond buffer pointed to by utf */
    UV uv;      /* Note: a UV, not a U8, not a char */
    STRLEN len; /* length of character in bytes */
    if (!UTF8_IS_INVARIANT(*utf))
        /* Must treat this as UTF-8 */
        uv = utf8_to_uvchr_buf(utf, utf_end, &amp;len);
    else
        /* OK to treat this character as a byte */
        uv = *utf;
</pre>
<div class="Pp"></div>
You can also see in that example that we use &quot;utf8_to_uvchr_buf&quot; to
  get the value of the character; the inverse function &quot;uvchr_to_utf8&quot;
  is available for putting a UV into UTF-8:
<div class="Pp"></div>
<pre>
    if (!UTF8_IS_INVARIANT(uv))
        /* Must treat this as UTF8 */
        utf8 = uvchr_to_utf8(utf8, uv);
    else
        /* OK to treat this character as a byte */
        *utf8++ = uv;
</pre>
<div class="Pp"></div>
You <b>must</b> convert characters to UVs using the above functions if you're
  ever in a situation where you have to match UTF-8 and non-UTF-8 characters.
  You may not skip over UTF-8 characters in this case. If you do this, you'll
  lose the ability to match hi-bit non-UTF-8 characters; for instance, if your
  UTF-8 string contains &quot;v196.172&quot;, and you skip that character, you
  can never match a &quot;chr(200)&quot; in a non-UTF-8 string. So don't do
  that!
<h2 class="Ss" title="Ss" id="How_does_Perl_store_UTF-8_strings?"><a class="selflink" href="#How_does_Perl_store_UTF-8_strings?">How
  does Perl store UTF-8 strings?</a></h2>
Currently, Perl deals with Unicode strings and non-Unicode strings slightly
  differently. A flag in the SV, &quot;SVf_UTF8&quot;, indicates that the string
  is internally encoded as UTF-8. Without it, the byte value is the codepoint
  number and vice versa (in other words, the string is encoded as iso-8859-1,
  but &quot;use feature 'unicode_strings'&quot; is needed to get iso-8859-1
  semantics). You can check and manipulate this flag with the following macros:
<div class="Pp"></div>
<pre>
    SvUTF8(sv)
    SvUTF8_on(sv)
    SvUTF8_off(sv)
</pre>
<div class="Pp"></div>
This flag has an important effect on Perl's treatment of the string: if Unicode
  data is not properly distinguished, regular expressions, &quot;length&quot;,
  &quot;substr&quot; and other string handling operations will have undesirable
  results.
<div class="Pp"></div>
The problem comes when you have, for instance, a string that isn't flagged as
  UTF-8, and contains a byte sequence that could be UTF-8 - especially when
  combining non-UTF-8 and UTF-8 strings.
<div class="Pp"></div>
Never forget that the &quot;SVf_UTF8&quot; flag is separate to the PV value; you
  need be sure you don't accidentally knock it off while you're manipulating
  SVs. More specifically, you cannot expect to do this:
<div class="Pp"></div>
<pre>
    SV *sv;
    SV *nsv;
    STRLEN len;
    char *p;
    p = SvPV(sv, len);
    frobnicate(p);
    nsv = newSVpvn(p, len);
</pre>
<div class="Pp"></div>
The &quot;char*&quot; string does not tell you the whole story, and you can't
  copy or reconstruct an SV just by copying the string value. Check if the old
  SV has the UTF8 flag set, and act accordingly:
<div class="Pp"></div>
<pre>
    p = SvPV(sv, len);
    frobnicate(p);
    nsv = newSVpvn(p, len);
    if (SvUTF8(sv))
        SvUTF8_on(nsv);
</pre>
<div class="Pp"></div>
In fact, your &quot;frobnicate&quot; function should be made aware of whether or
  not it's dealing with UTF-8 data, so that it can handle the string
  appropriately.
<div class="Pp"></div>
Since just passing an SV to an XS function and copying the data of the SV is not
  enough to copy the UTF8 flags, even less right is just passing a &quot;char
  *&quot; to an XS function.
<h2 class="Ss" title="Ss" id="How_do_I_convert_a_string_to_UTF-8?"><a class="selflink" href="#How_do_I_convert_a_string_to_UTF-8?">How
  do I convert a string to UTF-8?</a></h2>
If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade one of
  the strings to UTF-8. If you've got an SV, the easiest way to do this is:
<div class="Pp"></div>
<pre>
    sv_utf8_upgrade(sv);
</pre>
<div class="Pp"></div>
However, you must not do this, for example:
<div class="Pp"></div>
<pre>
    if (!SvUTF8(left))
        sv_utf8_upgrade(left);
</pre>
<div class="Pp"></div>
If you do this in a binary operator, you will actually change one of the strings
  that came into the operator, and, while it shouldn't be noticeable by the end
  user, it can cause problems in deficient code.
<div class="Pp"></div>
Instead, &quot;bytes_to_utf8&quot; will give you a UTF-8-encoded <b>copy</b> of
  its string argument. This is useful for having the data available for
  comparisons and so on, without harming the original SV. There's also
  &quot;utf8_to_bytes&quot; to go the other way, but naturally, this will fail
  if the string contains any characters above 255 that can't be represented in a
  single byte.
<h2 class="Ss" title="Ss" id="Is_there_anything_else_I_need_to_know?"><a class="selflink" href="#Is_there_anything_else_I_need_to_know?">Is
  there anything else I need to know?</a></h2>
Not really. Just remember these things:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">There's no way to tell if a string is UTF-8 or not. You can
      tell if an SV is UTF-8 by looking at its &quot;SvUTF8&quot; flag. Don't
      forget to set the flag if something should be UTF-8. Treat the flag as
      part of the PV, even though it's not - if you pass on the PV to somewhere,
      pass on the flag too.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a string is UTF-8, <b>always</b> use
      &quot;utf8_to_uvchr_buf&quot; to get at the value, unless
      &quot;UTF8_IS_INVARIANT(*s)&quot; in which case you can use *s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">When writing a character &quot;uv&quot; to a UTF-8 string,
      <b>always</b> use &quot;uvchr_to_utf8&quot;, unless
      &quot;UTF8_IS_INVARIANT(uv))&quot; in which case you can use &quot;*s =
      uv&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Mixing UTF-8 and non-UTF-8 strings is tricky. Use
      &quot;bytes_to_utf8&quot; to get a new string which is UTF-8 encoded, and
      then combine them.</dd>
</dl>
<h1 class="Sh" title="Sh" id="Custom_Operators"><a class="selflink" href="#Custom_Operators">Custom
  Operators</a></h1>
Custom operator support is a new experimental feature that allows you to define
  your own ops. This is primarily to allow the building of interpreters for
  other languages in the Perl core, but it also allows optimizations through the
  creation of &quot;macro-ops&quot; (ops which perform the functions of multiple
  ops which are usually executed together, such as &quot;gvsv, gvsv, add&quot;.)
<div class="Pp"></div>
This feature is implemented as a new op type, &quot;OP_CUSTOM&quot;. The Perl
  core does not &quot;know&quot; anything special about this op type, and so it
  will not be involved in any optimizations. This also means that you can define
  your custom ops to be any op structure - unary, binary, list and so on - you
  like.
<div class="Pp"></div>
It's important to know what custom operators won't do for you. They won't let
  you add new syntax to Perl, directly. They won't even let you add new
  keywords, directly. In fact, they won't change the way Perl compiles a program
  at all. You have to do those changes yourself, after Perl has compiled the
  program. You do this either by manipulating the op tree using a
  &quot;CHECK&quot; block and the &quot;B::Generate&quot; module, or by adding a
  custom peephole optimizer with the &quot;optimize&quot; module.
<div class="Pp"></div>
When you do this, you replace ordinary Perl ops with custom ops by creating ops
  with the type &quot;OP_CUSTOM&quot; and the &quot;pp_addr&quot; of your own PP
  function. This should be defined in XS code, and should look like the PP ops
  in &quot;pp_*.c&quot;. You are responsible for ensuring that your op takes the
  appropriate number of values from the stack, and you are responsible for
  adding stack marks if necessary.
<div class="Pp"></div>
You should also &quot;register&quot; your op with the Perl interpreter so that
  it can produce sensible error and warning messages. Since it is possible to
  have multiple custom ops within the one &quot;logical&quot; op type
  &quot;OP_CUSTOM&quot;, Perl uses the value of &quot;o-&gt;op_ppaddr&quot; to
  determine which custom op it is dealing with. You should create an
  &quot;XOP&quot; structure for each ppaddr you use, set the properties of the
  custom op with &quot;XopENTRY_set&quot;, and register the structure against
  the ppaddr using &quot;Perl_custom_op_register&quot;. A trivial example might
  look like:
<div class="Pp"></div>
<pre>
    static XOP my_xop;
    static OP *my_pp(pTHX);
    BOOT:
        XopENTRY_set(&amp;my_xop, xop_name, &quot;myxop&quot;);
        XopENTRY_set(&amp;my_xop, xop_desc, &quot;Useless custom op&quot;);
        Perl_custom_op_register(aTHX_ my_pp, &amp;my_xop);
</pre>
<div class="Pp"></div>
The available fields in the structure are:
<dl class="Bl-tag">
  <dt class="It-tag">xop_name</dt>
  <dd class="It-tag">A short name for your op. This will be included in some
      error messages, and will also be returned as &quot;$op-&gt;name&quot; by
      the B module, so it will appear in the output of module like
    B::Concise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">xop_desc</dt>
  <dd class="It-tag">A short description of the function of the op.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">xop_class</dt>
  <dd class="It-tag">Which of the various *OP structures this op uses. This
      should be one of the &quot;OA_*&quot; constants from <i>op.h</i>,
    namely</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">OA_BASEOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_UNOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_BINOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_LOGOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_LISTOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_PMOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_SVOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_PADOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_PVOP_OR_SVOP</dt>
  <dd class="It-tag">This should be interpreted as '&quot;PVOP&quot;' only. The
      &quot;_OR_SVOP&quot; is because the only core &quot;PVOP&quot;,
      &quot;OP_TRANS&quot;, can sometimes be a &quot;SVOP&quot; instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_LOOP</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OA_COP</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
The other &quot;OA_*&quot; constants should not be used.</div>
<dl class="Bl-tag">
  <dt class="It-tag">xop_peep</dt>
  <dd class="It-tag">This member is of type &quot;Perl_cpeep_t&quot;, which
      expands to &quot;void (*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&quot;. If it
      is set, this function will be called from &quot;Perl_rpeep&quot; when ops
      of this type are encountered by the peephole optimizer. <i>o</i> is the OP
      that needs optimizing; <i>oldop</i> is the previous OP optimized, whose
      &quot;op_next&quot; points to <i>o</i>.</dd>
</dl>
<div class="Pp"></div>
&quot;B::Generate&quot; directly supports the creation of custom ops by name.
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Until May 1997, this document was maintained by Jeff Okamoto
  &lt;okamoto@corp.hp.com&gt;. It is now maintained as part of Perl itself by
  the Perl 5 Porters &lt;perl5-porters@perl.org&gt;.
<div class="Pp"></div>
With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas
  Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew
  Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and
  Gurusamy Sarathy.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlapi, perlintern, perlxs, perlembed</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
