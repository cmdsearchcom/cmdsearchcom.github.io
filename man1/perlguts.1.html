<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:54 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLGUTS(1) Perl Programmers Reference Guide
PERLGUTS(1)</p>

<p style="margin-top: 1em">NAME <br>
perlguts - Introduction to the Perl API</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This document attempts to describe how to use the Perl API,
as well as to provide some info on the basic workings of the
Perl core. It is far from complete and probably contains
<br>
many errors. Please refer any questions or comments to the
author below.</p>

<p style="margin-top: 1em">Variables <br>
Datatypes <br>
Perl has three typedefs that handle Perl&rsquo;s three main
data types:</p>

<p style="margin-top: 1em">SV Scalar Value <br>
AV Array Value <br>
HV Hash Value</p>

<p style="margin-top: 1em">Each typedef has specific
routines that manipulate the various data types.</p>

<p style="margin-top: 1em">What is an &quot;IV&quot;? <br>
Perl uses a special typedef IV which is a simple signed
integer type that is guaranteed to be large enough to hold a
pointer (as well as an integer). Additionally, there is the
<br>
UV, which is simply an unsigned IV.</p>

<p style="margin-top: 1em">Perl also uses two special
typedefs, I32 and I16, which will always be at least 32-bits
and 16-bits long, respectively. (Again, there are U32 and
U16, as well.) They will <br>
usually be exactly 32 and 16 bits long, but on Crays they
will both be 64 bits.</p>

<p style="margin-top: 1em">Working with SVs <br>
An SV can be created and loaded with one command. There are
five types of values that can be loaded: an integer value
(IV), an unsigned integer value (UV), a double (NV), a <br>
string (PV), and another scalar (SV).</p>

<p style="margin-top: 1em">The seven routines are:</p>

<p style="margin-top: 1em">SV* newSViv(IV); <br>
SV* newSVuv(UV); <br>
SV* newSVnv(double); <br>
SV* newSVpv(const char*, STRLEN); <br>
SV* newSVpvn(const char*, STRLEN); <br>
SV* newSVpvf(const char*, ...); <br>
SV* newSVsv(SV*);</p>

<p style="margin-top: 1em">&quot;STRLEN&quot; is an integer
type (Size_t, usually defined as size_t in config.h)
guaranteed to be large enough to represent the size of any
string that perl can handle.</p>

<p style="margin-top: 1em">In the unlikely case of a SV
requiring more complex initialisation, you can create an
empty SV with newSV(len). If &quot;len&quot; is 0 an empty
SV of type NULL is returned, else an SV of <br>
type PV is returned with len + 1 (for the NUL) bytes of
storage allocated, accessible via SvPVX. In both cases the
SV has the undef value.</p>

<p style="margin-top: 1em">SV *sv = newSV(0); /* no storage
allocated */ <br>
SV *sv = newSV(10); /* 10 (+1) bytes of uninitialised
storage <br>
* allocated */</p>

<p style="margin-top: 1em">To change the value of an
already-existing SV, there are eight routines:</p>

<p style="margin-top: 1em">void sv_setiv(SV*, IV); <br>
void sv_setuv(SV*, UV); <br>
void sv_setnv(SV*, double); <br>
void sv_setpv(SV*, const char*); <br>
void sv_setpvn(SV*, const char*, STRLEN) <br>
void sv_setpvf(SV*, const char*, ...); <br>
void sv_vsetpvfn(SV*, const char*, STRLEN, va_list *, <br>
SV **, I32, bool *); <br>
void sv_setsv(SV*, SV*);</p>

<p style="margin-top: 1em">Notice that you can choose to
specify the length of the string to be assigned by using
&quot;sv_setpvn&quot;, &quot;newSVpvn&quot;, or
&quot;newSVpv&quot;, or you may allow Perl to calculate the
length by <br>
using &quot;sv_setpv&quot; or by specifying 0 as the second
argument to &quot;newSVpv&quot;. Be warned, though, that
Perl will determine the string&rsquo;s length by using
&quot;strlen&quot;, which depends on the <br>
string terminating with a NUL character, and not otherwise
containing NULs.</p>

<p style="margin-top: 1em">The arguments of
&quot;sv_setpvf&quot; are processed like
&quot;sprintf&quot;, and the formatted output becomes the
value.</p>

<p style="margin-top: 1em">&quot;sv_vsetpvfn&quot; is an
analogue of &quot;vsprintf&quot;, but it allows you to
specify either a pointer to a variable argument list or the
address and length of an array of SVs. The last <br>
argument points to a boolean; on return, if that boolean is
true, then locale-specific information has been used to
format the string, and the string&rsquo;s contents are
therefore <br>
untrustworthy (see perlsec). This pointer may be NULL if
that information is not important. Note that this function
requires you to specify the length of the format.</p>

<p style="margin-top: 1em">The &quot;sv_set*()&quot;
functions are not generic enough to operate on values that
have &quot;magic&quot;. See &quot;Magic Virtual Tables&quot;
later in this document.</p>

<p style="margin-top: 1em">All SVs that contain strings
should be terminated with a NUL character. If it is not
NUL-terminated there is a risk of core dumps and corruptions
from code which passes the <br>
string to C functions or system calls which expect a
NUL-terminated string. Perl&rsquo;s own functions typically
add a trailing NUL for this reason. Nevertheless, you should
be very <br>
careful when you pass a string stored in an SV to a C
function or system call.</p>

<p style="margin-top: 1em">To access the actual value that
an SV points to, you can use the macros:</p>

<p style="margin-top: 1em">SvIV(SV*) <br>
SvUV(SV*) <br>
SvNV(SV*) <br>
SvPV(SV*, STRLEN len) <br>
SvPV_nolen(SV*)</p>

<p style="margin-top: 1em">which will automatically coerce
the actual scalar type into an IV, UV, double, or
string.</p>

<p style="margin-top: 1em">In the &quot;SvPV&quot; macro,
the length of the string returned is placed into the
variable &quot;len&quot; (this is a macro, so you do not use
&amp;len). If you do not care what the length of the <br>
data is, use the &quot;SvPV_nolen&quot; macro. Historically
the &quot;SvPV&quot; macro with the global variable
&quot;PL_na&quot; has been used in this case. But that can
be quite inefficient because <br>
&quot;PL_na&quot; must be accessed in thread-local storage
in threaded Perl. In any case, remember that Perl allows
arbitrary strings of data that may both contain NULs and
might not be <br>
terminated by a NUL.</p>

<p style="margin-top: 1em">Also remember that C
doesn&rsquo;t allow you to safely say &quot;foo(SvPV(s,
len), len);&quot;. It might work with your compiler, but it
won&rsquo;t work for everyone. Break this sort of statement
up <br>
into separate assignments:</p>

<p style="margin-top: 1em">SV *s; <br>
STRLEN len; <br>
char *ptr; <br>
ptr = SvPV(s, len); <br>
foo(ptr, len);</p>

<p style="margin-top: 1em">If you want to know if the
scalar value is TRUE, you can use:</p>

<p style="margin-top: 1em">SvTRUE(SV*)</p>

<p style="margin-top: 1em">Although Perl will automatically
grow strings for you, if you need to force Perl to allocate
more memory for your SV, you can use the macro</p>

<p style="margin-top: 1em">SvGROW(SV*, STRLEN newlen)</p>

<p style="margin-top: 1em">which will determine if more
memory needs to be allocated. If so, it will call the
function &quot;sv_grow&quot;. Note that &quot;SvGROW&quot;
can only increase, not decrease, the allocated memory <br>
of an SV and that it does not automatically add space for
the trailing NUL byte (perl&rsquo;s own string functions
typically do &quot;SvGROW(sv, len + 1)&quot;).</p>

<p style="margin-top: 1em">If you have an SV and want to
know what kind of data Perl thinks is stored in it, you can
use the following macros to check the type of SV you
have.</p>

<p style="margin-top: 1em">SvIOK(SV*) <br>
SvNOK(SV*) <br>
SvPOK(SV*)</p>

<p style="margin-top: 1em">You can get and set the current
length of the string stored in an SV with the following
macros:</p>

<p style="margin-top: 1em">SvCUR(SV*) <br>
SvCUR_set(SV*, I32 val)</p>

<p style="margin-top: 1em">You can also get a pointer to
the end of the string stored in the SV with the macro:</p>

<p style="margin-top: 1em">SvEND(SV*)</p>

<p style="margin-top: 1em">But note that these last three
macros are valid only if &quot;SvPOK()&quot; is true.</p>

<p style="margin-top: 1em">If you want to append something
to the end of string stored in an &quot;SV*&quot;, you can
use the following functions:</p>

<p style="margin-top: 1em">void sv_catpv(SV*, const char*);
<br>
void sv_catpvn(SV*, const char*, STRLEN); <br>
void sv_catpvf(SV*, const char*, ...); <br>
void sv_vcatpvfn(SV*, const char*, STRLEN, va_list *, SV **,
<br>
I32, bool); <br>
void sv_catsv(SV*, SV*);</p>

<p style="margin-top: 1em">The first function calculates
the length of the string to be appended by using
&quot;strlen&quot;. In the second, you specify the length of
the string yourself. The third function <br>
processes its arguments like &quot;sprintf&quot; and appends
the formatted output. The fourth function works like
&quot;vsprintf&quot;. You can specify the address and length
of an array of SVs <br>
instead of the va_list argument. The fifth function extends
the string stored in the first SV with the string stored in
the second SV. It also forces the second SV to be <br>
interpreted as a string.</p>

<p style="margin-top: 1em">The &quot;sv_cat*()&quot;
functions are not generic enough to operate on values that
have &quot;magic&quot;. See &quot;Magic Virtual Tables&quot;
later in this document.</p>

<p style="margin-top: 1em">If you know the name of a scalar
variable, you can get a pointer to its SV by using the
following:</p>

<p style="margin-top: 1em">SV*
get_sv(&quot;package::varname&quot;, 0);</p>

<p style="margin-top: 1em">This returns NULL if the
variable does not exist.</p>

<p style="margin-top: 1em">If you want to know if this
variable (or any other SV) is actually &quot;defined&quot;,
you can call:</p>

<p style="margin-top: 1em">SvOK(SV*)</p>

<p style="margin-top: 1em">The scalar &quot;undef&quot;
value is stored in an SV instance called
&quot;PL_sv_undef&quot;.</p>

<p style="margin-top: 1em">Its address can be used whenever
an &quot;SV*&quot; is needed. Make sure that you don&rsquo;t
try to compare a random sv with &amp;PL_sv_undef. For
example when interfacing Perl code, it&rsquo;ll work <br>
correctly for:</p>

<p style="margin-top: 1em">foo(undef);</p>

<p style="margin-top: 1em">But won&rsquo;t work when called
as:</p>

<p style="margin-top: 1em">$x = undef; <br>
foo($x);</p>

<p style="margin-top: 1em">So to repeat always use SvOK()
to check whether an sv is defined.</p>

<p style="margin-top: 1em">Also you have to be careful when
using &amp;PL_sv_undef as a value in AVs or HVs (see
&quot;AVs, HVs and undefined values&quot;).</p>

<p style="margin-top: 1em">There are also the two values
&quot;PL_sv_yes&quot; and &quot;PL_sv_no&quot;, which
contain boolean TRUE and FALSE values, respectively. Like
&quot;PL_sv_undef&quot;, their addresses can be used
whenever an <br>
&quot;SV*&quot; is needed.</p>

<p style="margin-top: 1em">Do not be fooled into thinking
that &quot;(SV *) 0&quot; is the same as &amp;PL_sv_undef.
Take this code:</p>

<p style="margin-top: 1em">SV* sv = (SV*) 0; <br>
if (I-am-to-return-a-real-value) { <br>
sv = sv_2mortal(newSViv(42)); <br>
} <br>
sv_setsv(ST(0), sv);</p>

<p style="margin-top: 1em">This code tries to return a new
SV (which contains the value 42) if it should return a real
value, or undef otherwise. Instead it has returned a NULL
pointer which, somewhere <br>
down the line, will cause a segmentation violation, bus
error, or just weird results. Change the zero to
&amp;PL_sv_undef in the first line and all will be well.</p>

<p style="margin-top: 1em">To free an SV that you&rsquo;ve
created, call &quot;SvREFCNT_dec(SV*)&quot;. Normally this
call is not necessary (see &quot;Reference Counts and
Mortality&quot;).</p>

<p style="margin-top: 1em">Offsets <br>
Perl provides the function &quot;sv_chop&quot; to
efficiently remove characters from the beginning of a
string; you give it an SV and a pointer to somewhere inside
the PV, and it discards <br>
everything before the pointer. The efficiency comes by means
of a little hack: instead of actually removing the
characters, &quot;sv_chop&quot; sets the flag
&quot;OOK&quot; (offset OK) to signal to <br>
other functions that the offset hack is in effect, and it
puts the number of bytes chopped off into the IV field of
the SV. It then moves the PV pointer (called
&quot;SvPVX&quot;) forward <br>
that many bytes, and adjusts &quot;SvCUR&quot; and
&quot;SvLEN&quot;.</p>

<p style="margin-top: 1em">Hence, at this point, the start
of the buffer that we allocated lives at &quot;SvPVX(sv) -
SvIV(sv)&quot; in memory and the PV pointer is pointing into
the middle of this allocated <br>
storage.</p>

<p style="margin-top: 1em">This is best demonstrated by
example:</p>

<p style="margin-top: 1em">% ./perl -Ilib -MDevel::Peek -le
&rsquo;$a=&quot;12345&quot;; $a=~s/.//; Dump($a)&rsquo; <br>
SV = PVIV(0x8128450) at 0x81340f0 <br>
REFCNT = 1 <br>
FLAGS = (POK,OOK,pPOK) <br>
IV = 1 (OFFSET) <br>
PV = 0x8135781 ( &quot;1&quot; . ) &quot;2345&quot; <br>
CUR = 4 <br>
LEN = 5</p>

<p style="margin-top: 1em">Here the number of bytes chopped
off (1) is put into IV, and &quot;Devel::Peek::Dump&quot;
helpfully reminds us that this is an offset. The portion of
the string between the &quot;real&quot; and the <br>
&quot;fake&quot; beginnings is shown in parentheses, and the
values of &quot;SvCUR&quot; and &quot;SvLEN&quot; reflect
the fake beginning, not the real one.</p>

<p style="margin-top: 1em">Something similar to the offset
hack is performed on AVs to enable efficient shifting and
splicing off the beginning of the array; while
&quot;AvARRAY&quot; points to the first element in <br>
the array that is visible from Perl, &quot;AvALLOC&quot;
points to the real start of the C array. These are usually
the same, but a &quot;shift&quot; operation can be carried
out by increasing <br>
&quot;AvARRAY&quot; by one and decreasing &quot;AvFILL&quot;
and &quot;AvMAX&quot;. Again, the location of the real start
of the C array only comes into play when freeing the array.
See &quot;av_shift&quot; in av.c.</p>

<p style="margin-top: 1em">What&rsquo;s Really Stored in an
SV? <br>
Recall that the usual method of determining the type of
scalar you have is to use &quot;Sv*OK&quot; macros. Because
a scalar can be both a number and a string, usually these
macros will <br>
always return TRUE and calling the &quot;Sv*V&quot; macros
will do the appropriate conversion of string to
integer/double or integer/double to string.</p>

<p style="margin-top: 1em">If you really need to know if
you have an integer, double, or string pointer in an SV, you
can use the following three macros instead:</p>

<p style="margin-top: 1em">SvIOKp(SV*) <br>
SvNOKp(SV*) <br>
SvPOKp(SV*)</p>

<p style="margin-top: 1em">These will tell you if you truly
have an integer, double, or string pointer stored in your
SV. The &quot;p&quot; stands for private.</p>

<p style="margin-top: 1em">There are various ways in which
the private and public flags may differ. For example, a tied
SV may have a valid underlying value in the IV slot (so
SvIOKp is true), but the <br>
data should be accessed via the FETCH routine rather than
directly, so SvIOK is false. Another is when numeric
conversion has occurred and precision has been lost: only
the <br>
private flag is set on &rsquo;lossy&rsquo; values. So when
an NV is converted to an IV with loss, SvIOKp, SvNOKp and
SvNOK will be set, while SvIOK wont be.</p>

<p style="margin-top: 1em">In general, though, it&rsquo;s
best to use the &quot;Sv*V&quot; macros.</p>

<p style="margin-top: 1em">Working with AVs <br>
There are two ways to create and load an AV. The first
method creates an empty AV:</p>

<p style="margin-top: 1em">AV* newAV();</p>

<p style="margin-top: 1em">The second method both creates
the AV and initially populates it with SVs:</p>

<p style="margin-top: 1em">AV* av_make(I32 num, SV
**ptr);</p>

<p style="margin-top: 1em">The second argument points to an
array containing &quot;num&quot; &quot;SV*&quot;&rsquo;s.
Once the AV has been created, the SVs can be destroyed, if
so desired.</p>

<p style="margin-top: 1em">Once the AV has been created,
the following operations are possible on it:</p>

<p style="margin-top: 1em">void av_push(AV*, SV*); <br>
SV* av_pop(AV*); <br>
SV* av_shift(AV*); <br>
void av_unshift(AV*, I32 num);</p>

<p style="margin-top: 1em">These should be familiar
operations, with the exception of &quot;av_unshift&quot;.
This routine adds &quot;num&quot; elements at the front of
the array with the &quot;undef&quot; value. You must then
use <br>
&quot;av_store&quot; (described below) to assign values to
these new elements.</p>

<p style="margin-top: 1em">Here are some other
functions:</p>

<p style="margin-top: 1em">I32 av_len(AV*); <br>
SV** av_fetch(AV*, I32 key, I32 lval); <br>
SV** av_store(AV*, I32 key, SV* val);</p>

<p style="margin-top: 1em">The &quot;av_len&quot; function
returns the highest index value in an array (just like
$#array in Perl). If the array is empty, -1 is returned. The
&quot;av_fetch&quot; function returns the value <br>
at index &quot;key&quot;, but if &quot;lval&quot; is
non-zero, then &quot;av_fetch&quot; will store an undef
value at that index. The &quot;av_store&quot; function
stores the value &quot;val&quot; at index &quot;key&quot;,
and does not <br>
increment the reference count of &quot;val&quot;. Thus the
caller is responsible for taking care of that, and if
&quot;av_store&quot; returns NULL, the caller will have to
decrement the reference <br>
count to avoid a memory leak. Note that &quot;av_fetch&quot;
and &quot;av_store&quot; both return
&quot;SV**&quot;&rsquo;s, not &quot;SV*&quot;&rsquo;s as
their return value.</p>

<p style="margin-top: 1em">A few more:</p>

<p style="margin-top: 1em">void av_clear(AV*); <br>
void av_undef(AV*); <br>
void av_extend(AV*, I32 key);</p>

<p style="margin-top: 1em">The &quot;av_clear&quot;
function deletes all the elements in the AV* array, but does
not actually delete the array itself. The
&quot;av_undef&quot; function will delete all the elements
in the <br>
array plus the array itself. The &quot;av_extend&quot;
function extends the array so that it contains at least
&quot;key+1&quot; elements. If &quot;key+1&quot; is less
than the currently allocated length of <br>
the array, then nothing is done.</p>

<p style="margin-top: 1em">If you know the name of an array
variable, you can get a pointer to its AV by using the
following:</p>

<p style="margin-top: 1em">AV*
get_av(&quot;package::varname&quot;, 0);</p>

<p style="margin-top: 1em">This returns NULL if the
variable does not exist.</p>

<p style="margin-top: 1em">See &quot;Understanding the
Magic of Tied Hashes and Arrays&quot; for more information
on how to use the array access functions on tied arrays.</p>

<p style="margin-top: 1em">Working with HVs <br>
To create an HV, you use the following routine:</p>

<p style="margin-top: 1em">HV* newHV();</p>

<p style="margin-top: 1em">Once the HV has been created,
the following operations are possible on it:</p>

<p style="margin-top: 1em">SV** hv_store(HV*, const char*
key, U32 klen, SV* val, U32 hash); <br>
SV** hv_fetch(HV*, const char* key, U32 klen, I32 lval);</p>

<p style="margin-top: 1em">The &quot;klen&quot; parameter
is the length of the key being passed in (Note that you
cannot pass 0 in as a value of &quot;klen&quot; to tell Perl
to measure the length of the key). The &quot;val&quot; <br>
argument contains the SV pointer to the scalar being stored,
and &quot;hash&quot; is the precomputed hash value (zero if
you want &quot;hv_store&quot; to calculate it for you). The
&quot;lval&quot; parameter <br>
indicates whether this fetch is actually a part of a store
operation, in which case a new undefined value will be added
to the HV with the supplied key and &quot;hv_fetch&quot;
will return <br>
as if the value had already existed.</p>

<p style="margin-top: 1em">Remember that
&quot;hv_store&quot; and &quot;hv_fetch&quot; return
&quot;SV**&quot;&rsquo;s and not just &quot;SV*&quot;. To
access the scalar value, you must first dereference the
return value. However, you should check <br>
to make sure that the return value is not NULL before
dereferencing it.</p>

<p style="margin-top: 1em">The first of these two functions
checks if a hash table entry exists, and the second deletes
it.</p>

<p style="margin-top: 1em">bool hv_exists(HV*, const char*
key, U32 klen); <br>
SV* hv_delete(HV*, const char* key, U32 klen, I32
flags);</p>

<p style="margin-top: 1em">If &quot;flags&quot; does not
include the &quot;G_DISCARD&quot; flag then
&quot;hv_delete&quot; will create and return a mortal copy
of the deleted value.</p>

<p style="margin-top: 1em">And more miscellaneous
functions:</p>

<p style="margin-top: 1em">void hv_clear(HV*); <br>
void hv_undef(HV*);</p>

<p style="margin-top: 1em">Like their AV counterparts,
&quot;hv_clear&quot; deletes all the entries in the hash
table but does not actually delete the hash table. The
&quot;hv_undef&quot; deletes both the entries and the <br>
hash table itself.</p>

<p style="margin-top: 1em">Perl keeps the actual data in a
linked list of structures with a typedef of HE. These
contain the actual key and value pointers (plus extra
administrative overhead). The key is <br>
a string pointer; the value is an &quot;SV*&quot;. However,
once you have an &quot;HE*&quot;, to get the actual key and
value, use the routines specified below.</p>

<p style="margin-top: 1em">I32 hv_iterinit(HV*); <br>
/* Prepares starting point to traverse hash table */ <br>
HE* hv_iternext(HV*); <br>
/* Get the next entry, and return a pointer to a <br>
structure that has both the key and value */ <br>
char* hv_iterkey(HE* entry, I32* retlen); <br>
/* Get the key from an HE structure and also return <br>
the length of the key string */ <br>
SV* hv_iterval(HV*, HE* entry); <br>
/* Return an SV pointer to the value of the HE <br>
structure */ <br>
SV* hv_iternextsv(HV*, char** key, I32* retlen); <br>
/* This convenience routine combines hv_iternext, <br>
hv_iterkey, and hv_iterval. The key and retlen <br>
arguments are return values for the key and its <br>
length. The value is returned in the SV* argument */</p>

<p style="margin-top: 1em">If you know the name of a hash
variable, you can get a pointer to its HV by using the
following:</p>

<p style="margin-top: 1em">HV*
get_hv(&quot;package::varname&quot;, 0);</p>

<p style="margin-top: 1em">This returns NULL if the
variable does not exist.</p>

<p style="margin-top: 1em">The hash algorithm is defined in
the &quot;PERL_HASH(hash, key, klen)&quot; macro:</p>

<p style="margin-top: 1em">hash = 0; <br>
while (klen--) <br>
hash = (hash * 33) + *key++; <br>
hash = hash + (hash &gt;&gt; 5); /* after 5.6 */</p>

<p style="margin-top: 1em">The last step was added in
version 5.6 to improve distribution of lower bits in the
resulting hash value.</p>

<p style="margin-top: 1em">See &quot;Understanding the
Magic of Tied Hashes and Arrays&quot; for more information
on how to use the hash access functions on tied hashes.</p>

<p style="margin-top: 1em">Hash API Extensions <br>
Beginning with version 5.004, the following functions are
also supported:</p>

<p style="margin-top: 1em">HE* hv_fetch_ent (HV* tb, SV*
key, I32 lval, U32 hash); <br>
HE* hv_store_ent (HV* tb, SV* key, SV* val, U32 hash);</p>

<p style="margin-top: 1em">bool hv_exists_ent (HV* tb, SV*
key, U32 hash); <br>
SV* hv_delete_ent (HV* tb, SV* key, I32 flags, U32
hash);</p>

<p style="margin-top: 1em">SV* hv_iterkeysv (HE*
entry);</p>

<p style="margin-top: 1em">Note that these functions take
&quot;SV*&quot; keys, which simplifies writing of extension
code that deals with hash structures. These functions also
allow passing of &quot;SV*&quot; keys to &quot;tie&quot;
<br>
functions without forcing you to stringify the keys (unlike
the previous set of functions).</p>

<p style="margin-top: 1em">They also return and accept
whole hash entries (&quot;HE*&quot;), making their use more
efficient (since the hash number for a particular string
doesn&rsquo;t have to be recomputed every time). <br>
See perlapi for detailed descriptions.</p>

<p style="margin-top: 1em">The following macros must always
be used to access the contents of hash entries. Note that
the arguments to these macros must be simple variables,
since they may get evaluated <br>
more than once. See perlapi for detailed descriptions of
these macros.</p>

<p style="margin-top: 1em">HePV(HE* he, STRLEN len) <br>
HeVAL(HE* he) <br>
HeHASH(HE* he) <br>
HeSVKEY(HE* he) <br>
HeSVKEY_force(HE* he) <br>
HeSVKEY_set(HE* he, SV* sv)</p>

<p style="margin-top: 1em">These two lower level macros are
defined, but must only be used when dealing with keys that
are not &quot;SV*&quot;s:</p>

<p style="margin-top: 1em">HeKEY(HE* he) <br>
HeKLEN(HE* he)</p>

<p style="margin-top: 1em">Note that both
&quot;hv_store&quot; and &quot;hv_store_ent&quot; do not
increment the reference count of the stored &quot;val&quot;,
which is the caller&rsquo;s responsibility. If these
functions return a NULL <br>
value, the caller will usually have to decrement the
reference count of &quot;val&quot; to avoid a memory
leak.</p>

<p style="margin-top: 1em">AVs, HVs and undefined values
<br>
Sometimes you have to store undefined values in AVs or HVs.
Although this may be a rare case, it can be tricky.
That&rsquo;s because you&rsquo;re used to using
&amp;PL_sv_undef if you need an <br>
undefined SV.</p>

<p style="margin-top: 1em">For example, intuition tells you
that this XS code:</p>

<p style="margin-top: 1em">AV *av = newAV(); <br>
av_store( av, 0, &amp;PL_sv_undef );</p>

<p style="margin-top: 1em">is equivalent to this Perl
code:</p>

<p style="margin-top: 1em">my @av; <br>
$av[0] = undef;</p>

<p style="margin-top: 1em">Unfortunately, this isn&rsquo;t
true. AVs use &amp;PL_sv_undef as a marker for indicating
that an array element has not yet been initialized. Thus,
&quot;exists $av[0]&quot; would be true for the <br>
above Perl code, but false for the array generated by the XS
code.</p>

<p style="margin-top: 1em">Other problems can occur when
storing &amp;PL_sv_undef in HVs:</p>

<p style="margin-top: 1em">hv_store( hv, &quot;key&quot;,
3, &amp;PL_sv_undef, 0 );</p>

<p style="margin-top: 1em">This will indeed make the value
&quot;undef&quot;, but if you try to modify the value of
&quot;key&quot;, you&rsquo;ll get the following error:</p>

<p style="margin-top: 1em">Modification of non-creatable
hash value attempted</p>

<p style="margin-top: 1em">In perl 5.8.0, &amp;PL_sv_undef
was also used to mark placeholders in restricted hashes.
This caused such hash entries not to appear when iterating
over the hash or when checking for <br>
the keys with the &quot;hv_exists&quot; function.</p>

<p style="margin-top: 1em">You can run into similar
problems when you store &amp;PL_sv_yes or &amp;PL_sv_no into
AVs or HVs. Trying to modify such elements will give you the
following error:</p>

<p style="margin-top: 1em">Modification of a read-only
value attempted</p>

<p style="margin-top: 1em">To make a long story short, you
can use the special variables &amp;PL_sv_undef,
&amp;PL_sv_yes and &amp;PL_sv_no with AVs and HVs, but you
have to make sure you know what you&rsquo;re doing.</p>

<p style="margin-top: 1em">Generally, if you want to store
an undefined value in an AV or HV, you should not use
&amp;PL_sv_undef, but rather create a new undefined value
using the &quot;newSV&quot; function, for <br>
example:</p>

<p style="margin-top: 1em">av_store( av, 42, newSV(0) );
<br>
hv_store( hv, &quot;foo&quot;, 3, newSV(0), 0 );</p>

<p style="margin-top: 1em">References <br>
References are a special type of scalar that point to other
data types (including other references).</p>

<p style="margin-top: 1em">To create a reference, use
either of the following functions:</p>

<p style="margin-top: 1em">SV* newRV_inc((SV*) thing); <br>
SV* newRV_noinc((SV*) thing);</p>

<p style="margin-top: 1em">The &quot;thing&quot; argument
can be any of an &quot;SV*&quot;, &quot;AV*&quot;, or
&quot;HV*&quot;. The functions are identical except that
&quot;newRV_inc&quot; increments the reference count of the
&quot;thing&quot;, while <br>
&quot;newRV_noinc&quot; does not. For historical reasons,
&quot;newRV&quot; is a synonym for
&quot;newRV_inc&quot;.</p>

<p style="margin-top: 1em">Once you have a reference, you
can use the following macro to dereference the
reference:</p>

<p style="margin-top: 1em">SvRV(SV*)</p>

<p style="margin-top: 1em">then call the appropriate
routines, casting the returned &quot;SV*&quot; to either an
&quot;AV*&quot; or &quot;HV*&quot;, if required.</p>

<p style="margin-top: 1em">To determine if an SV is a
reference, you can use the following macro:</p>

<p style="margin-top: 1em">SvROK(SV*)</p>

<p style="margin-top: 1em">To discover what type of value
the reference refers to, use the following macro and then
check the return value.</p>

<p style="margin-top: 1em">SvTYPE(SvRV(SV*))</p>

<p style="margin-top: 1em">The most useful types that will
be returned are:</p>

<p style="margin-top: 1em">SVt_IV Scalar <br>
SVt_NV Scalar <br>
SVt_PV Scalar <br>
SVt_RV Scalar <br>
SVt_PVAV Array <br>
SVt_PVHV Hash <br>
SVt_PVCV Code <br>
SVt_PVGV Glob (possibly a file handle) <br>
SVt_PVMG Blessed or Magical Scalar</p>

<p style="margin-top: 1em">See the sv.h header file for
more details.</p>

<p style="margin-top: 1em">Blessed References and Class
Objects <br>
References are also used to support object-oriented
programming. In perl&rsquo;s OO lexicon, an object is simply
a reference that has been blessed into a package (or class).
Once <br>
blessed, the programmer may now use the reference to access
the various methods in the class.</p>

<p style="margin-top: 1em">A reference can be blessed into
a package with the following function:</p>

<p style="margin-top: 1em">SV* sv_bless(SV* sv, HV*
stash);</p>

<p style="margin-top: 1em">The &quot;sv&quot; argument must
be a reference value. The &quot;stash&quot; argument
specifies which class the reference will belong to. See
&quot;Stashes and Globs&quot; for information on converting
<br>
class names into stashes.</p>

<p style="margin-top: 1em">/* Still under construction
*/</p>

<p style="margin-top: 1em">The following function upgrades
rv to reference if not already one. Creates a new SV for rv
to point to. If &quot;classname&quot; is non-null, the SV is
blessed into the specified class. <br>
SV is returned.</p>

<p style="margin-top: 1em">SV* newSVrv(SV* rv, const char*
classname);</p>

<p style="margin-top: 1em">The following three functions
copy integer, unsigned integer or double into an SV whose
reference is &quot;rv&quot;. SV is blessed if
&quot;classname&quot; is non-null.</p>

<p style="margin-top: 1em">SV* sv_setref_iv(SV* rv, const
char* classname, IV iv); <br>
SV* sv_setref_uv(SV* rv, const char* classname, UV uv); <br>
SV* sv_setref_nv(SV* rv, const char* classname, NV iv);</p>

<p style="margin-top: 1em">The following function copies
the pointer value (the address, not the string!) into an SV
whose reference is rv. SV is blessed if
&quot;classname&quot; is non-null.</p>

<p style="margin-top: 1em">SV* sv_setref_pv(SV* rv, const
char* classname, void* pv);</p>

<p style="margin-top: 1em">The following function copies a
string into an SV whose reference is &quot;rv&quot;. Set
length to 0 to let Perl calculate the string length. SV is
blessed if &quot;classname&quot; is non-null.</p>

<p style="margin-top: 1em">SV* sv_setref_pvn(SV* rv, const
char* classname, char* pv, <br>
STRLEN length);</p>

<p style="margin-top: 1em">The following function tests
whether the SV is blessed into the specified class. It does
not check inheritance relationships.</p>

<p style="margin-top: 1em">int sv_isa(SV* sv, const char*
name);</p>

<p style="margin-top: 1em">The following function tests
whether the SV is a reference to a blessed object.</p>

<p style="margin-top: 1em">int sv_isobject(SV* sv);</p>

<p style="margin-top: 1em">The following function tests
whether the SV is derived from the specified class. SV can
be either a reference to a blessed object or a string
containing a class name. This is the <br>
function implementing the &quot;UNIVERSAL::isa&quot;
functionality.</p>

<p style="margin-top: 1em">bool sv_derived_from(SV* sv,
const char* name);</p>

<p style="margin-top: 1em">To check if you&rsquo;ve got an
object derived from a specific class you have to write:</p>

<p style="margin-top: 1em">if (sv_isobject(sv) &amp;&amp;
sv_derived_from(sv, class)) { ... }</p>

<p style="margin-top: 1em">Creating New Variables <br>
To create a new Perl variable with an undef value which can
be accessed from your Perl script, use the following
routines, depending on the variable type.</p>

<p style="margin-top: 1em">SV*
get_sv(&quot;package::varname&quot;, GV_ADD); <br>
AV* get_av(&quot;package::varname&quot;, GV_ADD); <br>
HV* get_hv(&quot;package::varname&quot;, GV_ADD);</p>

<p style="margin-top: 1em">Notice the use of GV_ADD as the
second parameter. The new variable can now be set, using the
routines appropriate to the data type.</p>

<p style="margin-top: 1em">There are additional macros
whose values may be bitwise OR&rsquo;ed with the
&quot;GV_ADD&quot; argument to enable certain extra
features. Those bits are:</p>

<p style="margin-top: 1em">GV_ADDMULTI <br>
Marks the variable as multiply defined, thus preventing
the:</p>

<p style="margin-top: 1em">Name &lt;varname&gt; used only
once: possible typo</p>

<p style="margin-top: 1em">warning.</p>

<p style="margin-top: 1em">GV_ADDWARN <br>
Issues the warning:</p>

<p style="margin-top: 1em">Had to create &lt;varname&gt;
unexpectedly</p>

<p style="margin-top: 1em">if the variable did not exist
before the function was called.</p>

<p style="margin-top: 1em">If you do not specify a package
name, the variable is created in the current package.</p>

<p style="margin-top: 1em">Reference Counts and Mortality
<br>
Perl uses a reference count-driven garbage collection
mechanism. SVs, AVs, or HVs (xV for short in the following)
start their life with a reference count of 1. If the
reference <br>
count of an xV ever drops to 0, then it will be destroyed
and its memory made available for reuse.</p>

<p style="margin-top: 1em">This normally doesn&rsquo;t
happen at the Perl level unless a variable is undef&rsquo;ed
or the last variable holding a reference to it is changed or
overwritten. At the internal level, <br>
however, reference counts can be manipulated with the
following macros:</p>

<p style="margin-top: 1em">int SvREFCNT(SV* sv); <br>
SV* SvREFCNT_inc(SV* sv); <br>
void SvREFCNT_dec(SV* sv);</p>

<p style="margin-top: 1em">However, there is one other
function which manipulates the reference count of its
argument. The &quot;newRV_inc&quot; function, you will
recall, creates a reference to the specified <br>
argument. As a side effect, it increments the
argument&rsquo;s reference count. If this is not what you
want, use &quot;newRV_noinc&quot; instead.</p>

<p style="margin-top: 1em">For example, imagine you want to
return a reference from an XSUB function. Inside the XSUB
routine, you create an SV which initially has a reference
count of one. Then you call <br>
&quot;newRV_inc&quot;, passing it the just-created SV. This
returns the reference as a new SV, but the reference count
of the SV you passed to &quot;newRV_inc&quot; has been
incremented to two. <br>
Now you return the reference from the XSUB routine and
forget about the SV. But Perl hasn&rsquo;t! Whenever the
returned reference is destroyed, the reference count of the
original <br>
SV is decreased to one and nothing happens. The SV will hang
around without any way to access it until Perl itself
terminates. This is a memory leak.</p>

<p style="margin-top: 1em">The correct procedure, then, is
to use &quot;newRV_noinc&quot; instead of
&quot;newRV_inc&quot;. Then, if and when the last reference
is destroyed, the reference count of the SV will go to zero
and <br>
it will be destroyed, stopping any memory leak.</p>

<p style="margin-top: 1em">There are some convenience
functions available that can help with the destruction of
xVs. These functions introduce the concept of
&quot;mortality&quot;. An xV that is mortal has had its <br>
reference count marked to be decremented, but not actually
decremented, until &quot;a short time later&quot;. Generally
the term &quot;short time later&quot; means a single Perl
statement, such as <br>
a call to an XSUB function. The actual determinant for when
mortal xVs have their reference count decremented depends on
two macros, SAVETMPS and FREETMPS. See perlcall and <br>
perlxs for more details on these macros.</p>

<p style="margin-top: 1em">&quot;Mortalization&quot; then
is at its simplest a deferred &quot;SvREFCNT_dec&quot;.
However, if you mortalize a variable twice, the reference
count will later be decremented twice.</p>

<p style="margin-top: 1em">&quot;Mortal&quot; SVs are
mainly used for SVs that are placed on perl&rsquo;s stack.
For example an SV which is created just to pass a number to
a called sub is made mortal to have it cleaned <br>
up automatically when it&rsquo;s popped off the stack.
Similarly, results returned by XSUBs (which are pushed on
the stack) are often made mortal.</p>

<p style="margin-top: 1em">To create a mortal variable, use
the functions:</p>

<p style="margin-top: 1em">SV* sv_newmortal() <br>
SV* sv_2mortal(SV*) <br>
SV* sv_mortalcopy(SV*)</p>

<p style="margin-top: 1em">The first call creates a mortal
SV (with no value), the second converts an existing SV to a
mortal SV (and thus defers a call to
&quot;SvREFCNT_dec&quot;), and the third creates a mortal
<br>
copy of an existing SV. Because &quot;sv_newmortal&quot;
gives the new SV no value, it must normally be given one via
&quot;sv_setpv&quot;, &quot;sv_setiv&quot;, etc. :</p>

<p style="margin-top: 1em">SV *tmp = sv_newmortal(); <br>
sv_setiv(tmp, an_integer);</p>

<p style="margin-top: 1em">As that is multiple C statements
it is quite common so see this idiom instead:</p>

<p style="margin-top: 1em">SV *tmp =
sv_2mortal(newSViv(an_integer));</p>

<p style="margin-top: 1em">You should be careful about
creating mortal variables. Strange things can happen if you
make the same value mortal within multiple contexts, or if
you make a variable mortal <br>
multiple times. Thinking of &quot;Mortalization&quot; as
deferred &quot;SvREFCNT_dec&quot; should help to minimize
such problems. For example if you are passing an SV which
you know has a high <br>
enough REFCNT to survive its use on the stack you need not
do any mortalization. If you are not sure then doing an
&quot;SvREFCNT_inc&quot; and &quot;sv_2mortal&quot;, or
making a &quot;sv_mortalcopy&quot; <br>
is safer.</p>

<p style="margin-top: 1em">The mortal routines are not just
for SVs; AVs and HVs can be made mortal by passing their
address (type-casted to &quot;SV*&quot;) to the
&quot;sv_2mortal&quot; or &quot;sv_mortalcopy&quot;
routines.</p>

<p style="margin-top: 1em">Stashes and Globs <br>
A stash is a hash that contains all variables that are
defined within a package. Each key of the stash is a symbol
name (shared by all the different types of objects that have
<br>
the same name), and each value in the hash table is a GV
(Glob Value). This GV in turn contains references to the
various objects of that name, including (but not limited to)
<br>
the following:</p>

<p style="margin-top: 1em">Scalar Value <br>
Array Value <br>
Hash Value <br>
I/O Handle <br>
Format <br>
Subroutine</p>

<p style="margin-top: 1em">There is a single stash called
&quot;PL_defstash&quot; that holds the items that exist in
the &quot;main&quot; package. To get at the items in other
packages, append the string &quot;::&quot; to the package
<br>
name. The items in the &quot;Foo&quot; package are in the
stash &quot;Foo::&quot; in PL_defstash. The items in the
&quot;Bar::Baz&quot; package are in the stash
&quot;Baz::&quot; in &quot;Bar::&quot;&rsquo;s stash.</p>

<p style="margin-top: 1em">To get the stash pointer for a
particular package, use the function:</p>

<p style="margin-top: 1em">HV* gv_stashpv(const char* name,
I32 flags) <br>
HV* gv_stashsv(SV*, I32 flags)</p>

<p style="margin-top: 1em">The first function takes a
literal string, the second uses the string stored in the SV.
Remember that a stash is just a hash table, so you get back
an &quot;HV*&quot;. The &quot;flags&quot; flag <br>
will create a new package if it is set to GV_ADD.</p>

<p style="margin-top: 1em">The name that
&quot;gv_stash*v&quot; wants is the name of the package
whose symbol table you want. The default package is called
&quot;main&quot;. If you have multiply nested packages, pass
their <br>
names to &quot;gv_stash*v&quot;, separated by &quot;::&quot;
as in the Perl language itself.</p>

<p style="margin-top: 1em">Alternately, if you have an SV
that is a blessed reference, you can find out the stash
pointer by using:</p>

<p style="margin-top: 1em">HV* SvSTASH(SvRV(SV*));</p>

<p style="margin-top: 1em">then use the following to get
the package name itself:</p>

<p style="margin-top: 1em">char* HvNAME(HV* stash);</p>

<p style="margin-top: 1em">If you need to bless or re-bless
an object you can use the following function:</p>

<p style="margin-top: 1em">SV* sv_bless(SV*, HV* stash)</p>

<p style="margin-top: 1em">where the first argument, an
&quot;SV*&quot;, must be a reference, and the second
argument is a stash. The returned &quot;SV*&quot; can now be
used in the same way as any other SV.</p>

<p style="margin-top: 1em">For more information on
references and blessings, consult perlref.</p>

<p style="margin-top: 1em">Double-Typed SVs <br>
Scalar variables normally contain only one type of value, an
integer, double, pointer, or reference. Perl will
automatically convert the actual scalar data from the stored
type <br>
into the requested type.</p>

<p style="margin-top: 1em">Some scalar variables contain
more than one type of scalar data. For example, the variable
$! contains either the numeric value of &quot;errno&quot; or
its string equivalent from either <br>
&quot;strerror&quot; or &quot;sys_errlist[]&quot;.</p>

<p style="margin-top: 1em">To force multiple data values
into an SV, you must do two things: use the
&quot;sv_set*v&quot; routines to add the additional scalar
type, then set a flag so that Perl will believe it <br>
contains more than one type of data. The four macros to set
the flags are:</p>

<p style="margin-top: 1em">SvIOK_on <br>
SvNOK_on <br>
SvPOK_on <br>
SvROK_on</p>

<p style="margin-top: 1em">The particular macro you must
use depends on which &quot;sv_set*v&quot; routine you called
first. This is because every &quot;sv_set*v&quot; routine
turns on only the bit for the particular type of <br>
data being set, and turns off all the rest.</p>

<p style="margin-top: 1em">For example, to create a new
Perl variable called &quot;dberror&quot; that contains both
the numeric and descriptive string error values, you could
use the following code:</p>

<p style="margin-top: 1em">extern int dberror; <br>
extern char *dberror_list;</p>

<p style="margin-top: 1em">SV* sv =
get_sv(&quot;dberror&quot;, GV_ADD); <br>
sv_setiv(sv, (IV) dberror); <br>
sv_setpv(sv, dberror_list[dberror]); <br>
SvIOK_on(sv);</p>

<p style="margin-top: 1em">If the order of
&quot;sv_setiv&quot; and &quot;sv_setpv&quot; had been
reversed, then the macro &quot;SvPOK_on&quot; would need to
be called instead of &quot;SvIOK_on&quot;.</p>

<p style="margin-top: 1em">Magic Variables <br>
[This section still under construction. Ignore everything
here. Post no bills. Everything not permitted is
forbidden.]</p>

<p style="margin-top: 1em">Any SV may be magical, that is,
it has special features that a normal SV does not have.
These features are stored in the SV structure in a linked
list of &quot;struct magic&quot;&rsquo;s, <br>
typedef&rsquo;ed to &quot;MAGIC&quot;.</p>

<p style="margin-top: 1em">struct magic { <br>
MAGIC* mg_moremagic; <br>
MGVTBL* mg_virtual; <br>
U16 mg_private; <br>
char mg_type; <br>
U8 mg_flags; <br>
I32 mg_len; <br>
SV* mg_obj; <br>
char* mg_ptr; <br>
};</p>

<p style="margin-top: 1em">Note this is current as of
patchlevel 0, and could change at any time.</p>

<p style="margin-top: 1em">Assigning Magic <br>
Perl adds magic to an SV using the sv_magic function:</p>

<p style="margin-top: 1em">void sv_magic(SV* sv, SV* obj,
int how, const char* name, I32 namlen);</p>

<p style="margin-top: 1em">The &quot;sv&quot; argument is a
pointer to the SV that is to acquire a new magical
feature.</p>

<p style="margin-top: 1em">If &quot;sv&quot; is not already
magical, Perl uses the &quot;SvUPGRADE&quot; macro to
convert &quot;sv&quot; to type &quot;SVt_PVMG&quot;. Perl
then continues by adding new magic to the beginning of the
linked list of <br>
magical features. Any prior entry of the same type of magic
is deleted. Note that this can be overridden, and multiple
instances of the same type of magic can be associated <br>
with an SV.</p>

<p style="margin-top: 1em">The &quot;name&quot; and
&quot;namlen&quot; arguments are used to associate a string
with the magic, typically the name of a variable.
&quot;namlen&quot; is stored in the &quot;mg_len&quot; field
and if &quot;name&quot; is non- <br>
null then either a &quot;savepvn&quot; copy of
&quot;name&quot; or &quot;name&quot; itself is stored in the
&quot;mg_ptr&quot; field, depending on whether
&quot;namlen&quot; is greater than zero or equal to zero
respectively. <br>
As a special case, if &quot;(name &amp;&amp; namlen ==
HEf_SVKEY)&quot; then &quot;name&quot; is assumed to contain
an &quot;SV*&quot; and is stored as-is with its REFCNT
incremented.</p>

<p style="margin-top: 1em">The sv_magic function uses
&quot;how&quot; to determine which, if any, predefined
&quot;Magic Virtual Table&quot; should be assigned to the
&quot;mg_virtual&quot; field. See the &quot;Magic Virtual
Tables&quot; <br>
section below. The &quot;how&quot; argument is also stored
in the &quot;mg_type&quot; field. The value of
&quot;how&quot; should be chosen from the set of macros
&quot;PERL_MAGIC_foo&quot; found in perl.h. Note that <br>
before these macros were added, Perl internals used to
directly use character literals, so you may occasionally
come across old code or documentation referring to
&rsquo;U&rsquo; magic <br>
rather than &quot;PERL_MAGIC_uvar&quot; for example.</p>

<p style="margin-top: 1em">The &quot;obj&quot; argument is
stored in the &quot;mg_obj&quot; field of the
&quot;MAGIC&quot; structure. If it is not the same as the
&quot;sv&quot; argument, the reference count of the
&quot;obj&quot; object is incremented. <br>
If it is the same, or if the &quot;how&quot; argument is
&quot;PERL_MAGIC_arylen&quot;, or if it is a NULL pointer,
then &quot;obj&quot; is merely stored, without the reference
count being incremented.</p>

<p style="margin-top: 1em">See also &quot;sv_magicext&quot;
in perlapi for a more flexible way to add magic to an
SV.</p>

<p style="margin-top: 1em">There is also a function to add
magic to an &quot;HV&quot;:</p>

<p style="margin-top: 1em">void hv_magic(HV *hv, GV *gv,
int how);</p>

<p style="margin-top: 1em">This simply calls
&quot;sv_magic&quot; and coerces the &quot;gv&quot; argument
into an &quot;SV&quot;.</p>

<p style="margin-top: 1em">To remove the magic from an SV,
call the function sv_unmagic:</p>

<p style="margin-top: 1em">int sv_unmagic(SV *sv, int
type);</p>

<p style="margin-top: 1em">The &quot;type&quot; argument
should be equal to the &quot;how&quot; value when the
&quot;SV&quot; was initially made magical.</p>

<p style="margin-top: 1em">However, note that
&quot;sv_unmagic&quot; removes all magic of a certain
&quot;type&quot; from the &quot;SV&quot;. If you want to
remove only certain magic of a &quot;type&quot; based on the
magic virtual table, use <br>
&quot;sv_unmagicext&quot; instead:</p>

<p style="margin-top: 1em">int sv_unmagicext(SV *sv, int
type, MGVTBL *vtbl);</p>

<p style="margin-top: 1em">Magic Virtual Tables <br>
The &quot;mg_virtual&quot; field in the &quot;MAGIC&quot;
structure is a pointer to an &quot;MGVTBL&quot;, which is a
structure of function pointers and stands for &quot;Magic
Virtual Table&quot; to handle the various <br>
operations that might be applied to that variable.</p>

<p style="margin-top: 1em">The &quot;MGVTBL&quot; has five
(or sometimes eight) pointers to the following routine
types:</p>

<p style="margin-top: 1em">int (*svt_get)(SV* sv, MAGIC*
mg); <br>
int (*svt_set)(SV* sv, MAGIC* mg); <br>
U32 (*svt_len)(SV* sv, MAGIC* mg); <br>
int (*svt_clear)(SV* sv, MAGIC* mg); <br>
int (*svt_free)(SV* sv, MAGIC* mg);</p>

<p style="margin-top: 1em">int (*svt_copy)(SV *sv, MAGIC*
mg, SV *nsv, <br>
const char *name, I32 namlen); <br>
int (*svt_dup)(MAGIC *mg, CLONE_PARAMS *param); <br>
int (*svt_local)(SV *nsv, MAGIC *mg);</p>

<p style="margin-top: 1em">This MGVTBL structure is set at
compile-time in perl.h and there are currently 32 types.
These different structures contain pointers to various
routines that perform additional <br>
actions depending on which function is being called.</p>

<p style="margin-top: 1em">Function pointer Action taken
<br>
---------------- ------------ <br>
svt_get Do something before the value of the SV is <br>
retrieved. <br>
svt_set Do something after the SV is assigned a value. <br>
svt_len Report on the SV&rsquo;s length. <br>
svt_clear Clear something the SV represents. <br>
svt_free Free any extra storage associated with the SV.</p>

<p style="margin-top: 1em">svt_copy copy tied variable
magic to a tied element <br>
svt_dup duplicate a magic structure during thread cloning
<br>
svt_local copy magic to local value during
&rsquo;local&rsquo;</p>

<p style="margin-top: 1em">For instance, the MGVTBL
structure called &quot;vtbl_sv&quot; (which corresponds to
an &quot;mg_type&quot; of &quot;PERL_MAGIC_sv&quot;)
contains:</p>

<p style="margin-top: 1em">{ magic_get, magic_set,
magic_len, 0, 0 }</p>

<p style="margin-top: 1em">Thus, when an SV is determined
to be magical and of type &quot;PERL_MAGIC_sv&quot;, if a
get operation is being performed, the routine
&quot;magic_get&quot; is called. All the various routines
for <br>
the various magical types begin with &quot;magic_&quot;.
NOTE: the magic routines are not considered part of the Perl
API, and may not be exported by the Perl library.</p>

<p style="margin-top: 1em">The last three slots are a
recent addition, and for source code compatibility they are
only checked for if one of the three flags MGf_COPY, MGf_DUP
or MGf_LOCAL is set in <br>
mg_flags. This means that most code can continue declaring a
vtable as a 5-element value. These three are currently used
exclusively by the threading code, and are highly subject
<br>
to change.</p>

<p style="margin-top: 1em">The current kinds of Magic
Virtual Tables are:</p>

<p style="margin-top: 1em">mg_type <br>
(old-style char and macro) MGVTBL Type of magic <br>
-------------------------- ------ ------------- <br>
PERL_MAGIC_sv vtbl_sv Special scalar variable <br>
# PERL_MAGIC_arylen vtbl_arylen Array length ($#ary) <br>
% PERL_MAGIC_rhash (none) extra data for restricted <br>
hashes <br>
. PERL_MAGIC_pos vtbl_pos pos() lvalue <br>
: PERL_MAGIC_symtab (none) extra data for symbol <br>
tables <br>
&lt; PERL_MAGIC_backref vtbl_backref for weak ref data <br>
@ PERL_MAGIC_arylen_p (none) to move arylen out of <br>
XPVAV <br>
A PERL_MAGIC_overload vtbl_amagic %OVERLOAD hash <br>
a PERL_MAGIC_overload_elem vtbl_amagicelem %OVERLOAD hash
element <br>
B PERL_MAGIC_bm vtbl_regexp Boyer-Moore <br>
(fast string search) <br>
c PERL_MAGIC_overload_table vtbl_ovrld Holds overload table
<br>
(AMT) on stash <br>
D PERL_MAGIC_regdata vtbl_regdata Regex match position data
<br>
(@+ and @- vars) <br>
d PERL_MAGIC_regdatum vtbl_regdatum Regex match position
data <br>
element <br>
E PERL_MAGIC_env vtbl_env %ENV hash <br>
e PERL_MAGIC_envelem vtbl_envelem %ENV hash element <br>
f PERL_MAGIC_fm vtbl_regdata Formline <br>
(&rsquo;compiled&rsquo; format) <br>
G PERL_MAGIC_study vtbl_regexp study()ed string <br>
g PERL_MAGIC_regex_global vtbl_mglob m//g target <br>
H PERL_MAGIC_hints vtbl_hints %^H hash <br>
h PERL_MAGIC_hintselem vtbl_hintselem %^H hash element <br>
I PERL_MAGIC_isa vtbl_isa @ISA array <br>
i PERL_MAGIC_isaelem vtbl_isaelem @ISA array element <br>
k PERL_MAGIC_nkeys vtbl_nkeys scalar(keys()) lvalue <br>
L PERL_MAGIC_dbfile (none) Debugger %_&lt;filename <br>
l PERL_MAGIC_dbline vtbl_dbline Debugger %_&lt;filename <br>
element <br>
N PERL_MAGIC_shared (none) Shared between threads <br>
n PERL_MAGIC_shared_scalar (none) Shared between threads
<br>
o PERL_MAGIC_collxfrm vtbl_collxfrm Locale transformation
<br>
P PERL_MAGIC_tied vtbl_pack Tied array or hash <br>
p PERL_MAGIC_tiedelem vtbl_packelem Tied array or hash
element <br>
q PERL_MAGIC_tiedscalar vtbl_packelem Tied scalar or handle
<br>
r PERL_MAGIC_qr vtbl_regexp precompiled qr// regex <br>
S PERL_MAGIC_sig (none) %SIG hash <br>
s PERL_MAGIC_sigelem vtbl_sigelem %SIG hash element <br>
t PERL_MAGIC_taint vtbl_taint Taintedness <br>
U PERL_MAGIC_uvar vtbl_uvar Available for use by <br>
extensions <br>
u PERL_MAGIC_uvar_elem (none) Reserved for use by <br>
extensions <br>
V PERL_MAGIC_vstring vtbl_vstring SV was vstring literal
<br>
v PERL_MAGIC_vec vtbl_vec vec() lvalue <br>
w PERL_MAGIC_utf8 vtbl_utf8 Cached UTF-8 information <br>
x PERL_MAGIC_substr vtbl_substr substr() lvalue <br>
y PERL_MAGIC_defelem vtbl_defelem Shadow &quot;foreach&quot;
iterator <br>
variable / smart parameter <br>
vivification <br>
] PERL_MAGIC_checkcall (none) inlining/mutation of call <br>
to this CV <br>
~ PERL_MAGIC_ext (none) Available for use by <br>
extensions</p>

<p style="margin-top: 1em">When an uppercase and lowercase
letter both exist in the table, then the uppercase letter is
typically used to represent some kind of composite type (a
list or a hash), and the <br>
lowercase letter is used to represent an element of that
composite type. Some internals code makes use of this case
relationship. However, &rsquo;v&rsquo; and &rsquo;V&rsquo;
(vec and v-string) are in <br>
no way related.</p>

<p style="margin-top: 1em">The &quot;PERL_MAGIC_ext&quot;
and &quot;PERL_MAGIC_uvar&quot; magic types are defined
specifically for use by extensions and will not be used by
perl itself. Extensions can use &quot;PERL_MAGIC_ext&quot;
<br>
magic to &rsquo;attach&rsquo; private information to
variables (typically objects). This is especially useful
because there is no way for normal perl code to corrupt this
private <br>
information (unlike using extra elements of a hash
object).</p>

<p style="margin-top: 1em">Similarly,
&quot;PERL_MAGIC_uvar&quot; magic can be used much like
tie() to call a C function any time a scalar&rsquo;s value
is used or changed. The &quot;MAGIC&quot;&rsquo;s
&quot;mg_ptr&quot; field points to a <br>
&quot;ufuncs&quot; structure:</p>

<p style="margin-top: 1em">struct ufuncs { <br>
I32 (*uf_val)(pTHX_ IV, SV*); <br>
I32 (*uf_set)(pTHX_ IV, SV*); <br>
IV uf_index; <br>
};</p>

<p style="margin-top: 1em">When the SV is read from or
written to, the &quot;uf_val&quot; or &quot;uf_set&quot;
function will be called with &quot;uf_index&quot; as the
first arg and a pointer to the SV as the second. A simple
example <br>
of how to add &quot;PERL_MAGIC_uvar&quot; magic is shown
below. Note that the ufuncs structure is copied by sv_magic,
so you can safely allocate it on the stack.</p>

<p style="margin-top: 1em">void <br>
Umagic(sv) <br>
SV *sv; <br>
PREINIT: <br>
struct ufuncs uf; <br>
CODE: <br>
uf.uf_val = &amp;my_get_fn; <br>
uf.uf_set = &amp;my_set_fn; <br>
uf.uf_index = 0; <br>
sv_magic(sv, 0, PERL_MAGIC_uvar, (char*)&amp;uf,
sizeof(uf));</p>

<p style="margin-top: 1em">Attaching
&quot;PERL_MAGIC_uvar&quot; to arrays is permissible but has
no effect.</p>

<p style="margin-top: 1em">For hashes there is a
specialized hook that gives control over hash keys (but not
values). This hook calls &quot;PERL_MAGIC_uvar&quot;
&rsquo;get&rsquo; magic if the &quot;set&quot; function in
the &quot;ufuncs&quot; <br>
structure is NULL. The hook is activated whenever the hash
is accessed with a key specified as an &quot;SV&quot;
through the functions &quot;hv_store_ent&quot;,
&quot;hv_fetch_ent&quot;, &quot;hv_delete_ent&quot;, and
<br>
&quot;hv_exists_ent&quot;. Accessing the key as a string
through the functions without the &quot;..._ent&quot; suffix
circumvents the hook. See &quot;GUTS&quot; in
Hash::Util::FieldHash for a detailed <br>
description.</p>

<p style="margin-top: 1em">Note that because multiple
extensions may be using &quot;PERL_MAGIC_ext&quot; or
&quot;PERL_MAGIC_uvar&quot; magic, it is important for
extensions to take extra care to avoid conflict. Typically
<br>
only using the magic on objects blessed into the same class
as the extension is sufficient. For
&quot;PERL_MAGIC_ext&quot; magic, it is usually a good idea
to define an &quot;MGVTBL&quot;, even if <br>
all its fields will be 0, so that individual
&quot;MAGIC&quot; pointers can be identified as a particular
kind of magic using their magic virtual table.
&quot;mg_findext&quot; provides an easy way <br>
to do that:</p>

<p style="margin-top: 1em">STATIC MGVTBL my_vtbl = { 0, 0,
0, 0, 0, 0, 0, 0 };</p>

<p style="margin-top: 1em">MAGIC *mg; <br>
if ((mg = mg_findext(sv, PERL_MAGIC_ext, &amp;my_vtbl))) {
<br>
/* this is really ours, not another module&rsquo;s
PERL_MAGIC_ext */ <br>
my_priv_data_t *priv = (my_priv_data_t *)mg-&gt;mg_ptr; <br>
... <br>
}</p>

<p style="margin-top: 1em">Also note that the
&quot;sv_set*()&quot; and &quot;sv_cat*()&quot; functions
described earlier do not invoke &rsquo;set&rsquo; magic on
their targets. This must be done by the user either by
calling the <br>
&quot;SvSETMAGIC()&quot; macro after calling these
functions, or by using one of the &quot;sv_set*_mg()&quot;
or &quot;sv_cat*_mg()&quot; functions. Similarly, generic C
code must call the &quot;SvGETMAGIC()&quot; <br>
macro to invoke any &rsquo;get&rsquo; magic if they use an
SV obtained from external sources in functions that
don&rsquo;t handle magic. See perlapi for a description of
these functions. For <br>
example, calls to the &quot;sv_cat*()&quot; functions
typically need to be followed by &quot;SvSETMAGIC()&quot;,
but they don&rsquo;t need a prior &quot;SvGETMAGIC()&quot;
since their implementation handles &rsquo;get&rsquo; <br>
magic.</p>

<p style="margin-top: 1em">Finding Magic <br>
MAGIC *mg_find(SV *sv, int type); /* Finds the magic pointer
of that <br>
* type */</p>

<p style="margin-top: 1em">This routine returns a pointer
to a &quot;MAGIC&quot; structure stored in the SV. If the SV
does not have that magical feature, &quot;NULL&quot; is
returned. If the SV has multiple instances of <br>
that magical feature, the first one will be returned.
&quot;mg_findext&quot; can be used to find a
&quot;MAGIC&quot; structure of an SV based on both its magic
type and its magic virtual table:</p>

<p style="margin-top: 1em">MAGIC *mg_findext(SV *sv, int
type, MGVTBL *vtbl);</p>

<p style="margin-top: 1em">Also, if the SV passed to
&quot;mg_find&quot; or &quot;mg_findext&quot; is not of type
SVt_PVMG, Perl may core dump.</p>

<p style="margin-top: 1em">int mg_copy(SV* sv, SV* nsv,
const char* key, STRLEN klen);</p>

<p style="margin-top: 1em">This routine checks to see what
types of magic &quot;sv&quot; has. If the mg_type field is
an uppercase letter, then the mg_obj is copied to
&quot;nsv&quot;, but the mg_type field is changed to be <br>
the lowercase letter.</p>

<p style="margin-top: 1em">Understanding the Magic of Tied
Hashes and Arrays <br>
Tied hashes and arrays are magical beasts of the
&quot;PERL_MAGIC_tied&quot; magic type.</p>

<p style="margin-top: 1em">WARNING: As of the 5.004
release, proper usage of the array and hash access functions
requires understanding a few caveats. Some of these caveats
are actually considered bugs in <br>
the API, to be fixed in later releases, and are bracketed
with [MAYCHANGE] below. If you find yourself actually
applying such information in this section, be aware that the
<br>
behavior may change in the future, umm, without warning.</p>

<p style="margin-top: 1em">The perl tie function associates
a variable with an object that implements the various GET,
SET, etc methods. To perform the equivalent of the perl tie
function from an XSUB, <br>
you must mimic this behaviour. The code below carries out
the necessary steps - firstly it creates a new hash, and
then creates a second hash which it blesses into the class
<br>
which will implement the tie methods. Lastly it ties the two
hashes together, and returns a reference to the new tied
hash. Note that the code below does NOT call the TIEHASH
<br>
method in the MyTie class - see &quot;Calling Perl Routines
from within C Programs&quot; for details on how to do
this.</p>

<p style="margin-top: 1em">SV* <br>
mytie() <br>
PREINIT: <br>
HV *hash; <br>
HV *stash; <br>
SV *tie; <br>
CODE: <br>
hash = newHV(); <br>
tie = newRV_noinc((SV*)newHV()); <br>
stash = gv_stashpv(&quot;MyTie&quot;, GV_ADD); <br>
sv_bless(tie, stash); <br>
hv_magic(hash, (GV*)tie, PERL_MAGIC_tied); <br>
RETVAL = newRV_noinc(hash); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">The &quot;av_store&quot;
function, when given a tied array argument, merely copies
the magic of the array onto the value to be
&quot;stored&quot;, using &quot;mg_copy&quot;. It may also
return NULL, <br>
indicating that the value did not actually need to be stored
in the array. [MAYCHANGE] After a call to
&quot;av_store&quot; on a tied array, the caller will
usually need to call <br>
&quot;mg_set(val)&quot; to actually invoke the perl level
&quot;STORE&quot; method on the TIEARRAY object. If
&quot;av_store&quot; did return NULL, a call to
&quot;SvREFCNT_dec(val)&quot; will also be usually <br>
necessary to avoid a memory leak. [/MAYCHANGE]</p>

<p style="margin-top: 1em">The previous paragraph is
applicable verbatim to tied hash access using the
&quot;hv_store&quot; and &quot;hv_store_ent&quot; functions
as well.</p>

<p style="margin-top: 1em">&quot;av_fetch&quot; and the
corresponding hash functions &quot;hv_fetch&quot; and
&quot;hv_fetch_ent&quot; actually return an undefined mortal
value whose magic has been initialized using
&quot;mg_copy&quot;. Note <br>
the value so returned does not need to be deallocated, as it
is already mortal. [MAYCHANGE] But you will need to call
&quot;mg_get()&quot; on the returned value in order to
actually <br>
invoke the perl level &quot;FETCH&quot; method on the
underlying TIE object. Similarly, you may also call
&quot;mg_set()&quot; on the return value after possibly
assigning a suitable value to it <br>
using &quot;sv_setsv&quot;, which will invoke the
&quot;STORE&quot; method on the TIE object. [/MAYCHANGE]</p>

<p style="margin-top: 1em">[MAYCHANGE] In other words, the
array or hash fetch/store functions don&rsquo;t really fetch
and store actual values in the case of tied arrays and
hashes. They merely call &quot;mg_copy&quot; <br>
to attach magic to the values that were meant to be
&quot;stored&quot; or &quot;fetched&quot;. Later calls to
&quot;mg_get&quot; and &quot;mg_set&quot; actually do the
job of invoking the TIE methods on the underlying <br>
objects. Thus the magic mechanism currently implements a
kind of lazy access to arrays and hashes.</p>

<p style="margin-top: 1em">Currently (as of perl version
5.004), use of the hash and array access functions requires
the user to be aware of whether they are operating on
&quot;normal&quot; hashes and arrays, or on <br>
their tied variants. The API may be changed to provide more
transparent access to both tied and normal data types in
future versions. [/MAYCHANGE]</p>

<p style="margin-top: 1em">You would do well to understand
that the TIEARRAY and TIEHASH interfaces are mere sugar to
invoke some perl method calls while using the uniform hash
and array syntax. The use <br>
of this sugar imposes some overhead (typically about two to
four extra opcodes per FETCH/STORE operation, in addition to
the creation of all the mortal variables required to <br>
invoke the methods). This overhead will be comparatively
small if the TIE methods are themselves substantial, but if
they are only a few statements long, the overhead will not
<br>
be insignificant.</p>

<p style="margin-top: 1em">Localizing changes <br>
Perl has a very handy construction</p>

<p style="margin-top: 1em">{ <br>
local $var = 2; <br>
... <br>
}</p>

<p style="margin-top: 1em">This construction is
approximately equivalent to</p>

<p style="margin-top: 1em">{ <br>
my $oldvar = $var; <br>
$var = 2; <br>
... <br>
$var = $oldvar; <br>
}</p>

<p style="margin-top: 1em">The biggest difference is that
the first construction would reinstate the initial value of
$var, irrespective of how control exits the block:
&quot;goto&quot;, &quot;return&quot;,
&quot;die&quot;/&quot;eval&quot;, etc. <br>
It is a little bit more efficient as well.</p>

<p style="margin-top: 1em">There is a way to achieve a
similar task from C via Perl API: create a pseudo-block, and
arrange for some changes to be automatically undone at the
end of it, either explicit, or <br>
via a non-local exit (via die()). A block-like construct is
created by a pair of &quot;ENTER&quot;/&quot;LEAVE&quot;
macros (see &quot;Returning a Scalar&quot; in perlcall).
Such a construct may be created <br>
specially for some important localized task, or an existing
one (like boundaries of enclosing Perl subroutine/block, or
an existing pair for freeing TMPs) may be used. (In the <br>
second case the overhead of additional localization must be
almost negligible.) Note that any XSUB is automatically
enclosed in an &quot;ENTER&quot;/&quot;LEAVE&quot; pair.</p>

<p style="margin-top: 1em">Inside such a pseudo-block the
following service is available:</p>

<p style="margin-top: 1em">&quot;SAVEINT(int i)&quot; <br>
&quot;SAVEIV(IV i)&quot; <br>
&quot;SAVEI32(I32 i)&quot; <br>
&quot;SAVELONG(long i)&quot; <br>
These macros arrange things to restore the value of integer
variable &quot;i&quot; at the end of enclosing
pseudo-block.</p>

<p style="margin-top: 1em">SAVESPTR(s) <br>
SAVEPPTR(p) <br>
These macros arrange things to restore the value of pointers
&quot;s&quot; and &quot;p&quot;. &quot;s&quot; must be a
pointer of a type which survives conversion to
&quot;SV*&quot; and back, &quot;p&quot; should be able to
<br>
survive conversion to &quot;char*&quot; and back.</p>

<p style="margin-top: 1em">&quot;SAVEFREESV(SV *sv)&quot;
<br>
The refcount of &quot;sv&quot; would be decremented at the
end of pseudo-block. This is similar to
&quot;sv_2mortal&quot; in that it is also a mechanism for
doing a delayed &quot;SvREFCNT_dec&quot;. <br>
However, while &quot;sv_2mortal&quot; extends the lifetime
of &quot;sv&quot; until the beginning of the next statement,
&quot;SAVEFREESV&quot; extends it until the end of the
enclosing scope. These <br>
lifetimes can be wildly different.</p>

<p style="margin-top: 1em">Also compare
&quot;SAVEMORTALIZESV&quot;.</p>

<p style="margin-top: 1em">&quot;SAVEMORTALIZESV(SV
*sv)&quot; <br>
Just like &quot;SAVEFREESV&quot;, but mortalizes
&quot;sv&quot; at the end of the current scope instead of
decrementing its reference count. This usually has the
effect of keeping &quot;sv&quot; alive <br>
until the statement that called the currently live scope has
finished executing.</p>

<p style="margin-top: 1em">&quot;SAVEFREEOP(OP *op)&quot;
<br>
The &quot;OP *&quot; is op_free()ed at the end of
pseudo-block.</p>

<p style="margin-top: 1em">SAVEFREEPV(p) <br>
The chunk of memory which is pointed to by &quot;p&quot; is
Safefree()ed at the end of pseudo-block.</p>

<p style="margin-top: 1em">&quot;SAVECLEARSV(SV *sv)&quot;
<br>
Clears a slot in the current scratchpad which corresponds to
&quot;sv&quot; at the end of pseudo-block.</p>

<p style="margin-top: 1em">&quot;SAVEDELETE(HV *hv, char
*key, I32 length)&quot; <br>
The key &quot;key&quot; of &quot;hv&quot; is deleted at the
end of pseudo-block. The string pointed to by
&quot;key&quot; is Safefree()ed. If one has a key in
short-lived storage, the corresponding <br>
string may be reallocated like this:</p>

<p style="margin-top: 1em">SAVEDELETE(PL_defstash,
savepv(tmpbuf), strlen(tmpbuf));</p>


<p style="margin-top: 1em">&quot;SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t
f, void *p)&quot; <br>
At the end of pseudo-block the function &quot;f&quot; is
called with the only argument &quot;p&quot;.</p>


<p style="margin-top: 1em">&quot;SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t
f, void *p)&quot; <br>
At the end of pseudo-block the function &quot;f&quot; is
called with the implicit context argument (if any), and
&quot;p&quot;.</p>

<p style="margin-top: 1em">&quot;SAVESTACK_POS()&quot; <br>
The current offset on the Perl internal stack (cf.
&quot;SP&quot;) is restored at the end of pseudo-block.</p>

<p style="margin-top: 1em">The following API list contains
functions, thus one needs to provide pointers to the
modifiable data explicitly (either C pointers, or Perlish
&quot;GV *&quot;s). Where the above macros <br>
take &quot;int&quot;, a similar function takes &quot;int
*&quot;.</p>

<p style="margin-top: 1em">&quot;SV* save_scalar(GV
*gv)&quot; <br>
Equivalent to Perl code &quot;local $gv&quot;.</p>

<p style="margin-top: 1em">&quot;AV* save_ary(GV *gv)&quot;
<br>
&quot;HV* save_hash(GV *gv)&quot; <br>
Similar to &quot;save_scalar&quot;, but localize @gv and
%gv.</p>

<p style="margin-top: 1em">&quot;void save_item(SV
*item)&quot; <br>
Duplicates the current value of &quot;SV&quot;, on the exit
from the current &quot;ENTER&quot;/&quot;LEAVE&quot;
pseudo-block will restore the value of &quot;SV&quot; using
the stored value. It doesn&rsquo;t handle <br>
magic. Use &quot;save_scalar&quot; if magic is affected.</p>

<p style="margin-top: 1em">&quot;void save_list(SV **sarg,
I32 maxsarg)&quot; <br>
A variant of &quot;save_item&quot; which takes multiple
arguments via an array &quot;sarg&quot; of &quot;SV*&quot;
of length &quot;maxsarg&quot;.</p>

<p style="margin-top: 1em">&quot;SV* save_svref(SV
**sptr)&quot; <br>
Similar to &quot;save_scalar&quot;, but will reinstate an
&quot;SV *&quot;.</p>

<p style="margin-top: 1em">&quot;void save_aptr(AV
**aptr)&quot; <br>
&quot;void save_hptr(HV **hptr)&quot; <br>
Similar to &quot;save_svref&quot;, but localize &quot;AV
*&quot; and &quot;HV *&quot;.</p>

<p style="margin-top: 1em">The &quot;Alias&quot; module
implements localization of the basic types within the
caller&rsquo;s scope. People who are interested in how to
localize things in the containing scope should take <br>
a look there too.</p>

<p style="margin-top: 1em">Subroutines <br>
XSUBs and the Argument Stack <br>
The XSUB mechanism is a simple way for Perl programs to
access C subroutines. An XSUB routine will have a stack that
contains the arguments from the Perl program, and a way to
<br>
map from the Perl data structures to a C equivalent.</p>

<p style="margin-top: 1em">The stack arguments are
accessible through the ST(n) macro, which returns the
&quot;n&quot;&rsquo;th stack argument. Argument 0 is the
first argument passed in the Perl subroutine call. These
<br>
arguments are &quot;SV*&quot;, and can be used anywhere an
&quot;SV*&quot; is used.</p>

<p style="margin-top: 1em">Most of the time, output from
the C routine can be handled through use of the RETVAL and
OUTPUT directives. However, there are some cases where the
argument stack is not already <br>
long enough to handle all the return values. An example is
the POSIX tzname() call, which takes no arguments, but
returns two, the local time zone&rsquo;s standard and summer
time <br>
abbreviations.</p>

<p style="margin-top: 1em">To handle this situation, the
PPCODE directive is used and the stack is extended using the
macro:</p>

<p style="margin-top: 1em">EXTEND(SP, num);</p>

<p style="margin-top: 1em">where &quot;SP&quot; is the
macro that represents the local copy of the stack pointer,
and &quot;num&quot; is the number of elements the stack
should be extended by.</p>

<p style="margin-top: 1em">Now that there is room on the
stack, values can be pushed on it using &quot;PUSHs&quot;
macro. The pushed values will often need to be
&quot;mortal&quot; (See &quot;Reference Counts and
Mortality&quot;):</p>


<p style="margin-top: 1em">PUSHs(sv_2mortal(newSViv(an_integer)))
<br>
PUSHs(sv_2mortal(newSVuv(an_unsigned_integer))) <br>
PUSHs(sv_2mortal(newSVnv(a_double))) <br>
PUSHs(sv_2mortal(newSVpv(&quot;Some String&quot;,0))) <br>
/* Although the last example is better written as the more
<br>
* efficient: */ <br>
PUSHs(newSVpvs_flags(&quot;Some String&quot;, SVs_TEMP))</p>

<p style="margin-top: 1em">And now the Perl program calling
&quot;tzname&quot;, the two values will be assigned as
in:</p>

<p style="margin-top: 1em">($standard_abbrev,
$summer_abbrev) = POSIX::tzname;</p>

<p style="margin-top: 1em">An alternate (and possibly
simpler) method to pushing values on the stack is to use the
macro:</p>

<p style="margin-top: 1em">XPUSHs(SV*)</p>

<p style="margin-top: 1em">This macro automatically adjusts
the stack for you, if needed. Thus, you do not need to call
&quot;EXTEND&quot; to extend the stack.</p>

<p style="margin-top: 1em">Despite their suggestions in
earlier versions of this document the macros
&quot;(X)PUSH[iunp]&quot; are not suited to XSUBs which
return multiple results. For that, either stick to the <br>
&quot;(X)PUSHs&quot; macros shown above, or use the new
&quot;m(X)PUSH[iunp]&quot; macros instead; see &quot;Putting
a C value on Perl stack&quot;.</p>

<p style="margin-top: 1em">For more information, consult
perlxs and perlxstut.</p>

<p style="margin-top: 1em">Autoloading with XSUBs <br>
If an AUTOLOAD routine is an XSUB, as with Perl subroutines,
Perl puts the fully-qualified name of the autoloaded
subroutine in the $AUTOLOAD variable of the XSUB&rsquo;s
package.</p>

<p style="margin-top: 1em">But it also puts the same
information in certain fields of the XSUB itself:</p>

<p style="margin-top: 1em">HV *stash = CvSTASH(cv); <br>
const char *subname = SvPVX(cv); <br>
STRLEN name_length = SvCUR(cv); /* in bytes */ <br>
U32 is_utf8 = SvUTF8(cv);</p>

<p style="margin-top: 1em">&quot;SvPVX(cv)&quot; contains
just the sub name itself, not including the package. For an
AUTOLOAD routine in UNIVERSAL or one of its superclasses,
&quot;CvSTASH(cv)&quot; returns NULL during a <br>
method call on a nonexistent package.</p>

<p style="margin-top: 1em">Note: Setting $AUTOLOAD stopped
working in 5.6.1, which did not support XS AUTOLOAD subs at
all. Perl 5.8.0 introduced the use of fields in the XSUB
itself. Perl 5.16.0 <br>
restored the setting of $AUTOLOAD. If you need to support
5.8-5.14, use the XSUB&rsquo;s fields.</p>

<p style="margin-top: 1em">Calling Perl Routines from
within C Programs <br>
There are four routines that can be used to call a Perl
subroutine from within a C program. These four are:</p>

<p style="margin-top: 1em">I32 call_sv(SV*, I32); <br>
I32 call_pv(const char*, I32); <br>
I32 call_method(const char*, I32); <br>
I32 call_argv(const char*, I32, register char**);</p>

<p style="margin-top: 1em">The routine most often used is
&quot;call_sv&quot;. The &quot;SV*&quot; argument contains
either the name of the Perl subroutine to be called, or a
reference to the subroutine. The second argument <br>
consists of flags that control the context in which the
subroutine is called, whether or not the subroutine is being
passed arguments, how errors should be trapped, and how to
<br>
treat return values.</p>

<p style="margin-top: 1em">All four routines return the
number of arguments that the subroutine returned on the Perl
stack.</p>

<p style="margin-top: 1em">These routines used to be called
&quot;perl_call_sv&quot;, etc., before Perl v5.6.0, but
those names are now deprecated; macros of the same name are
provided for compatibility.</p>

<p style="margin-top: 1em">When using any of these routines
(except &quot;call_argv&quot;), the programmer must
manipulate the Perl stack. These include the following
macros and functions:</p>

<p style="margin-top: 1em">dSP <br>
SP <br>
PUSHMARK() <br>
PUTBACK <br>
SPAGAIN <br>
ENTER <br>
SAVETMPS <br>
FREETMPS <br>
LEAVE <br>
XPUSH*() <br>
POP*()</p>

<p style="margin-top: 1em">For a detailed description of
calling conventions from C to Perl, consult perlcall.</p>

<p style="margin-top: 1em">Memory Allocation <br>
Allocation</p>

<p style="margin-top: 1em">All memory meant to be used with
the Perl API functions should be manipulated using the
macros described in this section. The macros provide the
necessary transparency between <br>
differences in the actual malloc implementation that is used
within perl.</p>

<p style="margin-top: 1em">It is suggested that you enable
the version of malloc that is distributed with Perl. It
keeps pools of various sizes of unallocated memory in order
to satisfy allocation <br>
requests more quickly. However, on some platforms, it may
cause spurious malloc or free errors.</p>

<p style="margin-top: 1em">The following three macros are
used to initially allocate memory :</p>

<p style="margin-top: 1em">Newx(pointer, number, type);
<br>
Newxc(pointer, number, type, cast); <br>
Newxz(pointer, number, type);</p>

<p style="margin-top: 1em">The first argument
&quot;pointer&quot; should be the name of a variable that
will point to the newly allocated memory.</p>

<p style="margin-top: 1em">The second and third arguments
&quot;number&quot; and &quot;type&quot; specify how many of
the specified type of data structure should be allocated.
The argument &quot;type&quot; is passed to
&quot;sizeof&quot;. The <br>
final argument to &quot;Newxc&quot;, &quot;cast&quot;,
should be used if the &quot;pointer&quot; argument is
different from the &quot;type&quot; argument.</p>

<p style="margin-top: 1em">Unlike the &quot;Newx&quot; and
&quot;Newxc&quot; macros, the &quot;Newxz&quot; macro calls
&quot;memzero&quot; to zero out all the newly allocated
memory.</p>

<p style="margin-top: 1em">Reallocation</p>

<p style="margin-top: 1em">Renew(pointer, number, type);
<br>
Renewc(pointer, number, type, cast); <br>
Safefree(pointer)</p>

<p style="margin-top: 1em">These three macros are used to
change a memory buffer size or to free a piece of memory no
longer needed. The arguments to &quot;Renew&quot; and
&quot;Renewc&quot; match those of &quot;New&quot; and
&quot;Newc&quot; <br>
with the exception of not needing the &quot;magic
cookie&quot; argument.</p>

<p style="margin-top: 1em">Moving</p>

<p style="margin-top: 1em">Move(source, dest, number,
type); <br>
Copy(source, dest, number, type); <br>
Zero(dest, number, type);</p>

<p style="margin-top: 1em">These three macros are used to
move, copy, or zero out previously allocated memory. The
&quot;source&quot; and &quot;dest&quot; arguments point to
the source and destination starting points. Perl <br>
will move, copy, or zero out &quot;number&quot; instances of
the size of the &quot;type&quot; data structure (using the
&quot;sizeof&quot; function).</p>

<p style="margin-top: 1em">PerlIO <br>
The most recent development releases of Perl have been
experimenting with removing Perl&rsquo;s dependency on the
&quot;normal&quot; standard I/O suite and allowing other
stdio implementations <br>
to be used. This involves creating a new abstraction layer
that then calls whichever implementation of stdio Perl was
compiled with. All XSUBs should now use the functions in
<br>
the PerlIO abstraction layer and not make any assumptions
about what kind of stdio is being used.</p>

<p style="margin-top: 1em">For a complete description of
the PerlIO abstraction, consult perlapio.</p>

<p style="margin-top: 1em">Putting a C value on Perl stack
<br>
A lot of opcodes (this is an elementary operation in the
internal perl stack machine) put an SV* on the stack.
However, as an optimization the corresponding SV is
(usually) not <br>
recreated each time. The opcodes reuse specially assigned
SVs (targets) which are (as a corollary) not constantly
freed/created.</p>

<p style="margin-top: 1em">Each of the targets is created
only once (but see &quot;Scratchpads and recursion&quot;
below), and when an opcode needs to put an integer, a
double, or a string on stack, it just sets the <br>
corresponding parts of its target and puts the target on
stack.</p>

<p style="margin-top: 1em">The macro to put this target on
stack is &quot;PUSHTARG&quot;, and it is directly used in
some opcodes, as well as indirectly in zillions of others,
which use it via &quot;(X)PUSH[iunp]&quot;.</p>

<p style="margin-top: 1em">Because the target is reused,
you must be careful when pushing multiple values on the
stack. The following code will not do what you think:</p>

<p style="margin-top: 1em">XPUSHi(10); <br>
XPUSHi(20);</p>

<p style="margin-top: 1em">This translates as &quot;set
&quot;TARG&quot; to 10, push a pointer to &quot;TARG&quot;
onto the stack; set &quot;TARG&quot; to 20, push a pointer
to &quot;TARG&quot; onto the stack&quot;. At the end of the
operation, the stack <br>
does not contain the values 10 and 20, but actually contains
two pointers to &quot;TARG&quot;, which we have set to
20.</p>

<p style="margin-top: 1em">If you need to push multiple
different values then you should either use the
&quot;(X)PUSHs&quot; macros, or else use the new
&quot;m(X)PUSH[iunp]&quot; macros, none of which make use of
&quot;TARG&quot;. <br>
The &quot;(X)PUSHs&quot; macros simply push an SV* on the
stack, which, as noted under &quot;XSUBs and the Argument
Stack&quot;, will often need to be &quot;mortal&quot;. The
new &quot;m(X)PUSH[iunp]&quot; macros make <br>
this a little easier to achieve by creating a new mortal for
you (via &quot;(X)PUSHmortal&quot;), pushing that onto the
stack (extending it if necessary in the case of the
&quot;mXPUSH[iunp]&quot; <br>
macros), and then setting its value. Thus, instead of
writing this to &quot;fix&quot; the example above:</p>

<p style="margin-top: 1em">XPUSHs(sv_2mortal(newSViv(10)))
<br>
XPUSHs(sv_2mortal(newSViv(20)))</p>

<p style="margin-top: 1em">you can simply write:</p>

<p style="margin-top: 1em">mXPUSHi(10) <br>
mXPUSHi(20)</p>

<p style="margin-top: 1em">On a related note, if you do use
&quot;(X)PUSH[iunp]&quot;, then you&rsquo;re going to need a
&quot;dTARG&quot; in your variable declarations so that the
&quot;*PUSH*&quot; macros can make use of the local variable
<br>
&quot;TARG&quot;. See also &quot;dTARGET&quot; and
&quot;dXSTARG&quot;.</p>

<p style="margin-top: 1em">Scratchpads <br>
The question remains on when the SVs which are targets for
opcodes are created. The answer is that they are created
when the current unit--a subroutine or a file (for opcodes
for <br>
statements outside of subroutines)--is compiled. During this
time a special anonymous Perl array is created, which is
called a scratchpad for the current unit.</p>

<p style="margin-top: 1em">A scratchpad keeps SVs which are
lexicals for the current unit and are targets for opcodes.
One can deduce that an SV lives on a scratchpad by looking
on its flags: lexicals have <br>
&quot;SVs_PADMY&quot; set, and targets have
&quot;SVs_PADTMP&quot; set.</p>

<p style="margin-top: 1em">The correspondence between OPs
and targets is not 1-to-1. Different OPs in the compile tree
of the unit can use the same target, if this would not
conflict with the expected life <br>
of the temporary.</p>

<p style="margin-top: 1em">Scratchpads and recursion <br>
In fact it is not 100% true that a compiled unit contains a
pointer to the scratchpad AV. In fact it contains a pointer
to an AV of (initially) one element, and this element is
<br>
the scratchpad AV. Why do we need an extra level of
indirection?</p>

<p style="margin-top: 1em">The answer is recursion, and
maybe threads. Both these can create several execution
pointers going into the same subroutine. For the
subroutine-child not write over the <br>
temporaries for the subroutine-parent (lifespan of which
covers the call to the child), the parent and the child
should have different scratchpads. (And the lexicals should
be <br>
separate anyway!)</p>

<p style="margin-top: 1em">So each subroutine is born with
an array of scratchpads (of length 1). On each entry to the
subroutine it is checked that the current depth of the
recursion is not more than the <br>
length of this array, and if it is, new scratchpad is
created and pushed into the array.</p>

<p style="margin-top: 1em">The targets on this scratchpad
are &quot;undef&quot;s, but they are already marked with
correct flags.</p>

<p style="margin-top: 1em">Compiled code <br>
Code tree <br>
Here we describe the internal form your code is converted to
by Perl. Start with a simple example:</p>

<p style="margin-top: 1em">$a = $b + $c;</p>

<p style="margin-top: 1em">This is converted to a tree
similar to this one:</p>

<p style="margin-top: 1em">assign-to <br>
/ + $a <br>
/ $b $c</p>

<p style="margin-top: 1em">(but slightly more complicated).
This tree reflects the way Perl parsed your code, but has
nothing to do with the execution order. There is an
additional &quot;thread&quot; going through <br>
the nodes of the tree which shows the order of execution of
the nodes. In our simplified example above it looks
like:</p>

<p style="margin-top: 1em">$b ---&gt; $c ---&gt; + ---&gt;
$a ---&gt; assign-to</p>

<p style="margin-top: 1em">But with the actual compile tree
for &quot;$a = $b + $c&quot; it is different: some nodes
optimized away. As a corollary, though the actual tree
contains more nodes than our simplified <br>
example, the execution order is the same as in our
example.</p>

<p style="margin-top: 1em">Examining the tree <br>
If you have your perl compiled for debugging (usually done
with &quot;-DDEBUGGING&quot; on the &quot;Configure&quot;
command line), you may examine the compiled tree by
specifying &quot;-Dx&quot; on the Perl <br>
command line. The output takes several lines per node, and
for &quot;$b+$c&quot; it looks like this:</p>

<p style="margin-top: 1em">5 TYPE = add ===&gt; 6 <br>
TARG = 1 <br>
FLAGS = (SCALAR,KIDS) <br>
{ <br>
TYPE = null ===&gt; (4) <br>
(was rv2sv) <br>
FLAGS = (SCALAR,KIDS) <br>
{ <br>
3 TYPE = gvsv ===&gt; 4 <br>
FLAGS = (SCALAR) <br>
GV = main::b <br>
} <br>
} <br>
{ <br>
TYPE = null ===&gt; (5) <br>
(was rv2sv) <br>
FLAGS = (SCALAR,KIDS) <br>
{ <br>
4 TYPE = gvsv ===&gt; 5 <br>
FLAGS = (SCALAR) <br>
GV = main::c <br>
} <br>
}</p>

<p style="margin-top: 1em">This tree has 5 nodes (one per
&quot;TYPE&quot; specifier), only 3 of them are not
optimized away (one per number in the left column). The
immediate children of the given node correspond <br>
to &quot;{}&quot; pairs on the same level of indentation,
thus this listing corresponds to the tree:</p>

<p style="margin-top: 1em">add <br>
/ null null <br>
| | <br>
gvsv gvsv</p>

<p style="margin-top: 1em">The execution order is indicated
by &quot;===&gt;&quot; marks, thus it is &quot;3 4 5 6&quot;
(node 6 is not included into above listing), i.e.,
&quot;gvsv gvsv add whatever&quot;.</p>

<p style="margin-top: 1em">Each of these nodes represents
an op, a fundamental operation inside the Perl core. The
code which implements each operation can be found in the
pp*.c files; the function which <br>
implements the op with type &quot;gvsv&quot; is
&quot;pp_gvsv&quot;, and so on. As the tree above shows,
different ops have different numbers of children:
&quot;add&quot; is a binary operator, as one would <br>
expect, and so has two children. To accommodate the various
different numbers of children, there are various types of op
data structure, and they link together in different
ways.</p>

<p style="margin-top: 1em">The simplest type of op
structure is &quot;OP&quot;: this has no children. Unary
operators, &quot;UNOP&quot;s, have one child, and this is
pointed to by the &quot;op_first&quot; field. Binary
operators <br>
(&quot;BINOP&quot;s) have not only an &quot;op_first&quot;
field but also an &quot;op_last&quot; field. The most
complex type of op is a &quot;LISTOP&quot;, which has any
number of children. In this case, the first <br>
child is pointed to by &quot;op_first&quot; and the last
child by &quot;op_last&quot;. The children in between can be
found by iteratively following the &quot;op_sibling&quot;
pointer from the first child to <br>
the last.</p>

<p style="margin-top: 1em">There are also two other op
types: a &quot;PMOP&quot; holds a regular expression, and
has no children, and a &quot;LOOP&quot; may or may not have
children. If the &quot;op_children&quot; field is non-zero,
it <br>
behaves like a &quot;LISTOP&quot;. To complicate matters, if
a &quot;UNOP&quot; is actually a &quot;null&quot; op after
optimization (see &quot;Compile pass 2: context
propagation&quot;) it will still have children in <br>
accordance with its former type.</p>

<p style="margin-top: 1em">Another way to examine the tree
is to use a compiler back-end module, such as
B::Concise.</p>

<p style="margin-top: 1em">Compile pass 1: check routines
<br>
The tree is created by the compiler while yacc code feeds it
the constructions it recognizes. Since yacc works bottom-up,
so does the first pass of perl compilation.</p>

<p style="margin-top: 1em">What makes this pass interesting
for perl developers is that some optimization may be
performed on this pass. This is optimization by so-called
&quot;check routines&quot;. The <br>
correspondence between node names and corresponding check
routines is described in opcode.pl (do not forget to run
&quot;make regen_headers&quot; if you modify this file).</p>

<p style="margin-top: 1em">A check routine is called when
the node is fully constructed except for the execution-order
thread. Since at this time there are no back-links to the
currently constructed node, <br>
one can do most any operation to the top-level node,
including freeing it and/or creating new nodes above/below
it.</p>

<p style="margin-top: 1em">The check routine returns the
node which should be inserted into the tree (if the
top-level node was not modified, check routine returns its
argument).</p>

<p style="margin-top: 1em">By convention, check routines
have names &quot;ck_*&quot;. They are usually called from
&quot;new*OP&quot; subroutines (or &quot;convert&quot;)
(which in turn are called from perly.y).</p>

<p style="margin-top: 1em">Compile pass 1a: constant
folding <br>
Immediately after the check routine is called the returned
node is checked for being compile-time executable. If it is
(the value is judged to be constant) it is immediately <br>
executed, and a constant node with the &quot;return
value&quot; of the corresponding subtree is substituted
instead. The subtree is deleted.</p>

<p style="margin-top: 1em">If constant folding was not
performed, the execution-order thread is created.</p>

<p style="margin-top: 1em">Compile pass 2: context
propagation <br>
When a context for a part of compile tree is known, it is
propagated down through the tree. At this time the context
can have 5 values (instead of 2 for runtime context): void,
<br>
boolean, scalar, list, and lvalue. In contrast with the pass
1 this pass is processed from top to bottom: a node&rsquo;s
context determines the context for its children.</p>

<p style="margin-top: 1em">Additional context-dependent
optimizations are performed at this time. Since at this
moment the compile tree contains back-references (via
&quot;thread&quot; pointers), nodes cannot be <br>
free()d now. To allow optimized-away nodes at this stage,
such nodes are null()ified instead of free()ing (i.e. their
type is changed to OP_NULL).</p>

<p style="margin-top: 1em">Compile pass 3: peephole
optimization <br>
After the compile tree for a subroutine (or for an
&quot;eval&quot; or a file) is created, an additional pass
over the code is performed. This pass is neither top-down or
bottom-up, but in <br>
the execution order (with additional complications for
conditionals). Optimizations performed at this stage are
subject to the same restrictions as in the pass 2.</p>

<p style="margin-top: 1em">Peephole optimizations are done
by calling the function pointed to by the global variable
&quot;PL_peepp&quot;. By default, &quot;PL_peepp&quot; just
calls the function pointed to by the global <br>
variable &quot;PL_rpeepp&quot;. By default, that performs
some basic op fixups and optimisations along the
execution-order op chain, and recursively calls
&quot;PL_rpeepp&quot; for each side chain <br>
of ops (resulting from conditionals). Extensions may provide
additional optimisations or fixups, hooking into either the
per-subroutine or recursive stage, like this:</p>

<p style="margin-top: 1em">static peep_t prev_peepp; <br>
static void my_peep(pTHX_ OP *o) <br>
{ <br>
/* custom per-subroutine optimisation goes here */ <br>
prev_peepp(o); <br>
/* custom per-subroutine optimisation may also go here */
<br>
} <br>
BOOT: <br>
prev_peepp = PL_peepp; <br>
PL_peepp = my_peep;</p>

<p style="margin-top: 1em">static peep_t prev_rpeepp; <br>
static void my_rpeep(pTHX_ OP *o) <br>
{ <br>
OP *orig_o = o; <br>
for(; o; o = o-&gt;op_next) { <br>
/* custom per-op optimisation goes here */ <br>
} <br>
prev_rpeepp(orig_o); <br>
} <br>
BOOT: <br>
prev_rpeepp = PL_rpeepp; <br>
PL_rpeepp = my_rpeep;</p>

<p style="margin-top: 1em">Pluggable runops <br>
The compile tree is executed in a runops function. There are
two runops functions, in run.c and in dump.c.
&quot;Perl_runops_debug&quot; is used with DEBUGGING and
&quot;Perl_runops_standard&quot; <br>
is used otherwise. For fine control over the execution of
the compile tree it is possible to provide your own runops
function.</p>

<p style="margin-top: 1em">It&rsquo;s probably best to copy
one of the existing runops functions and change it to suit
your needs. Then, in the BOOT section of your XS file, add
the line:</p>

<p style="margin-top: 1em">PL_runops = my_runops;</p>

<p style="margin-top: 1em">This function should be as
efficient as possible to keep your programs running as fast
as possible.</p>

<p style="margin-top: 1em">Compile-time scope hooks <br>
As of perl 5.14 it is possible to hook into the compile-time
lexical scope mechanism using
&quot;Perl_blockhook_register&quot;. This is used like
this:</p>

<p style="margin-top: 1em">STATIC void my_start_hook(pTHX_
int full); <br>
STATIC BHK my_hooks;</p>

<p style="margin-top: 1em">BOOT: <br>
BhkENTRY_set(&amp;my_hooks, bhk_start, my_start_hook); <br>
Perl_blockhook_register(aTHX_ &amp;my_hooks);</p>

<p style="margin-top: 1em">This will arrange to have
&quot;my_start_hook&quot; called at the start of compiling
every lexical scope. The available hooks are:</p>

<p style="margin-top: 1em">&quot;void bhk_start(pTHX_ int
full)&quot; <br>
This is called just after starting a new lexical scope. Note
that Perl code like</p>

<p style="margin-top: 1em">if ($x) { ... }</p>

<p style="margin-top: 1em">creates two scopes: the first
starts at the &quot;(&quot; and has &quot;full == 1&quot;,
the second starts at the &quot;{&quot; and has &quot;full ==
0&quot;. Both end at the &quot;}&quot;, so calls to
&quot;start&quot; and <br>
&quot;pre/post_end&quot; will match. Anything pushed onto
the save stack by this hook will be popped just before the
scope ends (between the &quot;pre_&quot; and
&quot;post_end&quot; hooks, in fact).</p>

<p style="margin-top: 1em">&quot;void bhk_pre_end(pTHX_ OP
**o)&quot; <br>
This is called at the end of a lexical scope, just before
unwinding the stack. o is the root of the optree
representing the scope; it is a double pointer so you can
replace <br>
the OP if you need to.</p>

<p style="margin-top: 1em">&quot;void bhk_post_end(pTHX_ OP
**o)&quot; <br>
This is called at the end of a lexical scope, just after
unwinding the stack. o is as above. Note that it is possible
for calls to &quot;pre_&quot; and &quot;post_end&quot; to
nest, if there is <br>
something on the save stack that calls string eval.</p>

<p style="margin-top: 1em">&quot;void bhk_eval(pTHX_ OP
*const o)&quot; <br>
This is called just before starting to compile an &quot;eval
STRING&quot;, &quot;do FILE&quot;, &quot;require&quot; or
&quot;use&quot;, after the eval has been set up. o is the OP
that requested the eval, and will <br>
normally be an &quot;OP_ENTEREVAL&quot;,
&quot;OP_DOFILE&quot; or &quot;OP_REQUIRE&quot;.</p>

<p style="margin-top: 1em">Once you have your hook
functions, you need a &quot;BHK&quot; structure to put them
in. It&rsquo;s best to allocate it statically, since there
is no way to free it once it&rsquo;s registered. The <br>
function pointers should be inserted into this structure
using the &quot;BhkENTRY_set&quot; macro, which will also
set flags indicating which entries are valid. If you do need
to allocate <br>
your &quot;BHK&quot; dynamically for some reason, be sure to
zero it before you start.</p>

<p style="margin-top: 1em">Once registered, there is no
mechanism to switch these hooks off, so if that is necessary
you will need to do this yourself. An entry in
&quot;%^H&quot; is probably the best way, so the <br>
effect is lexically scoped; however it is also possible to
use the &quot;BhkDISABLE&quot; and &quot;BhkENABLE&quot;
macros to temporarily switch entries on and off. You should
also be aware that <br>
generally speaking at least one scope will have opened
before your extension is loaded, so you will see some
&quot;pre/post_end&quot; pairs that didn&rsquo;t have a
matching &quot;start&quot;.</p>

<p style="margin-top: 1em">Examining internal data
structures with the &quot;dump&quot; functions <br>
To aid debugging, the source file dump.c contains a number
of functions which produce formatted output of internal data
structures.</p>

<p style="margin-top: 1em">The most commonly used of these
functions is &quot;Perl_sv_dump&quot;; it&rsquo;s used for
dumping SVs, AVs, HVs, and CVs. The &quot;Devel::Peek&quot;
module calls &quot;sv_dump&quot; to produce debugging output
<br>
from Perl-space, so users of that module should already be
familiar with its format.</p>

<p style="margin-top: 1em">&quot;Perl_op_dump&quot; can be
used to dump an &quot;OP&quot; structure or any of its
derivatives, and produces output similar to &quot;perl
-Dx&quot;; in fact, &quot;Perl_dump_eval&quot; will dump the
main root of <br>
the code being evaluated, exactly like &quot;-Dx&quot;.</p>

<p style="margin-top: 1em">Other useful functions are
&quot;Perl_dump_sub&quot;, which turns a &quot;GV&quot; into
an op tree, &quot;Perl_dump_packsubs&quot; which calls
&quot;Perl_dump_sub&quot; on all the subroutines in a
package like so: <br>
(Thankfully, these are all xsubs, so there is no op
tree)</p>

<p style="margin-top: 1em">(gdb) print
Perl_dump_packsubs(PL_defstash)</p>

<p style="margin-top: 1em">SUB attributes::bootstrap =
(xsub 0x811fedc 0)</p>

<p style="margin-top: 1em">SUB UNIVERSAL::can = (xsub
0x811f50c 0)</p>

<p style="margin-top: 1em">SUB UNIVERSAL::isa = (xsub
0x811f304 0)</p>

<p style="margin-top: 1em">SUB UNIVERSAL::VERSION = (xsub
0x811f7ac 0)</p>

<p style="margin-top: 1em">SUB DynaLoader::boot_DynaLoader
= (xsub 0x805b188 0)</p>

<p style="margin-top: 1em">and &quot;Perl_dump_all&quot;,
which dumps all the subroutines in the stash and the op tree
of the main root.</p>

<p style="margin-top: 1em">How multiple interpreters and
concurrency are supported <br>
Background and PERL_IMPLICIT_CONTEXT <br>
The Perl interpreter can be regarded as a closed box: it has
an API for feeding it code or otherwise making it do things,
but it also has functions for its own use. This smells <br>
a lot like an object, and there are ways for you to build
Perl so that you can have multiple interpreters, with one
interpreter represented either as a C structure, or inside a
<br>
thread-specific structure. These structures contain all the
context, the state of that interpreter.</p>

<p style="margin-top: 1em">One macro controls the major
Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has
a C structure that packages all the interpreter state. With
multiplicity-enabled perls, <br>
PERL_IMPLICIT_CONTEXT is also normally defined, and enables
the support for passing in a &quot;hidden&quot; first
argument that represents all three data structures.
MULTIPLICITY makes <br>
multi-threaded perls possible (with the ithreads threading
model, related to the macro USE_ITHREADS.)</p>

<p style="margin-top: 1em">Two other
&quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT
and PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the
former, and the former turns on MULTIPLICITY.) The <br>
PERL_GLOBAL_STRUCT causes all the internal variables of Perl
to be wrapped inside a single global struct, struct
perl_vars, accessible as (globals) &amp;PL_Vars or
PL_VarsPtr or the <br>
function Perl_GetVars(). The PERL_GLOBAL_STRUCT_PRIVATE goes
one step further, there is still a single struct (allocated
in main() either from heap or from stack) but there are <br>
no global data symbols pointing to it. In either case the
global struct should be initialised as the very first thing
in main() using Perl_init_global_struct() and <br>
correspondingly tear it down after perl_free() using
Perl_free_global_struct(), please see miniperlmain.c for
usage details. You may also need to use &quot;dVAR&quot; in
your coding to <br>
&quot;declare the global variables&quot; when you are using
them. dTHX does this for you automatically.</p>

<p style="margin-top: 1em">To see whether you have
non-const data you can use a BSD-compatible
&quot;nm&quot;:</p>

<p style="margin-top: 1em">nm libperl.a | grep -v &rsquo;
[TURtr] &rsquo;</p>

<p style="margin-top: 1em">If this displays any
&quot;D&quot; or &quot;d&quot; symbols, you have non-const
data.</p>

<p style="margin-top: 1em">For backward compatibility
reasons defining just PERL_GLOBAL_STRUCT doesn&rsquo;t
actually hide all symbols inside a big global struct: some
PerlIO_xxx vtables are left visible. The <br>
PERL_GLOBAL_STRUCT_PRIVATE then hides everything (see how
the PERLIO_FUNCS_DECL is used).</p>

<p style="margin-top: 1em">All this obviously requires a
way for the Perl internal functions to be either subroutines
taking some kind of structure as the first argument, or
subroutines taking nothing as <br>
the first argument. To enable these two very different ways
of building the interpreter, the Perl source (as it does in
so many other situations) makes heavy use of macros and <br>
subroutine naming conventions.</p>

<p style="margin-top: 1em">First problem: deciding which
functions will be public API functions and which will be
private. All functions whose names begin &quot;S_&quot; are
private (think &quot;S&quot; for &quot;secret&quot; or <br>
&quot;static&quot;). All other functions begin with
&quot;Perl_&quot;, but just because a function begins with
&quot;Perl_&quot; does not mean it is part of the API. (See
&quot;Internal Functions&quot;.) The easiest <br>
way to be sure a function is part of the API is to find its
entry in perlapi. If it exists in perlapi, it&rsquo;s part
of the API. If it doesn&rsquo;t, and you think it should be
(i.e., <br>
you need it for your extension), send mail via perlbug
explaining why you think it should be.</p>

<p style="margin-top: 1em">Second problem: there must be a
syntax so that the same subroutine declarations and calls
can pass a structure as their first argument, or pass
nothing. To solve this, the <br>
subroutines are named and declared in a particular way.
Here&rsquo;s a typical start of a static function used
within the Perl guts:</p>

<p style="margin-top: 1em">STATIC void <br>
S_incline(pTHX_ char *s)</p>

<p style="margin-top: 1em">STATIC becomes
&quot;static&quot; in C, and may be #define&rsquo;d to
nothing in some configurations in the future.</p>

<p style="margin-top: 1em">A public function (i.e. part of
the internal API, but not necessarily sanctioned for use in
extensions) begins like this:</p>

<p style="margin-top: 1em">void <br>
Perl_sv_setiv(pTHX_ SV* dsv, IV num)</p>

<p style="margin-top: 1em">&quot;pTHX_&quot; is one of a
number of macros (in perl.h) that hide the details of the
interpreter&rsquo;s context. THX stands for
&quot;thread&quot;, &quot;this&quot;, or &quot;thingy&quot;,
as the case may be. (And no, <br>
George Lucas is not involved. :-) The first character could
be &rsquo;p&rsquo; for a prototype, &rsquo;a&rsquo; for
argument, or &rsquo;d&rsquo; for declaration, so we have
&quot;pTHX&quot;, &quot;aTHX&quot; and &quot;dTHX&quot;, and
their <br>
variants.</p>

<p style="margin-top: 1em">When Perl is built without
options that set PERL_IMPLICIT_CONTEXT, there is no first
argument containing the interpreter&rsquo;s context. The
trailing underscore in the pTHX_ macro <br>
indicates that the macro expansion needs a comma after the
context argument because other arguments follow it. If
PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored,
<br>
and the subroutine is not prototyped to take the extra
argument. The form of the macro without the trailing
underscore is used when there are no additional explicit
arguments.</p>

<p style="margin-top: 1em">When a core function calls
another, it must pass the context. This is normally hidden
via macros. Consider &quot;sv_setiv&quot;. It expands into
something like this:</p>

<p style="margin-top: 1em">#ifdef PERL_IMPLICIT_CONTEXT
<br>
#define sv_setiv(a,b) Perl_sv_setiv(aTHX_ a, b) <br>
/* can&rsquo;t do this for vararg functions, see below */
<br>
#else <br>
#define sv_setiv Perl_sv_setiv <br>
#endif</p>

<p style="margin-top: 1em">This works well, and means that
XS authors can gleefully write:</p>

<p style="margin-top: 1em">sv_setiv(foo, bar);</p>

<p style="margin-top: 1em">and still have it work under all
the modes Perl could have been compiled with.</p>

<p style="margin-top: 1em">This doesn&rsquo;t work so
cleanly for varargs functions, though, as macros imply that
the number of arguments is known in advance. Instead we
either need to spell them out fully, <br>
passing &quot;aTHX_&quot; as the first argument (the Perl
core tends to do this with functions like Perl_warner), or
use a context-free version.</p>

<p style="margin-top: 1em">The context-free version of
Perl_warner is called Perl_warner_nocontext, and does not
take the extra argument. Instead it does dTHX; to get the
context from thread-local <br>
storage. We &quot;#define warner Perl_warner_nocontext&quot;
so that extensions get source compatibility at the expense
of performance. (Passing an arg is cheaper than grabbing it
from <br>
thread-local storage.)</p>

<p style="margin-top: 1em">You can ignore [pad]THXx when
browsing the Perl headers/sources. Those are strictly for
use within the core. Extensions and embedders need only be
aware of [pad]THX.</p>

<p style="margin-top: 1em">So what happened to dTHR? <br>
&quot;dTHR&quot; was introduced in perl 5.005 to support the
older thread model. The older thread model now uses the
&quot;THX&quot; mechanism to pass context pointers around,
so &quot;dTHR&quot; is not <br>
useful any more. Perl 5.6.0 and later still have it for
backward source compatibility, but it is defined to be a
no-op.</p>

<p style="margin-top: 1em">How do I use all this in
extensions? <br>
When Perl is built with PERL_IMPLICIT_CONTEXT, extensions
that call any functions in the Perl API will need to pass
the initial context argument somehow. The kicker is that you
<br>
will need to write it in such a way that the extension still
compiles when Perl hasn&rsquo;t been built with
PERL_IMPLICIT_CONTEXT enabled.</p>

<p style="margin-top: 1em">There are three ways to do this.
First, the easy but inefficient way, which is also the
default, in order to maintain source compatibility with
extensions: whenever XSUB.h is <br>
#included, it redefines the aTHX and aTHX_ macros to call a
function that will return the context. Thus, something
like:</p>

<p style="margin-top: 1em">sv_setiv(sv, num);</p>

<p style="margin-top: 1em">in your extension will translate
to this when PERL_IMPLICIT_CONTEXT is in effect:</p>


<p style="margin-top: 1em">Perl_sv_setiv(Perl_get_context(),
sv, num);</p>

<p style="margin-top: 1em">or to this otherwise:</p>

<p style="margin-top: 1em">Perl_sv_setiv(sv, num);</p>

<p style="margin-top: 1em">You don&rsquo;t have to do
anything new in your extension to get this; since the Perl
library provides Perl_get_context(), it will all just
work.</p>

<p style="margin-top: 1em">The second, more efficient way
is to use the following template for your Foo.xs:</p>

<p style="margin-top: 1em">#define PERL_NO_GET_CONTEXT /*
we want efficiency */ <br>
#include &quot;EXTERN.h&quot; <br>
#include &quot;perl.h&quot; <br>
#include &quot;XSUB.h&quot;</p>

<p style="margin-top: 1em">STATIC void
my_private_function(int arg1, int arg2);</p>

<p style="margin-top: 1em">STATIC void <br>
my_private_function(int arg1, int arg2) <br>
{ <br>
dTHX; /* fetch context */ <br>
... call many Perl API functions ... <br>
}</p>

<p style="margin-top: 1em">[... etc ...]</p>

<p style="margin-top: 1em">MODULE = Foo PACKAGE = Foo</p>

<p style="margin-top: 1em">/* typical XSUB */</p>

<p style="margin-top: 1em">void <br>
my_xsub(arg) <br>
int arg <br>
CODE: <br>
my_private_function(arg, 10);</p>

<p style="margin-top: 1em">Note that the only two changes
from the normal way of writing an extension is the addition
of a &quot;#define PERL_NO_GET_CONTEXT&quot; before
including the Perl headers, followed by a <br>
&quot;dTHX;&quot; declaration at the start of every function
that will call the Perl API. (You&rsquo;ll know which
functions need this, because the C compiler will complain
that there&rsquo;s an <br>
undeclared identifier in those functions.) No changes are
needed for the XSUBs themselves, because the XS() macro is
correctly defined to pass in the implicit context if
needed.</p>

<p style="margin-top: 1em">The third, even more efficient
way is to ape how it is done within the Perl guts:</p>

<p style="margin-top: 1em">#define PERL_NO_GET_CONTEXT /*
we want efficiency */ <br>
#include &quot;EXTERN.h&quot; <br>
#include &quot;perl.h&quot; <br>
#include &quot;XSUB.h&quot;</p>

<p style="margin-top: 1em">/* pTHX_ only needed for
functions that call Perl API */ <br>
STATIC void my_private_function(pTHX_ int arg1, int
arg2);</p>

<p style="margin-top: 1em">STATIC void <br>
my_private_function(pTHX_ int arg1, int arg2) <br>
{ <br>
/* dTHX; not needed here, because THX is an argument */ <br>
... call Perl API functions ... <br>
}</p>

<p style="margin-top: 1em">[... etc ...]</p>

<p style="margin-top: 1em">MODULE = Foo PACKAGE = Foo</p>

<p style="margin-top: 1em">/* typical XSUB */</p>

<p style="margin-top: 1em">void <br>
my_xsub(arg) <br>
int arg <br>
CODE: <br>
my_private_function(aTHX_ arg, 10);</p>

<p style="margin-top: 1em">This implementation never has to
fetch the context using a function call, since it is always
passed as an extra argument. Depending on your needs for
simplicity or efficiency, <br>
you may mix the previous two approaches freely.</p>

<p style="margin-top: 1em">Never add a comma after
&quot;pTHX&quot; yourself--always use the form of the macro
with the underscore for functions that take explicit
arguments, or the form without the argument for <br>
functions with no explicit arguments.</p>

<p style="margin-top: 1em">If one is compiling Perl with
the &quot;-DPERL_GLOBAL_STRUCT&quot; the &quot;dVAR&quot;
definition is needed if the Perl global variables (see
perlvars.h or globvar.sym) are accessed in the function <br>
and &quot;dTHX&quot; is not used (the &quot;dTHX&quot;
includes the &quot;dVAR&quot; if necessary). One notices the
need for &quot;dVAR&quot; only with the said compile-time
define, because otherwise the Perl global <br>
variables are visible as-is.</p>

<p style="margin-top: 1em">Should I do anything special if
I call perl from multiple threads? <br>
If you create interpreters in one thread and then proceed to
call them in another, you need to make sure perl&rsquo;s own
Thread Local Storage (TLS) slot is initialized correctly in
<br>
each of those threads.</p>

<p style="margin-top: 1em">The &quot;perl_alloc&quot; and
&quot;perl_clone&quot; API functions will automatically set
the TLS slot to the interpreter they created, so that there
is no need to do anything special if the <br>
interpreter is always accessed in the same thread that
created it, and that thread did not create or call any other
interpreters afterwards. If that is not the case, you have
to <br>
set the TLS slot of the thread before calling any functions
in the Perl API on that particular interpreter. This is done
by calling the &quot;PERL_SET_CONTEXT&quot; macro in that
thread <br>
as the first thing you do:</p>

<p style="margin-top: 1em">/* do this before doing anything
else with some_perl */ <br>
PERL_SET_CONTEXT(some_perl);</p>

<p style="margin-top: 1em">... other Perl API calls on
some_perl go here ...</p>

<p style="margin-top: 1em">Future Plans and
PERL_IMPLICIT_SYS <br>
Just as PERL_IMPLICIT_CONTEXT provides a way to bundle up
everything that the interpreter knows about itself and pass
it around, so too are there plans to allow the interpreter
<br>
to bundle up everything it knows about the environment
it&rsquo;s running on. This is enabled with the
PERL_IMPLICIT_SYS macro. Currently it only works with
USE_ITHREADS on Windows.</p>

<p style="margin-top: 1em">This allows the ability to
provide an extra pointer (called the &quot;host&quot;
environment) for all the system calls. This makes it
possible for all the system stuff to maintain their <br>
own state, broken down into seven C structures. These are
thin wrappers around the usual system calls (see
win32/perllib.c) for the default perl executable, but for a
more <br>
ambitious host (like the one that would do fork() emulation)
all the extra work needed to pretend that different
interpreters are actually different &quot;processes&quot;,
would be done <br>
here.</p>

<p style="margin-top: 1em">The Perl engine/interpreter and
the host are orthogonal entities. There could be one or more
interpreters in a process, and one or more
&quot;hosts&quot;, with free association between <br>
them.</p>

<p style="margin-top: 1em">Internal Functions <br>
All of Perl&rsquo;s internal functions which will be exposed
to the outside world are prefixed by &quot;Perl_&quot; so
that they will not conflict with XS functions or functions
used in a <br>
program in which Perl is embedded. Similarly, all global
variables begin with &quot;PL_&quot;. (By convention, static
functions start with &quot;S_&quot;.)</p>

<p style="margin-top: 1em">Inside the Perl core
(&quot;PERL_CORE&quot; defined), you can get at the
functions either with or without the &quot;Perl_&quot;
prefix, thanks to a bunch of defines that live in embed.h.
Note that <br>
extension code should not set &quot;PERL_CORE&quot;; this
exposes the full perl internals, and is likely to cause
breakage of the XS in each new perl release.</p>

<p style="margin-top: 1em">The file embed.h is generated
automatically from embed.pl and embed.fnc. embed.pl also
creates the prototyping header files for the internal
functions, generates the <br>
documentation and a lot of other bits and pieces. It&rsquo;s
important that when you add a new function to the core or
change an existing one, you change the data in the table in
<br>
embed.fnc as well. Here&rsquo;s a sample entry from that
table:</p>

<p style="margin-top: 1em">Apd |SV** |av_fetch |AV* ar|I32
key|I32 lval</p>

<p style="margin-top: 1em">The second column is the return
type, the third column the name. Columns after that are the
arguments. The first column is a set of flags:</p>

<p style="margin-top: 1em">A This function is a part of the
public API. All such functions should also have
&rsquo;d&rsquo;, very few do not.</p>

<p style="margin-top: 1em">p This function has a
&quot;Perl_&quot; prefix; i.e. it is defined as
&quot;Perl_av_fetch&quot;.</p>

<p style="margin-top: 1em">d This function has
documentation using the &quot;apidoc&quot; feature which
we&rsquo;ll look at in a second. Some functions have
&rsquo;d&rsquo; but not &rsquo;A&rsquo;; docs are good.</p>

<p style="margin-top: 1em">Other available flags are:</p>

<p style="margin-top: 1em">s This is a static function and
is defined as &quot;STATIC S_whatever&quot;, and usually
called within the sources as &quot;whatever(...)&quot;.</p>

<p style="margin-top: 1em">n This does not need an
interpreter context, so the definition has no
&quot;pTHX&quot;, and it follows that callers don&rsquo;t
use &quot;aTHX&quot;. (See &quot;Background and
PERL_IMPLICIT_CONTEXT&quot;.)</p>

<p style="margin-top: 1em">r This function never returns;
&quot;croak&quot;, &quot;exit&quot; and friends.</p>

<p style="margin-top: 1em">f This function takes a variable
number of arguments, &quot;printf&quot; style. The argument
list should end with &quot;...&quot;, like this:</p>

<p style="margin-top: 1em">Afprd |void |croak |const char*
pat|...</p>

<p style="margin-top: 1em">M This function is part of the
experimental development API, and may change or disappear
without notice.</p>

<p style="margin-top: 1em">o This function should not have
a compatibility macro to define, say, &quot;Perl_parse&quot;
to &quot;parse&quot;. It must be called as
&quot;Perl_parse&quot;.</p>

<p style="margin-top: 1em">x This function isn&rsquo;t
exported out of the Perl core.</p>

<p style="margin-top: 1em">m This is implemented as a
macro.</p>

<p style="margin-top: 1em">X This function is explicitly
exported.</p>

<p style="margin-top: 1em">E This function is visible to
extensions included in the Perl core.</p>

<p style="margin-top: 1em">b Binary backward compatibility;
this function is a macro but also has a &quot;Perl_&quot;
implementation (which is exported).</p>

<p style="margin-top: 1em">others <br>
See the comments at the top of &quot;embed.fnc&quot; for
others.</p>

<p style="margin-top: 1em">If you edit embed.pl or
embed.fnc, you will need to run &quot;make
regen_headers&quot; to force a rebuild of embed.h and other
auto-generated files.</p>

<p style="margin-top: 1em">Formatted Printing of IVs, UVs,
and NVs <br>
If you are printing IVs, UVs, or NVS instead of the stdio(3)
style formatting codes like %d, %ld, %f, you should use the
following macros for portability</p>

<p style="margin-top: 1em">IVdf IV in decimal <br>
UVuf UV in decimal <br>
UVof UV in octal <br>
UVxf UV in hexadecimal <br>
NVef NV %e-like <br>
NVff NV %f-like <br>
NVgf NV %g-like</p>

<p style="margin-top: 1em">These will take care of 64-bit
integers and long doubles. For example:</p>

<p style="margin-top: 1em">printf(&quot;IV is
%&quot;IVdf&quot;0, iv);</p>

<p style="margin-top: 1em">The IVdf will expand to whatever
is the correct format for the IVs.</p>

<p style="margin-top: 1em">If you are printing addresses of
pointers, use UVxf combined with PTR2UV(), do not use %lx or
%p.</p>

<p style="margin-top: 1em">Pointer-To-Integer and
Integer-To-Pointer <br>
Because pointer size does not necessarily equal integer
size, use the follow macros to do it right.</p>

<p style="margin-top: 1em">PTR2UV(pointer) <br>
PTR2IV(pointer) <br>
PTR2NV(pointer) <br>
INT2PTR(pointertotype, integer)</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">IV iv = ...; <br>
SV *sv = INT2PTR(SV*, iv);</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">AV *av = ...; <br>
UV uv = PTR2UV(av);</p>

<p style="margin-top: 1em">Exception Handling <br>
There are a couple of macros to do very basic exception
handling in XS modules. You have to define
&quot;NO_XSLOCKS&quot; before including XSUB.h to be able to
use these macros:</p>

<p style="margin-top: 1em">#define NO_XSLOCKS <br>
#include &quot;XSUB.h&quot;</p>

<p style="margin-top: 1em">You can use these macros if you
call code that may croak, but you need to do some cleanup
before giving control back to Perl. For example:</p>

<p style="margin-top: 1em">dXCPT; /* set up necessary
variables */</p>

<p style="margin-top: 1em">XCPT_TRY_START { <br>
code_that_may_croak(); <br>
} XCPT_TRY_END</p>

<p style="margin-top: 1em">XCPT_CATCH <br>
{ <br>
/* do cleanup here */ <br>
XCPT_RETHROW; <br>
}</p>

<p style="margin-top: 1em">Note that you always have to
rethrow an exception that has been caught. Using these
macros, it is not possible to just catch the exception and
ignore it. If you have to ignore <br>
the exception, you have to use the &quot;call_*&quot;
function.</p>

<p style="margin-top: 1em">The advantage of using the above
macros is that you don&rsquo;t have to setup an extra
function for &quot;call_*&quot;, and that using these macros
is faster than using &quot;call_*&quot;.</p>

<p style="margin-top: 1em">Source Documentation <br>
There&rsquo;s an effort going on to document the internal
functions and automatically produce reference manuals from
them - perlapi is one such manual which details all the
functions <br>
which are available to XS writers. perlintern is the
autogenerated manual for the functions which are not part of
the API and are supposedly for internal use only.</p>

<p style="margin-top: 1em">Source documentation is created
by putting POD comments into the C source, like this:</p>

<p style="margin-top: 1em">/* <br>
=for apidoc sv_setiv</p>

<p style="margin-top: 1em">Copies an integer into the given
SV. Does not handle &rsquo;set&rsquo; magic. See <br>
C&lt;sv_setiv_mg&gt;.</p>

<p style="margin-top: 1em">=cut <br>
*/</p>

<p style="margin-top: 1em">Please try and supply some
documentation if you add functions to the Perl core.</p>

<p style="margin-top: 1em">Backwards compatibility <br>
The Perl API changes over time. New functions are added or
the interfaces of existing functions are changed. The
&quot;Devel::PPPort&quot; module tries to provide
compatibility code for <br>
some of these changes, so XS writers don&rsquo;t have to
code it themselves when supporting multiple versions of
Perl.</p>

<p style="margin-top: 1em">&quot;Devel::PPPort&quot;
generates a C header file ppport.h that can also be run as a
Perl script. To generate ppport.h, run:</p>

<p style="margin-top: 1em">perl -MDevel::PPPort
-eDevel::PPPort::WriteFile</p>

<p style="margin-top: 1em">Besides checking existing XS
code, the script can also be used to retrieve compatibility
information for various API calls using the
&quot;--api-info&quot; command line switch. For <br>
example:</p>

<p style="margin-top: 1em">% perl ppport.h
--api-info=sv_magicext</p>

<p style="margin-top: 1em">For details, see &quot;perldoc
ppport.h&quot;.</p>

<p style="margin-top: 1em">Unicode Support <br>
Perl 5.6.0 introduced Unicode support. It&rsquo;s important
for porters and XS writers to understand this support and
make sure that the code they write does not corrupt Unicode
data.</p>

<p style="margin-top: 1em">What is Unicode, anyway? <br>
In the olden, less enlightened times, we all used to use
ASCII. Most of us did, anyway. The big problem with ASCII is
that it&rsquo;s American. Well, no, that&rsquo;s not
actually the <br>
problem; the problem is that it&rsquo;s not particularly
useful for people who don&rsquo;t use the Roman alphabet.
What used to happen was that particular languages would
stick their own <br>
alphabet in the upper range of the sequence, between 128 and
255. Of course, we then ended up with plenty of variants
that weren&rsquo;t quite ASCII, and the whole point of it
being a <br>
standard was lost.</p>

<p style="margin-top: 1em">Worse still, if you&rsquo;ve got
a language like Chinese or Japanese that has hundreds or
thousands of characters, then you really can&rsquo;t fit
them into a mere 256, so they had to forget <br>
about ASCII altogether, and build their own systems using
pairs of numbers to refer to one character.</p>

<p style="margin-top: 1em">To fix this, some people formed
Unicode, Inc. and produced a new character set containing
all the characters you can possibly think of and more. There
are several ways of <br>
representing these characters, and the one Perl uses is
called UTF-8. UTF-8 uses a variable number of bytes to
represent a character. You can learn more about Unicode and
Perl&rsquo;s <br>
Unicode model in perlunicode.</p>

<p style="margin-top: 1em">How can I recognise a UTF-8
string? <br>
You can&rsquo;t. This is because UTF-8 data is stored in
bytes just like non-UTF-8 data. The Unicode character 200,
(0xC8 for you hex types) capital E with a grave accent, is
<br>
represented by the two bytes &quot;v196.172&quot;.
Unfortunately, the non-Unicode string
&quot;chr(196).chr(172)&quot; has that byte sequence as
well. So you can&rsquo;t tell just by looking - this is <br>
what makes Unicode input an interesting problem.</p>

<p style="margin-top: 1em">In general, you either have to
know what you&rsquo;re dealing with, or you have to guess.
The API function &quot;is_utf8_string&quot; can help;
it&rsquo;ll tell you if a string contains only valid <br>
UTF-8 characters. However, it can&rsquo;t do the work for
you. On a character-by-character basis,
&quot;is_utf8_char&quot; will tell you whether the current
character in a string is valid UTF-8.</p>

<p style="margin-top: 1em">How does UTF-8 represent Unicode
characters? <br>
As mentioned above, UTF-8 uses a variable number of bytes to
store a character. Characters with values 0...127 are stored
in one byte, just like good ol&rsquo; ASCII. Character 128
is <br>
stored as &quot;v194.128&quot;; this continues up to
character 191, which is &quot;v194.191&quot;. Now
we&rsquo;ve run out of bits (191 is binary 10111111) so we
move on; 192 is &quot;v195.128&quot;. And so it goes <br>
on, moving to three bytes at character 2048.</p>

<p style="margin-top: 1em">Assuming you know you&rsquo;re
dealing with a UTF-8 string, you can find out how long the
first character in it is with the &quot;UTF8SKIP&quot;
macro:</p>

<p style="margin-top: 1em">char *utf =
&quot;305233340240201&quot;; <br>
I32 len;</p>

<p style="margin-top: 1em">len = UTF8SKIP(utf); /* len is 2
here */ <br>
utf += len; <br>
len = UTF8SKIP(utf); /* len is 3 here */</p>

<p style="margin-top: 1em">Another way to skip over
characters in a UTF-8 string is to use &quot;utf8_hop&quot;,
which takes a string and a number of characters to skip
over. You&rsquo;re on your own about bounds <br>
checking, though, so don&rsquo;t use it lightly.</p>

<p style="margin-top: 1em">All bytes in a multi-byte UTF-8
character will have the high bit set, so you can test if you
need to do something special with this character like this
(the UTF8_IS_INVARIANT() <br>
is a macro that tests whether the byte can be encoded as a
single byte even in UTF-8):</p>

<p style="margin-top: 1em">U8 *utf; <br>
U8 *utf_end; /* 1 beyond buffer pointed to by utf */ <br>
UV uv; /* Note: a UV, not a U8, not a char */ <br>
STRLEN len; /* length of character in bytes */</p>

<p style="margin-top: 1em">if (!UTF8_IS_INVARIANT(*utf))
<br>
/* Must treat this as UTF-8 */ <br>
uv = utf8_to_uvchr_buf(utf, utf_end, &amp;len); <br>
else <br>
/* OK to treat this character as a byte */ <br>
uv = *utf;</p>

<p style="margin-top: 1em">You can also see in that example
that we use &quot;utf8_to_uvchr_buf&quot; to get the value
of the character; the inverse function
&quot;uvchr_to_utf8&quot; is available for putting a UV into
UTF-8:</p>

<p style="margin-top: 1em">if (!UTF8_IS_INVARIANT(uv)) <br>
/* Must treat this as UTF8 */ <br>
utf8 = uvchr_to_utf8(utf8, uv); <br>
else <br>
/* OK to treat this character as a byte */ <br>
*utf8++ = uv;</p>

<p style="margin-top: 1em">You must convert characters to
UVs using the above functions if you&rsquo;re ever in a
situation where you have to match UTF-8 and non-UTF-8
characters. You may not skip over UTF-8 <br>
characters in this case. If you do this, you&rsquo;ll lose
the ability to match hi-bit non-UTF-8 characters; for
instance, if your UTF-8 string contains
&quot;v196.172&quot;, and you skip that <br>
character, you can never match a &quot;chr(200)&quot; in a
non-UTF-8 string. So don&rsquo;t do that!</p>

<p style="margin-top: 1em">How does Perl store UTF-8
strings? <br>
Currently, Perl deals with Unicode strings and non-Unicode
strings slightly differently. A flag in the SV,
&quot;SVf_UTF8&quot;, indicates that the string is
internally encoded as UTF-8. <br>
Without it, the byte value is the codepoint number and vice
versa (in other words, the string is encoded as iso-8859-1,
but &quot;use feature &rsquo;unicode_strings&rsquo;&quot; is
needed to get <br>
iso-8859-1 semantics). You can check and manipulate this
flag with the following macros:</p>

<p style="margin-top: 1em">SvUTF8(sv) <br>
SvUTF8_on(sv) <br>
SvUTF8_off(sv)</p>

<p style="margin-top: 1em">This flag has an important
effect on Perl&rsquo;s treatment of the string: if Unicode
data is not properly distinguished, regular expressions,
&quot;length&quot;, &quot;substr&quot; and other string <br>
handling operations will have undesirable results.</p>

<p style="margin-top: 1em">The problem comes when you have,
for instance, a string that isn&rsquo;t flagged as UTF-8,
and contains a byte sequence that could be UTF-8 -
especially when combining non-UTF-8 and <br>
UTF-8 strings.</p>

<p style="margin-top: 1em">Never forget that the
&quot;SVf_UTF8&quot; flag is separate to the PV value; you
need be sure you don&rsquo;t accidentally knock it off while
you&rsquo;re manipulating SVs. More specifically, you <br>
cannot expect to do this:</p>

<p style="margin-top: 1em">SV *sv; <br>
SV *nsv; <br>
STRLEN len; <br>
char *p;</p>

<p style="margin-top: 1em">p = SvPV(sv, len); <br>
frobnicate(p); <br>
nsv = newSVpvn(p, len);</p>

<p style="margin-top: 1em">The &quot;char*&quot; string
does not tell you the whole story, and you can&rsquo;t copy
or reconstruct an SV just by copying the string value. Check
if the old SV has the UTF8 flag set, and act <br>
accordingly:</p>

<p style="margin-top: 1em">p = SvPV(sv, len); <br>
frobnicate(p); <br>
nsv = newSVpvn(p, len); <br>
if (SvUTF8(sv)) <br>
SvUTF8_on(nsv);</p>

<p style="margin-top: 1em">In fact, your
&quot;frobnicate&quot; function should be made aware of
whether or not it&rsquo;s dealing with UTF-8 data, so that
it can handle the string appropriately.</p>

<p style="margin-top: 1em">Since just passing an SV to an
XS function and copying the data of the SV is not enough to
copy the UTF8 flags, even less right is just passing a
&quot;char *&quot; to an XS function.</p>

<p style="margin-top: 1em">How do I convert a string to
UTF-8? <br>
If you&rsquo;re mixing UTF-8 and non-UTF-8 strings, it is
necessary to upgrade one of the strings to UTF-8. If
you&rsquo;ve got an SV, the easiest way to do this is:</p>

<p style="margin-top: 1em">sv_utf8_upgrade(sv);</p>

<p style="margin-top: 1em">However, you must not do this,
for example:</p>

<p style="margin-top: 1em">if (!SvUTF8(left)) <br>
sv_utf8_upgrade(left);</p>

<p style="margin-top: 1em">If you do this in a binary
operator, you will actually change one of the strings that
came into the operator, and, while it shouldn&rsquo;t be
noticeable by the end user, it can cause <br>
problems in deficient code.</p>

<p style="margin-top: 1em">Instead,
&quot;bytes_to_utf8&quot; will give you a UTF-8-encoded copy
of its string argument. This is useful for having the data
available for comparisons and so on, without harming the
<br>
original SV. There&rsquo;s also &quot;utf8_to_bytes&quot; to
go the other way, but naturally, this will fail if the
string contains any characters above 255 that can&rsquo;t be
represented in a single <br>
byte.</p>

<p style="margin-top: 1em">Is there anything else I need to
know? <br>
Not really. Just remember these things:</p>

<p style="margin-top: 1em">&Acirc;&middot; There&rsquo;s no
way to tell if a string is UTF-8 or not. You can tell if an
SV is UTF-8 by looking at its &quot;SvUTF8&quot; flag.
Don&rsquo;t forget to set the flag if something should be
UTF-8. <br>
Treat the flag as part of the PV, even though it&rsquo;s not
- if you pass on the PV to somewhere, pass on the flag
too.</p>

<p style="margin-top: 1em">&Acirc;&middot; If a string is
UTF-8, always use &quot;utf8_to_uvchr_buf&quot; to get at
the value, unless &quot;UTF8_IS_INVARIANT(*s)&quot; in which
case you can use *s.</p>

<p style="margin-top: 1em">&Acirc;&middot; When writing a
character &quot;uv&quot; to a UTF-8 string, always use
&quot;uvchr_to_utf8&quot;, unless
&quot;UTF8_IS_INVARIANT(uv))&quot; in which case you can use
&quot;*s = uv&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Mixing UTF-8 and
non-UTF-8 strings is tricky. Use &quot;bytes_to_utf8&quot;
to get a new string which is UTF-8 encoded, and then combine
them.</p>

<p style="margin-top: 1em">Custom Operators <br>
Custom operator support is a new experimental feature that
allows you to define your own ops. This is primarily to
allow the building of interpreters for other languages in
the <br>
Perl core, but it also allows optimizations through the
creation of &quot;macro-ops&quot; (ops which perform the
functions of multiple ops which are usually executed
together, such as <br>
&quot;gvsv, gvsv, add&quot;.)</p>

<p style="margin-top: 1em">This feature is implemented as a
new op type, &quot;OP_CUSTOM&quot;. The Perl core does not
&quot;know&quot; anything special about this op type, and so
it will not be involved in any optimizations. <br>
This also means that you can define your custom ops to be
any op structure - unary, binary, list and so on - you
like.</p>

<p style="margin-top: 1em">It&rsquo;s important to know
what custom operators won&rsquo;t do for you. They
won&rsquo;t let you add new syntax to Perl, directly. They
won&rsquo;t even let you add new keywords, directly. In
fact, <br>
they won&rsquo;t change the way Perl compiles a program at
all. You have to do those changes yourself, after Perl has
compiled the program. You do this either by manipulating the
op <br>
tree using a &quot;CHECK&quot; block and the
&quot;B::Generate&quot; module, or by adding a custom
peephole optimizer with the &quot;optimize&quot; module.</p>

<p style="margin-top: 1em">When you do this, you replace
ordinary Perl ops with custom ops by creating ops with the
type &quot;OP_CUSTOM&quot; and the &quot;pp_addr&quot; of
your own PP function. This should be defined in XS <br>
code, and should look like the PP ops in &quot;pp_*.c&quot;.
You are responsible for ensuring that your op takes the
appropriate number of values from the stack, and you are
responsible <br>
for adding stack marks if necessary.</p>

<p style="margin-top: 1em">You should also
&quot;register&quot; your op with the Perl interpreter so
that it can produce sensible error and warning messages.
Since it is possible to have multiple custom ops within <br>
the one &quot;logical&quot; op type &quot;OP_CUSTOM&quot;,
Perl uses the value of &quot;o-&gt;op_ppaddr&quot; to
determine which custom op it is dealing with. You should
create an &quot;XOP&quot; structure for each ppaddr <br>
you use, set the properties of the custom op with
&quot;XopENTRY_set&quot;, and register the structure against
the ppaddr using &quot;Perl_custom_op_register&quot;. A
trivial example might look <br>
like:</p>

<p style="margin-top: 1em">static XOP my_xop; <br>
static OP *my_pp(pTHX);</p>

<p style="margin-top: 1em">BOOT: <br>
XopENTRY_set(&amp;my_xop, xop_name, &quot;myxop&quot;); <br>
XopENTRY_set(&amp;my_xop, xop_desc, &quot;Useless custom
op&quot;); <br>
Perl_custom_op_register(aTHX_ my_pp, &amp;my_xop);</p>

<p style="margin-top: 1em">The available fields in the
structure are:</p>

<p style="margin-top: 1em">xop_name <br>
A short name for your op. This will be included in some
error messages, and will also be returned as
&quot;$op-&gt;name&quot; by the B module, so it will appear
in the output of module <br>
like B::Concise.</p>

<p style="margin-top: 1em">xop_desc <br>
A short description of the function of the op.</p>

<p style="margin-top: 1em">xop_class <br>
Which of the various *OP structures this op uses. This
should be one of the &quot;OA_*&quot; constants from op.h,
namely</p>

<p style="margin-top: 1em">OA_BASEOP <br>
OA_UNOP <br>
OA_BINOP <br>
OA_LOGOP <br>
OA_LISTOP <br>
OA_PMOP <br>
OA_SVOP <br>
OA_PADOP <br>
OA_PVOP_OR_SVOP <br>
This should be interpreted as &rsquo;&quot;PVOP&quot;&rsquo;
only. The &quot;_OR_SVOP&quot; is because the only core
&quot;PVOP&quot;, &quot;OP_TRANS&quot;, can sometimes be a
&quot;SVOP&quot; instead.</p>

<p style="margin-top: 1em">OA_LOOP <br>
OA_COP</p>

<p style="margin-top: 1em">The other &quot;OA_*&quot;
constants should not be used.</p>

<p style="margin-top: 1em">xop_peep <br>
This member is of type &quot;Perl_cpeep_t&quot;, which
expands to &quot;void (*Perl_cpeep_t)(aTHX_ OP *o, OP
*oldop)&quot;. If it is set, this function will be called
from &quot;Perl_rpeep&quot; when ops <br>
of this type are encountered by the peephole optimizer. o is
the OP that needs optimizing; oldop is the previous OP
optimized, whose &quot;op_next&quot; points to o.</p>

<p style="margin-top: 1em">&quot;B::Generate&quot; directly
supports the creation of custom ops by name.</p>

<p style="margin-top: 1em">AUTHORS <br>
Until May 1997, this document was maintained by Jeff Okamoto
&lt;okamoto@corp.hp.com&gt;. It is now maintained as part of
Perl itself by the Perl 5 Porters
&lt;perl5-porters@perl.org&gt;.</p>

<p style="margin-top: 1em">With lots of help and
suggestions from Dean Roehrich, Malcolm Beattie, Andreas
Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider <br>
Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy
Sarathy.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perlapi, perlintern, perlxs, perlembed</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLGUTS(1)</p>
<hr>
</body>
</html>
