<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:24 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PGCENTER(1) General Commands Manual PGCENTER(1)</p>

<p style="margin-top: 1em">NAME <br>
pgcenter - is the PostgreSQL administration console with
top-like monitoring.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
pgcenter [OPTION]... [DBNAME [USERNAME]]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
PostgreSQL provides various statistics which includes
information about tables, indexes, functions and other
database objects and their usage. Moreover, statistics has
informa&acirc; <br>
tion about connections, current queries and database
operations (INSERT/DELETE/UPDATE). But most of this
statistics are provided as permanently incremented counters.
The pgcenter <br>
provides convenient interface to this statistics and allow
viewing statistics changes in time interval, eg. per second.
The pgcenter provides fast access for database management
<br>
task, such as editing configuration files, reloading
services, viewing log files and canceling or terminating
database backends (by pid or using state mask). However if
need exe&acirc; <br>
cute some specific operations, pgcenter can start psql
session for this purposes.</p>

<p style="margin-top: 1em">The pgcenter uses screens and
contexts. Screen is a special area for displaying
statistics. Number of screen limited by eight. Context is
the type of displayed statistics: table <br>
statistics, index statistics, functions statistics,
replication statistics, etc.</p>

<p style="margin-top: 1em">All operations in pgcenter
realized through hotkeys.</p>

<p style="margin-top: 1em">When pgcenter starts it using
the connection parameters transmitted directly through the
arguments, or use a connection file that describes the
connections options. For each con&acirc; <br>
nection is allocated a separate screen. When the arguments
and connections file used together, connect options from
arguments always starts in the firts screen. If the
arguments <br>
or connections file is not specified, pgcenter use default
connection settings.</p>

<p style="margin-top: 1em">The pgcenter main window divided
into 3 window: SUMMARY, CMDLINE, DBRESULT and optional
LOGTAIL window which hidden by default and appears only by
user command.</p>

<p style="margin-top: 1em">COMMAND-LINE OPTIONS <br>
The command-line syntax for pgcenter consists of:</p>

<p style="margin-top: 1em">-h, --host=HOSTNAME <br>
PostgreSQL server host or socket directory (default:
&quot;/tmp&quot;).</p>

<p style="margin-top: 1em">-p, --port=PORT <br>
PostgreSQL server port (default: &quot;5432&quot;).</p>

<p style="margin-top: 1em">-U, --username=USERNAME <br>
PostgerSQL user name (default: &quot;current logged
user&quot;).</p>

<p style="margin-top: 1em">-d, --dbname=DBNAME <br>
PostgreSQL administrative database name (default:
&quot;pgbouncer&quot;).</p>

<p style="margin-top: 1em">-f, --file=FILENAME <br>
Use connections information from file. By default, pgcenter
when starting, trying read ~/.pgcenterrc connections file.
This behaviour can be overriden with this option.</p>

<p style="margin-top: 1em">-w, --no-password <br>
Never prompt for password.</p>

<p style="margin-top: 1em">-W, --password <br>
Force password prompt (should happen automatically).</p>

<p style="margin-top: 1em">-?, --help <br>
Show this help, then exit.</p>

<p style="margin-top: 1em">-V, --version <br>
Print version, then exit.</p>

<p style="margin-top: 1em">SUMMARY WINDOW <br>
Summary window always displayed and provides various
information about system load and current connected
PostgreSQL.</p>

<p style="margin-top: 1em">Current Time and Load Average
<br>
Line 1-1 shows program name, current time, system load avg
over the last 1, 5 and 15 minutes.</p>

<p style="margin-top: 1em">CPU Usage <br>
Line 1-2 shows CPU usage percentages based on the interval
since the last refresh.</p>

<p style="margin-top: 1em">us, user <br>
Percentage of CPU utilization that occurred while executing
at the user level (application).</p>

<p style="margin-top: 1em">sy, system <br>
Percentage of CPU utilization that occurred while executing
at the system level (kernel).</p>

<p style="margin-top: 1em">ni, nice <br>
Percentage of CPU utilization that occurred while executing
at the user level with nice priority.</p>

<p style="margin-top: 1em">id, idle <br>
Percentage of time that the CPU or CPUs were idle and the
system did not have an outstanding disk I/O request.</p>

<p style="margin-top: 1em">wa, iowait <br>
Percentage of time that the CPU or CPUs were idle during
which the system had an outstanding disk I/O request.</p>

<p style="margin-top: 1em">hi, hardirq <br>
Percentage of time that the CPU or CPUS spent servicing
hardware interrupts.</p>

<p style="margin-top: 1em">si, softirq <br>
Percentage of time thatthe CPU or CPUS spent servicing
software interrupts.</p>

<p style="margin-top: 1em">st, steal <br>
Percentage of time spent in involuntary wait by the virtual
CPU or CPUs while the hypervisor was servicing another
virtual processor.</p>

<p style="margin-top: 1em">CPU Usage <br>
Line 1-3 shows memory and line 1-4 shows swap usage based on
the interval since the last refresh.</p>

<p style="margin-top: 1em">total <br>
Total amount of RAM or swap in MiB (mebibyte = 1024 KiB =
1,048,576 bytes).</p>

<p style="margin-top: 1em">free <br>
Total amount of free RAM or swap in MiB (mebibyte = 1024 KiB
= 1,048,576 bytes).</p>

<p style="margin-top: 1em">used <br>
Total amount of used RAM or swap in MiB (mebibyte = 1024 KiB
= 1,048,576 bytes).</p>

<p style="margin-top: 1em">buff/cached <br>
Total amount of cached and buffered RAM in MiB (mebibyte =
1024 KiB = 1,048,576 bytes).</p>

<p style="margin-top: 1em">dirty/writeback <br>
Total ammount of dirty memory which is waiting to be written
back to the disk. And total amount of memory actively being
written back to the disk. Values are in MiB <br>
(mebibyte = 1024 KiB = 1,048,576 bytes).</p>

<p style="margin-top: 1em">Connection information <br>
Line 2-1 shows connection information to the current
PostgreSQL:</p>

<p style="margin-top: 1em">conn <br>
Current screen number (from 1 to 8) and connection
status.</p>

<p style="margin-top: 1em">conninfo <br>
Current connection information with following format:
host:port username@dbname.</p>

<p style="margin-top: 1em">postgresql version <br>
Version of the PostgreSQL.</p>

<p style="margin-top: 1em">uptime <br>
Uptime of PostgreSQL service. <br>
Used query: SELECT now() - pg_postmaster_start_time();</p>

<p style="margin-top: 1em">Summary activity <br>
Line 2-2 shows current PostgreSQL connections grouped by
their states.</p>

<p style="margin-top: 1em">total <br>
Total connections number. <br>
Used query: SELECT count(*) FROM pg_stat_activity;</p>

<p style="margin-top: 1em">idle <br>
Number of backends in idle state which is waiting for a new
client command. <br>
Used query: SELECT count(*) FROM pg_stat_activity <br>
WHERE state = &rsquo;idle&rsquo;;</p>

<p style="margin-top: 1em">idle_in_xact <br>
Number of backends in idle in transaction means the backend
is in a transaction, but is not currently executing a query,
and idle in transaction (aborted) which is <br>
similar to idle in transaction, except one of the statements
in the transaction caused an error. <br>
Used query: SELECT count(*) FROM pg_stat_activity <br>
WHERE state IN (&rsquo;idle in transaction&rsquo;,
&rsquo;idle in transaction (aborted)&rsquo;);</p>

<p style="margin-top: 1em">active <br>
Number of backends in active state when backends is
executing a queries. <br>
Used query: SELECT count(*) FROM pg_stat_activity <br>
WHERE state = &rsquo;active&rsquo;;</p>

<p style="margin-top: 1em">waiting <br>
Number of backends which is currently waiting on a lock.
<br>
Used query: SELECT count(*) FROM pg_stat_activity <br>
WHERE waiting;</p>

<p style="margin-top: 1em">others <br>
Number of backends with fastpath function call state which
executes fast-path functions and disabled state which is
reported only if track_activities is disabled in <br>
backend. <br>
Used query: SELECT count(*) FROM pg_stat_activity <br>
WHERE state IN (&rsquo;fastpath function
call&rsquo;,&rsquo;disabled&rsquo;);</p>

<p style="margin-top: 1em">Autovacuum activity <br>
Line 2-3 shows current PostgreSQL autovacuum activity.</p>

<p style="margin-top: 1em">workers <br>
Total number of autovacuum workers currently running.</p>

<p style="margin-top: 1em">max <br>
Max number of allowed autovacuum workers.</p>

<p style="margin-top: 1em">manual <br>
Total number of vacuum workers started by user.</p>

<p style="margin-top: 1em">wraparound <br>
Total number of workers currently running and perform anti
wraparound vacuum.</p>

<p style="margin-top: 1em">avw_maxtime <br>
Execution time of the oldest autovacuum or user-started
worker.</p>

<p style="margin-top: 1em">Statements activity <br>
Line 2-4 shows statements activity. Some information
provided by pg_stat_statements contrib module which not
installed by default. For proper work, pg_stat_statements
must <br>
be installed into database. For more information see URLS
sections below.</p>

<p style="margin-top: 1em">stmt/s <br>
Number of statements per second. This value calculated as
difference between two values within 1 second interval. <br>
Used query: SELECT sum(calls) FROM pg_stat_statements;</p>

<p style="margin-top: 1em">stmt_avgtime <br>
Average queries duration in milisecond. Result defines here
present the average time since the start of statistics
collection. Therefore, to obtain a result that <br>
corresponds to the current time, pg_stat_statements
statistics should be periodically reset (once a day, for
example). <br>
Used query: SELECT (sum(total_time) /
sum(calls))::numeric(6,3) AS avg_query <br>
FROM pg_stat_statements;</p>

<p style="margin-top: 1em">xact_maxtime <br>
Execution time of the oldest transaction (not a query or
session). <br>
Used query: SELECT
coalesce(date_trunc(&rsquo;seconds&rsquo;, max(now() -
xact_start)), &rsquo;00:00:00&rsquo;) <br>
FROM pg_stat_activity;</p>

<p style="margin-top: 1em">CMDLINE WINDOW <br>
Cmdline window used for displaying diagnostic messages or
when need additional input from user.</p>

<p style="margin-top: 1em">DBRESULT WINDOW <br>
Dbresult window used for displaying statistics from
PostgreSQL. Here pgcenter uses statistics contexts, which
determines what type of statistics will be shown.</p>

<p style="margin-top: 1em">pg_stat_database context <br>
Statistics from pg_stat_database system view which show
database-wide statistics. Note, when new database created or
existing database dropped, pgcenter resets it&rsquo;s own
<br>
counters (not postgresql statistics counters) to zero. <br>
Used query: SELECT <br>
datname, <br>
xact_commit AS commit, xact_rollback AS rollback, <br>
blks_read AS reads, blks_hit AS hits, <br>
tup_returned AS returned, tup_fetched AS fetched, <br>
tup_inserted AS inserts, tup_updated AS updates, tup_deleted
AS deletes, <br>
conflicts, deadlocks, <br>
temp_files AS tmp_files, temp_bytes AS tmp_bytes, <br>
blk_read_time AS read_t, blk_write_time AS write_t <br>
FROM pg_stat_database ORDER BY datname;</p>

<p style="margin-top: 1em">datname <br>
Name of this database.</p>

<p style="margin-top: 1em">commit <br>
Number of transactions per second in this database that have
been committed.</p>

<p style="margin-top: 1em">rollback <br>
Number of transactions per second in this database that have
been rolled back.</p>

<p style="margin-top: 1em">reads <br>
Number of disk blocks read per second in this database.</p>

<p style="margin-top: 1em">hits <br>
Number of times per second when disk blocks were found
already in the buffer cache, so that a read was not
necessary (this only includes hits in the PostgreSQL
buf&acirc; <br>
fer cache, not the operating system&rsquo;s file system
cache).</p>

<p style="margin-top: 1em">returned <br>
Number of rows returned by queries in this database (per
second).</p>

<p style="margin-top: 1em">fetched <br>
Number of rows fetched by queries in this database (per
second).</p>

<p style="margin-top: 1em">inserts <br>
Number of rows inserted by queries in this database (per
second).</p>

<p style="margin-top: 1em">updates <br>
Number of rows updated by queries in this database (per
second).</p>

<p style="margin-top: 1em">deletes <br>
Number of rows deleted by queries in this database (per
second).</p>

<p style="margin-top: 1em">conflicts <br>
Number of queries per second canceled due to conflicts with
recovery in this database. Conflicts occur only on standby
servers.</p>

<p style="margin-top: 1em">deadlocks <br>
Number of deadlocks detected in this database (per
second).</p>

<p style="margin-top: 1em">tmp_files <br>
Number of temporary files created by queries in this
database (pre second). All temporary files are counted,
regardless of why the temporary file was created (e.g., <br>
sorting or hashing), and regardless of the log_temp_files
setting.</p>

<p style="margin-top: 1em">tmp_bytes <br>
Total amount of data written to temporary files by queries
in this database (per second). All temporary files are
counted, regardless of why the temporary file was <br>
created, and regardless of the log_temp_files setting.</p>

<p style="margin-top: 1em">read_t <br>
Time spent reading data file blocks by backends in this
database, in milliseconds.</p>

<p style="margin-top: 1em">write_t <br>
Time spent writing data file blocks by backends in this
database, in milliseconds.</p>

<p style="margin-top: 1em">pg_stat_replication context <br>
Statistics from pg_stat_replication system view which will
contain one row per WAL sender process, showing statistics
about replication to that sender&rsquo;s connected standby
<br>
server. Only directly connected standbys are listed; no
information is available about downstream standby servers.
<br>
Used query: SELECT <br>
client_addr AS client, usename AS user, application_name AS
name, <br>
state, sync_state AS mode, <br>

(pg_xlog_location_diff(pg_current_xlog_location(),sent_location)
/ 1024)::int as pending, <br>
(pg_xlog_location_diff(sent_location,write_location) /
1024)::int as write, <br>
(pg_xlog_location_diff(write_location,flush_location) /
1024)::int as flush, <br>
(pg_xlog_location_diff(flush_location,replay_location) /
1024)::int as replay, <br>

(pg_xlog_location_diff(pg_current_xlog_location(),replay_location))::int
/ 1024 as total_lag <br>
FROM pg_stat_replication&quot;</p>

<p style="margin-top: 1em">client <br>
IP address of the client connected to this WAL sender. If
this field is null, it indicates that the client is
connected via a Unix socket on the server machine.</p>

<p style="margin-top: 1em">user <br>
Name of the user logged into this WAL sender process.</p>

<p style="margin-top: 1em">name <br>
Name of the application that is connected to this WAL
sender.</p>

<p style="margin-top: 1em">state <br>
Current WAL sender state.</p>

<p style="margin-top: 1em">mode <br>
Synchronous state of this standby server.</p>

<p style="margin-top: 1em">pending <br>
Difference between XLOG current position and XLOG sent
position, shows amount of XLOG in kilobytes which should be
sent over network.</p>

<p style="margin-top: 1em">write <br>
Difference between XLOG sent position and XLOG write
position, shows amount of XLOG in kilobytes which sent over
network, but not written yet on remote host.</p>

<p style="margin-top: 1em">flush <br>
Difference between XLOG write position and XLOG flush
position, shows amount of XLOG in kilobytes which written,
but not flushed yet on remote host.</p>

<p style="margin-top: 1em">replay <br>
Difference between XLOG flush position and XLOG replay
position, shows amount of XLOG in kilobytes which flushed,
but not replayed yet on remote host.</p>

<p style="margin-top: 1em">total_lag <br>
Difference between XLOG current position on the master
server and XLOG replay position onremote host, shows the
total amount of XLOG in kilobytes, the standby is <br>
behind.</p>

<p style="margin-top: 1em">pg_stat_tables context <br>
Statistics from pg_stat_user_tables or pg_stat_all_tables
views which will contain one row for each table in the
current database (including TOAST tables), showing
statis&acirc; <br>
tics about accesses to that specific table.
pg_stat_user_tables used by default, and pgcenter can be
switched to pg_stat_all_tables using , hotkey. <br>
Used query: SELECT <br>
schemaname || &rsquo;.&rsquo; || relname AS relation, <br>
seq_scan, seq_tup_read AS seq_read, <br>
idx_scan, idx_tup_fetch AS idx_fetch, <br>
n_tup_ins AS inserts, n_tup_upd AS updates, <br>
n_tup_del AS deletes, n_tup_hot_upd AS hot_updates, <br>
n_live_tup AS live, n_dead_tup AS dead <br>
FROM pg_stat_user_tables ORDER BY 1;</p>

<p style="margin-top: 1em">relation <br>
Name of this table including schemaname.</p>

<p style="margin-top: 1em">seq_scan <br>
Number of sequential scans initiated on this table (per
second).</p>

<p style="margin-top: 1em">seq_read <br>
Number of live rows fetched by sequential scans (per
second).</p>

<p style="margin-top: 1em">idx_scan <br>
Number of index scans initiated on this table (per
second).</p>

<p style="margin-top: 1em">idx_fetch <br>
Number of live rows fetched by index scans (per second).</p>

<p style="margin-top: 1em">inserts <br>
Number of rows inserted (per second).</p>

<p style="margin-top: 1em">updates <br>
Number of rows updated (per second).</p>

<p style="margin-top: 1em">deletes <br>
Number of rows deleted (per second).</p>

<p style="margin-top: 1em">hot_updates <br>
Number of rows HOT updated means with no separate index
update required (per second).</p>

<p style="margin-top: 1em">live <br>
Estimated number of live rows (per second).</p>

<p style="margin-top: 1em">dead <br>
Estimated number of dead rows (per second).</p>

<p style="margin-top: 1em">pg_statio_tables context <br>
Show statistics from pg_statio_user_tables or
pg_statio_all_tables views which showing statistics about
I/O on that specific table in the current database.
pg_sta&acirc; <br>
tio_user_tables used by default, and pgcenter can be
switched to pg_statio_all_tables using , hotkey. <br>
Used query: SELECT <br>
schemaname ||&rsquo;.&rsquo;|| relname AS relation, <br>
heap_blks_read * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
heap_read, <br>
heap_blks_hit * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
heap_hit, <br>
idx_blks_read * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
idx_read, <br>
idx_blks_hit * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
idx_hit, <br>
toast_blks_read * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
toast_read, <br>
toast_blks_hit * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
toast_hit, <br>
tidx_blks_read * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
tidx_read, <br>
tidx_blks_hit * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
tidx_hit <br>
FROM pg_statio_user_tables ORDER BY 1;</p>

<p style="margin-top: 1em">relation <br>
Name of this table including schemaname.</p>

<p style="margin-top: 1em">heap_read <br>
Number of data read from disk related to this table in
kilobytes per second.</p>

<p style="margin-top: 1em">heap_hit <br>
Number of buffer hits in this table in kilobytes per
second.</p>

<p style="margin-top: 1em">idx_read <br>
Number of data read from disk in kilobytes per second
related to all indexes on this table.</p>

<p style="margin-top: 1em">idx_hit <br>
Number of buffer hits in all indexes on this table in
kilobytes per second.</p>

<p style="margin-top: 1em">toast_read <br>
Number of data read from disk in kilobytes per second from
this table&rsquo;s TOAST table (if any).</p>

<p style="margin-top: 1em">toast_hit <br>
Number of buffer hits in this table&rsquo;s TOAST table (if
any) in kilobytes per second.</p>

<p style="margin-top: 1em">tidx_read <br>
Number of data read from disk in kilobytes per second from
this table&rsquo;s TOAST table indexes (if any).</p>

<p style="margin-top: 1em">tidx_hit <br>
Number of buffer hits in this table&rsquo;s TOAST table
indexes (if any) in kilobytes per second.</p>

<p style="margin-top: 1em">pg_stat_indexes context <br>
Show statistics from pg_stat_user_indexes and
pg_statio_user_indexes (or pg_stat_all_indexes and
pg_statio_all_indexes). The pg_stat_user_indexes view will
contain one <br>
row for each index in the current database, showing
statistics about accesses to that specific index.
pg_statio_user_indexes view will contain one row for each
index in <br>
the current database, showing statistics about I/O on that
specific index.</p>

<p style="margin-top: 1em">Note: Indexes can be used via
either simple index scans or &quot;bitmap&quot; index scans.
In a bitmap scan the output of several indexes can be
combined via AND or OR rules, so it <br>
is difficult to associate individual heap row fetches with
specific indexes when a bitmap scan is used. Therefore, a
bitmap scan increments the <br>
pg_stat_all_indexes.idx_tup_read count(s) for the index(es)
it uses, and it increments the
pg_stat_all_tables.idx_tup_fetch count for the table, but it
does not affect <br>
pg_stat_all_indexes.idx_tup_fetch. The idx_tup_read and
idx_tup_fetch counts can be different even without any use
of bitmap scans, because idx_tup_read counts index <br>
entries retrieved from the index while idx_tup_fetch counts
live rows fetched from the table. The latter will be less if
any dead or not-yet-committed rows are fetched <br>
using the index, or if any heap fetches are avoided by means
of an index-only scan. <br>
Used query: SELECT <br>
s.schemaname ||&rsquo;.&rsquo;|| s.relname as relation,
s.indexrelname AS index, <br>
s.idx_scan, s.idx_tup_read, s.idx_tup_fetch, <br>
i.idx_blks_read * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
idx_read, <br>
i.idx_blks_hit * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
idx_hit <br>
FROM <br>
pg_stat_user_indexes s, <br>
pg_statio_user_indexes i <br>
WHERE s.indexrelid = i.indexrelid ORDER BY 1;</p>

<p style="margin-top: 1em">relation <br>
Name of the table for this index including schemaname.</p>

<p style="margin-top: 1em">index <br>
Name of this index.</p>

<p style="margin-top: 1em">idx_scan <br>
Number of index scans per second initiated on this
index.</p>

<p style="margin-top: 1em">idx_tup_read <br>
Number of index entries returned per second by scans on this
index.</p>

<p style="margin-top: 1em">idx_tup_fetch <br>
Number of live table rows fetched per second by simple index
scans using this index.</p>

<p style="margin-top: 1em">idx_read <br>
Number of disk blocks read per second from this index.</p>

<p style="margin-top: 1em">idx_hit <br>
Number of buffer hits per second in this index.</p>

<p style="margin-top: 1em">pg_tables_size context <br>
Show statistics about tables sizes. For taking information
about size of relations use pg_stat_user_tables (or
pg_stat_all_tables) view, pg_class system catalog and <br>
pg_relation_size(), pg_total_relation_size() functions. <br>
Used query: SELECT <br>
s.schemaname ||&rsquo;.&rsquo;|| s.relname AS relation, <br>
pg_total_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024 AS total_size, <br>
pg_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024 AS rel_size, <br>
(pg_total_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024) - <br>
(pg_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024) AS idx_size, <br>
pg_total_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024 AS total_change, <br>
pg_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024 AS rel_change, <br>
(pg_total_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024) - <br>
(pg_relation_size((s.schemaname ||&rsquo;.&rsquo;||
s.relname)::regclass) / 1024) AS idx_change <br>
FROM pg_stat_user_tables s, pg_class c WHERE s.relid = c.oid
ORDER BY 1;</p>

<p style="margin-top: 1em">relation <br>
Name of this table including schema name.</p>

<p style="margin-top: 1em">total_size <br>
Total size of relation including indexes, in kilobytes.</p>

<p style="margin-top: 1em">rel_size <br>
Size of relation without indexes, in kilobytes.</p>

<p style="margin-top: 1em">idx_size <br>
Size of all indexes of relation, in kilobytes.</p>

<p style="margin-top: 1em">total_change <br>
Relation and indexes size changes in kilobytes per
second.</p>

<p style="margin-top: 1em">rel_change <br>
Only relation size changes in kilobytes per second.</p>

<p style="margin-top: 1em">idx_change <br>
Only indexes size changes in kilobytes per second.</p>

<p style="margin-top: 1em">pg_stat_activity context <br>
Show process activity from pg_stat_activity which have one
row per server process, showing information related to the
current activity of that process. Show process which <br>
runs too long. Default threshold is 10 seconds, and can be
changed with A hotkey. Idle process not displaying. Note:
The waiting and state columns are independent. If a <br>
backend is in the active state, it may or may not be
waiting. If the state is active and waiting is true, it
means that a query is being executed, but is being blocked
by <br>
a lock somewhere in the system. <br>
Used query: SELECT <br>
pid, client_addr AS cl_addr, client_port AS cl_port, <br>
datname, usename, state, waiting, <br>
date_trunc(&rsquo;seconds&rsquo;, clock_timestamp() -
xact_start) AS xact_age, <br>
date_trunc(&rsquo;seconds&rsquo;, clock_timestamp() -
query_start) AS query_age, <br>
date_trunc(&rsquo;seconds&rsquo;, clock_timestamp() -
state_change) AS change_age, <br>
query <br>
FROM pg_stat_activity <br>
WHERE ((clock_timestamp() - xact_start) &gt;
&rsquo;00:00:10&rsquo;::interval <br>
OR (clock_timestamp() - query_start) &gt;
&rsquo;00:00:10&rsquo;::interval) <br>
AND state &lt;&gt; &rsquo;idle&rsquo; AND pid &lt;&gt;
pg_backend_pid() <br>
ORDER BY COALESCE(xact_start, query_start);</p>

<p style="margin-top: 1em">pid <br>
Process ID of this backend.</p>

<p style="margin-top: 1em">cl_addr <br>
IP address of the client connected to this backend. If this
field is null, it indicates either that the client is
connected via a Unix socket on the server machine <br>
or that this is an internal process such as autovacuum.</p>

<p style="margin-top: 1em">cl_port <br>
TCP port number that the client is using for communication
with this backend, or -1 if a Unix socket is used.</p>

<p style="margin-top: 1em">datname <br>
Name of the database this backend is connected to.</p>

<p style="margin-top: 1em">usename <br>
Name of the user logged into this backend.</p>

<p style="margin-top: 1em">state <br>
Current overall state of this backend. Possible values
are:</p>

<p style="margin-top: 1em">active <br>
The backend is executing a query.</p>

<p style="margin-top: 1em">idle <br>
The backend is waiting for a new client command.</p>

<p style="margin-top: 1em">idle in transaction <br>
The backend is in a transaction, but is not currently
executing a query.</p>

<p style="margin-top: 1em">idle in transaction (aborted)
<br>
This state is similar to idle in transaction, except one of
the statements in the transaction caused an error.</p>

<p style="margin-top: 1em">fastpath function call <br>
The backend is executing a fast-path function.</p>

<p style="margin-top: 1em">disabled <br>
This state is reported if track_activities is disabled in
this backend.</p>

<p style="margin-top: 1em">waiting <br>
True if this backend is currently waiting on a lock.</p>

<p style="margin-top: 1em">xact_age <br>
Age of transaction started within current process, or null
if no transaction is active. If the current query is the
first of its transaction, this column is equal <br>
to the query_age column.</p>

<p style="margin-top: 1em">query_age <br>
Age of currently active query, or if state is not active,
when the last query was started.</p>

<p style="margin-top: 1em">change_age <br>
Age since when the state was last changed.</p>

<p style="margin-top: 1em">query <br>
Text of this backend&rsquo;s most recent query. If state is
active this field shows the currently executing query. In
all other states, it shows the last query that was <br>
executed.</p>

<p style="margin-top: 1em">pg_stat_functions context <br>
Show statistics from pg_stat_user_function view which
contain one row for each tracked function, showing
statistics about executions of that function. The
track_functions <br>
parameter in postgresql.conf controls exactly which
functions are tracked. <br>
Used query: SELECT <br>
funcid, schemaname ||&rsquo;.&rsquo;||funcname AS function,
<br>
calls AS total_calls, calls AS calls, <br>
date_trunc(&rsquo;seconds&rsquo;, total_time / 1000 *
&rsquo;1 second&rsquo;::interval) AS total_t, <br>
date_trunc(&rsquo;seconds&rsquo;, self_time / 1000 *
&rsquo;1 second&rsquo;::interval) AS self_t, <br>
round((total_time / calls)::numeric, 4) AS avg_t, <br>
round((self_time / calls)::numeric, 4) AS avg_self_t <br>
FROM pg_stat_user_functions ORDER BY x DESC;</p>

<p style="margin-top: 1em">funcid <br>
Unique OID of a function.</p>

<p style="margin-top: 1em">function <br>
Name of this function, including schema name.</p>

<p style="margin-top: 1em">total_calls <br>
Number of times this function has been called.</p>

<p style="margin-top: 1em">calls <br>
Number of times this function has been called per
second.</p>

<p style="margin-top: 1em">total_t <br>
Total time spent in this function and all other functions
called by it.</p>

<p style="margin-top: 1em">self_t <br>
Total time spent in this function itself, not including
other functions called by it.</p>

<p style="margin-top: 1em">avg_t <br>
Average time spent in this function and all other functions
called by it, in milliseconds.</p>

<p style="margin-top: 1em">avg_self_t <br>
Average time spent in this function itself, not including
other functions called by it, in milliseconds.</p>

<p style="margin-top: 1em">pg_stat_statements_timing
context <br>
Show timing statistics from pg_stat_statements module which
tracking execution statistics of all SQL statements executed
by a server. The module must be loaded by adding <br>
pg_stat_statements to shared_preload_libraries in
postgresql.conf. This means that a server restart is needed
to add or remove the module. When module loaded, <br>
pg_stat_statement extension must be installed in target
database. For more information see
http://www.postgresql.org/docs/9.4/static/pgstatstatements.html.
Additionally <br>
used pg_authid and pg_database views. Different versions of
the PostgreSQL may have different number of fields. <br>
Used query: SELECT <br>
a.rolname AS user, d.datname AS database, <br>
date_trunc(&rsquo;seconds&rsquo;, round(sum(p.total_time)) /
1000 * &rsquo;1 second&rsquo;::interval) AS t_all_t, <br>
date_trunc(&rsquo;seconds&rsquo;,
round(sum(p.blk_read_time)) / 1000 * &rsquo;1
second&rsquo;::interval) AS t_read_t, <br>
date_trunc(&rsquo;seconds&rsquo;,
round(sum(p.blk_write_time)) / 1000 * &rsquo;1
second&rsquo;::interval) AS t_write_t, <br>
date_trunc(&rsquo;seconds&rsquo;, round((sum(p.total_time) -
(sum(p.blk_read_time) + sum(p.blk_write_time)))) / 1000 *
&rsquo;1 second&rsquo;::interval) AS tot_cpu_t, <br>
round(sum(p.total_time)) AS all_t, <br>
round(sum(p.blk_read_time)) AS read_t, <br>
round(sum(p.blk_write_time)) AS write_t, <br>
round((sum(p.total_time) - (sum(p.blk_read_time) +
sum(p.blk_write_time)))) AS cpu_t, <br>
sum(p.calls) AS calls, <br>
left(md5(d.datname || a.rolname || p.query ), 10) AS
queryid, <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace(p.query, <br>
E&rsquo;\?(::[a-zA-Z_]+)?( *, *\?(::[a-zA-Z_]+)?)+&rsquo;,
&rsquo;?&rsquo;, &rsquo;g&rsquo;), <br>
E&rsquo;\$[0-9]+(::[a-zA-Z_]+)?( *,
*\$[0-9]+(::[a-zA-Z_]+)?)*&rsquo;, &rsquo;$N&rsquo;,
&rsquo;g&rsquo;), <br>
E&rsquo;--.*$&rsquo;, &rsquo;&rsquo;, &rsquo;ng&rsquo;),
<br>
E&rsquo;/\*.*?\*&rsquo;, &rsquo;&rsquo;, &rsquo;g&rsquo;),
<br>
E&rsquo;\s+&rsquo;, &rsquo; &rsquo;, &rsquo;g&rsquo;) AS
query <br>
FROM pg_stat_statements p <br>
JOIN pg_authid a ON a.oid=p.userid <br>
JOIN pg_database d ON d.oid=p.dbid <br>
WHERE d.datname != &rsquo;postgres&rsquo; AND calls &gt; 50
<br>
GROUP BY a.rolname, d.datname, query;</p>

<p style="margin-top: 1em">user <br>
User who executed the statement.</p>

<p style="margin-top: 1em">database <br>
Database in which the statement was executed.</p>

<p style="margin-top: 1em">t_all_t <br>
Total time spent in the statement since last stats
reset.</p>

<p style="margin-top: 1em">t_read_t <br>
Total time the statement spent reading blocks (if
track_io_timing is enabled, otherwise zero) since last stats
reset.</p>

<p style="margin-top: 1em">t_write_t <br>
Total time the statement spent writing blocks (if
track_io_timing is enabled, otherwise zero) since last stats
reset.</p>

<p style="margin-top: 1em">t_cpu_t <br>
Total time the statement spent in CPU cycling (if
track_io_timing is enabled, otherwise equals total_t) since
last stats reset.</p>

<p style="margin-top: 1em">all_t <br>
Current time spent in the statement in ms.</p>

<p style="margin-top: 1em">read_t <br>
Current time the statement spent reading blocks (if
track_io_timing is enabled, otherwise zero) in ms.</p>

<p style="margin-top: 1em">write_t <br>
Total time the statement spent writing blocks (if
track_io_timing is enabled, otherwise zero) in ms.</p>

<p style="margin-top: 1em">cpu_t <br>
Total time the statement spent in CPU cycling, (if
track_io_timing is enabled, otherwise equals total_t) in
ms.</p>

<p style="margin-top: 1em">calls <br>
Current number of query calls.</p>

<p style="margin-top: 1em">queryid <br>
Query ID generated with MD5 hash function and truncated to
10 symbols. Hash based on username, dbname and query
text.</p>

<p style="margin-top: 1em">query <br>
Text of a representative statement.</p>

<p style="margin-top: 1em">pg_stat_statements_general
context <br>
Show general statistics about rows and calls from
pg_stat_statements module which tracking execution
statistics of all SQL statements executed by a server. The
module must <br>
be loaded by adding pg_stat_statements to
shared_preload_libraries in postgresql.conf. This means that
a server restart is needed to add or remove the module. When
module <br>
loaded, pg_stat_statement extension must be installed in
target database. For more information see
http://www.postgresql.org/docs/9.4/static/pgstatstatements.html.
Addi&acirc; <br>
tionally used pg_authid and pg_database views. <br>
Used query: SELECT <br>
a.rolname AS user, d.datname AS database, <br>
sum(p.calls) AS t_calls, sum(p.rows) as t_rows, <br>
sum(p.calls) AS calls, sum(p.rows) as rows, <br>
left(md5(d.datname || a.rolname || p.query ), 10) AS
queryid, <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace(p.query, <br>
E&rsquo;\?(::[a-zA-Z_]+)?( *, *\?(::[a-zA-Z_]+)?)+&rsquo;,
&rsquo;?&rsquo;, &rsquo;g&rsquo;), <br>
E&rsquo;\$[0-9]+(::[a-zA-Z_]+)?( *,
*\$[0-9]+(::[a-zA-Z_]+)?)*&rsquo;, &rsquo;$N&rsquo;,
&rsquo;g&rsquo;), <br>
E&rsquo;--.*$&rsquo;, &rsquo;&rsquo;, &rsquo;ng&rsquo;),
<br>
E&rsquo;/\*.*?\*&rsquo;, &rsquo;&rsquo;, &rsquo;g&rsquo;),
<br>
E&rsquo;\s+&rsquo;, &rsquo; &rsquo;, &rsquo;g&rsquo;) AS
query <br>
FROM pg_stat_statements p <br>
JOIN pg_authid a ON a.oid=p.userid <br>
JOIN pg_database d ON d.oid=p.dbid <br>
WHERE d.datname != &rsquo;postgres&rsquo; AND calls &gt; 50
<br>
GROUP BY a.rolname, d.datname, query;</p>

<p style="margin-top: 1em">user <br>
User who executed the statement.</p>

<p style="margin-top: 1em">database <br>
Database in which the statement was executed.</p>

<p style="margin-top: 1em">t_calls <br>
Total number of times the statement was executed.</p>

<p style="margin-top: 1em">t_rows <br>
Total number of rows retrieved or affected by the
statement.</p>

<p style="margin-top: 1em">calls <br>
Number of times the statement was executed per second.</p>

<p style="margin-top: 1em">rows <br>
Number of rows retrieved or affected by the statement per
second.</p>

<p style="margin-top: 1em">queryid <br>
Query ID generated with MD5 hash function and truncated to
10 symbols. Hash based on username, dbname and query
text.</p>

<p style="margin-top: 1em">query <br>
Text of a representative statement</p>

<p style="margin-top: 1em">pg_stat_statements_io context
<br>
Show statistics about buffer input/output from
pg_stat_statements module which tracking execution
statistics of all SQL statements executed by a server. The
module must be <br>
loaded by adding pg_stat_statements to
shared_preload_libraries in postgresql.conf. This means that
a server restart is needed to add or remove the module. When
module <br>
loaded, pg_stat_statement extension must be installed in
target database. For more information see
http://www.postgresql.org/docs/9.4/static/pgstatstatements.html.
Addi&acirc; <br>
tionally used pg_authid and pg_database views. <br>
Used query: SELECT <br>
a.rolname AS user, d.datname AS database, <br>
(sum(p.shared_blks_hit) + sum(p.local_blks_hit)) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as t_hits, <br>
(sum(p.shared_blks_read) + sum(p.local_blks_read)) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as t_reads, <br>
(sum(p.shared_blks_dirtied) + sum(p.local_blks_dirtied))
<br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as t_dirtied, <br>
(sum(p.shared_blks_written) + sum(p.local_blks_written))
<br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as t_written, <br>
(sum(p.shared_blks_hit) + sum(p.local_blks_hit)) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as hits, <br>
(sum(p.shared_blks_read) + sum(p.local_blks_read)) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as reads, <br>
(sum(p.shared_blks_dirtied) + sum(p.local_blks_dirtied))
<br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as dirtied, <br>
(sum(p.shared_blks_written) + sum(p.local_blks_written))
<br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as written, <br>
sum(p.calls) AS calls, <br>
left(md5(d.datname || a.rolname || p.query ), 10) AS
queryid, <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace(p.query, <br>
E&rsquo;\?(::[a-zA-Z_]+)?( *, *\?(::[a-zA-Z_]+)?)+&rsquo;,
&rsquo;?&rsquo;, &rsquo;g&rsquo;), <br>
E&rsquo;\$[0-9]+(::[a-zA-Z_]+)?( *,
*\$[0-9]+(::[a-zA-Z_]+)?)*&rsquo;, &rsquo;$N&rsquo;,
&rsquo;g&rsquo;), <br>
E&rsquo;--.*$&rsquo;, &rsquo;&rsquo;, &rsquo;ng&rsquo;),
<br>
E&rsquo;/\*.*?\*&rsquo;, &rsquo;&rsquo;, &rsquo;g&rsquo;),
<br>
E&rsquo;\s+&rsquo;, &rsquo; &rsquo;, &rsquo;g&rsquo;) AS
query <br>
FROM pg_stat_statements p <br>
JOIN pg_authid a ON a.oid=p.userid <br>
JOIN pg_database d ON d.oid=p.dbid <br>
WHERE d.datname != &rsquo;postgres&rsquo; AND calls &gt; 50
<br>
GROUP BY a.rolname, d.datname, query;</p>

<p style="margin-top: 1em">user <br>
User who executed the statement.</p>

<p style="margin-top: 1em">database <br>
Database in which the statement was executed.</p>

<p style="margin-top: 1em">t_hits <br>
Total amount of shared and local data hits from cache by the
statement since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">t_reads <br>
Total amount of shared and local data read by the statement
since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">t_dirtied <br>
Total amount of shared and local data dirtied by the
statement since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">t_written <br>
Total amount of shared and local data written by the
statement since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">hits <br>
Amount of shared and local data hits from cache by the
statement per interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">reads <br>
Amount of shared and local data read by the statement per
interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">dirtied <br>
Amount of shared and local data dirtied by the statement per
interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">written <br>
Amount of shared and local data written by the statement per
interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">calls <br>
Number of rows retrieved or affected by the statement per
interval.</p>

<p style="margin-top: 1em">queryid <br>
Query ID generated with MD5 hash function and truncated to
10 symbols. Hash based on username, dbname and query
text.</p>

<p style="margin-top: 1em">query <br>
Text of a representative statement</p>

<p style="margin-top: 1em">pg_stat_statements_temp context
<br>
Show statistics about buffers input/output related with
temporary buffers. Stats read from pg_stat_statements module
which tracking execution statistics of all SQL state&acirc;
<br>
ments executed by a server. The module must be loaded by
adding pg_stat_statements to shared_preload_libraries in
postgresql.conf. This means that a server restart is <br>
needed to add or remove the module. When module loaded,
pg_stat_statement extension must be installed in target
database. For more information see http://www.post&acirc;
<br>
gresql.org/docs/9.4/static/pgstatstatements.html.
Additionally used pg_authid and pg_database views. <br>
Used query: SELECT <br>
a.rolname AS user, d.datname AS database, <br>
sum(p.temp_blks_read) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as t_tmp_read, <br>
sum(p.temp_blks_written) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as t_tmp_write, <br>
sum(p.temp_blks_read) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as tmp_read, <br>
sum(p.temp_blks_written) <br>
* (SELECT current_setting(&rsquo;block_size&rsquo;)::int /
1024) as tmp_write, <br>
sum(p.calls) AS calls, <br>
left(md5(d.datname || a.rolname || p.query ), 10) AS
queryid, <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace(p.query, <br>
E&rsquo;\?(::[a-zA-Z_]+)?( *, *\?(::[a-zA-Z_]+)?)+&rsquo;,
&rsquo;?&rsquo;, &rsquo;g&rsquo;), <br>
E&rsquo;\$[0-9]+(::[a-zA-Z_]+)?( *,
*\$[0-9]+(::[a-zA-Z_]+)?)*&rsquo;, &rsquo;$N&rsquo;,
&rsquo;g&rsquo;), <br>
E&rsquo;--.*$&rsquo;, &rsquo;&rsquo;, &rsquo;ng&rsquo;),
<br>
E&rsquo;/\*.*?\*&rsquo;, &rsquo;&rsquo;, &rsquo;g&rsquo;),
<br>
E&rsquo;\s+&rsquo;, &rsquo; &rsquo;, &rsquo;g&rsquo;) AS
query <br>
FROM pg_stat_statements p <br>
JOIN pg_authid a ON a.oid=p.userid <br>
JOIN pg_database d ON d.oid=p.dbid <br>
WHERE d.datname != &rsquo;postgres&rsquo; AND calls &gt; 50
<br>
GROUP BY a.rolname, d.datname, query;</p>

<p style="margin-top: 1em">user <br>
User who executed the statement.</p>

<p style="margin-top: 1em">database <br>
Database in which the statement was executed.</p>

<p style="margin-top: 1em">t_tmp_read <br>
Total amount of temp data read by the statement since last
stats reset, in Kbytes.</p>

<p style="margin-top: 1em">t_tmp_write <br>
Total amount of temp data written by the statement sice last
stats reset, in Kbytes.</p>

<p style="margin-top: 1em">tmp_read <br>
Amount of temp data read by the statement per interval, in
Kbytes.</p>

<p style="margin-top: 1em">tmp_write <br>
Amount of temp data written by the statement per interval,
in Kbytes.</p>

<p style="margin-top: 1em">calls <br>
Number of times the statement was executed per second.</p>

<p style="margin-top: 1em">queryid <br>
Query ID generated with MD5 hash function and truncated to
10 symbols. Hash based on username, dbname and query
text.</p>

<p style="margin-top: 1em">query <br>
Text of a representative statement</p>

<p style="margin-top: 1em">pg_stat_statements_local context
<br>
Show statistics about local input/output (backends that use
local memory and not shared buffers) from pg_stat_statements
module which tracking execution statistics of all <br>
SQL statements executed by a server. The module must be
loaded by adding pg_stat_statements to
shared_preload_libraries in postgresql.conf. This means that
a server <br>
restart is needed to add or remove the module. When module
loaded, pg_stat_statement extension must be installed in
target database. For more information see <br>

http://www.postgresql.org/docs/9.4/static/pgstatstatements.html.
Additionally used pg_authid and pg_database views. <br>
Used query: SELECT <br>
a.rolname AS user, d.datname AS database, <br>
(sum(p.local_blks_hit)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
t_lo_hits, <br>
(sum(p.local_blks_read)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
t_lo_reads, <br>
(sum(p.local_blks_dirtied)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
t_lo_dirtied, <br>
(sum(p.local_blks_written)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
t_lo_written, <br>
(sum(p.local_blks_hit)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
lo_hits, <br>
(sum(p.local_blks_read)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
lo_reads, <br>
(sum(p.local_blks_dirtied)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
lo_dirtied, <br>
(sum(p.local_blks_written)) * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) as
lo_written, <br>
sum(p.calls) AS calls, <br>
left(md5(d.datname || a.rolname || p.query ), 10) AS
queryid, <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace( <br>
regexp_replace(p.query, <br>
E&rsquo;\?(::[a-zA-Z_]+)?( *, *\?(::[a-zA-Z_]+)?)+&rsquo;,
&rsquo;?&rsquo;, &rsquo;g&rsquo;), <br>
E&rsquo;\$[0-9]+(::[a-zA-Z_]+)?( *,
*\$[0-9]+(::[a-zA-Z_]+)?)*&rsquo;, &rsquo;$N&rsquo;,
&rsquo;g&rsquo;), <br>
E&rsquo;--.*$&rsquo;, &rsquo;&rsquo;, &rsquo;ng&rsquo;),
<br>
E&rsquo;/\*.*?\*&rsquo;, &rsquo;&rsquo;, &rsquo;g&rsquo;),
<br>
E&rsquo;\s+&rsquo;, &rsquo; &rsquo;, &rsquo;g&rsquo;) AS
query <br>
FROM pg_stat_statements p <br>
JOIN pg_authid a ON a.oid=p.userid <br>
JOIN pg_database d ON d.oid=p.dbid <br>
WHERE d.datname != &rsquo;postgres&rsquo; AND calls &gt; 50
<br>
GROUP BY a.rolname, d.datname, query;</p>

<p style="margin-top: 1em">user <br>
User who executed the statement.</p>

<p style="margin-top: 1em">database <br>
Database in which the statement was executed.</p>

<p style="margin-top: 1em">t_lo_hits <br>
Total amount of data hits from backends local memory by the
statement since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">t_lo_reads <br>
Total amount of data read from backends local memory by the
statement since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">t_lo_dirtied <br>
Total amount of data dirtied in backends local memory by the
statement since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">t_lo_written <br>
Total amount of data written to backends local memory by the
statement since stats reset, in Kbytes.</p>

<p style="margin-top: 1em">lo_hits <br>
Amount of data hits from backends local memory by the
statement per interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">lo_reads <br>
Amount of data read from backends local memory by the
statement per interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">lo_dirtied <br>
Amount of data dirtied in backends local memory by the
statement per interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">lo_written <br>
Amount of data written to backends local memory by the
statement per interval (default 1 second), in Kbytes.</p>

<p style="margin-top: 1em">calls <br>
Number of rows retrieved or affected by the statement per
interval.</p>

<p style="margin-top: 1em">queryid <br>
Query ID generated with MD5 hash function and truncated to
10 symbols. Hash based on username, dbname and query
text.</p>

<p style="margin-top: 1em">query <br>
Text of a representative statement</p>

<p style="margin-top: 1em">pg_stat_progress_vacuum context
<br>
Whenever VACUUM is running, the pg_stat_progress_vacuum view
will contain one row for each backend (including autovacuum
worker processes) that is currently vacuuming. The <br>
tables below describe the information that will be reported
and provide information about how to interpret it. Progress
reporting is not currently supported for VACUUM <br>
FULL and backends running VACUUM FULL will not be listed in
this view. This statistics are available since PostgreSQL
9.6, for more information see https://www.post&acirc; <br>
gresql.org/docs/9.6/static/progress-reporting.html.
Additionally used pg_stat_activity view. <br>
Used query: <br>
SELECT <br>
a.pid, <br>
date_trunc(&rsquo;seconds&rsquo;, clock_timestamp() -
xact_start) AS xact_age, <br>
v.datname, v.relid::regclass AS relation, <br>
a.state, v.phase, <br>
v.heap_blks_total * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
total, <br>
v.heap_blks_scanned * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
scanned, <br>
v.heap_blks_vacuumed * (SELECT
current_setting(&rsquo;block_size&rsquo;)::int / 1024) AS
vacuumed, <br>
a.wait_event_type AS wait_etype, a.wait_event, <br>
a.query <br>
FROM pg_stat_progress_vacuum v <br>
JOIN pg_stat_activity a ON v.pid = a.pid <br>
ORDER BY COALESCE(a.xact_start, a.query_start)</p>

<p style="margin-top: 1em">pid <br>
Process ID of vacuum.</p>

<p style="margin-top: 1em">xact_age <br>
Age of vacuum task.</p>

<p style="margin-top: 1em">datname <br>
Database name where vacuum worker is connected.</p>

<p style="margin-top: 1em">state <br>
Postgres backend state (see pg_stat_activity backends
states).</p>

<p style="margin-top: 1em">phase <br>
Current processing phase of vacuum. See VACUUM phases -
https://www.postgresql.org/docs/9.6/static/progress-reporting.html#VACUUM-PHASES.</p>

<p style="margin-top: 1em">total <br>
Total size of the table in Kbytes. This number is reported
as of the beginning of the scan; size increased during
vacuum will not be (and need not be) shown and <br>
this space will not be visited by this VACUUM.</p>

<p style="margin-top: 1em">scanned <br>
Size of table in Kbytes that is scanned. Because the
visibility map is used to optimize scans, some blocks will
be skipped without inspection; skipped blocks are <br>
included in this total, so that this number will eventually
become equal to total when the vacuum is complete. This
counter only advances when the phase is scanning <br>
heap.</p>

<p style="margin-top: 1em">vacuumed <br>
Size of table in Kbytes that is vacuumed. Unless the table
has no indexes, this counter only advances when the phase is
vacuuming heap. Blocks that contain no dead <br>
tuples are skipped, so the counter may sometimes skip
forward in large increments.</p>

<p style="margin-top: 1em">wait_etype <br>
The type of event for which the backend is waiting, if any;
otherwise NULL.</p>

<p style="margin-top: 1em">wait_event <br>
Wait event name if backend is currently waiting, otherwise
NULL.</p>

<p style="margin-top: 1em">query <br>
Text of a representative statement.</p>

<p style="margin-top: 1em">SUBSCREENS <br>
Subscreens it&rsquo;s a additional screens which presents
auxilary data which not directly related with the PostgreSQL
but may be useful in troubleshoot.</p>

<p style="margin-top: 1em">Logtail subscreen <br>
Opens logfile in subscreen and tail this log. Used only if
pgcenter and PostgreSQL running on the same host. All
multiline log entries truncates to end of line. Requires
<br>
database superuser privileges.</p>

<p style="margin-top: 1em">iostat subscreen <br>
Report input/output statistics for devices and partitions.
The iostat subscreen is used for monitoring system
input/output device loading by observing the time the
devices <br>
are active in relation to their average transfer rates. The
first report generated by the iostat subscreen provides
statistics concerning the time since the system was <br>
booted. Each subsequent report covers the time since the
previous report. Iostat subscreen similar to iostat utility
from sysstat package and /proc/diskstats interface. <br>
For the proper iostat work /proc filesystem must be mounted
for iostat to work. Kernels older than 2.6.x are not
supported.</p>

<p style="margin-top: 1em">Device <br>
Block device registered in a system.</p>

<p style="margin-top: 1em">rrqm/s <br>
The number of read requests merged per second that were
queued to the device.</p>

<p style="margin-top: 1em">wrqm/s <br>
The number of write requests merged per second that were
queued to the device.</p>

<p style="margin-top: 1em">r/s <br>
The number (after merges) of read requests completed per
second for the device.</p>

<p style="margin-top: 1em">w/s <br>
The number (after merges) of write requests completed per
second for the device.</p>

<p style="margin-top: 1em">rMB/s <br>
The number of megabytes read from the device per second.</p>

<p style="margin-top: 1em">wMB/s <br>
The number of megabytes written to the device per
second.</p>

<p style="margin-top: 1em">avgrq-sz <br>
The average size (in sectors) of the requests that were
issued to the device.</p>

<p style="margin-top: 1em">avgqu-sz <br>
The average queue length of the requests that were issued to
the device.</p>

<p style="margin-top: 1em">await <br>
The average time (in milliseconds) for I/O requests issued
to the device to be served. This includes the time spent by
the requests in queue and the time spent ser&acirc; <br>
vicing them.</p>

<p style="margin-top: 1em">r_await <br>
The average time (in milliseconds) for read requests issued
to the device to be served. This includes the time spent by
the requests in queue and the time spent <br>
servicing them.</p>

<p style="margin-top: 1em">w_await <br>
The average time (in milliseconds) for write requests issued
to the device to be served. This includes the time spent by
the requests in queue and the time spent <br>
servicing them.</p>

<p style="margin-top: 1em">%util <br>
Percentage of elapsed time during which I/O requests were
issued to the device (bandwidth utilization for the device).
Device saturation occurs when this value is <br>
close to 100% for devices serving requests serially. But for
devices serving requests in parallel, such as RAID arrays
and modern SSDs, this number does not <br>
reflect their performance limits.</p>

<p style="margin-top: 1em">nicstat subscreen <br>
Print network traffic statistics for all network cards
(NICs), including packets, kilobytes per second, average
packet sizes and more. Nicstat subscreen similar to nicstat
<br>
utility and use /proc/net/dev interface.</p>

<p style="margin-top: 1em">Interface <br>
Network interface registered in a system.</p>

<p style="margin-top: 1em">rMbps <br>
Megabits per interval read (received).</p>

<p style="margin-top: 1em">wMbps <br>
Megabits per interval written (transmitted).</p>

<p style="margin-top: 1em">rPk/s <br>
Packets per interval read (received).</p>

<p style="margin-top: 1em">wPk/s <br>
Packets per interval written (transmitted).</p>

<p style="margin-top: 1em">rAvs <br>
Average size of packets read (received).</p>

<p style="margin-top: 1em">wAvs <br>
Average size of packets written (transmitted).</p>

<p style="margin-top: 1em">IErr <br>
Packets received that could not be processed because they
contained errors.</p>

<p style="margin-top: 1em">OErr <br>
Packets that were not successfully transmitted because of
errors.</p>

<p style="margin-top: 1em">Coll <br>
Ethernet collisions during transmit.</p>

<p style="margin-top: 1em">Sat <br>
Saturation. This the number of errors/second seen for the
interface - an indicator the interface may be approaching
saturation. This statistic is combined from a <br>
number of kernel statistics.</p>

<p style="margin-top: 1em">%rUtil %wUtil <br>
Percentage utilization for bytes read and written,
respectively.</p>

<p style="margin-top: 1em">%Util <br>
Percentage utilization of the interface. For full-duplex
interfaces, this is the greater of rMB/s or wMB/s as a
percentage of the interface speed. For half-duplex <br>
interfaces, rMB/s and wMB/s are summed.</p>

<p style="margin-top: 1em">INTERACTIVE COMMANDS <br>
The global interactive commands are always available main
program mode</p>

<p style="margin-top: 1em">1..8 :Switch screen toggle <br>
Switch between already opened screens. Number of screens
limited by eight.</p>

<p style="margin-top: 1em">d :pg_stat_database toggle <br>
Show statistics from pg_stat_database view. This statistics
includes per database info about commits/rollbacks, returned
and fetched tuples, write operations such as <br>
inserts/deletes/updates, abnormal situations like conflicts
and deadlocks, info about temporary files usage and
read/write timings.</p>

<p style="margin-top: 1em">r :pg_stat_replication toggle
<br>
Show statistics from pg_stat_replication view. Statistics
about streaming replication connections, includes
information about connected standbys and amount of data
which <br>
is sent, written, flushed or replayed on standby servers.
Also available info about replication lag.</p>

<p style="margin-top: 1em">t :pg_stat_tables toggle <br>
Show statistics from pg_stat_user_tables (or
pg_stat_all_tables) view about accesses to that specific
tables. Includes sequential/index scans, number of <br>
inserted/updated/deleted tuples, number of live/dead tuples.
Useful for determine current tables workload. By default,
displayed only user tables, displaying system tables <br>
can be enabled by pressing V.</p>

<p style="margin-top: 1em">T :pg_statio_tables toggle <br>
Show statistics from pg_statio_user_tables (or
pg_statio_all_tables) view about I/O on tables in the
current database. Includes info about reads from disk and
shared buf&acirc; <br>
fers related to tables, their indexes or TOAST. Useful for
determine current tables workload. By default, displayed
only user tables, displaying system tables can be <br>
enabled by pressing V.</p>

<p style="margin-top: 1em">i :pg_stat_indexes toggle <br>
Show statistics from pg_stat_user_indexes and
pg_statio_user_indexes (or pg_stat_all_indexes and
pg_statio_all_indexes) views which showing statistics about
accesses to <br>
that specific indexes and their I/O. Includes info about
number of index scans, number of readen and fetched tuples,
data read from disk or shared buffers. By default, <br>
displayed only user indexes, displaying system indexes can
be enabled by pressing V. Useful for determine index
usage.</p>

<p style="margin-top: 1em">s :pg_tables_size toggle <br>
Show statistics about tables and their indexes sizes. For
taking information about size of relations use
pg_stat_user_tables (or pg_stat_all_tables) view, pg_class
system <br>
catalog and pg_relation_size(), pg_total_relation_size()
functions.</p>

<p style="margin-top: 1em">a :pg_stat_activity toggle <br>
Show statistics about long queries from pg_stat_activity
view. Show information about client (address, port, name,
database), text of query and his state and age. Default <br>
age threshold is 10 seconds, and can be changed with A
hotkey.</p>

<p style="margin-top: 1em">f :pg_stat_functions toggle <br>
Show statistics from pg_stat_user_functions view about
tracked functions and their executions, such as number of
calls and execution time. The track_functions parameter in
<br>
postgresql.conf controls exactly which functions are
tracked.</p>

<p style="margin-top: 1em">v :pg_stat_progress_vacuum
toggle <br>
Show statistics from pg_stat_progress_vacuum view about
vacuum execution progress. Available since PostgreSQL
9.6.</p>

<p style="margin-top: 1em">x :Switch to next
pg_stat_statements screen toggle <br>
Switches between pg_stat_statements screens: timings,
general, input/output, temporary input/output, local
input/output.</p>

<p style="margin-top: 1em">X :Show pg_stat_statements menu
toggle <br>
Open pg_stat_statements menu and allow to choose
pg_stat_statements screen without switching.</p>

<p style="margin-top: 1em">E :Edit configuration files menu
toggle <br>
Open configuration files menu and edit specific config.
Supported editing of postgresql.conf, pg_hba.conf,
pg_ident.conf and recovery.conf. Used only if pgcenter and
Post&acirc; <br>
greSQL running on the same host. Use $EDITOR environment
variable or vi by default. Requires database superuser
privileges.</p>

<p style="margin-top: 1em">C :Show current configuration
toggle <br>
Show current PostgreSQL configuration from pg_settings view.
For viewing all parameters requires database superuser
privileges.</p>

<p style="margin-top: 1em">R :Reload toggle <br>
Reload PostgreSQL service for apply configuration changes.
The pgcenter used pg_reload_conf() function for reloading.
Requires database superuser privileges.</p>

<p style="margin-top: 1em">p :Start psql session toggle
<br>
Start psql session with current connection settings.</p>

<p style="margin-top: 1em">B :Open iostat subscreen toggle
<br>
Open subscreen with iostat which reporting input/output
statistics for devices and partitions. Show statistics from
current host.</p>

<p style="margin-top: 1em">I :Open nicstat subscreen toggle
<br>
Open subscreen with nicstat which reporting network
statistics for all network cards (NICs), including packets,
kilobytes per second, average packet sizes and more.. Show
<br>
statistics from current host.</p>

<p style="margin-top: 1em">L :Open logtail subscreen toggle
<br>
Open subscreen and tail postgresql log. Used only if
pgcenter and PostgreSQL running on the same host. Requires
database superuser privileges.</p>

<p style="margin-top: 1em">l :Open log file toggle <br>
Open logfile with pager. Use $PAGER environment variable or
less by default. Used only if pgcenter and PostgreSQL
running on the same host. Requires database superuser <br>
privileges.</p>

<p style="margin-top: 1em">N :Open new connection toggle
<br>
Open new screen with new connection to PostgreSQL. Specify
host, port, user, dbname options and open new
connection.</p>

<p style="margin-top: 1em">Ctrl+D :Close current connection
toggle <br>
Close current screen and connection.</p>

<p style="margin-top: 1em">W :Write connection options
toggle <br>
Write connection settings into config file. By default is
~/.pgcenterrc is used. If --file=FILENAME argument was used
at pgcenter start, connection settings will be writ&acirc;
<br>
ten at specified file.</p>

<p style="margin-top: 1em">Left, Right :Change sort toggle
<br>
Change column which is used for sort.</p>

<p style="margin-top: 1em">/ :Change sort order toggle <br>
Change sort order, descent or ascent. Descent order used by
default.</p>

<p style="margin-top: 1em">F :Set filtration toggle <br>
Set filter pattern for a column, or reset filtration with
empty value. Note, filter patterns are remebered between tab
and context switches. Filtered column marked with * <br>
symbol. No filtration by default.</p>

<p style="margin-top: 1em">- :Cancel backend toggle <br>
Cancel query execution using backend pid with
pg_cancel_backend() function. This function allowed only
when pg_stat_activity screen enabled by a hotkey. Requires
database <br>
superuser privileges.</p>

<p style="margin-top: 1em">_ :Terminate backend toggle <br>
Terminate process using backend pid with
pg_terminate_backend() function. This function allowed only
when pg_stat_activity screen enabled by a hotkey. Requires
database <br>
superuser privileges.</p>

<p style="margin-top: 1em">Del :Cancel group of backends
toggle <br>
Cancel queries execution in group of backends with
pg_cancel_backend() function. Group of backends determined
using mask which specified by n toggle. Note, queries are
<br>
canceled without confirmation. This function allowed only
when pg_stat_activity screen enabled by a hotkey.
Unprivileged users can cancel their own queries. Superusers
can <br>
cancel any queries. Backend pids which queries will be
canceled are selected from pg_stat_activity view, select
condition determined by mask which can be defined with n
<br>
hotkey.</p>

<p style="margin-top: 1em">Shift+Del :Terminate group of
backends toggle <br>
Terminate queries execution in group of backends with
pg_terminate_backend() function. Group of backends
determined using mask which specified by n toggle. Note,
backends <br>
are terminated without confirmation. This function allowed
only when pg_stat_activity screen enabled by a hotkey.
Unprivileged users can terminate their own backends. <br>
Superusers can terminate any backends. Backend pids which
will be terminated are selected from pg_stat_activity view,
select condition determined by mask which can be <br>
defined with n hotkey.</p>

<p style="margin-top: 1em">n :Set new mask toggle <br>
Set new mask for group cancel/terminate. Type of backends
associated with their states:</p>

<p style="margin-top: 1em">active <br>
Backend which are executing a queries. <br>
Used condition: WHERE state = &rsquo;active&rsquo; AND (
<br>
(clock_timestamp() - xact_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
OR <br>
(clock_timestamp() - query_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
) AND pid &lt;&gt; pg_backend_pid();</p>

<p style="margin-top: 1em">idle <br>
Backends which are do nothing and waiting for a new client
command. <br>
Used confition: WHERE state = &rsquo;idle&rsquo; AND ( <br>
(clock_timestamp() - xact_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
OR <br>
(clock_timestamp() - query_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
) AND pid &lt;&gt; pg_backend_pid();</p>

<p style="margin-top: 1em">idle_in_xact <br>
Includes idle in transaction and idle in transaction:
(aborted) states. Always a bad state. <br>
Used condition: WHERE state IN (&rsquo;idle in transaction
(aborted)&rsquo;, &rsquo;idle in transaction&rsquo;) AND (
<br>
(clock_timestamp() - xact_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
OR <br>
(clock_timestamp() - query_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval) <br>
AND pid &lt;&gt; pg_backend_pid();</p>

<p style="margin-top: 1em">waiting <br>
Backends which are currently waiting on a lock. Long waiting
transactions or statements are bad. <br>
Used condition: WHERE waiting AND ( <br>
(clock_timestamp() - xact_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
OR (clock_timestamp() - query_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
) AND pid &lt;&gt; pg_backend_pid();</p>

<p style="margin-top: 1em">other <br>
backends which are executing a fast-path function call or
with disabled state - when track_activities are disabled in
those backends. <br>
Used condition: WHERE state IN (&rsquo;fastpath function
call&rsquo;, &rsquo;disabled&rsquo;) AND ( <br>
(clock_timestamp() - xact_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
OR (clock_timestamp() - query_start) &gt;
&rsquo;00:00:10.0&rsquo;::interval <br>
) AND pid &lt;&gt; pg_backend_pid();</p>

<p style="margin-top: 1em">A ten seconds interval used in
condition determines query or transaction age and can be
overriden with A hotkey.</p>

<p style="margin-top: 1em">Note, waiting is not a backend
state. If a backend is in the active state, it may or may
not be waiting. If the state is active and waiting is true,
it means that a query <br>
is being executed, but is being blocked by a lock somewhere
in the system. Therefore, if waiting added to the mask, all
waiting queries will be canceled ot terminated <br>
independently of his backends states.</p>

<p style="margin-top: 1em">m :Display current mask toggle
<br>
Show current mask which will used for group
cancel/terminate.</p>

<p style="margin-top: 1em">A :Change age threshold toggle
<br>
Change age threshold for long running queries. Queries which
age is never then threshold not displayed. Default threshold
10 seconds. This function allowed only when <br>
pg_stat_activity screen enabled by a hotkey.</p>

<p style="margin-top: 1em">V :Show system tables toggle
<br>
Toggle on/off system tables and indexes. By default, the
pgcenter shows table/index statistics for user tables from
pg_stat_user_* views.</p>

<p style="margin-top: 1em">K :Reset postgresql stats toggle
<br>
Reset PostgreSQL stats counters for the current database to
zero. The pg_stat_statements counters also reseted. Requires
database superuser privileges.</p>

<p style="margin-top: 1em">G :Get query report toggle <br>
Show query report with various information about specified
query. This function work only in pg_stat_statements_timing
and pg_stat_statements_general screens. For specify&acirc;
<br>
ing query use id values from queryid column.</p>

<p style="margin-top: 1em">z :Change refresh interval
toggle <br>
You will be prompted to enter the delay time, in seconds,
between display updates. Can not be less that 1 second.</p>

<p style="margin-top: 1em">Z :Change Color Mapping toggle
<br>
This key will take you to a separate screen where you can
change the colors for the windows.</p>

<p style="margin-top: 1em">space :Pause program execution
toggle</p>

<p style="margin-top: 1em">F1 :Help toggle <br>
Show help screen.</p>

<p style="margin-top: 1em">q :Quit</p>

<p style="margin-top: 1em">URLS <br>
pg_stat_statements module <br>

http://www.postgresql.org/docs/9.4/static/pgstatstatements.html</p>

<p style="margin-top: 1em">PostgreSQL statistics collector
<br>

http://www.postgresql.org/docs/9.4/static/monitoring-stats.html</p>

<p style="margin-top: 1em">BUGS <br>
To report bugs, use
http://github.com/lesovsky/pgbconsole/issues page</p>

<p style="margin-top: 1em">AUTHOR <br>
Alexey Lesovsky, &lt;lesovsky@gmail.com&gt;</p>

<p style="margin-top: 1em">SEE ALSO</p>

<p style="margin-top: 1em">August, 2015 PGCENTER(1)</p>
<hr>
</body>
</html>
