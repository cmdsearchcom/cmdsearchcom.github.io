<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:20 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>JAPICOMPAT(1) General Commands Manual JAPICOMPAT(1)</p>

<p style="margin-top: 1em">NAME <br>
japicompat - Test Java APIs for binary backwards
compatibility.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
japicompat [-svqhtjw4] [-o outfile] [-i ignorefiles]
&lt;original_api&gt; &lt;api_to_check&gt;</p>

<p style="margin-top: 1em">DESCRIPTION <br>
japicompat is part of japitools, designed to test for
compatibility between Java APIs.</p>

<p style="margin-top: 1em">They were originally designed
for testing free implementations of Java itself for
compatibility with Sun&rsquo;s JDK, but they can also be
used for testing backward compatibility <br>
between versions of any API.</p>

<p style="margin-top: 1em">The tools are japize and
japicompat. Japize is a Java program which emits a listing
of an API in a machine-readable format. Japicompat then
takes two such listings and compares <br>
them for binary compatibility, as defined by Sun in the Java
Language Specification.</p>

<p style="margin-top: 1em">OPTIONS <br>
-s disable additional binary compatibility checks (only do
checks defined by the JLS).</p>

<p style="margin-top: 1em">-v enable checks for minor
compatibility problems.</p>

<p style="margin-top: 1em">SerialVersionUID checking:
japicompat reports a minor error if a Serializable class has
a different SerialVersionUID between the two releases.</p>

<p style="margin-top: 1em">Deprecation checking: japicompat
reports a minor error if a class or member was deprecated in
the original API but is not deprecated in the API being
checked.</p>

<p style="margin-top: 1em">-q disables progress
reports.</p>

<p style="margin-top: 1em">-h generates output in HTML
format. The HTML files produced depend on the japi.css file
to get attractive presentation.</p>

<p style="margin-top: 1em">-t generates output in text
format. This is the default.</p>

<p style="margin-top: 1em">-j generates output in raw
machine readable form. The format produced is called
&quot;japio&quot; format, and by convention should be saved
with a &quot;.japio&quot; file extension. The stand&acirc;
<br>
alone japiotext and japiohtml utilities can be used to
convert this format into html or text (actually, japicompat
calls japiotext or japiohtml internally if the -h or -t <br>
flags are used). Japio files can also be used with the -i
flag to support ignoring errors caused by incompatibilities
between JDK versions.</p>

<p style="margin-top: 1em">-w disable warnings for running
against old buggy japi files. By default japicompat will
produce warnings if run against japi files originally
generated by older versions of <br>
japitools that had known bugs that japifix cannot
eliminate.</p>

<p style="margin-top: 1em">-4 use 1.4-compatible mode. This
works as long as the APIs to compare does not contain
1.5-only items.</p>

<p style="margin-top: 1em">-o &lt;outfile&gt; <br>
Send the output to &lt;outfile&gt; instead of stdout. The
format of this file depends on the -h, -t and -j flags.</p>

<p style="margin-top: 1em">-i &lt;ignorefiles&gt; <br>
Suppose you are attempting to implement the Java API. You
have (pretty much) completed coverage of the early JDK
versions (1.0 and 1.1) but still have some distance to <br>
achieve full coverage of 1.4 (this is an accurate
description of all Free Software Java implementations at the
time of writing). Using japicompat to compare your
implemen&acirc; <br>
tation with JDK 1.4 gives accurate results, but you might
also want to show your coverage of the earlier versions.</p>

<p style="margin-top: 1em">Unfortunately Sun has not
followed their own binary compatibility rules between JDK
releases, let alone the expanded rules that japicompat tests
for. So when you run a <br>
comparison between JDK 1.1 and your implementation, you will
get spurious error reports when you&rsquo;re compatible with
1.4 but not 1.1.</p>

<p style="margin-top: 1em">Obviously what you really want
is to ignore errors like this, and japicompat provides a way
to do so. First, run a comparison between 1.1 and 1.4 using
the -j switch. Then <br>
run the comparison between 1.1 and your implementation,
passing the &quot;-i&quot; option with the output of the
previous run. For example:</p>

<p style="margin-top: 1em">$ japicompat -jo
ignore-11-14.japio jdk11.japi.gz jdk14.japi.gz <br>
$ japicompat -ho jdk11-myimpl.html -i ignore-11-14.japio
jdk11.japi.gz myimpl.japi.gz</p>

<p style="margin-top: 1em">You can also get the same effect
by running:</p>

<p style="margin-top: 1em">$ japicompat -ho
jdk11-myimpl.html -i jdk14.japi.gz jdk11.japi.gz
myimpl.japi.gz</p>

<p style="margin-top: 1em">This is obviously simpler and
quicker to type, but requires the comparison between jdk11
and jdk14 to be run every single time. Making the japio file
manually allows for <br>
it to be saved and used again the next time, which lets
japicompat run about twice as fast.</p>

<p style="margin-top: 1em">&lt;original_api&gt;
&lt;api_to_check&gt; <br>
The japi files corresponding to the APIs to be compared.</p>

<p style="margin-top: 1em">japicompat specifically tests
that the second argument is backwardly-compatible with the
first. Therefore, a perfect implementation of JDK 1.1 would
produce no errors <br>
regardless of the order of the arguments, but a perfect
implementation of JDK1.1 plus parts of JDK1.2 should be
tested as follows:</p>

<p style="margin-top: 1em">$ japicompat jdk11.japi.gz
myimpl.japi.gz <br>
$ japicompat myimpl.japi.gz jdk12.japi.gz</p>

<p style="margin-top: 1em">It is probably impossible to
make an implementation that passes both these tests, since
Sun&rsquo;s own JDK1.2 produces numerous errors when tested
against JDK1.1. See the dis&acirc; <br>
cussion of the -i option above for a way to cope with this
situation.</p>

<p style="margin-top: 1em">Either compressed (.japi.gz) or
uncompressed (.japi) files can be passed to japicompat: The
file extension is used to determine whether or not to pipe
input through gzip <br>
or not.</p>

<p style="margin-top: 1em">SEE ALSO <br>
japize(1) Produce a listing of an API in a machine-readable
format. <br>
japilist(1) List the contents of japi files. <br>
japiohtml(1) Convert japicompat output to pretty html
format. <br>
japiotext(1) Convert japicompat output to readable plain
text format.</p>

<p style="margin-top: 1em">October 6, 2005
JAPICOMPAT(1)</p>
<hr>
</body>
</html>
