<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:55:18 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>BLASR(1) User Commands BLASR(1)</p>

<p style="margin-top: 1em">NAME <br>
blasr - Map SMRT Sequences to a reference genome.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
blasr reads.bam genome.fasta -bam -out out.bam</p>

<p style="margin-top: 1em">blasr reads.fasta
genome.fasta</p>

<p style="margin-top: 1em">blasr reads.fasta genome.fasta
-sa genome.fasta.sa</p>

<p style="margin-top: 1em">blasr reads.bax.h5 genome.fasta
[-sa genome.fasta.sa]</p>

<p style="margin-top: 1em">blasr reads.bax.h5 genome.fasta
-sa genome.fasta.sa -maxScore -100 -minMatch 15 ...</p>

<p style="margin-top: 1em">blasr reads.bax.h5 genome.fasta
-sa genome.fasta.sa -nproc 24 -out alignment.out ...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
blasr is a read mapping program that maps reads to positions
in a genome by clustering short exact matches between the
read and the genome, and scoring clusters using alignment.
<br>
The matches are generated by searching all suffixes of a
read against the genome using a suffix array. Global
chaining methods are used to score clusters of matches.</p>

<p style="margin-top: 1em">The only required inputs to
blasr are a file of reads and a reference genome. It is
exremely useful to have read filtering information, and
mapping runtime may decrease substan&acirc; <br>
tially when a precomputed suffix array index on the
reference sequence is specified.</p>

<p style="margin-top: 1em">Although reads may be input in
FASTA format, the recommended input is PacBio BAM files
because these contain qualtiy value information that is used
in the alignment and produces <br>
higher quality variant detection. Although alignments can be
output in various formats, the recommended output format is
PacBio BAM. Support for bax.h5 and plx.h5 files will be <br>
DEPRECATED. Support for region tables for h5 files will be
DEPRECATED.</p>

<p style="margin-top: 1em">When suffix array index of a
genome is not specified, the suffix array is built before
producing alignment. This may be prohibitively slow when the
genome is large (e.g. Human). <br>
It is best to precompute the suffix array of a genome using
the program sawriter(1), and then specify the suffix array
on the command line using -sa genome.fa.sa.</p>

<p style="margin-top: 1em">The optional parameters are
roughly divided into three categories: control over
anchoring, alignment scoring, and output.</p>

<p style="margin-top: 1em">The default anchoring parameters
are optimal for small genomes and samples with up to 5%
divergence from the reference genome. The main parameter
governing speed and sensitivity <br>
is the -minMatch parameter. For human genome alignments, a
value of 11 or higher is recommended. Several methods may be
used to speed up alignments, at the expense of possibly <br>
decreasing sensitivity.</p>

<p style="margin-top: 1em">Regions that are too repetitive
may be ignored during mapping by limiting the number of
positions a read maps to with the -maxAnchorsPerPosition
option. Values between 500 and <br>
1000 are effective in the human genome.</p>

<p style="margin-top: 1em">For small genomes such as
bacterial genomes or BACs, the default parameters are
sufficient for maximal sensitivity and good speed.</p>

<p style="margin-top: 1em">OPTIONS <br>
Input Files</p>

<p style="margin-top: 1em">Reads</p>

<p style="margin-top: 1em">reads.bam <br>
A PacBio BAM file of reads. This is the preferred input to
blasr because rich quality value (insertion,deletion, and
substitution quality values) informa&acirc; <br>
tion is maintained. The extra quality information improves
variant detection and mapping speed.</p>

<p style="margin-top: 1em">reads.fasta <br>
A multi-fasta file of reads, though any fasta file is valid
input</p>

<p style="margin-top: 1em">reads.bax.h5|reads.plx.h5 <br>
the old DEPRECATED output format of SMRT reads.</p>

<p style="margin-top: 1em">input.fofn <br>
File of file names</p>

<p style="margin-top: 1em">-sa suffixArrayFile <br>
Use the suffix array &rsquo;sa&rsquo; for detecting matches
between the reads and the reference. The suffix array has
been prepared by the sawriter(1) program.</p>

<p style="margin-top: 1em">-ctab tab <br>
A table of tuple counts used to estimate match significance.
This is by the program &rsquo;printTupleCountTable&rsquo;.
While it is quick to generate on the fly, if there are <br>
many invocations of blasr, it is useful to precompute the
ctab.</p>

<p style="margin-top: 1em">-regionTable table (DEPRECATED)
<br>
Read in a read-region table in HDF format for masking
portions of reads. This may be a single table if there is
just one input file, or a fofn. When a region ta&acirc; <br>
ble is specified, any region table inside the reads.plx.h5
or reads.bax.h5 files are ignored. <br>
(DEPRECATED) Options for modifying reads.</p>

<p style="margin-top: 1em">There is ancilliary information
about substrings of reads that is stored in a &rsquo;region
table&rsquo; for each read file. Because HDF is used, the
region table may be part of the <br>
.bax.h5 or .plx.h5 file, or a separate file. A contiguously
read substring from the template is a subread, and any read
may contain multiple subreads. The boundaries of <br>
the subreads may be inferred from the region table either
directly or by definition of adapter boundaries. Typically
region tables also contain information for the loca&acirc;
<br>
tion of the high and low quality regions of reads. Reads
produced by spurious reads from empty ZMWs have a high
quality start coordinate equal to high quality end, making
<br>
no usable read.</p>

<p style="margin-top: 1em">-useccs <br>
Align the circular consensus sequence (ccs), then report
alignments of the ccs subreads to the window that the ccs
was mapped to. Only alignments of the subreads <br>
are reported.</p>

<p style="margin-top: 1em">-useccsall <br>
Similar to -useccs, except all subreads are aligned, rather
than just the subreads used to call the ccs. This will
include reads that only cover part of the tem&acirc; <br>
plate.</p>

<p style="margin-top: 1em">-useccsdenovo <br>
Align the circular consensus, and report only the alignment
of the ccs sequence.</p>

<p style="margin-top: 1em">-noSplitSubreads (false) <br>
Do not split subreads at adapters. This is typically only
useful when the genome in an unrolled version of a known
template, and contains template-adapter- <br>
reverse_template sequence.</p>

<p style="margin-top: 1em">-ignoreRegions (false) <br>
Ignore any information in the region table.</p>

<p style="margin-top: 1em">-ignoreHQRegions (false) <br>
Ignore any hq regions in the region table. <br>
Alignments To Report</p>

<p style="margin-top: 1em">-bestn n (10) <br>
Report the top n alignments.</p>

<p style="margin-top: 1em">-hitPolicy (all) <br>
Specify a policy to treat multiple hits from [all, allbest,
random, randombest, leftmost]</p>

<p style="margin-top: 1em">all report all alignments.</p>

<p style="margin-top: 1em">allbest <br>
report all equally top scoring alignments.</p>

<p style="margin-top: 1em">random report a random
alignment.</p>

<p style="margin-top: 1em">randombest <br>
report a random alignment from multiple equally top scoring
alignments.</p>

<p style="margin-top: 1em">leftmost <br>
report an alignment which has the best alignmentscore and
has the smallest mapping coordinate in any reference.</p>

<p style="margin-top: 1em">-placeRepeatsRandomly (false)
<br>
DEPRECATED! If true, equivalent to -hitPolicy
randombest.</p>

<p style="margin-top: 1em">-randomSeed (0) <br>
Seed for random number generator. By default (0), use
current time as seed.</p>

<p style="margin-top: 1em">-noSortRefinedAlignments (false)
<br>
Once candidate alignments are generated and scored via
sparse dynamic programming, they are rescored using local
alignment that accounts for different error pro&acirc; <br>
files. Resorting based on the local alignment may change the
order the hits are returned.</p>

<p style="margin-top: 1em">-allowAdjacentIndels <br>
When specified, adjacent insertion or deletions are allowed.
Otherwise, adjacent insertion and deletions are merged into
one operation. Using quality values to <br>
guide pairwise alignments may dictate that the higher
probability alignment contains adjacent insertions or
deletions. Current tools such as GATK do not permit <br>
this and so they are not reported by default. <br>
Output Formats and Files</p>

<p style="margin-top: 1em">-out out (terminal) <br>
Write output to out.</p>

<p style="margin-top: 1em">-sam Write output in SAM
format.</p>

<p style="margin-top: 1em">-m t If not printing SAM, modify
the output of the alignment.</p>

<p style="margin-top: 1em">When t is:</p>

<p style="margin-top: 1em">0 Print blast like output with
|&rsquo;s connecting matched nucleotides.</p>

<p style="margin-top: 1em">1 Print only a summary: score
and pos.</p>

<p style="margin-top: 1em">2 Print in Compare.xml
format.</p>

<p style="margin-top: 1em">3 Print in vulgar format
(DEPRECATED).</p>

<p style="margin-top: 1em">4 Print a longer tabular version
of the alignment.</p>

<p style="margin-top: 1em">5 Print in a machine-parsable
format that is read by compareSequences.py.</p>

<p style="margin-top: 1em">-header <br>
Print a header as the first line of the output file
describing the contents of each column.</p>

<p style="margin-top: 1em">-titleTable tab (NULL) <br>
Construct a table of reference sequence titles. The
reference sequences are enumerated by row, 0,1,... The
reference index is printed in alignment results rather <br>
than the full reference name. This makes output concise,
particularly whenvery verbose titles exist in reference
names.</p>

<p style="margin-top: 1em">-unaligned file <br>
Output reads that are not aligned to file</p>

<p style="margin-top: 1em">-clipping
[none|hard|subread|soft] (none)</p>

<p style="margin-top: 1em">Use no/hard/subread/soft
clipping, ONLY for SAM/BAM output.</p>

<p style="margin-top: 1em">-printSAMQV (false) <br>
Print quality values to SAM output.</p>

<p style="margin-top: 1em">-cigarUseSeqMatch (false) <br>
CIGAR strings in SAM/BAM output use &rsquo;=&rsquo; and
&rsquo;X&rsquo; to represent sequence match and mismatch
instead of &rsquo;M&rsquo;. <br>
Options for anchoring alignment regions.</p>

<p style="margin-top: 1em">This will have the greatest
effect on speed and sensitivity.</p>

<p style="margin-top: 1em">-minMatch m (12) <br>
Minimum seed length. Higher minMatch will speed up
alignment, but decrease sensitivity.</p>

<p style="margin-top: 1em">-maxMatch l (inf) <br>
Stop mapping a read to the genome when the lcp length
reaches l. This is useful when the query is part of the
reference, for example when constructing pairwise <br>
alignments for de novo assembly.</p>

<p style="margin-top: 1em">-maxLCPLength l (inf) <br>
The same as -maxMatch.</p>

<p style="margin-top: 1em">-maxAnchorsPerPosition m (10000)
<br>
Do not add anchors from a position if it matches to more
than m locations in the target.</p>

<p style="margin-top: 1em">-advanceExactMatches E (0) <br>
Another trick for speeding up alignments with match - E
fewer anchors. Rather than finding anchors between the read
and the genome at every position in the read, <br>
when an anchor is found at position i in a read of length L,
the next position in a read to find an anchor is at i+L-E.
Use this when alignining already assembled <br>
contigs.</p>

<p style="margin-top: 1em">-nCandidates n (10) <br>
Keep up to n candidates for the best alignment. A large
value of n will slow mapping because the slower dynamic
programming steps are applied to more clusters of <br>
anchors which can be a rate limiting step when reads are
very long.</p>

<p style="margin-top: 1em">-concordant (false) <br>
Map all subreads of a zmw (hole) to where the longest full
pass subread of the zmw aligned to. This requires to use the
region table and hq regions. This option <br>
only works when reads are in base or pulse h5 format.</p>

<p style="margin-top: 1em">-concordantTemplate
(mediansubread) <br>
Select a full pass subread of a zmw as template for
concordant mapping. longestsubread - use the longest full
pass subread mediansubread - use the median length <br>
full pass subread typicalsubread - use the second longest
full pass subread if length of the longest full pass subread
is an outlier</p>

<p style="margin-top: 1em">-fastMaxInterval (false) <br>
Fast search maximum increasing intervals as alignment
candidates. The search is not as exhaustive as the default,
but is much faster.</p>

<p style="margin-top: 1em">-aggressiveIntervalCut (false)
<br>
Agreesively filter out non-promising alignment candidates,
if there exists at least one promising candidate. If this
option is turned on, blasr is likely to ignore <br>
short alignments of ALU elements.</p>

<p style="margin-top: 1em">-fastSDP (false) <br>
Use a fast heuristic algorithm to speed up sparse dynamic
programming. <br>
Options for Refining Hits</p>

<p style="margin-top: 1em">-sdpTupleSize K (11) <br>
Use matches of length K to speed dynamic programming
alignments. This controls accuracy of assigning gaps in
pairwise alignments once a mapping has been found, <br>
rather than mapping sensitivity itself.</p>

<p style="margin-top: 1em">-scoreMatrix score matrix string
<br>
Specify an alternative score matrix for scoring fasta reads.
The matrix is in the format</p>

<p style="margin-top: 1em">A C G T N <br>
A a b c d e <br>
C f g h i j <br>
G k l m n o <br>
T p q r s t <br>
N u v w x y</p>

<p style="margin-top: 1em">The values a...y should be input
as a quoted space separated string: &quot;a b c ... y&quot;.
Lowerf scores are better, so matches should be less than
mismatches e.g. a,g,m,s <br>
= -5 (match), mismatch = 6.</p>

<p style="margin-top: 1em">-affineOpen value (10) <br>
Set the penalty for opening an affine alignment.</p>

<p style="margin-top: 1em">-affineExtend a (0) <br>
Change affine (extension) gap penalty. Lower value allows
more gaps. <br>
Options for overlap/dynamic programming alignments and
pairwise overlap for de novo assembly.</p>

<p style="margin-top: 1em">-useQuality (false) <br>
Use substitution/insertion/deletion/merge quality values to
score gap and mismatch penalties in pairwise alignments.
Because the insertion and deletion rates are <br>
much higher than substitution, this will make many
alignments favor an insertion/deletion over a
substitution.nNaive consensus calling methods will then
often miss <br>
substitution polymorphisms. This option should be used when
calling consensus using the Quiver method. Furthermore, when
not using quality values to score align&acirc; <br>
ments, there will be a lower consensus accuracy in homolymer
regions.</p>

<p style="margin-top: 1em">-affineAlign (false) <br>
Refine alignment using affine guided align. <br>
Options for filtering reads and alignments</p>

<p style="margin-top: 1em">-minReadLength l (50) <br>
Skip reads that have a full length less than l. Subreads may
be shorter.</p>

<p style="margin-top: 1em">-minSubreadLength l (0) <br>
Do not align subreads of length less than l.</p>

<p style="margin-top: 1em">-minRawSubreadScore m (0) <br>
Do not align subreads whose quality score in region table is
less than m (quality scores should be in range [0,
1000]).</p>

<p style="margin-top: 1em">-maxScore m (-200) <br>
Maximum score to output (high is bad, negative good).</p>

<p style="margin-top: 1em">-minAlnLength <br>
(0) Report alignments only if their lengths are greater than
minAlnLength.</p>

<p style="margin-top: 1em">-minPctSimilarity (0) Report
alignments only if their percentage similairty is greater
than minPctSimilarity.</p>

<p style="margin-top: 1em">-minPctAccuracy <br>
(0) Report alignments only if their percentage accuray is
greater than minAccuracy. <br>
Options for parallel alignment</p>

<p style="margin-top: 1em">-nproc N (1) <br>
Align using N processes. All large data structures such as
the suffix array and tuple count table are shared.</p>

<p style="margin-top: 1em">-start S (0) <br>
Index of the first read to begin aligning. This is useful
when multiple instances are running on the same data, for
example when on a multi-rack cluster.</p>

<p style="margin-top: 1em">-stride S (1) <br>
Align one read every S reads. <br>
Options for subsampling reads.</p>

<p style="margin-top: 1em">-subsample (0) <br>
Proportion of reads to randomly subsample (expressed as a
decimal) and align.</p>

<p style="margin-top: 1em">-holeNumbers LIST <br>
When specified, only align reads whose ZMW hole numbers are
in LIST. LIST is a comma-delimited string of ranges, such as
&rsquo;1,2,3,10-13&rsquo;. This option only works <br>
when reads are in bam, bax.h5 or plx.h5 format.</p>

<p style="margin-top: 1em">-h Print help information.</p>

<p style="margin-top: 1em">CITATION <br>
To cite BLASR, please use: Chaisson M.J., and Tesler G.,
Mapping single molecule sequencing reads using Basic Local
Alignment with Successive Refinement (BLASR): Theory and
<br>
Application, BMC Bioinformatics 2012, 13:238.</p>

<p style="margin-top: 1em">BUGS <br>
Please report any bugs to
https://github.com/PacificBiosciences/blasr/issues.</p>

<p style="margin-top: 1em">SEE ALSO <br>
loadPulses(1) pls2fasta(1) samFilter(1) samtoh5(1)
samtom4(1) sawriter(1) sdpMatcher(1) toAfg(1)</p>

<p style="margin-top: 1em">blasr 3ca7fe8 July 2015
BLASR(1)</p>
<hr>
</body>
</html>
