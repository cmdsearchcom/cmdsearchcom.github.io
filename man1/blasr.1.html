<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>BLASR(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">BLASR(1)</td>
    <td class="head-vol">User Commands</td>
    <td class="head-rtitle">BLASR(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
blasr - Map SMRT Sequences to a reference genome.
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>blasr</b> <i>reads.bam</i> <i>genome.fasta <b>-bam -out</b><i>
  out.bam</i></i>
<div class="Pp"></div>
<b>blasr</b> <i>reads.fasta</i> <i>genome.fasta</i>
<div class="Pp"></div>
<b>blasr</b> <i>reads.fasta</i> <i>genome.fasta <b>-sa</b><i>
  genome.fasta.sa</i></i>
<div class="Pp"></div>
<b>blasr</b> <i>reads.bax.h5</i> <i>genome.fasta [<b>-sa
  </b><i>genome.fasta.sa</i>]</i>
<div class="Pp"></div>
<b>blasr</b> <i>reads.bax.h5</i> <i>genome.fasta <b>-sa</b><i> genome.fasta.sa
  </i> <b>-maxScore</b> -100 <b>-minMatch</b> 15 ...</i>
<div class="Pp"></div>
<b>blasr</b> <i>reads.bax.h5</i> <i>genome.fasta <b>-sa</b><i> genome.fasta.sa
  </i> <b>-nproc</b> 24 <b>-out</b><i> alignment.out</i> ...</i>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>blasr</b> is a read mapping program that maps reads to positions in a genome
  by clustering short exact matches between the read and the genome, and scoring
  clusters using alignment. The matches are generated by searching all suffixes
  of a read against the genome using a suffix array. Global chaining methods are
  used to score clusters of matches.
<div class="Pp"></div>
The only required inputs to blasr are a file of reads and a reference genome. It
  is exremely useful to have read filtering information, and mapping runtime may
  decrease substantially when a precomputed suffix array index on the reference
  sequence is specified.
<div class="Pp"></div>
Although reads may be input in FASTA format, the recommended input is PacBio BAM
  files because these contain qualtiy value information that is used in the
  alignment and produces higher quality variant detection. Although alignments
  can be output in various formats, the recommended output format is PacBio BAM.
  Support for bax.h5 and plx.h5 files will be <b>DEPRECATED</b>. Support for
  region tables for h5 files will be <b>DEPRECATED</b>.
<div class="Pp"></div>
When suffix array index of a genome is not specified, the suffix array is built
  before producing alignment. This may be prohibitively slow when the genome is
  large (e.g. Human). It is best to precompute the suffix array of a genome
  using the program <b>sawriter</b>(1), and then specify the suffix array on the
  command line using <b>-sa</b> genome.fa.sa.
<div class="Pp"></div>
The optional parameters are roughly divided into three categories: control over
  anchoring, alignment scoring, and output.
<div class="Pp"></div>
The default anchoring parameters are optimal for small genomes and samples with
  up to 5% divergence from the reference genome. The main parameter governing
  speed and sensitivity is the <b>-minMatch</b> parameter. For human genome
  alignments, a value of 11 or higher is recommended. Several methods may be
  used to speed up alignments, at the expense of possibly decreasing
  sensitivity.
<div class="Pp"></div>
Regions that are too repetitive may be ignored during mapping by limiting the
  number of positions a read maps to with the <b>-maxAnchorsPerPosition</b>
  option. Values between 500 and 1000 are effective in the human genome.
<div class="Pp"></div>
For small genomes such as bacterial genomes or BACs, the default parameters are
  sufficient for maximal sensitivity and good speed.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Input Files</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Reads</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>reads.bam</i></dt>
  <dd class="It-tag">A PacBio BAM file of reads. This is the preferred input to
      <b>blasr</b> because rich quality value (insertion,deletion, and
      substitution quality values) information is maintained. The extra quality
      information improves variant detection and mapping speed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>reads.fasta</i></dt>
  <dd class="It-tag">A multi-fasta file of reads, though any fasta file is valid
      input</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>reads.bax.h5</i>|<i>reads.plx.h5</i></dt>
  <dd class="It-tag">the old <b>DEPRECATED</b> output format of SMRT reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>input.fofn</i></dt>
  <dd class="It-tag">File of file names</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sa</b><i> suffixArrayFile</i></dt>
  <dd class="It-tag">Use the suffix array 'sa' for detecting matches between the
      reads and the reference. The suffix array has been prepared by the
      <b>sawriter</b>(1) program.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ctab</b><i> tab</i></dt>
  <dd class="It-tag">A table of tuple counts used to estimate match
      significance. This is by the program 'printTupleCountTable'. While it is
      quick to generate on the fly, if there are many invocations of
      <b>blasr</b>, it is useful to precompute the ctab.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-regionTable</b><i> table</i> (<b>DEPRECATED</b>)</dt>
  <dd class="It-tag">Read in a read-region table in HDF format for masking
      portions of reads. This may be a single table if there is just one input
      file, or a fofn. When a region table is specified, any region table inside
      the reads.plx.h5 or reads.bax.h5 files are ignored.</dd>
</dl>
</div>
<b>(DEPRECATED) Options for modifying reads.</b>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
There is ancilliary information about substrings of reads that is stored in a
  'region table' for each read file. Because HDF is used, the region table may
  be part of the .bax.h5 or .plx.h5 file, or a separate file. A contiguously
  read substring from the template is a subread, and any read may contain
  multiple subreads. The boundaries of the subreads may be inferred from the
  region table either directly or by definition of adapter boundaries. Typically
  region tables also contain information for the location of the high and low
  quality regions of reads. Reads produced by spurious reads from empty ZMWs
  have a high quality start coordinate equal to high quality end, making no
  usable read.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-useccs</b></dt>
  <dd class="It-tag">Align the circular consensus sequence (ccs), then report
      alignments of the ccs subreads to the window that the ccs was mapped to.
      Only alignments of the subreads are reported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-useccsall</b></dt>
  <dd class="It-tag">Similar to <b>-useccs</b>, except all subreads are aligned,
      rather than just the subreads used to call the ccs. This will include
      reads that only cover part of the template.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-useccsdenovo</b></dt>
  <dd class="It-tag">Align the circular consensus, and report only the alignment
      of the ccs sequence.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-noSplitSubreads</b> (false)</dt>
  <dd class="It-tag">Do not split subreads at adapters. This is typically only
      useful when the genome in an unrolled version of a known template, and
      contains template-adapter-reverse_template sequence.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ignoreRegions</b> (false)</dt>
  <dd class="It-tag">Ignore any information in the region table.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ignoreHQRegions</b> (false)</dt>
  <dd class="It-tag">Ignore any hq regions in the region table.</dd>
</dl>
</div>
<b>Alignments To Report</b>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bestn</b><i> n </i>(10)</dt>
  <dd class="It-tag">Report the top <i>n</i> alignments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hitPolicy</b> (all)</dt>
  <dd class="It-tag">Specify a policy to treat multiple hits from [all, allbest,
      random, randombest, leftmost]</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>all</i></dt>
  <dd class="It-tag">report all alignments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>allbest</i></dt>
  <dd class="It-tag">report all equally top scoring alignments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>random</i></dt>
  <dd class="It-tag">report a random alignment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>randombest</i></dt>
  <dd class="It-tag">report a random alignment from multiple equally top scoring
      alignments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>leftmost</i></dt>
  <dd class="It-tag">report an alignment which has the best alignmentscore and
      has the smallest mapping coordinate in any reference.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-placeRepeatsRandomly</b> (false)</dt>
  <dd class="It-tag"><b>DEPRECATED!</b> If true, equivalent to
      <b>-hitPolicy</b><i> randombest</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-randomSeed</b> (0)</dt>
  <dd class="It-tag">Seed for random number generator. By default (0), use
      current time as seed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-noSortRefinedAlignments</b> (false)</dt>
  <dd class="It-tag">Once candidate alignments are generated and scored via
      sparse dynamic programming, they are rescored using local alignment that
      accounts for different error profiles. Resorting based on the local
      alignment may change the order the hits are returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-allowAdjacentIndels</b></dt>
  <dd class="It-tag">When specified, adjacent insertion or deletions are
      allowed. Otherwise, adjacent insertion and deletions are merged into one
      operation. Using quality values to guide pairwise alignments may dictate
      that the higher probability alignment contains adjacent insertions or
      deletions. Current tools such as GATK do not permit this and so they are
      not reported by default.</dd>
</dl>
</div>
<b>Output Formats and Files</b>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-out</b><i> out </i>(terminal)</dt>
  <dd class="It-tag">Write output to <i>out</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sam</b></dt>
  <dd class="It-tag">Write output in SAM format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m</b><i> t</i></dt>
  <dd class="It-tag">If not printing SAM, modify the output of the
    alignment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">When <i>t</i> is:</dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">0</dt>
  <dd class="It-tag">Print blast like output with |'s connecting matched
      nucleotides.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1</dt>
  <dd class="It-tag">Print only a summary: score and pos.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2</dt>
  <dd class="It-tag">Print in Compare.xml format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3</dt>
  <dd class="It-tag">Print in vulgar format (<b>DEPRECATED</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4</dt>
  <dd class="It-tag">Print a longer tabular version of the alignment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5</dt>
  <dd class="It-tag">Print in a machine-parsable format that is read by
      compareSequences.py.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-header</b></dt>
  <dd class="It-tag">Print a header as the first line of the output file
      describing the contents of each column.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-titleTable</b><i> tab </i>(NULL)</dt>
  <dd class="It-tag">Construct a table of reference sequence titles. The
      reference sequences are enumerated by row, 0,1,... The reference index is
      printed in alignment results rather than the full reference name. This
      makes output concise, particularly whenvery verbose titles exist in
      reference names.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-unaligned</b><i> file</i></dt>
  <dd class="It-tag">Output reads that are not aligned to <i>file</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i><b>-clipping</b><i></i></i><i>&#x2002;[</i><i><i>none</i></i><i>|</i><i><i>hard</i></i><i>|</i><i><i>subread</i></i><i>|</i><i><i>soft</i></i><i>]</i><i><i>&#x2002;</i>(none)</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Use no/hard/subread/soft clipping, ONLY for SAM/BAM
    output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-printSAMQV</b> (false)</dt>
  <dd class="It-tag">Print quality values to SAM output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-cigarUseSeqMatch</b> (false)</dt>
  <dd class="It-tag">CIGAR strings in SAM/BAM output use '=' and 'X' to
      represent sequence match and mismatch instead of 'M'.</dd>
</dl>
</div>
<b>Options for anchoring alignment regions.</b>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
This will have the greatest effect on speed and sensitivity.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-minMatch</b><i> m </i>(12)</dt>
  <dd class="It-tag">Minimum seed length. Higher minMatch will speed up
      alignment, but decrease sensitivity.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-maxMatch</b><i> l </i>(inf)</dt>
  <dd class="It-tag">Stop mapping a read to the genome when the lcp length
      reaches <i>l</i>. This is useful when the query is part of the reference,
      for example when constructing pairwise alignments for de novo
    assembly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-maxLCPLength</b><i> l </i>(inf)</dt>
  <dd class="It-tag">The same as <b>-maxMatch</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-maxAnchorsPerPosition</b><i> m </i>(10000)</dt>
  <dd class="It-tag">Do not add anchors from a position if it matches to more
      than <i>m</i> locations in the target.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-advanceExactMatches</b><i> E </i>(0)</dt>
  <dd class="It-tag">Another trick for speeding up alignments with match - E
      fewer anchors. Rather than finding anchors between the read and the genome
      at every position in the read, when an anchor is found at position i in a
      read of length L, the next position in a read to find an anchor is at
      i+L-E. Use this when alignining already assembled contigs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-nCandidates</b><i> n </i>(10)</dt>
  <dd class="It-tag">Keep up to <i>n</i> candidates for the best alignment. A
      large value of n will slow mapping because the slower dynamic programming
      steps are applied to more clusters of anchors which can be a rate limiting
      step when reads are very long.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-concordant</b> (false)</dt>
  <dd class="It-tag">Map all subreads of a zmw (hole) to where the longest full
      pass subread of the zmw aligned to. This requires to use the region table
      and hq regions. This option only works when reads are in base or pulse h5
      format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-concordantTemplate</b> (mediansubread)</dt>
  <dd class="It-tag">Select a full pass subread of a zmw as template for
      concordant mapping. longestsubread - use the longest full pass subread
      mediansubread - use the median length full pass subread typicalsubread -
      use the second longest full pass subread if length of the longest full
      pass subread is an outlier</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fastMaxInterval</b> (false)</dt>
  <dd class="It-tag">Fast search maximum increasing intervals as alignment
      candidates. The search is not as exhaustive as the default, but is much
      faster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-aggressiveIntervalCut</b> (false)</dt>
  <dd class="It-tag">Agreesively filter out non-promising alignment candidates,
      if there exists at least one promising candidate. If this option is turned
      on, <b>blasr</b> is likely to ignore short alignments of ALU
    elements.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fastSDP</b> (false)</dt>
  <dd class="It-tag">Use a fast heuristic algorithm to speed up sparse dynamic
      programming.</dd>
</dl>
</div>
<b>Options for Refining Hits</b>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sdpTupleSize</b><i> K </i>(11)</dt>
  <dd class="It-tag">Use matches of length <i>K</i> to speed dynamic programming
      alignments. This controls accuracy of assigning gaps in pairwise
      alignments once a mapping has been found, rather than mapping sensitivity
      itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-scoreMatrix</b><i> score matrix string</i></dt>
  <dd class="It-tag">Specify an alternative score matrix for scoring fasta
      reads. The matrix is in the format
    <table class="tbl">
      <colgroup>
        <col style="width: 11.00ex;"/>
        <col style="width: 0.00ex;"/>
        <col style="width: 0.00ex;"/>
        <col style="width: 0.00ex;"/>
        <col style="width: 0.00ex;"/>
        <col style="width: 0.00ex;"/>
      </colgroup>
      <tr>
        <td> A C G T N</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>A a b c d e</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>C f g h i j</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>G k l m n o</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>T p q r s t</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>N u v w x y</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <div style="height: 1.00em;">&#x00A0;</div>
    The values a...y should be input as a quoted space separated string: &quot;a
      b c ... y&quot;. Lowerf scores are better, so matches should be less than
      mismatches e.g. a,g,m,s = -5 (match), mismatch = 6.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-affineOpen</b><i> value</i> (10)</dt>
  <dd class="It-tag">Set the penalty for opening an affine alignment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-affineExtend</b><i> a </i>(0)</dt>
  <dd class="It-tag">Change affine (extension) gap penalty. Lower value allows
      more gaps.</dd>
</dl>
</div>
<b>Options for overlap/dynamic programming alignments and pairwise overlap for
  de novo assembly.</b>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-useQuality</b> (false)</dt>
  <dd class="It-tag">Use substitution/insertion/deletion/merge quality values to
      score gap and mismatch penalties in pairwise alignments. Because the
      insertion and deletion rates are much higher than substitution, this will
      make many alignments favor an insertion/deletion over a
      substitution.nNaive consensus calling methods will then often miss
      substitution polymorphisms. This option should be used when calling
      consensus using the Quiver method. Furthermore, when not using quality
      values to score alignments, there will be a lower consensus accuracy in
      homolymer regions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-affineAlign</b> (false)</dt>
  <dd class="It-tag">Refine alignment using affine guided align.</dd>
</dl>
</div>
<b>Options for filtering reads and alignments</b>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-minReadLength</b><i> l</i> (50)</dt>
  <dd class="It-tag">Skip reads that have a full length less than <i>l</i>.
      Subreads may be shorter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-minSubreadLength </b><i>l </i>(0)</dt>
  <dd class="It-tag">Do not align subreads of length less than <i>l</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-minRawSubreadScore </b><i>m </i>(0)</dt>
  <dd class="It-tag">Do not align subreads whose quality score in region table
      is less than <i>m</i> (quality scores should be in range [0, 1000]).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-maxScore</b><i> m </i>(-200)</dt>
  <dd class="It-tag">Maximum score to output (high is bad, negative good).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-minAlnLength</b></dt>
  <dd class="It-tag">(0) Report alignments only if their lengths are greater
      than minAlnLength.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-minPctSimilarity</b>
  (0) Report alignments only if their percentage similairty is greater than
  minPctSimilarity.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-minPctAccuracy</b></dt>
  <dd class="It-tag">(0) Report alignments only if their percentage accuray is
      greater than minAccuracy.</dd>
</dl>
</div>
<b>Options for parallel alignment</b>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-nproc</b><i> N </i>(1)</dt>
  <dd class="It-tag">Align using <i>N</i> processes. All large data structures
      such as the suffix array and tuple count table are shared.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-start</b><i> S </i>(0)</dt>
  <dd class="It-tag">Index of the first read to begin aligning. This is useful
      when multiple instances are running on the same data, for example when on
      a multi-rack cluster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-stride</b><i> S </i>(1)</dt>
  <dd class="It-tag">Align one read every <i>S</i> reads.</dd>
</dl>
</div>
<b>Options for subsampling reads.</b>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-subsample</b> (0)</dt>
  <dd class="It-tag">Proportion of reads to randomly subsample (expressed as a
      decimal) and align.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-holeNumbers</b><i> LIST</i></dt>
  <dd class="It-tag">When specified, only align reads whose ZMW hole numbers are
      in <i>LIST</i>. <i>LIST</i> is a comma-delimited string of ranges, such as
      '1,2,3,10-13'. This option only works when reads are in bam, bax.h5 or
      plx.h5 format.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">Print help information.</dd>
</dl>
<h1 class="Sh" title="Sh" id="CITATION"><a class="selflink" href="#CITATION">CITATION</a></h1>
To cite BLASR, please use: Chaisson M.J., and Tesler G., Mapping single molecule
  sequencing reads using Basic Local Alignment with Successive Refinement
  (BLASR): Theory and Application, BMC Bioinformatics 2012, 13:238.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Please report any bugs to
  <i>https://github.com/PacificBiosciences/blasr/issues</i>.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>loadPulses</b>(1) <b>pls2fasta</b>(1) <b>samFilter</b>(1) <b>samtoh5</b>(1)
  <b>samtom4</b>(1) <b>sawriter</b>(1) <b>sdpMatcher</b>(1)
  <b>toAfg</b>(1)</div>
<table class="foot">
  <tr>
    <td class="foot-date">July 2015</td>
    <td class="foot-os">blasr 3ca7fe8</td>
  </tr>
</table>
</body>
</html>
