<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLCALL(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLCALL(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLCALL(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlcall - Perl calling conventions from C
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The purpose of this document is to show you how to call Perl subroutines
  directly from C, i.e., how to write <i>callbacks</i>.
<div class="Pp"></div>
Apart from discussing the C interface provided by Perl for writing callbacks the
  document uses a series of examples to show how the interface actually works in
  practice. In addition some techniques for coding callbacks are covered.
<div class="Pp"></div>
Examples where callbacks are necessary include
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">An Error Handler
    <div style="height: 1.00em;">&#x00A0;</div>
    You have created an XSUB interface to an application's C API.
    <div style="height: 1.00em;">&#x00A0;</div>
    A fairly common feature in applications is to allow you to define a C
      function that will be called whenever something nasty occurs. What we
      would like is to be able to specify a Perl subroutine that will be called
      instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">An Event-Driven Program
    <div style="height: 1.00em;">&#x00A0;</div>
    The classic example of where callbacks are used is when writing an event
      driven program, such as for an X11 application. In this case you register
      functions to be called whenever specific events occur, e.g., a mouse
      button is pressed, the cursor moves into a window or a menu item is
      selected.</dd>
</dl>
<div class="Pp"></div>
Although the techniques described here are applicable when embedding Perl in a C
  program, this is not the primary goal of this document. There are other
  details that must be considered and are specific to embedding Perl. For
  details on embedding Perl in C refer to perlembed.
<div class="Pp"></div>
Before you launch yourself head first into the rest of this document, it would
  be a good idea to have read the following two documents--perlxs and perlguts.
<h1 class="Sh" title="Sh" id="THE_CALL__FUNCTIONS"><a class="selflink" href="#THE_CALL__FUNCTIONS">THE
  CALL_ FUNCTIONS</a></h1>
Although this stuff is easier to explain using examples, you first need be aware
  of a few important definitions.
<div class="Pp"></div>
Perl has a number of C functions that allow you to call Perl subroutines. They
  are
<div class="Pp"></div>
<pre>
    I32 call_sv(SV* sv, I32 flags);
    I32 call_pv(char *subname, I32 flags);
    I32 call_method(char *methname, I32 flags);
    I32 call_argv(char *subname, I32 flags, register char **argv);
</pre>
<div class="Pp"></div>
The key function is <i>call_sv</i>. All the other functions are fairly simple
  wrappers which make it easier to call Perl subroutines in special cases. At
  the end of the day they will all call <i>call_sv</i> to invoke the Perl
  subroutine.
<div class="Pp"></div>
All the <i>call_*</i> functions have a &quot;flags&quot; parameter which is used
  to pass a bit mask of options to Perl. This bit mask operates identically for
  each of the functions. The settings available in the bit mask are discussed in
  &quot;FLAG VALUES&quot;.
<div class="Pp"></div>
Each of the functions will now be discussed in turn.
<dl class="Bl-tag">
  <dt class="It-tag">call_sv</dt>
  <dd class="It-tag"><i>call_sv</i> takes two parameters. The first,
      &quot;sv&quot;, is an SV*. This allows you to specify the Perl subroutine
      to be called either as a C string (which has first been converted to an
      SV) or a reference to a subroutine. The section, <i>Using call_sv</i>,
      shows how you can make use of <i>call_sv</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">call_pv</dt>
  <dd class="It-tag">The function, <i>call_pv</i>, is similar to <i>call_sv</i>
      except it expects its first parameter to be a C char* which identifies the
      Perl subroutine you want to call, e.g., &quot;call_pv(&quot;fred&quot;,
      0)&quot;. If the subroutine you want to call is in another package, just
      include the package name in the string, e.g., &quot;pkg::fred&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">call_method</dt>
  <dd class="It-tag">The function <i>call_method</i> is used to call a method
      from a Perl class. The parameter &quot;methname&quot; corresponds to the
      name of the method to be called. Note that the class that the method
      belongs to is passed on the Perl stack rather than in the parameter list.
      This class can be either the name of the class (for a static method) or a
      reference to an object (for a virtual method). See perlobj for more
      information on static and virtual methods and &quot;Using
      call_method&quot; for an example of using <i>call_method</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">call_argv</dt>
  <dd class="It-tag"><i>call_argv</i> calls the Perl subroutine specified by the
      C string stored in the &quot;subname&quot; parameter. It also takes the
      usual &quot;flags&quot; parameter. The final parameter, &quot;argv&quot;,
      consists of a NULL-terminated list of C strings to be passed as parameters
      to the Perl subroutine. See <i>Using call_argv</i>.</dd>
</dl>
<div class="Pp"></div>
All the functions return an integer. This is a count of the number of items
  returned by the Perl subroutine. The actual items returned by the subroutine
  are stored on the Perl stack.
<div class="Pp"></div>
As a general rule you should <i>always</i> check the return value from these
  functions. Even if you are expecting only a particular number of values to be
  returned from the Perl subroutine, there is nothing to stop someone from doing
  something unexpected--don't say you haven't been warned.
<h1 class="Sh" title="Sh" id="FLAG_VALUES"><a class="selflink" href="#FLAG_VALUES">FLAG
  VALUES</a></h1>
The &quot;flags&quot; parameter in all the <i>call_*</i> functions is one of
  G_VOID, G_SCALAR, or G_ARRAY, which indicate the call context, OR'ed together
  with a bit mask of any combination of the other G_* symbols defined below.
<h2 class="Ss" title="Ss" id="G_VOID"><a class="selflink" href="#G_VOID">G_VOID</a></h2>
Calls the Perl subroutine in a void context.
<div class="Pp"></div>
This flag has 2 effects:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">It indicates to the subroutine being called that it is
      executing in a void context (if it executes <i>wantarray</i> the result
      will be the undefined value).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">It ensures that nothing is actually returned from the
      subroutine.</dd>
</dl>
<div class="Pp"></div>
The value returned by the <i>call_*</i> function indicates how many items have
  been returned by the Perl subroutine--in this case it will be 0.
<h2 class="Ss" title="Ss" id="G_SCALAR"><a class="selflink" href="#G_SCALAR">G_SCALAR</a></h2>
Calls the Perl subroutine in a scalar context. This is the default context flag
  setting for all the <i>call_*</i> functions.
<div class="Pp"></div>
This flag has 2 effects:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">It indicates to the subroutine being called that it is
      executing in a scalar context (if it executes <i>wantarray</i> the result
      will be false).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">It ensures that only a scalar is actually returned from the
      subroutine. The subroutine can, of course, ignore the <i>wantarray</i> and
      return a list anyway. If so, then only the last element of the list will
      be returned.</dd>
</dl>
<div class="Pp"></div>
The value returned by the <i>call_*</i> function indicates how many items have
  been returned by the Perl subroutine - in this case it will be either 0 or 1.
<div class="Pp"></div>
If 0, then you have specified the G_DISCARD flag.
<div class="Pp"></div>
If 1, then the item actually returned by the Perl subroutine will be stored on
  the Perl stack - the section <i>Returning a Scalar</i> shows how to access
  this value on the stack. Remember that regardless of how many items the Perl
  subroutine returns, only the last one will be accessible from the stack -
  think of the case where only one value is returned as being a list with only
  one element. Any other items that were returned will not exist by the time
  control returns from the <i>call_*</i> function. The section <i>Returning a
  list in a scalar</i> <i>context</i> shows an example of this behavior.
<h2 class="Ss" title="Ss" id="G_ARRAY"><a class="selflink" href="#G_ARRAY">G_ARRAY</a></h2>
Calls the Perl subroutine in a list context.
<div class="Pp"></div>
As with G_SCALAR, this flag has 2 effects:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">It indicates to the subroutine being called that it is
      executing in a list context (if it executes <i>wantarray</i> the result
      will be true).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">It ensures that all items returned from the subroutine will
      be accessible when control returns from the <i>call_*</i> function.</dd>
</dl>
<div class="Pp"></div>
The value returned by the <i>call_*</i> function indicates how many items have
  been returned by the Perl subroutine.
<div class="Pp"></div>
If 0, then you have specified the G_DISCARD flag.
<div class="Pp"></div>
If not 0, then it will be a count of the number of items returned by the
  subroutine. These items will be stored on the Perl stack. The section
  <i>Returning a list of values</i> gives an example of using the G_ARRAY flag
  and the mechanics of accessing the returned items from the Perl stack.
<h2 class="Ss" title="Ss" id="G_DISCARD"><a class="selflink" href="#G_DISCARD">G_DISCARD</a></h2>
By default, the <i>call_*</i> functions place the items returned from by the
  Perl subroutine on the stack. If you are not interested in these items, then
  setting this flag will make Perl get rid of them automatically for you. Note
  that it is still possible to indicate a context to the Perl subroutine by
  using either G_SCALAR or G_ARRAY.
<div class="Pp"></div>
If you do not set this flag then it is <i>very</i> important that you make sure
  that any temporaries (i.e., parameters passed to the Perl subroutine and
  values returned from the subroutine) are disposed of yourself. The section
  <i>Returning a Scalar</i> gives details of how to dispose of these temporaries
  explicitly and the section <i>Using Perl to</i> <i>dispose of temporaries</i>
  discusses the specific circumstances where you can ignore the problem and let
  Perl deal with it for you.
<h2 class="Ss" title="Ss" id="G_NOARGS"><a class="selflink" href="#G_NOARGS">G_NOARGS</a></h2>
Whenever a Perl subroutine is called using one of the <i>call_*</i> functions,
  it is assumed by default that parameters are to be passed to the subroutine.
  If you are not passing any parameters to the Perl subroutine, you can save a
  bit of time by setting this flag. It has the effect of not creating the @_
  array for the Perl subroutine.
<div class="Pp"></div>
Although the functionality provided by this flag may seem straightforward, it
  should be used only if there is a good reason to do so. The reason for being
  cautious is that, even if you have specified the G_NOARGS flag, it is still
  possible for the Perl subroutine that has been called to think that you have
  passed it parameters.
<div class="Pp"></div>
In fact, what can happen is that the Perl subroutine you have called can access
  the @_ array from a previous Perl subroutine. This will occur when the code
  that is executing the <i>call_*</i> function has itself been called from
  another Perl subroutine. The code below illustrates this
<div class="Pp"></div>
<pre>
    sub fred
      { print &quot;@_\n&quot;  }
    sub joe
      { &amp;fred }
    &amp;joe(1,2,3);
</pre>
<div class="Pp"></div>
This will print
<div class="Pp"></div>
<pre>
    1 2 3
</pre>
<div class="Pp"></div>
What has happened is that &quot;fred&quot; accesses the @_ array which belongs
  to &quot;joe&quot;.
<h2 class="Ss" title="Ss" id="G_EVAL"><a class="selflink" href="#G_EVAL">G_EVAL</a></h2>
It is possible for the Perl subroutine you are calling to terminate abnormally,
  e.g., by calling <i>die</i> explicitly or by not actually existing. By
  default, when either of these events occurs, the process will terminate
  immediately. If you want to trap this type of event, specify the G_EVAL flag.
  It will put an <i>eval { }</i> around the subroutine call.
<div class="Pp"></div>
Whenever control returns from the <i>call_*</i> function you need to check the
  $@ variable as you would in a normal Perl script.
<div class="Pp"></div>
The value returned from the <i>call_*</i> function is dependent on what other
  flags have been specified and whether an error has occurred. Here are all the
  different cases that can occur:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If the <i>call_*</i> function returns normally, then the
      value returned is as specified in the previous sections.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If G_DISCARD is specified, the return value will always be
      0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If G_ARRAY is specified <i>and</i> an error has occurred,
      the return value will always be 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If G_SCALAR is specified <i>and</i> an error has occurred,
      the return value will be 1 and the value on the top of the stack will be
      <i>undef</i>. This means that if you have already detected the error by
      checking $@ and you want the program to continue, you must remember to pop
      the <i>undef</i> from the stack.</dd>
</dl>
<div class="Pp"></div>
See <i>Using G_EVAL</i> for details on using G_EVAL.
<h2 class="Ss" title="Ss" id="G_KEEPERR"><a class="selflink" href="#G_KEEPERR">G_KEEPERR</a></h2>
Using the G_EVAL flag described above will always set $@: clearing it if there
  was no error, and setting it to describe the error if there was an error in
  the called code. This is what you want if your intention is to handle possible
  errors, but sometimes you just want to trap errors and stop them interfering
  with the rest of the program.
<div class="Pp"></div>
This scenario will mostly be applicable to code that is meant to be called from
  within destructors, asynchronous callbacks, and signal handlers. In such
  situations, where the code being called has little relation to the surrounding
  dynamic context, the main program needs to be insulated from errors in the
  called code, even if they can't be handled intelligently. It may also be
  useful to do this with code for &quot;__DIE__&quot; or &quot;__WARN__&quot;
  hooks, and &quot;tie&quot; functions.
<div class="Pp"></div>
The G_KEEPERR flag is meant to be used in conjunction with G_EVAL in
  <i>call_*</i> functions that are used to implement such code, or with
  &quot;eval_sv&quot;. This flag has no effect on the &quot;call_*&quot;
  functions when G_EVAL is not used.
<div class="Pp"></div>
When G_KEEPERR is used, any error in the called code will terminate the call as
  usual, and the error will not propagate beyond the call (as usual for G_EVAL),
  but it will not go into $@. Instead the error will be converted into a
  warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be
  disabled using &quot;no warnings 'misc'&quot;. If there is no error, $@ will
  not be cleared.
<div class="Pp"></div>
Note that the G_KEEPERR flag does not propagate into inner evals; these may
  still set $@.
<div class="Pp"></div>
The G_KEEPERR flag was introduced in Perl version 5.002.
<div class="Pp"></div>
See <i>Using G_KEEPERR</i> for an example of a situation that warrants the use
  of this flag.
<h2 class="Ss" title="Ss" id="Determining_the_Context"><a class="selflink" href="#Determining_the_Context">Determining
  the Context</a></h2>
As mentioned above, you can determine the context of the currently executing
  subroutine in Perl with <i>wantarray</i>. The equivalent test can be made in C
  by using the &quot;GIMME_V&quot; macro, which returns &quot;G_ARRAY&quot; if
  you have been called in a list context, &quot;G_SCALAR&quot; if in a scalar
  context, or &quot;G_VOID&quot; if in a void context (i.e., the return value
  will not be used). An older version of this macro is called &quot;GIMME&quot;;
  in a void context it returns &quot;G_SCALAR&quot; instead of
  &quot;G_VOID&quot;. An example of using the &quot;GIMME_V&quot; macro is shown
  in section <i>Using GIMME_V</i>.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
Enough of the definition talk! Let's have a few examples.
<div class="Pp"></div>
Perl provides many macros to assist in accessing the Perl stack. Wherever
  possible, these macros should always be used when interfacing to Perl
  internals. We hope this should make the code less vulnerable to any changes
  made to Perl in the future.
<div class="Pp"></div>
Another point worth noting is that in the first series of examples I have made
  use of only the <i>call_pv</i> function. This has been done to keep the code
  simpler and ease you into the topic. Wherever possible, if the choice is
  between using <i>call_pv</i> and <i>call_sv</i>, you should always try to use
  <i>call_sv</i>. See <i>Using call_sv</i> for details.
<h2 class="Ss" title="Ss" id="No_Parameters,_Nothing_Returned"><a class="selflink" href="#No_Parameters,_Nothing_Returned">No
  Parameters, Nothing Returned</a></h2>
This first trivial example will call a Perl subroutine, <i>PrintUID</i>, to
  print out the UID of the process.
<div class="Pp"></div>
<pre>
    sub PrintUID
    {
        print &quot;UID is $&lt;\n&quot;;
    }
</pre>
<div class="Pp"></div>
and here is a C function to call it
<div class="Pp"></div>
<pre>
    static void
    call_PrintUID()
    {
        dSP;
        PUSHMARK(SP);
        call_pv(&quot;PrintUID&quot;, G_DISCARD|G_NOARGS);
    }
</pre>
<div class="Pp"></div>
Simple, eh?
<div class="Pp"></div>
A few points to note about this example:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Ignore &quot;dSP&quot; and &quot;PUSHMARK(SP)&quot; for
      now. They will be discussed in the next example.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">We aren't passing any parameters to <i>PrintUID</i> so
      G_NOARGS can be specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">We aren't interested in anything returned from
      <i>PrintUID</i>, so G_DISCARD is specified. Even if <i>PrintUID</i> was
      changed to return some value(s), having specified G_DISCARD will mean that
      they will be wiped by the time control returns from <i>call_pv</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">As <i>call_pv</i> is being used, the Perl subroutine is
      specified as a C string. In this case the subroutine name has been
      'hard-wired' into the code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">Because we specified G_DISCARD, it is not necessary to
      check the value returned from <i>call_pv</i>. It will always be 0.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Passing_Parameters"><a class="selflink" href="#Passing_Parameters">Passing
  Parameters</a></h2>
Now let's make a slightly more complex example. This time we want to call a Perl
  subroutine, &quot;LeftString&quot;, which will take 2 parameters--a string
  ($s) and an integer ($n). The subroutine will simply print the first $n
  characters of the string.
<div class="Pp"></div>
So the Perl subroutine would look like this:
<div class="Pp"></div>
<pre>
    sub LeftString
    {
        my($s, $n) = @_;
        print substr($s, 0, $n), &quot;\n&quot;;
    }
</pre>
<div class="Pp"></div>
The C function required to call <i>LeftString</i> would look like this:
<div class="Pp"></div>
<pre>
    static void
    call_LeftString(a, b)
    char * a;
    int b;
    {
        dSP;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSVpv(a, 0)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        call_pv(&quot;LeftString&quot;, G_DISCARD);
        FREETMPS;
        LEAVE;
    }
</pre>
<div class="Pp"></div>
Here are a few notes on the C function <i>call_LeftString</i>.
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Parameters are passed to the Perl subroutine using the Perl
      stack. This is the purpose of the code beginning with the line
      &quot;dSP&quot; and ending with the line &quot;PUTBACK&quot;. The
      &quot;dSP&quot; declares a local copy of the stack pointer. This local
      copy should <b>always</b> be accessed as &quot;SP&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">If you are going to put something onto the Perl stack, you
      need to know where to put it. This is the purpose of the macro
      &quot;dSP&quot;--it declares and initializes a <i>local</i> copy of the
      Perl stack pointer.
    <div style="height: 1.00em;">&#x00A0;</div>
    All the other macros which will be used in this example require you to have
      used this macro.
    <div style="height: 1.00em;">&#x00A0;</div>
    The exception to this rule is if you are calling a Perl subroutine directly
      from an XSUB function. In this case it is not necessary to use the
      &quot;dSP&quot; macro explicitly--it will be declared for you
      automatically.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Any parameters to be pushed onto the stack should be
      bracketed by the &quot;PUSHMARK&quot; and &quot;PUTBACK&quot; macros. The
      purpose of these two macros, in this context, is to count the number of
      parameters you are pushing automatically. Then whenever Perl is creating
      the @_ array for the subroutine, it knows how big to make it.
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;PUSHMARK&quot; macro tells Perl to make a mental note of the
      current stack pointer. Even if you aren't passing any parameters (like the
      example shown in the section <i>No Parameters, Nothing Returned</i>) you
      must still call the &quot;PUSHMARK&quot; macro before you can call any of
      the <i>call_*</i> functions--Perl still needs to know that there are no
      parameters.
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;PUTBACK&quot; macro sets the global copy of the stack pointer to
      be the same as our local copy. If we didn't do this, <i>call_pv</i>
      wouldn't know where the two parameters we pushed were--remember that up to
      now all the stack pointer manipulation we have done is with our local
      copy, <i>not</i> the global copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">Next, we come to XPUSHs. This is where the parameters
      actually get pushed onto the stack. In this case we are pushing a string
      and an integer.
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;XSUBs and the Argument Stack&quot; in perlguts for details on how
      the XPUSH macros work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">Because we created temporary values (by means of
      <i>sv_2mortal()</i> calls) we will have to tidy up the Perl stack and
      dispose of mortal SVs.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is the purpose of
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ENTER;
    SAVETMPS;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    at the start of the function, and
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    FREETMPS;
    LEAVE;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    at the end. The &quot;ENTER&quot;/&quot;SAVETMPS&quot; pair creates a
      boundary for any temporaries we create. This means that the temporaries we
      get rid of will be limited to those which were created after these calls.
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;FREETMPS&quot;/&quot;LEAVE&quot; pair will get rid of any values
      returned by the Perl subroutine (see next example), plus it will also dump
      the mortal SVs we have created. Having
      &quot;ENTER&quot;/&quot;SAVETMPS&quot; at the beginning of the code makes
      sure that no other mortals are destroyed.
    <div style="height: 1.00em;">&#x00A0;</div>
    Think of these macros as working a bit like &quot;{&quot; and &quot;}&quot;
      in Perl to limit the scope of local variables.
    <div style="height: 1.00em;">&#x00A0;</div>
    See the section <i>Using Perl to Dispose of Temporaries</i> for details of
      an alternative to using these macros.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6.</dt>
  <dd class="It-tag">Finally, <i>LeftString</i> can now be called via the
      <i>call_pv</i> function. The only flag specified this time is G_DISCARD.
      Because we are passing 2 parameters to the Perl subroutine this time, we
      have not specified G_NOARGS.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Returning_a_Scalar"><a class="selflink" href="#Returning_a_Scalar">Returning
  a Scalar</a></h2>
Now for an example of dealing with the items returned from a Perl subroutine.
<div class="Pp"></div>
Here is a Perl subroutine, <i>Adder</i>, that takes 2 integer parameters and
  simply returns their sum.
<div class="Pp"></div>
<pre>
    sub Adder
    {
        my($a, $b) = @_;
        $a + $b;
    }
</pre>
<div class="Pp"></div>
Because we are now concerned with the return value from <i>Adder</i>, the C
  function required to call it is now a bit more complex.
<div class="Pp"></div>
<pre>
    static void
    call_Adder(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;Adder&quot;, G_SCALAR);
        SPAGAIN;
        if (count != 1)
            croak(&quot;Big trouble\n&quot;);
        printf (&quot;The sum of %d and %d is %d\n&quot;, a, b, POPi);
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<div class="Pp"></div>
Points to note this time are
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">The only flag specified this time was G_SCALAR. That means
      that the @_ array will be created and that the value returned by
      <i>Adder</i> will still exist after the call to <i>call_pv</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">The purpose of the macro &quot;SPAGAIN&quot; is to refresh
      the local copy of the stack pointer. This is necessary because it is
      possible that the memory allocated to the Perl stack has been reallocated
      during the <i>call_pv</i> call.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you are making use of the Perl stack pointer in your code you must always
      refresh the local copy using SPAGAIN whenever you make use of the
      <i>call_*</i> functions or any other Perl internal function.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Although only a single value was expected to be returned
      from <i>Adder</i>, it is still good practice to check the return code from
      <i>call_pv</i> anyway.
    <div style="height: 1.00em;">&#x00A0;</div>
    Expecting a single value is not quite the same as knowing that there will be
      one. If someone modified <i>Adder</i> to return a list and we didn't check
      for that possibility and take appropriate action the Perl stack would end
      up in an inconsistent state. That is something you <i>really</i> don't
      want to happen ever.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">The &quot;POPi&quot; macro is used here to pop the return
      value from the stack. In this case we wanted an integer, so
      &quot;POPi&quot; was used.
    <div style="height: 1.00em;">&#x00A0;</div>
    Here is the complete list of POP macros available, along with the types they
      return.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    POPs        SV
    POPp        pointer
    POPn        double
    POPi        integer
    POPl        long
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">The final &quot;PUTBACK&quot; is used to leave the Perl
      stack in a consistent state before exiting the function. This is necessary
      because when we popped the return value from the stack with
      &quot;POPi&quot; it updated only our local copy of the stack pointer.
      Remember, &quot;PUTBACK&quot; sets the global stack pointer to be the same
      as our local copy.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Returning_a_List_of_Values"><a class="selflink" href="#Returning_a_List_of_Values">Returning
  a List of Values</a></h2>
Now, let's extend the previous example to return both the sum of the parameters
  and the difference.
<div class="Pp"></div>
Here is the Perl subroutine
<div class="Pp"></div>
<pre>
    sub AddSubtract
    {
       my($a, $b) = @_;
       ($a+$b, $a-$b);
    }
</pre>
<div class="Pp"></div>
and this is the C function
<div class="Pp"></div>
<pre>
    static void
    call_AddSubtract(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;AddSubtract&quot;, G_ARRAY);
        SPAGAIN;
        if (count != 2)
            croak(&quot;Big trouble\n&quot;);
        printf (&quot;%d - %d = %d\n&quot;, a, b, POPi);
        printf (&quot;%d + %d = %d\n&quot;, a, b, POPi);
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<div class="Pp"></div>
If <i>call_AddSubtract</i> is called like this
<div class="Pp"></div>
<pre>
    call_AddSubtract(7, 4);
</pre>
<div class="Pp"></div>
then here is the output
<div class="Pp"></div>
<pre>
    7 - 4 = 3
    7 + 4 = 11
</pre>
<div class="Pp"></div>
Notes
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">We wanted list context, so G_ARRAY was used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Not surprisingly &quot;POPi&quot; is used twice this time
      because we were retrieving 2 values from the stack. The important thing to
      note is that when using the &quot;POP*&quot; macros they come off the
      stack in <i>reverse</i> order.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Returning_a_List_in_a_Scalar_Context"><a class="selflink" href="#Returning_a_List_in_a_Scalar_Context">Returning
  a List in a Scalar Context</a></h2>
Say the Perl subroutine in the previous section was called in a scalar context,
  like this
<div class="Pp"></div>
<pre>
    static void
    call_AddSubScalar(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        int i;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;AddSubtract&quot;, G_SCALAR);
        SPAGAIN;
        printf (&quot;Items Returned = %d\n&quot;, count);
        for (i = 1; i &lt;= count; ++i)
            printf (&quot;Value %d = %d\n&quot;, i, POPi);
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<div class="Pp"></div>
The other modification made is that <i>call_AddSubScalar</i> will print the
  number of items returned from the Perl subroutine and their value (for
  simplicity it assumes that they are integer). So if <i>call_AddSubScalar</i>
  is called
<div class="Pp"></div>
<pre>
    call_AddSubScalar(7, 4);
</pre>
<div class="Pp"></div>
then the output will be
<div class="Pp"></div>
<pre>
    Items Returned = 1
    Value 1 = 3
</pre>
<div class="Pp"></div>
In this case the main point to note is that only the last item in the list is
  returned from the subroutine. <i>AddSubtract</i> actually made it back to
  <i>call_AddSubScalar</i>.
<h2 class="Ss" title="Ss" id="Returning_Data_from_Perl_via_the_Parameter_List"><a class="selflink" href="#Returning_Data_from_Perl_via_the_Parameter_List">Returning
  Data from Perl via the Parameter List</a></h2>
It is also possible to return values directly via the parameter list--whether it
  is actually desirable to do it is another matter entirely.
<div class="Pp"></div>
The Perl subroutine, <i>Inc</i>, below takes 2 parameters and increments each
  directly.
<div class="Pp"></div>
<pre>
    sub Inc
    {
        ++ $_[0];
        ++ $_[1];
    }
</pre>
<div class="Pp"></div>
and here is a C function to call it.
<div class="Pp"></div>
<pre>
    static void
    call_Inc(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        SV * sva;
        SV * svb;
        ENTER;
        SAVETMPS;
        sva = sv_2mortal(newSViv(a));
        svb = sv_2mortal(newSViv(b));
        PUSHMARK(SP);
        XPUSHs(sva);
        XPUSHs(svb);
        PUTBACK;
        count = call_pv(&quot;Inc&quot;, G_DISCARD);
        if (count != 0)
            croak (&quot;call_Inc: expected 0 values from 'Inc', got %d\n&quot;,
                   count);
        printf (&quot;%d + 1 = %d\n&quot;, a, SvIV(sva));
        printf (&quot;%d + 1 = %d\n&quot;, b, SvIV(svb));
        FREETMPS;
        LEAVE;
    }
</pre>
<div class="Pp"></div>
To be able to access the two parameters that were pushed onto the stack after
  they return from <i>call_pv</i> it is necessary to make a note of their
  addresses--thus the two variables &quot;sva&quot; and &quot;svb&quot;.
<div class="Pp"></div>
The reason this is necessary is that the area of the Perl stack which held them
  will very likely have been overwritten by something else by the time control
  returns from <i>call_pv</i>.
<h2 class="Ss" title="Ss" id="Using_G_EVAL"><a class="selflink" href="#Using_G_EVAL">Using
  G_EVAL</a></h2>
Now an example using G_EVAL. Below is a Perl subroutine which computes the
  difference of its 2 parameters. If this would result in a negative result, the
  subroutine calls <i>die</i>.
<div class="Pp"></div>
<pre>
    sub Subtract
    {
        my ($a, $b) = @_;
        die &quot;death can be fatal\n&quot; if $a &lt; $b;
        $a - $b;
    }
</pre>
<div class="Pp"></div>
and some C to call it
<div class="Pp"></div>
<pre>
    static void
    call_Subtract(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;Subtract&quot;, G_EVAL|G_SCALAR);
        SPAGAIN;
        /* Check the eval first */
        if (SvTRUE(ERRSV))
        {
            printf (&quot;Uh oh - %s\n&quot;, SvPV_nolen(ERRSV));
            POPs;
        }
        else
        {
            if (count != 1)
               croak(&quot;call_Subtract: wanted 1 value from 'Subtract', got %d\n&quot;,
                        count);
            printf (&quot;%d - %d = %d\n&quot;, a, b, POPi);
        }
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<div class="Pp"></div>
If <i>call_Subtract</i> is called thus
<div class="Pp"></div>
<pre>
    call_Subtract(4, 5)
</pre>
<div class="Pp"></div>
the following will be printed
<div class="Pp"></div>
<pre>
    Uh oh - death can be fatal
</pre>
<div class="Pp"></div>
Notes
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">We want to be able to catch the <i>die</i> so we have used
      the G_EVAL flag. Not specifying this flag would mean that the program
      would terminate immediately at the <i>die</i> statement in the subroutine
      <i>Subtract</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">The code
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    if (SvTRUE(ERRSV))
    {
        printf (&quot;Uh oh - %s\n&quot;, SvPV_nolen(ERRSV));
        POPs;
    }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    is the direct equivalent of this bit of Perl
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print &quot;Uh oh - $@\n&quot; if $@;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;PL_errgv&quot; is a perl global of type &quot;GV *&quot; that points
      to the symbol table entry containing the error. &quot;ERRSV&quot;
      therefore refers to the C equivalent of $@.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Note that the stack is popped using &quot;POPs&quot; in the
      block where &quot;SvTRUE(ERRSV)&quot; is true. This is necessary because
      whenever a <i>call_*</i> function invoked with G_EVAL|G_SCALAR returns an
      error, the top of the stack holds the value <i>undef</i>. Because we want
      the program to continue after detecting this error, it is essential that
      the stack be tidied up by removing the <i>undef</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Using_G_KEEPERR"><a class="selflink" href="#Using_G_KEEPERR">Using
  G_KEEPERR</a></h2>
Consider this rather facetious example, where we have used an XS version of the
  call_Subtract example above inside a destructor:
<div class="Pp"></div>
<pre>
    package Foo;
    sub new { bless {}, $_[0] }
    sub Subtract {
        my($a,$b) = @_;
        die &quot;death can be fatal&quot; if $a &lt; $b;
        $a - $b;
    }
    sub DESTROY { call_Subtract(5, 4); }
    sub foo { die &quot;foo dies&quot;; }
    package main;
    {
        my $foo = Foo-&gt;new;
        eval { $foo-&gt;foo };
    }
    print &quot;Saw: $@&quot; if $@;             # should be, but isn't
</pre>
<div class="Pp"></div>
This example will fail to recognize that an error occurred inside the &quot;eval
  {}&quot;. Here's why: the call_Subtract code got executed while perl was
  cleaning up temporaries when exiting the outer braced block, and because
  call_Subtract is implemented with <i>call_pv</i> using the G_EVAL flag, it
  promptly reset $@. This results in the failure of the outermost test for $@,
  and thereby the failure of the error trap.
<div class="Pp"></div>
Appending the G_KEEPERR flag, so that the <i>call_pv</i> call in call_Subtract
  reads:
<div class="Pp"></div>
<pre>
        count = call_pv(&quot;Subtract&quot;, G_EVAL|G_SCALAR|G_KEEPERR);
</pre>
<div class="Pp"></div>
will preserve the error and restore reliable error handling.
<h2 class="Ss" title="Ss" id="Using_call_sv"><a class="selflink" href="#Using_call_sv">Using
  call_sv</a></h2>
In all the previous examples I have 'hard-wired' the name of the Perl subroutine
  to be called from C. Most of the time though, it is more convenient to be able
  to specify the name of the Perl subroutine from within the Perl script.
<div class="Pp"></div>
Consider the Perl code below
<div class="Pp"></div>
<pre>
    sub fred
    {
        print &quot;Hello there\n&quot;;
    }
    CallSubPV(&quot;fred&quot;);
</pre>
<div class="Pp"></div>
Here is a snippet of XSUB which defines <i>CallSubPV</i>.
<div class="Pp"></div>
<pre>
    void
    CallSubPV(name)
        char *  name
        CODE:
        PUSHMARK(SP);
        call_pv(name, G_DISCARD|G_NOARGS);
</pre>
<div class="Pp"></div>
That is fine as far as it goes. The thing is, the Perl subroutine can be
  specified as only a string. For Perl 4 this was adequate, but Perl 5 allows
  references to subroutines and anonymous subroutines. This is where
  <i>call_sv</i> is useful.
<div class="Pp"></div>
The code below for <i>CallSubSV</i> is identical to <i>CallSubPV</i> except that
  the &quot;name&quot; parameter is now defined as an SV* and we use
  <i>call_sv</i> instead of <i>call_pv</i>.
<div class="Pp"></div>
<pre>
    void
    CallSubSV(name)
        SV *    name
        CODE:
        PUSHMARK(SP);
        call_sv(name, G_DISCARD|G_NOARGS);
</pre>
<div class="Pp"></div>
Because we are using an SV to call <i>fred</i> the following can all be used:
<div class="Pp"></div>
<pre>
    CallSubSV(&quot;fred&quot;);
    CallSubSV(\&amp;fred);
    $ref = \&amp;fred;
    CallSubSV($ref);
    CallSubSV( sub { print &quot;Hello there\n&quot; } );
</pre>
<div class="Pp"></div>
As you can see, <i>call_sv</i> gives you much greater flexibility in how you can
  specify the Perl subroutine.
<div class="Pp"></div>
You should note that, if it is necessary to store the SV (&quot;name&quot; in
  the example above) which corresponds to the Perl subroutine so that it can be
  used later in the program, it not enough just to store a copy of the pointer
  to the SV. Say the code above had been like this:
<div class="Pp"></div>
<pre>
    static SV * rememberSub;
    void
    SaveSub1(name)
        SV *    name
        CODE:
        rememberSub = name;
    void
    CallSavedSub1()
        CODE:
        PUSHMARK(SP);
        call_sv(rememberSub, G_DISCARD|G_NOARGS);
</pre>
<div class="Pp"></div>
The reason this is wrong is that, by the time you come to use the pointer
  &quot;rememberSub&quot; in &quot;CallSavedSub1&quot;, it may or may not still
  refer to the Perl subroutine that was recorded in &quot;SaveSub1&quot;. This
  is particularly true for these cases:
<div class="Pp"></div>
<pre>
    SaveSub1(\&amp;fred);
    CallSavedSub1();
    SaveSub1( sub { print &quot;Hello there\n&quot; } );
    CallSavedSub1();
</pre>
<div class="Pp"></div>
By the time each of the &quot;SaveSub1&quot; statements above has been executed,
  the SV*s which corresponded to the parameters will no longer exist. Expect an
  error message from Perl of the form
<div class="Pp"></div>
<pre>
    Can't use an undefined value as a subroutine reference at ...
</pre>
<div class="Pp"></div>
for each of the &quot;CallSavedSub1&quot; lines.
<div class="Pp"></div>
Similarly, with this code
<div class="Pp"></div>
<pre>
    $ref = \&amp;fred;
    SaveSub1($ref);
    $ref = 47;
    CallSavedSub1();
</pre>
<div class="Pp"></div>
you can expect one of these messages (which you actually get is dependent on the
  version of Perl you are using)
<div class="Pp"></div>
<pre>
    Not a CODE reference at ...
    Undefined subroutine &amp;main::47 called ...
</pre>
<div class="Pp"></div>
The variable $ref may have referred to the subroutine &quot;fred&quot; whenever
  the call to &quot;SaveSub1&quot; was made but by the time
  &quot;CallSavedSub1&quot; gets called it now holds the number 47. Because we
  saved only a pointer to the original SV in &quot;SaveSub1&quot;, any changes
  to $ref will be tracked by the pointer &quot;rememberSub&quot;. This means
  that whenever &quot;CallSavedSub1&quot; gets called, it will attempt to
  execute the code which is referenced by the SV* &quot;rememberSub&quot;. In
  this case though, it now refers to the integer 47, so expect Perl to complain
  loudly.
<div class="Pp"></div>
A similar but more subtle problem is illustrated with this code:
<div class="Pp"></div>
<pre>
    $ref = \&amp;fred;
    SaveSub1($ref);
    $ref = \&amp;joe;
    CallSavedSub1();
</pre>
<div class="Pp"></div>
This time whenever &quot;CallSavedSub1&quot; gets called it will execute the
  Perl subroutine &quot;joe&quot; (assuming it exists) rather than
  &quot;fred&quot; as was originally requested in the call to
  &quot;SaveSub1&quot;.
<div class="Pp"></div>
To get around these problems it is necessary to take a full copy of the SV. The
  code below shows &quot;SaveSub2&quot; modified to do that.
<div class="Pp"></div>
<pre>
    static SV * keepSub = (SV*)NULL;
    void
    SaveSub2(name)
        SV *    name
        CODE:
        /* Take a copy of the callback */
        if (keepSub == (SV*)NULL)
            /* First time, so create a new SV */
            keepSub = newSVsv(name);
        else
            /* Been here before, so overwrite */
            SvSetSV(keepSub, name);
    void
    CallSavedSub2()
        CODE:
        PUSHMARK(SP);
        call_sv(keepSub, G_DISCARD|G_NOARGS);
</pre>
<div class="Pp"></div>
To avoid creating a new SV every time &quot;SaveSub2&quot; is called, the
  function first checks to see if it has been called before. If not, then space
  for a new SV is allocated and the reference to the Perl subroutine
  &quot;name&quot; is copied to the variable &quot;keepSub&quot; in one
  operation using &quot;newSVsv&quot;. Thereafter, whenever &quot;SaveSub2&quot;
  is called, the existing SV, &quot;keepSub&quot;, is overwritten with the new
  value using &quot;SvSetSV&quot;.
<h2 class="Ss" title="Ss" id="Using_call_argv"><a class="selflink" href="#Using_call_argv">Using
  call_argv</a></h2>
Here is a Perl subroutine which prints whatever parameters are passed to it.
<div class="Pp"></div>
<pre>
    sub PrintList
    {
        my(@list) = @_;
        foreach (@list) { print &quot;$_\n&quot; }
    }
</pre>
<div class="Pp"></div>
And here is an example of <i>call_argv</i> which will call <i>PrintList</i>.
<div class="Pp"></div>
<pre>
    static char * words[] = {&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;, NULL};
    static void
    call_PrintList()
    {
        dSP;
        call_argv(&quot;PrintList&quot;, G_DISCARD, words);
    }
</pre>
<div class="Pp"></div>
Note that it is not necessary to call &quot;PUSHMARK&quot; in this instance.
  This is because <i>call_argv</i> will do it for you.
<h2 class="Ss" title="Ss" id="Using_call_method"><a class="selflink" href="#Using_call_method">Using
  call_method</a></h2>
Consider the following Perl code:
<div class="Pp"></div>
<pre>
    {
        package Mine;
        sub new
        {
            my($type) = shift;
            bless [@_]
        }
        sub Display
        {
            my ($self, $index) = @_;
            print &quot;$index: $$self[$index]\n&quot;;
        }
        sub PrintID
        {
            my($class) = @_;
            print &quot;This is Class $class version 1.0\n&quot;;
        }
    }
</pre>
<div class="Pp"></div>
It implements just a very simple class to manage an array. Apart from the
  constructor, &quot;new&quot;, it declares methods, one static and one virtual.
  The static method, &quot;PrintID&quot;, prints out simply the class name and a
  version number. The virtual method, &quot;Display&quot;, prints out a single
  element of the array. Here is an all-Perl example of using it.
<div class="Pp"></div>
<pre>
    $a = Mine-&gt;new('red', 'green', 'blue');
    $a-&gt;Display(1);
    Mine-&gt;PrintID;
</pre>
<div class="Pp"></div>
will print
<div class="Pp"></div>
<pre>
    1: green
    This is Class Mine version 1.0
</pre>
<div class="Pp"></div>
Calling a Perl method from C is fairly straightforward. The following things are
  required:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A reference to the object for a virtual method or the name
      of the class for a static method</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The name of the method</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Any other parameters specific to the method</dd>
</dl>
<div class="Pp"></div>
Here is a simple XSUB which illustrates the mechanics of calling both the
  &quot;PrintID&quot; and &quot;Display&quot; methods from C.
<div class="Pp"></div>
<pre>
    void
    call_Method(ref, method, index)
        SV *    ref
        char *  method
        int             index
        CODE:
        PUSHMARK(SP);
        XPUSHs(ref);
        XPUSHs(sv_2mortal(newSViv(index)));
        PUTBACK;
        call_method(method, G_DISCARD);
    void
    call_PrintID(class, method)
        char *  class
        char *  method
        CODE:
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSVpv(class, 0)));
        PUTBACK;
        call_method(method, G_DISCARD);
</pre>
<div class="Pp"></div>
So the methods &quot;PrintID&quot; and &quot;Display&quot; can be invoked like
  this:
<div class="Pp"></div>
<pre>
    $a = Mine-&gt;new('red', 'green', 'blue');
    call_Method($a, 'Display', 1);
    call_PrintID('Mine', 'PrintID');
</pre>
<div class="Pp"></div>
The only thing to note is that, in both the static and virtual methods, the
  method name is not passed via the stack--it is used as the first parameter to
  <i>call_method</i>.
<h2 class="Ss" title="Ss" id="Using_GIMME_V"><a class="selflink" href="#Using_GIMME_V">Using
  GIMME_V</a></h2>
Here is a trivial XSUB which prints the context in which it is currently
  executing.
<div class="Pp"></div>
<pre>
    void
    PrintContext()
        CODE:
        I32 gimme = GIMME_V;
        if (gimme == G_VOID)
            printf (&quot;Context is Void\n&quot;);
        else if (gimme == G_SCALAR)
            printf (&quot;Context is Scalar\n&quot;);
        else
            printf (&quot;Context is Array\n&quot;);
</pre>
<div class="Pp"></div>
And here is some Perl to test it.
<div class="Pp"></div>
<pre>
    PrintContext;
    $a = PrintContext;
    @a = PrintContext;
</pre>
<div class="Pp"></div>
The output from that will be
<div class="Pp"></div>
<pre>
    Context is Void
    Context is Scalar
    Context is Array
</pre>
<h2 class="Ss" title="Ss" id="Using_Perl_to_Dispose_of_Temporaries"><a class="selflink" href="#Using_Perl_to_Dispose_of_Temporaries">Using
  Perl to Dispose of Temporaries</a></h2>
In the examples given to date, any temporaries created in the callback (i.e.,
  parameters passed on the stack to the <i>call_*</i> function or values
  returned via the stack) have been freed by one of these methods:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Specifying the G_DISCARD flag with <i>call_*</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Explicitly using the
      &quot;ENTER&quot;/&quot;SAVETMPS&quot;--&quot;FREETMPS&quot;/&quot;LEAVE&quot;
      pairing</dd>
</dl>
<div class="Pp"></div>
There is another method which can be used, namely letting Perl do it for you
  automatically whenever it regains control after the callback has terminated.
  This is done by simply not using the
<div class="Pp"></div>
<pre>
    ENTER;
    SAVETMPS;
    ...
    FREETMPS;
    LEAVE;
</pre>
<div class="Pp"></div>
sequence in the callback (and not, of course, specifying the G_DISCARD flag).
<div class="Pp"></div>
If you are going to use this method you have to be aware of a possible memory
  leak which can arise under very specific circumstances. To explain these
  circumstances you need to know a bit about the flow of control between Perl
  and the callback routine.
<div class="Pp"></div>
The examples given at the start of the document (an error handler and an event
  driven program) are typical of the two main sorts of flow control that you are
  likely to encounter with callbacks. There is a very important distinction
  between them, so pay attention.
<div class="Pp"></div>
In the first example, an error handler, the flow of control could be as follows.
  You have created an interface to an external library. Control can reach the
  external library like this
<div class="Pp"></div>
<pre>
    perl --&gt; XSUB --&gt; external library
</pre>
<div class="Pp"></div>
Whilst control is in the library, an error condition occurs. You have previously
  set up a Perl callback to handle this situation, so it will get executed. Once
  the callback has finished, control will drop back to Perl again. Here is what
  the flow of control will be like in that situation
<div class="Pp"></div>
<pre>
    perl --&gt; XSUB --&gt; external library
                      ...
                      error occurs
                      ...
                      external library --&gt; call_* --&gt; perl
                                                          |
    perl &lt;-- XSUB &lt;-- external library &lt;-- call_* &lt;----+
</pre>
<div class="Pp"></div>
After processing of the error using <i>call_*</i> is completed, control reverts
  back to Perl more or less immediately.
<div class="Pp"></div>
In the diagram, the further right you go the more deeply nested the scope is. It
  is only when control is back with perl on the extreme left of the diagram that
  you will have dropped back to the enclosing scope and any temporaries you have
  left hanging around will be freed.
<div class="Pp"></div>
In the second example, an event driven program, the flow of control will be more
  like this
<div class="Pp"></div>
<pre>
    perl --&gt; XSUB --&gt; event handler
                      ...
                      event handler --&gt; call_* --&gt; perl
                                                       |
                      event handler &lt;-- call_* &lt;----+
                      ...
                      event handler --&gt; call_* --&gt; perl
                                                       |
                      event handler &lt;-- call_* &lt;----+
                      ...
                      event handler --&gt; call_* --&gt; perl
                                                       |
                      event handler &lt;-- call_* &lt;----+
</pre>
<div class="Pp"></div>
In this case the flow of control can consist of only the repeated sequence
<div class="Pp"></div>
<pre>
    event handler --&gt; call_* --&gt; perl
</pre>
<div class="Pp"></div>
for practically the complete duration of the program. This means that control
  may <i>never</i> drop back to the surrounding scope in Perl at the extreme
  left.
<div class="Pp"></div>
So what is the big problem? Well, if you are expecting Perl to tidy up those
  temporaries for you, you might be in for a long wait. For Perl to dispose of
  your temporaries, control must drop back to the enclosing scope at some stage.
  In the event driven scenario that may never happen. This means that, as time
  goes on, your program will create more and more temporaries, none of which
  will ever be freed. As each of these temporaries consumes some memory your
  program will eventually consume all the available memory in your
  system--kapow!
<div class="Pp"></div>
So here is the bottom line--if you are sure that control will revert back to the
  enclosing Perl scope fairly quickly after the end of your callback, then it
  isn't absolutely necessary to dispose explicitly of any temporaries you may
  have created. Mind you, if you are at all uncertain about what to do, it
  doesn't do any harm to tidy up anyway.
<h2 class="Ss" title="Ss" id="Strategies_for_Storing_Callback_Context_Information"><a class="selflink" href="#Strategies_for_Storing_Callback_Context_Information">Strategies
  for Storing Callback Context Information</a></h2>
Potentially one of the trickiest problems to overcome when designing a callback
  interface can be figuring out how to store the mapping between the C callback
  function and the Perl equivalent.
<div class="Pp"></div>
To help understand why this can be a real problem first consider how a callback
  is set up in an all C environment. Typically a C API will provide a function
  to register a callback. This will expect a pointer to a function as one of its
  parameters. Below is a call to a hypothetical function
  &quot;register_fatal&quot; which registers the C function to get called when a
  fatal error occurs.
<div class="Pp"></div>
<pre>
    register_fatal(cb1);
</pre>
<div class="Pp"></div>
The single parameter &quot;cb1&quot; is a pointer to a function, so you must
  have defined &quot;cb1&quot; in your code, say something like this
<div class="Pp"></div>
<pre>
    static void
    cb1()
    {
        printf (&quot;Fatal Error\n&quot;);
        exit(1);
    }
</pre>
<div class="Pp"></div>
Now change that to call a Perl subroutine instead
<div class="Pp"></div>
<pre>
    static SV * callback = (SV*)NULL;
    static void
    cb1()
    {
        dSP;
        PUSHMARK(SP);
        /* Call the Perl sub to process the callback */
        call_sv(callback, G_DISCARD);
    }
    void
    register_fatal(fn)
        SV *    fn
        CODE:
        /* Remember the Perl sub */
        if (callback == (SV*)NULL)
            callback = newSVsv(fn);
        else
            SvSetSV(callback, fn);
        /* register the callback with the external library */
        register_fatal(cb1);
</pre>
<div class="Pp"></div>
where the Perl equivalent of &quot;register_fatal&quot; and the callback it
  registers, &quot;pcb1&quot;, might look like this
<div class="Pp"></div>
<pre>
    # Register the sub pcb1
    register_fatal(\&amp;pcb1);
    sub pcb1
    {
        die &quot;I'm dying...\n&quot;;
    }
</pre>
<div class="Pp"></div>
The mapping between the C callback and the Perl equivalent is stored in the
  global variable &quot;callback&quot;.
<div class="Pp"></div>
This will be adequate if you ever need to have only one callback registered at
  any time. An example could be an error handler like the code sketched out
  above. Remember though, repeated calls to &quot;register_fatal&quot; will
  replace the previously registered callback function with the new one.
<div class="Pp"></div>
Say for example you want to interface to a library which allows asynchronous
  file i/o. In this case you may be able to register a callback whenever a read
  operation has completed. To be of any use we want to be able to call separate
  Perl subroutines for each file that is opened. As it stands, the error handler
  example above would not be adequate as it allows only a single callback to be
  defined at any time. What we require is a means of storing the mapping between
  the opened file and the Perl subroutine we want to be called for that file.
<div class="Pp"></div>
Say the i/o library has a function &quot;asynch_read&quot; which associates a C
  function &quot;ProcessRead&quot; with a file handle &quot;fh&quot;--this
  assumes that it has also provided some routine to open the file and so obtain
  the file handle.
<div class="Pp"></div>
<pre>
    asynch_read(fh, ProcessRead)
</pre>
<div class="Pp"></div>
This may expect the C <i>ProcessRead</i> function of this form
<div class="Pp"></div>
<pre>
    void
    ProcessRead(fh, buffer)
    int fh;
    char *      buffer;
    {
         ...
    }
</pre>
<div class="Pp"></div>
To provide a Perl interface to this library we need to be able to map between
  the &quot;fh&quot; parameter and the Perl subroutine we want called. A hash is
  a convenient mechanism for storing this mapping. The code below shows a
  possible implementation
<div class="Pp"></div>
<pre>
    static HV * Mapping = (HV*)NULL;
    void
    asynch_read(fh, callback)
        int     fh
        SV *    callback
        CODE:
        /* If the hash doesn't already exist, create it */
        if (Mapping == (HV*)NULL)
            Mapping = newHV();
        /* Save the fh -&gt; callback mapping */
        hv_store(Mapping, (char*)&amp;fh, sizeof(fh), newSVsv(callback), 0);
        /* Register with the C Library */
        asynch_read(fh, asynch_read_if);
</pre>
<div class="Pp"></div>
and &quot;asynch_read_if&quot; could look like this
<div class="Pp"></div>
<pre>
    static void
    asynch_read_if(fh, buffer)
    int fh;
    char *      buffer;
    {
        dSP;
        SV ** sv;
        /* Get the callback associated with fh */
        sv =  hv_fetch(Mapping, (char*)&amp;fh , sizeof(fh), FALSE);
        if (sv == (SV**)NULL)
            croak(&quot;Internal error...\n&quot;);
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(fh)));
        XPUSHs(sv_2mortal(newSVpv(buffer, 0)));
        PUTBACK;
        /* Call the Perl sub */
        call_sv(*sv, G_DISCARD);
    }
</pre>
<div class="Pp"></div>
For completeness, here is &quot;asynch_close&quot;. This shows how to remove the
  entry from the hash &quot;Mapping&quot;.
<div class="Pp"></div>
<pre>
    void
    asynch_close(fh)
        int     fh
        CODE:
        /* Remove the entry from the hash */
        (void) hv_delete(Mapping, (char*)&amp;fh, sizeof(fh), G_DISCARD);
        /* Now call the real asynch_close */
        asynch_close(fh);
</pre>
<div class="Pp"></div>
So the Perl interface would look like this
<div class="Pp"></div>
<pre>
    sub callback1
    {
        my($handle, $buffer) = @_;
    }
    # Register the Perl callback
    asynch_read($fh, \&amp;callback1);
    asynch_close($fh);
</pre>
<div class="Pp"></div>
The mapping between the C callback and Perl is stored in the global hash
  &quot;Mapping&quot; this time. Using a hash has the distinct advantage that it
  allows an unlimited number of callbacks to be registered.
<div class="Pp"></div>
What if the interface provided by the C callback doesn't contain a parameter
  which allows the file handle to Perl subroutine mapping? Say in the
  asynchronous i/o package, the callback function gets passed only the
  &quot;buffer&quot; parameter like this
<div class="Pp"></div>
<pre>
    void
    ProcessRead(buffer)
    char *      buffer;
    {
        ...
    }
</pre>
<div class="Pp"></div>
Without the file handle there is no straightforward way to map from the C
  callback to the Perl subroutine.
<div class="Pp"></div>
In this case a possible way around this problem is to predefine a series of C
  functions to act as the interface to Perl, thus
<div class="Pp"></div>
<pre>
    #define MAX_CB              3
    #define NULL_HANDLE -1
    typedef void (*FnMap)();
    struct MapStruct {
        FnMap    Function;
        SV *     PerlSub;
        int      Handle;
      };
    static void  fn1();
    static void  fn2();
    static void  fn3();
    static struct MapStruct Map [MAX_CB] =
        {
            { fn1, NULL, NULL_HANDLE },
            { fn2, NULL, NULL_HANDLE },
            { fn3, NULL, NULL_HANDLE }
        };
    static void
    Pcb(index, buffer)
    int index;
    char * buffer;
    {
        dSP;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSVpv(buffer, 0)));
        PUTBACK;
        /* Call the Perl sub */
        call_sv(Map[index].PerlSub, G_DISCARD);
    }
    static void
    fn1(buffer)
    char * buffer;
    {
        Pcb(0, buffer);
    }
    static void
    fn2(buffer)
    char * buffer;
    {
        Pcb(1, buffer);
    }
    static void
    fn3(buffer)
    char * buffer;
    {
        Pcb(2, buffer);
    }
    void
    array_asynch_read(fh, callback)
        int             fh
        SV *    callback
        CODE:
        int index;
        int null_index = MAX_CB;
        /* Find the same handle or an empty entry */
        for (index = 0; index &lt; MAX_CB; ++index)
        {
            if (Map[index].Handle == fh)
                break;
            if (Map[index].Handle == NULL_HANDLE)
                null_index = index;
        }
        if (index == MAX_CB &amp;&amp; null_index == MAX_CB)
            croak (&quot;Too many callback functions registered\n&quot;);
        if (index == MAX_CB)
            index = null_index;
        /* Save the file handle */
        Map[index].Handle = fh;
        /* Remember the Perl sub */
        if (Map[index].PerlSub == (SV*)NULL)
            Map[index].PerlSub = newSVsv(callback);
        else
            SvSetSV(Map[index].PerlSub, callback);
        asynch_read(fh, Map[index].Function);
    void
    array_asynch_close(fh)
        int     fh
        CODE:
        int index;
        /* Find the file handle */
        for (index = 0; index &lt; MAX_CB; ++ index)
            if (Map[index].Handle == fh)
                break;
        if (index == MAX_CB)
            croak (&quot;could not close fh %d\n&quot;, fh);
        Map[index].Handle = NULL_HANDLE;
        SvREFCNT_dec(Map[index].PerlSub);
        Map[index].PerlSub = (SV*)NULL;
        asynch_close(fh);
</pre>
<div class="Pp"></div>
In this case the functions &quot;fn1&quot;, &quot;fn2&quot;, and &quot;fn3&quot;
  are used to remember the Perl subroutine to be called. Each of the functions
  holds a separate hard-wired index which is used in the function
  &quot;Pcb&quot; to access the &quot;Map&quot; array and actually call the Perl
  subroutine.
<div class="Pp"></div>
There are some obvious disadvantages with this technique.
<div class="Pp"></div>
Firstly, the code is considerably more complex than with the previous example.
<div class="Pp"></div>
Secondly, there is a hard-wired limit (in this case 3) to the number of
  callbacks that can exist simultaneously. The only way to increase the limit is
  by modifying the code to add more functions and then recompiling. None the
  less, as long as the number of functions is chosen with some care, it is still
  a workable solution and in some cases is the only one available.
<div class="Pp"></div>
To summarize, here are a number of possible methods for you to consider for
  storing the mapping between C and the Perl callback
<dl class="Bl-tag">
  <dt class="It-tag">1. Ignore the problem - Allow only 1 callback</dt>
  <dd class="It-tag">For a lot of situations, like interfacing to an error
      handler, this may be a perfectly adequate solution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2. Create a sequence of callbacks - hard wired limit</dt>
  <dd class="It-tag">If it is impossible to tell from the parameters passed back
      from the C callback what the context is, then you may need to create a
      sequence of C callback interface functions, and store pointers to each in
      an array.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3. Use a parameter to map to the Perl callback</dt>
  <dd class="It-tag">A hash is an ideal mechanism to store the mapping between C
      and Perl.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Alternate_Stack_Manipulation"><a class="selflink" href="#Alternate_Stack_Manipulation">Alternate
  Stack Manipulation</a></h2>
Although I have made use of only the &quot;POP*&quot; macros to access values
  returned from Perl subroutines, it is also possible to bypass these macros and
  read the stack using the &quot;ST&quot; macro (See perlxs for a full
  description of the &quot;ST&quot; macro).
<div class="Pp"></div>
Most of the time the &quot;POP*&quot; macros should be adequate; the main
  problem with them is that they force you to process the returned values in
  sequence. This may not be the most suitable way to process the values in some
  cases. What we want is to be able to access the stack in a random order. The
  &quot;ST&quot; macro as used when coding an XSUB is ideal for this purpose.
<div class="Pp"></div>
The code below is the example given in the section <i>Returning a List</i> <i>of
  Values</i> recoded to use &quot;ST&quot; instead of &quot;POP*&quot;.
<div class="Pp"></div>
<pre>
    static void
    call_AddSubtract2(a, b)
    int a;
    int b;
    {
        dSP;
        I32 ax;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;AddSubtract&quot;, G_ARRAY);
        SPAGAIN;
        SP -= count;
        ax = (SP - PL_stack_base) + 1;
        if (count != 2)
            croak(&quot;Big trouble\n&quot;);
        printf (&quot;%d + %d = %d\n&quot;, a, b, SvIV(ST(0)));
        printf (&quot;%d - %d = %d\n&quot;, a, b, SvIV(ST(1)));
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<div class="Pp"></div>
Notes
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Notice that it was necessary to define the variable
      &quot;ax&quot;. This is because the &quot;ST&quot; macro expects it to
      exist. If we were in an XSUB it would not be necessary to define
      &quot;ax&quot; as it is already defined for us.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">The code
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        SPAGAIN;
        SP -= count;
        ax = (SP - PL_stack_base) + 1;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    sets the stack up so that we can use the &quot;ST&quot; macro.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Unlike the original coding of this example, the returned
      values are not accessed in reverse order. So ST(0) refers to the first
      value returned by the Perl subroutine and &quot;ST(count-1)&quot; refers
      to the last.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Creating_and_Calling_an_Anonymous_Subroutine_in_C"><a class="selflink" href="#Creating_and_Calling_an_Anonymous_Subroutine_in_C">Creating
  and Calling an Anonymous Subroutine in C</a></h2>
As we've already shown, &quot;call_sv&quot; can be used to invoke an anonymous
  subroutine. However, our example showed a Perl script invoking an XSUB to
  perform this operation. Let's see how it can be done inside our C code:
<div class="Pp"></div>
<pre>
 ...
 SV *cvrv = eval_pv(&quot;sub { print 'You will not find me cluttering any namespace!' }&quot;, TRUE);
 ...
 call_sv(cvrv, G_VOID|G_NOARGS);
</pre>
<div class="Pp"></div>
&quot;eval_pv&quot; is used to compile the anonymous subroutine, which will be
  the return value as well (read more about &quot;eval_pv&quot; in
  &quot;eval_pv&quot; in perlapi). Once this code reference is in hand, it can
  be mixed in with all the previous examples we've shown.
<h1 class="Sh" title="Sh" id="LIGHTWEIGHT_CALLBACKS"><a class="selflink" href="#LIGHTWEIGHT_CALLBACKS">LIGHTWEIGHT
  CALLBACKS</a></h1>
Sometimes you need to invoke the same subroutine repeatedly. This usually
  happens with a function that acts on a list of values, such as Perl's built-in
  <i>sort()</i>. You can pass a comparison function to <i>sort()</i>, which will
  then be invoked for every pair of values that needs to be compared. The
  <i>first()</i> and <i>reduce()</i> functions from List::Util follow a similar
  pattern.
<div class="Pp"></div>
In this case it is possible to speed up the routine (often quite substantially)
  by using the lightweight callback API. The idea is that the calling context
  only needs to be created and destroyed once, and the sub can be called
  arbitrarily many times in between.
<div class="Pp"></div>
It is usual to pass parameters using global variables (typically $_ for one
  parameter, or $a and $b for two parameters) rather than via @_. (It is
  possible to use the @_ mechanism if you know what you're doing, though there
  is as yet no supported API for it. It's also inherently slower.)
<div class="Pp"></div>
The pattern of macro calls is like this:
<div class="Pp"></div>
<pre>
    dMULTICALL;                 /* Declare local variables */
    I32 gimme = G_SCALAR;       /* context of the call: G_SCALAR,
                                 * G_ARRAY, or G_VOID */
    PUSH_MULTICALL(cv);         /* Set up the context for calling cv,
                                   and set local vars appropriately */
    /* loop */ {
        /* set the value(s) af your parameter variables */
        MULTICALL;              /* Make the actual call */
    } /* end of loop */
    POP_MULTICALL;              /* Tear down the calling context */
</pre>
<div class="Pp"></div>
For some concrete examples, see the implementation of the <i>first()</i> and
  <i>reduce()</i> functions of List::Util 1.18. There you will also find a
  header file that emulates the multicall API on older versions of perl.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlxs, perlguts, perlembed
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Paul Marquess
<div class="Pp"></div>
Special thanks to the following people who assisted in the creation of the
  document.
<div class="Pp"></div>
Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy and
  Larry Wall.
<h1 class="Sh" title="Sh" id="DATE"><a class="selflink" href="#DATE">DATE</a></h1>
Version 1.3, 14th Apr 1997</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
