<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:29:29 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OSRF_PYCOMMON(1) osrf_pycommon OSRF_PYCOMMON(1)</p>

<p style="margin-top: 1em">NAME <br>
osrf_pycommon - osrf_pycommon Documentation</p>

<p style="margin-top: 1em">osrf_pycommon is a python
package which contains commonly used Python boilerplate code
and patterns. Things like ansi terminal coloring, capturing
colored output from programs <br>
using subprocess, or even a simple logging system which
provides some nice functionality over the built-in Python
logging system.</p>

<p style="margin-top: 1em">The functionality provided here
should be generic enough to be reused in arbitrary scenarios
and should avoid bringing in dependencies which are not part
of the standard Python <br>
library. Where possible Windows and Linux/OS X should be
supported, and where it cannot it should be gracefully
degrading. Code should be pure Python as well as Python 2
and <br>
Python 3 bilingual.</p>

<p style="margin-top: 1em">Contents:</p>

<p style="margin-top: 1em">THE CLI_UTILS MODULE <br>
This module provides functions and patterns for creating
Command Line Interface (CLI) tools.</p>

<p style="margin-top: 1em">Common CLI Functions <br>
Commonly used, CLI related functions.</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.common.extract_argument_group(args,
delimiting_option) <br>
Extract a group of arguments from a list of arguments using
a delimiter.</p>

<p style="margin-top: 1em">Here is an example:</p>

<p style="margin-top: 1em">&gt;&gt;&gt;
extract_argument_group([&rsquo;foo&rsquo;,
&rsquo;--args&rsquo;, &rsquo;bar&rsquo;,
&rsquo;--baz&rsquo;], &rsquo;--args&rsquo;) <br>
([&rsquo;foo&rsquo;], [&rsquo;bar&rsquo;,
&rsquo;--baz&rsquo;])</p>

<p style="margin-top: 1em">The group can always be ended
using the double hyphen --. In order to pass a double hyphen
as arguments, use three hyphens ---. Any set of hyphens
encountered after the <br>
delimiter, and up to --, which have three or more hyphens
and are isolated, will be captured and reduced by one
hyphen.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">&gt;&gt;
extract_argument_group([&rsquo;foo&rsquo;, <br>
&rsquo;--args&rsquo;, &rsquo;bar&rsquo;,
&rsquo;--baz&rsquo;, &rsquo;---&rsquo;, &rsquo;--&rsquo;,
<br>
&rsquo;--foo-option&rsquo;], &rsquo;--args&rsquo;) <br>
([&rsquo;foo&rsquo;, &rsquo;--foo-option&rsquo;],
[&rsquo;bar&rsquo;, &rsquo;--baz&rsquo;,
&rsquo;--&rsquo;])</p>

<p style="margin-top: 1em">In the result the -- comes from
the --- in the input. The --args and the corresponding --
are removed entirely.</p>

<p style="margin-top: 1em">The delimiter and -- terminator
combination can also happen multiple times, in which case
the bodies of arguments are combined and returned in the
order they appeared.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">&gt;&gt;
extract_argument_group([&rsquo;foo&rsquo;, <br>
&rsquo;--args&rsquo;, &rsquo;ping&rsquo;, &rsquo;--&rsquo;,
<br>
&rsquo;bar&rsquo;, <br>
&rsquo;--args&rsquo;, &rsquo;pong&rsquo;, &rsquo;--&rsquo;,
<br>
&rsquo;baz&rsquo;, <br>
&rsquo;--args&rsquo;, &rsquo;--&rsquo;],
&rsquo;--args&rsquo;) <br>
([&rsquo;foo&rsquo;, &rsquo;bar&rsquo;, &rsquo;baz&rsquo;],
[&rsquo;ping&rsquo;, &rsquo;pong&rsquo;])</p>

<p style="margin-top: 1em">Note: -- cannot be used as the
delimiting_option.</p>

<p style="margin-top: 1em">Parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; args (list) --
list of strings which are ordered arguments.</p>

<p style="margin-top: 1em">&Acirc;&middot;
delimiting_option (str) -- option which denotes where to
split the args.</p>

<p style="margin-top: 1em">Returns <br>
tuple of arguments before and after the delimiter.</p>

<p style="margin-top: 1em">Return type <br>
tuple</p>

<p style="margin-top: 1em">Raises ValueError if the
delimiting_option is --.</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.common.extract_jobs_flags(arguments)
<br>
Extracts make job flags from a list of other make flags,
i.e. -j8 -l8</p>

<p style="margin-top: 1em">The input arguments are given as
a string separated by whitespace. Make job flags are matched
and removed from the arguments, and the Make job flags and
what is left over <br>
from the input arguments are returned.</p>

<p style="margin-top: 1em">If no job flags are encountered,
then an empty string is returned as the first element of the
returned tuple.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">&gt;&gt;
extract_jobs_flags(&rsquo;-j8 -l8&rsquo;) <br>
(&rsquo;-j8 -l8&rsquo;, &rsquo;&rsquo;) <br>
&gt;&gt; extract_jobs_flags(&rsquo;-j8 &rsquo;) <br>
(&rsquo;-j8&rsquo;, &rsquo; &rsquo;) <br>
&gt;&gt; extract_jobs_flags(&rsquo;target -j8 -l8
--some-option&rsquo;) <br>
(&rsquo;-j8 -l8&rsquo;, &rsquo;target --some-option&rsquo;)
<br>
&gt;&gt; extract_jobs_flags(&rsquo;target
--some-option&rsquo;) <br>
(&rsquo;&rsquo;, &rsquo;target --some-option&rsquo;)</p>

<p style="margin-top: 1em">Parameters <br>
arguments (str) -- string of space separated arguments which
may or may not contain make job flags</p>

<p style="margin-top: 1em">Returns <br>
tuple of make jobs flags as a space separated string and
leftover arguments as a space separated string</p>

<p style="margin-top: 1em">Return type <br>
tuple</p>

<p style="margin-top: 1em">The Verb Pattern <br>
The verb pattern is a pattern where a single command
aggregates multiple related commands by taking a required
positional argument which is the &quot;verb&quot; for the
action you want to <br>
perform. For example, catkin build is an example of a
command and verb pair, where catkin is the command and build
is the verb. In this example, the catkin command groups <br>
&quot;actions&quot; which are related to catkin together
using verbs like build which will build a workspace of
catkin packages.</p>

<p style="margin-top: 1em">Command Boilerplate <br>
This is an example boilerplate of a command which will use
verbs:</p>

<p style="margin-top: 1em">from __future__ import
print_function</p>

<p style="margin-top: 1em">import argparse <br>
import sys</p>

<p style="margin-top: 1em">from
osrf_pycommon.cli_utils.verb_pattern import
create_subparsers <br>
from osrf_pycommon.cli_utils.verb_pattern import list_verbs
<br>
from osrf_pycommon.cli_utils.verb_pattern import
split_arguments_by_verb</p>

<p style="margin-top: 1em">COMMAND_NAME = &rsquo;&lt;INSERT
COMMAND NAME HERE&gt;&rsquo;</p>

<p style="margin-top: 1em">VERBS_ENTRY_POINT =
&rsquo;{0}.verbs&rsquo;.format(COMMAND_NAME)</p>

<p style="margin-top: 1em">def main(sysargs=None): <br>
# Assign sysargs if not set <br>
sysargs = sys.argv[1:] if sysargs is None else sysargs</p>

<p style="margin-top: 1em"># Create a top level parser <br>
parser = argparse.ArgumentParser( <br>
description=&quot;{0} command&quot;.format(COMMAND_NAME)
<br>
)</p>

<p style="margin-top: 1em"># Generate a list of verbs
available <br>
verbs = list_verbs(VERBS_ENTRY_POINT)</p>

<p style="margin-top: 1em"># Create the subparsers for each
verb and collect the arg preprocessors <br>
argument_preprocessors, verb_subparsers = create_subparsers(
<br>
parser, <br>
COMMAND_NAME, <br>
verbs, <br>
VERBS_ENTRY_POINT, <br>
sysargs, <br>
)</p>

<p style="margin-top: 1em"># Determine the verb, splitting
arguments into pre and post verb <br>
verb, pre_verb_args, post_verb_args =
split_arguments_by_verb(sysargs)</p>

<p style="margin-top: 1em"># Short circuit -h and --help
<br>
if &rsquo;-h&rsquo; in pre_verb_args or &rsquo;--help&rsquo;
in pre_verb_args: <br>
parser.print_help() <br>
sys.exit(0)</p>

<p style="margin-top: 1em"># Error on no verb provided <br>
if verb is None: <br>
print(parser.format_usage()) <br>
sys.exit(&quot;Error: No verb provided.&quot;) <br>
# Error on unknown verb provided <br>
if verb not in verbs: <br>
print(parser.format_usage()) <br>
sys.exit(&quot;Error: Unknown verb &rsquo;{0}&rsquo;
provided.&quot;.format(verb))</p>

<p style="margin-top: 1em"># Short circuit -h and --help
for verbs <br>
if &rsquo;-h&rsquo; in post_verb_args or
&rsquo;--help&rsquo; in post_verb_args: <br>
verb_subparsers[verb].print_help() <br>
sys.exit(0)</p>

<p style="margin-top: 1em"># First allow the verb&rsquo;s
argument preprocessor to strip any args <br>
# and return any &quot;extra&quot; information it wants as a
dict <br>
processed_post_verb_args, extras =
argument_preprocessors[verb](post_verb_args) <br>
# Then allow argparse to process the left over post-verb
arguments along <br>
# with the pre-verb arguments and the verb itself <br>
args = parser.parse_args(pre_verb_args + [verb] +
processed_post_verb_args) <br>
# Extend the argparse result with the extras from the
preprocessor <br>
for key, value in extras.items(): <br>
setattr(args, key, value)</p>

<p style="margin-top: 1em"># Finally call the
subparser&rsquo;s main function with the processed args <br>
# and the extras which the preprocessor may have returned
<br>
sys.exit(args.main(args) or 0)</p>

<p style="margin-top: 1em">This function is mostly
boilerplate in that it will likely not change much between
commands of different types, but it would also be less
transparent to have this function cre&acirc; <br>
ated for you. If you are using this boilerplate to implement
your command, then you should be careful to update
COMMAND_NAME to reflect your command&rsquo;s name.</p>

<p style="margin-top: 1em">This line defines the
entry_point group for your command&rsquo;s verbs:</p>

<p style="margin-top: 1em">VERBS_ENTRY_POINT =
&rsquo;{0}.verbs&rsquo;.format(COMMAND_NAME)</p>

<p style="margin-top: 1em">In the case that your command is
called foo then this would become foo.verbs. This name is
important because it is how verbs for this command can be
provided by your Python <br>
package or others. For example, each verb for your command
foo will need entry in the setup.py of its containing
package, like this:</p>

<p style="margin-top: 1em">setup( <br>
... <br>
entry_points={ <br>
... <br>
&rsquo;foo.verbs&rsquo;: [ <br>
&rsquo;bar = foo.verbs.bar:entry_point_data&rsquo;, <br>
], <br>
} <br>
)</p>

<p style="margin-top: 1em">You can see here that you are
defining bar to be a an entry_point of type foo.verbs which
in turn points to a module and reference foo.verbs.bar and
entry_point_data. At run <br>
time this verb pattern will let your command lookup all
things defined as foo.verbs and load up the reference to
which they point.</p>

<p style="margin-top: 1em">Adding Verbs <br>
In order to add a verb to your command, a few things must
happen.</p>

<p style="margin-top: 1em">First you must have an entry in
the setup.py as described above. This allows the command to
find the entry_point for your verb at run time. The
entry_point for these verbs <br>
should point to a dictionary which describes the verb being
added.</p>

<p style="margin-top: 1em">This is an example of an
entry_point_data dictionary for a verb:</p>

<p style="margin-top: 1em">entry_point_data = dict( <br>
verb=&rsquo;build&rsquo;, <br>
description=&rsquo;Builds a workspace of packages&rsquo;,
<br>
# Called for execution, given parsed arguments object <br>
main=main, <br>
# Called first to setup argparse, given argparse parser <br>
prepare_arguments=prepare_arguments, <br>
# Called after prepare_arguments, but before
argparse.parse_args <br>
argument_preprocessor=argument_preprocessor, <br>
)</p>

<p style="margin-top: 1em">As you can see this dictionary
describes the verb and gives references to functions which
allow the command to describe the verb, hook into argparse
parameter creation for the <br>
verb, and to execute the verb. The verb, description, main,
and prepare_arguments keys of the dictionary are required,
but the argument_preprocessor key is optional.</p>

<p style="margin-top: 1em">&Acirc;&middot; verb: This is
the name of the verb, and is how the command knows which
verb implementation to match to a verb on the command
line.</p>

<p style="margin-top: 1em">&Acirc;&middot; description:
This is used by the argument parsing to describe the verb in
--help.</p>

<p style="margin-top: 1em">&Acirc;&middot;
prepare_arguments: This function gets called to allow the
verb to setup it&rsquo;s own argparse options. This function
should always take one parameter which is the
argparse.Argu&acirc; <br>
mentParser for this verb, to which arguments can be added.
It can optionally take a second parameter which are the
current command line arguments. This is not always needed,
<br>
but can be useful in some cases. This function should always
return the parser.</p>

<p style="margin-top: 1em">&Acirc;&middot;
argument_preprocessor: This function is optional, but allows
your verb an opportunity to process the raw arguments before
they are passed to argparse&rsquo;s parse_args function.
<br>
This can be useful when argparse is not capable of
processing the options correctly.</p>

<p style="margin-top: 1em">&Acirc;&middot; main: This is
the implementation of the verb, it gets called last and is
passed the parsed arguments. The return type of this
function is used for sys.exit, a return type of <br>
None is interpreted as 0.</p>

<p style="margin-top: 1em">Here is an invented example of
main, prepare_arguments, and argument_preprocessor:</p>

<p style="margin-top: 1em">def prepare_arguments(parser):
<br>
parser.add_argument(&rsquo;--some-argument&rsquo;,
action=&rsquo;store_true&rsquo;, default=False) <br>
return parser</p>

<p style="margin-top: 1em">def argument_preprocessor(args):
<br>
extras = {}</p>

<p style="margin-top: 1em">if
&rsquo;-strange-argument&rsquo; in args: <br>
args.remove(&rsquo;-strange-argument&rsquo;) <br>
extras[&rsquo;strange_argument&rsquo;] = True</p>

<p style="margin-top: 1em">return args, extras</p>

<p style="margin-top: 1em">def main(options): <br>
print(&rsquo;--some-argument:&rsquo;, options.some_argument)
<br>
print(&rsquo;-strange-argument:&rsquo;,
options.strange_argument) <br>
if options.strange_argument: <br>
return 1 <br>
return 0</p>

<p style="margin-top: 1em">The above example is simply to
illustrate the signature of these functions and how they
might be used.</p>

<p style="margin-top: 1em">Verb Pattern API <br>
API for implementing commands and verbs which used the verb
pattern.</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.verb_pattern.call_prepare_arguments(func,
parser, sysargs=None) <br>
Call a prepare_arguments function with the correct number of
parameters.</p>

<p style="margin-top: 1em">The prepare_arguments function
of a verb can either take one parameter, parser, or two
parameters parser and args, where args are the current
arguments being processed.</p>

<p style="margin-top: 1em">Parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; func (Callabe)
-- Callable prepare_arguments function.</p>

<p style="margin-top: 1em">&Acirc;&middot; parser
(argparse.ArgumentParser) -- parser which is always passed
to the function</p>

<p style="margin-top: 1em">&Acirc;&middot; sysargs (list)
-- arguments to optionally pass to the function, if
needed</p>

<p style="margin-top: 1em">Returns <br>
return value of function or the parser if the function
returns None.</p>

<p style="margin-top: 1em">Return type <br>
argparse.ArgumentParser</p>

<p style="margin-top: 1em">Raises ValueError if a function
with the wrong number of parameters is given</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.verb_pattern.create_subparsers(parser,
cmd_name, verbs, group, sysargs, title=None) <br>
Creates argparse subparsers for each verb which can be
discovered.</p>

<p style="margin-top: 1em">Using the verbs parameter, the
availble verbs are iterated through. For each verb a
subparser is created for it using the parser parameter. The
cmd_name is used to fill <br>
the title and description of the add_subparsers function
call. The group parameter is used with each verb to load the
verb&rsquo;s description, prepare_arguments function, and
<br>
the verb&rsquo;s argument_preprocessors if available. Each
verb&rsquo;s prepare_arguments function is called, allowing
them to add arguments. Finally a list of
argument_preproces&acirc; <br>
sors functions and verb subparsers are returned, one for
each verb.</p>

<p style="margin-top: 1em">Parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; parser
(argparse.ArgumentParser) -- parser for this command</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd_name (str)
-- name of the command to which the verbs are being
added</p>

<p style="margin-top: 1em">&Acirc;&middot; verbs (list) --
list of verbs (by name as a string)</p>

<p style="margin-top: 1em">&Acirc;&middot; group (str) --
name of the entry_point group for the verbs</p>

<p style="margin-top: 1em">&Acirc;&middot; sysargs (list)
-- list of system arguments</p>

<p style="margin-top: 1em">&Acirc;&middot; title (str) --
optional custom title for the command</p>

<p style="margin-top: 1em">Returns <br>
tuple of argument_preprocessors and verb subparsers</p>

<p style="margin-top: 1em">Return type <br>
tuple</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.verb_pattern.default_argument_preprocessor(args)
<br>
Return unmodifed args and an empty dict for extras</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.verb_pattern.list_verbs(group)
<br>
List verbs available for a given entry_point group.</p>

<p style="margin-top: 1em">Parameters <br>
group (str) -- entry_point group name for the verbs to
list</p>

<p style="margin-top: 1em">Returns <br>
list of verb names for the given entry_point group</p>

<p style="margin-top: 1em">Return type <br>
list of str</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.verb_pattern.load_verb_description(verb_name,
group) <br>
Load description of a verb in a given group by name.</p>

<p style="margin-top: 1em">Parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; verb_name (str)
-- name of the verb to load, as a string</p>

<p style="margin-top: 1em">&Acirc;&middot; group (str) --
entry_point group name which the verb is in</p>

<p style="margin-top: 1em">Returns <br>
verb description</p>

<p style="margin-top: 1em">Return type <br>
dict</p>


<p style="margin-top: 1em">osrf_pycommon.cli_utils.verb_pattern.split_arguments_by_verb(arguments)
<br>
Split arguments by verb.</p>

<p style="margin-top: 1em">Given a list of arguments (list
of strings), the verb, the pre verb arguments, and the post
verb arugments are returned.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">&gt;&gt;&gt; args =
[&rsquo;--command-arg1&rsquo;, &rsquo;verb&rsquo;,
&rsquo;--verb-arg1&rsquo;, &rsquo;--verb-arg2&rsquo;] <br>
&gt;&gt;&gt; split_arguments_by_verb(args) <br>
(&rsquo;verb&rsquo;, [&rsquo;--command-arg1&rsquo;],
[&rsquo;--verb-arg1&rsquo;, &rsquo;--verb-arg2&rsquo;])</p>

<p style="margin-top: 1em">Parameters <br>
arguments (list) -- list of system arguments</p>

<p style="margin-top: 1em">Returns <br>
the verb (str), pre verb args (list), and post verb args
(list)</p>

<p style="margin-top: 1em">Return type <br>
tuple</p>

<p style="margin-top: 1em">THE PROCESS_UTILS MODULE <br>
This module provides functions for doing process
management.</p>

<p style="margin-top: 1em">These are the main sections of
this module:</p>

<p style="margin-top: 1em">&Acirc;&middot; Asynchronous
Process Utilities</p>

<p style="margin-top: 1em">&Acirc;&middot; Synchronous
Process Utilities</p>

<p style="margin-top: 1em">&Acirc;&middot; Utility
Functions</p>

<p style="margin-top: 1em">Asynchronous Process Utilities
<br>
There is a function and class which can be used together
with your custom Tollius or asyncio run loop.</p>

<p style="margin-top: 1em">The
osrf_pycommon.process_utils.async_execute_process() function
is a coroutine which allows you to run a process and get the
output back bit by bit in real-time, either with <br>
stdout and stderr separated or combined. This function also
allows you to emulate the terminal using a pty simply by
toggling a flag in the parameters.</p>

<p style="margin-top: 1em">Along side this coroutine is a
Protocol class,
osrf_pycommon.process_utils.AsyncSubprocessProtocol, from
which you can inherit in order to customize how the yielded
output is <br>
handled.</p>

<p style="margin-top: 1em">Because this coroutine is built
on the trollius/asyncio framework&rsquo;s subprocess
functions, it is portable and should behave the same on all
major OS&rsquo;s. (including on Windows where <br>
an IOCP implementation is used)</p>


<p style="margin-top: 1em">osrf_pycommon.process_utils.async_execute_process(protocol_class,
cmd=None, cwd=None, env=None, shell=False,
emulate_tty=False, stderr_to_stdout=True) <br>
Coroutine to execute a subprocess and yield the output back
asynchronously.</p>

<p style="margin-top: 1em">This function is meant to be
used with the Python asyncio module, which is available via
pip with Python 3.3 and built-in to Python 3.4. On Python
&gt;= 2.6 you can use the <br>
trollius module to get the same functionality, but without
using the new yield from syntax.</p>

<p style="margin-top: 1em">Here is an example of how to use
this function:</p>

<p style="margin-top: 1em">import asyncio <br>
from osrf_pycommon.process_utils import
async_execute_process <br>
from osrf_pycommon.process_utils import
AsyncSubprocessProtocol <br>
from osrf_pycommon.process_utils import get_loop</p>

<p style="margin-top: 1em">@asyncio.coroutine <br>
def setup(): <br>
transport, protocol = yield from async_execute_process( <br>
AsyncSubprocessProtocol, [&rsquo;ls&rsquo;,
&rsquo;/usr&rsquo;]) <br>
returncode = yield from protocol.complete <br>
return returncode</p>

<p style="margin-top: 1em">retcode =
get_loop().run_until_complete(setup()) <br>
get_loop().close()</p>

<p style="margin-top: 1em">That same example using trollius
would look like this:</p>

<p style="margin-top: 1em">import trollius as asyncio <br>
from osrf_pycommon.process_utils import
async_execute_process <br>
from osrf_pycommon.process_utils import
AsyncSubprocessProtocol <br>
from osrf_pycommon.process_utils import get_loop</p>

<p style="margin-top: 1em">@asyncio.coroutine <br>
def setup(): <br>
transport, protocol = yield
asyncio.From(async_execute_process( <br>
AsyncSubprocessProtocol, [&rsquo;ls&rsquo;,
&rsquo;/usr&rsquo;])) <br>
returncode = yield asyncio.From(protocol.complete) <br>
raise asyncio.Return(returncode)</p>

<p style="margin-top: 1em">retcode =
get_loop().run_until_complete(setup()) <br>
get_loop().close()</p>

<p style="margin-top: 1em">This difference is required
because in Python &lt; 3.3 the yield from syntax is not
valid.</p>

<p style="margin-top: 1em">In both examples, the first
argument is the default AsyncSubprocessProtocol protocol
class, which simply prints output from stdout to stdout and
output from stderr to <br>
stderr.</p>

<p style="margin-top: 1em">If you want to capture and do
something with the output or write to the stdin, then you
need to subclass from the AsyncSubprocessProtocol class, and
override the on_std&acirc; <br>
out_received, on_stderr_received, and on_process_exited
functions.</p>

<p style="margin-top: 1em">See the documentation for the
AsyncSubprocessProtocol class for more details, but here is
an example which uses asyncio from Python 3.4:</p>

<p style="margin-top: 1em">import asyncio <br>
from osrf_pycommon.process_utils import
async_execute_process <br>
from osrf_pycommon.process_utils import
AsyncSubprocessProtocol <br>
from osrf_pycommon.process_utils import get_loop</p>

<p style="margin-top: 1em">class
MyProtocol(AsyncSubprocessProtocol): <br>
def __init__(self, file_name, **kwargs): <br>
self.fh = open(file_name, &rsquo;w&rsquo;) <br>
AsyncSubprocessProtocol.__init__(self, **kwargs)</p>

<p style="margin-top: 1em">def on_stdout_received(self,
data): <br>
# Data has line endings intact, but is bytes in Python 3
<br>
self.fh.write(data.decode(&rsquo;utf-8&rsquo;))</p>

<p style="margin-top: 1em">def on_stderr_received(self,
data): <br>
self.fh.write(data.decode(&rsquo;utf-8&rsquo;))</p>

<p style="margin-top: 1em">def on_process_exited(self,
returncode): <br>
self.fh.write(&quot;Exited with return code:
{0}&quot;.format(returncode)) <br>
self.fh.close()</p>

<p style="margin-top: 1em">@asyncio.coroutine <br>
def log_command_to_file(cmd, file_name):</p>

<p style="margin-top: 1em">def create_protocol(**kwargs):
<br>
return MyProtocol(file_name, **kwargs)</p>

<p style="margin-top: 1em">transport, protocol = yield from
async_execute_process( <br>
create_protocol, cmd) <br>
returncode = yield from protocol.complete <br>
return returncode</p>

<p style="margin-top: 1em">get_loop().run_until_complete(
<br>
log_command_to_file([&rsquo;ls&rsquo;, &rsquo;/&rsquo;],
&rsquo;/tmp/out.txt&rsquo;)) <br>
get_loop().close()</p>

<p style="margin-top: 1em">See the subprocess.Popen class
for more details on some of the parameters to this function
like cwd, env, and shell.</p>

<p style="margin-top: 1em">See the
osrf_pycommon.process_utils.execute_process() function for
more details on the emulate_tty parameter.</p>

<p style="margin-top: 1em">Parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; protocol_class
(AsyncSubprocessProtocol or a subclass) -- Protocol class
which handles subprocess callbacks</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd (list) --
list of arguments where the executable is the first item</p>

<p style="margin-top: 1em">&Acirc;&middot; cwd (str) --
directory in which to run the command</p>

<p style="margin-top: 1em">&Acirc;&middot; env (dict) -- a
dictionary of environment variable names to values</p>

<p style="margin-top: 1em">&Acirc;&middot; shell (bool) --
if True, the cmd variable is interpreted by a the shell</p>

<p style="margin-top: 1em">&Acirc;&middot; emulate_tty
(bool) -- if True, pty&rsquo;s are passed to the subprocess
for stdout and stderr, see
osrf_pycommon.process_utils.execute_process().</p>

<p style="margin-top: 1em">&Acirc;&middot; stderr_to_stdout
(bool) -- if True, stderr is directed to stdout, so they are
not captured separately.</p>

<p style="margin-top: 1em">class
osrf_pycommon.process_utils.AsyncSubprocessProtocol(stdin=None,
stdout=None, stderr=None) <br>
Protocol to subclass to get events from
async_execute_process().</p>

<p style="margin-top: 1em">When subclassing this Protocol
class, you should override these functions:</p>

<p style="margin-top: 1em">def on_stdout_received(self,
data): <br>
# ...</p>

<p style="margin-top: 1em">def on_stderr_received(self,
data): <br>
# ...</p>

<p style="margin-top: 1em">def on_process_exited(self,
returncode): <br>
# ...</p>

<p style="margin-top: 1em">By default these functions just
print the data received from stdout and stderr and does
nothing when the process exits.</p>

<p style="margin-top: 1em">Data received by the
on_stdout_received and on_stderr_received functions is
always in bytes (str in Python2 and bytes in Python3).
Therefore, it may be necessary to call <br>
.decode() on the data before printing to the screen.</p>

<p style="margin-top: 1em">Additionally, the data received
will not be stripped of new lines, so take that into
consideration when printing the result.</p>

<p style="margin-top: 1em">You can also override these less
commonly used functions:</p>

<p style="margin-top: 1em">def on_stdout_open(self): <br>
# ...</p>

<p style="margin-top: 1em">def on_stdout_close(self, exc):
<br>
# ...</p>

<p style="margin-top: 1em">def on_stderr_open(self): <br>
# ...</p>

<p style="margin-top: 1em">def on_stderr_close(self, exc):
<br>
# ...</p>

<p style="margin-top: 1em">These functions are called when
stdout/stderr are opened and closed, and can be useful when
using pty&rsquo;s for example. The exc parameter of the
*_close functions is None <br>
unless there was an exception.</p>

<p style="margin-top: 1em">In addition to the overridable
functions this class has a few useful public attributes. The
stdin attribute is a reference to the PipeProto which
follows the asyn&acirc; <br>
cio.WriteTransport interface. The stdout and stderr
attributes also reference their PipeProto. The complete
attribute is a asyncio.Future which is set to complete when
<br>
the process exits and its result is the return code.</p>

<p style="margin-top: 1em">The complete attribute can be
used like this:</p>

<p style="margin-top: 1em">import asyncio <br>
from osrf_pycommon.process_utils import
async_execute_process <br>
from osrf_pycommon.process_utils import
AsyncSubprocessProtocol <br>
from osrf_pycommon.process_utils import get_loop</p>

<p style="margin-top: 1em">@asyncio.coroutine <br>
def setup(): <br>
transport, protocol = yield from async_execute_process( <br>
AsyncSubprocessProtocol, [&rsquo;ls&rsquo;,
&rsquo;-G&rsquo;, &rsquo;/usr&rsquo;]) <br>
retcode = yield from protocol.complete <br>
print(&quot;Exited with&quot;, retcode)</p>

<p style="margin-top: 1em"># This will block until the
protocol.complete Future is done. <br>
get_loop().run_until_complete(setup()) <br>
get_loop().close()</p>

<p style="margin-top: 1em">In addtion to these functions,
there is a utility function for getting the correct asyncio
event loop:</p>


<p style="margin-top: 1em">osrf_pycommon.process_utils.get_loop()
<br>
This function will return the proper event loop for the
subprocess async calls.</p>

<p style="margin-top: 1em">On Unix this just returns
asyncio.get_event_loop(), but on Windows it will set and
return a asyncio.ProactorEventLoop instead.</p>

<p style="margin-top: 1em">Treatment of File Descriptors
<br>
Unlike subprocess.Popen, all of the process_utils functions
behave the same way on Python versions 2.7 through 3.4, and
they do not close inheritable <br>

&lt;https://docs.python.org/3.4/library/os.html#fd-inheritance&gt;.
file descriptors before starting subprocesses. This is
equivalent to passing close_fds=False to subprocess.Popen on
<br>
all Python versions.</p>

<p style="margin-top: 1em">In Python 3.2, the
subprocess.Popen default for the close_fds option changed
from False to True so that file descriptors opened by the
parent process were closed before spawning <br>
the child process. In Python 3.4, PEP 0446 additionally made
it so even when close_fds=False file descriptors which are
non-inheritable are still closed before spawning the
sub&acirc; <br>
process.</p>

<p style="margin-top: 1em">If you want to be able to pass
file descriptors to subprocesses in Python 3.4 or higher,
you will need to make sure they are inheritable <br>

&lt;https://docs.python.org/3.4/library/os.html#fd-inheritance&gt;.</p>

<p style="margin-top: 1em">Synchronous Process Utilities
<br>
For synchronous execution and output capture of subprocess,
there are two functions:</p>

<p style="margin-top: 1em">&Acirc;&middot;
osrf_pycommon.process_utils.execute_process()</p>

<p style="margin-top: 1em">&Acirc;&middot;
osrf_pycommon.process_utils.execute_process_split()</p>

<p style="margin-top: 1em">These functions are not yet
using the trollius/asyncio framework as a back-end and
therefore on Windows will not stream the data from the
subprocess as it does on Unix machines. <br>
Instead data will not be yielded until the subprocess is
finished and all output is buffered (the normal warnings
about long running programs with lots of output apply).</p>

<p style="margin-top: 1em">The streaming of output does not
work on Windows because on Windows the select.select()
method only works on sockets and not file-like objects which
are used with subprocess <br>
pipes. asyncio implements Windows subprocess support by
implementing a Proactor event loop based on Window&rsquo;s
IOCP API. One future option will be to implement this
synchronous <br>
style method using IOCP in this module, but another option
is to just make synchronous the asynchronous calls, but
there are issues with that as well. In the mean time, if you
<br>
need streaming of output in both Windows and Unix, use the
asynchronous calls.</p>


<p style="margin-top: 1em">osrf_pycommon.process_utils.execute_process(cmd,
cwd=None, env=None, shell=False, emulate_tty=False) <br>
Executes a command with arguments and returns output line by
line.</p>

<p style="margin-top: 1em">All arguments, except
emulate_tty, are passed directly to subprocess.Popen.</p>

<p style="margin-top: 1em">execute_process returns a
generator which yields the output, line by line, until the
subprocess finishes at which point the return code is
yielded.</p>

<p style="margin-top: 1em">This is an example of how this
function should be used:</p>

<p style="margin-top: 1em">from __future__ import
print_function <br>
from osrf_pycommon.process_utils import execute_process</p>

<p style="margin-top: 1em">cmd = [&rsquo;ls&rsquo;,
&rsquo;-G&rsquo;] <br>
for line in execute_process(cmd, cwd=&rsquo;/usr&rsquo;):
<br>
if isinstance(line, int): <br>
# This is a return code, the command has exited <br>
print(&quot;&rsquo;{0}&rsquo; exited with:
{1}&quot;.format(&rsquo; &rsquo;.join(cmd), line)) <br>
continue # break would also be appropriate here <br>
# In Python 3, it will be a bytes array which needs to be
decoded <br>
if not isinstance(line, str): <br>
line = line.decode(&rsquo;utf-8&rsquo;) <br>
# Then print it to the screen <br>
print(line, end=&rsquo;&rsquo;)</p>

<p style="margin-top: 1em">stdout and stderr are always
captured together and returned line by line through the
returned generator. New line characters are preserved in the
output, so if re-print&acirc; <br>
ing the data take care to use end=&rsquo;&rsquo; or first
rstrip the output lines.</p>

<p style="margin-top: 1em">When emulate_tty is used on Unix
systems, commands will identify that they are on a tty and
should output color to the screen as if you were running it
on the terminal, <br>
and therefore there should not be any need to pass arguments
like -c color.ui=always to commands like git. Additionally,
programs might also behave differently in when <br>
emulate_tty is being used, for example, Python will default
to unbuffered output when it detects a tty.</p>

<p style="margin-top: 1em">emulate_tty works by using
psuedo-terminals on Unix machines, and so if you are running
this command many times in parallel (like hundreds of times)
then you may get one <br>
of a few different OSError&rsquo;s. For example,
&quot;OSError: [Errno 24] Too many open files:
&rsquo;/dev/ttyp0&rsquo;&quot; or &quot;OSError: out of pty
devices&quot;. You should also be aware that you <br>
share pty devices with the rest of the system, so even if
you are not using a lot, it is possible to get this error.
You can catch this error before getting data from the <br>
generator, so when using emulate_tty you might want to do
something like this:</p>

<p style="margin-top: 1em">from __future__ import
print_function <br>
from osrf_pycommon.process_utils import execute_process</p>

<p style="margin-top: 1em">cmd = [&rsquo;ls&rsquo;,
&rsquo;-G&rsquo;, &rsquo;/usr&rsquo;] <br>
try: <br>
output = execute_process(cmd, emulate_tty=True) <br>
except OSError: <br>
output = execute_process(cmd, emulate_tty=False) <br>
for line in output: <br>
if isinstance(line, int): <br>
print(&quot;&rsquo;{0}&rsquo; exited with:
{1}&quot;.format(&rsquo; &rsquo;.join(cmd), line)) <br>
continue <br>
# In Python 3, it will be a bytes array which needs to be
decoded <br>
if not isinstance(line, str): <br>
line = line.decode(&rsquo;utf-8&rsquo;) <br>
print(line, end=&rsquo;&rsquo;)</p>

<p style="margin-top: 1em">This way if a pty cannot be
opened in order to emulate the tty then you can try again
without emulation, and any other OSError should raise again
with emulate_tty set to <br>
False. Obviously, you only want to do this if emulating the
tty is non-critical to your processing, like when you are
using it to capture color.</p>

<p style="margin-top: 1em">Any color information that the
command outputs as ANSI escape sequences is captured by this
command. That way you can print the output to the screen and
preserve the <br>
color formatting.</p>

<p style="margin-top: 1em">If you do not want color to be
in the output, then try setting emulate_tty to False, but
that does not guarantee that there is no color in the
output, instead it only will <br>
cause called processes to identify that they are not being
run in a terminal. Most well behaved programs will not
output color if they detect that they are not being
exe&acirc; <br>
cuted in a terminal, but you shouldn&rsquo;t rely on
that.</p>

<p style="margin-top: 1em">If you want to ensure there is
no color in the output from an executed process, then use
this function:</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.remove_ansi_escape_senquences()</p>

<p style="margin-top: 1em">Exceptions can be raised by
functions called by the implementation, for example,
subprocess.Popen can raise an OSError when the given command
is not found. If you want to <br>
check for the existence of an executable on the path, see:
which(). However, this function itself does not raise any
special exceptions.</p>

<p style="margin-top: 1em">Parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd (list) --
list of strings with the first item being a command and
subsequent items being any arguments to that command; passed
directly to subprocess.Popen.</p>

<p style="margin-top: 1em">&Acirc;&middot; cwd (str) --
path in which to run the command, defaults to None which
means os.getcwd() is used; passed directly to
subprocess.Popen.</p>

<p style="margin-top: 1em">&Acirc;&middot; env (dict) --
environment dictionary to use for executing the command,
default is None which uses the os.environ environment;
passed directly to subprocess.Popen.</p>

<p style="margin-top: 1em">&Acirc;&middot; shell (bool) --
If True the system shell is used to evaluate the command,
default is False; passed directly to subprocess.Popen.</p>

<p style="margin-top: 1em">&Acirc;&middot; emulate_tty
(bool) -- If True attempts to use a pty to convince
subprocess&rsquo;s that they are being run in a terminal.
Typically this is useful for capturing col&acirc; <br>
orized output from commands. This does not work on Windows
(no pty&rsquo;s), so it is considered False even when True.
Defaults to False.</p>

<p style="margin-top: 1em">Returns <br>
a generator which yields output from the command line by
line</p>

<p style="margin-top: 1em">Return type <br>
generator which yields strings</p>

<p style="margin-top: 1em">Availability: Unix (streaming),
Windows (blocking)</p>


<p style="margin-top: 1em">osrf_pycommon.process_utils.execute_process_split(cmd,
cwd=None, env=None, shell=False, emulate_tty=False) <br>
execute_process(), except stderr is returned separately.</p>

<p style="margin-top: 1em">Instead of yielding output line
by line until yielding a return code, this function always a
triplet of stdout, stderr, and return code. Each time only
one of the three <br>
will not be None. Once you receive a non-None return code
(type will be int) there will be no more stdout or stderr.
Therefore you can use the command like this:</p>

<p style="margin-top: 1em">from __future__ import
print_function <br>
import sys <br>
from osrf_pycommon.process_utils import
execute_process_split</p>

<p style="margin-top: 1em">cmd = [&rsquo;time&rsquo;,
&rsquo;ls&rsquo;, &rsquo;-G&rsquo;] <br>
for out, err, ret in execute_process_split(cmd,
cwd=&rsquo;/usr&rsquo;): <br>
# In Python 3, it will be a bytes array which needs to be
decoded <br>
out = out.decode(&rsquo;utf-8&rsquo;) if out is not None
else None <br>
err = err.decode(&rsquo;utf-8&rsquo;) if err is not None
else None <br>
if ret is not None: <br>
# This is a return code, the command has exited <br>
print(&quot;&rsquo;{0}&rsquo; exited with:
{1}&quot;.format(&rsquo; &rsquo;.join(cmd), ret)) <br>
break <br>
if out is not None: <br>
print(out, end=&rsquo;&rsquo;) <br>
if err is not None: <br>
print(err, end=&rsquo;&rsquo;, file=sys.stderr)</p>

<p style="margin-top: 1em">When using this, it is possible
that the stdout and stderr data can be returned in a
different order than what would happen on the terminal. This
is due to the fact that <br>
the subprocess is given different buffers for stdout and
stderr and so there is a race condition on the subprocess
writing to the different buffers and this command
read&acirc; <br>
ing the buffers. This can be avoided in most scenarios by
using emulate_tty, because of the use of pty&rsquo;s, though
the ordering can still not be guaranteed and the number <br>
of pty&rsquo;s is finite as explained in the documentation
for execute_process(). For situations where output ordering
between stdout and stderr are critical, they should not <br>
be returned separately and instead should share one buffer,
and so execute_process() should be used.</p>

<p style="margin-top: 1em">For all other parameters and
documentation see: execute_process()</p>

<p style="margin-top: 1em">Availability: Unix (streaming),
Windows (blocking)</p>

<p style="margin-top: 1em">Utility Functions <br>
Currently there is only one utility function, a Python
implementation of the which shell command.</p>


<p style="margin-top: 1em">osrf_pycommon.process_utils.which(cmd,
mode=1, path=None, **kwargs) <br>
Given a command, mode, and a PATH string, return the path
which conforms to the given mode on the PATH, or None if
there is no such file.</p>

<p style="margin-top: 1em">mode defaults to os.F_OK |
os.X_OK. path defaults to the result of
os.environ.get(&quot;PATH&quot;), or can be overridden with
a custom search path.</p>

<p style="margin-top: 1em">Backported from shutil.which()
(https://docs.python.org/3.3/library/shutil.html#shutil.which),
available in Python 3.3.</p>

<p style="margin-top: 1em">THE TERMINAL_COLOR MODULE <br>
This module provides tools for colorizing terminal
output.</p>

<p style="margin-top: 1em">This module defines the ansi
escape sequences used for colorizing the output from
terminal programs in Linux. You can access the ansi escape
sequences using the ansi() function:</p>

<p style="margin-top: 1em">&gt;&gt;&gt; from
osrf_pycommon.terminal_color import ansi <br>
&gt;&gt;&gt; print([&quot;This is &quot;,
ansi(&rsquo;red&rsquo;), &quot;red&quot;,
ansi(&rsquo;reset&rsquo;), &quot;.&quot;]) <br>
[&rsquo;This is &rsquo;, &rsquo;b[31m&rsquo;,
&rsquo;red&rsquo;, &rsquo;b[0m&rsquo;, &rsquo;.&rsquo;]</p>

<p style="margin-top: 1em">You can also use format_color()
to do in-line substitution of keys wrapped in @{} markers
for their ansi escape sequences:</p>

<p style="margin-top: 1em">&gt;&gt;&gt; from
osrf_pycommon.terminal_color import format_color <br>
&gt;&gt;&gt; print(format_color(&quot;This is
@{bf}blue@{reset}.&quot;).split()) <br>
[&rsquo;This&rsquo;, &rsquo;is&rsquo;,
&rsquo;b[34mblueb[0m.&rsquo;]</p>

<p style="margin-top: 1em">This is a list of all of the
available substitutions:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;Long Form &acirc; Shorter &acirc; Value &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{blackf} &acirc; @{kf} &acirc; 33[30m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{redf} &acirc; @{rf} &acirc; 33[31m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{greenf} &acirc; @{gf} &acirc; 33[32m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{yellowf} &acirc; @{yf} &acirc; 33[33m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{bluef} &acirc; @{bf} &acirc; 33[34m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{purplef} &acirc; @{pf} &acirc; 33[35m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{cyanf} &acirc; @{cf} &acirc; 33[36m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{whitef} &acirc; @{wf} &acirc; 33[37m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{blackb} &acirc; @{kb} &acirc; 33[40m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{redb} &acirc; @{rb} &acirc; 33[41m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">&acirc;@{greenb} &acirc; @{gb}
&acirc; 33[42m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{yellowb} &acirc; @{yb} &acirc; 33[43m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{blueb} &acirc; @{bb} &acirc; 33[44m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{purpleb} &acirc; @{pb} &acirc; 33[45m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{cyanb} &acirc; @{cb} &acirc; 33[46m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{whiteb} &acirc; @{wb} &acirc; 33[47m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{escape} &acirc; &acirc; 33 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{reset} &acirc; @| &acirc; 33[0m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{boldon} &acirc; @! &acirc; 33[1m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{italicson} &acirc; @/ &acirc; 33[3m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{ulon} &acirc; @_ &acirc; 33[4m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{invon} &acirc; &acirc; 33[7m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{boldoff} &acirc; &acirc; 33[22m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{italicsoff} &acirc; &acirc; 33[23m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{uloff} &acirc; &acirc; 33[24m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;@{invoff} &acirc; &acirc; 33[27m &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">These substitution&rsquo;s
values come from the ANSI color escape sequences, see:
http://en.wikipedia.org/wiki/ANSI_escape_code</p>

<p style="margin-top: 1em">Also for any of the keys which
have a trailing f, you can safely drop the trailing f and
get the same thing.</p>

<p style="margin-top: 1em">For example,
format_color(&quot;@{redf}&quot;) and
format_color(&quot;@{red}&quot;) are functionally
equivalent.</p>

<p style="margin-top: 1em">Also, many of the substitutions
have shorten forms for convenience, such that @{redf},
@{rf}, @{red}, and @{r} are all the same.</p>

<p style="margin-top: 1em">Note that a trailing b is always
required when specifying a background.</p>

<p style="margin-top: 1em">Some of the most common
non-color sequences have {}&rsquo;less versions.</p>

<p style="margin-top: 1em">For example, @{boldon}&rsquo;s
shorter form is @!.</p>

<p style="margin-top: 1em">By default, the substitutions
(and calls to ansi()) resolve to escape sequences, but if
you call disable_ansi_color_substitution_globally() then
they will resolve to empty <br>
strings.</p>

<p style="margin-top: 1em">This allows you to always use
the substitution strings and disable them globally when
desired.</p>

<p style="margin-top: 1em">On Windows the substitutions are
always resolved to empty strings as the ansi escape
sequences do not work on Windows. Instead strings annotated
with @{} style substitutions or <br>
raw b[xxm style ansi escape sequences must be passed to
print_color() in order for colors to be displayed on
windows. Also the print_ansi_color_win32() function can be
used <br>
on strings which only contain ansi escape sequences.</p>

<p style="margin-top: 1em">NOTE: <br>
There are existing Python modules like colorama which
provide ansi colorization on multiple platforms, so a valid
question is: &quot;why write this module?&quot;. The reason
for writ&acirc; <br>
ing this module is to provide the color annotation of
strings and functions for removing or replacing ansi escape
sequences which are not provided by modules like colorama.
<br>
This module could have depended on colorama for colorization
on Windows, but colorama works by replacing the built-in
sys.stdout and sys.stderr, which we did not want and it <br>
has extra functionality that we do not need. So, instead of
depending on colorama, the Windows color printing code was
used as the inspiration for the Windows color printing <br>
in the windows.py module in this terminal_color package. The
colorama license was placed in the header of that file and
the colorama license is compatible with this package&rsquo;s
<br>
license.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.ansi(key)
<br>
Returns the escape sequence for a given ansi color key.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.disable_ansi_color_substitution_globally()
<br>
Causes format_color() to replace color annotations with
empty strings.</p>

<p style="margin-top: 1em">It also affects ansi().</p>

<p style="margin-top: 1em">This is not the case by default,
so if you want to make all substitutions given to either
function mentioned above return empty strings then call this
function.</p>

<p style="margin-top: 1em">The default behavior can be
restored by calling
enable_ansi_color_substitution_globally().</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.enable_ansi_color_substitution_globally()
<br>
Causes format_color() to replace color annotations with ansi
esacpe sequences.</p>

<p style="margin-top: 1em">It also affects ansi().</p>

<p style="margin-top: 1em">This is the case by default, so
there is no need to call this everytime.</p>

<p style="margin-top: 1em">If you have previously caused
all substitutions to evaluate to an empty string by calling
disable_ansi_color_substitution_globally(), then you can
restore the escape <br>
sequences for substitutions by calling this function.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.format_color(msg)
<br>
Replaces color annotations with ansi escape sequences.</p>

<p style="margin-top: 1em">See this module&rsquo;s
documentation for the list of available substitutions.</p>

<p style="margin-top: 1em">If
disable_ansi_color_substitution_globally() has been called
then all color annotations will be replaced by empty
strings.</p>

<p style="margin-top: 1em">Also, on Windows all color
annotations will be replaced with empty strings. If you want
colorization on Windows, you must pass annotated strings to
print_color().</p>

<p style="margin-top: 1em">Parameters <br>
msg (str) -- string message to be colorized</p>

<p style="margin-top: 1em">Returns <br>
colorized string</p>

<p style="margin-top: 1em">Return type <br>
str</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.get_ansi_dict()
<br>
Returns a copy of the dictionary of keys and ansi escape
sequences.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.print_ansi_color_win32(*args,
**kwargs) <br>
Prints color string containing ansi escape sequences to
console in Windows.</p>

<p style="margin-top: 1em">If called on a non-Windows
system, a NotImplementedError occurs.</p>

<p style="margin-top: 1em">Does not respect
disable_ansi_color_substitution_globally().</p>

<p style="margin-top: 1em">Does not substitute color
annotations like @{r} or @!, the string must already contain
the 33[1m style ansi escape sequences.</p>

<p style="margin-top: 1em">Works by splitting each argument
up by ansi escape sequence, printing the text between the
sequences, and doing the corresponding win32 action for each
ansi sequence <br>
encountered.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.print_color(*args,
**kwargs) <br>
Colorizes and prints with an implicit ansi reset at the
end</p>

<p style="margin-top: 1em">Calls format_color() on each
positional argument and then sends all positional and
keyword arguments to print.</p>

<p style="margin-top: 1em">If the end keyword argument is
not present then the default end value
ansi(&rsquo;reset&rsquo;) + &rsquo;0 is used and passed to
print.</p>

<p style="margin-top: 1em">os.linesep is used to determine
the actual value for 0</p>

<p style="margin-top: 1em">Therefore, if you use the end
keyword argument be sure to include an ansi reset escape
sequence if necessary.</p>

<p style="margin-top: 1em">On Windows the substituted
arguments and keyword arguments are passed to
print_ansi_color_win32() instead of just print.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.remove_ansi_escape_senquences(string)
<br>
Removes any ansi escape sequences found in the given string
and returns it.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.sanitize(msg)
<br>
Sanitizes the given string to prevent format_color() from
substituting content.</p>

<p style="margin-top: 1em">For example, when the string
&rsquo;Email: {user}@{org}&rsquo; is passed to
format_color() the @{org} will be incorrectly recognized as
a colorization annotation and it will fail to <br>
substitute with a KeyError: org.</p>

<p style="margin-top: 1em">In order to prevent this, you
can first &quot;sanatize&quot; the string, add color
annotations, and then pass the whole string to
format_color().</p>

<p style="margin-top: 1em">If you give this function the
string &rsquo;Email: {user}@{org}&rsquo;, then it will
return &rsquo;Email: {{user}}@@{{org}}&rsquo;. Then if you
pass that to format_color() it will return &rsquo;Email:
<br>
{user}@{org}&rsquo;. In this way format_color() is the
reverse of this function and so it is safe to call this
function on any incoming data if it will eventually be
passed to <br>
format_color().</p>

<p style="margin-top: 1em">In addition to expanding { =&gt;
{{, } =&gt; }}, and @ =&gt; @@, this function will also
replace any instances of @!, @/, @_, and @| with
@{atexclimation}, @{atfwdslash}, @{atun&acirc; <br>
derscore}, and @{atbar} respectively. And then there are
corresponding keys in the ansi dict to convert them
back.</p>

<p style="margin-top: 1em">For example, if you pass the
string &rsquo;|@ Notice @|&rsquo; to this function it will
return &rsquo;|@@ Notice @{atbar}&rsquo;. And since
ansi(&rsquo;atbar&rsquo;) always returns @|, even when <br>
disable_ansi_color_substitution_globally() has been called,
the result of passing that string to format_color() will be
&rsquo;|@ Notice @|&rsquo; again.</p>

<p style="margin-top: 1em">There are two main strategies
for constructing strings which use both the Python
str.format() function and the colorization annotations.</p>

<p style="margin-top: 1em">One way is to just build each
piece and concatenate the result:</p>

<p style="margin-top: 1em">print_color(&quot;@{r}&quot;,
&quot;{error}&quot;.format(error=error_str)) <br>
# Or using print (remember to include an ansi reset) <br>
print(format_color(&quot;@{r}&quot; +
&quot;{error}&quot;.format(error=error_str) +
&quot;@|&quot;))</p>

<p style="margin-top: 1em">Another way is to use this
function on the format string, concatenate to the
annotations, pass the whole string to format_color(), and
then format the whole thing:</p>


<p style="margin-top: 1em">print(format_color(&quot;@{r}&quot;
+ sanitize(&quot;{error}&quot;) + &quot;@|&quot;) <br>
.format(error=error_str))</p>

<p style="margin-top: 1em">However, the most common use for
this function is to sanitize incoming strings which may have
unknown content:</p>

<p style="margin-top: 1em">def my_func(user_content): <br>
print_color(&quot;@{y}&quot; + sanitize(user_content))</p>

<p style="margin-top: 1em">This function is not intended to
be used on strings with color annotations.</p>

<p style="margin-top: 1em">Parameters <br>
msg (str) -- string message to be sanitized</p>

<p style="margin-top: 1em">Returns <br>
sanitized string</p>

<p style="margin-top: 1em">Return type <br>
str</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.split_by_ansi_escape_sequence(string,
include_delimiters=False) <br>
Splits a string into a list using any ansi escape sequence
as a delimiter.</p>

<p style="margin-top: 1em">Parameters</p>

<p style="margin-top: 1em">&Acirc;&middot; string (str) --
string to be split</p>

<p style="margin-top: 1em">&Acirc;&middot;
include_delimiters (bool) -- If True include matched escape
sequences in the list (default: False)</p>

<p style="margin-top: 1em">Returns <br>
list of strings, split from original string by escape
sequences</p>

<p style="margin-top: 1em">Return type <br>
list</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_color.test_colors(file=None)
<br>
Prints a color testing block using print_color()</p>

<p style="margin-top: 1em">THE TERMINAL_UTILS MODULE <br>
This module has a miscellaneous set of functions for working
with terminals.</p>

<p style="margin-top: 1em">You can use the
get_terminal_dimensions() to get the width and height of the
terminal as a tuple.</p>

<p style="margin-top: 1em">You can also use the is_tty()
function to determine if a given object is a tty.</p>

<p style="margin-top: 1em">exception
osrf_pycommon.terminal_utils.GetTerminalDimensionsError <br>
Raised when the terminal dimensions cannot be
determined.</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_utils.get_terminal_dimensions()
<br>
Returns the width and height of the terminal.</p>

<p style="margin-top: 1em">Returns <br>
width and height in that order as a tuple</p>

<p style="margin-top: 1em">Return type <br>
tuple</p>

<p style="margin-top: 1em">Raises
GetTerminalDimensionsError when the terminal dimensions
cannot be determined</p>


<p style="margin-top: 1em">osrf_pycommon.terminal_utils.is_tty(stream)
<br>
Returns True if the given stream is a tty, else False</p>

<p style="margin-top: 1em">Parameters <br>
stream -- object to be checked for being a tty</p>

<p style="margin-top: 1em">Returns <br>
True if the given object is a tty, otherwise False</p>

<p style="margin-top: 1em">Return type <br>
bool</p>

<p style="margin-top: 1em">INSTALLING FROM SOURCE <br>
Given that you have a copy of the source code, you can
install osrf_pycommon like this:</p>

<p style="margin-top: 1em">$ python setup.py install</p>

<p style="margin-top: 1em">NOTE: <br>
If you are installing to a system Python you may need to use
sudo.</p>

<p style="margin-top: 1em">If you do not want to install
osrf_pycommon into your system Python, or you don&rsquo;t
have access to sudo, then you can use a virtualenv.</p>

<p style="margin-top: 1em">HACKING <br>
Because osrf_pycommon uses setuptools you can (and should)
use the develop feature:</p>

<p style="margin-top: 1em">$ python setup.py develop</p>

<p style="margin-top: 1em">NOTE: <br>
If you are developing against the system Python, you may
need sudo.</p>

<p style="margin-top: 1em">This will &quot;install&quot;
osrf_pycommon to your Python path, but rather than copying
the source files, it will instead place a marker file in the
PYTHONPATH redirecting Python to your <br>
source directory. This allows you to use it as if it were
installed but where changes to the source code take
immediate affect.</p>

<p style="margin-top: 1em">When you are done with develop
mode you can (and should) undo it like this:</p>

<p style="margin-top: 1em">$ python setup.py develop -u</p>

<p style="margin-top: 1em">NOTE: <br>
If you are developing against the system Python, you may
need sudo.</p>

<p style="margin-top: 1em">That will &quot;uninstall&quot;
the hooks into the PYTHONPATH which point to your source
directory, but you should be wary that sometimes console
scripts do not get removed from the bin <br>
folder.</p>

<p style="margin-top: 1em">TESTING <br>
In order to run the tests you will need to install
nosetests, flake8, and Mock.</p>

<p style="margin-top: 1em">Once you have installed those,
then run nosetest in the root of the osrf_pycommon source
directory:</p>

<p style="margin-top: 1em">$ nosetests</p>

<p style="margin-top: 1em">BUILDING THE DOCUMENTATION <br>
In order to build the docs you will need to first install
Sphinx.</p>

<p style="margin-top: 1em">You can build the documentation
by invoking the Sphinx provided make target in the docs
folder:</p>

<p style="margin-top: 1em">$ # In the docs folder <br>
$ make html <br>
$ open _build/html/index.html</p>

<p style="margin-top: 1em">Sometimes Sphinx does not pickup
on changes to modules in packages which utilize the __all__
mechanism, so on repeat builds you may need to clean the
docs first:</p>

<p style="margin-top: 1em">$ # In the docs folder <br>
$ make clean <br>
$ make html <br>
$ open _build/html/index.html</p>

<p style="margin-top: 1em">AUTHOR <br>
William Woodall</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2014, Open Source Robotics Foundation</p>

<p style="margin-top: 1em">0.0 Feb 11, 2017
OSRF_PYCOMMON(1)</p>
<hr>
</body>
</html>
