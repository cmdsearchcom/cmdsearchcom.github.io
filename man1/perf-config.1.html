<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:28 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERF-CONFIG(1) perf Manual PERF-CONFIG(1)</p>

<p style="margin-top: 1em">NAME <br>
perf-config - Get and set variables in a configuration
file.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
perf config [&lt;file-option&gt;] -l | --list</p>

<p style="margin-top: 1em">DESCRIPTION <br>
You can manage variables in a configuration file with this
command.</p>

<p style="margin-top: 1em">OPTIONS <br>
-l, --list <br>
Show current config variables, name and value, for all
sections.</p>

<p style="margin-top: 1em">--user <br>
For writing and reading options: write to user
$HOME/.perfconfig file or read it.</p>

<p style="margin-top: 1em">--system <br>
For writing and reading options: write to system-wide
$(sysconfdir)/perfconfig or read it.</p>

<p style="margin-top: 1em">CONFIGURATION FILE <br>
The perf configuration file contains many variables to
change various aspects of each of its tools, including
output, disk usage, etc. The $HOME/.perfconfig file is used
to store <br>
a per-user configuration. The file $(sysconfdir)/perfconfig
can be used to store a system-wide default
configuration.</p>

<p style="margin-top: 1em">When reading or writing, the
values are read from the system and user configuration files
by default, and options --system and --user can be used to
tell the command to read from <br>
or write to only that location.</p>

<p style="margin-top: 1em">Syntax <br>
The file consist of sections. A section starts with its name
surrounded by square brackets and continues till the next
section begins. Each variable must be in a section, and <br>
have the form name = value, for example:</p>

<p style="margin-top: 1em">[section] <br>
name1 = value1 <br>
name2 = value2</p>

<p style="margin-top: 1em">Section names are case sensitive
and can contain any characters except newline (double quote
&quot; and backslash have to be escaped as <br>
span multiple lines.</p>

<p style="margin-top: 1em">Example <br>
Given a $HOME/.perfconfig like this:</p>

<p style="margin-top: 1em"># # This is the config file, and
# a # and ; character indicates a comment #</p>

<p style="margin-top: 1em">[colors] <br>
# Color variables <br>
top = red, default <br>
medium = green, default <br>
normal = lightgray, default <br>
selected = white, lightgray <br>
jump_arrows = blue, default <br>
addr = magenta, default <br>
root = white, blue</p>

<p style="margin-top: 1em">[tui] <br>
# Defaults if linked with libslang <br>
report = on <br>
annotate = on <br>
top = on</p>

<p style="margin-top: 1em">[buildid] <br>
# Default, disable using /dev/null <br>
dir = ~/.debug</p>

<p style="margin-top: 1em">[annotate] <br>
# Defaults <br>
hide_src_code = false <br>
use_offset = true <br>
jump_arrows = true <br>
show_nr_jumps = false</p>

<p style="margin-top: 1em">[help] <br>
# Format can be man, info, web or html <br>
format = man <br>
autocorrect = 0</p>

<p style="margin-top: 1em">[ui] <br>
show-headers = true</p>

<p style="margin-top: 1em">[call-graph] <br>
# fp (framepointer), dwarf <br>
record-mode = fp <br>
print-type = graph <br>
order = caller <br>
sort-key = function</p>

<p style="margin-top: 1em">Variables <br>
colors.* <br>
The variables for customizing the colors used in the output
for the report, top and annotate in the TUI. They should
specify the foreground and background colors, separated <br>
by a comma, for example:</p>

<p style="margin-top: 1em">medium = green, lightgray</p>

<p style="margin-top: 1em">If you want to use the color
configured for you terminal, just leave it <br>
as &rsquo;default&rsquo;, for example:</p>

<p style="margin-top: 1em">medium = default, lightgray</p>

<p style="margin-top: 1em">Available colors: <br>
red, yellow, green, cyan, gray, black, blue, <br>
white, default, magenta, lightgray</p>

<p style="margin-top: 1em">colors.top <br>
top means a overhead percentage which is more than 5%. And
values of this variable specify percentage colors. Basic key
values are foreground-color red and background-color <br>
default.</p>

<p style="margin-top: 1em">colors.medium <br>
medium means a overhead percentage which has more than 0.5%.
Default values are green and default.</p>

<p style="margin-top: 1em">colors.normal <br>
normal means the rest of overhead percentages except top,
medium, selected. Default values are lightgray and
default.</p>

<p style="margin-top: 1em">colors.selected <br>
This selects the colors for the current entry in a list of
entries from sub-commands (top, report, annotate). Default
values are black and lightgray.</p>

<p style="margin-top: 1em">colors.jump_arrows <br>
Colors for jump arrows on assembly code listings such as
jns, jmp, jane, etc. Default values are blue, default.</p>

<p style="margin-top: 1em">colors.addr <br>
This selects colors for addresses from annotate. Default
values are magenta, default.</p>

<p style="margin-top: 1em">colors.root <br>
Colors for headers in the output of a sub-commands (top,
report). Default values are white, blue.</p>

<p style="margin-top: 1em">tui., gtk. <br>
Subcommands that can be configured here are top, report and
annotate. These values are booleans, for example:</p>

<p style="margin-top: 1em">[tui] <br>
top = true</p>

<p style="margin-top: 1em">will make the TUI be the default
for the &rsquo;top&rsquo; subcommand. Those will be <br>
available if the required libs were detected at tool build
time.</p>

<p style="margin-top: 1em">buildid.*, buildid.dir <br>
Each executable and shared library in modern distributions
comes with a content based identifier that, if available,
will be inserted in a perf.data file header to, at <br>
analysis time find what is needed to do symbol resolution,
code annotation, etc.</p>

<p style="margin-top: 1em">The recording tools also stores
a hard link or copy in a per-user <br>
directory, $HOME/.debug/, of binaries, shared libraries,
/proc/kallsyms <br>
and /proc/kcore files to be used at analysis time.</p>

<p style="margin-top: 1em">The buildid.dir variable can be
used to either change this directory <br>
cache location, or to disable it altogether. If you want to
disable it, <br>
set buildid.dir to /dev/null. The default is
$HOME/.debug</p>

<p style="margin-top: 1em">annotate.* <br>
These options work only for TUI. These are in control of
addresses, jump function, source code in lines of assembly
code from a specific program.</p>

<p style="margin-top: 1em">annotate.hide_src_code <br>
If a program which is analyzed has source code, this option
lets annotate print a list of assembly code with the source
code. For example, let&acirc;s see a part of a program. <br>
There&acirc;re four lines. If this option is true, they can
be printed without source code from a program as below.</p>

<p style="margin-top: 1em">&acirc; push %rbp <br>
&acirc; mov %rsp,%rbp <br>
&acirc; sub $0x10,%rsp <br>
&acirc; mov (%rdi),%rdx</p>

<p style="margin-top: 1em">But if this option is
&rsquo;false&rsquo;, source code of the part <br>
can be also printed as below. Default is
&rsquo;false&rsquo;.</p>

<p style="margin-top: 1em">&acirc; struct rb_node
*rb_next(const struct rb_node *node) <br>
&acirc; { <br>
&acirc; push %rbp <br>
&acirc; mov %rsp,%rbp <br>
&acirc; sub $0x10,%rsp <br>
&acirc; struct rb_node *parent; <br>
&acirc; <br>
&acirc; if (RB_EMPTY_NODE(node)) <br>
&acirc; mov (%rdi),%rdx <br>
&acirc; return n;</p>

<p style="margin-top: 1em">annotate.use_offset <br>
Basing on a first address of a loaded function, offset can
be used. Instead of using original addresses of assembly
code, addresses subtracted from a base address can be <br>
printed. Let&acirc;s illustrate an example. If a base
address is 0XFFFFFFFF81624d50 as below,</p>

<p style="margin-top: 1em">ffffffff81624d50
&lt;load0&gt;</p>

<p style="margin-top: 1em">an address on assembly code has
a specific absolute address as below</p>

<p style="margin-top: 1em">ffffffff816250b8:&acirc; mov
0x8(%r14),%rdi</p>

<p style="margin-top: 1em">but if use_offset is
&rsquo;true&rsquo;, an address subtracted from a base
address is printed. <br>
Default is true. This option is only applied to TUI.</p>

<p style="margin-top: 1em">368:&acirc; mov
0x8(%r14),%rdi</p>

<p style="margin-top: 1em">annotate.jump_arrows <br>
There can be jump instruction among assembly code. Depending
on a boolean value of jump_arrows, arrows can be printed or
not which represent where do the instruction jump <br>
into as below.</p>

<p style="margin-top: 1em">&acirc; &acirc;&acirc;&acirc;jmp
1333 <br>
&acirc; &acirc; xchg %ax,%ax <br>
&acirc;1330:&acirc; mov %r15,%r10 <br>
&acirc;1333:&acirc;&acirc;&acirc;cmp %r15,%r14</p>

<p style="margin-top: 1em">If jump_arrow is
&rsquo;false&rsquo;, the arrows isn&rsquo;t printed as
below. <br>
Default is &rsquo;false&rsquo;.</p>

<p style="margin-top: 1em">&acirc; &acirc; jmp 1333 <br>
&acirc; xchg %ax,%ax <br>
&acirc;1330: mov %r15,%r10 <br>
&acirc;1333: cmp %r15,%r14</p>

<p style="margin-top: 1em">annotate.show_linenr <br>
When showing source code if this option is true, line
numbers are printed as below.</p>

<p style="margin-top: 1em">&acirc;1628 if (type &amp;
PERF_SAMPLE_IDENTIFIER) { <br>
&acirc; &acirc; jne 508 <br>
&acirc;1628 data-&gt;id = *array; <br>
&acirc;1629 array++; <br>
&acirc;1630 }</p>

<p style="margin-top: 1em">However if this option is
&rsquo;false&rsquo;, they aren&rsquo;t printed as below.
<br>
Default is &rsquo;false&rsquo;.</p>

<p style="margin-top: 1em">&acirc; if (type &amp;
PERF_SAMPLE_IDENTIFIER) { <br>
&acirc; &acirc; jne 508 <br>
&acirc; data-&gt;id = *array; <br>
&acirc; array++; <br>
&acirc; }</p>

<p style="margin-top: 1em">annotate.show_nr_jumps <br>
Let&acirc;s see a part of assembly code.</p>

<p style="margin-top: 1em">&acirc;1382: movb
$0x1,-0x270(%rbp)</p>

<p style="margin-top: 1em">If use this, the number of
branches jumping to that address can be printed as below.
<br>
Default is &rsquo;false&rsquo;.</p>

<p style="margin-top: 1em">&acirc;1 1382: movb
$0x1,-0x270(%rbp)</p>

<p style="margin-top: 1em">annotate.show_total_period <br>
To compare two records on an instruction base, with this
option provided, display total number of samples that belong
to a line in assembly code. If this option is true, <br>
total periods are printed instead of percent values as
below.</p>

<p style="margin-top: 1em">302 &acirc; mov %eax,%eax</p>

<p style="margin-top: 1em">But if this option is
&rsquo;false&rsquo;, percent values for overhead are printed
i.e. <br>
Default is &rsquo;false&rsquo;.</p>

<p style="margin-top: 1em">99.93 &acirc; mov %eax,%eax</p>

<p style="margin-top: 1em">hist.*, hist.percentage <br>
This option control the way to calculate overhead of
filtered entries - that means the value of this option is
effective only if there&acirc;s a filter (by comm, dso or
symbol <br>
name). Suppose a following example:</p>

<p style="margin-top: 1em">Overhead Symbols <br>
........ ....... <br>
33.33% foo <br>
33.33% bar <br>
33.33% baz</p>

<p style="margin-top: 1em">This is an original overhead and
we&rsquo;ll filter out the first &rsquo;foo&rsquo; <br>
entry. The value of &rsquo;relative&rsquo; would increase
the overhead of &rsquo;bar&rsquo; <br>
and &rsquo;baz&rsquo; to 50.00% for each, while
&rsquo;absolute&rsquo; would show their <br>
current overhead (33.33%).</p>

<p style="margin-top: 1em">ui.*, ui.show-headers <br>
This option controls display of column headers (like
Overhead and Symbol) in report and top. If this option is
false, they are hidden. This option is only applied to
TUI.</p>

<p style="margin-top: 1em">call-graph.* <br>
When sub-commands top and report work with
-g/&acirc;-children there&acirc;re options in control of
call-graph.</p>

<p style="margin-top: 1em">call-graph.record-mode <br>
The record-mode can be fp (frame pointer), dwarf and lbr.
The value of dwarf is effective only if perf detect needed
library (libunwind or a recent version of libdw). lbr <br>
only work for cpus that support it.</p>

<p style="margin-top: 1em">call-graph.dump-size <br>
The size of stack to dump in order to do post-unwinding.
Default is 8192 (byte). When using dwarf into record-mode,
the default size will be used if omitted.</p>

<p style="margin-top: 1em">call-graph.print-type <br>
The print-types can be graph (graph absolute), fractal
(graph relative), flat and folded. This option controls a
way to show overhead for each callchain entry. Suppose a
<br>
following example.</p>

<p style="margin-top: 1em">Overhead Symbols <br>
........ ....... <br>
40.00% foo <br>
| <br>
---foo <br>
| <br>
|--50.00%--bar <br>
| main <br>
| <br>
--50.00%--baz <br>
main</p>

<p style="margin-top: 1em">This output is a
&rsquo;fractal&rsquo; format. The &rsquo;foo&rsquo; came
from &rsquo;bar&rsquo; and &rsquo;baz&rsquo; exactly <br>
half and half so &rsquo;fractal&rsquo; shows 50.00% for each
<br>
(meaning that it assumes 100% total overhead of
&rsquo;foo&rsquo;).</p>

<p style="margin-top: 1em">The &rsquo;graph&rsquo; uses
absolute overhead value of &rsquo;foo&rsquo; as total so
each of <br>
&rsquo;bar&rsquo; and &rsquo;baz&rsquo; callchain will have
20.00% of overhead. <br>
If &rsquo;flat&rsquo; is used, single column and linear
exposure of call chains. <br>
&rsquo;folded&rsquo; mean call chains are displayed in a
line, separated by semicolons.</p>

<p style="margin-top: 1em">call-graph.order <br>
This option controls print order of callchains. The default
is callee which means callee is printed at top and then
followed by its caller and so on. The caller prints it in
<br>
reverse order.</p>

<p style="margin-top: 1em">If this option is not set and
report.children or top.children is <br>
set to true (or the equivalent command line option is
given), <br>
the default value of this option is changed to
&rsquo;caller&rsquo; for the <br>
execution of &rsquo;perf report&rsquo; or &rsquo;perf
top&rsquo;. Other commands will <br>
still default to &rsquo;callee&rsquo;.</p>

<p style="margin-top: 1em">call-graph.sort-key <br>
The callchains are merged if they contain same information.
The sort-key option determines a way to compare the
callchains. A value of sort-key can be function or address.
<br>
The default is function.</p>

<p style="margin-top: 1em">call-graph.threshold <br>
When there&acirc;re many callchains it&acirc;d print tons of
lines. So perf omits small callchains under a certain
overhead (threshold) and this option control the threshold.
Default is <br>
0.5 (%). The overhead is calculated by value depends on
call-graph.print-type.</p>

<p style="margin-top: 1em">call-graph.print-limit <br>
This is a maximum number of lines of callchain printed for a
single histogram entry. Default is 0 which means no
limitation.</p>

<p style="margin-top: 1em">report.*, report.percent-limit
<br>
This one is mostly the same as call-graph.threshold but
works for histogram entries. Entries having an overhead
lower than this percentage will not be printed. Default is
0. <br>
If percent-limit is 10, only entries which have more than
10% of overhead will be printed.</p>

<p style="margin-top: 1em">report.queue-size <br>
This option sets up the maximum allocation size of the
internal event queue for ordering events. Default is 0,
meaning no limit.</p>

<p style="margin-top: 1em">report.children <br>
Children means functions called from another function. If
this option is true, perf report cumulates callchains of
children and show (accumulated) total overhead as well as
<br>
Self overhead. Please refer to the perf report manual. The
default is true.</p>

<p style="margin-top: 1em">report.group <br>
This option is to show event group information together.
Example output with this turned on, notice that there is one
column per event in the group, ref-cycles and cycles:</p>

<p style="margin-top: 1em"># group: {ref-cycles,cycles}
<br>
# ======== <br>
# <br>
# Samples: 7K of event &rsquo;anon group { ref-cycles,
cycles }&rsquo; <br>
# Event count (approx.): 6876107743 <br>
# <br>
# Overhead Command Shared Object Symbol <br>
# ................ ....... .................
................... <br>
# <br>
99.84% 99.76% noploop noploop [.] main <br>
0.07% 0.00% noploop ld-2.15.so [.] strcmp <br>
0.03% 0.00% noploop [kernel.kallsyms] [k] timerqueue_del</p>

<p style="margin-top: 1em">top.*, top.children <br>
Same as report.children. So if it is enabled, the output of
top command will have Children overhead column as well as
Self overhead column by default. The default is true.</p>

<p style="margin-top: 1em">man.*, man.viewer <br>
This option can assign a tool to view manual pages when help
subcommand was invoked. Supported tools are man, woman (with
emacs client) and konqueror. Default is man.</p>

<p style="margin-top: 1em">New man viewer tool can be also
added using &rsquo;man.&lt;tool&gt;.cmd&rsquo; <br>
or use different path using
&rsquo;man.&lt;tool&gt;.path&rsquo; config option.</p>

<p style="margin-top: 1em">pager.*,
pager.&lt;subcommand&gt; <br>
When the subcommand is run on stdio, determine whether it
uses pager or not based on this value. Default is
unspecified.</p>

<p style="margin-top: 1em">kmem.*, kmem.default <br>
This option decides which allocator is to be analyzed if
neither --slab nor --page option is used. Default is
slab.</p>

<p style="margin-top: 1em">record.*, record.build-id <br>
This option can be cache, no-cache or skip. cache is to
post-process data and save/update the binaries into the
build-id cache (in ~/.debug). This is the default. But if
<br>
this option is no-cache, it will not update the build-id
cache. skip skips post-processing and does not update the
cache.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perf(1)</p>

<p style="margin-top: 1em">perf 07/04/2017
PERF-CONFIG(1)</p>
<hr>
</body>
</html>
