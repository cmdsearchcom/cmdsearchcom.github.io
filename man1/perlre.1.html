<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:03 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLRE(1) Perl Programmers Reference Guide PERLRE(1)</p>

<p style="margin-top: 1em">NAME <br>
perlre - Perl regular expressions</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This page describes the syntax of regular expressions in
Perl.</p>

<p style="margin-top: 1em">If you haven&rsquo;t used
regular expressions before, a quick-start introduction is
available in perlrequick, and a longer tutorial introduction
is available in perlretut.</p>

<p style="margin-top: 1em">For reference on how regular
expressions are used in matching operations, plus various
examples of the same, see discussions of &quot;m//&quot;,
&quot;s///&quot;, &quot;qr//&quot; and &quot;??&quot; in
&quot;Regexp Quote- <br>
Like Operators&quot; in perlop.</p>

<p style="margin-top: 1em">Modifiers <br>
Matching operations can have various modifiers. Modifiers
that relate to the interpretation of the regular expression
inside are listed below. Modifiers that alter the way a <br>
regular expression is used by Perl are detailed in
&quot;Regexp Quote-Like Operators&quot; in perlop and
&quot;Gory details of parsing quoted constructs&quot; in
perlop.</p>

<p style="margin-top: 1em">m Treat string as multiple
lines. That is, change &quot;^&quot; and &quot;$&quot; from
matching the start or end of the string to matching the
start or end of any line anywhere within the string.</p>

<p style="margin-top: 1em">s Treat string as single line.
That is, change &quot;.&quot; to match any character
whatsoever, even a newline, which normally it would not
match.</p>

<p style="margin-top: 1em">Used together, as
&quot;/ms&quot;, they let the &quot;.&quot; match any
character whatsoever, while still allowing &quot;^&quot; and
&quot;$&quot; to match, respectively, just after and just
before newlines within <br>
the string.</p>

<p style="margin-top: 1em">i Do case-insensitive pattern
matching.</p>

<p style="margin-top: 1em">If locale matching rules are in
effect, the case map is taken from the current locale for
code points less than 255, and from Unicode rules for larger
code points. However, <br>
matches that would cross the Unicode rules/non-Unicode rules
boundary (ords 255/256) will not succeed. See
perllocale.</p>

<p style="margin-top: 1em">There are a number of Unicode
characters that match multiple characters under
&quot;/i&quot;. For example, &quot;LATIN SMALL LIGATURE
FI&quot; should match the sequence &quot;fi&quot;. Perl is
not <br>
currently able to do this when the multiple characters are
in the pattern and are split between groupings, or when one
or more are quantified. Thus</p>

<p style="margin-top: 1em">&quot;ATIN SMALL LIGATURE
FI}&quot; =~ /fi/i; # Matches <br>
&quot;ATIN SMALL LIGATURE FI}&quot; =~ /[fi][fi]/i; #
Doesn&rsquo;t match! <br>
&quot;ATIN SMALL LIGATURE FI}&quot; =~ /fi*/i; #
Doesn&rsquo;t match!</p>

<p style="margin-top: 1em"># The below doesn&rsquo;t match,
and it isn&rsquo;t clear what $1 and $2 would <br>
# be even if it did!! <br>
&quot;ATIN SMALL LIGATURE FI}&quot; =~ /(f)(i)/i; #
Doesn&rsquo;t match!</p>

<p style="margin-top: 1em">Perl doesn&rsquo;t match
multiple characters in an inverted bracketed character
class, which otherwise could be highly confusing. See
&quot;Negation&quot; in perlrecharclass.</p>

<p style="margin-top: 1em">Another bug involves character
classes that match both a sequence of multiple characters,
and an initial sub-string of that sequence. For example,</p>

<p style="margin-top: 1em">/[s]/i</p>

<p style="margin-top: 1em">should match both a single and a
double &quot;s&quot;, since &quot;&quot; (on ASCII
platforms) matches &quot;ss&quot;. However, this bug ([perl
#89774] <br>

&lt;https://rt.perl.org/rt3/Ticket/Display.html?id=89774&gt;)
causes it to only match a single &quot;s&quot;, even if the
final larger match fails, and matching the double
&quot;ss&quot; would have <br>
succeeded.</p>

<p style="margin-top: 1em">Also, Perl matching
doesn&rsquo;t fully conform to the current Unicode
&quot;/i&quot; recommendations, which ask that the matching
be made upon the NFD (Normalization Form Decomposed) of the
<br>
text. However, Unicode is in the process of reconsidering
and revising their recommendations.</p>

<p style="margin-top: 1em">x Extend your pattern&rsquo;s
legibility by permitting whitespace and comments. Details in
&quot;/x&quot;</p>

<p style="margin-top: 1em">p Preserve the string matched
such that ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} are
available for use after matching.</p>

<p style="margin-top: 1em">g and c <br>
Global matching, and keep the Current position after failed
matching. Unlike i, m, s and x, these two flags affect the
way the regex is used rather than the regex itself. <br>
See &quot;Using regular expressions in Perl&quot; in
perlretut for further explanation of the g and c
modifiers.</p>

<p style="margin-top: 1em">a, d, l and u <br>
These modifiers, all new in 5.14, affect which character-set
semantics (Unicode, etc.) are used, as described below in
&quot;Character set modifiers&quot;.</p>

<p style="margin-top: 1em">Regular expression modifiers are
usually written in documentation as e.g., &quot;the
&quot;/x&quot; modifier&quot;, even though the delimiter in
question might not really be a slash. The modifiers <br>
&quot;/imsxadlup&quot; may also be embedded within the
regular expression itself using the &quot;(?...)&quot;
construct, see &quot;Extended Patterns&quot; below.</p>

<p style="margin-top: 1em">/x</p>

<p style="margin-top: 1em">&quot;/x&quot; tells the regular
expression parser to ignore most whitespace that is neither
backslashed nor within a character class. You can use this
to break up your regular expression <br>
into (slightly) more readable parts. The &quot;#&quot;
character is also treated as a metacharacter introducing a
comment, just as in ordinary Perl code. This also means that
if you want <br>
real whitespace or &quot;#&quot; characters in the pattern
(outside a character class, where they are unaffected by
&quot;/x&quot;), then you&rsquo;ll either have to escape
them (using backslashes or <br>
&quot;Q... <br>
you have to be careful not to include the pattern delimiter
in the comment--perl has no way of knowing you did not
intend to close the pattern early. See the C-comment
deletion <br>
code in perlop. Also note that anything inside a &quot;Q...
<br>
construct. For example in &quot;.}&quot;, regardless of the
&quot;/x&quot; modifier, there can be no spaces. Same for a
quantifier such as &quot;{3}&quot; or &quot;{5,}&quot;.
Similarly, &quot;(?:...)&quot; can&rsquo;t have a <br>
space between the &quot;?&quot; and &quot;:&quot;, but can
between the &quot;(&quot; and &quot;?&quot;. Within any
delimiters for such a construct, allowed spaces are not
affected by &quot;/x&quot;, and depend on the construct.
<br>
For example, &quot;.}&quot; can&rsquo;t have spaces because
hexadecimal numbers don&rsquo;t have spaces in them. But,
Unicode properties can have spaces, so in &quot;{...}&quot;
there can be spaces that <br>
follow the Unicode rules, for which see &quot;Properties
accessible through {} and P{}&quot; in perluniprops.</p>

<p style="margin-top: 1em">Character set modifiers</p>

<p style="margin-top: 1em">&quot;/d&quot;, &quot;/u&quot;,
&quot;/a&quot;, and &quot;/l&quot;, available starting in
5.14, are called the character set modifiers; they affect
the character set semantics used for the regular
expression.</p>

<p style="margin-top: 1em">The &quot;/d&quot;,
&quot;/u&quot;, and &quot;/l&quot; modifiers are not likely
to be of much use to you, and so you need not worry about
them very much. They exist for Perl&rsquo;s internal use, so
that complex <br>
regular expression data structures can be automatically
serialized and later exactly reconstituted, including all
their nuances. But, since Perl can&rsquo;t keep a secret,
and there <br>
may be rare instances where they are useful, they are
documented here.</p>

<p style="margin-top: 1em">The &quot;/a&quot; modifier, on
the other hand, may be useful. Its purpose is to allow code
that is to work mostly on ASCII data to not have to concern
itself with Unicode.</p>

<p style="margin-top: 1em">Briefly, &quot;/l&quot; sets the
character set to that of whatever Locale is in effect at the
time of the execution of the pattern match.</p>

<p style="margin-top: 1em">&quot;/u&quot; sets the
character set to Unicode.</p>

<p style="margin-top: 1em">&quot;/a&quot; also sets the
character set to Unicode, BUT adds several restrictions for
ASCII-safe matching.</p>

<p style="margin-top: 1em">&quot;/d&quot; is the old,
problematic, pre-5.14 Default character set behavior. Its
only use is to force that old behavior.</p>

<p style="margin-top: 1em">At any given time, exactly one
of these modifiers is in effect. Their existence allows Perl
to keep the originally compiled behavior of a regular
expression, regardless of what <br>
rules are in effect when it is actually executed. And if it
is interpolated into a larger regex, the original&rsquo;s
rules continue to apply to it, and only it.</p>

<p style="margin-top: 1em">The &quot;/l&quot; and
&quot;/u&quot; modifiers are automatically selected for
regular expressions compiled within the scope of various
pragmas, and we recommend that in general, you use those
<br>
pragmas instead of specifying these modifiers explicitly.
For one thing, the modifiers affect only pattern matching,
and do not extend to even any replacement done, whereas <br>
using the pragmas give consistent results for all
appropriate operations within their scopes. For example,</p>

<p style="margin-top: 1em">s/foo/Ubar/il</p>

<p style="margin-top: 1em">will match &quot;foo&quot; using
the locale&rsquo;s rules for case-insensitive matching, but
the &quot;/l&quot; does not affect how the &quot;U&quot;
operates. Most likely you want both of them to use locale
<br>
rules. To do this, instead compile the regular expression
within the scope of &quot;use locale&quot;. This both
implicitly adds the &quot;/l&quot; and applies locale rules
to the &quot;U&quot;. The <br>
lesson is to &quot;use locale&quot; and not &quot;/l&quot;
explicitly.</p>

<p style="margin-top: 1em">Similarly, it would be better to
use &quot;use feature &rsquo;unicode_strings&rsquo;&quot;
instead of,</p>

<p style="margin-top: 1em">s/foo/r/iu</p>

<p style="margin-top: 1em">to get Unicode rules, as the
&quot;n the former (but not necessarily the latter) would
also use Unicode rules.</p>

<p style="margin-top: 1em">More detail on each of the
modifiers follows. Most likely you don&rsquo;t need to know
this detail for &quot;/l&quot;, &quot;/u&quot;, and
&quot;/d&quot;, and can skip ahead to /a.</p>

<p style="margin-top: 1em">/l</p>

<p style="margin-top: 1em">means to use the current
locale&rsquo;s rules (see perllocale) when pattern matching.
For example, &quot;384word&quot; characters of that locale,
and &quot;/i&quot; case-insensitive <br>
matching will match according to the locale&rsquo;s case
folding rules. The locale used will be the one in effect at
the time of execution of the pattern match. This may not be
the <br>
same as the compilation-time locale, and can differ from one
match to another if there is an intervening call of the
setlocale() function.</p>

<p style="margin-top: 1em">Perl only supports single-byte
locales. This means that code points above 255 are treated
as Unicode no matter what locale is in effect. Under Unicode
rules, there are a few <br>
case-insensitive matches that cross the 255/256 boundary.
These are disallowed under &quot;/l&quot;. For example, 0xFF
(on ASCII platforms) does not caselessly match the character
at <br>
0x178, &quot;LATIN CAPITAL LETTER Y WITH DIAERESIS&quot;,
because 0xFF may not be &quot;LATIN SMALL LETTER Y WITH
DIAERESIS&quot; in the current locale, and Perl has no way
of knowing if that <br>
character even exists in the locale, much less what code
point it is.</p>

<p style="margin-top: 1em">This modifier may be specified
to be the default by &quot;use locale&quot;, but see
&quot;Which character set modifier is in effect?&quot;.</p>

<p style="margin-top: 1em">/u</p>

<p style="margin-top: 1em">means to use Unicode rules when
pattern matching. On ASCII platforms, this means that the
code points between 128 and 255 take on their Latin-1
(ISO-8859-1) meanings (which are <br>
the same as Unicode&rsquo;s). (Otherwise Perl considers
their meanings to be undefined.) Thus, under this modifier,
the ASCII platform effectively becomes a Unicode platform;
and <br>
hence, for example, &quot;1632</p>

<p style="margin-top: 1em">Unlike most locales, which are
specific to a language and country pair, Unicode classifies
all the characters that are letters somewhere in the world
as &quot;480 <br>
locale might not think that &quot;LATIN SMALL LETTER
ETH&quot; is a letter (unless you happen to speak
Icelandic), but Unicode does. Similarly, all the characters
that are decimal digits <br>
somewhere in the world will match &quot;&quot;; this is
hundreds, not 10, possible matches. And some of those digits
look like some of the 10 ASCII digits, but mean a different
number, <br>
so a human could easily think a number is a different
quantity than it really is. For example, &quot;BENGALI DIGIT
FOUR&quot; (U+09EA) looks very much like an &quot;ASCII
DIGIT EIGHT&quot; <br>
(U+0038). And, &quot;+&quot;, may match strings of digits
that are a mixture from different writing systems, creating
a security issue. &quot;num()&quot; in Unicode::UCD can be
used to sort this <br>
out. Or the &quot;/a&quot; modifier can be used to force
&quot;&quot; to match just the ASCII 0 through 9.</p>

<p style="margin-top: 1em">Also, under this modifier,
case-insensitive matching works on the full set of Unicode
characters. The &quot;KELVIN SIGN&quot;, for example matches
the letters &quot;k&quot; and &quot;K&quot;; and &quot;LATIN
<br>
SMALL LIGATURE FF&quot; matches the sequence &quot;ff&quot;,
which, if you&rsquo;re not prepared, might make it look like
a hexadecimal constant, presenting another potential
security issue. See <br>
&lt;http://unicode.org/reports/tr36&gt; for a detailed
discussion of Unicode security issues.</p>

<p style="margin-top: 1em">On the EBCDIC platforms that
Perl handles, the native character set is equivalent to
Latin-1. Thus this modifier changes behavior only when the
&quot;/i&quot; modifier is also specified, <br>
and it turns out it affects only two characters, giving them
full Unicode semantics: the &quot;MICRO SIGN&quot; will
match the Greek capital and small letters &quot;MU&quot;,
otherwise not; and the <br>
&quot;LATIN CAPITAL LETTER SHARP S&quot; will match any of
&quot;SS&quot;, &quot;Ss&quot;, &quot;sS&quot;, and
&quot;ss&quot;, otherwise not.</p>

<p style="margin-top: 1em">This modifier may be specified
to be the default by &quot;use feature
&rsquo;unicode_strings&quot;, &quot;use locale
&rsquo;:not_characters&rsquo;&quot;, or &quot;use
5.012&quot; (or higher), but see &quot;Which character set
<br>
modifier is in effect?&quot;.</p>

<p style="margin-top: 1em">/d</p>

<p style="margin-top: 1em">This modifier means to use the
&quot;Default&quot; native rules of the platform except when
there is cause to use Unicode rules instead, as follows:</p>

<p style="margin-top: 1em">1. the target string is encoded
in UTF-8; or</p>

<p style="margin-top: 1em">2. the pattern is encoded in
UTF-8; or</p>

<p style="margin-top: 1em">3. the pattern explicitly
mentions a code point that is above 255 (say by
&quot;&quot;); or</p>

<p style="margin-top: 1em">4. the pattern uses a Unicode
name (&quot; or</p>

<p style="margin-top: 1em">5. the pattern uses a Unicode
property (&quot;{...}&quot;)</p>

<p style="margin-top: 1em">Another mnemonic for this
modifier is &quot;Depends&quot;, as the rules actually used
depend on various things, and as a result you can get
unexpected results. See &quot;The &quot;Unicode
Bug&quot;&quot; in <br>
perlunicode. The Unicode Bug has become rather infamous,
leading to yet another (printable) name for this modifier,
&quot;Dodgy&quot;.</p>

<p style="margin-top: 1em">On ASCII platforms, the native
rules are ASCII, and on EBCDIC platforms (at least the ones
that Perl handles), they are Latin-1.</p>

<p style="margin-top: 1em">Here are some examples of how
that works on an ASCII platform:</p>

<p style="margin-top: 1em">$str = &quot;&quot;; # $str is
not in UTF-8 format. <br>
$str =~ /^1200 <br>
$str .= &quot;0b}&quot;; # Now $str is in UTF-8 format. <br>
$str =~ /^1080 <br>
chop $str; <br>
$str =~ /^1296</p>

<p style="margin-top: 1em">This modifier is automatically
selected by default when none of the others are, so yet
another name for it is &quot;Default&quot;.</p>

<p style="margin-top: 1em">Because of the unexpected
behaviors associated with this modifier, you probably should
only use it to maintain weird backward compatibilities.</p>

<p style="margin-top: 1em">/a (and /aa)</p>

<p style="margin-top: 1em">This modifier stands for
ASCII-restrict (or ASCII-safe). This modifier, unlike the
others, may be doubled-up to increase its effect.</p>

<p style="margin-top: 1em">When it appears singly, it
causes the sequences &quot;&quot;, &quot; &quot;2592 <br>
Unicode meanings. Under &quot;/a&quot;, &quot;&quot; always
means precisely the digits &quot;0&quot; to &quot;9&quot;;
&quot;eans the five characters &quot;[ r]&quot;;
&quot;600[A-Za-z0-9_]&quot;; and <br>
likewise, all the Posix classes such as
&quot;[[:print:]]&quot; match only the appropriate
ASCII-range characters.</p>

<p style="margin-top: 1em">This modifier is useful for
people who only incidentally use Unicode, and who do not
wish to be burdened with its complexities and security
concerns.</p>

<p style="margin-top: 1em">With &quot;/a&quot;, one can
write &quot;&quot; with confidence that it will only match
ASCII characters, and should the need arise to match beyond
ASCII, you can instead use &quot;{Digit}&quot; (or <br>
&quot;{Word}&quot; for &quot;528{...}&quot; constructs that
can match beyond ASCII both white space (see
&quot;Whitespace&quot; in perlrecharclass), and Posix
classes (see &quot;POSIX <br>
Character Classes&quot; in perlrecharclass). Thus, this
modifier doesn&rsquo;t mean you can&rsquo;t use Unicode, it
means that to get Unicode matching you must explicitly use a
construct <br>
(&quot;{}&quot;, &quot;P{}&quot;) that signals Unicode.</p>

<p style="margin-top: 1em">As you would expect, this
modifier causes, for example, s t i l l &quot;[^0-9]&quot;;
in fact, all non-ASCII characters match &quot; and
&quot;W&quot;. &quot;m e a n s <br>
to match at the boundary between &quot;120W&quot;, using the
&quot;/a&quot; definitions of them (similarly for
&quot;0</p>

<p style="margin-top: 1em">Otherwise, &quot;/a&quot;
behaves like the &quot;/u&quot; modifier, in that
case-insensitive matching uses Unicode semantics; for
example, &quot;k&quot; will match the Unicode &quot;ELVIN
SIGN}&quot; under &quot;/i&quot; <br>
matching, and code points in the Latin1 range, above ASCII
will have Unicode rules when it comes to case-insensitive
matching.</p>

<p style="margin-top: 1em">To forbid ASCII/non-ASCII
matches (like &quot;k&quot; with &quot;ELVIN SIGN}&quot;),
specify the &quot;a&quot; twice, for example
&quot;/aai&quot; or &quot;/aia&quot;. (The first occurrence
of &quot;a&quot; restricts the &quot;&quot;, etc., <br>
and the second occurrence adds the &quot;/i&quot;
restrictions.) But, note that code points outside the ASCII
range will use Unicode rules for &quot;/i&quot; matching, so
the modifier doesn&rsquo;t <br>
really restrict things to just ASCII; it just forbids the
intermixing of ASCII and non-ASCII.</p>

<p style="margin-top: 1em">To summarize, this modifier
provides protection for applications that don&rsquo;t wish
to be exposed to all of Unicode. Specifying it twice gives
added protection.</p>

<p style="margin-top: 1em">This modifier may be specified
to be the default by &quot;use re &rsquo;/a&rsquo;&quot; or
&quot;use re &rsquo;/aa&rsquo;&quot;. If you do so, you may
actually have occasion to use the &quot;/u&quot; modifier
explictly if there are <br>
a few regular expressions where you do want full Unicode
rules (but even here, it&rsquo;s best if everything were
under feature &quot;unicode_strings&quot;, along with the
&quot;use re &rsquo;/aa&rsquo;&quot;). Also <br>
see &quot;Which character set modifier is in
effect?&quot;.</p>

<p style="margin-top: 1em">Which character set modifier is
in effect?</p>

<p style="margin-top: 1em">Which of these modifiers is in
effect at any given point in a regular expression depends on
a fairly complex set of interactions. These have been
designed so that in general you <br>
don&rsquo;t have to worry about it, but this section gives
the gory details. As explained below in &quot;Extended
Patterns&quot; it is possible to explicitly specify
modifiers that apply only <br>
to portions of a regular expression. The innermost always
has priority over any outer ones, and one applying to the
whole expression has priority over any of the default <br>
settings that are described in the remainder of this
section.</p>

<p style="margin-top: 1em">The &quot;use re
&rsquo;/foo&rsquo;&quot; pragma can be used to set default
modifiers (including these) for regular expressions compiled
within its scope. This pragma has precedence over the other
<br>
pragmas listed below that also change the defaults.</p>

<p style="margin-top: 1em">Otherwise, &quot;use
locale&quot; sets the default modifier to &quot;/l&quot;;
and &quot;use feature &rsquo;unicode_strings&quot;, or
&quot;use 5.012&quot; (or higher) set the default to
&quot;/u&quot; when not in the same scope as <br>
either &quot;use locale&quot; or &quot;use bytes&quot;.
(&quot;use locale &rsquo;:not_characters&rsquo;&quot; also
sets the default to &quot;/u&quot;, overriding any plain
&quot;use locale&quot;.) Unlike the mechanisms mentioned
above, <br>
these affect operations besides regular expressions pattern
matching, and so give more consistent results with other
operators, including using &quot;U&quot;, &quot; etc. in
substitution <br>
replacements.</p>

<p style="margin-top: 1em">If none of the above apply, for
backwards compatibility reasons, the &quot;/d&quot; modifier
is the one in effect by default. As this can lead to
unexpected results, it is best to specify <br>
which other rule set should be used.</p>

<p style="margin-top: 1em">Character set modifier behavior
prior to Perl 5.14</p>

<p style="margin-top: 1em">Prior to 5.14, there were no
explicit modifiers, but &quot;/l&quot; was implied for
regexes compiled within the scope of &quot;use locale&quot;,
and &quot;/d&quot; was implied otherwise. However, <br>
interpolating a regex into a larger regex would ignore the
original compilation in favor of whatever was in effect at
the time of the second compilation. There were a number of
<br>
inconsistencies (bugs) with the &quot;/d&quot; modifier,
where Unicode rules would be used when inappropriate, and
vice versa. &quot;{}&quot; did not imply Unicode rules, and
neither did all <br>
occurrences of &quot;&quot;, until 5.12.</p>

<p style="margin-top: 1em">Regular Expressions <br>
Metacharacters</p>

<p style="margin-top: 1em">The patterns used in Perl
pattern matching evolved from those supplied in the Version
8 regex routines. (The routines are derived (distantly) from
Henry Spencer&rsquo;s freely <br>
redistributable reimplementation of the V8 routines.) See
&quot;Version 8 Regular Expressions&quot; for details.</p>

<p style="margin-top: 1em">In particular the following
metacharacters have their standard egrep-ish meanings:
&nbsp;</p>

<p style="margin-top: 1em">Quote the next metacharacter
<br>
^ Match the beginning of the line <br>
. Match any character (except newline) <br>
$ Match the end of the line (or before newline at the end)
<br>
| Alternation <br>
() Grouping <br>
[] Bracketed Character class</p>

<p style="margin-top: 1em">By default, the &quot;^&quot;
character is guaranteed to match only the beginning of the
string, the &quot;$&quot; character only the end (or before
the newline at the end), and Perl does certain <br>
optimizations with the assumption that the string contains
only one line. Embedded newlines will not be matched by
&quot;^&quot; or &quot;$&quot;. You may, however, wish to
treat a string as a <br>
multi-line buffer, such that the &quot;^&quot; will match
after any newline within the string (except if the newline
is the last character in the string), and &quot;$&quot; will
match before any <br>
newline. At the cost of a little more overhead, you can do
this by using the /m modifier on the pattern match operator.
(Older programs did this by setting $*, but this option <br>
was removed in perl 5.9.)</p>

<p style="margin-top: 1em">To simplify multi-line
substitutions, the &quot;.&quot; character never matches a
newline unless you use the &quot;/s&quot; modifier, which in
effect tells Perl to pretend the string is a single <br>
line--even if it isn&rsquo;t.</p>

<p style="margin-top: 1em">Quantifiers</p>

<p style="margin-top: 1em">The following standard
quantifiers are recognized:</p>

<p style="margin-top: 1em">* Match 0 or more times <br>
+ Match 1 or more times <br>
? Match 1 or 0 times <br>
{n} Match exactly n times <br>
{n,} Match at least n times <br>
{n,m} Match at least n but not more than m times</p>

<p style="margin-top: 1em">(If a curly bracket occurs in
any other context and does not form part of a backslashed
sequence like &quot;.}&quot;, it is treated as a regular
character. In particular, the lower <br>
quantifier bound is not optional. However, in Perl v5.18, it
is planned to issue a deprecation warning for all such
occurrences, and in Perl v5.20 to require literal uses of a
<br>
curly bracket to be escaped, say by preceding them with a
backslash or enclosing them within square brackets,
(&quot;&quot; or &quot;[{]&quot;). This change will allow
for future syntax <br>
extensions (like making the lower bound of a quantifier
optional), and better error checking of quantifiers. Now, a
typo in a quantifier silently causes it to be treated as the
<br>
literal characters. For example,</p>

<p style="margin-top: 1em">/o{4,3}/</p>

<p style="margin-top: 1em">looks like a quantifier that
matches 0 times, since 4 is greater than 3, but it really
means to match the sequence of six characters &quot;o { 4 ,
3 }&quot;.)</p>

<p style="margin-top: 1em">The &quot;*&quot; quantifier is
equivalent to &quot;{0,}&quot;, the &quot;+&quot; quantifier
to &quot;{1,}&quot;, and the &quot;?&quot; quantifier to
&quot;{0,1}&quot;. n and m are limited to non-negative
integral values less than a <br>
preset limit defined when perl is built. This is usually
32766 on the most common platforms. The actual limit can be
seen in the error message generated by code such as
this:</p>

<p style="margin-top: 1em">$_ **= $_ , / {$_} / for 2 ..
42;</p>

<p style="margin-top: 1em">By default, a quantified
subpattern is &quot;greedy&quot;, that is, it will match as
many times as possible (given a particular starting
location) while still allowing the rest of the <br>
pattern to match. If you want it to match the minimum number
of times possible, follow the quantifier with a
&quot;?&quot;. Note that the meanings don&rsquo;t change,
just the &quot;greediness&quot;:</p>

<p style="margin-top: 1em">*? Match 0 or more times, not
greedily <br>
+? Match 1 or more times, not greedily <br>
?? Match 0 or 1 time, not greedily <br>
{n}? Match exactly n times, not greedily (redundant) <br>
{n,}? Match at least n times, not greedily <br>
{n,m}? Match at least n but not more than m times, not
greedily</p>

<p style="margin-top: 1em">By default, when a quantified
subpattern does not allow the rest of the overall pattern to
match, Perl will backtrack. However, this behaviour is
sometimes undesirable. Thus Perl <br>
provides the &quot;possessive&quot; quantifier form as
well.</p>

<p style="margin-top: 1em">*+ Match 0 or more times and
give nothing back <br>
++ Match 1 or more times and give nothing back <br>
?+ Match 0 or 1 time and give nothing back <br>
{n}+ Match exactly n times and give nothing back (redundant)
<br>
{n,}+ Match at least n times and give nothing back <br>
{n,m}+ Match at least n but not more than m times and give
nothing back</p>

<p style="margin-top: 1em">For instance,</p>

<p style="margin-top: 1em">&rsquo;aaaa&rsquo; =~ /a++a/</p>

<p style="margin-top: 1em">will never match, as the
&quot;a++&quot; will gobble up all the &quot;a&quot;&rsquo;s
in the string and won&rsquo;t leave any for the remaining
part of the pattern. This feature can be extremely useful to
give <br>
perl hints about where it shouldn&rsquo;t backtrack. For
instance, the typical &quot;match a double-quoted
string&quot; problem can be most efficiently performed when
written as:</p>


<p style="margin-top: 1em">/&quot;(?:[^&quot;\]++|\.)*+&quot;/</p>

<p style="margin-top: 1em">as we know that if the final
quote does not match, backtracking will not help. See the
independent subexpression
&quot;&quot;(?&gt;pattern)&quot;&quot; for more details;
possessive quantifiers are just <br>
syntactic sugar for that construct. For instance the above
example could also be written as follows:</p>


<p style="margin-top: 1em">/&quot;(?&gt;(?:(?&gt;[^&quot;\]+)|\.)*)&quot;/</p>

<p style="margin-top: 1em">Escape sequences</p>

<p style="margin-top: 1em">Because patterns are processed
as double-quoted strings, the following also work:</p>

<p style="margin-top: 1em">tab (HT, TAB) <br>
newline (LF, NL) <br>
return (CR) <br>
form feed (FF) <br>
alarm (bell) (BEL) <br>
\ escape (think troff) (ESC) <br>
, 0 character whose ordinal is the given hexadecimal number
<br>
ame} named Unicode character or character sequence <br>
+263D} Unicode character (example: FIRST QUARTER MOON) r
<br>
lowercase next char (think vi) <br>
uppercase next char (think vi) <br>
lowercase till &nbsp;(think vi) <br>
U uppercase till &nbsp;(think vi) <br>
Q quote (disable) pattern metacharacters till &nbsp; end
either case modification or quoted section, think vi</p>

<p style="margin-top: 1em">Details are in &quot;Quote and
Quote-like Operators&quot; in perlop.</p>

<p style="margin-top: 1em">Character Classes and other
Special Escapes</p>

<p style="margin-top: 1em">In addition, Perl defines the
following:</p>

<p style="margin-top: 1em">Sequence Note Description <br>
[...] [1] Match a character according to the rules of the
<br>
bracketed character class defined by the &quot;...&quot;.
<br>
Example: [a-z] matches &quot;a&quot; or &quot;b&quot; or
&quot;c&quot; ... or &quot;z&quot; <br>
[[:...:]] [2] Match a character according to the rules of
the POSIX <br>
character class &quot;...&quot; within the outer bracketed
<br>
character class. Example: [[:upper:]] matches any <br>
uppercase character. <br>
0 [3] Match a &quot;word&quot; character (alphanumeric plus
&quot;_&quot;, plus <br>
other connector punctuation chars plus Unicode <br>
marks) <br>
W [3] Match a non-&quot;word&quot; character <br>
[3] Match a whitespace character <br>
[3] Match a non-whitespace character <br>
[3] Match a decimal digit character <br>
[3] Match a non-digit character <br>
P [3] Match P, named property. Use {Prop} for longer names
<br>
PP [3] Match non-P <br>
[4] Match Unicode &quot;eXtended grapheme cluster&quot; <br>
Match a single C-language char (octet) even if that is <br>
part of a larger UTF-8 character. Thus it breaks up <br>
characters into their UTF-8 bytes, so you may end up <br>
with malformed pieces of UTF-8. Unsupported in <br>
lookbehind. <br>
1 [5] Backreference to a specific capture group or buffer.
<br>
&rsquo;1&rsquo; may actually be any positive integer. <br>
[5] Backreference to a specific or previous group, <br>
-1} [5] The number may be negative indicating a relative
<br>
previous group and may optionally be wrapped in <br>
curly brackets for safer parsing. <br>
name} [5] Named backreference <br>
name&gt; [5] Named backreference <br>
K [6] Keep the stuff left of the K, don&rsquo;t include it
in $&amp; <br>
[7] Any character but (experimental). Not affected by <br>
/s modifier <br>
[3] Vertical whitespace <br>
[3] Not vertical whitespace <br>
[3] Horizontal whitespace <br>
[3] Not horizontal whitespace <br>
[4] Linebreak</p>

<p style="margin-top: 1em">[1] See &quot;Bracketed
Character Classes&quot; in perlrecharclass for details.</p>

<p style="margin-top: 1em">[2] See &quot;POSIX Character
Classes&quot; in perlrecharclass for details.</p>

<p style="margin-top: 1em">[3] See &quot;Backslash
sequences&quot; in perlrecharclass for details.</p>

<p style="margin-top: 1em">[4] See &quot;Misc&quot; in
perlrebackslash for details.</p>

<p style="margin-top: 1em">[5] See &quot;Capture
groups&quot; below for details.</p>

<p style="margin-top: 1em">[6] See &quot;Extended
Patterns&quot; below for details.</p>

<p style="margin-top: 1em">[7] Note that &quot;as two
meanings. When of the form &quot;AME}&quot;, it matches the
character or character sequence whose name is
&quot;NAME&quot;; and similarly when of the form <br>
&quot;+hex}&quot;, it matches the character whose Unicode
code point is hex. Otherwise it matches any character but
&quot;0.</p>

<p style="margin-top: 1em">Assertions</p>

<p style="margin-top: 1em">Perl defines the following
zero-width assertions:</p>

<p style="margin-top: 1em">Match a word boundary <br>
0 Match except at a word boundary <br>
0Match only at beginning of string <br>
Match only at end of string, or before newline at the end
<br>
Match only at end of string <br>
G Match only at pos() (e.g. at the end-of-match position
<br>
of prior m//g) ) i s a s p o t b e t w e e n t w o</p>

<p style="margin-top: 1em">A word boundary
(&quot;c600W&quot; on the other side of it (in h a r a c t e
r s t h a t h a s a either order), counting the imaginary
characters <br>
off the beginning and end of the string as matching a
&quot;W&quot;. r e p r e s e n t s b a c k s p a c e r a t h
e r t h a n a w o r d (Within character classes &quot;b o u
n d a r y , j u s t a s i t n o r m a l l y d o e s i n a n
y <br>
double-quoted string.) The &quot;0
areandjust&quot;$&quot;,lik^&quot; except that they
won&rsquo;t match multiple times when the &quot;/m&quot;
modifier is used, while &quot;^&quot; and &quot;$&quot; will
match at <br>
every internal line boundary. To match the actual end of the
string and not ignore an optional trailing newline, use
&quot;.</p>

<p style="margin-top: 1em">The &quot;G&quot; assertion can
be used to chain global matches (using &quot;m//g&quot;), as
described in &quot;Regexp Quote-Like Operators&quot; in
perlop. It is also useful when writing &quot;lex&quot;-like
<br>
scanners, when you have several patterns that you want to
match against consequent substrings of your string; see the
previous reference. The actual location where &quot;G&quot;
will <br>
match can also be influenced by using &quot;pos()&quot; as
an lvalue: see &quot;pos&quot; in perlfunc. Note that the
rule for zero-length matches (see &quot;Repeated Patterns
Matching a Zero-length <br>
Substring&quot;) is modified somewhat, in that contents to
the left of &quot;G&quot; are not counted when determining
the length of the match. Thus the following will not match
forever:</p>

<p style="margin-top: 1em">my $string = &rsquo;ABC&rsquo;;
<br>
pos($string) = 1; <br>
while ($string =~ /(.G)/g) { <br>
print $1; <br>
}</p>

<p style="margin-top: 1em">It will print &rsquo;A&rsquo;
and then terminate, as it considers the match to be
zero-width, and thus will not match at the same position
twice in a row.</p>

<p style="margin-top: 1em">It is worth noting that
&quot;G&quot; improperly used can result in an infinite
loop. Take care when using patterns that include
&quot;G&quot; in an alternation.</p>

<p style="margin-top: 1em">Capture groups</p>

<p style="margin-top: 1em">The bracketing construct &quot;(
... )&quot; creates capture groups (also referred to as
capture buffers). To refer to the current contents of a
group later on, within the same pattern, <br>
use &quot;&quot; (or &quot;1}&quot;) for the first,
&quot;&quot; (or &quot;2}&quot;) for the second, and so on.
This is called a backreference.</p>

<p style="margin-top: 1em">There is no limit to the number
of captured substrings that you may use. Groups are numbered
with the leftmost open parenthesis being number 1, etc. If a
group did not match, <br>
the associated backreference won&rsquo;t match either. (This
can happen if the group is optional, or in a different
branch of an alternation.) You can omit the &quot;g&quot;,
and write &quot;1&quot;, <br>
etc, but there are some issues with this form, described
below.</p>

<p style="margin-top: 1em">You can also refer to capture
groups relatively, by using a negative number, so that
&quot;1&quot; and &quot;-1}&quot; both refer to the
immediately preceding capture group, and &quot;2&quot; and
<br>
&quot;-2}&quot; both refer to the group before it. For
example:</p>

<p style="margin-top: 1em">/ <br>
(Y) # group 1 <br>
( # group 2 <br>
(X) # group 3 <br>
-1} # backref to group 3 <br>
-3} # backref to group 1 <br>
) <br>
/x</p>

<p style="margin-top: 1em">would match the same as
&quot;/(Y) ( (X) )/x&quot;. This allows you to interpolate
regexes into larger regexes and not have to worry about the
capture groups being renumbered.</p>

<p style="margin-top: 1em">You can dispense with numbers
altogether and create named capture groups. The notation is
&quot;(?&lt;name&gt;...)&quot; to declare and
&quot;name}&quot; to reference. (To be compatible with .Net
<br>
regular expressions, &quot;name}&quot; may also be written
as &quot;name}&quot;, &quot;name&gt;&quot; or
&quot;name&rsquo;&quot;.) name must not begin with a number,
nor contain hyphens. When different groups <br>
within the same pattern have the same name, any reference to
that name assumes the leftmost defined group. Named groups
count in absolute and relative numbering, and so can also
<br>
be referred to by those numbers. (It&rsquo;s possible to do
things with named capture groups that would otherwise
require &quot;(??{})&quot;.)</p>

<p style="margin-top: 1em">Capture group contents are
dynamically scoped and available to you outside the pattern
until the end of the enclosing block or until the next
successful match, whichever comes <br>
first. (See &quot;Compound Statements&quot; in perlsyn.) You
can refer to them by absolute number (using &quot;$1&quot;
instead of &quot;&quot;, etc); or by name via the
&quot;%+&quot; hash, using &quot;$+{name}&quot;.</p>

<p style="margin-top: 1em">Braces are required in referring
to named capture groups, but are optional for absolute or
relative numbered ones. Braces are safer when creating a
regex by concatenating <br>
smaller strings. For example if you have
&quot;qr/$a$b/&quot;, and $a contained &quot;&quot;, and $b
contained &quot;37&quot;, you would get &quot;/37/&quot;
which is probably not what you intended.</p>

<p style="margin-top: 1em">The &quot;0 and &quot; notations
were introduced in Perl 5.10.0. Prior to that there were no
named nor relative numbered capture groups. Absolute
numbered groups were referred to <br>
using &quot;1&quot;, &quot;2&quot;, etc., and this notation
is still accepted (and likely always will be). But it leads
to some ambiguities if there are more than 9 capture groups,
as &quot;10&quot; could <br>
mean either the tenth capture group, or the character whose
ordinal in octal is 010 (a backspace in ASCII). Perl
resolves this ambiguity by interpreting &quot;10&quot; as a
backreference <br>
only if at least 10 left parentheses have opened before it.
Likewise &quot;11&quot; is a backreference only if at least
11 left parentheses have opened before it. And so on.
&quot;1&quot; <br>
through &quot;9&quot; are always interpreted as
backreferences. There are several examples below that
illustrate these perils. You can avoid the ambiguity by
always using &quot;0}&quot; or &quot;0 <br>
if you mean capturing groups; and for octal constants always
using &quot;n <br>
octal constant.</p>

<p style="margin-top: 1em">The &quot;igit&quot; notation
also works in certain circumstances outside the pattern. See
&quot;Warning on 1 Instead of $1&quot; below for
details.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">s/^([^ ]*) *([^ ]*)/$2 $1/; #
swap first two words</p>

<p style="margin-top: 1em">/(.)/ # find first doubled char
<br>
and print &quot;&rsquo;$1&rsquo; is the first doubled
character456;</p>

<p style="margin-top: 1em">/(?&lt;char&gt;.)char&gt;/ # ...
a different way <br>
and print &quot;&rsquo;$+{char}&rsquo; is the first doubled
character456;</p>

<p style="margin-top: 1em">/(?&rsquo;char&rsquo;.)/ # ...
mix and match <br>
and print &quot;&rsquo;$1&rsquo; is the first doubled
character456;</p>

<p style="margin-top: 1em">if (/Time: (..):(..):(..)/) { #
parse out values <br>
$hours = $1; <br>
$minutes = $2; <br>
$seconds = $3; <br>
}</p>

<p style="margin-top: 1em">/(.)(.)(.)(.)(.)(.)(.)(.)(.)0/ #
0 is a backreference <br>
/(.)(.)(.)(.)(.)(.)(.)(.)(.)10/ # 10 is octal <br>
/((.)(.)(.)(.)(.)(.)(.)(.)(.))10/ # 10 is a backreference
<br>
/((.)(.)(.)(.)(.)(.)(.)(.)(.)) 10/ # 10 is octal</p>

<p style="margin-top: 1em">$a = &rsquo;(.)1&rsquo;; #
Creates problems when concatenated. <br>
$b = &rsquo;(.)01}&rsquo;; # Avoids the problems. <br>
&quot;aa&quot; =~ /${a}/; # True <br>
&quot;aa&quot; =~ /${b}/; # True <br>
&quot;aa0&quot; =~ /${a}0/; # False! <br>
&quot;aa0&quot; =~ /${b}0/; # True <br>
&quot;aa8&quot; =~ /${a}0/; # True! <br>
&quot;aa8&quot; =~ /${b}0/; # False</p>

<p style="margin-top: 1em">Several special variables also
refer back to portions of the previous match. $+ returns
whatever the last bracket match matched. $&amp; returns the
entire matched string. (At one <br>
point $0 did also, but now it returns the name of the
program.) &quot;$&lsquo;&quot; returns everything before the
matched string. &quot;$&rsquo;&quot; returns everything
after the matched string. And $^N <br>
contains whatever was matched by the most-recently closed
group (submatch). $^N can be used in extended patterns (see
below), for example to assign a submatch to a variable.</p>

<p style="margin-top: 1em">These special variables, like
the &quot;%+&quot; hash and the numbered match variables
($1, $2, $3, etc.) are dynamically scoped until the end of
the enclosing block or until the next <br>
successful match, whichever comes first. (See &quot;Compound
Statements&quot; in perlsyn.)</p>

<p style="margin-top: 1em">NOTE: Failed matches in Perl do
not reset the match variables, which makes it easier to
write code that tests for a series of more specific cases
and remembers the best match.</p>

<p style="margin-top: 1em">WARNING: Once Perl sees that you
need one of $&amp;, &quot;$&lsquo;&quot;, or
&quot;$&rsquo;&quot; anywhere in the program, it has to
provide them for every pattern match. This may substantially
slow your program. <br>
Perl uses the same mechanism to produce $1, $2, etc, so you
also pay a price for each pattern that contains capturing
parentheses. (To avoid this cost while retaining the <br>
grouping behaviour, use the extended regular expression
&quot;(?: ... )&quot; instead.) But if you never use $&amp;,
&quot;$&lsquo;&quot; or &quot;$&rsquo;&quot;, then patterns
without capturing parentheses will not be <br>
penalized. So avoid $&amp;, &quot;$&rsquo;&quot;, and
&quot;$&lsquo;&quot; if you can, but if you can&rsquo;t (and
some algorithms really appreciate them), once you&rsquo;ve
used them once, use them at will, because you&rsquo;ve <br>
already paid the price. As of 5.005, $&amp; is not so costly
as the other two.</p>

<p style="margin-top: 1em">As a workaround for this
problem, Perl 5.10.0 introduces &quot;${^PREMATCH}&quot;,
&quot;${^MATCH}&quot; and &quot;${^POSTMATCH}&quot;, which
are equivalent to &quot;$&lsquo;&quot;, $&amp; and
&quot;$&rsquo;&quot;, except that they are only <br>
guaranteed to be defined after a successful match that was
executed with the &quot;/p&quot; (preserve) modifier. The
use of these variables incurs no global performance penalty,
unlike <br>
their punctuation char equivalents, however at the trade-off
that you have to tell perl when you want to use them.</p>

<p style="margin-top: 1em">Quoting metacharacters <br>
Backslashed metacharacters in Perl are alphanumeric, such as
&quot;,48456. Unlike some other regular expression
languages, there are no backslashed symbols that
aren&rsquo;t <br>
alphanumeric. So anything that looks like \, , &lt;, &gt;, ,
or is always interpreted as a literal character, not a
metacharacter. This was once used in a common idiom <br>
to disable or quote the special meanings of regular
expression metacharacters in a string that you want to use
for a pattern. Simply quote all non-&quot;word&quot;
characters:</p>

<p style="margin-top: 1em">$pattern =~ s/(W)/\$1/g;</p>

<p style="margin-top: 1em">(If &quot;use locale&quot; is
set, then this depends on the current locale.) Today it is
more common to use the quotemeta() function or the
&quot;Q&quot; metaquoting escape sequence to disable all
<br>
metacharacters&rsquo; special meanings like this:</p>

<p style="margin-top: 1em">/$unquotedQ$quotednquoted/</p>

<p style="margin-top: 1em">Beware that if you put literal
backslashes (those not inside interpolated variables)
between &quot;Q&quot; and &quot; <br>
If you need to use literal backslashes within &quot;Q...</p>

<p style="margin-top: 1em">&quot;quotemeta()&quot; and
&quot;Q&quot; are fully described in &quot;quotemeta&quot;
in perlfunc.</p>

<p style="margin-top: 1em">Extended Patterns <br>
Perl also defines a consistent extension syntax for features
not found in standard tools like awk and lex. The syntax for
most of these is a pair of parentheses with a question <br>
mark as the first thing within the parentheses. The
character after the question mark indicates the
extension.</p>

<p style="margin-top: 1em">The stability of these
extensions varies widely. Some have been part of the core
language for many years. Others are experimental and may
change without warning or be <br>
completely removed. Check the documentation on an individual
feature to verify its current status.</p>

<p style="margin-top: 1em">A question mark was chosen for
this and for the minimal-matching construct because 1)
question marks are rare in older regular expressions, and 2)
whenever you see one, you <br>
should stop and &quot;question&quot; exactly what is going
on. That&rsquo;s psychology....</p>

<p style="margin-top: 1em">&quot;(?#text)&quot; <br>
A comment. The text is ignored. If the &quot;/x&quot;
modifier enables whitespace formatting, a simple
&quot;#&quot; will suffice. Note that Perl closes the
comment as soon as it sees a &quot;)&quot;, <br>
so there is no way to put a literal &quot;)&quot; in the
comment.</p>

<p style="margin-top: 1em">&quot;(?adlupimsx-imsx)&quot;
<br>
&quot;(?^alupimsx)&quot; <br>
One or more embedded pattern-match modifiers, to be turned
on (or turned off, if preceded by &quot;-&quot;) for the
remainder of the pattern or the remainder of the enclosing
pattern <br>
group (if any).</p>

<p style="margin-top: 1em">This is particularly useful for
dynamic patterns, such as those read in from a configuration
file, taken from an argument, or specified in a table
somewhere. Consider the <br>
case where some patterns want to be case-sensitive and some
do not: The case-insensitive ones merely need to include
&quot;(?i)&quot; at the front of the pattern. For
example:</p>

<p style="margin-top: 1em">$pattern = &quot;foobar&quot;;
<br>
if ( /$pattern/i ) { }</p>

<p style="margin-top: 1em"># more flexible:</p>

<p style="margin-top: 1em">$pattern =
&quot;(?i)foobar&quot;; <br>
if ( /$pattern/ ) { }</p>

<p style="margin-top: 1em">These modifiers are restored at
the end of the enclosing group. For example,</p>

<p style="margin-top: 1em">( (?i) blah )</p>

<p style="margin-top: 1em">will match &quot;blah&quot; in
any case, some spaces, and an exact (including the case!)
repetition of the previous word, assuming the &quot;/x&quot;
modifier, and no &quot;/i&quot; modifier outside this <br>
group.</p>

<p style="margin-top: 1em">These modifiers do not carry
over into named subpatterns called in the enclosing group.
In other words, a pattern such as
&quot;((?i)(?&amp;NAME))&quot; does not change the case-
<br>
sensitivity of the &quot;NAME&quot; pattern.</p>

<p style="margin-top: 1em">Any of these modifiers can be
set to apply globally to all regular expressions compiled
within the scope of a &quot;use re&quot;. See
&quot;&rsquo;/flags&rsquo; mode&quot; in re.</p>

<p style="margin-top: 1em">Starting in Perl 5.14, a
&quot;^&quot; (caret or circumflex accent) immediately after
the &quot;?&quot; is a shorthand equivalent to
&quot;d-imsx&quot;. Flags (except &quot;d&quot;) may follow
the caret to <br>
override it. But a minus sign is not legal with it.</p>

<p style="margin-top: 1em">Note that the &quot;a&quot;,
&quot;d&quot;, &quot;l&quot;, &quot;p&quot;, and
&quot;u&quot; modifiers are special in that they can only be
enabled, not disabled, and the &quot;a&quot;, &quot;d&quot;,
&quot;l&quot;, and &quot;u&quot; modifiers are mutually <br>
exclusive: specifying one de-specifies the others, and a
maximum of one (or two &quot;a&quot;&rsquo;s) may appear in
the construct. Thus, for example, &quot;(?-p)&quot; will
warn when compiled under <br>
&quot;use warnings&quot;; &quot;(?-d:...)&quot; and
&quot;(?dl:...)&quot; are fatal errors.</p>

<p style="margin-top: 1em">Note also that the &quot;p&quot;
modifier is special in that its presence anywhere in a
pattern has a global effect.</p>

<p style="margin-top: 1em">&quot;(?:pattern)&quot; <br>
&quot;(?adluimsx-imsx:pattern)&quot; <br>
&quot;(?^aluimsx:pattern)&quot; <br>
This is for clustering, not capturing; it groups
subexpressions like &quot;()&quot;, but doesn&rsquo;t make
backreferences as &quot;()&quot; does. So ? : a |</p>

<p style="margin-top: 1em">@fields = split(/b | c )</p>

<p style="margin-top: 1em">is like a | b</p>

<p style="margin-top: 1em">@fields = split(/| c )</p>

<p style="margin-top: 1em">but doesn&rsquo;t spit out extra
fields. It&rsquo;s also cheaper not to capture characters if
you don&rsquo;t need to.</p>

<p style="margin-top: 1em">Any letters between
&quot;?&quot; and &quot;:&quot; act as flags modifiers as
with &quot;(?adluimsx-imsx)&quot;. For example,</p>


<p style="margin-top: 1em">/(?s-i:more.*than).*million/i</p>

<p style="margin-top: 1em">is equivalent to the more
verbose</p>


<p style="margin-top: 1em">/(?:(?s-i)more.*than).*million/i</p>

<p style="margin-top: 1em">Starting in Perl 5.14, a
&quot;^&quot; (caret or circumflex accent) immediately after
the &quot;?&quot; is a shorthand equivalent to
&quot;d-imsx&quot;. Any positive flags (except
&quot;d&quot;) may follow the <br>
caret, so</p>

<p style="margin-top: 1em">(?^x:foo)</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">(?x-ims:foo)</p>

<p style="margin-top: 1em">The caret tells Perl that this
cluster doesn&rsquo;t inherit the flags of any surrounding
pattern, but uses the system defaults (&quot;d-imsx&quot;),
modified by any flags specified.</p>

<p style="margin-top: 1em">The caret allows for simpler
stringification of compiled regular expressions. These look
like</p>

<p style="margin-top: 1em">(?^:pattern)</p>

<p style="margin-top: 1em">with any non-default flags
appearing between the caret and the colon. A test that looks
at such stringification thus doesn&rsquo;t need to have the
system default flags hard-coded <br>
in it, just the caret. If new flags are added to Perl, the
meaning of the caret&rsquo;s expansion will change to
include the default for those flags, so the test will still
work, <br>
unchanged.</p>

<p style="margin-top: 1em">Specifying a negative flag after
the caret is an error, as the flag is redundant.</p>

<p style="margin-top: 1em">Mnemonic for
&quot;(?^...)&quot;: A fresh beginning since the usual use
of a caret is to match at the beginning.</p>

<p style="margin-top: 1em">&quot;(?|pattern)&quot; <br>
This is the &quot;branch reset&quot; pattern, which has the
special property that the capture groups are numbered from
the same starting point in each alternation branch. It is
<br>
available starting from perl 5.10.0.</p>

<p style="margin-top: 1em">Capture groups are numbered from
left to right, but inside this construct the numbering is
restarted for each branch.</p>

<p style="margin-top: 1em">The numbering within each branch
will be as normal, and any groups following this construct
will be numbered as though the construct contained only one
branch, that being the <br>
one with the most capture groups in it.</p>

<p style="margin-top: 1em">This construct is useful when
you want to capture one of a number of alternative
matches.</p>

<p style="margin-top: 1em">Consider the following pattern.
The numbers underneath show in which group the captured
content will be stored.</p>

<p style="margin-top: 1em"># before
---------------branch-reset----------- after <br>
/ ( a ) (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
<br>
# 1 2 2 3 2 3 4</p>

<p style="margin-top: 1em">Be careful when using the branch
reset pattern in combination with named captures. Named
captures are implemented as being aliases to numbered groups
holding the captures, <br>
and that interferes with the implementation of the branch
reset pattern. If you are using named captures in a branch
reset pattern, it&rsquo;s best to use the same names, in the
<br>
same order, in each of the alternations:</p>

<p style="margin-top: 1em">/(?| (?&lt;a&gt; x ) (?&lt;b&gt;
y ) <br>
| (?&lt;a&gt; z ) (?&lt;b&gt; w )) /x</p>

<p style="margin-top: 1em">Not doing so may lead to
surprises:</p>

<p style="margin-top: 1em">&quot;12&quot; =~ /(?|
(?&lt;a&gt; + ) | (?&lt;b&gt; say $+ {a}; # Prints
&rsquo;12&rsquo; <br>
say $+ {b}; # *Also* prints &rsquo;12&rsquo;.</p>

<p style="margin-top: 1em">The problem here is that both
the group named &quot;a&quot; and the group named
&quot;b&quot; are aliases for the group belonging to $1.</p>

<p style="margin-top: 1em">Look-Around Assertions <br>
Look-around assertions are zero-width patterns which match a
specific pattern without including it in $&amp;. Positive
assertions match when their subpattern matches, negative
<br>
assertions match when their subpattern fails. Look-behind
matches text up to the current match position, look-ahead
matches text following the current match position.</p>

<p style="margin-top: 1em">&quot;(?=pattern)&quot; <br>
A zero-width positive look-ahead assertion. For example,
&quot;/1752</p>

<p style="margin-top: 1em">&quot;(?!pattern)&quot; <br>
A zero-width negative look-ahead assertion. For example
&quot;/foo(?!bar)/&quot; matches any occurrence of
&quot;foo&quot; that isn&rsquo;t followed by
&quot;bar&quot;. Note however that look-ahead and <br>
look-behind are NOT the same thing. You cannot use this for
look-behind.</p>

<p style="margin-top: 1em">If you are looking for a
&quot;bar&quot; that isn&rsquo;t preceded by a
&quot;foo&quot;, &quot;/(?!foo)bar/&quot; will not do what
you want. That&rsquo;s because the &quot;(?!foo)&quot; is
just saying that the next thing <br>
cannot be &quot;foo&quot;--and it&rsquo;s not, it&rsquo;s a
&quot;bar&quot;, so &quot;foobar&quot; will match. Use
look-behind instead (see below).</p>

<p style="margin-top: 1em">&quot;(?&lt;=pattern)&quot;
&quot;K&quot; <br>
A zero-width positive look-behind assertion. For example,
&quot;/(?&lt;=)2352 <br>
look-behind.</p>

<p style="margin-top: 1em">There is a special form of this
construct, called &quot;K&quot;, which causes the regex
engine to &quot;keep&quot; everything it had matched prior
to the &quot;K&quot; and not include it in $&amp;. This <br>
effectively provides variable-length look-behind. The use of
&quot;K&quot; inside of another look-around assertion is
allowed, but the behaviour is currently not well
defined.</p>

<p style="margin-top: 1em">For various reasons
&quot;K&quot; may be significantly more efficient than the
equivalent &quot;(?&lt;=...)&quot; construct, and it is
especially useful in situations where you want to <br>
efficiently remove something following something else in a
string. For instance</p>

<p style="margin-top: 1em">s/(foo)bar/$1/g;</p>

<p style="margin-top: 1em">can be rewritten as the much
more efficient</p>

<p style="margin-top: 1em">s/fooKbar//g;</p>

<p style="margin-top: 1em">&quot;(?&lt;!pattern)&quot; <br>
A zero-width negative look-behind assertion. For example
&quot;/(?&lt;!bar)foo/&quot; matches any occurrence of
&quot;foo&quot; that does not follow &quot;bar&quot;. Works
only for fixed-width look- <br>
behind.</p>


<p style="margin-top: 1em">&quot;(?&rsquo;NAME&rsquo;pattern)&quot;
<br>
&quot;(?&lt;NAME&gt;pattern)&quot; <br>
A named capture group. Identical in every respect to normal
capturing parentheses &quot;()&quot; but for the additional
fact that the group can be referred to by name in various
<br>
regular expression constructs (like &quot;0NAME}&quot;) and
can be accessed by name after a successful match via
&quot;%+&quot; or &quot;%-&quot;. See perlvar for more
details on the &quot;%+&quot; and &quot;%-&quot; <br>
hashes.</p>

<p style="margin-top: 1em">If multiple distinct capture
groups have the same name then the $+{NAME} will refer to
the leftmost defined group in the match.</p>

<p style="margin-top: 1em">The forms
&quot;(?&rsquo;NAME&rsquo;pattern)&quot; and
&quot;(?&lt;NAME&gt;pattern)&quot; are equivalent.</p>

<p style="margin-top: 1em">NOTE: While the notation of this
construct is the same as the similar function in .NET
regexes, the behavior is not. In Perl the groups are
numbered sequentially regardless <br>
of being named or not. Thus in the pattern</p>

<p style="margin-top: 1em">/(x)(?&lt;foo&gt;y)(z)/</p>

<p style="margin-top: 1em">$+{foo} will be the same as $2,
and $3 will contain &rsquo;z&rsquo; instead of the opposite
which is what a .NET regex hacker might expect.</p>

<p style="margin-top: 1em">Currently NAME is restricted to
simple identifiers only. In other words, it must match
&quot;/^[_A-Za-z][_A-Za-z0-9]*&quot; or its Unicode
extension (see utf8), though it isn&rsquo;t <br>
extended by the locale (see perllocale).</p>

<p style="margin-top: 1em">NOTE: In order to make things
easier for programmers with experience with the Python or
PCRE regex engines, the pattern
&quot;(?P&lt;NAME&gt;pattern)&quot; may be used instead of
<br>
&quot;(?&lt;NAME&gt;pattern)&quot;; however this form does
not support the use of single quotes as a delimiter for the
name.</p>

<p style="margin-top: 1em">&quot;NAME&gt;&quot; <br>
&quot;NAME&rsquo;&quot; <br>
Named backreference. Similar to numeric backreferences,
except that the group is designated by name and not number.
If multiple groups have the same name then it refers to <br>
the leftmost defined group in the current match.</p>

<p style="margin-top: 1em">It is an error to refer to a
name not defined by a &quot;(?&lt;NAME&gt;)&quot; earlier in
the pattern.</p>

<p style="margin-top: 1em">Both forms are equivalent.</p>

<p style="margin-top: 1em">NOTE: In order to make things
easier for programmers with experience with the Python or
PCRE regex engines, the pattern &quot;(?P=NAME)&quot; may be
used instead of &quot;NAME&gt;&quot;.</p>

<p style="margin-top: 1em">&quot;(?{ code })&quot; <br>
WARNING: This extended regular expression feature is
considered experimental, and may be changed without notice.
Code executed that has side effects may not perform <br>
identically from version to version due to the effect of
future optimisations in the regex engine.</p>

<p style="margin-top: 1em">This zero-width assertion
evaluates any embedded Perl code. It always succeeds, and
its &quot;code&quot; is not interpolated. Currently, the
rules to determine where the &quot;code&quot; ends <br>
are somewhat convoluted.</p>

<p style="margin-top: 1em">This feature can be used
together with the special variable $^N to capture the
results of submatches in variables without having to keep
track of the number of nested <br>
parentheses. For example:</p>

<p style="margin-top: 1em">$_ = &quot;The brown fox jumps
over the lazy dog&quot;; <br>
/the ()(?{ $color = $^N }) ()(?{ $animal = $^N })/i; <br>
print &quot;color = $color, animal = $animal456;</p>

<p style="margin-top: 1em">Inside the &quot;(?{...})&quot;
block, $_ refers to the string the regular expression is
matching against. You can also use &quot;pos()&quot; to know
what is the current position of matching <br>
within this string.</p>

<p style="margin-top: 1em">The &quot;code&quot; is properly
scoped in the following sense: If the assertion is
backtracked (compare &quot;Backtracking&quot;), all changes
introduced after &quot;local&quot;ization are undone, so
<br>
that</p>

<p style="margin-top: 1em">$_ = &rsquo;a&rsquo; x 8; <br>
m&lt; <br>
(?{ $cnt = 0 }) # Initialize $cnt. <br>
( <br>
a <br>
(?{ <br>
local $cnt = $cnt + 1; # Update $cnt, <br>
# backtracking-safe. <br>
}) <br>
)* <br>
aaaa <br>
(?{ $res = $cnt }) # On success copy to <br>
# non-localized location. <br>
&gt;x;</p>

<p style="margin-top: 1em">will set &quot;$res = 4&quot;.
Note that after the match, $cnt returns to the globally
introduced value, because the scopes that restrict
&quot;local&quot; operators are unwound.</p>

<p style="margin-top: 1em">This assertion may be used as a
&quot;(?(condition)yes-pattern|no-pattern)&quot; switch. If
not used in this way, the result of evaluation of
&quot;code&quot; is put into the special variable <br>
$^R. This happens immediately, so $^R can be used from other
&quot;(?{ code })&quot; assertions inside the same regular
expression.</p>

<p style="margin-top: 1em">The assignment to $^R above is
properly localized, so the old value of $^R is restored if
the assertion is backtracked; compare
&quot;Backtracking&quot;.</p>

<p style="margin-top: 1em">For reasons of security, this
construct is forbidden if the regular expression involves
run-time interpolation of variables, unless the perilous
&quot;use re &rsquo;eval&rsquo;&quot; pragma has <br>
been used (see re), or the variables contain results of the
&quot;qr//&quot; operator (see
&quot;qr/STRING/msixpodual&quot; in perlop).</p>

<p style="margin-top: 1em">This restriction is due to the
wide-spread and remarkably convenient custom of using
run-time determined strings as patterns. For example:</p>

<p style="margin-top: 1em">$re = &lt;&gt;; <br>
chomp $re; <br>
$string =~ /$re/;</p>

<p style="margin-top: 1em">Before Perl knew how to execute
interpolated code within a pattern, this operation was
completely safe from a security point of view, although it
could raise an exception <br>
from an illegal pattern. If you turn on the &quot;use re
&rsquo;eval&rsquo;&quot;, though, it is no longer secure, so
you should only do so if you are also using taint checking.
Better yet, use <br>
the carefully constrained evaluation within a Safe
compartment. See perlsec for details about both these
mechanisms.</p>

<p style="margin-top: 1em">WARNING: Use of lexical
(&quot;my&quot;) variables in these blocks is broken. The
result is unpredictable and will make perl unstable. The
workaround is to use global (&quot;our&quot;) <br>
variables.</p>

<p style="margin-top: 1em">WARNING: In perl 5.12.x and
earlier, the regex engine was not re-entrant, so
interpolated code could not safely invoke the regex engine
either directly with &quot;m//&quot; or &quot;s///&quot;),
<br>
or indirectly with functions such as &quot;split&quot;.
Invoking the regex engine in these blocks would make perl
unstable.</p>

<p style="margin-top: 1em">&quot;(??{ code })&quot; <br>
WARNING: This extended regular expression feature is
considered experimental, and may be changed without notice.
Code executed that has side effects may not perform <br>
identically from version to version due to the effect of
future optimisations in the regex engine.</p>

<p style="margin-top: 1em">This is a &quot;postponed&quot;
regular subexpression. The &quot;code&quot; is evaluated at
run time, at the moment this subexpression may match. The
result of evaluation is considered a <br>
regular expression and matched as if it were inserted
instead of this construct. Note that this means that the
contents of capture groups defined inside an eval&rsquo;ed
pattern <br>
are not available outside of the pattern, and vice versa,
there is no way for the inner pattern returned from the code
block to refer to a capture group defined outside. <br>
(The code block itself can use $1, etc., to refer to the
enclosing pattern&rsquo;s capture groups.) Thus,</p>

<p style="margin-top: 1em">(&rsquo;a&rsquo; x
100)=~/(??{&rsquo;(.)&rsquo; x 100})/</p>

<p style="margin-top: 1em">will match, it will not set
$1.</p>

<p style="margin-top: 1em">The &quot;code&quot; is not
interpolated. As before, the rules to determine where the
&quot;code&quot; ends are currently somewhat convoluted.</p>

<p style="margin-top: 1em">The following pattern matches a
parenthesized group:</p>

<p style="margin-top: 1em">$re = qr{ <br>
(?: <br>
(?&gt; [^()]+ ) # Non-parens without backtracking <br>
| <br>
(??{ $re }) # Group with matching parens <br>
)* <br>
}x;</p>

<p style="margin-top: 1em">See also &quot;(?PARNO)&quot;
for a different, more efficient way to accomplish the same
task.</p>

<p style="margin-top: 1em">For reasons of security, this
construct is forbidden if the regular expression involves
run-time interpolation of variables, unless the perilous
&quot;use re &rsquo;eval&rsquo;&quot; pragma has <br>
been used (see re), or the variables contain results of the
&quot;qr//&quot; operator (see
&quot;qr/STRING/msixpodual&quot; in perlop).</p>

<p style="margin-top: 1em">In perl 5.12.x and earlier,
because the regex engine was not re-entrant, delayed code
could not safely invoke the regex engine either directly
with &quot;m//&quot; or &quot;s///&quot;), or <br>
indirectly with functions such as &quot;split&quot;.</p>

<p style="margin-top: 1em">Recursing deeper than 50 times
without consuming any input string will result in a fatal
error. The maximum depth is compiled into perl, so changing
it requires a custom <br>
build.</p>

<p style="margin-top: 1em">&quot;(?PARNO)&quot;
&quot;(?-PARNO)&quot; &quot;(?+PARNO)&quot; &quot;(?R)&quot;
&quot;(?0)&quot; <br>
Similar to &quot;(??{ code })&quot; except it does not
involve compiling any code, instead it treats the contents
of a capture group as an independent pattern that must match
at the <br>
current position. Capture groups contained by the pattern
will have the value as determined by the outermost
recursion.</p>

<p style="margin-top: 1em">PARNO is a sequence of digits
(not starting with 0) whose value reflects the paren-number
of the capture group to recurse to. &quot;(?R)&quot;
recurses to the beginning of the whole <br>
pattern. &quot;(?0)&quot; is an alternate syntax for
&quot;(?R)&quot;. If PARNO is preceded by a plus or minus
sign then it is assumed to be relative, with negative
numbers indicating preceding <br>
capture groups and positive ones following. Thus
&quot;(?-1)&quot; refers to the most recently declared
group, and &quot;(?+1)&quot; indicates the next group to be
declared. Note that the <br>
counting for relative recursion differs from that of
relative backreferences, in that with recursion unclosed
groups are included.</p>

<p style="margin-top: 1em">The following pattern matches a
function foo() which may contain balanced parentheses as the
argument.</p>

<p style="margin-top: 1em">$re = qr{ ( # paren group 1
(full function) <br>
foo <br>
( # paren group 2 (parens) <br>
( # paren group 3 (contents of parens) <br>
(?: <br>
(?&gt; [^()]+ ) # Non-parens without backtracking <br>
| <br>
(?2) # Recurse to start of paren group 2 <br>
)* <br>
) <br>
) <br>
) <br>
}x;</p>

<p style="margin-top: 1em">If the pattern was used as
follows</p>


<p style="margin-top: 1em">&rsquo;foo(bar(baz)+baz(bop))&rsquo;=~/$re/
<br>
and print &quot; = $1456, <br>
&quot; = $2456, <br>
&quot; = $3456;</p>

<p style="margin-top: 1em">the output produced should be
the following:</p>

<p style="margin-top: 1em">$1 = foo(bar(baz)+baz(bop)) <br>
$2 = (bar(baz)+baz(bop)) <br>
$3 = bar(baz)+baz(bop)</p>

<p style="margin-top: 1em">If there is no corresponding
capture group defined, then it is a fatal error. Recursing
deeper than 50 times without consuming any input string will
also result in a fatal <br>
error. The maximum depth is compiled into perl, so changing
it requires a custom build.</p>

<p style="margin-top: 1em">The following shows how using
negative indexing can make it easier to embed recursive
patterns inside of a &quot;qr//&quot; construct for later
use:</p>

<p style="margin-top: 1em">my $parens =
qr/(:[^()]++|(?-1))*+)/; <br>
if (/foo $parens + bar $parens/x) { <br>
# do something here... <br>
}</p>

<p style="margin-top: 1em">Note that this pattern does not
behave the same way as the equivalent PCRE or Python
construct of the same form. In Perl you can backtrack into a
recursed group, in PCRE and <br>
Python the recursed into group is treated as atomic. Also,
modifiers are resolved at compile time, so constructs like
(?i:(?1)) or (?:(?i)(?1)) do not affect how the sub- <br>
pattern will be processed.</p>

<p style="margin-top: 1em">&quot;(?&amp;NAME)&quot; <br>
Recurse to a named subpattern. Identical to
&quot;(?PARNO)&quot; except that the parenthesis to recurse
to is determined by name. If multiple parentheses have the
same name, then it <br>
recurses to the leftmost.</p>

<p style="margin-top: 1em">It is an error to refer to a
name that is not declared somewhere in the pattern.</p>

<p style="margin-top: 1em">NOTE: In order to make things
easier for programmers with experience with the Python or
PCRE regex engines the pattern &quot;(?P&gt;NAME)&quot; may
be used instead of &quot;(?&amp;NAME)&quot;.</p>


<p style="margin-top: 1em">&quot;(?(condition)yes-pattern|no-pattern)&quot;
<br>
&quot;(?(condition)yes-pattern)&quot; <br>
Conditional expression. Matches &quot;yes-pattern&quot; if
&quot;condition&quot; yields a true value, matches
&quot;no-pattern&quot; otherwise. A missing pattern always
matches.</p>

<p style="margin-top: 1em">&quot;(condition)&quot; should
be either an integer in parentheses (which is valid if the
corresponding pair of parentheses matched), a
look-ahead/look-behind/evaluate zero-width <br>
assertion, a name in angle brackets or single quotes (which
is valid if a group with the given name matched), or the
special symbol (R) (true when evaluated inside of <br>
recursion or eval). Additionally the R may be followed by a
number, (which will be true when evaluated when recursing
inside of the appropriate group), or by &amp;NAME, in which
<br>
case it will be true only when evaluated during recursion in
the named group.</p>

<p style="margin-top: 1em">Here&rsquo;s a summary of the
possible predicates:</p>

<p style="margin-top: 1em">(1) (2) ... <br>
Checks if the numbered capturing group has matched
something.</p>

<p style="margin-top: 1em">(&lt;NAME&gt;)
(&rsquo;NAME&rsquo;) <br>
Checks if a group with the given name has matched
something.</p>

<p style="margin-top: 1em">(?=...) (?!...) (?&lt;=...)
(?&lt;!...) <br>
Checks whether the pattern matches (or does not match, for
the &rsquo;!&rsquo; variants).</p>

<p style="margin-top: 1em">(?{ CODE }) <br>
Treats the return value of the code block as the
condition.</p>

<p style="margin-top: 1em">(R) Checks if the expression has
been evaluated inside of recursion.</p>

<p style="margin-top: 1em">(R1) (R2) ... <br>
Checks if the expression has been evaluated while executing
directly inside of the n-th capture group. This check is the
regex equivalent of</p>

<p style="margin-top: 1em">if ((caller(0))[3] eq
&rsquo;subname&rsquo;) { ... }</p>

<p style="margin-top: 1em">In other words, it does not
check the full recursion stack.</p>

<p style="margin-top: 1em">(R&amp;NAME) <br>
Similar to &quot;(R1)&quot;, this predicate checks to see if
we&rsquo;re executing directly inside of the leftmost group
with a given name (this is the same logic used by
&quot;(?&amp;NAME)&quot; to <br>
disambiguate). It does not check the full stack, but only
the name of the innermost active recursion.</p>

<p style="margin-top: 1em">(DEFINE) <br>
In this case, the yes-pattern is never directly executed,
and no no-pattern is allowed. Similar in spirit to
&quot;(?{0})&quot; but more efficient. See below for
details.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">m{ ( )? <br>
[^()]+ <br>
(?(1) ) <br>
}x</p>

<p style="margin-top: 1em">matches a chunk of
non-parentheses, possibly included in parentheses
themselves.</p>

<p style="margin-top: 1em">A special form is the
&quot;(DEFINE)&quot; predicate, which never executes its
yes-pattern directly, and does not allow a no-pattern. This
allows one to define subpatterns which will <br>
be executed only by the recursion mechanism. This way, you
can define a set of regular expression rules that can be
bundled into any pattern you choose.</p>

<p style="margin-top: 1em">It is recommended that for this
usage you put the DEFINE block at the end of the pattern,
and that you name any subpatterns defined within it.</p>

<p style="margin-top: 1em">Also, it&rsquo;s worth noting
that patterns defined this way probably will not be as
efficient, as the optimiser is not very clever about
handling them.</p>

<p style="margin-top: 1em">An example of how this might be
used is as follows:</p>


<p style="margin-top: 1em">/(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
<br>
(?(DEFINE) <br>
(?&lt;NAME_PAT&gt;....) <br>
(?&lt;ADRESS_PAT&gt;....) <br>
)/x</p>

<p style="margin-top: 1em">Note that capture groups matched
inside of recursion are not accessible after the recursion
returns, so the extra layer of capturing groups is
necessary. Thus $+{NAME_PAT} <br>
would not be defined even though $+{NAME} would be.</p>

<p style="margin-top: 1em">Finally, keep in mind that
subpatterns created inside a DEFINE block count towards the
absolute and relative number of captures, so this:</p>

<p style="margin-top: 1em">my @captures = &quot;a&quot; =~
/(.) # First capture <br>
(?(DEFINE) <br>
(?&lt;EXAMPLE&gt; 1 ) # Second capture <br>
)/x; <br>
say scalar @captures;</p>

<p style="margin-top: 1em">Will output 2, not 1. This is
particularly important if you intend to compile the
definitions with the &quot;qr//&quot; operator, and later
interpolate them in another pattern.</p>

<p style="margin-top: 1em">&quot;(?&gt;pattern)&quot; <br>
An &quot;independent&quot; subexpression, one which matches
the substring that a standalone &quot;pattern&quot; would
match if anchored at the given position, and it matches
nothing other than <br>
this substring. This construct is useful for optimizations
of what would otherwise be &quot;eternal&quot; matches,
because it will not backtrack (see
&quot;Backtracking&quot;). It may also be <br>
useful in places where the &quot;grab all you can, and do
not give anything back&quot; semantic is desirable.</p>

<p style="margin-top: 1em">For example:
&quot;^(?&gt;a*)ab&quot; will never match, since
&quot;(?&gt;a*)&quot; (anchored at the beginning of string,
as above) will match all characters &quot;a&quot; at the
beginning of string, leaving no <br>
&quot;a&quot; for &quot;ab&quot; to match. In contrast,
&quot;a*ab&quot; will match the same as &quot;a+b&quot;,
since the match of the subgroup &quot;a*&quot; is influenced
by the following group &quot;ab&quot; (see
&quot;Backtracking&quot;). <br>
In particular, &quot;a*&quot; inside &quot;a*ab&quot; will
match fewer characters than a standalone &quot;a*&quot;,
since this makes the tail match.</p>

<p style="margin-top: 1em">&quot;(?&gt;pattern)&quot; does
not disable backtracking altogether once it has matched. It
is still possible to backtrack past the construct, but not
into it. So &quot;((?&gt;a*)|(?&gt;b*))ar&quot; will <br>
still match &quot;bar&quot;.</p>

<p style="margin-top: 1em">An effect similar to
&quot;(?&gt;pattern)&quot; may be achieved by writing
&quot;(?=(pattern))0-1}&quot;. This matches the same
substring as a standalone &quot;a+&quot;, and the following
&quot;0-1}&quot; eats <br>
the matched string; it therefore makes a zero-length
assertion into an analogue of &quot;(?&gt;...)&quot;. (The
difference between these two constructs is that the second
one uses a <br>
capturing group, thus shifting ordinals of backreferences in
the rest of a regular expression.)</p>

<p style="margin-top: 1em">Consider this pattern:</p>

<p style="margin-top: 1em">m{ <br>
( <br>
[^()]+ # x+ <br>
| <br>
[^()]* <br>
)+ <br>
}x</p>

<p style="margin-top: 1em">That will efficiently match a
nonempty group with matching parentheses two levels deep or
less. However, if there is no such group, it will take
virtually forever on a long <br>
string. That&rsquo;s because there are so many different
ways to split a long string into several substrings. This is
what &quot;(.+)+&quot; is doing, and &quot;(.+)+&quot; is
similar to a <br>
subpattern of the above pattern. Consider how the pattern
above detects no-match on &quot;((()aaaaaaaaaaaaaaaaaa&quot;
in several seconds, but that each extra letter doubles this
<br>
time. This exponential performance will make it appear that
your program has hung. However, a tiny change to this
pattern</p>

<p style="margin-top: 1em">m{ <br>
( <br>
(?&gt; [^()]+ ) # change x+ above to (?&gt; x+ ) <br>
| <br>
[^()]* <br>
)+ <br>
}x</p>

<p style="margin-top: 1em">which uses
&quot;(?&gt;...)&quot; matches exactly when the one above
does (verifying this yourself would be a productive
exercise), but finishes in a fourth the time when used on a
<br>
similar string with 1000000 &quot;a&quot;s. Be aware,
however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the &quot;use warnings&quot; <br>
pragma or -w switch saying it &quot;matches null string many
times in regex&quot;.</p>

<p style="margin-top: 1em">On simple groups, such as the
pattern &quot;(?&gt; [^()]+ )&quot;, a comparable effect may
be achieved by negative look-ahead, as in &quot;[^()]+ (?!
[^()] )&quot;. This was only 4 times slower on <br>
a string with 1000000 &quot;a&quot;s.</p>

<p style="margin-top: 1em">The &quot;grab all you can, and
do not give anything back&quot; semantic is desirable in
many situations where on the first sight a simple
&quot;()*&quot; looks like the correct solution. <br>
Suppose we parse text with comments being delimited by
&quot;#&quot; followed by some optional (horizontal)
whitespace. Contrary to its appearance, &quot;#[ ]*&quot; is
not the correct <br>
subexpression to match the comment delimiter, because it may
&quot;give up&quot; some whitespace if the remainder of the
pattern can be made to match that way. The correct answer is
<br>
either one of these:</p>

<p style="margin-top: 1em">(?&gt;#[ ]*) <br>
#[ ]*(?![ ])</p>

<p style="margin-top: 1em">For example, to grab non-empty
comments into $1, one should use either one of these:</p>

<p style="margin-top: 1em">/ (?&gt; / <br>
Which one you pick depends on which of these expressions
better reflects the above specification of comments.</p>

<p style="margin-top: 1em">In some literature this
construct is called &quot;atomic matching&quot; or
&quot;possessive matching&quot;.</p>

<p style="margin-top: 1em">Possessive quantifiers are
equivalent to putting the item they are applied to inside of
one of these constructs. The following equivalences
apply:</p>

<p style="margin-top: 1em">Quantifier Form Bracketing Form
<br>
--------------- --------------- <br>
PAT*+ (?&gt;PAT*) <br>
PAT++ (?&gt;PAT+) <br>
PAT?+ (?&gt;PAT?) <br>
PAT{min,max}+ (?&gt;PAT{min,max})</p>

<p style="margin-top: 1em">Special Backtracking Control
Verbs <br>
WARNING: These patterns are experimental and subject to
change or removal in a future version of Perl. Their usage
in production code should be noted to avoid problems during
<br>
upgrades.</p>

<p style="margin-top: 1em">These special patterns are
generally of the form &quot;(*VERB:ARG)&quot;. Unless
otherwise stated the ARG argument is optional; in some
cases, it is forbidden.</p>

<p style="margin-top: 1em">Any pattern containing a special
backtracking verb that allows an argument has the special
behaviour that when executed it sets the current
package&rsquo;s $REGERROR and $REGMARK <br>
variables. When doing so the following rules apply:</p>

<p style="margin-top: 1em">On failure, the $REGERROR
variable will be set to the ARG value of the verb pattern,
if the verb was involved in the failure of the match. If the
ARG part of the pattern was <br>
omitted, then $REGERROR will be set to the name of the last
&quot;(*MARK:NAME)&quot; pattern executed, or to TRUE if
there was none. Also, the $REGMARK variable will be set to
FALSE.</p>

<p style="margin-top: 1em">On a successful match, the
$REGERROR variable will be set to FALSE, and the $REGMARK
variable will be set to the name of the last
&quot;(*MARK:NAME)&quot; pattern executed. See the <br>
explanation for the &quot;(*MARK:NAME)&quot; verb below for
more details.</p>

<p style="margin-top: 1em">NOTE: $REGERROR and $REGMARK are
not magic variables like $1 and most other regex-related
variables. They are not local to a scope, nor readonly, but
instead are volatile package <br>
variables similar to $AUTOLOAD. Use &quot;local&quot; to
localize changes to them to a specific scope if
necessary.</p>

<p style="margin-top: 1em">If a pattern does not contain a
special backtracking verb that allows an argument, then
$REGERROR and $REGMARK are not touched at all.</p>

<p style="margin-top: 1em">Verbs that take an argument <br>
&quot;(*PRUNE)&quot; &quot;(*PRUNE:NAME)&quot; <br>
This zero-width pattern prunes the backtracking tree at the
current point when backtracked into on failure. Consider the
pattern &quot;A (*PRUNE) B&quot;, where A and B are complex
<br>
patterns. Until the &quot;(*PRUNE)&quot; verb is reached, A
may backtrack as necessary to match. Once it is reached,
matching continues in B, which may also backtrack as
necessary; <br>
however, should B not match, then no further backtracking
will take place, and the pattern will fail outright at the
current starting position.</p>

<p style="margin-top: 1em">The following example counts all
the possible matching strings in a pattern (without actually
matching any of them).</p>

<p style="margin-top: 1em">&rsquo;aaab&rsquo; =~
/a+b?(?{print &quot;$&amp;456; $count++})(*FAIL)/; <br>
print &quot;Count=$count456;</p>

<p style="margin-top: 1em">which produces:</p>

<p style="margin-top: 1em">aaab <br>
aaa <br>
aa <br>
a <br>
aab <br>
aa <br>
a <br>
ab <br>
a <br>
Count=9</p>

<p style="margin-top: 1em">If we add a &quot;(*PRUNE)&quot;
before the count like the following</p>

<p style="margin-top: 1em">&rsquo;aaab&rsquo; =~
/a+b?(*PRUNE)(?{print &quot;$&amp;456; $count++})(*FAIL)/;
<br>
print &quot;Count=$count456;</p>

<p style="margin-top: 1em">we prevent backtracking and find
the count of the longest matching string at each matching
starting point like so:</p>

<p style="margin-top: 1em">aaab <br>
aab <br>
ab <br>
Count=3</p>

<p style="margin-top: 1em">Any number of
&quot;(*PRUNE)&quot; assertions may be used in a
pattern.</p>

<p style="margin-top: 1em">See also
&quot;(?&gt;pattern)&quot; and possessive quantifiers for
other ways to control backtracking. In some cases, the use
of &quot;(*PRUNE)&quot; can be replaced with a
&quot;(?&gt;pattern)&quot; with no <br>
functional difference; however, &quot;(*PRUNE)&quot; can be
used to handle cases that cannot be expressed using a
&quot;(?&gt;pattern)&quot; alone.</p>

<p style="margin-top: 1em">&quot;(*SKIP)&quot;
&quot;(*SKIP:NAME)&quot; <br>
This zero-width pattern is similar to &quot;(*PRUNE)&quot;,
except that on failure it also signifies that whatever text
that was matched leading up to the &quot;(*SKIP)&quot;
pattern being <br>
executed cannot be part of any match of this pattern. This
effectively means that the regex engine &quot;skips&quot;
forward to this position on failure and tries to match
again, <br>
(assuming that there is sufficient room to match).</p>

<p style="margin-top: 1em">The name of the
&quot;(*SKIP:NAME)&quot; pattern has special significance.
If a &quot;(*MARK:NAME)&quot; was encountered while
matching, then it is that position which is used as the
&quot;skip <br>
point&quot;. If no &quot;(*MARK)&quot; of that name was
encountered, then the &quot;(*SKIP)&quot; operator has no
effect. When used without a name the &quot;skip point&quot;
is where the match point was <br>
when executing the (*SKIP) pattern.</p>

<p style="margin-top: 1em">Compare the following to the
examples in &quot;(*PRUNE)&quot;; note the string is twice
as long:</p>

<p style="margin-top: 1em">&rsquo;aaabaaab&rsquo; =~
/a+b?(*SKIP)(?{print &quot;$&amp;456; $count++})(*FAIL)/;
<br>
print &quot;Count=$count456;</p>

<p style="margin-top: 1em">outputs</p>

<p style="margin-top: 1em">aaab <br>
aaab <br>
Count=2</p>

<p style="margin-top: 1em">Once the &rsquo;aaab&rsquo; at
the start of the string has matched, and the
&quot;(*SKIP)&quot; executed, the next starting point will
be where the cursor was when the &quot;(*SKIP)&quot; was
executed.</p>

<p style="margin-top: 1em">&quot;(*MARK:NAME)&quot;
&quot;(*:NAME)&quot; <br>
This zero-width pattern can be used to mark the point
reached in a string when a certain part of the pattern has
been successfully matched. This mark may be given a name.
<br>
A later &quot;(*SKIP)&quot; pattern will then skip forward
to that point if backtracked into on failure. Any number of
&quot;(*MARK)&quot; patterns are allowed, and the NAME
portion may be <br>
duplicated.</p>

<p style="margin-top: 1em">In addition to interacting with
the &quot;(*SKIP)&quot; pattern, &quot;(*MARK:NAME)&quot;
can be used to &quot;label&quot; a pattern branch, so that
after matching, the program can determine which <br>
branches of the pattern were involved in the match.</p>

<p style="margin-top: 1em">When a match is successful, the
$REGMARK variable will be set to the name of the most
recently executed &quot;(*MARK:NAME)&quot; that was involved
in the match.</p>

<p style="margin-top: 1em">This can be used to determine
which branch of a pattern was matched without using a
separate capture group for each branch, which in turn can
result in a performance <br>
improvement, as perl cannot optimize
&quot;/(?:(x)|(y)|(z))/&quot; as efficiently as something
like &quot;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&quot;.</p>

<p style="margin-top: 1em">When a match has failed, and
unless another verb has been involved in failing the match
and has provided its own name to use, the $REGERROR variable
will be set to the <br>
name of the most recently executed
&quot;(*MARK:NAME)&quot;.</p>

<p style="margin-top: 1em">See &quot;(*SKIP)&quot; for more
details.</p>

<p style="margin-top: 1em">As a shortcut
&quot;(*MARK:NAME)&quot; can be written
&quot;(*:NAME)&quot;.</p>

<p style="margin-top: 1em">&quot;(*THEN)&quot;
&quot;(*THEN:NAME)&quot; <br>
This is similar to the &quot;cut group&quot; operator
&quot;::&quot; from Perl 6. Like &quot;(*PRUNE)&quot;, this
verb always matches, and when backtracked into on failure,
it causes the regex engine <br>
to try the next alternation in the innermost enclosing group
(capturing or otherwise) that has alternations. The two
branches of a
&quot;(?(condition)yes-pattern|no-pattern)&quot; <br>
do not count as an alternation, as far as
&quot;(*THEN)&quot; is concerned.</p>

<p style="margin-top: 1em">Its name comes from the
observation that this operation combined with the
alternation operator (&quot;|&quot;) can be used to create
what is essentially a pattern-based if/then/else <br>
block:</p>

<p style="margin-top: 1em">( COND (*THEN) FOO | COND2
(*THEN) BAR | COND3 (*THEN) BAZ )</p>

<p style="margin-top: 1em">Note that if this operator is
used and NOT inside of an alternation then it acts exactly
like the &quot;(*PRUNE)&quot; operator.</p>

<p style="margin-top: 1em">/ A (*PRUNE) B /</p>

<p style="margin-top: 1em">is the same as</p>

<p style="margin-top: 1em">/ A (*THEN) B /</p>

<p style="margin-top: 1em">but</p>

<p style="margin-top: 1em">/ ( A (*THEN) B | C (*THEN) D )
/</p>

<p style="margin-top: 1em">is not the same as</p>

<p style="margin-top: 1em">/ ( A (*PRUNE) B | C (*PRUNE) D
) /</p>

<p style="margin-top: 1em">as after matching the A but
failing on the B the &quot;(*THEN)&quot; verb will backtrack
and try C; but the &quot;(*PRUNE)&quot; verb will simply
fail.</p>

<p style="margin-top: 1em">Verbs without an argument <br>
&quot;(*COMMIT)&quot; <br>
This is the Perl 6 &quot;commit pattern&quot;
&quot;&lt;commit&gt;&quot; or &quot;:::&quot;. It&rsquo;s a
zero-width pattern similar to &quot;(*SKIP)&quot;, except
that when backtracked into on failure it causes the match
<br>
to fail outright. No further attempts to find a valid match
by advancing the start pointer will occur again. For
example,</p>

<p style="margin-top: 1em">&rsquo;aaabaaab&rsquo; =~
/a+b?(*COMMIT)(?{print &quot;$&amp;456; $count++})(*FAIL)/;
<br>
print &quot;Count=$count456;</p>

<p style="margin-top: 1em">outputs</p>

<p style="margin-top: 1em">aaab <br>
Count=1</p>

<p style="margin-top: 1em">In other words, once the
&quot;(*COMMIT)&quot; has been entered, and if the pattern
does not match, the regex engine will not try any further
matching on the rest of the string.</p>

<p style="margin-top: 1em">&quot;(*FAIL)&quot;
&quot;(*F)&quot; <br>
This pattern matches nothing and always fails. It can be
used to force the engine to backtrack. It is equivalent to
&quot;(?!)&quot;, but easier to read. In fact,
&quot;(?!)&quot; gets <br>
optimised into &quot;(*FAIL)&quot; internally.</p>

<p style="margin-top: 1em">It is probably useful only when
combined with &quot;(?{})&quot; or &quot;(??{})&quot;.</p>

<p style="margin-top: 1em">&quot;(*ACCEPT)&quot; <br>
WARNING: This feature is highly experimental. It is not
recommended for production code.</p>

<p style="margin-top: 1em">This pattern matches nothing and
causes the end of successful matching at the point at which
the &quot;(*ACCEPT)&quot; pattern was encountered,
regardless of whether there is <br>
actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern
dynamically generated via &quot;(??{})&quot;, only the
innermost pattern <br>
is ended immediately.</p>

<p style="margin-top: 1em">If the &quot;(*ACCEPT)&quot; is
inside of capturing groups then the groups are marked as
ended at the point at which the &quot;(*ACCEPT)&quot; was
encountered. For instance:</p>

<p style="margin-top: 1em">&rsquo;AB&rsquo; =~ /(A
(A|B(*ACCEPT)|C) D)(E)/x;</p>

<p style="margin-top: 1em">will match, and $1 will be
&quot;AB&quot; and $2 will be &quot;B&quot;, $3 will not be
set. If another branch in the inner parentheses was matched,
such as in the string &rsquo;ACDE&rsquo;, then the
&quot;D&quot; <br>
and &quot;E&quot; would have to be matched as well.</p>

<p style="margin-top: 1em">Backtracking <br>
NOTE: This section presents an abstract approximation of
regular expression behavior. For a more rigorous (and
complicated) view of the rules involved in selecting a match
among <br>
possible alternatives, see &quot;Combining RE
Pieces&quot;.</p>

<p style="margin-top: 1em">A fundamental feature of regular
expression matching involves the notion called backtracking,
which is currently used (when needed) by all regular
non-possessive expression <br>
quantifiers, namely &quot;*&quot;, &quot;*?&quot;,
&quot;+&quot;, &quot;+?&quot;, &quot;{n,m}&quot;, and
&quot;{n,m}?&quot;. Backtracking is often optimized
internally, but the general principle outlined here is
valid.</p>

<p style="margin-top: 1em">For a regular expression to
match, the entire regular expression must match, not just
part of it. So if the beginning of a pattern containing a
quantifier succeeds in a way that <br>
causes later parts in the pattern to fail, the matching
engine backs up and recalculates the beginning
part--that&rsquo;s why it&rsquo;s called backtracking.</p>

<p style="margin-top: 1em">Here is an example of
backtracking: Let&rsquo;s say you want to find the word
following &quot;foo&quot; in the string &quot;Food is on the
foo table.&quot;:</p>

<p style="margin-top: 1em">$_ = &quot;Food is on the foo
table.&quot;; f o <br>
if ( /o
<big><big><big><big><big><big><big><big>8</big></big></big></big></big></big></big></big>
<sup>) <big><big><big><big><big><big><big><big><br>
print &quot;$2 follows $1.456; <br>
}</big></big></big></big></big></big></big></big></sup></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>When
the match runs, the first part of the regular expression
(&quot; s a , r e v e w o H . &quot; o o F &quot; h t i w 1
$ p u s d a o l d n a , g n i r t s e h t f o g n i n n i g
e b e h t t a t h g i r h c t a m e l b i s s o p a s d n i
f ) &quot; ) o o f <br>
soon as the matching engine sees that there&rsquo;s no
whitespace following the &quot;Foo&quot; that it had saved
in $1, it realizes its mistake and starts over again one
character after where <br>
it had the tentative match. This time it goes all the way
until the next occurrence of &quot;foo&quot;. The complete
regular expression matches this time, and you get the
expected output <br>
of &quot;table follows
foo.&quot;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Sometimes
minimal matching can help a lot. Imagine you&rsquo;d like to
match everything between &quot;foo&quot; and
&quot;bar&quot;. Initially, you write something like
this:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>$_
= &quot;The food is under the bar in the barn.&quot;; <br>
if ( /foo(.*)bar/ ) { <br>
print &quot;got &lt;$1&gt;456; <br>
}</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Which
perhaps unexpectedly
yields:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>got
&lt;d is under the bar in the
&gt;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>That&rsquo;s
because &quot;.*&quot; was greedy, so you get everything
between the first &quot;foo&quot; and the last
&quot;bar&quot;. Here it&rsquo;s more effective to use
minimal matching to make sure you get the text <br>
between a &quot;foo&quot; and the first &quot;bar&quot;
thereafter.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>if
( /foo(.*?)bar/ ) { print &quot;got &lt;$1&gt;456 } <br>
got &lt;d is under the
&gt;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Here&rsquo;s
another example. Let&rsquo;s say you&rsquo;d like to match a
number at the end of a string, and you also want to keep the
preceding part of the match. So you write
this:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>$_
= &quot;I have 2 numbers: 53147&quot;; <br>
if ( /(.*)( *)/ ) {# Wrong! <br>
print &quot;Beginning is &lt;$1&gt;, number is
&lt;$2&gt;.456; <br>
}</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>That
won&rsquo;t work at all, because &quot;.*&quot; was greedy
and gobbled up the whole string. As &quot; *&quot; can match
on an empty string thecomplete regular expression matched
successfully.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Beginning
is &lt;I have 2 numbers: 53147&gt;, number is
&lt;&gt;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Here
are some variants, most of which don&rsquo;t
work:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>$_
= &quot;I have 2 numbers: 53147&quot;; <br>
@pats = qw{ <br>
(.*)( *) <br>
(.*)( +) <br>
(.*?)( *) <br>
(.*?)( +) <br>
(.*)( +)$ <br>
(.*?)( +)$ <br>
(.*) $ ) + <br>
(.*$ <br>
};</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>for
$pat (@pats) { <br>
printf &quot;%-12s &quot;, $pat; <br>
if ( /$pat/ ) { <br>
print &quot;&lt;$1&gt; &lt;$2&gt;456; <br>
} else { <br>
print &quot;FAIL456; <br>
} <br>
}</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>That
will print
out:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>(.*)(
*) &lt;I have 2numbers: 53147&gt; &lt;&gt; <br>
(.*)( +) &lt;I have 2numbers: 5314&gt; &lt;7&gt; <br>
(.*?)( *) &lt;&gt; &lt;&gt; <br>
(.*?)( +) &lt;I have &gt;&lt;2&gt; <br>
(.*)( +)$ &lt;I have 2numbers: 5314&gt; &lt;7&gt; <br>
(.*?)( +)$ &lt;I have 2numbers: &gt; &lt;53147&gt; <br>
(.*) &gt; 7 4 1 3 5 &lt; &gt; : s r e b m u n 2 e v a h I
&lt; $ ) + <br>
(.*$ &lt;I have 2 numbers: &gt;
&lt;53147&gt;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>As
you see, this can be a bit tricky. It&rsquo;s important to
realize that a regular expression is merely a set of
assertions that gives a definition of success. There may be
0, 1, <br>
or several different ways that the definition might succeed
against a particular string. And if there are multiple ways
it might succeed, you need to understand backtracking to
<br>
know which variety of success you will
achieve.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>When
using look-ahead assertions and negations, this can all get
even trickier. Imagine you&rsquo;d like to find a sequence
of non-digits not followed by &quot;123&quot;. You might try
to <br>
write that
as</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>$_
= &quot;ABC123&quot;; <br>
if ( /^ print &quot;Yup, no 123 in $_456; <br>
}</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>But
that isn&rsquo;t going to match; at least, not the way
you&rsquo;re hoping. It claims that there is no 123 in the
string. Here&rsquo;s a clearer picture of why that pattern
matches, contrary <br>
to popular
expectations:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>$x
= &rsquo;ABC123&rsquo;; <br>
$y =
&rsquo;ABC445&rsquo;;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>print
&quot;1: got $1456 if $x =~ /^(ABC)(?!123)/; <br>
print &quot;2: got $1456 if $y =~
/^(ABC)(?!123)/;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>print
&quot;3: got $1456 if $x =~ /^( print &quot;4: got $1456 if
$y =~ /^( <br>
This
prints</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>2:
got ABC <br>
3: got AB <br>
4: got
ABC</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>You
might have expected test 3 to fail because it seems to a
more general purpose version of test 1. The important
difference between them is that test 3 contains a quantifier
<br>
(&quot; something that&rsquo;s not 123?&quot; If the pattern
matcher had let &quot; <br>
The search engine will initially match &quot; <br>
The pattern really, really wants to succeed, so it uses the
standard pattern back-off-and-retry and lets &quot;
following &quot;AB&quot; that is not &quot;123&quot;.
It&rsquo;s &quot;C123&quot;, which
suffices.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>We
can deal with this by using both an assertion and a
negation. We&rsquo;ll say that the first part in $1 must be
followed both by a digit and by something that&rsquo;s not
&quot;123&quot;. <br>
Remember that the look-aheads are zero-width
expressions--they only look, but don&rsquo;t consume any of
the string in their match. So rewriting this way produces
what you&rsquo;d expect; <br>
that is, case 5 will fail, but case 6
succeeds:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>print
&quot;5: got $1456 if $x =~ /^( print &quot;6: got $1456 if
$y =~ /^( <br>
6: got
ABC</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>In
other words, the two zero-width assertions next to each
other work as though they&rsquo;re ANDed together, just as
you&rsquo;d use any built-in assertions: &quot;/^$/&quot;
matches only if you&rsquo;re <br>
at the beginning of the line AND the end of the line
simultaneously. The deeper underlying truth is that
juxtaposition in regular expressions always means AND,
except when you <br>
write an explicit OR using the vertical bar.
&quot;/ab/&quot; means match &quot;a&quot; AND (then) match
&quot;b&quot;, although the attempted matches are made at
different positions because &quot;a&quot; is not a <br>
zero-width assertion, but a one-width
assertion.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>WARNING:
Particularly complicated regular expressions can take
exponential time to solve because of the immense number of
possible ways they can use backtracking to try for a <br>
match. For example, without internal optimizations done by
the regular expression engine, this will take a painfully
long time to
run:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&rsquo;aaaaaaaaaaaa&rsquo;
=~
/((a{0,5}){0,5})*[c]/</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>And
if you used &quot;*&quot;&rsquo;s in the internal groups
instead of limiting them to 0 through 5 matches, then it
would take forever--or until you ran out of stack space.
Moreover, these <br>
internal optimizations are not always applicable. For
example, if you put &quot;{0,5}&quot; instead of
&quot;*&quot; on the external group, no current optimization
is applicable, and the match <br>
takes a long time to
finish.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>A
powerful tool for optimizing such beasts is what is known as
an &quot;independent group&quot;, which does not backtrack
(see &quot;&quot;(?&gt;pattern)&quot;&quot;). Note also that
zero-length <br>
look-ahead/look-behind assertions will not backtrack to make
the tail match, since they are in &quot;logical&quot;
context: only whether they match is considered relevant. For
an example <br>
where side-effects of look-ahead might have influenced the
following match, see
&quot;&quot;(?&gt;pattern)&quot;&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Version
8 Regular Expressions <br>
In case you&rsquo;re not familiar with the
&quot;regular&quot; Version 8 regex routines, here are the
pattern-matching rules not described
above.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Any
single character matches itself, unless it is a
metacharacter with a special meaning described here or
above. You can cause characters that normally function as
<br>
metacharacters to be interpreted literally by prefixing them
with a &quot; <br>
for the character used as the pattern
delimiter.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>A
series of characters matches that series of characters in
the target string, so the pattern &quot;blurfl&quot; would
match &quot;blurfl&quot; in the target
string.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>You
can specify a character class, by enclosing a list of
characters in &quot;[]&quot;, which will match any character
from the list. If the first character after the
&quot;[&quot; is &quot;^&quot;, the <br>
class matches any character not in the list. Within a list,
the &quot;-&quot; character specifies a range, so that
&quot;a-z&quot; represents all characters between
&quot;a&quot; and &quot;z&quot;, inclusive. If you <br>
want either &quot;-&quot; or &quot;]&quot; itself to be a
member of a class, put it at the start of the list (possibly
after a &quot;^&quot;), or escape it with a backslash.
&quot;-&quot; is also taken literally when <br>
it is at the end of the list, just before the closing
&quot;]&quot;. (The following all specify the same class of
three characters: &quot;[-az]&quot;, &quot;[az-]&quot;, and
&quot;[a&minus;z]&quot;. All are different from <br>
&quot;[a-z]&quot;, which specifies a class containing
twenty-six characters, even on EBCDIC-based character sets.)
Also, if you try to use the character classes
&quot;96W&quot;, &quot; &quot; <br>
&quot; &quot;, or &quot;-&quot; is
understoodliterally.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Note
also that the whole range idea is rather unportable between
character sets--and even within character sets they may
cause results you probably didn&rsquo;t expect. A sound <br>
principle is to use only ranges that begin from and end at
either alphabetics of equal case ([a-e], [A-E]), or digits
([0-9]). Anything else is unsafe. If in doubt, spell out
<br>
the character sets in
full.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Characters
may be specified using a metacharacter syntax much like that
used in C: &quot;456 matches a newline, &quot;&quot; a tab,
&quot; &quot; a carriage return, &quot; a form feed, etc.
More <br>
generally, 0n, where nnn is a string of three octal digits,
matches the character whose coded character set value is
nnn. Similarly, , where nn are hexadecimal digits, <br>
matches the character whose ordinal is nn. The expression
&quot;/s&quot;).</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>You
can specify a series of alternatives for a pattern using
&quot;|&quot; to separate them, so that
&quot;fee|fie|foe&quot; will match any of &quot;fee&quot;,
&quot;fie&quot;, or &quot;foe&quot; in the target string (as
would <br>
&quot;f(e|i|o)e&quot;). The first alternative includes
everything from the last pattern delimiter (&quot;(&quot;,
&quot;(?:&quot;, etc. or the beginning of the pattern) up to
the first &quot;|&quot;, and the last <br>
alternative contains everything from the last &quot;|&quot;
to the next closing pattern delimiter. That&rsquo;s why
it&rsquo;s common practice to include alternatives in
parentheses: to minimize <br>
confusion about where they start and
end.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Alternatives
are tried from left to right, so the first alternative found
for which the entire expression matches, is the one that is
chosen. This means that alternatives are not <br>
necessarily greedy. For example: when matching
&quot;foo|foot&quot; against &quot;barefoot&quot;, only the
&quot;foo&quot; part will match, as that is the first
alternative tried, and it successfully matches <br>
the target string. (This might not seem important, but it is
important when you are capturing matched text using
parentheses.)</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Also
remember that &quot;|&quot; is interpreted as a literal
within square brackets, so if you write
&quot;[fee|fie|foe]&quot; you&rsquo;re really only matching
&quot;[feio|]&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Within
a pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to
the nth subpattern later in the pattern using the <br>
metacharacter or 0. Subpatterns are numbered based on the
left to right order of their opening parenthesis. A
backreference matches whatever actually matched the <br>
subpattern in the string being examined, not the rules for
that subpattern. Therefore, &quot;(0|0x) **&quot; will match
&quot;0x1234 0x4321&quot;, butnot &quot;0x1234 01234&quot;,
because subpattern <br>
1 matched &quot;0x&quot;, even though the rule
&quot;0|0x&quot; could potentially match the leading 0 in
the second
number.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Warning
on 1 Instead of $1 <br>
Some people get too used to writing things
like:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>$pattern
=~
s/(W)/\1/g;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>This
is grandfathered (for 1 to 9) for the RHS of a substitute to
avoid shocking the sed addicts, but it&rsquo;s a dirty habit
to get into. That&rsquo;s because in PerlThink, the <br>
righthand side of an &quot;s///&quot; is a double-quoted
string. &quot;1&quot; in the usual double-quoted string
means a control-A. The customary Unix meaning of
&quot;1&quot; is kludged in for &quot;s///&quot;. <br>
However, if you get into the habit of doing that, you get
yourself into trouble if you then add an &quot;/e&quot;
modifier.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>s/(
+)/ 1 + 1 /eg;# causes warning under
-w</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Or
if you try to
do</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>s/(
+)/1000/;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>You
can&rsquo;t disambiguate that by saying &quot;1}000&quot;,
whereas you can fix it with &quot;${1}000&quot;. The
operation of interpolation should not be confused with the
operation of matching a <br>
backreference. Certainly they mean two different things on
the left side of the
&quot;s///&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Repeated
Patterns Matching a Zero-length Substring <br>
WARNING: Difficult material (and prose) ahead. This section
needs a
rewrite.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Regular
expressions provide a terse and powerful programming
language. As with most other power tools, power comes
together with the ability to wreak
havoc.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>A
common abuse of this power stems from the ability to make
infinite loops using regular expressions, with something as
innocuous
as:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&rsquo;foo&rsquo;
=~ m{ ( o? )*
}x;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>The
&quot;o?&quot; matches at the beginning of
&rsquo;foo&rsquo;, and since the position in the string is
not moved by the match, &quot;o?&quot; would match again and
again because of the &quot;*&quot; quantifier. <br>
Another common way to create a similar cycle is with the
looping modifier
&quot;//g&quot;:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>@matches
= ( &rsquo;foo&rsquo; =~ m{ o? }xg
);</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>or</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>print
&quot;match: &lt;$&amp;&gt;456 while &rsquo;foo&rsquo; =~ m{
o? }xg;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>or
the loop implied by
split().</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>However,
long experience has shown that many programming tasks may be
significantly simplified by using repeated subexpressions
that may match zero-length substrings. Here&rsquo;s a <br>
simple example
being:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>@chars
= split //, $string; # // is not magic in split <br>
($whitewashed = $string) =~ s/()/ /g; # parens avoid magic
s// /</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Thus
Perl allows such constructs, by forcefully breaking the
infinite loop. The rules for this are different for
lower-level loops given by the greedy quantifiers
&quot;*+{}&quot;, and <br>
for higher-level ones like the &quot;/g&quot; modifier or
split()
operator.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>The
lower-level loops are interrupted (that is, the loop is
broken) when Perl detects that a repeated expression matched
a zero-length substring.
Thus</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>m{
(?: NON_ZERO_LENGTH | ZERO_LENGTH )*
}x;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>is
made equivalent
to</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>m{
(?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )?
}x;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>For
example, this
program</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>#!perl
-l <br>
&quot;aaaaab&quot; =~ / <br>
(?: <br>
a # non-zero <br>
| # or <br>
(?{print &quot;hello&quot;}) # print hello whenever this
<br>
# branch is tried <br>
(?=(b)) # zero-width assertion <br>
)* # any number of times <br>
/x; <br>
print $&amp;; <br>
print
$1;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>prints</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>hello
<br>
aaaaa <br>
b</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Notice
that &quot;hello&quot; is only printed once, as when Perl
sees that the sixth iteration of the outermost
&quot;(?:)*&quot; matches a zero-length string, it stops the
&quot;*&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>The
higher-level loops preserve an additional state between
iterations: whether the last match was zero-length. To break
the loop, the following match after a zero-length match <br>
is prohibited to have a length of zero. This prohibition
interacts with backtracking (see &quot;Backtracking&quot;),
and so the second best match is chosen if the best match is
of zero <br>
length.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>For
example:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>$_
= &rsquo;bar&rsquo;; <br>

s/0/&lt;$&amp;&gt;/g;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>results
in
&quot;&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;&quot;.
At each position of the string the best match given by
non-greedy &quot;??&quot; is the zero-length match, and the
second best match is what is matched by <br>

&quot;2064</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Similarly,
for repeated &quot;m/()/g&quot; the second-best match is the
match at the position one notch further in the
string.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>The
additional state of being matched with zero-length is
associated with the matched string, and is reset by each
assignment to pos(). Zero-length matches at the end of the
<br>
previous match are ignored during
&quot;split&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Combining
RE Pieces <br>
Each of the elementary pieces of regular expressions which
were described before (such as &quot;ab&quot; or &quot;)
could match at most one substring at the given position of
the input <br>
string. However, in a typical regular expression these
elementary pieces are combined into more complicated
patterns using combining operators &quot;ST&quot;,
&quot;S|T&quot;, &quot;S*&quot; etc. (in these <br>
examples &quot;S&quot; and &quot;T&quot; are regular
subexpressions).</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Such
combinations can include alternatives, leading to a problem
of choice: if we match a regular expression &quot;a|ab&quot;
against &quot;abc&quot;, will it match substring
&quot;a&quot; or &quot;ab&quot;? One way <br>
to describe which substring is actually matched is the
concept of backtracking (see &quot;Backtracking&quot;).
However, this description is too low-level and makes you
think in terms of a <br>
particular
implementation.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Another
description starts with notions of
&quot;better&quot;/&quot;worse&quot;. All the substrings
which may be matched by the given regular expression can be
sorted from the &quot;best&quot; match to the <br>
&quot;worst&quot; match, and it is the &quot;best&quot;
match which is chosen. This substitutes the question of
&quot;what is chosen?&quot; by the question of &quot;which
matches are better, and which are <br>

worse?&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Again,
for elementary pieces there is no such question, since at
most one match at a given position is possible. This section
describes the notion of better/worse for combining <br>
operators. In the description below &quot;S&quot; and
&quot;T&quot; are regular
subexpressions.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;ST&quot;
<br>
Consider two possible matches, &quot;AB&quot; and
&quot;A&rsquo;B&rsquo;&quot;, &quot;A&quot; and
&quot;A&rsquo;&quot; are substrings which can be matched by
&quot;S&quot;, &quot;B&quot; and &quot;B&rsquo;&quot; are
substrings which can be matched by
&quot;T&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>If
&quot;A&quot; is a better match for &quot;S&quot; than
&quot;A&rsquo;&quot;, &quot;AB&quot; is a better match than
&quot;A&rsquo;B&rsquo;&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>If
&quot;A&quot; and &quot;A&rsquo;&quot; coincide:
&quot;AB&quot; is a better match than &quot;AB&rsquo;&quot;
if &quot;B&quot; is a better match for &quot;T&quot; than
&quot;B&rsquo;&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;S|T&quot;
<br>
When &quot;S&quot; can match, it is a better match than when
only &quot;T&quot; can
match.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Ordering
of two matches for &quot;S&quot; is the same as for
&quot;S&quot;. Similar for two matches for
&quot;T&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;S{REPEAT_COUNT}&quot;
<br>
Matches as &quot;SSS...S&quot; (repeated as many times as
necessary).</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;S{min,max}&quot;
<br>
Matches as
&quot;S{max}|S{max-1}|...|S{min+1}|S{min}&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;S{min,max}?&quot;
<br>
Matches as
&quot;S{min}|S{min+1}|...|S{max-1}|S{max}&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;S?&quot;,
&quot;S*&quot;, &quot;S+&quot; <br>
Same as &quot;S{0,1}&quot;, &quot;S{0,BIG_NUMBER}&quot;,
&quot;S{1,BIG_NUMBER}&quot;
respectively.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;S??&quot;,
&quot;S*?&quot;, &quot;S+?&quot; <br>
Same as &quot;S{0,1}?&quot;, &quot;S{0,BIG_NUMBER}?&quot;,
&quot;S{1,BIG_NUMBER}?&quot;
respectively.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(?&gt;S)&quot;
<br>
Matches the best match for &quot;S&quot; and only
that.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(?=S)&quot;,
&quot;(?&lt;=S)&quot; <br>
Only the best match for &quot;S&quot; is considered. (This
is important only if &quot;S&quot; has capturing
parentheses, and backreferences are used somewhere else in
the whole regular <br>

expression.)</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(?!S)&quot;,
&quot;(?&lt;!S)&quot; <br>
For this grouping operator there is no need to describe the
ordering, since only whether or not &quot;S&quot; can match
is
important.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(??{
EXPR })&quot;, &quot;(?PARNO)&quot; <br>
The ordering is the same as for the regular expression which
is the result of EXPR, or the pattern contained by capture
group
PARNO.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(?(condition)yes-pattern|no-pattern)&quot;
<br>
Recall that which of &quot;yes-pattern&quot; or
&quot;no-pattern&quot; actually matches is already
determined. The ordering of the matches is the same as for
the chosen
subexpression.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>The
above recipes describe the ordering of matches at a given
position. One more rule is needed to understand how a match
is determined for the whole regular expression: a match <br>
at an earlier position is always better than a match at a
later
position.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Creating
Custom RE Engines <br>
As of Perl 5.10.0, one can create custom regular expression
engines. This is not for the faint of heart, as they have to
plug in at the C level. See perlreapi for more
details.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>As
an alternative, overloaded constants (see overload) provide
a simple way to extend the functionality of the RE engine,
by substituting one pattern for
another.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Suppose
that we want to enable a new RE escape-sequence &quot;&quot;
which matches at a boundary between whitespace characters
and non-whitespace characters. Note that <br>
&quot;(?=(?&lt;!|(?!(?&lt;=&quot; matches exactly at these
positions, so we want to have each &quot;&quot; in the place
of the more complicated version. We can create a module
&quot;customre&quot; <br>
to do
this:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>package
customre; <br>
use
overload;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>sub
import { <br>
shift; <br>
die &quot;No argument to customre::import allowed&quot; if
@_; <br>
overload::constant &rsquo;qr&rsquo; =&gt; convert; <br>
}</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>sub
invalid { die &quot;/$_[0]/: invalid escape
&rsquo;\$_[1]&rsquo;&quot;}</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>#
We must also take care of not escaping the legitimate \Y|
<br>
# sequence, hence the presence of &rsquo;\&rsquo; in the
conversion rules. <br>
my %rules = ( &rsquo;\&rsquo; =&gt; &rsquo;\\&rsquo;, <br>
&rsquo;Y|&rsquo; =&gt; qr/(?=(?&lt;!|(?!(?&lt;=/ ); <br>
sub convert { <br>
my $re = shift; <br>
$re =~ s{ <br>
\ ( \ | Y . ) <br>
} <br>
{ $rules{$1} or invalid($re,$1) }sgex; <br>
return $re; <br>
}</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Now
&quot;use customre&quot; enables the new escape in constant
regular expressions, i.e., those without any runtime
variable interpolations. As documented in overload, this
conversion <br>
will work only over literal parts of regular expressions.
For &quot;$re&quot; the variable part of this regular
expression needs to be converted explicitly (but only if the
special <br>
meaning of &quot;&quot; should be enabled inside
$re):</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>use
customre; <br>
$re = &lt;&gt;; <br>
chomp $re; <br>
$re = customre::convert $re; <br>
/$re/;</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>PCRE/Python
Support <br>
As of Perl 5.10.0, Perl supports several
Python/PCRE-specific extensions to the regex syntax. While
Perl programmers are encouraged to use the Perl-specific
syntax, the following <br>
are also
accepted:</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(?P&lt;NAME&gt;pattern)&quot;
<br>
Define a named capture group. Equivalent to
&quot;(?&lt;NAME&gt;pattern)&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(?P=NAME)&quot;
<br>
Backreference to a named capture group. Equivalent to
&quot;0NAME}&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;(?P&gt;NAME)&quot;
<br>
Subroutine call to a named capture group. Equivalent to
&quot;(?&amp;NAME)&quot;.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>BUGS
<br>
Many regular expression constructs don&rsquo;t work on
EBCDIC
platforms.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>There
are a number of issues with regard to case-insensitive
matching in Unicode rules. See &quot;i&quot; under
&quot;Modifiers&quot;
above.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>This
document varies from difficult to understand to completely
and utterly opaque. The wandering prose riddled with jargon
is hard to fathom in several
places.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>This
document needs a rewrite that separates the tutorial content
from the reference
content.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>SEE
ALSO <br>

perlrequick.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>perlretut.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;Regexp
Quote-Like Operators&quot; in
perlop.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;Gory
details of parsing quoted constructs&quot; in
perlop.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>perlfaq6.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>&quot;pos&quot;
in
perlfunc.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>perllocale.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>perlebcdic.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>Mastering
Regular Expressions by Jeffrey Friedl, published by
O&rsquo;Reilly and
Associates.</big></big></big></big></big></big></big></big></p>


<p style="margin-top: 1em"><big><big><big><big><big><big><big><big>perl
v5.16.3 2013-03-04
PERLRE(1)</big></big></big></big></big></big></big></big></p>
<hr>
</body>
</html>
