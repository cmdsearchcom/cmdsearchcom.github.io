<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:10:18 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>flexc++(1) flexc++ scanner generator flexc++(1)</p>

<p style="margin-top: 1em">NAME <br>
flexc++ - Generate a C++ scanner class and parsing
function</p>

<p style="margin-top: 1em">SYNOPSIS <br>
flexc++ [options] rules-file</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Flexc++(1) was designed after flex(1) and flex++(1). Like
these latter two programs flexc++ generates code performing
pattern-matching on text, possibly executing actions when
<br>
certain regular expressions are recognized.</p>

<p style="margin-top: 1em">Flexc++, contrary to flex and
flex++, generates code that is explicitly intended for use
by C++ programs. The well-known flex(1) program generates C
source-code and flex++(1) <br>
merely offers a C++-like shell around the yylex function
generated by flex(1) and hardly supports present-day ideas
about C++ software development.</p>

<p style="margin-top: 1em">Contrary to this, flexc++
creates a C++ class offering a predefined member function
lex matching input against regular expressions and possibly
executing C++ code once regular <br>
expressions were matched. The code generated by flexc++ is
pure C++, allowing its users to apply all of the features
offered by that language.</p>

<p style="margin-top: 1em">Not every aspect of flexc++ is
covered by the man-pages. In addition to what&acirc;s
summarized by the man-pages the flexc++ manual offers a
chapter covering pre-loading of input lines <br>
(allowing you to, e.g, display lines in which errors are
observed even though not all of the line&acirc;s tokens have
already been scanned), as well as a chapter covering
technical <br>
documentation about the inner working of flexc++.</p>

<p style="margin-top: 1em">From version 0.92.00 Until
version 1.07.00 flexc++ offered one big manual page. The
advantage of that being that you never had to look for which
manual page contained which <br>
information. At the same time, flexc++&acirc;s man-page grew
into a huge man-page, in which it was hard to find your way.
Starting with release 1.08.00 we reverted back to using
multi&acirc; <br>
ple man-pages. The following index relates manual pages to
their specific contents:</p>

<p style="margin-top: 1em">This man-page</p>

<p style="margin-top: 1em">This man-page offers the
following sections:</p>

<p style="margin-top: 1em">o 1. QUICK START: a quick start
overview about how to use flexc++;</p>

<p style="margin-top: 1em">o 2. QUICK START: FLEXC++ and
BISONC++: a quick start overview about how to use flexc++ in
combination with bisonc++(1);</p>

<p style="margin-top: 1em">o 3. GENERATED FILES: files
generated by flexc++ and their purposes</p>

<p style="margin-top: 1em">o 4. OPTIONS: options available
for flexc++.</p>

<p style="margin-top: 1em">The flexc++api(3) man-page:</p>

<p style="margin-top: 1em">This man-page describes the
classes generated by flexc++, describing flexc++&acirc;s
actions from the programmer&acirc;s point of view.</p>

<p style="margin-top: 1em">o 1. INTERACTIVE SCANNERS: how
to create an interactive scanner</p>

<p style="margin-top: 1em">o 2. THE CLASS INTERFACE:
SCANNER.H: Constructors and members of the scanner class
generated by flexc++</p>

<p style="margin-top: 1em">o 3. NAMING CONVENTION: symbols
defined by flexc++ in the scanner class.</p>

<p style="margin-top: 1em">o 4. CONSTRUCTORS: constructors
defined in the scanner class.</p>

<p style="margin-top: 1em">o 5. PUBLIC MEMBER FUNCTION:
public member declared in the scanner class.</p>

<p style="margin-top: 1em">o 6. PRIVATE MEMBER FUNCTIONS:
private members declared in the scanner class.</p>

<p style="margin-top: 1em">o 7. SCANNER CLASS HEADER
EXAMPLE: an example of a generated scanner class header</p>

<p style="margin-top: 1em">o 8. THE SCANNER BASE CLASS: the
scanner class is derived from a base class. The base class
is described in this section</p>

<p style="margin-top: 1em">o 9. PUBLIC ENUMS AND -TYPES:
enums and types declared by the base class</p>

<p style="margin-top: 1em">o 10. PROTECTED ENUMS AND
-TYPES: enumerations and types used by the scanner and
scanner base classes</p>

<p style="margin-top: 1em">o 11. NO PUBLIC CONSTRUCTORS:
the scanner base class does not offer public
constructors.</p>

<p style="margin-top: 1em">o 12. PUBLIC MEMBER FUNCTIONS:
several members defined by the scanner base class have
public access rights.</p>

<p style="margin-top: 1em">o 13. PROTECTED CONSTRUCTORS:
the base class can be constructed by a derived class.
Usually this is the scanner class generated by flexc++.</p>

<p style="margin-top: 1em">o 14. PROTECTED MEMBER
FUNCTIONS: this section covers the base class member
functions that can only be used by scanner class or scanner
base class members</p>

<p style="margin-top: 1em">o 15. PROTECTED DATA MEMBERS:
this section covers the base class data members that can
only be used by scanner class or scanner base class
members</p>

<p style="margin-top: 1em">o 16. FLEX++ TO FLEXC++ MEMBERS:
a short overview of frequently used flex(1) members that
received different names in flexc++.</p>

<p style="margin-top: 1em">o 17. THE CLASS INPUT: the
scanner&acirc;s job is completely decoupled from the actual
input stream. The class Input, nested within the scanner
base class handles the communica&acirc; <br>
tion with the input streams. The class Input, is described
in this section.</p>

<p style="margin-top: 1em">o 18. INPUT CONSTRUCTORS: the
class Input can easily be replaced by another class. The
constructor-requirements are described in this section.</p>

<p style="margin-top: 1em">o 19. REQUIRED PUBLIC MEMBER
FUNCTIONS: this section covers the required public members
of a self-made Input class</p>

<p style="margin-top: 1em">The flexc++input(7)
man-page:</p>

<p style="margin-top: 1em">This man-page describes how
flexc++&acirc;s input s should be organized. It contains the
following sections:</p>

<p style="margin-top: 1em">o 1. SPECIFICATION FILE(S): the
format and contents of flexc++ input files, specifying the
Scanner&acirc;s characteristics</p>

<p style="margin-top: 1em">o 2. FILE SWITCHING: how to
switch to another input specification file</p>

<p style="margin-top: 1em">o 3. DIRECTIVES: directives that
can be used in input specification files</p>

<p style="margin-top: 1em">o 4. MINI SCANNERS: how to
declare mini-scanners</p>

<p style="margin-top: 1em">o 5. DEFINITIONS: how to define
symbolic names for regular expressions</p>

<p style="margin-top: 1em">o 6. %% SEPARATOR: the separator
between the input specification sections</p>

<p style="margin-top: 1em">o 7. REGULAR EXPRESSIONS:
regular expressions supported by flexc++</p>

<p style="margin-top: 1em">o 8. SPECIFICATION EXAMPLE: an
example of a specification file</p>

<p style="margin-top: 1em">1. QUICK START <br>
A bare-bones, no-frills scanner is generated as follows:</p>

<p style="margin-top: 1em">o Create a file lexer defining
the regular expressions to recognize, and the tokens to
return. Use token values exceeding 0xff if plain ascii
character values can also be <br>
used as token values. Example (assume capitalized words are
token-symbols defined in an enum defined by the scanner
class):</p>

<p style="margin-top: 1em">%% <br>
[ 0+ // skip white space chars. <br>
[0-9]+ return NUMBER; <br>
[[:alpha:]_][[:alpha:][:digit:]_]* return IDENTIFIER; <br>
. return matched()[0];</p>

<p style="margin-top: 1em">o Execute:</p>

<p style="margin-top: 1em">flexc++ lexer</p>

<p style="margin-top: 1em">This generates four
files:Scanner.h, Scanner.hh, Scannerbase.h, and lex.cc</p>

<p style="margin-top: 1em">o Edit Scanner.h, add the enum
defining the token-symbols in (usually) the public section
of the class Scanner. E.g.,</p>

<p style="margin-top: 1em">class Scanner: public
ScannerBase <br>
{ <br>
public: <br>
enum Tokens <br>
{ <br>
IDENTIFIER = 0x100, <br>
NUMBER <br>
}; <br>
// ... (etc, as generated by flexc++)</p>

<p style="margin-top: 1em">o Create a file defining int
main, e.g.:</p>

<p style="margin-top: 1em">#include &lt;iostream&gt; <br>
#include &quot;Scanner.h&quot;</p>

<p style="margin-top: 1em">using namespace std;</p>

<p style="margin-top: 1em">int main() <br>
{ <br>
Scanner scanner; // define a Scanner object</p>

<p style="margin-top: 1em">while (int token =
scanner.lex()) // get all tokens <br>
{ <br>
string const &amp;text = scanner.matched(); <br>
switch (token) <br>
{ <br>
case Scanner::IDENTIFIER: <br>
cout &lt;&lt; &quot;identifier: &quot; &lt;&lt; text
&lt;&lt; &acirc;0; <br>
break;</p>

<p style="margin-top: 1em">case Scanner::NUMBER: <br>
cout &lt;&lt; &quot;number: &quot; &lt;&lt; text &lt;&lt;
&acirc;0; <br>
break;</p>

<p style="margin-top: 1em">default: <br>
cout &lt;&lt; &quot;char. token: &lsquo;&quot; &lt;&lt; text
&lt;&lt; &quot;&acirc;0; <br>
break; <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">o Compile all .cc files:</p>

<p style="margin-top: 1em">g++ --std=c++11 *.cc</p>

<p style="margin-top: 1em">o To &lsquo;tokenize&acirc;
main.cc, execute:</p>

<p style="margin-top: 1em">a.out &lt; main.cc</p>

<p style="margin-top: 1em">)</p>

<p style="margin-top: 1em">2. QUICK START: FLEXC++ and
BISONC++ <br>
To interface flexc++ to the bisonc++(1) parser generator
proceed as follows:</p>

<p style="margin-top: 1em">o Specify a grammar that can be
processed by bisonc++(1). Assuming that the scanner and
parser are developed in, respectively, the sub-directories
scanner and parser, then a <br>
simple grammar specification that can be used with the
scanner developed in the previous section is, e.g., write
the file parser/grammar:</p>

<p style="margin-top: 1em">%scanner ../scanner/Scanner.h
<br>
%scanner-token-function d_scanner.lex()</p>

<p style="margin-top: 1em">%token IDENTIFIER NUMBER
CHAR</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">startrule: <br>
startrule tokenshow <br>
| <br>
tokenshow <br>
;</p>

<p style="margin-top: 1em">tokenshow: <br>
token <br>
{ <br>
std::cout &lt;&lt; &quot;matched: &quot; &lt;&lt;
d_scanner.matched() &lt;&lt; &acirc;0; <br>
} <br>
;</p>

<p style="margin-top: 1em">token: <br>
IDENTIFIER <br>
| <br>
NUMBER <br>
| <br>
CHAR <br>
;</p>

<p style="margin-top: 1em">o Write a scanner specification
file. E.g.,</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">[ 0+ // skip white space chars.
<br>
[0-9]+ return Parser::NUMBER; <br>
[[:alpha:]_][[:alpha:][:digit:]_]* return
Parser::IDENTIFIER; <br>
. return Parser::CHAR;</p>

<p style="margin-top: 1em">This causes the scanner to
return Parser tokens to the generated parser.</p>

<p style="margin-top: 1em">o Add the line</p>

<p style="margin-top: 1em">#include
&quot;../parser/Parserbase.h&quot;</p>

<p style="margin-top: 1em">to the file
scanner/Scanner.hh</p>

<p style="margin-top: 1em">o Write a simple main function
in the file main.cc. E.g.,</p>

<p style="margin-top: 1em">#include
&quot;parser/Parser.h&quot;</p>

<p style="margin-top: 1em">int main(int argc, char **argv)
<br>
{ <br>
Parser parser;</p>

<p style="margin-top: 1em">parser.parse(); <br>
}</p>

<p style="margin-top: 1em">o Generate a scanner in the
scanner subdirectory:</p>

<p style="margin-top: 1em">flexc++ lexer</p>

<p style="margin-top: 1em">o Generate a parser in the
parser subdirectory:</p>

<p style="margin-top: 1em">bisonc++ grammar</p>

<p style="margin-top: 1em">o Compile all sources:</p>

<p style="margin-top: 1em">g++ --std=c++0x *.cc */*.cc</p>

<p style="margin-top: 1em">o Execute the program, providing
it some source file to be processed:</p>

<p style="margin-top: 1em">a.out &lt; main.cc</p>

<p style="margin-top: 1em">3. GENERATED FILES <br>
Flexc++ generates four files from a well-formed input
file:</p>

<p style="margin-top: 1em">o A file containing the
implementation of the lex member function and its support
functions. By default this file is named lex.cc.</p>

<p style="margin-top: 1em">o A file containing the
scanner&acirc;s class interface. By default this file is
named Scanner.h. The scanner class itself is generated once
and is thereafter &lsquo;owned&acirc; by the pro&acirc; <br>
grammer, who may change it ad-lib. Newly added members (data
members, function members) will survive future flexc++ runs
as flexc++ will never rewrite an existing scanner <br>
class interface file, unless explicitly ordered to do
so.</p>

<p style="margin-top: 1em">o A file containing the
interface of the scanner class&acirc;s base class. The
scanner class is publicly derived from this base class. It
is used to minimize the size of the scan&acirc; <br>
ner interface itself. The scanner base class is
&lsquo;owned&acirc; by flexc++ and should never be
hand-modified. By default the scanner&acirc;s base class is
provided in the file Scanner&acirc; <br>
base.h. At each new flexc++ run this file is rewritten
unless flexc++ is explicitly ordered not to do so.</p>

<p style="margin-top: 1em">o A file containing the
implementation header. This file should contain includes and
declarations that are only required when compiling the
members of the scanner class. By <br>
default this file is named Scanner.hh. This file, like the
file containing the scanner class&acirc;s interface is never
rewritten by flexc++ unless flexc++ is explicitly ordered
<br>
to do so.</p>

<p style="margin-top: 1em">4. OPTIONS <br>
Where available, single letter options are listed between
parentheses following their associated long-option variants.
Single letter options require arguments if their associated
<br>
long options require arguments as well. Options affecting
the class header or implementation header file are ignored
if these files already exist. Options accepting a
&lsquo;filename&acirc; <br>
do not accept path names, i.e., they cannot contain
directory separators (/); options accepting a
&acirc;pathname&acirc; may contain directory separators.</p>

<p style="margin-top: 1em">Some options may generate
errors. This happens when an option conflicts with the
contents of an existing file which flexc++ cannot modify
(e.g., a scanner class header file <br>
exists, but doesn&acirc;t define a name space, but a
--namespace option was provided). To solve the error the
offending option could be omitted, the existing file could
be removed, or <br>
the existing file could be hand-edited according to the
option&acirc;s specification. Note that flexc++ currently
does not handle the opposite error condition: if a
previously used <br>
option is omitted, then flexc++ does not detect the
inconsistency. In those cases you may encounter compilation
errors.</p>

<p style="margin-top: 1em">o --baseclass-header=filename
(-b) <br>
Use filename as the name of the file to contain the scanner
class&acirc;s base class. Defaults to the name of the
scanner class plus base.h</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already existing scanner-class header file does
not include &lsquo;filename&acirc;.</p>

<p style="margin-top: 1em">o --baseclass-skeleton=pathname
(-C) <br>
Use pathname as the path to the file containing the skeleton
of the scanner class&acirc;s base class. Its filename
defaults to flexc++base.h.</p>

<p style="margin-top: 1em">o --case-insensitive <br>
Use this option to generate a scanner case insensitively
matching regular expressions. All regular expressions
specified in flexc++&acirc;s input file are interpreted case
<br>
insensitively and the resulting scanner object will case
insensitively interpret its input.</p>

<p style="margin-top: 1em">When this option is specified
the resulting scanner does not distinguish between the
following rules:</p>

<p style="margin-top: 1em">First // initial F is
transformed to f <br>
first <br>
FIRST // all capitals are transformed to lower case
chars</p>

<p style="margin-top: 1em">With a case-insensitive scanner
only the first rule can be matched, and flexc++ will issue
warnings for the second and third rule about rules that
cannot be matched.</p>

<p style="margin-top: 1em">Input processed by a
case-insensitive scanner is also handled case insensitively.
The above mentioned First rule is matched for all of the
following input words: first <br>
First FIRST firST.</p>

<p style="margin-top: 1em">Although the matching process
proceeds case insensitively, the matched text (as returned
by the scanner&acirc;s matched() member) always contains the
original, unmodified text. <br>
So, with the above input matched() returns, respectively
first, First, FIRST and firST, while matching the rule
First.</p>

<p style="margin-top: 1em">o --class-header=filename (-c)
<br>
Use filename as the name of the file to contain the scanner
class. Defaults to the name of the scanner class plus the
suffix .h</p>

<p style="margin-top: 1em">o --class-name=className <br>
Use className (rather than Scanner) as the name of the
scanner class. Unless overridden by other options generated
files will be given the (transformed to lower case) <br>
className* name instead of scanner*.</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already existing scanner-class header file does
not define class &lsquo;className&acirc;</p>

<p style="margin-top: 1em">o --class-skeleton=pathname (-C)
<br>
Use pathname as the path to the file containing the skeleton
of the scanner class. Its filename defaults to
flexc++.h.</p>

<p style="margin-top: 1em">o --construction (-K) <br>
Write details about the lexical scanner to the file
&lsquo;rules-file&acirc;.output. Details cover the used
character ranges, information about the regexes, the raw NFA
states, and <br>
the final DFAs.</p>

<p style="margin-top: 1em">o --debug (-d) <br>
Provide lex and its support functions with debugging code,
showing the actual parsing process on the standard output
stream. When included, the debugging output is active <br>
by default, but its activity may be controlled using the
setDebug(bool on-off) member. Note that #ifdef DEBUG macros
are not used anymore. By rerunning flexc++ without the <br>
--debug option an equivalent scanner is generated not
containing the debugging code. This option does not provide
debug information about flexc++ itself. For that use the
<br>
options --own-parser and/or --own-tokens (see below).</p>

<p style="margin-top: 1em">o --filenames=genericName (-f)
<br>
Generic name of generated files (header files, not the
lex-function source file, see the --lex-source option for
that). By default the header file names will be equal to
<br>
the name of the generated class.</p>

<p style="margin-top: 1em">o --help (-h) <br>
Write basic usage information to the standard output stream
and terminate.</p>

<p style="margin-top: 1em">o
--implementation-header=filename (-i) <br>
Use filename as the name of the file to contain the
implementation header. Defaults to the name of the generated
scanner class plus the suffix .hh. The implementation <br>
header should contain all directives and declarations only
used by the implementations of the scanner&acirc;s member
functions. It is the only header file that is included by
<br>
the source file containing lex()&acirc;s implementation.
User defined implementation of other class members may use
the same convention, thus concentrating all directives and
<br>
declarations that are required for the compilation of other
source files belonging to the scanner class in one header
file.</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already &acirc;filename&acirc; file does not
include the scanner class header file.</p>

<p style="margin-top: 1em">o
--implementation-skeleton=pathname (-I) <br>
Use pathname as the path to the file containing the skeleton
of the implementation header. Its filename defaults to
flexc++.hh.</p>

<p style="margin-top: 1em">o --lex-skeleton=pathname (-L)
<br>
Use pathname as the path to the file containing the lex()
member function&acirc;s skeleton. Its filename defaults to
flexc++.cc.</p>

<p style="margin-top: 1em">o --lex-function-name=funname
<br>
Use funname rather than lex as the name of the member
function performing the lexical scanning.</p>

<p style="margin-top: 1em">o --lex-source=filename (-l)
<br>
Define filename as the name of the source file to contain
the scanner member function lex. Defaults to lex.cc.</p>

<p style="margin-top: 1em">o --matched-rules
(-&acirc;R&acirc;) <br>
The generated scanner will write the numbers of matched
rules to the standard output. It is implied by the --debug
option. Displaying the matched rules can be suppressed <br>
by calling the generated scanner&acirc;s member
setDebug(false) (or, of course, by re-generating the scanner
without using specifying --matched-rules).</p>

<p style="margin-top: 1em">o --max-depth=depth (-m) <br>
Set the maximum inclusion depth of the lexical
scanner&acirc;s specification files to depth. By default the
maximum depth is set to 10. When more than depth
specification files <br>
are used the scanner throws a Max stream stack size exceeded
std::length_error exception.</p>

<p style="margin-top: 1em">o --namespace=identifier <br>
Define the scanner class in the namespace identifier. By
default no namespace is used. If this options is used the
implementation header is provided with a commented out <br>
using namespace declaration for the requested namespace. In
addition, the scanner and scanner base class header files
also use the specified namespace to define their <br>
include guard directives.</p>

<p style="margin-top: 1em">It is an error if this option is
used and an already scanner-class header file does not
define namespace identifier.</p>

<p style="margin-top: 1em">o --no-baseclass-header <br>
Do not write the file containing the scanner&acirc;s base
class interface even if it doesn&acirc;t yet exist. By
default the file containing the scanner&acirc;s base class
interface is <br>
(re)written each time flexc++ is called.</p>

<p style="margin-top: 1em">o --no-lines <br>
Do not put #line preprocessor directives in the file
containing the scanner&acirc;s lex function. By default
#line directives are entered at the beginning of the action
state&acirc; <br>
ments in the generated lex.cc file, allowing the compiler
and debuggers to associate errors with lines in your grammar
specification file, rather than with the source file <br>
containing the lex function itself.</p>

<p style="margin-top: 1em">o --no-lex-source <br>
Do not write the file containing the scanner&acirc;s
predefined scanner member functions, even if that file
doesn&acirc;t yet exist. By default the file containing the
scanner&acirc;s lex <br>
member function is (re)written each time flexc++ is called.
This option should normally be avoided, as this file
contains parsing tables which are altered whenever the <br>
grammar definition is modified.</p>

<p style="margin-top: 1em">o --own-parser (-P) <br>
The actions performed by flexc++&acirc;s own parser are
written to the standard output stream.</p>

<p style="margin-top: 1em">This option does not result in
the generated program optionally displaying the actions of
its lex function. If that is what you want, use the --debug
option.</p>

<p style="margin-top: 1em">o --own-tokens (-T) <br>
The tokens returned as well as the text matched by flexc++
are written to the standard output stream when this option
is used.</p>

<p style="margin-top: 1em">This option does not result in
the generated program displaying returned tokens and matched
text. If that is what you want, use the --print-tokens
option.</p>

<p style="margin-top: 1em">o --print-tokens (-t) <br>
The tokens returned as well as the text matched by the
generated lex function are displayed on the standard output
stream, just before returning the token to lex&acirc;s
caller. <br>
Displaying tokens and matched text is suppressed again when
the lex.cc file is generated without using this option. The
function showing the tokens (ScannerBase::print__) <br>
is called from Scanner::printTokens, which is defined
in-line in Scanner.h. Calling ScannerBase::print__,
therefore, can also easily be controlled by an option
controlled <br>
by the program using the scanner object.</p>

<p style="margin-top: 1em">This option does not show the
tokens returned and text matched by flexc++ itself when
reading its input s. If that is what you want, use the
--own-tokens option.</p>

<p style="margin-top: 1em">o --regex-calls <br>
Show the function call order when parsing regular
expressions (this option is normally not required. Its main
purpose is to help developers understand what happens when
<br>
regular expressions are parsed).</p>

<p style="margin-top: 1em">o --show-filenames (-F) <br>
Write the names of the files that are generated to the
standard error stream.</p>

<p style="margin-top: 1em">o --skeleton-directory=pathname
(-S) <br>
Defines the directory containing the skeleton files. This
option can be overridden by the specific skeleton-specifying
options (-B -C, -H, and -I).</p>

<p style="margin-top: 1em">o --target-directory=pathname
<br>
Specifies the directory where generated files should be
written. By default this is the directory where flexc++ is
called.</p>

<p style="margin-top: 1em">o --usage (-h) <br>
Write basic usage information to the standard output stream
and terminate.</p>

<p style="margin-top: 1em">o --verbose(-V) <br>
The verbose option generates on the standard output stream
various pieces of additional information, not covered by the
--construction and --show-filenames options.</p>

<p style="margin-top: 1em">o --version (-v) <br>
Display flexc++&acirc;s version number and terminate.</p>

<p style="margin-top: 1em">FILES <br>
Flexc++&acirc;s default skeleton files are in
/usr/share/flexc++. <br>
By default, flexc++ generates the following files:</p>

<p style="margin-top: 1em">o Scanner.h: the header file
containing the scanner class&acirc;s interface.</p>

<p style="margin-top: 1em">o Scannerbase.h: the header file
containing the interface of the scanner class&acirc;s base
class.</p>

<p style="margin-top: 1em">o Scanner.hh: the internal
header file that is meant to be included by the scanner
class&acirc;s source files (e.g., it is included by lex.cc,
see the next item&acirc;s file), and that <br>
should contain all declarations required for compiling the
scanner class&acirc;s sources.</p>

<p style="margin-top: 1em">o lex.cc: the source file
implementing the scanner class member function lex (and
support functions), performing the lexical scan.</p>

<p style="margin-top: 1em">SEE ALSO <br>
bisonc++(1), flexc++api(3), flexc++input(7)</p>

<p style="margin-top: 1em">BUGS <br>
None reported</p>

<p style="margin-top: 1em">ABOUT flexc++ <br>
Flexc++ was originally started as a programming project by
Jean-Paul van Oosten and Richard Berendsen in the 2007-2008
academic year. After graduating, Richard left the project
<br>
and moved to Amsterdam. Jean-Paul remained in Groningen, and
after on-and-off activities on the project, in close
cooperation with Frank B. Brokken, Frank undertook a rewrite
of <br>
the project&acirc;s code around 2010. During the development
of flexc++, the lookahead-operator handling continuously
threatened the completion of the project. By now, the
project has <br>
evolved to a level that we feel it&acirc;s defensible to
publish the program, although we still tend to consider the
program in its experimental stage; it will remain that way
until we <br>
decide to move its version from the 0.9x.xx series to the
1.xx.xx series.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
This is free software, distributed under the terms of the
GNU General Public License (GPL).</p>

<p style="margin-top: 1em">AUTHOR <br>
Frank B. Brokken (f.b.brokken@rug.nl), <br>
Jean-Paul van Oosten (j.p.van.oosten@rug.nl), <br>
Richard Berendsen (richardberendsen@xs4all.nl) (until
2010).</p>

<p style="margin-top: 1em">flexc++.2.05.00.tar.gz 2008-2016
flexc++(1)</p>
<hr>
</body>
</html>
