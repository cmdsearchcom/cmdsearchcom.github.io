<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_STATEMENTS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_STATEMENTS(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_STATEMENTS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp_statements -- Various statements in a makefile
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>A:</b>&#x00A0;autoload,&#x00A0; <b>B:</b>&#x00A0;build_cache,
<br/>
 build_check,&#x00A0; <b>D:</b>&#x00A0;&quot;define&quot;,&#x00A0;
  <b>E:</b>&#x00A0;export,&#x00A0; <b>G:</b>&#x00A0;global,&#x00A0;
  <b>I:</b>&#x00A0;ifdef,
<br/>
 ifeq,
<br/>
 ifmakeperl,
<br/>
 ifndef,
<br/>
 ifneq,
<br/>
 ifnsys,
<br/>
 ifntrue,
<br/>
 ifperl,
<br/>
 ifsys,
<br/>
 iftrue,
<br/>
 -include,
<br/>
 include,
<br/>
 _include,&#x00A0; <b>L:</b>&#x00A0;load_makefile,&#x00A0;
  <b>M:</b>&#x00A0;make,
<br/>
 makeperl,
<br/>
 makesub,&#x00A0; <b>N:</b>&#x00A0;&quot;no_implicit_load&quot;,&#x00A0;
  <b>P:</b>&#x00A0;perl,
<br/>
 &quot;perl_begin&quot;,
<br/>
 prebuild,&#x00A0; <b>R:</b>&#x00A0;register_command_parser,
<br/>
 register_input_suffix,
<br/>
 register_parser,
<br/>
 repository,
<br/>
 runtime,&#x00A0; <b>S:</b>&#x00A0;signature,
<br/>
 &quot;sub&quot;,&#x00A0; <b>V:</b>&#x00A0;vpath
<div class="Pp"></div>
A statement is any line beginning with a word which does not have a
  &quot;:&quot; in it. (A colon implies that the line is a rule.) For example,
  these are statements:
<div class="Pp"></div>
<pre>
    include extra_rules.mk
    load_makefile subdir
</pre>
<div class="Pp"></div>
Makepp has a number of builtin statements which you may occasionally need to
  use.
<div class="Pp"></div>
Note that wherever you see an underscore, you may also use a dash, because
  makepp converts dashes to underscores in statement names.
<h2 class="Ss" title="Ss" id="Conditionals"><a class="selflink" href="#Conditionals">Conditionals</a></h2>
Conditionals are special statements, which control what lines of the Makeppfile
  are actually seen. The simplest form (where &quot;ifxxx&quot; stands for any
  of the conditional statements documented below) is:
<div class="Pp"></div>
<pre>
    ifxxx ...
        lines seen if the statement evaluates as true
    endif
</pre>
<div class="Pp"></div>
or:
<div class="Pp"></div>
<pre>
    ifxxx ...
        lines seen if the statement evaluates as true
    else
        lines seen if the statement evaluates as false
    endif
</pre>
<div class="Pp"></div>
There is also the possibility to do complex combinations like this:
<div class="Pp"></div>
<pre>
    ifxxx ...
      and ifxxx ...
      and ifxxx ...
    or ifxxx ...
      and ifxxx ...
        lines seen if the combined statements evaluate as true
    else ifxxx ...
    or ifxxx ...
      and ifxxx ...
        lines seen if the first combination evaluates as false
        and these combined statements evaluate as true
    else
        lines seen if the statements above evaluate as false
    endif
</pre>
<div class="Pp"></div>
As is suggested by the indentation, <b></b><b>&quot;and&quot;</b><b></b> has
  higher precedence than <b></b><b>&quot;or&quot;</b><b></b>. In other words an
  <b></b><b>&quot;or&quot;</b><b></b> elects between two groups of
  <b></b><b>&quot;and&quot;</b> <b></b>`s. There may be any number of &quot;and
  ifxxx&quot;`s, &quot;or ifxxx&quot;`s and &quot;else ifxxx&quot;`s.
<div class="Pp"></div>
The &quot;ifxxx&quot; conditional statements are unique in that they may occur
  in the middle of rule actions, as in the above example, without disrupting the
  rule.
<dl class="Bl-tag">
  <dt class="It-tag">ifeq <i>string1, string2</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifneq <i>string1, string2</i></dt>
  <dd class="It-tag">
    <pre>
    ifeq ($(STR1),$(STR2))
       makefile lines if true
    else
       makefile lines if false
    endif
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If the two strings match exactly (except for leading or trailing
      whitespace), then the first set of lines is used; otherwise the second is
      used. The else clause is optional.
    <div style="height: 1.00em;">&#x00A0;</div>
    There are two other acceptable syntaxes for the &quot;ifeq&quot; and
      &quot;ifneq&quot; statements:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ifeq string1, string2
    ifeq string1 string2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    which are equivalent. Of course you can quote the strings as needed.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;ifeq&quot; and its friends &quot;ifneq&quot;, &quot;ifdef&quot;,
      &quot;ifndef&quot;, &quot;ifperl&quot;, &quot;ifmakeperl&quot;,
      &quot;ifsys&quot; and &quot;iftrue&quot; are primarily useful when you
      have to build a program under several different conditions. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    BUILD_TYPE := debug    # &quot;debug&quot; or &quot;production&quot;
 
    ifeq ($(BUILD_TYPE), debug)
      CFLAGS := -g
    else
      CFLAGS := -O2
    endif
 
    program : *.o
        $(CC) $(CFLAGS) $(inputs) -o $(output) $(LIBS)
    ifeq ($(BUILD_TYPE), production)
        strip $(output)
    endif
 
    %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If this is a production build, all files are compiled with the
      &quot;-O2&quot; option instead of the &quot;-g&quot; option. Furthermore,
      the program &quot;strip&quot; is run on the resulting binary (in case you
      happened to link with some libraries that were compiled in debug mode).
    <div style="height: 1.00em;">&#x00A0;</div>
    Sometimes it is easier to use the &quot;$(if)&quot; function or
      &quot;$(perl)&quot; function function instead of a &quot;ifeq&quot;
      statement.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you just want to see whether a symbol is blank or not, you only need to
      supply a single argument, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ifneq $(EXE_SUFFIX)
      # what to do if $(EXE_SUFFIX) is not blank
    endif
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifdef <i>VARIABLE ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifndef <i>VARIABLE ...</i></dt>
  <dd class="It-tag">These statements work analogously to the &quot;ifeq&quot;
      and &quot;ifneq&quot; statements, except that they test whether any of the
      variables is defined or not any is (i.e. none is defined). A variable is
      defined if:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">It was given a value with an assignment earlier in the
      makefile. See makepp_variables for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">It was given a value as a Perl variable in a
      &quot;perl_begin&quot; block.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The variable is present in the environment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The variable is present on the command line, e.g., to
      invoke your makefile, you typed
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    makepp CFLAGS=-O2
    </pre>
  </dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
For example,
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    ifndef CFLAGS
      CFLAGS := -g
    endif
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
In this case, &quot;CFLAGS&quot; is set to &quot;-g&quot; only if it wasn't
  already defined. Note that this statement could just as easily have been
  written using the &quot;?=&quot; assignment, like this:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    CFLAGS ?= -g
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">ifperl <i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifmakeperl <i>perlcode</i></dt>
  <dd class="It-tag">These statements work analogously to the &quot;ifeq&quot;
      and &quot;ifneq&quot; statements, except that the tests are in Perl. The
      first variant is plain Perl code, while the second variant first passes
      the statement through Make-style variable expansion.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    VERSION := 3.0
    # VERSION is automatically also a Perl variable:
    ifperl $VERSION &lt;= 2
      CPPFLAGS := -DNEW
    endif
    # quotes necessary for CFLAGS, because Perl sees only the value:
    ifmakeperl my $$x = '$(CFLAGS)'; $$x =~ /-g/
      CFLAGS := -g -O2
    endif
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifsys <i>wildcard ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifnsys <i>wildcard ...</i></dt>
  <dd class="It-tag">Tests if the current system makepp is running on matches
      any of the wildcards or not any (i.e. none).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ifsys i[3-6]86
      and ifsys Linux SunOS
      ...               # An Intel platform with Linux or Solaris
    else ifnsys sparc power*
      ...               # Nor Sparc or PowerPC
    endif
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    There are up to six different strings you can match against. The actual
      strings are not standardized. Three of them reflect what the Perl instance
      was built for (not necessarily the same as where it is running), and the
      others come from the system and all vary wildly in form. You can find all
      of what the current platform matches by typing the following command at
      the Shell:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    perl -MConfig -e'print &quot;$^O @Config{qw(archname myarchname)} &quot;'; uname -mps
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">iftrue <i>expression</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifntrue <i>expression</i></dt>
  <dd class="It-tag">Tests if the expression evaluates to some value other than
      zero or the empty string.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Other_Multiline_Statements"><a class="selflink" href="#Other_Multiline_Statements">Other
  Multiline Statements</a></h2>
Conditionals may control a whole multiline statement, but they cannot be inside
  such a statement.
<dl class="Bl-tag">
  <dt class="It-tag">define</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">{export|global|override}* define</dt>
  <dd class="It-tag">
    <pre>
    define VARIABLE [assignment-operator]
    variable value line 1
    variable value line 2
    endef
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Defines $(VARIABLE)'s value to be all the lines between the
      &quot;define&quot; statement and the &quot;endef&quot; statement. See
      multiline variables. The keywords &quot;export&quot; and
      &quot;global&quot; may not be given at the same time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">perl_begin</dt>
  <dd class="It-tag">This is the same as &quot;perl&quot;, but using GNU make
      style statement syntax. This statement introduces a block of code which is
      interpreted verbatim by perl. It can be useful for defining functions, but
      you can do this more concisely with the &quot;sub&quot; statement. A block
      of Perl code in your makefile can be useful to perform actions that are
      easier in Perl than with makepp functions and rules.
    <div style="height: 1.00em;">&#x00A0;</div>
    The remainder of the line following the &quot;perl_begin&quot; statement is
      ignored. All text up until a line that begins at the left margin with
      &quot;perl_end&quot; is sent verbatim to the perl interpreter. There can
      be no spaces before &quot;perl_end&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    One example that I use this for is to make directories that might not
      necessarily exist. It's common in makefiles to put all the .o files in a
      subdirectory (e.g., a directory with a name <i>i386</i>, or <i>sparc</i>,
      or something that depends on the machine type). But what if the directory
      does not exist yet? You can make each .o file depend on the subdirectory,
      and put a rule in to build the subdirectory. But it's a lot easier just to
      do this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    OBJDIR := $(ARCH)               # Where we put .o files.
    perl_begin
    -d $OBJDIR or mkdir $OBJDIR;    # Make sure the directory exists.
    perl_end
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This way, every time the makefile is run, the subdirectory will be created
      if it does not exist.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some operations are better expressed in terms of regular expressions than
      makepp's text functions. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    perl_begin
    if ($ARCH =~ /^i[56]86/) {          # You could do this with: ifsys i[56]86
      $CFLAGS = '-O6 -malign-double';   # On intel machines &gt; 486, there
                                        # is a substantial speed penalty
                                        # for doubles that aren't quadword
                                        # aligned.
    } else {
      $CFLAGS = '-O6';
    }
    perl_end
 
    %.o: %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Any make variable can be accessed directly as a Perl scalar. In this case,
      we've set the value of &quot;CFLAGS&quot; differently based on a regular
      expression match on the architecture flags.
    <div style="height: 1.00em;">&#x00A0;</div>
    As a final example, some pieces of information are easier to access directly
      from Perl than from makepp. For example, you can access all of the
      configuration information that perl knows about your system, including how
      to build shared libraries, etc. (Type &quot;perldoc&#x00A0;Config&quot; if
      you want to see what configuration information Perl has available.)
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    perl_begin
 
    use Config;
 
    $ARCH = $Config{'archname'};    # Use perl's knowledge of the architecture.
    $CC = $Config{'cc'};            # Use the same C compiler as Perl did.
    $SHARED_OBJ_CFLAGS = $Config{'cccdlflags'};
                                # Flags needed to compile objects which will
                                # go into a shared library.
    $SHARED_OBJ_LDFLAGS = $Config{'ccdlflags'} . &quot; &quot; . $Config{'lddlflags'};
                                # Linker flags to make a shared library.
    $SHARED_CC_LINK = $Config{'ld'}; # Command to produce shared libraries.
 
    $SHARED_EXTENSION = $Config{'dlext'}; # Extension of shared libraries.
    perl_end
 
    %.o: %.c
        $(CC) $(CFLAGS) $(SHARED_OBJ_CFLAGS) -c $(input) -o $(output)
 
    libmylib.$(DLEXT): *.o
        $(SHARED_CC_LINK) $(inputs) -o $(output) $(SHARED_OBJ_LDFLAGS)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note how we define a bunch of variables in the Perl block, and then we use
      them afterwards in the rest of the makefile. You can use the full power of
      the perl interpreter to set your variables in arbitrarily complicated
      ways. You can run shell commands from your Perl code, access a database,
      or whatever you want.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">perl <i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makeperl <i>perlcode</i></dt>
  <dd class="It-tag">This is the same as &quot;perl_begin&quot;, but using
      Perl-style braces. The first variant is plain Perl code, while the second
      variant first passes the statement through Make-style variable expansion.
      Note that the difficulty of parsing Perl's braces has lead to the
      following simple heuristic:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a double opening brace is found on the same or next
      line, a double closing brace will terminate the block. It must be at the
      beginning of a line, but may be preceded by whitespace.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Else, if the closing brace is at the very end of the
      &quot;perl&quot; line this is a one liner.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Otherwise the closing brace must be at the very beginning
      of a following line, i.e. no leading whitespace.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
For an efficient way to call Perl scripts, see &quot;run&quot;. Unlike the
  &quot;$(perl)&quot; function, the return value of this block is ignored.
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    perl { print &quot;passed this point in the makefile\n&quot; }
 
    perl
    {
      print &quot;and this one too\n&quot;;
    }
 
    ifdef NOISY
      perl {{
        print &quot;as well as this one\n&quot;
      }}
    endif
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
You can use the Perl debugger for your embedded code, by running makepp itself
  in the debugger, where ... are the arguments, if any, you normally pass:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    perl -d -S mpp ...
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
It is hard to set breakpoints in Perl code that has not been loaded. You can
  work around this by putting this line into your embedded Perl, just before
  where you want to break:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    $DB::single = 1;
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Then you can type &quot;c&quot; at the debugger's prompt, to continue till that
  point.</div>
<dl class="Bl-tag">
  <dt class="It-tag">sub</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makesub</dt>
  <dd class="It-tag">This statement provides a way to define a Perl subroutine
      inside your makefile. The first variant is plain Perl code, while the
      second variant first passes the statement through Make-style variable
      expansion. The syntax is identical to that of the Perl sub statement,
      except that prototypes are meaningless.
    <div style="height: 1.00em;">&#x00A0;</div>
    For the three possibilities of putting the braces of the body, see the
      explanation at the &quot;perl&quot; statement.
    <div style="height: 1.00em;">&#x00A0;</div>
    A Perl subroutine is invoked whenever a statement is seen, or when an
      expression like &quot;$(name&#x00A0;words)&quot; is seen. For example,
      suppose that for some reason you need to load the contents of a file into
      a make variable. (You could do this by saying
      &quot;$(shell&#x00A0;cat&#x00A0;filename)&quot; but it's possible to do it
      without ever invoking the shell.) This can be done by placing the
      following into your makefile:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub f_file_contents {
      my ($file) = @_;          # Name the argument.
      open my $fh, $file or die &quot;$file: $!\n&quot;;
      local $/ = undef;         # Slurp file in one read.
      &lt;$fh&gt;;
    }
 
    ifdef NEWSUB
      makesub f_VAR2
      {{
        $(VAR) * 2;
      }}
    endif
 
    makesub f_VAR1 { $(VAR) + 1 }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Now, with this function defined, you can write
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    X = $(file_contents filename) # equivalent to builtin $(&amp;cat filename)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and the variable &quot;$(X)&quot; will fetch the contents of the given file
      every time it gets expanded. Use &quot;:=&quot; to do this exactly once,
      or &quot;;=&quot; to do this at most once.
    <div style="height: 1.00em;">&#x00A0;</div>
    See makepp_extending for more details and examples.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Simple_Statements"><a class="selflink" href="#Simple_Statements">Simple
  Statements</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">autoload <i>filename ...</i></dt>
  <dd class="It-tag">Specifies one or more makefiles to load should an attempt
      to find a rule for a file in this directory otherwise fail. This is useful
      when the makefile has rules whose definitions depend (possibly indirectly)
      on a file in another directory that depends (possibly indirectly) on other
      files in this directory (built by rules that do <i>not</i> depend on the
      file in the other directory).
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, your <i>Makeppfile</i> might look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    rules-to-build-files-that-otherdir/x-depends-on
    more_rules.makeppfile: otherdir/x
        action-to-build-more_rules.makeppfile
    autoload more_rules.makeppfile
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that we cannot reliably replace &quot;autoload&quot; with
      &quot;include&quot; here, because if something other than the rule for
      <i>more_rules.makeppfile</i> tries to build <i>otherdir/x</i> first, then
      <i>more_rules.makeppfile</i> will probably fail because <i>otherdir/x</i>
      won't exist yet, because there is already an attempt to build it underway
      when <i>Makeppfile</i> is implicitly loaded on its behalf.
    <div style="height: 1.00em;">&#x00A0;</div>
    WARNING: Be very careful about doing things in an autoloaded makefile that
      change the behavior of rules in the directory's other makefile(s), as this
      will cause that behavior to depend on whether or not some previously built
      target caused makefiles to be autoloaded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">build_cache <i>/path/to/build/cache</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[global] build_cache <i>/path/to/build/cache</i></dt>
  <dd class="It-tag">Specifies a path to a build cache. See makepp_build_cache
      for details. The build cache must already exist; see &quot;How to manage a
      build cache&quot; in makepp_build_cache for how to make it in the first
      place. A &quot;build_cache&quot; statement in a makefile overrides the
      &quot;--build-cache&quot; command line option for rules in the makefile,
      but it may be overridden by the &quot;:build_cache&quot; rule modifier on
      a per-rule basis.
    <div style="height: 1.00em;">&#x00A0;</div>
    The keyword &quot;global&quot; may precede this statement with the same
      effect as the command line option, i.e. the build cache applies in every
      makefile. This should best be given in a <i>RootMakeppfile</i> to be
      certain it is seen early enough.
    <div style="height: 1.00em;">&#x00A0;</div>
    Specify &quot;none&quot; instead of a path to a directory if you want to
      disable the build cache for all rules in this makefile.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">build_check <i>build_check_method</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[global] build_check <i>build_check_method</i></dt>
  <dd class="It-tag">Specifies the default build check method for all rules in
      this makefile. See makepp_build_check for details. The
      &quot;build_check&quot; statement overrides the
      &quot;--build-check-method&quot; command line option for all rules in the
      makefile, but may be overridden by the &quot;:build_check&quot; modifier
      on a per-rule basis.
    <div style="height: 1.00em;">&#x00A0;</div>
    The keyword &quot;global&quot; may precede this statement with the same
      effect as the command line option, i.e. the build check method applies in
      every makefile which does not specify its own. This should best be given
      in a <i>RootMakeppfile</i> to be certain it is seen early enough.
    <div style="height: 1.00em;">&#x00A0;</div>
    Specify &quot;build_check&#x00A0;default&quot; instead of a name if you want
      to return to the default. With the keyword &quot;global&quot; this means
      the &quot;exact_match&quot; method, else this reverts the current makefile
      to not having its own specific method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">export <i>VAR ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">export <i>assignment</i></dt>
  <dd class="It-tag">
    <pre>
    export PATH := $(PWD):$(PATH)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Marks the given variables for export to subprocesses. See setting
    variables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">global <i>VAR ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">global <i>assignment</i></dt>
  <dd class="It-tag">
    <pre>
    global MYPROJECT.INFO = info to be seen in all makefiles
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Marks the given variables as global to all makefiles. See setting
    variables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">include <i>makefile</i></dt>
  <dd class="It-tag">This inserts the contents of another makefile into the
      current makefile. It can be useful if you have boilerplate files with a
      number of rules or variables, and each directory only needs to make a few
      modifications. The &quot;include&quot; statement also used to be commonly
      used in traditional makes in conjunction with automatic include file
      scanners, but this is no longer necessary with makepp.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;include&quot; first considers the current directory, then the parent
      of the current directory, then its parent, etc. It stops considering
      directories when it reaches the root of the file system or when the file
      system device ID changes. (This means that it will not find files located
      in other NFS mounts. This is to prevent problems with network file systems
      or automounters and dead servers.) If it does not find a file of the given
      name by the time its search is stopped, then it looks in the makepp data
      directory ( <i>/usr/local/share/makepp</i> if you installed makepp in
      <i>/usr/local</i>) for one of the include files that comes with makepp.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want to include a template file in every makefile in a whole
      directory hierarchy, you can place your makefile template at the top
      directory. The makefiles do not have to know exactly where they are in the
      hierarchy; each makefile can contain a line like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    include standard_definitions.mk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    instead of something more complicated, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    include ../../../standard_definitions.mk  # Is this the right number of ..?
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can specify as many files as you want, and variables are allowed:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    include file1 file2 file3 $(other_include_files)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you're working on a build that needs to work with both GNU make and
      makepp, sometimes it's convenient to have exactly identical makefiles but
      a different include file. For example, all of your makefiles may contain a
      line like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    include $(TOPDIR)/standard_rules.mk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and you want <i>standard_rules.mk</i> to be different for GNU make and
      makepp. To facilitate this, the &quot;include&quot; statement <b>first</b>
      looks for a file with the suffix of <i>.makepp</i> before looking for the
      file you asked for. In this case, it would first look for a file called
      <i>standard_rules.mk.makepp</i>, and if that exists, it would load it
      instead of <i>standard_rules.mk</i>. This way, when you run the makefile
      with GNU make, it loads <i>standard_rules.mk</i>, but with makepp, it
      loads <i>standard_rules.mk.makepp</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Because many legacy files put the rule to generate an include file after the
      include statement, makepp will defer decisions about inexistant or stale
      includes till the end of makefile loading. That is, unless it is invoked
      with &quot;--rm-stale&quot;. For as many times as the situation has
      improved by then (because a rule appeared) makepp will reload the
      makefile, which may again make more such rules appear. This is obviously
      an inefficient way to load makefiles, so try to avoid that. Worse, if your
      makefile loading has side-effects (like appending to a global variable or
      a line like &quot;do_it_now := $(shell cat a &gt;&gt;b)&quot; or its
      makepp equivalent &quot;&amp;cat a -o&gt;&gt;b&quot;) they will happen as
      many times as the makefile needs to be loaded, so, again, try to avoid
      that!</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">_include <i>makefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-include <i>makefile</i></dt>
  <dd class="It-tag">A minor variant on &quot;include&quot;, the
      &quot;_include&quot; statement includes the file if it exists but doesn't
      generate a fatal error if it does not. The &quot;_include&quot; statement
      used to be important for include file scanning with GNU make, but is less
      useful for makepp.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">load_makefile
    <i>/some/directory/somewhere/Makefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">load_makefile <i>subdir</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">load_makefile <i>VAR1=value1 VAR2=value2 subdir</i></dt>
  <dd class="It-tag">This statement causes makepp to cd to the directory
      containing the makefile and load its rules into makepp's internal
      database. If you specify just a directory instead of a makefile,
      &quot;load_makefile&quot; looks for &quot;Makeppfile&quot;,
      &quot;makefile&quot;, or &quot;Makefile&quot; in that directory.
    <div style="height: 1.00em;">&#x00A0;</div>
    Any variables you specify with the syntax &quot;VAR=value&quot; (or
      &quot;VAR=&quot;value1&#x00A0;value2&quot;&quot;) are passed to the loaded
      makefiles. They override any settings in those makefiles, just as if you
      had typed them on the command line.
    <div style="height: 1.00em;">&#x00A0;</div>
    Using &quot;load_makefile&quot; is different from the command
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    include dir/makefile
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    in two ways. First, &quot;load_makefile&quot; does not transfer any
      variables from the top-level makefile into the subordinate makefile; each
      makefile exists in its own namespace. The subordinate makefile cannot
      influence the variables in the top-level makefile in any way.
    <div style="height: 1.00em;">&#x00A0;</div>
    Second, each build command is tagged with the directory of the makefile that
      it came from. When makepp executes a rule from a different makefile, it
      first cd's to the directory containing that makefile before executing the
      command. Makefiles which are seen with the &quot;include&quot; statement
      are actually treated as part of the makefile that included them, and
      therefore their rules are not tagged with a different directory.
    <div style="height: 1.00em;">&#x00A0;</div>
    You usually do not have to load a makefile explicitly, unless it has an
      unusual name, or it has targets which are not contained in the same
      directory as the makefile itself, or you have disabled implicit makefile
      loading. By default, if makepp is trying to build a file and doesn't have
      a rule to build it, or if it is evaluating a wildcarded filename in a
      directory, it will automatically attempt to load a makefile from that
      directory. See &quot;Tips for multiple directories&quot; in
      makepp_cookbook for info on building with multiple directories.
    <div style="height: 1.00em;">&#x00A0;</div>
    You cannot use &quot;load_makefile&quot; to load several makefiles that
      apply to the same directory. Use &quot;include&quot; for several pieces of
      the makefile that apply to the same directory, and
      &quot;load_makefile&quot; for makefiles that apply to different
      directories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">no_implicit_load</dt>
  <dd class="It-tag">This statement turns off implicit loading of makefiles from
      a set of directories. This can be useful if you want to load makefiles
      automatically from most directories, but there are some directories which
      for various reasons you do not want makepp to attempt to update. (E.g.,
      maybe the directory has a makefile for some other version of make which
      makepp does not understand.) For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    no_implicit_load dir1 dir2/*
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The above statement will turn off implicit loading for makefiles in
      &quot;dir1&quot; <b>and all of its subdirectories</b>. It will also turn
      of implicit makefile loading for all subdirectories of &quot;dir2&quot;
      (and all of their subdirectories), but not for &quot;dir2&quot; itself.
    <div style="height: 1.00em;">&#x00A0;</div>
    You may use wildcards in the statement. Non-directory files that match the
      wildcard are ignored. You can also use functions to further specify the
      directories that you are interested in, e.g.,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    no_implicit_load $(filter-out dir1 dir2, *)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will turn off implicit loading for all subdirectories except <i>dir1</i> and
      <i>dir2</i> and their subdirectories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">prebuild <i>target</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">make <i>target</i></dt>
  <dd class="It-tag">The arguments (which undergo Make-style variable expansion)
      are built immediately. This is useful when the list of targets that the
      Makefile can build depends on a generated file in another directory.
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently, it will quietly fail to build targets if there is a dependency
      loop among the prebuilt targets and the Makefiles that must be loaded to
      build them, but that ought to be treated as an error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">register_command_parser <i>command_word parser</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">register_parser <i>command_word parser</i></dt>
  <dd class="It-tag">When lexically analyzing rule actions, use <i>parser</i>
      for <i>command_word</i>, which may be the full path or just the basename.
      The basename is usually enough because the lexer tries both.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>parser</i> may either be a classname with or without the leading
      &quot;Mpp::CommandParser::&quot;. Such a class must have a member function
      called &quot;factory&quot; that returns an object of that class. If the
      classname contains colons, it must be quoted, so as not make this line
      look like a rule.
    <div style="height: 1.00em;">&#x00A0;</div>
    Or, because that class is usually not yet loaded, instead the factory
      function may reside in the Makefile namespace. These functions have a
      prefix of &quot;p_&quot; which must not be given. This is the case of the
      builtin parsers.
    <div style="height: 1.00em;">&#x00A0;</div>
    The effect is comparable to the &quot;:parser&quot; rule option. But for
      multi-command rules this is the better way.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">register_input_suffix <i>command_word suffix ...</i></dt>
  <dd class="It-tag">Add &quot;suffix&quot; ... to the list of input file
      suffixes recognized when an action beginning with &quot;command_word&quot;
      is parsed. The parser would normally pick this up via
      Mpp::CommandParser::input_filename_regexp, but it might instead ignore
      this entirely.
    <div style="height: 1.00em;">&#x00A0;</div>
    Parsers don't normally pick up all the arguments that aren't recognized as
      options, because they might be arguments of unrecognized options. (For
      example, <i>i386v</i> is <i>not</i> an input file of the command &quot;gcc
      -b i386v foo.c&quot;.) Instead, they pick up only positional arguments
      that look like input filenames.
    <div style="height: 1.00em;">&#x00A0;</div>
    It is not unusual to use standard tools with site-specific nonstandard
      suffixes in order to signify that those files require special handling,
      such as different command options and/or postprocessing steps. For
      example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    register_input_suffix cpp .vpp
    %.v: %.vpp
        cpp $&lt; &gt; $@
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">repository <i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">repository <i>destdir=srcdir</i></dt>
  <dd class="It-tag">Specifies one or more repository directories. The first
      repository specified has precedence over the others if the same file
      exists in multiple repositories and there is no build command for it. See
      makepp_repositories for more details about repositories.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you specify just a directory after &quot;repository&quot;, its contents
      are linked into the current directory. You can link its contents into any
      arbitrary place in the file system by specifying the location before an
      equals sign, e.g,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    repository subdir1/subdir2=/users/joe/joes_nifty_library
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You should put the repository statement near the top of your makefile,
      before any rules that may need to use it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">runtime <i>program,library</i></dt>
  <dd class="It-tag">Store &quot;library&quot; as a runtime dependency of
      &quot;program&quot;. Both &quot;program&quot; and &quot;library&quot; may
      contain multiple words, in which case each word in &quot;library&quot; is
      stored as a runtime dependency of each word in &quot;program&quot;. When
      &quot;program&quot; is added automatically as the executable dependency of
      a command by the &quot;Mpp::CommandParser&quot; base class, its runtime
      dependencies (if any) are added as well. In order for this to happen,
      &quot;program&quot; must be specified in the rule with a directory
      component, and without any shell meta characters. The purpose of this
      statement is to capture dependencies on libraries and other executables
      that are often loaded by the program, without having to specify them
      explicitly as dependencies of each rule that invokes &quot;program&quot;,
      or to scan &quot;program&quot; to determine those dependencies (which
      could be prohibitively difficult.)
    <div style="height: 1.00em;">&#x00A0;</div>
    Runtime dependencies are traversed recursively, so if &quot;a&quot; has a
      runtime dependency on &quot;b&quot; and &quot;b&quot; has a runtime
      dependency on &quot;c&quot;, then any rule that uses &quot;./a&quot; will
      have implicit dependencies on both &quot;b&quot; and &quot;c&quot; (unless
      it uses a special &quot;Mpp::CommandParser&quot; class that overrides this
      behavior).
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that missing dependencies won't necessarily be added after you add this
      statement to a makefile, unless the rule is re-scanned. Use the
      &quot;--force-rescan&quot; command line option to ensure that this
      happens.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">signature <i>name</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[global] [override] signature <i>name</i></dt>
  <dd class="It-tag">
    <pre>
    signature md5
    signature C
    signature c_compilation_md5
    signature xml
    signature xml-space
    signature default
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Sets the signature method for all rules following the &quot;signature&quot;
      statement, for which no command parser chooses a method. You can override
      this for individual rules with the &quot;:signature&quot; rule modifier.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you add the keyword &quot;override&quot;, then this method will override
      even the the choice made by command parsers, but not those specified with
      the &quot;:signature&quot; rule modifier. If you add the keyword
      &quot;global&quot;, the effect applies to all rules yet to be read, unless
      their makefile also has its own &quot;signature&quot; statement. This is
      equivalent to the &quot;--signature&quot; command line option if given
      before any rule is read, e.g. in a <i>RootMakeppfile</i> to be certain it
      is seen early enough. Likewise the keywords &quot;global override&quot;
      for this statement are equivalent to the &quot;--override-signature&quot;
      command line option.
    <div style="height: 1.00em;">&#x00A0;</div>
    Specify &quot;signature&#x00A0;default&quot; instead of a name if you want
      to return to the default. With the keyword &quot;global&quot; this means
      the simple modification time and file size method. Else this reverts the
      current makefile to not having its own specific method, using a global
      method if one was set.
    <div style="height: 1.00em;">&#x00A0;</div>
    For more information about signature methods, see makepp_signatures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">vpath <i>pattern directory ...</i></dt>
  <dd class="It-tag">Fetch all files matching pattern from each given directory.
      Pattern may contain at most one &quot;%&quot; wildcard. This uses the
      transparent repository mechanism (unlike gmake which rewrites filenames),
      but it does not recurse into subdirectories.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Commands"><a class="selflink" href="#Commands">Commands</a></h2>
All builtin and self defined commands (see builtin commands and extending
  makepp), as well as external cleanly programmed Perl scripts can be used like
  statements. In this case they differ from rule actions in that they run in the
  same process as makepp and any input or output files are not noted as
  dependencies or as having been built by makepp.
<div class="Pp"></div>
As with all statements, they are considered as such, if they are indented less
  than the actions of the previous rule, if any.
<div class="Pp"></div>
This can be used for messages to be output while reading the makefile:
<div class="Pp"></div>
<pre>
    &amp;echo The value of $$(VAR) is $(VAR)
</pre>
<div class="Pp"></div>
Or instead of making many rules each depend on a directory creation rule, you
  can simply create it on the fly. Note that commands which create files are
  processed again every time the makefile is read., That's why we protect this
  one with a test -- though in this special case that would not be necessary, as
  this command would do no harm when repeated:
<div class="Pp"></div>
<pre>
    ifperl !-d 'include'
        &amp;mkdir -p include               # Create only if not present
    endif
</pre>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Gary Holt (holt-makepp@gholt.net)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
