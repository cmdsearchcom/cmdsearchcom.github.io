<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:22 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>jarsigner(1) General Commands Manual jarsigner(1)</p>

<p style="margin-top: 1em">NAME <br>
jarsigner - JAR Signing and Verification Tool</p>

<p style="margin-top: 1em">Generates signatures for Java
ARchive (JAR) files, and verifies the signatures of signed
JAR files.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
jarsigner [ options ] jar-file alias <br>
jarsigner -verify [ options ] jar-file</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The jarsigner tool is used for two purposes:</p>

<p style="margin-top: 1em">1. to sign Java ARchive (JAR)
files, and</p>

<p style="margin-top: 1em">2. to verify the signatures and
integrity of signed JAR files.</p>

<p style="margin-top: 1em">The JAR feature enables the
packaging of class files, images, sounds, and other digital
data in a single file for faster and easier distribution. A
tool named jar enables devel&acirc; <br>
opers to produce JAR files. (Technically, any zip file can
also be considered a JAR file, although when created by jar
or processed by jarsigner, JAR files also contain a <br>
META-INF/MANIFEST.MF file.)</p>

<p style="margin-top: 1em">A digital signature is a string
of bits that is computed from some data (the data being
&quot;signed&quot;) and the private key of an entity (a
person, company, etc.). Like a handwritten <br>
signature, a digital signature has many useful
characteristics:</p>

<p style="margin-top: 1em">o Its authenticity can be
verified, via a computation that uses the public key
corresponding to the private key used to generate the
signature.</p>

<p style="margin-top: 1em">o It cannot be forged, assuming
the private key is kept secret.</p>

<p style="margin-top: 1em">o It is a function of the data
signed and thus can&rsquo;t be claimed to be the signature
for other data as well.</p>

<p style="margin-top: 1em">o The signed data cannot be
changed; if it is, the signature will no longer verify as
being authentic.</p>

<p style="margin-top: 1em">In order for an entity&rsquo;s
signature to be generated for a file, the entity must first
have a public/private key pair associated with it, and also
one or more certificates authen&acirc; <br>
ticating its public key. A certificate is a digitally signed
statement from one entity, saying that the public key of
some other entity has a particular value.</p>

<p style="margin-top: 1em">jarsigner uses key and
certificate information from a keystore to generate digital
signatures for JAR files. A keystore is a database of
private keys and their associated X.509 <br>
certificate chains authenticating the corresponding public
keys. The keytool utility is used to create and administer
keystores.</p>

<p style="margin-top: 1em">jarsigner uses an entity&rsquo;s
private key to generate a signature. The signed JAR file
contains, among other things, a copy of the certificate from
the keystore for the public key <br>
corresponding to the private key used to sign the file.
jarsigner can verify the digital signature of the signed JAR
file using the certificate inside it (in its signature block
<br>
file).</p>

<p style="margin-top: 1em">Starting in J2SE 5.0, jarsigner
can generate signatures that include a timestamp, thus
enabling systems/deployer (including Java Plug-in) to check
whether the JAR file was signed <br>
while the signing certificate was still valid. In addition,
APIs were added in J2SE 5.0 to allow applications to obtain
the timestamp information.</p>

<p style="margin-top: 1em">At this time, jarsigner can only
sign JAR files created by the SDK jar tool or zip files.
(JAR files are the same as zip files, except they also have
a META-INF/MANIFEST.MF file. <br>
Such a file will automatically be created when jarsigner
signs a zip file.)</p>

<p style="margin-top: 1em">The default jarsigner behavior
is to sign a JAR (or zip) file. Use the -verify option to
instead have it verify a signed JAR file.</p>

<p style="margin-top: 1em">Compatibility with JDK 1.1 <br>
The keytool and jarsigner tools completely replace the
javakey tool provided in JDK 1.1. These new tools provide
more features than javakey, including the ability to protect
<br>
the keystore and private keys with passwords, and the
ability to verify signatures in addition to generating
them.</p>

<p style="margin-top: 1em">The new keystore architecture
replaces the identity database that javakey created and
managed. There is no backwards compatibility between the
keystore format and the database <br>
format used by javakey in 1.1. However,</p>

<p style="margin-top: 1em">o It is possible to import the
information from an identity database into a keystore, via
the keytool -identitydb command.</p>

<p style="margin-top: 1em">o jarsigner can sign JAR files
also previously signed using javakey.</p>

<p style="margin-top: 1em">o jarsigner can verify JAR files
signed using javakey. Thus, it recognizes and can work with
signer aliases that are from a JDK 1.1 identity database
rather than a Java 2 <br>
SDK keystore.</p>

<p style="margin-top: 1em">The following table explains how
JAR files that were signed in JDK 1.1.x are treated in the
Java 2 platform.</p>

<p style="margin-top: 1em">Notes:</p>

<p style="margin-top: 1em">1. If an identity/alias is
mentioned in the policy file, it must be imported into the
keystore for the policy file to have any effect on
privileges granted.</p>

<p style="margin-top: 1em">2. The policy file/keystore
combination has precedence over a trusted identity in the
identity database.</p>

<p style="margin-top: 1em">3. Untrusted identities are
ignored in the Java 2 platform.</p>

<p style="margin-top: 1em">4. Only trusted identities can
be imported into Java 2 SDK keystores.</p>

<p style="margin-top: 1em">Keystore Aliases <br>
All keystore entities are accessed via unique aliases.</p>

<p style="margin-top: 1em">When using jarsigner to sign a
JAR file, you must specify the alias for the keystore entry
containing the private key needed to generate the signature.
For example, the fol&acirc; <br>
lowing will sign the JAR file named
&quot;MyJARFile.jar&quot;, using the private key associated
with the alias &quot;duke&quot; in the keystore named
&quot;mystore&quot; in the &quot;working&quot; directory.
Since <br>
no output file is specified, it overwrites MyJARFile.jar
with the signed JAR file.</p>

<p style="margin-top: 1em">jarsigner -keystore
/working/mystore -storepass myspass <br>
-keypass dukekeypasswd MyJARFile.jar duke</p>

<p style="margin-top: 1em">Keystores are protected with a
password, so the store password (in this case
&quot;myspass&quot;) must be specified. You will be prompted
for it if you don&rsquo;t specify it on the command <br>
line. Similarly, private keys are protected in a keystore
with a password, so the private key&rsquo;s password (in
this case &quot;dukekeypasswd&quot;) must be specified, and
you will be <br>
prompted for it if you don&rsquo;t specify it on the command
line and it isn&rsquo;t the same as the store password.</p>

<p style="margin-top: 1em">Keystore Location <br>
jarsigner has a -keystore option for specifying the URL of
the keystore to be used. The keystore is by default stored
in a file named .keystore in the user&rsquo;s home
directory, <br>
as determined by the user.home system property. On Solaris
systems user.home defaults to the user&rsquo;s home
directory.</p>

<p style="margin-top: 1em">Note that the input stream from
the -keystore option is passed to the KeyStore.load method.
If NONE is specified as the URL, then a null stream is
passed to the KeyStore.load <br>
method. NONE should be specified if the KeyStore is not
file-based, for example, if it resides on a hardware token
device.</p>

<p style="margin-top: 1em">Keystore Implementation <br>
The KeyStore class provided in the java.security package
supplies well-defined interfaces to access and modify the
information in a keystore. It is possible for there to be
<br>
multiple different concrete implementations, where each
implementation is that for a particular type of
keystore.</p>

<p style="margin-top: 1em">Currently, there are two
command-line tools that make use of keystore implementations
(keytool and jarsigner), and also a GUI-based tool named
Policy Tool. Since KeyStore is <br>
publicly available, Java 2 SDK users can write additional
security applications that use it.</p>

<p style="margin-top: 1em">There is a built-in default
implementation, provided by Sun Microsystems. It implements
the keystore as a file, utilizing a proprietary keystore
type (format) named &quot;JKS&quot;. It <br>
protects each private key with its individual password, and
also protects the integrity of the entire keystore with a
(possibly different) password.</p>

<p style="margin-top: 1em">Keystore implementations are
provider-based. More specifically, the application
interfaces supplied by KeyStore are implemented in terms of
a &quot;Service Provider Interface&quot; <br>
(SPI). That is, there is a corresponding abstract
KeystoreSpi class, also in the java.security package, which
defines the Service Provider Interface methods that
&quot;providers&quot; <br>
must implement. (The term &quot;provider&quot; refers to a
package or a set of packages that supply a concrete
implementation of a subset of services that can be accessed
by the Java <br>
Security API.) Thus, to provide a keystore implementation,
clients must implement a provider and supply a KeystoreSpi
subclass implementation, as described in How to Implement
<br>
a Provider for the Java Cryptography Architecture @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/HowToImplAProvider.html.</p>

<p style="margin-top: 1em">Applications can choose
different types of keystore implementations from different
providers, using the &quot;getInstance&quot; factory method
supplied in the KeyStore class. A keystore <br>
type defines the storage and data format of the keystore
information, and the algorithms used to protect private keys
in the keystore and the integrity of the keystore itself.
<br>
Keystore implementations of different types are not
compatible.</p>

<p style="margin-top: 1em">keytool works on any file-based
keystore implementation. (It treats the keytore location
that is passed to it at the command line as a filename and
converts it to a FileInput&acirc; <br>
Stream, from which it loads the keystore information.) The
jarsigner and policytool tools, on the other hand, can read
a keystore from any location that can be specified using
<br>
a URL.</p>

<p style="margin-top: 1em">For jarsigner and keytool, you
can specify a keystore type at the command line, via the
-storetype option. For Policy Tool, you can specify a
keystore type via the &quot;Change <br>
Keystore&quot; command in the Edit menu.</p>

<p style="margin-top: 1em">If you don&rsquo;t explicitly
specify a keystore type, the tools choose a keystore
implementation based simply on the value of the
keystore.type property specified in the security <br>
properties file. The security properties file is called
java.security, and it resides in the SDK security properties
directory, java.home/lib/security, where java.home is the
<br>
runtime environment&rsquo;s directory (the jre directory in
the SDK or the top-level directory of the Java 2 Runtime
Environment).</p>

<p style="margin-top: 1em">Each tool gets the keystore.type
value and then examines all the currently-installed
providers until it finds one that implements keystores of
that type. It then uses the key&acirc; <br>
store implementation from that provider.</p>

<p style="margin-top: 1em">The KeyStore class defines a
static method named getDefaultType that lets applications
and applets retrieve the value of the keystore.type
property. The following line of code <br>
creates an instance of the default keystore type (as
specified in the keystore.type property):</p>

<p style="margin-top: 1em">KeyStore keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</p>

<p style="margin-top: 1em">The default keystore type is
&quot;jks&quot; (the proprietary type of the keystore
implementation provided by Sun). This is specified by the
following line in the security properties <br>
file:</p>

<p style="margin-top: 1em">keystore.type=jks</p>

<p style="margin-top: 1em">Note: Case doesn&rsquo;t matter
in keystore type designations. For example, &quot;JKS&quot;
would be considered the same as &quot;jks&quot;.</p>

<p style="margin-top: 1em">To have the tools utilize a
keystore implementation other than the default, change that
line to specify a different keystore type. For example, if
you have a provider package <br>
that supplies a keystore implementation for a keystore type
called &quot;pkcs12&quot;, change the line to</p>

<p style="margin-top: 1em">keystore.type=pkcs12</p>

<p style="margin-top: 1em">Note that if you us the PKCS#11
provider package, you should refer to the KeyTool and
JarSigner @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html#keytooljarsigner
section of the Java PKCS#11 Reference Guide for details.</p>

<p style="margin-top: 1em">Supported Algorithms <br>
By default, jarsigner signs a JAR file using either</p>

<p style="margin-top: 1em">o DSA (Digital Signature
Algorithm) with the SHA-1 digest algorithm, or</p>

<p style="margin-top: 1em">o the RSA algorithm with the MD5
digest algorithm.</p>

<p style="margin-top: 1em">That is, if the signer&rsquo;s
public and private keys are DSA keys, jarsigner will sign
the JAR file using the &quot;SHA1withDSA&quot; algorithm. If
the signer&rsquo;s keys are RSA keys, jarsigner <br>
will attempt to sign the JAR file using the
&quot;MD5withRSA&quot; algorithm.</p>

<p style="margin-top: 1em">These default signature
algorithms can be overridden using the -sigalg option.</p>

<p style="margin-top: 1em">The Signed JAR File <br>
When jarsigner is used to sign a JAR file, the output signed
JAR file is exactly the same as the input JAR file, except
that it has two additional files placed in the META-INF <br>
directory:</p>

<p style="margin-top: 1em">o a signature file, with a .SF
extension, and</p>

<p style="margin-top: 1em">o a signature block file, with a
.DSA extension.</p>

<p style="margin-top: 1em">The base file names for these
two files come from the value of the -sigFile option. For
example, if the option appears as</p>

<p style="margin-top: 1em">-sigFile MKSIGN</p>

<p style="margin-top: 1em">the files are named
&quot;MKSIGN.SF&quot; and &quot;MKSIGN.DSA&quot;.</p>

<p style="margin-top: 1em">If no -sigfile option appears on
the command line, the base file name for the .SF and .DSA
files will be the first 8 characters of the alias name
specified on the command <br>
line, all converted to upper case. If the alias name has
fewer than 8 characters, the full alias name is used. If the
alias name contains any characters that are not allowed <br>
in a signature file name, each such character is converted
to an underscore (&quot;_&quot;) character in forming the
file name. Legal characters include letters, digits,
underscores, <br>
and hyphens.</p>

<p style="margin-top: 1em">The Signature (.SF) File</p>

<p style="margin-top: 1em">A signature file (the .SF file)
looks similar to the manifest file that is always included
in a JAR file when jarsigner is used to sign the file. That
is, for each source <br>
file included in the JAR file, the .SF file has three lines,
just as in the manifest file, listing the following:</p>

<p style="margin-top: 1em">o the file name,</p>

<p style="margin-top: 1em">o the name of the digest
algorithm used (SHA), and</p>

<p style="margin-top: 1em">o a SHA digest value.</p>

<p style="margin-top: 1em">In the manifest file, the SHA
digest value for each source file is the digest (hash) of
the binary data in the source file. In the .SF file, on the
other hand, the digest <br>
value for a given source file is the hash of the three lines
in the manifest file for the source file.</p>

<p style="margin-top: 1em">The signature file also, by
default, includes a header containing a hash of the whole
manifest file. The presence of the header enables
verification optimization, as <br>
described in JAR File Verification.</p>

<p style="margin-top: 1em">The Signature Block (.DSA)
File</p>

<p style="margin-top: 1em">The .SF file is signed and the
signature is placed in the .DSA file. The .DSA file also
contains, encoded inside it, the certificate or certificate
chain from the keystore <br>
which authenticates the public key corresponding to the
private key used for signing.</p>

<p style="margin-top: 1em">Signature Timestamp <br>
As of the J2SE 5.0 release, the jarsigner tool can now
generate and store a signature timestamp when signing a JAR
file. In addition, jarsigner supports alternative signing
<br>
mechanisms. This behavior is optional and is controlled by
the user at the time of signing through these options:</p>

<p style="margin-top: 1em">o -tsa url</p>

<p style="margin-top: 1em">o -tsacert alias</p>

<p style="margin-top: 1em">o -altsigner class</p>

<p style="margin-top: 1em">o -altsignerpath
classpathlist</p>

<p style="margin-top: 1em">Each of these options is
detailed in the Options section below.</p>

<p style="margin-top: 1em">JAR File Verification <br>
A successful JAR file verification occurs if the
signature(s) are valid, and none of the files that were in
the JAR file when the signatures were generated have been
changed <br>
since then. JAR file verification involves the following
steps:</p>

<p style="margin-top: 1em">1. Verify the signature of the
.SF file itself.</p>

<p style="margin-top: 1em">That is, the verification
ensures that the signature stored in each signature block
(.DSA) file was in fact generated using the private key
corresponding to the public key <br>
whose certificate (or certificate chain) also appears in the
.DSA file. It also ensures that the signature is a valid
signature of the corresponding signature (.SF) file, <br>
and thus the .SF file has not been tampered with.</p>

<p style="margin-top: 1em">2. Verify the digest listed in
each entry in the .SF file with each corresponding section
in the manifest.</p>

<p style="margin-top: 1em">The .SF file by default includes
a header containing a hash of the entire manifest file. When
the header is present, then the verification can check to
see whether or not <br>
the hash in the header indeed matches the hash of the
manifest file. If that is the case, verification proceeds to
the next step.</p>

<p style="margin-top: 1em">If that is not the case, a less
optimized verification is required to ensure that the hash
in each source file information section in the .SF file
equals the hash of its <br>
corresponding section in the manifest file (see The
Signature (.SF) File).</p>

<p style="margin-top: 1em">One reason the hash of the
manifest file that is stored in the .SF file header may not
equal the hash of the current manifest file would be because
one or more files were <br>
added to the JAR file (using the jar tool) after the
signature (and thus the .SF file) was generated. When the
jar tool is used to add files, the manifest file is changed
<br>
(sections are added to it for the new files), but the .SF
file is not. A verification is still considered successful
if none of the files that were in the JAR file when the <br>
signature was generated have been changed since then, which
is the case if the hashes in the non-header sections of the
.SF file equal the hashes of the corresponding sec&acirc;
<br>
tions in the manifest file.</p>

<p style="margin-top: 1em">3. Read each file in the JAR
file that has an entry in the .SF file. While reading,
compute the file&rsquo;s digest, and then compare the result
with the digest for this file in <br>
the manifest section. The digests should be the same, or
verification fails.</p>

<p style="margin-top: 1em">If any serious verification
failures occur during the verification process, the process
is stopped and a security exception is thrown. It is caught
and displayed by jarsigner.</p>

<p style="margin-top: 1em">Multiple Signatures for a JAR
File <br>
A JAR file can be signed by multiple people simply by
running the jarsigner tool on the file multiple times,
specifying the alias for a different person each time, as
in:</p>

<p style="margin-top: 1em">jarsigner myBundle.jar susan
<br>
jarsigner myBundle.jar kevin</p>

<p style="margin-top: 1em">When a JAR file is signed
multiple times, there are multiple .SF and .DSA files in the
resulting JAR file, one pair for each signature. Thus, in
the example above, the output <br>
JAR file includes files with the following names:</p>

<p style="margin-top: 1em">SUSAN.SF <br>
SUSAN.DSA <br>
KEVIN.SF <br>
KEVIN.DSA</p>

<p style="margin-top: 1em">Note: It is also possible for a
JAR file to have mixed signatures, some generated by the JDK
1.1 javakey tool and others by jarsigner. That is, jarsigner
can be used to sign <br>
JAR files already previously signed using javakey.</p>

<p style="margin-top: 1em">OPTIONS <br>
The various jarsigner options are listed and described
below. Note:</p>

<p style="margin-top: 1em">o All option names are preceded
by a minus sign (-).</p>

<p style="margin-top: 1em">o The options may be provided in
any order.</p>

<p style="margin-top: 1em">o Items in italics (option
values) represent the actual values that must be
supplied.</p>

<p style="margin-top: 1em">o The -keystore, -storepass,
-keypass, -sigfile, -sigalg, -digestalg, and -signedjar
options are only relevant when signing a JAR file, not when
verifying a signed JAR file. <br>
Similarly, an alias is only specified on the command line
when signing a JAR file.</p>

<p style="margin-top: 1em">-keystore url <br>
Specifies the URL that tells the keystore location. This
defaults to the file .keystore in the user&rsquo;s home
directory, as determined by the &quot;user.home&quot; system
property.</p>

<p style="margin-top: 1em">A keystore is required when
signing, so you must explicitly specify one if the default
keystore does not exist (or you want to use one other than
the default).</p>

<p style="margin-top: 1em">A keystore is not required when
verifying, but if one is specified, or the default exists,
and the -verbose option was also specified, additional
information is output regard&acirc; <br>
ing whether or not any of the certificates used to verify
the JAR file are contained in that keystore.</p>

<p style="margin-top: 1em">Note: the -keystore argument can
actually be a file name (and path) specification rather than
a URL, in which case it will be treated the same as a
&quot;file:&quot; URL. That is, <br>
-keystore filePathAndName <br>
is treated as equivalent to <br>
-keystore file:filePathAndName <br>
If the Sun PKCS#11 provider has been configured in the
java.security security properties file (located in the
JRE&rsquo;s $JAVA_HOME/lib/security directory), then keytool
and jar&acirc; <br>
signer can operate on the PKCS#11 token by specifying these
options:</p>

<p style="margin-top: 1em">o -keystore NONE</p>

<p style="margin-top: 1em">o -storetype PKCS11 <br>
For example, this command lists the contents of the
configured PKCS#11 token:</p>

<p style="margin-top: 1em">jarsigner -keystore NONE
-storetype PKCS11 -list</p>

<p style="margin-top: 1em">-storetype storetype <br>
Specifies the type of keystore to be instantiated. The
default keystore type is the one that is specified as the
value of the &quot;keystore.type&quot; property in the
security prop&acirc; <br>
erties file, which is returned by the static getDefaultType
method in java.security.KeyStore.</p>

<p style="margin-top: 1em">The PIN for a PCKS#11 token can
also be specified using the -storepass option. If none has
been specified, keytool and jarsigner will prompt for the
token PIN. If the token <br>
has a protected authentication path (such as a dedicated
PIN-pad or a biometric reader), then the -protected option
must be specified and no password options can be
specified.</p>

<p style="margin-top: 1em">-storepass password <br>
Specifies the password which is required to access the
keystore. This is only needed when signing (not verifying) a
JAR file. In that case, if a -storepass option is not <br>
provided at the command line, the user is prompted for the
password.</p>

<p style="margin-top: 1em">Note: The password
shouldn&rsquo;t be specified on the command line or in a
script unless it is for testing purposes, or you are on a
secure system. Also, when typing in a password <br>
at the password prompt, the password is echoed (displayed
exactly as typed), so be careful not to type it in front of
anyone.</p>

<p style="margin-top: 1em">-keypass password <br>
Specifies the password used to protect the private key of
the keystore entry addressed by the alias specified on the
command line. The password is required when using jar&acirc;
<br>
signer to sign a JAR file. If no password is provided on the
command line, and the required password is different from
the store password, the user is prompted for it.</p>

<p style="margin-top: 1em">Note: The password
shouldn&rsquo;t be specified on the command line or in a
script unless it is for testing purposes, or you are on a
secure system. Also, when typing in a password <br>
at the password prompt, the password is echoed (displayed
exactly as typed), so be careful not to type it in front of
anyone.</p>

<p style="margin-top: 1em">-sigfile file <br>
Specifies the base file name to be used for the generated
.SF and .DSA files. For example, if file is
&quot;DUKESIGN&quot;, the generated .SF and .DSA files will
be named &quot;DUKE&acirc; <br>
SIGN.SF&quot; and &quot;DUKESIGN.DSA&quot;, and will be
placed in the &quot;META-INF&quot; directory of the signed
JAR file.</p>

<p style="margin-top: 1em">The characters in file must come
from the set &quot;a-zA-Z0-9_-&quot;. That is, only letters,
numbers, underscore, and hyphen characters are allowed.
Note: All lowercase characters will <br>
be converted to uppercase for the .SF and .DSA file
names.</p>

<p style="margin-top: 1em">If no -sigfile option appears on
the command line, the base file name for the .SF and .DSA
files will be the first 8 characters of the alias name
specified on the command <br>
line, all converted to upper case. If the alias name has
fewer than 8 characters, the full alias name is used. If the
alias name contains any characters that are not legal in
<br>
a signature file name, each such character is converted to
an underscore (&quot;_&quot;) character in forming the file
name.</p>

<p style="margin-top: 1em">-sigalg algorithm</p>

<p style="margin-top: 1em">Specifies the name of the
signature algorithm to use to sign the JAR file.</p>

<p style="margin-top: 1em">See Appendix A @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#appa
of the Java Cryptography Architecture for a list of standard
signature algorithm <br>
names. This algorithm must be compatible with the private
key used to sign the JAR file. If this option is not
specified, SHA1withDSA or MD5withRSA will be used depending
<br>
on the type of private key. There must either be a
statically installed provider supplying an implementation of
the specified algorithm or the user must specify one with
<br>
the -providerClass option, otherwise the command will not
succeed.</p>

<p style="margin-top: 1em">-digestalg algorithm <br>
Specifies the name of the message digest algorithm to use
when digesting the entries of a jar file.</p>

<p style="margin-top: 1em">See Appendix A @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#appa
of the Java Cryptography Architecture for a list of standard
message digest algo&acirc; <br>
rithm names. If this option is not specified, SHA-1 will be
used. There must either be a statically installed provider
supplying an implementation of the specified algo&acirc;
<br>
rithm or the user must specify one with the -providerClass
option, otherwise the command will not succeed.</p>

<p style="margin-top: 1em">-signedjar file <br>
Specifies the name to be used for the signed JAR file.</p>

<p style="margin-top: 1em">If no name is specified on the
command line, the name used is the same as the input JAR
file name (the name of the JAR file to be signed); in other
words, that file is over&acirc; <br>
written with the signed JAR file.</p>

<p style="margin-top: 1em">-verify <br>
If this appears on the command line, the specified JAR file
will be verified, not signed. If the verification is
successful, &quot;jar verified&quot; will be displayed. If
you try to <br>
verify an unsigned JAR file, or a JAR file signed with an
unsupported algorithm (e.g., RSA when you don&rsquo;t have
an RSA provider installed), the following is displayed:
&quot;jar <br>
is unsigned. (signatures missing or not parsable)&quot;</p>

<p style="margin-top: 1em">It is possible to verify JAR
files signed using either jarsigner or the JDK 1.1 javakey
tool, or both.</p>

<p style="margin-top: 1em">For further information on
verification, see JAR File Verification.</p>

<p style="margin-top: 1em">-certs <br>
If this appears on the command line, along with the -verify
and -verbose options, the output includes certificate
information for each signer of the JAR file. This
informa&acirc; <br>
tion includes</p>

<p style="margin-top: 1em">o the name of the type of
certificate (stored in the .DSA file) that certifies the
signer&rsquo;s public key</p>

<p style="margin-top: 1em">o if the certificate is an X.509
certificate (more specifically, an instance of
java.security.cert.X509Certificate): the distinguished name
of the signer</p>

<p style="margin-top: 1em">The keystore is also examined.
If no keystore value is specified on the command line, the
default keystore file (if any) will be checked. If the
public key certificate for a <br>
signer matches an entry in the keystore, then the following
information will also be displayed:</p>

<p style="margin-top: 1em">o in parentheses, the alias name
for the keystore entry for that signer. If the signer
actually comes from a JDK 1.1 identity database instead of
from a keystore, the alias <br>
name will appear in brackets instead of parentheses.</p>

<p style="margin-top: 1em">-verbose <br>
If this appears on the command line, it indicates
&quot;verbose&quot; mode, which causes jarsigner to output
extra information as to the progress of the JAR signing or
verification.</p>

<p style="margin-top: 1em">-internalsf <br>
In the past, the .DSA (signature block) file generated when
a JAR file was signed used to include a complete encoded
copy of the .SF file (signature file) also generated. <br>
This behavior has been changed. To reduce the overall size
of the output JAR file, the .DSA file by default
doesn&rsquo;t contain a copy of the .SF file anymore. But if
-inter&acirc; <br>
nalsf appears on the command line, the old behavior is
utilized. This option is mainly useful for testing; in
practice, it should not be used, since doing so eliminates a
<br>
useful optimization.</p>

<p style="margin-top: 1em">-sectionsonly <br>
If this appears on the command line, the .SF file (signature
file) generated when a JAR file is signed does not include a
header containing a hash of the whole manifest <br>
file. It just contains information and hashes related to
each individual source file included in the JAR file, as
described in The Signature (.SF) File .</p>

<p style="margin-top: 1em">By default, this header is
added, as an optimization. When the header is present, then
whenever the JAR file is verified, the verification can
first check to see whether or <br>
not the hash in the header indeed matches the hash of the
whole manifest file. If so, verification proceeds to the
next step. If not, it is necessary to do a less optimized
<br>
verification that the hash in each source file information
section in the .SF file equals the hash of its corresponding
section in the manifest file.</p>

<p style="margin-top: 1em">For further information, see JAR
File Verification.</p>

<p style="margin-top: 1em">This option is mainly useful for
testing; in practice, it should not be used, since doing so
eliminates a useful optimization.</p>

<p style="margin-top: 1em">-protected <br>
Either true or false. This value should be specified as true
if a password must be given via a protected authentication
path such as a dedicated PIN reader.</p>

<p style="margin-top: 1em">-provider provider-class-name
<br>
Used to specify the name of cryptographic service
provider&rsquo;s master class file when the service provider
is not listed in the security properties file,
java.security.</p>

<p style="margin-top: 1em">Used in conjunction with the
-providerArg ConfigFilePath option, keytool and jarsigner
will install the provider dynamically (where ConfigFilePath
is the path to the token <br>
configuration file). Here&rsquo;s an example of a command to
list a PKCS#11 keystore when the Sun PKCS#11 provider has
not been configured in the security properties file.</p>

<p style="margin-top: 1em">jarsigner -keystore NONE
-storetype PKCS11 -providerClass
sun.security.pkcs11.SunPKCS11 -providerArg
/foo/bar/token.config -list</p>

<p style="margin-top: 1em">-providerName providerName <br>
If more than one provider has been configured in the
java.security security properties file, you can use the
-providerName option to target a specific provider instance.
<br>
The argument to this option is the name of the provider.</p>

<p style="margin-top: 1em">For the Sun PKCS#11 provider,
providerName is of the form SunPKCS11-TokenName, where
TokenName is the name suffix that the provider instance has
been configured with, as <br>
detailed in the configuration attributes table @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html#KeyToolJarSigner#ATTRS.
For example, the following command lists the contents of the
PKCS#11 keystore <br>
provider instance with name suffix SmartCard:</p>

<p style="margin-top: 1em">jarsigner -keystore NONE
-storetype PKCS11 -providerName SunPKCS11-SmartCard
-list</p>

<p style="margin-top: 1em">-Jjavaoption <br>
Passes through the specified javaoption string directly to
the Java interpreter. (jarsigner is actually a
&quot;wrapper&quot; around the interpreter.) This option
should not contain <br>
any spaces. It is useful for adjusting the execution
environment or memory usage. For a list of possible
interpreter options, type java -h or java -X at the command
line.</p>

<p style="margin-top: 1em">-tsa url <br>
If &quot;-tsa http://example.tsa.url&quot; appears on the
command line when signing a JAR file then a timestamp is
generated for the signature. The URL,
http://example.tsa.url, iden&acirc; <br>
tifies the location of the Time Stamping Authority (TSA). It
overrides any URL found via the -tsacert option. The -tsa
option does not require the TSA&rsquo;s public key
certifi&acirc; <br>
cate to be present in the keystore.</p>

<p style="margin-top: 1em">To generate the timestamp,
jarsigner communicates with the TSA using the Time-Stamp
Protocol (TSP) defined in RFC 3161 @ <br>
http://www.ietf.org/rfc/rfc3161.txt. If successful, the
timestamp token returned by the TSA is stored along with the
signature in the signature block file.</p>

<p style="margin-top: 1em">-tsacert alias <br>
If &quot;-tsacert alias&quot; appears on the command line
when signing a JAR file then a timestamp is generated for
the signature. The alias identifies the TSA&rsquo;s public
key certifi&acirc; <br>
cate in the keystore that is currently in effect. The
entry&rsquo;s certificate is examined for a Subject
Information Access extension that contains a URL identifying
the loca&acirc; <br>
tion of the TSA.</p>

<p style="margin-top: 1em">The TSA&rsquo;s public key
certificate must be present in the keystore when using
-tsacert.</p>

<p style="margin-top: 1em">-altsigner class <br>
Specifies that an alternative signing mechanism be used. The
fully-qualified class name identifies a class file that
extends the com.sun.jarsigner.ContentSigner abstract <br>
class. The path to this class file is defined by the
-altsignerpath option. If the -altsigner option is used,
jarsigner uses the signing mechanism provided by the
specified <br>
class. Otherwise, jarsigner uses its default signing
mechanism.</p>

<p style="margin-top: 1em">For example, to use the signing
mechanism provided by a class named
com.sun.sun.jarsigner.AuthSigner, use the jarsigner option
&quot;-altsigner com.sun.jarsigner.AuthSigner&quot;</p>

<p style="margin-top: 1em">-altsignerpath classpathlist
<br>
Specifies the path to the class file (the class file name is
specified with the -altsigner option described above) and
any JAR files it depends on. If the class file is in <br>
a JAR file, then this specifies the path to that JAR file,
as shown in the example below.</p>

<p style="margin-top: 1em">An absolute path or a path
relative to the current directory may be specified. If
classpathlist contains multiple paths or JAR files, they
should be separated with a colon (:) <br>
on Solaris and a semi-colon (;) on Windows. This option is
not necessary if the class is already in the search
path.</p>

<p style="margin-top: 1em">Example of specifying the path
to a jar file that contains the class file:</p>

<p style="margin-top: 1em">-altsignerpath
/home/user/lib/authsigner.jar</p>

<p style="margin-top: 1em">Note that the JAR file name is
included.</p>

<p style="margin-top: 1em">Example of specifying the path
to the jar file that contains the class file:</p>

<p style="margin-top: 1em">-altsignerpath
/home/user/classes/com/sun/tools/jarsigner/</p>

<p style="margin-top: 1em">Note that the JAR file name is
omitted.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Signing a JAR File <br>
Suppose you have a JAR file named &quot;bundle.jar&quot; and
you&rsquo;d like to sign it using the private key of the
user whose keystore alias is &quot;jane&quot; in the
keystore named &quot;mystore&quot; in <br>
the &quot;working&quot; directory. Suppose the keystore
password is &quot;myspass&quot; and the password for
jane&rsquo;s private key is &quot;j638klm&quot;. You can use
the following to sign the JAR file and <br>
name the signed JAR file &quot;sbundle.jar&quot;:</p>

<p style="margin-top: 1em">jarsigner -keystore
/working/mystore -storepass myspass <br>
-keypass j638klm -signedjar sbundle.jar bundle.jar jane</p>

<p style="margin-top: 1em">Note that there is no -sigfile
specified in the command above, so the generated .SF and
.DSA files to be placed in the signed JAR file will have
default names based on the <br>
alias name. That is, they will be named JANE.SF and
JANE.DSA.</p>

<p style="margin-top: 1em">If you want to be prompted for
the store password and the private key password, you could
shorten the above command to</p>

<p style="margin-top: 1em">jarsigner -keystore
/working/mystore <br>
-signedjar sbundle.jar bundle.jar jane</p>

<p style="margin-top: 1em">If the keystore to be used is
the default keystore (the one named &quot;.keystore&quot; in
your home directory), you don&rsquo;t need to specify a
keystore, as in:</p>

<p style="margin-top: 1em">jarsigner -signedjar sbundle.jar
bundle.jar jane</p>

<p style="margin-top: 1em">Finally, if you want the signed
JAR file to simply overwrite the input JAR file
(bundle.jar), you don&rsquo;t need to specify a -signedjar
option:</p>

<p style="margin-top: 1em">jarsigner bundle.jar jane</p>

<p style="margin-top: 1em">Verifying a Signed JAR File <br>
To verify a signed JAR file, that is, to verify that the
signature is valid and the JAR file has not been tampered
with, use a command such as the following:</p>

<p style="margin-top: 1em">jarsigner -verify
sbundle.jar</p>

<p style="margin-top: 1em">If the verification is
successful,</p>

<p style="margin-top: 1em">jar verified.</p>

<p style="margin-top: 1em">is displayed. Otherwise, an
error message appears.</p>

<p style="margin-top: 1em">You can get more information if
you use the -verbose option. A sample use of jarsigner with
the -verbose option is shown below, along with sample
output:</p>

<p style="margin-top: 1em">jarsigner -verify -verbose
sbundle.jar</p>

<p style="margin-top: 1em">198 Fri Sep 26 16:14:06 PDT 1997
META-INF/MANIFEST.MF <br>
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA <br>
smk 2752 Fri Sep 26 16:12:30 PDT 1997 AclEx.class <br>
smk 849 Fri Sep 26 16:12:46 PDT 1997 test.class</p>

<p style="margin-top: 1em">s = signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore</p>

<p style="margin-top: 1em">jar verified.</p>

<p style="margin-top: 1em">Verification with Certificate
Information <br>
If you specify the -certs option when verifying, along with
the -verify and -verbose options, the output includes
certificate information for each signer of the JAR file,
includ&acirc; <br>
ing the certificate type, the signer distinguished name
information (iff it&rsquo;s an X.509 certificate), and, in
parentheses, the keystore alias for the signer if the public
key cer&acirc; <br>
tificate in the JAR file matches that in a keystore entry.
For example,</p>

<p style="margin-top: 1em">jarsigner -keystore
/working/mystore -verify -verbose -certs myTest.jar</p>

<p style="margin-top: 1em">198 Fri Sep 26 16:14:06 PDT 1997
META-INF/MANIFEST.MF <br>
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA <br>
208 Fri Sep 26 16:23:30 PDT 1997 META-INF/JAVATEST.SF <br>
1087 Fri Sep 26 16:23:30 PDT 1997 META-INF/JAVATEST.DSA <br>
smk 2752 Fri Sep 26 16:12:30 PDT 1997 Tst.class</p>

<p style="margin-top: 1em">X.509, CN=Test Group, OU=Java
Software, O=Sun Microsystems, L=CUP, S=CA, C=US (javatest)
<br>
X.509, CN=Jane Smith, OU=Java Software, O=Sun, L=cup, S=ca,
C=us (jane)</p>

<p style="margin-top: 1em">s = signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore</p>

<p style="margin-top: 1em">jar verified.</p>

<p style="margin-top: 1em">If the certificate for a signer
is not an X.509 certificate, there is no distinguished name
information. In that case, just the certificate type and the
alias are shown. For <br>
example, if the certificate is a PGP certificate, and the
alias is &quot;bob&quot;, you&rsquo;d get</p>

<p style="margin-top: 1em">PGP, (bob)</p>

<p style="margin-top: 1em">Verification of a JAR File that
Includes Identity Database Signers <br>
If a JAR file has been signed using the JDK 1.1 javakey
tool, and thus the signer is an alias in an identity
database, the verification output includes an &quot;i&quot;
symbol. If the JAR <br>
file has been signed by both an alias in an identity
database and an alias in a keystore, both &quot;k&quot; and
&quot;i&quot; appear.</p>

<p style="margin-top: 1em">When the -certs option is used,
any identity database aliases are shown in square brackets
rather than the parentheses used for keystore aliases. For
example:</p>

<p style="margin-top: 1em">jarsigner -keystore
/working/mystore -verify -verbose -certs writeFile.jar</p>

<p style="margin-top: 1em">198 Fri Sep 26 16:14:06 PDT 1997
META-INF/MANIFEST.MF <br>
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA <br>
199 Fri Sep 27 12:22:30 PDT 1997 META-INF/DUKE.SF <br>
1013 Fri Sep 27 12:22:30 PDT 1997 META-INF/DUKE.DSA <br>
smki 2752 Fri Sep 26 16:12:30 PDT 1997 writeFile.html</p>

<p style="margin-top: 1em">X.509, CN=Jane Smith, OU=Java
Software, O=Sun, L=cup, S=ca, C=us (jane) <br>
X.509, CN=Duke, OU=Java Software, O=Sun, L=cup, S=ca, C=us
[duke]</p>

<p style="margin-top: 1em">s = signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore <br>
i = at least one certificate was found in identity scope</p>

<p style="margin-top: 1em">jar verified.</p>

<p style="margin-top: 1em">Note that the alias
&quot;duke&quot; is in brackets to denote that it is an
identity database alias, not a keystore alias.</p>

<p style="margin-top: 1em">SEE ALSO <br>
o jar tool documentation</p>

<p style="margin-top: 1em">o keytool tool documentation</p>

<p style="margin-top: 1em">o the Security @ <br>

http://java.sun.com/docs/books/tutorial/security1.2/index.html
trail of the Java Tutorial @ <br>
http://java.sun.com/docs/books/tutorial/trailmap.html for
examples of the use of the jarsigner tool</p>

<p style="margin-top: 1em">07 Aug 2006 jarsigner(1)</p>
<hr>
</body>
</html>
