<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLGIT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLGIT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLGIT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlgit - Detailed information about git and the Perl repository
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document provides details on using git to develop Perl. If you are just
  interested in working on a quick patch, see perlhack first. This document is
  intended for people who are regular contributors to Perl, including those with
  write access to the git repository.
<h1 class="Sh" title="Sh" id="CLONING_THE_REPOSITORY"><a class="selflink" href="#CLONING_THE_REPOSITORY">CLONING
  THE REPOSITORY</a></h1>
All of Perl's source code is kept centrally in a Git repository at
  <i>perl5.git.perl.org</i>.
<div class="Pp"></div>
You can make a read-only clone of the repository by running:
<div class="Pp"></div>
<pre>
  % git clone git://perl5.git.perl.org/perl.git perl
</pre>
<div class="Pp"></div>
This uses the git protocol (port 9418).
<div class="Pp"></div>
If you cannot use the git protocol for firewall reasons, you can also clone via
  http, though this is much slower:
<div class="Pp"></div>
<pre>
  % git clone http://perl5.git.perl.org/perl.git perl
</pre>
<h1 class="Sh" title="Sh" id="WORKING_WITH_THE_REPOSITORY"><a class="selflink" href="#WORKING_WITH_THE_REPOSITORY">WORKING
  WITH THE REPOSITORY</a></h1>
Once you have changed into the repository directory, you can inspect it. After a
  clone the repository will contain a single local branch, which will be the
  current branch as well, as indicated by the asterisk.
<div class="Pp"></div>
<pre>
  % git branch
  * blead
</pre>
<div class="Pp"></div>
Using the -a switch to &quot;branch&quot; will also show the remote tracking
  branches in the repository:
<div class="Pp"></div>
<pre>
  % git branch -a
  * blead
    origin/HEAD
    origin/blead
  ...
</pre>
<div class="Pp"></div>
The branches that begin with &quot;origin&quot; correspond to the &quot;git
  remote&quot; that you cloned from (which is named &quot;origin&quot;). Each
  branch on the remote will be exactly tracked by these branches. You should
  NEVER do work on these remote tracking branches. You only ever do work in a
  local branch. Local branches can be configured to automerge (on pull) from a
  designated remote tracking branch. This is the case with the default branch
  &quot;blead&quot; which will be configured to merge from the remote tracking
  branch &quot;origin/blead&quot;.
<div class="Pp"></div>
You can see recent commits:
<div class="Pp"></div>
<pre>
  % git log
</pre>
<div class="Pp"></div>
And pull new changes from the repository, and update your local repository (must
  be clean first)
<div class="Pp"></div>
<pre>
  % git pull
</pre>
<div class="Pp"></div>
Assuming we are on the branch &quot;blead&quot; immediately after a pull, this
  command would be more or less equivalent to:
<div class="Pp"></div>
<pre>
  % git fetch
  % git merge origin/blead
</pre>
<div class="Pp"></div>
In fact if you want to update your local repository without touching your
  working directory you do:
<div class="Pp"></div>
<pre>
  % git fetch
</pre>
<div class="Pp"></div>
And if you want to update your remote-tracking branches for all defined remotes
  simultaneously you can do
<div class="Pp"></div>
<pre>
  % git remote update
</pre>
<div class="Pp"></div>
Neither of these last two commands will update your working directory, however
  both will update the remote-tracking branches in your repository.
<div class="Pp"></div>
To make a local branch of a remote branch:
<div class="Pp"></div>
<pre>
  % git checkout -b maint-5.10 origin/maint-5.10
</pre>
<div class="Pp"></div>
To switch back to blead:
<div class="Pp"></div>
<pre>
  % git checkout blead
</pre>
<h2 class="Ss" title="Ss" id="Finding_out_your_status"><a class="selflink" href="#Finding_out_your_status">Finding
  out your status</a></h2>
The most common git command you will use will probably be
<div class="Pp"></div>
<pre>
  % git status
</pre>
<div class="Pp"></div>
This command will produce as output a description of the current state of the
  repository, including modified files and unignored untracked files, and in
  addition it will show things like what files have been staged for the next
  commit, and usually some useful information about how to change things. For
  instance the following:
<div class="Pp"></div>
<pre>
  $ git status
  # On branch blead
  # Your branch is ahead of 'origin/blead' by 1 commit.
  #
  # Changes to be committed:
  #   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
  #
  #       modified:   pod/perlgit.pod
  #
  # Changed but not updated:
  #   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  #
  #       modified:   pod/perlgit.pod
  #
  # Untracked files:
  #   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
  #
  #       deliberate.untracked
</pre>
<div class="Pp"></div>
This shows that there were changes to this document staged for commit, and that
  there were further changes in the working directory not yet staged. It also
  shows that there was an untracked file in the working directory, and as you
  can see shows how to change all of this. It also shows that there is one
  commit on the working branch &quot;blead&quot; which has not been pushed to
  the &quot;origin&quot; remote yet. <b>NOTE</b>: that this output is also what
  you see as a template if you do not provide a message to &quot;git
  commit&quot;.
<h2 class="Ss" title="Ss" id="Patch_workflow"><a class="selflink" href="#Patch_workflow">Patch
  workflow</a></h2>
First, please read perlhack for details on hacking the Perl core. That document
  covers many details on how to create a good patch.
<div class="Pp"></div>
If you already have a Perl repository, you should ensure that you're on the
  <i>blead</i> branch, and your repository is up to date:
<div class="Pp"></div>
<pre>
  % git checkout blead
  % git pull
</pre>
<div class="Pp"></div>
It's preferable to patch against the latest blead version, since this is where
  new development occurs for all changes other than critical bug fixes. Critical
  bug fix patches should be made against the relevant maint branches, or should
  be submitted with a note indicating all the branches where the fix should be
  applied.
<div class="Pp"></div>
Now that we have everything up to date, we need to create a temporary new branch
  for these changes and switch into it:
<div class="Pp"></div>
<pre>
  % git checkout -b orange
</pre>
<div class="Pp"></div>
which is the short form of
<div class="Pp"></div>
<pre>
  % git branch orange
  % git checkout orange
</pre>
<div class="Pp"></div>
Creating a topic branch makes it easier for the maintainers to rebase or merge
  back into the master blead for a more linear history. If you don't work on a
  topic branch the maintainer has to manually cherry pick your changes onto
  blead before they can be applied.
<div class="Pp"></div>
That'll get you scolded on perl5-porters, so don't do that. Be Awesome.
<div class="Pp"></div>
Then make your changes. For example, if Leon Brocard changes his name to Orange
  Brocard, we should change his name in the AUTHORS file:
<div class="Pp"></div>
<pre>
  % perl -pi -e 's{Leon Brocard}{Orange Brocard}' AUTHORS
</pre>
<div class="Pp"></div>
You can see what files are changed:
<div class="Pp"></div>
<pre>
  % git status
  # On branch orange
  # Changes to be committed:
  #   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
  #
  #    modified:   AUTHORS
  #
</pre>
<div class="Pp"></div>
And you can see the changes:
<div class="Pp"></div>
<pre>
  % git diff
  diff --git a/AUTHORS b/AUTHORS
  index 293dd70..722c93e 100644
  --- a/AUTHORS
  +++ b/AUTHORS
  @@ -541,7 +541,7 @@    Lars Hecking                   &lt;lhecking@nmrc.ucc.ie&gt;
   Laszlo Molnar                  &lt;laszlo.molnar@eth.ericsson.se&gt;
   Leif Huhn                      &lt;leif@hale.dkstat.com&gt;
   Len Johnson                    &lt;lenjay@ibm.net&gt;
  -Leon Brocard                   &lt;acme@astray.com&gt;
  +Orange Brocard                 &lt;acme@astray.com&gt;
   Les Peters                     &lt;lpeters@aol.net&gt;
   Lesley Binks                   &lt;lesley.binks@gmail.com&gt;
   Lincoln D. Stein               &lt;lstein@cshl.org&gt;
</pre>
<div class="Pp"></div>
Now commit your change locally:
<div class="Pp"></div>
<pre>
  % git commit -a -m 'Rename Leon Brocard to Orange Brocard'
  Created commit 6196c1d: Rename Leon Brocard to Orange Brocard
   1 files changed, 1 insertions(+), 1 deletions(-)
</pre>
<div class="Pp"></div>
The &quot;-a&quot; option is used to include all files that git tracks that you
  have changed. If at this time, you only want to commit some of the files you
  have worked on, you can omit the &quot;-a&quot; and use the command
  &quot;git&#x00A0;add&#x00A0; <i>FILE&#x00A0;...</i>&quot; before doing the
  commit. &quot;git&#x00A0;add&#x00A0;--interactive&quot; allows you to even
  just commit portions of files instead of all the changes in them.
<div class="Pp"></div>
The &quot;-m&quot; option is used to specify the commit message. If you omit it,
  git will open a text editor for you to compose the message interactively. This
  is useful when the changes are more complex than the sample given here, and,
  depending on the editor, to know that the first line of the commit message
  doesn't exceed the 50 character legal maximum.
<div class="Pp"></div>
Once you've finished writing your commit message and exited your editor, git
  will write your change to disk and tell you something like this:
<div class="Pp"></div>
<pre>
  Created commit daf8e63: explain git status and stuff about remotes
   1 files changed, 83 insertions(+), 3 deletions(-)
</pre>
<div class="Pp"></div>
If you re-run &quot;git status&quot;, you should see something like this:
<div class="Pp"></div>
<pre>
  % git status
  # On branch blead
  # Your branch is ahead of 'origin/blead' by 2 commits.
  #
  # Untracked files:
  #   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
  #
  #       deliberate.untracked
  nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</pre>
<div class="Pp"></div>
When in doubt, before you do anything else, check your status and read it
  carefully, many questions are answered directly by the git status output.
<div class="Pp"></div>
You can examine your last commit with:
<div class="Pp"></div>
<pre>
  % git show HEAD
</pre>
<div class="Pp"></div>
and if you are not happy with either the description or the patch itself you can
  fix it up by editing the files once more and then issue:
<div class="Pp"></div>
<pre>
  % git commit -a --amend
</pre>
<div class="Pp"></div>
Now you should create a patch file for all your local changes:
<div class="Pp"></div>
<pre>
  % git format-patch -M origin..
  0001-Rename-Leon-Brocard-to-Orange-Brocard.patch
</pre>
<div class="Pp"></div>
You should now send an email to perlbug@perl.org &lt;mailto:perlbug@perl.org&gt;
  with a description of your changes, and include this patch file as an
  attachment. In addition to being tracked by RT, mail to perlbug will
  automatically be forwarded to perl5-porters (with manual moderation, so please
  be patient). You should only send patches to perl5-porters@perl.org
  &lt;mailto:perl5-porters@perl.org&gt; directly if the patch is not ready to be
  applied, but intended for discussion.
<div class="Pp"></div>
See the next section for how to configure and use git to send these emails for
  you.
<div class="Pp"></div>
If you want to delete your temporary branch, you may do so with:
<div class="Pp"></div>
<pre>
  % git checkout blead
  % git branch -d orange
  error: The branch 'orange' is not an ancestor of your current HEAD.
  If you are sure you want to delete it, run 'git branch -D orange'.
  % git branch -D orange
  Deleted branch orange.
</pre>
<h2 class="Ss" title="Ss" id="Committing_your_changes"><a class="selflink" href="#Committing_your_changes">Committing
  your changes</a></h2>
Assuming that you'd like to commit all the changes you've made as a single
  atomic unit, run this command:
<div class="Pp"></div>
<pre>
   % git commit -a
</pre>
<div class="Pp"></div>
(That &quot;-a&quot; tells git to add every file you've changed to this commit.
  New files aren't automatically added to your commit when you use &quot;commit
  -a&quot; If you want to add files or to commit some, but not all of your
  changes, have a look at the documentation for &quot;git add&quot;.)
<div class="Pp"></div>
Git will start up your favorite text editor, so that you can craft a commit
  message for your change. See &quot;Commit message&quot; in perlhack for more
  information about what makes a good commit message.
<div class="Pp"></div>
Once you've finished writing your commit message and exited your editor, git
  will write your change to disk and tell you something like this:
<div class="Pp"></div>
<pre>
  Created commit daf8e63: explain git status and stuff about remotes
   1 files changed, 83 insertions(+), 3 deletions(-)
</pre>
<div class="Pp"></div>
If you re-run &quot;git status&quot;, you should see something like this:
<div class="Pp"></div>
<pre>
  % git status
  # On branch blead
  # Your branch is ahead of 'origin/blead' by 2 commits.
  #
  # Untracked files:
  #   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
  #
  #       deliberate.untracked
  nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</pre>
<div class="Pp"></div>
When in doubt, before you do anything else, check your status and read it
  carefully, many questions are answered directly by the git status output.
<h2 class="Ss" title="Ss" id="Using_git_to_send_patch_emails"><a class="selflink" href="#Using_git_to_send_patch_emails">Using
  git to send patch emails</a></h2>
Please read perlhack first in order to figure out where your patches should be
  sent.
<div class="Pp"></div>
In your ~/git/perl repository, set the destination email to perl's bug tracker:
<div class="Pp"></div>
<pre>
  $ git config sendemail.to perlbug@perl.org
</pre>
<div class="Pp"></div>
Or maybe perl5-porters:
<div class="Pp"></div>
<pre>
  $ git config sendemail.to perl5-porters@perl.org
</pre>
<div class="Pp"></div>
Then you can use git directly to send your patch emails:
<div class="Pp"></div>
<pre>
  $ git send-email 0001-Rename-Leon-Brocard-to-Orange-Brocard.patch
</pre>
<div class="Pp"></div>
You may need to set some configuration variables for your particular email
  service provider. For example, to set your global git config to send email via
  a gmail account:
<div class="Pp"></div>
<pre>
  $ git config --global sendemail.smtpserver smtp.gmail.com
  $ git config --global sendemail.smtpssl 1
  $ git config --global sendemail.smtpuser YOURUSERNAME@gmail.com
</pre>
<div class="Pp"></div>
With this configuration, you will be prompted for your gmail password when you
  run 'git send-email'. You can also configure &quot;sendemail.smtppass&quot;
  with your password if you don't care about having your password in the
  .gitconfig file.
<h2 class="Ss" title="Ss" id="A_note_on_derived_files"><a class="selflink" href="#A_note_on_derived_files">A
  note on derived files</a></h2>
Be aware that many files in the distribution are derivative--avoid patching
  them, because git won't see the changes to them, and the build process will
  overwrite them. Patch the originals instead. Most utilities (like perldoc) are
  in this category, i.e. patch <i>utils/perldoc.PL</i> rather than
  <i>utils/perldoc</i>. Similarly, don't create patches for files under
  $src_root/ext from their copies found in $install_root/lib. If you are unsure
  about the proper location of a file that may have gotten copied while building
  the source distribution, consult the &quot;MANIFEST&quot;.
<h2 class="Ss" title="Ss" id="Cleaning_a_working_directory"><a class="selflink" href="#Cleaning_a_working_directory">Cleaning
  a working directory</a></h2>
The command &quot;git clean&quot; can with varying arguments be used as a
  replacement for &quot;make clean&quot;.
<div class="Pp"></div>
To reset your working directory to a pristine condition you can do:
<div class="Pp"></div>
<pre>
  % git clean -dxf
</pre>
<div class="Pp"></div>
However, be aware this will delete ALL untracked content. You can use
<div class="Pp"></div>
<pre>
  % git clean -Xf
</pre>
<div class="Pp"></div>
to remove all ignored untracked files, such as build and test byproduct, but
  leave any manually created files alone.
<div class="Pp"></div>
If you only want to cancel some uncommitted edits, you can use &quot;git
  checkout&quot; and give it a list of files to be reverted, or &quot;git
  checkout -f&quot; to revert them all.
<div class="Pp"></div>
If you want to cancel one or several commits, you can use &quot;git reset&quot;.
<h2 class="Ss" title="Ss" id="Bisecting"><a class="selflink" href="#Bisecting">Bisecting</a></h2>
&quot;git&quot; provides a built-in way to determine which commit should be
  blamed for introducing a given bug. &quot;git bisect&quot; performs a binary
  search of history to locate the first failing commit. It is fast, powerful and
  flexible, but requires some setup and to automate the process an auxiliary
  shell script is needed.
<div class="Pp"></div>
The core provides a wrapper program, <i>Porting/bisect.pl</i>, which attempts to
  simplify as much as possible, making bisecting as simple as running a Perl
  one-liner. For example, if you want to know when this became an error:
<div class="Pp"></div>
<pre>
    perl -e 'my $a := 2'
</pre>
<div class="Pp"></div>
you simply run this:
<div class="Pp"></div>
<pre>
    .../Porting/bisect.pl -e 'my $a := 2;'
</pre>
<div class="Pp"></div>
Using &quot;bisect.pl&quot;, with one command (and no other files) it's easy to
  find out
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Which commit caused this example code to break?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Which commit caused this example code to start
    working?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Which commit added the first file to match this regex?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Which commit removed the last file to match this
    regex?</dd>
</dl>
<div class="Pp"></div>
usually without needing to know which versions of perl to use as start and end
  revisions, as <i>bisect.pl</i> automatically searches to find the earliest
  stable version for which the test case passes. Run &quot;Porting/bisect.pl
  --help&quot; for the full documentation, including how to set the
  &quot;Configure&quot; and build time options.
<div class="Pp"></div>
If you require more flexibility than <i>Porting/bisect.pl</i> has to offer,
  you'll need to run &quot;git bisect&quot; yourself. It's most useful to use
  &quot;git bisect run&quot; to automate the building and testing of perl
  revisions. For this you'll need a shell script for &quot;git&quot; to call to
  test a particular revision. An example script is
  <i>Porting/bisect-example.sh</i>, which you should copy <b>outside</b> of the
  repository, as the bisect process will reset the state to a clean checkout as
  it runs. The instructions below assume that you copied it as <i>~/run</i> and
  then edited it as appropriate.
<div class="Pp"></div>
You first enter in bisect mode with:
<div class="Pp"></div>
<pre>
  % git bisect start
</pre>
<div class="Pp"></div>
For example, if the bug is present on &quot;HEAD&quot; but wasn't in 5.10.0,
  &quot;git&quot; will learn about this when you enter:
<div class="Pp"></div>
<pre>
  % git bisect bad
  % git bisect good perl-5.10.0
  Bisecting: 853 revisions left to test after this
</pre>
<div class="Pp"></div>
This results in checking out the median commit between &quot;HEAD&quot; and
  &quot;perl-5.10.0&quot;. You can then run the bisecting process with:
<div class="Pp"></div>
<pre>
  % git bisect run ~/run
</pre>
<div class="Pp"></div>
When the first bad commit is isolated, &quot;git bisect&quot; will tell you so:
<div class="Pp"></div>
<pre>
  ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5 is first bad commit
  commit ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5
  Author: Dave Mitchell &lt;davem@fdisolutions.com&gt;
  Date:   Sat Feb 9 14:56:23 2008 +0000
      [perl #49472] Attributes + Unknown Error
      ...
  bisect run success
</pre>
<div class="Pp"></div>
You can peek into the bisecting process with &quot;git bisect log&quot; and
  &quot;git bisect visualize&quot;. &quot;git bisect reset&quot; will get you
  out of bisect mode.
<div class="Pp"></div>
Please note that the first &quot;good&quot; state must be an ancestor of the
  first &quot;bad&quot; state. If you want to search for the commit that
  <i>solved</i> some bug, you have to negate your test case (i.e. exit with 1 if
  OK and 0 if not) and still mark the lower bound as &quot;good&quot; and the
  upper as &quot;bad&quot;. The &quot;first bad commit&quot; has then to be
  understood as the &quot;first commit where the bug is solved&quot;.
<div class="Pp"></div>
&quot;git help bisect&quot; has much more information on how you can tweak your
  binary searches.
<h1 class="Sh" title="Sh" id="Topic_branches_and_rewriting_history"><a class="selflink" href="#Topic_branches_and_rewriting_history">Topic
  branches and rewriting history</a></h1>
Individual committers should create topic branches under
  <b>yourname</b>/<b>some_descriptive_name</b>. Other committers should check
  with a topic branch's creator before making any change to it.
<div class="Pp"></div>
The simplest way to create a remote topic branch that works on all versions of
  git is to push the current head as a new branch on the remote, then check it
  out locally:
<div class="Pp"></div>
<pre>
  $ branch=&quot;$yourname/$some_descriptive_name&quot;
  $ git push origin HEAD:$branch
  $ git checkout -b $branch origin/$branch
</pre>
<div class="Pp"></div>
Users of git 1.7 or newer can do it in a more obvious manner:
<div class="Pp"></div>
<pre>
  $ branch=&quot;$yourname/$some_descriptive_name&quot;
  $ git checkout -b $branch
  $ git push origin -u $branch
</pre>
<div class="Pp"></div>
If you are not the creator of <b>yourname</b>/<b>some_descriptive_name</b>, you
  might sometimes find that the original author has edited the branch's history.
  There are lots of good reasons for this. Sometimes, an author might simply be
  rebasing the branch onto a newer source point. Sometimes, an author might have
  found an error in an early commit which they wanted to fix before merging the
  branch to blead.
<div class="Pp"></div>
Currently the master repository is configured to forbid non-fast-forward merges.
  This means that the branches within can not be rebased and pushed as a single
  step.
<div class="Pp"></div>
The only way you will ever be allowed to rebase or modify the history of a
  pushed branch is to delete it and push it as a new branch under the same name.
  Please think carefully about doing this. It may be better to sequentially
  rename your branches so that it is easier for others working with you to
  cherry-pick their local changes onto the new version. (XXX: needs
  explanation).
<div class="Pp"></div>
If you want to rebase a personal topic branch, you will have to delete your
  existing topic branch and push as a new version of it. You can do this via the
  following formula (see the explanation about &quot;refspec&quot;'s in the git
  push documentation for details) after you have rebased your branch:
<div class="Pp"></div>
<pre>
   # first rebase
   $ git checkout $user/$topic
   $ git fetch
   $ git rebase origin/blead
   # then &quot;delete-and-push&quot;
   $ git push origin :$user/$topic
   $ git push origin $user/$topic
</pre>
<div class="Pp"></div>
<b>NOTE:</b> it is forbidden at the repository level to delete any of the
  &quot;primary&quot; branches. That is any branch matching
  &quot;m!^(blead|maint|perl)!&quot;. Any attempt to do so will result in git
  producing an error like this:
<div class="Pp"></div>
<pre>
    $ git push origin :blead
    *** It is forbidden to delete blead/maint branches in this repository
    error: hooks/update exited with error code 1
    error: hook declined to update refs/heads/blead
    To ssh://perl5.git.perl.org/perl
     ! [remote rejected] blead (hook declined)
     error: failed to push some refs to 'ssh://perl5.git.perl.org/perl'
</pre>
<div class="Pp"></div>
As a matter of policy we do <b>not</b> edit the history of the blead and maint-*
  branches. If a typo (or worse) sneaks into a commit to blead or maint-*, we'll
  fix it in another commit. The only types of updates allowed on these branches
  are &quot;fast-forward's&quot;, where all history is preserved.
<div class="Pp"></div>
Annotated tags in the canonical perl.git repository will never be deleted or
  modified. Think long and hard about whether you want to push a local tag to
  perl.git before doing so. (Pushing unannotated tags is not allowed.)
<h2 class="Ss" title="Ss" id="Grafts"><a class="selflink" href="#Grafts">Grafts</a></h2>
The perl history contains one mistake which was not caught in the conversion: a
  merge was recorded in the history between blead and maint-5.10 where no merge
  actually occurred. Due to the nature of git, this is now impossible to fix in
  the public repository. You can remove this mis-merge locally by adding the
  following line to your &quot;.git/info/grafts&quot; file:
<div class="Pp"></div>
<pre>
  296f12bbbbaa06de9be9d09d3dcf8f4528898a49 434946e0cb7a32589ed92d18008aaa1d88515930
</pre>
<div class="Pp"></div>
It is particularly important to have this graft line if any bisecting is done in
  the area of the &quot;merge&quot; in question.
<h1 class="Sh" title="Sh" id="WRITE_ACCESS_TO_THE_GIT_REPOSITORY"><a class="selflink" href="#WRITE_ACCESS_TO_THE_GIT_REPOSITORY">WRITE
  ACCESS TO THE GIT REPOSITORY</a></h1>
Once you have write access, you will need to modify the URL for the origin
  remote to enable pushing. Edit <i>.git/config</i> with the
  <i>git-config</i>(1) command:
<div class="Pp"></div>
<pre>
  % git config remote.origin.url ssh://perl5.git.perl.org/perl.git
</pre>
<div class="Pp"></div>
You can also set up your user name and e-mail address. Most people do this once
  globally in their <i>~/.gitconfig</i> by doing something like:
<div class="Pp"></div>
<pre>
  % git config --global user.name &quot;var Arnfjoerd` Bjarmason&quot;
  % git config --global user.email avarab@gmail.com
</pre>
<div class="Pp"></div>
However if you'd like to override that just for perl then execute then execute
  something like the following in <i>perl</i>:
<div class="Pp"></div>
<pre>
  % git config user.email avar@cpan.org
</pre>
<div class="Pp"></div>
It is also possible to keep &quot;origin&quot; as a git remote, and add a new
  remote for ssh access:
<div class="Pp"></div>
<pre>
  % git remote add camel perl5.git.perl.org:/perl.git
</pre>
<div class="Pp"></div>
This allows you to update your local repository by pulling from
  &quot;origin&quot;, which is faster and doesn't require you to authenticate,
  and to push your changes back with the &quot;camel&quot; remote:
<div class="Pp"></div>
<pre>
  % git fetch camel
  % git push camel
</pre>
<div class="Pp"></div>
The &quot;fetch&quot; command just updates the &quot;camel&quot; refs, as the
  objects themselves should have been fetched when pulling from
  &quot;origin&quot;.
<h1 class="Sh" title="Sh" id="Accepting_a_patch"><a class="selflink" href="#Accepting_a_patch">Accepting
  a patch</a></h1>
If you have received a patch file generated using the above section, you should
  try out the patch.
<div class="Pp"></div>
First we need to create a temporary new branch for these changes and switch into
  it:
<div class="Pp"></div>
<pre>
  % git checkout -b experimental
</pre>
<div class="Pp"></div>
Patches that were formatted by &quot;git format-patch&quot; are applied with
  &quot;git am&quot;:
<div class="Pp"></div>
<pre>
  % git am 0001-Rename-Leon-Brocard-to-Orange-Brocard.patch
  Applying Rename Leon Brocard to Orange Brocard
</pre>
<div class="Pp"></div>
If just a raw diff is provided, it is also possible use this two-step process:
<div class="Pp"></div>
<pre>
  % git apply bugfix.diff
  % git commit -a -m &quot;Some fixing&quot; --author=&quot;That Guy &lt;that.guy@internets.com&gt;&quot;
</pre>
<div class="Pp"></div>
Now we can inspect the change:
<div class="Pp"></div>
<pre>
  % git show HEAD
  commit b1b3dab48344cff6de4087efca3dbd63548ab5e2
  Author: Leon Brocard &lt;acme@astray.com&gt;
  Date:   Fri Dec 19 17:02:59 2008 +0000
    Rename Leon Brocard to Orange Brocard
  diff --git a/AUTHORS b/AUTHORS
  index 293dd70..722c93e 100644
  --- a/AUTHORS
  +++ b/AUTHORS
  @@ -541,7 +541,7 @@ Lars Hecking                        &lt;lhecking@nmrc.ucc.ie&gt;
   Laszlo Molnar                  &lt;laszlo.molnar@eth.ericsson.se&gt;
   Leif Huhn                      &lt;leif@hale.dkstat.com&gt;
   Len Johnson                    &lt;lenjay@ibm.net&gt;
  -Leon Brocard                   &lt;acme@astray.com&gt;
  +Orange Brocard                 &lt;acme@astray.com&gt;
   Les Peters                     &lt;lpeters@aol.net&gt;
   Lesley Binks                   &lt;lesley.binks@gmail.com&gt;
   Lincoln D. Stein               &lt;lstein@cshl.org&gt;
</pre>
<div class="Pp"></div>
If you are a committer to Perl and you think the patch is good, you can then
  merge it into blead then push it out to the main repository:
<div class="Pp"></div>
<pre>
  % git checkout blead
  % git merge experimental
  % git push
</pre>
<div class="Pp"></div>
If you want to delete your temporary branch, you may do so with:
<div class="Pp"></div>
<pre>
  % git checkout blead
  % git branch -d experimental
  error: The branch 'experimental' is not an ancestor of your current HEAD.
  If you are sure you want to delete it, run 'git branch -D experimental'.
  % git branch -D experimental
  Deleted branch experimental.
</pre>
<h2 class="Ss" title="Ss" id="Committing_to_blead"><a class="selflink" href="#Committing_to_blead">Committing
  to blead</a></h2>
The 'blead' branch will become the next production release of Perl.
<div class="Pp"></div>
Before pushing <i>any</i> local change to blead, it's incredibly important that
  you do a few things, lest other committers come after you with pitchforks and
  torches:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Make sure you have a good commit message. See &quot;Commit
      message&quot; in perlhack for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Run the test suite. You might not think that one typo fix
      would break a test file. You'd be wrong. Here's an example of where not
      running the suite caused problems. A patch was submitted that added a
      couple of tests to an existing .t. It couldn't possibly affect anything
      else, so no need to test beyond the single affected .t, right? But, the
      submitter's email address had changed since the last of their submissions,
      and this caused other tests to fail. Running the test target given in the
      next item would have caught this problem.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If you don't run the full test suite, at least &quot;make
      test_porting&quot;. This will run basic sanity checks. To see which sanity
      checks, have a look in <i>t/porting</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If you make any changes that affect miniperl or core
      routines that have different code paths for miniperl, be sure to run
      &quot;make minitest&quot;. This will catch problems that even the full
      test suite will not catch because it runs a subset of tests under miniperl
      rather than perl.</dd>
</dl>
<div class="Pp"></div>
<i>On merging and rebasing</i>
<div class="Pp"></div>
Simple, one-off commits pushed to the 'blead' branch should be simple commits
  that apply cleanly. In other words, you should make sure your work is
  committed against the current position of blead, so that you can push back to
  the master repository without merging.
<div class="Pp"></div>
Sometimes, blead will move while you're building or testing your changes. When
  this happens, your push will be rejected with a message like this:
<div class="Pp"></div>
<pre>
  To ssh://perl5.git.perl.org/perl.git
   ! [rejected]        blead -&gt; blead (non-fast-forward)
  error: failed to push some refs to 'ssh://perl5.git.perl.org/perl.git'
  To prevent you from losing history, non-fast-forward updates were rejected
  Merge the remote changes (e.g. 'git pull') before pushing again.  See the
  'Note about fast-forwards' section of 'git push --help' for details.
</pre>
<div class="Pp"></div>
When this happens, you can just <i>rebase</i> your work against the new position
  of blead, like this (assuming your remote for the master repository is
  &quot;p5p&quot;):
<div class="Pp"></div>
<pre>
  $ git fetch p5p
  $ git rebase p5p/blead
</pre>
<div class="Pp"></div>
You will see your commits being re-applied, and you will then be able to push
  safely. More information about rebasing can be found in the documentation for
  the <i>git-rebase</i>(1) command.
<div class="Pp"></div>
For larger sets of commits that only make sense together, or that would benefit
  from a summary of the set's purpose, you should use a merge commit. You should
  perform your work on a topic branch, which you should regularly rebase against
  blead to ensure that your code is not broken by blead moving. When you have
  finished your work, please perform a final rebase and test. Linear history is
  something that gets lost with every commit on blead, but a final rebase makes
  the history linear again, making it easier for future maintainers to see what
  has happened. Rebase as follows (assuming your work was on the branch
  &quot;committer/somework&quot;):
<div class="Pp"></div>
<pre>
  $ git checkout committer/somework
  $ git rebase blead
</pre>
<div class="Pp"></div>
Then you can merge it into master like this:
<div class="Pp"></div>
<pre>
  $ git checkout blead
  $ git merge --no-ff --no-commit committer/somework
  $ git commit -a
</pre>
<div class="Pp"></div>
The switches above deserve explanation. &quot;--no-ff&quot; indicates that even
  if all your work can be applied linearly against blead, a merge commit should
  still be prepared. This ensures that all your work will be shown as a side
  branch, with all its commits merged into the mainstream blead by the merge
  commit.
<div class="Pp"></div>
&quot;--no-commit&quot; means that the merge commit will be <i>prepared</i> but
  not <i>committed</i>. The commit is then actually performed when you run the
  next command, which will bring up your editor to describe the commit. Without
  &quot;--no-commit&quot;, the commit would be made with nearly no useful
  message, which would greatly diminish the value of the merge commit as a
  placeholder for the work's description.
<div class="Pp"></div>
When describing the merge commit, explain the purpose of the branch, and keep in
  mind that this description will probably be used by the eventual release
  engineer when reviewing the next perldelta document.
<h2 class="Ss" title="Ss" id="Committing_to_maintenance_versions"><a class="selflink" href="#Committing_to_maintenance_versions">Committing
  to maintenance versions</a></h2>
Maintenance versions should only be altered to add critical bug fixes, see
  perlpolicy.
<div class="Pp"></div>
To commit to a maintenance version of perl, you need to create a local tracking
  branch:
<div class="Pp"></div>
<pre>
  % git checkout --track -b maint-5.005 origin/maint-5.005
</pre>
<div class="Pp"></div>
This creates a local branch named &quot;maint-5.005&quot;, which tracks the
  remote branch &quot;origin/maint-5.005&quot;. Then you can pull, commit, merge
  and push as before.
<div class="Pp"></div>
You can also cherry-pick commits from blead and another branch, by using the
  &quot;git cherry-pick&quot; command. It is recommended to use the <b>-x</b>
  option to &quot;git cherry-pick&quot; in order to record the SHA1 of the
  original commit in the new commit message.
<div class="Pp"></div>
Before pushing any change to a maint version, make sure you've satisfied the
  steps in &quot;Committing to blead&quot; above.
<h2 class="Ss" title="Ss" id="Merging_from_a_branch_via_GitHub"><a class="selflink" href="#Merging_from_a_branch_via_GitHub">Merging
  from a branch via GitHub</a></h2>
While we don't encourage the submission of patches via GitHub, that will still
  happen. Here is a guide to merging patches from a GitHub repository.
<div class="Pp"></div>
<pre>
  % git remote add avar git://github.com/avar/perl.git
  % git fetch avar
</pre>
<div class="Pp"></div>
Now you can see the differences between the branch and blead:
<div class="Pp"></div>
<pre>
  % git diff avar/orange
</pre>
<div class="Pp"></div>
And you can see the commits:
<div class="Pp"></div>
<pre>
  % git log avar/orange
</pre>
<div class="Pp"></div>
If you approve of a specific commit, you can cherry pick it:
<div class="Pp"></div>
<pre>
  % git cherry-pick 0c24b290ae02b2ab3304f51d5e11e85eb3659eae
</pre>
<div class="Pp"></div>
Or you could just merge the whole branch if you like it all:
<div class="Pp"></div>
<pre>
  % git merge avar/orange
</pre>
<div class="Pp"></div>
And then push back to the repository:
<div class="Pp"></div>
<pre>
  % git push
</pre>
<h2 class="Ss" title="Ss" id="A_note_on_camel_and_dromedary"><a class="selflink" href="#A_note_on_camel_and_dromedary">A
  note on camel and dromedary</a></h2>
The committers have SSH access to the two servers that serve
  &quot;perl5.git.perl.org&quot;. One is &quot;perl5.git.perl.org&quot; itself (
  <i>camel</i>), which is the 'master' repository. The second one is
  &quot;users.perl5.git.perl.org&quot; ( <i>dromedary</i>), which can be used
  for general testing and development. Dromedary syncs the git tree from camel
  every few minutes, you should not push there. Both machines also have a full
  CPAN mirror in /srv/CPAN, please use this. To share files with the general
  public, dromedary serves your ~/public_html/ as
  &quot;http://users.perl5.git.perl.org/~yourlogin/&quot;
<div class="Pp"></div>
These hosts have fairly strict firewalls to the outside. Outgoing, only rsync,
  ssh and git are allowed. For http and ftp, you can use http://webproxy:3128 as
  proxy. Incoming, the firewall tries to detect attacks and blocks IP addresses
  with suspicious activity. This sometimes (but very rarely) has false positives
  and you might get blocked. The quickest way to get unblocked is to notify the
  admins.
<div class="Pp"></div>
These two boxes are owned, hosted, and operated by booking.com. You can reach
  the sysadmins in #p5p on irc.perl.org or via mail to
  &quot;perl5-porters@perl.org&quot;.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
