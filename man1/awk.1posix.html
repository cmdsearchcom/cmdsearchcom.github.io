<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:53:55 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>AWK(1POSIX) POSIX Programmer&rsquo;s Manual
AWK(1POSIX)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
awk &acirc; pattern scanning and processing language</p>

<p style="margin-top: 1em">SYNOPSIS <br>
awk [&acirc;F sepstring] [&acirc;v assignment]... program
[argument...]</p>

<p style="margin-top: 1em">awk [&acirc;F sepstring]
&acirc;f progfile [&acirc;f progfile]... [&acirc;v
assignment]... <br>
[argument...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The awk utility shall execute programs written in the awk
programming language, which is specialized for textual data
manipulation. An awk program is a sequence of patterns and
<br>
corresponding actions. When input is read that matches a
pattern, the action associated with that pattern is carried
out.</p>

<p style="margin-top: 1em">Input shall be interpreted as a
sequence of records. By default, a record is a line, less
its terminating &lt;newline&gt;, but this can be changed by
using the RS built-in variable. <br>
Each record of input shall be matched in turn against each
pattern in the program. For each pattern matched, the
associated action shall be executed.</p>

<p style="margin-top: 1em">The awk utility shall interpret
each input record as a sequence of fields where, by default,
a field is a string of non-&lt;blank&gt; non-&lt;newline&gt;
characters. This default &lt;blank&gt; and <br>
&lt;newline&gt; field delimiter can be changed by using the
FS built-in variable or the &acirc;F sepstring option. The
awk utility shall denote the first field in a record $1, the
second $2, <br>
and so on. The symbol $0 shall refer to the entire record;
setting any other field causes the re-evaluation of $0.
Assigning to $0 shall reset the values of all other fields
and <br>
the NF built-in variable.</p>

<p style="margin-top: 1em">OPTIONS <br>
The awk utility shall conform to the Base Definitions volume
of POSIX.1&acirc;2008, Section 12.2, Utility Syntax
Guidelines.</p>

<p style="margin-top: 1em">The following options shall be
supported:</p>

<p style="margin-top: 1em">&acirc;F sepstring <br>
Define the input field separator. This option shall be
equivalent to:</p>

<p style="margin-top: 1em">-v FS=sepstring</p>

<p style="margin-top: 1em">except that if &acirc;F
sepstring and &acirc;v FS=sepstring are both used, it is
unspecified whether the FS assignment resulting from
&acirc;F sepstring is processed in command line <br>
order or is processed after the last &acirc;v FS=sepstring.
See the description of the FS built-in variable, and how it
is used, in the EXTENDED DESCRIPTION section.</p>

<p style="margin-top: 1em">&acirc;f progfile <br>
Specify the pathname of the file progfile containing an awk
program. A pathname of &rsquo;&acirc;&rsquo; shall denote
the standard input. If multiple instances of this option are
speci&acirc; <br>
fied, the concatenation of the files specified as progfile
in the order specified shall be the awk program. The awk
program can alternatively be specified in the com&acirc;
<br>
mand line as a single argument.</p>

<p style="margin-top: 1em">&acirc;v assignment <br>
The application shall ensure that the assignment argument is
in the same form as an assignment operand. The specified
variable assignment shall occur prior to executing <br>
the awk program, including the actions associated with BEGIN
patterns (if any). Multiple occurrences of this option can
be specified.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operands shall be supported:</p>

<p style="margin-top: 1em">program If no &acirc;f option is
specified, the first operand to awk shall be the text of the
awk program. The application shall supply the program
operand as a single argument to <br>
awk. If the text does not end in a &lt;newline&gt;, awk
shall interpret the text as if it did.</p>

<p style="margin-top: 1em">argument Either of the following
two types of argument can be intermixed:</p>

<p style="margin-top: 1em">file A pathname of a file that
contains the input to be read, which is matched against the
set of patterns in the program. If no file operands are
specified, or if <br>
a file operand is &rsquo;&acirc;&rsquo;, the standard input
shall be used.</p>

<p style="margin-top: 1em">assignment <br>
An operand that begins with an &lt;underscore&gt; or
alphabetic character from the portable character set (see
the table in the Base Definitions volume of <br>
POSIX.1&acirc;2008, Section 6.1, Portable Character Set),
followed by a sequence of underscores, digits, and
alphabetics from the portable character set, followed <br>
by the &rsquo;=&rsquo; character, shall specify a variable
assignment rather than a pathname. The characters before the
&rsquo;=&rsquo; represent the name of an awk variable; if
<br>
that name is an awk reserved word (see Grammar) the behavior
is undefined. The characters following the
&lt;equals-sign&gt; shall be interpreted as if they appeared
<br>
in the awk program preceded and followed by a double-quote
(&rsquo;&quot;&rsquo;) character, as a STRING token (see
Grammar), except that if the last character is an unescaped
<br>
&lt;backslash&gt;, it shall be interpreted as a literal
&lt;backslash&gt; rather than as the first character of the
sequence &quot; <br>
value of that STRING token and, if appropriate, shall be
considered a numeric string (see Expressions in awk), the
variable shall also be assigned its numeric <br>
value. Each such variable assignment shall occur just prior
to the processing of the following file, if any. Thus, an
assignment before the first file argu&acirc; <br>
ment shall be executed after the BEGIN actions (if any),
while an assignment after the last file argument shall occur
before the END actions (if any). If <br>
there are no file arguments, assignments shall be executed
before processing the standard input.</p>

<p style="margin-top: 1em">STDIN <br>
The standard input shall be used only if no file operands
are specified, or if a file operand is
&rsquo;&acirc;&rsquo;, or if a progfile option-argument is
&rsquo;&acirc;&rsquo;; see the INPUT FILES section. If the
<br>
awk program contains no actions and no patterns, but is
otherwise a valid awk program, standard input and any file
operands shall not be read and awk shall exit with a return
<br>
status of zero.</p>

<p style="margin-top: 1em">INPUT FILES <br>
Input files to the awk program from any of the following
sources shall be text files:</p>

<p style="margin-top: 1em">* Any file operands or their
equivalents, achieved by modifying the awk variables ARGV
and ARGC</p>

<p style="margin-top: 1em">* Standard input in the absence
of any file operands</p>

<p style="margin-top: 1em">* Arguments to the getline
function</p>

<p style="margin-top: 1em">Whether the variable RS is set
to a value other than a &lt;newline&gt; or not, for these
files, implementations shall support records terminated with
the specified separator up to <br>
{LINE_MAX} bytes and may support longer records.</p>

<p style="margin-top: 1em">If &acirc;f progfile is
specified, the application shall ensure that the files named
by each of the progfile option-arguments are text files and
their concatenation, in the same order <br>
as they appear in the arguments, is an awk program.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of awk:</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of POSIX.1&acirc;2008,
Section 8.2, Internationaliza&acirc; <br>
tion Variables for the precedence of internationalization
variables used to determine the values of locale
categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_COLLATE <br>
Determine the locale for the behavior of ranges, equivalence
classes, and multi-character collating elements within
regular expressions and in comparisons of string <br>
values.</p>

<p style="margin-top: 1em">LC_CTYPE Determine the locale
for the interpretation of sequences of bytes of text data as
characters (for example, single-byte as opposed to
multi-byte characters in arguments <br>
and input files), the behavior of character classes within
regular expressions, the identification of characters as
letters, and the mapping of uppercase and lowercase <br>
characters for the toupper and tolower functions.</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">LC_NUMERIC <br>
Determine the radix character used when interpreting numeric
input, performing conversions between numeric and string
values, and formatting numeric output. Regardless <br>
of locale, the &lt;period&gt; character (the decimal-point
character of the POSIX locale) is the decimal-point
character recognized in processing awk programs (including
<br>
assignments in command line arguments).</p>

<p style="margin-top: 1em">NLSPATH Determine the location
of message catalogs for the processing of LC_MESSAGES.</p>

<p style="margin-top: 1em">PATH Determine the search path
when looking for commands executed by system(expr), or input
and output pipes; see the Base Definitions volume of
POSIX.1&acirc;2008, Chapter 8, <br>
Environment Variables.</p>

<p style="margin-top: 1em">In addition, all environment
variables shall be visible via the awk variable ENVIRON.</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
Default.</p>

<p style="margin-top: 1em">STDOUT <br>
The nature of the output files depends on the awk
program.</p>

<p style="margin-top: 1em">STDERR <br>
The standard error shall be used only for diagnostic
messages.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
The nature of the output files depends on the awk
program.</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
Overall Program Structure <br>
An awk program is composed of pairs of the form:</p>

<p style="margin-top: 1em">pattern { action }</p>

<p style="margin-top: 1em">Either the pattern or the action
(including the enclosing brace characters) can be
omitted.</p>

<p style="margin-top: 1em">A missing pattern shall match
any record of input, and a missing action shall be
equivalent to:</p>

<p style="margin-top: 1em">{ print }</p>

<p style="margin-top: 1em">Execution of the awk program
shall start by first executing the actions associated with
all BEGIN patterns in the order they occur in the program.
Then each file operand (or <br>
standard input if no files were specified) shall be
processed in turn by reading data from the file until a
record separator is seen (&lt;newline&gt; by default).
Before the first ref&acirc; <br>
erence to a field in the record is evaluated, the record
shall be split into fields, according to the rules in
Regular Expressions, using the value of FS that was current
at the <br>
time the record was read. Each pattern in the program then
shall be evaluated in the order of occurrence, and the
action associated with each pattern that matches the current
<br>
record executed. The action for a matching pattern shall be
executed before evaluating subsequent patterns. Finally, the
actions associated with all END patterns shall be exe&acirc;
<br>
cuted in the order they occur in the program.</p>

<p style="margin-top: 1em">Expressions in awk <br>
Expressions describe computations used in patterns and
actions. In the following table, valid expression operations
are given in groups from highest precedence first to lowest
<br>
precedence last, with equal-precedence operators grouped
between horizontal lines. In expression evaluation, where
the grammar is formally ambiguous, higher precedence
operators <br>
shall be evaluated before lower precedence operators. In
this table expr, expr1, expr2, and expr3 represent any
expression, while lvalue represents any entity that can be
<br>
assigned to (that is, on the left side of an assignment
operator). The precise syntax of expressions is given in
Grammar.</p>

<p style="margin-top: 1em">Table 4-1: Expressions in
Decreasing Precedence in awk</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; Syntax &acirc; Name &acirc; Type of Result
&acirc;Associativity &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;( expr ) &acirc;Grouping &acirc;Type of expr
&acirc;N/A &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;$expr &acirc;Field reference &acirc;String &acirc;N/A
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;lvalue ++ &acirc;Post-increment &acirc;Numeric
&acirc;N/A &acirc; <br>
&acirc;lvalue &acirc;&acirc; &acirc;Post-decrement
&acirc;Numeric &acirc;N/A &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;++ lvalue &acirc;Pre-increment &acirc;Numeric
&acirc;N/A &acirc; <br>
&acirc;&acirc;&acirc; lvalue &acirc;Pre-decrement
&acirc;Numeric &acirc;N/A &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr ^ expr &acirc;Exponentiation &acirc;Numeric
&acirc;Right &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;! expr &acirc;Logical not &acirc;Numeric &acirc;N/A
&acirc; <br>
&acirc;+ expr &acirc;Unary plus &acirc;Numeric &acirc;N/A
&acirc; <br>
&acirc;&acirc; expr &acirc;Unary minus &acirc;Numeric
&acirc;N/A &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr * expr &acirc;Multiplication &acirc;Numeric
&acirc;Left &acirc; <br>
&acirc;expr / expr &acirc;Division &acirc;Numeric
&acirc;Left &acirc; <br>
&acirc;expr % expr &acirc;Modulus &acirc;Numeric &acirc;Left
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr + expr &acirc;Addition &acirc;Numeric
&acirc;Left &acirc; <br>
&acirc;expr &acirc; expr &acirc;Subtraction &acirc;Numeric
&acirc;Left &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr expr &acirc;String concatenation &acirc;String
&acirc;Left &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr &lt; expr &acirc;Less than &acirc;Numeric
&acirc;None &acirc; <br>
&acirc;expr &lt;= expr &acirc;Less than or equal to
&acirc;Numeric &acirc;None &acirc; <br>
&acirc;expr != expr &acirc;Not equal to &acirc;Numeric
&acirc;None &acirc; <br>
&acirc;expr == expr &acirc;Equal to &acirc;Numeric
&acirc;None &acirc; <br>
&acirc;expr &gt; expr &acirc;Greater than &acirc;Numeric
&acirc;None &acirc; <br>
&acirc;expr &gt;= expr &acirc;Greater than or equal to
&acirc;Numeric &acirc;None &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr ~ expr &acirc;ERE match &acirc;Numeric
&acirc;None &acirc; <br>
&acirc;expr !~ expr &acirc;ERE non-match &acirc;Numeric
&acirc;None &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr in array &acirc;Array membership &acirc;Numeric
&acirc;Left &acirc; <br>
&acirc;( index ) in array &acirc;Multi-dimension array
&acirc;Numeric &acirc;Left &acirc; <br>
&acirc; &acirc;membership &acirc; &acirc; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr &amp;&amp; expr &acirc;Logical AND
&acirc;Numeric &acirc;Left &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr || expr &acirc;Logical OR &acirc;Numeric
&acirc;Left &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;expr1 ? expr2 : expr3&acirc;Conditional expression
&acirc;Type of selected&acirc;Right &acirc; <br>
&acirc; &acirc; &acirc;expr2 or expr3 &acirc; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;lvalue ^= expr &acirc;Exponentiation
assignment&acirc;Numeric &acirc;Right &acirc; <br>
&acirc;lvalue %= expr &acirc;Modulus assignment
&acirc;Numeric &acirc;Right &acirc; <br>
&acirc;lvalue *= expr &acirc;Multiplication
assignment&acirc;Numeric &acirc;Right &acirc; <br>
&acirc;lvalue /= expr &acirc;Division assignment
&acirc;Numeric &acirc;Right &acirc; <br>
&acirc;lvalue += expr &acirc;Addition assignment
&acirc;Numeric &acirc;Right &acirc; <br>
&acirc;lvalue &acirc;= expr &acirc;Subtraction assignment
&acirc;Numeric &acirc;Right &acirc; <br>
&acirc;lvalue = expr &acirc;Assignment &acirc;Type of expr
&acirc;Right &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
Each expression shall have either a string value, a numeric
value, or both. Except as stated for specific contexts, the
value of an expression shall be implicitly converted to <br>
the type needed for the context in which it is used. A
string value shall be converted to a numeric value either by
the equivalent of the following calls to functions defined
by <br>
the ISO C standard:</p>

<p style="margin-top: 1em">setlocale(LC_NUMERIC,
&quot;&quot;); <br>
numeric_value = atof(string_value);</p>

<p style="margin-top: 1em">or by converting the initial
portion of the string to type double representation as
follows:</p>

<p style="margin-top: 1em">The input string is decomposed
into two parts: an initial, possibly empty, sequence of
white-space characters (as specified by isspace()) and a
subject sequence inter&acirc; <br>
preted as a floating-point constant.</p>

<p style="margin-top: 1em">The expected form of the subject
sequence is an optional &rsquo;+&rsquo; or
&rsquo;&acirc;&rsquo; sign, then a non-empty sequence of
digits optionally containing a &lt;period&gt;, then an
optional exponent <br>
part. An exponent part consists of &rsquo;e&rsquo; or
&rsquo;E&rsquo;, followed by an optional sign, followed by
one or more decimal digits.</p>

<p style="margin-top: 1em">The sequence starting with the
first digit or the &lt;period&gt; (whichever occurs first)
is interpreted as a floating constant of the C language, and
if neither an exponent <br>
part nor a &lt;period&gt; appears, a &lt;period&gt; is
assumed to follow the last digit in the string. If the
subject sequence begins with a minus-sign, the value
resulting from the <br>
conversion is negated.</p>

<p style="margin-top: 1em">A numeric value that is exactly
equal to the value of an integer (see Section 1.1.2,
Concepts Derived from the ISO C Standard) shall be converted
to a string by the equivalent of <br>
a call to the sprintf function (see String Functions) with
the string &quot;%d&quot; as the fmt argument and the
numeric value being converted as the first and only expr
argument. Any <br>
other numeric value shall be converted to a string by the
equivalent of a call to the sprintf function with the value
of the variable CONVFMT as the fmt argument and the numeric
<br>
value being converted as the first and only expr argument.
The result of the conversion is unspecified if the value of
CONVFMT is not a floating-point format specification. This
<br>
volume of POSIX.1&acirc;2008 specifies no explicit
conversions between numbers and strings. An application can
force an expression to be treated as a number by adding zero
to it, or <br>
can force it to be treated as a string by concatenating the
null string (&quot;&quot;) to it.</p>

<p style="margin-top: 1em">A string value shall be
considered a numeric string if it comes from one of the
following:</p>

<p style="margin-top: 1em">1. Field variables</p>

<p style="margin-top: 1em">2. Input from the getline()
function</p>

<p style="margin-top: 1em">3. FILENAME</p>

<p style="margin-top: 1em">4. ARGV array elements</p>

<p style="margin-top: 1em">5. ENVIRON array elements</p>

<p style="margin-top: 1em">6. Array elements created by the
split() function</p>

<p style="margin-top: 1em">7. A command line variable
assignment</p>

<p style="margin-top: 1em">8. Variable assignment from
another numeric string variable</p>

<p style="margin-top: 1em">and an implementation-dependent
condition corresponding to either case (a) or (b) below is
met.</p>

<p style="margin-top: 1em">a. After the equivalent of the
following calls to functions defined by the ISO C standard,
string_value_end would differ from string_value, and any
characters before the termi&acirc; <br>
nating null character in string_value_end would be
&lt;blank&gt; characters:</p>

<p style="margin-top: 1em">char *string_value_end; <br>
setlocale(LC_NUMERIC, &quot;&quot;); <br>
numeric_value = strtod (string_value,
&amp;string_value_end);</p>

<p style="margin-top: 1em">b. After all the following
conversions have been applied, the resulting string would
lexically be recognized as a NUMBER token as described by
the lexical conventions in Gram&acirc; <br>
mar:</p>

<p style="margin-top: 1em">-- All leading and trailing
&lt;blank&gt; characters are discarded.</p>

<p style="margin-top: 1em">-- If the first
non-&lt;blank&gt; is &rsquo;+&rsquo; or
&rsquo;&acirc;&rsquo;, it is discarded.</p>

<p style="margin-top: 1em">-- Each occurrence of the
decimal point character from the current locale is changed
to a &lt;period&gt;. <br>
In case (a) the numeric value of the numeric string shall be
the value that would be returned by the strtod() call. In
case (b) if the first non-&lt;blank&gt; is
&rsquo;&acirc;&rsquo;, the numeric value <br>
of the numeric string shall be the negation of the numeric
value of the recognized NUMBER token; otherwise, the numeric
value of the numeric string shall be the numeric value of
<br>
the recognized NUMBER token. Whether or not a string is a
numeric string shall be relevant only in contexts where that
term is used in this section.</p>

<p style="margin-top: 1em">When an expression is used in a
Boolean context, if it has a numeric value, a value of zero
shall be treated as false and any other value shall be
treated as true. Otherwise, a <br>
string value of the null string shall be treated as false
and any other value shall be treated as true. A Boolean
context shall be one of the following:</p>

<p style="margin-top: 1em">* The first subexpression of a
conditional expression</p>

<p style="margin-top: 1em">* An expression operated on by
logical NOT, logical AND, or logical OR</p>

<p style="margin-top: 1em">* The second expression of a for
statement</p>

<p style="margin-top: 1em">* The expression of an if
statement</p>

<p style="margin-top: 1em">* The expression of the while
clause in either a while or do...while statement</p>

<p style="margin-top: 1em">* An expression used as a
pattern (as in Overall Program Structure)</p>

<p style="margin-top: 1em">All arithmetic shall follow the
semantics of floating-point arithmetic as specified by the
ISO C standard (see Section 1.1.2, Concepts Derived from the
ISO C Standard).</p>

<p style="margin-top: 1em">The value of the expression:</p>

<p style="margin-top: 1em">expr1 ^ expr2</p>

<p style="margin-top: 1em">shall be equivalent to the value
returned by the ISO C standard function call:</p>

<p style="margin-top: 1em">pow(expr1, expr2)</p>

<p style="margin-top: 1em">The expression:</p>

<p style="margin-top: 1em">lvalue ^= expr</p>

<p style="margin-top: 1em">shall be equivalent to the ISO C
standard expression:</p>

<p style="margin-top: 1em">lvalue = pow(lvalue, expr)</p>

<p style="margin-top: 1em">except that lvalue shall be
evaluated only once. The value of the expression:</p>

<p style="margin-top: 1em">expr1 % expr2</p>

<p style="margin-top: 1em">shall be equivalent to the value
returned by the ISO C standard function call:</p>

<p style="margin-top: 1em">fmod(expr1, expr2)</p>

<p style="margin-top: 1em">The expression:</p>

<p style="margin-top: 1em">lvalue %= expr</p>

<p style="margin-top: 1em">shall be equivalent to the ISO C
standard expression:</p>

<p style="margin-top: 1em">lvalue = fmod(lvalue, expr)</p>

<p style="margin-top: 1em">except that lvalue shall be
evaluated only once.</p>

<p style="margin-top: 1em">Variables and fields shall be
set by the assignment statement:</p>

<p style="margin-top: 1em">lvalue = expression</p>

<p style="margin-top: 1em">and the type of expression shall
determine the resulting variable type. The assignment
includes the arithmetic assignments (&quot;+=&quot;,
&quot;&acirc;=&quot;, &quot;*=&quot;, &quot;/=&quot;,
&quot;%=&quot;, &quot;^=&quot;, &quot;++&quot;,
&quot;&acirc;&acirc;&quot;) all of <br>
which shall produce a numeric result. The left-hand side of
an assignment and the target of increment and decrement
operators can be one of a variable, an array with index, or
a <br>
field selector.</p>

<p style="margin-top: 1em">The awk language supplies arrays
that are used for storing numbers or strings. Arrays need
not be declared. They shall initially be empty, and their
sizes shall change dynami&acirc; <br>
cally. The subscripts, or element identifiers, are strings,
providing a type of associative array capability. An array
name followed by a subscript within square brackets can be
<br>
used as an lvalue and thus as an expression, as described in
the grammar; see Grammar. Unsubscripted array names can be
used in only the following contexts:</p>

<p style="margin-top: 1em">* A parameter in a function
definition or function call</p>

<p style="margin-top: 1em">* The NAME token following any
use of the keyword in as specified in the grammar (see
Grammar); if the name used in this context is not an array
name, the behavior is undefined</p>

<p style="margin-top: 1em">A valid array index shall
consist of one or more &lt;comma&gt;-separated expressions,
similar to the way in which multi-dimensional arrays are
indexed in some programming languages. <br>
Because awk arrays are really one-dimensional, such a
&lt;comma&gt;-separated list shall be converted to a single
string by concatenating the string values of the separate
expressions, <br>
each separated from the other by the value of the SUBSEP
variable. Thus, the following two index operations shall be
equivalent:</p>

<p style="margin-top: 1em">var[expr1, expr2, ... exprn]</p>

<p style="margin-top: 1em">var[expr1 SUBSEP expr2 SUBSEP
... SUBSEP exprn]</p>

<p style="margin-top: 1em">The application shall ensure
that a multi-dimensioned index used with the in operator is
parenthesized. The in operator, which tests for the
existence of a particular array ele&acirc; <br>
ment, shall not cause that element to exist. Any other
reference to a nonexistent array element shall automatically
create it.</p>

<p style="margin-top: 1em">Comparisons (with the
&rsquo;&lt;&rsquo;, &quot;&lt;=&quot;, &quot;!=&quot;,
&quot;==&quot;, &rsquo;&gt;&rsquo;, and &quot;&gt;=&quot;
operators) shall be made numerically if both operands are
numeric, if one is numeric and the other has a string value
<br>
that is a numeric string, or if one is numeric and the other
has the uninitialized value. Otherwise, operands shall be
converted to strings as required and a string comparison
<br>
shall be made using the locale-specific collation sequence.
The value of the comparison expression shall be 1 if the
relation is true, or 0 if the relation is false.</p>

<p style="margin-top: 1em">Variables and Special Variables
<br>
Variables can be used in an awk program by referencing them.
With the exception of function parameters (see User-Defined
Functions), they are not explicitly declared. Function <br>
parameter names shall be local to the function; all other
variable names shall be global. The same name shall not be
used as both a function parameter name and as the name of a
<br>
function or a special awk variable. The same name shall not
be used both as a variable name with global scope and as the
name of a function. The same name shall not be used <br>
within the same scope both as a scalar variable and as an
array. Uninitialized variables, including scalar variables,
array elements, and field variables, shall have an
unini&acirc; <br>
tialized value. An uninitialized value shall have both a
numeric value of zero and a string value of the empty
string. Evaluation of variables with an uninitialized value,
to <br>
either string or numeric, shall be determined by the context
in which they are used.</p>

<p style="margin-top: 1em">Field variables shall be
designated by a &rsquo;$&rsquo; followed by a number or
numerical expression. The effect of the field number
expression evaluating to anything other than a
non-nega&acirc; <br>
tive integer is unspecified; uninitialized variables or
string values need not be converted to numeric values in
this context. New field variables can be created by
assigning a <br>
value to them. References to nonexistent fields (that is,
fields after $NF), shall evaluate to the uninitialized
value. Such references shall not create new fields. However,
<br>
assigning to a nonexistent field (for example, $(NF+2)=5)
shall increase the value of NF; create any intervening
fields with the uninitialized value; and cause the value of
$0 to <br>
be recomputed, with the fields being separated by the value
of OFS. Each field variable shall have a string value or an
uninitialized value when created. Field variables shall <br>
have the uninitialized value when created from $0 using FS
and the variable does not contain any characters. If
appropriate, the field variable shall be considered a
numeric <br>
string (see Expressions in awk).</p>

<p style="margin-top: 1em">Implementations shall support
the following other special variables that are set by
awk:</p>

<p style="margin-top: 1em">ARGC The number of elements in
the ARGV array.</p>

<p style="margin-top: 1em">ARGV An array of command line
arguments, excluding options and the program argument,
numbered from zero to ARGC&acirc;1.</p>

<p style="margin-top: 1em">The arguments in ARGV can be
modified or added to; ARGC can be altered. As each input
file ends, awk shall treat the next non-null element of
ARGV, up to the current <br>
value of ARGC&acirc;1, inclusive, as the name of the next
input file. Thus, setting an element of ARGV to null means
that it shall not be treated as an input file. The name <br>
&rsquo;&acirc;&rsquo; indicates the standard input. If an
argument matches the format of an assignment operand, this
argument shall be treated as an assignment rather than a
file argu&acirc; <br>
ment.</p>

<p style="margin-top: 1em">CONVFMT The printf format for
converting numbers to strings (except for output statements,
where OFMT is used); &quot;%.6g&quot; by default.</p>

<p style="margin-top: 1em">ENVIRON An array representing
the value of the environment, as described in the exec
functions defined in the System Interfaces volume of
POSIX.1&acirc;2008. The indices of the array <br>
shall be strings consisting of the names of the environment
variables, and the value of each array element shall be a
string consisting of the value of that variable. <br>
If appropriate, the environment variable shall be considered
a numeric string (see Expressions in awk); the array element
shall also have its numeric value.</p>

<p style="margin-top: 1em">In all cases where the behavior
of awk is affected by environment variables (including the
environment of any commands that awk executes via the system
function or via <br>
pipeline redirections with the print statement, the printf
statement, or the getline function), the environment used
shall be the environment at the time awk began exe&acirc;
<br>
cuting; it is implementation-defined whether any
modification of ENVIRON affects this environment.</p>

<p style="margin-top: 1em">FILENAME A pathname of the
current input file. Inside a BEGIN action the value is
undefined. Inside an END action the value shall be the name
of the last input file processed.</p>

<p style="margin-top: 1em">FNR The ordinal number of the
current record in the current file. Inside a BEGIN action
the value shall be zero. Inside an END action the value
shall be the number of the <br>
last record processed in the last file processed.</p>

<p style="margin-top: 1em">FS Input field separator regular
expression; a &lt;space&gt; by default.</p>

<p style="margin-top: 1em">NF The number of fields in the
current record. Inside a BEGIN action, the use of NF is
undefined unless a getline function without a var argument
is executed previously. <br>
Inside an END action, NF shall retain the value it had for
the last record read, unless a subsequent, redirected,
getline function without a var argument is performed <br>
prior to entering the END action.</p>

<p style="margin-top: 1em">NR The ordinal number of the
current record from the start of input. Inside a BEGIN
action the value shall be zero. Inside an END action the
value shall be the number of <br>
the last record processed.</p>

<p style="margin-top: 1em">OFMT The printf format for
converting numbers to strings in output statements (see
Output Statements); &quot;%.6g&quot; by default. The result
of the conversion is unspecified if the <br>
value of OFMT is not a floating-point format
specification.</p>

<p style="margin-top: 1em">OFS The print statement output
field separator; &lt;space&gt; by default.</p>

<p style="margin-top: 1em">ORS The print statement output
record separator; a &lt;newline&gt; by default.</p>

<p style="margin-top: 1em">RLENGTH The length of the string
matched by the match function.</p>

<p style="margin-top: 1em">RS The first character of the
string value of RS shall be the input record separator; a
&lt;newline&gt; by default. If RS contains more than one
character, the results are <br>
unspecified. If RS is null, then records are separated by
sequences consisting of a &lt;newline&gt; plus one or more
blank lines, leading or trailing blank lines shall not <br>
result in empty records at the beginning or end of the
input, and a &lt;newline&gt; shall always be a field
separator, no matter what the value of FS is.</p>

<p style="margin-top: 1em">RSTART The starting position of
the string matched by the match function, numbering from 1.
This shall always be equivalent to the return value of the
match function.</p>

<p style="margin-top: 1em">SUBSEP The subscript separator
string for multi-dimensional arrays; the default value is
implementation-defined.</p>

<p style="margin-top: 1em">Regular Expressions <br>
The awk utility shall make use of the extended regular
expression notation (see the Base Definitions volume of
POSIX.1&acirc;2008, Section 9.4, Extended Regular
Expressions) except <br>
that it shall allow the use of C-language conventions for
escaping special characters within the EREs, as specified in
the table in the Base Definitions volume of
POSIX.1&acirc;2008, <br>
Chapter 5, File Format Notation (&rsquo;\&rsquo;,
&rsquo;&rsquo;, &rsquo;,, &rsquo;0,&rsquo;, &rsquo;&rsquo;,
&rsquo; and the following table; these escape sequences
shall &rsquo; be recognized both inside and outside <br>
bracket expressions. Note that records need not be separated
by &lt;newline&gt; characters and string constants can
contain &lt;newline&gt; characters, so even the &quot;0
sequence is valid in <br>
awk EREs. Using a &lt;slash&gt; character within an ERE
requires the escaping shown in the following table.</p>

<p style="margin-top: 1em">Table 4-2: Escape Sequences in
awk</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; Escape &acirc; &acirc; &acirc; <br>
&acirc;Sequence &acirc; Description &acirc; Meaning &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc; &acirc; &lt;backslash&gt; &lt;slash&gt; &acirc;
&lt;slash&gt; character &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;dd &acirc; A &lt;backslash&gt; character followed
&acirc; The character whose encoding is &acirc; <br>
&acirc; &acirc; by the longest sequence of one, &acirc;
represented by the one, two, or &acirc; <br>
&acirc; &acirc; two, or three octal-digit charac&acirc;
&acirc; three-digit octal integer. Multi- &acirc; <br>
&acirc; &acirc; ters (01234567). If all of the &acirc; byte
characters require multiple, &acirc; <br>
&acirc; &acirc; digits are 0 (that is, representa&acirc;
&acirc; concatenated escape sequences of &acirc; <br>
&acirc; &acirc; tion of the NUL character), the &acirc; this
type, including the leading &acirc; <br>
&acirc; &acirc; behavior is undefined. &acirc;
&lt;backslash&gt; for each byte. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc; &acirc; &acirc; by any character not described in
&acirc; &acirc; <br>
&acirc; &acirc; this table or in the table in the &acirc;
&acirc; <br>
&acirc; &acirc; Base Definitions volume of &acirc; &acirc;
<br>
&acirc; &acirc; POSIX.1&acirc;2008, Chapter 5, File
For&acirc; &acirc; &acirc; <br>
&acirc; &acirc;, mat Notation (&rsquo;\&rsquo;,
&rsquo;&rsquo;, &rsquo;&acirc; &acirc; <br>
&acirc; &acirc;&rsquo;, &rsquo;&rsquo;, &rsquo;. &acirc;
&acirc; &rsquo;, &rsquo;0, &rsquo; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
A regular expression can be matched against a specific field
or string by using one of the two regular expression
matching operators, &rsquo;~&rsquo; and &quot;!~&quot;.
These operators shall inter&acirc; <br>
pret their right-hand operand as a regular expression and
their left-hand operand as a string. If the regular
expression matches the string, the &rsquo;~&rsquo;
expression shall evaluate to <br>
a value of 1, and the &quot;!~&quot; expression shall
evaluate to a value of 0. (The regular expression matching
operation is as defined by the term matched in the Base
Definitions volume <br>
of POSIX.1&acirc;2008, Section 9.1, Regular Expression
Definitions, where a match occurs on any part of the string
unless the regular expression is limited with the
&lt;circumflex&gt; or <br>
&lt;dollar-sign&gt; special characters.) If the regular
expression does not match the string, the &rsquo;~&rsquo;
expression shall evaluate to a value of 0, and the
&quot;!~&quot; expression shall evaluate <br>
to a value of 1. If the right-hand operand is any expression
other than the lexical token ERE, the string value of the
expression shall be interpreted as an extended regular <br>
expression, including the escape conventions described
above. Note that these same escape conventions shall also be
applied in determining the value of a string literal (the
<br>
lexical token STRING), and thus shall be applied a second
time when a string literal is used in this context.</p>

<p style="margin-top: 1em">When an ERE token appears as an
expression in any context other than as the right-hand of
the &rsquo;~&rsquo; or &quot;!~&quot; operator or as one of
the built-in function arguments described below, <br>
the value of the resulting expression shall be the
equivalent of:</p>

<p style="margin-top: 1em">$0 &quot; &quot; /ere/</p>

<p style="margin-top: 1em">The ere argument to the gsub,
match, sub functions, and the fs argument to the split
function (see String Functions) shall be interpreted as
extended regular expressions. These <br>
can be either ERE tokens or arbitrary expressions, and shall
be interpreted in the same manner as the right-hand side of
the &rsquo;~&rsquo; or &quot;!~&quot; operator.</p>

<p style="margin-top: 1em">An extended regular expression
can be used to separate fields by assigning a string
containing the expression to the built-in variable FS,
either directly or as a consequence of <br>
using the &acirc;F sepstring option. The default value of
the FS variable shall be a single &lt;space&gt;. The
following describes FS behavior:</p>

<p style="margin-top: 1em">1. If FS is a null string, the
behavior is unspecified.</p>

<p style="margin-top: 1em">2. If FS is a single
character:</p>

<p style="margin-top: 1em">a. If FS is &lt;space&gt;, skip
leading and trailing &lt;blank&gt; and &lt;newline&gt;
characters; fields shall be delimited by sets of one or more
&lt;blank&gt; or &lt;newline&gt; characters.</p>

<p style="margin-top: 1em">b. Otherwise, if FS is any other
character c, fields shall be delimited by each single
occurrence of c.</p>

<p style="margin-top: 1em">3. Otherwise, the string value
of FS shall be considered to be an extended regular
expression. Each occurrence of a sequence matching the
extended regular expression shall <br>
delimit fields.</p>

<p style="margin-top: 1em">Except for the &rsquo;~&rsquo;
and &quot;!~&quot; operators, and in the gsub, match, split,
and sub built-in functions, ERE matching shall be based on
input records; that is, record separator charac&acirc; <br>
ters (the first character of the value of the variable RS,
&lt;newline&gt; by default) cannot be embedded in the
expression, and no expression shall match the record
separator charac&acirc; <br>
ter. If the record separator is not &lt;newline&gt;,
&lt;newline&gt; characters embedded in the expression can be
matched. For the &rsquo;~&rsquo; and &quot;!~&quot;
operators, and in those four built-in func&acirc; <br>
tions, ERE matching shall be based on text strings; that is,
any character (including &lt;newline&gt; and the record
separator) can be embedded in the pattern, and an
appropriate pat&acirc; <br>
tern shall match any character. However, in all awk ERE
matching, the use of one or more NUL characters in the
pattern, input record, or text string produces undefined
results.</p>

<p style="margin-top: 1em">Patterns <br>
A pattern is any valid expression, a range specified by two
expressions separated by a comma, or one of the two special
patterns BEGIN or END.</p>

<p style="margin-top: 1em">Special Patterns <br>
The awk utility shall recognize two special patterns, BEGIN
and END. Each BEGIN pattern shall be matched once and its
associated action executed before the first record of input
<br>
is read&acirc;except possibly by use of the getline function
(see Input/Output and General Functions) in a prior BEGIN
action&acirc;and before command line assignment is done.
Each END pat&acirc; <br>
tern shall be matched once and its associated action
executed after the last record of input has been read. These
two patterns shall have associated actions.</p>

<p style="margin-top: 1em">BEGIN and END shall not combine
with other patterns. Multiple BEGIN and END patterns shall
be allowed. The actions associated with the BEGIN patterns
shall be executed in the <br>
order specified in the program, as are the END actions. An
END pattern can precede a BEGIN pattern in a program.</p>

<p style="margin-top: 1em">If an awk program consists of
only actions with the pattern BEGIN, and the BEGIN action
contains no getline function, awk shall exit without reading
its input when the last <br>
statement in the last BEGIN action is executed. If an awk
program consists of only actions with the pattern END or
only actions with the patterns BEGIN and END, the input
shall <br>
be read before the statements in the END actions are
executed.</p>

<p style="margin-top: 1em">Expression Patterns <br>
An expression pattern shall be evaluated as if it were an
expression in a Boolean context. If the result is true, the
pattern shall be considered to match, and the associated
<br>
action (if any) shall be executed. If the result is false,
the action shall not be executed.</p>

<p style="margin-top: 1em">Pattern Ranges <br>
A pattern range consists of two expressions separated by a
comma; in this case, the action shall be performed for all
records between a match of the first expression and the
fol&acirc; <br>
lowing match of the second expression, inclusive. At this
point, the pattern range can be repeated starting at input
records subsequent to the end of the matched range.</p>

<p style="margin-top: 1em">Actions <br>
An action is a sequence of statements as shown in the
grammar in Grammar. Any single statement can be replaced by
a statement list enclosed in curly braces. The application
<br>
shall ensure that statements in a statement list are
separated by &lt;newline&gt; or &lt;semicolon&gt;
characters. Statements in a statement list shall be executed
sequentially in the order <br>
that they appear.</p>

<p style="margin-top: 1em">The expression acting as the
conditional in an if statement shall be evaluated and if it
is non-zero or non-null, the following statement shall be
executed; otherwise, if else is <br>
present, the statement following the else shall be
executed.</p>

<p style="margin-top: 1em">The if, while, do...while, for,
break, and continue statements are based on the ISO C
standard (see Section 1.1.2, Concepts Derived from the ISO C
Standard), except that the <br>
Boolean expressions shall be treated as described in
Expressions in awk, and except in the case of:</p>

<p style="margin-top: 1em">for (variable in array)</p>

<p style="margin-top: 1em">which shall iterate, assigning
each index of array to variable in an unspecified order. The
results of adding new elements to array within such a for
loop are undefined. If a <br>
break or continue statement occurs outside of a loop, the
behavior is undefined.</p>

<p style="margin-top: 1em">The delete statement shall
remove an individual array element. Thus, the following code
deletes an entire array:</p>

<p style="margin-top: 1em">for (index in array) <br>
delete array[index]</p>

<p style="margin-top: 1em">The next statement shall cause
all further processing of the current input record to be
abandoned. The behavior is undefined if a next statement
appears or is invoked in a BEGIN <br>
or END action.</p>

<p style="margin-top: 1em">The exit statement shall invoke
all END actions in the order in which they occur in the
program source and then terminate the program without
reading further input. An exit <br>
statement inside an END action shall terminate the program
without further execution of END actions. If an expression
is specified in an exit statement, its numeric value shall
<br>
be the exit status of awk, unless subsequent errors are
encountered or a subsequent exit statement with an
expression is executed.</p>

<p style="margin-top: 1em">Output Statements <br>
Both print and printf statements shall write to standard
output by default. The output shall be written to the
location specified by output_redirection if one is supplied,
as <br>
follows:</p>

<p style="margin-top: 1em">&gt; expression <br>
&gt;&gt; expression <br>
| expression</p>

<p style="margin-top: 1em">In all cases, the expression
shall be evaluated to produce a string that is used as a
pathname into which to write (for &rsquo;&gt;&rsquo; or
&quot;&gt;&gt;&quot;) or as a command to be executed (for
&rsquo;|&rsquo;). <br>
Using the first two forms, if the file of that name is not
currently open, it shall be opened, creating it if necessary
and using the first form, truncating the file. The output
<br>
then shall be appended to the file. As long as the file
remains open, subsequent calls in which expression evaluates
to the same string value shall simply append output to the
<br>
file. The file remains open until the close function (see
Input/Output and General Functions) is called with an
expression that evaluates to the same string value.</p>

<p style="margin-top: 1em">The third form shall write
output onto a stream piped to the input of a command. The
stream shall be created if no stream is currently open with
the value of expression as its <br>
command name. The stream created shall be equivalent to one
created by a call to the popen() function defined in the
System Interfaces volume of POSIX.1&acirc;2008 with the
value of <br>
expression as the command argument and a value of w as the
mode argument. As long as the stream remains open,
subsequent calls in which expression evaluates to the same
string <br>
value shall write output to the existing stream. The stream
shall remain open until the close function (see Input/Output
and General Functions) is called with an expression that
<br>
evaluates to the same string value. At that time, the stream
shall be closed as if by a call to the pclose() function
defined in the System Interfaces volume of
POSIX.1&acirc;2008.</p>

<p style="margin-top: 1em">As described in detail by the
grammar in Grammar, these output statements shall take a
&lt;comma&gt;-separated list of expressions referred to in
the grammar by the non-terminal sym&acirc; <br>
bols expr_list, print_expr_list, or print_expr_list_opt.
This list is referred to here as the expression list, and
each member is referred to as an expression argument.</p>

<p style="margin-top: 1em">The print statement shall write
the value of each expression argument onto the indicated
output stream separated by the current output field
separator (see variable OFS above), <br>
and terminated by the output record separator (see variable
ORS above). All expression arguments shall be taken as
strings, being converted if necessary; this conversion shall
be <br>
as described in Expressions in awk, with the exception that
the printf format in OFMT shall be used instead of the value
in CONVFMT. An empty expression list shall stand for the
<br>
whole input record ($0).</p>

<p style="margin-top: 1em">The printf statement shall
produce output based on a notation similar to the File
Format Notation used to describe file formats in this volume
of POSIX.1&acirc;2008 (see the Base Defi&acirc; <br>
nitions volume of POSIX.1&acirc;2008, Chapter 5, File Format
Notation). Output shall be produced as specified with the
first expression argument as the string format and
subsequent <br>
expression arguments as the strings arg1 to argn, inclusive,
with the following exceptions:</p>

<p style="margin-top: 1em">1. The format shall be an actual
character string rather than a graphical representation.
Therefore, it cannot contain empty character positions. The
&lt;space&gt; in the format <br>
string, in any context other than a flag of a conversion
specification, shall be treated as an ordinary character
that is copied to the output.</p>

<p style="margin-top: 1em">2. If the character set contains
a &rsquo;&rsquo; character and that character appears in the
format string, it shall be treated as an ordinary character
that is copied to the output.</p>

<p style="margin-top: 1em">3. The escape sequences
beginning with a &lt;backslash&gt; character shall be
treated as sequences of ordinary characters that are copied
to the output. Note that these same sequences <br>
shall be interpreted lexically by awk when they appear in
literal strings, but they shall not be treated specially by
the printf statement.</p>

<p style="margin-top: 1em">4. A field width or precision
can be specified as the &rsquo;*&rsquo; character instead of
a digit string. In this case the next argument from the
expression list shall be fetched and its <br>
numeric value taken as the field width or precision.</p>

<p style="margin-top: 1em">5. The implementation shall not
precede or follow output from the d or u conversion
specifier characters with &lt;blank&gt; characters not
specified by the format string.</p>

<p style="margin-top: 1em">6. The implementation shall not
precede output from the o conversion specifier character
with leading zeros not specified by the format string.</p>

<p style="margin-top: 1em">7. For the c conversion
specifier character: if the argument has a numeric value,
the character whose encoding is that value shall be output.
If the value is zero or is not the <br>
encoding of any character in the character set, the behavior
is undefined. If the argument does not have a numeric value,
the first character of the string value shall be <br>
output; if the string does not contain any characters, the
behavior is undefined.</p>

<p style="margin-top: 1em">8. For each conversion
specification that consumes an argument, the next expression
argument shall be evaluated. With the exception of the c
conversion specifier character, the <br>
value shall be converted (according to the rules specified
in Expressions in awk) to the appropriate type for the
conversion specification.</p>

<p style="margin-top: 1em">9. If there are insufficient
expression arguments to satisfy all the conversion
specifications in the format string, the behavior is
undefined.</p>

<p style="margin-top: 1em">10. If any character sequence in
the format string begins with a &rsquo;%&rsquo; character,
but does not form a valid conversion specification, the
behavior is unspecified.</p>

<p style="margin-top: 1em">Both print and printf can output
at least {LINE_MAX} bytes.</p>

<p style="margin-top: 1em">Functions <br>
The awk language has a variety of built-in functions:
arithmetic, string, input/output, and general.</p>

<p style="margin-top: 1em">Arithmetic Functions <br>
The arithmetic functions, except for int, shall be based on
the ISO C standard (see Section 1.1.2, Concepts Derived from
the ISO C Standard). The behavior is undefined in cases <br>
where the ISO C standard specifies that an error be returned
or that the behavior is undefined. Although the grammar (see
Grammar) permits built-in functions to appear with no <br>
arguments or parentheses, unless the argument or parentheses
are indicated as optional in the following list (by
displaying them within the &quot;[]&quot; brackets), such
use is undefined.</p>

<p style="margin-top: 1em">atan2(y,x) <br>
Return arctangent of y/x in radians in the range
[&acirc;&Iuml;,&Iuml;].</p>

<p style="margin-top: 1em">cos(x) Return cosine of x, where
x is in radians.</p>

<p style="margin-top: 1em">sin(x) Return sine of x, where x
is in radians.</p>

<p style="margin-top: 1em">exp(x) Return the exponential
function of x.</p>

<p style="margin-top: 1em">log(x) Return the natural
logarithm of x.</p>

<p style="margin-top: 1em">sqrt(x) Return the square root
of x.</p>

<p style="margin-top: 1em">int(x) Return the argument
truncated to an integer. Truncation shall be toward 0 when
x&gt;0.</p>

<p style="margin-top: 1em">rand() Return a random number n,
such that 0&acirc;&curren;n&lt;1.</p>

<p style="margin-top: 1em">srand([expr]) <br>
Set the seed value for rand to expr or use the time of day
if expr is omitted. The previous seed value shall be
returned.</p>

<p style="margin-top: 1em">String Functions <br>
The string functions in the following list shall be
supported. Although the grammar (see Grammar) permits
built-in functions to appear with no arguments or
parentheses, unless <br>
the argument or parentheses are indicated as optional in the
following list (by displaying them within the &quot;[]&quot;
brackets), such use is undefined.</p>

<p style="margin-top: 1em">gsub(ere, repl[, in]) <br>
Behave like sub (see below), except that it shall replace
all occurrences of the regular expression (like the ed
utility global substitute) in $0 or in the in argument, <br>
when specified.</p>

<p style="margin-top: 1em">index(s, t) <br>
Return the position, in characters, numbering from 1, in
string s where string t first occurs, or zero if it does not
occur at all.</p>

<p style="margin-top: 1em">length[([s])] <br>
Return the length, in characters, of its argument taken as a
string, or of the whole record, $0, if there is no
argument.</p>

<p style="margin-top: 1em">match(s, ere) <br>
Return the position, in characters, numbering from 1, in
string s where the extended regular expression ere occurs,
or zero if it does not occur at all. RSTART shall be <br>
set to the starting position (which is the same as the
returned value), zero if no match is found; RLENGTH shall be
set to the length of the matched string, &acirc;1 if no <br>
match is found.</p>

<p style="margin-top: 1em">split(s, a[, fs ]) <br>
Split the string s into array elements a[1], a[2], ...,
a[n], and return n. All elements of the array shall be
deleted before the split is performed. The separation <br>
shall be done with the ERE fs or with the field separator FS
if fs is not given. Each array element shall have a string
value when created and, if appropriate, the <br>
array element shall be considered a numeric string (see
Expressions in awk). The effect of a null string as the
value of fs is unspecified.</p>

<p style="margin-top: 1em">sprintf(fmt, expr, expr, ...)
<br>
Format the expressions according to the printf format given
by fmt and return the resulting string.</p>

<p style="margin-top: 1em">sub(ere, repl[, in ]) <br>
Substitute the string repl in place of the first instance of
the extended regular expression ERE in string in and return
the number of substitutions. An &lt;ampersand&gt; <br>
(&rsquo;&amp;&rsquo;) appearing in the string repl shall be
replaced by the string from in that matches the ERE. An
&lt;ampersand&gt; preceded with a &lt;backslash&gt; shall be
interpreted as the <br>
literal &lt;ampersand&gt; character. An occurrence of two
consecutive &lt;backslash&gt; characters shall be
interpreted as just a single literal &lt;backslash&gt;
character. Any other <br>
occurrence of a &lt;backslash&gt; (for example, preceding
any other character) shall be treated as a literal
&lt;backslash&gt; character. Note that if repl is a string
literal (the <br>
lexical token STRING; see Grammar), the handling of the
&lt;ampersand&gt; character occurs after any lexical
processing, including any lexical &lt;backslash&gt;-escape
sequence <br>
processing. If in is specified and it is not an lvalue (see
Expressions in awk), the behavior is undefined. If in is
omitted, awk shall use the current record ($0) in <br>
its place.</p>

<p style="margin-top: 1em">substr(s, m[, n ]) <br>
Return the at most n-character substring of s that begins at
position m, numbering from 1. If n is omitted, or if n
specifies more characters than are left in the <br>
string, the length of the substring shall be limited by the
length of the string s.</p>

<p style="margin-top: 1em">tolower(s) <br>
Return a string based on the string s. Each character in s
that is an uppercase letter specified to have a tolower
mapping by the LC_CTYPE category of the current <br>
locale shall be replaced in the returned string by the
lowercase letter specified by the mapping. Other characters
in s shall be unchanged in the returned string.</p>

<p style="margin-top: 1em">toupper(s) <br>
Return a string based on the string s. Each character in s
that is a lowercase letter specified to have a toupper
mapping by the LC_CTYPE category of the current <br>
locale is replaced in the returned string by the uppercase
letter specified by the mapping. Other characters in s are
unchanged in the returned string.</p>

<p style="margin-top: 1em">All of the preceding functions
that take ERE as a parameter expect a pattern or a string
valued expression that is a regular expression as defined in
Regular Expressions.</p>

<p style="margin-top: 1em">Input/Output and General
Functions <br>
The input/output and general functions are:</p>

<p style="margin-top: 1em">close(expression) <br>
Close the file or pipe opened by a print or printf statement
or a call to getline with the same string-valued expression.
The limit on the number of open expression <br>
arguments is implementation-defined. If the close was
successful, the function shall return zero; otherwise, it
shall return non-zero.</p>

<p style="margin-top: 1em">expression | getline [var] <br>
Read a record of input from a stream piped from the output
of a command. The stream shall be created if no stream is
currently open with the value of expression as its <br>
command name. The stream created shall be equivalent to one
created by a call to the popen() function with the value of
expression as the command argument and a value <br>
of r as the mode argument. As long as the stream remains
open, subsequent calls in which expression evaluates to the
same string value shall read subsequent records <br>
from the stream. The stream shall remain open until the
close function is called with an expression that evaluates
to the same string value. At that time, the stream <br>
shall be closed as if by a call to the pclose() function. If
var is omitted, $0 and NF shall be set; otherwise, var shall
be set and, if appropriate, it shall be con&acirc; <br>
sidered a numeric string (see Expressions in awk).</p>

<p style="margin-top: 1em">The getline operator can form
ambiguous constructs when there are unparenthesized
operators (including concatenate) to the left of the
&rsquo;|&rsquo; (to the beginning of the <br>
expression containing getline). In the context of the
&rsquo;$&rsquo; operator, &rsquo;|&rsquo; shall behave as if
it had a lower precedence than &rsquo;$&rsquo;. The result
of evaluating other opera&acirc; <br>
tors is unspecified, and conforming applications shall
parenthesize properly all such usages.</p>

<p style="margin-top: 1em">getline Set $0 to the next input
record from the current input file. This form of getline
shall set the NF, NR, and FNR variables.</p>

<p style="margin-top: 1em">getline var <br>
Set variable var to the next input record from the current
input file and, if appropriate, var shall be considered a
numeric string (see Expressions in awk). This form <br>
of getline shall set the FNR and NR variables.</p>

<p style="margin-top: 1em">getline [var] &lt; expression
<br>
Read the next record of input from a named file. The
expression shall be evaluated to produce a string that is
used as a pathname. If the file of that name is not
cur&acirc; <br>
rently open, it shall be opened. As long as the stream
remains open, subsequent calls in which expression evaluates
to the same string value shall read subsequent <br>
records from the file. The file shall remain open until the
close function is called with an expression that evaluates
to the same string value. If var is omitted, $0 <br>
and NF shall be set; otherwise, var shall be set and, if
appropriate, it shall be considered a numeric string (see
Expressions in awk).</p>

<p style="margin-top: 1em">The getline operator can form
ambiguous constructs when there are unparenthesized binary
operators (including concatenate) to the right of the
&rsquo;&lt;&rsquo; (up to the end of the <br>
expression containing the getline). The result of evaluating
such a construct is unspecified, and conforming applications
shall parenthesize properly all such usages.</p>

<p style="margin-top: 1em">system(expression) <br>
Execute the command given by expression in a manner
equivalent to the system() function defined in the System
Interfaces volume of POSIX.1&acirc;2008 and return the exit
sta&acirc; <br>
tus of the command.</p>

<p style="margin-top: 1em">All forms of getline shall
return 1 for successful input, zero for end-of-file, and
&acirc;1 for an error.</p>

<p style="margin-top: 1em">Where strings are used as the
name of a file or pipeline, the application shall ensure
that the strings are textually identical. The terminology
&lsquo;&lsquo;same string value&rsquo;&rsquo; implies <br>
that &lsquo;&lsquo;equivalent strings&rsquo;&rsquo;, even
those that differ only by &lt;space&gt; characters,
represent different files.</p>

<p style="margin-top: 1em">User-Defined Functions <br>
The awk language also provides user-defined functions. Such
functions can be defined as:</p>

<p style="margin-top: 1em">function name([parameter, ...])
{ statements }</p>

<p style="margin-top: 1em">A function can be referred to
anywhere in an awk program; in particular, its use can
precede its definition. The scope of a function is
global.</p>

<p style="margin-top: 1em">Function parameters, if present,
can be either scalars or arrays; the behavior is undefined
if an array name is passed as a parameter that the function
uses as a scalar, or if a <br>
scalar expression is passed as a parameter that the function
uses as an array. Function parameters shall be passed by
value if scalar and by reference if array name.</p>

<p style="margin-top: 1em">The number of parameters in the
function definition need not match the number of parameters
in the function call. Excess formal parameters can be used
as local variables. If <br>
fewer arguments are supplied in a function call than are in
the function definition, the extra parameters that are used
in the function body as scalars shall evaluate to the <br>
uninitialized value until they are otherwise initialized,
and the extra parameters that are used in the function body
as arrays shall be treated as uninitialized arrays where
<br>
each element evaluates to the uninitialized value until
otherwise initialized.</p>

<p style="margin-top: 1em">When invoking a function, no
white space can be placed between the function name and the
opening parenthesis. Function calls can be nested and
recursive calls can be made upon <br>
functions. Upon return from any nested or recursive function
call, the values of all of the calling function&rsquo;s
parameters shall be unchanged, except for array parameters
passed <br>
by reference. The return statement can be used to return a
value. If a return statement appears outside of a function
definition, the behavior is undefined.</p>

<p style="margin-top: 1em">In the function definition,
&lt;newline&gt; characters shall be optional before the
opening brace and after the closing brace. Function
definitions can appear anywhere in the program <br>
where a pattern-action pair is allowed.</p>

<p style="margin-top: 1em">Grammar <br>
The grammar in this section and the lexical conventions in
the following section shall together describe the syntax for
awk programs. The general conventions for this style of <br>
grammar are described in Section 1.3, Grammar Conventions. A
valid program can be represented as the non-terminal symbol
program in the grammar. This formal syntax shall take <br>
precedence over the preceding text syntax description.</p>

<p style="margin-top: 1em">%token NAME NUMBER STRING ERE
<br>
%token FUNC_NAME /* Name followed by &rsquo;(&rsquo; without
white space. */</p>

<p style="margin-top: 1em">/* Keywords */ <br>
%token Begin End <br>
/* &rsquo;BEGIN&rsquo; &rsquo;END&rsquo; */</p>

<p style="margin-top: 1em">%token Break Continue Delete Do
Else <br>
/* &rsquo;break&rsquo; &rsquo;continue&rsquo;
&rsquo;delete&rsquo; &rsquo;do&rsquo; &rsquo;else&rsquo;
*/</p>

<p style="margin-top: 1em">%token Exit For Function If In
<br>
/* &rsquo;exit&rsquo; &rsquo;for&rsquo;
&rsquo;function&rsquo; &rsquo;if&rsquo; &rsquo;in&rsquo;
*/</p>

<p style="margin-top: 1em">%token Next Print Printf Return
While <br>
/* &rsquo;next&rsquo; &rsquo;print&rsquo;
&rsquo;printf&rsquo; &rsquo;return&rsquo;
&rsquo;while&rsquo; */</p>

<p style="margin-top: 1em">/* Reserved function names */
<br>
%token BUILTIN_FUNC_NAME <br>
/* One token for the following: <br>
* atan2 cos sin exp log sqrt int rand srand <br>
* gsub index length match split sprintf sub <br>
* substr tolower toupper close system <br>
*/ <br>
%token GETLINE <br>
/* Syntactically different from other built-ins. */</p>

<p style="margin-top: 1em">/* Two-character tokens. */ <br>
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN
MOD_ASSIGN POW_ASSIGN <br>
/* &rsquo;+=&rsquo; &rsquo;&acirc;=&rsquo; &rsquo;*=&rsquo;
&rsquo;/=&rsquo; &rsquo;%=&rsquo; &rsquo;^=&rsquo; */</p>

<p style="margin-top: 1em">%token OR AND NO_MATCH EQ LE GE
NE INCR DECR APPEND <br>
/* &rsquo;||&rsquo; &rsquo;&amp;&amp;&rsquo;
&rsquo;!~&rsquo; &rsquo;==&rsquo; &rsquo;&lt;=&rsquo;
&rsquo;&gt;=&rsquo; &rsquo;!=&rsquo; &rsquo;++&rsquo;
&rsquo;&acirc;&acirc;&rsquo; &rsquo;&gt;&gt;&rsquo; */</p>

<p style="margin-top: 1em">/* One-character tokens. */ <br>
%token &rsquo;{&rsquo; &rsquo;}&rsquo; &rsquo;(&rsquo;
&rsquo;)&rsquo; &rsquo;[&rsquo; &rsquo;]&rsquo;
&rsquo;,&rsquo; &rsquo;;&rsquo; NEWLINE <br>
%token &rsquo;+&rsquo; &rsquo;&acirc;&rsquo; &rsquo;*&rsquo;
&rsquo;%&rsquo; &rsquo;^&rsquo; &rsquo;!&rsquo;
&rsquo;&gt;&rsquo; &rsquo;&lt;&rsquo; &rsquo;|&rsquo;
&rsquo;?&rsquo; &rsquo;:&rsquo; &rsquo; &quot; &quot;
&rsquo; &rsquo;$&rsquo; &rsquo;=&rsquo;</p>

<p style="margin-top: 1em">%start program <br>
%%</p>

<p style="margin-top: 1em">program : item_list <br>
| actionless_item_list <br>
;</p>

<p style="margin-top: 1em">item_list : newline_opt <br>
| actionless_item_list item terminator <br>
| item_list item terminator <br>
| item_list action terminator <br>
;</p>

<p style="margin-top: 1em">actionless_item_list : item_list
pattern terminator <br>
| actionless_item_list pattern terminator <br>
;</p>

<p style="margin-top: 1em">item : pattern action <br>
| Function NAME &rsquo;(&rsquo; param_list_opt
&rsquo;)&rsquo; <br>
newline_opt action <br>
| Function FUNC_NAME &rsquo;(&rsquo; param_list_opt
&rsquo;)&rsquo; <br>
newline_opt action <br>
;</p>

<p style="margin-top: 1em">param_list_opt : /* empty */
<br>
| param_list <br>
;</p>

<p style="margin-top: 1em">param_list : NAME <br>
| param_list &rsquo;,&rsquo; NAME <br>
;</p>

<p style="margin-top: 1em">pattern : Begin <br>
| End <br>
| expr <br>
| expr &rsquo;,&rsquo; newline_opt expr <br>
;</p>

<p style="margin-top: 1em">action : &rsquo;{&rsquo;
newline_opt &rsquo;}&rsquo; <br>
| &rsquo;{&rsquo; newline_opt terminated_statement_list
&rsquo;}&rsquo; <br>
| &rsquo;{&rsquo; newline_opt unterminated_statement_list
&rsquo;}&rsquo; <br>
;</p>

<p style="margin-top: 1em">terminator : terminator
&rsquo;;&rsquo; <br>
| terminator NEWLINE <br>
| &rsquo;;&rsquo; <br>
| NEWLINE <br>
;</p>

<p style="margin-top: 1em">terminated_statement_list :
terminated_statement <br>
| terminated_statement_list terminated_statement <br>
;</p>

<p style="margin-top: 1em">unterminated_statement_list :
unterminated_statement <br>
| terminated_statement_list unterminated_statement <br>
;</p>

<p style="margin-top: 1em">terminated_statement : action
newline_opt <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
Else newline_opt terminated_statement <br>
| While &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
| For &rsquo;(&rsquo; simple_statement_opt &rsquo;;&rsquo;
<br>
expr_opt &rsquo;;&rsquo; simple_statement_opt
&rsquo;)&rsquo; newline_opt <br>
terminated_statement <br>
| For &rsquo;(&rsquo; NAME In NAME &rsquo;)&rsquo;
newline_opt <br>
terminated_statement <br>
| &rsquo;;&rsquo; newline_opt <br>
| terminatable_statement NEWLINE newline_opt <br>
| terminatable_statement &rsquo;;&rsquo; newline_opt <br>
;</p>

<p style="margin-top: 1em">unterminated_statement :
terminatable_statement <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
unterminated_statement <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
Else newline_opt unterminated_statement <br>
| While &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
unterminated_statement <br>
| For &rsquo;(&rsquo; simple_statement_opt &rsquo;;&rsquo;
<br>
expr_opt &rsquo;;&rsquo; simple_statement_opt
&rsquo;)&rsquo; newline_opt <br>
unterminated_statement <br>
| For &rsquo;(&rsquo; NAME In NAME &rsquo;)&rsquo;
newline_opt <br>
unterminated_statement <br>
;</p>

<p style="margin-top: 1em">terminatable_statement :
simple_statement <br>
| Break <br>
| Continue <br>
| Next <br>
| Exit expr_opt <br>
| Return expr_opt <br>
| Do newline_opt terminated_statement While &rsquo;(&rsquo;
expr &rsquo;)&rsquo; <br>
;</p>

<p style="margin-top: 1em">simple_statement_opt : /* empty
*/ <br>
| simple_statement <br>
;</p>

<p style="margin-top: 1em">simple_statement : Delete NAME
&rsquo;[&rsquo; expr_list &rsquo;]&rsquo; <br>
| expr <br>
| print_statement <br>
;</p>

<p style="margin-top: 1em">print_statement :
simple_print_statement <br>
| simple_print_statement output_redirection <br>
;</p>

<p style="margin-top: 1em">simple_print_statement : Print
print_expr_list_opt <br>
| Print &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo;
<br>
| Printf print_expr_list <br>
| Printf &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo;
<br>
;</p>

<p style="margin-top: 1em">output_redirection :
&rsquo;&gt;&rsquo; expr <br>
| APPEND expr <br>
| &rsquo;|&rsquo; expr <br>
;</p>

<p style="margin-top: 1em">expr_list_opt : /* empty */ <br>
| expr_list <br>
;</p>

<p style="margin-top: 1em">expr_list : expr <br>
| multiple_expr_list <br>
;</p>

<p style="margin-top: 1em">multiple_expr_list : expr
&rsquo;,&rsquo; newline_opt expr <br>
| multiple_expr_list &rsquo;,&rsquo; newline_opt expr <br>
;</p>

<p style="margin-top: 1em">expr_opt : /* empty */ <br>
| expr <br>
;</p>

<p style="margin-top: 1em">expr : unary_expr <br>
| non_unary_expr <br>
;</p>

<p style="margin-top: 1em">unary_expr : &rsquo;+&rsquo;
expr <br>
| &rsquo;&acirc;&rsquo; expr <br>
| unary_expr &rsquo;^&rsquo; expr <br>
| unary_expr &rsquo;*&rsquo; expr <br>
| unary_expr &rsquo;/&rsquo; expr <br>
| unary_expr &rsquo;%&rsquo; expr <br>
| unary_expr &rsquo;+&rsquo; expr <br>
| unary_expr &rsquo;&acirc;&rsquo; expr <br>
| unary_expr non_unary_expr <br>
| unary_expr &rsquo;&lt;&rsquo; expr <br>
| unary_expr LE expr <br>
| unary_expr NE expr <br>
| unary_expr EQ expr <br>
| unary_expr &rsquo;&gt;&rsquo; expr <br>
| unary_expr GE expr <br>
| unary_expr &rsquo;~&rsquo; expr <br>
| unary_expr NO_MATCH expr <br>
| unary_expr In NAME <br>
| unary_expr AND newline_opt expr <br>
| unary_expr OR newline_opt expr <br>
| unary_expr &rsquo;?&rsquo; expr &rsquo;:&rsquo; expr <br>
| unary_input_function <br>
;</p>

<p style="margin-top: 1em">non_unary_expr : &rsquo;(&rsquo;
expr &rsquo;)&rsquo; <br>
| &rsquo;!&rsquo; expr <br>
| non_unary_expr &rsquo;^&rsquo; expr <br>
| non_unary_expr &rsquo;*&rsquo; expr <br>
| non_unary_expr &rsquo;/&rsquo; expr <br>
| non_unary_expr &rsquo;%&rsquo; expr <br>
| non_unary_expr &rsquo;+&rsquo; expr <br>
| non_unary_expr &rsquo;&acirc;&rsquo; expr <br>
| non_unary_expr non_unary_expr <br>
| non_unary_expr &rsquo;&lt;&rsquo; expr <br>
| non_unary_expr LE expr <br>
| non_unary_expr NE expr <br>
| non_unary_expr EQ expr <br>
| non_unary_expr &rsquo;&gt;&rsquo; expr <br>
| non_unary_expr GE expr <br>
| non_unary_expr &rsquo;~&rsquo; expr <br>
| non_unary_expr NO_MATCH expr <br>
| non_unary_expr In NAME <br>
| &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo; In NAME
<br>
| non_unary_expr AND newline_opt expr <br>
| non_unary_expr OR newline_opt expr <br>
| non_unary_expr &rsquo;?&rsquo; expr &rsquo;:&rsquo; expr
<br>
| NUMBER <br>
| STRING <br>
| lvalue <br>
| ERE <br>
| lvalue INCR <br>
| lvalue DECR <br>
| INCR lvalue <br>
| DECR lvalue <br>
| lvalue POW_ASSIGN expr <br>
| lvalue MOD_ASSIGN expr <br>
| lvalue MUL_ASSIGN expr <br>
| lvalue DIV_ASSIGN expr <br>
| lvalue ADD_ASSIGN expr <br>
| lvalue SUB_ASSIGN expr <br>
| lvalue &rsquo;=&rsquo; expr <br>
| FUNC_NAME &rsquo;(&rsquo; expr_list_opt &rsquo;)&rsquo;
<br>
/* no white space allowed before &rsquo;(&rsquo; */ <br>
| BUILTIN_FUNC_NAME &rsquo;(&rsquo; expr_list_opt
&rsquo;)&rsquo; <br>
| BUILTIN_FUNC_NAME <br>
| non_unary_input_function <br>
;</p>

<p style="margin-top: 1em">print_expr_list_opt : /* empty
*/ <br>
| print_expr_list <br>
;</p>

<p style="margin-top: 1em">print_expr_list : print_expr
<br>
| print_expr_list &rsquo;,&rsquo; newline_opt print_expr
<br>
;</p>

<p style="margin-top: 1em">print_expr : unary_print_expr
<br>
| non_unary_print_expr <br>
;</p>

<p style="margin-top: 1em">unary_print_expr :
&rsquo;+&rsquo; print_expr <br>
| &rsquo;&acirc;&rsquo; print_expr <br>
| unary_print_expr &rsquo;^&rsquo; print_expr <br>
| unary_print_expr &rsquo;*&rsquo; print_expr <br>
| unary_print_expr &rsquo;/&rsquo; print_expr <br>
| unary_print_expr &rsquo;%&rsquo; print_expr <br>
| unary_print_expr &rsquo;+&rsquo; print_expr <br>
| unary_print_expr &rsquo;&acirc;&rsquo; print_expr <br>
| unary_print_expr non_unary_print_expr <br>
| unary_print_expr &rsquo;~&rsquo; print_expr <br>
| unary_print_expr NO_MATCH print_expr <br>
| unary_print_expr In NAME <br>
| unary_print_expr AND newline_opt print_expr <br>
| unary_print_expr OR newline_opt print_expr <br>
| unary_print_expr &rsquo;?&rsquo; print_expr
&rsquo;:&rsquo; print_expr <br>
;</p>

<p style="margin-top: 1em">non_unary_print_expr :
&rsquo;(&rsquo; expr &rsquo;)&rsquo; <br>
| &rsquo;!&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;^&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;*&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;/&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;%&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;+&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;&acirc;&rsquo; print_expr <br>
| non_unary_print_expr non_unary_print_expr <br>
| non_unary_print_expr &rsquo;~&rsquo; print_expr <br>
| non_unary_print_expr NO_MATCH print_expr <br>
| non_unary_print_expr In NAME <br>
| &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo; In NAME
<br>
| non_unary_print_expr AND newline_opt print_expr <br>
| non_unary_print_expr OR newline_opt print_expr <br>
| non_unary_print_expr &rsquo;?&rsquo; print_expr
&rsquo;:&rsquo; print_expr <br>
| NUMBER <br>
| STRING <br>
| lvalue <br>
| ERE <br>
| lvalue INCR <br>
| lvalue DECR <br>
| INCR lvalue <br>
| DECR lvalue <br>
| lvalue POW_ASSIGN print_expr <br>
| lvalue MOD_ASSIGN print_expr <br>
| lvalue MUL_ASSIGN print_expr <br>
| lvalue DIV_ASSIGN print_expr <br>
| lvalue ADD_ASSIGN print_expr <br>
| lvalue SUB_ASSIGN print_expr <br>
| lvalue &rsquo;=&rsquo; print_expr <br>
| FUNC_NAME &rsquo;(&rsquo; expr_list_opt &rsquo;)&rsquo;
<br>
/* no white space allowed before &rsquo;(&rsquo; */ <br>
| BUILTIN_FUNC_NAME &rsquo;(&rsquo; expr_list_opt
&rsquo;)&rsquo; <br>
| BUILTIN_FUNC_NAME <br>
;</p>

<p style="margin-top: 1em">lvalue : NAME <br>
| NAME &rsquo;[&rsquo; expr_list &rsquo;]&rsquo; <br>
| &rsquo;$&rsquo; expr <br>
;</p>

<p style="margin-top: 1em">non_unary_input_function :
simple_get <br>
| simple_get &rsquo;&lt;&rsquo; expr <br>
| non_unary_expr &rsquo;|&rsquo; simple_get <br>
;</p>

<p style="margin-top: 1em">unary_input_function :
unary_expr &rsquo;|&rsquo; simple_get <br>
;</p>

<p style="margin-top: 1em">simple_get : GETLINE <br>
| GETLINE lvalue <br>
;</p>

<p style="margin-top: 1em">newline_opt : /* empty */ <br>
| newline_opt NEWLINE <br>
;</p>

<p style="margin-top: 1em">This grammar has several
ambiguities that shall be resolved as follows:</p>

<p style="margin-top: 1em">* Operator precedence and
associativity shall be as described in Table 4-1,
Expressions in Decreasing Precedence in awk.</p>

<p style="margin-top: 1em">* In case of ambiguity, an else
shall be associated with the most immediately preceding if
that would satisfy the grammar.</p>

<p style="margin-top: 1em">* In some contexts, a
&lt;slash&gt; (&rsquo;/&rsquo;) that is used to surround an
ERE could also be the division operator. This shall be
resolved in such a way that wherever the division
opera&acirc; <br>
tor could appear, a &lt;slash&gt; is assumed to be the
division operator. (There is no unary division
operator.)</p>

<p style="margin-top: 1em">Each expression in an awk
program shall conform to the precedence and associativity
rules, even when this is not needed to resolve an ambiguity.
For example, because &rsquo;$&rsquo; has <br>
higher precedence than &rsquo;++&rsquo;, the string
&quot;$x++&acirc;&acirc;&quot; is not a valid awk
expression, even though it is unambiguously parsed by the
grammar as &quot;$(x++)&acirc;&acirc;&quot;.</p>

<p style="margin-top: 1em">One convention that might not be
obvious from the formal grammar is where &lt;newline&gt;
characters are acceptable. There are several obvious
placements such as terminating a state&acirc; <br>
ment, and a &lt;backslash&gt; can be used to escape
&lt;newline&gt; characters between any lexical tokens. In
addition, &lt;newline&gt; characters without
&lt;backslash&gt; characters can follow a <br>
comma, an open brace, logical AND operator
(&quot;&amp;&amp;&quot;), logical OR operator
(&quot;||&quot;), the do keyword, the else keyword, and the
closing parenthesis of an if, for, or while statement. <br>
For example:</p>

<p style="margin-top: 1em">{ print $1, <br>
$2 }</p>

<p style="margin-top: 1em">Lexical Conventions <br>
The lexical conventions for awk programs, with respect to
the preceding grammar, shall be as follows:</p>

<p style="margin-top: 1em">1. Except as noted, awk shall
recognize the longest possible token or delimiter beginning
at a given point.</p>

<p style="margin-top: 1em">2. A comment shall consist of
any characters beginning with the &lt;number-sign&gt;
character and terminated by, but excluding the next
occurrence of, a &lt;newline&gt;. Comments shall <br>
have no effect, except to delimit lexical tokens.</p>

<p style="margin-top: 1em">3. The &lt;newline&gt; shall be
recognized as the token NEWLINE.</p>

<p style="margin-top: 1em">4. A &lt;backslash&gt; character
immediately followed by a &lt;newline&gt; shall have no
effect.</p>

<p style="margin-top: 1em">5. The token STRING shall
represent a string constant. A string constant shall begin
with the character &rsquo;&quot;&rsquo;. Within a string
constant, a &lt;backslash&gt; character shall be
consid&acirc; <br>
ered to begin an escape sequence as specified in the table
in the Base Definitions volume of POSIX.1&acirc;2008,
Chapter 5, File Format Notation (&rsquo;\&rsquo;,
&rsquo;&rsquo;, &rsquo;,, &rsquo;0,&rsquo;, &rsquo;&rsquo;,
&rsquo;. In addition, the escape sequences in Table <br>
&rsquo; 4-2, Escape Sequences in awk shall be recognized. A
&lt;newline&gt; shall not occur within a string constant. A
<br>
string constant shall be terminated by the first unescaped
occurrence of the character &rsquo;&quot;&rsquo; after the
one that begins the string constant. The value of the string
shall be the <br>
sequence of all unescaped characters and values of escape
sequences between, but not including, the two delimiting
&rsquo;&quot;&rsquo; characters.</p>

<p style="margin-top: 1em">6. The token ERE represents an
extended regular expression constant. An ERE constant shall
begin with the &lt;slash&gt; character. Within an ERE
constant, a &lt;backslash&gt; character <br>
shall be considered to begin an escape sequence as specified
in the table in the Base Definitions volume of
POSIX.1&acirc;2008, Chapter 5, File Format Notation. In
addition, the <br>
escape sequences in Table 4-2, Escape Sequences in awk shall
be recognized. The application shall ensure that a
&lt;newline&gt; does not occur within an ERE constant. An
ERE con&acirc; <br>
stant shall be terminated by the first unescaped occurrence
of the &lt;slash&gt; character after the one that begins the
ERE constant. The extended regular expression represented
<br>
by the ERE constant shall be the sequence of all unescaped
characters and values of escape sequences between, but not
including, the two delimiting &lt;slash&gt; characters.</p>

<p style="margin-top: 1em">7. A &lt;blank&gt; shall have no
effect, except to delimit lexical tokens or within STRING or
ERE tokens.</p>

<p style="margin-top: 1em">8. The token NUMBER shall
represent a numeric constant. Its form and numeric value
shall either be equivalent to the decimal-floating-constant
token as specified by the ISO C <br>
standard, or it shall be a sequence of decimal digits and
shall be evaluated as an integer constant in decimal. In
addition, implementations may accept numeric constants with
<br>
the form and numeric value equivalent to the
hexadecimal-constant and hexadecimal-floating-constant
tokens as specified by the ISO C standard.</p>

<p style="margin-top: 1em">If the value is too large or too
small to be representable (see Section 1.1.2, Concepts
Derived from the ISO C Standard), the behavior is
undefined.</p>

<p style="margin-top: 1em">9. A sequence of underscores,
digits, and alphabetics from the portable character set (see
the Base Definitions volume of POSIX.1&acirc;2008, Section
6.1, Portable Character Set), <br>
beginning with an &lt;underscore&gt; or alphabetic
character, shall be considered a word.</p>

<p style="margin-top: 1em">10. The following words are
keywords that shall be recognized as individual tokens; the
name of the token is the same as the keyword:</p>

<p style="margin-top: 1em">BEGIN delete END function in
printf <br>
break do exit getline next return <br>
continue else for if print while</p>

<p style="margin-top: 1em">11. The following words are
names of built-in functions and shall be recognized as the
token BUILTIN_FUNC_NAME:</p>

<p style="margin-top: 1em">atan2 gsub log split sub toupper
<br>
close index match sprintf substr <br>
cos int rand sqrt system <br>
exp length sin srand tolower</p>

<p style="margin-top: 1em">The above-listed keywords and
names of built-in functions are considered reserved
words.</p>

<p style="margin-top: 1em">12. The token NAME shall consist
of a word that is not a keyword or a name of a built-in
function and is not followed immediately (without any
delimiters) by the &rsquo;(&rsquo; character.</p>

<p style="margin-top: 1em">13. The token FUNC_NAME shall
consist of a word that is not a keyword or a name of a
built-in function, followed immediately (without any
delimiters) by the &rsquo;(&rsquo; character. The <br>
&rsquo;(&rsquo; character shall not be included as part of
the token.</p>

<p style="margin-top: 1em">14. The following two-character
sequences shall be recognized as the named tokens:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;Token Name &acirc; Sequence &acirc; Token Name
&acirc; Sequence &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;ADD_ASSIGN &acirc; += &acirc; NO_MATCH &acirc; !~
&acirc; <br>
&acirc;SUB_ASSIGN &acirc; &acirc;= &acirc; EQ &acirc; ==
&acirc; <br>
&acirc;MUL_ASSIGN &acirc; *= &acirc; LE &acirc; &lt;=
&acirc; <br>
&acirc;DIV_ASSIGN &acirc; /= &acirc; GE &acirc; &gt;=
&acirc; <br>
&acirc;MOD_ASSIGN &acirc; %= &acirc; NE &acirc; != &acirc;
<br>
&acirc;POW_ASSIGN &acirc; ^= &acirc; INCR &acirc; ++ &acirc;
<br>
&acirc;OR &acirc; || &acirc; DECR &acirc; &acirc;&acirc;
&acirc; <br>
&acirc;AND &acirc; &amp;&amp; &acirc; APPEND &acirc;
&gt;&gt; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
15. The following single characters shall be recognized as
tokens whose names are the character:</p>

<p style="margin-top: 1em">&lt;newline&gt; { } ( ) [ ] , ;
+ &acirc; * % ^ ! &gt; &lt; | ? : &quot; &quot; $ =</p>

<p style="margin-top: 1em">There is a lexical ambiguity
between the token ERE and the tokens &rsquo;/&rsquo; and
DIV_ASSIGN. When an input sequence begins with a
&lt;slash&gt; character in any syntactic context where the
<br>
token &rsquo;/&rsquo; or DIV_ASSIGN could appear as the next
token in a valid program, the longer of those two tokens
that can be recognized shall be recognized. In any other
syntactic con&acirc; <br>
text where the token ERE could appear as the next token in a
valid program, the token ERE shall be recognized.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The following exit values shall be returned:</p>

<p style="margin-top: 1em">0 All input files were processed
successfully.</p>

<p style="margin-top: 1em">&gt;0 An error occurred.</p>

<p style="margin-top: 1em">The exit status can be altered
within the program by using an exit expression.</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
If any file operand is specified and the named file cannot
be accessed, awk shall write a diagnostic message to
standard error and terminate without any further action.</p>

<p style="margin-top: 1em">If the program specified by
either the program operand or a progfile operand is not a
valid awk program (as specified in the EXTENDED DESCRIPTION
section), the behavior is unde&acirc; <br>
fined.</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
The index, length, match, and substr functions should not be
confused with similar functions in the ISO C standard; the
awk versions deal with characters, while the ISO C
stan&acirc; <br>
dard deals with bytes.</p>

<p style="margin-top: 1em">Because the concatenation
operation is represented by adjacent expressions rather than
an explicit operator, it is often necessary to use
parentheses to enforce the proper evalu&acirc; <br>
ation precedence.</p>

<p style="margin-top: 1em">EXAMPLES <br>
The awk program specified in the command line is most easily
specified within single-quotes (for example,
&rsquo;program&rsquo;) for applications using sh, because
awk programs commonly con&acirc; <br>
tain characters that are special to the shell, including
double-quotes. In the cases where an awk program contains
single-quote characters, it is usually easiest to specify
most <br>
of the program as strings within single-quotes concatenated
by the shell with quoted single-quote characters. For
example:</p>

<p style="margin-top: 1em">awk
&rsquo;/&rsquo;&acute;&rsquo;/ { print &quot;quote:&quot;,
$0 }&rsquo;</p>

<p style="margin-top: 1em">prints all lines from the
standard input containing a single-quote character, prefixed
with quote:.</p>

<p style="margin-top: 1em">The following are examples of
simple awk programs:</p>

<p style="margin-top: 1em">1. Write to the standard output
all input lines for which field 3 is greater than 5:</p>

<p style="margin-top: 1em">$3 &gt; 5</p>

<p style="margin-top: 1em">2. Write every tenth line:</p>

<p style="margin-top: 1em">(NR % 10) == 0</p>

<p style="margin-top: 1em">3. Write any line with a
substring matching the regular expression:</p>


<p style="margin-top: 1em">/(G|D)(2[0&acirc;9][[:alpha:]]*)/</p>

<p style="margin-top: 1em">4. Print any line with a
substring containing a &rsquo;G&rsquo; or &rsquo;D&rsquo;,
followed by a sequence of digits and characters. This
example uses character classes digit and alpha to match
lan&acirc; <br>
guage-independent digit and alphabetic characters
respectively:</p>


<p style="margin-top: 1em">/(G|D)([[:digit:][:alpha:]]*)/</p>

<p style="margin-top: 1em">5. Write any line in which the
second field matches the regular expression and the fourth
field does not:</p>

<p style="margin-top: 1em">$2 &quot; &quot; /xyz/
&amp;&amp; $4 ! &quot; &quot; /xyz/</p>

<p style="margin-top: 1em">6. Write any line in which the
second field contains a &lt;backslash&gt;:</p>

<p style="margin-top: 1em">$2 &quot; &quot; /\/</p>

<p style="margin-top: 1em">7. Write any line in which the
second field contains a &lt;backslash&gt;. Note that
&lt;backslash&gt;-escapes are interpreted twice; once in
lexical processing of the string and once in <br>
processing the regular expression:</p>

<p style="margin-top: 1em">$2 &quot; &quot;
&quot;\\&quot;</p>

<p style="margin-top: 1em">8. Write the second to the last
and the last field in each line. Separate the fields by a
&lt;colon&gt;:</p>

<p style="margin-top: 1em">{OFS=&quot;:&quot;;print
$(NF&acirc;1), $NF}</p>

<p style="margin-top: 1em">9. Write the line number and
number of fields in each line. The three strings
representing the line number, the &lt;colon&gt;, and the
number of fields are concatenated and that <br>
string is written to standard output:</p>

<p style="margin-top: 1em">{print NR &quot;:&quot; NF}</p>

<p style="margin-top: 1em">10. Write lines longer than 72
characters:</p>

<p style="margin-top: 1em">length($0) &gt; 72</p>

<p style="margin-top: 1em">11. Write the first two fields
in opposite order separated by OFS:</p>

<p style="margin-top: 1em">{ print $2, $1 }</p>

<p style="margin-top: 1em">12. Same, with input fields
separated by a &lt;comma&gt; or &lt;space&gt; and
&lt;tab&gt; characters, or both:</p>

<p style="margin-top: 1em">BEGIN { FS = &quot;,[ ]*|[
]+&quot; } <br>
{ print $2, $1 }</p>

<p style="margin-top: 1em">13. Add up the first column,
print sum, and average:</p>

<p style="margin-top: 1em">{s += $1 } <br>
END {print &quot;sum is &quot;, s, &quot; average is&quot;,
s/NR}</p>

<p style="margin-top: 1em">14. Write fields in reverse
order, one per line (many lines out for each line in):</p>

<p style="margin-top: 1em">{ for (i = NF; i &gt; 0;
&acirc;&acirc;i) print $i }</p>

<p style="margin-top: 1em">15. Write all lines between
occurrences of the strings start and stop:</p>

<p style="margin-top: 1em">/start/, /stop/</p>

<p style="margin-top: 1em">16. Write all lines whose first
field is different from the previous one:</p>

<p style="margin-top: 1em">$1 != prev { print; prev = $1
}</p>

<p style="margin-top: 1em">17. Simulate echo:</p>

<p style="margin-top: 1em">BEGIN { <br>
for (i = 1; i &lt; ARGC; ++i) <br>
printf(&quot;%s%s&quot;, ARGV[i],
i==ARGC&acirc;1?&quot;0:&quot; &quot;) <br>
}</p>

<p style="margin-top: 1em">18. Write the path prefixes
contained in the PATH environment variable, one per
line:</p>

<p style="margin-top: 1em">BEGIN { <br>
n = split (ENVIRON[&quot;PATH&quot;], path, &quot;:&quot;)
<br>
for (i = 1; i &lt;= n; ++i) <br>
print path[i] <br>
}</p>

<p style="margin-top: 1em">19. If there is a file named
input containing page headers of the form: Page #</p>

<p style="margin-top: 1em">and a file named program that
contains:</p>

<p style="margin-top: 1em">/Page/ { $2 = n++; } <br>
{ print }</p>

<p style="margin-top: 1em">then the command line:</p>

<p style="margin-top: 1em">awk &acirc;f program n=5
input</p>

<p style="margin-top: 1em">prints the file input, filling
in page numbers starting at 5.</p>

<p style="margin-top: 1em">RATIONALE <br>
This description is based on the new awk,
&lsquo;&lsquo;nawk&rsquo;&rsquo;, (see the referenced The
AWK Programming Language), which introduced a number of new
features to the historical awk:</p>

<p style="margin-top: 1em">1. New keywords: delete, do,
function, return</p>

<p style="margin-top: 1em">2. New built-in functions:
atan2, close, cos, gsub, match, rand, sin, srand, sub,
system</p>

<p style="margin-top: 1em">3. New predefined variables:
FNR, ARGC, ARGV, RSTART, RLENGTH, SUBSEP</p>

<p style="margin-top: 1em">4. New expression operators: ?,
:, ,, ^</p>

<p style="margin-top: 1em">5. The FS variable and the third
argument to split, now treated as extended regular
expressions.</p>

<p style="margin-top: 1em">6. The operator precedence,
changed to more closely match the C language. Two examples
of code that operate differently are:</p>

<p style="margin-top: 1em">while ( n /= 10 &gt; 1) ... <br>
if (!&quot;wk&quot; ~ /bwk/) ...</p>

<p style="margin-top: 1em">Several features have been added
based on newer implementations of awk:</p>

<p style="margin-top: 1em">* Multiple instances of &acirc;f
progfile are permitted.</p>

<p style="margin-top: 1em">* The new option &acirc;v
assignment.</p>

<p style="margin-top: 1em">* The new predefined variable
ENVIRON.</p>

<p style="margin-top: 1em">* New built-in functions toupper
and tolower.</p>

<p style="margin-top: 1em">* More formatting capabilities
are added to printf to match the ISO C standard.</p>

<p style="margin-top: 1em">The overall awk syntax has
always been based on the C language, with a few features
from the shell command language and other sources. Because
of this, it is not completely com&acirc; <br>
patible with any other language, which has caused confusion
for some users. It is not the intent of the standard
developers to address such issues. A few relatively minor
changes <br>
toward making the language more compatible with the ISO C
standard were made; most of these changes are based on
similar changes in recent implementations, as described
above. <br>
There remain several C-language conventions that are not in
awk. One of the notable ones is the &lt;comma&gt; operator,
which is commonly used to specify multiple expressions in
the C <br>
language for statement. Also, there are various places where
awk is more restrictive than the C language regarding the
type of expression that can be used in a given context. <br>
These limitations are due to the different features that the
awk language does provide.</p>

<p style="margin-top: 1em">Regular expressions in awk have
been extended somewhat from historical implementations to
make them a pure superset of extended regular expressions,
as defined by POSIX.1&acirc;2008 <br>
(see the Base Definitions volume of POSIX.1&acirc;2008,
Section 9.4, Extended Regular Expressions). The main
extensions are internationalization features and interval
expressions. <br>
Historical implementations of awk have long supported
&lt;backslash&gt;-escape sequences as an extension to
extended regular expressions, and this extension has been
retained despite <br>
inconsistency with other utilities. The number of escape
sequences recognized in both extended regular expressions
and strings has varied (generally increasing with time)
among <br>
implementations. The set specified by POSIX.1&acirc;2008
includes most sequences known to be supported by popular
implementations and by the ISO C standard. One sequence that
is not <br>
supported is hexadecimal value escapes beginning with
&rsquo; This would allow values expressed in more than 9
bits to be used within awk as in the ISO C standard.
However, <br>
because this syntax has a non-deterministic length, it does
not permit the subsequent character to be a hexadecimal
digit. This limitation can be dealt with in the C language
by <br>
the use of lexical string concatenation. In the awk
language, concatenation could also be a solution for
strings, but not for extended regular expressions (either
lexical ERE <br>
tokens or strings used dynamically as regular expressions).
Because of this limitation, the feature has not been added
to POSIX.1&acirc;2008.</p>

<p style="margin-top: 1em">When a string variable is used
in a context where an extended regular expression normally
appears (where the lexical token ERE is used in the grammar)
the string does not contain <br>
the literal &lt;slash&gt; characters.</p>

<p style="margin-top: 1em">Some versions of awk allow the
form:</p>

<p style="margin-top: 1em">func name(args, ... ) {
statements }</p>

<p style="margin-top: 1em">This has been deprecated by the
authors of the language, who asked that it not be
specified.</p>

<p style="margin-top: 1em">Historical implementations of
awk produce an error if a next statement is executed in a
BEGIN action, and cause awk to terminate if a next statement
is executed in an END action. <br>
This behavior has not been documented, and it was not
believed that it was necessary to standardize it.</p>

<p style="margin-top: 1em">The specification of conversions
between string and numeric values is much more detailed than
in the documentation of historical implementations or in the
referenced The AWK Pro&acirc; <br>
gramming Language. Although most of the behavior is designed
to be intuitive, the details are necessary to ensure
compatible behavior from different implementations. This is
<br>
especially important in relational expressions since the
types of the operands determine whether a string or numeric
comparison is performed. From the perspective of an
applica&acirc; <br>
tion developer, it is usually sufficient to expect intuitive
behavior and to force conversions (by adding zero or
concatenating a null string) when the type of an expression
does <br>
not obviously match what is needed. The intent has been to
specify historical practice in almost all cases. The one
exception is that, in historical implementations, variables
<br>
and constants maintain both string and numeric values after
their original value is converted by any use. This means
that referencing a variable or constant can have unexpected
<br>
side-effects. For example, with historical implementations
the following program:</p>

<p style="margin-top: 1em">{ <br>
a = &quot;+2&quot; <br>
b = 2 <br>
if (NR % 2) <br>
c = a + b <br>
if (a == b) <br>
print &quot;numeric comparison&quot; <br>
else <br>
print &quot;string comparison&quot; <br>
}</p>

<p style="margin-top: 1em">would perform a numeric
comparison (and output numeric comparison) for each
odd-numbered line, but perform a string comparison (and
output string comparison) for each even-num&acirc; <br>
bered line. POSIX.1&acirc;2008 ensures that comparisons will
be numeric if necessary. With historical implementations,
the following program:</p>

<p style="margin-top: 1em">BEGIN { <br>
OFMT = &quot;%e&quot; <br>
print 3.14 <br>
OFMT = &quot;%f&quot; <br>
print 3.14 <br>
}</p>

<p style="margin-top: 1em">would output
&quot;3.140000e+00&quot; twice, because in the second print
statement the constant &quot;3.14&quot; would have a string
value from the previous conversion. POSIX.1&acirc;2008
requires that <br>
the output of the second print statement be
&quot;3.140000&quot;. The behavior of historical
implementations was seen as too unintuitive and
unpredictable.</p>

<p style="margin-top: 1em">It was pointed out that with the
rules contained in early drafts, the following script would
print nothing:</p>

<p style="margin-top: 1em">BEGIN { <br>
y[1.5] = 1 <br>
OFMT = &quot;%e&quot; <br>
print y[1.5] <br>
}</p>

<p style="margin-top: 1em">Therefore, a new variable,
CONVFMT, was introduced. The OFMT variable is now restricted
to affecting output conversions of numbers to strings and
CONVFMT is used for internal <br>
conversions, such as comparisons or array indexing. The
default value is the same as that for OFMT, so unless a
program changes CONVFMT (which no historical program would
do), it <br>
will receive the historical behavior associated with
internal string conversions.</p>

<p style="margin-top: 1em">The POSIX awk lexical and
syntactic conventions are specified more formally than in
other sources. Again the intent has been to specify
historical practice. One convention that <br>
may not be obvious from the formal grammar as in other
verbal descriptions is where &lt;newline&gt; characters are
acceptable. There are several obvious placements such as
terminating <br>
a statement, and a &lt;backslash&gt; can be used to escape
&lt;newline&gt; characters between any lexical tokens. In
addition, &lt;newline&gt; characters without
&lt;backslash&gt; characters can follow <br>
a comma, an open brace, a logical AND operator
(&quot;&amp;&amp;&quot;), a logical OR operator
(&quot;||&quot;), the do keyword, the else keyword, and the
closing parenthesis of an if, for, or while state&acirc;
<br>
ment. For example:</p>

<p style="margin-top: 1em">{ print $1, <br>
$2 }</p>

<p style="margin-top: 1em">The requirement that awk add a
trailing &lt;newline&gt; to the program argument text is to
simplify the grammar, making it match a text file in form.
There is no way for an application <br>
or test suite to determine whether a literal &lt;newline&gt;
is added or whether awk simply acts as if it did.</p>

<p style="margin-top: 1em">POSIX.1&acirc;2008 requires
several changes from historical implementations in order to
support internationalization. Probably the most subtle of
these is the use of the decimal-point <br>
character, defined by the LC_NUMERIC category of the locale,
in representations of floating-point numbers. This
locale-specific character is used in recognizing numeric
input, <br>
in converting between strings and numeric values, and in
formatting output. However, regardless of locale, the
&lt;period&gt; character (the decimal-point character of the
POSIX <br>
locale) is the decimal-point character recognized in
processing awk programs (including assignments in command
line arguments). This is essentially the same convention as
the one <br>
used in the ISO C standard. The difference is that the C
language includes the setlocale() function, which permits an
application to modify its locale. Because of this
capabil&acirc; <br>
ity, a C application begins executing with its locale set to
the C locale, and only executes in the environment-specified
locale after an explicit call to setlocale(). However, <br>
adding such an elaborate new feature to the awk language was
seen as inappropriate for POSIX.1&acirc;2008. It is possible
to execute an awk program explicitly in any desired locale
by <br>
setting the environment in the shell.</p>

<p style="margin-top: 1em">The undefined behavior resulting
from NULs in extended regular expressions allows future
extensions for the GNU gawk program to process binary
data.</p>

<p style="margin-top: 1em">The behavior in the case of
invalid awk programs (including lexical, syntactic, and
semantic errors) is undefined because it was considered
overly limiting on implementations to <br>
specify. In most cases such errors can be expected to
produce a diagnostic and a non-zero exit status. However,
some implementations may choose to extend the language in
ways <br>
that make use of certain invalid constructs. Other invalid
constructs might be deemed worthy of a warning, but
otherwise cause some reasonable behavior. Still other
constructs <br>
may be very difficult to detect in some implementations.
Also, different implementations might detect a given error
during an initial parsing of the program (before reading any
<br>
input files) while others might detect it when executing the
program after reading some input. Implementors should be
aware that diagnosing errors as early as possible and
pro&acirc; <br>
ducing useful diagnostics can ease debugging of
applications, and thus make an implementation more
usable.</p>

<p style="margin-top: 1em">The unspecified behavior from
using multi-character RS values is to allow possible future
extensions based on extended regular expressions used for
record separators. Historical <br>
implementations take the first character of the string and
ignore the others.</p>

<p style="margin-top: 1em">Unspecified behavior when
split(string,array,&lt;null&gt;) is used is to allow a
proposed future extension that would split up a string into
an array of individual characters.</p>

<p style="margin-top: 1em">In the context of the getline
function, equally good arguments for different precedences
of the | and &lt; operators can be made. Historical practice
has been that:</p>

<p style="margin-top: 1em">getline &lt; &quot;a&quot;
&quot;b&quot;</p>

<p style="margin-top: 1em">is parsed as:</p>

<p style="margin-top: 1em">( getline &lt; &quot;a&quot; )
&quot;b&quot;</p>

<p style="margin-top: 1em">although many would argue that
the intent was that the file ab should be read. However:</p>

<p style="margin-top: 1em">getline &lt; &quot;x&quot; +
1</p>

<p style="margin-top: 1em">parses as:</p>

<p style="margin-top: 1em">getline &lt; ( &quot;x&quot; + 1
)</p>

<p style="margin-top: 1em">Similar problems occur with the
| version of getline, particularly in combination with $.
For example:</p>

<p style="margin-top: 1em">$&quot;echo hi&quot; |
getline</p>

<p style="margin-top: 1em">(This situation is particularly
problematic when used in a print statement, where the
|getline part might be a redirection of the print.)</p>

<p style="margin-top: 1em">Since in most cases such
constructs are not (or at least should not) be used (because
they have a natural ambiguity for which there is no
conventional parsing), the meaning of <br>
these constructs has been made explicitly unspecified. (The
effect is that a conforming application that runs into the
problem must parenthesize to resolve the ambiguity.) There
<br>
appeared to be few if any actual uses of such
constructs.</p>

<p style="margin-top: 1em">Grammars can be written that
would cause an error under these circumstances. Where
backwards-compatibility is not a large consideration,
implementors may wish to use such gram&acirc; <br>
mars.</p>

<p style="margin-top: 1em">Some historical implementations
have allowed some built-in functions to be called without an
argument list, the result being a default argument list
chosen in some &lsquo;&lsquo;reasonable&rsquo;&rsquo; <br>
way. Use of length as a synonym for length($0) is the only
one of these forms that is thought to be widely known or
widely used; this particular form is documented in various
<br>
places (for example, most historical awk reference pages,
although not in the referenced The AWK Programming Language)
as legitimate practice. With this exception, default
argu&acirc; <br>
ment lists have always been undocumented and vaguely
defined, and it is not at all clear how (or if) they should
be generalized to user-defined functions. They add no useful
<br>
functionality and preclude possible future extensions that
might need to name functions without calling them. Not
standardizing them seems the simplest course. The standard
<br>
developers considered that length merited special treatment,
however, since it has been documented in the past and sees
possibly substantial use in historical programs.
Accord&acirc; <br>
ingly, this usage has been made legitimate, but Issue 5
removed the obsolescent marking for XSI-conforming
implementations and many otherwise conforming applications
depend on <br>
this feature.</p>

<p style="margin-top: 1em">In sub and gsub, if repl is a
string literal (the lexical token STRING), then two
consecutive &lt;backslash&gt; characters should be used in
the string to ensure a single &lt;backslash&gt; <br>
will precede the &lt;ampersand&gt; when the resultant string
is passed to the function. (For example, to specify one
literal &lt;ampersand&gt; in the replacement string, use
gsub(ERE, <br>
&quot;\&amp;&quot;).)</p>

<p style="margin-top: 1em">Historically, the only special
character in the repl argument of sub and gsub string
functions was the &lt;ampersand&gt; (&rsquo;&amp;&rsquo;)
character and preceding it with the &lt;backslash&gt;
character <br>
was used to turn off its special meaning.</p>

<p style="margin-top: 1em">The description in the ISO
POSIX&acirc;2:1993 standard introduced behavior such that
the &lt;backslash&gt; character was another special
character and it was unspecified whether there were <br>
any other special characters. This description introduced
several portability problems, some of which are described
below, and so it has been replaced with the more historical
<br>
description. Some of the problems include:</p>

<p style="margin-top: 1em">* Historically, to create the
replacement string, a script could use gsub(ERE,
&quot;\&amp;&quot;), but with the ISO POSIX&acirc;2:1993
standard wording, it was necessary to use gsub(ERE, <br>
&quot;\\&amp;&quot;). The &lt;backslash&gt; characters are
doubled here because all string literals are subject to
lexical analysis, which would reduce each pair of
&lt;backslash&gt; characters to <br>
a single &lt;backslash&gt; before being passed to gsub.</p>

<p style="margin-top: 1em">* Since it was unspecified what
the special characters were, for portable scripts to
guarantee that characters are printed literally, each
character had to be preceded with a <br>
&lt;backslash&gt;. (For example, a portable script had to
use gsub(ERE, &quot;\h\i&quot;) to produce a replacement
string of &quot;hi&quot;.)</p>

<p style="margin-top: 1em">The description for comparisons
in the ISO POSIX&acirc;2:1993 standard did not properly
describe historical practice because of the way numeric
strings are compared as numbers. The <br>
current rules cause the following code:</p>

<p style="margin-top: 1em">if (0 == &quot;000&quot;) <br>
print &quot;strange, but true&quot; <br>
else <br>
print &quot;not true&quot;</p>

<p style="margin-top: 1em">to do a numeric comparison,
causing the if to succeed. It should be intuitively obvious
that this is incorrect behavior, and indeed, no historical
implementation of awk actually <br>
behaves this way.</p>

<p style="margin-top: 1em">To fix this problem, the
definition of numeric string was enhanced to include only
those values obtained from specific circumstances (mostly
external sources) where it is not <br>
possible to determine unambiguously whether the value is
intended to be a string or a numeric.</p>

<p style="margin-top: 1em">Variables that are assigned to a
numeric string shall also be treated as a numeric string.
(For example, the notion of a numeric string can be
propagated across assignments.) In <br>
comparisons, all variables having the uninitialized value
are to be treated as a numeric operand evaluating to the
numeric value zero.</p>

<p style="margin-top: 1em">Uninitialized variables include
all types of variables including scalars, array elements,
and fields. The definition of an uninitialized value in
Variables and Special Variables <br>
is necessary to describe the value placed on uninitialized
variables and on fields that are valid (for example, &lt;
$NF) but have no characters in them and to describe how
these <br>
variables are to be used in comparisons. A valid field, such
as $1, that has no characters in it can be obtained from an
input line of &quot;&quot; when FS=&rsquo;&rsquo;.
Historically, the <br>
comparison ($1&lt;10) was done numerically after evaluating
$1 to the value zero.</p>

<p style="margin-top: 1em">The phrase &lsquo;&lsquo;...
also shall have the numeric value of the numeric
string&rsquo;&rsquo; was removed from several sections of
the ISO POSIX&acirc;2:1993 standard because is specifies an
unnecessary <br>
implementation detail. It is not necessary for
POSIX.1&acirc;2008 to specify that these objects be assigned
two different values. It is only necessary to specify that
these objects <br>
may evaluate to two different values depending on
context.</p>

<p style="margin-top: 1em">Historical implementations of
awk did not parse hexadecimal integer or floating constants
like &quot;0xa&quot; and &quot;0xap0&quot;. Due to an
oversight, the 2001 through 2004 editions of this <br>
standard required support for hexadecimal floating
constants. This was due to the reference to atof(). This
version of the standard allows but does not require
implementations <br>
to use atof() and includes a description of how
floating-point numbers are recognized as an alternative to
match historic behavior. The intent of this change is to
allow imple&acirc; <br>
mentations to recognize floating-point constants according
to either the ISO/IEC 9899:1990 standard or ISO/IEC
9899:1999 standard, and to allow (but not require)
implementations <br>
to recognize hexadecimal integer constants.</p>

<p style="margin-top: 1em">Historical implementations of
awk did not support floating-point infinities and NaNs in
numeric strings; e.g., &quot;&acirc;INF&quot; and
&quot;NaN&quot;. However, implementations that use the
atof() or <br>
strtod() functions to do the conversion picked up support
for these values if they used a ISO/IEC 9899:1999 standard
version of the function instead of a ISO/IEC 9899:1990
stan&acirc; <br>
dard version. Due to an oversight, the 2001 through 2004
editions of this standard did not allow support for
infinities and NaNs, but in this revision support is allowed
(but not <br>
required). This is a silent change to the behavior of awk
programs; for example, in the POSIX locale the
expression:</p>

<p style="margin-top: 1em">(&quot;-INF&quot; + 0 &lt;
0)</p>

<p style="margin-top: 1em">formerly had the value 0 because
&quot;&acirc;INF&quot; converted to 0, but now it may have
the value 0 or 1.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
None.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Section 1.3, Grammar Conventions, grep, lex, sed</p>

<p style="margin-top: 1em">The Base Definitions volume of
POSIX.1&acirc;2008, Chapter 5, File Format Notation, Section
6.1, Portable Character Set, Chapter 8, Environment
Variables, Chapter 9, Regular Expres&acirc; <br>
sions, Section 12.2, Utility Syntax Guidelines</p>

<p style="margin-top: 1em">The System Interfaces volume of
POSIX.1&acirc;2008, atof(), exec, isspace(), popen(),
setlocale(), strtod()</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2013 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 7,
Copyright (C) 2013 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. (This is <br>
POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.)
In the event of any discrepancy between this version and the
original IEEE and The Open Group Standard, the original <br>
IEEE and The Open Group Standard is the referee document.
The original Standard can be obtained online at
http://www.unix.org/online.html .</p>

<p style="margin-top: 1em">Any typographical or formatting
errors that appear in this page are most likely to have been
introduced during the conversion of the source files to man
page format. To report <br>
such errors, see
https://www.kernel.org/doc/man-pages/reporting_bugs.html
.</p>

<p style="margin-top: 1em">IEEE/The Open Group 2013
AWK(1POSIX)</p>
<hr>
</body>
</html>
