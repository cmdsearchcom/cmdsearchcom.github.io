<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:33:53 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PROVE(1) User Contributed Perl Documentation
PROVE(1)</p>

<p style="margin-top: 1em">NAME <br>
prove - Run tests through a TAP harness.</p>

<p style="margin-top: 1em">USAGE <br>
prove [options] [files or directories]</p>

<p style="margin-top: 1em">OPTIONS <br>
Boolean options:</p>

<p style="margin-top: 1em">-v, --verbose Print all test
lines. <br>
-l, --lib Add &rsquo;lib&rsquo; to the path for your tests
(-Ilib). <br>
-b, --blib Add &rsquo;blib/lib&rsquo; and
&rsquo;blib/arch&rsquo; to the path for <br>
your tests <br>
-s, --shuffle Run the tests in random order. <br>
-c, --color Colored test output (default). <br>
--nocolor Do not color test output. <br>
--count Show the X/Y test count when not verbose <br>
(default) <br>
--nocount Disable the X/Y test count. <br>
-D --dry Dry run. Show test that would have run. <br>
-f, --failures Show failed tests. <br>
-o, --comments Show comments. <br>
--ignore-exit Ignore exit status from test scripts. <br>
-m, --merge Merge test scripts&rsquo; STDERR with their
STDOUT. <br>
-r, --recurse Recursively descend into directories. <br>
--reverse Run the tests in reverse order. <br>
-q, --quiet Suppress some test output while running tests.
<br>
-Q, --QUIET Only print summary results. <br>
-p, --parse Show full list of TAP parse errors, if any. <br>
--directives Only show results with TODO or SKIP directives.
<br>
--timer Print elapsed time after each test. <br>
--trap Trap Ctrl-C and print summary on interrupt. <br>
--normalize Normalize TAP output in verbose output <br>
-T Enable tainting checks. <br>
-t Enable tainting warnings. <br>
-W Enable fatal warnings. <br>
-w Enable warnings. <br>
-h, --help Display this help <br>
-?, Display this help <br>
-H, --man Longer manpage for prove <br>
--norc Don&rsquo;t process default .proverc</p>

<p style="margin-top: 1em">Options that take arguments:</p>

<p style="margin-top: 1em">-I Library paths to include.
<br>
-P Load plugin (searches App::Prove::Plugin::*.) <br>
-M Load a module. <br>
-e, --exec Interpreter to run the tests (&rsquo;&rsquo; for
compiled <br>
tests.) <br>
--ext Set the extension for tests (default &rsquo;.t&rsquo;)
<br>
--harness Define test harness to use. See TAP::Harness. <br>
--formatter Result formatter to use. See FORMATTERS. <br>
--source Load and/or configure a SourceHandler. See <br>
SOURCE HANDLERS. <br>
-a, --archive out.tgz Store the resulting TAP in an archive
file. <br>
-j, --jobs N Run N test jobs in parallel (try 9.) <br>
--state=opts Control prove&rsquo;s persistent state. <br>
--rc=rcfile Process options from rcfile <br>
--rules Rules for parallel vs sequential processing.</p>

<p style="margin-top: 1em">NOTES <br>
.proverc <br>
If ~/.proverc or ./.proverc exist they will be read and any
options they contain processed before the command line
options. Options in .proverc are specified in the same way
as <br>
command line options:</p>

<p style="margin-top: 1em"># .proverc <br>
--state=hot,fast,save <br>
-j9</p>

<p style="margin-top: 1em">Additional option files may be
specified with the &quot;--rc&quot; option. Default option
file processing is disabled by the &quot;--norc&quot;
option.</p>

<p style="margin-top: 1em">Under Windows and VMS the option
file is named _proverc rather than .proverc and is sought
only in the current directory.</p>

<p style="margin-top: 1em">Reading from &quot;STDIN&quot;
<br>
If you have a list of tests (or URLs, or anything else you
want to test) in a file, you can add them to your tests by
using a &rsquo;-&rsquo;:</p>

<p style="margin-top: 1em">prove - &lt;
my_list_of_things_to_test.txt</p>

<p style="margin-top: 1em">See the &quot;README&quot; in
the &quot;examples&quot; directory of this distribution.</p>

<p style="margin-top: 1em">Default Test Directory <br>
If no files or directories are supplied, &quot;prove&quot;
looks for all files matching the pattern
&quot;t/*.t&quot;.</p>

<p style="margin-top: 1em">Colored Test Output <br>
Colored test output is the default, but if output is not to
a terminal, color is disabled. You can override this by
adding the &quot;--color&quot; switch.</p>

<p style="margin-top: 1em">Color support requires
Term::ANSIColor on Unix-like platforms and Win32::Console
windows. If the necessary module is not installed colored
output will not be available.</p>

<p style="margin-top: 1em">Exit Code <br>
If the tests fail &quot;prove&quot; will exit with non-zero
status.</p>

<p style="margin-top: 1em">Arguments to Tests <br>
It is possible to supply arguments to tests. To do so
separate them from prove&rsquo;s own arguments with the
arisdottle, &rsquo;::&rsquo;. For example</p>

<p style="margin-top: 1em">prove -v t/mytest.t :: --url
http://example.com</p>

<p style="margin-top: 1em">would run t/mytest.t with the
options &rsquo;--url http://example.com&rsquo;. When running
multiple tests they will each receive the same
arguments.</p>

<p style="margin-top: 1em">&quot;--exec&quot; <br>
Normally you can just pass a list of Perl tests and the
harness will know how to execute them. However, if your
tests are not written in Perl or if you want all tests
invoked <br>
exactly the same way, use the &quot;-e&quot;, or
&quot;--exec&quot; switch:</p>

<p style="margin-top: 1em">prove --exec
&rsquo;/usr/bin/ruby -w&rsquo; t/ <br>
prove --exec &rsquo;/usr/bin/perl -Tw -mstrict -Ilib&rsquo;
t/ <br>
prove --exec &rsquo;/path/to/my/customer/exec&rsquo;</p>

<p style="margin-top: 1em">&quot;--merge&quot; <br>
If you need to make sure your diagnostics are displayed in
the correct order relative to test results you can use the
&quot;--merge&quot; option to merge the test scripts&rsquo;
STDERR into <br>
their STDOUT.</p>

<p style="margin-top: 1em">This guarantees that STDOUT
(where the test results appear) and STDERR (where the
diagnostics appear) will stay in sync. The harness will
display any diagnostics your tests emit <br>
on STDERR.</p>

<p style="margin-top: 1em">Caveat: this is a bit of a
kludge. In particular note that if anything that appears on
STDERR looks like a test result the test harness will get
confused. Use this option only if <br>
you understand the consequences and can live with the
risk.</p>

<p style="margin-top: 1em">&quot;--trap&quot; <br>
The &quot;--trap&quot; option will attempt to trap SIGINT
(Ctrl-C) during a test run and display the test summary even
if the run is interrupted</p>

<p style="margin-top: 1em">&quot;--state&quot; <br>
You can ask &quot;prove&quot; to remember the state of
previous test runs and select and/or order the tests to be
run based on that saved state.</p>

<p style="margin-top: 1em">The &quot;--state&quot; switch
requires an argument which must be a comma separated list of
one or more of the following options.</p>

<p style="margin-top: 1em">&quot;last&quot; <br>
Run the same tests as the last time the state was saved.
This makes it possible, for example, to recreate the
ordering of a shuffled test.</p>

<p style="margin-top: 1em"># Run all tests in random order
<br>
$ prove -b --state=save --shuffle</p>

<p style="margin-top: 1em"># Run them again in the same
order <br>
$ prove -b --state=last</p>

<p style="margin-top: 1em">&quot;failed&quot; <br>
Run only the tests that failed on the last run.</p>

<p style="margin-top: 1em"># Run all tests <br>
$ prove -b --state=save</p>

<p style="margin-top: 1em"># Run failures <br>
$ prove -b --state=failed</p>

<p style="margin-top: 1em">If you also specify the
&quot;save&quot; option newly passing tests will be excluded
from subsequent runs.</p>

<p style="margin-top: 1em"># Repeat until no more failures
<br>
$ prove -b --state=failed,save</p>

<p style="margin-top: 1em">&quot;passed&quot; <br>
Run only the passed tests from last time. Useful to make
sure that no new problems have been introduced.</p>

<p style="margin-top: 1em">&quot;all&quot; <br>
Run all tests in normal order. Multple options may be
specified, so to run all tests with the failures from last
time first:</p>

<p style="margin-top: 1em">$ prove -b
--state=failed,all,save</p>

<p style="margin-top: 1em">&quot;hot&quot; <br>
Run the tests that most recently failed first. The last
failure time of each test is stored. The &quot;hot&quot;
option causes tests to be run in most-recent- failure
order.</p>

<p style="margin-top: 1em">$ prove -b --state=hot,save</p>

<p style="margin-top: 1em">Tests that have never failed
will not be selected. To run all tests with the most
recently failed first use</p>

<p style="margin-top: 1em">$ prove -b
--state=hot,all,save</p>

<p style="margin-top: 1em">This combination of options may
also be specified thus</p>

<p style="margin-top: 1em">$ prove -b --state=adrian</p>

<p style="margin-top: 1em">&quot;todo&quot; <br>
Run any tests with todos.</p>

<p style="margin-top: 1em">&quot;slow&quot; <br>
Run the tests in slowest to fastest order. This is useful in
conjunction with the &quot;-j&quot; parallel testing switch
to ensure that your slowest tests start running first.</p>

<p style="margin-top: 1em">$ prove -b --state=slow -j9</p>

<p style="margin-top: 1em">&quot;fast&quot; <br>
Run test tests in fastest to slowest order.</p>

<p style="margin-top: 1em">&quot;new&quot; <br>
Run the tests in newest to oldest order based on the
modification times of the test scripts.</p>

<p style="margin-top: 1em">&quot;old&quot; <br>
Run the tests in oldest to newest order.</p>

<p style="margin-top: 1em">&quot;fresh&quot; <br>
Run those test scripts that have been modified since the
last test run.</p>

<p style="margin-top: 1em">&quot;save&quot; <br>
Save the state on exit. The state is stored in a file called
.prove (_prove on Windows and VMS) in the current
directory.</p>

<p style="margin-top: 1em">The &quot;--state&quot; switch
may be used more than once.</p>

<p style="margin-top: 1em">$ prove -b --state=hot
--state=all,save</p>

<p style="margin-top: 1em">--rules <br>
The &quot;--rules&quot; option is used to control which
tests are run sequentially and which are run in parallel, if
the &quot;--jobs&quot; option is specified. The option may
be specified multiple <br>
times, and the order matters.</p>

<p style="margin-top: 1em">The most practical use is likely
to specify that some tests are not
&quot;parallel-ready&quot;. Since mentioning a file with
--rules doens&rsquo;t cause it to selected to run as a test,
you can <br>
&quot;set and forget&quot; some rules preferences in your
.proverc file. Then you&rsquo;ll be able to take maximum
advantage of the performance benefits of parallel testing,
while some <br>
exceptions are still run in parallel.</p>

<p style="margin-top: 1em">--rules examples</p>

<p style="margin-top: 1em"># All tests are allowed to run
in parallel, except those starting with &quot;p&quot; <br>
--rules=&rsquo;seq=t/p*.t&rsquo;
--rules=&rsquo;par=**&rsquo;</p>

<p style="margin-top: 1em"># All tests must run in sequence
except those starting with &quot;p&quot;, which should be
run parallel <br>
--rules=&rsquo;par=t/p*.t&rsquo;</p>

<p style="margin-top: 1em">--rules resolution</p>

<p style="margin-top: 1em">&Acirc;&middot; By default, all
tests are eligible to be run in parallel. Specifying any of
your own rules removes this one.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;First
match wins&quot;. The first rule that matches a test will be
the one that applies.</p>

<p style="margin-top: 1em">&Acirc;&middot; Any test which
does not match a rule will be run in sequence at the end of
the run.</p>

<p style="margin-top: 1em">&Acirc;&middot; The existence of
a rule does not imply selecting a test. You must still
specify the tests to run.</p>

<p style="margin-top: 1em">&Acirc;&middot; Specifying a
rule to allow tests to run in parallel does not make the run
in parallel. You still need specify the number of parallel
&quot;jobs&quot; in your Harness object.</p>

<p style="margin-top: 1em">--rules Glob-style pattern
matching</p>

<p style="margin-top: 1em">We implement our own glob-style
pattern matching for --rules. Here are the supported
patterns:</p>

<p style="margin-top: 1em">** is any number of characters,
including /, within a pathname <br>
* is zero or more characters within a filename/directory
name <br>
? is exactly one character within a filename/directory name
<br>
{foo,bar,baz} is any of foo, bar or baz. &nbsp; <br>
is an escape character</p>

<p style="margin-top: 1em">More advance specifications for
parallel vs sequence run rules</p>

<p style="margin-top: 1em">If you need more advanced
management of what runs in parallel vs in sequence, see the
associated &rsquo;rules&rsquo; documentation in TAP::Harness
and TAP::Parser::Scheduler. If what&rsquo;s <br>
possible directly through &quot;prove&quot; is not
sufficient, you can write your own harness to access these
features directly.</p>

<p style="margin-top: 1em">@INC <br>
prove introduces a separation between &quot;options passed
to the perl which runs prove&quot; and &quot;options passed
to the perl which runs tests&quot;; this distinction is by
design. Thus the <br>
perl which is running a test starts with the default @INC.
Additional library directories can be added via the
&quot;PERL5LIB&quot; environment variable, via -Ifoo in
&quot;PERL5OPT&quot; or via the <br>
&quot;-Ilib&quot; option to prove.</p>

<p style="margin-top: 1em">Taint Mode <br>
Normally when a Perl program is run in taint mode the
contents of the &quot;PERL5LIB&quot; environment variable do
not appear in @INC.</p>

<p style="margin-top: 1em">Because &quot;PERL5LIB&quot; is
often used during testing to add build directories to @INC
prove passes the names of any directories found in
&quot;PERL5LIB&quot; as -I switches. The net effect of <br>
this is that &quot;PERL5LIB&quot; is honoured even when
prove is run in taint mode.</p>

<p style="margin-top: 1em">FORMATTERS <br>
You can load a custom TAP::Parser::Formatter:</p>

<p style="margin-top: 1em">prove --formatter
MyFormatter</p>

<p style="margin-top: 1em">SOURCE HANDLERS <br>
You can load custom TAP::Parser::SourceHandlers, to change
the way the parser interprets particular sources of TAP.</p>

<p style="margin-top: 1em">prove --source MyHandler
--source YetAnother t</p>

<p style="margin-top: 1em">If you want to provide config to
the source you can use:</p>

<p style="margin-top: 1em">prove --source MyCustom --source
Perl --perl-option &rsquo;foo=bar baz&rsquo; --perl-option
avg=0.278 --source File --file-option extensions=.txt
--file-option extensions=.tmp t <br>
--source pgTAP --pgtap-option pset=format=html
--pgtap-option pset=border=2</p>

<p style="margin-top: 1em">Each
&quot;--$source-option&quot; option must specify a key/value
pair separated by an &quot;=&quot;. If an option can take
multiple values, just specify it multiple times, as with the
&quot;extensions=&quot; <br>
examples above. If the option should be a hash reference,
specify the value as a second pair separated by a
&quot;=&quot;, as in the &quot;pset=&quot; examples above
(escape &quot;=&quot; with a backslash).</p>

<p style="margin-top: 1em">All &quot;--sources&quot; are
combined into a hash, and passed to &quot;new&quot; in
TAP::Harness&rsquo;s &quot;sources&quot; parameter.</p>

<p style="margin-top: 1em">See TAP::Parser::IteratorFactory
for more details on how configuration is passed to
SourceHandlers.</p>

<p style="margin-top: 1em">PLUGINS <br>
Plugins can be loaded using the &quot;-Pplugin&quot; syntax,
eg:</p>

<p style="margin-top: 1em">prove -PMyPlugin</p>

<p style="margin-top: 1em">This will search for a module
named &quot;App::Prove::Plugin::MyPlugin&quot;, or failing
that, &quot;MyPlugin&quot;. If the plugin can&rsquo;t be
found, &quot;prove&quot; will complain &amp; exit.</p>

<p style="margin-top: 1em">You can pass arguments to your
plugin by appending &quot;=arg1,arg2,etc&quot; to the plugin
name:</p>

<p style="margin-top: 1em">prove -PMyPlugin=fou,du,fafa</p>

<p style="margin-top: 1em">Please check individual plugin
documentation for more details.</p>

<p style="margin-top: 1em">Available Plugins <br>
For an up-to-date list of plugins available, please check
CPAN:</p>


<p style="margin-top: 1em">&lt;http://search.cpan.org/search?query=App%3A%3AProve+Plugin&gt;</p>

<p style="margin-top: 1em">Writing Plugins <br>
Please see &quot;PLUGINS&quot; in App::Prove.</p>

<p style="margin-top: 1em">POD ERRORS <br>
Hey! The above document had some coding errors, which are
explained below:</p>

<p style="margin-top: 1em">Around line 291: <br>
Unknown directive: =over4</p>

<p style="margin-top: 1em">Around line 293: <br>
&rsquo;=item&rsquo; outside of any &rsquo;=over&rsquo;</p>

<p style="margin-top: 1em">perl v5.16.3 2013-05-02
PROVE(1)</p>
<hr>
</body>
</html>
