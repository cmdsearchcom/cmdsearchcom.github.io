<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:29:00 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OPENSHIFT CLI(1) June 2016 OPENSHIFT CLI(1)</p>

<p style="margin-top: 1em">NAME <br>
openshift cli new-app - Create a new application</p>

<p style="margin-top: 1em">SYNOPSIS <br>
openshift cli new-app [OPTIONS]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Create a new application by specifying source code,
templates, and/or images</p>

<p style="margin-top: 1em">This command will try to build
up the components of an application using images, templates,
or code that has a public repository. It will lookup the
images on the local Docker <br>
installation (if available), a Docker registry, an
integrated image stream, or stored templates.</p>

<p style="margin-top: 1em">If you specify a source code
URL, it will set up a build that takes your source code and
converts it into an image that can run inside of a pod.
Local source must be in a git <br>
repository that has a remote repository that the server can
see. The images will be deployed via a deployment
configuration, and a service will be connected to the first
public <br>
port of the app. You may either specify components using the
various existing flags or let new-app autodetect what kind
of components you have provided.</p>

<p style="margin-top: 1em">If you provide source code, a
new build will be automatically triggered. You can use
&rsquo;openshift cli status&rsquo; to check the
progress.</p>

<p style="margin-top: 1em">OPTIONS <br>
--allow-missing-images=false <br>
If true, indicates that referenced Docker images that cannot
be found locally or in a registry should still be used.</p>


<p style="margin-top: 1em">--allow-missing-imagestream-tags=false
<br>
If true, indicates that image stream tags that don&rsquo;t
exist should still be used.</p>

<p style="margin-top: 1em">--as-test=false <br>
If true create this application as a test deployment, which
validates that the deployment succeeds and then scales
down.</p>

<p style="margin-top: 1em">--build-env=[] <br>
Specify a key-value pair for an environment variable to set
into each build image.</p>

<p style="margin-top: 1em">--build-env-file=[] <br>
File containing key-value pairs of environment variables to
set into each build image.</p>

<p style="margin-top: 1em">--code=[] <br>
Source code to use to build this application.</p>

<p style="margin-top: 1em">--context-dir=&quot;&quot; <br>
Context directory to be used for the build.</p>

<p style="margin-top: 1em">--docker-image=[] <br>
Name of a Docker image to include in the app.</p>

<p style="margin-top: 1em">--dry-run=false <br>
If true, show the result of the operation without performing
it.</p>

<p style="margin-top: 1em">-e, --env=[] <br>
Specify a key-value pair for an environment variable to set
into each container.</p>

<p style="margin-top: 1em">--env-file=[] <br>
File containing key-value pairs of environment variables to
set into each container.</p>

<p style="margin-top: 1em">-f, --file=[] <br>
Path to a template file to use for the app.</p>

<p style="margin-top: 1em">--grant-install-rights=false
<br>
If true, a component that requires access to your account
may use your token to install software into your project.
Only grant images you trust the right to run with your <br>
token.</p>

<p style="margin-top: 1em">--group=[] <br>
Indicate components that should be grouped together as
&lt;comp1&gt;+&lt;comp2&gt;.</p>

<p style="margin-top: 1em">--image=[] <br>
Name of an image stream to use in the app. (deprecated)</p>

<p style="margin-top: 1em">-i, --image-stream=[] <br>
Name of an image stream to use in the app.</p>

<p style="margin-top: 1em">--insecure-registry=false <br>
If true, indicates that the referenced Docker images are on
insecure registries and should bypass certificate
checking</p>

<p style="margin-top: 1em">-l, --labels=&quot;&quot; <br>
Label to set in all resources for this application.</p>

<p style="margin-top: 1em">-L, --list=false <br>
List all local templates and image streams that can be used
to create.</p>

<p style="margin-top: 1em">--name=&quot;&quot; <br>
Set name to use for generated application artifacts</p>

<p style="margin-top: 1em">--no-install=false <br>
Do not attempt to run images that describe themselves as
being installable</p>

<p style="margin-top: 1em">-o, --output=&quot;&quot; <br>
Output results as yaml or json instead of executing, or use
name for succint output (resource/name).</p>

<p style="margin-top: 1em">--output-version=&quot;&quot;
<br>
The preferred API versions of the output objects</p>

<p style="margin-top: 1em">-p, --param=[] <br>
Specify a key-value pair (e.g., -p FOO=BAR) to set/override
a parameter value in the template.</p>

<p style="margin-top: 1em">--param-file=[] <br>
File containing parameter values to set/override in the
template.</p>

<p style="margin-top: 1em">-S, --search=false <br>
Search all templates, image streams, and Docker images that
match the arguments provided.</p>

<p style="margin-top: 1em">--strategy= <br>
Specify the build strategy to use if you don&rsquo;t want to
detect (docker|pipeline|source).</p>

<p style="margin-top: 1em">--template=[] <br>
Name of a stored template to use in the app.</p>

<p style="margin-top: 1em">OPTIONS INHERITED FROM PARENT
COMMANDS <br>
--api-version=&quot;&quot; <br>
DEPRECATED: The API version to use when talking to the
server</p>

<p style="margin-top: 1em">--as=&quot;&quot; <br>
Username to impersonate for the operation</p>


<p style="margin-top: 1em">--azure-container-registry-config=&quot;&quot;
<br>
Path to the file container Azure container registry
configuration information.</p>


<p style="margin-top: 1em">--certificate-authority=&quot;&quot;
<br>
Path to a cert. file for the certificate authority</p>


<p style="margin-top: 1em">--client-certificate=&quot;&quot;
<br>
Path to a client certificate file for TLS</p>

<p style="margin-top: 1em">--client-key=&quot;&quot; <br>
Path to a client key file for TLS</p>

<p style="margin-top: 1em">--cluster=&quot;&quot; <br>
The name of the kubeconfig cluster to use</p>

<p style="margin-top: 1em">--config=&quot;&quot; <br>
Path to the config file to use for CLI requests.</p>

<p style="margin-top: 1em">--context=&quot;&quot; <br>
The name of the kubeconfig context to use</p>

<p style="margin-top: 1em">--google-json-key=&quot;&quot;
<br>
The Google Cloud Platform Service Account JSON Key to use
for authentication.</p>


<p style="margin-top: 1em">--insecure-skip-tls-verify=false
<br>
If true, the server&rsquo;s certificate will not be checked
for validity. This will make your HTTPS connections
insecure</p>

<p style="margin-top: 1em">--log-flush-frequency=0 <br>
Maximum number of seconds between log flushes</p>

<p style="margin-top: 1em">--match-server-version=false
<br>
Require server version to match client version</p>

<p style="margin-top: 1em">-n, --namespace=&quot;&quot;
<br>
If present, the namespace scope for this CLI request</p>

<p style="margin-top: 1em">--request-timeout=&quot;0&quot;
<br>
The length of time to wait before giving up on a single
server request. Non-zero values should contain a
corresponding time unit (e.g. 1s, 2m, 3h). A value of zero
means <br>
don&rsquo;t timeout requests.</p>

<p style="margin-top: 1em">--server=&quot;&quot; <br>
The address and port of the Kubernetes API server</p>

<p style="margin-top: 1em">--token=&quot;&quot; <br>
Bearer token for authentication to the API server</p>

<p style="margin-top: 1em">--user=&quot;&quot; <br>
The name of the kubeconfig user to use</p>

<p style="margin-top: 1em">EXAMPLE <br>
# List all local templates and image streams that can be
used to create an app <br>
openshift cli new-app --list</p>

<p style="margin-top: 1em"># Create an application based on
the source code in the current git repository (with a public
remote) <br>
# and a Docker image <br>
openshift cli new-app . --docker-image=repo/langimage</p>

<p style="margin-top: 1em"># Create a Ruby application
based on the provided [image] [source code] combination <br>
openshift cli new-app centos/ruby-22-centos7
https://github.com/openshift/ruby-ex.git</p>

<p style="margin-top: 1em"># Use the public Docker Hub
MySQL image to create an app. Generated artifacts will be
labeled with db=mysql <br>
openshift cli new-app mysql MYSQL_USER=user
MYSQL_PASSWORD=pass MYSQL_DATABASE=testdb -l db=mysql</p>

<p style="margin-top: 1em"># Use a MySQL image in a private
registry to create an app and override application
artifacts&rsquo; names <br>
openshift cli new-app
--docker-image=myregistry.com/mycompany/mysql
--name=private</p>

<p style="margin-top: 1em"># Create an application from a
remote repository using its beta4 branch <br>
openshift cli new-app
https://github.com/openshift/ruby-hello-world#beta4</p>

<p style="margin-top: 1em"># Create an application based on
a stored template, explicitly setting a parameter value <br>
openshift cli new-app --template=ruby-helloworld-sample
--param=MYSQL_USER=admin</p>

<p style="margin-top: 1em"># Create an application from a
remote repository and specify a context directory <br>
openshift cli new-app
https://github.com/youruser/yourgitrepo
--context-dir=src/build</p>

<p style="margin-top: 1em"># Create an application based on
a template file, explicitly setting a parameter value <br>
openshift cli new-app --file=./example/myapp/template.json
--param=MYSQL_USER=admin</p>

<p style="margin-top: 1em"># Search all templates, image
streams, and Docker images for the ones that match
&quot;ruby&quot; <br>
openshift cli new-app --search ruby</p>

<p style="margin-top: 1em"># Search for &quot;ruby&quot;,
but only in stored templates (--template, --image-stream and
--docker-image <br>
# can be used to filter search results) <br>
openshift cli new-app --search --template=ruby</p>

<p style="margin-top: 1em"># Search for &quot;ruby&quot; in
stored templates and print the output as an YAML <br>
openshift cli new-app --search --template=ruby
--output=yaml</p>

<p style="margin-top: 1em">SEE ALSO <br>
openshift-cli(1),</p>

<p style="margin-top: 1em">HISTORY <br>
June 2016, Ported from the Kubernetes man-doc generator</p>

<p style="margin-top: 1em">Openshift Openshift CLI User
Manuals OPENSHIFT CLI(1)</p>
<hr>
</body>
</html>
