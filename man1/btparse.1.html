<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>BTPARSE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">BTPARSE(1)</td>
    <td class="head-vol">btparse</td>
    <td class="head-rtitle">BTPARSE(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
btparse - C library for parsing and processing BibTeX data files
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
   #include &lt;btparse.h&gt;
   /* Basic library initialization / cleanup */
   void bt_initialize (void);
   void bt_free_ast (AST *ast);
   void bt_cleanup (void);
   /* Input / interface to parser */
   void   bt_set_stringopts (bt_metatype_t metatype, btshort options);
   AST * bt_parse_entry_s (char *    entry_text,
                           char *    filename,
                           int       line,
                           btshort    options,
                           boolean * status);
   AST * bt_parse_entry   (FILE *    infile,
                           char *    filename,
                           btshort    options,
                           boolean * status);
   AST * bt_parse_file    (char *    filename, 
                           btshort    options, 
                           boolean * overall_status);
   /* AST traversal/query */
   AST * bt_next_entry (AST * entry_list, 
                        AST * prev_entry)
   AST * bt_next_field (AST *entry, AST *prev, char **name);
   AST * bt_next_value (AST *head, 
                        AST *prev,
                        bt_nodetype_t *nodetype,
                        char **text);
   bt_metatype_t bt_entry_metatype (AST *entry);
   char *bt_entry_type (AST *entry);
   char *bt_entry_key (AST *entry);
   char *bt_get_text (AST *node);
   /* Splitting names and lists of names */
   bt_stringlist * bt_split_list (char *   string,
                                  char *   delim,
                                  char *   filename,
                                  int      line,
                                  char *   description);
   void bt_free_list (bt_stringlist *list);
   bt_name * bt_split_name (char *  name,
                            char *  filename, 
                            int     line,
                            int     name_num);
   void bt_free_name (bt_name * name);
   /* Formatting names */
   bt_name_format * bt_create_name_format (char * parts, boolean abbrev_first);
   void bt_free_name_format (bt_name_format * format);
   void bt_set_format_text (bt_name_format * format, 
                            bt_namepart part,
                            char * pre_part,
                            char * post_part,
                            char * pre_token,
                            char * post_token);
   void bt_set_format_options (bt_name_format * format, 
                               bt_namepart part,
                               boolean abbrev,
                               bt_joinmethod join_tokens,
                               bt_joinmethod join_part);
   char * bt_format_name (bt_name * name, bt_name_format * format);
   /* Construct tree from TeX groups */
   bt_tex_tree * bt_build_tex_tree (char * string);
   void          bt_free_tex_tree (bt_tex_tree **top);
   void          bt_dump_tex_tree (bt_tex_tree *node, int depth, FILE *stream);
   char *        bt_flatten_tex_tree (bt_tex_tree *top);
   /* Miscellaneous string utilities */
   void bt_purify_string (char * string, btshort options);
   void bt_change_case (char transform, char * string, btshort options);
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>btparse</b> is a C library for parsing and processing BibTeX files. It
  provides a lexical scanner and LR parser (constructed by PCCTS), both of which
  are efficient and offer good error detection and recovery; a set of functions
  for traversing the AST (abstract syntax tree) generated by the parser; and
  utility functions for manipulating strings according to BibTeX conventions.
  (Note that nothing in the library assumes that you're using BibTeX files for
  their original purpose of bibliographic data for scholarly publications; you
  could use the file format for any conceivable purpose that fits it. However,
  there is some code in the library that is really only appropriate for use with
  strings meant to be processed in the same way that BibTeX itself does. This is
  all entirely optional, though.)
<div class="Pp"></div>
Note that the interface provided by <b>btparse</b>, while complete, is fairly
  low-level. If you have more sophisticated needs, you might be interested my
  &quot;Text::BibTeX&quot; module for Perl 5 (available on CPAN).
<h1 class="Sh" title="Sh" id="CONCEPTS_AND_TERMINOLOGY"><a class="selflink" href="#CONCEPTS_AND_TERMINOLOGY">CONCEPTS
  AND TERMINOLOGY</a></h1>
To understand this document and use <b>btparse</b>, you should already be
  familiar with the BibTeX language---more specifically, the BibTeX data
  description language. (BibTeX being the complex beast that it is, one can
  conceive of the term applying to the program, the data language, the
  particular database structure described in the original BibTeX documentation,
  the &quot;.bst&quot; formatting language, and the set of conventions embodied
  in the standard styles included with the BibTeX distribution. In this
  document, I'll stick to the first two meanings---the data language because
  that's what <b>btparse</b> deals with, and the program because it's
  occasionally necessary to explain differences between my parser and BibTeX's.)
<div class="Pp"></div>
In particular, you should have a good idea what's going on in the following:
<div class="Pp"></div>
<pre>
   @string{and = { and },
           joe = &quot;Blow, Joe&quot;,
           john = &quot;John Smith&quot;}
   @book(ourbook,
         author = joe # and # john,
         title = {Our Little Book})
</pre>
<div class="Pp"></div>
If this looks like something you want to parse, but don't want to have to write
  your own parser for, you've come to the right place.
<div class="Pp"></div>
Before going much further, though, you're going to have to learn some of the
  terminology I use for describing BibTeX data. Most of it's the same as you'll
  find in any BibTeX documentation, but it's important to be sure that we're
  talking about the same things here. So, some definitions:
<dl class="Bl-tag">
  <dt class="It-tag">top-level</dt>
  <dd class="It-tag">All text in a BibTeX file from the start of the file to the
      start of the first entry, and between entries thereafter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">name</dt>
  <dd class="It-tag">A string of letters, digits, and the following characters:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
   ! $ &amp; * + - . / : ; &lt; &gt; ? [ ] ^ _ ` |
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    A &quot;name&quot; is a catch-all used for entry types, entry keys, and
      field and macro names. For BibTeX compatibility, there are slightly
      different rules for these four entities; currently, the only such rule
      actually implemented is that field and macro names may not begin with a
      digit. Some names in the above example: &quot;string&quot;,
      &quot;and&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">entry</dt>
  <dd class="It-tag">A chunk of text starting with an &quot;at&quot; sign
      (&quot;@&quot;) at top-level, followed by a name (the <i>entry type</i>),
      an <i>entry delimiter</i> (&quot;{&quot; or &quot;(&quot;), and proceeding
      to the matching closing delimiter. Also, the data structure that results
      from parsing this chunk of text. There are two entries in the above
      example.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">entry type</dt>
  <dd class="It-tag">The name that comes right after an &quot;@&quot; at
      top-level. Examples from above: &quot;string&quot;, &quot;book&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">entry metatype</dt>
  <dd class="It-tag">A classification of entry types that allows us to group one
      or more entry types under the same heading. With the standard BibTeX
      database structure, &quot;article&quot;, &quot;book&quot;,
      &quot;inbook&quot;, etc. all fall under the &quot;regular entry&quot;
      metatype. Other metatypes are &quot;macro definition&quot; (for
      &quot;string&quot; entries), &quot;preamble&quot; (for
      &quot;preamble&quot;) entries, and &quot;comment&quot;
      (&quot;comment&quot; entries). In fact, any entry whose type is not one of
      &quot;string&quot;, &quot;preamble&quot;, or &quot;comment&quot; is called
      a &quot;regular&quot; entry.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">entry delimiters</dt>
  <dd class="It-tag">&quot;{&quot; and &quot;}&quot;, or &quot;(&quot; and
      &quot;)&quot;: the pair of characters that (almost) mark the boundaries of
      an entry. &quot;Almost&quot; because the start of an entry is marked by an
      &quot;@&quot;, not by the &quot;entry open&quot; delimiter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">entry key</dt>
  <dd class="It-tag">(Or just <i>key</i> when it's clear what we're speaking
      of.) The name immediately following the entry open delimiter in a regular
      entry, which uniquely identifies the entry. Example from above:
      &quot;ourbook&quot;. Only regular entries have keys.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">field</dt>
  <dd class="It-tag">A name to the left of an equals sign in a regular or
      macro-definition entry. In the latter context, might also be called a
      macro name. Examples from above: &quot;joe&quot;, &quot;author&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">field list</dt>
  <dd class="It-tag">In a regular entry, everything between the entry delimiters
      except for the entry key. In a macro definition entry, everything between
      the entry delimiters (possibly also called a macro list).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">compound value</dt>
  <dd class="It-tag">(Usually just &quot;value&quot;.) The text that follows an
      equals sign (&quot;=&quot;) in a regular or macro definition entry, up to
      a comma or the entry close delimiter; a list of one or more simple values
      joined by hash signs (&quot;#&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">simple value</dt>
  <dd class="It-tag">A string, macro, or number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string</dt>
  <dd class="It-tag">(Or, sometimes, &quot;quoted string.&quot;) A chunk of text
      between quotes (&quot;&quot;&quot;) or braces (&quot;{&quot; and
      &quot;}&quot;). Braces must balance: &quot;{this is a {string}&quot; is
      not a BibTeX string, but &quot;{this is a {string}}&quot; is. (&quot;this
      is a {string&quot; is also illegal, mainly to avoid the possibility of
      generating bogus TeX code--which BibTeX will do in certain cases.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">macro</dt>
  <dd class="It-tag">A name that appears on the right-hand side of an equals
      sign (i.e. as one simple value in a compound value). Implies that this
      name was defined as a macro in an earlier macro definition entry, but this
      is only checked if <b>btparse</b> is being asked to expand macros to their
      full definitions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">number</dt>
  <dd class="It-tag">An unquoted string of digits.</dd>
</dl>
<div class="Pp"></div>
Working with <b>btparse</b> generally consists of passing the library some
  BibTeX data (or a source for some BibTeX data, such as a filename or a file
  pointer), which it then lexically scans, parses, and constructs an abstract
  syntax tree (AST) from. It returns this AST to you, and you call other
  <b>btparse</b> functions to traverse and query the tree.
<div class="Pp"></div>
The contents of AST nodes are the private domain of the library, and you
  shouldn't go poking into them. This being C, though, there's nothing to
  prevent you from doing so except good manners and the possibility that I might
  change the AST structure in future releases, breaking any badly-behaved code.
  Also, it's not necessary to know the structural relationships between nodes in
  the AST---that's taken care of by the query/traversal functions.
<div class="Pp"></div>
However, it's useful to know some of the things that <b>btparse</b> deposits in
  the AST and returns to you through those query/traversal functions. First off,
  each node has a &quot;node type,&quot; which records the syntactic element
  corresponding to each node. For instance, the entry
<div class="Pp"></div>
<pre>
   @book{mybook, author = &quot;Joe Blow&quot;, title = &quot;My Little Book&quot;}
</pre>
<div class="Pp"></div>
is rooted by an &quot;entry&quot; node; under this would be found a
  &quot;key&quot; node (for the entry key), two &quot;field&quot; nodes (for the
  &quot;author&quot; and &quot;title&quot; fields); and associated with each
  field node would be a &quot;string&quot; node. The only time this concerns you
  is when you ask the library for a simple value; just looking at the text is
  not enough to distinguish quoted strings, numbers, and macro names, so
  <b>btparse</b> returns the nodetype as well.
<div class="Pp"></div>
In addition to the nodetype, <b>btparse</b> records the metatype of each
  &quot;entry&quot; node. This allows you (and the library) to distinguish, say,
  regular entries from comment entries. Not only do they have very different
  structures and must therefore be traversed differently by the library, but
  certain traversal functions make no sense on certain entry metatypes---thus
  it's necessary for you to be able to make the distinction as well.
<div class="Pp"></div>
That said, everything you need to know to work with the AST is explained in
  bt_traversal.
<h1 class="Sh" title="Sh" id="DATA_TYPES_AND_MACROS"><a class="selflink" href="#DATA_TYPES_AND_MACROS">DATA
  TYPES AND MACROS</a></h1>
<b>btparse</b> defines several types required for the external interface. First,
  it trivially defines a &quot;boolean&quot; type (along with &quot;TRUE&quot;
  and &quot;FALSE&quot; macros). This might affect you when including the
  <i>btparse.h</i> header in your own code---since it's not possible for the
  code to detect if there is already a &quot;boolean&quot; type defined, you
  might have to define the &quot;HAVE_BOOLEAN&quot; pre-processor token to
  deactivate <i>btparse.h</i>'s &quot;typedef&quot; of &quot;boolean&quot;.
<div class="Pp"></div>
Next, two enumeration types are defined: &quot;bt_metatype&quot; and
  &quot;bt_nodetype&quot;. Both of these are used extensively in the library
  itself, and are made available to users of the library because they can be
  found in nodes of the &quot;btparse&quot; AST (abstract syntax tree). (I.e.,
  querying the AST can give you &quot;bt_metatype&quot; and
  &quot;bt_nodetype&quot; values, so the &quot;typedef&quot;s must be available
  to your code.)
<h2 class="Ss" title="Ss" id="Entry_metatype_enum"><a class="selflink" href="#Entry_metatype_enum">Entry
  metatype enum</a></h2>
&quot;bt_metatype_t&quot; has the following values:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTE_UNKNOWN&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTE_REGULAR&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTE_COMMENT&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTE_PREAMBLE&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTE_MACRODEF&quot;</dd>
</dl>
<div class="Pp"></div>
which are determined by the &quot;entry type&quot; token. (@string entries have
  the &quot;BTE_MACRODEF&quot; metatype; @comment and @preamble correspond to
  &quot;BTE_COMMENT&quot; and &quot;BTE_PREAMBLE&quot;; and any other entry type
  has the &quot;BTE_REGULAR&quot; metatype.)
<h2 class="Ss" title="Ss" id="AST_nodetype_enum"><a class="selflink" href="#AST_nodetype_enum">AST
  nodetype enum</a></h2>
&quot;bt_nodetype&quot; has the following values:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTAST_UNKNOWN&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTAST_ENTRY&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTAST_KEY&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTAST_FIELD&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTAST_STRING&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTAST_NUMBER&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;BTAST_MACRO&quot;</dd>
</dl>
<div class="Pp"></div>
Of these, you'll only ever deal with the last three. They are returned when you
  query the AST for a simple value---just seeing the text isn't enough to
  distinguish between a quoted string, a number, and a macro, so the AST
  nodetype is supplied along with the text.
<h2 class="Ss" title="Ss" id="String_processing_option_macros"><a class="selflink" href="#String_processing_option_macros">String
  processing option macros</a></h2>
Since BibTeX is essentially a system for glueing strings together in a wide
  variety of ways, the processing done to its strings is fairly important. Most
  of the string transformations are done outside of the lexer/parser; this
  reduces their complexity, and makes it easier to switch different
  transformations on and off. This switching is done with an &quot;options&quot;
  bitmap which can be specified on a per-entry-metatype basis. (That is, you can
  have one set of transformations done to the strings in all regular entries,
  another set done to the strings in all macro definition entries, and so on.)
  If you need finer control than that, it's currently unavailable outside of the
  library (but it's just a matter of making a couple functions available and
  documenting them---so bug me if you need this feature).
<div class="Pp"></div>
There are three basic macros for constructing this bitmap:
<dl class="Bl-tag">
  <dt class="It-tag">&quot;BTO_CONVERT&quot;</dt>
  <dd class="It-tag">Convert &quot;number&quot; values to strings. (The
      conversion is trivial, involving changing the type of the AST node
      representing the number from &quot;BTAST_NUMBER&quot; to
      &quot;BTAST_STRING&quot;. &quot;Number&quot; values are stored as strings
      of digits, just as they are in the input data.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;BTO_EXPAND&quot;</dt>
  <dd class="It-tag">Expand macro invocations to the full macro text.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;BTO_PASTE&quot;</dt>
  <dd class="It-tag">Paste simple values together.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;BTO_COLLAPSE&quot;</dt>
  <dd class="It-tag">Collapse whitespace according to the BibTeX rules.</dd>
</dl>
<div class="Pp"></div>
For instance, supplying &quot;BTO_CONVERT | BTO_EXPAND&quot; as the string
  options bitmap for the &quot;BTE_REGULAR&quot; metatype means that all simple
  values in &quot;regular&quot; entries will be converted to strings: numbers
  will simply have their &quot;nodetype&quot; changed, and macros will be
  expanded. Nothing else will be done to the simple values, though---they will
  not be concatenated, nor will whitespace be collapsed. See the
  &quot;bt_set_stringopts()&quot; and &quot;bt_parse_*()&quot; functions in
  bt_input for more information on the various options for parsing; see
  bt_postprocess for details on the post-processing.
<h1 class="Sh" title="Sh" id="USING_THE_LIBRARY"><a class="selflink" href="#USING_THE_LIBRARY">USING
  THE LIBRARY</a></h1>
The following code is a skeletal example of using the <b>btparse</b> library:
<div class="Pp"></div>
<pre>
    #include &lt;btparse.h&gt;
    int main (void)
    {
       bt_initialize ();
       /* process some data */
       bt_cleanup ();
       exit (0);
    }
</pre>
<div class="Pp"></div>
Please note the call to &quot;bt_initialize()&quot;; this is very important!
  Without it, the library may crash or fail mysteriously. You <i>must</i> call
  &quot;bt_initialize()&quot; before calling any other <b>btparse</b> functions.
  &quot;bt_cleanup()&quot; just frees the memory allocated by
  &quot;bt_initialize()&quot;; if you are careful to call it before exiting, and
  &quot;bt_free_ast()&quot; on any abstract syntax trees generated by
  <b>btparse</b> when you are done with them, then your program shouldn't have
  any memory leaks. (Unless they're due to your own code, of course!)
<h1 class="Sh" title="Sh" id="BUGS_AND_LIMITATIONS"><a class="selflink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
<b>btparse</b> has several inherent limitations that are due to the lexical
  scanner and parser generated by PCCTS 1.x. In short, the scanner and parser
  are both heavily dependent on global variables, meaning that thread safety --
  or even the ability to have two files open and being parsed at the same time
  -- is well-nigh impossible. This will not change until I get with the times
  and adopt ANTLR 2.0, the successor to PCCTS -- presuming of course that it can
  generate more modular C scanners and parsers.
<div class="Pp"></div>
Another limitation that is due to PCCTS: entries with a large number of fields
  (more than about 90, if each field value is just a single string) will cause
  the parser to crash. This is unavoidable due to the parser using
  statically-allocated stacks for attributes and abstract-syntax tree nodes. I
  could increase the static allocation, but that would just decrease the
  likelihood of encountering the problem, not make it go away. Again, the
  chances of this changing as long as I'm using PCCTS 1.x are nil.
<div class="Pp"></div>
Apart from those inherent limitations, there are no known bugs in
  <b>btparse</b>. Any segmentation faults or bus errors from the library should
  be considered bugs. They probably result from using the library incorrectly
  (eg. attempting to interleave the parsing of two files), but I do make an
  attempt to catch all such mistakes, and if I've missed any I'd like to know
  about it.
<div class="Pp"></div>
Any memory leaks from the library are also a concern; as long as you are
  conscientious about calling the cleanup functions (&quot;bt_free_ast()&quot;
  and &quot;bt_cleanup()&quot;), then the library shouldn't leak.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
To read and parse BibTeX data files, see bt_input.
<div class="Pp"></div>
To traverse the syntax tree that results, see bt_traversal.
<div class="Pp"></div>
To learn what is done to values in parsed entries, and how to customize that
  munging, see bt_postprocess.
<div class="Pp"></div>
To learn how <b>btparse</b> deals with strings, see bt_strings (oops, I haven't
  written this one yet!).
<div class="Pp"></div>
To manipulate and access the <b>btparse</b> macro table, see bt_macros.
<div class="Pp"></div>
For splitting author names and lists &quot;the BibTeX way&quot; using
  <b>btparse</b>, bt_split_names.
<div class="Pp"></div>
To put author names back together again, see bt_format_names.
<div class="Pp"></div>
Miscellaneous functions for processing strings &quot;the BibTeX way&quot;:
  bt_misc.
<div class="Pp"></div>
A semi-formal language definition is in bt_language.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Greg Ward &lt;gward@python.net&gt;
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 1996-97 by Gregory P. Ward.
<div class="Pp"></div>
This library is free software; you can redistribute it and/or modify it under
  the terms of the GNU Library General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option) any
  later version.
<div class="Pp"></div>
This library is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU Library General Public License for more
  details.
<div class="Pp"></div>
You should have received a copy of the GNU Library General Public License along
  with this library; if not, write to the Free Software Foundation, Inc., 675
  Mass Ave, Cambridge, MA 02139, USA.
<h1 class="Sh" title="Sh" id="AVAILABILITY"><a class="selflink" href="#AVAILABILITY">AVAILABILITY</a></h1>
The btOOL home page, where you can get up-to-date information about
  <b>btparse</b> (and download the latest version) is
<div class="Pp"></div>
<pre>
   http://starship.python.net/~gward/btOOL/
</pre>
<div class="Pp"></div>
You will also find the latest version of <b>Text::BibTeX</b>, the Perl library
  that provides a high-level front-end to <b>btparse</b>, there. <b>btparse</b>
  is needed to build &quot;Text::BibTeX&quot;, and must be downloaded
  separately.
<div class="Pp"></div>
Both libraries are also available on CTAN (the Comprehensive TeX Archive
  Network, &quot;http://www.ctan.org/tex-archive/&quot;) and CPAN (the
  Comprehensive Perl Archive Network, &quot;http://www.cpan.org/&quot;). Look in
  <i>biblio/bibtex/utils/btOOL/</i> on CTAN, and <i>authors/Greg_Ward/</i> on
  CPAN. For example,
<div class="Pp"></div>
<pre>
   http://www.ctan.org/tex-archive/biblio/bibtex/utils/btOOL/
   http://www.cpan.org/authors/Greg_Ward
</pre>
<div class="Pp"></div>
will both get you to the latest version of &quot;Text::BibTeX&quot; and
  <b>btparse</b> -- but of course, you should always access busy sites like CTAN
  and CPAN through a mirror.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-01-10</td>
    <td class="foot-os">btparse, version 0.78</td>
  </tr>
</table>
</body>
</html>
