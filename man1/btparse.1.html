<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:56:28 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>BTPARSE(1) btparse BTPARSE(1)</p>

<p style="margin-top: 1em">NAME <br>
btparse - C library for parsing and processing BibTeX data
files</p>

<p style="margin-top: 1em">SYNOPSIS <br>
#include &lt;btparse.h&gt;</p>

<p style="margin-top: 1em">/* Basic library initialization
/ cleanup */ <br>
void bt_initialize (void); <br>
void bt_free_ast (AST *ast); <br>
void bt_cleanup (void);</p>

<p style="margin-top: 1em">/* Input / interface to parser
*/ <br>
void bt_set_stringopts (bt_metatype_t metatype, btshort
options); <br>
AST * bt_parse_entry_s (char * entry_text, <br>
char * filename, <br>
int line, <br>
btshort options, <br>
boolean * status); <br>
AST * bt_parse_entry (FILE * infile, <br>
char * filename, <br>
btshort options, <br>
boolean * status); <br>
AST * bt_parse_file (char * filename, <br>
btshort options, <br>
boolean * overall_status);</p>

<p style="margin-top: 1em">/* AST traversal/query */ <br>
AST * bt_next_entry (AST * entry_list, <br>
AST * prev_entry) <br>
AST * bt_next_field (AST *entry, AST *prev, char **name);
<br>
AST * bt_next_value (AST *head, <br>
AST *prev, <br>
bt_nodetype_t *nodetype, <br>
char **text);</p>

<p style="margin-top: 1em">bt_metatype_t bt_entry_metatype
(AST *entry); <br>
char *bt_entry_type (AST *entry); <br>
char *bt_entry_key (AST *entry); <br>
char *bt_get_text (AST *node);</p>

<p style="margin-top: 1em">/* Splitting names and lists of
names */ <br>
bt_stringlist * bt_split_list (char * string, <br>
char * delim, <br>
char * filename, <br>
int line, <br>
char * description); <br>
void bt_free_list (bt_stringlist *list); <br>
bt_name * bt_split_name (char * name, <br>
char * filename, <br>
int line, <br>
int name_num); <br>
void bt_free_name (bt_name * name);</p>

<p style="margin-top: 1em">/* Formatting names */ <br>
bt_name_format * bt_create_name_format (char * parts,
boolean abbrev_first); <br>
void bt_free_name_format (bt_name_format * format); <br>
void bt_set_format_text (bt_name_format * format, <br>
bt_namepart part, <br>
char * pre_part, <br>
char * post_part, <br>
char * pre_token, <br>
char * post_token); <br>
void bt_set_format_options (bt_name_format * format, <br>
bt_namepart part, <br>
boolean abbrev, <br>
bt_joinmethod join_tokens, <br>
bt_joinmethod join_part); <br>
char * bt_format_name (bt_name * name, bt_name_format *
format);</p>

<p style="margin-top: 1em">/* Construct tree from TeX
groups */ <br>
bt_tex_tree * bt_build_tex_tree (char * string); <br>
void bt_free_tex_tree (bt_tex_tree **top); <br>
void bt_dump_tex_tree (bt_tex_tree *node, int depth, FILE
*stream); <br>
char * bt_flatten_tex_tree (bt_tex_tree *top);</p>

<p style="margin-top: 1em">/* Miscellaneous string
utilities */ <br>
void bt_purify_string (char * string, btshort options); <br>
void bt_change_case (char transform, char * string, btshort
options);</p>

<p style="margin-top: 1em">DESCRIPTION <br>
btparse is a C library for parsing and processing BibTeX
files. It provides a lexical scanner and LR parser
(constructed by PCCTS), both of which are efficient and
offer good <br>
error detection and recovery; a set of functions for
traversing the AST (abstract syntax tree) generated by the
parser; and utility functions for manipulating strings
according <br>
to BibTeX conventions. (Note that nothing in the library
assumes that you&rsquo;re using BibTeX files for their
original purpose of bibliographic data for scholarly
publications; you <br>
could use the file format for any conceivable purpose that
fits it. However, there is some code in the library that is
really only appropriate for use with strings meant to be
<br>
processed in the same way that BibTeX itself does. This is
all entirely optional, though.)</p>

<p style="margin-top: 1em">Note that the interface provided
by btparse, while complete, is fairly low-level. If you have
more sophisticated needs, you might be interested my
&quot;Text::BibTeX&quot; module for Perl <br>
5 (available on CPAN).</p>

<p style="margin-top: 1em">CONCEPTS AND TERMINOLOGY <br>
To understand this document and use btparse, you should
already be familiar with the BibTeX language---more
specifically, the BibTeX data description language. (BibTeX
being the <br>
complex beast that it is, one can conceive of the term
applying to the program, the data language, the particular
database structure described in the original BibTeX <br>
documentation, the &quot;.bst&quot; formatting language, and
the set of conventions embodied in the standard styles
included with the BibTeX distribution. In this document,
I&rsquo;ll stick to <br>
the first two meanings---the data language because
that&rsquo;s what btparse deals with, and the program
because it&rsquo;s occasionally necessary to explain
differences between my parser <br>
and BibTeX&rsquo;s.)</p>

<p style="margin-top: 1em">In particular, you should have a
good idea what&rsquo;s going on in the following:</p>

<p style="margin-top: 1em">@string{and = { and }, <br>
joe = &quot;Blow, Joe&quot;, <br>
john = &quot;John Smith&quot;}</p>

<p style="margin-top: 1em">@book(ourbook, <br>
author = joe # and # john, <br>
title = {Our Little Book})</p>

<p style="margin-top: 1em">If this looks like something you
want to parse, but don&rsquo;t want to have to write your
own parser for, you&rsquo;ve come to the right place.</p>

<p style="margin-top: 1em">Before going much further,
though, you&rsquo;re going to have to learn some of the
terminology I use for describing BibTeX data. Most of
it&rsquo;s the same as you&rsquo;ll find in any BibTeX <br>
documentation, but it&rsquo;s important to be sure that
we&rsquo;re talking about the same things here. So, some
definitions:</p>

<p style="margin-top: 1em">top-level <br>
All text in a BibTeX file from the start of the file to the
start of the first entry, and between entries
thereafter.</p>

<p style="margin-top: 1em">name <br>
A string of letters, digits, and the following
characters:</p>

<p style="margin-top: 1em">! $ &amp; * + - . / : ; &lt;
&gt; ? [ ] ^ _ &lsquo; |</p>

<p style="margin-top: 1em">A &quot;name&quot; is a
catch-all used for entry types, entry keys, and field and
macro names. For BibTeX compatibility, there are slightly
different rules for these four entities; <br>
currently, the only such rule actually implemented is that
field and macro names may not begin with a digit. Some names
in the above example: &quot;string&quot;,
&quot;and&quot;.</p>

<p style="margin-top: 1em">entry <br>
A chunk of text starting with an &quot;at&quot; sign
(&quot;@&quot;) at top-level, followed by a name (the entry
type), an entry delimiter (&quot;{&quot; or &quot;(&quot;),
and proceeding to the matching closing <br>
delimiter. Also, the data structure that results from
parsing this chunk of text. There are two entries in the
above example.</p>

<p style="margin-top: 1em">entry type <br>
The name that comes right after an &quot;@&quot; at
top-level. Examples from above: &quot;string&quot;,
&quot;book&quot;.</p>

<p style="margin-top: 1em">entry metatype <br>
A classification of entry types that allows us to group one
or more entry types under the same heading. With the
standard BibTeX database structure, &quot;article&quot;,
&quot;book&quot;, <br>
&quot;inbook&quot;, etc. all fall under the &quot;regular
entry&quot; metatype. Other metatypes are &quot;macro
definition&quot; (for &quot;string&quot; entries),
&quot;preamble&quot; (for &quot;preamble&quot;) entries, and
&quot;comment&quot; <br>
(&quot;comment&quot; entries). In fact, any entry whose type
is not one of &quot;string&quot;, &quot;preamble&quot;, or
&quot;comment&quot; is called a &quot;regular&quot;
entry.</p>

<p style="margin-top: 1em">entry delimiters <br>
&quot;{&quot; and &quot;}&quot;, or &quot;(&quot; and
&quot;)&quot;: the pair of characters that (almost) mark the
boundaries of an entry. &quot;Almost&quot; because the start
of an entry is marked by an &quot;@&quot;, not by the <br>
&quot;entry open&quot; delimiter.</p>

<p style="margin-top: 1em">entry key <br>
(Or just key when it&rsquo;s clear what we&rsquo;re speaking
of.) The name immediately following the entry open delimiter
in a regular entry, which uniquely identifies the entry.
<br>
Example from above: &quot;ourbook&quot;. Only regular
entries have keys.</p>

<p style="margin-top: 1em">field <br>
A name to the left of an equals sign in a regular or
macro-definition entry. In the latter context, might also be
called a macro name. Examples from above: &quot;joe&quot;,
&quot;author&quot;.</p>

<p style="margin-top: 1em">field list <br>
In a regular entry, everything between the entry delimiters
except for the entry key. In a macro definition entry,
everything between the entry delimiters (possibly also <br>
called a macro list).</p>

<p style="margin-top: 1em">compound value <br>
(Usually just &quot;value&quot;.) The text that follows an
equals sign (&quot;=&quot;) in a regular or macro definition
entry, up to a comma or the entry close delimiter; a list of
one or more <br>
simple values joined by hash signs (&quot;#&quot;).</p>

<p style="margin-top: 1em">simple value <br>
A string, macro, or number.</p>

<p style="margin-top: 1em">string <br>
(Or, sometimes, &quot;quoted string.&quot;) A chunk of text
between quotes (&quot;&quot;&quot;) or braces (&quot;{&quot;
and &quot;}&quot;). Braces must balance: &quot;{this is a
{string}&quot; is not a BibTeX string, but <br>
&quot;{this is a {string}}&quot; is. (&quot;this is a
{string&quot; is also illegal, mainly to avoid the
possibility of generating bogus TeX code--which BibTeX will
do in certain cases.)</p>

<p style="margin-top: 1em">macro <br>
A name that appears on the right-hand side of an equals sign
(i.e. as one simple value in a compound value). Implies that
this name was defined as a macro in an earlier <br>
macro definition entry, but this is only checked if btparse
is being asked to expand macros to their full
definitions.</p>

<p style="margin-top: 1em">number <br>
An unquoted string of digits.</p>

<p style="margin-top: 1em">Working with btparse generally
consists of passing the library some BibTeX data (or a
source for some BibTeX data, such as a filename or a file
pointer), which it then lexically <br>
scans, parses, and constructs an abstract syntax tree (AST)
from. It returns this AST to you, and you call other btparse
functions to traverse and query the tree.</p>

<p style="margin-top: 1em">The contents of AST nodes are
the private domain of the library, and you shouldn&rsquo;t
go poking into them. This being C, though, there&rsquo;s
nothing to prevent you from doing so except <br>
good manners and the possibility that I might change the AST
structure in future releases, breaking any badly-behaved
code. Also, it&rsquo;s not necessary to know the structural
<br>
relationships between nodes in the AST---that&rsquo;s taken
care of by the query/traversal functions.</p>

<p style="margin-top: 1em">However, it&rsquo;s useful to
know some of the things that btparse deposits in the AST and
returns to you through those query/traversal functions.
First off, each node has a &quot;node <br>
type,&quot; which records the syntactic element
corresponding to each node. For instance, the entry</p>

<p style="margin-top: 1em">@book{mybook, author = &quot;Joe
Blow&quot;, title = &quot;My Little Book&quot;}</p>

<p style="margin-top: 1em">is rooted by an
&quot;entry&quot; node; under this would be found a
&quot;key&quot; node (for the entry key), two
&quot;field&quot; nodes (for the &quot;author&quot; and
&quot;title&quot; fields); and associated with each field
<br>
node would be a &quot;string&quot; node. The only time this
concerns you is when you ask the library for a simple value;
just looking at the text is not enough to distinguish quoted
<br>
strings, numbers, and macro names, so btparse returns the
nodetype as well.</p>

<p style="margin-top: 1em">In addition to the nodetype,
btparse records the metatype of each &quot;entry&quot; node.
This allows you (and the library) to distinguish, say,
regular entries from comment entries. Not <br>
only do they have very different structures and must
therefore be traversed differently by the library, but
certain traversal functions make no sense on certain entry
<br>
metatypes---thus it&rsquo;s necessary for you to be able to
make the distinction as well.</p>

<p style="margin-top: 1em">That said, everything you need
to know to work with the AST is explained in
bt_traversal.</p>

<p style="margin-top: 1em">DATA TYPES AND MACROS <br>
btparse defines several types required for the external
interface. First, it trivially defines a &quot;boolean&quot;
type (along with &quot;TRUE&quot; and &quot;FALSE&quot;
macros). This might affect you <br>
when including the btparse.h header in your own code---since
it&rsquo;s not possible for the code to detect if there is
already a &quot;boolean&quot; type defined, you might have
to define the <br>
&quot;HAVE_BOOLEAN&quot; pre-processor token to deactivate
btparse.h&rsquo;s &quot;typedef&quot; of
&quot;boolean&quot;.</p>

<p style="margin-top: 1em">Next, two enumeration types are
defined: &quot;bt_metatype&quot; and
&quot;bt_nodetype&quot;. Both of these are used extensively
in the library itself, and are made available to users of
the <br>
library because they can be found in nodes of the
&quot;btparse&quot; AST (abstract syntax tree). (I.e.,
querying the AST can give you &quot;bt_metatype&quot; and
&quot;bt_nodetype&quot; values, so the <br>
&quot;typedef&quot;s must be available to your code.)</p>

<p style="margin-top: 1em">Entry metatype enum <br>
&quot;bt_metatype_t&quot; has the following values:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTE_UNKNOWN&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTE_REGULAR&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTE_COMMENT&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTE_PREAMBLE&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTE_MACRODEF&quot;</p>

<p style="margin-top: 1em">which are determined by the
&quot;entry type&quot; token. (@string entries have the
&quot;BTE_MACRODEF&quot; metatype; @comment and @preamble
correspond to &quot;BTE_COMMENT&quot; and
&quot;BTE_PREAMBLE&quot;; and any <br>
other entry type has the &quot;BTE_REGULAR&quot;
metatype.)</p>

<p style="margin-top: 1em">AST nodetype enum <br>
&quot;bt_nodetype&quot; has the following values:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTAST_UNKNOWN&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTAST_ENTRY&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTAST_KEY&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTAST_FIELD&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTAST_STRING&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTAST_NUMBER&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;BTAST_MACRO&quot;</p>

<p style="margin-top: 1em">Of these, you&rsquo;ll only ever
deal with the last three. They are returned when you query
the AST for a simple value---just seeing the text
isn&rsquo;t enough to distinguish between a <br>
quoted string, a number, and a macro, so the AST nodetype is
supplied along with the text.</p>

<p style="margin-top: 1em">String processing option macros
<br>
Since BibTeX is essentially a system for glueing strings
together in a wide variety of ways, the processing done to
its strings is fairly important. Most of the string <br>
transformations are done outside of the lexer/parser; this
reduces their complexity, and makes it easier to switch
different transformations on and off. This switching is done
<br>
with an &quot;options&quot; bitmap which can be specified on
a per-entry-metatype basis. (That is, you can have one set
of transformations done to the strings in all regular
entries, <br>
another set done to the strings in all macro definition
entries, and so on.) If you need finer control than that,
it&rsquo;s currently unavailable outside of the library (but
it&rsquo;s <br>
just a matter of making a couple functions available and
documenting them---so bug me if you need this feature).</p>

<p style="margin-top: 1em">There are three basic macros for
constructing this bitmap:</p>

<p style="margin-top: 1em">&quot;BTO_CONVERT&quot; <br>
Convert &quot;number&quot; values to strings. (The
conversion is trivial, involving changing the type of the
AST node representing the number from
&quot;BTAST_NUMBER&quot; to &quot;BTAST_STRING&quot;. <br>
&quot;Number&quot; values are stored as strings of digits,
just as they are in the input data.)</p>

<p style="margin-top: 1em">&quot;BTO_EXPAND&quot; <br>
Expand macro invocations to the full macro text.</p>

<p style="margin-top: 1em">&quot;BTO_PASTE&quot; <br>
Paste simple values together.</p>

<p style="margin-top: 1em">&quot;BTO_COLLAPSE&quot; <br>
Collapse whitespace according to the BibTeX rules.</p>

<p style="margin-top: 1em">For instance, supplying
&quot;BTO_CONVERT | BTO_EXPAND&quot; as the string options
bitmap for the &quot;BTE_REGULAR&quot; metatype means that
all simple values in &quot;regular&quot; entries will be
converted <br>
to strings: numbers will simply have their
&quot;nodetype&quot; changed, and macros will be expanded.
Nothing else will be done to the simple values,
though---they will not be <br>
concatenated, nor will whitespace be collapsed. See the
&quot;bt_set_stringopts()&quot; and &quot;bt_parse_*()&quot;
functions in bt_input for more information on the various
options for parsing; <br>
see bt_postprocess for details on the post-processing.</p>

<p style="margin-top: 1em">USING THE LIBRARY <br>
The following code is a skeletal example of using the
btparse library:</p>

<p style="margin-top: 1em">#include &lt;btparse.h&gt;</p>

<p style="margin-top: 1em">int main (void) <br>
{ <br>
bt_initialize ();</p>

<p style="margin-top: 1em">/* process some data */</p>

<p style="margin-top: 1em">bt_cleanup (); <br>
exit (0); <br>
}</p>

<p style="margin-top: 1em">Please note the call to
&quot;bt_initialize()&quot;; this is very important! Without
it, the library may crash or fail mysteriously. You must
call &quot;bt_initialize()&quot; before calling any <br>
other btparse functions. &quot;bt_cleanup()&quot; just frees
the memory allocated by &quot;bt_initialize()&quot;; if you
are careful to call it before exiting, and
&quot;bt_free_ast()&quot; on any abstract <br>
syntax trees generated by btparse when you are done with
them, then your program shouldn&rsquo;t have any memory
leaks. (Unless they&rsquo;re due to your own code, of
course!)</p>

<p style="margin-top: 1em">BUGS AND LIMITATIONS <br>
btparse has several inherent limitations that are due to the
lexical scanner and parser generated by PCCTS 1.x. In short,
the scanner and parser are both heavily dependent on <br>
global variables, meaning that thread safety -- or even the
ability to have two files open and being parsed at the same
time -- is well-nigh impossible. This will not change <br>
until I get with the times and adopt ANTLR 2.0, the
successor to PCCTS -- presuming of course that it can
generate more modular C scanners and parsers.</p>

<p style="margin-top: 1em">Another limitation that is due
to PCCTS: entries with a large number of fields (more than
about 90, if each field value is just a single string) will
cause the parser to crash. <br>
This is unavoidable due to the parser using
statically-allocated stacks for attributes and
abstract-syntax tree nodes. I could increase the static
allocation, but that would <br>
just decrease the likelihood of encountering the problem,
not make it go away. Again, the chances of this changing as
long as I&rsquo;m using PCCTS 1.x are nil.</p>

<p style="margin-top: 1em">Apart from those inherent
limitations, there are no known bugs in btparse. Any
segmentation faults or bus errors from the library should be
considered bugs. They probably <br>
result from using the library incorrectly (eg. attempting to
interleave the parsing of two files), but I do make an
attempt to catch all such mistakes, and if I&rsquo;ve missed
any I&rsquo;d <br>
like to know about it.</p>

<p style="margin-top: 1em">Any memory leaks from the
library are also a concern; as long as you are conscientious
about calling the cleanup functions
(&quot;bt_free_ast()&quot; and &quot;bt_cleanup()&quot;),
then the library <br>
shouldn&rsquo;t leak.</p>

<p style="margin-top: 1em">SEE ALSO <br>
To read and parse BibTeX data files, see bt_input.</p>

<p style="margin-top: 1em">To traverse the syntax tree that
results, see bt_traversal.</p>

<p style="margin-top: 1em">To learn what is done to values
in parsed entries, and how to customize that munging, see
bt_postprocess.</p>

<p style="margin-top: 1em">To learn how btparse deals with
strings, see bt_strings (oops, I haven&rsquo;t written this
one yet!).</p>

<p style="margin-top: 1em">To manipulate and access the
btparse macro table, see bt_macros.</p>

<p style="margin-top: 1em">For splitting author names and
lists &quot;the BibTeX way&quot; using btparse,
bt_split_names.</p>

<p style="margin-top: 1em">To put author names back
together again, see bt_format_names.</p>

<p style="margin-top: 1em">Miscellaneous functions for
processing strings &quot;the BibTeX way&quot;: bt_misc.</p>

<p style="margin-top: 1em">A semi-formal language
definition is in bt_language.</p>

<p style="margin-top: 1em">AUTHOR <br>
Greg Ward &lt;gward@python.net&gt;</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (c) 1996-97 by Gregory P. Ward.</p>

<p style="margin-top: 1em">This library is free software;
you can redistribute it and/or modify it under the terms of
the GNU Library General Public License as published by the
Free Software Foundation; <br>
either version 2 of the License, or (at your option) any
later version.</p>

<p style="margin-top: 1em">This library is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR <br>
PURPOSE. See the GNU Library General Public License for more
details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU Library General Public License along with this
library; if not, write to the Free Software Foundation,
Inc., 675 Mass Ave, Cambridge, <br>
MA 02139, USA.</p>

<p style="margin-top: 1em">AVAILABILITY <br>
The btOOL home page, where you can get up-to-date
information about btparse (and download the latest version)
is</p>


<p style="margin-top: 1em">http://starship.python.net/~gward/btOOL/</p>

<p style="margin-top: 1em">You will also find the latest
version of Text::BibTeX, the Perl library that provides a
high-level front-end to btparse, there. btparse is needed to
build &quot;Text::BibTeX&quot;, and <br>
must be downloaded separately.</p>

<p style="margin-top: 1em">Both libraries are also
available on CTAN (the Comprehensive TeX Archive Network,
&quot;http://www.ctan.org/tex-archive/&quot;) and CPAN (the
Comprehensive Perl Archive Network, <br>
&quot;http://www.cpan.org/&quot;). Look in
biblio/bibtex/utils/btOOL/ on CTAN, and authors/Greg_Ward/
on CPAN. For example,</p>


<p style="margin-top: 1em">http://www.ctan.org/tex-archive/biblio/bibtex/utils/btOOL/
<br>
http://www.cpan.org/authors/Greg_Ward</p>

<p style="margin-top: 1em">will both get you to the latest
version of &quot;Text::BibTeX&quot; and btparse -- but of
course, you should always access busy sites like CTAN and
CPAN through a mirror.</p>

<p style="margin-top: 1em">btparse, version 0.78 2017-01-10
BTPARSE(1)</p>
<hr>
</body>
</html>
