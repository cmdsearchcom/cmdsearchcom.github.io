<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:50 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLFAQ5(1) Perl Programmers Reference Guide
PERLFAQ5(1)</p>

<p style="margin-top: 1em">NAME <br>
perlfaq5 - Files and Formats</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This section deals with I/O and the &quot;f&quot; issues:
filehandles, flushing, formats, and footers.</p>

<p style="margin-top: 1em">How do I flush/unbuffer an
output filehandle? Why must I do this? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">You might like to read Mark
Jason Dominus&rsquo;s &quot;Suffering From Buffering&quot;
at &lt;http://perl.plover.com/FAQs/Buffering.html&gt; .</p>

<p style="margin-top: 1em">Perl normally buffers output so
it doesn&rsquo;t make a system call for every bit of output.
By saving up output, it makes fewer expensive system calls.
For instance, in this little <br>
bit of code, you want to print a dot to the screen for every
line you process to watch the progress of your program.
Instead of seeing a dot for every line, Perl buffers the
<br>
output and you have a long wait before you see a row of 50
dots all at once:</p>

<p style="margin-top: 1em"># long wait, then row of dots
all at once <br>
while( &lt;&gt; ) { <br>
print &quot;.&quot;; <br>
print &quot;0 unless ++$count % 50;</p>

<p style="margin-top: 1em">#... expensive line processing
operations <br>
}</p>

<p style="margin-top: 1em">To get around this, you have to
unbuffer the output filehandle, in this case,
&quot;STDOUT&quot;. You can set the special variable $| to a
true value (mnemonic: making your filehandles <br>
&quot;piping hot&quot;):</p>

<p style="margin-top: 1em">$|++;</p>

<p style="margin-top: 1em"># dot shown immediately <br>
while( &lt;&gt; ) { <br>
print &quot;.&quot;; <br>
print &quot;0 unless ++$count % 50;</p>

<p style="margin-top: 1em">#... expensive line processing
operations <br>
}</p>

<p style="margin-top: 1em">The $| is one of the
per-filehandle special variables, so each filehandle has its
own copy of its value. If you want to merge standard output
and standard error for instance, you <br>
have to unbuffer each (although STDERR might be unbuffered
by default):</p>

<p style="margin-top: 1em">{ <br>
my $previous_default = select(STDOUT); # save previous
default <br>
$|++; # autoflush STDOUT <br>
select(STDERR); <br>
$|++; # autoflush STDERR, to be sure <br>
select($previous_default); # restore previous default <br>
}</p>

<p style="margin-top: 1em"># now should alternate . and +
<br>
while( 1 ) { <br>
sleep 1; <br>
print STDOUT &quot;.&quot;; <br>
print STDERR &quot;+&quot;; <br>
print STDOUT &quot;0 unless ++$count % 25; <br>
}</p>

<p style="margin-top: 1em">Besides the $| special variable,
you can use &quot;binmode&quot; to give your filehandle a
&quot;:unix&quot; layer, which is unbuffered:</p>

<p style="margin-top: 1em">binmode( STDOUT,
&quot;:unix&quot; );</p>

<p style="margin-top: 1em">while( 1 ) { <br>
sleep 1; <br>
print &quot;.&quot;; <br>
print &quot;0 unless ++$count % 50; <br>
}</p>

<p style="margin-top: 1em">For more information on output
layers, see the entries for &quot;binmode&quot; and open in
perlfunc, and the PerlIO module documentation.</p>

<p style="margin-top: 1em">If you are using IO::Handle or
one of its subclasses, you can call the
&quot;autoflush&quot; method to change the settings of the
filehandle:</p>

<p style="margin-top: 1em">use IO::Handle; <br>
open my( $io_fh ), &quot;&gt;&quot;, &quot;output.txt&quot;;
<br>
$io_fh-&gt;autoflush(1);</p>

<p style="margin-top: 1em">The IO::Handle objects also have
a &quot;flush&quot; method. You can flush the buffer any
time you want without auto-buffering</p>

<p style="margin-top: 1em">$io_fh-&gt;flush;</p>

<p style="margin-top: 1em">How do I change, delete, or
insert a line in a file, or append to the beginning of a
file? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">The basic idea of inserting,
changing, or deleting a line from a text file involves
reading and printing the file to the point you want to make
the change, making the change, <br>
then reading and printing the rest of the file. Perl
doesn&rsquo;t provide random access to lines (especially
since the record input separator, $/, is mutable), although
modules such <br>
as Tie::File can fake it.</p>

<p style="margin-top: 1em">A Perl program to do these tasks
takes the basic form of opening a file, printing its lines,
then closing the file:</p>

<p style="margin-top: 1em">open my $in, &rsquo;&lt;&rsquo;,
$file or die &quot;Can&rsquo;t read old file: $!&quot;; <br>
open my $out, &rsquo;&gt;&rsquo;, &quot;$file.new&quot; or
die &quot;Can&rsquo;t write new file: $!&quot;;</p>

<p style="margin-top: 1em">while( &lt;$in&gt; ) { <br>
print $out $_; <br>
}</p>

<p style="margin-top: 1em">close $out;</p>

<p style="margin-top: 1em">Within that basic form, add the
parts that you need to insert, change, or delete lines.</p>

<p style="margin-top: 1em">To prepend lines to the
beginning, print those lines before you enter the loop that
prints the existing lines.</p>

<p style="margin-top: 1em">open my $in, &rsquo;&lt;&rsquo;,
$file or die &quot;Can&rsquo;t read old file: $!&quot;; <br>
open my $out, &rsquo;&gt;&rsquo;, &quot;$file.new&quot; or
die &quot;Can&rsquo;t write new file: $!&quot;;</p>

<p style="margin-top: 1em">print $out &quot;# Add this line
to the top0; # &lt;--- HERE&rsquo;S THE MAGIC</p>

<p style="margin-top: 1em">while( &lt;$in&gt; ) { <br>
print $out $_; <br>
}</p>

<p style="margin-top: 1em">close $out;</p>

<p style="margin-top: 1em">To change existing lines, insert
the code to modify the lines inside the &quot;while&quot;
loop. In this case, the code finds all lowercased versions
of &quot;perl&quot; and uppercases them. The <br>
happens for every line, so be sure that you&rsquo;re
supposed to do that on every line!</p>

<p style="margin-top: 1em">open my $in, &rsquo;&lt;&rsquo;,
$file or die &quot;Can&rsquo;t read old file: $!&quot;; <br>
open my $out, &rsquo;&gt;&rsquo;, &quot;$file.new&quot; or
die &quot;Can&rsquo;t write new file: $!&quot;;</p>

<p style="margin-top: 1em">print $out &quot;# Add this line
to the top0;</p>

<p style="margin-top: 1em">while( &lt;$in&gt; ) { p e r
<br>
s/l ) g ; <br>
print $out $_; <br>
}</p>

<p style="margin-top: 1em">close $out;</p>

<p style="margin-top: 1em">To change only a particular
line, the input line number, $., is useful. First read and
print the lines up to the one you want to change. Next, read
the single line you want to <br>
change, change it, and print it. After that, read the rest
of the lines and print those:</p>

<p style="margin-top: 1em">while( &lt;$in&gt; ) { # print
the lines before the change <br>
print $out $_; <br>
last if $. == 4; # line number before change <br>
}</p>

<p style="margin-top: 1em">my $line = &lt;$in&gt;; p e r
<br>
$line =~ s/l ) g ; <br>
print $out $line;</p>

<p style="margin-top: 1em">while( &lt;$in&gt; ) { # print
the rest of the lines <br>
print $out $_; <br>
}</p>

<p style="margin-top: 1em">To skip lines, use the looping
controls. The &quot;next&quot; in this example skips comment
lines, and the &quot;last&quot; stops all processing once it
encounters either &quot;__END__&quot; or
&quot;__DATA__&quot;.</p>

<p style="margin-top: 1em">while( &lt;$in&gt; ) { <br>
next if /^ # skip comment lines <br>
last if /^__(END|DATA)__$/; # stop at end of code marker
<br>
print $out $_; <br>
}</p>

<p style="margin-top: 1em">Do the same sort of thing to
delete a particular line by using &quot;next&quot; to skip
the lines you don&rsquo;t want to show up in the output.
This example skips every fifth line:</p>

<p style="margin-top: 1em">while( &lt;$in&gt; ) { <br>
next unless $. % 5; <br>
print $out $_; <br>
}</p>

<p style="margin-top: 1em">If, for some odd reason, you
really want to see the whole file at once rather than
processing line-by-line, you can slurp it in (as long as you
can fit the whole thing in <br>
memory!):</p>

<p style="margin-top: 1em">open my $in, &rsquo;&lt;&rsquo;,
$file or die &quot;Can&rsquo;t read old file: $!&quot; <br>
open my $out, &rsquo;&gt;&rsquo;, &quot;$file.new&quot; or
die &quot;Can&rsquo;t write new file: $!&quot;;</p>

<p style="margin-top: 1em">my @lines = do { local $/;
&lt;$in&gt; }; # slurp!</p>

<p style="margin-top: 1em"># do your magic here</p>

<p style="margin-top: 1em">print $out @lines;</p>

<p style="margin-top: 1em">Modules such as File::Slurp and
Tie::File can help with that too. If you can, however, avoid
reading the entire file at once. Perl won&rsquo;t give that
memory back to the operating <br>
system until the process finishes.</p>

<p style="margin-top: 1em">You can also use Perl one-liners
to modify a file in-place. The following changes all
&rsquo;Fred&rsquo; to &rsquo;Barney&rsquo; in inFile.txt,
overwriting the file with the new contents. With the
&quot;-p&quot; <br>
switch, Perl wraps a &quot;while&quot; loop around the code
you specify with &quot;-e&quot;, and &quot;-i&quot; turns on
in-place editing. The current line is in $_. With
&quot;-p&quot;, Perl automatically prints the <br>
value of $_ at the end of the loop. See perlrun for more
details.</p>

<p style="margin-top: 1em">perl -pi -e
&rsquo;s/Fred/Barney/&rsquo; inFile.txt</p>

<p style="margin-top: 1em">To make a backup of
&quot;inFile.txt&quot;, give &quot;-i&quot; a file extension
to add:</p>

<p style="margin-top: 1em">perl -pi.bak -e
&rsquo;s/Fred/Barney/&rsquo; inFile.txt</p>

<p style="margin-top: 1em">To change only the fifth line,
you can add a test checking $., the input line number, then
only perform the operation when the test passes:</p>

<p style="margin-top: 1em">perl -pi -e
&rsquo;s/Fred/Barney/ if $. == 5&rsquo; inFile.txt</p>

<p style="margin-top: 1em">To add lines before a certain
line, you can add a line (or lines!) before Perl prints
$_:</p>

<p style="margin-top: 1em">perl -pi -e &rsquo;print
&quot;Put before third line0 if $. == 3&rsquo;
inFile.txt</p>

<p style="margin-top: 1em">You can even add a line to the
beginning of a file, since the current line prints at the
end of the loop:</p>

<p style="margin-top: 1em">perl -pi -e &rsquo;print
&quot;Put before first line0 if $. == 1&rsquo;
inFile.txt</p>

<p style="margin-top: 1em">To insert a line after one
already in the file, use the &quot;-n&quot; switch.
It&rsquo;s just like &quot;-p&quot; except that it
doesn&rsquo;t print $_ at the end of the loop, so you have
to do that yourself. <br>
In this case, print $_ first, then print the line that you
want to add.</p>

<p style="margin-top: 1em">perl -ni -e &rsquo;print; print
&quot;Put after fifth line0 if $. == 5&rsquo; inFile.txt</p>

<p style="margin-top: 1em">To delete lines, only print the
ones that you want.</p>

<p style="margin-top: 1em">perl -ni -e &rsquo;print if
/d/&rsquo; inFile.txt</p>

<p style="margin-top: 1em">How do I count the number of
lines in a file? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">Conceptually, the easiest way to
count the lines in a file is to simply read them and count
them:</p>

<p style="margin-top: 1em">my $count = 0; <br>
while( &lt;$fh&gt; ) { $count++; }</p>

<p style="margin-top: 1em">You don&rsquo;t really have to
count them yourself, though, since Perl already does that
with the $. variable, which is the current line number from
the last filehandle read:</p>

<p style="margin-top: 1em">1 while( &lt;$fh&gt; ); <br>
my $count = $.;</p>

<p style="margin-top: 1em">If you want to use $., you can
reduce it to a simple one-liner, like one of these:</p>

<p style="margin-top: 1em">% perl -lne &rsquo;} print $.;
{&rsquo; file</p>

<p style="margin-top: 1em">% perl -lne &rsquo;END { print
$. }&rsquo; file</p>

<p style="margin-top: 1em">Those can be rather inefficient
though. If they aren&rsquo;t fast enough for you, you might
just read chunks of data and count the number of
newlines:</p>

<p style="margin-top: 1em">my $lines = 0; <br>
open my($fh), &rsquo;&lt;:raw&rsquo;, $filename or die
&quot;Can&rsquo;t open $filename: $!&quot;; <br>
while( sysread $fh, $buffer, 4096 ) { <br>
$lines += ( $buffer =~ tr/0/ ); <br>
} <br>
close FILE;</p>

<p style="margin-top: 1em">However, that doesn&rsquo;t work
if the line ending isn&rsquo;t a newline. You might change
that &quot;tr///&quot; to a &quot;s///&quot; so you can
count the number of times the input record separator, $/,
<br>
shows up:</p>

<p style="margin-top: 1em">my $lines = 0; <br>
open my($fh), &rsquo;&lt;:raw&rsquo;, $filename or die
&quot;Can&rsquo;t open $filename: $!&quot;; <br>
while( sysread $fh, $buffer, 4096 ) { <br>
$lines += ( $buffer =~ s|$/||g; ); <br>
} <br>
close FILE;</p>

<p style="margin-top: 1em">If you don&rsquo;t mind shelling
out, the &quot;wc&quot; command is usually the fastest, even
with the extra interprocess overhead. Ensure that you have
an untainted filename though:</p>

<p style="margin-top: 1em">#!perl -T</p>

<p style="margin-top: 1em">$ENV{PATH} = undef;</p>

<p style="margin-top: 1em">my $lines; <br>
if( $filename =~ /^([0-9a-z_.]+)/) { <br>
$lines = &lsquo;/usr/bin/wc -l $1&lsquo; <br>
chomp $lines; <br>
}</p>

<p style="margin-top: 1em">How do I delete the last N lines
from a file? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">The easiest conceptual solution
is to count the lines in the file then start at the
beginning and print the number of lines (minus the last N)
to a new file.</p>

<p style="margin-top: 1em">Most often, the real question is
how you can delete the last N lines without making more than
one pass over the file, or how to do it without a lot of
copying. The easy concept <br>
is the hard reality when you might have millions of lines in
your file.</p>

<p style="margin-top: 1em">One trick is to use
File::ReadBackwards, which starts at the end of the file.
That module provides an object that wraps the real
filehandle to make it easy for you to move around <br>
the file. Once you get to the spot you need, you can get the
actual filehandle and work with it as normal. In this case,
you get the file position at the end of the last line you
<br>
want to keep and truncate the file to that point:</p>

<p style="margin-top: 1em">use File::ReadBackwards;</p>

<p style="margin-top: 1em">my $filename =
&rsquo;test.txt&rsquo;; <br>
my $Lines_to_truncate = 2;</p>

<p style="margin-top: 1em">my $bw =
File::ReadBackwards-&gt;new( $filename ) <br>
or die &quot;Could not read backwards in [$filename]:
$!&quot;;</p>

<p style="margin-top: 1em">my $lines_from_end = 0; <br>
until( $bw-&gt;eof or $lines_from_end == $Lines_to_truncate
) { <br>
print &quot;Got: &quot;, $bw-&gt;readline; <br>
$lines_from_end++; <br>
}</p>

<p style="margin-top: 1em">truncate( $filename,
$bw-&gt;tell );</p>

<p style="margin-top: 1em">The File::ReadBackwards module
also has the advantage of setting the input record separator
to a regular expression.</p>

<p style="margin-top: 1em">You can also use the Tie::File
module which lets you access the lines through a tied array.
You can use normal array operations to modify your file,
including setting the last <br>
index and using &quot;splice&quot;.</p>

<p style="margin-top: 1em">How can I use Perl&rsquo;s
&quot;-i&quot; option from within a program? <br>
&quot;-i&quot; sets the value of Perl&rsquo;s $^I variable,
which in turn affects the behavior of &quot;&lt;&gt;&quot;;
see perlrun for more details. By modifying the appropriate
variables directly, you can get <br>
the same behavior within a larger program. For example:</p>

<p style="margin-top: 1em"># ... <br>
{ <br>
local($^I, @ARGV) = (&rsquo;.orig&rsquo;,
glob(&quot;*.c&quot;)); <br>
while (&lt;&gt;) { <br>
if ($. == 1) { <br>
print &quot;This line should appear at the top of each
file0; <br>
} p ) e a r l i ; # C o r r e c t t y <br>
s/p o s , p r e s e r v i n g c a s e <br>
print; <br>
close ARGV if eof; # Reset $. <br>
} <br>
} <br>
# $^I and @ARGV return to their old values here</p>

<p style="margin-top: 1em">This block modifies all the
&quot;.c&quot; files in the current directory, leaving a
backup of the original data from each file in a new
&quot;.c.orig&quot; file.</p>

<p style="margin-top: 1em">How can I copy a file? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">Use the File::Copy module. It
comes with Perl and can do a true copy across file systems,
and it does its magic in a portable fashion.</p>

<p style="margin-top: 1em">use File::Copy;</p>

<p style="margin-top: 1em">copy( $original, $new_copy ) or
die &quot;Copy failed: $!&quot;;</p>

<p style="margin-top: 1em">If you can&rsquo;t use
File::Copy, you&rsquo;ll have to do the work yourself: open
the original file, open the destination file, then print to
the destination file as you read the original. <br>
You also have to remember to copy the permissions, owner,
and group to the new file.</p>

<p style="margin-top: 1em">How do I make a temporary file
name? <br>
If you don&rsquo;t need to know the name of the file, you
can use &quot;open()&quot; with &quot;undef&quot; in place
of the file name. In Perl 5.8 or later, the
&quot;open()&quot; function creates an anonymous <br>
temporary file:</p>

<p style="margin-top: 1em">open my $tmp,
&rsquo;+&gt;&rsquo;, undef or die $!;</p>

<p style="margin-top: 1em">Otherwise, you can use the
File::Temp module.</p>

<p style="margin-top: 1em">use File::Temp qw/ tempfile
tempdir /;</p>

<p style="margin-top: 1em">my $dir = tempdir( CLEANUP =&gt;
1 ); <br>
($fh, $filename) = tempfile( DIR =&gt; $dir );</p>

<p style="margin-top: 1em"># or if you don&rsquo;t need to
know the filename</p>

<p style="margin-top: 1em">my $fh = tempfile( DIR =&gt;
$dir );</p>

<p style="margin-top: 1em">The File::Temp has been a
standard module since Perl 5.6.1. If you don&rsquo;t have a
modern enough Perl installed, use the
&quot;new_tmpfile&quot; class method from the IO::File
module to get a <br>
filehandle opened for reading and writing. Use it if you
don&rsquo;t need to know the file&rsquo;s name:</p>

<p style="margin-top: 1em">use IO::File; <br>
my $fh = IO::File-&gt;new_tmpfile() <br>
or die &quot;Unable to make new temporary file:
$!&quot;;</p>

<p style="margin-top: 1em">If you&rsquo;re committed to
creating a temporary file by hand, use the process ID and/or
the current time-value. If you need to have many temporary
files in one process, use a <br>
counter:</p>

<p style="margin-top: 1em">BEGIN { <br>
use Fcntl; <br>
my $temp_dir = -d &rsquo;/tmp&rsquo; ? &rsquo;/tmp&rsquo; :
$ENV{TMPDIR} || $ENV{TEMP}; <br>
my $base_name = sprintf &quot;%s/%d-%d-0000&quot;,
$temp_dir, $$, time;</p>

<p style="margin-top: 1em">sub temp_file { <br>
my $fh; <br>
my $count = 0; <br>
until( defined(fileno($fh)) || $count++ &gt; 100 ) { <br>
$base_name =~ s/-(+)$/&quot;-&quot; . (1 + $1)/e; <br>
# O_EXCL is required for security reasons. <br>
sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT; <br>
}</p>

<p style="margin-top: 1em">if( defined fileno($fh) ) { <br>
return ($fh, $base_name); <br>
} <br>
else { <br>
return (); <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">How can I manipulate
fixed-record-length files? <br>
The most efficient way is using pack() and unpack(). This is
faster than using substr() when taking many, many strings.
It is slower for just a few.</p>

<p style="margin-top: 1em">Here is a sample chunk of code
to break up and put back together again some fixed-format
input lines, in this case from the output of a normal,
Berkeley-style ps:</p>

<p style="margin-top: 1em"># sample input line: <br>
# 15158 p5 T 0:00 perl /home/tchrist/scripts/now-what <br>
my $PS_T = &rsquo;A6 A4 A7 A5 A*&rsquo;; <br>
open my $ps, &rsquo;-|&rsquo;, &rsquo;ps&rsquo;; <br>
print scalar &lt;$ps&gt;; <br>
my @fields = qw( pid tt stat time command ); <br>
while (&lt;$ps&gt;) { <br>
my %process; <br>
@process{@fields} = unpack($PS_T, $_); <br>
for my $field ( @fields ) { <br>
print &quot;$field: &lt;$process{$field}&gt;0; <br>
} <br>
print &rsquo;line=&rsquo;, pack($PS_T, @process{@fields} ),
&quot;0; <br>
}</p>

<p style="margin-top: 1em">We&rsquo;ve used a hash slice in
order to easily handle the fields of each row. Storing the
keys in an array makes it easy to operate on them as a group
or loop over them with &quot;for&quot;. <br>
It also avoids polluting the program with global variables
and using symbolic references.</p>

<p style="margin-top: 1em">How can I make a filehandle
local to a subroutine? How do I pass filehandles between
subroutines? How do I make an array of filehandles? <br>
As of perl5.6, open() autovivifies file and directory
handles as references if you pass it an uninitialized scalar
variable. You can then pass these references just like any
<br>
other scalar, and use them in the place of named
handles.</p>

<p style="margin-top: 1em">open my $fh, $file_name;</p>

<p style="margin-top: 1em">open local $fh, $file_name;</p>

<p style="margin-top: 1em">print $fh &quot;Hello
World!0;</p>

<p style="margin-top: 1em">process_file( $fh );</p>

<p style="margin-top: 1em">If you like, you can store these
filehandles in an array or a hash. If you access them
directly, they aren&rsquo;t simple scalars and you need to
give &quot;print&quot; a little help by placing <br>
the filehandle reference in braces. Perl can only figure it
out on its own when the filehandle reference is a simple
scalar.</p>

<p style="margin-top: 1em">my @fhs = ( $fh1, $fh2, $fh3
);</p>

<p style="margin-top: 1em">for( $i = 0; $i &lt;= $#fhs;
$i++ ) { <br>
print {$fhs[$i]} &quot;just another Perl answer, 0; <br>
}</p>

<p style="margin-top: 1em">Before perl5.6, you had to deal
with various typeglob idioms which you may see in older
code.</p>

<p style="margin-top: 1em">open FILE, &quot;&gt;
$filename&quot;; <br>
process_typeglob( *FILE ); <br>
process_reference( ILE );</p>

<p style="margin-top: 1em">sub process_typeglob { local *FH
= shift; print FH &quot;Typeglob!&quot; } <br>
sub process_reference { local $fh = shift; print $fh
&quot;Reference!&quot; }</p>

<p style="margin-top: 1em">If you want to create many
anonymous handles, you should check out the Symbol or
IO::Handle modules.</p>

<p style="margin-top: 1em">How can I use a filehandle
indirectly? <br>
An indirect filehandle is the use of something other than a
symbol in a place that a filehandle is expected. Here are
ways to get indirect filehandles:</p>

<p style="margin-top: 1em">$fh = SOME_FH; # bareword is
strict-subs hostile <br>
$fh = &quot;SOME_FH&quot;; # strict-refs hostile; same
package only <br>
$fh = *SOME_FH; # typeglob <br>
$fh = OME_FH; # ref to typeglob (bless-able) <br>
$fh = *SOME_FH{IO}; # blessed IO::Handle from *SOME_FH
typeglob</p>

<p style="margin-top: 1em">Or, you can use the
&quot;new&quot; method from one of the IO::* modules to
create an anonymous filehandle and store that in a scalar
variable.</p>

<p style="margin-top: 1em">use IO::Handle; # 5.004 or
higher <br>
my $fh = IO::Handle-&gt;new();</p>

<p style="margin-top: 1em">Then use any of those as you
would a normal filehandle. Anywhere that Perl is expecting a
filehandle, an indirect filehandle may be used instead. An
indirect filehandle is just a <br>
scalar variable that contains a filehandle. Functions like
&quot;print&quot;, &quot;open&quot;, &quot;seek&quot;, or
the &quot;&lt;FH&gt;&quot; diamond operator will accept
either a named filehandle or a scalar variable <br>
containing one:</p>

<p style="margin-top: 1em">($ifh, $ofh, $efh) = (*STDIN,
*STDOUT, *STDERR); <br>
print $ofh &quot;Type it: &quot;; <br>
my $got = &lt;$ifh&gt; <br>
print $efh &quot;What was that: $got&quot;;</p>

<p style="margin-top: 1em">If you&rsquo;re passing a
filehandle to a function, you can write the function in two
ways:</p>

<p style="margin-top: 1em">sub accept_fh { <br>
my $fh = shift; <br>
print $fh &quot;Sending to indirect filehandle0; <br>
}</p>

<p style="margin-top: 1em">Or it can localize a typeglob
and use the filehandle directly:</p>

<p style="margin-top: 1em">sub accept_fh { <br>
local *FH = shift; <br>
print FH &quot;Sending to localized filehandle0; <br>
}</p>

<p style="margin-top: 1em">Both styles work with either
objects or typeglobs of real filehandles. (They might also
work with strings under some circumstances, but this is
risky.)</p>

<p style="margin-top: 1em">accept_fh(*STDOUT); <br>
accept_fh($handle);</p>

<p style="margin-top: 1em">In the examples above, we
assigned the filehandle to a scalar variable before using
it. That is because only simple scalar variables, not
expressions or subscripts of hashes or <br>
arrays, can be used with built-ins like &quot;print&quot;,
&quot;printf&quot;, or the diamond operator. Using something
other than a simple scalar variable as a filehandle is
illegal and won&rsquo;t even <br>
compile:</p>

<p style="margin-top: 1em">my @fd = (*STDIN, *STDOUT,
*STDERR); <br>
print $fd[1] &quot;Type it: &quot;; # WRONG <br>
my $got = &lt;$fd[0]&gt; # WRONG <br>
print $fd[2] &quot;What was that: $got&quot;; # WRONG</p>

<p style="margin-top: 1em">With &quot;print&quot; and
&quot;printf&quot;, you get around this by using a block and
an expression where you would place the filehandle:</p>

<p style="margin-top: 1em">print { $fd[1] } &quot;funny
stuff0; <br>
printf { $fd[1] } &quot;Pity the poor %x.0, 3_735_928_559;
<br>
# Pity the poor deadbeef.</p>

<p style="margin-top: 1em">That block is a proper block
like any other, so you can put more complicated code there.
This sends the message out to one of two places:</p>

<p style="margin-top: 1em">my $ok = -x
&quot;/bin/cat&quot;; <br>
print { $ok ? $fd[1] : $fd[2] } &quot;cat stat $ok0; <br>
print { $fd[ 1+ ($ok || 0) ] } &quot;cat stat $ok0;</p>

<p style="margin-top: 1em">This approach of treating
&quot;print&quot; and &quot;printf&quot; like object methods
calls doesn&rsquo;t work for the diamond operator.
That&rsquo;s because it&rsquo;s a real operator, not just a
function with a <br>
comma-less argument. Assuming you&rsquo;ve been storing
typeglobs in your structure as we did above, you can use the
built-in function named &quot;readline&quot; to read a
record just as &quot;&lt;&gt;&quot; <br>
does. Given the initialization shown above for @fd, this
would work, but only because readline() requires a typeglob.
It doesn&rsquo;t work with objects or strings, which might
be a <br>
bug we haven&rsquo;t fixed yet.</p>

<p style="margin-top: 1em">$got = readline($fd[0]);</p>

<p style="margin-top: 1em">Let it be noted that the
flakiness of indirect filehandles is not related to whether
they&rsquo;re strings, typeglobs, objects, or anything else.
It&rsquo;s the syntax of the fundamental <br>
operators. Playing the object game doesn&rsquo;t help you at
all here.</p>

<p style="margin-top: 1em">How can I set up a footer format
to be used with write()? <br>
There&rsquo;s no builtin way to do this, but perlform has a
couple of techniques to make it possible for the intrepid
hacker.</p>

<p style="margin-top: 1em">How can I write() into a string?
<br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">If you want to &quot;write&quot;
into a string, you just have to &lt;open&gt; a filehandle to
a string, which Perl has been able to do since Perl 5.6:</p>

<p style="margin-top: 1em">open FH, &rsquo;&gt;&rsquo;,
$string; <br>
write( FH );</p>

<p style="margin-top: 1em">Since you want to be a good
programmer, you probably want to use a lexical filehandle,
even though formats are designed to work with bareword
filehandles since the default format <br>
names take the filehandle name. However, you can control
this with some Perl special per-filehandle variables: $^,
which names the top-of-page format, and $~ which shows the
line <br>
format. You have to change the default filehandle to set
these variables:</p>

<p style="margin-top: 1em">open my($fh),
&rsquo;&gt;&rsquo;, $string;</p>

<p style="margin-top: 1em">{ # set per-filehandle variables
<br>
my $old_fh = select( $fh ); <br>
$~ = &rsquo;ANIMAL&rsquo;; <br>
$^ = &rsquo;ANIMAL_TOP&rsquo;; <br>
select( $old_fh ); <br>
}</p>

<p style="margin-top: 1em">format ANIMAL_TOP = <br>
ID Type Name <br>
.</p>

<p style="margin-top: 1em">format ANIMAL = <br>
@## @&lt;&lt;&lt;
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
<br>
$id, $type, $name <br>
.</p>

<p style="margin-top: 1em">Although write can work with
lexical or package variables, whatever variables you use
have to scope in the format. That most likely means
you&rsquo;ll want to localize some package <br>
variables:</p>

<p style="margin-top: 1em">{ <br>
local( $id, $type, $name ) = qw( 12 cat Buster ); <br>
write( $fh ); <br>
}</p>

<p style="margin-top: 1em">print $string;</p>

<p style="margin-top: 1em">There are also some tricks that
you can play with &quot;formline&quot; and the accumulator
variable $^A, but you lose a lot of the value of formats
since &quot;formline&quot; won&rsquo;t handle paging and
<br>
so on. You end up reimplementing formats when you use
them.</p>

<p style="margin-top: 1em">How can I open a filehandle to a
string? <br>
(contributed by Peter J. Holzer, hjp-usenet2@hjp.at)</p>

<p style="margin-top: 1em">Since Perl 5.8.0 a file handle
referring to a string can be created by calling open with a
reference to that string instead of the filename. This file
handle can then be used to <br>
read from or write to the string:</p>

<p style="margin-top: 1em">open(my $fh, &rsquo;&gt;&rsquo;,
tring) or die &quot;Could not open string for writing&quot;;
<br>
print $fh &quot;foo0; <br>
print $fh &quot;bar0; # $string now contains
&quot;foo0ar0</p>

<p style="margin-top: 1em">open(my $fh, &rsquo;&lt;&rsquo;,
tring) or die &quot;Could not open string for reading&quot;;
<br>
my $x = &lt;$fh&gt;; # $x now contains &quot;foo0</p>

<p style="margin-top: 1em">With older versions of Perl, the
IO::String module provides similar functionality.</p>

<p style="margin-top: 1em">How can I output my numbers with
commas added? <br>
(contributed by brian d foy and Benjamin Goldberg)</p>

<p style="margin-top: 1em">You can use Number::Format to
separate places in a number. It handles locale information
for those of you who want to insert full stops instead (or
anything else that they want <br>
to use, really).</p>

<p style="margin-top: 1em">This subroutine will add commas
to your number:</p>

<p style="margin-top: 1em">sub commify { <br>
local $_ = shift; <br>
1 while s/^([-+]?+)({3})/$1,$2/; <br>
return $_; <br>
}</p>

<p style="margin-top: 1em">This regex from Benjamin
Goldberg will add commas to numbers:</p>


<p style="margin-top: 1em">s/(^[-+]?+?(?=(?&gt;(?:{3})+)(?!))|G{3}(?=))/$1,/g;</p>

<p style="margin-top: 1em">It is easier to see with
comments:</p>

<p style="margin-top: 1em">s/( <br>
^[-+]? # beginning of number. <br>
+? # first digits before first comma <br>
(?= # followed by, (but not included in the match) : <br>
(?&gt;(?:{3})+) # some positive multiple of three digits.
<br>
(?!) # an *exact* multiple, not x * 3 + 1 or whatever. <br>
) <br>
| # or: <br>
G{3} # after the last group, get three digits <br>
(?=) # but they have to have more digits after them. <br>
)/$1,/xg;</p>

<p style="margin-top: 1em">How can I translate tildes (~)
in a filename? <br>
Use the &lt;&gt; (&quot;glob()&quot;) operator, documented
in perlfunc. Versions of Perl older than 5.6 require that
you have a shell installed that groks tildes. Later versions
of Perl have <br>
this feature built in. The File::KGlob module (available
from CPAN) gives more portable glob functionality.</p>

<p style="margin-top: 1em">Within Perl, you may use this
directly:</p>

<p style="margin-top: 1em">$filename =~ s{ <br>
^ ~ # find a leading tilde <br>
( # save this in $1 <br>
[^/] # a non-slash character <br>
* # repeated 0 or more times (0 means me) <br>
) <br>
}{ <br>
$1 <br>
? (getpwnam($1))[7] <br>
: ( $ENV{HOME} || $ENV{LOGDIR} ) <br>
}ex;</p>

<p style="margin-top: 1em">How come when I open a file
read-write it wipes it out? <br>
Because you&rsquo;re using something like this, which
truncates the file then gives you read-write access:</p>

<p style="margin-top: 1em">open my $fh,
&rsquo;+&gt;&rsquo;, &rsquo;/path/name&rsquo;; # WRONG
(almost always)</p>

<p style="margin-top: 1em">Whoops. You should instead use
this, which will fail if the file doesn&rsquo;t exist:</p>

<p style="margin-top: 1em">open my $fh,
&rsquo;+&lt;&rsquo;, &rsquo;/path/name&rsquo;; # open for
update</p>

<p style="margin-top: 1em">Using &quot;&gt;&quot; always
clobbers or creates. Using &quot;&lt;&quot; never does
either. The &quot;+&quot; doesn&rsquo;t change this.</p>

<p style="margin-top: 1em">Here are examples of many kinds
of file opens. Those using &quot;sysopen&quot; all assume
that you&rsquo;ve pulled in the constants from Fcntl:</p>

<p style="margin-top: 1em">use Fcntl;</p>

<p style="margin-top: 1em">To open file for reading:</p>

<p style="margin-top: 1em">open my $fh, &rsquo;&lt;&rsquo;,
$path or die $!; <br>
sysopen my $fh, $path, O_RDONLY or die $!;</p>

<p style="margin-top: 1em">To open file for writing, create
new file if needed or else truncate old file:</p>

<p style="margin-top: 1em">open my $fh, &rsquo;&gt;&rsquo;,
$path or die $!; <br>
sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT or die $!;
<br>
sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or die
$!;</p>

<p style="margin-top: 1em">To open file for writing, create
new file, file must not exist:</p>

<p style="margin-top: 1em">sysopen my $fh, $path,
O_WRONLY|O_EXCL|O_CREAT or die $!; <br>
sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666 or die
$!;</p>

<p style="margin-top: 1em">To open file for appending,
create if necessary:</p>

<p style="margin-top: 1em">open my $fh,
&rsquo;&gt;&gt;&rsquo; $path or die $!; <br>
sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT or die $!;
<br>
sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or
die $!;</p>

<p style="margin-top: 1em">To open file for appending, file
must exist:</p>

<p style="margin-top: 1em">sysopen my $fh, $path,
O_WRONLY|O_APPEND or die $!;</p>

<p style="margin-top: 1em">To open file for update, file
must exist:</p>

<p style="margin-top: 1em">open my $fh,
&rsquo;+&lt;&rsquo;, $path or die $!; <br>
sysopen my $fh, $path, O_RDWR or die $!;</p>

<p style="margin-top: 1em">To open file for update, create
file if necessary:</p>

<p style="margin-top: 1em">sysopen my $fh, $path,
O_RDWR|O_CREAT or die $!; <br>
sysopen my $fh, $path, O_RDWR|O_CREAT, 0666 or die $!;</p>

<p style="margin-top: 1em">To open file for update, file
must not exist:</p>

<p style="margin-top: 1em">sysopen my $fh, $path,
O_RDWR|O_EXCL|O_CREAT or die $!; <br>
sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666 or die
$!;</p>

<p style="margin-top: 1em">To open a file without blocking,
creating if necessary:</p>

<p style="margin-top: 1em">sysopen my $fh,
&rsquo;/foo/somefile&rsquo;, O_WRONLY|O_NDELAY|O_CREAT <br>
or die &quot;can&rsquo;t open /foo/somefile: $!&quot;:</p>

<p style="margin-top: 1em">Be warned that neither creation
nor deletion of files is guaranteed to be an atomic
operation over NFS. That is, two processes might both
successfully create or unlink the same <br>
file! Therefore O_EXCL isn&rsquo;t as exclusive as you might
wish.</p>

<p style="margin-top: 1em">See also perlopentut.</p>

<p style="margin-top: 1em">Why do I sometimes get an
&quot;Argument list too long&quot; when I use &lt;*&gt;?
<br>
The &quot;&lt;&gt;&quot; operator performs a globbing
operation (see above). In Perl versions earlier than v5.6.0,
the internal glob() operator forks csh(1) to do the actual
glob expansion, but <br>
csh can&rsquo;t handle more than 127 items and so gives the
error message &quot;Argument list too long&quot;. People who
installed tcsh as csh won&rsquo;t have this problem, but
their users may be <br>
surprised by it.</p>

<p style="margin-top: 1em">To get around this, either
upgrade to Perl v5.6.0 or later, do the glob yourself with
readdir() and patterns, or use a module like File::Glob, one
that doesn&rsquo;t use the shell to <br>
do globbing.</p>

<p style="margin-top: 1em">How can I open a file with a
leading &quot;&gt;&quot; or trailing blanks? <br>
(contributed by Brian McCauley)</p>

<p style="margin-top: 1em">The special two-argument form of
Perl&rsquo;s open() function ignores trailing blanks in
filenames and infers the mode from certain leading
characters (or a trailing &quot;|&quot;). In older <br>
versions of Perl this was the only version of open() and so
it is prevalent in old code and books.</p>

<p style="margin-top: 1em">Unless you have a particular
reason to use the two-argument form you should use the
three-argument form of open() which does not treat any
characters in the filename as special.</p>

<p style="margin-top: 1em">open my $fh, &quot;&lt;&quot;,
&quot; file &quot;; # filename is &quot; file &quot; <br>
open my $fh, &quot;&gt;&quot;, &quot;&gt;file&quot;; #
filename is &quot;&gt;file&quot;</p>

<p style="margin-top: 1em">How can I reliably rename a
file? <br>
If your operating system supports a proper mv(1) utility or
its functional equivalent, this works:</p>

<p style="margin-top: 1em">rename($old, $new) or
system(&quot;mv&quot;, $old, $new);</p>

<p style="margin-top: 1em">It may be more portable to use
the File::Copy module instead. You just copy to the new file
to the new name (checking return values), then delete the
old one. This isn&rsquo;t really <br>
the same semantically as a &quot;rename()&quot;, which
preserves meta-information like permissions, timestamps,
inode info, etc.</p>

<p style="margin-top: 1em">How can I lock a file? <br>
Perl&rsquo;s builtin flock() function (see perlfunc for
details) will call flock(2) if that exists, fcntl(2) if it
doesn&rsquo;t (on perl version 5.004 and later), and
lockf(3) if neither of <br>
the two previous system calls exists. On some systems, it
may even use a different form of native locking. Here are
some gotchas with Perl&rsquo;s flock():</p>

<p style="margin-top: 1em">1. Produces a fatal error if
none of the three system calls (or their close equivalent)
exists.</p>

<p style="margin-top: 1em">2. lockf(3) does not provide
shared locking, and requires that the filehandle be open for
writing (or appending, or read/writing).</p>

<p style="margin-top: 1em">3. Some versions of flock()
can&rsquo;t lock files over a network (e.g. on NFS file
systems), so you&rsquo;d need to force the use of fcntl(2)
when you build Perl. But even this is dubious <br>
at best. See the flock entry of perlfunc and the INSTALL
file in the source distribution for information on building
Perl to do this.</p>

<p style="margin-top: 1em">Two potentially non-obvious but
traditional flock semantics are that it waits indefinitely
until the lock is granted, and that its locks are merely
advisory. Such <br>
discretionary locks are more flexible, but offer fewer
guarantees. This means that files locked with flock() may be
modified by programs that do not also use flock(). Cars <br>
that stop for red lights get on well with each other, but
not with cars that don&rsquo;t stop for red lights. See the
perlport manpage, your port&rsquo;s specific documentation,
or your <br>
system-specific local manpages for details. It&rsquo;s best
to assume traditional behavior if you&rsquo;re writing
portable programs. (If you&rsquo;re not, you should as
always feel perfectly <br>
free to write for your own system&rsquo;s idiosyncrasies
(sometimes called &quot;features&quot;). Slavish adherence
to portability concerns shouldn&rsquo;t get in the way of
your getting your job <br>
done.)</p>

<p style="margin-top: 1em">For more information on file
locking, see also &quot;File Locking&quot; in perlopentut if
you have it (new for 5.6).</p>

<p style="margin-top: 1em">Why can&rsquo;t I just open(FH,
&quot;&gt;file.lock&quot;)? <br>
A common bit of code NOT TO USE is this:</p>

<p style="margin-top: 1em">sleep(3) while -e
&rsquo;file.lock&rsquo;; # PLEASE DO NOT USE <br>
open my $lock, &rsquo;&gt;&rsquo;, &rsquo;file.lock&rsquo;;
# THIS BROKEN CODE</p>

<p style="margin-top: 1em">This is a classic race
condition: you take two steps to do something which must be
done in one. That&rsquo;s why computer hardware provides an
atomic test-and-set instruction. In <br>
theory, this &quot;ought&quot; to work:</p>

<p style="margin-top: 1em">sysopen my $fh,
&quot;file.lock&quot;, O_WRONLY|O_EXCL|O_CREAT <br>
or die &quot;can&rsquo;t open file.lock: $!&quot;;</p>

<p style="margin-top: 1em">except that lamentably, file
creation (and deletion) is not atomic over NFS, so this
won&rsquo;t work (at least, not every time) over the net.
Various schemes involving link() have <br>
been suggested, but these tend to involve busy-wait, which
is also less than desirable.</p>

<p style="margin-top: 1em">I still don&rsquo;t get locking.
I just want to increment the number in the file. How can I
do this? <br>
Didn&rsquo;t anyone ever tell you web-page hit counters were
useless? They don&rsquo;t count number of hits,
they&rsquo;re a waste of time, and they serve only to stroke
the writer&rsquo;s vanity. It&rsquo;s <br>
better to pick a random number; they&rsquo;re more
realistic.</p>

<p style="margin-top: 1em">Anyway, this is what you can do
if you can&rsquo;t help yourself.</p>

<p style="margin-top: 1em">use Fcntl qw(:DEFAULT :flock);
<br>
sysopen my $fh, &quot;numfile&quot;, O_RDWR|O_CREAT or die
&quot;can&rsquo;t open numfile: $!&quot;; <br>
flock $fh, LOCK_EX or die &quot;can&rsquo;t flock numfile:
$!&quot;; <br>
my $num = &lt;$fh&gt; || 0; <br>
seek $fh, 0, 0 or die &quot;can&rsquo;t rewind numfile:
$!&quot;; <br>
truncate $fh, 0 or die &quot;can&rsquo;t truncate numfile:
$!&quot;; <br>
(print $fh $num+1, &quot;0) or die &quot;can&rsquo;t write
numfile: $!&quot;; <br>
close $fh or die &quot;can&rsquo;t close numfile:
$!&quot;;</p>

<p style="margin-top: 1em">Here&rsquo;s a much better
web-page hit counter:</p>

<p style="margin-top: 1em">$hits = int( (time() -
850_000_000) / rand(1_000) );</p>

<p style="margin-top: 1em">If the count doesn&rsquo;t
impress your friends, then the code might. :-)</p>

<p style="margin-top: 1em">All I want to do is append a
small amount of text to the end of a file. Do I still have
to use locking? <br>
If you are on a system that correctly implements
&quot;flock&quot; and you use the example appending code
from &quot;perldoc -f flock&quot; everything will be OK even
if the OS you are on doesn&rsquo;t <br>
implement append mode correctly (if such a system exists).
So if you are happy to restrict yourself to OSs that
implement &quot;flock&quot; (and that&rsquo;s not really
much of a restriction) <br>
then that is what you should do.</p>

<p style="margin-top: 1em">If you know you are only going
to use a system that does correctly implement appending
(i.e. not Win32) then you can omit the &quot;seek&quot; from
the code in the previous answer.</p>

<p style="margin-top: 1em">If you know you are only writing
code to run on an OS and filesystem that does implement
append mode correctly (a local filesystem on a modern Unix
for example), and you keep the <br>
file in block-buffered mode and you write less than one
buffer-full of output between each manual flushing of the
buffer then each bufferload is almost guaranteed to be
written <br>
to the end of the file in one chunk without getting
intermingled with anyone else&rsquo;s output. You can also
use the &quot;syswrite&quot; function which is simply a
wrapper around your <br>
system&rsquo;s write(2) system call.</p>

<p style="margin-top: 1em">There is still a small
theoretical chance that a signal will interrupt the
system-level &quot;write()&quot; operation before
completion. There is also a possibility that some STDIO <br>
implementations may call multiple system level
&quot;write()&quot;s even if the buffer was empty to start.
There may be some systems where this probability is reduced
to zero, and this is <br>
not a concern when using &quot;:perlio&quot; instead of your
system&rsquo;s STDIO.</p>

<p style="margin-top: 1em">How do I randomly update a
binary file? <br>
If you&rsquo;re just trying to patch a binary, in many cases
something as simple as this works:</p>

<p style="margin-top: 1em">perl -i -pe &rsquo;s{window
manager}{window mangler}g&rsquo; /usr/bin/emacs</p>

<p style="margin-top: 1em">However, if you have fixed sized
records, then you might do something more like this:</p>

<p style="margin-top: 1em">my $RECSIZE = 220; # size of
record, in bytes <br>
my $recno = 37; # which record to update <br>
open my $fh, &rsquo;+&lt;&rsquo;, &rsquo;somewhere&rsquo; or
die &quot;can&rsquo;t update somewhere: $!&quot;; <br>
seek $fh, $recno * $RECSIZE, 0; <br>
read $fh, $record, $RECSIZE == $RECSIZE or die
&quot;can&rsquo;t read record $recno: $!&quot;; <br>
# munge the record <br>
seek $fh, -$RECSIZE, 1; <br>
print $fh $record; <br>
close $fh;</p>

<p style="margin-top: 1em">Locking and error checking are
left as an exercise for the reader. Don&rsquo;t forget them
or you&rsquo;ll be quite sorry.</p>

<p style="margin-top: 1em">How do I get a file&rsquo;s
timestamp in perl? <br>
If you want to retrieve the time at which the file was last
read, written, or had its meta-data (owner, etc) changed,
you use the -A, -M, or -C file test operations as documented
<br>
in perlfunc. These retrieve the age of the file (measured
against the start-time of your program) in days as a
floating point number. Some platforms may not have all of
these <br>
times. See perlport for details. To retrieve the
&quot;raw&quot; time in seconds since the epoch, you would
call the stat function, then use &quot;localtime()&quot;,
&quot;gmtime()&quot;, or <br>
&quot;POSIX::strftime()&quot; to convert this into
human-readable form.</p>

<p style="margin-top: 1em">Here&rsquo;s an example:</p>

<p style="margin-top: 1em">my $write_secs =
(stat($file))[9]; <br>
printf &quot;file %s updated at %s0, $file, <br>
scalar localtime($write_secs);</p>

<p style="margin-top: 1em">If you prefer something more
legible, use the File::stat module (part of the standard
distribution in version 5.004 and later):</p>

<p style="margin-top: 1em"># error checking left as an
exercise for reader. <br>
use File::stat; <br>
use Time::localtime; <br>
my $date_string = ctime(stat($file)-&gt;mtime); <br>
print &quot;file $file updated at $date_string0;</p>

<p style="margin-top: 1em">The POSIX::strftime() approach
has the benefit of being, in theory, independent of the
current locale. See perllocale for details.</p>

<p style="margin-top: 1em">How do I set a file&rsquo;s
timestamp in perl? <br>
You use the utime() function documented in &quot;utime&quot;
in perlfunc. By way of example, here&rsquo;s a little
program that copies the read and write times from its first
argument to all <br>
the rest of them.</p>

<p style="margin-top: 1em">if (@ARGV &lt; 2) { <br>
die &quot;usage: cptimes timestamp_file other_files ...0;
<br>
} <br>
my $timestamp = shift; <br>
my($atime, $mtime) = (stat($timestamp))[8,9]; <br>
utime $atime, $mtime, @ARGV;</p>

<p style="margin-top: 1em">Error checking is, as usual,
left as an exercise for the reader.</p>

<p style="margin-top: 1em">The perldoc for utime also has
an example that has the same effect as touch(1) on files
that already exist.</p>

<p style="margin-top: 1em">Certain file systems have a
limited ability to store the times on a file at the expected
level of precision. For example, the FAT and HPFS filesystem
are unable to create dates <br>
on files with a finer granularity than two seconds. This is
a limitation of the filesystems, not of utime().</p>

<p style="margin-top: 1em">How do I print to more than one
file at once? <br>
To connect one filehandle to several output filehandles, you
can use the IO::Tee or Tie::FileHandle::Multiplex
modules.</p>

<p style="margin-top: 1em">If you only have to do this
once, you can print individually to each filehandle.</p>

<p style="margin-top: 1em">for my $fh ($fh1, $fh2, $fh3) {
print $fh &quot;whatever0 }</p>

<p style="margin-top: 1em">How can I read in an entire file
all at once? <br>
The customary Perl approach for processing all the lines in
a file is to do so one line at a time:</p>

<p style="margin-top: 1em">open my $input,
&rsquo;&lt;&rsquo;, $file or die &quot;can&rsquo;t open
$file: $!&quot;; <br>
while (&lt;$input&gt;) { <br>
chomp; <br>
# do something with $_ <br>
} <br>
close $input or die &quot;can&rsquo;t close $file:
$!&quot;;</p>

<p style="margin-top: 1em">This is tremendously more
efficient than reading the entire file into memory as an
array of lines and then processing it one element at a time,
which is often--if not almost <br>
always--the wrong approach. Whenever you see someone do
this:</p>

<p style="margin-top: 1em">my @lines = &lt;INPUT&gt;;</p>

<p style="margin-top: 1em">You should think long and hard
about why you need everything loaded at once. It&rsquo;s
just not a scalable solution.</p>

<p style="margin-top: 1em">If you &quot;mmap&quot; the file
with the File::Map module from CPAN, you can virtually load
the entire file into a string without actually storing it in
memory:</p>

<p style="margin-top: 1em">use File::Map qw(map_file);</p>

<p style="margin-top: 1em">map_file my $string,
$filename;</p>

<p style="margin-top: 1em">Once mapped, you can treat
$string as you would any other string. Since you don&rsquo;t
necessarily have to load the data, mmap-ing can be very fast
and may not increase your memory <br>
footprint.</p>

<p style="margin-top: 1em">You might also find it more fun
to use the standard Tie::File module, or the DB_File
module&rsquo;s $DB_RECNO bindings, which allow you to tie an
array to a file so that accessing an <br>
element of the array actually accesses the corresponding
line in the file.</p>

<p style="margin-top: 1em">If you want to load the entire
file, you can use the File::Slurp module to do it in one one
simple and efficient step:</p>

<p style="margin-top: 1em">use File::Slurp;</p>

<p style="margin-top: 1em">my $all_of_it =
read_file($filename); # entire file in scalar <br>
my @all_lines = read_file($filename); # one line per
element</p>

<p style="margin-top: 1em">Or you can read the entire file
contents into a scalar like this:</p>

<p style="margin-top: 1em">my $var; <br>
{ <br>
local $/; <br>
open my $fh, &rsquo;&lt;&rsquo;, $file or die
&quot;can&rsquo;t open $file: $!&quot;; <br>
$var = &lt;$fh&gt;; <br>
}</p>

<p style="margin-top: 1em">That temporarily undefs your
record separator, and will automatically close the file at
block exit. If the file is already open, just use this:</p>

<p style="margin-top: 1em">my $var = do { local $/;
&lt;$fh&gt; };</p>

<p style="margin-top: 1em">You can also use a localized
@ARGV to eliminate the &quot;open&quot;:</p>

<p style="margin-top: 1em">my $var = do { local( @ARGV, $/
) = $file; &lt;&gt; };</p>

<p style="margin-top: 1em">For ordinary files you can also
use the &quot;read&quot; function.</p>

<p style="margin-top: 1em">read( $fh, $var, -s $fh );</p>

<p style="margin-top: 1em">That third argument tests the
byte size of the data on the $fh filehandle and reads that
many bytes into the buffer $var.</p>

<p style="margin-top: 1em">How can I read in a file by
paragraphs? <br>
Use the $/ variable (see perlvar for details). You can
either set it to &quot;&quot; to eliminate empty paragraphs
(&quot;abc0ef&quot;, for instance, gets treated as two
paragraphs and not <br>
three), or &quot;0 to accept empty paragraphs.</p>

<p style="margin-top: 1em">Note that a blank line must have
no blanks in it. Thus &quot;fred0tuff0 is one paragraph, but
&quot;fred0tuff0 is two.</p>

<p style="margin-top: 1em">How can I read a single
character from a file? From the keyboard? <br>
You can use the builtin &quot;getc()&quot; function for most
filehandles, but it won&rsquo;t (easily) work on a terminal
device. For STDIN, either use the Term::ReadKey module from
CPAN or use <br>
the sample code in &quot;getc&quot; in perlfunc.</p>

<p style="margin-top: 1em">If your system supports the
portable operating system programming interface (POSIX), you
can use the following code, which you&rsquo;ll note turns
off echo processing as well.</p>

<p style="margin-top: 1em">#!/usr/bin/perl -w <br>
use strict; <br>
$| = 1; <br>
for (1..4) { <br>
print &quot;gimme: &quot;; <br>
my $got = getone(); <br>
print &quot;--&gt; $got0; <br>
} <br>
exit;</p>

<p style="margin-top: 1em">BEGIN { <br>
use POSIX qw(:termios_h);</p>

<p style="margin-top: 1em">my ($term, $oterm, $echo,
$noecho, $fd_stdin);</p>

<p style="margin-top: 1em">my $fd_stdin =
fileno(STDIN);</p>

<p style="margin-top: 1em">$term =
POSIX::Termios-&gt;new(); <br>
$term-&gt;getattr($fd_stdin); <br>
$oterm = $term-&gt;getlflag();</p>

<p style="margin-top: 1em">$echo = ECHO | ECHOK | ICANON;
<br>
$noecho = $oterm &amp; ~$echo;</p>

<p style="margin-top: 1em">sub cbreak { <br>
$term-&gt;setlflag($noecho); <br>
$term-&gt;setcc(VTIME, 1); <br>
$term-&gt;setattr($fd_stdin, TCSANOW); <br>
}</p>

<p style="margin-top: 1em">sub cooked { <br>
$term-&gt;setlflag($oterm); <br>
$term-&gt;setcc(VTIME, 0); <br>
$term-&gt;setattr($fd_stdin, TCSANOW); <br>
}</p>

<p style="margin-top: 1em">sub getone { <br>
my $key = &rsquo;&rsquo;; <br>
cbreak(); <br>
sysread(STDIN, $key, 1); <br>
cooked(); <br>
return $key; <br>
} <br>
}</p>

<p style="margin-top: 1em">END { cooked() }</p>

<p style="margin-top: 1em">The Term::ReadKey module from
CPAN may be easier to use. Recent versions include also
support for non-portable systems as well.</p>

<p style="margin-top: 1em">use Term::ReadKey; <br>
open my $tty, &rsquo;&lt;&rsquo;, &rsquo;/dev/tty&rsquo;;
<br>
print &quot;Gimme a char: &quot;; <br>
ReadMode &quot;raw&quot;; <br>
my $key = ReadKey 0, $tty; <br>
ReadMode &quot;normal&quot;; <br>
printf &quot;0ou said %s, char number %03d0, <br>
$key, ord $key;</p>

<p style="margin-top: 1em">How can I tell whether
there&rsquo;s a character waiting on a filehandle? <br>
The very first thing you should do is look into getting the
Term::ReadKey extension from CPAN. As we mentioned earlier,
it now even has limited support for non-portable (read: <br>
not open systems, closed, proprietary, not POSIX, not Unix,
etc.) systems.</p>

<p style="margin-top: 1em">You should also check out the
Frequently Asked Questions list in comp.unix.* for things
like this: the answer is essentially the same. It&rsquo;s
very system-dependent. Here&rsquo;s one <br>
solution that works on BSD systems:</p>

<p style="margin-top: 1em">sub key_ready { <br>
my($rin, $nfd); <br>
vec($rin, fileno(STDIN), 1) = 1; <br>
return $nfd = select($rin,undef,undef,0); <br>
}</p>

<p style="margin-top: 1em">If you want to find out how many
characters are waiting, there&rsquo;s also the FIONREAD
ioctl call to be looked at. The h2ph tool that comes with
Perl tries to convert C include files <br>
to Perl code, which can be &quot;require&quot;d. FIONREAD
ends up defined as a function in the sys/ioctl.ph file:</p>

<p style="margin-top: 1em">require
&rsquo;sys/ioctl.ph&rsquo;;</p>

<p style="margin-top: 1em">$size = pack(&quot;L&quot;, 0);
<br>
ioctl(FH, FIONREAD(), $size) or die &quot;Couldn&rsquo;t
call ioctl: $!0; <br>
$size = unpack(&quot;L&quot;, $size);</p>

<p style="margin-top: 1em">If h2ph wasn&rsquo;t installed
or doesn&rsquo;t work for you, you can grep the include
files by hand:</p>

<p style="margin-top: 1em">% grep FIONREAD /usr/include/*/*
<br>
/usr/include/asm/ioctls.h:#define FIONREAD 0x541B</p>

<p style="margin-top: 1em">Or write a small C program using
the editor of champions:</p>

<p style="margin-top: 1em">% cat &gt; fionread.c <br>
#include &lt;sys/ioctl.h&gt; <br>
main() { <br>
printf(&quot;%#08x0, FIONREAD); <br>
} <br>
^D <br>
% cc -o fionread fionread.c <br>
% ./fionread <br>
0x4004667f</p>

<p style="margin-top: 1em">And then hard-code it, leaving
porting as an exercise to your successor.</p>

<p style="margin-top: 1em">$FIONREAD = 0x4004667f; # XXX:
opsys dependent</p>

<p style="margin-top: 1em">$size = pack(&quot;L&quot;, 0);
<br>
ioctl(FH, $FIONREAD, $size) or die &quot;Couldn&rsquo;t call
ioctl: $!0; <br>
$size = unpack(&quot;L&quot;, $size);</p>

<p style="margin-top: 1em">FIONREAD requires a filehandle
connected to a stream, meaning that sockets, pipes, and tty
devices work, but not files.</p>

<p style="margin-top: 1em">How do I do a &quot;tail
-f&quot; in perl? <br>
First try</p>

<p style="margin-top: 1em">seek($gw_fh, 0, 1);</p>

<p style="margin-top: 1em">The statement &quot;seek($gw_fh,
0, 1)&quot; doesn&rsquo;t change the current position, but
it does clear the end-of-file condition on the handle, so
that the next &quot;&lt;$gw_fh&gt;&quot; makes Perl try <br>
again to read something.</p>

<p style="margin-top: 1em">If that doesn&rsquo;t work (it
relies on features of your stdio implementation), then you
need something more like this:</p>

<p style="margin-top: 1em">for (;;) { <br>
for ($curpos = tell($gw_fh); &lt;$gw_fh&gt;; $curpos
=tell($gw_fh)) { <br>
# search for some stuff and put it into files <br>
} <br>
# sleep for a while <br>
seek($gw_fh, $curpos, 0); # seek to where we had been <br>
}</p>

<p style="margin-top: 1em">If this still doesn&rsquo;t
work, look into the &quot;clearerr&quot; method from
IO::Handle, which resets the error and end-of-file states on
the handle.</p>

<p style="margin-top: 1em">There&rsquo;s also a File::Tail
module from CPAN.</p>

<p style="margin-top: 1em">How do I dup() a filehandle in
Perl? <br>
If you check &quot;open&quot; in perlfunc, you&rsquo;ll see
that several of the ways to call open() should do the trick.
For example:</p>

<p style="margin-top: 1em">open my $log,
&rsquo;&gt;&gt;&rsquo;, &rsquo;/foo/logfile&rsquo;; <br>
open STDERR, &rsquo;&gt;&amp;&rsquo;, $log;</p>

<p style="margin-top: 1em">Or even with a literal numeric
descriptor:</p>

<p style="margin-top: 1em">my $fd = $ENV{MHCONTEXTFD}; <br>
open $mhcontext, &quot;&lt;&amp;=$fd&quot;; # like
fdopen(3S)</p>

<p style="margin-top: 1em">Note that
&quot;&lt;&amp;STDIN&quot; makes a copy, but
&quot;&lt;&amp;=STDIN&quot; makes an alias. That means if
you close an aliased handle, all aliases become
inaccessible. This is not true with a copied one.</p>

<p style="margin-top: 1em">Error checking, as always, has
been left as an exercise for the reader.</p>

<p style="margin-top: 1em">How do I close a file descriptor
by number? <br>
If, for some reason, you have a file descriptor instead of a
filehandle (perhaps you used &quot;POSIX::open&quot;), you
can use the &quot;close()&quot; function from the POSIX
module:</p>

<p style="margin-top: 1em">use POSIX ();</p>

<p style="margin-top: 1em">POSIX::close( $fd );</p>

<p style="margin-top: 1em">This should rarely be necessary,
as the Perl &quot;close()&quot; function is to be used for
things that Perl opened itself, even if it was a dup of a
numeric descriptor as with &quot;MHCONTEXT&quot; <br>
above. But if you really have to, you may be able to do
this:</p>

<p style="margin-top: 1em">require
&rsquo;sys/syscall.ph&rsquo;; <br>
my $rc = syscall(&amp;SYS_close, $fd + 0); # must force
numeric <br>
die &quot;can&rsquo;t sysclose $fd: $!&quot; unless $rc ==
-1;</p>

<p style="margin-top: 1em">Or, just use the fdopen(3S)
feature of &quot;open()&quot;:</p>

<p style="margin-top: 1em">{ <br>
open my $fh, &quot;&lt;&amp;=$fd&quot; or die &quot;Cannot
reopen fd=$fd: $!&quot;; <br>
close $fh; <br>
}</p>

<p style="margin-top: 1em">Why can&rsquo;t I use
&quot;C:empo&quot; in DOS paths? Why doesn&rsquo;t
&lsquo;C:empo.exe&lsquo; work? <br>
Whoops! You just put a tab and a formfeed into that
filename! Remember that within double quoted strings
(&quot;likehis&quot;), the backslash is an escape character.
The full list of <br>
these is in &quot;Quote and Quote-like Operators&quot; in
perlop. Unsurprisingly, you don&rsquo;t have a file called
&quot;c:(tab)emp(formfeed)oo&quot; or
&quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS
<br>
filesystem.</p>

<p style="margin-top: 1em">Either single-quote your
strings, or (preferably) use forward slashes. Since all DOS
and Windows versions since something like MS-DOS 2.0 or so
have treated &quot;/&quot; and &quot; <br>
in a path, you might as well use the one that doesn&rsquo;t
clash with Perl--or the POSIX shell, ANSI C and C++, awk,
Tcl, Java, or Python, just to mention a few. POSIX paths are
more <br>
portable, too.</p>

<p style="margin-top: 1em">Why doesn&rsquo;t
glob(&quot;*.*&quot;) get all the files? <br>
Because even on non-Unix ports, Perl&rsquo;s glob function
follows standard Unix globbing semantics. You&rsquo;ll need
&quot;glob(&quot;*&quot;)&quot; to get all (non-hidden)
files. This makes glob() portable <br>
even to legacy systems. Your port may include proprietary
globbing functions as well. Check its documentation for
details.</p>

<p style="margin-top: 1em">Why does Perl let me delete
read-only files? Why does &quot;-i&quot; clobber protected
files? Isn&rsquo;t this a bug in Perl? <br>
This is elaborately and painstakingly described in the
file-dir-perms article in the &quot;Far More Than You Ever
Wanted To Know&quot; collection in <br>
&lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; .</p>

<p style="margin-top: 1em">The executive summary: learn how
your filesystem works. The permissions on a file say what
can happen to the data in that file. The permissions on a
directory say what can <br>
happen to the list of files in that directory. If you delete
a file, you&rsquo;re removing its name from the directory
(so the operation depends on the permissions of the
directory, <br>
not of the file). If you try to write to the file, the
permissions of the file govern whether you&rsquo;re allowed
to.</p>

<p style="margin-top: 1em">How do I select a random line
from a file? <br>
Short of loading the file into a database or pre-indexing
the lines in the file, there are a couple of things that you
can do.</p>

<p style="margin-top: 1em">Here&rsquo;s a
reservoir-sampling algorithm from the Camel Book:</p>

<p style="margin-top: 1em">srand; <br>
rand($.) &lt; 1 &amp;&amp; ($line = $_) while &lt;&gt;;</p>

<p style="margin-top: 1em">This has a significant advantage
in space over reading the whole file in. You can find a
proof of this method in The Art of Computer Programming,
Volume 2, Section 3.4.2, by <br>
Donald E. Knuth.</p>

<p style="margin-top: 1em">You can use the File::Random
module which provides a function for that algorithm:</p>

<p style="margin-top: 1em">use File::Random
qw/random_line/; <br>
my $line = random_line($filename);</p>

<p style="margin-top: 1em">Another way is to use the
Tie::File module, which treats the entire file as an array.
Simply access a random array element.</p>

<p style="margin-top: 1em">Why do I get weird spaces when I
print an array of lines? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">If you are seeing spaces between
the elements of your array when you print the array, you are
probably interpolating the array in double quotes:</p>

<p style="margin-top: 1em">my @animals = qw(camel llama
alpaca vicuna); <br>
print &quot;animals are: @animals0;</p>

<p style="margin-top: 1em">It&rsquo;s the double quotes,
not the &quot;print&quot;, doing this. Whenever you
interpolate an array in a double quote context, Perl joins
the elements with spaces (or whatever is in $&quot;, which
<br>
is a space by default):</p>

<p style="margin-top: 1em">animals are: camel llama alpaca
vicuna</p>

<p style="margin-top: 1em">This is different than printing
the array without the interpolation:</p>

<p style="margin-top: 1em">my @animals = qw(camel llama
alpaca vicuna); <br>
print &quot;animals are: &quot;, @animals, &quot;0;</p>

<p style="margin-top: 1em">Now the output doesn&rsquo;t
have the spaces between the elements because the elements of
@animals simply become part of the list to
&quot;print&quot;:</p>

<p style="margin-top: 1em">animals are:
camelllamaalpacavicuna</p>

<p style="margin-top: 1em">You might notice this when each
of the elements of @array end with a newline. You expect to
print one element per line, but notice that every line after
the first is indented:</p>

<p style="margin-top: 1em">this is a line <br>
this is another line <br>
this is the third line</p>

<p style="margin-top: 1em">That extra space comes from the
interpolation of the array. If you don&rsquo;t want to put
anything between your array elements, don&rsquo;t use the
array in double quotes. You can send it <br>
to print without them:</p>

<p style="margin-top: 1em">print @lines;</p>

<p style="margin-top: 1em">How do I traverse a directory
tree? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">The File::Find module, which
comes with Perl, does all of the hard work to traverse a
directory structure. It comes with Perl. You simply call the
&quot;find&quot; subroutine with a <br>
callback subroutine and the directories you want to
traverse:</p>

<p style="margin-top: 1em">use File::Find;</p>

<p style="margin-top: 1em">find( wanted, @directories
);</p>

<p style="margin-top: 1em">sub wanted { <br>
# full path in $File::Find::name <br>
# just filename in $_ <br>
... do whatever you want to do ... <br>
}</p>

<p style="margin-top: 1em">The File::Find::Closures, which
you can download from CPAN, provides many ready-to-use
subroutines that you can use with File::Find.</p>

<p style="margin-top: 1em">The File::Finder, which you can
download from CPAN, can help you create the callback
subroutine using something closer to the syntax of the
&quot;find&quot; command-line utility:</p>

<p style="margin-top: 1em">use File::Find; <br>
use File::Finder;</p>

<p style="margin-top: 1em">my $deep_dirs =
File::Finder-&gt;depth-&gt;type(&rsquo;d&rsquo;)-&gt;ls-&gt;exec(&rsquo;rmdir&rsquo;,&rsquo;{}&rsquo;);</p>

<p style="margin-top: 1em">find( $deep_dirs-&gt;as_options,
@places );</p>

<p style="margin-top: 1em">The File::Find::Rule module,
which you can download from CPAN, has a similar interface,
but does the traversal for you too:</p>

<p style="margin-top: 1em">use File::Find::Rule;</p>

<p style="margin-top: 1em">my @files =
File::Find::Rule-&gt;file() <br>
-&gt;name( &rsquo;*.pm&rsquo; ) <br>
-&gt;in( @INC );</p>

<p style="margin-top: 1em">How do I delete a directory
tree? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">If you have an empty directory,
you can use Perl&rsquo;s built-in &quot;rmdir&quot;. If the
directory is not empty (so, no files or subdirectories), you
either have to empty it yourself (a lot <br>
of work) or use a module to help you.</p>

<p style="margin-top: 1em">The File::Path module, which
comes with Perl, has a &quot;remove_tree&quot; which can
take care of all of the hard work for you:</p>

<p style="margin-top: 1em">use File::Path
qw(remove_tree);</p>

<p style="margin-top: 1em">remove_tree( @directories );</p>

<p style="margin-top: 1em">The File::Path module also has a
legacy interface to the older &quot;rmtree&quot;
subroutine.</p>

<p style="margin-top: 1em">How do I copy an entire
directory? <br>
(contributed by Shlomi Fish)</p>

<p style="margin-top: 1em">To do the equivalent of &quot;cp
-R&quot; (i.e. copy an entire directory tree recursively) in
portable Perl, you&rsquo;ll either need to write something
yourself or find a good CPAN module such <br>
as File::Copy::Recursive.</p>

<p style="margin-top: 1em">AUTHOR AND COPYRIGHT <br>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington,
and other authors as noted. All rights reserved.</p>

<p style="margin-top: 1em">This documentation is free; you
can redistribute it and/or modify it under the same terms as
Perl itself.</p>

<p style="margin-top: 1em">Irrespective of its
distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code
and any derivatives thereof in your own <br>
programs for fun or for profit as you see fit. A simple
comment in the code giving credit to the FAQ would be
courteous but is not required.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLFAQ5(1)</p>
<hr>
</body>
</html>
