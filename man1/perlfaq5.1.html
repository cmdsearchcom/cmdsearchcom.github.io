<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLFAQ5(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFAQ5(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFAQ5(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlfaq5 - Files and Formats
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This section deals with I/O and the &quot;f&quot; issues: filehandles, flushing,
  formats, and footers.
<h2 class="Ss" title="Ss" id="How_do_I_flush/unbuffer_an_output_filehandle?_Why_must_I_do_this?"><a class="selflink" href="#How_do_I_flush/unbuffer_an_output_filehandle?_Why_must_I_do_this?">How
  do I flush/unbuffer an output filehandle? Why must I do this?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
You might like to read Mark Jason Dominus's &quot;Suffering From Buffering&quot;
  at &lt;http://perl.plover.com/FAQs/Buffering.html&gt; .
<div class="Pp"></div>
Perl normally buffers output so it doesn't make a system call for every bit of
  output. By saving up output, it makes fewer expensive system calls. For
  instance, in this little bit of code, you want to print a dot to the screen
  for every line you process to watch the progress of your program. Instead of
  seeing a dot for every line, Perl buffers the output and you have a long wait
  before you see a row of 50 dots all at once:
<div class="Pp"></div>
<pre>
    # long wait, then row of dots all at once
    while( &lt;&gt; ) {
        print &quot;.&quot;;
        print &quot;\n&quot; unless ++$count % 50;
        #... expensive line processing operations
    }
</pre>
<div class="Pp"></div>
To get around this, you have to unbuffer the output filehandle, in this case,
  &quot;STDOUT&quot;. You can set the special variable $| to a true value
  (mnemonic: making your filehandles &quot;piping hot&quot;):
<div class="Pp"></div>
<pre>
    $|++;
    # dot shown immediately
    while( &lt;&gt; ) {
        print &quot;.&quot;;
        print &quot;\n&quot; unless ++$count % 50;
        #... expensive line processing operations
    }
</pre>
<div class="Pp"></div>
The $| is one of the per-filehandle special variables, so each filehandle has
  its own copy of its value. If you want to merge standard output and standard
  error for instance, you have to unbuffer each (although STDERR might be
  unbuffered by default):
<div class="Pp"></div>
<pre>
    {
        my $previous_default = select(STDOUT);  # save previous default
        $|++;                                   # autoflush STDOUT
        select(STDERR);
        $|++;                                   # autoflush STDERR, to be sure
        select($previous_default);              # restore previous default
    }
    # now should alternate . and +
    while( 1 ) {
        sleep 1;
        print STDOUT &quot;.&quot;;
        print STDERR &quot;+&quot;;
        print STDOUT &quot;\n&quot; unless ++$count % 25;
    }
</pre>
<div class="Pp"></div>
Besides the $| special variable, you can use &quot;binmode&quot; to give your
  filehandle a &quot;:unix&quot; layer, which is unbuffered:
<div class="Pp"></div>
<pre>
    binmode( STDOUT, &quot;:unix&quot; );
    while( 1 ) {
        sleep 1;
        print &quot;.&quot;;
        print &quot;\n&quot; unless ++$count % 50;
    }
</pre>
<div class="Pp"></div>
For more information on output layers, see the entries for &quot;binmode&quot;
  and open in perlfunc, and the PerlIO module documentation.
<div class="Pp"></div>
If you are using IO::Handle or one of its subclasses, you can call the
  &quot;autoflush&quot; method to change the settings of the filehandle:
<div class="Pp"></div>
<pre>
    use IO::Handle;
    open my( $io_fh ), &quot;&gt;&quot;, &quot;output.txt&quot;;
    $io_fh-&gt;autoflush(1);
</pre>
<div class="Pp"></div>
The IO::Handle objects also have a &quot;flush&quot; method. You can flush the
  buffer any time you want without auto-buffering
<div class="Pp"></div>
<pre>
    $io_fh-&gt;flush;
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_change,_delete,_or_insert_a_line_in_a_file,_or_append_to_the_beginning_of_a_file?"><a class="selflink" href="#How_do_I_change,_delete,_or_insert_a_line_in_a_file,_or_append_to_the_beginning_of_a_file?">How
  do I change, delete, or insert a line in a file, or append to the beginning of
  a file?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
The basic idea of inserting, changing, or deleting a line from a text file
  involves reading and printing the file to the point you want to make the
  change, making the change, then reading and printing the rest of the file.
  Perl doesn't provide random access to lines (especially since the record input
  separator, $/, is mutable), although modules such as Tie::File can fake it.
<div class="Pp"></div>
A Perl program to do these tasks takes the basic form of opening a file,
  printing its lines, then closing the file:
<div class="Pp"></div>
<pre>
    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    while( &lt;$in&gt; ) {
            print $out $_;
    }
    close $out;
</pre>
<div class="Pp"></div>
Within that basic form, add the parts that you need to insert, change, or delete
  lines.
<div class="Pp"></div>
To prepend lines to the beginning, print those lines before you enter the loop
  that prints the existing lines.
<div class="Pp"></div>
<pre>
    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    print $out &quot;# Add this line to the top\n&quot;; # &lt;--- HERE'S THE MAGIC
    while( &lt;$in&gt; ) {
            print $out $_;
    }
    close $out;
</pre>
<div class="Pp"></div>
To change existing lines, insert the code to modify the lines inside the
  &quot;while&quot; loop. In this case, the code finds all lowercased versions
  of &quot;perl&quot; and uppercases them. The happens for every line, so be
  sure that you're supposed to do that on every line!
<div class="Pp"></div>
<pre>
    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    print $out &quot;# Add this line to the top\n&quot;;
    while( &lt;$in&gt; ) {
        s/\b(perl)\b/Perl/g;
        print $out $_;
    }
    close $out;
</pre>
<div class="Pp"></div>
To change only a particular line, the input line number, $., is useful. First
  read and print the lines up to the one you want to change. Next, read the
  single line you want to change, change it, and print it. After that, read the
  rest of the lines and print those:
<div class="Pp"></div>
<pre>
    while( &lt;$in&gt; ) { # print the lines before the change
        print $out $_;
        last if $. == 4; # line number before change
    }
    my $line = &lt;$in&gt;;
    $line =~ s/\b(perl)\b/Perl/g;
    print $out $line;
    while( &lt;$in&gt; ) { # print the rest of the lines
        print $out $_;
    }
</pre>
<div class="Pp"></div>
To skip lines, use the looping controls. The &quot;next&quot; in this example
  skips comment lines, and the &quot;last&quot; stops all processing once it
  encounters either &quot;__END__&quot; or &quot;__DATA__&quot;.
<div class="Pp"></div>
<pre>
    while( &lt;$in&gt; ) {
        next if /^\s+#/;             # skip comment lines
        last if /^__(END|DATA)__$/;  # stop at end of code marker
        print $out $_;
    }
</pre>
<div class="Pp"></div>
Do the same sort of thing to delete a particular line by using &quot;next&quot;
  to skip the lines you don't want to show up in the output. This example skips
  every fifth line:
<div class="Pp"></div>
<pre>
    while( &lt;$in&gt; ) {
        next unless $. % 5;
        print $out $_;
    }
</pre>
<div class="Pp"></div>
If, for some odd reason, you really want to see the whole file at once rather
  than processing line-by-line, you can slurp it in (as long as you can fit the
  whole thing in memory!):
<div class="Pp"></div>
<pre>
    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    my @lines = do { local $/; &lt;$in&gt; }; # slurp!
        # do your magic here
    print $out @lines;
</pre>
<div class="Pp"></div>
Modules such as File::Slurp and Tie::File can help with that too. If you can,
  however, avoid reading the entire file at once. Perl won't give that memory
  back to the operating system until the process finishes.
<div class="Pp"></div>
You can also use Perl one-liners to modify a file in-place. The following
  changes all 'Fred' to 'Barney' in <i>inFile.txt</i>, overwriting the file with
  the new contents. With the &quot;-p&quot; switch, Perl wraps a
  &quot;while&quot; loop around the code you specify with &quot;-e&quot;, and
  &quot;-i&quot; turns on in-place editing. The current line is in $_. With
  &quot;-p&quot;, Perl automatically prints the value of $_ at the end of the
  loop. See perlrun for more details.
<div class="Pp"></div>
<pre>
    perl -pi -e 's/Fred/Barney/' inFile.txt
</pre>
<div class="Pp"></div>
To make a backup of &quot;inFile.txt&quot;, give &quot;-i&quot; a file extension
  to add:
<div class="Pp"></div>
<pre>
    perl -pi.bak -e 's/Fred/Barney/' inFile.txt
</pre>
<div class="Pp"></div>
To change only the fifth line, you can add a test checking $., the input line
  number, then only perform the operation when the test passes:
<div class="Pp"></div>
<pre>
    perl -pi -e 's/Fred/Barney/ if $. == 5' inFile.txt
</pre>
<div class="Pp"></div>
To add lines before a certain line, you can add a line (or lines!) before Perl
  prints $_:
<div class="Pp"></div>
<pre>
    perl -pi -e 'print &quot;Put before third line\n&quot; if $. == 3' inFile.txt
</pre>
<div class="Pp"></div>
You can even add a line to the beginning of a file, since the current line
  prints at the end of the loop:
<div class="Pp"></div>
<pre>
    perl -pi -e 'print &quot;Put before first line\n&quot; if $. == 1' inFile.txt
</pre>
<div class="Pp"></div>
To insert a line after one already in the file, use the &quot;-n&quot; switch.
  It's just like &quot;-p&quot; except that it doesn't print $_ at the end of
  the loop, so you have to do that yourself. In this case, print $_ first, then
  print the line that you want to add.
<div class="Pp"></div>
<pre>
    perl -ni -e 'print; print &quot;Put after fifth line\n&quot; if $. == 5' inFile.txt
</pre>
<div class="Pp"></div>
To delete lines, only print the ones that you want.
<div class="Pp"></div>
<pre>
    perl -ni -e 'print if /d/' inFile.txt
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_count_the_number_of_lines_in_a_file?"><a class="selflink" href="#How_do_I_count_the_number_of_lines_in_a_file?">How
  do I count the number of lines in a file?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
Conceptually, the easiest way to count the lines in a file is to simply read
  them and count them:
<div class="Pp"></div>
<pre>
    my $count = 0;
    while( &lt;$fh&gt; ) { $count++; }
</pre>
<div class="Pp"></div>
You don't really have to count them yourself, though, since Perl already does
  that with the $. variable, which is the current line number from the last
  filehandle read:
<div class="Pp"></div>
<pre>
    1 while( &lt;$fh&gt; );
    my $count = $.;
</pre>
<div class="Pp"></div>
If you want to use $., you can reduce it to a simple one-liner, like one of
  these:
<div class="Pp"></div>
<pre>
    % perl -lne '} print $.; {'    file
    % perl -lne 'END { print $. }' file
</pre>
<div class="Pp"></div>
Those can be rather inefficient though. If they aren't fast enough for you, you
  might just read chunks of data and count the number of newlines:
<div class="Pp"></div>
<pre>
    my $lines = 0;
    open my($fh), '&lt;:raw', $filename or die &quot;Can't open $filename: $!&quot;;
    while( sysread $fh, $buffer, 4096 ) {
        $lines += ( $buffer =~ tr/\n// );
    }
    close FILE;
</pre>
<div class="Pp"></div>
However, that doesn't work if the line ending isn't a newline. You might change
  that &quot;tr///&quot; to a &quot;s///&quot; so you can count the number of
  times the input record separator, $/, shows up:
<div class="Pp"></div>
<pre>
    my $lines = 0;
    open my($fh), '&lt;:raw', $filename or die &quot;Can't open $filename: $!&quot;;
    while( sysread $fh, $buffer, 4096 ) {
        $lines += ( $buffer =~ s|$/||g; );
    }
    close FILE;
</pre>
<div class="Pp"></div>
If you don't mind shelling out, the &quot;wc&quot; command is usually the
  fastest, even with the extra interprocess overhead. Ensure that you have an
  untainted filename though:
<div class="Pp"></div>
<pre>
    #!perl -T
    $ENV{PATH} = undef;
    my $lines;
    if( $filename =~ /^([0-9a-z_.]+)\z/ ) {
        $lines = `/usr/bin/wc -l $1`
        chomp $lines;
    }
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_delete_the_last_N_lines_from_a_file?"><a class="selflink" href="#How_do_I_delete_the_last_N_lines_from_a_file?">How
  do I delete the last N lines from a file?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
The easiest conceptual solution is to count the lines in the file then start at
  the beginning and print the number of lines (minus the last N) to a new file.
<div class="Pp"></div>
Most often, the real question is how you can delete the last N lines without
  making more than one pass over the file, or how to do it without a lot of
  copying. The easy concept is the hard reality when you might have millions of
  lines in your file.
<div class="Pp"></div>
One trick is to use File::ReadBackwards, which starts at the end of the file.
  That module provides an object that wraps the real filehandle to make it easy
  for you to move around the file. Once you get to the spot you need, you can
  get the actual filehandle and work with it as normal. In this case, you get
  the file position at the end of the last line you want to keep and truncate
  the file to that point:
<div class="Pp"></div>
<pre>
    use File::ReadBackwards;
    my $filename = 'test.txt';
    my $Lines_to_truncate = 2;
    my $bw = File::ReadBackwards-&gt;new( $filename )
        or die &quot;Could not read backwards in [$filename]: $!&quot;;
    my $lines_from_end = 0;
    until( $bw-&gt;eof or $lines_from_end == $Lines_to_truncate ) {
        print &quot;Got: &quot;, $bw-&gt;readline;
        $lines_from_end++;
    }
    truncate( $filename, $bw-&gt;tell );
</pre>
<div class="Pp"></div>
The File::ReadBackwards module also has the advantage of setting the input
  record separator to a regular expression.
<div class="Pp"></div>
You can also use the Tie::File module which lets you access the lines through a
  tied array. You can use normal array operations to modify your file, including
  setting the last index and using &quot;splice&quot;.
<h2 class="Ss" title="Ss" id="How_can_I_use_Perl's_&quot;-i&quot;_option_from_within_a_program?"><a class="selflink" href="#How_can_I_use_Perl's_&quot;-i&quot;_option_from_within_a_program?">How
  can I use Perl's &quot;-i&quot; option from within a program?</a></h2>
&quot;-i&quot; sets the value of Perl's $^I variable, which in turn affects the
  behavior of &quot;&lt;&gt;&quot;; see perlrun for more details. By modifying
  the appropriate variables directly, you can get the same behavior within a
  larger program. For example:
<div class="Pp"></div>
<pre>
    # ...
    {
        local($^I, @ARGV) = ('.orig', glob(&quot;*.c&quot;));
        while (&lt;&gt;) {
            if ($. == 1) {
                print &quot;This line should appear at the top of each file\n&quot;;
            }
            s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
            print;
            close ARGV if eof;              # Reset $.
        }
    }
    # $^I and @ARGV return to their old values here
</pre>
<div class="Pp"></div>
This block modifies all the &quot;.c&quot; files in the current directory,
  leaving a backup of the original data from each file in a new
  &quot;.c.orig&quot; file.
<h2 class="Ss" title="Ss" id="How_can_I_copy_a_file?"><a class="selflink" href="#How_can_I_copy_a_file?">How
  can I copy a file?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
Use the File::Copy module. It comes with Perl and can do a true copy across file
  systems, and it does its magic in a portable fashion.
<div class="Pp"></div>
<pre>
    use File::Copy;
    copy( $original, $new_copy ) or die &quot;Copy failed: $!&quot;;
</pre>
<div class="Pp"></div>
If you can't use File::Copy, you'll have to do the work yourself: open the
  original file, open the destination file, then print to the destination file
  as you read the original. You also have to remember to copy the permissions,
  owner, and group to the new file.
<h2 class="Ss" title="Ss" id="How_do_I_make_a_temporary_file_name?"><a class="selflink" href="#How_do_I_make_a_temporary_file_name?">How
  do I make a temporary file name?</a></h2>
If you don't need to know the name of the file, you can use &quot;open()&quot;
  with &quot;undef&quot; in place of the file name. In Perl 5.8 or later, the
  &quot;open()&quot; function creates an anonymous temporary file:
<div class="Pp"></div>
<pre>
    open my $tmp, '+&gt;', undef or die $!;
</pre>
<div class="Pp"></div>
Otherwise, you can use the File::Temp module.
<div class="Pp"></div>
<pre>
    use File::Temp qw/ tempfile tempdir /;
    my $dir = tempdir( CLEANUP =&gt; 1 );
    ($fh, $filename) = tempfile( DIR =&gt; $dir );
    # or if you don't need to know the filename
    my $fh = tempfile( DIR =&gt; $dir );
</pre>
<div class="Pp"></div>
The File::Temp has been a standard module since Perl 5.6.1. If you don't have a
  modern enough Perl installed, use the &quot;new_tmpfile&quot; class method
  from the IO::File module to get a filehandle opened for reading and writing.
  Use it if you don't need to know the file's name:
<div class="Pp"></div>
<pre>
    use IO::File;
    my $fh = IO::File-&gt;new_tmpfile()
        or die &quot;Unable to make new temporary file: $!&quot;;
</pre>
<div class="Pp"></div>
If you're committed to creating a temporary file by hand, use the process ID
  and/or the current time-value. If you need to have many temporary files in one
  process, use a counter:
<div class="Pp"></div>
<pre>
    BEGIN {
        use Fcntl;
        my $temp_dir = -d '/tmp' ? '/tmp' : $ENV{TMPDIR} || $ENV{TEMP};
        my $base_name = sprintf &quot;%s/%d-%d-0000&quot;, $temp_dir, $$, time;
        sub temp_file {
            my $fh;
            my $count = 0;
            until( defined(fileno($fh)) || $count++ &gt; 100 ) {
                $base_name =~ s/-(\d+)$/&quot;-&quot; . (1 + $1)/e;
                # O_EXCL is required for security reasons.
                sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT;
            }
            if( defined fileno($fh) ) {
                return ($fh, $base_name);
            }
            else {
                return ();
            }
        }
    }
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_manipulate_fixed-record-length_files?"><a class="selflink" href="#How_can_I_manipulate_fixed-record-length_files?">How
  can I manipulate fixed-record-length files?</a></h2>
The most efficient way is using <i>pack()</i> and <i>unpack()</i>. This is
  faster than using <i>substr()</i> when taking many, many strings. It is slower
  for just a few.
<div class="Pp"></div>
Here is a sample chunk of code to break up and put back together again some
  fixed-format input lines, in this case from the output of a normal,
  Berkeley-style ps:
<div class="Pp"></div>
<pre>
    # sample input line:
    #   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
    my $PS_T = 'A6 A4 A7 A5 A*';
    open my $ps, '-|', 'ps';
    print scalar &lt;$ps&gt;;
    my @fields = qw( pid tt stat time command );
    while (&lt;$ps&gt;) {
        my %process;
        @process{@fields} = unpack($PS_T, $_);
        for my $field ( @fields ) {
            print &quot;$field: &lt;$process{$field}&gt;\n&quot;;
        }
        print 'line=', pack($PS_T, @process{@fields} ), &quot;\n&quot;;
    }
</pre>
<div class="Pp"></div>
We've used a hash slice in order to easily handle the fields of each row.
  Storing the keys in an array makes it easy to operate on them as a group or
  loop over them with &quot;for&quot;. It also avoids polluting the program with
  global variables and using symbolic references.
<h2 class="Ss" title="Ss" id="How_can_I_make_a_filehandle_local_to_a_subroutine?_How_do_I_pass_filehandles_between_subroutines?_How_do_I_make_an_array_of_filehandles?"><a class="selflink" href="#How_can_I_make_a_filehandle_local_to_a_subroutine?_How_do_I_pass_filehandles_between_subroutines?_How_do_I_make_an_array_of_filehandles?">How
  can I make a filehandle local to a subroutine? How do I pass filehandles
  between subroutines? How do I make an array of filehandles?</a></h2>
As of perl5.6, <i>open()</i> autovivifies file and directory handles as
  references if you pass it an uninitialized scalar variable. You can then pass
  these references just like any other scalar, and use them in the place of
  named handles.
<div class="Pp"></div>
<pre>
    open my    $fh, $file_name;
    open local $fh, $file_name;
    print $fh &quot;Hello World!\n&quot;;
    process_file( $fh );
</pre>
<div class="Pp"></div>
If you like, you can store these filehandles in an array or a hash. If you
  access them directly, they aren't simple scalars and you need to give
  &quot;print&quot; a little help by placing the filehandle reference in braces.
  Perl can only figure it out on its own when the filehandle reference is a
  simple scalar.
<div class="Pp"></div>
<pre>
    my @fhs = ( $fh1, $fh2, $fh3 );
    for( $i = 0; $i &lt;= $#fhs; $i++ ) {
        print {$fhs[$i]} &quot;just another Perl answer, \n&quot;;
    }
</pre>
<div class="Pp"></div>
Before perl5.6, you had to deal with various typeglob idioms which you may see
  in older code.
<div class="Pp"></div>
<pre>
    open FILE, &quot;&gt; $filename&quot;;
    process_typeglob(   *FILE );
    process_reference( \*FILE );
    sub process_typeglob  { local *FH = shift; print FH  &quot;Typeglob!&quot; }
    sub process_reference { local $fh = shift; print $fh &quot;Reference!&quot; }
</pre>
<div class="Pp"></div>
If you want to create many anonymous handles, you should check out the Symbol or
  IO::Handle modules.
<h2 class="Ss" title="Ss" id="How_can_I_use_a_filehandle_indirectly?"><a class="selflink" href="#How_can_I_use_a_filehandle_indirectly?">How
  can I use a filehandle indirectly?</a></h2>
An indirect filehandle is the use of something other than a symbol in a place
  that a filehandle is expected. Here are ways to get indirect filehandles:
<div class="Pp"></div>
<pre>
    $fh =   SOME_FH;       # bareword is strict-subs hostile
    $fh =  &quot;SOME_FH&quot;;      # strict-refs hostile; same package only
    $fh =  *SOME_FH;       # typeglob
    $fh = \*SOME_FH;       # ref to typeglob (bless-able)
    $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob
</pre>
<div class="Pp"></div>
Or, you can use the &quot;new&quot; method from one of the IO::* modules to
  create an anonymous filehandle and store that in a scalar variable.
<div class="Pp"></div>
<pre>
    use IO::Handle;                     # 5.004 or higher
    my $fh = IO::Handle-&gt;new();
</pre>
<div class="Pp"></div>
Then use any of those as you would a normal filehandle. Anywhere that Perl is
  expecting a filehandle, an indirect filehandle may be used instead. An
  indirect filehandle is just a scalar variable that contains a filehandle.
  Functions like &quot;print&quot;, &quot;open&quot;, &quot;seek&quot;, or the
  &quot;&lt;FH&gt;&quot; diamond operator will accept either a named filehandle
  or a scalar variable containing one:
<div class="Pp"></div>
<pre>
    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
    print $ofh &quot;Type it: &quot;;
    my $got = &lt;$ifh&gt;
    print $efh &quot;What was that: $got&quot;;
</pre>
<div class="Pp"></div>
If you're passing a filehandle to a function, you can write the function in two
  ways:
<div class="Pp"></div>
<pre>
    sub accept_fh {
        my $fh = shift;
        print $fh &quot;Sending to indirect filehandle\n&quot;;
    }
</pre>
<div class="Pp"></div>
Or it can localize a typeglob and use the filehandle directly:
<div class="Pp"></div>
<pre>
    sub accept_fh {
        local *FH = shift;
        print  FH &quot;Sending to localized filehandle\n&quot;;
    }
</pre>
<div class="Pp"></div>
Both styles work with either objects or typeglobs of real filehandles. (They
  might also work with strings under some circumstances, but this is risky.)
<div class="Pp"></div>
<pre>
    accept_fh(*STDOUT);
    accept_fh($handle);
</pre>
<div class="Pp"></div>
In the examples above, we assigned the filehandle to a scalar variable before
  using it. That is because only simple scalar variables, not expressions or
  subscripts of hashes or arrays, can be used with built-ins like
  &quot;print&quot;, &quot;printf&quot;, or the diamond operator. Using
  something other than a simple scalar variable as a filehandle is illegal and
  won't even compile:
<div class="Pp"></div>
<pre>
    my @fd = (*STDIN, *STDOUT, *STDERR);
    print $fd[1] &quot;Type it: &quot;;                           # WRONG
    my $got = &lt;$fd[0]&gt;                                  # WRONG
    print $fd[2] &quot;What was that: $got&quot;;                 # WRONG
</pre>
<div class="Pp"></div>
With &quot;print&quot; and &quot;printf&quot;, you get around this by using a
  block and an expression where you would place the filehandle:
<div class="Pp"></div>
<pre>
    print  { $fd[1] } &quot;funny stuff\n&quot;;
    printf { $fd[1] } &quot;Pity the poor %x.\n&quot;, 3_735_928_559;
    # Pity the poor deadbeef.
</pre>
<div class="Pp"></div>
That block is a proper block like any other, so you can put more complicated
  code there. This sends the message out to one of two places:
<div class="Pp"></div>
<pre>
    my $ok = -x &quot;/bin/cat&quot;;
    print { $ok ? $fd[1] : $fd[2] } &quot;cat stat $ok\n&quot;;
    print { $fd[ 1+ ($ok || 0) ]  } &quot;cat stat $ok\n&quot;;
</pre>
<div class="Pp"></div>
This approach of treating &quot;print&quot; and &quot;printf&quot; like object
  methods calls doesn't work for the diamond operator. That's because it's a
  real operator, not just a function with a comma-less argument. Assuming you've
  been storing typeglobs in your structure as we did above, you can use the
  built-in function named &quot;readline&quot; to read a record just as
  &quot;&lt;&gt;&quot; does. Given the initialization shown above for @fd, this
  would work, but only because <i>readline()</i> requires a typeglob. It doesn't
  work with objects or strings, which might be a bug we haven't fixed yet.
<div class="Pp"></div>
<pre>
    $got = readline($fd[0]);
</pre>
<div class="Pp"></div>
Let it be noted that the flakiness of indirect filehandles is not related to
  whether they're strings, typeglobs, objects, or anything else. It's the syntax
  of the fundamental operators. Playing the object game doesn't help you at all
  here.
<h2 class="Ss" title="Ss" id="How_can_I_set_up_a_footer_format_to_be_used_with_write()?"><a class="selflink" href="#How_can_I_set_up_a_footer_format_to_be_used_with_write()?">How
  can I set up a footer format to be used with <i>write()</i>?</a></h2>
There's no builtin way to do this, but perlform has a couple of techniques to
  make it possible for the intrepid hacker.
<h2 class="Ss" title="Ss" id="How_can_I_write()_into_a_string?"><a class="selflink" href="#How_can_I_write()_into_a_string?">How
  can I <i>write()</i> into a string?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
If you want to &quot;write&quot; into a string, you just have to &lt;open&gt; a
  filehandle to a string, which Perl has been able to do since Perl 5.6:
<div class="Pp"></div>
<pre>
    open FH, '&gt;', \my $string;
    write( FH );
</pre>
<div class="Pp"></div>
Since you want to be a good programmer, you probably want to use a lexical
  filehandle, even though formats are designed to work with bareword filehandles
  since the default format names take the filehandle name. However, you can
  control this with some Perl special per-filehandle variables: $^, which names
  the top-of-page format, and $~ which shows the line format. You have to change
  the default filehandle to set these variables:
<div class="Pp"></div>
<pre>
    open my($fh), '&gt;', \my $string;
    { # set per-filehandle variables
        my $old_fh = select( $fh );
        $~ = 'ANIMAL';
        $^ = 'ANIMAL_TOP';
        select( $old_fh );
    }
    format ANIMAL_TOP =
     ID  Type    Name
    .
    format ANIMAL =
    @##   @&lt;&lt;&lt;    @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    $id,  $type,  $name
    .
</pre>
<div class="Pp"></div>
Although write can work with lexical or package variables, whatever variables
  you use have to scope in the format. That most likely means you'll want to
  localize some package variables:
<div class="Pp"></div>
<pre>
    {
        local( $id, $type, $name ) = qw( 12 cat Buster );
        write( $fh );
    }
    print $string;
</pre>
<div class="Pp"></div>
There are also some tricks that you can play with &quot;formline&quot; and the
  accumulator variable $^A, but you lose a lot of the value of formats since
  &quot;formline&quot; won't handle paging and so on. You end up reimplementing
  formats when you use them.
<h2 class="Ss" title="Ss" id="How_can_I_open_a_filehandle_to_a_string?"><a class="selflink" href="#How_can_I_open_a_filehandle_to_a_string?">How
  can I open a filehandle to a string?</a></h2>
(contributed by Peter J. Holzer, hjp-usenet2@hjp.at)
<div class="Pp"></div>
Since Perl 5.8.0 a file handle referring to a string can be created by calling
  open with a reference to that string instead of the filename. This file handle
  can then be used to read from or write to the string:
<div class="Pp"></div>
<pre>
    open(my $fh, '&gt;', \$string) or die &quot;Could not open string for writing&quot;;
    print $fh &quot;foo\n&quot;;
    print $fh &quot;bar\n&quot;;    # $string now contains &quot;foo\nbar\n&quot;
    open(my $fh, '&lt;', \$string) or die &quot;Could not open string for reading&quot;;
    my $x = &lt;$fh&gt;;    # $x now contains &quot;foo\n&quot;
</pre>
<div class="Pp"></div>
With older versions of Perl, the IO::String module provides similar
  functionality.
<h2 class="Ss" title="Ss" id="How_can_I_output_my_numbers_with_commas_added?"><a class="selflink" href="#How_can_I_output_my_numbers_with_commas_added?">How
  can I output my numbers with commas added?</a></h2>
(contributed by brian d foy and Benjamin Goldberg)
<div class="Pp"></div>
You can use Number::Format to separate places in a number. It handles locale
  information for those of you who want to insert full stops instead (or
  anything else that they want to use, really).
<div class="Pp"></div>
This subroutine will add commas to your number:
<div class="Pp"></div>
<pre>
    sub commify {
        local $_  = shift;
        1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
        return $_;
    }
</pre>
<div class="Pp"></div>
This regex from Benjamin Goldberg will add commas to numbers:
<div class="Pp"></div>
<pre>
    s/(^[-+]?\d+?(?=(?&gt;(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;
</pre>
<div class="Pp"></div>
It is easier to see with comments:
<div class="Pp"></div>
<pre>
    s/(
        ^[-+]?             # beginning of number.
        \d+?               # first digits before first comma
        (?=                # followed by, (but not included in the match) :
            (?&gt;(?:\d{3})+) # some positive multiple of three digits.
            (?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
        )
        |                  # or:
        \G\d{3}            # after the last group, get three digits
        (?=\d)             # but they have to have more digits after them.
    )/$1,/xg;
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_translate_tildes_(~)_in_a_filename?"><a class="selflink" href="#How_can_I_translate_tildes_(~)_in_a_filename?">How
  can I translate tildes (~) in a filename?</a></h2>
Use the &lt;&gt; (&quot;glob()&quot;) operator, documented in perlfunc. Versions
  of Perl older than 5.6 require that you have a shell installed that groks
  tildes. Later versions of Perl have this feature built in. The File::KGlob
  module (available from CPAN) gives more portable glob functionality.
<div class="Pp"></div>
Within Perl, you may use this directly:
<div class="Pp"></div>
<pre>
    $filename =~ s{
      ^ ~             # find a leading tilde
      (               # save this in $1
          [^/]        # a non-slash character
                *     # repeated 0 or more times (0 means me)
      )
    }{
      $1
          ? (getpwnam($1))[7]
          : ( $ENV{HOME} || $ENV{LOGDIR} )
    }ex;
</pre>
<h2 class="Ss" title="Ss" id="How_come_when_I_open_a_file_read-write_it_wipes_it_out?"><a class="selflink" href="#How_come_when_I_open_a_file_read-write_it_wipes_it_out?">How
  come when I open a file read-write it wipes it out?</a></h2>
Because you're using something like this, which truncates the file <i>then</i>
  gives you read-write access:
<div class="Pp"></div>
<pre>
    open my $fh, '+&gt;', '/path/name'; # WRONG (almost always)
</pre>
<div class="Pp"></div>
Whoops. You should instead use this, which will fail if the file doesn't exist:
<div class="Pp"></div>
<pre>
    open my $fh, '+&lt;', '/path/name'; # open for update
</pre>
<div class="Pp"></div>
Using &quot;&gt;&quot; always clobbers or creates. Using &quot;&lt;&quot; never
  does either. The &quot;+&quot; doesn't change this.
<div class="Pp"></div>
Here are examples of many kinds of file opens. Those using &quot;sysopen&quot;
  all assume that you've pulled in the constants from Fcntl:
<div class="Pp"></div>
<pre>
    use Fcntl;
</pre>
<div class="Pp"></div>
To open file for reading:
<div class="Pp"></div>
<pre>
    open my $fh, '&lt;', $path                               or die $!;
    sysopen my $fh, $path, O_RDONLY                       or die $!;
</pre>
<div class="Pp"></div>
To open file for writing, create new file if needed or else truncate old file:
<div class="Pp"></div>
<pre>
    open my $fh, '&gt;', $path                               or die $!;
    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT       or die $!;
    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or die $!;
</pre>
<div class="Pp"></div>
To open file for writing, create new file, file must not exist:
<div class="Pp"></div>
<pre>
    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT        or die $!;
    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666  or die $!;
</pre>
<div class="Pp"></div>
To open file for appending, create if necessary:
<div class="Pp"></div>
<pre>
    open my $fh, '&gt;&gt;' $path                               or die $!;
    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT      or die $!;
    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or die $!;
</pre>
<div class="Pp"></div>
To open file for appending, file must exist:
<div class="Pp"></div>
<pre>
    sysopen my $fh, $path, O_WRONLY|O_APPEND              or die $!;
</pre>
<div class="Pp"></div>
To open file for update, file must exist:
<div class="Pp"></div>
<pre>
    open my $fh, '+&lt;', $path                              or die $!;
    sysopen my $fh, $path, O_RDWR                         or die $!;
</pre>
<div class="Pp"></div>
To open file for update, create file if necessary:
<div class="Pp"></div>
<pre>
    sysopen my $fh, $path, O_RDWR|O_CREAT                 or die $!;
    sysopen my $fh, $path, O_RDWR|O_CREAT, 0666           or die $!;
</pre>
<div class="Pp"></div>
To open file for update, file must not exist:
<div class="Pp"></div>
<pre>
    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT          or die $!;
    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666    or die $!;
</pre>
<div class="Pp"></div>
To open a file without blocking, creating if necessary:
<div class="Pp"></div>
<pre>
    sysopen my $fh, '/foo/somefile', O_WRONLY|O_NDELAY|O_CREAT
        or die &quot;can't open /foo/somefile: $!&quot;:
</pre>
<div class="Pp"></div>
Be warned that neither creation nor deletion of files is guaranteed to be an
  atomic operation over NFS. That is, two processes might both successfully
  create or unlink the same file! Therefore O_EXCL isn't as exclusive as you
  might wish.
<div class="Pp"></div>
See also perlopentut.
<h2 class="Ss" title="Ss" id="Why_do_I_sometimes_get_an_&quot;Argument_list_too_long&quot;_when_I_use_&lt;*&gt;?"><a class="selflink" href="#Why_do_I_sometimes_get_an_&quot;Argument_list_too_long&quot;_when_I_use_&lt;*&gt;?">Why
  do I sometimes get an &quot;Argument list too long&quot; when I use
  &lt;*&gt;?</a></h2>
The &quot;&lt;&gt;&quot; operator performs a globbing operation (see above). In
  Perl versions earlier than v5.6.0, the internal <i>glob()</i> operator forks
  <i>csh</i>(1) to do the actual glob expansion, but csh can't handle more than
  127 items and so gives the error message &quot;Argument list too long&quot;.
  People who installed tcsh as csh won't have this problem, but their users may
  be surprised by it.
<div class="Pp"></div>
To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself
  with <i>readdir()</i> and patterns, or use a module like File::Glob, one that
  doesn't use the shell to do globbing.
<h2 class="Ss" title="Ss" id="How_can_I_open_a_file_with_a_leading_&quot;&gt;&quot;_or_trailing_blanks?"><a class="selflink" href="#How_can_I_open_a_file_with_a_leading_&quot;&gt;&quot;_or_trailing_blanks?">How
  can I open a file with a leading &quot;&gt;&quot; or trailing blanks?</a></h2>
(contributed by Brian McCauley)
<div class="Pp"></div>
The special two-argument form of Perl's <i>open()</i> function ignores trailing
  blanks in filenames and infers the mode from certain leading characters (or a
  trailing &quot;|&quot;). In older versions of Perl this was the only version
  of <i>open()</i> and so it is prevalent in old code and books.
<div class="Pp"></div>
Unless you have a particular reason to use the two-argument form you should use
  the three-argument form of <i>open()</i> which does not treat any characters
  in the filename as special.
<div class="Pp"></div>
<pre>
    open my $fh, &quot;&lt;&quot;, &quot;  file  &quot;;  # filename is &quot;   file   &quot;
    open my $fh, &quot;&gt;&quot;, &quot;&gt;file&quot;;     # filename is &quot;&gt;file&quot;
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_reliably_rename_a_file?"><a class="selflink" href="#How_can_I_reliably_rename_a_file?">How
  can I reliably rename a file?</a></h2>
If your operating system supports a proper <i>mv</i>(1) utility or its
  functional equivalent, this works:
<div class="Pp"></div>
<pre>
    rename($old, $new) or system(&quot;mv&quot;, $old, $new);
</pre>
<div class="Pp"></div>
It may be more portable to use the File::Copy module instead. You just copy to
  the new file to the new name (checking return values), then delete the old
  one. This isn't really the same semantically as a &quot;rename()&quot;, which
  preserves meta-information like permissions, timestamps, inode info, etc.
<h2 class="Ss" title="Ss" id="How_can_I_lock_a_file?"><a class="selflink" href="#How_can_I_lock_a_file?">How
  can I lock a file?</a></h2>
Perl's builtin <i>flock()</i> function (see perlfunc for details) will call
  <i>flock</i>(2) if that exists, <i>fcntl</i>(2) if it doesn't (on perl version
  5.004 and later), and <i>lockf</i>(3) if neither of the two previous system
  calls exists. On some systems, it may even use a different form of native
  locking. Here are some gotchas with Perl's <i>flock()</i>:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Produces a fatal error if none of the three system calls
      (or their close equivalent) exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag"><i>lockf</i>(3) does not provide shared locking, and
      requires that the filehandle be open for writing (or appending, or
      read/writing).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Some versions of <i>flock()</i> can't lock files over a
      network (e.g. on NFS file systems), so you'd need to force the use of
      <i>fcntl</i>(2) when you build Perl. But even this is dubious at best. See
      the flock entry of perlfunc and the <i>INSTALL</i> file in the source
      distribution for information on building Perl to do this.
    <div style="height: 1.00em;">&#x00A0;</div>
    Two potentially non-obvious but traditional flock semantics are that it
      waits indefinitely until the lock is granted, and that its locks are
      <i>merely advisory</i>. Such discretionary locks are more flexible, but
      offer fewer guarantees. This means that files locked with <i>flock()</i>
      may be modified by programs that do not also use <i>flock()</i>. Cars that
      stop for red lights get on well with each other, but not with cars that
      don't stop for red lights. See the perlport manpage, your port's specific
      documentation, or your system-specific local manpages for details. It's
      best to assume traditional behavior if you're writing portable programs.
      (If you're not, you should as always feel perfectly free to write for your
      own system's idiosyncrasies (sometimes called &quot;features&quot;).
      Slavish adherence to portability concerns shouldn't get in the way of your
      getting your job done.)
    <div style="height: 1.00em;">&#x00A0;</div>
    For more information on file locking, see also &quot;File Locking&quot; in
      perlopentut if you have it (new for 5.6).</dd>
</dl>
<h2 class="Ss" title="Ss" id="Why_can't_I_just_open(FH,_&quot;&gt;file.lock&quot;)?"><a class="selflink" href="#Why_can't_I_just_open(FH,_&quot;&gt;file.lock&quot;)?">Why
  can't I just open(FH, &quot;&gt;file.lock&quot;)?</a></h2>
A common bit of code <b>NOT TO USE</b> is this:
<div class="Pp"></div>
<pre>
    sleep(3) while -e 'file.lock';    # PLEASE DO NOT USE
    open my $lock, '&gt;', 'file.lock'; # THIS BROKEN CODE
</pre>
<div class="Pp"></div>
This is a classic race condition: you take two steps to do something which must
  be done in one. That's why computer hardware provides an atomic test-and-set
  instruction. In theory, this &quot;ought&quot; to work:
<div class="Pp"></div>
<pre>
    sysopen my $fh, &quot;file.lock&quot;, O_WRONLY|O_EXCL|O_CREAT
        or die &quot;can't open  file.lock: $!&quot;;
</pre>
<div class="Pp"></div>
except that lamentably, file creation (and deletion) is not atomic over NFS, so
  this won't work (at least, not every time) over the net. Various schemes
  involving <i>link()</i> have been suggested, but these tend to involve
  busy-wait, which is also less than desirable.
<h2 class="Ss" title="Ss" id="I_still_don't_get_locking._I_just_want_to_increment_the_number_in_the_file._How_can_I_do_this?"><a class="selflink" href="#I_still_don't_get_locking._I_just_want_to_increment_the_number_in_the_file._How_can_I_do_this?">I
  still don't get locking. I just want to increment the number in the file. How
  can I do this?</a></h2>
Didn't anyone ever tell you web-page hit counters were useless? They don't count
  number of hits, they're a waste of time, and they serve only to stroke the
  writer's vanity. It's better to pick a random number; they're more realistic.
<div class="Pp"></div>
Anyway, this is what you can do if you can't help yourself.
<div class="Pp"></div>
<pre>
    use Fcntl qw(:DEFAULT :flock);
    sysopen my $fh, &quot;numfile&quot;, O_RDWR|O_CREAT or die &quot;can't open numfile: $!&quot;;
    flock $fh, LOCK_EX                        or die &quot;can't flock numfile: $!&quot;;
    my $num = &lt;$fh&gt; || 0;
    seek $fh, 0, 0                            or die &quot;can't rewind numfile: $!&quot;;
    truncate $fh, 0                           or die &quot;can't truncate numfile: $!&quot;;
    (print $fh $num+1, &quot;\n&quot;)                  or die &quot;can't write numfile: $!&quot;;
    close $fh                                 or die &quot;can't close numfile: $!&quot;;
</pre>
<div class="Pp"></div>
Here's a much better web-page hit counter:
<div class="Pp"></div>
<pre>
    $hits = int( (time() - 850_000_000) / rand(1_000) );
</pre>
<div class="Pp"></div>
If the count doesn't impress your friends, then the code might. :-)
<h2 class="Ss" title="Ss" id="All_I_want_to_do_is_append_a_small_amount_of_text_to_the_end_of_a_file._Do_I_still_have_to_use_locking?"><a class="selflink" href="#All_I_want_to_do_is_append_a_small_amount_of_text_to_the_end_of_a_file._Do_I_still_have_to_use_locking?">All
  I want to do is append a small amount of text to the end of a file. Do I still
  have to use locking?</a></h2>
If you are on a system that correctly implements &quot;flock&quot; and you use
  the example appending code from &quot;perldoc -f flock&quot; everything will
  be OK even if the OS you are on doesn't implement append mode correctly (if
  such a system exists). So if you are happy to restrict yourself to OSs that
  implement &quot;flock&quot; (and that's not really much of a restriction) then
  that is what you should do.
<div class="Pp"></div>
If you know you are only going to use a system that does correctly implement
  appending (i.e. not Win32) then you can omit the &quot;seek&quot; from the
  code in the previous answer.
<div class="Pp"></div>
If you know you are only writing code to run on an OS and filesystem that does
  implement append mode correctly (a local filesystem on a modern Unix for
  example), and you keep the file in block-buffered mode and you write less than
  one buffer-full of output between each manual flushing of the buffer then each
  bufferload is almost guaranteed to be written to the end of the file in one
  chunk without getting intermingled with anyone else's output. You can also use
  the &quot;syswrite&quot; function which is simply a wrapper around your
  system's write(2) system call.
<div class="Pp"></div>
There is still a small theoretical chance that a signal will interrupt the
  system-level &quot;write()&quot; operation before completion. There is also a
  possibility that some STDIO implementations may call multiple system level
  &quot;write()&quot;s even if the buffer was empty to start. There may be some
  systems where this probability is reduced to zero, and this is not a concern
  when using &quot;:perlio&quot; instead of your system's STDIO.
<h2 class="Ss" title="Ss" id="How_do_I_randomly_update_a_binary_file?"><a class="selflink" href="#How_do_I_randomly_update_a_binary_file?">How
  do I randomly update a binary file?</a></h2>
If you're just trying to patch a binary, in many cases something as simple as
  this works:
<div class="Pp"></div>
<pre>
    perl -i -pe 's{window manager}{window mangler}g' /usr/bin/emacs
</pre>
<div class="Pp"></div>
However, if you have fixed sized records, then you might do something more like
  this:
<div class="Pp"></div>
<pre>
    my $RECSIZE = 220; # size of record, in bytes
    my $recno   = 37;  # which record to update
    open my $fh, '+&lt;', 'somewhere' or die &quot;can't update somewhere: $!&quot;;
    seek $fh, $recno * $RECSIZE, 0;
    read $fh, $record, $RECSIZE == $RECSIZE or die &quot;can't read record $recno: $!&quot;;
    # munge the record
    seek $fh, -$RECSIZE, 1;
    print $fh $record;
    close $fh;
</pre>
<div class="Pp"></div>
Locking and error checking are left as an exercise for the reader. Don't forget
  them or you'll be quite sorry.
<h2 class="Ss" title="Ss" id="How_do_I_get_a_file's_timestamp_in_perl?"><a class="selflink" href="#How_do_I_get_a_file's_timestamp_in_perl?">How
  do I get a file's timestamp in perl?</a></h2>
If you want to retrieve the time at which the file was last read, written, or
  had its meta-data (owner, etc) changed, you use the <b>-A</b>, <b>-M</b>, or
  <b>-C</b> file test operations as documented in perlfunc. These retrieve the
  age of the file (measured against the start-time of your program) in days as a
  floating point number. Some platforms may not have all of these times. See
  perlport for details. To retrieve the &quot;raw&quot; time in seconds since
  the epoch, you would call the stat function, then use &quot;localtime()&quot;,
  &quot;gmtime()&quot;, or &quot;POSIX::strftime()&quot; to convert this into
  human-readable form.
<div class="Pp"></div>
Here's an example:
<div class="Pp"></div>
<pre>
    my $write_secs = (stat($file))[9];
    printf &quot;file %s updated at %s\n&quot;, $file,
        scalar localtime($write_secs);
</pre>
<div class="Pp"></div>
If you prefer something more legible, use the File::stat module (part of the
  standard distribution in version 5.004 and later):
<div class="Pp"></div>
<pre>
    # error checking left as an exercise for reader.
    use File::stat;
    use Time::localtime;
    my $date_string = ctime(stat($file)-&gt;mtime);
    print &quot;file $file updated at $date_string\n&quot;;
</pre>
<div class="Pp"></div>
The <i>POSIX::strftime()</i> approach has the benefit of being, in theory,
  independent of the current locale. See perllocale for details.
<h2 class="Ss" title="Ss" id="How_do_I_set_a_file's_timestamp_in_perl?"><a class="selflink" href="#How_do_I_set_a_file's_timestamp_in_perl?">How
  do I set a file's timestamp in perl?</a></h2>
You use the <i>utime()</i> function documented in &quot;utime&quot; in perlfunc.
  By way of example, here's a little program that copies the read and write
  times from its first argument to all the rest of them.
<div class="Pp"></div>
<pre>
    if (@ARGV &lt; 2) {
        die &quot;usage: cptimes timestamp_file other_files ...\n&quot;;
    }
    my $timestamp = shift;
    my($atime, $mtime) = (stat($timestamp))[8,9];
    utime $atime, $mtime, @ARGV;
</pre>
<div class="Pp"></div>
Error checking is, as usual, left as an exercise for the reader.
<div class="Pp"></div>
The perldoc for utime also has an example that has the same effect as
  <i>touch</i>(1) on files that <i>already exist</i>.
<div class="Pp"></div>
Certain file systems have a limited ability to store the times on a file at the
  expected level of precision. For example, the FAT and HPFS filesystem are
  unable to create dates on files with a finer granularity than two seconds.
  This is a limitation of the filesystems, not of <i>utime()</i>.
<h2 class="Ss" title="Ss" id="How_do_I_print_to_more_than_one_file_at_once?"><a class="selflink" href="#How_do_I_print_to_more_than_one_file_at_once?">How
  do I print to more than one file at once?</a></h2>
To connect one filehandle to several output filehandles, you can use the IO::Tee
  or Tie::FileHandle::Multiplex modules.
<div class="Pp"></div>
If you only have to do this once, you can print individually to each filehandle.
<div class="Pp"></div>
<pre>
    for my $fh ($fh1, $fh2, $fh3) { print $fh &quot;whatever\n&quot; }
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_read_in_an_entire_file_all_at_once?"><a class="selflink" href="#How_can_I_read_in_an_entire_file_all_at_once?">How
  can I read in an entire file all at once?</a></h2>
The customary Perl approach for processing all the lines in a file is to do so
  one line at a time:
<div class="Pp"></div>
<pre>
    open my $input, '&lt;', $file or die &quot;can't open $file: $!&quot;;
    while (&lt;$input&gt;) {
        chomp;
        # do something with $_
    }
    close $input or die &quot;can't close $file: $!&quot;;
</pre>
<div class="Pp"></div>
This is tremendously more efficient than reading the entire file into memory as
  an array of lines and then processing it one element at a time, which is
  often--if not almost always--the wrong approach. Whenever you see someone do
  this:
<div class="Pp"></div>
<pre>
    my @lines = &lt;INPUT&gt;;
</pre>
<div class="Pp"></div>
You should think long and hard about why you need everything loaded at once.
  It's just not a scalable solution.
<div class="Pp"></div>
If you &quot;mmap&quot; the file with the File::Map module from CPAN, you can
  virtually load the entire file into a string without actually storing it in
  memory:
<div class="Pp"></div>
<pre>
    use File::Map qw(map_file);
    map_file my $string, $filename;
</pre>
<div class="Pp"></div>
Once mapped, you can treat $string as you would any other string. Since you
  don't necessarily have to load the data, mmap-ing can be very fast and may not
  increase your memory footprint.
<div class="Pp"></div>
You might also find it more fun to use the standard Tie::File module, or the
  DB_File module's $DB_RECNO bindings, which allow you to tie an array to a file
  so that accessing an element of the array actually accesses the corresponding
  line in the file.
<div class="Pp"></div>
If you want to load the entire file, you can use the File::Slurp module to do it
  in one one simple and efficient step:
<div class="Pp"></div>
<pre>
    use File::Slurp;
    my $all_of_it = read_file($filename); # entire file in scalar
    my @all_lines = read_file($filename); # one line per element
</pre>
<div class="Pp"></div>
Or you can read the entire file contents into a scalar like this:
<div class="Pp"></div>
<pre>
    my $var;
    {
        local $/;
        open my $fh, '&lt;', $file or die &quot;can't open $file: $!&quot;;
        $var = &lt;$fh&gt;;
    }
</pre>
<div class="Pp"></div>
That temporarily undefs your record separator, and will automatically close the
  file at block exit. If the file is already open, just use this:
<div class="Pp"></div>
<pre>
    my $var = do { local $/; &lt;$fh&gt; };
</pre>
<div class="Pp"></div>
You can also use a localized @ARGV to eliminate the &quot;open&quot;:
<div class="Pp"></div>
<pre>
    my $var = do { local( @ARGV, $/ ) = $file; &lt;&gt; };
</pre>
<div class="Pp"></div>
For ordinary files you can also use the &quot;read&quot; function.
<div class="Pp"></div>
<pre>
    read( $fh, $var, -s $fh );
</pre>
<div class="Pp"></div>
That third argument tests the byte size of the data on the $fh filehandle and
  reads that many bytes into the buffer $var.
<h2 class="Ss" title="Ss" id="How_can_I_read_in_a_file_by_paragraphs?"><a class="selflink" href="#How_can_I_read_in_a_file_by_paragraphs?">How
  can I read in a file by paragraphs?</a></h2>
Use the $/ variable (see perlvar for details). You can either set it to
  &quot;&quot; to eliminate empty paragraphs (&quot;abc\n\n\n\ndef&quot;, for
  instance, gets treated as two paragraphs and not three), or &quot;\n\n&quot;
  to accept empty paragraphs.
<div class="Pp"></div>
Note that a blank line must have no blanks in it. Thus
  &quot;fred\n&#x00A0;\nstuff\n\n&quot; is one paragraph, but
  &quot;fred\n\nstuff\n\n&quot; is two.
<h2 class="Ss" title="Ss" id="How_can_I_read_a_single_character_from_a_file?_From_the_keyboard?"><a class="selflink" href="#How_can_I_read_a_single_character_from_a_file?_From_the_keyboard?">How
  can I read a single character from a file? From the keyboard?</a></h2>
You can use the builtin &quot;getc()&quot; function for most filehandles, but it
  won't (easily) work on a terminal device. For STDIN, either use the
  Term::ReadKey module from CPAN or use the sample code in &quot;getc&quot; in
  perlfunc.
<div class="Pp"></div>
If your system supports the portable operating system programming interface
  (POSIX), you can use the following code, which you'll note turns off echo
  processing as well.
<div class="Pp"></div>
<pre>
    #!/usr/bin/perl -w
    use strict;
    $| = 1;
    for (1..4) {
        print &quot;gimme: &quot;;
        my $got = getone();
        print &quot;--&gt; $got\n&quot;;
    }
    exit;
    BEGIN {
        use POSIX qw(:termios_h);
        my ($term, $oterm, $echo, $noecho, $fd_stdin);
        my $fd_stdin = fileno(STDIN);
        $term     = POSIX::Termios-&gt;new();
        $term-&gt;getattr($fd_stdin);
        $oterm     = $term-&gt;getlflag();
        $echo     = ECHO | ECHOK | ICANON;
        $noecho   = $oterm &amp; ~$echo;
        sub cbreak {
            $term-&gt;setlflag($noecho);
            $term-&gt;setcc(VTIME, 1);
            $term-&gt;setattr($fd_stdin, TCSANOW);
        }
        sub cooked {
            $term-&gt;setlflag($oterm);
            $term-&gt;setcc(VTIME, 0);
            $term-&gt;setattr($fd_stdin, TCSANOW);
        }
        sub getone {
            my $key = '';
            cbreak();
            sysread(STDIN, $key, 1);
            cooked();
            return $key;
        }
    }
    END { cooked() }
</pre>
<div class="Pp"></div>
The Term::ReadKey module from CPAN may be easier to use. Recent versions include
  also support for non-portable systems as well.
<div class="Pp"></div>
<pre>
    use Term::ReadKey;
    open my $tty, '&lt;', '/dev/tty';
    print &quot;Gimme a char: &quot;;
    ReadMode &quot;raw&quot;;
    my $key = ReadKey 0, $tty;
    ReadMode &quot;normal&quot;;
    printf &quot;\nYou said %s, char number %03d\n&quot;,
        $key, ord $key;
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_tell_whether_there's_a_character_waiting_on_a_filehandle?"><a class="selflink" href="#How_can_I_tell_whether_there's_a_character_waiting_on_a_filehandle?">How
  can I tell whether there's a character waiting on a filehandle?</a></h2>
The very first thing you should do is look into getting the Term::ReadKey
  extension from CPAN. As we mentioned earlier, it now even has limited support
  for non-portable (read: not open systems, closed, proprietary, not POSIX, not
  Unix, etc.) systems.
<div class="Pp"></div>
You should also check out the Frequently Asked Questions list in comp.unix.* for
  things like this: the answer is essentially the same. It's very
  system-dependent. Here's one solution that works on BSD systems:
<div class="Pp"></div>
<pre>
    sub key_ready {
        my($rin, $nfd);
        vec($rin, fileno(STDIN), 1) = 1;
        return $nfd = select($rin,undef,undef,0);
    }
</pre>
<div class="Pp"></div>
If you want to find out how many characters are waiting, there's also the
  FIONREAD ioctl call to be looked at. The <i>h2ph</i> tool that comes with Perl
  tries to convert C include files to Perl code, which can be
  &quot;require&quot;d. FIONREAD ends up defined as a function in the
  <i>sys/ioctl.ph</i> file:
<div class="Pp"></div>
<pre>
    require 'sys/ioctl.ph';
    $size = pack(&quot;L&quot;, 0);
    ioctl(FH, FIONREAD(), $size)    or die &quot;Couldn't call ioctl: $!\n&quot;;
    $size = unpack(&quot;L&quot;, $size);
</pre>
<div class="Pp"></div>
If <i>h2ph</i> wasn't installed or doesn't work for you, you can <i>grep</i> the
  include files by hand:
<div class="Pp"></div>
<pre>
    % grep FIONREAD /usr/include/*/*
    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B
</pre>
<div class="Pp"></div>
Or write a small C program using the editor of champions:
<div class="Pp"></div>
<pre>
    % cat &gt; fionread.c
    #include &lt;sys/ioctl.h&gt;
    main() {
        printf(&quot;%#08x\n&quot;, FIONREAD);
    }
    ^D
    % cc -o fionread fionread.c
    % ./fionread
    0x4004667f
</pre>
<div class="Pp"></div>
And then hard-code it, leaving porting as an exercise to your successor.
<div class="Pp"></div>
<pre>
    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
    $size = pack(&quot;L&quot;, 0);
    ioctl(FH, $FIONREAD, $size)     or die &quot;Couldn't call ioctl: $!\n&quot;;
    $size = unpack(&quot;L&quot;, $size);
</pre>
<div class="Pp"></div>
FIONREAD requires a filehandle connected to a stream, meaning that sockets,
  pipes, and tty devices work, but <i>not</i> files.
<h2 class="Ss" title="Ss" id="How_do_I_do_a_&quot;tail_-f&quot;_in_perl?"><a class="selflink" href="#How_do_I_do_a_&quot;tail_-f&quot;_in_perl?">How
  do I do a &quot;tail -f&quot; in perl?</a></h2>
First try
<div class="Pp"></div>
<pre>
    seek($gw_fh, 0, 1);
</pre>
<div class="Pp"></div>
The statement &quot;seek($gw_fh, 0, 1)&quot; doesn't change the current
  position, but it does clear the end-of-file condition on the handle, so that
  the next &quot;&lt;$gw_fh&gt;&quot; makes Perl try again to read something.
<div class="Pp"></div>
If that doesn't work (it relies on features of your stdio implementation), then
  you need something more like this:
<div class="Pp"></div>
<pre>
    for (;;) {
      for ($curpos = tell($gw_fh); &lt;$gw_fh&gt;; $curpos =tell($gw_fh)) {
        # search for some stuff and put it into files
      }
      # sleep for a while
      seek($gw_fh, $curpos, 0);  # seek to where we had been
    }
</pre>
<div class="Pp"></div>
If this still doesn't work, look into the &quot;clearerr&quot; method from
  IO::Handle, which resets the error and end-of-file states on the handle.
<div class="Pp"></div>
There's also a File::Tail module from CPAN.
<h2 class="Ss" title="Ss" id="How_do_I_dup()_a_filehandle_in_Perl?"><a class="selflink" href="#How_do_I_dup()_a_filehandle_in_Perl?">How
  do I <i>dup()</i> a filehandle in Perl?</a></h2>
If you check &quot;open&quot; in perlfunc, you'll see that several of the ways
  to call <i>open()</i> should do the trick. For example:
<div class="Pp"></div>
<pre>
    open my $log, '&gt;&gt;', '/foo/logfile';
    open STDERR, '&gt;&amp;', $log;
</pre>
<div class="Pp"></div>
Or even with a literal numeric descriptor:
<div class="Pp"></div>
<pre>
    my $fd = $ENV{MHCONTEXTFD};
    open $mhcontext, &quot;&lt;&amp;=$fd&quot;;  # like fdopen(3S)
</pre>
<div class="Pp"></div>
Note that &quot;&lt;&amp;STDIN&quot; makes a copy, but
  &quot;&lt;&amp;=STDIN&quot; makes an alias. That means if you close an aliased
  handle, all aliases become inaccessible. This is not true with a copied one.
<div class="Pp"></div>
Error checking, as always, has been left as an exercise for the reader.
<h2 class="Ss" title="Ss" id="How_do_I_close_a_file_descriptor_by_number?"><a class="selflink" href="#How_do_I_close_a_file_descriptor_by_number?">How
  do I close a file descriptor by number?</a></h2>
If, for some reason, you have a file descriptor instead of a filehandle (perhaps
  you used &quot;POSIX::open&quot;), you can use the &quot;close()&quot;
  function from the POSIX module:
<div class="Pp"></div>
<pre>
    use POSIX ();
    POSIX::close( $fd );
</pre>
<div class="Pp"></div>
This should rarely be necessary, as the Perl &quot;close()&quot; function is to
  be used for things that Perl opened itself, even if it was a dup of a numeric
  descriptor as with &quot;MHCONTEXT&quot; above. But if you really have to, you
  may be able to do this:
<div class="Pp"></div>
<pre>
    require 'sys/syscall.ph';
    my $rc = syscall(&amp;SYS_close, $fd + 0);  # must force numeric
    die &quot;can't sysclose $fd: $!&quot; unless $rc == -1;
</pre>
<div class="Pp"></div>
Or, just use the fdopen(3S) feature of &quot;open()&quot;:
<div class="Pp"></div>
<pre>
    {
        open my $fh, &quot;&lt;&amp;=$fd&quot; or die &quot;Cannot reopen fd=$fd: $!&quot;;
        close $fh;
    }
</pre>
<h2 class="Ss" title="Ss" id="Why_can't_I_use_&quot;C:\temp\foo&quot;_in_DOS_paths?_Why_doesn't_`C:\temp\foo.exe`_work?"><a class="selflink" href="#Why_can't_I_use_&quot;C:\temp\foo&quot;_in_DOS_paths?_Why_doesn't_`C:\temp\foo.exe`_work?">Why
  can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't
  `C:\temp\foo.exe` work?</a></h2>
Whoops! You just put a tab and a formfeed into that filename! Remember that
  within double quoted strings (&quot;like\this&quot;), the backslash is an
  escape character. The full list of these is in &quot;Quote and Quote-like
  Operators&quot; in perlop. Unsurprisingly, you don't have a file called
  &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot;
  on your legacy DOS filesystem.
<div class="Pp"></div>
Either single-quote your strings, or (preferably) use forward slashes. Since all
  DOS and Windows versions since something like MS-DOS 2.0 or so have treated
  &quot;/&quot; and &quot;\&quot; the same in a path, you might as well use the
  one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++, awk,
  Tcl, Java, or Python, just to mention a few. POSIX paths are more portable,
  too.
<h2 class="Ss" title="Ss" id="Why_doesn't_glob(&quot;*.*&quot;)_get_all_the_files?"><a class="selflink" href="#Why_doesn't_glob(&quot;*.*&quot;)_get_all_the_files?">Why
  doesn't glob(&quot;*.*&quot;) get all the files?</a></h2>
Because even on non-Unix ports, Perl's glob function follows standard Unix
  globbing semantics. You'll need &quot;glob(&quot;*&quot;)&quot; to get all
  (non-hidden) files. This makes <i>glob()</i> portable even to legacy systems.
  Your port may include proprietary globbing functions as well. Check its
  documentation for details.
<h2 class="Ss" title="Ss" id="Why_does_Perl_let_me_delete_read-only_files?_Why_does_&quot;-i&quot;_clobber_protected_files?_Isn't_this_a_bug_in_Perl?"><a class="selflink" href="#Why_does_Perl_let_me_delete_read-only_files?_Why_does_&quot;-i&quot;_clobber_protected_files?_Isn't_this_a_bug_in_Perl?">Why
  does Perl let me delete read-only files? Why does &quot;-i&quot; clobber
  protected files? Isn't this a bug in Perl?</a></h2>
This is elaborately and painstakingly described in the <i>file-dir-perms</i>
  article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in
  &lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; .
<div class="Pp"></div>
The executive summary: learn how your filesystem works. The permissions on a
  file say what can happen to the data in that file. The permissions on a
  directory say what can happen to the list of files in that directory. If you
  delete a file, you're removing its name from the directory (so the operation
  depends on the permissions of the directory, not of the file). If you try to
  write to the file, the permissions of the file govern whether you're allowed
  to.
<h2 class="Ss" title="Ss" id="How_do_I_select_a_random_line_from_a_file?"><a class="selflink" href="#How_do_I_select_a_random_line_from_a_file?">How
  do I select a random line from a file?</a></h2>
Short of loading the file into a database or pre-indexing the lines in the file,
  there are a couple of things that you can do.
<div class="Pp"></div>
Here's a reservoir-sampling algorithm from the Camel Book:
<div class="Pp"></div>
<pre>
    srand;
    rand($.) &lt; 1 &amp;&amp; ($line = $_) while &lt;&gt;;
</pre>
<div class="Pp"></div>
This has a significant advantage in space over reading the whole file in. You
  can find a proof of this method in <i>The Art of Computer</i>
  <i>Programming</i>, Volume 2, Section 3.4.2, by Donald E. Knuth.
<div class="Pp"></div>
You can use the File::Random module which provides a function for that
  algorithm:
<div class="Pp"></div>
<pre>
    use File::Random qw/random_line/;
    my $line = random_line($filename);
</pre>
<div class="Pp"></div>
Another way is to use the Tie::File module, which treats the entire file as an
  array. Simply access a random array element.
<h2 class="Ss" title="Ss" id="Why_do_I_get_weird_spaces_when_I_print_an_array_of_lines?"><a class="selflink" href="#Why_do_I_get_weird_spaces_when_I_print_an_array_of_lines?">Why
  do I get weird spaces when I print an array of lines?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
If you are seeing spaces between the elements of your array when you print the
  array, you are probably interpolating the array in double quotes:
<div class="Pp"></div>
<pre>
    my @animals = qw(camel llama alpaca vicuna);
    print &quot;animals are: @animals\n&quot;;
</pre>
<div class="Pp"></div>
It's the double quotes, not the &quot;print&quot;, doing this. Whenever you
  interpolate an array in a double quote context, Perl joins the elements with
  spaces (or whatever is in $&quot;, which is a space by default):
<div class="Pp"></div>
<pre>
    animals are: camel llama alpaca vicuna
</pre>
<div class="Pp"></div>
This is different than printing the array without the interpolation:
<div class="Pp"></div>
<pre>
    my @animals = qw(camel llama alpaca vicuna);
    print &quot;animals are: &quot;, @animals, &quot;\n&quot;;
</pre>
<div class="Pp"></div>
Now the output doesn't have the spaces between the elements because the elements
  of @animals simply become part of the list to &quot;print&quot;:
<div class="Pp"></div>
<pre>
    animals are: camelllamaalpacavicuna
</pre>
<div class="Pp"></div>
You might notice this when each of the elements of @array end with a newline.
  You expect to print one element per line, but notice that every line after the
  first is indented:
<div class="Pp"></div>
<pre>
    this is a line
     this is another line
     this is the third line
</pre>
<div class="Pp"></div>
That extra space comes from the interpolation of the array. If you don't want to
  put anything between your array elements, don't use the array in double
  quotes. You can send it to print without them:
<div class="Pp"></div>
<pre>
    print @lines;
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_traverse_a_directory_tree?"><a class="selflink" href="#How_do_I_traverse_a_directory_tree?">How
  do I traverse a directory tree?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
The File::Find module, which comes with Perl, does all of the hard work to
  traverse a directory structure. It comes with Perl. You simply call the
  &quot;find&quot; subroutine with a callback subroutine and the directories you
  want to traverse:
<div class="Pp"></div>
<pre>
    use File::Find;
    find( \&amp;wanted, @directories );
    sub wanted {
        # full path in $File::Find::name
        # just filename in $_
        ... do whatever you want to do ...
    }
</pre>
<div class="Pp"></div>
The File::Find::Closures, which you can download from CPAN, provides many
  ready-to-use subroutines that you can use with File::Find.
<div class="Pp"></div>
The File::Finder, which you can download from CPAN, can help you create the
  callback subroutine using something closer to the syntax of the
  &quot;find&quot; command-line utility:
<div class="Pp"></div>
<pre>
    use File::Find;
    use File::Finder;
    my $deep_dirs = File::Finder-&gt;depth-&gt;type('d')-&gt;ls-&gt;exec('rmdir','{}');
    find( $deep_dirs-&gt;as_options, @places );
</pre>
<div class="Pp"></div>
The File::Find::Rule module, which you can download from CPAN, has a similar
  interface, but does the traversal for you too:
<div class="Pp"></div>
<pre>
    use File::Find::Rule;
    my @files = File::Find::Rule-&gt;file()
                             -&gt;name( '*.pm' )
                             -&gt;in( @INC );
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_delete_a_directory_tree?"><a class="selflink" href="#How_do_I_delete_a_directory_tree?">How
  do I delete a directory tree?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
If you have an empty directory, you can use Perl's built-in &quot;rmdir&quot;.
  If the directory is not empty (so, no files or subdirectories), you either
  have to empty it yourself (a lot of work) or use a module to help you.
<div class="Pp"></div>
The File::Path module, which comes with Perl, has a &quot;remove_tree&quot;
  which can take care of all of the hard work for you:
<div class="Pp"></div>
<pre>
    use File::Path qw(remove_tree);
    remove_tree( @directories );
</pre>
<div class="Pp"></div>
The File::Path module also has a legacy interface to the older
  &quot;rmtree&quot; subroutine.
<h2 class="Ss" title="Ss" id="How_do_I_copy_an_entire_directory?"><a class="selflink" href="#How_do_I_copy_an_entire_directory?">How
  do I copy an entire directory?</a></h2>
(contributed by Shlomi Fish)
<div class="Pp"></div>
To do the equivalent of &quot;cp -R&quot; (i.e. copy an entire directory tree
  recursively) in portable Perl, you'll either need to write something yourself
  or find a good CPAN module such as File::Copy::Recursive.
<h1 class="Sh" title="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="selflink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and other authors
  as noted. All rights reserved.
<div class="Pp"></div>
This documentation is free; you can redistribute it and/or modify it under the
  same terms as Perl itself.
<div class="Pp"></div>
Irrespective of its distribution, all code examples here are in the public
  domain. You are permitted and encouraged to use this code and any derivatives
  thereof in your own programs for fun or for profit as you see fit. A simple
  comment in the code giving credit to the FAQ would be courteous but is not
  required.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
