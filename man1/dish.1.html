<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:04:15 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DISH(1) User Commands DISH(1)</p>

<p style="margin-top: 1em">NAME <br>
dish - tool for parallel sysadmin of multiple hosts</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dish [option]... -e command {-g hosts_file | host_1 host_2
...} <br>
dicp {-g hosts_file | -g &quot;user@host_1 ...&quot;}
local_file :remote_file <br>
dicp {-g hosts_file | -g &quot;user@host_1 ...&quot;}
:remote_file local_file</p>

<p style="margin-top: 1em">DESCRIPTION <br>
dish - the diligence shell executes commands on several
hosts via ssh/rsh/telnet, and also makes easy the
distribution of files by scp/rcp, a remote password change,
etc. It can <br>
process hosts in parallel mode.</p>

<p style="margin-top: 1em">OPTIONS <br>
-h Print help message describing shortly all command-line
options</p>

<p style="margin-top: 1em">-H, --help <br>
Comprehensive help including examples</p>

<p style="margin-top: 1em">--version <br>
Print program version and copyright message, then exit</p>

<p style="margin-top: 1em">-V Display the version number
and exit</p>

<p style="margin-top: 1em">-C &lt;dir&gt; <br>
Configuration directory - $HOME/.dish is default; In this
directory are located following configuration files:
&rsquo;hosts&rsquo;, &rsquo;rests&rsquo;,
&rsquo;pass&rsquo;, and &rsquo;options&rsquo;. When used,
this <br>
option must be the first argument in the command line
string, or be the second one if &lsquo;-D&rsquo; chosen!
Alternatively, one can specify the configuration directory
by defining <br>
the environment variable DISH_CONF.</p>

<p style="margin-top: 1em">-CC &lt;dir&gt; <br>
Same as &lsquo;-C&rsquo; with fallback to default if local
config not found; This means that, in case the files
&rsquo;pass&rsquo;, &rsquo;options&rsquo; or
&rsquo;rests&rsquo; are absent in the given directory, but
<br>
such files exist in $HOME/.dish, the latter will be
considered. The only exception is
&rsquo;$HOME/.dish/hosts&rsquo; which will be ignored. Using
this option is equivalent to chang&acirc; <br>
ing directory to the opted one and then executing
&lsquo;dish&rsquo;.</p>

<p style="margin-top: 1em">-c &lt;name&gt; <br>
Program (alias &quot;connector&quot;) and its options used
for connecting to the remote host(s) - for example
&lsquo;rsh&rsquo;, whereas the spawned process will be
&quot;rsh $host &lt;cmd&gt;&quot;. Your <br>
default connector is &lsquo;ssh&rsquo;. Furthermore, by
using a relevant text-based client as connector, one can
access various kinds of hosts - switches, databases, and so
on.</p>

<p style="margin-top: 1em">-e &lt;cmd&gt; <br>
Remote command to execute; It can be also set by the
environment variable DISH_CMD.</p>

<p style="margin-top: 1em">-E &lt;cmd&gt; <br>
Execute command where also the connection part is specified
e.g. &quot;-E &rsquo;ssh $host date&rsquo;&quot; which is
equal to &quot;-e date&quot;. This option is incompatible
with &lsquo;-c&rsquo; and &lsquo;-e&rsquo;. It can <br>
be also set by the environment variable DISH_FUEXE.</p>

<p style="margin-top: 1em">-t Force pseudo-tty allocation
in ssh; This happens automatically in case of password
change.</p>

<p style="margin-top: 1em">-T &lt;time&gt; <br>
Timeout for command execution - default 30s (per host)</p>

<p style="margin-top: 1em">-TT &lt;time&gt; <br>
Total timeout for command execution - default 300s (all
hosts); This option is useful only when hosts are processed
in sequence and the total processing time should not <br>
exceed the specified upper bound.</p>

<p style="margin-top: 1em">-x &lt;regex&gt; <br>
Regular expression for the shell prompt; This value
specifies which prompt is to be expected in the
program&rsquo;s shell after login into a system by
&lsquo;telnet&rsquo;, &lsquo;mysql&rsquo;, <br>
&lsquo;sqlplus&rsquo; or other interactive command-line
clients (see &lsquo;-c&rsquo;). The default value is
&lsquo;(%|#|&gt;) ?$&rsquo;.</p>

<p style="margin-top: 1em">-X &lt;regex&gt; <br>
Regular expression for the password prompt; It is
case-insensitive with default value &lsquo;Password:
*$&rsquo;.</p>

<p style="margin-top: 1em">-AD &lt;regex&gt; <br>
Regular expression for the ssh-prompt to add a new host key
- &lsquo;connecting (yes/no)?.*&rsquo; is default</p>

<p style="margin-top: 1em">-AC &lt;str&gt; <br>
String with the answer to the ssh-prompt to add a new host
key - &lsquo;yes&rsquo; is default</p>

<p style="margin-top: 1em">-g &lt;file&gt; <br>
File with list of hosts/ip&rsquo;s/accounts to target; The
command will be executed on these targets. The default host
file is &rsquo;$HOME/.dish/hosts&rsquo; - normally per line
one <br>
account of the form &quot;user@host&quot; (if ssh is your
choice for connector). In order to join lists use the option
repeatedly. Alternatively, the environment variable <br>
DISH_HOSTS could be used to define the target hosts whereas
in the specified string they have to be separated by blanks.
By combining this option with &lsquo;-r&rsquo; or
&lsquo;-i&rsquo; you can <br>
define various subsets of targeted hosts/accounts.</p>

<p style="margin-top: 1em">-r &lt;file&gt; <br>
File with list of resting hosts/accounts to exclude; The
default one is &rsquo;$HOME/.dish/rests&rsquo;. A
&quot;resting host&quot; means one which will be excluded
from the targets. The list <br>
of resting hosts or the file name could be specified also by
the environment variable DISH_RESTS.</p>

<p style="margin-top: 1em">-i &lt;file&gt; <br>
File with list of hosts/accounts to overlap with targeted
hosts; There is no default file. Only overlapping hosts,
such included in this list and at the same time defined <br>
as targets, will be processed.</p>

<p style="margin-top: 1em">-u &lt;name&gt; <br>
User name - default is your local user name; It can be
defined also by the environment variable DISH_USER.
Internally the value is accessible by the variable $user
(see <br>
examples). Further, it is irrelevant in case that accounts
of the form &quot;user@host&quot; are processed since they
include already the user name.</p>

<p style="margin-top: 1em">-p &lt;passwd&gt; <br>
Login password (-p &quot;&quot; = -pp = -a0) - alias
&quot;login authentic&quot; or &quot;a0&quot;; If no
authentication for login is required (no user- and no
password-prompt appear), then use <br>
&lsquo;/dev/null&rsquo; as password. If the user name is
requested, yet the password is an empty string, then
&lsquo;/dev/empty&rsquo; has to be given as password. The
value of this option could <br>
be also a password file (see &lsquo;-P&rsquo;). Eventually,
one can define the password by the environment variable
DISH_PASS.</p>

<p style="margin-top: 1em">-a &lt;passwd&gt; <br>
Additional password for authentication (-a &quot;&quot; =
-aa = -a1) - alias &quot;first authentic&quot; or
&quot;a1&quot;; Inside the spawn process, if a program like
&lsquo;smbmount&rsquo;, &lsquo;su&rsquo;, &lsquo;ssh&rsquo;,
etc. <br>
asks for authentication, the a1-password is passed to it.
This password can be also set by the environment variable
DISH_PASS1.</p>

<p style="margin-top: 1em">-A &lt;passwd&gt; <br>
One more password for authentication (-A &quot;&quot; = -AA
= -a2) - alias &quot;second authentic&quot; or
&quot;a2&quot;; When a spawned process, after one
authentication by the a1-password, asks <br>
again for a password, then a2 is sent. This password can be
also set by the environment variable DISH_PASS2.</p>

<p style="margin-top: 1em">-n &lt;passwd&gt; <br>
New password in case of password change (-n &quot;&quot; =
-nn = -ne)</p>

<p style="margin-top: 1em">-p0 Login without authentication
- the same as &lsquo;-p /dev/null&rsquo;</p>

<p style="margin-top: 1em">-p1 Set the a1-password to be
the same as the login password; This option should not be
used together with &lsquo;-p0&rsquo; and &lsquo;-a1&rsquo;.
See example d) bellow.</p>

<p style="margin-top: 1em">-P &lt;file&gt; <br>
File with password(s); The default password file is
&rsquo;$HOME/.dish/pass&rsquo;. It must be readable only for
the user (file mode 600 or 700), otherwise the program exits
with <br>
error, but see also next option. Every line in the file can
hold a password entry of the form:
&quot;password:username:hostname&quot;, alternatively
&quot;password:::username:::host&acirc; <br>
name&quot;, or &quot;password;;;username;;;hostname&quot;.
One can specify a list of hosts separated by the
&lsquo;,&rsquo; or &lsquo;;&rsquo; characters. Regular
expressions for hostnames are also allowed <br>
(see the example configuration files in the
distribution).</p>

<p style="margin-top: 1em">-m Ignore the access permissions
of the password file</p>

<p style="margin-top: 1em">-s [&lt;time&gt;] <br>
Sequential processing of hosts (default mode); If a time
interval (measured in floating seconds) is specified, then
the program is waiting this amount of time before <br>
starting to process the next host in the sequence.</p>

<p style="margin-top: 1em">-F Spawn processes in background
- fork and disconnect; This way all hosts are processed
essentially in parallel! It&rsquo;s a very powerful option -
depending on you RAM size and <br>
memory utilization, it shouldn&rsquo;t be a problem to
process a few hundreds of hosts in parallel. Anyway, be
careful - if you have too many hosts on the list, your could
put <br>
your system under load. The stdout&rsquo;s of the background
processes are redirected to &rsquo;/dev/null&rsquo;, however
you can use &lsquo;-l&rsquo; or &lsquo;-L&rsquo; to write
the output to files. See also <br>
&rsquo;bugs and known problems&rsquo; in the manual
page.</p>

<p style="margin-top: 1em">-f Spawn processes in background
without disconnecting from tty; It&rsquo;s the same as
&lsquo;-F&rsquo; whereas the stdout&rsquo;s of the spawned
processes are sent to the terminal. Also the parent <br>
process waits for his children to finish. See also
&rsquo;bugs and known problems&rsquo; in the manual
page.</p>

<p style="margin-top: 1em">-q Be quiet - skip output from
spawn and login; When working with the secure shell, it is
also convenient to use &lsquo;ssh&rsquo; with the
&lsquo;-q&rsquo; option.</p>

<p style="margin-top: 1em">-Q Be QUIET - skip any
output</p>

<p style="margin-top: 1em">-v Be verbose (default) -
overrides &lsquo;-q&rsquo; and &lsquo;-Q&rsquo;</p>

<p style="margin-top: 1em">-l &lt;file&gt; <br>
Log command output to file; The output of the spawned
processes is appended to the file.</p>

<p style="margin-top: 1em">-L &lt;name&gt; <br>
Write a separate log for every host where &lt;name&gt;
denotes the base name of the log file. The full name of a
log file is defined as
&quot;&lt;name&gt;_&lt;user@host&gt;.log&quot;.</p>

<p style="margin-top: 1em">-j Record the invoked command
into a journal file with the name
&rsquo;$HOME/.dish/journal&rsquo;; It keeps the history of
the executed commands and their time of execution. An unique
<br>
identifier is associated with every command.</p>

<p style="margin-top: 1em">-J Record the invoked command
and the spawned processes as well; Write into the journal
file the executed command as well as the single processes
spawned and their time of <br>
execution.</p>

<p style="margin-top: 1em">-o &lt;file&gt; <br>
File with command line options passed to the program -
default is &rsquo;$HOME/.dish/options&rsquo;; The options
must be written in the file separated - one per line. By
means of this <br>
file, one can modify the standard configuration: set up fork
mode to be default, change the default connector, and so
forth. When working in &quot;copy mode&quot;, i.e. by
invoking <br>
the program as &rsquo;dicp&rsquo;,
&rsquo;$HOME/.dish/options.dicp&rsquo; is considered to be
the default options file.</p>

<p style="margin-top: 1em">-d enable expect&rsquo;s
diagnostic output (look at &lsquo;man expect&rsquo;)</p>

<p style="margin-top: 1em">-D Debug mode (dry-run); Print
out environment variables, config file names, and commands
to execute, then exit. This option should be used as first
in the command line.</p>

<p style="margin-top: 1em">EXAMPLES <br>
You should consider that the variables $host and $user are
evaluated. Thus $host changes dynamically its value to the
actual host/account name before a new process is spawned.
<br>
The same is true for $user.</p>

<p style="margin-top: 1em">a) Check the date and uptime on
hosts 192.168.0.1 and 192.168.0.2</p>

<p style="margin-top: 1em">dish -e &rsquo;date ;
uptime&rsquo; root@192.168.0.1 root@192.168.0.2</p>

<p style="margin-top: 1em">b) Distribute
&rsquo;.profile&rsquo; and &rsquo;.bashrc&rsquo; to guest
accounts on &rsquo;host1&rsquo; and &rsquo;host2&rsquo;</p>

<p style="margin-top: 1em">dish -E &quot;scp $HOME/.profile
$HOME/.bashrc guest@ost:&quot; host1 host2</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">dicp -e &quot;$HOME/.profile
$HOME/.bashrc guest@:&quot; host1 host2</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">dicp -g &quot;host1 host2&quot;
$HOME/.profile $HOME/.bashrc guest@:</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">dicp -g &quot;guest@host1
guest@host2&quot; $HOME/.profile $HOME/.bashrc :</p>

<p style="margin-top: 1em">c) Copy remote
&rsquo;.profile&rsquo; files into the local directory on
localhost</p>

<p style="margin-top: 1em">dicp -g &quot;guest@host1
guest@host2 admin@host2&quot; :.profile .profile.ost</p>

<p style="margin-top: 1em">Here, the name of the target
file (local file) will include the remote account name in
order that the local files have unique names.</p>

<p style="margin-top: 1em">d) Use &lsquo;ssh&rsquo; to
login on &rsquo;host1&rsquo; and copy from there
&rsquo;.profile&rsquo; to &rsquo;host2&rsquo;</p>

<p style="margin-top: 1em">Since the list of hosts can not
be empty, a dummy host is used to initiate the process. The
&lsquo;-t&rsquo; option is necessary to force pseudo-tty
allocation in &lsquo;ssh&rsquo;, otherwise <br>
&lsquo;ssh&rsquo; will fail with error on login. A second
password (a1-password) is required for scp-authentication on
&rsquo;host2&rsquo;:</p>

<p style="margin-top: 1em">dish -a &rsquo;&rsquo; -E
&rsquo;ssh -t user1@host1 scp .profile user2@host2:&rsquo;
dummy_host</p>

<p style="margin-top: 1em">In case the password of
&rsquo;user1&rsquo; and &rsquo;user2&rsquo; is the same, you
will be asked only once for a login password for user1@host1
if you use &lsquo;-p1&rsquo;:</p>

<p style="margin-top: 1em">dish -p1 -E &rsquo;ssh -t
user1@host1 scp .profile user2@host2:&rsquo; dummy_host</p>

<p style="margin-top: 1em">Or equivalently, and more
simple:</p>

<p style="margin-top: 1em">dish -p1 -t -e &rsquo;scp
.profile user2@host2:&rsquo; user1@host1</p>

<p style="margin-top: 1em">e) Substitute lines with
&lsquo;START_XNTPD=&rsquo; by
&lsquo;START_XNTPD=&quot;yes&quot;&rsquo; in
/etc/rc.config</p>

<p style="margin-top: 1em">This command is executed as root
user on every host listed in &rsquo;Hosts.root&rsquo;:</p>

<p style="margin-top: 1em">dish -u root -E &rsquo;ssh
$user@$host &quot;perl -pi -e</p>

<p style="margin-top: 1em">f) Freeze accounts of users on a
termination list</p>

<p style="margin-top: 1em">By using a script called
&lsquo;FreezeUser.sh&rsquo;, all accounts of users found on
&rsquo;Terminate.User.lst&rsquo; will be frozen today at
24:00 o&rsquo;clock on both server groups as defined in <br>
files &rsquo;Hosts.1&rsquo; and &rsquo;Hosts.2&rsquo;:</p>

<p style="margin-top: 1em">dish -E &rsquo;ssh root@$host
&quot;cat Terminate.User.lst | while read UN; do echo</p>

<p style="margin-top: 1em">g) Print out remote
configuration file of an automounter</p>

<p style="margin-top: 1em">Login as &rsquo;admin&rsquo;
user on host 192.168.0.1, switch to &rsquo;root&rsquo;, then
cat the file &rsquo;/etc/auto.net&rsquo; and print out the
date. The &lsquo;-a&rsquo; option causes the program to ask
you for <br>
the root-password on remote host:</p>

<p style="margin-top: 1em">dish -u admin -a &rsquo;&rsquo;
-E &rsquo;rsh -l $user $host su - root -c</p>

<p style="margin-top: 1em">h) Install a package on Debian
GNU/Linux hosts</p>

<p style="margin-top: 1em">After mounting a fileserver over
samba, install from there a debian dish-package on all
running servers, yet skip hosts on maintenance. Three
different passwords are <br>
needed for authentication - one for login, next for su-root,
and the last for mounting the fileserver:</p>

<p style="margin-top: 1em">dish -a0 -a1 -a2 -g Debian.up -r
Debian.maint -e &rsquo;su - -c</p>

<p style="margin-top: 1em">i) Check for system load &gt;2
using default &rsquo;hosts&rsquo; and &rsquo;pass&rsquo;
config files</p>

<p style="margin-top: 1em">dish &rsquo;(uptime |egrep</p>

<p style="margin-top: 1em">j) Query a MySQL database on
remote host 10.0.0.1</p>

<p style="margin-top: 1em">dish -pp -c &rsquo;mysql -p -u
$user -h&rsquo; -e &rsquo;use mysql; show tables; describe
user;&rsquo; -u root 10.0.0.1</p>

<p style="margin-top: 1em">k) Change password concurrently
on all hosts/accounts</p>

<p style="margin-top: 1em">We assume that the list of user
accounts is contained in file &rsquo;Accounts.lst&rsquo;,
whereas an entry in the list is of the form
&quot;user@hostname&quot;. After command execution, you <br>
will be asked first for the login password (old password),
and then for the new password which eventually have to
retyped correctly:</p>

<p style="margin-top: 1em">dish -p &rsquo;&rsquo; -n
&rsquo;&rsquo; -e passwd -g Accounts.lst</p>

<p style="margin-top: 1em">Or alternatively, processing
concurrently and quietly all hosts:</p>

<p style="margin-top: 1em">dish -pp -nn -f -Q -e passwd -g
Accounts.lst</p>

<p style="margin-top: 1em">When you want to change password
and use &lsquo;-nn&rsquo;, then the a1-password is
implicitly set equal to the login password
(a0-password).</p>

<p style="margin-top: 1em">l) Change password from
&rsquo;root&rsquo; account (don&rsquo;t use the
&lsquo;-a0&rsquo; option)</p>

<p style="margin-top: 1em">If you are going to change the
root-password on &rsquo;remotehost&rsquo;, then try:</p>

<p style="margin-top: 1em">dish -nn -e passwd
root@remotehost</p>

<p style="margin-top: 1em">The same as previous, but login
as user &rsquo;admin&rsquo; (login password), then switch to
&rsquo;root&rsquo; (a1-password), and finally update the
root-password:</p>

<p style="margin-top: 1em">dish -a1 -nn -e &rsquo;su -c
passwd&rsquo; admin@remotehost</p>

<p style="margin-top: 1em">Changing the password for
&rsquo;admin&rsquo; on &rsquo;localhost&rsquo;, after login
as &rsquo;root&rsquo; via &lsquo;telnet&rsquo;, is done
by:</p>

<p style="margin-top: 1em">dish -nn -c telnet -u root -e
&rsquo;passwd admin&rsquo; localhost</p>

<p style="margin-top: 1em">Notice that for password change,
when &lsquo;-p &quot;&quot;&rsquo; (or equivalently
&lsquo;-a0&rsquo; or &lsquo;-pp&rsquo;) is not explicitly
used, the assumption is made that &lsquo;passwd&rsquo; will
not ask for the old password, as <br>
in case of a password change by &rsquo;root&rsquo;. The same
is true also if you can login into an account without typing
a password, but then &lsquo;passwd&rsquo; prompts you to
type the old one - this <br>
situation occurs when one is using a ssh-key for login
without password-authentication. For such scenario the
correct choice of options is &lsquo;-p0 -aa -nn&rsquo;.</p>

<p style="margin-top: 1em">In case of properly prepared
configuration files in &rsquo;$HOME/.dish&rsquo;, one can
use dish as a distributed shell for a virtual cluster of
hosts, and run it without specifying any pro&acirc; <br>
gram parameters but merely issuing a command, as for
instance &lsquo;dish df -k /&rsquo; or &lsquo;dicp .profile
:&rsquo;.</p>

<p style="margin-top: 1em">As a very last note, one should
be aware that in case of authentication by password,
dish&rsquo;s automated login process is based on the
expectation that the login prompt send to the <br>
terminal will include the case-insensitive regex-string
&lsquo;Password: *$&rsquo; (but see also &lsquo;-X&rsquo;).
Otherwise the authentication procedure will fail.</p>

<p style="margin-top: 1em">BUGS AND KNOWN PROBLEMS <br>
If Tcl is compiled with thread support, the program hangs
when executed in parallel mode (options &lsquo;-f&rsquo; or
&lsquo;-F&rsquo;) - it seems to be a Tcl problem. Generally,
at present Debian <br>
GNU/Linux (and other debian-based Linux distros as Ubuntu,
Knoppix, etc.) pre-package Tcl with multi-thread support
enabled. Therefore, on such systems dish fails to process
<br>
hosts in parallel. In this case you can download the debian
source package of Tcl, remove the option
&quot;--enable-threads&quot; in
&Acirc;&acute;debian/rules&Acirc;&acute;, rebuild the
package with &lsquo;dpkg-build&acirc; <br>
package -rfakeroot&rsquo;, and eventually install it. It
could be a good idea to put the freshly installed package on
hold. Otherwise, you should recompile it on every tcl
upgrade.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to &lt;gnu@mirendom.net&gt;</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 2003-2013 Dimitar Ivanov</p>

<p style="margin-top: 1em">License: GNU GPL version 3 or
later &lt;http://gnu.org/licenses/gpl.html&gt; <br>
This is free software: you are free to change and
redistribute it. There is NO WARRANTY, to the extent
permitted by law.</p>

<p style="margin-top: 1em">SEE ALSO <br>
expect(1), tcl(3), ssh(1), rsh(1), telnet(1)</p>

<p style="margin-top: 1em">dish 1.19.1 September 2013
DISH(1)</p>
<hr>
</body>
</html>
