<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:02:57 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>dcm2xml(1) OFFIS DCMTK dcm2xml(1)</p>

<p style="margin-top: 1em">NAME <br>
dcm2xml - Convert DICOM file and data set to XML</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dcm2xml [options] dcmfile-in [xmlfile-out]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The dcm2xml utility converts the contents of a DICOM file
(file format or raw data set) to XML (Extensible Markup
Language). There are two output formats. The first one is
<br>
specific to DCMTK with its DTD (Document Type Definition)
described in the file dcm2xml.dtd. The second one refers to
the &rsquo;Native DICOM Model&rsquo; which is specified for
the DICOM <br>
Application Hosting service found in DICOM part 19.</p>

<p style="margin-top: 1em">If dcm2xml reads a raw data set
(DICOM data without a file format meta-header) it will
attempt to guess the transfer syntax by examining the first
few bytes of the file. It is <br>
not always possible to correctly guess the transfer syntax
and it is better to convert a data set to a file format
whenever possible (using the dcmconv utility). It is also
<br>
possible to use the -f and -t[ieb] options to force dcm2xml
to read a data set with a particular transfer syntax.</p>

<p style="margin-top: 1em">PARAMETERS <br>
dcmfile-in DICOM input filename to be converted</p>

<p style="margin-top: 1em">xmlfile-out XML output filename
(default: stdout)</p>

<p style="margin-top: 1em">OPTIONS <br>
general options <br>
-h --help <br>
print this help text and exit</p>

<p style="margin-top: 1em">--version <br>
print version information and exit</p>

<p style="margin-top: 1em">--arguments <br>
print expanded command line arguments</p>

<p style="margin-top: 1em">-q --quiet <br>
quiet mode, print no warnings and errors</p>

<p style="margin-top: 1em">-v --verbose <br>
verbose mode, print processing details</p>

<p style="margin-top: 1em">-d --debug <br>
debug mode, print debug information</p>

<p style="margin-top: 1em">-ll --log-level [l]evel: string
constant <br>
(fatal, error, warn, info, debug, trace) <br>
use level l for the logger</p>

<p style="margin-top: 1em">-lc --log-config [f]ilename:
string <br>
use config file f for the logger</p>

<p style="margin-top: 1em">input options <br>
input file format:</p>

<p style="margin-top: 1em">+f --read-file <br>
read file format or data set (default)</p>

<p style="margin-top: 1em">+fo --read-file-only <br>
read file format only</p>

<p style="margin-top: 1em">-f --read-dataset <br>
read data set without file meta information</p>

<p style="margin-top: 1em">input transfer syntax:</p>

<p style="margin-top: 1em">-t= --read-xfer-auto <br>
use TS recognition (default)</p>

<p style="margin-top: 1em">-td --read-xfer-detect <br>
ignore TS specified in the file meta header</p>

<p style="margin-top: 1em">-te --read-xfer-little <br>
read with explicit VR little endian TS</p>

<p style="margin-top: 1em">-tb --read-xfer-big <br>
read with explicit VR big endian TS</p>

<p style="margin-top: 1em">-ti --read-xfer-implicit <br>
read with implicit VR little endian TS</p>

<p style="margin-top: 1em">long tag values:</p>

<p style="margin-top: 1em">+M --load-all <br>
load very long tag values (e.g. pixel data)</p>

<p style="margin-top: 1em">-M --load-short <br>
do not load very long values (default)</p>

<p style="margin-top: 1em">+R --max-read-length [k]bytes:
integer (4..4194302, default: 4) <br>
set threshold for long values to k kbytes</p>

<p style="margin-top: 1em">processing options <br>
specific character set:</p>

<p style="margin-top: 1em">+Cr --charset-require <br>
require declaration of extended charset (default)</p>

<p style="margin-top: 1em">+Ca --charset-assume [c]harset:
string <br>
assume charset c if no extended charset declared</p>

<p style="margin-top: 1em">+Cc --charset-check-all <br>
check all data elements with string values <br>
(default: only PN, LO, LT, SH, ST, UC and UT)</p>

<p style="margin-top: 1em"># this option is only used for
the mapping to an appropriate <br>
# XML character encoding, but not for the conversion to
UTF-8</p>

<p style="margin-top: 1em">+U8 --convert-to-utf8 <br>
convert all element values that are affected <br>
by Specific Character Set (0008,0005) to UTF-8</p>

<p style="margin-top: 1em"># requires support from the
libiconv toolkit</p>

<p style="margin-top: 1em">output options <br>
general XML format:</p>

<p style="margin-top: 1em">-dtk --dcmtk-format <br>
output in DCMTK-specific format (default)</p>

<p style="margin-top: 1em">-nat --native-format <br>
output in Native DICOM Model format (part 19)</p>

<p style="margin-top: 1em">+Xn --use-xml-namespace <br>
add XML namespace declaration to root element</p>

<p style="margin-top: 1em">DCMTK-specific format (not with
--native-format):</p>

<p style="margin-top: 1em">+Xd --add-dtd-reference <br>
add reference to document type definition (DTD)</p>

<p style="margin-top: 1em">+Xe --embed-dtd-content <br>
embed document type definition into XML document</p>

<p style="margin-top: 1em">+Xf --use-dtd-file [f]ilename:
string <br>
use specified DTD file (only with +Xe) <br>
(default: /usr/local/share/dcmtk/dcm2xml.dtd)</p>

<p style="margin-top: 1em">+Wn --write-element-name <br>
write name of the DICOM data elements (default)</p>

<p style="margin-top: 1em">-Wn --no-element-name <br>
do not write name of the DICOM data elements</p>

<p style="margin-top: 1em">+Wb --write-binary-data <br>
write binary data of OB and OW elements <br>
(default: off, be careful with --load-all)</p>

<p style="margin-top: 1em">encoding of binary data:</p>

<p style="margin-top: 1em">+Eh --encode-hex <br>
encode binary data as hex numbers <br>
(default for DCMTK-specific format)</p>

<p style="margin-top: 1em">+Eu --encode-uuid <br>
encode binary data as a UUID reference <br>
(default for Native DICOM Model)</p>

<p style="margin-top: 1em">+Eb --encode-base64 <br>
encode binary data as Base64 (RFC 2045, MIME)</p>

<p style="margin-top: 1em">DCMTK Format <br>
The basic structure of the DCMTK-specific XML output created
from a DICOM file looks like the following:</p>

<p style="margin-top: 1em">&lt;?xml version=&quot;1.0&quot;
encoding=&quot;ISO-8859-1&quot;?&gt; <br>
&lt;!DOCTYPE file-format SYSTEM &quot;dcm2xml.dtd&quot;&gt;
<br>
&lt;file-format
xmlns=&quot;http://dicom.offis.de/dcmtk&quot;&gt; <br>
&lt;meta-header xfer=&quot;1.2.840.10008.1.2.1&quot;
name=&quot;Little Endian Explicit&quot;&gt; <br>
&lt;element tag=&quot;0002,0000&quot; vr=&quot;UL&quot;
vm=&quot;1&quot; len=&quot;4&quot; <br>
name=&quot;MetaElementGroupLength&quot;&gt; <br>
166 <br>
&lt;/element&gt; <br>
... <br>
&lt;element tag=&quot;0002,0013&quot; vr=&quot;SH&quot;
vm=&quot;1&quot; len=&quot;16&quot; <br>
name=&quot;ImplementationVersionName&quot;&gt; <br>
OFFIS_DCMTK_353 <br>
&lt;/element&gt; <br>
&lt;/meta-header&gt; <br>
&lt;data-set xfer=&quot;1.2.840.10008.1.2&quot;
name=&quot;Little Endian Implicit&quot;&gt; <br>
&lt;element tag=&quot;0008,0005&quot; vr=&quot;CS&quot;
vm=&quot;1&quot; len=&quot;10&quot; <br>
name=&quot;SpecificCharacterSet&quot;&gt; <br>
ISO_IR 100 <br>
&lt;/element&gt; <br>
... <br>
&lt;sequence tag=&quot;0028,3010&quot; vr=&quot;SQ&quot;
card=&quot;2&quot; name=&quot;VOILUTSequence&quot;&gt; <br>
&lt;item card=&quot;3&quot;&gt; <br>
&lt;element tag=&quot;0028,3002&quot; vr=&quot;xs&quot;
vm=&quot;3&quot; len=&quot;6&quot; <br>
name=&quot;LUTDescriptor&quot;&gt; <br>
256 8 <br>
&lt;/element&gt; <br>
... <br>
&lt;/item&gt; <br>
... <br>
&lt;/sequence&gt; <br>
... <br>
&lt;element tag=&quot;7fe0,0010&quot; vr=&quot;OW&quot;
vm=&quot;1&quot; len=&quot;262144&quot; <br>
name=&quot;PixelData&quot; loaded=&quot;no&quot;
binary=&quot;hidden&quot;&gt; <br>
&lt;/element&gt; <br>
&lt;/data-set&gt; <br>
&lt;/file-format&gt;</p>

<p style="margin-top: 1em">The &rsquo;file-format&rsquo;
and &rsquo;meta-header&rsquo; tags are absent for DICOM data
sets.</p>

<p style="margin-top: 1em">XML Encoding <br>
Attributes with very large value fields (e.g. pixel data)
are not loaded by default. They can be identified by the
additional attribute &rsquo;loaded&rsquo; with a value of
&rsquo;no&rsquo; (see example <br>
above). The command line option --load-all forces to load
all value fields including the very long ones.</p>

<p style="margin-top: 1em">Furthermore, binary information
of OB and OW attributes are not written to the XML output
file by default. These elements can be identified by the
additional attribute &rsquo;binary&rsquo; <br>
with a value of &rsquo;hidden&rsquo; (default is
&rsquo;no&rsquo;). The command line option
--write-binary-data causes also binary value fields to be
printed (attribute value is &rsquo;yes&rsquo; or
&rsquo;base64&rsquo;). But, <br>
be careful when using this option together with --load-all
because of the large amounts of pixel data that might be
printed to the output. Please note that in this context <br>
element values with a VR of OD or OF are not regarded as
&rsquo;binary information&rsquo;.</p>

<p style="margin-top: 1em">Multiple values (i.e. where the
DICOM value multiplicity is greater than 1) are separated by
a backslash &rsquo;&acute; (except for Base64 encoded data).
The &rsquo;len&rsquo; attribute indicates the <br>
number of bytes for the particular value field as stored in
the DICOM data set, i.e. it might deviate from the XML
encoded value length e.g. because of non-significant padding
<br>
that has been removed. If this attribute is missing in
&rsquo;sequence&rsquo; or &rsquo;item&rsquo; start tags, the
corresponding DICOM element has been stored with undefined
length.</p>

<p style="margin-top: 1em">Native DICOM Model Format <br>
The description of the Native DICOM Model format can be
found in the DICOM standard, part 19 (&rsquo;Application
Hosting&rsquo;).</p>

<p style="margin-top: 1em">Bulk Data <br>
Binary data, i.e. DICOM element values with Value
Representations (VR) of OB or OW, as well as OD, OF and UN
values are by default not written to the XML output because
of their <br>
size. Instead, for each element, a new Universally Unique
Identifier (UUID) is being generated and written as an
attribute of a &lt;BulkData&gt; XML element. So far, there
is no <br>
possibility to write an additional file to hold the binary
data for each of the binary data chunks. This is not
required by the standard, however, it might be useful for
<br>
implementing an Application Hosting interface; thus this
feature may be available in future versions of dcm2xml.</p>

<p style="margin-top: 1em">In addition, Supplement 163
(Store Over the Web by Representational State Transfer
Services) introduces a new &lt;InlineBinary&gt; XML element
that allows for encoding binary data as <br>
Base64. Currently, the command line option --encode-base64
enables this encoding for the following VRs: OB, OD, OF, OW,
and UN.</p>

<p style="margin-top: 1em">Known Issues <br>
In addition to what is written in the above section on
&rsquo;Bulk Data&rsquo;, there are further known issues with
the current implementation of the Native DICOM Model format.
For example, <br>
large element values with a VR other than OB, OD, OF, OW or
UN are currently never written as bulk data, although it
might be useful, e.g. for very long text elements
(especially <br>
UT) or very long numeric fields (of various VRs).</p>

<p style="margin-top: 1em">NOTES <br>
Character Encoding <br>
The XML encoding is determined automatically from the DICOM
attribute (0008,0005) &rsquo;Specific Character Set&rsquo;
using the following mapping:</p>

<p style="margin-top: 1em">ASCII (ISO_IR 6) =&gt;
&quot;UTF-8&quot; <br>
UTF-8 &quot;ISO_IR 192&quot; =&gt; &quot;UTF-8&quot; <br>
ISO Latin 1 &quot;ISO_IR 100&quot; =&gt;
&quot;ISO-8859-1&quot; <br>
ISO Latin 2 &quot;ISO_IR 101&quot; =&gt;
&quot;ISO-8859-2&quot; <br>
ISO Latin 3 &quot;ISO_IR 109&quot; =&gt;
&quot;ISO-8859-3&quot; <br>
ISO Latin 4 &quot;ISO_IR 110&quot; =&gt;
&quot;ISO-8859-4&quot; <br>
ISO Latin 5 &quot;ISO_IR 148&quot; =&gt;
&quot;ISO-8859-9&quot; <br>
Cyrillic &quot;ISO_IR 144&quot; =&gt; &quot;ISO-8859-5&quot;
<br>
Arabic &quot;ISO_IR 127&quot; =&gt; &quot;ISO-8859-6&quot;
<br>
Greek &quot;ISO_IR 126&quot; =&gt; &quot;ISO-8859-7&quot;
<br>
Hebrew &quot;ISO_IR 138&quot; =&gt;
&quot;ISO-8859-8&quot;</p>

<p style="margin-top: 1em">If this DICOM attribute is
missing in the input file, although needed, option
--charset-assume can be used to specify an appropriate
character set manually (using one of the <br>
DICOM defined terms). For reasons of backward compatibility
with previous versions of this tool, the following terms are
also supported and mapped automatically to the associated
<br>
DICOM defined terms: latin-1, latin-2, latin-3, latin-4,
latin-5, cyrillic, arabic, greek, hebrew.</p>

<p style="margin-top: 1em">Multiple character sets using
code extension techniques are not supported. If needed,
option --convert-to-utf8 can be used to convert the DICOM
file or data set to UTF-8 encoding <br>
prior to the conversion to XML format. This is also useful
for DICOMDIR files where each directory record can have a
different character set.</p>

<p style="margin-top: 1em">LOGGING <br>
The level of logging output of the various command line
tools and underlying libraries can be specified by the user.
By default, only errors and warnings are written to the <br>
standard error stream. Using option --verbose also
informational messages like processing details are reported.
Option --debug can be used to get more details on the
internal <br>
activity, e.g. for debugging purposes. Other logging levels
can be selected using option --log-level. In --quiet mode
only fatal errors are reported. In such very severe error
<br>
events, the application will usually terminate. For more
details on the different logging levels, see documentation
of module &rsquo;oflog&rsquo;.</p>

<p style="margin-top: 1em">In case the logging output
should be written to file (optionally with logfile
rotation), to syslog (Unix) or the event log (Windows)
option --log-config can be used. This <br>
configuration file also allows for directing only certain
messages to a particular output stream and for filtering
certain messages based on the module or application where
they <br>
are generated. An example configuration file is provided in
&lt;etcdir&gt;/logger.cfg.</p>

<p style="margin-top: 1em">COMMAND LINE <br>
All command line tools use the following notation for
parameters: square brackets enclose optional values (0-1),
three trailing dots indicate that multiple values are
allowed <br>
(1-n), a combination of both means 0 to n values.</p>

<p style="margin-top: 1em">Command line options are
distinguished from parameters by a leading &rsquo;+&rsquo;
or &rsquo;-&rsquo; sign, respectively. Usually, order and
position of command line options are arbitrary (i.e. they
<br>
can appear anywhere). However, if options are mutually
exclusive the rightmost appearance is used. This behavior
conforms to the standard evaluation rules of common Unix
shells.</p>

<p style="margin-top: 1em">In addition, one or more command
files can be specified using an &rsquo;@&rsquo; sign as a
prefix to the filename (e.g. @command.txt). Such a command
argument is replaced by the content of <br>
the corresponding text file (multiple whitespaces are
treated as a single separator unless they appear between two
quotation marks) prior to any further evaluation. Please
note <br>
that a command file cannot contain another command file.
This simple but effective approach allows one to summarize
common combinations of options/parameters and avoids longish
<br>
and confusing command lines (an example is provided in file
&lt;datadir&gt;/dumppat.txt).</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
The dcm2xml utility will attempt to load DICOM data
dictionaries specified in the DCMDICTPATH environment
variable. By default, i.e. if the DCMDICTPATH environment
variable is <br>
not set, the file &lt;datadir&gt;/dicom.dic will be loaded
unless the dictionary is built into the application (default
for Windows).</p>

<p style="margin-top: 1em">The default behavior should be
preferred and the DCMDICTPATH environment variable only used
when alternative data dictionaries are required. The
DCMDICTPATH environment variable <br>
has the same format as the Unix shell PATH variable in that
a colon (&rsquo;:&rsquo;) separates entries. On Windows
systems, a semicolon (&rsquo;;&rsquo;) is used as a
separator. The data dictionary <br>
code will attempt to load each file specified in the
DCMDICTPATH environment variable. It is an error if no data
dictionary can be loaded.</p>

<p style="margin-top: 1em">FILES <br>
&lt;datadir&gt;/dcm2xml.dtd - Document Type Definition (DTD)
file</p>

<p style="margin-top: 1em">SEE ALSO <br>
xml2dcm(1), dcmconv(1)</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) 2002-2015 by OFFIS e.V., Escherweg 2, 26121
Oldenburg, Germany.</p>

<p style="margin-top: 1em">Version 3.6.1 Tue Feb 16 2016
dcm2xml(1)</p>
<hr>
</body>
</html>
