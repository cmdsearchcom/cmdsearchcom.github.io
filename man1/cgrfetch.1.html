<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:58:08 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CGRFETCH(1) BP executables CGRFETCH(1)</p>

<p style="margin-top: 1em">NAME <br>
cgrfetch - Visualize CGR simulations</p>

<p style="margin-top: 1em">SYNOPSIS <br>
cgrfetch [OPTIONS] DEST-NODE</p>

<p style="margin-top: 1em">DESCRIPTION <br>
cgrfetch uses CGR to simulate sending a bundle from the
local node to DEST-NODE. It traces the execution of CGR to
generate graphs of the routes that were considered and the
<br>
routes that were ultimately chosen to forward along. No
bundle is sent during the simulation.</p>

<p style="margin-top: 1em">A JSON representation of the
simulation is output to OUTPUT-FILE. The representation
includes parameters of the simulation and a structure for
each considered route, which in <br>
turn includes calculated parameters for the route and an
image of the contact graph.</p>

<p style="margin-top: 1em">The dot(1) tool from the
Graphviz package is used to generate the contact graph
images and is required for cgrfetch(1). The base64(1) tool
from coreutils is used to embed the <br>
images in the JSON and is also required.</p>

<p style="margin-top: 1em">OPTIONS <br>
DEST-NODE <br>
The final destination to route to. To be useful, it should
be a node that exists in the contact plan.</p>

<p style="margin-top: 1em">-q Disable trace message
output.</p>

<p style="margin-top: 1em">-j Disable JSON output.</p>

<p style="margin-top: 1em">-m Use a minimum-latency
extended COS for the bundle. This ends up sending the bundle
to all proximate nodes.</p>

<p style="margin-top: 1em">-t DISPATCH-OFFSET <br>
Request a dispatch time of DISPATCH-OFFSET seconds from the
time the command is run (default: 0).</p>

<p style="margin-top: 1em">-e EXPIRATION-OFFSET <br>
Set the bundle expiration time to EXPIRATION-OFFSET seconds
from the time the command is run (default: 3600).</p>

<p style="margin-top: 1em">-s BUNDLE-SIZE <br>
Set the bundle payload size to BUNDLE-SIZE bytes (default:
0).</p>

<p style="margin-top: 1em">-o OUTPUT-FILE <br>
Send JSON to OUTPUT-FILE (default: stdout).</p>

<p style="margin-top: 1em">-p OUTDUCT-PROTO <br>
Use OUTDUCT-PROTO as the outduct protocol (default:
udp).</p>

<p style="margin-top: 1em">-n OUTDUCT-NAME <br>
Use OUTDUCT-NAME as the outduct name (default: *).</p>

<p style="margin-top: 1em">EXAMPLES <br>
cgrfetch 8 <br>
Simulate CGR with destination node 8 and dispatch time equal
to the current time.</p>

<p style="margin-top: 1em">cgrfetch 8 -t 60 <br>
Do the same with a dispatch time 60 seconds in the
future.</p>

<p style="margin-top: 1em">SEE ALSO <br>
dot(1), base64(1)</p>

<p style="margin-top: 1em">perl v5.24.1 2016-07-07
CGRFETCH(1)</p>
<hr>
</body>
</html>
