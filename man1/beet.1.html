<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:54:40 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>BEET(1) beets BEET(1)</p>

<p style="margin-top: 1em">NAME <br>
beet - music tagger and library organizer</p>

<p style="margin-top: 1em">SYNOPSIS <br>
beet [args...] command [args...] <br>
beet help command</p>

<p style="margin-top: 1em">COMMANDS <br>
import <br>
beet import [-CWAPRqst] [-l LOGPATH] PATH... <br>
beet import [options] -L QUERY</p>

<p style="margin-top: 1em">Add music to your library,
attempting to get correct tags for it from MusicBrainz.</p>

<p style="margin-top: 1em">Point the command at some music:
directories, single files, or compressed archives. The music
will be copied to a configurable directory structure and
added to a library data&acirc; <br>
base. The command is interactive and will try to get you to
verify MusicBrainz tags that it thinks are suspect. See the
autotagging guide for detail on how to use the interactive
<br>
tag-correction flow.</p>

<p style="margin-top: 1em">Directories passed to the import
command can contain either a single album or many, in which
case the leaf directories will be considered albums (the
latter case is true of typi&acirc; <br>
cal Artist/Album organizations and many people&rsquo;s
&quot;downloads&quot; folders). The path can also be a
single song or an archive. Beets supports zip and tar
archives out of the box. To <br>
extract rar files, install the rarfile package and the unrar
command.</p>

<p style="margin-top: 1em">Optional command flags:</p>

<p style="margin-top: 1em">&Acirc;&middot; By default, the
command copies files your the library directory and updates
the ID3 tags on your music. If you&rsquo;d like to leave
your music files untouched, try the -C (don&rsquo;t <br>
copy) and -W (don&rsquo;t write tags) options. You can also
disable this behavior by default in the configuration file
(below).</p>

<p style="margin-top: 1em">&Acirc;&middot; Also, you can
disable the autotagging behavior entirely using -A
(don&rsquo;t autotag)---then your music will be imported
with its existing metadata.</p>

<p style="margin-top: 1em">&Acirc;&middot; During a long
tagging import, it can be useful to keep track of albums
that weren&rsquo;t tagged successfully---either because
they&rsquo;re not in the MusicBrainz database or because
<br>
something&rsquo;s wrong with the files. Use the -l option to
specify a filename to log every time you skip an album or
import it &quot;as-is&quot; or an album gets skipped as a
duplicate.</p>

<p style="margin-top: 1em">&Acirc;&middot; Relatedly, the
-q (quiet) option can help with large imports by autotagging
without ever bothering to ask for user input. Whenever the
normal autotagger mode would ask for con&acirc; <br>
firmation, the quiet mode pessimistically skips the album.
The quiet mode also disables the tagger&rsquo;s ability to
resume interrupted imports.</p>

<p style="margin-top: 1em">&Acirc;&middot; Speaking of
resuming interrupted imports, the tagger will prompt you if
it seems like the last import of the directory was
interrupted (by you or by a crash). If you want to <br>
skip this prompt, you can say &quot;yes&quot; automatically
by providing -p or &quot;no&quot; using -P. The resuming
feature can be disabled by default using a configuration
option (see below).</p>

<p style="margin-top: 1em">&Acirc;&middot; If you want to
import only the new stuff from a directory, use the -i
option to run an incremental import. With this flag, beets
will keep track of every directory it ever <br>
imports and avoid importing them again. This is useful if
you have an &quot;incoming&quot; directory that you
periodically add things to. To get this to work correctly,
you&rsquo;ll need to <br>
use an incremental import every time you run an import on
the directory in question---including the first time, when
no subdirectories will be skipped. So consider enabling the
<br>
incremental configuration option.</p>

<p style="margin-top: 1em">&Acirc;&middot; By default,
beets will proceed without asking if it finds a very close
metadata match. To disable this and have the importer ask
you every time, use the -t (for timid) option.</p>

<p style="margin-top: 1em">&Acirc;&middot; The importer
typically works in a whole-album-at-a-time mode. If you
instead want to import individual, non-album tracks, use the
singleton mode by supplying the -s option.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you have an
album that&rsquo;s split across several directories under a
common top directory, use the --flat option. This takes all
the music files under the directory (recur&acirc; <br>
sively) and treats them as a single large album instead of
as one album per directory. This can help with your more
stubborn multi-disc albums.</p>

<p style="margin-top: 1em">&Acirc;&middot; Similarly, if
you have one directory that contains multiple albums, use
the --group-albums option to split the files based on their
metadata before matching them as separate <br>
albums.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you want to
preview which files would be imported, use the --pretend
option. If set, beets will just print a list of files that
it would otherwise import.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you already
have a metadata backend ID that matches the items to be
imported, you can instruct beets to restrict the search to
that ID instead of searching for other candi&acirc; <br>
dates by using the --search-id SEARCH_ID option. Multiple
IDs can be specified by simply repeating the option several
times.</p>

<p style="margin-top: 1em">list <br>
beet list [-apf] QUERY</p>

<p style="margin-top: 1em">Queries the database for
music.</p>

<p style="margin-top: 1em">Want to search for
&quot;Gronlandic Edit&quot; by of Montreal? Try beet list
gronlandic. Maybe you want to see everything released in
2009 with &quot;vegetables&quot; in the title? Try beet list
<br>
year:2009 title:vegetables. You can also specify the sort
order. (Read more in query.)</p>

<p style="margin-top: 1em">You can use the -a switch to
search for albums instead of individual items. In this case,
the queries you use are restricted to album-level fields:
for example, you can search <br>
for year:1969 but query parts for item-level fields like
title:foo will be ignored. Remember that artist is an
item-level field; albumartist is the corresponding album
field.</p>

<p style="margin-top: 1em">The -p option makes beets print
out filenames of matched items, which might be useful for
piping into other Unix commands (such as xargs). Similarly,
the -f option lets you spec&acirc; <br>
ify a specific format with which to print every album or
track. This uses the same template syntax as beets&rsquo;
path formats. For example, the command beet ls -af
&rsquo;$album: $trackto&acirc; <br>
tal&rsquo; beatles prints out the number of tracks on each
Beatles album. In Unix shells, remember to enclose the
template argument in single quotes to avoid environment
variable <br>
expansion.</p>

<p style="margin-top: 1em">remove <br>
beet remove [-adf] QUERY</p>

<p style="margin-top: 1em">Remove music from your
library.</p>

<p style="margin-top: 1em">This command uses the same query
syntax as the list command. You&rsquo;ll be shown a list of
the files that will be removed and asked to confirm. By
default, this just removes <br>
entries from the library database; it doesn&rsquo;t touch
the files on disk. To actually delete the files, use beet
remove -d. If you do not want to be prompted to remove the
files, <br>
use beet remove -f.</p>

<p style="margin-top: 1em">modify <br>
beet modify [-MWay] QUERY [FIELD=VALUE...] [FIELD!...]</p>

<p style="margin-top: 1em">Change the metadata for items or
albums in the database.</p>

<p style="margin-top: 1em">Supply a query matching the
things you want to change and a series of field=value pairs.
For example, beet modify genius of love artist=&quot;Tom Tom
Club&quot; will change the artist for <br>
the track &quot;Genius of Love.&quot; To remove fields
(which is only possible for flexible attributes), follow a
field name with an exclamation point: field!.</p>

<p style="margin-top: 1em">The -a switch operates on albums
instead of individual tracks. Items will automatically be
moved around when necessary if they&rsquo;re in your library
directory, but you can disable <br>
that with -M. Tags will be written to the files according to
the settings you have for imports, but these can be
overridden with -w (write tags, the default) and -W
(don&rsquo;t write <br>
tags). Finally, this command politely asks for your
permission before making any changes, but you can skip that
prompt with the -y switch.</p>

<p style="margin-top: 1em">move <br>
beet move [-capt] [-d DIR] QUERY</p>

<p style="margin-top: 1em">Move or copy items in your
library.</p>

<p style="margin-top: 1em">This command, by default, acts
as a library consolidator: items matching the query are
renamed into your library directory structure. By specifying
a destination directory with <br>
-d manually, you can move items matching a query anywhere in
your filesystem. The -c option copies files instead of
moving them. As with other commands, the -a option matches
<br>
albums instead of items.</p>

<p style="margin-top: 1em">To perform a &quot;dry
run&quot;, just use the -p (for &quot;pretend&quot;) flag.
This will show you a list of files that would be moved but
won&rsquo;t actually change anything on disk. The -t option
<br>
sets the timid mode which will ask again before really
moving or copying the files.</p>

<p style="margin-top: 1em">update <br>
beet update [-aM] QUERY</p>

<p style="margin-top: 1em">Update the library (and,
optionally, move files) to reflect out-of-band metadata
changes and file deletions.</p>

<p style="margin-top: 1em">This will scan all the matched
files and read their tags, populating the database with the
new values. By default, files will be renamed according to
their new metadata; disable <br>
this with -M. Beets will skip files if their modification
times have not changed, so any out-of-band metadata changes
must also update these for beet update to recognise that the
<br>
files have been edited.</p>

<p style="margin-top: 1em">To perform a &quot;dry run&quot;
of an update, just use the -p (for &quot;pretend&quot;)
flag. This will show you all the proposed changes but
won&rsquo;t actually change anything on disk.</p>

<p style="margin-top: 1em">When an updated track is part of
an album, the album-level fields of all tracks from the
album are also updated. (Specifically, the command copies
album-level data from the first <br>
track on the album and applies it to the rest of the
tracks.) This means that, if album-level fields aren&rsquo;t
identical within an album, some changes shown by the update
command <br>
may be overridden by data from other tracks on the same
album. This means that running the update command multiple
times may show the same changes being applied.</p>

<p style="margin-top: 1em">write <br>
beet write [-pf] [QUERY]</p>

<p style="margin-top: 1em">Write metadata from the database
into files&rsquo; tags.</p>

<p style="margin-top: 1em">When you make changes to the
metadata stored in beets&rsquo; library database (during
import or with the modify command, for example), you often
have the option of storing changes only <br>
in the database, leaving your files untouched. The write
command lets you later change your mind and write the
contents of the database into the files. By default, this
writes <br>
the changes only if there is a difference between the
database and the tags in the file.</p>

<p style="margin-top: 1em">You can think of this command as
the opposite of update.</p>

<p style="margin-top: 1em">The -p option previews metadata
changes without actually applying them.</p>

<p style="margin-top: 1em">The -f option forces a write to
the file, even if the file tags match the database. This is
useful for making sure that enabled plugins that run on
write (e.g., the Scrub and <br>
Zero plugins) are run on the file.</p>

<p style="margin-top: 1em">stats <br>
beet stats [-e] [QUERY]</p>

<p style="margin-top: 1em">Show some statistics on your
entire library (if you don&rsquo;t provide a query) or the
matched items (if you do).</p>

<p style="margin-top: 1em">By default, the command
calculates file sizes using their bitrate and duration. The
-e (--exact) option reads the exact sizes of each file (but
is slower). The exact mode also <br>
outputs the exact duration in seconds.</p>

<p style="margin-top: 1em">fields <br>
beet fields</p>

<p style="margin-top: 1em">Show the item and album metadata
fields available for use in query and pathformat. The
listing includes any template fields provided by plugins and
any flexible attributes you&rsquo;ve <br>
manually assigned to your items and albums.</p>

<p style="margin-top: 1em">config <br>
beet config [-pdc] <br>
beet config -e</p>

<p style="margin-top: 1em">Show or edit the user
configuration. This command does one of three things:</p>

<p style="margin-top: 1em">&Acirc;&middot; With no options,
print a YAML representation of the current user
configuration. With the --default option, beets&rsquo;
default options are also included in the dump.</p>

<p style="margin-top: 1em">&Acirc;&middot; The --path
option instead shows the path to your configuration file.
This can be combined with the --default flag to show where
beets keeps its internal defaults.</p>

<p style="margin-top: 1em">&Acirc;&middot; By default,
sensitive information like passwords is removed when dumping
the configuration. The --clear option includes this
sensitive data.</p>

<p style="margin-top: 1em">&Acirc;&middot; With the --edit
option, beets attempts to open your config file for editing.
It first tries the $EDITOR environment variable and then a
fallback option depending on your plat&acirc; <br>
form: open on OS X, xdg-open on Unix, and direct invocation
on Windows.</p>

<p style="margin-top: 1em">GLOBAL FLAGS <br>
Beets has a few &quot;global&quot; flags that affect all
commands. These must appear between the executable name
(beet) and the command---for example, beet -v import
....</p>

<p style="margin-top: 1em">&Acirc;&middot; -l LIBPATH:
specify the library database file to use.</p>

<p style="margin-top: 1em">&Acirc;&middot; -d DIRECTORY:
specify the library root directory.</p>

<p style="margin-top: 1em">&Acirc;&middot; -v: verbose
mode; prints out a deluge of debugging information. Please
use this flag when reporting bugs. You can use it twice, as
in -vv, to make beets even more verbose.</p>

<p style="margin-top: 1em">&Acirc;&middot; -c FILE: read a
specified YAML configuration file.</p>

<p style="margin-top: 1em">Beets also uses the BEETSDIR
environment variable to look for configuration and data.</p>

<p style="margin-top: 1em">SHELL COMPLETION <br>
Beets includes support for shell command completion. The
command beet completion prints out a bash 3.2 script; to
enable completion put a line like this into your .bashrc or
sim&acirc; <br>
ilar file:</p>

<p style="margin-top: 1em">eval &quot;$(beet
completion)&quot;</p>

<p style="margin-top: 1em">Or, to avoid slowing down your
shell startup time, you can pipe the beet completion output
to a file and source that instead.</p>

<p style="margin-top: 1em">You will also need to source the
bash-completion script, which is probably available via your
package manager. On OS X, you can install it via Homebrew
with brew install <br>
bash-completion; Homebrew will give you instructions for
sourcing the script.</p>

<p style="margin-top: 1em">The completion script suggests
names of subcommands and (after typing -) options of the
given command. If you are using a command that accepts a
query, the script will also com&acirc; <br>
plete field names.</p>

<p style="margin-top: 1em">beet list ar[TAB] <br>
# artist: artist_credit: artist_sort: artpath: <br>
beet list artp[TAB] <br>
beet list artpath</p>

<p style="margin-top: 1em">(Don&rsquo;t worry about the
slash in front of the colon: this is a escape sequence for
the shell and won&rsquo;t be seen by beets.)</p>

<p style="margin-top: 1em">Completion of plugin commands
only works for those plugins that were enabled when running
beet completion. If you add a plugin later on you will want
to re-generate the script.</p>

<p style="margin-top: 1em">zsh <br>
If you use zsh, take a look at the included completion
script. The script should be placed in a directory that is
part of your fpath, and not sourced in your .zshrc. Running
echo <br>
$fpath will give you a list of valid directories.</p>

<p style="margin-top: 1em">Another approach is to use
zsh&rsquo;s bash completion compatibility. This snippet
defines some bash-specific functions to make this work
without errors:</p>

<p style="margin-top: 1em">autoload bashcompinit <br>
bashcompinit <br>
_get_comp_words_by_ref() { :; } <br>
compopt() { :; } <br>
_filedir() { :; } <br>
eval &quot;$(beet completion)&quot;</p>

<p style="margin-top: 1em">SEE ALSO <br>
http://beets.readthedocs.org/</p>

<p style="margin-top: 1em">beetsconfig(5)</p>

<p style="margin-top: 1em">AUTHOR <br>
Adrian Sampson</p>

<p style="margin-top: 1em">COPYRIGHT <br>
2017, Adrian Sampson</p>

<p style="margin-top: 1em">1.3 Jan 23, 2017 BEET(1)</p>
<hr>
</body>
</html>
