<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:13:24 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GIT-FAST-IMPORT(1) Git Manual GIT-FAST-IMPORT(1)</p>

<p style="margin-top: 1em">NAME <br>
git-fast-import - Backend for fast Git data importers</p>

<p style="margin-top: 1em">SYNOPSIS <br>
frontend | git fast-import [options]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This program is usually not what the end user wants to run
directly. Most end users want to use one of the existing
frontend programs, which parses a specific type of foreign
<br>
source and feeds the contents stored there to git
fast-import.</p>

<p style="margin-top: 1em">fast-import reads a mixed
command/data stream from standard input and writes one or
more packfiles directly into the current repository. When
EOF is received on standard input, <br>
fast import writes out updated branch and tag refs, fully
updating the current repository with the newly imported
data.</p>

<p style="margin-top: 1em">The fast-import backend itself
can import into an empty repository (one that has already
been initialized by git init) or incrementally update an
existing populated repository. <br>
Whether or not incremental imports are supported from a
particular foreign source depends on the frontend program in
use.</p>

<p style="margin-top: 1em">OPTIONS <br>
--force <br>
Force updating modified existing branches, even if doing so
would cause commits to be lost (as the new commit does not
contain the old commit).</p>

<p style="margin-top: 1em">--quiet <br>
Disable all non-fatal output, making fast-import silent when
it is successful. This option disables the output shown by
--stats.</p>

<p style="margin-top: 1em">--stats <br>
Display some basic statistics about the objects fast-import
has created, the packfiles they were stored into, and the
memory used by fast-import during this run. Showing this
<br>
output is currently the default, but can be disabled with
--quiet.</p>

<p style="margin-top: 1em">Options for Frontends <br>
--cat-blob-fd=&lt;fd&gt; <br>
Write responses to cat-blob and ls queries to the file
descriptor &lt;fd&gt; instead of stdout. Allows progress
output intended for the end-user to be separated from other
output.</p>

<p style="margin-top: 1em">--date-format=&lt;fmt&gt; <br>
Specify the type of dates the frontend will supply to
fast-import within author, committer and tagger commands.
See &acirc;Date Formats&acirc; below for details about which
formats are <br>
supported, and their syntax.</p>

<p style="margin-top: 1em">--done <br>
Terminate with error if there is no done command at the end
of the stream. This option might be useful for detecting
errors that cause the frontend to terminate before it has
<br>
started to write a stream.</p>

<p style="margin-top: 1em">Locations of Marks Files <br>
--export-marks=&lt;file&gt; <br>
Dumps the internal marks table to &lt;file&gt; when
complete. Marks are written one per line as :markid SHA-1.
Frontends can use this file to validate imports after they
have been <br>
completed, or to save the marks table across incremental
runs. As &lt;file&gt; is only opened and truncated at
checkpoint (or completion) the same path can also be safely
given to <br>
--import-marks.</p>

<p style="margin-top: 1em">--import-marks=&lt;file&gt; <br>
Before processing any input, load the marks specified in
&lt;file&gt;. The input file must exist, must be readable,
and must use the same format as produced by --export-marks.
<br>
Multiple options may be supplied to import more than one set
of marks. If a mark is defined to different values, the last
file wins.</p>


<p style="margin-top: 1em">--import-marks-if-exists=&lt;file&gt;
<br>
Like --import-marks but instead of erroring out, silently
skips the file if it does not exist.</p>

<p style="margin-top: 1em">--[no-]relative-marks <br>
After specifying --relative-marks the paths specified with
--import-marks= and --export-marks= are relative to an
internal directory in the current repository. In <br>
git-fast-import this means that the paths are relative to
the .git/info/fast-import directory. However, other
importers may use a different location.</p>

<p style="margin-top: 1em">Relative and non-relative marks
may be combined by interweaving --(no-)-relative-marks with
the --(import|export)-marks= options.</p>

<p style="margin-top: 1em">Performance and Compression
Tuning <br>
--active-branches=&lt;n&gt; <br>
Maximum number of branches to maintain active at once. See
&acirc;Memory Utilization&acirc; below for details. Default
is 5.</p>

<p style="margin-top: 1em">--big-file-threshold=&lt;n&gt;
<br>
Maximum size of a blob that fast-import will attempt to
create a delta for, expressed in bytes. The default is 512m
(512 MiB). Some importers may wish to lower this on <br>
systems with constrained memory.</p>

<p style="margin-top: 1em">--depth=&lt;n&gt; <br>
Maximum delta depth, for blob and tree deltification.
Default is 10.</p>


<p style="margin-top: 1em">--export-pack-edges=&lt;file&gt;
<br>
After creating a packfile, print a line of data to
&lt;file&gt; listing the filename of the packfile and the
last commit on each branch that was written to that
packfile. This <br>
information may be useful after importing projects whose
total object set exceeds the 4 GiB packfile limit, as these
commits can be used as edge points during calls to git <br>
pack-objects.</p>

<p style="margin-top: 1em">--max-pack-size=&lt;n&gt; <br>
Maximum size of each output packfile. The default is
unlimited.</p>

<p style="margin-top: 1em">PERFORMANCE <br>
The design of fast-import allows it to import large projects
in a minimum amount of memory usage and processing time.
Assuming the frontend is able to keep up with fast-import
<br>
and feed it a constant stream of data, import times for
projects holding 10+ years of history and containing
100,000+ individual commits are generally completed in just
1-2 hours <br>
on quite modest (~$2,000 USD) hardware.</p>

<p style="margin-top: 1em">Most bottlenecks appear to be in
foreign source data access (the source just cannot extract
revisions fast enough) or disk IO (fast-import writes as
fast as the disk will take <br>
the data). Imports will run faster if the source data is
stored on a different drive than the destination Git
repository (due to less IO contention).</p>

<p style="margin-top: 1em">DEVELOPMENT COST <br>
A typical frontend for fast-import tends to weigh in at
approximately 200 lines of Perl/Python/Ruby code. Most
developers have been able to create working importers in
just a <br>
couple of hours, even though it is their first exposure to
fast-import, and sometimes even to Git. This is an ideal
situation, given that most conversion tools are throw-away
<br>
(use once, and never look back).</p>

<p style="margin-top: 1em">PARALLEL OPERATION <br>
Like git push or git fetch, imports handled by fast-import
are safe to run alongside parallel git repack -a -d or git
gc invocations, or any other Git operation (including git
<br>
prune, as loose objects are never used by fast-import).</p>

<p style="margin-top: 1em">fast-import does not lock the
branch or tag refs it is actively importing. After the
import, during its ref update phase, fast-import tests each
existing branch ref to verify the <br>
update will be a fast-forward update (the commit stored in
the ref is contained in the new history of the commit to be
written). If the update is not a fast-forward update, <br>
fast-import will skip updating that ref and instead prints a
warning message. fast-import will always attempt to update
all branch refs, and does not stop on the first failure.</p>

<p style="margin-top: 1em">Branch updates can be forced
with --force, but it&acirc;s recommended that this only be
used on an otherwise quiet repository. Using --force is not
necessary for an initial import into <br>
an empty repository.</p>

<p style="margin-top: 1em">TECHNICAL DISCUSSION <br>
fast-import tracks a set of branches in memory. Any branch
can be created or modified at any point during the import
process by sending a commit command on the input stream.
This <br>
design allows a frontend program to process an unlimited
number of branches simultaneously, generating commits in the
order they are available from the source data. It also <br>
simplifies the frontend programs considerably.</p>

<p style="margin-top: 1em">fast-import does not use or
alter the current working directory, or any file within it.
(It does however update the current Git repository, as
referenced by GIT_DIR.) Therefore <br>
an import frontend may use the working directory for its own
purposes, such as extracting file revisions from the foreign
source. This ignorance of the working directory also <br>
allows fast-import to run very quickly, as it does not need
to perform any costly file update operations when switching
between branches.</p>

<p style="margin-top: 1em">INPUT FORMAT <br>
With the exception of raw file data (which Git does not
interpret) the fast-import input format is text (ASCII)
based. This text based format simplifies development and
debugging <br>
of frontend programs, especially when a higher level
language such as Perl, Python or Ruby is being used.</p>

<p style="margin-top: 1em">fast-import is very strict about
its input. Where we say SP below we mean exactly one space.
Likewise LF means one (and only one) linefeed and HT one
(and only one) horizontal <br>
tab. Supplying additional whitespace characters will cause
unexpected results, such as branch names or file names with
leading or trailing spaces in their name, or early <br>
termination of fast-import when it encounters unexpected
input.</p>

<p style="margin-top: 1em">Stream Comments <br>
To aid in debugging frontends fast-import ignores any line
that begins with # (ASCII pound/hash) up to and including
the line ending LF. A comment line may contain any sequence
<br>
of bytes that does not contain an LF and therefore may be
used to include any detailed debugging information that
might be specific to the frontend and useful when inspecting
a <br>
fast-import data stream.</p>

<p style="margin-top: 1em">Date Formats <br>
The following date formats are supported. A frontend should
select the format it will use for this import by passing the
format name in the --date-format=&lt;fmt&gt; command line
<br>
option.</p>

<p style="margin-top: 1em">raw <br>
This is the Git native format and is &lt;time&gt; SP
&lt;offutc&gt;. It is also fast-import&acirc;s default
format, if --date-format was not specified.</p>

<p style="margin-top: 1em">The time of the event is
specified by &lt;time&gt; as the number of seconds since the
UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an
ASCII decimal integer.</p>

<p style="margin-top: 1em">The local offset is specified by
&lt;offutc&gt; as a positive or negative offset from UTC.
For example EST (which is 5 hours behind UTC) would be
expressed in &lt;tz&gt; by &acirc;-0500&acirc; while <br>
UTC is &acirc;+0000&acirc;. The local offset does not affect
&lt;time&gt;; it is used only as an advisement to help
formatting routines display the timestamp.</p>

<p style="margin-top: 1em">If the local offset is not
available in the source material, use &acirc;+0000&acirc;,
or the most common local offset. For example many
organizations have a CVS repository which has only <br>
ever been accessed by users who are located in the same
location and timezone. In this case a reasonable offset from
UTC could be assumed.</p>

<p style="margin-top: 1em">Unlike the rfc2822 format, this
format is very strict. Any variation in formatting will
cause fast-import to reject the value.</p>

<p style="margin-top: 1em">rfc2822 <br>
This is the standard email format as described by RFC
2822.</p>

<p style="margin-top: 1em">An example value is &acirc;Tue
Feb 6 11:22:18 2007 -0500&acirc;. The Git parser is
accurate, but a little on the lenient side. It is the same
parser used by git am when applying patches <br>
received from email.</p>

<p style="margin-top: 1em">Some malformed strings may be
accepted as valid dates. In some of these cases Git will
still be able to obtain the correct date from the malformed
string. There are also some <br>
types of malformed strings which Git will parse wrong, and
yet consider valid. Seriously malformed strings will be
rejected.</p>

<p style="margin-top: 1em">Unlike the raw format above, the
timezone/UTC offset information contained in an RFC 2822
date string is used to adjust the date value to UTC prior to
storage. Therefore it <br>
is important that this information be as accurate as
possible.</p>

<p style="margin-top: 1em">If the source material uses RFC
2822 style dates, the frontend should let fast-import handle
the parsing and conversion (rather than attempting to do it
itself) as the Git <br>
parser has been well tested in the wild.</p>

<p style="margin-top: 1em">Frontends should prefer the raw
format if the source material already uses UNIX-epoch
format, can be coaxed to give dates in that format, or its
format is easily convertible <br>
to it, as there is no ambiguity in parsing.</p>

<p style="margin-top: 1em">now <br>
Always use the current time and timezone. The literal now
must always be supplied for &lt;when&gt;.</p>

<p style="margin-top: 1em">This is a toy format. The
current time and timezone of this system is always copied
into the identity string at the time it is being created by
fast-import. There is no way <br>
to specify a different time or timezone.</p>

<p style="margin-top: 1em">This particular format is
supplied as it&acirc;s short to implement and may be useful
to a process that wants to create a new commit right now,
without needing to use a working <br>
directory or git update-index.</p>

<p style="margin-top: 1em">If separate author and committer
commands are used in a commit the timestamps may not match,
as the system clock will be polled twice (once for each
command). The only way to <br>
ensure that both author and committer identity information
has the same timestamp is to omit author (thus copying from
committer) or to use a date format other than now.</p>

<p style="margin-top: 1em">Commands <br>
fast-import accepts several commands to update the current
repository and control the current import process. More
detailed discussion (with examples) of each command follows
<br>
later.</p>

<p style="margin-top: 1em">commit <br>
Creates a new branch or updates an existing branch by
creating a new commit and updating the branch to point at
the newly created commit.</p>

<p style="margin-top: 1em">tag <br>
Creates an annotated tag object from an existing commit or
branch. Lightweight tags are not supported by this command,
as they are not recommended for recording meaningful <br>
points in time.</p>

<p style="margin-top: 1em">reset <br>
Reset an existing branch (or a new branch) to a specific
revision. This command must be used to change a branch to a
specific revision without making a commit on it.</p>

<p style="margin-top: 1em">blob <br>
Convert raw file data into a blob, for future use in a
commit command. This command is optional and is not needed
to perform an import.</p>

<p style="margin-top: 1em">checkpoint <br>
Forces fast-import to close the current packfile, generate
its unique SHA-1 checksum and index, and start a new
packfile. This command is optional and is not needed to <br>
perform an import.</p>

<p style="margin-top: 1em">progress <br>
Causes fast-import to echo the entire line to its own
standard output. This command is optional and is not needed
to perform an import.</p>

<p style="margin-top: 1em">done <br>
Marks the end of the stream. This command is optional unless
the done feature was requested using the --done command line
option or feature done command.</p>

<p style="margin-top: 1em">cat-blob <br>
Causes fast-import to print a blob in cat-file --batch
format to the file descriptor set with --cat-blob-fd or
stdout if unspecified.</p>

<p style="margin-top: 1em">ls <br>
Causes fast-import to print a line describing a directory
entry in ls-tree format to the file descriptor set with
--cat-blob-fd or stdout if unspecified.</p>

<p style="margin-top: 1em">feature <br>
Require that fast-import supports the specified feature, or
abort if it does not.</p>

<p style="margin-top: 1em">option <br>
Specify any of the options listed under OPTIONS that do not
change stream semantic to suit the frontend&acirc;s needs.
This command is optional and is not needed to perform an
<br>
import.</p>

<p style="margin-top: 1em">commit <br>
Create or update a branch with a new commit, recording one
logical change to the project.</p>

<p style="margin-top: 1em">&rsquo;commit&rsquo; SP
&lt;ref&gt; LF <br>
mark? <br>
(&rsquo;author&rsquo; (SP &lt;name&gt;)? SP LT &lt;email&gt;
GT SP &lt;when&gt; LF)? <br>
&rsquo;committer&rsquo; (SP &lt;name&gt;)? SP LT
&lt;email&gt; GT SP &lt;when&gt; LF <br>
data <br>
(&rsquo;from&rsquo; SP &lt;committish&gt; LF)? <br>
(&rsquo;merge&rsquo; SP &lt;committish&gt; LF)? <br>
(filemodify | filedelete | filecopy | filerename |
filedeleteall | notemodify)* <br>
LF?</p>

<p style="margin-top: 1em">where &lt;ref&gt; is the name of
the branch to make the commit on. Typically branch names are
prefixed with refs/heads/ in Git, so importing the CVS
branch symbol RELENG-1_0 would use <br>
refs/heads/RELENG-1_0 for the value of &lt;ref&gt;. The
value of &lt;ref&gt; must be a valid refname in Git. As LF
is not valid in a Git refname, no quoting or escaping syntax
is supported <br>
here.</p>

<p style="margin-top: 1em">A mark command may optionally
appear, requesting fast-import to save a reference to the
newly created commit for future use by the frontend (see
below for format). It is very <br>
common for frontends to mark every commit they create,
thereby allowing future branch creation from any imported
commit.</p>

<p style="margin-top: 1em">The data command following
committer must supply the commit message (see below for data
command syntax). To import an empty commit message use a 0
length data. Commit messages <br>
are free-form and are not interpreted by Git. Currently they
must be encoded in UTF-8, as fast-import does not permit
other encodings to be specified.</p>

<p style="margin-top: 1em">Zero or more filemodify,
filedelete, filecopy, filerename, filedeleteall and
notemodify commands may be included to update the contents
of the branch prior to creating the <br>
commit. These commands may be supplied in any order. However
it is recommended that a filedeleteall command precede all
filemodify, filecopy, filerename and notemodify commands
<br>
in the same commit, as filedeleteall wipes the branch clean
(see below).</p>

<p style="margin-top: 1em">The LF after the command is
optional (it used to be required).</p>

<p style="margin-top: 1em">author <br>
An author command may optionally appear, if the author
information might differ from the committer information. If
author is omitted then fast-import will automatically use
<br>
the committer&acirc;s information for the author portion of
the commit. See below for a description of the fields in
author, as they are identical to committer.</p>

<p style="margin-top: 1em">committer <br>
The committer command indicates who made this commit, and
when they made it.</p>

<p style="margin-top: 1em">Here &lt;name&gt; is the
person&acirc;s display name (for example &acirc;Com M
Itter&acirc;) and &lt;email&gt; is the person&acirc;s email
address (&acirc;cm@example.com&acirc;). LT and GT are the
literal less-than (c) <br>
and greater-than (e) symbols. These are required to delimit
the email address from the other fields in the line. Note
that &lt;name&gt; and &lt;email&gt; are free-form and may
contain <br>
any sequence of bytes, except LT, GT and LF. &lt;name&gt; is
typically UTF-8 encoded.</p>

<p style="margin-top: 1em">The time of the change is
specified by &lt;when&gt; using the date format that was
selected by the --date-format=&lt;fmt&gt; command line
option. See &acirc;Date Formats&acirc; above for the set of
<br>
supported formats, and their syntax.</p>

<p style="margin-top: 1em">from <br>
The from command is used to specify the commit to initialize
this branch from. This revision will be the first ancestor
of the new commit. The state of the tree built at this <br>
commit will begin with the state at the from commit, and be
altered by the content modifications in this commit.</p>

<p style="margin-top: 1em">Omitting the from command in the
first commit of a new branch will cause fast-import to
create that commit with no ancestor. This tends to be
desired only for the initial <br>
commit of a project. If the frontend creates all files from
scratch when making a new branch, a merge command may be
used instead of from to start the commit with an empty <br>
tree. Omitting the from command on existing branches is
usually desired, as the current commit on that branch is
automatically assumed to be the first ancestor of the new
<br>
commit.</p>

<p style="margin-top: 1em">As LF is not valid in a Git
refname or SHA-1 expression, no quoting or escaping syntax
is supported within &lt;committish&gt;.</p>

<p style="margin-top: 1em">Here &lt;committish&gt; is any
of the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; The name of an
existing branch already in fast-import&acirc;s internal
branch table. If fast-import doesn&acirc;t know the name,
it&acirc;s treated as a SHA-1 expression.</p>

<p style="margin-top: 1em">&Acirc;&middot; A mark
reference, :&lt;idnum&gt;, where &lt;idnum&gt; is the mark
number.</p>

<p style="margin-top: 1em">The reason fast-import uses : to
denote a mark reference is this character is not legal in a
Git branch name. The leading : makes it easy to distinguish
between the mark <br>
42 (:42) and the branch 42 (42 or refs/heads/42), or an
abbreviated SHA-1 which happened to consist only of base-10
digits.</p>

<p style="margin-top: 1em">Marks must be declared (via
mark) before they can be used.</p>

<p style="margin-top: 1em">&Acirc;&middot; A complete 40
byte or abbreviated commit SHA-1 in hex.</p>

<p style="margin-top: 1em">&Acirc;&middot; Any valid Git
SHA-1 expression that resolves to a commit. See
&acirc;SPECIFYING REVISIONS&acirc; in gitrevisions(7) for
details.</p>

<p style="margin-top: 1em">The special case of restarting
an incremental import from the current branch value should
be written as:</p>

<p style="margin-top: 1em">from refs/heads/branch^0</p>

<p style="margin-top: 1em">The ^0 suffix is necessary as
fast-import does not permit a branch to start from itself,
and the branch is created in memory before the from command
is even read from the <br>
input. Adding ^0 will force fast-import to resolve the
commit through Git&acirc;s revision parsing library, rather
than its internal branch table, thereby loading in the
existing <br>
value of the branch.</p>

<p style="margin-top: 1em">merge <br>
Includes one additional ancestor commit. The additional
ancestry link does not change the way the tree state is
built at this commit. If the from command is omitted when
<br>
creating a new branch, the first merge commit will be the
first ancestor of the current commit, and the branch will
start out with no files. An unlimited number of merge <br>
commands per commit are permitted by fast-import, thereby
establishing an n-way merge. However Git&acirc;s other tools
never create commits with more than 15 additional ancestors
<br>
(forming a 16-way merge). For this reason it is suggested
that frontends do not use more than 15 merge commands per
commit; 16, if starting a new, empty branch.</p>

<p style="margin-top: 1em">Here &lt;committish&gt; is any
of the commit specification expressions also accepted by
from (see above).</p>

<p style="margin-top: 1em">filemodify <br>
Included in a commit command to add a new file or change the
content of an existing file. This command has two different
means of specifying the content of the file.</p>

<p style="margin-top: 1em">External data format <br>
The data content for the file was already supplied by a
prior blob command. The frontend just needs to connect
it.</p>

<p style="margin-top: 1em">&rsquo;M&rsquo; SP &lt;mode&gt;
SP &lt;dataref&gt; SP &lt;path&gt; LF</p>

<p style="margin-top: 1em">Here usually &lt;dataref&gt;
must be either a mark reference (:&lt;idnum&gt;) set by a
prior blob command, or a full 40-byte SHA-1 of an existing
Git blob object. If &lt;mode&gt; is <br>
040000&lsquo; then &lt;dataref&gt; must be the full 40-byte
SHA-1 of an existing Git tree object or a mark reference set
with --import-marks.</p>

<p style="margin-top: 1em">Inline data format <br>
The data content for the file has not been supplied yet. The
frontend wants to supply it as part of this modify
command.</p>

<p style="margin-top: 1em">&rsquo;M&rsquo; SP &lt;mode&gt;
SP &rsquo;inline&rsquo; SP &lt;path&gt; LF <br>
data</p>

<p style="margin-top: 1em">See below for a detailed
description of the data command.</p>

<p style="margin-top: 1em">In both formats &lt;mode&gt; is
the type of file entry, specified in octal. Git only
supports the following modes:</p>

<p style="margin-top: 1em">&Acirc;&middot; 100644 or 644: A
normal (not-executable) file. The majority of files in most
projects use this mode. If in doubt, this is what you
want.</p>

<p style="margin-top: 1em">&Acirc;&middot; 100755 or 755: A
normal, but executable, file.</p>

<p style="margin-top: 1em">&Acirc;&middot; 120000: A
symlink, the content of the file will be the link
target.</p>

<p style="margin-top: 1em">&Acirc;&middot; 160000: A
gitlink, SHA-1 of the object refers to a commit in another
repository. Git links can only be specified by SHA or
through a commit mark. They are used to <br>
implement submodules.</p>

<p style="margin-top: 1em">&Acirc;&middot; 040000: A
subdirectory. Subdirectories can only be specified by SHA or
through a tree mark set with --import-marks.</p>

<p style="margin-top: 1em">In both formats &lt;path&gt; is
the complete path of the file to be added (if not already
existing) or modified (if already existing).</p>

<p style="margin-top: 1em">A &lt;path&gt; string must use
UNIX-style directory separators (forward slash /), may
contain any byte other than LF, and must not start with
double quote (&quot;).</p>

<p style="margin-top: 1em">A path can use C-style string
quoting; this is accepted in all cases and mandatory if the
filename starts with double quote or contains LF. In C-style
quoting, the complete <br>
name should be surrounded with double quotes, and any LF,
backslash, or double quote characters must be escaped by
preceding them with a backslash (e.g., &quot;path/with0 \
and</p>

<p style="margin-top: 1em">The value of &lt;path&gt; must
be in canonical form. That is it must not:</p>

<p style="margin-top: 1em">&Acirc;&middot; contain an empty
directory component (e.g. foo//bar is invalid),</p>

<p style="margin-top: 1em">&Acirc;&middot; end with a
directory separator (e.g. foo/ is invalid),</p>

<p style="margin-top: 1em">&Acirc;&middot; start with a
directory separator (e.g. /foo is invalid),</p>

<p style="margin-top: 1em">&Acirc;&middot; contain the
special component . or .. (e.g. foo/./bar and foo/../bar are
invalid).</p>

<p style="margin-top: 1em">The root of the tree can be
represented by an empty string as &lt;path&gt;.</p>

<p style="margin-top: 1em">It is recommended that
&lt;path&gt; always be encoded using UTF-8.</p>

<p style="margin-top: 1em">filedelete <br>
Included in a commit command to remove a file or recursively
delete an entire directory from the branch. If the file or
directory removal makes its parent directory empty, <br>
the parent directory will be automatically removed too. This
cascades up the tree until the first non-empty directory or
the root is reached.</p>

<p style="margin-top: 1em">&rsquo;D&rsquo; SP &lt;path&gt;
LF</p>

<p style="margin-top: 1em">here &lt;path&gt; is the
complete path of the file or subdirectory to be removed from
the branch. See filemodify above for a detailed description
of &lt;path&gt;.</p>

<p style="margin-top: 1em">filecopy <br>
Recursively copies an existing file or subdirectory to a
different location within the branch. The existing file or
directory must exist. If the destination exists it will be
<br>
completely replaced by the content copied from the
source.</p>

<p style="margin-top: 1em">&rsquo;C&rsquo; SP &lt;path&gt;
SP &lt;path&gt; LF</p>

<p style="margin-top: 1em">here the first &lt;path&gt; is
the source location and the second &lt;path&gt; is the
destination. See filemodify above for a detailed description
of what &lt;path&gt; may look like. To use a <br>
source path that contains SP the path must be quoted.</p>

<p style="margin-top: 1em">A filecopy command takes effect
immediately. Once the source location has been copied to the
destination any future commands applied to the source
location will not impact <br>
the destination of the copy.</p>

<p style="margin-top: 1em">filerename <br>
Renames an existing file or subdirectory to a different
location within the branch. The existing file or directory
must exist. If the destination exists it will be replaced
<br>
by the source directory.</p>

<p style="margin-top: 1em">&rsquo;R&rsquo; SP &lt;path&gt;
SP &lt;path&gt; LF</p>

<p style="margin-top: 1em">here the first &lt;path&gt; is
the source location and the second &lt;path&gt; is the
destination. See filemodify above for a detailed description
of what &lt;path&gt; may look like. To use a <br>
source path that contains SP the path must be quoted.</p>

<p style="margin-top: 1em">A filerename command takes
effect immediately. Once the source location has been
renamed to the destination any future commands applied to
the source location will create new <br>
files there and not impact the destination of the
rename.</p>

<p style="margin-top: 1em">Note that a filerename is the
same as a filecopy followed by a filedelete of the source
location. There is a slight performance advantage to using
filerename, but the <br>
advantage is so small that it is never worth trying to
convert a delete/add pair in source material into a rename
for fast-import. This filerename command is provided just to
<br>
simplify frontends that already have rename information and
don&acirc;t want bother with decomposing it into a filecopy
followed by a filedelete.</p>

<p style="margin-top: 1em">filedeleteall <br>
Included in a commit command to remove all files (and also
all directories) from the branch. This command resets the
internal branch structure to have no files in it, <br>
allowing the frontend to subsequently add all interesting
files from scratch.</p>

<p style="margin-top: 1em">&rsquo;deleteall&rsquo; LF</p>

<p style="margin-top: 1em">This command is extremely useful
if the frontend does not know (or does not care to know)
what files are currently on the branch, and therefore cannot
generate the proper <br>
filedelete commands to update the content.</p>

<p style="margin-top: 1em">Issuing a filedeleteall followed
by the needed filemodify commands to set the correct content
will produce the same results as sending only the needed
filemodify and <br>
filedelete commands. The filedeleteall approach may however
require fast-import to use slightly more memory per active
branch (less than 1 MiB for even most large projects); <br>
so frontends that can easily obtain only the affected paths
for a commit are encouraged to do so.</p>

<p style="margin-top: 1em">notemodify <br>
Included in a commit &lt;notes_ref&gt; command to add a new
note annotating a &lt;committish&gt; or change this
annotation contents. Internally it is similar to filemodify
100644 on <br>
&lt;committish&gt; path (maybe split into subdirectories).
It&acirc;s not advised to use any other commands to write to
the &lt;notes_ref&gt; tree except filedeleteall to delete
all existing <br>
notes in this tree. This command has two different means of
specifying the content of the note.</p>

<p style="margin-top: 1em">External data format <br>
The data content for the note was already supplied by a
prior blob command. The frontend just needs to connect it to
the commit that is to be annotated.</p>

<p style="margin-top: 1em">&rsquo;N&rsquo; SP
&lt;dataref&gt; SP &lt;committish&gt; LF</p>

<p style="margin-top: 1em">Here &lt;dataref&gt; can be
either a mark reference (:&lt;idnum&gt;) set by a prior blob
command, or a full 40-byte SHA-1 of an existing Git blob
object.</p>

<p style="margin-top: 1em">Inline data format <br>
The data content for the note has not been supplied yet. The
frontend wants to supply it as part of this modify
command.</p>

<p style="margin-top: 1em">&rsquo;N&rsquo; SP
&rsquo;inline&rsquo; SP &lt;committish&gt; LF <br>
data</p>

<p style="margin-top: 1em">See below for a detailed
description of the data command.</p>

<p style="margin-top: 1em">In both formats
&lt;committish&gt; is any of the commit specification
expressions also accepted by from (see above).</p>

<p style="margin-top: 1em">mark <br>
Arranges for fast-import to save a reference to the current
object, allowing the frontend to recall this object at a
future point in time, without knowing its SHA-1. Here the
<br>
current object is the object creation command the mark
command appears within. This can be commit, tag, and blob,
but commit is the most common usage.</p>

<p style="margin-top: 1em">&rsquo;mark&rsquo; SP
&rsquo;:&rsquo; &lt;idnum&gt; LF</p>

<p style="margin-top: 1em">where &lt;idnum&gt; is the
number assigned by the frontend to this mark. The value of
&lt;idnum&gt; is expressed as an ASCII decimal integer. The
value 0 is reserved and cannot be used as a <br>
mark. Only values greater than or equal to 1 may be used as
marks.</p>

<p style="margin-top: 1em">New marks are created
automatically. Existing marks can be moved to another object
simply by reusing the same &lt;idnum&gt; in another mark
command.</p>

<p style="margin-top: 1em">tag <br>
Creates an annotated tag referring to a specific commit. To
create lightweight (non-annotated) tags see the reset
command below.</p>

<p style="margin-top: 1em">&rsquo;tag&rsquo; SP
&lt;name&gt; LF <br>
&rsquo;from&rsquo; SP &lt;committish&gt; LF <br>
&rsquo;tagger&rsquo; (SP &lt;name&gt;)? SP LT &lt;email&gt;
GT SP &lt;when&gt; LF <br>
data</p>

<p style="margin-top: 1em">where &lt;name&gt; is the name
of the tag to create.</p>

<p style="margin-top: 1em">Tag names are automatically
prefixed with refs/tags/ when stored in Git, so importing
the CVS branch symbol RELENG-1_0-FINAL would use just
RELENG-1_0-FINAL for &lt;name&gt;, and <br>
fast-import will write the corresponding ref as
refs/tags/RELENG-1_0-FINAL.</p>

<p style="margin-top: 1em">The value of &lt;name&gt; must
be a valid refname in Git and therefore may contain forward
slashes. As LF is not valid in a Git refname, no quoting or
escaping syntax is supported <br>
here.</p>

<p style="margin-top: 1em">The from command is the same as
in the commit command; see above for details.</p>

<p style="margin-top: 1em">The tagger command uses the same
format as committer within commit; again see above for
details.</p>

<p style="margin-top: 1em">The data command following
tagger must supply the annotated tag message (see below for
data command syntax). To import an empty tag message use a 0
length data. Tag messages are <br>
free-form and are not interpreted by Git. Currently they
must be encoded in UTF-8, as fast-import does not permit
other encodings to be specified.</p>

<p style="margin-top: 1em">Signing annotated tags during
import from within fast-import is not supported. Trying to
include your own PGP/GPG signature is not recommended, as
the frontend does not (easily) <br>
have access to the complete set of bytes which normally goes
into such a signature. If signing is required, create
lightweight tags from within fast-import with reset, then
<br>
create the annotated versions of those tags offline with the
standard git tag process.</p>

<p style="margin-top: 1em">reset <br>
Creates (or recreates) the named branch, optionally starting
from a specific revision. The reset command allows a
frontend to issue a new from command for an existing branch,
or <br>
to create a new branch from an existing commit without
creating a new commit.</p>

<p style="margin-top: 1em">&rsquo;reset&rsquo; SP
&lt;ref&gt; LF <br>
(&rsquo;from&rsquo; SP &lt;committish&gt; LF)? <br>
LF?</p>

<p style="margin-top: 1em">For a detailed description of
&lt;ref&gt; and &lt;committish&gt; see above under commit
and from.</p>

<p style="margin-top: 1em">The LF after the command is
optional (it used to be required).</p>

<p style="margin-top: 1em">The reset command can also be
used to create lightweight (non-annotated) tags. For
example:</p>

<p style="margin-top: 1em">reset refs/tags/938 <br>
from :938</p>

<p style="margin-top: 1em">would create the lightweight tag
refs/tags/938 referring to whatever commit mark :938
references.</p>

<p style="margin-top: 1em">blob <br>
Requests writing one file revision to the packfile. The
revision is not connected to any commit; this connection
must be formed in a subsequent commit command by referencing
the <br>
blob through an assigned mark.</p>

<p style="margin-top: 1em">&rsquo;blob&rsquo; LF <br>
mark? <br>
data</p>

<p style="margin-top: 1em">The mark command is optional
here as some frontends have chosen to generate the Git SHA-1
for the blob on their own, and feed that directly to commit.
This is typically more work <br>
than it&acirc;s worth however, as marks are inexpensive to
store and easy to use.</p>

<p style="margin-top: 1em">data <br>
Supplies raw data (for use as blob/file content, commit
messages, or annotated tag messages) to fast-import. Data
can be supplied using an exact byte count or delimited with
a <br>
terminating line. Real frontends intended for
production-quality conversions should always use the exact
byte count format, as it is more robust and performs better.
The <br>
delimited format is intended primarily for testing
fast-import.</p>

<p style="margin-top: 1em">Comment lines appearing within
the &lt;raw&gt; part of data commands are always taken to be
part of the body of the data and are therefore never ignored
by fast-import. This makes it <br>
safe to import any file/message content whose lines might
start with #.</p>

<p style="margin-top: 1em">Exact byte count format <br>
The frontend must specify the number of bytes of data.</p>

<p style="margin-top: 1em">&rsquo;data&rsquo; SP
&lt;count&gt; LF <br>
&lt;raw&gt; LF?</p>

<p style="margin-top: 1em">where &lt;count&gt; is the exact
number of bytes appearing within &lt;raw&gt;. The value of
&lt;count&gt; is expressed as an ASCII decimal integer. The
LF on either side of &lt;raw&gt; is not <br>
included in &lt;count&gt; and will not be included in the
imported data.</p>

<p style="margin-top: 1em">The LF after &lt;raw&gt; is
optional (it used to be required) but recommended. Always
including it makes debugging a fast-import stream easier as
the next command always starts in <br>
column 0 of the next line, even if &lt;raw&gt; did not end
with an LF.</p>

<p style="margin-top: 1em">Delimited format <br>
A delimiter string is used to mark the end of the data.
fast-import will compute the length by searching for the
delimiter. This format is primarily useful for testing and
is <br>
not recommended for real data.</p>

<p style="margin-top: 1em">&rsquo;data&rsquo; SP
&rsquo;&lt;&lt;&rsquo; &lt;delim&gt; LF <br>
&lt;raw&gt; LF <br>
&lt;delim&gt; LF <br>
LF?</p>

<p style="margin-top: 1em">where &lt;delim&gt; is the
chosen delimiter string. The string &lt;delim&gt; must not
appear on a line by itself within &lt;raw&gt;, as otherwise
fast-import will think the data ends earlier <br>
than it really does. The LF immediately trailing &lt;raw&gt;
is part of &lt;raw&gt;. This is one of the limitations of
the delimited format, it is impossible to supply a data
chunk which <br>
does not have an LF as its last byte.</p>

<p style="margin-top: 1em">The LF after &lt;delim&gt; LF is
optional (it used to be required).</p>

<p style="margin-top: 1em">checkpoint <br>
Forces fast-import to close the current packfile, start a
new one, and to save out all current branch refs, tags and
marks.</p>

<p style="margin-top: 1em">&rsquo;checkpoint&rsquo; LF <br>
LF?</p>

<p style="margin-top: 1em">Note that fast-import
automatically switches packfiles when the current packfile
reaches --max-pack-size, or 4 GiB, whichever limit is
smaller. During an automatic packfile <br>
switch fast-import does not update the branch refs, tags or
marks.</p>

<p style="margin-top: 1em">As a checkpoint can require a
significant amount of CPU time and disk IO (to compute the
overall pack SHA-1 checksum, generate the corresponding
index file, and update the refs) <br>
it can easily take several minutes for a single checkpoint
command to complete.</p>

<p style="margin-top: 1em">Frontends may choose to issue
checkpoints during extremely large and long running imports,
or when they need to allow another Git process access to a
branch. However given that a <br>
30 GiB Subversion repository can be loaded into Git through
fast-import in about 3 hours, explicit checkpointing may not
be necessary.</p>

<p style="margin-top: 1em">The LF after the command is
optional (it used to be required).</p>

<p style="margin-top: 1em">progress <br>
Causes fast-import to print the entire progress line
unmodified to its standard output channel (file descriptor
1) when the command is processed from the input stream. The
<br>
command otherwise has no impact on the current import, or on
any of fast-import&acirc;s internal state.</p>

<p style="margin-top: 1em">&rsquo;progress&rsquo; SP
&lt;any&gt; LF <br>
LF?</p>

<p style="margin-top: 1em">The &lt;any&gt; part of the
command may contain any sequence of bytes that does not
contain LF. The LF after the command is optional. Callers
may wish to process the output through a <br>
tool such as sed to remove the leading part of the line, for
example:</p>

<p style="margin-top: 1em">frontend | git fast-import | sed
&rsquo;s/^progress //&rsquo;</p>

<p style="margin-top: 1em">Placing a progress command
immediately after a checkpoint will inform the reader when
the checkpoint has been completed and it can safely access
the refs that fast-import <br>
updated.</p>

<p style="margin-top: 1em">cat-blob <br>
Causes fast-import to print a blob to a file descriptor
previously arranged with the --cat-blob-fd argument. The
command otherwise has no impact on the current import; its
main <br>
purpose is to retrieve blobs that may be in
fast-import&acirc;s memory but not accessible from the
target repository.</p>

<p style="margin-top: 1em">&rsquo;cat-blob&rsquo; SP
&lt;dataref&gt; LF</p>

<p style="margin-top: 1em">The &lt;dataref&gt; can be
either a mark reference (:&lt;idnum&gt;) set previously or a
full 40-byte SHA-1 of a Git blob, preexisting or ready to be
written.</p>

<p style="margin-top: 1em">Output uses the same format as
git cat-file --batch:</p>

<p style="margin-top: 1em">&lt;sha1&gt; SP
&rsquo;blob&rsquo; SP &lt;size&gt; LF <br>
&lt;contents&gt; LF</p>

<p style="margin-top: 1em">This command can be used
anywhere in the stream that comments are accepted. In
particular, the cat-blob command can be used in the middle
of a commit but not in the middle of a <br>
data command.</p>

<p style="margin-top: 1em">See &acirc;Responses To
Commands&acirc; below for details about how to read this
output safely.</p>

<p style="margin-top: 1em">ls <br>
Prints information about the object at a path to a file
descriptor previously arranged with the --cat-blob-fd
argument. This allows printing a blob from the active commit
(with <br>
cat-blob) or copying a blob or tree from a previous commit
for use in the current one (with filemodify).</p>

<p style="margin-top: 1em">The ls command can be used
anywhere in the stream that comments are accepted, including
the middle of a commit.</p>

<p style="margin-top: 1em">Reading from the active commit
<br>
This form can only be used in the middle of a commit. The
path names a directory entry within fast-import&acirc;s
active commit. The path must be quoted in this case.</p>

<p style="margin-top: 1em">&rsquo;ls&rsquo; SP &lt;path&gt;
LF</p>

<p style="margin-top: 1em">Reading from a named tree <br>
The &lt;dataref&gt; can be a mark reference (:&lt;idnum&gt;)
or the full 40-byte SHA-1 of a Git tag, commit, or tree
object, preexisting or waiting to be written. The path is
relative to <br>
the top level of the tree named by &lt;dataref&gt;.</p>

<p style="margin-top: 1em">&rsquo;ls&rsquo; SP
&lt;dataref&gt; SP &lt;path&gt; LF</p>

<p style="margin-top: 1em">See filemodify above for a
detailed description of &lt;path&gt;.</p>

<p style="margin-top: 1em">Output uses the same format as
git ls-tree &lt;tree&gt; -- &lt;path&gt;:</p>

<p style="margin-top: 1em">&lt;mode&gt; SP
(&rsquo;blob&rsquo; | &rsquo;tree&rsquo; |
&rsquo;commit&rsquo;) SP &lt;dataref&gt; HT &lt;path&gt;
LF</p>

<p style="margin-top: 1em">The &lt;dataref&gt; represents
the blob, tree, or commit object at &lt;path&gt; and can be
used in later cat-blob, filemodify, or ls commands.</p>

<p style="margin-top: 1em">If there is no file or subtree
at that path, git fast-import will instead report</p>

<p style="margin-top: 1em">missing SP &lt;path&gt; LF</p>

<p style="margin-top: 1em">See &acirc;Responses To
Commands&acirc; below for details about how to read this
output safely.</p>

<p style="margin-top: 1em">feature <br>
Require that fast-import supports the specified feature, or
abort if it does not.</p>

<p style="margin-top: 1em">&rsquo;feature&rsquo; SP
&lt;feature&gt; (&rsquo;=&rsquo; &lt;argument&gt;)? LF</p>

<p style="margin-top: 1em">The &lt;feature&gt; part of the
command may be any one of the following:</p>

<p style="margin-top: 1em">date-format, export-marks,
relative-marks, no-relative-marks, force <br>
Act as though the corresponding command-line option with a
leading -- was passed on the command line (see OPTIONS,
above).</p>

<p style="margin-top: 1em">import-marks,
import-marks-if-exists <br>
Like --import-marks except in two respects: first, only one
&quot;feature import-marks&quot; or &quot;feature
import-marks-if-exists&quot; command is allowed per stream;
second, an <br>
--import-marks= or --import-marks-if-exists command-line
option overrides any of these &quot;feature&quot; commands
in the stream; third, &quot;feature
import-marks-if-exists&quot; like a <br>
corresponding command-line option silently skips a
nonexistent file.</p>

<p style="margin-top: 1em">cat-blob, ls <br>
Require that the backend support the cat-blob or ls command.
Versions of fast-import not supporting the specified command
will exit with a message indicating so. This lets <br>
the import error out early with a clear message, rather than
wasting time on the early part of an import before the
unsupported command is detected.</p>

<p style="margin-top: 1em">notes <br>
Require that the backend support the notemodify (N)
subcommand to the commit command. Versions of fast-import
not supporting notes will exit with a message indicating
so.</p>

<p style="margin-top: 1em">done <br>
Error out if the stream ends without a done command. Without
this feature, errors causing the frontend to end abruptly at
a convenient point in the stream can go undetected. <br>
This may occur, for example, if an import front end dies in
mid-operation without emitting SIGTERM or SIGKILL at its
subordinate git fast-import instance.</p>

<p style="margin-top: 1em">option <br>
Processes the specified option so that git fast-import
behaves in a way that suits the frontend&acirc;s needs. Note
that options specified by the frontend are overridden by any
options <br>
the user may specify to git fast-import itself.</p>

<p style="margin-top: 1em">&rsquo;option&rsquo; SP
&lt;option&gt; LF</p>

<p style="margin-top: 1em">The &lt;option&gt; part of the
command may contain any of the options listed in the OPTIONS
section that do not change import semantics, without the
leading -- and is treated in the <br>
same way.</p>

<p style="margin-top: 1em">Option commands must be the
first commands on the input (not counting feature commands),
to give an option command after any non-option command is an
error.</p>

<p style="margin-top: 1em">The following commandline
options change import semantics and may therefore not be
passed as option:</p>

<p style="margin-top: 1em">&Acirc;&middot; date-format</p>

<p style="margin-top: 1em">&Acirc;&middot; import-marks</p>

<p style="margin-top: 1em">&Acirc;&middot; export-marks</p>

<p style="margin-top: 1em">&Acirc;&middot; cat-blob-fd</p>

<p style="margin-top: 1em">&Acirc;&middot; force</p>

<p style="margin-top: 1em">done <br>
If the done feature is not in use, treated as if EOF was
read. This can be used to tell fast-import to finish
early.</p>

<p style="margin-top: 1em">If the --done command line
option or feature done command is in use, the done command
is mandatory and marks the end of the stream.</p>

<p style="margin-top: 1em">RESPONSES TO COMMANDS <br>
New objects written by fast-import are not available
immediately. Most fast-import commands have no visible
effect until the next checkpoint (or completion). The
frontend can <br>
send commands to fill fast-import&acirc;s input pipe without
worrying about how quickly they will take effect, which
improves performance by simplifying scheduling.</p>

<p style="margin-top: 1em">For some frontends, though, it
is useful to be able to read back data from the current
repository as it is being updated (for example when the
source material describes objects <br>
in terms of patches to be applied to previously imported
objects). This can be accomplished by connecting the
frontend and fast-import via bidirectional pipes:</p>

<p style="margin-top: 1em">mkfifo fast-import-output <br>
frontend &lt;fast-import-output | <br>
git fast-import &gt;fast-import-output</p>

<p style="margin-top: 1em">A frontend set up this way can
use progress, ls, and cat-blob commands to read information
from the import in progress.</p>

<p style="margin-top: 1em">To avoid deadlock, such
frontends must completely consume any pending output from
progress, ls, and cat-blob before performing writes to
fast-import that might block.</p>

<p style="margin-top: 1em">CRASH REPORTS <br>
If fast-import is supplied invalid input it will terminate
with a non-zero exit status and create a crash report in the
top level of the Git repository it was importing into. <br>
Crash reports contain a snapshot of the internal fast-import
state as well as the most recent commands that lead up to
the crash.</p>

<p style="margin-top: 1em">All recent commands (including
stream comments, file changes and progress commands) are
shown in the command history within the crash report, but
raw file data and commit <br>
messages are excluded from the crash report. This exclusion
saves space within the report file and reduces the amount of
buffering that fast-import must perform during
execution.</p>

<p style="margin-top: 1em">After writing a crash report
fast-import will close the current packfile and export the
marks table. This allows the frontend developer to inspect
the repository state and resume <br>
the import from the point where it crashed. The modified
branches and tags are not updated during a crash, as the
import did not complete successfully. Branch and tag
information <br>
can be found in the crash report and must be applied
manually if the update is needed.</p>

<p style="margin-top: 1em">An example crash:</p>

<p style="margin-top: 1em">$ cat &gt;in
&lt;&lt;END_OF_INPUT <br>
# my very first test commit <br>
commit refs/heads/master <br>
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400 <br>
# who is that guy anyway? <br>
data &lt;&lt;EOF <br>
this is my commit <br>
EOF <br>
M 644 inline .gitignore <br>
data &lt;&lt;EOF <br>
.gitignore <br>
EOF <br>
M 777 inline bob <br>
END_OF_INPUT</p>

<p style="margin-top: 1em">$ git fast-import &lt;in <br>
fatal: Corrupt mode: M 777 inline bob <br>
fast-import: dumping crash report to
.git/fast_import_crash_8434</p>

<p style="margin-top: 1em">$ cat
.git/fast_import_crash_8434 <br>
fast-import crash report: <br>
fast-import process: 8434 <br>
parent process : 1391 <br>
at Sat Sep 1 00:58:12 2007</p>

<p style="margin-top: 1em">fatal: Corrupt mode: M 777
inline bob</p>

<p style="margin-top: 1em">Most Recent Commands Before
Crash <br>
--------------------------------- <br>
# my very first test commit <br>
commit refs/heads/master <br>
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400 <br>
# who is that guy anyway? <br>
data &lt;&lt;EOF <br>
M 644 inline .gitignore <br>
data &lt;&lt;EOF <br>
* M 777 inline bob</p>

<p style="margin-top: 1em">Active Branch LRU <br>
----------------- <br>
active_branches = 1 cur, 5 max</p>

<p style="margin-top: 1em">pos clock name <br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <br>
1) 0 refs/heads/master</p>

<p style="margin-top: 1em">Inactive Branches <br>
----------------- <br>
refs/heads/master: <br>
status : active loaded dirty <br>
tip commit : 0000000000000000000000000000000000000000 <br>
old tree : 0000000000000000000000000000000000000000 <br>
cur tree : 0000000000000000000000000000000000000000 <br>
commit clock: 0 <br>
last pack :</p>

<p style="margin-top: 1em">------------------- <br>
END OF CRASH REPORT</p>

<p style="margin-top: 1em">TIPS AND TRICKS <br>
The following tips and tricks have been collected from
various users of fast-import, and are offered here as
suggestions.</p>

<p style="margin-top: 1em">Use One Mark Per Commit <br>
When doing a repository conversion, use a unique mark per
commit (mark :&lt;n&gt;) and supply the --export-marks
option on the command line. fast-import will dump a file
which lists <br>
every mark and the Git object SHA-1 that corresponds to it.
If the frontend can tie the marks back to the source
repository, it is easy to verify the accuracy and
completeness of <br>
the import by comparing each Git commit to the corresponding
source revision.</p>

<p style="margin-top: 1em">Coming from a system such as
Perforce or Subversion this should be quite simple, as the
fast-import mark can also be the Perforce changeset number
or the Subversion revision <br>
number.</p>

<p style="margin-top: 1em">Freely Skip Around Branches <br>
Don&acirc;t bother trying to optimize the frontend to stick
to one branch at a time during an import. Although doing so
might be slightly faster for fast-import, it tends to
increase <br>
the complexity of the frontend code considerably.</p>

<p style="margin-top: 1em">The branch LRU builtin to
fast-import tends to behave very well, and the cost of
activating an inactive branch is so low that bouncing around
between branches has virtually no <br>
impact on import performance.</p>

<p style="margin-top: 1em">Handling Renames <br>
When importing a renamed file or directory, simply delete
the old name(s) and modify the new name(s) during the
corresponding commit. Git performs rename detection <br>
after-the-fact, rather than explicitly during a commit.</p>

<p style="margin-top: 1em">Use Tag Fixup Branches <br>
Some other SCM systems let the user create a tag from
multiple files which are not from the same commit/changeset.
Or to create tags which are a subset of the files available
in <br>
the repository.</p>

<p style="margin-top: 1em">Importing these tags as-is in
Git is impossible without making at least one commit which
&acirc;fixes up&acirc; the files to match the content of the
tag. Use fast-import&acirc;s reset command to <br>
reset a dummy branch outside of your normal branch space to
the base commit for the tag, then commit one or more file
fixup commits, and finally tag the dummy branch.</p>

<p style="margin-top: 1em">For example since all normal
branches are stored under refs/heads/ name the tag fixup
branch TAG_FIXUP. This way it is impossible for the fixup
branch used by the importer to <br>
have namespace conflicts with real branches imported from
the source (the name TAG_FIXUP is not
refs/heads/TAG_FIXUP).</p>

<p style="margin-top: 1em">When committing fixups, consider
using merge to connect the commit(s) which are supplying
file revisions to the fixup branch. Doing so will allow
tools such as git blame to track <br>
through the real commit history and properly annotate the
source files.</p>

<p style="margin-top: 1em">After fast-import terminates the
frontend will need to do rm .git/TAG_FIXUP to remove the
dummy branch.</p>

<p style="margin-top: 1em">Import Now, Repack Later <br>
As soon as fast-import completes the Git repository is
completely valid and ready for use. Typically this takes
only a very short time, even for considerably large projects
<br>
(100,000+ commits).</p>

<p style="margin-top: 1em">However repacking the repository
is necessary to improve data locality and access
performance. It can also take hours on extremely large
projects (especially if -f and a large <br>
--window parameter is used). Since repacking is safe to run
alongside readers and writers, run the repack in the
background and let it finish when it finishes. There is no
reason <br>
to wait to explore your new Git project!</p>

<p style="margin-top: 1em">If you choose to wait for the
repack, don&acirc;t try to run benchmarks or performance
tests until repacking is completed. fast-import outputs
suboptimal packfiles that are simply <br>
never seen in real use situations.</p>

<p style="margin-top: 1em">Repacking Historical Data <br>
If you are repacking very old imported data (e.g. older than
the last year), consider expending some extra CPU time and
supplying --window=50 (or higher) when you run git repack.
<br>
This will take longer, but will also produce a smaller
packfile. You only need to expend the effort once, and
everyone using your project will benefit from the smaller
<br>
repository.</p>

<p style="margin-top: 1em">Include Some Progress Messages
<br>
Every once in a while have your frontend emit a progress
message to fast-import. The contents of the messages are
entirely free-form, so one suggestion would be to output the
<br>
current month and year each time the current commit date
moves into the next month. Your users will feel better
knowing how much of the data stream has been processed.</p>

<p style="margin-top: 1em">PACKFILE OPTIMIZATION <br>
When packing a blob fast-import always attempts to deltify
against the last blob written. Unless specifically arranged
for by the frontend, this will probably not be a prior <br>
version of the same file, so the generated delta will not be
the smallest possible. The resulting packfile will be
compressed, but will not be optimal.</p>

<p style="margin-top: 1em">Frontends which have efficient
access to all revisions of a single file (for example
reading an RCS/CVS ,v file) can choose to supply all
revisions of that file as a sequence of <br>
consecutive blob commands. This allows fast-import to
deltify the different file revisions against each other,
saving space in the final packfile. Marks can be used to
later <br>
identify individual file revisions during a sequence of
commit commands.</p>

<p style="margin-top: 1em">The packfile(s) created by
fast-import do not encourage good disk access patterns. This
is caused by fast-import writing the data in the order it is
received on standard input, <br>
while Git typically organizes data within packfiles to make
the most recent (current tip) data appear before historical
data. Git also clusters commits together, speeding up <br>
revision traversal through better cache locality.</p>

<p style="margin-top: 1em">For this reason it is strongly
recommended that users repack the repository with git repack
-a -d after fast-import completes, allowing Git to
reorganize the packfiles for faster <br>
data access. If blob deltas are suboptimal (see above) then
also adding the -f option to force recomputation of all
deltas can significantly reduce the final packfile size <br>
(30-50% smaller can be quite typical).</p>

<p style="margin-top: 1em">MEMORY UTILIZATION <br>
There are a number of factors which affect how much memory
fast-import requires to perform an import. Like critical
sections of core Git, fast-import uses its own memory <br>
allocators to amortize any overheads associated with malloc.
In practice fast-import tends to amortize any malloc
overheads to 0, due to its use of large block
allocations.</p>

<p style="margin-top: 1em">per object <br>
fast-import maintains an in-memory structure for every
object written in this execution. On a 32 bit system the
structure is 32 bytes, on a 64 bit system the structure is
40 <br>
bytes (due to the larger pointer sizes). Objects in the
table are not deallocated until fast-import terminates.
Importing 2 million objects on a 32 bit system will require
<br>
approximately 64 MiB of memory.</p>

<p style="margin-top: 1em">The object table is actually a
hashtable keyed on the object name (the unique SHA-1). This
storage configuration allows fast-import to reuse an
existing or already written object <br>
and avoid writing duplicates to the output packfile.
Duplicate blobs are surprisingly common in an import,
typically due to branch merges in the source.</p>

<p style="margin-top: 1em">per mark <br>
Marks are stored in a sparse array, using 1 pointer (4 bytes
or 8 bytes, depending on pointer size) per mark. Although
the array is sparse, frontends are still strongly <br>
encouraged to use marks between 1 and n, where n is the
total number of marks required for this import.</p>

<p style="margin-top: 1em">per branch <br>
Branches are classified as active and inactive. The memory
usage of the two classes is significantly different.</p>

<p style="margin-top: 1em">Inactive branches are stored in
a structure which uses 96 or 120 bytes (32 bit or 64 bit
systems, respectively), plus the length of the branch name
(typically under 200 bytes), <br>
per branch. fast-import will easily handle as many as 10,000
inactive branches in under 2 MiB of memory.</p>

<p style="margin-top: 1em">Active branches have the same
overhead as inactive branches, but also contain copies of
every tree that has been recently modified on that branch.
If subtree include has not been <br>
modified since the branch became active, its contents will
not be loaded into memory, but if subtree src has been
modified by a commit since the branch became active, then
its <br>
contents will be loaded in memory.</p>

<p style="margin-top: 1em">As active branches store
metadata about the files contained on that branch, their
in-memory storage size can grow to a considerable size (see
below).</p>

<p style="margin-top: 1em">fast-import automatically moves
active branches to inactive status based on a simple
least-recently-used algorithm. The LRU chain is updated on
each commit command. The maximum <br>
number of active branches can be increased or decreased on
the command line with --active-branches=.</p>

<p style="margin-top: 1em">per active tree <br>
Trees (aka directories) use just 12 bytes of memory on top
of the memory required for their entries (see &acirc;per
active file&acirc; below). The cost of a tree is virtually
0, as its <br>
overhead amortizes out over the individual file entries.</p>

<p style="margin-top: 1em">per active file entry <br>
Files (and pointers to subtrees) within active trees require
52 or 64 bytes (32/64 bit platforms) per entry. To conserve
space, file and tree names are pooled in a common string
<br>
table, allowing the filename &acirc;Makefile&acirc; to use
just 16 bytes (after including the string header overhead)
no matter how many times it occurs within the project.</p>

<p style="margin-top: 1em">The active branch LRU, when
coupled with the filename string pool and lazy loading of
subtrees, allows fast-import to efficiently import projects
with 2,000+ branches and 45,114+ <br>
files in a very limited memory footprint (less than 2.7 MiB
per active branch).</p>

<p style="margin-top: 1em">SIGNALS <br>
Sending SIGUSR1 to the git fast-import process ends the
current packfile early, simulating a checkpoint command. The
impatient operator can use this facility to peek at the <br>
objects and refs from an import in progress, at the cost of
some added running time and worse compression.</p>

<p style="margin-top: 1em">GIT <br>
Part of the git(1) suite</p>

<p style="margin-top: 1em">Git 1.8.3.1 03/23/2016
GIT-FAST-IMPORT(1)</p>
<hr>
</body>
</html>
