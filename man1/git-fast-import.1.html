<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GIT-FAST-IMPORT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GIT-FAST-IMPORT(1)</td>
    <td class="head-vol">Git Manual</td>
    <td class="head-rtitle">GIT-FAST-IMPORT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
git-fast-import - Backend for fast Git data importers
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
frontend |  <i>git fast-import</i> [options]
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This program is usually not what the end user wants to run directly. Most end
  users want to use one of the existing frontend programs, which parses a
  specific type of foreign source and feeds the contents stored there to <i>git
  fast-import</i>.
<div style="height: 1.00em;">&#x00A0;</div>
fast-import reads a mixed command/data stream from standard input and writes one
  or more packfiles directly into the current repository. When EOF is received
  on standard input, fast import writes out updated branch and tag refs, fully
  updating the current repository with the newly imported data.
<div style="height: 1.00em;">&#x00A0;</div>
The fast-import backend itself can import into an empty repository (one that has
  already been initialized by <i>git init</i>) or incrementally update an
  existing populated repository. Whether or not incremental imports are
  supported from a particular foreign source depends on the frontend program in
  use.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
--force
<div style="margin-left: 4.00ex;">Force updating modified existing branches,
  even if doing so would cause commits to be lost (as the new commit does not
  contain the old commit).</div>
<div class="Pp"></div>
--quiet
<div style="margin-left: 4.00ex;">Disable all non-fatal output, making
  fast-import silent when it is successful. This option disables the output
  shown by --stats.</div>
<div class="Pp"></div>
--stats
<div style="margin-left: 4.00ex;">Display some basic statistics about the
  objects fast-import has created, the packfiles they were stored into, and the
  memory used by fast-import during this run. Showing this output is currently
  the default, but can be disabled with --quiet.</div>
<h2 class="Ss" title="Ss" id="Options_for_Frontends"><a class="selflink" href="#Options_for_Frontends">Options
  for Frontends</a></h2>
--cat-blob-fd=&lt;fd&gt;
<div style="margin-left: 4.00ex;">Write responses to cat-blob and ls queries to
  the file descriptor &lt;fd&gt; instead of stdout. Allows progress output
  intended for the end-user to be separated from other output.</div>
<div class="Pp"></div>
--date-format=&lt;fmt&gt;
<div style="margin-left: 4.00ex;">Specify the type of dates the frontend will
  supply to fast-import within author, committer and tagger commands. See
  &#x201C;Date Formats&#x201D; below for details about which formats are
  supported, and their syntax.</div>
<div class="Pp"></div>
--done
<div style="margin-left: 4.00ex;">Terminate with error if there is no done
  command at the end of the stream. This option might be useful for detecting
  errors that cause the frontend to terminate before it has started to write a
  stream.</div>
<h2 class="Ss" title="Ss" id="Locations_of_Marks_Files"><a class="selflink" href="#Locations_of_Marks_Files">Locations
  of Marks Files</a></h2>
--export-marks=&lt;file&gt;
<div style="margin-left: 4.00ex;">Dumps the internal marks table to &lt;file&gt;
  when complete. Marks are written one per line as :markid SHA-1. Frontends can
  use this file to validate imports after they have been completed, or to save
  the marks table across incremental runs. As &lt;file&gt; is only opened and
  truncated at checkpoint (or completion) the same path can also be safely given
  to --import-marks.</div>
<div class="Pp"></div>
--import-marks=&lt;file&gt;
<div style="margin-left: 4.00ex;">Before processing any input, load the marks
  specified in &lt;file&gt;. The input file must exist, must be readable, and
  must use the same format as produced by --export-marks. Multiple options may
  be supplied to import more than one set of marks. If a mark is defined to
  different values, the last file wins.</div>
<div class="Pp"></div>
--import-marks-if-exists=&lt;file&gt;
<div style="margin-left: 4.00ex;">Like --import-marks but instead of erroring
  out, silently skips the file if it does not exist.</div>
<div class="Pp"></div>
--[no-]relative-marks
<div style="margin-left: 4.00ex;">After specifying --relative-marks the paths
  specified with --import-marks= and --export-marks= are relative to an internal
  directory in the current repository. In git-fast-import this means that the
  paths are relative to the .git/info/fast-import directory. However, other
  importers may use a different location.
<div style="height: 1.00em;">&#x00A0;</div>
Relative and non-relative marks may be combined by interweaving
  --(no-)-relative-marks with the --(import|export)-marks= options.</div>
<h2 class="Ss" title="Ss" id="Performance_and_Compression_Tuning"><a class="selflink" href="#Performance_and_Compression_Tuning">Performance
  and Compression Tuning</a></h2>
--active-branches=&lt;n&gt;
<div style="margin-left: 4.00ex;">Maximum number of branches to maintain active
  at once. See &#x201C;Memory Utilization&#x201D; below for details. Default is
  5.</div>
<div class="Pp"></div>
--big-file-threshold=&lt;n&gt;
<div style="margin-left: 4.00ex;">Maximum size of a blob that fast-import will
  attempt to create a delta for, expressed in bytes. The default is 512m (512
  MiB). Some importers may wish to lower this on systems with constrained
  memory.</div>
<div class="Pp"></div>
--depth=&lt;n&gt;
<div style="margin-left: 4.00ex;">Maximum delta depth, for blob and tree
  deltification. Default is 10.</div>
<div class="Pp"></div>
--export-pack-edges=&lt;file&gt;
<div style="margin-left: 4.00ex;">After creating a packfile, print a line of
  data to &lt;file&gt; listing the filename of the packfile and the last commit
  on each branch that was written to that packfile. This information may be
  useful after importing projects whose total object set exceeds the 4 GiB
  packfile limit, as these commits can be used as edge points during calls to
  <i>git pack-objects</i>.</div>
<div class="Pp"></div>
--max-pack-size=&lt;n&gt;
<div style="margin-left: 4.00ex;">Maximum size of each output packfile. The
  default is unlimited.</div>
<h1 class="Sh" title="Sh" id="PERFORMANCE"><a class="selflink" href="#PERFORMANCE">PERFORMANCE</a></h1>
The design of fast-import allows it to import large projects in a minimum amount
  of memory usage and processing time. Assuming the frontend is able to keep up
  with fast-import and feed it a constant stream of data, import times for
  projects holding 10+ years of history and containing 100,000+ individual
  commits are generally completed in just 1-2 hours on quite modest (~$2,000
  USD) hardware.
<div style="height: 1.00em;">&#x00A0;</div>
Most bottlenecks appear to be in foreign source data access (the source just
  cannot extract revisions fast enough) or disk IO (fast-import writes as fast
  as the disk will take the data). Imports will run faster if the source data is
  stored on a different drive than the destination Git repository (due to less
  IO contention).
<h1 class="Sh" title="Sh" id="DEVELOPMENT_COST"><a class="selflink" href="#DEVELOPMENT_COST">DEVELOPMENT
  COST</a></h1>
A typical frontend for fast-import tends to weigh in at approximately 200 lines
  of Perl/Python/Ruby code. Most developers have been able to create working
  importers in just a couple of hours, even though it is their first exposure to
  fast-import, and sometimes even to Git. This is an ideal situation, given that
  most conversion tools are throw-away (use once, and never look back).
<h1 class="Sh" title="Sh" id="PARALLEL_OPERATION"><a class="selflink" href="#PARALLEL_OPERATION">PARALLEL
  OPERATION</a></h1>
Like <i>git push</i> or <i>git fetch</i>, imports handled by fast-import are
  safe to run alongside parallel git repack -a -d or git gc invocations, or any
  other Git operation (including <i>git prune</i>, as loose objects are never
  used by fast-import).
<div style="height: 1.00em;">&#x00A0;</div>
fast-import does not lock the branch or tag refs it is actively importing. After
  the import, during its ref update phase, fast-import tests each existing
  branch ref to verify the update will be a fast-forward update (the commit
  stored in the ref is contained in the new history of the commit to be
  written). If the update is not a fast-forward update, fast-import will skip
  updating that ref and instead prints a warning message. fast-import will
  always attempt to update all branch refs, and does not stop on the first
  failure.
<div style="height: 1.00em;">&#x00A0;</div>
Branch updates can be forced with --force, but it&#x2019;s recommended that this
  only be used on an otherwise quiet repository. Using --force is not necessary
  for an initial import into an empty repository.
<h1 class="Sh" title="Sh" id="TECHNICAL_DISCUSSION"><a class="selflink" href="#TECHNICAL_DISCUSSION">TECHNICAL
  DISCUSSION</a></h1>
fast-import tracks a set of branches in memory. Any branch can be created or
  modified at any point during the import process by sending a commit command on
  the input stream. This design allows a frontend program to process an
  unlimited number of branches simultaneously, generating commits in the order
  they are available from the source data. It also simplifies the frontend
  programs considerably.
<div style="height: 1.00em;">&#x00A0;</div>
fast-import does not use or alter the current working directory, or any file
  within it. (It does however update the current Git repository, as referenced
  by GIT_DIR.) Therefore an import frontend may use the working directory for
  its own purposes, such as extracting file revisions from the foreign source.
  This ignorance of the working directory also allows fast-import to run very
  quickly, as it does not need to perform any costly file update operations when
  switching between branches.
<h1 class="Sh" title="Sh" id="INPUT_FORMAT"><a class="selflink" href="#INPUT_FORMAT">INPUT
  FORMAT</a></h1>
With the exception of raw file data (which Git does not interpret) the
  fast-import input format is text (ASCII) based. This text based format
  simplifies development and debugging of frontend programs, especially when a
  higher level language such as Perl, Python or Ruby is being used.
<div style="height: 1.00em;">&#x00A0;</div>
fast-import is very strict about its input. Where we say SP below we mean
  <b>exactly</b> one space. Likewise LF means one (and only one) linefeed and HT
  one (and only one) horizontal tab. Supplying additional whitespace characters
  will cause unexpected results, such as branch names or file names with leading
  or trailing spaces in their name, or early termination of fast-import when it
  encounters unexpected input.
<h2 class="Ss" title="Ss" id="Stream_Comments"><a class="selflink" href="#Stream_Comments">Stream
  Comments</a></h2>
To aid in debugging frontends fast-import ignores any line that begins with #
  (ASCII pound/hash) up to and including the line ending LF. A comment line may
  contain any sequence of bytes that does not contain an LF and therefore may be
  used to include any detailed debugging information that might be specific to
  the frontend and useful when inspecting a fast-import data stream.
<h2 class="Ss" title="Ss" id="Date_Formats"><a class="selflink" href="#Date_Formats">Date
  Formats</a></h2>
The following date formats are supported. A frontend should select the format it
  will use for this import by passing the format name in the
  --date-format=&lt;fmt&gt; command line option.
<div class="Pp"></div>
raw
<div style="margin-left: 4.00ex;">This is the Git native format and is
  &lt;time&gt; SP &lt;offutc&gt;. It is also fast-import&#x2019;s default
  format, if --date-format was not specified.
<div style="height: 1.00em;">&#x00A0;</div>
The time of the event is specified by &lt;time&gt; as the number of seconds
  since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII
  decimal integer.
<div style="height: 1.00em;">&#x00A0;</div>
The local offset is specified by &lt;offutc&gt; as a positive or negative offset
  from UTC. For example EST (which is 5 hours behind UTC) would be expressed in
  &lt;tz&gt; by &#x201C;-0500&#x201D; while UTC is &#x201C;+0000&#x201D;. The
  local offset does not affect &lt;time&gt;; it is used only as an advisement to
  help formatting routines display the timestamp.
<div style="height: 1.00em;">&#x00A0;</div>
If the local offset is not available in the source material, use
  &#x201C;+0000&#x201D;, or the most common local offset. For example many
  organizations have a CVS repository which has only ever been accessed by users
  who are located in the same location and timezone. In this case a reasonable
  offset from UTC could be assumed.
<div style="height: 1.00em;">&#x00A0;</div>
Unlike the rfc2822 format, this format is very strict. Any variation in
  formatting will cause fast-import to reject the value.</div>
<div class="Pp"></div>
rfc2822
<div style="margin-left: 4.00ex;">This is the standard email format as described
  by RFC 2822.
<div style="height: 1.00em;">&#x00A0;</div>
An example value is &#x201C;Tue Feb 6 11:22:18 2007 -0500&#x201D;. The Git
  parser is accurate, but a little on the lenient side. It is the same parser
  used by <i>git am</i> when applying patches received from email.
<div style="height: 1.00em;">&#x00A0;</div>
Some malformed strings may be accepted as valid dates. In some of these cases
  Git will still be able to obtain the correct date from the malformed string.
  There are also some types of malformed strings which Git will parse wrong, and
  yet consider valid. Seriously malformed strings will be rejected.
<div style="height: 1.00em;">&#x00A0;</div>
Unlike the raw format above, the timezone/UTC offset information contained in an
  RFC 2822 date string is used to adjust the date value to UTC prior to storage.
  Therefore it is important that this information be as accurate as possible.
<div style="height: 1.00em;">&#x00A0;</div>
If the source material uses RFC 2822 style dates, the frontend should let
  fast-import handle the parsing and conversion (rather than attempting to do it
  itself) as the Git parser has been well tested in the wild.
<div style="height: 1.00em;">&#x00A0;</div>
Frontends should prefer the raw format if the source material already uses
  UNIX-epoch format, can be coaxed to give dates in that format, or its format
  is easily convertible to it, as there is no ambiguity in parsing.</div>
<div class="Pp"></div>
now
<div style="margin-left: 4.00ex;">Always use the current time and timezone. The
  literal now must always be supplied for &lt;when&gt;.
<div style="height: 1.00em;">&#x00A0;</div>
This is a toy format. The current time and timezone of this system is always
  copied into the identity string at the time it is being created by
  fast-import. There is no way to specify a different time or timezone.
<div style="height: 1.00em;">&#x00A0;</div>
This particular format is supplied as it&#x2019;s short to implement and may be
  useful to a process that wants to create a new commit right now, without
  needing to use a working directory or <i>git update-index</i>.
<div style="height: 1.00em;">&#x00A0;</div>
If separate author and committer commands are used in a commit the timestamps
  may not match, as the system clock will be polled twice (once for each
  command). The only way to ensure that both author and committer identity
  information has the same timestamp is to omit author (thus copying from
  committer) or to use a date format other than now.</div>
<h2 class="Ss" title="Ss" id="Commands"><a class="selflink" href="#Commands">Commands</a></h2>
fast-import accepts several commands to update the current repository and
  control the current import process. More detailed discussion (with examples)
  of each command follows later.
<div class="Pp"></div>
commit
<div style="margin-left: 4.00ex;">Creates a new branch or updates an existing
  branch by creating a new commit and updating the branch to point at the newly
  created commit.</div>
<div class="Pp"></div>
tag
<div style="margin-left: 4.00ex;">Creates an annotated tag object from an
  existing commit or branch. Lightweight tags are not supported by this command,
  as they are not recommended for recording meaningful points in time.</div>
<div class="Pp"></div>
reset
<div style="margin-left: 4.00ex;">Reset an existing branch (or a new branch) to
  a specific revision. This command must be used to change a branch to a
  specific revision without making a commit on it.</div>
<div class="Pp"></div>
blob
<div style="margin-left: 4.00ex;">Convert raw file data into a blob, for future
  use in a commit command. This command is optional and is not needed to perform
  an import.</div>
<div class="Pp"></div>
checkpoint
<div style="margin-left: 4.00ex;">Forces fast-import to close the current
  packfile, generate its unique SHA-1 checksum and index, and start a new
  packfile. This command is optional and is not needed to perform an
  import.</div>
<div class="Pp"></div>
progress
<div style="margin-left: 4.00ex;">Causes fast-import to echo the entire line to
  its own standard output. This command is optional and is not needed to perform
  an import.</div>
<div class="Pp"></div>
done
<div style="margin-left: 4.00ex;">Marks the end of the stream. This command is
  optional unless the done feature was requested using the --done command line
  option or feature done command.</div>
<div class="Pp"></div>
cat-blob
<div style="margin-left: 4.00ex;">Causes fast-import to print a blob in
  <i>cat-file --batch</i> format to the file descriptor set with --cat-blob-fd
  or stdout if unspecified.</div>
<div class="Pp"></div>
ls
<div style="margin-left: 4.00ex;">Causes fast-import to print a line describing
  a directory entry in <i>ls-tree</i> format to the file descriptor set with
  --cat-blob-fd or stdout if unspecified.</div>
<div class="Pp"></div>
feature
<div style="margin-left: 4.00ex;">Require that fast-import supports the
  specified feature, or abort if it does not.</div>
<div class="Pp"></div>
option
<div style="margin-left: 4.00ex;">Specify any of the options listed under
  OPTIONS that do not change stream semantic to suit the frontend&#x2019;s
  needs. This command is optional and is not needed to perform an import.</div>
<h2 class="Ss" title="Ss" id="commit"><a class="selflink" href="#commit">commit</a></h2>
Create or update a branch with a new commit, recording one logical change to the
  project.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'commit' SP &lt;ref&gt; LF
        mark?
        ('author' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF)?
        'committer' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
        data
        ('from' SP &lt;committish&gt; LF)?
        ('merge' SP &lt;committish&gt; LF)?
        (filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*
        LF?
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
where &lt;ref&gt; is the name of the branch to make the commit on. Typically
  branch names are prefixed with refs/heads/ in Git, so importing the CVS branch
  symbol RELENG-1_0 would use refs/heads/RELENG-1_0 for the value of
  &lt;ref&gt;. The value of &lt;ref&gt; must be a valid refname in Git. As LF is
  not valid in a Git refname, no quoting or escaping syntax is supported here.
<div style="height: 1.00em;">&#x00A0;</div>
A mark command may optionally appear, requesting fast-import to save a reference
  to the newly created commit for future use by the frontend (see below for
  format). It is very common for frontends to mark every commit they create,
  thereby allowing future branch creation from any imported commit.
<div style="height: 1.00em;">&#x00A0;</div>
The data command following committer must supply the commit message (see below
  for data command syntax). To import an empty commit message use a 0 length
  data. Commit messages are free-form and are not interpreted by Git. Currently
  they must be encoded in UTF-8, as fast-import does not permit other encodings
  to be specified.
<div style="height: 1.00em;">&#x00A0;</div>
Zero or more filemodify, filedelete, filecopy, filerename, filedeleteall and
  notemodify commands may be included to update the contents of the branch prior
  to creating the commit. These commands may be supplied in any order. However
  it is recommended that a filedeleteall command precede all filemodify,
  filecopy, filerename and notemodify commands in the same commit, as
  filedeleteall wipes the branch clean (see below).
<div style="height: 1.00em;">&#x00A0;</div>
The LF after the command is optional (it used to be required).
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>author</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
An author command may optionally appear, if the author information might differ
  from the committer information. If author is omitted then fast-import will
  automatically use the committer&#x2019;s information for the author portion of
  the commit. See below for a description of the fields in author, as they are
  identical to committer.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>committer</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
The committer command indicates who made this commit, and when they made it.
<div style="height: 1.00em;">&#x00A0;</div>
Here &lt;name&gt; is the person&#x2019;s display name (for example &#x201C;Com M
  Itter&#x201D;) and &lt;email&gt; is the person&#x2019;s email address
  (&#x201C;cm@example.com&#x201D;). LT and GT are the literal less-than (\x3c)
  and greater-than (\x3e) symbols. These are required to delimit the email
  address from the other fields in the line. Note that &lt;name&gt; and
  &lt;email&gt; are free-form and may contain any sequence of bytes, except LT,
  GT and LF. &lt;name&gt; is typically UTF-8 encoded.
<div style="height: 1.00em;">&#x00A0;</div>
The time of the change is specified by &lt;when&gt; using the date format that
  was selected by the --date-format=&lt;fmt&gt; command line option. See
  &#x201C;Date Formats&#x201D; above for the set of supported formats, and their
  syntax.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>from</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
The from command is used to specify the commit to initialize this branch from.
  This revision will be the first ancestor of the new commit. The state of the
  tree built at this commit will begin with the state at the from commit, and be
  altered by the content modifications in this commit.
<div style="height: 1.00em;">&#x00A0;</div>
Omitting the from command in the first commit of a new branch will cause
  fast-import to create that commit with no ancestor. This tends to be desired
  only for the initial commit of a project. If the frontend creates all files
  from scratch when making a new branch, a merge command may be used instead of
  from to start the commit with an empty tree. Omitting the from command on
  existing branches is usually desired, as the current commit on that branch is
  automatically assumed to be the first ancestor of the new commit.
<div style="height: 1.00em;">&#x00A0;</div>
As LF is not valid in a Git refname or SHA-1 expression, no quoting or escaping
  syntax is supported within &lt;committish&gt;.
<div style="height: 1.00em;">&#x00A0;</div>
Here &lt;committish&gt; is any of the following:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;The name of an existing branch already
  in fast-import&#x2019;s internal branch table. If fast-import doesn&#x2019;t
  know the name, it&#x2019;s treated as a SHA-1 expression.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;A mark reference, :&lt;idnum&gt;,
  where &lt;idnum&gt; is the mark number.
<div style="height: 1.00em;">&#x00A0;</div>
The reason fast-import uses : to denote a mark reference is this character is
  not legal in a Git branch name. The leading : makes it easy to distinguish
  between the mark 42 (:42) and the branch 42 (42 or refs/heads/42), or an
  abbreviated SHA-1 which happened to consist only of base-10 digits.
<div style="height: 1.00em;">&#x00A0;</div>
Marks must be declared (via mark) before they can be used.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;A complete 40 byte or abbreviated
  commit SHA-1 in hex.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;Any valid Git SHA-1 expression that
  resolves to a commit. See &#x201C;SPECIFYING REVISIONS&#x201D; in
  <b>gitrevisions</b>(7) for details.</div>
<div style="height: 1.00em;">&#x00A0;</div>
The special case of restarting an incremental import from the current branch
  value should be written as:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        from refs/heads/branch^0
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
The ^0 suffix is necessary as fast-import does not permit a branch to start from
  itself, and the branch is created in memory before the from command is even
  read from the input. Adding ^0 will force fast-import to resolve the commit
  through Git&#x2019;s revision parsing library, rather than its internal branch
  table, thereby loading in the existing value of the branch.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>merge</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Includes one additional ancestor commit. The additional ancestry link does not
  change the way the tree state is built at this commit. If the from command is
  omitted when creating a new branch, the first merge commit will be the first
  ancestor of the current commit, and the branch will start out with no files.
  An unlimited number of merge commands per commit are permitted by fast-import,
  thereby establishing an n-way merge. However Git&#x2019;s other tools never
  create commits with more than 15 additional ancestors (forming a 16-way
  merge). For this reason it is suggested that frontends do not use more than 15
  merge commands per commit; 16, if starting a new, empty branch.
<div style="height: 1.00em;">&#x00A0;</div>
Here &lt;committish&gt; is any of the commit specification expressions also
  accepted by from (see above).</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>filemodify</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Included in a commit command to add a new file or change the content of an
  existing file. This command has two different means of specifying the content
  of the file.
<div class="Pp"></div>
External data format
<div style="margin-left: 4.00ex;">The data content for the file was already
  supplied by a prior blob command. The frontend just needs to connect it.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'M' SP &lt;mode&gt; SP &lt;dataref&gt; SP &lt;path&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
Here usually &lt;dataref&gt; must be either a mark reference (:&lt;idnum&gt;)
  set by a prior blob command, or a full 40-byte SHA-1 of an existing Git blob
  object. If &lt;mode&gt; is 040000` then &lt;dataref&gt; must be the full
  40-byte SHA-1 of an existing Git tree object or a mark reference set with
  --import-marks.</div>
<div class="Pp"></div>
Inline data format
<div style="margin-left: 4.00ex;">The data content for the file has not been
  supplied yet. The frontend wants to supply it as part of this modify command.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'M' SP &lt;mode&gt; SP 'inline' SP &lt;path&gt; LF
        data
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
See below for a detailed description of the data command.</div>
<div style="height: 1.00em;">&#x00A0;</div>
In both formats &lt;mode&gt; is the type of file entry, specified in octal. Git
  only supports the following modes:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;100644 or 644: A normal
  (not-executable) file. The majority of files in most projects use this mode.
  If in doubt, this is what you want.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;100755 or 755: A normal, but
  executable, file.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;120000: A symlink, the content of the
  file will be the link target.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;160000: A gitlink, SHA-1 of the object
  refers to a commit in another repository. Git links can only be specified by
  SHA or through a commit mark. They are used to implement submodules.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;040000: A subdirectory. Subdirectories
  can only be specified by SHA or through a tree mark set with
  --import-marks.</div>
<div style="height: 1.00em;">&#x00A0;</div>
In both formats &lt;path&gt; is the complete path of the file to be added (if
  not already existing) or modified (if already existing).
<div style="height: 1.00em;">&#x00A0;</div>
A &lt;path&gt; string must use UNIX-style directory separators (forward slash
  /), may contain any byte other than LF, and must not start with double quote
  (&quot;).
<div style="height: 1.00em;">&#x00A0;</div>
A path can use C-style string quoting; this is accepted in all cases and
  mandatory if the filename starts with double quote or contains LF. In C-style
  quoting, the complete name should be surrounded with double quotes, and any
  LF, backslash, or double quote characters must be escaped by preceding them
  with a backslash (e.g., &quot;path/with\n, \\ and \&quot; in it&quot;).
<div style="height: 1.00em;">&#x00A0;</div>
The value of &lt;path&gt; must be in canonical form. That is it must not:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;contain an empty directory component
  (e.g. foo//bar is invalid),</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;end with a directory separator (e.g.
  foo/ is invalid),</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;start with a directory separator (e.g.
  /foo is invalid),</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;contain the special component . or ..
  (e.g. foo/./bar and foo/../bar are invalid).</div>
<div style="height: 1.00em;">&#x00A0;</div>
The root of the tree can be represented by an empty string as &lt;path&gt;.
<div style="height: 1.00em;">&#x00A0;</div>
It is recommended that &lt;path&gt; always be encoded using UTF-8.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>filedelete</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Included in a commit command to remove a file or recursively delete an entire
  directory from the branch. If the file or directory removal makes its parent
  directory empty, the parent directory will be automatically removed too. This
  cascades up the tree until the first non-empty directory or the root is
  reached.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'D' SP &lt;path&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
here &lt;path&gt; is the complete path of the file or subdirectory to be removed
  from the branch. See filemodify above for a detailed description of
  &lt;path&gt;.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>filecopy</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Recursively copies an existing file or subdirectory to a different location
  within the branch. The existing file or directory must exist. If the
  destination exists it will be completely replaced by the content copied from
  the source.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'C' SP &lt;path&gt; SP &lt;path&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
here the first &lt;path&gt; is the source location and the second &lt;path&gt;
  is the destination. See filemodify above for a detailed description of what
  &lt;path&gt; may look like. To use a source path that contains SP the path
  must be quoted.
<div style="height: 1.00em;">&#x00A0;</div>
A filecopy command takes effect immediately. Once the source location has been
  copied to the destination any future commands applied to the source location
  will not impact the destination of the copy.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>filerename</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Renames an existing file or subdirectory to a different location within the
  branch. The existing file or directory must exist. If the destination exists
  it will be replaced by the source directory.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'R' SP &lt;path&gt; SP &lt;path&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
here the first &lt;path&gt; is the source location and the second &lt;path&gt;
  is the destination. See filemodify above for a detailed description of what
  &lt;path&gt; may look like. To use a source path that contains SP the path
  must be quoted.
<div style="height: 1.00em;">&#x00A0;</div>
A filerename command takes effect immediately. Once the source location has been
  renamed to the destination any future commands applied to the source location
  will create new files there and not impact the destination of the rename.
<div style="height: 1.00em;">&#x00A0;</div>
Note that a filerename is the same as a filecopy followed by a filedelete of the
  source location. There is a slight performance advantage to using filerename,
  but the advantage is so small that it is never worth trying to convert a
  delete/add pair in source material into a rename for fast-import. This
  filerename command is provided just to simplify frontends that already have
  rename information and don&#x2019;t want bother with decomposing it into a
  filecopy followed by a filedelete.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>filedeleteall</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Included in a commit command to remove all files (and also all directories) from
  the branch. This command resets the internal branch structure to have no files
  in it, allowing the frontend to subsequently add all interesting files from
  scratch.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'deleteall' LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
This command is extremely useful if the frontend does not know (or does not care
  to know) what files are currently on the branch, and therefore cannot generate
  the proper filedelete commands to update the content.
<div style="height: 1.00em;">&#x00A0;</div>
Issuing a filedeleteall followed by the needed filemodify commands to set the
  correct content will produce the same results as sending only the needed
  filemodify and filedelete commands. The filedeleteall approach may however
  require fast-import to use slightly more memory per active branch (less than 1
  MiB for even most large projects); so frontends that can easily obtain only
  the affected paths for a commit are encouraged to do so.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div>&#x00A0;</div>
<b>notemodify</b>
<div>&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Included in a commit &lt;notes_ref&gt; command to add a new note annotating a
  &lt;committish&gt; or change this annotation contents. Internally it is
  similar to filemodify 100644 on &lt;committish&gt; path (maybe split into
  subdirectories). It&#x2019;s not advised to use any other commands to write to
  the &lt;notes_ref&gt; tree except filedeleteall to delete all existing notes
  in this tree. This command has two different means of specifying the content
  of the note.
<div class="Pp"></div>
External data format
<div style="margin-left: 4.00ex;">The data content for the note was already
  supplied by a prior blob command. The frontend just needs to connect it to the
  commit that is to be annotated.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'N' SP &lt;dataref&gt; SP &lt;committish&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
Here &lt;dataref&gt; can be either a mark reference (:&lt;idnum&gt;) set by a
  prior blob command, or a full 40-byte SHA-1 of an existing Git blob
  object.</div>
<div class="Pp"></div>
Inline data format
<div style="margin-left: 4.00ex;">The data content for the note has not been
  supplied yet. The frontend wants to supply it as part of this modify command.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'N' SP 'inline' SP &lt;committish&gt; LF
        data
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
See below for a detailed description of the data command.</div>
<div style="height: 1.00em;">&#x00A0;</div>
In both formats &lt;committish&gt; is any of the commit specification
  expressions also accepted by from (see above).</div>
<h2 class="Ss" title="Ss" id="mark"><a class="selflink" href="#mark">mark</a></h2>
Arranges for fast-import to save a reference to the current object, allowing the
  frontend to recall this object at a future point in time, without knowing its
  SHA-1. Here the current object is the object creation command the mark command
  appears within. This can be commit, tag, and blob, but commit is the most
  common usage.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'mark' SP ':' &lt;idnum&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
where &lt;idnum&gt; is the number assigned by the frontend to this mark. The
  value of &lt;idnum&gt; is expressed as an ASCII decimal integer. The value 0
  is reserved and cannot be used as a mark. Only values greater than or equal to
  1 may be used as marks.
<div style="height: 1.00em;">&#x00A0;</div>
New marks are created automatically. Existing marks can be moved to another
  object simply by reusing the same &lt;idnum&gt; in another mark command.
<h2 class="Ss" title="Ss" id="tag"><a class="selflink" href="#tag">tag</a></h2>
Creates an annotated tag referring to a specific commit. To create lightweight
  (non-annotated) tags see the reset command below.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'tag' SP &lt;name&gt; LF
        'from' SP &lt;committish&gt; LF
        'tagger' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
        data
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
where &lt;name&gt; is the name of the tag to create.
<div style="height: 1.00em;">&#x00A0;</div>
Tag names are automatically prefixed with refs/tags/ when stored in Git, so
  importing the CVS branch symbol RELENG-1_0-FINAL would use just
  RELENG-1_0-FINAL for &lt;name&gt;, and fast-import will write the
  corresponding ref as refs/tags/RELENG-1_0-FINAL.
<div style="height: 1.00em;">&#x00A0;</div>
The value of &lt;name&gt; must be a valid refname in Git and therefore may
  contain forward slashes. As LF is not valid in a Git refname, no quoting or
  escaping syntax is supported here.
<div style="height: 1.00em;">&#x00A0;</div>
The from command is the same as in the commit command; see above for details.
<div style="height: 1.00em;">&#x00A0;</div>
The tagger command uses the same format as committer within commit; again see
  above for details.
<div style="height: 1.00em;">&#x00A0;</div>
The data command following tagger must supply the annotated tag message (see
  below for data command syntax). To import an empty tag message use a 0 length
  data. Tag messages are free-form and are not interpreted by Git. Currently
  they must be encoded in UTF-8, as fast-import does not permit other encodings
  to be specified.
<div style="height: 1.00em;">&#x00A0;</div>
Signing annotated tags during import from within fast-import is not supported.
  Trying to include your own PGP/GPG signature is not recommended, as the
  frontend does not (easily) have access to the complete set of bytes which
  normally goes into such a signature. If signing is required, create
  lightweight tags from within fast-import with reset, then create the annotated
  versions of those tags offline with the standard <i>git tag</i> process.
<h2 class="Ss" title="Ss" id="reset"><a class="selflink" href="#reset">reset</a></h2>
Creates (or recreates) the named branch, optionally starting from a specific
  revision. The reset command allows a frontend to issue a new from command for
  an existing branch, or to create a new branch from an existing commit without
  creating a new commit.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'reset' SP &lt;ref&gt; LF
        ('from' SP &lt;committish&gt; LF)?
        LF?
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
For a detailed description of &lt;ref&gt; and &lt;committish&gt; see above under
  commit and from.
<div style="height: 1.00em;">&#x00A0;</div>
The LF after the command is optional (it used to be required).
<div style="height: 1.00em;">&#x00A0;</div>
The reset command can also be used to create lightweight (non-annotated) tags.
  For example:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
reset refs/tags/938
from :938
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
would create the lightweight tag refs/tags/938 referring to whatever commit mark
  :938 references.
<h2 class="Ss" title="Ss" id="blob"><a class="selflink" href="#blob">blob</a></h2>
Requests writing one file revision to the packfile. The revision is not
  connected to any commit; this connection must be formed in a subsequent commit
  command by referencing the blob through an assigned mark.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'blob' LF
        mark?
        data
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The mark command is optional here as some frontends have chosen to generate the
  Git SHA-1 for the blob on their own, and feed that directly to commit. This is
  typically more work than it&#x2019;s worth however, as marks are inexpensive
  to store and easy to use.
<h2 class="Ss" title="Ss" id="data"><a class="selflink" href="#data">data</a></h2>
Supplies raw data (for use as blob/file content, commit messages, or annotated
  tag messages) to fast-import. Data can be supplied using an exact byte count
  or delimited with a terminating line. Real frontends intended for
  production-quality conversions should always use the exact byte count format,
  as it is more robust and performs better. The delimited format is intended
  primarily for testing fast-import.
<div style="height: 1.00em;">&#x00A0;</div>
Comment lines appearing within the &lt;raw&gt; part of data commands are always
  taken to be part of the body of the data and are therefore never ignored by
  fast-import. This makes it safe to import any file/message content whose lines
  might start with #.
<div class="Pp"></div>
Exact byte count format
<div style="margin-left: 4.00ex;">The frontend must specify the number of bytes
  of data.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'data' SP &lt;count&gt; LF
        &lt;raw&gt; LF?
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
where &lt;count&gt; is the exact number of bytes appearing within &lt;raw&gt;.
  The value of &lt;count&gt; is expressed as an ASCII decimal integer. The LF on
  either side of &lt;raw&gt; is not included in &lt;count&gt; and will not be
  included in the imported data.
<div style="height: 1.00em;">&#x00A0;</div>
The LF after &lt;raw&gt; is optional (it used to be required) but recommended.
  Always including it makes debugging a fast-import stream easier as the next
  command always starts in column 0 of the next line, even if &lt;raw&gt; did
  not end with an LF.</div>
<div class="Pp"></div>
Delimited format
<div style="margin-left: 4.00ex;">A delimiter string is used to mark the end of
  the data. fast-import will compute the length by searching for the delimiter.
  This format is primarily useful for testing and is not recommended for real
  data.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'data' SP '&lt;&lt;' &lt;delim&gt; LF
        &lt;raw&gt; LF
        &lt;delim&gt; LF
        LF?
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
where &lt;delim&gt; is the chosen delimiter string. The string &lt;delim&gt;
  must not appear on a line by itself within &lt;raw&gt;, as otherwise
  fast-import will think the data ends earlier than it really does. The LF
  immediately trailing &lt;raw&gt; is part of &lt;raw&gt;. This is one of the
  limitations of the delimited format, it is impossible to supply a data chunk
  which does not have an LF as its last byte.
<div style="height: 1.00em;">&#x00A0;</div>
The LF after &lt;delim&gt; LF is optional (it used to be required).</div>
<h2 class="Ss" title="Ss" id="checkpoint"><a class="selflink" href="#checkpoint">checkpoint</a></h2>
Forces fast-import to close the current packfile, start a new one, and to save
  out all current branch refs, tags and marks.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'checkpoint' LF
        LF?
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
Note that fast-import automatically switches packfiles when the current packfile
  reaches --max-pack-size, or 4 GiB, whichever limit is smaller. During an
  automatic packfile switch fast-import does not update the branch refs, tags or
  marks.
<div style="height: 1.00em;">&#x00A0;</div>
As a checkpoint can require a significant amount of CPU time and disk IO (to
  compute the overall pack SHA-1 checksum, generate the corresponding index
  file, and update the refs) it can easily take several minutes for a single
  checkpoint command to complete.
<div style="height: 1.00em;">&#x00A0;</div>
Frontends may choose to issue checkpoints during extremely large and long
  running imports, or when they need to allow another Git process access to a
  branch. However given that a 30 GiB Subversion repository can be loaded into
  Git through fast-import in about 3 hours, explicit checkpointing may not be
  necessary.
<div style="height: 1.00em;">&#x00A0;</div>
The LF after the command is optional (it used to be required).
<h2 class="Ss" title="Ss" id="progress"><a class="selflink" href="#progress">progress</a></h2>
Causes fast-import to print the entire progress line unmodified to its standard
  output channel (file descriptor 1) when the command is processed from the
  input stream. The command otherwise has no impact on the current import, or on
  any of fast-import&#x2019;s internal state.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'progress' SP &lt;any&gt; LF
        LF?
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The &lt;any&gt; part of the command may contain any sequence of bytes that does
  not contain LF. The LF after the command is optional. Callers may wish to
  process the output through a tool such as sed to remove the leading part of
  the line, for example:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
frontend | git fast-import | sed 's/^progress //'
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
Placing a progress command immediately after a checkpoint will inform the reader
  when the checkpoint has been completed and it can safely access the refs that
  fast-import updated.
<h2 class="Ss" title="Ss" id="cat-blob"><a class="selflink" href="#cat-blob">cat-blob</a></h2>
Causes fast-import to print a blob to a file descriptor previously arranged with
  the --cat-blob-fd argument. The command otherwise has no impact on the current
  import; its main purpose is to retrieve blobs that may be in
  fast-import&#x2019;s memory but not accessible from the target repository.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'cat-blob' SP &lt;dataref&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The &lt;dataref&gt; can be either a mark reference (:&lt;idnum&gt;) set
  previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be
  written.
<div style="height: 1.00em;">&#x00A0;</div>
Output uses the same format as git cat-file --batch:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
&lt;sha1&gt; SP 'blob' SP &lt;size&gt; LF
&lt;contents&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
This command can be used anywhere in the stream that comments are accepted. In
  particular, the cat-blob command can be used in the middle of a commit but not
  in the middle of a data command.
<div style="height: 1.00em;">&#x00A0;</div>
See &#x201C;Responses To Commands&#x201D; below for details about how to read
  this output safely.
<h2 class="Ss" title="Ss" id="ls"><a class="selflink" href="#ls">ls</a></h2>
Prints information about the object at a path to a file descriptor previously
  arranged with the --cat-blob-fd argument. This allows printing a blob from the
  active commit (with cat-blob) or copying a blob or tree from a previous commit
  for use in the current one (with filemodify).
<div style="height: 1.00em;">&#x00A0;</div>
The ls command can be used anywhere in the stream that comments are accepted,
  including the middle of a commit.
<div class="Pp"></div>
Reading from the active commit
<div style="margin-left: 4.00ex;">This form can only be used in the middle of a
  commit. The path names a directory entry within fast-import&#x2019;s active
  commit. The path must be quoted in this case.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'ls' SP &lt;path&gt; LF
</pre>
</div>
</div>
<div class="Pp"></div>
Reading from a named tree
<div style="margin-left: 4.00ex;">The &lt;dataref&gt; can be a mark reference
  (:&lt;idnum&gt;) or the full 40-byte SHA-1 of a Git tag, commit, or tree
  object, preexisting or waiting to be written. The path is relative to the top
  level of the tree named by &lt;dataref&gt;.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'ls' SP &lt;dataref&gt; SP &lt;path&gt; LF
</pre>
</div>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
See filemodify above for a detailed description of &lt;path&gt;.
<div style="height: 1.00em;">&#x00A0;</div>
Output uses the same format as git ls-tree &lt;tree&gt; -- &lt;path&gt;:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
&lt;mode&gt; SP ('blob' | 'tree' | 'commit') SP &lt;dataref&gt; HT &lt;path&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The &lt;dataref&gt; represents the blob, tree, or commit object at &lt;path&gt;
  and can be used in later <i>cat-blob</i>, <i>filemodify</i>, or <i>ls</i>
  commands.
<div style="height: 1.00em;">&#x00A0;</div>
If there is no file or subtree at that path, <i>git fast-import</i> will instead
  report
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
missing SP &lt;path&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
See &#x201C;Responses To Commands&#x201D; below for details about how to read
  this output safely.
<h2 class="Ss" title="Ss" id="feature"><a class="selflink" href="#feature">feature</a></h2>
Require that fast-import supports the specified feature, or abort if it does
  not.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
        'feature' SP &lt;feature&gt; ('=' &lt;argument&gt;)? LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The &lt;feature&gt; part of the command may be any one of the following:
<div class="Pp"></div>
date-format, export-marks, relative-marks, no-relative-marks, force
<div style="margin-left: 4.00ex;">Act as though the corresponding command-line
  option with a leading <i>--</i> was passed on the command line (see OPTIONS,
  above).</div>
<div class="Pp"></div>
import-marks, import-marks-if-exists
<div style="margin-left: 4.00ex;">Like --import-marks except in two respects:
  first, only one &quot;feature import-marks&quot; or &quot;feature
  import-marks-if-exists&quot; command is allowed per stream; second, an
  --import-marks= or --import-marks-if-exists command-line option overrides any
  of these &quot;feature&quot; commands in the stream; third, &quot;feature
  import-marks-if-exists&quot; like a corresponding command-line option silently
  skips a nonexistent file.</div>
<div class="Pp"></div>
cat-blob, ls
<div style="margin-left: 4.00ex;">Require that the backend support the
  <i>cat-blob</i> or <i>ls</i> command. Versions of fast-import not supporting
  the specified command will exit with a message indicating so. This lets the
  import error out early with a clear message, rather than wasting time on the
  early part of an import before the unsupported command is detected.</div>
<div class="Pp"></div>
notes
<div style="margin-left: 4.00ex;">Require that the backend support the
  <i>notemodify</i> (N) subcommand to the <i>commit</i> command. Versions of
  fast-import not supporting notes will exit with a message indicating so.</div>
<div class="Pp"></div>
done
<div style="margin-left: 4.00ex;">Error out if the stream ends without a
  <i>done</i> command. Without this feature, errors causing the frontend to end
  abruptly at a convenient point in the stream can go undetected. This may
  occur, for example, if an import front end dies in mid-operation without
  emitting SIGTERM or SIGKILL at its subordinate git fast-import instance.</div>
<h2 class="Ss" title="Ss" id="option"><a class="selflink" href="#option">option</a></h2>
Processes the specified option so that git fast-import behaves in a way that
  suits the frontend&#x2019;s needs. Note that options specified by the frontend
  are overridden by any options the user may specify to git fast-import itself.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
    'option' SP &lt;option&gt; LF
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The &lt;option&gt; part of the command may contain any of the options listed in
  the OPTIONS section that do not change import semantics, without the leading
  <i>--</i> and is treated in the same way.
<div style="height: 1.00em;">&#x00A0;</div>
Option commands must be the first commands on the input (not counting feature
  commands), to give an option command after any non-option command is an error.
<div style="height: 1.00em;">&#x00A0;</div>
The following commandline options change import semantics and may therefore not
  be passed as option:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;date-format</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;import-marks</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;export-marks</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;cat-blob-fd</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;force</div>
<h2 class="Ss" title="Ss" id="done"><a class="selflink" href="#done">done</a></h2>
If the done feature is not in use, treated as if EOF was read. This can be used
  to tell fast-import to finish early.
<div style="height: 1.00em;">&#x00A0;</div>
If the --done command line option or feature done command is in use, the done
  command is mandatory and marks the end of the stream.
<h1 class="Sh" title="Sh" id="RESPONSES_TO_COMMANDS"><a class="selflink" href="#RESPONSES_TO_COMMANDS">RESPONSES
  TO COMMANDS</a></h1>
New objects written by fast-import are not available immediately. Most
  fast-import commands have no visible effect until the next checkpoint (or
  completion). The frontend can send commands to fill fast-import&#x2019;s input
  pipe without worrying about how quickly they will take effect, which improves
  performance by simplifying scheduling.
<div style="height: 1.00em;">&#x00A0;</div>
For some frontends, though, it is useful to be able to read back data from the
  current repository as it is being updated (for example when the source
  material describes objects in terms of patches to be applied to previously
  imported objects). This can be accomplished by connecting the frontend and
  fast-import via bidirectional pipes:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
mkfifo fast-import-output
frontend &lt;fast-import-output |
git fast-import &gt;fast-import-output
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
A frontend set up this way can use progress, ls, and cat-blob commands to read
  information from the import in progress.
<div style="height: 1.00em;">&#x00A0;</div>
To avoid deadlock, such frontends must completely consume any pending output
  from progress, ls, and cat-blob before performing writes to fast-import that
  might block.
<h1 class="Sh" title="Sh" id="CRASH_REPORTS"><a class="selflink" href="#CRASH_REPORTS">CRASH
  REPORTS</a></h1>
If fast-import is supplied invalid input it will terminate with a non-zero exit
  status and create a crash report in the top level of the Git repository it was
  importing into. Crash reports contain a snapshot of the internal fast-import
  state as well as the most recent commands that lead up to the crash.
<div style="height: 1.00em;">&#x00A0;</div>
All recent commands (including stream comments, file changes and progress
  commands) are shown in the command history within the crash report, but raw
  file data and commit messages are excluded from the crash report. This
  exclusion saves space within the report file and reduces the amount of
  buffering that fast-import must perform during execution.
<div style="height: 1.00em;">&#x00A0;</div>
After writing a crash report fast-import will close the current packfile and
  export the marks table. This allows the frontend developer to inspect the
  repository state and resume the import from the point where it crashed. The
  modified branches and tags are not updated during a crash, as the import did
  not complete successfully. Branch and tag information can be found in the
  crash report and must be applied manually if the update is needed.
<div style="height: 1.00em;">&#x00A0;</div>
An example crash:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
$ cat &gt;in &lt;&lt;END_OF_INPUT
# my very first test commit
commit refs/heads/master
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
# who is that guy anyway?
data &lt;&lt;EOF
this is my commit
EOF
M 644 inline .gitignore
data &lt;&lt;EOF
.gitignore
EOF
M 777 inline bob
END_OF_INPUT
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
$ git fast-import &lt;in
fatal: Corrupt mode: M 777 inline bob
fast-import: dumping crash report to .git/fast_import_crash_8434
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
$ cat .git/fast_import_crash_8434
fast-import crash report:
    fast-import process: 8434
    parent process     : 1391
    at Sat Sep 1 00:58:12 2007
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
fatal: Corrupt mode: M 777 inline bob
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
Most Recent Commands Before Crash
---------------------------------
  # my very first test commit
  commit refs/heads/master
  committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
  # who is that guy anyway?
  data &lt;&lt;EOF
  M 644 inline .gitignore
  data &lt;&lt;EOF
* M 777 inline bob
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
Active Branch LRU
-----------------
    active_branches = 1 cur, 5 max
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
pos  clock name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1)      0 refs/heads/master
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
Inactive Branches
-----------------
refs/heads/master:
  status      : active loaded dirty
  tip commit  : 0000000000000000000000000000000000000000
  old tree    : 0000000000000000000000000000000000000000
  cur tree    : 0000000000000000000000000000000000000000
  commit clock: 0
  last pack   :
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
-------------------
END OF CRASH REPORT
</pre>
</div>
<h1 class="Sh" title="Sh" id="TIPS_AND_TRICKS"><a class="selflink" href="#TIPS_AND_TRICKS">TIPS
  AND TRICKS</a></h1>
The following tips and tricks have been collected from various users of
  fast-import, and are offered here as suggestions.
<h2 class="Ss" title="Ss" id="Use_One_Mark_Per_Commit"><a class="selflink" href="#Use_One_Mark_Per_Commit">Use
  One Mark Per Commit</a></h2>
When doing a repository conversion, use a unique mark per commit (mark
  :&lt;n&gt;) and supply the --export-marks option on the command line.
  fast-import will dump a file which lists every mark and the Git object SHA-1
  that corresponds to it. If the frontend can tie the marks back to the source
  repository, it is easy to verify the accuracy and completeness of the import
  by comparing each Git commit to the corresponding source revision.
<div style="height: 1.00em;">&#x00A0;</div>
Coming from a system such as Perforce or Subversion this should be quite simple,
  as the fast-import mark can also be the Perforce changeset number or the
  Subversion revision number.
<h2 class="Ss" title="Ss" id="Freely_Skip_Around_Branches"><a class="selflink" href="#Freely_Skip_Around_Branches">Freely
  Skip Around Branches</a></h2>
Don&#x2019;t bother trying to optimize the frontend to stick to one branch at a
  time during an import. Although doing so might be slightly faster for
  fast-import, it tends to increase the complexity of the frontend code
  considerably.
<div style="height: 1.00em;">&#x00A0;</div>
The branch LRU builtin to fast-import tends to behave very well, and the cost of
  activating an inactive branch is so low that bouncing around between branches
  has virtually no impact on import performance.
<h2 class="Ss" title="Ss" id="Handling_Renames"><a class="selflink" href="#Handling_Renames">Handling
  Renames</a></h2>
When importing a renamed file or directory, simply delete the old name(s) and
  modify the new name(s) during the corresponding commit. Git performs rename
  detection after-the-fact, rather than explicitly during a commit.
<h2 class="Ss" title="Ss" id="Use_Tag_Fixup_Branches"><a class="selflink" href="#Use_Tag_Fixup_Branches">Use
  Tag Fixup Branches</a></h2>
Some other SCM systems let the user create a tag from multiple files which are
  not from the same commit/changeset. Or to create tags which are a subset of
  the files available in the repository.
<div style="height: 1.00em;">&#x00A0;</div>
Importing these tags as-is in Git is impossible without making at least one
  commit which &#x201C;fixes up&#x201D; the files to match the content of the
  tag. Use fast-import&#x2019;s reset command to reset a dummy branch outside of
  your normal branch space to the base commit for the tag, then commit one or
  more file fixup commits, and finally tag the dummy branch.
<div style="height: 1.00em;">&#x00A0;</div>
For example since all normal branches are stored under refs/heads/ name the tag
  fixup branch TAG_FIXUP. This way it is impossible for the fixup branch used by
  the importer to have namespace conflicts with real branches imported from the
  source (the name TAG_FIXUP is not refs/heads/TAG_FIXUP).
<div style="height: 1.00em;">&#x00A0;</div>
When committing fixups, consider using merge to connect the commit(s) which are
  supplying file revisions to the fixup branch. Doing so will allow tools such
  as <i>git blame</i> to track through the real commit history and properly
  annotate the source files.
<div style="height: 1.00em;">&#x00A0;</div>
After fast-import terminates the frontend will need to do rm .git/TAG_FIXUP to
  remove the dummy branch.
<h2 class="Ss" title="Ss" id="Import_Now,_Repack_Later"><a class="selflink" href="#Import_Now,_Repack_Later">Import
  Now, Repack Later</a></h2>
As soon as fast-import completes the Git repository is completely valid and
  ready for use. Typically this takes only a very short time, even for
  considerably large projects (100,000+ commits).
<div style="height: 1.00em;">&#x00A0;</div>
However repacking the repository is necessary to improve data locality and
  access performance. It can also take hours on extremely large projects
  (especially if -f and a large --window parameter is used). Since repacking is
  safe to run alongside readers and writers, run the repack in the background
  and let it finish when it finishes. There is no reason to wait to explore your
  new Git project!
<div style="height: 1.00em;">&#x00A0;</div>
If you choose to wait for the repack, don&#x2019;t try to run benchmarks or
  performance tests until repacking is completed. fast-import outputs suboptimal
  packfiles that are simply never seen in real use situations.
<h2 class="Ss" title="Ss" id="Repacking_Historical_Data"><a class="selflink" href="#Repacking_Historical_Data">Repacking
  Historical Data</a></h2>
If you are repacking very old imported data (e.g. older than the last year),
  consider expending some extra CPU time and supplying --window=50 (or higher)
  when you run <i>git repack</i>. This will take longer, but will also produce a
  smaller packfile. You only need to expend the effort once, and everyone using
  your project will benefit from the smaller repository.
<h2 class="Ss" title="Ss" id="Include_Some_Progress_Messages"><a class="selflink" href="#Include_Some_Progress_Messages">Include
  Some Progress Messages</a></h2>
Every once in a while have your frontend emit a progress message to fast-import.
  The contents of the messages are entirely free-form, so one suggestion would
  be to output the current month and year each time the current commit date
  moves into the next month. Your users will feel better knowing how much of the
  data stream has been processed.
<h1 class="Sh" title="Sh" id="PACKFILE_OPTIMIZATION"><a class="selflink" href="#PACKFILE_OPTIMIZATION">PACKFILE
  OPTIMIZATION</a></h1>
When packing a blob fast-import always attempts to deltify against the last blob
  written. Unless specifically arranged for by the frontend, this will probably
  not be a prior version of the same file, so the generated delta will not be
  the smallest possible. The resulting packfile will be compressed, but will not
  be optimal.
<div style="height: 1.00em;">&#x00A0;</div>
Frontends which have efficient access to all revisions of a single file (for
  example reading an RCS/CVS ,v file) can choose to supply all revisions of that
  file as a sequence of consecutive blob commands. This allows fast-import to
  deltify the different file revisions against each other, saving space in the
  final packfile. Marks can be used to later identify individual file revisions
  during a sequence of commit commands.
<div style="height: 1.00em;">&#x00A0;</div>
The packfile(s) created by fast-import do not encourage good disk access
  patterns. This is caused by fast-import writing the data in the order it is
  received on standard input, while Git typically organizes data within
  packfiles to make the most recent (current tip) data appear before historical
  data. Git also clusters commits together, speeding up revision traversal
  through better cache locality.
<div style="height: 1.00em;">&#x00A0;</div>
For this reason it is strongly recommended that users repack the repository with
  git repack -a -d after fast-import completes, allowing Git to reorganize the
  packfiles for faster data access. If blob deltas are suboptimal (see above)
  then also adding the -f option to force recomputation of all deltas can
  significantly reduce the final packfile size (30-50% smaller can be quite
  typical).
<h1 class="Sh" title="Sh" id="MEMORY_UTILIZATION"><a class="selflink" href="#MEMORY_UTILIZATION">MEMORY
  UTILIZATION</a></h1>
There are a number of factors which affect how much memory fast-import requires
  to perform an import. Like critical sections of core Git, fast-import uses its
  own memory allocators to amortize any overheads associated with malloc. In
  practice fast-import tends to amortize any malloc overheads to 0, due to its
  use of large block allocations.
<h2 class="Ss" title="Ss" id="per_object"><a class="selflink" href="#per_object">per
  object</a></h2>
fast-import maintains an in-memory structure for every object written in this
  execution. On a 32 bit system the structure is 32 bytes, on a 64 bit system
  the structure is 40 bytes (due to the larger pointer sizes). Objects in the
  table are not deallocated until fast-import terminates. Importing 2 million
  objects on a 32 bit system will require approximately 64 MiB of memory.
<div style="height: 1.00em;">&#x00A0;</div>
The object table is actually a hashtable keyed on the object name (the unique
  SHA-1). This storage configuration allows fast-import to reuse an existing or
  already written object and avoid writing duplicates to the output packfile.
  Duplicate blobs are surprisingly common in an import, typically due to branch
  merges in the source.
<h2 class="Ss" title="Ss" id="per_mark"><a class="selflink" href="#per_mark">per
  mark</a></h2>
Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes,
  depending on pointer size) per mark. Although the array is sparse, frontends
  are still strongly encouraged to use marks between 1 and n, where n is the
  total number of marks required for this import.
<h2 class="Ss" title="Ss" id="per_branch"><a class="selflink" href="#per_branch">per
  branch</a></h2>
Branches are classified as active and inactive. The memory usage of the two
  classes is significantly different.
<div style="height: 1.00em;">&#x00A0;</div>
Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit
  or 64 bit systems, respectively), plus the length of the branch name
  (typically under 200 bytes), per branch. fast-import will easily handle as
  many as 10,000 inactive branches in under 2 MiB of memory.
<div style="height: 1.00em;">&#x00A0;</div>
Active branches have the same overhead as inactive branches, but also contain
  copies of every tree that has been recently modified on that branch. If
  subtree include has not been modified since the branch became active, its
  contents will not be loaded into memory, but if subtree src has been modified
  by a commit since the branch became active, then its contents will be loaded
  in memory.
<div style="height: 1.00em;">&#x00A0;</div>
As active branches store metadata about the files contained on that branch,
  their in-memory storage size can grow to a considerable size (see below).
<div style="height: 1.00em;">&#x00A0;</div>
fast-import automatically moves active branches to inactive status based on a
  simple least-recently-used algorithm. The LRU chain is updated on each commit
  command. The maximum number of active branches can be increased or decreased
  on the command line with --active-branches=.
<h2 class="Ss" title="Ss" id="per_active_tree"><a class="selflink" href="#per_active_tree">per
  active tree</a></h2>
Trees (aka directories) use just 12 bytes of memory on top of the memory
  required for their entries (see &#x201C;per active file&#x201D; below). The
  cost of a tree is virtually 0, as its overhead amortizes out over the
  individual file entries.
<h2 class="Ss" title="Ss" id="per_active_file_entry"><a class="selflink" href="#per_active_file_entry">per
  active file entry</a></h2>
Files (and pointers to subtrees) within active trees require 52 or 64 bytes
  (32/64 bit platforms) per entry. To conserve space, file and tree names are
  pooled in a common string table, allowing the filename
  &#x201C;Makefile&#x201D; to use just 16 bytes (after including the string
  header overhead) no matter how many times it occurs within the project.
<div style="height: 1.00em;">&#x00A0;</div>
The active branch LRU, when coupled with the filename string pool and lazy
  loading of subtrees, allows fast-import to efficiently import projects with
  2,000+ branches and 45,114+ files in a very limited memory footprint (less
  than 2.7 MiB per active branch).
<h1 class="Sh" title="Sh" id="SIGNALS"><a class="selflink" href="#SIGNALS">SIGNALS</a></h1>
Sending <b>SIGUSR1</b> to the <i>git fast-import</i> process ends the current
  packfile early, simulating a checkpoint command. The impatient operator can
  use this facility to peek at the objects and refs from an import in progress,
  at the cost of some added running time and worse compression.
<h1 class="Sh" title="Sh" id="GIT"><a class="selflink" href="#GIT">GIT</a></h1>
Part of the <b>git</b>(1) suite</div>
<table class="foot">
  <tr>
    <td class="foot-date">03/23/2016</td>
    <td class="foot-os">Git 1.8.3.1</td>
  </tr>
</table>
</body>
</html>
