<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GVPR(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GVPR(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">GVPR(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
gvpr - graph pattern scanning and processing language
<div>&#x00A0;</div>
( previously known as <b>gpr</b> )
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>gvpr</b> [ <b>-icnqV?</b>] [ <b>-o</b> <i>outfile</i> ] [ <b>-a</b>
  <i>args</i> ] [ <i>'prog'</i> | <b>-f</b> <i>progfile</i> ] [ <i>files</i> ]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>gvpr</b> is a graph stream editor inspired by <b>awk</b>. It copies input
  graphs to its output, possibly transforming their structure and attributes,
  creating new graphs, or printing arbitrary information. The graph model is
  that provided by <i>libcgraph</i>(3). In particular, <b>gvpr</b> reads and
  writes graphs using the dot language.
<div class="Pp"></div>
Basically, <b>gvpr</b> traverses each input graph, denoted by <b>$G</b>,
  visiting each node and edge, matching it with the predicate&#x2010;action
  rules supplied in the input program. The rules are evaluated in order. For
  each predicate evaluating to true, the corresponding action is performed.
  During the traversal, the current node or edge being visited is denoted by
  <b>$</b>.
<div class="Pp"></div>
For each input graph, there is a target subgraph, denoted by <b>$T</b>,
  initially empty and used to accumulate chosen entities, and an output graph,
  <b>$O</b>, used for final processing and then written to output. By default,
  the output graph is the target graph. The output graph can be set in the
  program or, in a limited sense, on the command line.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
The following options are supported:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b><i> args</i></dt>
  <dd class="It-tag">The string <i>args</i> is split into
      whitespace&#x2010;separated tokens, with the individual tokens available
      as strings in the <b>gvpr</b> program as
      <b>ARGV[</b><i>0</i><b>],...,ARGV[ARGC-1]</b>. Whitespace characters
      within single or double quoted substrings, or preceded by a backslash, are
      ignored as separators. In general, a backslash character turns off any
      special meaning of the following character. Note that the tokens derived
      from multiple <b>-a</b> flags are concatenated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag">Use the source graph as the output graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b></dt>
  <dd class="It-tag">Derive the node&#x2010;induced subgraph extension of the
      output graph in the context of its root graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b><i> outfile</i></dt>
  <dd class="It-tag">Causes the output stream to be written to the specified
      file; by default, output is written to <b>stdout</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b><i> progfile</i></dt>
  <dd class="It-tag">Use the contents of the specified file as the program to
      execute on the input. If <i>progfile</i> contains a slash character, the
      name is taken as the pathname of the file. Otherwise, <b>gvpr</b> will use
      the directories specified in the environment variable <b>GVPRPATH</b> to
      look for the file. If <b>-f</b> is not given, <b>gvpr</b> will use the
      first non&#x2010;option argument as the program.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b></dt>
  <dd class="It-tag">Turns off warning messages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b></dt>
  <dd class="It-tag">Turns off graph read-ahead. By default, the variable
      <b>$NG</b> is set to the next graph to be processed. This requires a read
      of the next graph before processing the current graph, which may block is
      the next graph is only generated in response to some action pertaining to
      the processing of the current graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag">Causes the program to print version information and
    exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-?</b></dt>
  <dd class="It-tag">Causes the program to print usage information and
    exit.</dd>
</dl>
<h1 class="Sh" title="Sh" id="OPERANDS"><a class="selflink" href="#OPERANDS">OPERANDS</a></h1>
The following operand is supported:
<dl class="Bl-tag">
  <dt class="It-tag"><i>files</i></dt>
  <dd class="It-tag">Names of files containing 1 or more graphs in the dot
      language. If no <b>-f</b> option is given, the first name is removed from
      the list and used as the input program. If the list of files is empty,
      <b>stdin</b> will be used.</dd>
</dl>
<h1 class="Sh" title="Sh" id="PROGRAMS"><a class="selflink" href="#PROGRAMS">PROGRAMS</a></h1>
A <b>gvpr</b> program consists of a list of predicate&#x2010;action clauses,
  having one of the forms:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>BEGIN { </b><i>action</i><b> }</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>BEG_G { </b><i>action</i><b> }</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>N [ </b><i>predicate</i><b> ] { </b><i>action</i><b>
      }</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>E [ </b><i>predicate</i><b> ] { </b><i>action</i><b>
      }</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>END_G { </b><i>action</i><b> }</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>END { </b><i>action</i><b> }</b></dd>
</dl>
<div class="Pp"></div>
A program can contain at most one of each of the <b>BEGIN</b>, <b>END_G</b> and
  <b>END</b> clauses. There can be any number of <b>BEG_G</b>, <b>N</b> and
  <b>E</b> statements, the first applied to graphs, the second to nodes, the
  third to edges. These are separated into blocks, a block consisting of an
  optional <b>BEG_G</b> statement and all <b>N</b> and <b>E</b> statements up to
  the next <b>BEG_G</b> statement, if any. The top&#x2010;level semantics of a
  <b>gvpr</b> program are:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
Evaluate the  <b>BEGIN</b> clause, if any.
For each input graph  <i>G</i> {
    For each block {
        Set  <i>G</i> as the current graph and current object.
        Evaluate the  <b>BEG_G</b> clause, if any.
        For each node and edge in  <i>G</i> {
            Set the node or edge as the current object.
            Evaluate the  <b>N</b> or <b>E</b> clauses, as appropriate.
        } 
    } 
    Set  <i>G</i> as the current object.
    Evaluate the  <b>END_G</b> clause, if any.
} 
Evaluate the  <b>END</b> clause, if any.
</pre>
</div>
<div class="Pp"></div>
The actions of the <b>BEGIN</b>, <b>BEG_G</b>, <b>END_G</b> and <b>END</b>
  clauses are performed when the clauses are evaluated. For <b>N</b> or <b>E</b>
  clauses, either the predicate or action may be omitted. If there is no
  predicate with an action, the action is performed on every node or edge, as
  appropriate. If there is no action and the predicate evaluates to true, the
  associated node or edge is added to the target graph.
<div class="Pp"></div>
The blocks are evaluated in the order in which they occur. Within a block, the
  <b>N</b> clauses ( <b>E</b> clauses, respectively) are evaluated in the order
  in which the occur. Note, though, that within a block, <b>N</b> or <b>E</b>
  clauses may be interlaced, depending on the traversal order.
<div class="Pp"></div>
Predicates and actions are sequences of statements in the C dialect supported by
  the <i>expr</i>(3) library. The only difference between predicates and actions
  is that the former must have a type that may interpreted as either true or
  false. Here the usual C convention is followed, in which a non&#x2010;zero
  value is considered true. This would include non&#x2010;empty strings and
  non&#x2010;empty references to nodes, edges, etc. However, if a string can be
  converted to an integer, this value is used.
<div class="Pp"></div>
In addition to the usual C base types ( <b>void</b>, <b>int</b>, <b>char</b>,
  <b>float</b>, <b>long</b>, <b>unsigned</b> and <b>double</b>), <b>gvpr</b>
  provides <b>string</b> as a synonym for <b>char*</b>, and the
  graph&#x2010;based types <b>node_t</b>, <b>edge_t</b>, <b>graph_t</b> and
  <b>obj_t</b>. The <b>obj_t</b> type can be viewed as a supertype of the other
  3 concrete types; the correct base type is maintained dynamically. Besides
  these base types, the only other supported type expressions are (associative)
  arrays.
<div class="Pp"></div>
Constants follow C syntax, but strings may be quoted with either
  <b>&quot;...&quot;</b> or <b>'...'</b>. <b>gvpr</b> accepts C++ comments as
  well as cpp&#x2010;type comments. For the latter, if a line begins with a '#'
  character, the rest of the line is ignored.
<div class="Pp"></div>
A statement can be a declaration of a function, a variable or an array, or an
  executable statement. For declarations, there is a single scope. Array
  declarations have the form:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<i> type array </i><b>[</b><i> type0 </i><b>]</b>
</pre>
</div>
<div class="Pp"></div>
where <i> type0 </i> is optional. If it is supplied, the parser will enforce
  that all array subscripts have the specified type. If it is not supplied,
  objects of all types can be used as subscripts. As in C, variables and arrays
  must be declared. In particular, an undeclared variable will be interpreted as
  the name of an attribute of a node, edge or graph, depending on the context.
<div class="Pp"></div>
Executable statements can be one of the following:
<div style="margin-left: 5.00ex;">
<pre>
<b>{</b> [<i> statement ... </i>] <b>}</b>
<i>expression</i>	// commonly<i> var </i><b>=</b><i> expression</i>
<b>if(</b><i> expression </i><b>)</b><i> statement </i>[ <b>else</b><i> statement </i>]
<b>for(</b><i> expression </i><b>;</b><i> expression </i><b>;</b><i> expression </i><b>)</b><i> statement</i><b></b>
<b></b><b>for(</b><i> array </i><b>[</b><i> var </i><b>])</b><i> statement</i><b></b>
<b></b><b>forr(</b><i> array </i><b>[</b><i> var </i><b>])</b><i> statement</i><b></b>
<b></b><b>while(</b><i> expression </i><b>)</b><i> statement</i><b></b>
<b></b><b>switch(</b><i> expression </i><b>)</b><i> case statements</i><b></b>
<b></b><b>break [</b><i> expression </i><b>]</b>
<b></b><b>continue [</b><i> expression </i><b>]</b>
<b></b><b>return [</b><i> expression </i><b>]</b>
</pre>
</div>
<small>Items in brackets are optional.</small>
<div class="Pp"></div>
In the second form of the <b>for</b> statement and the <b>forr</b> statement,
  the variable <i>var</i> is set to each value used as an index in the specified
  array and then the associated <i>statement</i> is evaluated. For numeric and
  string indices, the indices are returned in increasing (decreasing) numeric or
  lexicographic order for <b>for</b> (<b>forr</b>, respectively). This can be
  used for sorting.
<div class="Pp"></div>
Function definitions can only appear in the <b>BEGIN</b> clause.
<div class="Pp"></div>
Expressions include the usual C expressions. String comparisons using <b>==</b>
  and <b>!=</b> treat the right hand operand as a pattern for the purpose of
  regular expression matching. Patterns use <i>ksh</i>(1) file match pattern
  syntax. (For simple string equality, use the <b>strcmp</b> function.
<div class="Pp"></div>
<b>gvpr</b> will attempt to use an expression as a string or numeric value as
  appropriate. Both C-like casts and function templates will cause conversions
  to be performed, if possible.
<div class="Pp"></div>
Expressions of graphical type (i.e., <b>graph_t, node_t,</b> <b>edge_t,
  obj_t</b>) may be followed by a field reference in the form of
  <b>.</b><i>name</i>. The resulting value is the value of the attribute named
  <i>name</i> of the given object. In addition, in certain contexts an
  undeclared, unmodified identifier is taken to be an attribute name.
  Specifically, such identifiers denote attributes of the current node or edge,
  respectively, in <b>N</b> and <b>E</b> clauses, and the current graph in
  <b>BEG_G</b> and <b>END_G</b> clauses.
<div class="Pp"></div>
As usual in the <i>libcgraph</i>(3) model, attributes are string&#x2010;valued.
  In addition, <b>gvpr</b> supports certain pseudo&#x2010;attributes of graph
  objects, not necessarily string&#x2010;valued. These reflect intrinsic
  properties of the graph objects and cannot be set by the user.
<dl class="Bl-tag">
  <dt class="It-tag"><b>head</b> : <b>node_t</b></dt>
  <dd class="It-tag">the head of an edge.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tail</b> : <b>node_t</b></dt>
  <dd class="It-tag">the tail of an edge.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>name</b> : <b>string</b></dt>
  <dd class="It-tag">the name of an edge, node or graph. The name of an edge has
      the form &quot;
      <i>&lt;tail&#x2010;name&gt;&lt;edge&#x2010;op&gt;&lt;head&#x2010;name&gt;</i>
      <b>[</b><i>&lt;key&gt;</i><b>]</b>&quot;, where
      <i>&lt;edge&#x2010;op&gt;</i> is &quot; <b>-&gt;</b>&quot; or
      &quot;<b>--</b>&quot; depending on whether the graph is directed or not.
      The bracket part <b>[</b><i>&lt;key&gt;</i><b>]</b> only appears if the
      edge has a non&#x2010;trivial key.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>indegree</b> : <b>int</b></dt>
  <dd class="It-tag">the indegree of a node.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>outdegree</b> : <b>int</b></dt>
  <dd class="It-tag">the outdegree of a node.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>degree</b> : <b>int</b></dt>
  <dd class="It-tag">the degree of a node.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>root</b> : <b>graph_t</b></dt>
  <dd class="It-tag">the root graph of an object. The root of a root graph is
      itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>parent</b> : <b>graph_t</b></dt>
  <dd class="It-tag">the parent graph of a subgraph. The parent of a root graph
      is <b>NULL</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>n_edges</b> : <b>int</b></dt>
  <dd class="It-tag">the number of edges in the graph</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>n_nodes</b> : <b>int</b></dt>
  <dd class="It-tag">the number of nodes in the graph</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>directed</b> : <b>int</b></dt>
  <dd class="It-tag">true (non&#x2010;zero) if the graph is directed</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>strict</b> : <b>int</b></dt>
  <dd class="It-tag">true (non&#x2010;zero) if the graph is strict</dd>
</dl>
<h1 class="Sh" title="Sh" id="BUILT&#x2010;IN_FUNCTIONS"><a class="selflink" href="#BUILT&#x2010;IN_FUNCTIONS">BUILT&#x2010;IN
  FUNCTIONS</a></h1>
The following functions are built into <b>gvpr</b>. Those functions returning
  references to graph objects return <b>NULL</b> in case of failure.
<h2 class="Ss" title="Ss" id="Graphs_and_subgraph"><a class="selflink" href="#Graphs_and_subgraph">Graphs
  and subgraph</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>graph</b>(<i>s</i> : <b>string</b>, <i>t</i> :
    <b>string</b>) : <b>graph_t</b></dt>
  <dd class="It-tag">creates a graph whose name is <i>s</i> and whose type is
      specified by the string <i>t</i>. Ignoring case, the characters <b>U, D,
      S, N</b> have the interpretation undirected, directed, strict, and
      non&#x2010;strict, respectively. If <i>t</i> is empty, a directed,
      non&#x2010;strict graph is generated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>subg</b>(<i>g</i> : <b>graph_t</b>, <i>s</i> :
    <b>string</b>) : <b>graph_t</b></dt>
  <dd class="It-tag">creates a subgraph in graph <i>g</i> with name <i>s</i>. If
      the subgraph already exists, it is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isSubg</b>(<i>g</i> : <b>graph_t</b>, <i>s</i> :
    <b>string</b>) : <b>graph_t</b></dt>
  <dd class="It-tag">returns the subgraph in graph <i>g</i> with name <i>s</i>,
      if it exists, or <b>NULL</b> otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstsubg</b>(<i>g</i> : <b>graph_t</b>) :
    <b>graph_t</b></dt>
  <dd class="It-tag">returns the first subgraph in graph <i>g</i>, or
      <b>NULL</b> if none exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtsubg</b>(<i>sg</i> : <b>graph_t</b>) :
    <b>graph_t</b></dt>
  <dd class="It-tag">returns the next subgraph after <i>sg</i>, or
    <b>NULL</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isDirect</b>(<i>g</i> : <b>graph_t</b>) :
    <b>int</b></dt>
  <dd class="It-tag">returns true if and only if <i>g</i> is directed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isStrict</b>(<i>g</i> : <b>graph_t</b>) :
    <b>int</b></dt>
  <dd class="It-tag">returns true if and only if <i>g</i> is strict.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nNodes</b>(<i>g</i> : <b>graph_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the number of nodes in <i>g</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nEdges</b>(<i>g</i> : <b>graph_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the number of edges in <i>g</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Nodes"><a class="selflink" href="#Nodes">Nodes</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>node</b>(<i>sg</i> : <b>graph_t</b>, <i>s</i> :
    <b>string</b>) : <b>node_t</b></dt>
  <dd class="It-tag">creates a node in graph <i>g</i> of name <i>s</i>. If such
      a node already exists, it is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>subnode</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>node_t</b></dt>
  <dd class="It-tag">inserts the node <i>n</i> into the subgraph <i>g</i>.
      Returns the node.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstnode</b>(<i>g</i> : <b>graph_t</b>) :
    <b>node_t</b></dt>
  <dd class="It-tag">returns the first node in graph <i>g</i>, or <b>NULL</b> if
      none exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtnode</b>(<i>n</i> : <b>node_t</b>) :
    <b>node_t</b></dt>
  <dd class="It-tag">returns the next node after <i>n</i> in the root graph, or
      <b>NULL</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtnode_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>node_t</b></dt>
  <dd class="It-tag">returns the next node after <i>n</i> in <i>sg</i>, or
      <b>NULL</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isNode</b>(<i>sg</i> : <b>graph_t</b>, <i>s</i> :
    <b>string</b>) : <b>node_t</b></dt>
  <dd class="It-tag">looks for a node in (sub)graph <i>sg</i> of name <i>s</i>.
      If such a node exists, it is returned. Otherwise, <b>NULL</b> is
    returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isSubnode</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns non-zero if node <i>n</i> is in (sub)graph
      <i>sg</i>, or zero otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>indegreeOf</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the indegree of node <i>n</i> in (sub)graph
      <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>outdegreeOf</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the outdegree of node <i>n</i> in (sub)graph
      <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>degreeOf</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the degree of node <i>n</i> in (sub)graph
      <i>sg</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Edges"><a class="selflink" href="#Edges">Edges</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>edge</b>(<i>t</i> : <b>node_t</b>, <i>h</i> :
    <b>node_t</b>, <i>s</i> : <b>string</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">creates an edge with tail node <i>t</i>, head node <i>h</i>
      and name <i>s</i> in the root graph. If the graph is undirected, the
      distinction between head and tail nodes is unimportant. If such an edge
      already exists, it is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>edge_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>t</i> :
    <b>node_t</b>, <i>h</i> : <b>node_t</b>, <i>s</i> : <b>string</b>) :
    <b>edge_t</b></dt>
  <dd class="It-tag">creates an edge with tail node <i>t</i>, head node <i>h</i>
      and name <i>s</i> in (sub)graph <i>sg</i> (and all parent graphs). If the
      graph is undirected, the distinction between head and tail nodes is
      unimportant. If such an edge already exists, it is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>subedge</b>(<i>g</i> : <b>graph_t</b>, <i>e</i> :
    <b>edge_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">inserts the edge <i>e</i> into the subgraph <i>g</i>.
      Returns the edge.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isEdge</b>(<i>t</i> : <b>node_t</b>, <i>h</i> :
    <b>node_t</b>, <i>s</i> : <b>string</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">looks for an edge with tail node <i>t</i>, head node
      <i>h</i> and name <i>s</i>. If the graph is undirected, the distinction
      between head and tail nodes is unimportant. If such an edge exists, it is
      returned. Otherwise, <b>NULL</b> is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isEdge_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>t</i> :
    <b>node_t</b>, <i>h</i> : <b>node_t</b>, <i>s</i> : <b>string</b>) :
    <b>edge_t</b></dt>
  <dd class="It-tag">looks for an edge with tail node <i>t</i>, head node
      <i>h</i> and name <i>s</i> in (sub)graph <i>sg</i>. If the graph is
      undirected, the distinction between head and tail nodes is unimportant. If
      such an edge exists, it is returned. Otherwise, <b>NULL</b> is
    returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isSubedge</b>(<i>g</i> : <b>graph_t</b>, <i>e</i> :
    <b>edge_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns non-zero if edge <i>e</i> is in (sub)graph
      <i>sg</i>, or zero otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstout</b>(<i>n</i> : <b>node_t</b>) :
    <b>edge_t</b></dt>
  <dd class="It-tag">returns the first outedge of node <i>n</i> in the root
      graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstout_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the first outedge of node <i>n</i> in (sub)graph
      <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtout</b>(<i>e</i> : <b>edge_t</b>) :
    <b>edge_t</b></dt>
  <dd class="It-tag">returns the next outedge after <i>e</i> in the root
    graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtout_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>e</i> :
    <b>edge_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the next outedge after <i>e</i> in graph
    <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstin</b>(<i>n</i> : <b>node_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the first inedge of node <i>n</i> in the root
      graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstin_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the first inedge of node <i>n</i> in graph
      <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtin</b>(<i>e</i> : <b>edge_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the next inedge after <i>e</i> in the root
    graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtin_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>e</i> :
    <b>edge_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the next inedge after <i>e</i> in graph
    <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstedge</b>(<i>n</i> : <b>node_t</b>) :
    <b>edge_t</b></dt>
  <dd class="It-tag">returns the first edge of node <i>n</i> in the root
    graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstedge_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the first edge of node <i>n</i> in graph
    <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtedge</b>(<i>e</i> : <b>edge_t</b>, <b>node_t</b>) :
    <b>edge_t</b></dt>
  <dd class="It-tag">returns the next edge after <i>e</i> in the root
    graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtedge_sg</b>(<i>sg</i> : <b>graph_t</b>, <i>e</i> :
    <b>edge_t</b>, <b>node_t</b>) : <b>edge_t</b></dt>
  <dd class="It-tag">returns the next edge after <i>e</i> in the graph
      <i>sg</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>opp</b>(<i>e</i> : <b>edge_t</b>, <b>node_t</b>) :
    <b>node_t</b></dt>
  <dd class="It-tag">returns the node on the edge <i>e</i> not equal to
      <i>n</i>. Returns NULL if <i>n</i> is not a node of <i>e</i>. This can be
      useful when using <b>fstedge</b> and <b>nxtedge</b> to enumerate the
      neighbors of <i>n</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Graph_I/O"><a class="selflink" href="#Graph_I/O">Graph
  I/O</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write</b>(<i>g</i> : <b>graph_t</b>) : <b>void</b></dt>
  <dd class="It-tag">prints <i>g</i> in dot format onto the output stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>writeG</b>(<i>g</i> : <b>graph_t</b>, <i>fname</i> :
    <b>string</b>) : <b>void</b></dt>
  <dd class="It-tag">prints <i>g</i> in dot format into the file
    <i>fname</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fwriteG</b>(<i>g</i> : <b>graph_t</b>, <i>fd</i> :
    <b>int</b>) : <b>void</b></dt>
  <dd class="It-tag">prints <i>g</i> in dot format onto the open stream denoted
      by the integer <i>fd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>readG</b>(<i>fname</i> : <b>string</b>) :
    <b>graph_t</b></dt>
  <dd class="It-tag">returns a graph read from the file <i>fname</i>. The graph
      should be in dot format. If no graph can be read, <b>NULL</b> is
    returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>freadG</b>(<i>fd</i> : <b>int</b>) : <b>graph_t</b></dt>
  <dd class="It-tag">returns the next graph read from the open stream <i>fd</i>.
      Returns <b>NULL</b> at end of file.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Graph_miscellany"><a class="selflink" href="#Graph_miscellany">Graph
  miscellany</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>delete</b>(<i>g</i> : <b>graph_t</b>, <i>x</i> :
    <b>obj_t</b>) : <b>void</b></dt>
  <dd class="It-tag">deletes object <i>x</i> from graph <i>g</i>. If <i>g</i> is
      <b>NULL</b>, the function uses the root graph of <i>x</i>. If <i>x</i> is
      a graph or subgraph, it is closed unless <i>x</i> is locked.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isIn</b>(<i>g</i> : <b>graph_t</b>, <i>x</i> :
    <b>obj_t</b>) : <b>int</b></dt>
  <dd class="It-tag">returns true if <i>x</i> is in subgraph <i>g</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cloneG</b>(<i>g</i> : <b>graph_t</b>, <i>s</i> :
    <b>string</b>) : <b>graph_t</b></dt>
  <dd class="It-tag">creates a clone of graph <i>g</i> with name of <i>s</i>. If
      <i>s</i> is &quot;&quot;, the created graph has the same name as
    <i>g</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>clone</b>(<i>g</i> : <b>graph_t</b>, <i>x</i> :
    <b>obj_t</b>) : <b>obj_t</b></dt>
  <dd class="It-tag">creates a clone of object <i>x</i> in graph <i>g</i>. In
      particular, the new object has the same name/value attributes and
      structure as the original object. If an object with the same key as
      <i>x</i> already exists, its attributes are overlaid by those of <i>x</i>
      and the object is returned. If an edge is cloned, both endpoints are
      implicitly cloned. If a graph is cloned, all nodes, edges and subgraphs
      are implicitly cloned. If <i>x</i> is a graph, <i>g</i> may be
      <b>NULL</b>, in which case the cloned object will be a new root graph. In
      this case, the call is equivalent to
      <b>cloneG(</b><i>x</i><b>,&quot;&quot;)</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>copy</b>(<i>g</i> : <b>graph_t</b>, <i>x</i> :
    <b>obj_t</b>) : <b>obj_t</b></dt>
  <dd class="It-tag">creates a copy of object <i>x</i> in graph <i>g</i>, where
      the new object has the same name/value attributes as the original object.
      If an object with the same key as <i>x</i> already exists, its attributes
      are overlaid by those of <i>x</i> and the object is returned. Note that
      this is a shallow copy. If <i>x</i> is a graph, none of its nodes, edges
      or subgraphs are copied into the new graph. If <i>x</i> is an edge, the
      endpoints are created if necessary, but they are not cloned. If <i>x</i>
      is a graph, <i>g</i> may be <b>NULL</b>, in which case the cloned object
      will be a new root graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>copyA</b>(<i>src</i> : <b>obj_t</b>, <i>tgt</i> :
    <b>obj_t</b>) : <b>int</b></dt>
  <dd class="It-tag">copies the attributes of object <i>src</i> to object
      <i>tgt</i>, overwriting any attribute values <i>tgt</i> may initially
      have.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>induce</b>(<i>g</i> : <b>graph_t</b>) : <b>void</b></dt>
  <dd class="It-tag">extends <i>g</i> to its node&#x2010;induced subgraph
      extension in its root graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hasAttr</b>(<i>src</i> : <b>obj_t</b>, <i>name</i> :
    <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">returns non-zero if object <i>src</i> has an attribute
      whose name is <i>name</i>. It returns 0 otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>isAttr</b>(<i>g</i> : <b>graph_t</b>, <i>kind</i> :
    <b>string</b>, <i>name</i> : <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">returns non-zero if an attribute <i>name</i> has been
      defined in <i>g</i> for objects of the given <i>kind</i>. For nodes,
      edges, and graphs, <i>kind</i> should be &quot;N&quot;, &quot;E&quot;, and
      &quot;G&quot;, respectively. It returns 0 otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>aget</b>(<i>src</i> : <b>obj_t</b>, <i>name</i> :
    <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the value of attribute <i>name</i> in object
      <i>src</i>. This is useful for those cases when <i>name</i> conflicts with
      one of the keywords such as &quot;head&quot; or &quot;root&quot;. If the
      attribute has not been declared in the graph, the function will initialize
      it with a default value of &quot;&quot;. To avoid this, one should use the
      <b>hasAttr</b> or <b>isAttr</b> function to check that the attribute
      exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>aset</b>(<i>src</i> : <b>obj_t</b>, <i>name</i> :
    <b>string</b>, <i>value</i> : <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">sets the value of attribute <i>name</i> in object
      <i>src</i> to <i>value</i>. Returns 0 on success, non&#x2010;zero on
      failure. See <b>aget</b> above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>getDflt</b>(<i>g</i> : <b>graph_t</b>, <i>kind</i> :
    <b>string</b>, <i>name</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the default value of attribute <i>name</i> in
      objects in <i>g</i> of the given <i>kind</i>. For nodes, edges, and
      graphs, <i>kind</i> should be &quot;N&quot;, &quot;E&quot;, and
      &quot;G&quot;, respectively. If the attribute has not been declared in the
      graph, the function will initialize it with a default value of
      &quot;&quot;. To avoid this, one should use the <b>isAttr</b> function to
      check that the attribute exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>setDflt</b>(<i>g</i> : <b>graph_t</b>, <i>kind</i> :
    <b>string</b>, <i>name</i> : <b>string</b>, <i>value</i> : <b>string</b>) :
    <b>int</b></dt>
  <dd class="It-tag">sets the default value of attribute <i>name</i> to
      <i>value</i> in objects in <i>g</i> of the given <i>kind</i>. For nodes,
      edges, and graphs, <i>kind</i> should be &quot;N&quot;, &quot;E&quot;, and
      &quot;G&quot;, respectively. Returns 0 on success, non&#x2010;zero on
      failure. See <b>getDflt</b> above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fstAttr</b>(<i>g</i> : <b>graph_t</b>, <i>kind</i> :
    <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the name of the first attribute of objects in
      <i>g</i> of the given <i>kind</i>. For nodes, edges, and graphs,
      <i>kind</i> should be &quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
      respectively. If there are no attributes, the string &quot;&quot; is
      returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nxtAttr</b>(<i>g</i> : <b>graph_t</b>, <i>kind</i> :
    <b>string</b>, <i>name</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the name of the next attribute of objects in
      <i>g</i> of the given <i>kind</i> after the attribute <i>name</i>. The
      argument <i>name</i> must be the name of an existing attribute; it will
      typically be the return value of an previous call to <b>fstAttr</b> or
      <b>nxtAttr</b>. For nodes, edges, and graphs, <i>kind</i> should be
      &quot;N&quot;, &quot;E&quot;, and &quot;G&quot;, respectively. If there
      are no attributes left, the string &quot;&quot; is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>compOf</b>(<i>g</i> : <b>graph_t</b>, <i>n</i> :
    <b>node_t</b>) : <b>graph_t</b></dt>
  <dd class="It-tag">returns the connected component of the graph <i>g</i>
      containing node <i>n</i>, as a subgraph of <i>g</i>. The subgraph only
      contains the nodes. One can use <i>induce</i> to add the edges. The
      function fails and returns <b>NULL</b> if <i>n</i> is not in <i>g</i>.
      Connectivity is based on the underlying undirected graph of <i>g</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>kindOf</b>(<i>obj</i> : <b>obj_t</b>) :
    <b>string</b></dt>
  <dd class="It-tag">returns an indication of what kind of graph object is the
      argument. For nodes, edges, and graphs, it returns should be
      &quot;N&quot;, &quot;E&quot;, and &quot;G&quot;, respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>lock</b>(<i>g</i> : <b>graph_t</b>, <i>v</i> :
    <b>int</b>) : <b>int</b></dt>
  <dd class="It-tag">implements graph locking on root graphs. If the integer
      <i>v</i> is positive, the graph is set so that future calls to
      <b>delete</b> have no immediate effect. If <i>v</i> is zero, the graph is
      unlocked. If there has been a call to delete the graph while it was
      locked, the graph is closed. If <i>v</i> is negative, nothing is done. In
      all cases, the previous lock value is returned.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Strings"><a class="selflink" href="#Strings">Strings</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sprintf</b>(<i>fmt</i> : <b>string</b>, <i>...</i>) :
    <b>string</b></dt>
  <dd class="It-tag">returns the string resulting from formatting the values of
      the expressions occurring after <i>fmt</i> according to the
      <i>printf</i>(3) format <i>fmt</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gsub</b>(<i>str</i> : <b>string</b>, <i>pat</i> :
    <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gsub</b>(<i>str</i> : <b>string</b>, <i>pat</i> :
    <b>string</b>, <i>repl</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns <i>str</i> with all substrings matching <i>pat</i>
      deleted or replaced by <i>repl</i>, respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sub</b>(<i>str</i> : <b>string</b>, <i>pat</i> :
    <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sub</b>(<i>str</i> : <b>string</b>, <i>pat</i> :
    <b>string</b>, <i>repl</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns <i>str</i> with the leftmost substring matching
      <i>pat</i> deleted or replaced by <i>repl</i>, respectively. The
      characters '^' and '$' may be used at the beginning and end, respectively,
      of <i>pat</i> to anchor the pattern to the beginning or end of
    <i>str</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>substr</b>(<i>str</i> : <b>string</b>, <i>idx</i> :
    <b>int</b>) : <b>string</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>substr</b>(<i>str</i> : <b>string</b>, <i>idx</i> :
    <b>int</b>, <i>len</i> : <b>int</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the substring of <i>str</i> starting at position
      <i>idx</i> to the end of the string or of length <i>len</i>, respectively.
      Indexing starts at 0. If <i>idx</i> is negative or <i>idx</i> is greater
      than the length of <i>str</i>, a fatal error occurs. Similarly, in the
      second case, if <i>len</i> is negative or <i>idx</i> + <i>len</i> is
      greater than the length of <i>str</i>, a fatal error occurs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>strcmp</b>(<i>s1</i> : <b>string</b>, <i>s2</i> :
    <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">provides the standard C function <i>strcmp</i>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>length</b>(<i>s</i> : <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the length of string <i>s</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>index</b>(<i>s</i> : <b>string</b>, <i>t</i> :
    <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rindex</b>(<i>s</i> : <b>string</b>, <i>t</i> :
    <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the index of the character in string <i>s</i> where
      the leftmost (rightmost) copy of string <i>t</i> can be found, or -1 if
      <i>t</i> is not a substring of <i>s</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>match</b>(<i>s</i> : <b>string</b>, <i>p</i> :
    <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">returns the index of the character in string <i>s</i> where
      the leftmost match of pattern <i>p</i> can be found, or -1 if no substring
      of <i>s</i> matches <i>p</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>toupper</b>(<i>s</i> : <b>string</b>) :
    <b>string</b></dt>
  <dd class="It-tag">returns a version of <i>s</i> with the alphabetic
      characters converted to upper-case.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tolower</b>(<i>s</i> : <b>string</b>) :
    <b>string</b></dt>
  <dd class="It-tag">returns a version of <i>s</i> with the alphabetic
      characters converted to lower-case.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>canon</b>(<i>s</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns a version of <i>s</i> appropriate to be used as an
      identifier in a dot file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>html</b>(<i>g</i> : <b>graph_t</b>, <i>s</i> :
    <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns a ``magic'' version of <i>s</i> as an HTML string.
      This will typically be used to attach an HTML-like label to a graph
      object. Note that the returned string lives in <i>g</i>. In particular, it
      will be freed when <i>g</i> is closed, and to act as an HTML string, it
      has to be used with an object of <i>g</i>. In addition, note that the
      angle bracket quotes should not be part of <i>s</i>. These will be added
      if <i>g</i> is written in concrete DOT format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ishtml</b>(<i>s</i> : <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">returns non-zero if and only if <i>s</i> is an HTML
    string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>xOf</b>(<i>s</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the string &quot;<i>x</i>&quot; if <i>s</i> has the
      form &quot; <i>x</i>,<i>y</i>&quot;, where both <i>x</i> and <i>y</i> are
      numeric.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>yOf</b>(<i>s</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the string &quot;<i>y</i>&quot; if <i>s</i> has the
      form &quot; <i>x</i>,<i>y</i>&quot;, where both <i>x</i> and <i>y</i> are
      numeric.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>llOf</b>(<i>s</i> : <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the string &quot;<i>llx</i>,<i>lly</i>&quot; if
      <i>s</i> has the form &quot;
      <i>llx</i>,<i>lly</i>,<i>urx</i>,<i>ury</i>&quot;, where all of
      <i>llx</i>, <i>lly</i>, <i>urx</i>, and <i>ury</i> are numeric.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>urOf(</b><i>s</i><b>)</b></dt>
  <dd class="It-tag"><b>urOf</b>(<i>s</i> : <b>string</b>) : <b>string</b>
      returns the string &quot; <i>urx</i>,<i>ury</i>&quot; if <i>s</i> has the
      form &quot; <i>llx</i>,<i>lly</i>,<i>urx</i>,<i>ury</i>&quot;, where all
      of <i>llx</i>, <i>lly</i>, <i>urx</i>, and <i>ury</i> are numeric.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sscanf</b>(<i>s</i> : <b>string</b>, <i>fmt</i> :
    <b>string</b>, <i>...</i>) : <b>int</b></dt>
  <dd class="It-tag">scans the string <i>s</i>, extracting values according to
      the <i>sscanf</i>(3) format <i>fmt</i>. The values are stored in the
      addresses following <i>fmt</i>, addresses having the form
      <b>&amp;</b><i>v</i>, where <i>v</i> is some declared variable of the
      correct type. Returns the number of items successfully scanned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>split</b>(<i>s</i> : <b>string</b>, <i>arr</i> :
    <b>array</b>, <i>seps</i> : <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>split</b>(<i>s</i> : <b>string</b>, <i>arr</i> :
    <b>array</b>) : <b>int</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tokens</b>(<i>s</i> : <b>string</b>, <i>arr</i> :
    <b>array</b>, <i>seps</i> : <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tokens</b>(<i>s</i> : <b>string</b>, <i>arr</i> :
    <b>array</b>) : <b>int</b></dt>
  <dd class="It-tag">The <b>split</b> function breaks the string <i>s</i> into
      fields, while the <b>tokens</b> function breaks the string into tokens. A
      field consists of all non-separator characters between two separator
      characters or the beginning or end of the string. Thus, a field may be the
      empty string. A token is a maximal, non-empty substring not containing a
      separator character. The separator characters are those given in the
      <i>seps</i> argument. If <i>seps</i> is not provided, the default value is
      &quot; \t\n&quot;. The functions return the number of fields or tokens.
    <div style="height: 1.00em;">&#x00A0;</div>
    The fields and tokens are stored in the argument array. The array must be
      <b>string</b>-valued and, if an index type is specified, it must be
      <b>int</b>. The entries are indexed by consecutive integers, starting at
      0. Any values already stored in the array will be either overwritten, or
      still be present after the function returns.</dd>
</dl>
<h2 class="Ss" title="Ss" id="I/O"><a class="selflink" href="#I/O">I/O</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>print</b>(<i>...</i>) : <b>void</b></dt>
  <dd class="It-tag"><b>print(</b><i> expr</i><b>,</b><i> ...<b> )</b></i>
      <b>prints a string representation of each argument in turn onto</b>
      <b></b> <b>stdout</b><b>, followed by a newline.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>printf</b>(<i>fmt</i> : <b>string</b>, <i>...</i>) :
    <b>int</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>printf</b>(<i>fd</i> : <b>int</b>, <i>fmt</i> :
    <b>string</b>, <i>...</i>) : <b>int</b></dt>
  <dd class="It-tag">prints the string resulting from formatting the values of
      the expressions following <i>fmt</i> according to the <i>printf</i>(3)
      format <i>fmt</i>. Returns 0 on success. By default, it prints on
      <b>stdout</b>. If the optional integer <i>fd</i> is given, output is
      written on the open stream associated with <i>fd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>scanf</b>(<i>fmt</i> : <b>string</b>, <i>...</i>) :
    <b>int</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>scanf</b>(<i>fd</i> : <b>int</b>, <i>fmt</i> :
    <b>string</b>, <i>...</i>) : <b>int</b></dt>
  <dd class="It-tag">scans in values from an input stream according to the
      <i>scanf</i>(3) format <i>fmt</i>. The values are stored in the addresses
      following <i>fmt</i>, addresses having the form <b>&amp;</b><i>v</i>,
      where <i>v</i> is some declared variable of the correct type. By default,
      it reads from <b>stdin</b>. If the optional integer <i>fd</i> is given,
      input is read from the open stream associated with <i>fd</i>. Returns the
      number of items successfully scanned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>openF</b>(<i>s</i> : <b>string</b>, <i>t</i> :
    <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">opens the file <i>s</i> as an I/O stream. The string
      argument <i>t</i> specifies how the file is opened. The arguments are the
      same as for the C function <i>fopen</i>(3). It returns an integer denoting
      the stream, or -1 on error.
    <div style="height: 1.00em;">&#x00A0;</div>
    As usual, streams 0, 1 and 2 are already open as <b>stdin</b>,
      <b>stdout</b>, and <b>stderr</b>, respectively. Since <b>gvpr</b> may use
      <b>stdin</b> to read the input graphs, the user should avoid using this
      stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>closeF</b>(<i>fd</i> : <b>int</b>) : <b>int</b></dt>
  <dd class="It-tag">closes the open stream denoted by the integer <i>fd</i>.
      Streams 0, 1 and 2 cannot be closed. Returns 0 on success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>readL</b>(<i>fd</i> : <b>int</b>) : <b>string</b></dt>
  <dd class="It-tag">returns the next line read from the input stream <i>fd</i>.
      It returns the empty string &quot;&quot; on end of file. Note that the
      newline character is left in the returned string.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Math"><a class="selflink" href="#Math">Math</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exp</b>(<i>d</i> : <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns e to the <i>d</i>th power.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log</b>(<i>d</i> : <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns the natural log of <i>d</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sqrt</b>(<i>d</i> : <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns the square root of the double <i>d</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pow</b>(<i>d</i> : <b>double</b>, <i>x</i> :
    <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns <i>d</i> raised to the <i>x</i>th power.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cos</b>(<i>d</i> : <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns the cosine of <i>d</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sin</b>(<i>d</i> : <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns the sine of <i>d</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>atan2</b>(<i>y</i> : <b>double</b>, <i>x</i> :
    <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns the arctangent of <i>y/x</i> in the range -pi to
      pi.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>MIN</b>(<i>y</i> : <b>double</b>, <i>x</i> :
    <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns the minimum of <i>y</i> and <i>x</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>MAX</b>(<i>y</i> : <b>double</b>, <i>x</i> :
    <b>double</b>) : <b>double</b></dt>
  <dd class="It-tag">returns the maximum of <i>y</i> and <i>x</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Associative_Arrays"><a class="selflink" href="#Associative_Arrays">Associative
  Arrays</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#</b> <i>arr</i> : <b>int</b></dt>
  <dd class="It-tag">returns the number of elements in the array
    <i>arr</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>idx</i> <b>in</b> <i>arr</i> : <b>int</b></dt>
  <dd class="It-tag">returns 1 if a value has been set for index <i>idx</i> in
      the array <i>arr</i>. It returns 0 otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unset</b>(<i>v</i> : <b>array</b>, <i>idx</i>) :
    <b>int</b></dt>
  <dd class="It-tag">removes the item indexed by <i>idx</i>. It returns 1 if the
      item existed, 0 otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unset</b>(<i>v</i> : <b>array</b>) : <b>void</b></dt>
  <dd class="It-tag">re-initializes the array.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Miscellaneous"><a class="selflink" href="#Miscellaneous">Miscellaneous</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exit</b>(<i>v</i> : <b>int</b>) : <b>void</b></dt>
  <dd class="It-tag">causes <b>gvpr</b> to exit with the exit code
    <i>v</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>system</b>(<i>cmd</i> : <b>string</b>) : <b>int</b></dt>
  <dd class="It-tag">provides the standard C function <i>system</i>(3). It
      executes <i>cmd</i> in the user's shell environment, and returns the exit
      status of the shell.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rand</b>() : <b>double</b></dt>
  <dd class="It-tag">returns a pseudo&#x2010;random double between 0 and 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>srand</b>() : <b>int</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>srand</b>(<i>v</i> : <b>int</b>) : <b>int</b></dt>
  <dd class="It-tag">sets a seed for the random number generator. The optional
      argument gives the seed; if it is omitted, the current time is used. The
      previous seed value is returned. <b>srand</b> should be called before any
      calls to <b>rand</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>colorx</b>(<i>color</i> : <b>string</b>, <i>fmt</i> :
    <b>string</b>) : <b>string</b></dt>
  <dd class="It-tag">translates a color from one format to another. The
      <i>color</i> argument should be a color in one of the recognized string
      representations. The <i>fmt</i> value should be one of &quot;RGB&quot;,
      &quot;RGBA&quot;, &quot;HSV&quot;, or &quot;HSVA&quot;. An empty string is
      returned on error.</dd>
</dl>
<h1 class="Sh" title="Sh" id="BUILT&#x2010;IN_VARIABLES"><a class="selflink" href="#BUILT&#x2010;IN_VARIABLES">BUILT&#x2010;IN
  VARIABLES</a></h1>
<b>gvpr</b> provides certain special, built&#x2010;in variables, whose values
  are set automatically by <b>gvpr</b> depending on the context. Except as
  noted, the user cannot modify their values.
<dl class="Bl-tag">
  <dt class="It-tag"><b>$</b> : <b>obj_t</b></dt>
  <dd class="It-tag">denotes the current object (node, edge, graph) depending on
      the context. It is not available in <b>BEGIN</b> or <b>END</b>
    clauses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$F</b> : <b>string</b></dt>
  <dd class="It-tag">is the name of the current input file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$G</b> : <b>graph_t</b></dt>
  <dd class="It-tag">denotes the current graph being processed. It is not
      available in <b>BEGIN</b> or <b>END</b> clauses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$NG</b> : <b>graph_t</b></dt>
  <dd class="It-tag">denotes the next graph to be processed. If <b>$NG</b> is
      NULL, the current graph <b>$G</b> is the last graph. Note that if the
      input comes from stdin, the last graph cannot be determined until the
      input pipe is closed. It is not available in <b>BEGIN</b> or <b>END</b>
      clauses, or if the <b>-n</b> flag is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$O</b> : <b>graph_t</b></dt>
  <dd class="It-tag">denotes the output graph. Before graph traversal, it is
      initialized to the target graph. After traversal and any <b>END_G</b>
      actions, if it refers to a non&#x2010;empty graph, that graph is printed
      onto the output stream. It is only valid in <b>N</b>, <b>E</b> and
      <b>END_G</b> clauses. The output graph may be set by the user.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$T</b> : <b>graph_t</b></dt>
  <dd class="It-tag">denotes the current target graph. It is a subgraph of
      <b>$G</b> and is available only in <b>N</b>, <b>E</b> and <b>END_G</b>
      clauses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$tgtname</b> : <b>string</b></dt>
  <dd class="It-tag">denotes the name of the target graph. By default, it is set
      to <b>&quot;gvpr_result&quot;</b>. If used multiple times during the
      execution of <b>gvpr</b>, the name will be appended with an integer. This
      variable may be set by the user.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$tvroot</b> : <b>node_t</b></dt>
  <dd class="It-tag">indicates the starting node for a (directed or undirected)
      depth&#x2010;first or breadth&#x2010;first traversal of the graph (cf.
      <b>$tvtype</b> below). The default value is <b>NULL</b> for each input
      graph. After the traversal at the given root, if the value of
      <b>$tvroot</b> has changed, a new traversal will begin with the new value
      of <b>$tvroot</b>. Also, set <b>$tvnext</b> below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$tvnext</b> : <b>node_t</b></dt>
  <dd class="It-tag">indicates the next starting node for a (directed or
      undirected) depth&#x2010;first or breadth&#x2010;first traversal of the
      graph (cf. <b>$tvtype</b> below). If a traversal finishes and the
      <b>$tvroot</b> but the <b>$tvnext</b> has been set but not used, this node
      will be used as the next choice for <b>$tvroot</b>. The default value is
      <b>NULL</b> for each input graph.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$tvedge</b> : <b>edge_t</b></dt>
  <dd class="It-tag">For BFS and DFS traversals, this is set to the edge used to
      arrive at the current node or edge. At the beginning of a traversal, or
      for other traversal types, the value is <b>NULL</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$tvtype</b> : <b>tvtype_t</b></dt>
  <dd class="It-tag">indicates how <b>gvpr</b> traverses a graph. It can only
      take one of the constant values with the previx &quot;TV_&quot; described
      below. <b>TV_flat</b> is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In the underlying graph library <i>cgraph</i>(3), edges in
      undirected graphs are given an arbitrary direction. This is used for
      traversals, such as <b>TV_fwd</b>, requiring directed edges.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ARGC</b> : <b>int</b></dt>
  <dd class="It-tag">denotes the number of arguments specified by the <b>-a</b>
      <i>args</i> command&#x2010;line argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ARGV</b> : <b>string array</b></dt>
  <dd class="It-tag">denotes the array of arguments specified by the <b>-a</b>
      <i>args</i> command&#x2010;line argument. The <i>i</i>th argument is given
      by <b>ARGV[</b><i>i</i><b>]</b>.</dd>
</dl>
<h1 class="Sh" title="Sh" id="BUILT&#x2010;IN_CONSTANTS"><a class="selflink" href="#BUILT&#x2010;IN_CONSTANTS">BUILT&#x2010;IN
  CONSTANTS</a></h1>
There are several symbolic constants defined by <b>gvpr</b>.
<dl class="Bl-tag">
  <dt class="It-tag"><b>NULL</b> : <i>obj_t</i></dt>
  <dd class="It-tag">a null object reference, equivalent to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_flat</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">a simple, flat traversal, with graph objects visited in
      seemingly arbitrary order.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_ne</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">a traversal which first visits all of the nodes, then all
      of the edges.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_en</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">a traversal which first visits all of the edges, then all
      of the nodes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_dfs</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_postdfs</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_prepostdfs</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">a traversal of the graph using a depth&#x2010;first search
      on the underlying undirected graph. To do the traversal, <b>gvpr</b> will
      check the value of <b>$tvroot</b>. If this has the same value that it had
      previously (at the start, the previous value is initialized to
      <b>NULL</b>.), <b>gvpr</b> will simply look for some unvisited node and
      traverse its connected component. On the other hand, if <b>$tvroot</b> has
      changed, its connected component will be toured, assuming it has not been
      previously visited or, if <b>$tvroot</b> is <b>NULL</b>, the traversal
      will stop. Note that using <b>TV_dfs</b> and <b>$tvroot</b>, it is
      possible to create an infinite loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">By default, the traversal is done in pre-order. That is, a
      node is visited before all of its unvisited edges. For <b>TV_postdfs</b>,
      all of a node's unvisited edges are visited before the node. For
      <b>TV_prepostdfs</b>, a node is visited twice, before and after all of its
      unvisited edges.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_fwd</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_postfwd</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_prepostfwd</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">A traversal of the graph using a depth&#x2010;first search
      on the graph following only forward arcs. The choice of roots for the
      traversal is the same as described for <b>TV_dfs</b> above. The different
      order of visitation specified by <b>TV_fwd</b>, <b>TV_postfwd</b> and
      <b>TV_prepostfwd</b> are the same as those specified by the analogous
      traversals <b>TV_dfs</b>, <b>TV_postdfs</b> and <b>TV_prepostdfs</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_rev</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_postrev</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_prepostrev</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">A traversal of the graph using a depth&#x2010;first search
      on the graph following only reverse arcs. The choice of roots for the
      traversal is the same as described for <b>TV_dfs</b> above. The different
      order of visitation specified by <b>TV_rev</b>, <b>TV_postrev</b> and
      <b>TV_prepostrev</b> are the same as those specified by the analogous
      traversals <b>TV_dfs</b>, <b>TV_postdfs</b> and <b>TV_prepostdfs</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>TV_bfs</b> : <i>tvtype_t</i></dt>
  <dd class="It-tag">A traversal of the graph using a breadth&#x2010;first
      search on the graph ignoring edge directions. See the item on
      <b>TV_dfs</b> above for the role of <b>$tvroot</b>.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<div style="margin-left: 5.00ex;">
<pre>
<b>gvpr -i 'N[color==&quot;blue&quot;]' file.gv</b>
</pre>
</div>
<div class="Pp"></div>
Generate the node&#x2010;induced subgraph of all nodes with color blue.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<b>gvpr -c 'N[color==&quot;blue&quot;]{color = &quot;red&quot;}' file.gv</b>
</pre>
</div>
<div class="Pp"></div>
Make all blue nodes red.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<b>BEGIN { int n, e; int tot_n = 0; int tot_e = 0; }</b>
<b>BEG_G {</b>
<b>  n = nNodes($G);</b>
<b>  e = nEdges($G);</b>
<b>  printf (&quot;%d nodes %d edges %s\n&quot;, n, e, $G.name);</b>
<b>  tot_n += n;</b>
<b>  tot_e += e;</b>
<b>}</b>
<b>END { printf (&quot;%d nodes %d edges total\n&quot;, tot_n, tot_e) }</b>
</pre>
</div>
<div class="Pp"></div>
Version of the program <b>gc</b>.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<b>gvpr -c &quot;&quot;</b>
</pre>
</div>
<div class="Pp"></div>
Equivalent to <b>nop</b>.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<b>BEG_G { graph_t g = graph (&quot;merge&quot;, &quot;S&quot;); }</b>
<b>E {</b>
<b>  node_t h = clone(g,$.head);</b>
<b>  node_t t = clone(g,$.tail);</b>
<b>  edge_t e = edge(t,h,&quot;&quot;);</b>
<b>  e.weight = e.weight + 1;</b>
<b>}</b>
<b>END_G { $O = g; }</b>
</pre>
</div>
<div class="Pp"></div>
Produces a strict version of the input graph, where the weight attribute of an
  edge indicates how many edges from the input graph the edge represents.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<b>BEGIN {node_t n; int deg[]}</b>
<b>E{deg[head]++; deg[tail]++; }</b>
<b>END_G {</b>
<b>  for (deg[n]) {</b>
<b>    printf (&quot;deg[%s] = %d\n&quot;, n.name, deg[n]);</b>
<b>  }</b>
<b>}</b>
</pre>
</div>
<div class="Pp"></div>
Computes the degrees of nodes with edges.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<b>BEGIN {</b>
<b>  int i, indent;</b>
<b>  int seen[string];</b>
<b>  void prInd (int cnt) {</b>
<b>    for (i = 0; i &lt; cnt; i++) printf (&quot;  &quot;);</b>
<b>  }</b>
<b>}</b>
<b>BEG_G {</b>
<div class="Pp"></div>
<b>   $tvtype = TV_prepostfwd;</b>
<b>   $tvroot = node($,ARGV[0]);</b>
<b>}</b>
<b>N {</b>
<b>  if (seen[$.name]) indent--;</b>
<b>  else {</b>
<b>    prInd(indent);</b>
<b>      print ($.name);</b>
<b>    seen[$.name] = 1;</b>
<b>    indent++;</b>
<b>  }</b>
<b>}</b>
</pre>
</div>
<div class="Pp"></div>
Prints the depth-first traversal of the graph, starting with the node whose name
  is <b>ARGV[0]</b>, as an indented list.
<h1 class="Sh" title="Sh" id="ENVIRONMENT"><a class="selflink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>GVPRPATH</b></dt>
  <dd class="It-tag">Colon&#x2010;separated list of directories to be searched
      to find the file specified by the -f option. <b>gvpr</b> has a default
      list built in. If <b>GVPRPATH</b> is not defined, the default list is
      used. If <b>GVPRPATH</b> starts with colon, the list is formed by
      appending <b>GVPRPATH</b> to the default list. If <b>GVPRPATH</b> ends
      with colon, the list is formed by appending the default list to
      <b>GVPRPATH</b>. Otherwise, <b>GVPRPATH</b> is used for the list.</dd>
</dl>
<div class="Pp"></div>
On Windows systems, replace ``colon'' with ``semicolon'' in the previous
  paragraph.
<h1 class="Sh" title="Sh" id="BUGS_AND_WARNINGS"><a class="selflink" href="#BUGS_AND_WARNINGS">BUGS
  AND WARNINGS</a></h1>
Scripts should be careful deleting nodes during <b>N{}</b> and <b>E{}</b> blocks
  using BFS and DFS traversals as these rely on stacks and queues of nodes.
<div class="Pp"></div>
When the program is given as a command line argument, the usual shell
  interpretation takes place, which may affect some of the special names in
  <b>gvpr</b>. To avoid this, it is best to wrap the program in single quotes.
<div class="Pp"></div>
If string constants contain pattern metacharacters that you want to escape to
  avoid pattern matching, two backslashes will probably be necessary, as a
  single backslash will be lost when the string is originally scanned. Usually,
  it is simpler to use <b>strcmp</b> to avoid pattern matching.
<div class="Pp"></div>
As of 24 April 2008, <b>gvpr</b> switched to using a new, underlying graph
  library, which uses the simpler model that there is only one copy of a node,
  not one copy for each subgraph logically containing it. This means that
  iterators such as <i>nxtnode</i> cannot traverse a subgraph using just a node
  argument. For this reason, subgraph traversal requires new functions ending in
  &quot;_sg&quot;, which also take a subgraph argument. The versions without
  that suffix will always traverse the root graph.
<div class="Pp"></div>
There is a single global scope, except for formal function parameters, and even
  these can interfere with the type system. Also, the extent of all variables is
  the entire life of the program. It might be preferable for scope to reflect
  the natural nesting of the clauses, or for the program to at least reset
  locally declared variables. For now, it is advisable to use distinct names for
  all variables.
<div class="Pp"></div>
If a function ends with a complex statement, such as an IF statement, with each
  branch doing a return, type checking may fail. Functions should use a return
  at the end.
<div class="Pp"></div>
The expr library does not support string values of (char*)0. This means we can't
  distinguish between &quot;&quot; and (char*)0 edge keys. For the purposes of
  looking up and creating edges, we translate &quot;&quot; to be (char*)0, since
  this latter value is necessary in order to look up any edge with a matching
  head and tail.
<div class="Pp"></div>
Related to this, strings converted to integers act like char pointers, getting
  the value 0 or 1 depending on whether the string consists solely of zeroes or
  not. Thus, the ((int)&quot;2&quot;) evaluates to 1.
<div class="Pp"></div>
The language inherits the usual C problems such as dangling references and the
  confusion between '=' and '=='.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Emden R. Gansner &lt;erg@research.att.com&gt;
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
awk(1), gc(1), dot(1), nop(1), expr(3), cgraph(3)</div>
<table class="foot">
  <tr>
    <td class="foot-date">4 May 2012</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
