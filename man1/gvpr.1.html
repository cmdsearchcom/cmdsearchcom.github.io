<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:16:12 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GVPR(1) General Commands Manual GVPR(1)</p>

<p style="margin-top: 1em">NAME <br>
gvpr - graph pattern scanning and processing language <br>
( previously known as gpr )</p>

<p style="margin-top: 1em">SYNOPSIS <br>
gvpr [-icnqV?] [ -o outfile ] [ -a args ] [
&rsquo;prog&rsquo; | -f progfile ] [ files ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
gvpr is a graph stream editor inspired by awk. It copies
input graphs to its output, possibly transforming their
structure and attributes, creating new graphs, or printing
arbi&acirc; <br>
trary information. The graph model is that provided by
libcgraph(3). In particular, gvpr reads and writes graphs
using the dot language.</p>

<p style="margin-top: 1em">Basically, gvpr traverses each
input graph, denoted by $G, visiting each node and edge,
matching it with the predicate&acirc;action rules supplied
in the input program. The rules are <br>
evaluated in order. For each predicate evaluating to true,
the corresponding action is performed. During the traversal,
the current node or edge being visited is denoted by $.</p>

<p style="margin-top: 1em">For each input graph, there is a
target subgraph, denoted by $T, initially empty and used to
accumulate chosen entities, and an output graph, $O, used
for final processing and <br>
then written to output. By default, the output graph is the
target graph. The output graph can be set in the program or,
in a limited sense, on the command line.</p>

<p style="margin-top: 1em">OPTIONS <br>
The following options are supported:</p>

<p style="margin-top: 1em">-a args <br>
The string args is split into whitespace&acirc;separated
tokens, with the individual tokens available as strings in
the gvpr program as ARGV[0],...,ARGV[ARGC-1]. Whitespace
<br>
characters within single or double quoted substrings, or
preceded by a backslash, are ignored as separators. In
general, a backslash character turns off any special
mean&acirc; <br>
ing of the following character. Note that the tokens derived
from multiple -a flags are concatenated.</p>

<p style="margin-top: 1em">-c Use the source graph as the
output graph.</p>

<p style="margin-top: 1em">-i Derive the node&acirc;induced
subgraph extension of the output graph in the context of its
root graph.</p>

<p style="margin-top: 1em">-o outfile <br>
Causes the output stream to be written to the specified
file; by default, output is written to stdout.</p>

<p style="margin-top: 1em">-f progfile <br>
Use the contents of the specified file as the program to
execute on the input. If progfile contains a slash
character, the name is taken as the pathname of the file.
Oth&acirc; <br>
erwise, gvpr will use the directories specified in the
environment variable GVPRPATH to look for the file. If -f is
not given, gvpr will use the first non&acirc;option argument
<br>
as the program.</p>

<p style="margin-top: 1em">-q Turns off warning
messages.</p>

<p style="margin-top: 1em">-n Turns off graph read-ahead.
By default, the variable $NG is set to the next graph to be
processed. This requires a read of the next graph before
processing the current <br>
graph, which may block is the next graph is only generated
in response to some action pertaining to the processing of
the current graph.</p>

<p style="margin-top: 1em">-V Causes the program to print
version information and exit.</p>

<p style="margin-top: 1em">-? Causes the program to print
usage information and exit.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operand is supported:</p>

<p style="margin-top: 1em">files Names of files containing
1 or more graphs in the dot language. If no -f option is
given, the first name is removed from the list and used as
the input program. If the <br>
list of files is empty, stdin will be used.</p>

<p style="margin-top: 1em">PROGRAMS <br>
A gvpr program consists of a list of predicate&acirc;action
clauses, having one of the forms:</p>

<p style="margin-top: 1em">BEGIN { action }</p>

<p style="margin-top: 1em">BEG_G { action }</p>

<p style="margin-top: 1em">N [ predicate ] { action }</p>

<p style="margin-top: 1em">E [ predicate ] { action }</p>

<p style="margin-top: 1em">END_G { action }</p>

<p style="margin-top: 1em">END { action }</p>

<p style="margin-top: 1em">A program can contain at most
one of each of the BEGIN, END_G and END clauses. There can
be any number of BEG_G, N and E statements, the first
applied to graphs, the second to <br>
nodes, the third to edges. These are separated into blocks,
a block consisting of an optional BEG_G statement and all N
and E statements up to the next BEG_G statement, if any.
<br>
The top&acirc;level semantics of a gvpr program are:</p>

<p style="margin-top: 1em">Evaluate the BEGIN clause, if
any. <br>
For each input graph G { <br>
For each block { <br>
Set G as the current graph and current object. <br>
Evaluate the BEG_G clause, if any. <br>
For each node and edge in G { <br>
Set the node or edge as the current object. <br>
Evaluate the N or E clauses, as appropriate. <br>
} <br>
} <br>
Set G as the current object. <br>
Evaluate the END_G clause, if any. <br>
} <br>
Evaluate the END clause, if any.</p>

<p style="margin-top: 1em">The actions of the BEGIN, BEG_G,
END_G and END clauses are performed when the clauses are
evaluated. For N or E clauses, either the predicate or
action may be omitted. If there <br>
is no predicate with an action, the action is performed on
every node or edge, as appropriate. If there is no action
and the predicate evaluates to true, the associated node or
<br>
edge is added to the target graph.</p>

<p style="margin-top: 1em">The blocks are evaluated in the
order in which they occur. Within a block, the N clauses (E
clauses, respectively) are evaluated in the order in which
the occur. Note, though, <br>
that within a block, N or E clauses may be interlaced,
depending on the traversal order.</p>

<p style="margin-top: 1em">Predicates and actions are
sequences of statements in the C dialect supported by the
expr(3) library. The only difference between predicates and
actions is that the former must <br>
have a type that may interpreted as either true or false.
Here the usual C convention is followed, in which a
non&acirc;zero value is considered true. This would include
non&acirc;empty <br>
strings and non&acirc;empty references to nodes, edges, etc.
However, if a string can be converted to an integer, this
value is used.</p>

<p style="margin-top: 1em">In addition to the usual C base
types (void, int, char, float, long, unsigned and double),
gvpr provides string as a synonym for char*, and the
graph&acirc;based types node_t, edge_t, <br>
graph_t and obj_t. The obj_t type can be viewed as a
supertype of the other 3 concrete types; the correct base
type is maintained dynamically. Besides these base types,
the <br>
only other supported type expressions are (associative)
arrays.</p>

<p style="margin-top: 1em">Constants follow C syntax, but
strings may be quoted with either &quot;...&quot; or
&rsquo;...&rsquo;. gvpr accepts C++ comments as well as
cpp&acirc;type comments. For the latter, if a line begins
with a <br>
&rsquo;#&rsquo; character, the rest of the line is
ignored.</p>

<p style="margin-top: 1em">A statement can be a declaration
of a function, a variable or an array, or an executable
statement. For declarations, there is a single scope. Array
declarations have the form:</p>

<p style="margin-top: 1em">type array [ type0 ]</p>

<p style="margin-top: 1em">where type0 is optional. If it
is supplied, the parser will enforce that all array
subscripts have the specified type. If it is not supplied,
objects of all types can be used <br>
as subscripts. As in C, variables and arrays must be
declared. In particular, an undeclared variable will be
interpreted as the name of an attribute of a node, edge or
graph, <br>
depending on the context.</p>

<p style="margin-top: 1em">Executable statements can be one
of the following: <br>
{ [ statement ... ] } <br>
expression // commonly var = expression <br>
if( expression ) statement [ else statement ] <br>
for( expression ; expression ; expression ) statement <br>
for( array [ var ]) statement <br>
forr( array [ var ]) statement <br>
while( expression ) statement <br>
switch( expression ) case statements <br>
break [ expression ] <br>
continue [ expression ] <br>
return [ expression ] <br>
Items in brackets are optional.</p>

<p style="margin-top: 1em">In the second form of the for
statement and the forr statement, the variable var is set to
each value used as an index in the specified array and then
the associated statement is <br>
evaluated. For numeric and string indices, the indices are
returned in increasing (decreasing) numeric or lexicographic
order for for (forr, respectively). This can be used for
<br>
sorting.</p>

<p style="margin-top: 1em">Function definitions can only
appear in the BEGIN clause.</p>

<p style="margin-top: 1em">Expressions include the usual C
expressions. String comparisons using == and != treat the
right hand operand as a pattern for the purpose of regular
expression matching. Pat&acirc; <br>
terns use ksh(1) file match pattern syntax. (For simple
string equality, use the strcmp function.</p>

<p style="margin-top: 1em">gvpr will attempt to use an
expression as a string or numeric value as appropriate. Both
C-like casts and function templates will cause conversions
to be performed, if possible.</p>

<p style="margin-top: 1em">Expressions of graphical type
(i.e., graph_t, node_t, edge_t, obj_t) may be followed by a
field reference in the form of .name. The resulting value is
the value of the attribute <br>
named name of the given object. In addition, in certain
contexts an undeclared, unmodified identifier is taken to be
an attribute name. Specifically, such identifiers denote
<br>
attributes of the current node or edge, respectively, in N
and E clauses, and the current graph in BEG_G and END_G
clauses.</p>

<p style="margin-top: 1em">As usual in the libcgraph(3)
model, attributes are string&acirc;valued. In addition, gvpr
supports certain pseudo&acirc;attributes of graph objects,
not necessarily string&acirc;valued. These <br>
reflect intrinsic properties of the graph objects and cannot
be set by the user.</p>

<p style="margin-top: 1em">head : node_t <br>
the head of an edge.</p>

<p style="margin-top: 1em">tail : node_t <br>
the tail of an edge.</p>

<p style="margin-top: 1em">name : string <br>
the name of an edge, node or graph. The name of an edge has
the form
&quot;&lt;tail&acirc;name&gt;&lt;edge&acirc;op&gt;&lt;head&acirc;name&gt;[&lt;key&gt;]&quot;,
where &lt;edge&acirc;op&gt; is &quot;-&gt;&quot; or
&quot;--&quot; depending on whether the <br>
graph is directed or not. The bracket part [&lt;key&gt;]
only appears if the edge has a non&acirc;trivial key.</p>

<p style="margin-top: 1em">indegree : int <br>
the indegree of a node.</p>

<p style="margin-top: 1em">outdegree : int <br>
the outdegree of a node.</p>

<p style="margin-top: 1em">degree : int <br>
the degree of a node.</p>

<p style="margin-top: 1em">root : graph_t <br>
the root graph of an object. The root of a root graph is
itself.</p>

<p style="margin-top: 1em">parent : graph_t <br>
the parent graph of a subgraph. The parent of a root graph
is NULL</p>

<p style="margin-top: 1em">n_edges : int <br>
the number of edges in the graph</p>

<p style="margin-top: 1em">n_nodes : int <br>
the number of nodes in the graph</p>

<p style="margin-top: 1em">directed : int <br>
true (non&acirc;zero) if the graph is directed</p>

<p style="margin-top: 1em">strict : int <br>
true (non&acirc;zero) if the graph is strict</p>

<p style="margin-top: 1em">BUILT&acirc;IN FUNCTIONS <br>
The following functions are built into gvpr. Those functions
returning references to graph objects return NULL in case of
failure.</p>

<p style="margin-top: 1em">Graphs and subgraph <br>
graph(s : string, t : string) : graph_t <br>
creates a graph whose name is s and whose type is specified
by the string t. Ignoring case, the characters U, D, S, N
have the interpretation undirected, directed, strict, <br>
and non&acirc;strict, respectively. If t is empty, a
directed, non&acirc;strict graph is generated.</p>

<p style="margin-top: 1em">subg(g : graph_t, s : string) :
graph_t <br>
creates a subgraph in graph g with name s. If the subgraph
already exists, it is returned.</p>

<p style="margin-top: 1em">isSubg(g : graph_t, s : string)
: graph_t <br>
returns the subgraph in graph g with name s, if it exists,
or NULL otherwise.</p>

<p style="margin-top: 1em">fstsubg(g : graph_t) : graph_t
<br>
returns the first subgraph in graph g, or NULL if none
exists.</p>

<p style="margin-top: 1em">nxtsubg(sg : graph_t) : graph_t
<br>
returns the next subgraph after sg, or NULL.</p>

<p style="margin-top: 1em">isDirect(g : graph_t) : int <br>
returns true if and only if g is directed.</p>

<p style="margin-top: 1em">isStrict(g : graph_t) : int <br>
returns true if and only if g is strict.</p>

<p style="margin-top: 1em">nNodes(g : graph_t) : int <br>
returns the number of nodes in g.</p>

<p style="margin-top: 1em">nEdges(g : graph_t) : int <br>
returns the number of edges in g.</p>

<p style="margin-top: 1em">Nodes <br>
node(sg : graph_t, s : string) : node_t <br>
creates a node in graph g of name s. If such a node already
exists, it is returned.</p>

<p style="margin-top: 1em">subnode(sg : graph_t, n :
node_t) : node_t <br>
inserts the node n into the subgraph g. Returns the
node.</p>

<p style="margin-top: 1em">fstnode(g : graph_t) : node_t
<br>
returns the first node in graph g, or NULL if none
exists.</p>

<p style="margin-top: 1em">nxtnode(n : node_t) : node_t
<br>
returns the next node after n in the root graph, or
NULL.</p>

<p style="margin-top: 1em">nxtnode_sg(sg : graph_t, n :
node_t) : node_t <br>
returns the next node after n in sg, or NULL.</p>

<p style="margin-top: 1em">isNode(sg : graph_t, s : string)
: node_t <br>
looks for a node in (sub)graph sg of name s. If such a node
exists, it is returned. Otherwise, NULL is returned.</p>

<p style="margin-top: 1em">isSubnode(sg : graph_t, n :
node_t) : int <br>
returns non-zero if node n is in (sub)graph sg, or zero
otherwise.</p>

<p style="margin-top: 1em">indegreeOf(sg : graph_t, n :
node_t) : int <br>
returns the indegree of node n in (sub)graph sg.</p>

<p style="margin-top: 1em">outdegreeOf(sg : graph_t, n :
node_t) : int <br>
returns the outdegree of node n in (sub)graph sg.</p>

<p style="margin-top: 1em">degreeOf(sg : graph_t, n :
node_t) : int <br>
returns the degree of node n in (sub)graph sg.</p>

<p style="margin-top: 1em">Edges <br>
edge(t : node_t, h : node_t, s : string) : edge_t <br>
creates an edge with tail node t, head node h and name s in
the root graph. If the graph is undirected, the distinction
between head and tail nodes is unimportant. If <br>
such an edge already exists, it is returned.</p>

<p style="margin-top: 1em">edge_sg(sg : graph_t, t :
node_t, h : node_t, s : string) : edge_t <br>
creates an edge with tail node t, head node h and name s in
(sub)graph sg (and all parent graphs). If the graph is
undirected, the distinction between head and tail nodes <br>
is unimportant. If such an edge already exists, it is
returned.</p>

<p style="margin-top: 1em">subedge(g : graph_t, e : edge_t)
: edge_t <br>
inserts the edge e into the subgraph g. Returns the
edge.</p>

<p style="margin-top: 1em">isEdge(t : node_t, h : node_t, s
: string) : edge_t <br>
looks for an edge with tail node t, head node h and name s.
If the graph is undirected, the distinction between head and
tail nodes is unimportant. If such an edge <br>
exists, it is returned. Otherwise, NULL is returned.</p>

<p style="margin-top: 1em">isEdge_sg(sg : graph_t, t :
node_t, h : node_t, s : string) : edge_t <br>
looks for an edge with tail node t, head node h and name s
in (sub)graph sg. If the graph is undirected, the
distinction between head and tail nodes is unimportant. If
<br>
such an edge exists, it is returned. Otherwise, NULL is
returned.</p>

<p style="margin-top: 1em">isSubedge(g : graph_t, e :
edge_t) : int <br>
returns non-zero if edge e is in (sub)graph sg, or zero
otherwise.</p>

<p style="margin-top: 1em">fstout(n : node_t) : edge_t <br>
returns the first outedge of node n in the root graph.</p>

<p style="margin-top: 1em">fstout_sg(sg : graph_t, n :
node_t) : edge_t <br>
returns the first outedge of node n in (sub)graph sg.</p>

<p style="margin-top: 1em">nxtout(e : edge_t) : edge_t <br>
returns the next outedge after e in the root graph.</p>

<p style="margin-top: 1em">nxtout_sg(sg : graph_t, e :
edge_t) : edge_t <br>
returns the next outedge after e in graph sg.</p>

<p style="margin-top: 1em">fstin(n : node_t) : edge_t <br>
returns the first inedge of node n in the root graph.</p>

<p style="margin-top: 1em">fstin_sg(sg : graph_t, n :
node_t) : edge_t <br>
returns the first inedge of node n in graph sg.</p>

<p style="margin-top: 1em">nxtin(e : edge_t) : edge_t <br>
returns the next inedge after e in the root graph.</p>

<p style="margin-top: 1em">nxtin_sg(sg : graph_t, e :
edge_t) : edge_t <br>
returns the next inedge after e in graph sg.</p>

<p style="margin-top: 1em">fstedge(n : node_t) : edge_t
<br>
returns the first edge of node n in the root graph.</p>

<p style="margin-top: 1em">fstedge_sg(sg : graph_t, n :
node_t) : edge_t <br>
returns the first edge of node n in graph sg.</p>

<p style="margin-top: 1em">nxtedge(e : edge_t, node_t) :
edge_t <br>
returns the next edge after e in the root graph.</p>

<p style="margin-top: 1em">nxtedge_sg(sg : graph_t, e :
edge_t, node_t) : edge_t <br>
returns the next edge after e in the graph sg.</p>

<p style="margin-top: 1em">opp(e : edge_t, node_t) : node_t
<br>
returns the node on the edge e not equal to n. Returns NULL
if n is not a node of e. This can be useful when using
fstedge and nxtedge to enumerate the neighbors of n.</p>

<p style="margin-top: 1em">Graph I/O <br>
write(g : graph_t) : void <br>
prints g in dot format onto the output stream.</p>

<p style="margin-top: 1em">writeG(g : graph_t, fname :
string) : void <br>
prints g in dot format into the file fname.</p>

<p style="margin-top: 1em">fwriteG(g : graph_t, fd : int) :
void <br>
prints g in dot format onto the open stream denoted by the
integer fd.</p>

<p style="margin-top: 1em">readG(fname : string) : graph_t
<br>
returns a graph read from the file fname. The graph should
be in dot format. If no graph can be read, NULL is
returned.</p>

<p style="margin-top: 1em">freadG(fd : int) : graph_t <br>
returns the next graph read from the open stream fd. Returns
NULL at end of file.</p>

<p style="margin-top: 1em">Graph miscellany <br>
delete(g : graph_t, x : obj_t) : void <br>
deletes object x from graph g. If g is NULL, the function
uses the root graph of x. If x is a graph or subgraph, it is
closed unless x is locked.</p>

<p style="margin-top: 1em">isIn(g : graph_t, x : obj_t) :
int <br>
returns true if x is in subgraph g.</p>

<p style="margin-top: 1em">cloneG(g : graph_t, s : string)
: graph_t <br>
creates a clone of graph g with name of s. If s is
&quot;&quot;, the created graph has the same name as g.</p>

<p style="margin-top: 1em">clone(g : graph_t, x : obj_t) :
obj_t <br>
creates a clone of object x in graph g. In particular, the
new object has the same name/value attributes and structure
as the original object. If an object with the same <br>
key as x already exists, its attributes are overlaid by
those of x and the object is returned. If an edge is cloned,
both endpoints are implicitly cloned. If a graph is <br>
cloned, all nodes, edges and subgraphs are implicitly
cloned. If x is a graph, g may be NULL, in which case the
cloned object will be a new root graph. In this case, the
<br>
call is equivalent to cloneG(x,&quot;&quot;).</p>

<p style="margin-top: 1em">copy(g : graph_t, x : obj_t) :
obj_t <br>
creates a copy of object x in graph g, where the new object
has the same name/value attributes as the original object.
If an object with the same key as x already exists, <br>
its attributes are overlaid by those of x and the object is
returned. Note that this is a shallow copy. If x is a graph,
none of its nodes, edges or subgraphs are copied <br>
into the new graph. If x is an edge, the endpoints are
created if necessary, but they are not cloned. If x is a
graph, g may be NULL, in which case the cloned object will
<br>
be a new root graph.</p>

<p style="margin-top: 1em">copyA(src : obj_t, tgt : obj_t)
: int <br>
copies the attributes of object src to object tgt,
overwriting any attribute values tgt may initially have.</p>

<p style="margin-top: 1em">induce(g : graph_t) : void <br>
extends g to its node&acirc;induced subgraph extension in
its root graph.</p>

<p style="margin-top: 1em">hasAttr(src : obj_t, name :
string) : int <br>
returns non-zero if object src has an attribute whose name
is name. It returns 0 otherwise.</p>

<p style="margin-top: 1em">isAttr(g : graph_t, kind :
string, name : string) : int <br>
returns non-zero if an attribute name has been defined in g
for objects of the given kind. For nodes, edges, and graphs,
kind should be &quot;N&quot;, &quot;E&quot;, and
&quot;G&quot;, respectively. <br>
It returns 0 otherwise.</p>

<p style="margin-top: 1em">aget(src : obj_t, name : string)
: string <br>
returns the value of attribute name in object src. This is
useful for those cases when name conflicts with one of the
keywords such as &quot;head&quot; or &quot;root&quot;. If
the attribute <br>
has not been declared in the graph, the function will
initialize it with a default value of &quot;&quot;. To avoid
this, one should use the hasAttr or isAttr function to check
that <br>
the attribute exists.</p>

<p style="margin-top: 1em">aset(src : obj_t, name : string,
value : string) : int <br>
sets the value of attribute name in object src to value.
Returns 0 on success, non&acirc;zero on failure. See aget
above.</p>

<p style="margin-top: 1em">getDflt(g : graph_t, kind :
string, name : string) : string <br>
returns the default value of attribute name in objects in g
of the given kind. For nodes, edges, and graphs, kind should
be &quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively. If the <br>
attribute has not been declared in the graph, the function
will initialize it with a default value of &quot;&quot;. To
avoid this, one should use the isAttr function to check that
<br>
the attribute exists.</p>

<p style="margin-top: 1em">setDflt(g : graph_t, kind :
string, name : string, value : string) : int <br>
sets the default value of attribute name to value in objects
in g of the given kind. For nodes, edges, and graphs, kind
should be &quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively. Returns <br>
0 on success, non&acirc;zero on failure. See getDflt
above.</p>

<p style="margin-top: 1em">fstAttr(g : graph_t, kind :
string) : string <br>
returns the name of the first attribute of objects in g of
the given kind. For nodes, edges, and graphs, kind should be
&quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively. If there are no <br>
attributes, the string &quot;&quot; is returned.</p>

<p style="margin-top: 1em">nxtAttr(g : graph_t, kind :
string, name : string) : string <br>
returns the name of the next attribute of objects in g of
the given kind after the attribute name. The argument name
must be the name of an existing attribute; it will <br>
typically be the return value of an previous call to fstAttr
or nxtAttr. For nodes, edges, and graphs, kind should be
&quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively. If there are no <br>
attributes left, the string &quot;&quot; is returned.</p>

<p style="margin-top: 1em">compOf(g : graph_t, n : node_t)
: graph_t <br>
returns the connected component of the graph g containing
node n, as a subgraph of g. The subgraph only contains the
nodes. One can use induce to add the edges. The func&acirc;
<br>
tion fails and returns NULL if n is not in g. Connectivity
is based on the underlying undirected graph of g.</p>

<p style="margin-top: 1em">kindOf(obj : obj_t) : string
<br>
returns an indication of what kind of graph object is the
argument. For nodes, edges, and graphs, it returns should be
&quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively.</p>

<p style="margin-top: 1em">lock(g : graph_t, v : int) : int
<br>
implements graph locking on root graphs. If the integer v is
positive, the graph is set so that future calls to delete
have no immediate effect. If v is zero, the graph <br>
is unlocked. If there has been a call to delete the graph
while it was locked, the graph is closed. If v is negative,
nothing is done. In all cases, the previous lock <br>
value is returned.</p>

<p style="margin-top: 1em">Strings <br>
sprintf(fmt : string, ...) : string <br>
returns the string resulting from formatting the values of
the expressions occurring after fmt according to the
printf(3) format fmt</p>

<p style="margin-top: 1em">gsub(str : string, pat : string)
: string</p>

<p style="margin-top: 1em">gsub(str : string, pat : string,
repl : string) : string <br>
returns str with all substrings matching pat deleted or
replaced by repl, respectively.</p>

<p style="margin-top: 1em">sub(str : string, pat : string)
: string</p>

<p style="margin-top: 1em">sub(str : string, pat : string,
repl : string) : string <br>
returns str with the leftmost substring matching pat deleted
or replaced by repl, respectively. The characters
&rsquo;^&rsquo; and &rsquo;$&rsquo; may be used at the
beginning and end, respec&acirc; <br>
tively, of pat to anchor the pattern to the beginning or end
of str.</p>

<p style="margin-top: 1em">substr(str : string, idx : int)
: string</p>

<p style="margin-top: 1em">substr(str : string, idx : int,
len : int) : string <br>
returns the substring of str starting at position idx to the
end of the string or of length len, respectively. Indexing
starts at 0. If idx is negative or idx is greater <br>
than the length of str, a fatal error occurs. Similarly, in
the second case, if len is negative or idx + len is greater
than the length of str, a fatal error occurs.</p>

<p style="margin-top: 1em">strcmp(s1 : string, s2 : string)
: int <br>
provides the standard C function strcmp(3).</p>

<p style="margin-top: 1em">length(s : string) : int <br>
returns the length of string s.</p>

<p style="margin-top: 1em">index(s : string, t : string) :
int</p>

<p style="margin-top: 1em">rindex(s : string, t : string) :
int <br>
returns the index of the character in string s where the
leftmost (rightmost) copy of string t can be found, or -1 if
t is not a substring of s.</p>

<p style="margin-top: 1em">match(s : string, p : string) :
int <br>
returns the index of the character in string s where the
leftmost match of pattern p can be found, or -1 if no
substring of s matches p.</p>

<p style="margin-top: 1em">toupper(s : string) : string
<br>
returns a version of s with the alphabetic characters
converted to upper-case.</p>

<p style="margin-top: 1em">tolower(s : string) : string
<br>
returns a version of s with the alphabetic characters
converted to lower-case.</p>

<p style="margin-top: 1em">canon(s : string) : string <br>
returns a version of s appropriate to be used as an
identifier in a dot file.</p>

<p style="margin-top: 1em">html(g : graph_t, s : string) :
string <br>
returns a &lsquo;&lsquo;magic&rsquo;&rsquo; version of s as
an HTML string. This will typically be used to attach an
HTML-like label to a graph object. Note that the returned
string lives in g. <br>
In particular, it will be freed when g is closed, and to act
as an HTML string, it has to be used with an object of g. In
addition, note that the angle bracket quotes <br>
should not be part of s. These will be added if g is written
in concrete DOT format.</p>

<p style="margin-top: 1em">ishtml(s : string) : int <br>
returns non-zero if and only if s is an HTML string.</p>

<p style="margin-top: 1em">xOf(s : string) : string <br>
returns the string &quot;x&quot; if s has the form
&quot;x,y&quot;, where both x and y are numeric.</p>

<p style="margin-top: 1em">yOf(s : string) : string <br>
returns the string &quot;y&quot; if s has the form
&quot;x,y&quot;, where both x and y are numeric.</p>

<p style="margin-top: 1em">llOf(s : string) : string <br>
returns the string &quot;llx,lly&quot; if s has the form
&quot;llx,lly,urx,ury&quot;, where all of llx, lly, urx, and
ury are numeric.</p>

<p style="margin-top: 1em">urOf(s) <br>
urOf(s : string) : string returns the string
&quot;urx,ury&quot; if s has the form
&quot;llx,lly,urx,ury&quot;, where all of llx, lly, urx, and
ury are numeric.</p>

<p style="margin-top: 1em">sscanf(s : string, fmt : string,
...) : int <br>
scans the string s, extracting values according to the
sscanf(3) format fmt. The values are stored in the addresses
following fmt, addresses having the form &amp;v, where v
<br>
is some declared variable of the correct type. Returns the
number of items successfully scanned.</p>

<p style="margin-top: 1em">split(s : string, arr : array,
seps : string) : int</p>

<p style="margin-top: 1em">split(s : string, arr : array) :
int</p>

<p style="margin-top: 1em">tokens(s : string, arr : array,
seps : string) : int</p>

<p style="margin-top: 1em">tokens(s : string, arr : array)
: int <br>
The split function breaks the string s into fields, while
the tokens function breaks the string into tokens. A field
consists of all non-separator characters between two <br>
separator characters or the beginning or end of the string.
Thus, a field may be the empty string. A token is a maximal,
non-empty substring not containing a separator <br>
character. The separator characters are those given in the
seps argument. If seps is not provided, the default value is
&quot; 0. The functions return the number of <br>
fields or tokens.</p>

<p style="margin-top: 1em">The fields and tokens are stored
in the argument array. The array must be string-valued and,
if an index type is specified, it must be int. The entries
are indexed by con&acirc; <br>
secutive integers, starting at 0. Any values already stored
in the array will be either overwritten, or still be present
after the function returns.</p>

<p style="margin-top: 1em">I/O <br>
print(...) : void <br>
print( expr, ... ) prints a string representation of each
argument in turn onto stdout, followed by a newline.</p>

<p style="margin-top: 1em">printf(fmt : string, ...) :
int</p>

<p style="margin-top: 1em">printf(fd : int, fmt : string,
...) : int <br>
prints the string resulting from formatting the values of
the expressions following fmt according to the printf(3)
format fmt. Returns 0 on success. By default, it <br>
prints on stdout. If the optional integer fd is given,
output is written on the open stream associated with fd.</p>

<p style="margin-top: 1em">scanf(fmt : string, ...) :
int</p>

<p style="margin-top: 1em">scanf(fd : int, fmt : string,
...) : int <br>
scans in values from an input stream according to the
scanf(3) format fmt. The values are stored in the addresses
following fmt, addresses having the form &amp;v, where v is
<br>
some declared variable of the correct type. By default, it
reads from stdin. If the optional integer fd is given, input
is read from the open stream associated with fd. <br>
Returns the number of items successfully scanned.</p>

<p style="margin-top: 1em">openF(s : string, t : string) :
int <br>
opens the file s as an I/O stream. The string argument t
specifies how the file is opened. The arguments are the same
as for the C function fopen(3). It returns an inte&acirc;
<br>
ger denoting the stream, or -1 on error.</p>

<p style="margin-top: 1em">As usual, streams 0, 1 and 2 are
already open as stdin, stdout, and stderr, respectively.
Since gvpr may use stdin to read the input graphs, the user
should avoid using <br>
this stream.</p>

<p style="margin-top: 1em">closeF(fd : int) : int <br>
closes the open stream denoted by the integer fd. Streams 0,
1 and 2 cannot be closed. Returns 0 on success.</p>

<p style="margin-top: 1em">readL(fd : int) : string <br>
returns the next line read from the input stream fd. It
returns the empty string &quot;&quot; on end of file. Note
that the newline character is left in the returned
string.</p>

<p style="margin-top: 1em">Math <br>
exp(d : double) : double <br>
returns e to the dth power.</p>

<p style="margin-top: 1em">log(d : double) : double <br>
returns the natural log of d.</p>

<p style="margin-top: 1em">sqrt(d : double) : double <br>
returns the square root of the double d.</p>

<p style="margin-top: 1em">pow(d : double, x : double) :
double <br>
returns d raised to the xth power.</p>

<p style="margin-top: 1em">cos(d : double) : double <br>
returns the cosine of d.</p>

<p style="margin-top: 1em">sin(d : double) : double <br>
returns the sine of d.</p>

<p style="margin-top: 1em">atan2(y : double, x : double) :
double <br>
returns the arctangent of y/x in the range -pi to pi.</p>

<p style="margin-top: 1em">MIN(y : double, x : double) :
double <br>
returns the minimum of y and x.</p>

<p style="margin-top: 1em">MAX(y : double, x : double) :
double <br>
returns the maximum of y and x.</p>

<p style="margin-top: 1em">Associative Arrays <br>
# arr : int <br>
returns the number of elements in the array arr.</p>

<p style="margin-top: 1em">idx in arr : int <br>
returns 1 if a value has been set for index idx in the array
arr. It returns 0 otherwise.</p>

<p style="margin-top: 1em">unset(v : array, idx) : int <br>
removes the item indexed by idx. It returns 1 if the item
existed, 0 otherwise.</p>

<p style="margin-top: 1em">unset(v : array) : void <br>
re-initializes the array.</p>

<p style="margin-top: 1em">Miscellaneous <br>
exit(v : int) : void <br>
causes gvpr to exit with the exit code v.</p>

<p style="margin-top: 1em">system(cmd : string) : int <br>
provides the standard C function system(3). It executes cmd
in the user&rsquo;s shell environment, and returns the exit
status of the shell.</p>

<p style="margin-top: 1em">rand() : double <br>
returns a pseudo&acirc;random double between 0 and 1.</p>

<p style="margin-top: 1em">srand() : int</p>

<p style="margin-top: 1em">srand(v : int) : int <br>
sets a seed for the random number generator. The optional
argument gives the seed; if it is omitted, the current time
is used. The previous seed value is returned. srand <br>
should be called before any calls to rand.</p>

<p style="margin-top: 1em">colorx(color : string, fmt :
string) : string <br>
translates a color from one format to another. The color
argument should be a color in one of the recognized string
representations. The fmt value should be one of
&quot;RGB&quot;, <br>
&quot;RGBA&quot;, &quot;HSV&quot;, or &quot;HSVA&quot;. An
empty string is returned on error.</p>

<p style="margin-top: 1em">BUILT&acirc;IN VARIABLES <br>
gvpr provides certain special, built&acirc;in variables,
whose values are set automatically by gvpr depending on the
context. Except as noted, the user cannot modify their
values.</p>

<p style="margin-top: 1em">$ : obj_t <br>
denotes the current object (node, edge, graph) depending on
the context. It is not available in BEGIN or END
clauses.</p>

<p style="margin-top: 1em">$F : string <br>
is the name of the current input file.</p>

<p style="margin-top: 1em">$G : graph_t <br>
denotes the current graph being processed. It is not
available in BEGIN or END clauses.</p>

<p style="margin-top: 1em">$NG : graph_t <br>
denotes the next graph to be processed. If $NG is NULL, the
current graph $G is the last graph. Note that if the input
comes from stdin, the last graph cannot be deter&acirc; <br>
mined until the input pipe is closed. It is not available in
BEGIN or END clauses, or if the -n flag is used.</p>

<p style="margin-top: 1em">$O : graph_t <br>
denotes the output graph. Before graph traversal, it is
initialized to the target graph. After traversal and any
END_G actions, if it refers to a non&acirc;empty graph, that
<br>
graph is printed onto the output stream. It is only valid in
N, E and END_G clauses. The output graph may be set by the
user.</p>

<p style="margin-top: 1em">$T : graph_t <br>
denotes the current target graph. It is a subgraph of $G and
is available only in N, E and END_G clauses.</p>

<p style="margin-top: 1em">$tgtname : string <br>
denotes the name of the target graph. By default, it is set
to &quot;gvpr_result&quot;. If used multiple times during
the execution of gvpr, the name will be appended with an
<br>
integer. This variable may be set by the user.</p>

<p style="margin-top: 1em">$tvroot : node_t <br>
indicates the starting node for a (directed or undirected)
depth&acirc;first or breadth&acirc;first traversal of the
graph (cf. $tvtype below). The default value is NULL for
each <br>
input graph. After the traversal at the given root, if the
value of $tvroot has changed, a new traversal will begin
with the new value of $tvroot. Also, set $tvnext <br>
below.</p>

<p style="margin-top: 1em">$tvnext : node_t <br>
indicates the next starting node for a (directed or
undirected) depth&acirc;first or breadth&acirc;first
traversal of the graph (cf. $tvtype below). If a traversal
finishes and the <br>
$tvroot but the $tvnext has been set but not used, this node
will be used as the next choice for $tvroot. The default
value is NULL for each input graph.</p>

<p style="margin-top: 1em">$tvedge : edge_t <br>
For BFS and DFS traversals, this is set to the edge used to
arrive at the current node or edge. At the beginning of a
traversal, or for other traversal types, the value is <br>
NULL.</p>

<p style="margin-top: 1em">$tvtype : tvtype_t <br>
indicates how gvpr traverses a graph. It can only take one
of the constant values with the previx &quot;TV_&quot;
described below. TV_flat is the default.</p>

<p style="margin-top: 1em">In the underlying graph library
cgraph(3), edges in undirected graphs are given an arbitrary
direction. This is used for traversals, such as TV_fwd,
requiring directed <br>
edges.</p>

<p style="margin-top: 1em">ARGC : int <br>
denotes the number of arguments specified by the -a args
command&acirc;line argument.</p>

<p style="margin-top: 1em">ARGV : string array <br>
denotes the array of arguments specified by the -a args
command&acirc;line argument. The ith argument is given by
ARGV[i].</p>

<p style="margin-top: 1em">BUILT&acirc;IN CONSTANTS <br>
There are several symbolic constants defined by gvpr.</p>

<p style="margin-top: 1em">NULL : obj_t <br>
a null object reference, equivalent to 0.</p>

<p style="margin-top: 1em">TV_flat : tvtype_t <br>
a simple, flat traversal, with graph objects visited in
seemingly arbitrary order.</p>

<p style="margin-top: 1em">TV_ne : tvtype_t <br>
a traversal which first visits all of the nodes, then all of
the edges.</p>

<p style="margin-top: 1em">TV_en : tvtype_t <br>
a traversal which first visits all of the edges, then all of
the nodes.</p>

<p style="margin-top: 1em">TV_dfs : tvtype_t <br>
TV_postdfs : tvtype_t <br>
TV_prepostdfs : tvtype_t <br>
a traversal of the graph using a depth&acirc;first search on
the underlying undirected graph. To do the traversal, gvpr
will check the value of $tvroot. If this has the same <br>
value that it had previously (at the start, the previous
value is initialized to NULL.), gvpr will simply look for
some unvisited node and traverse its connected compo&acirc;
<br>
nent. On the other hand, if $tvroot has changed, its
connected component will be toured, assuming it has not been
previously visited or, if $tvroot is NULL, the traversal
<br>
will stop. Note that using TV_dfs and $tvroot, it is
possible to create an infinite loop.</p>

<p style="margin-top: 1em">By default, the traversal is
done in pre-order. That is, a node is visited before all of
its unvisited edges. For TV_postdfs, all of a node&rsquo;s
unvisited edges are visited <br>
before the node. For TV_prepostdfs, a node is visited twice,
before and after all of its unvisited edges.</p>

<p style="margin-top: 1em">TV_fwd : tvtype_t <br>
TV_postfwd : tvtype_t <br>
TV_prepostfwd : tvtype_t <br>
A traversal of the graph using a depth&acirc;first search on
the graph following only forward arcs. The choice of roots
for the traversal is the same as described for TV_dfs <br>
above. The different order of visitation specified by
TV_fwd, TV_postfwd and TV_prepostfwd are the same as those
specified by the analogous traversals TV_dfs, TV_postdfs
<br>
and TV_prepostdfs.</p>

<p style="margin-top: 1em">TV_rev : tvtype_t <br>
TV_postrev : tvtype_t <br>
TV_prepostrev : tvtype_t <br>
A traversal of the graph using a depth&acirc;first search on
the graph following only reverse arcs. The choice of roots
for the traversal is the same as described for TV_dfs <br>
above. The different order of visitation specified by
TV_rev, TV_postrev and TV_prepostrev are the same as those
specified by the analogous traversals TV_dfs, TV_postdfs
<br>
and TV_prepostdfs.</p>

<p style="margin-top: 1em">TV_bfs : tvtype_t <br>
A traversal of the graph using a breadth&acirc;first search
on the graph ignoring edge directions. See the item on
TV_dfs above for the role of $tvroot.</p>

<p style="margin-top: 1em">EXAMPLES <br>
gvpr -i &rsquo;N[color==&quot;blue&quot;]&rsquo; file.gv</p>

<p style="margin-top: 1em">Generate the node&acirc;induced
subgraph of all nodes with color blue.</p>

<p style="margin-top: 1em">gvpr -c
&rsquo;N[color==&quot;blue&quot;]{color =
&quot;red&quot;}&rsquo; file.gv</p>

<p style="margin-top: 1em">Make all blue nodes red.</p>

<p style="margin-top: 1em">BEGIN { int n, e; int tot_n = 0;
int tot_e = 0; } <br>
BEG_G { <br>
n = nNodes($G); <br>
e = nEdges($G); <br>
printf (&quot;%d nodes %d edges %s0, n, e, $G.name); <br>
tot_n += n; <br>
tot_e += e; <br>
} <br>
END { printf (&quot;%d nodes %d edges total0, tot_n, tot_e)
}</p>

<p style="margin-top: 1em">Version of the program gc.</p>

<p style="margin-top: 1em">gvpr -c &quot;&quot;</p>

<p style="margin-top: 1em">Equivalent to nop.</p>

<p style="margin-top: 1em">BEG_G { graph_t g = graph
(&quot;merge&quot;, &quot;S&quot;); } <br>
E { <br>
node_t h = clone(g,$.head); <br>
node_t t = clone(g,$.tail); <br>
edge_t e = edge(t,h,&quot;&quot;); <br>
e.weight = e.weight + 1; <br>
} <br>
END_G { $O = g; }</p>

<p style="margin-top: 1em">Produces a strict version of the
input graph, where the weight attribute of an edge indicates
how many edges from the input graph the edge represents.</p>

<p style="margin-top: 1em">BEGIN {node_t n; int deg[]} <br>
E{deg[head]++; deg[tail]++; } <br>
END_G { <br>
for (deg[n]) { <br>
printf (&quot;deg[%s] = %d0, n.name, deg[n]); <br>
} <br>
}</p>

<p style="margin-top: 1em">Computes the degrees of nodes
with edges.</p>

<p style="margin-top: 1em">BEGIN { <br>
int i, indent; <br>
int seen[string]; <br>
void prInd (int cnt) { <br>
for (i = 0; i &lt; cnt; i++) printf (&quot; &quot;); <br>
} <br>
} <br>
BEG_G {</p>

<p style="margin-top: 1em">$tvtype = TV_prepostfwd; <br>
$tvroot = node($,ARGV[0]); <br>
} <br>
N { <br>
if (seen[$.name]) indent--; <br>
else { <br>
prInd(indent); <br>
print ($.name); <br>
seen[$.name] = 1; <br>
indent++; <br>
} <br>
}</p>

<p style="margin-top: 1em">Prints the depth-first traversal
of the graph, starting with the node whose name is ARGV[0],
as an indented list.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
GVPRPATH <br>
Colon&acirc;separated list of directories to be searched to
find the file specified by the -f option. gvpr has a default
list built in. If GVPRPATH is not defined, the default <br>
list is used. If GVPRPATH starts with colon, the list is
formed by appending GVPRPATH to the default list. If
GVPRPATH ends with colon, the list is formed by appending
the <br>
default list to GVPRPATH. Otherwise, GVPRPATH is used for
the list.</p>

<p style="margin-top: 1em">On Windows systems, replace
&lsquo;&lsquo;colon&rsquo;&rsquo; with
&lsquo;&lsquo;semicolon&rsquo;&rsquo; in the previous
paragraph.</p>

<p style="margin-top: 1em">BUGS AND WARNINGS <br>
Scripts should be careful deleting nodes during N{} and E{}
blocks using BFS and DFS traversals as these rely on stacks
and queues of nodes.</p>

<p style="margin-top: 1em">When the program is given as a
command line argument, the usual shell interpretation takes
place, which may affect some of the special names in gvpr.
To avoid this, it is best to <br>
wrap the program in single quotes.</p>

<p style="margin-top: 1em">If string constants contain
pattern metacharacters that you want to escape to avoid
pattern matching, two backslashes will probably be
necessary, as a single backslash will be <br>
lost when the string is originally scanned. Usually, it is
simpler to use strcmp to avoid pattern matching.</p>

<p style="margin-top: 1em">As of 24 April 2008, gvpr
switched to using a new, underlying graph library, which
uses the simpler model that there is only one copy of a
node, not one copy for each subgraph <br>
logically containing it. This means that iterators such as
nxtnode cannot traverse a subgraph using just a node
argument. For this reason, subgraph traversal requires new
func&acirc; <br>
tions ending in &quot;_sg&quot;, which also take a subgraph
argument. The versions without that suffix will always
traverse the root graph.</p>

<p style="margin-top: 1em">There is a single global scope,
except for formal function parameters, and even these can
interfere with the type system. Also, the extent of all
variables is the entire life of <br>
the program. It might be preferable for scope to reflect the
natural nesting of the clauses, or for the program to at
least reset locally declared variables. For now, it is <br>
advisable to use distinct names for all variables.</p>

<p style="margin-top: 1em">If a function ends with a
complex statement, such as an IF statement, with each branch
doing a return, type checking may fail. Functions should use
a return at the end.</p>

<p style="margin-top: 1em">The expr library does not
support string values of (char*)0. This means we can&rsquo;t
distinguish between &quot;&quot; and (char*)0 edge keys. For
the purposes of looking up and creating <br>
edges, we translate &quot;&quot; to be (char*)0, since this
latter value is necessary in order to look up any edge with
a matching head and tail.</p>

<p style="margin-top: 1em">Related to this, strings
converted to integers act like char pointers, getting the
value 0 or 1 depending on whether the string consists solely
of zeroes or not. Thus, the <br>
((int)&quot;2&quot;) evaluates to 1.</p>

<p style="margin-top: 1em">The language inherits the usual
C problems such as dangling references and the confusion
between &rsquo;=&rsquo; and &rsquo;==&rsquo;.</p>

<p style="margin-top: 1em">AUTHOR <br>
Emden R. Gansner &lt;erg@research.att.com&gt;</p>

<p style="margin-top: 1em">SEE ALSO <br>
awk(1), gc(1), dot(1), nop(1), expr(3), cgraph(3)</p>

<p style="margin-top: 1em">4 May 2012 GVPR(1)</p>
<hr>
</body>
</html>
