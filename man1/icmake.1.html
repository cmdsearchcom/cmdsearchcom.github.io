<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:18:07 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>icmake(1) A program maintenance utility icmake(1)</p>

<p style="margin-top: 1em">NAME <br>
icmake - A program maintenance (make) utility using a C-like
grammar</p>

<p style="margin-top: 1em">SYNOPSIS <br>
icmake [options] source[.im] [dest[.bim]] [-- [args]]</p>

<p style="margin-top: 1em">icmun bimfile</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Icmake(1) was designed as a generic tool that can be used as
an alternative to make(1), handling program maintenance.
It&acirc;s a generic tool in that icmake-scripts, written in
a <br>
language closely resembling the C programming language, can
perform tasks that are traditionally the domain of scripting
languages.</p>

<p style="margin-top: 1em">Icmake allows programmers to use
a programming language (closely resembling the well-known
C-programming language) to define the actions that are
required for (complex) program <br>
maintenance. For this, icmake offers various special
operators as well as a set of support functions that have
shown their usefulness in program maintenance.</p>

<p style="margin-top: 1em">Although icmake-scripts can be
written from scratch for handling program maintenance, often
the required activities are highly comparable. This
observation resulted in the con&acirc; <br>
struction of two icmake-scripts: icmstart(1), initializing a
directory for program development and icmbuild(1), handling
the actual program maintenance. Both come predefined as <br>
scripts tailored to initializing and maintaining C++
programs (or, after minimal adaptation, C programs), but can
easily be adapted to other programming languages. Both
icmstart <br>
and icmbuild can be run without explicitly calling
icmake.</p>

<p style="margin-top: 1em">This man-page covers icmake (the
program), its support programs and the syntax and facilities
offered by icmake&acirc;s scripting language. Refer to the
icmstart(1)) man-page for <br>
information about how a directory can be initialized
(created) in which (by default) a C++ or C program can be
developed and refer to the icmbuild(1) man-page for
information <br>
about how icmbuild can be used to handle program
maintenance.</p>

<p style="margin-top: 1em">It should be stressed that
icmake and its support programs and scripts do not offer an
Integrated Development Environment (IDE). It merely performs
tasks for which scripts can be <br>
written, and it offers just a few pre-defined scripts
(icmstart and icmbuild) that repeatedly have shown to be
extremely useful when developing and maintaining
programs.</p>

<p style="margin-top: 1em">In its standard operation mode,
icmake calls the following programs:</p>

<p style="margin-top: 1em">o icm-pp to preprocess the
icmake file</p>

<p style="margin-top: 1em">o icm-comp to byte-code compile
the icmake s</p>

<p style="margin-top: 1em">o icm-dep to handle
class-dependencies (see section ICM-DEP in
icmbuild(1)&acirc;s man-page for more information about
icm-dep).</p>

<p style="margin-top: 1em">o icm-exec to execute the
byte-code file</p>

<p style="margin-top: 1em">The program icmun(1) can be used
to disassemble the compiled byte-code (.bim) file. Icmun is
mainly used for illustration, education, and debugging. As
it is not required for <br>
icmake&acirc;s daily use it is not installed in a standard
PATH directory but (since icmake&acirc;s version 9.02.00) in
icmake&acirc;s lib directory, commonly /usr/lib/icmake.</p>

<p style="margin-top: 1em">Traditional make-utilities
recompile sources once header files are modified. When
developing C++ programs this is often a bad idea, as adding
a new member to a class does not <br>
normally require you to recompile all of the class&acirc;s
source files. To handle class dependencies icmbuld(1) may
inspect class dependencies, (re)compiling sources of
dependent <br>
classes whenever necessary. By default, class-dependencies
are not interpreted, but this can easily be changed by
activating the PRECOMP and/or USE_ALL defines in icmconf.
Refer <br>
to the icmconf(7) man-page for further details.</p>

<p style="margin-top: 1em">Precompiled header files can
also easily be used. Precompiled header files dramatically
reduce the time that is required for compiling
classes&acirc; source files. Refer to the icm&acirc; <br>
conf(7) man-page (in particular the description of the
PRECOMP define) for further details.</p>

<p style="margin-top: 1em">Icmake&acirc;s C-like scripting
language is described in the upcoming sections of this
man-page:</p>

<p style="margin-top: 1em">o PREPROCESSOR DIRECTIVES <br>
- supported preprocessor directives, like #include and
#define;</p>

<p style="margin-top: 1em">o DATA TYPES <br>
- int, list, string, and void (for functions);</p>

<p style="margin-top: 1em">o PREDEFINED CONSTANTS <br>
- like O_FILE, OFF, and S_IFREG;</p>

<p style="margin-top: 1em">o OPERATORS <br>
- like +, younger, and casts</p>

<p style="margin-top: 1em">o FLOW CONTROL <br>
- if, for, while, etc. (the switch is not available);</p>

<p style="margin-top: 1em">o PREDEFINED FUNCTIONS <br>
- executing programs, changing directories, operations on
string and list type variables, etc.;</p>

<p style="margin-top: 1em">o USER DEFINED FUNCTIONS <br>
- at least main, with or without its common parameters argc,
argv, and envp.</p>

<p style="margin-top: 1em">OPTIONS <br>
Where available, single letter options are listed between
parentheses beyond their associated long-option
variants.</p>

<p style="margin-top: 1em">The -- option is special:</p>

<p style="margin-top: 1em">o --: icmake arguments separator
separating icmake arguments from arguments passed to the
.bim filenl(). Those arguments are passed to the .bim file
as-is, and are available <br>
from the list argv parameter available from the icmake
script&acirc;s main function&acirc;s second parameter (see
below at section USER DEFINED FUNCTIONS). For some options
(see <br>
below) the -- separator is not required.</p>

<p style="margin-top: 1em">Icmake supports various options,
and only one of these can be specified when icmake is
invocated.</p>

<p style="margin-top: 1em">o --about (-a) <br>
Show information about icmake and terminate.</p>

<p style="margin-top: 1em">o --compile (-c) <br>
The icmake source file is compiled, generating a .bim
file.</p>

<p style="margin-top: 1em">o --execute (-e) <br>
Execute the icmake .bim file, given as icmake&acirc;s first
file argument. Any additional arguments are passed to the
.bim file as-is, and -- should not be specified.</p>

<p style="margin-top: 1em">o --force (-f) <br>
The icmake source file is recompiled (even if the .bim file
is up-to-date) either when no other options are specified,
or when in combination with options --source and <br>
--tmpbin.</p>

<p style="margin-top: 1em">o --help (-h) <br>
Provide usage info and terminate.</p>

<p style="margin-top: 1em">o --icm-dep (-d) <br>
Calls /usr/lib/icmake/icm-dep, passing it all remaining
arguments. If no additional arguments are specified
icm-dep&acirc;s short usage information is shown to the std.
output <br>
stream. See section ICM-DEP in icbuild(1)&acirc;s man-page
for more information about the icm-dep support program. An
overview of icm-dep&acirc;s option follows below, next to
this <br>
overview of icmake&acirc;s options.</p>

<p style="margin-top: 1em">o --preprocess (-p) <br>
The icmake source file is only preprocessed, and the
preprocessed file is written to icmake&acirc;s second file
argument (by default &lsquo;source&acirc;.pim).</p>

<p style="margin-top: 1em">o --source (-i) <br>
The first argument is the icmake source file, the default
binary file is constructed if necessary. Any additional
arguments are passed to the .bim file as-is, and -- <br>
should not be specified.</p>

<p style="margin-top: 1em">o --summary (-F) <br>
The filenames and flags as well as an overview of all
actions to be performed by icmake are shown on the standard
output stream.</p>

<p style="margin-top: 1em">o -t tmpbim <br>
The tmpbim argument following -t is the name of a temporary
.bim file, which is removed after icmake&acirc;s call. When
. is specified for tmpbim then the default temporary <br>
directory, followed by icmake&acirc;s process-id, followed
by .bim is used.</p>

<p style="margin-top: 1em">Following the name of the
temporary .bim file the name of the icmake source script
must be specified. Any additional arguments are passed to
the .bim file as-is, and -- <br>
should not be specified; After setting the source script
file&acirc;s executable flag (chmod +x script), and
providing it with an initial line like this:</p>

<p style="margin-top: 1em">#!/usr/bin/icmake -t.</p>

<p style="margin-top: 1em">the icmake script can directly
be called:</p>

<p style="margin-top: 1em">script arg1 arg2</p>

<p style="margin-top: 1em">in which case the icmake script
&lsquo;script&acirc; is executed while it receives the
arguments script arg1 arg2.</p>

<p style="margin-top: 1em">o -T directory <br>
The specified directory is used to store temporary files.
E.g., when compiling an icmake script, the output of
icmake&acirc;s preprocessor is a temporary file which is
removed <br>
on exit. By default /tmp is used, unless /tmp is not a
writable directory, in which case the current user&acirc;s
$HOME directory is used. Implicit temporary filenames always
<br>
start with the process id of the current icmake process.</p>

<p style="margin-top: 1em">o --version (-v) <br>
Displays icmake&acirc;s version number, and terminates.</p>

<p style="margin-top: 1em">Icmun:</p>

<p style="margin-top: 1em">bimfile: binary icmake script
file.</p>

<p style="margin-top: 1em">ICM-DEP invocation and options
<br>
To start its work, the dependencies-analyzer icm_dep needs
one command-line argument: go. Any other argument results in
icm_dep performing a &lsquo;dry run&acirc;: it will perform
all its <br>
duties (and verbose messages are displayed as if go had been
specified), but no files (precompiled headers or USE_ALL
files) will be touched or removed. If neither options nor
<br>
arguments are specified icm_dep writes its usage summary to
the standard output.</p>

<p style="margin-top: 1em">Options of icm-dep can be
specified immediately following icmake&acirc;s --icm-dep
option. The following options are recognized by icm-dep:</p>

<p style="margin-top: 1em">o --classes=filename (-c) <br>
By default, icm-dep inspects dependencies of the classes
whose directories are mentioned in the file CLASSES. If
specified in the icmconf(7) file, it will also consider <br>
dependencies of the classes Parser (directory parser) and
Scanner (directory scanner), or it uses their actual names
as defined in the icmconf(7) file. Use this option if <br>
instead of CLASSES another file should be inspected.</p>

<p style="margin-top: 1em">o --help (-h) <br>
Icm-dep writes a summary of its usage to the standard output
and terminates.</p>

<p style="margin-top: 1em">o --icmconf=filename (-i) <br>
By default icm-dep inspects the contents of an icmconf file,
looking for the USE_ALL and PRECOMP specifications. Use this
option if instead of icmconf another file should <br>
be inspected.</p>

<p style="margin-top: 1em">o --mainih=mainheader (-m) <br>
The icmconf file uses the #define IH parameter to specify
the suffix of class header files that should be precompiled,
their filenames being equal to the names of the <br>
classes mentioned in the CLASSES file. CLASSES does not
specify a top-level directory. The name of the top-level
header file to precompile can be specified using this <br>
option. By default it is main.ih.</p>

<p style="margin-top: 1em">o --gch <br>
By default precompiled header files are inspected if icmconf
contains a #define PRECOMP specification. If it does not,
but precompiled headers should nonetheless be <br>
inspected, the option --gch can be specified.</p>

<p style="margin-top: 1em">o --no-gch <br>
By default precompiled header files are inspected if icmconf
contains a #define PRECOMP specification. If so, but
precompiled headers should not be inspected, the option <br>
--no-gch can be specified.</p>

<p style="margin-top: 1em">o --no-use-all <br>
By default files named at the #define USE_ALL specification
are inspected if icmconf contains such a specification. If
it does, but the &lsquo;USE_ALL&acirc; files should not be
<br>
inspected, this option can be specified.</p>

<p style="margin-top: 1em">o --use-all=filename <br>
By default files named at the #define USE_ALL specification
are inspected if icmconf contains such a specification. If
it does not, but &lsquo;USE_ALL&acirc; files should
nonetheless <br>
be inspected, this option can be specified, together with
the name of files (existing in one or more directories that
indicate that all the directory&acirc;s source files must
<br>
be recompiled).</p>

<p style="margin-top: 1em">o --verbose (-V) <br>
This option can be specified multiple times. The number of
times it is specified defines icm_dep&acirc;s verbosity. If
none is specified, icm_dep silently performs its duties.
<br>
If specified once, then icm_dep reports to the standard
output what actions it performs; if specified twice it
reports the options it encountered; if specified three times
<br>
it also reports the class dependencies; if specified more
often it reports what files it encountered and what
situations caused it to make its decisions.</p>

<p style="margin-top: 1em">o --version (-v) <br>
Icm_dep reports its version number to the standard output
and terminates.</p>

<p style="margin-top: 1em">PREPROCESSOR DIRECTIVES <br>
The following preprocessor directives are available:</p>

<p style="margin-top: 1em">o comment: <br>
standard C comment (all between /* and */) as well as
comment-to-end-of-line (all line contents following //) are
ignored.</p>

<p style="margin-top: 1em">o Shell startup: The first line
of the icmake-script may start with #!path, where path
defines the absolute location of the icmake program. By
making the script executable, <br>
it can be called without explicitly calling icmake.</p>

<p style="margin-top: 1em">E.g., if the first line of an
(executable) icmakefile &acirc;icm&acirc; (without
extension) contains</p>

<p style="margin-top: 1em">#!/usr/bin/icmake -i</p>

<p style="margin-top: 1em">then icm may be issued as a
command, thus executing</p>

<p style="margin-top: 1em">/usr/bin/icmake -i icm ...</p>

<p style="margin-top: 1em">Alternatively,</p>

<p style="margin-top: 1em">#!/usr/bin/icmake -t
/tmp/icm</p>

<p style="margin-top: 1em">may be used, resulting in the
execution of</p>

<p style="margin-top: 1em">#!/usr/bin/icmake -t /tmp/icm
icm ...</p>

<p style="margin-top: 1em">In this case the binary file is
removed on exit.</p>

<p style="margin-top: 1em">o #include &quot;filename&quot;
<br>
The file filename is included at the location of the
directive</p>

<p style="margin-top: 1em">o #include &lt;filename&gt; <br>
The file filename is included at the location of the
#include directive; filename is searched in the
colon-separated directories specified by the IM environment
variable. <br>
The first occurrence of filename in the directories
specified by the IM environment variable is used.</p>

<p style="margin-top: 1em">o #define identifier
[definition] <br>
The text identifier will be replaced by definition. The
definition may contain references to already defined
identifiers, using the ${identifier} format. If the
${identi&acirc; <br>
fier} hasn&acirc;t been defined (yet), the text
${identifier} is literally kept. To prevent infinite
recursion at most 100 ${identifier} replacements are
allowed.</p>

<p style="margin-top: 1em">Definitions continue at the next
line if the last character on a line is a backslash (.
(which is not included in the definition). The preprocessor
concatenates dou&acirc; <br>
ble-quuted strings, and double quoted strings may not span
multiple lines. Multiple blanks (outside of double quoted
strings) in definitions are contracted to a single <br>
blank space.</p>

<p style="margin-top: 1em">The definition following the
#define&acirc;s identifier is optional. If omitted, the
macro is defined, so it can be used in #if(n)def directives
(see below), but they are not <br>
replaced by any text in icmake code statements.</p>

<p style="margin-top: 1em">o #ifdef identifier <br>
If the identifier macro was defined the next block of code
(until a matching #else or #endif directive was read) is
byte-compiled. Otherwise, the block of code is ignored.</p>

<p style="margin-top: 1em">o #ifndef identifier <br>
If the identifier macro was not defined the next block of
code (until a matching #else or #endif directive was
detected) is byte-compiled. Otherwise, the block of code is
<br>
ignored.</p>

<p style="margin-top: 1em">o #else <br>
Terminates a #ifdef and #ifndef directive, reversing the
acceptance decision about the following code. Only one #else
directive can be associated with #if(n)def direc&acirc; <br>
tives.</p>

<p style="margin-top: 1em">o #endif <br>
Terminates the preprocessor block starting at the matching
#ifdef, #ifndef or #else directive. The #endif directory and
its matching #if(n)def directive must be specified <br>
in the same file.</p>

<p style="margin-top: 1em">o #undef identifier <br>
Remove identifier from the set of defined symbols. This does
not affect the specification of any previously defined
symbols in which identifier&acirc;s definition has been
used. <br>
If identifier hasn&acirc;t been defined a warning is
issued.</p>

<p style="margin-top: 1em">DATA TYPES <br>
Icmake supports these data types:</p>

<p style="margin-top: 1em">o ASCII character constants <br>
ASCII character constants consist of one character,
surrounded by single or double quotes. Single characters
(e.g., &acirc;a&acirc;) represent the character itself.
Standard escape <br>
sequences (e.g., &acirc;0) are supported and represent their
standard converted value (e.g., &acirc;0 represents ascii
value 10 (decimal)). Non-standard escape sequences (e.g.,
<br>
&acirc; represent the ascii character following the escape
character (so &acirc;quals &acirc;x&acirc;). Escape
sequences consisting of three octal digits represent the
ascii character <br>
corresponding to the octal value modulo 256 (e.g.,
&acirc;123&acirc;). Escape sequences consisting of an x
followed by two hexadecimal digits represent the ascii
character corre&acirc; <br>
sponding to the hexadecimal value (e.g., &acirc;).</p>

<p style="margin-top: 1em">o int <br>
Integral values, ranging from -0x8000 through 0x7fff. int
constants may be specified as decimal numbers (starting with
digits 1 through 9), octal numbers (starting with 0, <br>
followed by one or more octal digits) hexadecimal numbers
(starting with 0x, followed by one or more hexadecimal
digits) or as ASCII character constants.</p>

<p style="margin-top: 1em">o string <br>
Text variables. String constants are delimited by double
quotes. Multiple string constants may be concatenated, but a
single string constant may not span multiple lines. <br>
String constants separated by white space only (i.e.,
blanks, newlines, comment) are concatenated and represent
one single string constant. To indicate an end-of-line in a
<br>
string constant use the escape sequence.</p>

<p style="margin-top: 1em">ASCII character constants
surrounded by double quotes can also be used in arithmetic
expressions if one of the operands is an int. The single
character string constant <br>
must be a constant, and cannot be a string variable.</p>

<p style="margin-top: 1em">Likewise, ASCII character
constants surrounded by single quotes may be used in
situations where a string operand is expected.</p>

<p style="margin-top: 1em">o list <br>
A data structure containing a series of individually
accessible string values. When a list contains elements, its
first element is indicated by index 0.</p>

<p style="margin-top: 1em">o void <br>
Used with function definitions to indicate that the function
does not return a value.</p>

<p style="margin-top: 1em">Variables can be defined at the
global level as well as at any local level inside functions.
When defined inside functions, the standard C scoping and
visibility rules apply. <br>
E.g., local variables can only be used in their own or in
more deeply nested blocks, their visibility is masked in
more deeply nested blocks by defining an identically named
<br>
variable inside those more deeply nested blocks. Variables
are strongly typed, and cannot have type void.</p>

<p style="margin-top: 1em">Variables may be initialized
when they are defined. Initializations are expressions, that
can use pre- or user-defined functions, constant values, and
values of variables that <br>
are visible at the point of definition.</p>

<p style="margin-top: 1em">PREDEFINED CONSTANTS <br>
The following constants are predefined by icmake. All are
constant int values:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
symbol value intended for <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
O_ALL 8 makelist <br>
O_DIR 2 makelist <br>
O_FILE 1 makelist <br>
O_SUBDIR 4 makelist <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
OFF 0 echo <br>
ON 1 echo <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
P_CHECK 0 system calls <br>
P_NOCHECK 1 system calls <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
S_IEXEC 32 stat <br>
S_IFCHR 1 stat <br>
S_IFDIR 2 stat <br>
S_IFREG 4 stat <br>
S_IREAD 8 stat <br>
S_IWRITE 16 stat <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">The following constants are
architecture dependent:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
symbol 1 when defined on the platform, otherwise 0 <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">unix Unix, usually with
GNU&acirc;s gcc compiler <br>
UNIX may alternatively be available <br>
linux x86 running Linux (usually with gcc) <br>
LINUX may alternatively be available <br>
M_SYSV, M_UNIX x86 running SCO/Unix <br>
_POSIX _SOURCE Unix with Posix compliant compiler <br>
__hpux HP-UX, with the native HP compiler <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">OPERATORS <br>
int-typed operand(s):</p>

<p style="margin-top: 1em">All C operators are available
(except for pointer operators, as icmake does not support
pointers). They operate like their C-programming language
counterparts.</p>

<p style="margin-top: 1em">string-typed operand(s):</p>

<p style="margin-top: 1em">For string type variables and/or
constants the following operators are available (a and b
represent string variables or constants):</p>

<p style="margin-top: 1em">o a + b: returns a new string
value containing the concatenation of string values a and b.
Note that string constants may be directly concatetated
(without using the + oper&acirc; <br>
ator), e.g., the following two lines both define the string
&quot;hello world&quot;:</p>

<p style="margin-top: 1em">&quot;hello &quot;
&quot;world&quot; <br>
&quot;hello &quot; + &quot;world&quot;</p>

<p style="margin-top: 1em">o a += b: a must be a string
variable, to which the string variable or value b is
appended.</p>

<p style="margin-top: 1em">o string comparisons: operators
== != &lt;= &gt;= &lt; &gt; != and == may be applied to
string values or variables, returning 1 if the comparison
succeeds, otherwise 0. Comparison is <br>
case sensitively, and follows the ordering or characters as
defined in the ASCII character set.</p>

<p style="margin-top: 1em">o !a: the boolean ! (not)
operator returns 1 if the string a is empty, otherwise 0 is
returned.</p>

<p style="margin-top: 1em">o a younger b, a newer b:
returns 1 if file a is more recent than file b. E.g.,
&quot;source.cc&quot; newer &quot;source.o&quot;. The files
a and b do not have to exist: if both don&acirc;t exist 0
<br>
is returned; if b doesn&acirc;t exist, 1 is returned; if a
doesn&acirc;t exist 0 is returned; if they are equally old 0
is returned. (the exists() predefined function (see below,
sec&acirc; <br>
tion PREDEFINED FUNCTIONS) can be used to test explicitly
whether a file exists).</p>

<p style="margin-top: 1em">o a older b: turns 1 if file a
is older than file b. E.g., &quot;libprog.a&quot; older
&quot;source.o&quot;. The files a and b do not have to
exist: if both don&acirc;t exist 0 is returned; if a <br>
doesn&acirc;t exist, 1 is returned; if b doesn&acirc;t exist
0 is returned; if they are equally old 0 is returned.</p>

<p style="margin-top: 1em">o []: the index operator
retrieves a character from a string variable or constant: it
returns a string as an rvalue. Therefore, the following
statement compiles OK:</p>

<p style="margin-top: 1em">// assume str1 and str2 are
strings <br>
str1 = str2[3];</p>

<p style="margin-top: 1em">but the following statement
won&acirc;t compile:</p>

<p style="margin-top: 1em">str2[3] = &quot;a&quot;;</p>

<p style="margin-top: 1em">An empty string is returned if
an invalid index value is provided.</p>

<p style="margin-top: 1em">o The &lsquo;backtick&lsquo;
operator (&lsquo;string cmd&lsquo;) <br>
A string placed between two backticks is executed by the
popen(3) function. The standard output gererated by the
command that is stored in the string argument is returned
<br>
as a list. An empty list indicates that the command could
not be executed. A command that could be executed but did
not produce any output returns a list containing one <br>
empty element. The command&acirc;s standard error stream
output is not collected by the backtick operator. However,
standard shell redirection could be used to collect the
stan&acirc; <br>
dard error stream&acirc;s output. Example:</p>


<p style="margin-top: 1em">printf(&lsquo;&quot;ls&quot;&lsquo;);
// prints the elements in <br>
// the current directory</p>

<p style="margin-top: 1em">The predefined function
eval(string cmd) behaves exactly like the backtick operator:
they are synonyms.</p>

<p style="margin-top: 1em">list-typed operand(s):</p>

<p style="margin-top: 1em">For list type variables and/or
values the following operators are available:</p>

<p style="margin-top: 1em">o a + b: returns a new list
value containing the concatenation of list values a and b.
This is not a set operation: if an element appears both in a
and in b, they will <br>
appear twice in the resulting list (set-addition is provided
by the built-in function listunion).</p>

<p style="margin-top: 1em">o a - b: returns a new list
value containing the elements in a that are not present in
b. This is a set-difference operation: the returned list
contains all elements in a <br>
that are not elements of b.</p>

<p style="margin-top: 1em">o a += b: elements in b are
added to the elements in a, which must be a list variable.
This is not a set operation.</p>

<p style="margin-top: 1em">o a -= b: elements in b are
removed from the elements in a, which must be a list
variable. This is a set operation: all elements of a that
are found in b are removed from <br>
a.</p>

<p style="margin-top: 1em">o list equality comparisons:
operators != and == may be applied to list values or
variables. Operator == returns 1 if both lists have
element-by-element identical elements, <br>
otherwise 0 is returned. Operator != reverses the result of
==.</p>

<p style="margin-top: 1em">o !a: the boolean ! operator
returns 1 if the list a is empty, otherwise 0 is
returned.</p>

<p style="margin-top: 1em">o []: the index operator
retrieves a list element from a list variable: it returns a
string as an rvalue. Therefore, the following statement
compiles OK:</p>

<p style="margin-top: 1em">// assume lst is a list, str is
a string <br>
str = lst[3];</p>

<p style="margin-top: 1em">but the following statement
won&acirc;t compile:</p>

<p style="margin-top: 1em">lst[3] = str;</p>

<p style="margin-top: 1em">An empty string is returned if
an invalid index value is provided.</p>

<p style="margin-top: 1em">Casting:</p>

<p style="margin-top: 1em">Type-casts may be performed
using the standard C cast-operator to cast:</p>

<p style="margin-top: 1em">o Strings to ints and vice versa
((int)&quot;123&quot;, (string)55)</p>

<p style="margin-top: 1em">o Strings to lists (list lst =
(list)&quot;hello&quot;)</p>

<p style="margin-top: 1em">FLOW CONTROL <br>
Icmake offers the following subset of C&acirc;s statements.
They can be used as in the C programming language.</p>

<p style="margin-top: 1em">o expression ; <br>
The plain expression statement;</p>

<p style="margin-top: 1em">o The compound statement <br>
Variables of any type may be defined and initialized
anywhere inside any compound statement. The visibility of a
variable starts at its point of definition.</p>

<p style="margin-top: 1em">o if (condition) statement <br>
Inside the condition a variable may be defined and
initialized. E.g,</p>

<p style="margin-top: 1em">if (string str = getText()) <br>
process(str);</p>

<p style="margin-top: 1em">In this example, process is not
called if getText() returns an empty string. The variable
str does not exist either before or after the if
statement.</p>

<p style="margin-top: 1em">o if (condition) statement else
statement <br>
As with the previous statement, inside the condition a
variable may be defined and initialized.</p>

<p style="margin-top: 1em">o for (init; condition;
increment) statement <br>
Variables (of a single type) may be initialized (and
optionally be defined) in the init section. The init,
condition and increment sections may remain empty. The empty
<br>
condition section is interpreted as &lsquo;always
true&acirc;.</p>

<p style="margin-top: 1em">o while (condition) statement
<br>
Inside the condition a variable may be defined and
initialized. <br>
A complementary do ... while() statement is not available.
Note that defining a variable, using an initialization
expression means that the initialization expressing is <br>
executed at each iteration of the while statement. So the
following statement will never end, and will display a never
ending stream of values 10:</p>

<p style="margin-top: 1em">while (int x = 10) <br>
printf(x--, &quot;0);</p>

<p style="margin-top: 1em">o return;, and return
expression; <br>
Plain return statements can be used in void functions, and
return expression statements are used in other type of
functions. The function main has return type void and so
<br>
in main only plain return statements can be used. By default
an icmake script&acirc;s exit value equals 0. Use the
built-in function exit (see below) to specify any other exit
<br>
value.</p>

<p style="margin-top: 1em">Be advised: the behavior of
non-void functions not returning values is undefined.</p>

<p style="margin-top: 1em">o break <br>
Leaves for and while statements, overruling the
statement&acirc;s condition.</p>

<p style="margin-top: 1em">o continue <br>
Continues with the next iteration of a for or while
statement.</p>

<p style="margin-top: 1em">o exit(expression) <br>
Ends the execution of an icmake-script. The expression must
evaluate to an int value, which becomes the script&acirc;s
exit value.</p>

<p style="margin-top: 1em">PREDEFINED FUNCTIONS <br>
Icmake offers the following predefined functions, which can
be used anywhere in icmake scripts. The following overview
is ordered alphabetically by function name.</p>

<p style="margin-top: 1em">o void arghead(string h) <br>
Helper function of exec() (see also below at exec()):
defines the &lsquo;argument head&acirc;, to be used with
exec(). By default, the &lsquo;argument head&acirc; is an
empty string.</p>

<p style="margin-top: 1em">o void argtail (string t) <br>
Helper function of exec() (see also below at exec()):
defines the &lsquo;argument tail&acirc;, to be used with
exec(). By default, the &lsquo;argument tail&acirc; is an
empty string.</p>

<p style="margin-top: 1em">o int ascii(string s) <br>
Returns the first character of s as an int; e.g.,
ascii(&quot;A&quot;) returns 65;</p>

<p style="margin-top: 1em">o string ascii(int i) <br>
Returns i as a string, e.g., ascii(65) returns the string
&quot;A&quot;;</p>

<p style="margin-top: 1em">o string change_base(string
file, string newbase) <br>
Changes the basename of file, returns the changed name. E.g,
change_base(&quot;/path/demo.im&quot;, &quot;out&quot;)
returns &quot;/path/out.im&quot;;</p>

<p style="margin-top: 1em">o string change_ext(string file,
string newext) <br>
Changes the extension of file, returns the changed name.
E.g, rss_changeExt(&quot;source.cc&quot;, &quot;o&quot;)
returns &quot;source.o&quot;;</p>

<p style="margin-top: 1em">o string change_path(string
file, string newpath) <br>
Changes the path specification of file, returns the changed
name. E.g, change_path(&quot;tmp/binary&quot;,
&quot;/usr/bin&quot;) returns &quot;/usr/bin/binary&quot;.
Note that the /-separator is <br>
inserted if required.</p>

<p style="margin-top: 1em">o string chdir(string newdir)
<br>
Changes the script&acirc;s working directory, returns the
previous dir as an absolute path.</p>

<p style="margin-top: 1em">Use chdir(&quot;.&quot;) to
obtain the current working directory, chdir(&quot;&quot;)
may be used to obtain the startup working directory (this
functionality was broken in releases before <br>
than 7.00, but is now operational). The function terminates
the icmake-script if the specified newdir does not
exist.</p>

<p style="margin-top: 1em">o string chdir(int checking,
string newdir) <br>
Same functionality as the previous function, but by
specifying checking as P_NOCHECK. the function won&acirc;t
terminate the script. Rather, it will return the
script&acirc;s current <br>
working directory.</p>

<p style="margin-top: 1em">o cmdhead(string h) <br>
Helper function of exec() (see also below at exec()):
Defines a &lsquo;command head&acirc;, to be used with
exec(). By default, the &lsquo;command head&acirc; is an
empty string.</p>

<p style="margin-top: 1em">o cmdtail(string t) <br>
Helper function of exec() (see also below at exec()):
Defines a &lsquo;command tail&acirc;, to be used with
exec(). By default, the &lsquo;command tail&acirc; is an
empty string.</p>

<p style="margin-top: 1em">o echo(int opt) <br>
Controls echoing of called programs (and their arguments),
specify OFF if echoing is not requested. By default echo(ON)
is used.</p>

<p style="margin-top: 1em">o string element(int index, list
(or string) var) <br>
Acts identical to the index operator: refer to the index
([]) operator in the section OPERATORS.</p>

<p style="margin-top: 1em">o list eval(string str) <br>
This function acts identically to the backtick operator. The
example provided with the backtick operator could therefore
also have been written like this:</p>

<p style="margin-top: 1em">printf(eval(&quot;ls&quot;)); //
prints the elements in the current <br>
// directory</p>

<p style="margin-top: 1em">o exec(string cmd, ...) <br>
Executes command with arguments. Each argument will be
prefixed by arghead()&acirc;s argument and postfixed by
argtail()&acirc;s argument. Note that no blanks are inserted
between <br>
arghead()&acirc;s contents, the argument proper, and
argtail()&acirc;s argument. All thus modified arguments are
concatenated, this time separated by single blanks, and then
cmd&acirc; <br>
head()&acirc;s contents are inserted between the command and
the first argument (on either side delimited by single
blanks) and cmdtail()&acirc;s contents are appended to the
argu&acirc; <br>
ments (again, separated by a single blank). PATH is searched
to locate cmd. 0 is returned.</p>

<p style="margin-top: 1em">o exec(int checkcmd, string cmd,
...) <br>
Same functionality as the previous function, but by
specifying checking as NOT_CHECKED the function won&acirc;t
terminate the script. Rather, it will return the called
command&acirc;s <br>
exit status, or 0x7f00 if the command wasn&acirc;t
found.</p>

<p style="margin-top: 1em">o execute(string cmd, string
cmdhd, string arghd, ..., string argtl, string cmdtl) <br>
Same as exec(), but command head/tail and argument head/tail
must be specified.</p>

<p style="margin-top: 1em">The actually executed command
starts with cmd, followed by cmdhd. Next is a series of
arguments follows, each enclosed by arghd and argtl. The
command terminates with <br>
cmdtl. 0 is returned</p>

<p style="margin-top: 1em">o execute(int checking, string
cmd, string cmdhd, string arghd, ..., string argtl, string
cmdtl) <br>
Same functionality as the previous function, but by
specifying checking as NOT_CHECKED the function won&acirc;t
terminate the script. Rather, it will return the called
command&acirc;s <br>
exit status, or 0x7f00 if the command wasn&acirc;t
found.</p>

<p style="margin-top: 1em">o int exists(string file) <br>
Returns a non-zero value if file exists, otherwise 0 is
returned.</p>

<p style="margin-top: 1em">o list fgets(string file, list
offset) <br>
NOTE: in icmake version 8.00.00 the prototype of this
function was changed from list fgets(string file, int
offset) to list fgets(string file, list offset).</p>

<p style="margin-top: 1em">The next line found at the
offset contained in offset is read from file. Pass an empty
list to fgets to read file from its beginning.</p>

<p style="margin-top: 1em">It returns a list containing as
its first element the contents of the read line (without the
line terminator), as its second element the line&acirc;s
terminator &lsquo;0 (if <br>
encountered), and as its third element the string OK if a
line was successfully read, FAIL if reading from file
failed. When reading at EOF an empty list is returned. The
<br>
returned list may contain additional elements, which are
internally used by fgets when reading the next line.</p>

<p style="margin-top: 1em">To read multiple lines, start by
passing an empty list as gets&acirc;s second argument. To
read subsequent lines, pass the previously returned list to
fgets&acirc;s second argument.</p>

<p style="margin-top: 1em">Here is an example showing how
to read a complete file:</p>

<p style="margin-top: 1em">list ret; <br>
while (1) <br>
{ <br>
ret = fgets(&quot;filename&quot;, ret); <br>
if (!ret) <br>
break; <br>
process(ret[0], ret[1]); <br>
}</p>

<p style="margin-top: 1em">o int fprintf(string filename,
...) <br>
Appends all (comma separated) arguments to the file
filename. Returns the number of printed arguments.</p>

<p style="margin-top: 1em">o int fprintf(string filename,
string format, ...) <br>
Appends all (comma separated) arguments to the file
filename. Returns the number of printed arguments.</p>

<p style="margin-top: 1em">If format contains placeholders
%1 .. %n the output is formatted (see also strformat). Note
that in this case argument counting (also) starts beyond the
format string: the <br>
first argument following format is referred to as %1.</p>

<p style="margin-top: 1em">o string get_base(string file)
<br>
Returns the base name of file. The base name is the file
without its path prefix and without its extension. The
extension is all information starting at the final dot in
<br>
the filename. If no final dot is found, the file name is the
base name. E.g., the base name of a.b equals a, the base
name of a.b.c equals a.b, the base name of a/b/c <br>
equals c.</p>

<p style="margin-top: 1em">o string getch() <br>
Returns the next pressed key as a string (pressing
&lsquo;Enter&acirc; is not required).</p>

<p style="margin-top: 1em">o string get_dext(string file)
<br>
Returns the extension of file, including the separating dot.
The extension is all information starting at the
filename&acirc;s final dot.</p>

<p style="margin-top: 1em">If no final dot is found, an
empty string is returned.</p>

<p style="margin-top: 1em">o list getenv(string envvar)
<br>
Returns the value of environment variable envvar in a list
containing two elements:</p>

<p style="margin-top: 1em">the first element indicates
whether the environment variable was defined (value
&quot;1&quot;) or not (value &quot;0&quot;); <br>
the second element indicates the value of the environment
variable.</p>

<p style="margin-top: 1em">Enivironment variables are of
the form variable=value, and if defined the list&acirc;s
second element contains value. If the value is empty, the
variable is defined, but has no <br>
text associated with it.</p>

<p style="margin-top: 1em">o string get_ext(string file)
<br>
Returns the extension of file, except for the separating
dot. The extension is all information starting at the final
dot in the filename.</p>

<p style="margin-top: 1em">If no final dot is found, an
empty string is returned.</p>

<p style="margin-top: 1em">o int getpid() <br>
Returns the process-id of the icmake byte code interpreter
icm-exec.</p>

<p style="margin-top: 1em">o string gets() <br>
Returns the next line read from the keyboard as a string.
The line entered on the keyboard must be terminated by an
&lsquo;Enter&acirc; key, which is not stored in the returned
<br>
string.</p>

<p style="margin-top: 1em">o string get_path(string file)
<br>
Returns the path-prefix of file. The path prefix is all
information up to (and including) the final directory
separator (which is, depending on the operating system, a
<br>
forward- or backslash).</p>

<p style="margin-top: 1em">If no path is found, an empty
strring is returned.</p>

<p style="margin-top: 1em">o int listfind(list lst, string
str) <br>
Returns the first index in lst where the string str is
found, or -1 if lst does not contain str.</p>

<p style="margin-top: 1em">o int listlen(list l) <br>
Returns the number of elements in list.</p>

<p style="margin-top: 1em">o list listunion(list lhs, list
rhs) <br>
Returns a list containing the union of the elements in lhs
and rhs.</p>

<p style="margin-top: 1em">o list listunion(list lst,
string str) <br>
Returns a list containing the union of the elements in lst
and str.</p>

<p style="margin-top: 1em">o list makelist(string mask)
<br>
Returns a list of all files matching mask. E.g.,
makelist(&quot;*.c&quot;) returns a list containing all
files ending in .c.</p>

<p style="margin-top: 1em">o list makelist(type, string
mask) <br>
Same as the previous function, but the type of the directory
elements may be specified as its first argument:</p>

<p style="margin-top: 1em">symbol meaning <br>
O_ALL obtain all directory entries <br>
O_DIR obtain all directories, including . and .. <br>
O_FILE obtain a list of files <br>
O_SUBDIR obtain all subdirectories</p>

<p style="margin-top: 1em">Note that the pattern * will not
match hidden entries under Unix-type operating systems. Use
.* for that.</p>

<p style="margin-top: 1em">o list makelist(string mask,
newer, string comparefile) <br>
Returns list of all files matching mask which are newer than
a provided comparefile. Operator younger may be used instead
of newer. Note that newer and younger are opera&acirc; <br>
tors, not strings.</p>

<p style="margin-top: 1em">o list makelist([int = IS_FILE,]
string mask, newer, string comparefile) <br>
Same as the previous function, but type may be specified as
in list makelist(type, string mask).</p>

<p style="margin-top: 1em">o makelist(string mask, older,
string comparefile) <br>
See above; returns a list of files that are older than the
comparefile.</p>

<p style="margin-top: 1em">o makelist(type, string mask,
older, string comparefile) <br>
Same as the previous function, but type may be specified as
in list makelist(type, string mask).</p>

<p style="margin-top: 1em">o int printf(...) <br>
Shows all (comma separated) arguments to screen (i.e., the
standard output stream). Returns the number of printed
arguments.</p>

<p style="margin-top: 1em">o int printf(string format, ...)
<br>
Shows all (comma separated) arguments to screen (i.e., the
standard output stream). Returns the number of printed
arguments (the format string counts as one argument).</p>

<p style="margin-top: 1em">If format contains placeholders
%1 .. %n the output is formatted (see also strformat).</p>

<p style="margin-top: 1em">o int putenv(string envvar) <br>
Adds envvar to the current (icmake) environment Use the
format: &quot;VAR=value&quot;. Returns 0.</p>

<p style="margin-top: 1em">o string resize(string str, int
newlength) Returns a copy of string str, resized to
newlength characters. If newlength is negative then an empty
string is returned, if <br>
newlength exceeds str&acirc;s length then the newly added
characters are initialized to blank spaces.</p>

<p style="margin-top: 1em">o int sizeof(list l) <br>
Deprecated: use listlen.</p>

<p style="margin-top: 1em">o int sizeoflist(list l) <br>
Deprecated: use listlen.</p>

<p style="margin-top: 1em">o list stat(string entry) <br>
Returns stat(2) information of directory entry entry as a
list. The returned list has two elements: element 0 is the
attribute value, element 1 contains the size of the <br>
file.</p>

<p style="margin-top: 1em">Attributes are returned as
bit-flags, composed from the following predefined
constants:</p>

<p style="margin-top: 1em">S_IFCHR S_IFDIR S_IFREG <br>
S_IREAD S_IWRITE S_IEXEC</p>

<p style="margin-top: 1em">See the stat(2) manual page for
the meanings of these constants.</p>

<p style="margin-top: 1em">o list stat(checking, string
entry) <br>
Same as the previous function, but by specifying checking as
P_NOCHECK the function won&acirc;t terminate the script.
Rather, it returns stat(2)&acirc;s return value.</p>

<p style="margin-top: 1em">o int strchr(string str, string
chars) <br>
Returns the first index in str where any of the characters
in chars is found, or -1 if str does not contain any of the
characters in chars.</p>

<p style="margin-top: 1em">o int strlen(string str) <br>
Returns the number of characters in str (not counting the
final 0).</p>

<p style="margin-top: 1em">o int strfind(string haystack,
string needle) <br>
Returns index in haystack where needle is found, or -1 if
needle is not contained in haystack. <br>
This function was called strstr() in versions before
7.00.</p>

<p style="margin-top: 1em">o int strformat(string
format,...) <br>
Returns a formatted string using placeholders %1 .. %2 to
address arguments following format. <br>
Example:</p>

<p style="margin-top: 1em">void main() <br>
{ <br>
int i = 10; <br>
int j = 20; <br>
string s1; <br>
string s2; <br>
// traditional approach: <br>
s1 = (string)i + &quot; &quot; + (string)j + &quot; &quot; +
(string)i; <br>
// using strformat: <br>
s2 = strformat(&quot;%1 %2 %1&quot;, i, j); <br>
printf(&quot;s1 = %1, s2 = %20, s1, s2); <br>
}</p>

<p style="margin-top: 1em">o string strlwr(string s) <br>
Returns a lower-case duplicate of s.</p>

<p style="margin-top: 1em">o list strtok(string str, string
separators) <br>
Returns a list containing all substrings of str separated by
one or more (consecutive) characters in separators. E.g.,
strtok(&quot;hello icmake&acirc;s+world&quot;, &quot;
+&quot;) returns the <br>
list containing the three strings &quot;hello&quot;,
&quot;icmake&acirc;s&quot;, and &quot;world&quot;.</p>

<p style="margin-top: 1em">o string strupr(string s) <br>
Returns an upper-case duplicate of s.</p>

<p style="margin-top: 1em">o string substr(string text, int
offset, int count) <br>
Returns a substring of text, starting at offset, consisting
of count characters. If offset exceeds (or equals) the
string&acirc;s size or if count &lt;= 0, then an empty
string is <br>
returned. If offset is less than 0 then offset = 0 is
used.</p>

<p style="margin-top: 1em">o int system(string command)
<br>
Executes command. The return value indicates the executed
command&acirc;s exit value. The string command may contain
redirection and/or piping characters.</p>

<p style="margin-top: 1em">o int system(int checking,
string command) <br>
Same functionality as the previous function, but by
specifying checking as NOT_CHECKED the function won&acirc;t
terminate the script. Rather, it will return the called
command&acirc;s <br>
exit status, or 0x7f00 if the command wasn&acirc;t
found.</p>

<p style="margin-top: 1em">o string trim(string s) <br>
Returns a copy of s without leading and trailing white
spaces.</p>

<p style="margin-top: 1em">o string trimleft(string str)
<br>
Returns a copy of s without leading white spaces.</p>

<p style="margin-top: 1em">o string trim(string s) <br>
Returns a copy of s without trailing white spaces.</p>

<p style="margin-top: 1em">USER DEFINED FUNCTIONS <br>
void main</p>

<p style="margin-top: 1em">Icmake scripts must be provided
with a user-defined function main. The function main has
three optional parameters, which may be omitted from the
last one (envp) to the first <br>
(argc), like in C. Its full prototype is (note: void return
type):</p>

<p style="margin-top: 1em">void main(int argc, list argv,
list envp)</p>

<p style="margin-top: 1em">In main(),</p>

<p style="margin-top: 1em">o argc represents the number of
elements in argv;</p>

<p style="margin-top: 1em">o argv contains the arguments,
with element 0 being equal to the name of the .bim file;</p>

<p style="margin-top: 1em">o envp contains the
&lsquo;environment&acirc; variables. The function listlen
can be used to determine the number of its elements.
Elements in envp have the form variable=value. Alter&acirc;
<br>
natively, the function getenv can be used to retrieve a
specific environment variable immediately. Example:</p>

<p style="margin-top: 1em">void main(int argc, list argv)
<br>
{ <br>
list toCompile; <br>
int idx;</p>

<p style="margin-top: 1em">if (argc == 1) <br>
usage(element(0, argv));</p>

<p style="margin-top: 1em">if (toCompile =
altered(&quot;*.cc&quot;)) <br>
{ <br>
for (idx = length(toCompile); idx--; ) <br>
compile(element(idx, toCompile));</p>

<p style="margin-top: 1em">if
(getenv(&quot;dryrun&quot;)[0] == &quot;0&quot;) <br>
linking(element(2, argv)); <br>
} <br>
}</p>

<p style="margin-top: 1em">Having initialized all global
variables in order of their definitions main is called by
icmake&acirc;s run-time support system to perform additional
tasks.</p>

<p style="margin-top: 1em">Additionally defined user
functions</p>

<p style="margin-top: 1em">Additional functions may be
defined. Once defined, these functions can be called.
Forward referencing of either variables or functions is not
supported, but recursively calling <br>
functions is. As function declarations are not supported
indirect recursion is not supported either.</p>

<p style="margin-top: 1em">User-defined functions must have
the following elements:</p>

<p style="margin-top: 1em">o The function&acirc;s return
type, which must be one of void, int, string or list. There
is no default type.</p>

<p style="margin-top: 1em">o The function&acirc;s name,
e.g., compile.</p>

<p style="margin-top: 1em">o A parameter list, defining
zero or more comma-separated parameters. The parameters
themselves consist of a type name (int, string, or list)
followed by the parameter&acirc;s <br>
identifier. E.g., (string outfile, string source).</p>

<p style="margin-top: 1em">o A body surrounded by a pair of
curly braces ({ and }).</p>

<p style="margin-top: 1em">Function bodies may contain
(optionally initialized) variable definitions. Variable
definitions start with a type name, followed by one or more
comma separated (optionally ini&acirc; <br>
tialized) variable identifiers. If a variable is not
explicitly initialized it is initialized by default. By
default an int variable is initialized to 0, a string is
initialized <br>
to an empty string (&quot;&quot;) and a list is initialized
to a list of zero elements.</p>

<p style="margin-top: 1em">In addition to variable
definitions, bodies may contain zero or more statements (cf.
section FLOW CONTROL). Note that variables may be defined
(and optionally initialized) any&acirc; <br>
where inside functions, and also in if, for and while
statements.</p>

<p style="margin-top: 1em">The behavior of icmake-scripts
using non-void functions that do not return values is not
defined.</p>

<p style="margin-top: 1em">FILES <br>
The mentioned paths are sugestive only and may vary over
different icmake-installations:</p>

<p style="margin-top: 1em">o /usr/bin/icmake: the main
icmake program;</p>

<p style="margin-top: 1em">o /usr/bin/icmun: the icmake
unassembler;</p>

<p style="margin-top: 1em">o /usr/lib/icmake/icm-dep: the
support program handling class- and precompiled header
dependencies;</p>

<p style="margin-top: 1em">o /usr/lib/icmake/icm-pp: the
preprocessor called by icmake;</p>

<p style="margin-top: 1em">o /usr/lib/icmake/icm-comp: the
compiler called by icmake;</p>

<p style="margin-top: 1em">o /usr/lib/icmake/icm-exec: the
byte-code interpreter called by icmake;</p>

<p style="margin-top: 1em">EXAMPLES <br>
The distribution (usually in /usr/share/doc/icmake) contains
a directory examples containing various examples of icmake
script. Note in particular the examples/icmbuild
subdirec&acirc; <br>
tory containing a general script for C++ and C program
maintenance.</p>

<p style="margin-top: 1em">SEE ALSO <br>
icmbuild(1), icmconf(7), icmstart(1), icmstart.rc(7),
make(1)</p>

<p style="margin-top: 1em">BUGS <br>
Standard comment starting on lines containing preprocessor
directives may not extend over multiple lines.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
This is free software, distributed under the terms of the
GNU General Public License (GPL).</p>

<p style="margin-top: 1em">AUTHOR <br>
Frank B. Brokken (f.b.brokken@rug.nl).</p>

<p style="margin-top: 1em">icmake.9.02.02.tar.gz 1992-2016
icmake(1)</p>
<hr>
</body>
</html>
