<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GCOV(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GCOV(1)</td>
    <td class="head-vol">GNU</td>
    <td class="head-rtitle">GCOV(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
gcov - coverage testing tool
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
gcov [ <b>-v</b>|<b>--version</b>] [<b>-h</b>|<b>--help</b>]
<br/>
 [ <b>-a</b>|<b>--all-blocks</b>]
<br/>
 [ <b>-b</b>|<b>--branch-probabilities</b>]
<br/>
 [ <b>-c</b>|<b>--branch-counts</b>]
<br/>
 [ <b>-n</b>|<b>--no-output</b>]
<br/>
 [ <b>-l</b>|<b>--long-file-names</b>]
<br/>
 [ <b>-p</b>|<b>--preserve-paths</b>]
<br/>
 [ <b>-f</b>|<b>--function-summaries</b>]
<br/>
 [ <b>-o</b>|<b>--object-directory</b> <i>directory|file</i>] <i>sourcefiles</i>
<br/>
 [ <b>-u</b>|<b>--unconditional-branches</b>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>gcov</b> is a test coverage program. Use it in concert with GCC to analyze
  your programs to help create more efficient, faster running code and to
  discover untested parts of your program. You can use <b>gcov</b> as a
  profiling tool to help discover where your optimization efforts will best
  affect your code. You can also use <b>gcov</b> along with the other profiling
  tool, <b>gprof</b>, to assess which parts of your code use the greatest amount
  of computing time.
<div class="Pp"></div>
Profiling tools help you analyze your code's performance. Using a profiler such
  as <b>gcov</b> or <b>gprof</b>, you can find out some basic performance
  statistics, such as:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">how often each line of code executes</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">what lines of code are actually executed</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">how much computing time each section of code uses</dd>
</dl>
<div class="Pp"></div>
Once you know these things about how your code works when compiled, you can look
  at each module to see which modules should be optimized. <b>gcov</b> helps you
  determine where to work on optimization.
<div class="Pp"></div>
Software developers also use coverage testing in concert with testsuites, to
  make sure software is actually good enough for a release. Testsuites can
  verify that a program works as expected; a coverage program tests to see how
  much of the program is exercised by the testsuite. Developers can then
  determine what kinds of test cases need to be added to the testsuites to
  create both better testing and a better final product.
<div class="Pp"></div>
You should compile your code without optimization if you plan to use <b>gcov</b>
  because the optimization, by combining some lines of code into one function,
  may not give you as much information as you need to look for `hot spots' where
  the code is using a great deal of computer time. Likewise, because <b>gcov</b>
  accumulates statistics by line (at the lowest resolution), it works best with
  a programming style that places only one statement on each line. If you use
  complicated macros that expand to loops or to other control structures, the
  statistics are less helpful---they only report on the line where the macro
  call appears. If your complex macros behave like functions, you can replace
  them with inline functions to solve this problem.
<div class="Pp"></div>
<b>gcov</b> creates a logfile called <i></i><i>sourcefile</i><i>.gcov</i> which
  indicates how many times each line of a source file
  <i></i><i>sourcefile</i><i>.c</i> has executed. You can use these logfiles
  along with <b>gprof</b> to aid in fine-tuning the performance of your
  programs. <b>gprof</b> gives timing information you can use along with the
  information you get from <b>gcov</b>.
<div class="Pp"></div>
<b>gcov</b> works only on code compiled with GCC. It is not compatible with any
  other profiling or test coverage mechanism.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">Display help about using <b>gcov</b> (on the standard
      output), and exit without doing any further processing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag">Display the <b>gcov</b> version number (on the standard
      output), and exit without doing any further processing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--all-blocks</b></dt>
  <dd class="It-tag">Write individual execution counts for every basic block.
      Normally gcov outputs execution counts only for the main blocks of a line.
      With this option you can determine if blocks within a single line are not
      being executed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--branch-probabilities</b></dt>
  <dd class="It-tag">Write branch frequencies to the output file, and write
      branch summary info to the standard output. This option allows you to see
      how often each branch in your program was taken. Unconditional branches
      will not be shown, unless the <b>-u</b> option is given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--branch-counts</b></dt>
  <dd class="It-tag">Write branch frequencies as the number of branches taken,
      rather than the percentage of branches taken.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-output</b></dt>
  <dd class="It-tag">Do not create the <b>gcov</b> output file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--long-file-names</b></dt>
  <dd class="It-tag">Create long file names for included source files. For
      example, if the header file <i>x.h</i> contains code, and was included in
      the file <i>a.c</i>, then running <b>gcov</b> on the file <i>a.c</i> will
      produce an output file called <i>a.c##x.h.gcov</i> instead of
      <i>x.h.gcov</i>. This can be useful if <i>x.h</i> is included in multiple
      source files. If you use the <b>-p</b> option, both the including and
      included file names will be complete path names.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--preserve-paths</b></dt>
  <dd class="It-tag">Preserve complete path information in the names of
      generated <i>.gcov</i> files. Without this option, just the filename
      component is used. With this option, all directories are used, with
      <b>/</b> characters translated to <b>#</b> characters, <i>.</i> directory
      components removed and <i>..</i> components renamed to <b>^</b>. This is
      useful if sourcefiles are in several different directories. It also
      affects the <b>-l</b> option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--function-summaries</b></dt>
  <dd class="It-tag">Output summaries for each function in addition to the file
      level summary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b> <i>directory|file</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--object-directory</b> <i>directory</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--object-file</b> <i>file</i></dt>
  <dd class="It-tag">Specify either the directory containing the gcov data
      files, or the object path name. The <i>.gcno</i>, and <i>.gcda</i> data
      files are searched for using this option. If a directory is specified, the
      data files are in that directory and named after the source file name,
      without its extension. If a file is specified here, the data files are
      named after that file, without its extension. If this option is not
      supplied, it defaults to the current directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--unconditional-branches</b></dt>
  <dd class="It-tag">When branch probabilities are given, include those of
      unconditional branches. Unconditional branches are normally not
      interesting.</dd>
</dl>
<div class="Pp"></div>
<b>gcov</b> should be run with the current directory the same as that when you
  invoked the compiler. Otherwise it will not be able to locate the source
  files. <b>gcov</b> produces files called <i></i><i>mangledname</i><i>.gcov</i>
  in the current directory. These contain the coverage information of the source
  file they correspond to. One <i>.gcov</i> file is produced for each source
  file containing code, which was compiled to produce the data files. The
  <i>mangledname</i> part of the output file name is usually simply the source
  file name, but can be something more complicated if the <b>-l</b> or <b>-p</b>
  options are given. Refer to those options for details.
<div class="Pp"></div>
The <i>.gcov</i> files contain the <b>:</b> separated fields along with program
  source code. The format is
<div class="Pp"></div>
<pre>
        &lt;execution_count&gt;:&lt;line_number&gt;:&lt;source line text&gt;
</pre>
<div class="Pp"></div>
Additional block information may succeed each line, when requested by command
  line option. The <i>execution_count</i> is <b>-</b> for lines containing no
  code and <b>#####</b> for lines which were never executed. Some lines of
  information at the start have <i>line_number</i> of zero.
<div class="Pp"></div>
The preamble lines are of the form
<div class="Pp"></div>
<pre>
        -:0:&lt;tag&gt;:&lt;value&gt;
</pre>
<div class="Pp"></div>
The ordering and number of these preamble lines will be augmented as <b>gcov</b>
  development progresses --- do not rely on them remaining unchanged. Use
  <i>tag</i> to locate a particular preamble line.
<div class="Pp"></div>
The additional block information is of the form
<div class="Pp"></div>
<pre>
        &lt;tag&gt; &lt;information&gt;
</pre>
<div class="Pp"></div>
The <i>information</i> is human readable, but designed to be simple enough for
  machine parsing too.
<div class="Pp"></div>
When printing percentages, 0% and 100% are only printed when the values are
  <i>exactly</i> 0% and 100% respectively. Other values which would
  conventionally be rounded to 0% or 100% are instead printed as the nearest
  non-boundary value.
<div class="Pp"></div>
When using <b>gcov</b>, you must first compile your program with two special GCC
  options: <b>-fprofile-arcs -ftest-coverage</b>. This tells the compiler to
  generate additional information needed by gcov (basically a flow graph of the
  program) and also includes additional code in the object files for generating
  the extra profiling information needed by gcov. These additional files are
  placed in the directory where the object file is located.
<div class="Pp"></div>
Running the program will cause profile output to be generated. For each source
  file compiled with <b>-fprofile-arcs</b>, an accompanying <i>.gcda</i> file
  will be placed in the object file directory.
<div class="Pp"></div>
Running <b>gcov</b> with your program's source file names as arguments will now
  produce a listing of the code along with frequency of execution for each line.
  For example, if your program is called <i>tmp.c</i>, this is what you see when
  you use the basic <b>gcov</b> facility:
<div class="Pp"></div>
<pre>
        $ gcc -fprofile-arcs -ftest-coverage tmp.c
        $ a.out
        $ gcov tmp.c
        90.00% of 10 source lines executed in file tmp.c
        Creating tmp.c.gcov.
</pre>
<div class="Pp"></div>
The file <i>tmp.c.gcov</i> contains output from <b>gcov</b>. Here is a sample:
<div class="Pp"></div>
<pre>
                -:    0:Source:tmp.c
                -:    0:Graph:tmp.gcno
                -:    0:Data:tmp.gcda
                -:    0:Runs:1
                -:    0:Programs:1
                -:    1:#include &lt;stdio.h&gt;
                -:    2:
                -:    3:int main (void)
                1:    4:{
                1:    5:  int i, total;
                -:    6:
                1:    7:  total = 0;
                -:    8:
               11:    9:  for (i = 0; i &lt; 10; i++)
               10:   10:    total += i;
                -:   11:
                1:   12:  if (total != 45)
            #####:   13:    printf (&quot;Failure\n&quot;);
                -:   14:  else
                1:   15:    printf (&quot;Success\n&quot;);
                1:   16:  return 0;
                -:   17:}
</pre>
<div class="Pp"></div>
When you use the <b>-a</b> option, you will get individual block counts, and the
  output looks like this:
<div class="Pp"></div>
<pre>
                -:    0:Source:tmp.c
                -:    0:Graph:tmp.gcno
                -:    0:Data:tmp.gcda
                -:    0:Runs:1
                -:    0:Programs:1
                -:    1:#include &lt;stdio.h&gt;
                -:    2:
                -:    3:int main (void)
                1:    4:{
                1:    4-block  0
                1:    5:  int i, total;
                -:    6:
                1:    7:  total = 0;
                -:    8:
               11:    9:  for (i = 0; i &lt; 10; i++)
               11:    9-block  0
               10:   10:    total += i;
               10:   10-block  0
                -:   11:
                1:   12:  if (total != 45)
                1:   12-block  0
            #####:   13:    printf (&quot;Failure\n&quot;);
            $$$$$:   13-block  0
                -:   14:  else
                1:   15:    printf (&quot;Success\n&quot;);
                1:   15-block  0
                1:   16:  return 0;
                1:   16-block  0
                -:   17:}
</pre>
<div class="Pp"></div>
In this mode, each basic block is only shown on one line -- the last line of the
  block. A multi-line block will only contribute to the execution count of that
  last line, and other lines will not be shown to contain code, unless previous
  blocks end on those lines. The total execution count of a line is shown and
  subsequent lines show the execution counts for individual blocks that end on
  that line. After each block, the branch and call counts of the block will be
  shown, if the <b>-b</b> option is given.
<div class="Pp"></div>
Because of the way GCC instruments calls, a call count can be shown after a line
  with no individual blocks. As you can see, line 13 contains a basic block that
  was not executed.
<div class="Pp"></div>
When you use the <b>-b</b> option, your output looks like this:
<div class="Pp"></div>
<pre>
        $ gcov -b tmp.c
        90.00% of 10 source lines executed in file tmp.c
        80.00% of 5 branches executed in file tmp.c
        80.00% of 5 branches taken at least once in file tmp.c
        50.00% of 2 calls executed in file tmp.c
        Creating tmp.c.gcov.
</pre>
<div class="Pp"></div>
Here is a sample of a resulting <i>tmp.c.gcov</i> file:
<div class="Pp"></div>
<pre>
                -:    0:Source:tmp.c
                -:    0:Graph:tmp.gcno
                -:    0:Data:tmp.gcda
                -:    0:Runs:1
                -:    0:Programs:1
                -:    1:#include &lt;stdio.h&gt;
                -:    2:
                -:    3:int main (void)
        function main called 1 returned 1 blocks executed 75%
                1:    4:{
                1:    5:  int i, total;
                -:    6:
                1:    7:  total = 0;
                -:    8:
               11:    9:  for (i = 0; i &lt; 10; i++)
        branch  0 taken 91% (fallthrough)
        branch  1 taken 9%
               10:   10:    total += i;
                -:   11:
                1:   12:  if (total != 45)
        branch  0 taken 0% (fallthrough)
        branch  1 taken 100%
            #####:   13:    printf (&quot;Failure\n&quot;);
        call    0 never executed
                -:   14:  else
                1:   15:    printf (&quot;Success\n&quot;);
        call    0 called 1 returned 100%
                1:   16:  return 0;
                -:   17:}
</pre>
<div class="Pp"></div>
For each function, a line is printed showing how many times the function is
  called, how many times it returns and what percentage of the function's blocks
  were executed.
<div class="Pp"></div>
For each basic block, a line is printed after the last line of the basic block
  describing the branch or call that ends the basic block. There can be multiple
  branches and calls listed for a single source line if there are multiple basic
  blocks that end on that line. In this case, the branches and calls are each
  given a number. There is no simple way to map these branches and calls back to
  source constructs. In general, though, the lowest numbered branch or call will
  correspond to the leftmost construct on the source line.
<div class="Pp"></div>
For a branch, if it was executed at least once, then a percentage indicating the
  number of times the branch was taken divided by the number of times the branch
  was executed will be printed. Otherwise, the message &quot;never
  executed&quot; is printed.
<div class="Pp"></div>
For a call, if it was executed at least once, then a percentage indicating the
  number of times the call returned divided by the number of times the call was
  executed will be printed. This will usually be 100%, but may be less for
  functions that call &quot;exit&quot; or &quot;longjmp&quot;, and thus may not
  return every time they are called.
<div class="Pp"></div>
The execution counts are cumulative. If the example program were executed again
  without removing the <i>.gcda</i> file, the count for the number of times each
  line in the source was executed would be added to the results of the previous
  run(s). This is potentially useful in several ways. For example, it could be
  used to accumulate data over a number of program runs as part of a test
  verification suite, or to provide more accurate long-term information over a
  large number of program runs.
<div class="Pp"></div>
The data in the <i>.gcda</i> files is saved immediately before the program
  exits. For each source file compiled with <b>-fprofile-arcs</b>, the profiling
  code first attempts to read in an existing <i>.gcda</i> file; if the file
  doesn't match the executable (differing number of basic block counts) it will
  ignore the contents of the file. It then adds in the new execution counts and
  finally writes the data to the file.
<h2 class="Ss" title="Ss" id="Using_gcov_with_GCC_Optimization"><a class="selflink" href="#Using_gcov_with_GCC_Optimization">Using
  <b>gcov</b> with GCC Optimization</a></h2>
If you plan to use <b>gcov</b> to help optimize your code, you must first
  compile your program with two special GCC options: <b>-fprofile-arcs
  -ftest-coverage</b>. Aside from that, you can use any other GCC options; but
  if you want to prove that every single line in your program was executed, you
  should not compile with optimization at the same time. On some machines the
  optimizer can eliminate some simple code lines by combining them with other
  lines. For example, code like this:
<div class="Pp"></div>
<pre>
        if (a != b)
          c = 1;
        else
          c = 0;
</pre>
<div class="Pp"></div>
can be compiled into one instruction on some machines. In this case, there is no
  way for <b>gcov</b> to calculate separate execution counts for each line
  because there isn't separate code for each line. Hence the <b>gcov</b> output
  looks like this if you compiled the program with optimization:
<div class="Pp"></div>
<pre>
              100:   12:if (a != b)
              100:   13:  c = 1;
              100:   14:else
              100:   15:  c = 0;
</pre>
<div class="Pp"></div>
The output shows that this block of code, combined by optimization, executed 100
  times. In one sense this result is correct, because there was only one
  instruction representing all four of these lines. However, the output does not
  indicate how many times the result was 0 and how many times the result was 1.
<div class="Pp"></div>
Inlineable functions can create unexpected line counts. Line counts are shown
  for the source code of the inlineable function, but what is shown depends on
  where the function is inlined, or if it is not inlined at all.
<div class="Pp"></div>
If the function is not inlined, the compiler must emit an out of line copy of
  the function, in any object file that needs it. If <i>fileA.o</i> and
  <i>fileB.o</i> both contain out of line bodies of a particular inlineable
  function, they will also both contain coverage counts for that function. When
  <i>fileA.o</i> and <i>fileB.o</i> are linked together, the linker will, on
  many systems, select one of those out of line bodies for all calls to that
  function, and remove or ignore the other. Unfortunately, it will not remove
  the coverage counters for the unused function body. Hence when instrumented,
  all but one use of that function will show zero counts.
<div class="Pp"></div>
If the function is inlined in several places, the block structure in each
  location might not be the same. For instance, a condition might now be
  calculable at compile time in some instances. Because the coverage of all the
  uses of the inline function will be shown for the same source lines, the line
  counts themselves might seem inconsistent.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>gpl</i>(7), <i>gfdl</i>(7), <i>fsf-funding</i>(7), <i>gcc</i>(1) and the Info
  entry for <i>gcc</i>.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 1996, 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008 Free
  Software Foundation, Inc.
<div class="Pp"></div>
Permission is granted to copy, distribute and/or modify this document under the
  terms of the GNU Free Documentation License, Version 1.2 or any later version
  published by the Free Software Foundation; with the Invariant Sections being
  &quot;GNU General Public License&quot; and &quot;Funding Free Software&quot;,
  the Front-Cover texts being (a) (see below), and with the Back-Cover Texts
  being (b) (see below). A copy of the license is included in the <i>gfdl</i>(7)
  man page.
<div class="Pp"></div>
(a) The FSF's Front-Cover Text is:
<div class="Pp"></div>
<pre>
     A GNU Manual
</pre>
<div class="Pp"></div>
(b) The FSF's Back-Cover Text is:
<div class="Pp"></div>
<pre>
     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.
</pre>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-13</td>
    <td class="foot-os">gcc-4.4.7</td>
  </tr>
</table>
</body>
</html>
