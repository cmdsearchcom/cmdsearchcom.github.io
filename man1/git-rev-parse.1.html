<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:13:38 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GIT-REV-PARSE(1) Git Manual GIT-REV-PARSE(1)</p>

<p style="margin-top: 1em">NAME <br>
git-rev-parse - Pick out and massage parameters</p>

<p style="margin-top: 1em">SYNOPSIS <br>
git rev-parse [ --option ] &lt;args&gt;...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Many Git porcelainish commands take mixture of flags (i.e.
parameters that begin with a dash -) and parameters meant
for the underlying git rev-list command they use internally
<br>
and flags and parameters for the other commands they use
downstream of git rev-list. This command is used to
distinguish between them.</p>

<p style="margin-top: 1em">OPTIONS <br>
--parseopt <br>
Use git rev-parse in option parsing mode (see PARSEOPT
section below).</p>

<p style="margin-top: 1em">--keep-dashdash <br>
Only meaningful in --parseopt mode. Tells the option parser
to echo out the first -- met instead of skipping it.</p>

<p style="margin-top: 1em">--stop-at-non-option <br>
Only meaningful in --parseopt mode. Lets the option parser
stop at the first non-option argument. This can be used to
parse sub-commands that take options themselves.</p>

<p style="margin-top: 1em">--sq-quote <br>
Use git rev-parse in shell quoting mode (see SQ-QUOTE
section below). In contrast to the --sq option below, this
mode does only quoting. Nothing else is done to command <br>
input.</p>

<p style="margin-top: 1em">--revs-only <br>
Do not output flags and parameters not meant for git
rev-list command.</p>

<p style="margin-top: 1em">--no-revs <br>
Do not output flags and parameters meant for git rev-list
command.</p>

<p style="margin-top: 1em">--flags <br>
Do not output non-flag parameters.</p>

<p style="margin-top: 1em">--no-flags <br>
Do not output flag parameters.</p>

<p style="margin-top: 1em">--default &lt;arg&gt; <br>
If there is no parameter given by the user, use &lt;arg&gt;
instead.</p>

<p style="margin-top: 1em">--verify <br>
Verify that exactly one parameter is provided, and that it
can be turned into a raw 20-byte SHA-1 that can be used to
access the object database. If so, emit it to the <br>
standard output; otherwise, error out.</p>

<p style="margin-top: 1em">If you want to make sure that
the output actually names an object in your object database
and/or can be used as a specific type of object For example,
git rev-parse <br>
&quot;$VAR^{commit}&quot; will make sure $VAR names an
existing object that is a commit-ish (i.e. a commit, or an
annotated tag that points at a commit). To make sure that
$VAR names <br>
an existing object of any type, git rev-parse
&quot;$VAR^{object}&quot; can be used.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Only meaningful in --verify mode. Do not output an error
message if the first argument is not a valid object name;
instead exit with non-zero status silently.</p>

<p style="margin-top: 1em">--sq <br>
Usually the output is made one line per flag and parameter.
This option makes output a single line, properly quoted for
consumption by shell. Useful when you expect your <br>
parameter to contain whitespaces and newlines (e.g. when
using pickaxe -S with git diff-*). In contrast to the
--sq-quote option, the command input is still interpreted as
<br>
usual.</p>

<p style="margin-top: 1em">--not <br>
When showing object names, prefix them with ^ and strip ^
prefix from the object names that already have one.</p>

<p style="margin-top: 1em">--symbolic <br>
Usually the object names are output in SHA-1 form (with
possible ^ prefix); this option makes them output in a form
as close to the original input as possible.</p>

<p style="margin-top: 1em">--symbolic-full-name <br>
This is similar to --symbolic, but it omits input that are
not refs (i.e. branch or tag names; or more explicitly
disambiguating &quot;heads/master&quot; form, when you want
to name <br>
the &quot;master&quot; branch when there is an unfortunately
named tag &quot;master&quot;), and show them as full
refnames (e.g. &quot;refs/heads/master&quot;).</p>

<p style="margin-top: 1em">--abbrev-ref[=(strict|loose)]
<br>
A non-ambiguous short name of the objects name. The option
core.warnAmbiguousRefs is used to select the strict
abbreviation mode.</p>

<p style="margin-top: 1em">--disambiguate=&lt;prefix&gt;
<br>
Show every object whose name begins with the given prefix.
The &lt;prefix&gt; must be at least 4 hexadecimal digits
long to avoid listing each and every object in the
repository by <br>
mistake.</p>

<p style="margin-top: 1em">--all <br>
Show all refs found in refs/.</p>

<p style="margin-top: 1em">--branches[=pattern],
--tags[=pattern], --remotes[=pattern] <br>
Show all branches, tags, or remote-tracking branches,
respectively (i.e., refs found in refs/heads, refs/tags, or
refs/remotes, respectively).</p>

<p style="margin-top: 1em">If a pattern is given, only refs
matching the given shell glob are shown. If the pattern does
not contain a globbing character (?, *, or [), it is turned
into a prefix match <br>
by appending /*.</p>

<p style="margin-top: 1em">--glob=pattern <br>
Show all refs matching the shell glob pattern pattern. If
the pattern does not start with refs/, this is automatically
prepended. If the pattern does not contain a globbing <br>
character (?, *, or [), it is turned into a prefix match by
appending /*.</p>

<p style="margin-top: 1em">--show-toplevel <br>
Show the absolute path of the top-level directory.</p>

<p style="margin-top: 1em">--show-prefix <br>
When the command is invoked from a subdirectory, show the
path of the current directory relative to the top-level
directory.</p>

<p style="margin-top: 1em">--show-cdup <br>
When the command is invoked from a subdirectory, show the
path of the top-level directory relative to the current
directory (typically a sequence of &quot;../&quot;, or an
empty <br>
string).</p>

<p style="margin-top: 1em">--git-dir <br>
Show $GIT_DIR if defined. Otherwise show the path to the
.git directory. The path shown, when relative, is relative
to the current working directory.</p>

<p style="margin-top: 1em">If $GIT_DIR is not defined and
the current directory is not detected to lie in a Git
repository or work tree print a message to stderr and exit
with nonzero status.</p>

<p style="margin-top: 1em">--is-inside-git-dir <br>
When the current working directory is below the repository
directory print &quot;true&quot;, otherwise
&quot;false&quot;.</p>

<p style="margin-top: 1em">--is-inside-work-tree <br>
When the current working directory is inside the work tree
of the repository print &quot;true&quot;, otherwise
&quot;false&quot;.</p>

<p style="margin-top: 1em">--is-bare-repository <br>
When the repository is bare print &quot;true&quot;,
otherwise &quot;false&quot;.</p>

<p style="margin-top: 1em">--local-env-vars <br>
List the GIT_* environment variables that are local to the
repository (e.g. GIT_DIR or GIT_WORK_TREE, but not
GIT_EDITOR). Only the names of the variables are listed, not
<br>
their value, even if they are set.</p>

<p style="margin-top: 1em">--short, --short=number <br>
Instead of outputting the full SHA-1 values of object names
try to abbreviate them to a shorter unique name. When no
length is specified 7 is used. The minimum length is 4.</p>

<p style="margin-top: 1em">--since=datestring,
--after=datestring <br>
Parse the date string, and output the corresponding
--max-age= parameter for git rev-list.</p>

<p style="margin-top: 1em">--until=datestring,
--before=datestring <br>
Parse the date string, and output the corresponding
--min-age= parameter for git rev-list.</p>

<p style="margin-top: 1em">&lt;args&gt;... <br>
Flags and parameters to be parsed.</p>

<p style="margin-top: 1em">--resolve-git-dir &lt;path&gt;
<br>
Check if &lt;path&gt; is a valid repository or a gitfile
that points at a valid repository, and print the location of
the repository. If &lt;path&gt; is a gitfile then the
resolved path <br>
to the real repository is printed.</p>

<p style="margin-top: 1em">SPECIFYING REVISIONS <br>
A revision parameter &lt;rev&gt; typically, but not
necessarily, names a commit object. It uses what is called
an extended SHA-1 syntax. Here are various ways to spell
object names. <br>
The ones listed near the end of this list name trees and
blobs contained in a commit.</p>

<p style="margin-top: 1em">&lt;sha1&gt;, e.g.
dae86e1950b1277e545cee180551750029cfe735, dae86e <br>
The full SHA-1 object name (40-byte hexadecimal string), or
a leading substring that is unique within the repository.
E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e
<br>
both name the same commit object if there is no other object
in your repository whose object name starts with dae86e.</p>

<p style="margin-top: 1em">&lt;describeOutput&gt;, e.g.
v1.7.4.2-679-g3bee7fb <br>
Output from git describe; i.e. a closest tag, optionally
followed by a dash and a number of commits, followed by a
dash, a g, and an abbreviated object name.</p>

<p style="margin-top: 1em">&lt;refname&gt;, e.g. master,
heads/master, refs/heads/master <br>
A symbolic ref name. E.g. master typically means the commit
object referenced by refs/heads/master. If you happen to
have both heads/master and tags/master, you can <br>
explicitly say heads/master to tell Git which one you mean.
When ambiguous, a &lt;refname&gt; is disambiguated by taking
the first match in the following rules:</p>

<p style="margin-top: 1em">1. If $GIT_DIR/&lt;refname&gt;
exists, that is what you mean (this is usually useful only
for HEAD, FETCH_HEAD, ORIG_HEAD, MERGE_HEAD and
CHERRY_PICK_HEAD);</p>

<p style="margin-top: 1em">2. otherwise,
refs/&lt;refname&gt; if it exists;</p>

<p style="margin-top: 1em">3. otherwise,
refs/tags/&lt;refname&gt; if it exists;</p>

<p style="margin-top: 1em">4. otherwise,
refs/heads/&lt;refname&gt; if it exists;</p>

<p style="margin-top: 1em">5. otherwise,
refs/remotes/&lt;refname&gt; if it exists;</p>

<p style="margin-top: 1em">6. otherwise,
refs/remotes/&lt;refname&gt;/HEAD if it exists.</p>

<p style="margin-top: 1em">HEAD names the commit on which
you based the changes in the working tree. FETCH_HEAD
records the branch which you fetched from a remote
repository with your last git <br>
fetch invocation. ORIG_HEAD is created by commands that move
your HEAD in a drastic way, to record the position of the
HEAD before their operation, so that you can <br>
easily change the tip of the branch back to the state before
you ran them. MERGE_HEAD records the commit(s) which you are
merging into your branch when you run git <br>
merge. CHERRY_PICK_HEAD records the commit which you are
cherry-picking when you run git cherry-pick.</p>

<p style="margin-top: 1em">Note that any of the refs/*
cases above may come either from the $GIT_DIR/refs directory
or from the $GIT_DIR/packed-refs file. While the ref name
encoding is <br>
unspecified, UTF-8 is preferred as some output processing
may assume ref names in UTF-8.</p>

<p style="margin-top: 1em">&lt;refname&gt;@{&lt;date&gt;},
e.g. master@{yesterday}, HEAD@{5 minutes ago} <br>
A ref followed by the suffix @ with a date specification
enclosed in a brace pair (e.g. {yesterday}, {1 month 2 weeks
3 days 1 hour 1 second ago} or {1979-02-26 18:30:00}) <br>
specifies the value of the ref at a prior point in time.
This suffix may only be used immediately following a ref
name and the ref must have an existing log <br>
($GIT_DIR/logs/&lt;ref&gt;). Note that this looks up the
state of your local ref at a given time; e.g., what was in
your local master branch last week. If you want to look at
<br>
commits made during certain times, see --since and
--until.</p>

<p style="margin-top: 1em">&lt;refname&gt;@{&lt;n&gt;},
e.g. master@{1} <br>
A ref followed by the suffix @ with an ordinal specification
enclosed in a brace pair (e.g. {1}, {15}) specifies the n-th
prior value of that ref. For example master@{1} is <br>
the immediate prior value of master while master@{5} is the
5th prior value of master. This suffix may only be used
immediately following a ref name and the ref must have an
<br>
existing log ($GIT_DIR/logs/&lt;refname&gt;).</p>

<p style="margin-top: 1em">@{&lt;n&gt;}, e.g. @{1} <br>
You can use the @ construct with an empty ref part to get at
a reflog entry of the current branch. For example, if you
are on branch blabla then @{1} means the same as <br>
blabla@{1}.</p>

<p style="margin-top: 1em">@{-&lt;n&gt;}, e.g. @{-1} <br>
The construct @{-&lt;n&gt;} means the &lt;n&gt;th branch
checked out before the current one.</p>

<p style="margin-top: 1em">&lt;branchname&gt;@{upstream},
e.g. master@{upstream}, @{u} <br>
The suffix @{upstream} to a branchname (short form
&lt;branchname&gt;@{u}) refers to the branch that the branch
specified by branchname is set to build on top of. A missing
<br>
branchname defaults to the current one.</p>

<p style="margin-top: 1em">&lt;rev&gt;^, e.g. HEAD^,
v1.5.1^0 <br>
A suffix ^ to a revision parameter means the first parent of
that commit object. ^&lt;n&gt; means the &lt;n&gt;th parent
(i.e. &lt;rev&gt;^ is equivalent to &lt;rev&gt;^1). As a
special rule, <br>
&lt;rev&gt;^0 means the commit itself and is used when
&lt;rev&gt; is the object name of a tag object that refers
to a commit object.</p>

<p style="margin-top: 1em">&lt;rev&gt;~&lt;n&gt;, e.g.
master~3 <br>
A suffix ~&lt;n&gt; to a revision parameter means the commit
object that is the &lt;n&gt;th generation ancestor of the
named commit object, following only the first parents. I.e.
<br>
&lt;rev&gt;~3 is equivalent to &lt;rev&gt;^^^ which is
equivalent to &lt;rev&gt;^1^1^1. See below for an
illustration of the usage of this form.</p>

<p style="margin-top: 1em">&lt;rev&gt;^{&lt;type&gt;}, e.g.
v0.99.8^{commit} <br>
A suffix ^ followed by an object type name enclosed in brace
pair means the object could be a tag, and dereference the
tag recursively until an object of that type is found <br>
or the object cannot be dereferenced anymore (in which case,
barf). &lt;rev&gt;^0 is a short-hand for
&lt;rev&gt;^{commit}.</p>

<p style="margin-top: 1em">rev^{object} can be used to make
sure rev names an object that exists, without requiring rev
to be a tag, and without dereferencing rev; because a tag is
already an object, <br>
it does not have to be dereferenced even once to get to an
object.</p>

<p style="margin-top: 1em">&lt;rev&gt;^{}, e.g. v0.99.8^{}
<br>
A suffix ^ followed by an empty brace pair means the object
could be a tag, and dereference the tag recursively until a
non-tag object is found.</p>

<p style="margin-top: 1em">&lt;rev&gt;^{/&lt;text&gt;},
e.g. HEAD^{/fix nasty bug} <br>
A suffix ^ to a revision parameter, followed by a brace pair
that contains a text led by a slash, is the same as the
:/fix nasty bug syntax below except that it returns the <br>
youngest matching commit which is reachable from the
&lt;rev&gt; before ^.</p>

<p style="margin-top: 1em">:/&lt;text&gt;, e.g. :/fix nasty
bug <br>
A colon, followed by a slash, followed by a text, names a
commit whose commit message matches the specified regular
expression. This name returns the youngest matching commit
<br>
which is reachable from any ref. If the commit message
starts with a ! you have to repeat that; the special
sequence :/!, followed by something else than !, is reserved
for <br>
now. The regular expression can match any part of the commit
message. To match messages starting with a string, one can
use e.g. :/^foo.</p>

<p style="margin-top: 1em">&lt;rev&gt;:&lt;path&gt;, e.g.
HEAD:README, :README, master:./README <br>
A suffix : followed by a path names the blob or tree at the
given path in the tree-ish object named by the part before
the colon. :path (with an empty part before the colon) <br>
is a special case of the syntax described next: content
recorded in the index at the given path. A path starting
with ./ or ../ is relative to the current working directory.
<br>
The given path will be converted to be relative to the
working tree&acirc;s root directory. This is most useful to
address a blob or tree from a commit or tree that has the
same <br>
tree structure as the working tree.</p>

<p style="margin-top: 1em">:&lt;n&gt;:&lt;path&gt;, e.g.
:0:README, :README <br>
A colon, optionally followed by a stage number (0 to 3) and
a colon, followed by a path, names a blob object in the
index at the given path. A missing stage number (and the
<br>
colon that follows it) names a stage 0 entry. During a
merge, stage 1 is the common ancestor, stage 2 is the target
branch&acirc;s version (typically the current branch), and
stage <br>
3 is the version from the branch which is being merged.</p>

<p style="margin-top: 1em">Here is an illustration, by Jon
Loeliger. Both commit nodes B and C are parents of commit
node A. Parent commits are ordered left-to-right.</p>

<p style="margin-top: 1em">G H I J &nbsp; <br>
/ &nbsp;/ <br>
D E F &nbsp; <br>
| / &nbsp;| / | <br>
/ | <br>
B C &nbsp; <br>
/ &nbsp; <br>
/ <br>
A</p>

<p style="margin-top: 1em">A = = A^0 <br>
B = A^ = A^1 = A~1 <br>
C = A^2 = A^2 <br>
D = A^^ = A^1^1 = A~2 <br>
E = B^2 = A^^2 <br>
F = B^3 = A^^3 <br>
G = A^^^ = A^1^1^1 = A~3 <br>
H = D^2 = B^^2 = A^^^2 = A~2^2 <br>
I = F^ = B^3^ = A^^3^ <br>
J = F^2 = B^3^2 = A^^3^2</p>

<p style="margin-top: 1em">SPECIFYING RANGES <br>
History traversing commands such as git log operate on a set
of commits, not just a single commit. To these commands,
specifying a single revision with the notation described in
<br>
the previous section means the set of commits reachable from
that commit, following the commit ancestry chain.</p>

<p style="margin-top: 1em">To exclude commits reachable
from a commit, a prefix ^ notation is used. E.g. ^r1 r2
means commits reachable from r2 but exclude the ones
reachable from r1.</p>

<p style="margin-top: 1em">This set operation appears so
often that there is a shorthand for it. When you have two
commits r1 and r2 (named according to the syntax explained
in SPECIFYING REVISIONS above), <br>
you can ask for commits that are reachable from r2 excluding
those that are reachable from r1 by ^r1 r2 and it can be
written as r1..r2.</p>

<p style="margin-top: 1em">A similar notation r1...r2 is
called symmetric difference of r1 and r2 and is defined as
r1 r2 --not $(git merge-base --all r1 r2). It is the set of
commits that are reachable <br>
from either one of r1 or r2 but not from both.</p>

<p style="margin-top: 1em">In these two shorthands, you can
omit one end and let it default to HEAD. For example,
origin.. is a shorthand for origin..HEAD and asks &quot;What
did I do since I forked from the <br>
origin branch?&quot; Similarly, ..origin is a shorthand for
HEAD..origin and asks &quot;What did the origin do since I
forked from them?&quot; Note that .. would mean HEAD..HEAD
which is an <br>
empty range that is both reachable and unreachable from
HEAD.</p>

<p style="margin-top: 1em">Two other shorthands for naming
a set that is formed by a commit and its parent commits
exist. The r1^@ notation means all parents of r1. r1^!
includes commit r1 but excludes all <br>
of its parents.</p>

<p style="margin-top: 1em">To summarize:</p>

<p style="margin-top: 1em">&lt;rev&gt; <br>
Include commits that are reachable from (i.e. ancestors of)
&lt;rev&gt;.</p>

<p style="margin-top: 1em">^&lt;rev&gt; <br>
Exclude commits that are reachable from (i.e. ancestors of)
&lt;rev&gt;.</p>

<p style="margin-top: 1em">&lt;rev1&gt;..&lt;rev2&gt; <br>
Include commits that are reachable from &lt;rev2&gt; but
exclude those that are reachable from &lt;rev1&gt;. When
either &lt;rev1&gt; or &lt;rev2&gt; is omitted, it defaults
to HEAD.</p>

<p style="margin-top: 1em">&lt;rev1&gt;...&lt;rev2&gt; <br>
Include commits that are reachable from either &lt;rev1&gt;
or &lt;rev2&gt; but exclude those that are reachable from
both. When either &lt;rev1&gt; or &lt;rev2&gt; is omitted,
it defaults to HEAD.</p>

<p style="margin-top: 1em">&lt;rev&gt;^@, e.g. HEAD^@ <br>
A suffix ^ followed by an at sign is the same as listing all
parents of &lt;rev&gt; (meaning, include anything reachable
from its parents, but not the commit itself).</p>

<p style="margin-top: 1em">&lt;rev&gt;^!, e.g. HEAD^! <br>
A suffix ^ followed by an exclamation mark is the same as
giving commit &lt;rev&gt; and then all its parents prefixed
with ^ to exclude them (and their ancestors).</p>

<p style="margin-top: 1em">Here are a handful of
examples:</p>

<p style="margin-top: 1em">D G H D <br>
D F G H I J D F <br>
^G D H D <br>
^D B E I J F B <br>
B..C C <br>
B...C G H D E B C <br>
^D B C E I J F B C <br>
C I J F C <br>
C^@ I J F <br>
C^! C <br>
F^! D G H D F</p>

<p style="margin-top: 1em">PARSEOPT <br>
In --parseopt mode, git rev-parse helps massaging options to
bring to shell scripts the same facilities C builtins have.
It works as an option normalizer (e.g. splits single <br>
switches aggregate values), a bit like getopt(1) does.</p>

<p style="margin-top: 1em">It takes on the standard input
the specification of the options to parse and understand,
and echoes on the standard output a string suitable for
sh(1) eval to replace the <br>
arguments with normalized ones. In case of error, it outputs
usage on the standard error stream, and exits with code
129.</p>

<p style="margin-top: 1em">Note: Make sure you quote the
result when passing it to eval. See below for an
example.</p>

<p style="margin-top: 1em">Input Format <br>
git rev-parse --parseopt input format is fully text based.
It has two parts, separated by a line that contains only --.
The lines before the separator (should be more than one)
<br>
are used for the usage. The lines after the separator
describe the options.</p>

<p style="margin-top: 1em">Each line of options has this
format:</p>

<p style="margin-top: 1em">&lt;opt_spec&gt;&lt;flags&gt;*
SP+ help LF</p>

<p style="margin-top: 1em">&lt;opt_spec&gt; <br>
its format is the short option character, then the long
option name separated by a comma. Both parts are not
required, though at least one is necessary. h,help, dry-run
and <br>
f are all three correct &lt;opt_spec&gt;.</p>

<p style="margin-top: 1em">&lt;flags&gt; <br>
&lt;flags&gt; are of *, =, ? or !.</p>

<p style="margin-top: 1em">&Acirc;&middot; Use = if the
option takes an argument.</p>

<p style="margin-top: 1em">&Acirc;&middot; Use ? to mean
that the option is optional (though its use is
discouraged).</p>

<p style="margin-top: 1em">&Acirc;&middot; Use * to mean
that this option should not be listed in the usage generated
for the -h argument. It&acirc;s shown for --help-all as
documented in gitcli(7).</p>

<p style="margin-top: 1em">&Acirc;&middot; Use ! to not
make the corresponding negated long option available.</p>

<p style="margin-top: 1em">The remainder of the line, after
stripping the spaces, is used as the help associated to the
option.</p>

<p style="margin-top: 1em">Blank lines are ignored, and
lines that don&acirc;t match this specification are used as
option group headers (start the line with a space to create
such lines on purpose).</p>

<p style="margin-top: 1em">Example <br>
OPTS_SPEC=&quot; some-command [options] &lt;args&gt;...</p>

<p style="margin-top: 1em">some-command does foo and bar!
<br>
-- <br>
h,help show the help</p>

<p style="margin-top: 1em">foo some nifty option --foo <br>
bar= some cool option --bar with an argument</p>

<p style="margin-top: 1em">An option group Header <br>
C? option C with an optional argument&quot;</p>

<p style="margin-top: 1em">eval &quot;$(echo
&quot;$OPTS_SPEC&quot; | git rev-parse --parseopt --
&quot;$@&quot; || echo exit $?)&quot;</p>

<p style="margin-top: 1em">SQ-QUOTE <br>
In --sq-quote mode, git rev-parse echoes on the standard
output a single line suitable for sh(1) eval. This line is
made by normalizing the arguments following --sq-quote. <br>
Nothing other than quoting the arguments is done.</p>

<p style="margin-top: 1em">If you want command input to
still be interpreted as usual by git rev-parse before the
output is shell quoted, see the --sq option.</p>

<p style="margin-top: 1em">Example <br>
$ cat &gt;your-git-script.sh &lt;&lt; <br>
#!/bin/sh <br>
args=$(git rev-parse --sq-quote &quot;$@&quot;) # quote
user-supplied arguments <br>
command=&quot;git frotz -n24 $args&quot; # and use it inside
a handcrafted <br>
# command line <br>
eval &quot;$command&quot; <br>
EOF</p>

<p style="margin-top: 1em">$ sh your-git-script.sh &quot;a
b&rsquo;c&quot;</p>

<p style="margin-top: 1em">EXAMPLES <br>
&Acirc;&middot; Print the object name of the current
commit:</p>

<p style="margin-top: 1em">$ git rev-parse --verify
HEAD</p>

<p style="margin-top: 1em">&Acirc;&middot; Print the commit
object name from the revision in the $REV shell
variable:</p>

<p style="margin-top: 1em">$ git rev-parse --verify
$REV^{commit}</p>

<p style="margin-top: 1em">This will error out if $REV is
empty or not a valid revision.</p>

<p style="margin-top: 1em">&Acirc;&middot; Similar to
above:</p>

<p style="margin-top: 1em">$ git rev-parse --default master
--verify $REV</p>

<p style="margin-top: 1em">but if $REV is empty, the commit
object name from master will be printed.</p>

<p style="margin-top: 1em">GIT <br>
Part of the git(1) suite</p>

<p style="margin-top: 1em">Git 1.8.3.1 03/23/2016
GIT-REV-PARSE(1)</p>
<hr>
</body>
</html>
