<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:24:24 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>METACONFIG(1) General Commands Manual METACONFIG(1)</p>

<p style="margin-top: 1em">NAME <br>
metaconfig - a Configure script generator</p>

<p style="margin-top: 1em">SYNOPSIS <br>
metaconfig [ -dhkmostvwGMV ] [ -L dir ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Metaconfig is a program that generates Configure scripts. If
you don&rsquo;t know what a Configure script is, please skip
to the TUTORIAL section of this manual page. If you want a
<br>
full (formal) description of the way to use metaconfig and
its units, please look at the REFERENCE section. The
following is a quick introduction and reference for
knowledgeable <br>
users.</p>

<p style="margin-top: 1em">Metaconfig operates from set of
units which define everything that metaconfig knows about
portability. Each unit is self-contained, and does not have
to be registered anywhere <br>
other than by inclusion in either the public U directory or
your private U directory. If the dist package (of which
metaconfig is a part) is installed in LIB, then the public U
<br>
directory is LIB/dist/mcon/U. On this machine, the LIB
directory is /usr/share/dist. Your private U directory, if
you have one, is in the top level directory of your package.
<br>
Before you can run metaconfig you must do a several
things:</p>

<p style="margin-top: 1em">&Acirc;&middot; Create a
.package file in the package&rsquo;s top level directory by
running packinit. This program will ask you about your
package and remember what you tell it so that all the <br>
dist programs can be smart.</p>

<p style="margin-top: 1em">&Acirc;&middot; Consult the
Glossary (in LIB/dist/mcon) and write your shell scripts and
C programs in terms of the symbols that metaconfig knows how
to define. You don&rsquo;t need to tell <br>
metaconfig which symbols you used, since metaconfig will
figure that out for you.</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate any .SH
scripts needed to write Makefiles or shell scripts that will
depend on values defined by Configure. There is a program
called makeSH that will help you <br>
convert a plain script into a script.SH template; some
editing will still need to be performed on the resulting .SH
file to move the variable configuration part in the top <br>
part of the script (see inline comments generated by makeSH
within your .SH file).</p>

<p style="margin-top: 1em">&Acirc;&middot; Create a
MANIFEST.new file in your top level directory that lists all
the files in your package. This file will remain private and
will not be part of the final distribu&acirc; <br>
tion. (As a convenience, the MANIFEST file will be used by
metaconfig if there is no MANIFEST.new file yet.) The
filename should be the first field on each line. After <br>
some whitespace you can add a short comment describing your
file. Only source files should be listed in there. The
special file patchlevel.h (which is handled and main&acirc;
<br>
tained by the patching tools -- see pat(1)) should be part
of the MANIFEST.new file, but may be silently ignored by
some tools. As a rule of thumb, only files maintained by
<br>
RCS should be listed in there, the patchlevel.h file being
one important exception.</p>

<p style="margin-top: 1em">&Acirc;&middot; Optionally, you
may wish to create a MANIFEST file, which will be an
exported version of your MANIFEST.new. That file must be
made part of the release, i.e. listed in both <br>
your MANIFEST.new and MANIFEST itself. One of the metaconfig
units knows about this file and will force Configure to
perform a release check, ensuring all the files listed <br>
there are part of the distribution. The MANIFEST and
MANIFEST.new files should be distinct, not links.</p>

<p style="margin-top: 1em">&Acirc;&middot; Copy any .U
files that you want to modify to your private U directory.
Any .U files in your private U directory will be used in
preference to the one in the public U direc&acirc; <br>
tory. For example, one way to force inclusion of any unit is
to copy the End.U file to your .U directory and add the name
of the unit you want as a dependency on the end of <br>
the ?MAKE: line. Certain units can ONLY be forced in this
way, namely those of the form Warn_*.U and Chk_*.U. You can
also customize certain default Configure variables by <br>
copying Myinit.U to your package&rsquo;s private U directory
and setting the variables in that unit.</p>

<p style="margin-top: 1em">Now you are ready to run
metaconfig. That will create a Configure file, and
optionally a config_h.SH file (if your sources make any use
of C symbols). The generated files will <br>
automatically be added to your MANIFEST.new if necessary. Do
not forget to update your MANIFEST file though.</p>

<p style="margin-top: 1em">In order to create new units, do
the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; Copy a similar
unit to a new .U file. The name you choose should be the
name of a variable generated by the unit, although this is
only a convenience for you, not a <br>
requirement. It should be 12 or less characters to prevent
filename chopping. Actually, it should probably be 10 or
less so that those who want to use RCS can have a .U,v <br>
on the end without chopping. Metaconfig uses the case of the
first letter to determine if any variable is actually
produced by this unit, so don&rsquo;t Capitalize your unit
name <br>
if it is supposed to produce a shell variable.</p>

<p style="margin-top: 1em">&Acirc;&middot; Edit the new .U
file to do what you want. The first ?MAKE: line indicates
the dependencies; before the final list colon all the
variables this unit defines, and after the <br>
final colon all the variables (or other units) on which this
unit depends. It is very important that these lists be
accurate. If a dependency is optional and a default <br>
value can be used, you should prefix the dependency with a
&rsquo;+&rsquo; sign. The corresponding unit will not be
loaded to compute the symbol, unless really required by
another unit.</p>

<p style="margin-top: 1em">&Acirc;&middot; To the extent
possible, parameterize your unit based on shell variable
defined on ?INIT: lines. This will move the variable
definitions up to the Init.U unit, where they <br>
can be overridden by definitions in Myinit.U, which is
included after Init.U.</p>

<p style="margin-top: 1em">&Acirc;&middot; Add the
definition of any C symbols desired as ?H: lines. A line
beginning with ?H:?%&lt;: in the .U file will be added to
the eventual config.h file if and only if metaconfig <br>
decides that this unit is needed. The %&lt; stands for the
unit&rsquo;s name, which happens to be the name of the file
too (without .U) if you followed the convention. Always put
a <br>
comment on each ?H: line in case one of the variable
substitutions earlier on the line starts a comment without
finishing it. Any shell variable starting with d_ may do
<br>
this, so beware. If you ommit the ?%&lt;:, then metaconfig
will try to intuit the symbol whose definition is needed
prior any inclusion in config.h.</p>

<p style="margin-top: 1em">&Acirc;&middot; Add glossary
definitions as ?S: lines for shell variables and ?C: lines
for C preprocessor variables. See a current unit for
examples. It is VERY important to start each <br>
entry with a left justified symbol name, and end each entry
with a ?C:. or ?S:. line. The algorithm that translates C
preprocessor symbol entries for the Glossary into com&acirc;
<br>
ments for config.h depends on this.</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure the
order of all your ? lines is right. The correct order
is:</p>

<p style="margin-top: 1em">?RCS: and ?X: basically just
comments <br>
?MAKE: metaconfig dependencies <br>
?Y: unit layout directive <br>
?S: glossary shell definitions <br>
?C: glossary C definitions <br>
?H: config.h definitions <br>
?M: confmagic.h definitions <br>
?W: wanted symbols <br>
?V: visible symbols <br>
?F: files created by this unit <br>
?T: temporary shell symbols used <br>
?D: optional dependencies default value <br>
?O: used to mark obsolete units <br>
?LINT: metalint hints <br>
?INIT: shell symbols initializations</p>

<p style="margin-top: 1em">Here is an example to show the
ordering of the lines and the various formats allowed:</p>

<p style="margin-top: 1em">?RCS: $RCS-Id$ <br>
?RCS: Copyright information <br>
?RCS: $RCS-Log$ <br>
?X: <br>
?X: A contrived example <br>
?X: <br>
?MAKE:d_one two: three +four Five <br>
?MAKE: -pick add $@ %&lt; <br>
?Y:DEFAULT <br>
?S:d_one: <br>
?S: First shell symbol, conditionally defines ONE. <br>
?S:. <br>
?S:two: <br>
?S: Second shell symbol, value for TWO. <br>
?S:. <br>
?C:ONE: <br>
?C: First C symbol. <br>
?C:. <br>
?C:TWO: <br>
?C: Second C symbol. <br>
?C:. <br>
?H:#$d_one ONE /**/ <br>
?H:#define TWO &quot;$two&quot; <br>
?H:#$d_one ONE_TWO &quot;$two&quot; <br>
?H:. <br>
?M:flip: HAS_FLIP <br>
?M:#ifndef HAS_FLIP <br>
?M:#define flip(x) flop(x) <br>
?M:#endif <br>
?M:. <br>
?W:%&lt;:one_two <br>
?V:p_one p_two:p_three <br>
?F:file ./ftest !tmp <br>
?T:tmp var <br>
?D:two=&rsquo;undef&rsquo; <br>
?LINT:change three <br>
?INIT:two_init=&rsquo;2&rsquo; <br>
: shell code implementing the unit follows <br>
p_one=&rsquo;one&rsquo; <br>
p_two=&rsquo;two&rsquo; <br>
p_three=&quot;&quot;</p>

<p style="margin-top: 1em">Let me state it one more time:
the above unit definition is a fake one to only show the
different possibilities. Such a unit would serve little
purpose anyway... Some more <br>
advanced features are not described here. Please refer to
the REFERENCE section for more complete information.</p>

<p style="margin-top: 1em">&Acirc;&middot; Put the unit
into the public or private U directory as appropriate.</p>

<p style="margin-top: 1em">&Acirc;&middot; Rerun
metaconfig.</p>

<p style="margin-top: 1em">&Acirc;&middot; Send your unit
to ram@acri.fr (Raphael Manfredi) for inclusion in the
master copy, if you think it&rsquo;s of general
interest.</p>

<p style="margin-top: 1em">In order to add a new program to
be located:</p>

<p style="margin-top: 1em">&Acirc;&middot; Edit Loc.U, and
add the name of the program both to the ?MAKE: line (between
the two colons) and to either loclist or trylist (depending
on whether the program is manda&acirc; <br>
tory or not).</p>

<p style="margin-top: 1em">&Acirc;&middot; Rerun
metaconfig.</p>

<p style="margin-top: 1em">&Acirc;&middot; Send your unit
to me for inclusion in the master copy, if you think
it&rsquo;s of general interest.</p>

<p style="margin-top: 1em">Notes for writing .U files:</p>

<p style="margin-top: 1em">* Always use &quot;rm -f&quot;
because there are systems where rm is interactive by
default.</p>

<p style="margin-top: 1em">* Do not use &quot;set --
...&quot; because &rsquo;--&rsquo; does not work with every
shell. Use &quot;set x ...; shift&quot;.</p>

<p style="margin-top: 1em">* Do not use &quot;unset
ENV&quot; since unset is not fully portable. Say
&quot;ENV=&rsquo;&rsquo;&quot; instead.</p>

<p style="margin-top: 1em">* Always use echo &quot; &quot;
(with a space) because of Eunice systems.</p>

<p style="margin-top: 1em">* Only use test with -r, -w, -f
or -d since those are the only portable switches. In
particular, avoid &quot;test -x&quot;.</p>

<p style="margin-top: 1em">* Use only programs that came
with V7, so that you know everyone has them.</p>

<p style="margin-top: 1em">* Use $contains when you want to
grep conditionally, since not all greps return a reasonable
status. Be sure to redirect the output to /dev/null, by
using &rsquo;&gt;/dev/null 2&gt;&amp;1&rsquo;.</p>

<p style="margin-top: 1em">* Use &quot;if test&quot; rather
than &quot;if [...]&quot; since not every sh knows the
latter construct.</p>

<p style="margin-top: 1em">* Use the myread script for
inputs so that they can do shell escapes and default
evaluation. The general form is</p>

<p style="margin-top: 1em">case &quot;$grimble&quot; in
<br>
&rsquo;&rsquo;) dflt=452;; <br>
*) dflt=&quot;$grimble&quot;;; <br>
esac <br>
rp=&rsquo;How many grimbles do you have?&rsquo; <br>
. ./myread <br>
grimble=&quot;$ans&quot;</p>

<p style="margin-top: 1em">* Use the getfile script when
asking for a file pathname in order to have optional ~name
expansion and sanity checks. See the Getfile.U unit for a
full decription.</p>

<p style="margin-top: 1em">* Always put a</p>

<p style="margin-top: 1em">$startsh</p>

<p style="margin-top: 1em">at the top of every generated
script that is going to be launched or sourced by
Configure.</p>

<p style="margin-top: 1em">* Never assume common UNIX-isms
like the fact that an object file ends with a .o and that a
library name ends with .a. Use the $_o and $_a variables
instead (see Unix.U).</p>

<p style="margin-top: 1em">* When doing a
compile-link-execute test, always write it like this:</p>

<p style="margin-top: 1em">$cc $ccflags $ldflags try.c -o
try $libs</p>

<p style="margin-top: 1em">because some systems require
that linking flags be specified before the compiled target
(with the exception of trailing linking libraries).</p>

<p style="margin-top: 1em">* Issue important messages on
file descriptor #4, by using &rsquo;&gt;&amp;4&rsquo; to
redirect output. Only those messages will appear when the -s
switch is given to Configure on the command <br>
line (silent mode).</p>

<p style="margin-top: 1em">* Always try to determine
whether a feature is present in the most specific
way--don&rsquo;t say &quot;if bsd&quot; when you can grep
libc. There are many hybrid systems out there, and each <br>
feature should stand or fall by itself.</p>

<p style="margin-top: 1em">* Always try to determine
whether a feature is present in the most general way, so
that other packages can use your unit.</p>

<p style="margin-top: 1em">* When in doubt, set a default
and ask. Don&rsquo;t assume anything.</p>

<p style="margin-top: 1em">* If you think the user is
wrong, allow for the fact that he may be right. For
instance, he could be running Configure on a different
system than he is going to use the final <br>
product on.</p>

<p style="margin-top: 1em">Metaconfig reserves the
following names in your directory, and if you use such a
name it may get clobbered or have other unforeseen
effects:</p>

<p style="margin-top: 1em">.MT/* <br>
Configure <br>
Wanted <br>
Obsolete <br>
configure <br>
config_h.SH <br>
confmagic.h <br>
U/* <br>
MANIFEST.new</p>

<p style="margin-top: 1em">Additionally, Configure may
clobber these names in the directory it is run in:</p>

<p style="margin-top: 1em">UU/* <br>
config.sh <br>
config.h</p>

<p style="margin-top: 1em">OPTIONS <br>
The following options are recognized by metaconfig:</p>

<p style="margin-top: 1em">-d Turn on debug mode. Not
really useful unless you are debugging metaconfig
itself.</p>

<p style="margin-top: 1em">-h Print help message and
exit.</p>

<p style="margin-top: 1em">-k Keep temporary directory, so
that you may examine the working files used by metaconfig to
build your Configure script. Useful only when debugging the
units.</p>

<p style="margin-top: 1em">-m Assume lots of memory and
swap space. This will speed up symbol lookup in source files
by a significant amount of time, at the expense of memory
consumption...</p>

<p style="margin-top: 1em">-o Map obsolete symbols on new
ones. Use this switch if you still have some obsolete
symbols in your source code and do not want (or cannot)
remove them for now. The <br>
obsolete symbols are otherwise ignored, although that will
give you a warning from metaconfig.</p>

<p style="margin-top: 1em">-s Turn silent mode on.</p>

<p style="margin-top: 1em">-t Trace symbols as they are
found.</p>

<p style="margin-top: 1em">-v Turn verbose mode on.</p>

<p style="margin-top: 1em">-w Assume Wanted file is
up-to-date. This will skip the time and memory consuming
phase of source code scanning, looking for known symbols.
Use it only when you know <br>
your source file have not changed with respect to the pool
of metaconfig symbols used.</p>

<p style="margin-top: 1em">-G Also provide a GNU
configure-like front end to the generated Configure script,
to be included in the distribution as well. This is only a
wrapper around the Con&acirc; <br>
figure script naturally, but it lets people familiar with
the GNU tool to not be lost when facing a new
distribution.</p>

<p style="margin-top: 1em">-L dir Override default library
location. Normally only useful for metaconfig maintainers to
locally use the units being developed instead of the
publicly available ones. <br>
The dir specified is the one containing the units U
directory.</p>

<p style="margin-top: 1em">-M Allow production of a
confmagic.h file to automagically remap some well-known
symbols to some other alternative, like bcopy() being
remapped transparently to mem&acirc; <br>
cpy() when not available. This option is turned on
automatically when a confmagic.h file exists in the
top-level directory. Simply remove that file if you wish to
<br>
disable this option permanently.</p>

<p style="margin-top: 1em">-V Print version number and
exit.</p>

<p style="margin-top: 1em">TUTORIAL <br>
This (long) section is an introduction to metaconfig, in
which we will learn all the basics. If you already know how
to use metaconfig, you may safely skip to the next
section.</p>

<p style="margin-top: 1em">Overview <br>
Usually when you want to get some source package to compile
on a given platform you have to edit the main Makefile
(assuming there is one!), choose a C compiler, make sure you
<br>
have the proper libraries, and then fire the make command.
If the package is reasonably well written, it will compile
(without a warning being an option :-). In itself, the last
<br>
sentence is a real performance, since given the variety of
UNIX platforms available today and the diversity of
flavours, that means the author of the package has gone into
deep <br>
trouble to figure out the right choices given some standard
trial, guessing and messing around with system includes and
types.</p>

<p style="margin-top: 1em">However, despite all his talent,
the author cannot possibly know that some system has a
broken system call, or that some system structure lacks one
otherwise standard field, or <br>
simply whether a given include file exists or not. And
I&rsquo;m not considering the implicit assumptions, like the
type returned by the malloc() function or the presence of
the <br>
rename() system call to name a few. But that knowledge is
necessary to achieve real portability.</p>

<p style="margin-top: 1em">Now let&rsquo;s not abuse
ourselves. Using that information requires greater skills,
yet it can lead to more portable programs since it is then
written in a system-independant fashion <br>
and relies only on the fact that some assumption is true or
false on a particular system, each assumption being
unrelated with each other. That is to say, we do not say:
We&rsquo;re on <br>
a BSD system or we are on a USG system. That&rsquo;s too
fuzzy anyway nowadays. No, we want to say to the source
code: this system does not have the rename() system call and
malloc() <br>
returns a (void *) value.</p>

<p style="margin-top: 1em">Metaconfig is a tool that will
let you do just that, with the additional benefit of not
having to hand-edit the Makefile if all goes well. By
running metaconfig, you create a <br>
shell script named Configure. Lots of efforts have been
devoted to the Configure script internals to ensure it will
run on 99% of the existing shells available as of this
writ&acirc; <br>
ing. Configure will probe the target system, asking
questions when in doubt and gather all the answers in one
single shell file, which in turn can be used to
automatically gen&acirc; <br>
erate configured Makefiles and C include files.</p>

<p style="margin-top: 1em">There is only a limited (but
quite large) set of symbols available for your shell scripts
and C programs. They are all documented in the Glossary
file. All you need to do is <br>
learn about them and start using them to address portability
and configuration problems. Then, by running metaconfig, a
suitable Configure script will be generated for your
pack&acirc; <br>
age.</p>

<p style="margin-top: 1em">The Configure script is built
out several units (more than 300), each unit being
responsible for defining a small number of shell and/or C
symbols. Units are assembled together <br>
at the final stage, honoring the dependency graph (one unit
may need the result of several other units which are then
placed before in the script).</p>

<p style="margin-top: 1em">Symbols <br>
Symbols are the most important thing in the metaconfig
world. They are the smallest recognized entity, usually a
word, and can be granted a value at the end of the Configure
exe&acirc; <br>
cution. For instance, the C pre-processor symbol HAS_RENAME
is a metaconfig symbol that is guranteed to be defined if,
and only if, the rename() system call is present. Likewise,
<br>
the $ranlib shell variable will be set to either
&rsquo;:&rsquo; or &rsquo;ranlib&rsquo; depending on whether
the call to the ranlib program is needed to order a library
file. How this works is not <br>
important for now, what is important is to understand that
those symbols are given a life (i.e. a value) upon Configure
execution.</p>

<p style="margin-top: 1em">Using symbols is relatively
straightforward. In a C source file, you simply use the
symbol value, as a pre-processor directive (for instance an:
#ifdef HAS_RENAME) or, if the <br>
symbol value is a string, directly as you would use a macro
in C. And in a shell file or a Makefile, you may reference a
shell symbol directly.</p>

<p style="margin-top: 1em">Actually, I&rsquo;m lying,
because that&rsquo;s not completely as magic as the previous
paragraph could sound. In a C file, you need to include the
Configure-produced config.h file, and you <br>
must wrap your shell script or Makefile in a .SH file and
you may reference the shell symbol only in the variable
substitution part of that .SH file. More on this later.</p>

<p style="margin-top: 1em">Source Files <br>
Symbols may only appear in a limited set of source files,
because metaconfig will only scan those when looking for
known symbols, trying to figure out which units it will
need. <br>
You may use C symbols in C source files, i.e. files with a
.c, .h, .y or .l extension, and shell symbols are looked for
only in .SH files.</p>

<p style="margin-top: 1em">In order to get the value of a
symbol, a C file needs to include the special config.h file,
which is produced by Configure when C symbols are present.
And .SH files are run <br>
through a shell, producing a new file. However, in the top
section of the .SH file, the special config.sh file (also
produced by running Configure) is sourced, and variable
sub&acirc; <br>
stitutions apply. Actually, config.h is produced by running
the metaconfig-produced config_h.SH file, again using
variable substitution. So we&rsquo;re going to look at that
a little <br>
more closely since this is the heart of the whole
configuration scheme...</p>

<p style="margin-top: 1em">Variable Substitution <br>
There is shell construct called here document which enables
a command to take an input specified within the script
itself. That input is interpreted by the shell as a double-
<br>
quoted string or a single quoted string depending on the
form of the here document specification.</p>

<p style="margin-top: 1em">To specify a here document, the
&rsquo;&lt;&lt;&rsquo; token is used, followed by a single
identifier. From then on, the remaining script lines form
the input for the command, until the here docu&acirc; <br>
ment is found on a line by itself. Shell substitution
(including shell variable substitutions) is done unless the
identifier is surrounded by single quotes. For instance:</p>

<p style="margin-top: 1em">var=&rsquo;first&rsquo; <br>
tar=&rsquo;second&rsquo; <br>
echo &quot;--&gt; first here document:&quot; <br>
cat &lt;&lt;EOM <br>
var=&rsquo;$var&rsquo; <br>
tar=&rsquo;$tar&rsquo; <br>
EOM <br>
echo &quot;--&gt; second here document:&quot; <br>
cat &lt;&lt;&rsquo;EOM&rsquo; <br>
echo $var <br>
echo $tar <br>
EOM <br>
echo &quot;--&gt; end.&quot;</p>

<p style="margin-top: 1em">will produce, when run through a
shell:</p>

<p style="margin-top: 1em">--&gt; first here document: <br>
var=&rsquo;first&rsquo; <br>
tar=&rsquo;second&rsquo; <br>
--&gt; second here document: <br>
echo $var <br>
echo $tar <br>
--&gt; end.</p>

<p style="margin-top: 1em">The first here document has its
content interpreted whilst the second one is output as-is.
Both are useful in a .SH script, as we are about to see.</p>

<p style="margin-top: 1em">Using .SH Scripts <br>
A .SH script is usually produced by running the MakeSH
script other an existing file, transforming file into a
file.SH. Let&rsquo;s take a single example. Here is a little
script <br>
(let&rsquo;s call it intsize) which prints a single message,
the size of the int datatype in C. Unfortunately, it has the
value hardwired in it, thusly:</p>

<p style="margin-top: 1em">#!/bin/sh <br>
intsize=&rsquo;4&rsquo; <br>
echo &quot;On this machine, the int type is $intsize
bytes&quot;</p>

<p style="margin-top: 1em">Let&rsquo;s run makeSH on it by
typing &rsquo;makeSH intsize&rsquo;. We get a single
intsize.SH file that looks like this:</p>

<p style="margin-top: 1em">case $CONFIG in <br>
&rsquo;&rsquo;) <br>
if test -f config.sh; then TOP=.; <br>
elif test -f ../config.sh; then TOP=..; <br>
elif test -f ../../config.sh; then TOP=../..; <br>
elif test -f ../../../config.sh; then TOP=../../..; <br>
elif test -f ../../../../config.sh; then TOP=../../../..;
<br>
else <br>
echo &quot;Can&rsquo;t find config.sh.&quot;; exit 1 <br>
fi <br>
. $TOP/config.sh <br>
;; <br>
esac <br>
: This forces SH files to create target in same directory as
SH file. <br>
: This is so that make depend always knows where to find SH
derivatives. <br>
case &quot;$0&quot; in <br>
*/*) cd &lsquo;expr X$0 : &rsquo;X/&rsquo;&lsquo; ;; <br>
esac <br>
echo &quot;Extracting intsize (with variable
substitutions)&quot; <br>
: This section of the file will have variable substitutions
done on it. <br>
: Move anything that needs config subs from !NO!SUBS!
section to !GROK!THIS!. <br>
: Protect any dollar signs and backticks that you do not
want interpreted <br>
: by putting a backslash in front. You may delete these
comments. <br>
$spitshell &gt;intsize &lt;&lt;!GROK!THIS! <br>
$startsh <br>
!GROK!THIS!</p>

<p style="margin-top: 1em">: In the following dollars and
backticks do not need the extra backslash. <br>
$spitshell &gt;&gt;intsize &lt;&lt;&rsquo;!NO!SUBS!&rsquo;
<br>
intsize=&rsquo;4&rsquo; <br>
echo &quot;On this machine, the int type is $intsize
bytes&quot; <br>
!NO!SUBS! <br>
chmod 755 intsize <br>
$eunicefix intsize</p>

<p style="margin-top: 1em">The first part of this script
(in the case statement) is trying to locate the config.sh
file, in order to source it. The $CONFIG variable is false
by default, by true when con&acirc; <br>
fig.sh has been sourced already (which would be the case if
this file was executed from within Configure itself, but
let&rsquo;s not confuse the issue here).</p>

<p style="margin-top: 1em">Once the config.sh file has been
sources, all the shell symbols defined by Configure are set.
We know reach a second case statement, used to change the
current directory should a <br>
path be used to reach this program (for instance if we said
&rsquo;sh ../scripts/intsize.SH&rsquo;, we would first run
&rsquo;cd ../scripts&rsquo; before continuing). If you do
not understand this, <br>
don&rsquo;t worry about it.</p>

<p style="margin-top: 1em">Here comes the intersting stuff.
This script uses the $spitshell variable, and it&rsquo;s not
something we know about...yet. If you look through the
Glossary file, you will see that <br>
this is a variable known by metaconfig. If you make this
file part of your distribution (by including it in the
MANIFEST.new file, we&rsquo;ll come back to that later on)
and run meta&acirc; <br>
config, then the Configure script will determine a suitable
value for this variable and it will be set in config.sh.
Same goes for $startsh and the mysterious $eunicefix at the
<br>
end. On a reasonable system, the relevant part of config.sh
would look like this:</p>

<p style="margin-top: 1em">spitshell=&rsquo;cat&rsquo; <br>
startsh=&rsquo;#!/bin/sh&rsquo; <br>
eunicefix=&rsquo;:&rsquo;</p>

<p style="margin-top: 1em">Ah! We&rsquo;re getting there.
Now it looks familiar. We&rsquo;re facing a single cat
command whose input comes from a variable-interpolated here
document and whose output is redirected to <br>
intsize. The value will be that of $startsh, i.e.
&rsquo;#!/bin/sh&rsquo;. Fine so far.</p>

<p style="margin-top: 1em">Then we reach the second here
document expansion, to get the remaining of the script. This
time, the here document symbol is surrounded by single
quotes so the contents will be <br>
appended verbatim to the intsize file. So, by running
&rsquo;sh intsize.SH&rsquo;, we get the following
output:</p>

<p style="margin-top: 1em">Extracting intsize (with
variable substitutions)</p>

<p style="margin-top: 1em">and by looking at the produced
intsize file, we see:</p>

<p style="margin-top: 1em">#!/bin/sh <br>
intsize=&rsquo;4&rsquo; <br>
echo &quot;On this machine, the int type is $intsize
bytes&quot;</p>

<p style="margin-top: 1em">which is exactly what we had at
the beginning. So far, it&rsquo;s a no-operation
procedure... But, how marvelous! It so happens (pure
coincidence, trust me!), that metaconfig knows <br>
about the $intsize shell symbol. By moving the
initialization of intsize to the variable-interpolated area
of the .SH script and initializing it with the
Configure-computed <br>
value, and removing the now useless comments added by
makeSH, we get:</p>

<p style="margin-top: 1em">case $CONFIG in <br>
&rsquo;&rsquo;) <br>
if test -f config.sh; then TOP=.; <br>
elif test -f ../config.sh; then TOP=..; <br>
elif test -f ../../config.sh; then TOP=../..; <br>
elif test -f ../../../config.sh; then TOP=../../..; <br>
elif test -f ../../../../config.sh; then TOP=../../../..;
<br>
else <br>
echo &quot;Can&rsquo;t find config.sh.&quot;; exit 1 <br>
fi <br>
. $TOP/config.sh <br>
;; <br>
esac <br>
case &quot;$0&quot; in <br>
*/*) cd &lsquo;expr X$0 : &rsquo;X/&rsquo;&lsquo; ;; <br>
esac <br>
echo &quot;Extracting intsize (with variable
substitutions)&quot; <br>
$spitshell &gt;intsize &lt;&lt;!GROK!THIS! <br>
$startsh <br>
intsize=&rsquo;$intsize&rsquo; <br>
!GROK!THIS!</p>

<p style="margin-top: 1em">$spitshell &gt;&gt;intsize
&lt;&lt;&rsquo;!NO!SUBS!&rsquo; <br>
echo &quot;On this machine, the int type is $intsize
bytes&quot; <br>
!NO!SUBS! <br>
chmod 755 intsize <br>
$eunicefix intsize</p>

<p style="margin-top: 1em">Of course, running this script
through a shell will again output the same script. But if we
run Configure on a machine where an int is stored as a 64
bits quantity, config.sh <br>
will set intsize to 8 and the intsize script will bear the
right value and print:</p>

<p style="margin-top: 1em">On this machine, the int type is
8 bytes</p>

<p style="margin-top: 1em">which is correct.
Congratulations! We have just configured a shell
script!!</p>

<p style="margin-top: 1em">Producing config.h <br>
We can now have a look at the way config.h is produced out
of config_h.SH. We know that running Configure produces a
config.sh script (how exactly this is done is not strictly
<br>
relevant here, but for the curious, it&rsquo;s another here
document substitution within Configure itself). The
config_h.SH itself is built by metaconfig at the same time
Configure is, <br>
provided you make use of at least one C symbol within your
sources.</p>

<p style="margin-top: 1em">Let&rsquo;s have a look at some
random config_h.SH file to see what really happens:</p>

<p style="margin-top: 1em">case $CONFIG in <br>
&rsquo;&rsquo;) <br>
if test -f config.sh; then TOP=.; <br>
elif test -f ../config.sh; then TOP=..; <br>
elif test -f ../../config.sh; then TOP=../..; <br>
elif test -f ../../../config.sh; then TOP=../../..; <br>
elif test -f ../../../../config.sh; then TOP=../../../..;
<br>
else <br>
echo &quot;Can&rsquo;t find config.sh.&quot;; exit 1 <br>
fi <br>
. $TOP/config.sh <br>
;; <br>
esac <br>
case &quot;$0&quot; in <br>
*/*) cd &lsquo;expr X$0 : &rsquo;X/&rsquo;&lsquo; ;; <br>
esac <br>
echo &quot;Extracting config.h (with variable
substitutions)&quot; <br>
sed &lt;&lt;!GROK!THIS! &gt;config.h -e
&rsquo;s!^#undef!/define!&rsquo; -e
&rsquo;s!^#un-def!#undef!&rsquo; <br>
/* <br>
* This file was produced by running the config_h.SH script,
which <br>
* gets its values from config.sh, which is generally
produced by <br>
* running Configure. <br>
* <br>
* Feel free to modify any of this as the need arises. Note,
however, <br>
* that running config.h.SH again will wipe out any changes
you&rsquo;ve made. <br>
* For a more permanent change edit config.sh and rerun
config.h.SH. <br>
*/</p>

<p style="margin-top: 1em">/* Configuration time: $cf_time
<br>
* Configured by: $cf_by <br>
* Target system: $myuname <br>
*/</p>

<p style="margin-top: 1em">#ifndef _config_h_ <br>
#define _config_h_</p>

<p style="margin-top: 1em">/* bcopy: <br>
* This symbol is maped to memcpy if the bcopy() routine is
not <br>
* available to copy strings. <br>
*/ <br>
/* HAS_BCOPY: <br>
* This symbol is defined if the bcopy() routine is available
to <br>
* copy blocks of memory. You should not use this symbol
under <br>
* normal circumstances and use bcopy() directly instead,
which <br>
* will get mapped to memcpy() if bcopy is not available.
<br>
*/ <br>
#$d_bcopy HAS_BCOPY /**/ <br>
#ifndef HAS_BCOPY <br>
#ifdef bcopy <br>
#un-def bcopy <br>
#endif <br>
#define bcopy(s,d,l) memcpy((d),(s),(l)) /* mapped to memcpy
*/ <br>
#endif</p>

<p style="margin-top: 1em">/* HAS_DUP2: <br>
* This symbol, if defined, indicates that the dup2 routine
is <br>
* available to duplicate file descriptors. <br>
*/ <br>
#$d_dup2 HAS_DUP2 /**/</p>

<p style="margin-top: 1em">/* I_STRING: <br>
* This symbol, if defined, indicates to the C program that
it should <br>
* include &lt;string.h&gt; (USG systems) instead of
&lt;strings.h&gt; (BSD systems). <br>
*/ <br>
#$i_string I_STRING /**/</p>

<p style="margin-top: 1em">#endif <br>
!GROK!THIS!</p>

<p style="margin-top: 1em">At the top of the file, we
recognize the standard .SH construct that we have already
studied in detail. Next comes the extraction of the file
itself, via a here document with <br>
variable substitutions. However, here we do not use a plain
cat but a sed instead, since we need to do some further
editing on-the-fly. We&rsquo;ll see why later on, so
let&rsquo;s forget <br>
about it right now.</p>

<p style="margin-top: 1em">We now reach the leading
comment, and the file is tagged with the configuration time,
the target system, etc... (those variables coming from the
sourced config.sh file have been <br>
set up by Configure). That comment header is followed by a
&rsquo;#ifndef&rsquo; protection to guard against multiple
inclusions of this file. Then comes the heart of the
file...</p>

<p style="margin-top: 1em">It helps to know that $d_* and
$i_* variables are set to either &rsquo;define&rsquo; or
&rsquo;undef&rsquo; by Configure, depending on whether a
function or an include file is present on the system or <br>
not. That means the:</p>

<p style="margin-top: 1em">#$d_bcopy HAS_BCOPY /**/</p>

<p style="margin-top: 1em">line will be expanded to
either:</p>

<p style="margin-top: 1em">#define HAS_BCOPY /**/</p>

<p style="margin-top: 1em">if the $d_bcopy variable is set
to &rsquo;define&rsquo; or:</p>

<p style="margin-top: 1em">#undef HAS_BCOPY /**/</p>

<p style="margin-top: 1em">if $d_bcopy was set to
&rsquo;undef&rsquo;, because the feature was not there.
However, that&rsquo;s not what gets written in the config.h
file because of the sed filter we have already seen, <br>
which will transform the second form into:</p>

<p style="margin-top: 1em">/*#define HAS_BCOPY /**/</p>

<p style="margin-top: 1em">That&rsquo;s a handy form for
later editing of config.h because you only need to remove
the leading &rsquo;/*&rsquo; if you want to override
Configure&rsquo;s choice. Likewise, you may add a single
<br>
&rsquo;/*&rsquo; at the beginning of a &rsquo;#define&rsquo;
line to avoid the definition of a particular symbol. This is
why each symbol definition is protected by a trailing
&rsquo;/**/&rsquo;, to close the lead&acirc; <br>
ing comment opened by &rsquo;/*&rsquo; (comments are not
nested in C).</p>

<p style="margin-top: 1em">Now transforming
&rsquo;#undef&rsquo; into &rsquo;/*#define&rsquo; is nice,
but if we want to actually write a &rsquo;#undef&rsquo;,
we&rsquo;re stuck... unless we write it as
&rsquo;#un-def&rsquo; and let sed fix that to
&rsquo;#undef&rsquo; <br>
while producing config.h, which is what is actually done
here.</p>

<p style="margin-top: 1em">The same kind of reasoning
applies to those two lines:</p>

<p style="margin-top: 1em">#$d_dup2 HAS_DUP2 /**/ <br>
#$i_string I_STRING /**/</p>

<p style="margin-top: 1em">and assuming config.sh
defines:</p>

<p style="margin-top: 1em">d_dup2=&rsquo;define&rsquo; <br>
i_string=&rsquo;undef&rsquo;</p>

<p style="margin-top: 1em">we&rsquo;ll get in the produced
config.h:</p>

<p style="margin-top: 1em">#define HAS_DUP2 /**/ <br>
/*#define I_STRING /**/</p>

<p style="margin-top: 1em">Clear as running water?
Good!</p>

<p style="margin-top: 1em">Now it should be obvious that by
including config.h in all your C source files, you get to
know what Configure has guessed on your system. In effect,
by using those symbols, you <br>
are writing configured C code, since metaconfig will know
that you need those symbols and will generate a suitable
config_h.SH file as well as all the necessary code in
Configure <br>
to compute a proper value for them (by assigning values to
associated shell variables).</p>

<p style="margin-top: 1em">Running Metaconfig <br>
Let&rsquo;s focus on the metaconfig program for a while to
understand how it uses its units and your source code to
produce all the needed configuration files. If you intend to
write <br>
new units, you should have a good understanding of the whole
scheme.</p>

<p style="margin-top: 1em">If there is no MANIFEST.new
file, metaconfig will try to use the MANIFEST file instead,
for convenience. Everywhere we mention MANIFEST.new, it can
be understood as MANIFEST <br>
provided there is no MANIFEST.new file found at the root of
your package.</p>

<p style="margin-top: 1em">Assuming your MANIFEST.new file
is properly set and lists all the source files you wish to
configure, and that you have run packint in your root source
directory to create a <br>
.package file, you may run metaconfig and you&rsquo;ll get
the following:</p>

<p style="margin-top: 1em">$ metaconfig <br>
Locating units... <br>
Extracting dependency lists from 312 units... <br>
Extracting filenames (*.[chyl] and *.SH) from
MANIFEST.new... <br>
Building a Wanted file... <br>
Scanning .[chyl] files for symbols... <br>
Scanning .SH files for symbols... <br>
Computing optimal dependency graph... <br>
Building private make file... <br>
Determining loadable units... <br>
Updating make file... <br>
Determining the correct order for the units... <br>
Creating Configure... <br>
Done.</p>

<p style="margin-top: 1em">The first phase looks for all
the units files (ending with .U) in the public directory
first, then in your private one. If you copy a public file
in your private U directory <br>
(i.e. a directory named U at the top level of your package),
it will override the public version. Once it has a list of
all the available units, it parses them and extracts all
<br>
the ?MAKE: lines to know about the dependencies and the
known shell symbols. It also focuses on the ?H: lines to
learn about the C symbols and which shell symbols needs to
be <br>
computed to get a proper value for that C symbol (so we have
another level of dependencies here).</p>

<p style="margin-top: 1em">Next, the proper filenames are
extracted from the MANIFEST.new files and a Wanted file is
built: that file lists all the C symbols and the shell
symbols needed for that package. <br>
We first scan the C-type files for C symbols, then propagate
the dependencies to their associated shell symbols (gathered
from ?H: lines). Next .SH files are scanned and finally <br>
all the shell symbols are known.</p>

<p style="margin-top: 1em">A temporary Makefile is built
and metaconfig tries to make all the shell symbols to see
what commands (listed on the second ?MAKE: lines) are
executed, and thus which units are <br>
really needed. Optional units not otherwise required are
removed and a second Makefile is generated. This time, we
know about all the units and their respective orders,
optional <br>
units having been removed and default values computed for
their shell symbols. The Configure script can then be
generated, along with config_h.SH. We&rsquo;re done.</p>

<p style="margin-top: 1em">Conventions <br>
Proper conventions needs to be followed to make the whole
process sound. There is a case convention for units and a
variable naming convention.</p>

<p style="margin-top: 1em">All units should have their
first letter lower-cased, unless they are special units. By
special, we mean they do not really define new shell
variables that can be used by the <br>
user in his .SH files, but rather units producing scripts or
shell variables that are to be used internally by the
Configure script. Typical examples are the Init.U file which
is <br>
the main variable initialization, or Myread.U which produces
the myread script used almost everywhere in Configure when a
question is to be asked to the user.</p>

<p style="margin-top: 1em">Non-special units then subdivise
in two distinct groups: units defining variables associated
to a C symbol and units defining shell variables of their
own. The first group is <br>
further divided in variables related to include files (their
name begin with i_) and variables related to other
definitions (name starting with d_). The second group have
names <br>
standing for itself, for instance cc.U defines the $cc shell
variable whose value is the C compiler to be used.</p>

<p style="margin-top: 1em">Special units sometimes reserve
themselves some pre-defined variable and return
&quot;results&quot; in other well-known variables. For
instance, the myread script produced by Myread.U <br>
expects the prompt in $rp, the default answer in $dflt and
places the user answer in $ans. This is not documented in
this manual page: you have to go and look at the unit itself
<br>
to understand which variables are used and how the unit is
to be used.</p>

<p style="margin-top: 1em">Using The Glossary <br>
The Glossary file is automatically produced by the makegloss
script, which extracts the information from ?S:, ?C: and
?MAKE: lines and reformats them into an alphabetically <br>
sorted glossary. It is important to read the Glossary to
know about the symbols you are allowed to use. However, the
Glossary will not tell you how to use them. Usually,
that&rsquo;s <br>
up to you.</p>

<p style="margin-top: 1em">One day, you will probably write
your own units and you will know enough about metaconfig to
do so quickly and efficiently. However, never forget to
properly document your work <br>
in the ?S: and ?C: lines, or other people will not be able
to reuse it. Remember about the time where you had only the
Glossary and this manual page to get started.</p>

<p style="margin-top: 1em">Conclusion <br>
Now that you know the metaconfig basics, you should read the
DESCRIPTION section, then skip to the REFERENCE section to
learn about all the gory details such as the allowed
syn&acirc; <br>
tax for unit control lines (lines starting with a
&rsquo;?&rsquo;) or the distinct MAKE commands you are
allowed to use.</p>

<p style="margin-top: 1em">REFERENCE <br>
This section documents the internals of metaconfig,
basically the unit syntax, the special units you should know
about and the hint files.</p>

<p style="margin-top: 1em">General Unit Syntax <br>
A metaconfig unit is divided into two distinct parts. The
header section (lines starting with &rsquo;?&rsquo;) and a
shell section (code to be included in the Configure script).
It is possi&acirc; <br>
ble to add &rsquo;?X:&rsquo; comments anywhere within the
unit, but the other &rsquo;?&rsquo; lines (also called
control lines) have a strict ordering policy.</p>

<p style="margin-top: 1em">If a control line is too long,
it is possible to use a continuation by escaping the final
new-line with a backslash and continuing on the next line
(which should then be indented <br>
by spaces or tabs).</p>

<p style="margin-top: 1em">The following is a formal
description of each of the control lines. Unless stated
otherwise, the order of this presentation is the order to be
used within the unit.</p>

<p style="margin-top: 1em">?RCS: free text <br>
To be used for RCS comments, at the top of the unit.</p>

<p style="margin-top: 1em">?X: any text <br>
General purpose comments. May appear anywhere in the unit
but must be left justfied. For RCS comments, please use the
?RCS: comment form.</p>

<p style="margin-top: 1em">?MAKE:symbol list: dependency
list [+optional] <br>
This is the first dependency line. The first symbol list
should list all the symbols built by this unit (i.e. whose
value is computed by the shell section of the unit).
Sym&acirc; <br>
bols should be space separated. If a defined symbol is for
internal use only and should not appear in the generated
config.sh file, then it should be preceded by a
&rsquo;+&rsquo; (not <br>
to be confused with optional dependencies defined
hereafter). The second part of the list (after the middle
&rsquo;:&rsquo;) is the unit dependency. It should list all
the needed spe&acirc; <br>
cial units, as well as all the symbols used by the shell
implementation. If a symbol is nedded but its configuration
value is not critical, it can be preceded by a
&rsquo;+&rsquo;, in <br>
which case it is called a conditional dependency: its
corresponding unit will be loaded if, and only if, that
symbol is otherwise really wanted; otherwise the default
value <br>
will be used.</p>

<p style="margin-top: 1em">?MAKE:tab command <br>
There can be one or more command lines following the initial
dependency lines. Those commands will be executed when the
unit is wanted to load them into Configure. See the <br>
paragraph about make commands for more information. Note
that the leading tab character is required before the
command.</p>

<p style="margin-top: 1em">?Y:layout <br>
Declare a layout directive for this unit. That directive may
be one of the strings top, default or bottom (case does not
matter, recommended style is to spell them out <br>
uppercased). If omitted, default is assumed.</p>

<p style="margin-top: 1em">This directive is only required
if you wish to force a unit at the top or the bottom of the
generated Configure script, as unit dependencies permit it.
Important questions <br>
may thus be forced at the beginning. Within the same layout
class, units are sorted alphabetically with two special
cases for d_* and i_* units, forced respectively at the <br>
top and bottom of their classes (but these should belong to
the default class).</p>

<p style="margin-top: 1em">It you force at the top a unit
whose dependencies require all the other unit to precede it,
you achieve nothing interesting. Therefore, that directive
should really be used <br>
to increase the priority of some interactive units that do
not depend on many other user-visible symbols, like
path-related questions.</p>

<p style="margin-top: 1em">?S:symbol_name [(obsolete symbol
list)]: <br>
Introduces a shell symbol. This first line names the symbol,
optionally followed by a list enclosed between parenthesis
and giving the obsolete equivalent. Those obsolete <br>
symbols will be remapped to the new symbol_name if the -o
option is given to metaconfig.</p>

<p style="margin-top: 1em">?S:any text, for Glossary <br>
Basically a comment describing the shell symbol, which will
be extracted by makegloss into the Glossary file.</p>

<p style="margin-top: 1em">?S:. Closes the shell symbol
comment.</p>

<p style="margin-top: 1em">?C:symbol_name [~ alias]
[(obsolete symbol list)]: <br>
Introduces a new C symbol. The alias name is the name under
which the C symbol will be controlled, i.e. if the alias
symbol is wanted, then that C symbol will be written in <br>
the config_h.SH file. Usually, the alias is just
&rsquo;%&lt;&rsquo; (stands for the unit&rsquo;s name) and
there is also a ?W: line mapping a C symbol to the alias.
Also the relevant parts of <br>
the ?H: lines are explicitly protected by a
&rsquo;?%&lt;&rsquo; condition. See the symbol aliasing
paragraph for more details. The remaining of the line is the
optional obsolete symbol <br>
list, which lists old equivalents for the new
symbol_name.</p>

<p style="margin-top: 1em">?C:any text, for Glossary and
config_h.SH <br>
Basically a comment describing the C symbol, which will be
extracted by makegloss into the Glossary file and by
metaconfig into the config_h.SH file if the symbol is wanted
<br>
(or if its alias is wanted when symbol aliasing is
used).</p>

<p style="margin-top: 1em">?C:. Closes the C symbol
comment.</p>

<p style="margin-top: 1em">?H:?symbol:config_h.SH stuff
<br>
This is the general inclusion request into config_h.SH. The
line is only written when the guarding symbol is really
wanted. This general form is needed when C symbol
alias&acirc; <br>
ing was used. Otherwise, if you use one of the other
&quot;standard&quot; forms, the guarding is automatically
done by metaconfig itself.</p>

<p style="margin-top: 1em">?H:#$d_var VAR &quot;$var&quot;
<br>
Conditionally defines the VAR C symbol into $var when is set
to &rsquo;define&rsquo;. Implies a &rsquo;?VAR:&rsquo;
guarding condition, and metaconfig automatically links VAR
to its two shell vari&acirc; <br>
able dependencies (i.e. both $d_var and $var will be flagged
as wanted if VAR is used in C sources).</p>

<p style="margin-top: 1em">?H:#define VAR [optional text]
<br>
Always defines the VAR C symbol to some value. Implies a
&rsquo;?VAR:&rsquo; guarding condition. An automatic shell
dependency is made to the unit itself.</p>

<p style="margin-top: 1em">?H:#define VAR(x,y,z) $var <br>
Always defines the macro VAR to be the value of the $var
variable. It is up to the unit to ensure $var holds a
sensible value. An automatic dependency between the C macro
<br>
VAR and the shell variable is established, and the whole
line is guarded by an implicit &rsquo;?VAR:&rsquo;.</p>

<p style="margin-top: 1em">?H:#$d_var VAR <br>
Conditionally defines VAR if $d_var is set to
&rsquo;define&rsquo;. Implies a &rsquo;?VAR:&rsquo; guarding
condition. An automatic shell dependency is generated
towards $d_war.</p>

<p style="margin-top: 1em">?H:#define VAR &quot;$var&quot;
<br>
Assigns a configured value to the VAR C symbol. Implies a
&rsquo;?VAR:&rsquo; gurading condition. An automatic shell
dependency is generated to link VAR and $var.</p>

<p style="margin-top: 1em">?H:. Closes the config_h.SH
inclusion requests.</p>

<p style="margin-top: 1em">?M:C symbol: C dependencies <br>
Introduces magic definition concerning the C symbol, for
confmagic.h, and defines the guarding symbol for the
remaining ?M: definitions. This line silently implies
&rsquo;?W:%&lt;:C <br>
symbol&rsquo;, i.e. the unit will be loaded into Configure
if the C symbol appears within the C sources, whether magic
is used or not. The C dependencies are activated when magic
<br>
is used, in order to force their definition in config_h.SH.
However, if magic is not used but the C symbol appears in
the source without the needed C dependencies, you will <br>
be warned every time the Wanted file is built, since it may
be a portability issue (and also because the unit is
unconditionally loaded into Configure whenever the C symbol
<br>
is used, regardless of the other ?C: lines from the
unit).</p>

<p style="margin-top: 1em">?M:cpp defs <br>
Defines the magic cpp mapping to be introduced in
confmagic.h whenever the concerned symbol is used. There is
an implicit &rsquo;?sym&rsquo; guarding where sym is the
symbol name <br>
defined by the leading ?M: line.</p>

<p style="margin-top: 1em">?M:. Closes the confmagic.h
inclusion request.</p>

<p style="margin-top: 1em">?W:shell symbol list:C symbol
list <br>
Ties up the destiny of the shell symbols with that of the C
symbols: if any of the C symbols listed is wanted, then all
the shell symbols are marked as wanted. Useful to <br>
force inclusion of a unit (shell symbol list set to
&rsquo;%&lt;&rsquo;) when the presence of some C symbol is
detected. The shell symbol list may be left empty, to
benefit from the side <br>
effect of C symbol location within the builtin pre-processor
(symbol being defined for that pre-processor if located in
the source). To look for patterns with a space in <br>
them, you need to quote the C symbols within simple quotes,
as in &rsquo;struct timezone&rsquo;.</p>

<p style="margin-top: 1em">?V:read-only symbols:read-write
symbols <br>
This is a metalint hint and should be used only in special
units exporting some shell variables. The variables before
the middle &rsquo;:&rsquo; are exported read-only (changing
them <br>
will issue a warning), while other symbols may be freely
read and changed.</p>

<p style="margin-top: 1em">?F:files created <br>
This line serves two purposes: it is a metalint hint, and
also a placeholder for future jmake use. It must list three
kind of files: the temporary one which are created for <br>
a test, the private UU ones created in the UU directory for
later perusal, and the public ones left in the root
directory of the package. Temporary files must be listed
with <br>
a preceding &rsquo;!&rsquo; character (meaning &quot;no!
they&rsquo;re not re-used later!&quot;), private UU files
should be preceded by a &rsquo;./&rsquo; (meaning: to use
them, say ./file, not just file), and <br>
public ones should be named as-is.</p>

<p style="margin-top: 1em">?T:shell temporaries <br>
Another metalint hint. This line lists all the shell
variables used as temporaries within the shell section of
this unit.</p>

<p style="margin-top: 1em">?D:symbol=&rsquo;value&rsquo;
<br>
Initialization value for symbols used as conditional
dependencies. If no ?D: line is found, then a null value is
used instead. The metalint program will warn you if a symbol
<br>
is used at least once as a conditional dependency and does
not have a proper ?D: initialization. It&rsquo;s a good
practice to add those lines even for a null initialization
since <br>
it emphasizes on the possibly optional nature of a
symbol.</p>

<p style="margin-top: 1em">?O:any message you want <br>
This directive indicates that this unit is obsolete as a
whole. Whenever usage of any of its symbols is made (or
indirect usage via dependencies), the message is output on
<br>
the screen (on stderr). You can put one ore more lines, in
which case each line will be printed, in order.</p>

<p style="margin-top: 1em">?LINT:metalint hints <br>
See the metalint manual page for an explaination of the
distinct hints that can be used.</p>

<p style="margin-top: 1em">?INIT:initialization code <br>
The initialization code specified by this line will be
loaded at the top of the Configure script provided the unit
is needed.</p>

<p style="margin-top: 1em">C Symbol Aliasing <br>
Sometimes it is not possible to rely on metaconfig&rsquo;s
own default selection for config_h.SH comments and C symbol
definition. That&rsquo;s where aliasing comes into play.
Since it&rsquo;s <br>
rather tricky to explain, we&rsquo;ll study an example to
understand the underlying mechanism.</p>

<p style="margin-top: 1em">The d_const.U unit tries to
determine whether or not your C compiler known about the
const keyword. If it doesn&rsquo;t we want to remap that
keyword to a null string, in order to let <br>
the program compile. Moreover, we want to automatically
trigger the test when the const word is used.</p>

<p style="margin-top: 1em">Here are the relevant parts of
the d_const.U unit:</p>

<p style="margin-top: 1em">?MAKE:d_const: cat cc ccflags
Setvar <br>
?MAKE: -pick add $@ %&lt; <br>
?S:d_const: <br>
?S: This variable conditionally defines the HASCONST symbol,
which <br>
?S: indicates to the C program that this C compiler knows
about the <br>
?S: const type. <br>
?S:. <br>
?C:HASCONST ~ %&lt;: <br>
?C: This symbol, if defined, indicates that this C compiler
knows about <br>
?C: the const type. There is no need to actually test for
that symbol <br>
?C: within your programs. The mere use of the
&quot;const&quot; keyword will <br>
?C: trigger the necessary tests. <br>
?C:. <br>
?H:?%&lt;:#$d_const HASCONST /**/ <br>
?H:?%&lt;:#ifndef HASCONST <br>
?H:?%&lt;:#define const <br>
?H:?%&lt;:#endif <br>
?H:. <br>
?W:%&lt;:const <br>
?LINT:set d_const <br>
?LINT:known const <br>
: check for const keyword <br>
echo &quot; &quot; <br>
echo &rsquo;Checking to see if your C compiler knows about
&quot;const&quot;...&rsquo; &gt;&amp;4 <br>
/bin/cat &gt;const.c &lt;&lt;&rsquo;EOCP&rsquo; <br>
main() <br>
{ <br>
const char *foo; <br>
} <br>
EOCP <br>
if $cc -c $ccflags const.c &gt;/dev/null 2&gt;&amp;1 ; then
<br>
val=&quot;$define&quot; <br>
echo &quot;Yup, it does.&quot; <br>
else <br>
val=&quot;$undef&quot; <br>
echo &quot;Nope, it doesn&rsquo;t.&quot; <br>
fi <br>
set d_const <br>
eval $setvar</p>

<p style="margin-top: 1em">First we notice the use of a ?W:
line, which basically says: &quot;This unit is wanted when
the const keyword is used in a C file.&quot;. In order to
conditionally remap const to a null <br>
string in config.h, I chose to conditionally define HASCONST
via $d_const.</p>

<p style="margin-top: 1em">However, this raises a problem,
because the HASCONST symbol is not going to be used in the
sources, only the const token is. And the ?H: line defining
HASCONST is implicitely <br>
guarded by &rsquo;?HASCONST&rsquo;. Therefore, we must add
the explicit &rsquo;?%&lt;&rsquo; constraint to tell
metaconfig that those lines should be included in
config_h.SH whenever the &rsquo;%&lt;&rsquo; symbol gets
<br>
wanted (%&lt; refers to the unit&rsquo;s name, here
d_const).</p>

<p style="margin-top: 1em">That&rsquo;s almost perfect,
because the ?W: line will want d_const whenever const is
used, then the ?H: lines will get included in the
config_h.SH file. However, the leading comment <br>
(?C: lines) attached to HASCONST is itself also guarded via
HASCONST, i.e. it has an implicit &rsquo;?HASCONST&rsquo;
constraint. Hence the need for aliasing the HASCONST symbol
to &rsquo;%&lt;&rsquo;.</p>

<p style="margin-top: 1em">The remaining part of the unit
(the shell part) is really straightforward. It simply tries
to compile a sample C program using the const keyword. If it
can, then it will define <br>
$d_const via the $setvar fonction (defined by the Setvar.U
unit). See the paragraph about special units for more
details.</p>

<p style="margin-top: 1em">Make Commands <br>
On the ?MAKE: command line, you may write a shell command to
be executed as-is or a special -pick command which is
trapped by metaconfig and parsed to see what should be done.
<br>
The leading &rsquo;-&rsquo; is only there to prevent make
from failing when the command returns a non-zero status --
it&rsquo;s not really needed since we use &rsquo;make
-n&rsquo; to resolve the dependen&acirc; <br>
cies, but I advise you to keep it in case it becomes
mandatory in future versions. The syntax of the pick command
is:</p>

<p style="margin-top: 1em">-pick cmd $@ target_file</p>

<p style="margin-top: 1em">where $@ is the standard macro
within Makefiles standing for the current target (the name
of the unit being built, with the final .U extension
stripped). The cmd part is the <br>
actual metaconfig command to be run, and the target_file is
yet another parameter, whose interpretation depends on the
cmd itself. It also has its final .U extension stripped and
<br>
normally refers to a unit file, unless it start with
&rsquo;./&rsquo; in which case it references one of the
metaconfig control files in the &rsquo;.MT directory.</p>

<p style="margin-top: 1em">The available commands are:</p>

<p style="margin-top: 1em">add Adds the target_file to
Configure.</p>

<p style="margin-top: 1em">add.Config_sh <br>
Fills in that part of Configure producing the config.sh
file. Only used variables are added, conditional ones (from
conditional dependencies) are skipped.</p>

<p style="margin-top: 1em">add.Null Adds the section
initializing all the shell variables used to an empty
string.</p>

<p style="margin-top: 1em">c_h_weed Produces the
config_h.SH file. Only the necessary lines are printed.</p>

<p style="margin-top: 1em">cm_h_weed Produces the
confmagic.h file. Only the necessary lines are printed. This
command is only enabled when the -M switch is given, or when
a confmagic.h file already <br>
exists.</p>

<p style="margin-top: 1em">close.Config_sh <br>
Adds the final &rsquo;EOT&rsquo; symbol on a line by itself
to end the here document construct producing the config.sh
file.</p>

<p style="margin-top: 1em">prepend Prepends the content of
the target to the target_file if that file is not empty.</p>

<p style="margin-top: 1em">weed Adds the unit to Configure
like the add command, but make some additional tests to
remove the &rsquo;?symbol&rsquo; and &rsquo;%symbol&rsquo;
lines from the target_file if the symbol is not <br>
wanted or conditionally wanted. The &rsquo;%&rsquo; form is
only used internally by metaconfig while producing its own
.U files in the &rsquo;.MT&rsquo; directory.</p>

<p style="margin-top: 1em">wipe Same as add really, but
performs an additional macro substitution. The available
macros are described in the Hardwired Macros paragraph.</p>

<p style="margin-top: 1em">As a side note, metaconfig
generates a -cond command internally to deal with
conditional dependencies. You should not use it by yourself,
but you will see it if scanning the gen&acirc; <br>
erated Makefile in the .MT directory.</p>

<p style="margin-top: 1em">Hardwired Macros <br>
The following macros are recognized by the wipe command and
subsituted before inclusion in Configure:</p>

<p style="margin-top: 1em">&lt;BASEREV&gt; The base
revision number of the package, derived from .package.</p>

<p style="margin-top: 1em">&lt;DATE&gt; The current
date.</p>

<p style="margin-top: 1em">&lt;MAINTLOC&gt; <br>
The e-mail address of the maintainer of this package,
derived from your .package.</p>

<p style="margin-top: 1em">&lt;PACKAGENAME&gt; <br>
The name of the package, as derived from your .package
file.</p>

<p style="margin-top: 1em">&lt;PATCHLEVEL&gt; <br>
The patch level of the metaconfig program (deprecated in
favor of &lt;REVISION&gt;).</p>

<p style="margin-top: 1em">&lt;REVISION&gt; <br>
The SVN revision level of the metaconfig program.</p>

<p style="margin-top: 1em">&lt;VERSION&gt; The version
number of the metaconfig program.</p>

<p style="margin-top: 1em">Those macros are mainly used to
identify the metaconfig version that generated a particular
Configure script and for which package it was done. The
e-mail address of the main&acirc; <br>
tainer is hardwired in the leading instructions that
Configure prints when starting.</p>

<p style="margin-top: 1em">Recent metaconfig versions
understand a much more general syntax of the form:</p>

<p style="margin-top: 1em">&lt;$variable&gt;</p>

<p style="margin-top: 1em">which is replaced at
Configure-generation time by the value of variable taken
from your .package file. Eventually, the old hardwired macro
format will disappear, and &lt;$baserev&gt; <br>
will replace &lt;BASEREV&gt; in all the supplied units.</p>

<p style="margin-top: 1em">Special Units <br>
The following special units are used to factorize code and
provide higher level functionalities. They either produce a
shell script that can be sourced or a shell variable that
<br>
can be eval&rsquo;ed. Parameter passing is done via
well-know variables, either named or anonymous like $1, $2,
etc... (which can be easily set via the shell set operator).
When Con&acirc; <br>
figure executes, it creates and goes into a UU directory, so
every produced script lies in there and does not interfere
with the files from your package.</p>

<p style="margin-top: 1em">Here are the sepcial units that
you should know about, and the way to use them.</p>

<p style="margin-top: 1em">Cppsym.U <br>
This unit produces a shell script called Cppsym, which can
be used to determine whether any symbol in a list is defined
by the C preprocessor or C compiler you have speci&acirc;
<br>
fied. It can determine the status of any symbol, though the
symbols in (attribute list) are more easily determined.</p>

<p style="margin-top: 1em">Csym.U <br>
This sets the $csym shell variable, used internally by
Configure to check whether a given C symbol is defined or
not. A typical use is:</p>

<p style="margin-top: 1em">set symbol result [-fva]
[previous] <br>
eval $csym</p>

<p style="margin-top: 1em">That will set the result
variable to &rsquo;true&rsquo; if the function [-f],
variable [-v] or array [-a] is defined, &rsquo;false&rsquo;
otherwise. If a previous value is given and the -r switch
<br>
was provided to Configure (see the Configure Options
paragraph), then that value is re-used without
questioning.</p>

<p style="margin-top: 1em">The way this computation is done
depends on the answer the user gives to the question
Configure will ask about whether it should perform an nm
extraction or not. If the <br>
exctraction was performed, the unit simply looks through the
symbol list, otherwise it performs a compile-link test,
unless -r was given to reuse the previously computed <br>
value, naturally...</p>

<p style="margin-top: 1em">End.U <br>
By copying this unit into your private U directory and
appending dependencies on the ?MAKE: line, you can force a
given unit to be loaded into Configure even if it is not
<br>
otherwise wanted. Some units may only be forced into
Configure that way.</p>

<p style="margin-top: 1em">Filexp.U <br>
This unit produces a shell script filexp which will expand
filenames beginning with tildes. A typical use is:</p>

<p style="margin-top: 1em">exp_name=&lsquo;./filexp
$name&lsquo;</p>

<p style="margin-top: 1em">to assign the expanded file name
in exp_name.</p>

<p style="margin-top: 1em">Findhdr.U <br>
This unit produces a findhdr script which is used to locate
the header files in $usrinc or other stranger places using
cpp capabilities. The script is given an include file <br>
base name like &rsquo;stdio.h&rsquo; or
&rsquo;sys/file.h&rsquo; and it returns the full path of the
inlcude file and a zero status if found, or an empty string
and a non-zero status if the file <br>
could not be located.</p>

<p style="margin-top: 1em">Getfile.U <br>
This unit produces a bit of shell code that must be sourced
in order to get a file name and make some sanity checks.
Optionally, a ~name expansion is performed.</p>

<p style="margin-top: 1em">To use this unit, $rp and $dflt
must hold the question and the default answer, which will be
passed as-is to the myread script (see forthcoming
Myread.U). The $fn variable <br>
controls the operation and the result is returned into
$ans.</p>

<p style="margin-top: 1em">To locate a file or directory,
put &rsquo;f&rsquo; or &rsquo;d&rsquo; in f~/. If a
&rsquo;~&rsquo; appears, then ~name substitution is allowed.
If a &rsquo;/&rsquo; appears, only absolute pathnames are
accepted and ~name <br>
subsitutions are always expanded before returning. If
&rsquo;+&rsquo; is specified, existence checks are skipped.
If &rsquo;n&rsquo; appears within $fn, then the user is
allowed to answer &rsquo;none&rsquo;.</p>

<p style="margin-top: 1em">Usually, unless you asked for
portability, ~name substitution occurs when requested.
However, there are some times you wish to bypass portability
and force the substitution. <br>
You may use the &rsquo;e&rsquo; letter (expand) to do
that.</p>

<p style="margin-top: 1em">If the special &rsquo;l&rsquo;
(locate) type is used, then the $fn variable must end with a
&rsquo;:&rsquo;, followed by a file basename. If the answer
is a directory, the file basename will be <br>
appended before testing for file existence. This is useful
in locate-style questions like this:</p>

<p style="margin-top: 1em">dflt=&rsquo;~news/lib&rsquo;
<br>
: no need to specify &rsquo;d&rsquo; or &rsquo;f&rsquo; when
&rsquo;l&rsquo; is used <br>
fn=&rsquo;l~:active&rsquo; <br>
rp=&rsquo;Where is the active file?&rsquo; <br>
. ./getfile <br>
active=&quot;$ans&quot;</p>

<p style="margin-top: 1em">Additionally, the
&rsquo;p&rsquo; (path) letter may be used in conjunction
with &rsquo;l&rsquo; to tell getfile that an answer without
a &rsquo;/&rsquo; in it should be accepted, assuming that it
will be in <br>
everyone&rsquo;s PATH at the time this value will be
needed.</p>

<p style="margin-top: 1em">Also useful is the possibility
to specify a list of answers that should be accepted
verbatim, bypassing all the checks. This list must be within
parenthesis and items must <br>
be comma separated, with no interleaving spaces. Don&rsquo;t
forget to quote the resulting string since parenthesis are
meaningful to the shell. For instance:</p>

<p style="margin-top: 1em">dflt=&rsquo;/bin/install&rsquo;
<br>
fn=&rsquo;/fe~(install,./install)&rsquo; <br>
rp=&rsquo;Use which install program?&rsquo; <br>
. ./getfile <br>
install=&quot;$ans&quot;</p>

<p style="margin-top: 1em">would let the user only specify
fully qualified paths referring to existing files, but still
allow the special &quot;install&quot; and
&quot;./install&quot; answers as-is (assuming of course <br>
something will deal with them specially later on in the
chain since they do not conform with the general expected
frame).</p>

<p style="margin-top: 1em">If the answer to the question is
&rsquo;none&rsquo;, then the existence checks are skipped
and the empty string is returned. Note that since getfile
calls myread internally, all the <br>
features available with myread apply here to.</p>

<p style="margin-top: 1em">If a completely expanded value
is needed (for instance in a Makefile), you may use the
$ansexp variable which is always set up properly by getfile
as the expanded version of <br>
$ans. Of course, it will not expand ~name if you did not
allow that in the first place in the $fn variable.</p>

<p style="margin-top: 1em">Inhdr.U <br>
This unit produces the $inhdr shell variable, used
internally by Configure to check whether a set of headers
exist or not. A typical use is:</p>

<p style="margin-top: 1em">set header i_header [ header2
i_header2 ... ] <br>
eval $inhdr</p>

<p style="margin-top: 1em">That will print a message,
saying whether the header was found or not and set the
i_header variable accordingly. If more than one header is
specified and the first header is <br>
not found, we try the next one, until the list is empty or
one is found.</p>

<p style="margin-top: 1em">Inlibc.U <br>
This unit produces the $inlibc shell variable, used
internally by Configure to check whether a given C function
is defined or not. A typical use is:</p>

<p style="margin-top: 1em">set function d_func <br>
eval $inlibc</p>

<p style="margin-top: 1em">That will print a message,
saying whether the function was found or not and set $d_func
accordingly. Internally, it used the $csym routine.</p>

<p style="margin-top: 1em">Loc.U <br>
This important unit produces a shell script loc which can be
used to find out where in a list of directories a given file
lies. The first argument specifies the file to be <br>
located, the second argument is what will be returned if the
search fails, and the reamining arguments are a list of
directories where the file is to be searched. For <br>
instance:</p>

<p style="margin-top: 1em">dflt=&lsquo;./loc sendmail.cf X
/usr/lib /var/lib/sendmail /lib&lsquo;</p>

<p style="margin-top: 1em">would set $dflt to X if no
sendmail.cf file was found under the listed directories, or
something like /usr/lib/sendmail.cf on some systems. See
also Getfile.U.</p>

<p style="margin-top: 1em">MailAuthor.U <br>
This unit needs to be included on the ?MAKE: line of your
own private End.U to make it into Configure. It offers the
user to register himself to the author, optionally being
<br>
notified when new patches arrive or receiving them
automatically when issued. You need to install mailagent to
do this (at least version 3.0).</p>

<p style="margin-top: 1em">MailList.U <br>
This unit needs to be included on the ?MAKE: line of your
own private End.U to make it into Configure. It offers the
user to subscribe or unsubscribe to a mailing list where
<br>
discussion related to the package are taking place. You need
to run packinit and answer the mailing list related
questions to set up the proper variables in your .package
<br>
before this unit may become operational.</p>

<p style="margin-top: 1em">Myinit.U <br>
Copy this unit into your private U directory to add your own
default values to some internal variables. This unit is
loaded into Configure after all the default
initializa&acirc; <br>
tions have been done.</p>

<p style="margin-top: 1em">Myread.U <br>
This unit produces the myread shell script that must be
sourced in order to do a read. It allows shell escapes,
default assignment and parameter evaluation, as documented
in <br>
the Instruct.U unit. It also allows dynamic setting of the
-d option, which will be used for the remaining of the
script execution.</p>

<p style="margin-top: 1em">To use this unit, $rp must hold
the question and $dflt should contain the default answer.
The question will be printed by the script itself, and the
result is returned in <br>
the $ans variable.</p>

<p style="margin-top: 1em">Here is a typical usage:</p>

<p style="margin-top: 1em">dflt=&rsquo;y&rsquo; <br>
rp=&rsquo;Question?&rsquo; <br>
. ./myread <br>
value=&quot;$ans&quot;</p>

<p style="margin-top: 1em">See the unit itself for more
information.</p>

<p style="margin-top: 1em">Oldconfig.U <br>
This unit must be part of your dependency ?MAKE: line when
some of your units tries to reuse an old symbol value. This
unit is responsible for getting the old answers from <br>
config.sh or providing useful hints when running on a given
platform for the first time. See the Configure Hints
paragraph for more information about hints.</p>

<p style="margin-top: 1em">Prefixit.U <br>
The purpose of this unit is to detect changes in the
installation prefix directory to recompute automatically
suitable defaults from previous answers. It relies on the
<br>
value of the $oldprefix variable which holds the previous
prefix directory when it changed, and is empty otherwise.
For instance, if the prefix was changed from /opt to <br>
/usr/local, then the previous binary installation directory
will be changed from /opt/bin to /usr/local/bin, or will
remain unchanged if it was, say, /bin.</p>

<p style="margin-top: 1em">You need to call set before
issuing an eval on $prefixit, such as:</p>

<p style="margin-top: 1em">set dflt var [dir] <br>
eval $prefixit</p>

<p style="margin-top: 1em">which would set $dflt to $var or
$prefix/dir depending on whether the prefix remained the
same or not. If dir is the string none, a single space value
in $dflt is kept as- <br>
is, even when the prefix changes. If dir is omitted, then
$dflt is set to an empty string if the prefix changed, to
$var otherwise.</p>

<p style="margin-top: 1em">Prefixup.U <br>
The intent of thit unit is similar to that of Prefixit.U,
i.e. it helps fixing the default string to accommodate
prefix changes. However, the shell variable $prefixup, when
<br>
evaluated, will only restore ~name expansions, should prefix
use such an escape mechanism. Use it as:</p>

<p style="margin-top: 1em">set dflt <br>
eval $prefixup</p>

<p style="margin-top: 1em">before prompting via getfile for
instance. If the prefix does not make use of ~name
expanstion, then the above will be a no-op on the y
variable, naturally.</p>

<p style="margin-top: 1em">Typedef.U <br>
This unit produces the $typedef shell variable, used
internally by Configure to check whether a typedef exists or
not. A typical use is:</p>

<p style="margin-top: 1em">set typedef val_t default [
includes ] <br>
eval $typedef</p>

<p style="margin-top: 1em">This will set the variable val_t
to the value of default if the typedef was not found among
the listed include files, or to typedef if found. If no
include files are speci&acirc; <br>
fied, the unit looks in &lt;sys/types.h&gt; only. If you
specifiy some includes, only those are looked at.</p>

<p style="margin-top: 1em">Unix.U <br>
The purpose of this unit is to define some of the most
common UNIX-isms via variables which can be altered from the
command line or via proper hint files. In particular, <br>
$_exe, $_o and $_a are set. All the units should refer to
$_o and not to .o directly. The &rsquo;.&rsquo; is part of
these variables.</p>

<p style="margin-top: 1em">Setvar.U <br>
This unit produces the variable, which is used internally by
Configure to set a define/undef value to a given symbol,
emitting a warning when it suddenly changes from a <br>
previous value. For instance:</p>

<p style="margin-top: 1em">val=&quot;$define&quot; <br>
set d_variable <br>
eval $setvar</p>

<p style="margin-top: 1em">If the previous $d_variable
value was non-null and $val is different, a &quot;whoa&quot;
warning is issued.</p>

<p style="margin-top: 1em">Whoa.U <br>
This unit produces the whoa script, which emits a warning
when the value in variable whose name is $var is not the
same as its old previous value held in $was. Upon return,
<br>
$td and $tu hold the proper value to define or undef the
variable. See examples in Inlibc.U.</p>

<p style="margin-top: 1em">Builtin Pre-processor <br>
Each unit to be included in Configure is ran through a
built-in pre-processor. Pre-processor statements are
introduced by the &rsquo;@&rsquo; character (&rsquo;#&rsquo;
is the shell comment character). <br>
It functions merely as the C pre-processor does but allows
for shell and perl escapes. Here are the available
functions:</p>

<p style="margin-top: 1em">@if expression <br>
If expression is true, continue loading code until @end,
@elsif or @else.</p>

<p style="margin-top: 1em">@elsif expression <br>
Alternative choice. If expression is true, continue loading
code until @end, another @elsif or @else.</p>

<p style="margin-top: 1em">@else Default code to be loaded
if the @if expression was false and none of the optional
@elsif matched. Load until @end.</p>

<p style="margin-top: 1em">@end Close the conditional
loading statement opened by @if.</p>

<p style="margin-top: 1em">@define symbol <br>
Tells the pre-processor that symbol is defined from now
on.</p>

<p style="margin-top: 1em">The conditional expression can
include symbol names (value is true if symbol is wanted or
defined via @define or shell/perl escapes. Those atoms can
be combined using the tradi&acirc; <br>
tional boolean operators &rsquo;!&rsquo; for negation,
&rsquo;&amp;&amp;&rsquo; for logical and, and
&rsquo;||&rsquo; for logical or.</p>

<p style="margin-top: 1em">Text enclosed within single
brackets is a shell test, while text between double brakets
is a perl test. Namely the expressions:</p>

<p style="margin-top: 1em">{ shell text } <br>
{{ perl text }}</p>

<p style="margin-top: 1em">are translated into:</p>

<p style="margin-top: 1em">if shell text &gt;/dev/null
2&gt;&amp;1; then exit 0; else exit 1; fi <br>
if (perl text) {exit 0;} else {exit 1;}</p>

<p style="margin-top: 1em">and the exit status is used in
the standard way to get a boolean value, i.e. 0 is true and
everything else is false. Note that only simple conditions
can be expressed in perl, <br>
until some complex code can be loaded within metaconfig and
executed.</p>

<p style="margin-top: 1em">The built-in pre-processor can
be used to finely tune some units (see d_gethname.U for a
complex example) depending on the symbols actually used by
the program or the files <br>
present in the distribution. For instance, the Oldconfig.U
uses a test like:</p>

<p style="margin-top: 1em">@if {test -d ../hints}</p>

<p style="margin-top: 1em">and Configure will contain
hint-dependent code only if there is a hints directory in
the package&rsquo;s top level directory. Note that tests are
ran from within the &rsquo;.MT&rsquo; directory, <br>
hence the needed &rsquo;../&rsquo; in the test.</p>

<p style="margin-top: 1em">The pre-processor can also be
used to avoid putting useless code when a symbol is not
defined. Units defining more than one symbol can be
protected that way (since the unit is <br>
loaded as a whole) by gathering symbol-dependent code within
an @if/@end pair. For instance:</p>

<p style="margin-top: 1em">@if I_TIME || I_SYS_TIME ||
I_SYS_TIME_KERNEL <br>
need_time_h=&rsquo;true&rsquo; <br>
@else <br>
need_time_h=&rsquo;false&rsquo; <br>
@end</p>

<p style="margin-top: 1em">will test whether the source
code makes any use of one of the three symbols that control
the time.h or sys/time.h inclusion and define the shell
symbol accordingly. That gives <br>
Configure a feedback on what the sources need and avoid the
drawback of having fixed frozen units.</p>

<p style="margin-top: 1em">Via the &rsquo;?W:&rsquo; lines,
you can get intersting combinations. For instance, the
i_time.U unit needs to know whether the C sources make any
use of the struct timezone type. Therefore, <br>
the line:</p>

<p style="margin-top: 1em">?W::timezone</p>

<p style="margin-top: 1em">is used for its side-effect of
defining the symbol timezone for the pre-processor. The unit
code can then say:</p>

<p style="margin-top: 1em">@if timezone <br>
for s_timezone in &rsquo;-DS_TIMEZONE&rsquo; &rsquo;&rsquo;;
do <br>
@else <br>
s_timezone=&rsquo;&rsquo; <br>
@end</p>

<p style="margin-top: 1em">... code using s_timezone
...</p>

<p style="margin-top: 1em">@if timezone <br>
done <br>
@end</p>

<p style="margin-top: 1em">and have an extra loop trying
two successive values for the s_timezone variable, but only
if needed.</p>

<p style="margin-top: 1em">Obsolete Symbols <br>
Obsolete symbols are preserved to ease the transition with
older metaconfig units. Unless the -o switch is passed to
metaconfig they will be ignored. However, an Obsolete file
<br>
will be generated, telling you which files are making use of
those obsolete symbols and what are the new symbols to be
used.</p>

<p style="margin-top: 1em">The lifetime for obsolete
symbols is one full revision, i.e. they will be removed when
the next base revision is issued (patch upgrades do not
count of course). Therefore, it is <br>
wise to translate your sources and start using the new
symbols as soon as possible.</p>

<p style="margin-top: 1em">Configure Hints <br>
It may happen that the internal configuration logic makes
the wrong choices. For instance, on some platform, the
vfork() system call is present but broken, so it should not
be <br>
used. It is not possible to include that knowledge in the
units themselves, because that might be a temporary problem
which the vendor will eventually fix, or something that was
<br>
introduced by a new OS upgrade.</p>

<p style="margin-top: 1em">Anyway, for all those tiny
little problems that are too system-specific, metaconfig
provides hint files support. To use it, you need to create a
hints directory in the package&rsquo;s <br>
top level directory, and have it when you run metaconfig.
That will load the hint-related part from Oldconfig.U.</p>

<p style="margin-top: 1em">From then on, you may pre-set
some of the shell variables Configure uses in an OS-specific
.sh file. There is code in Oldconfig.U that tries to guess
which hint files are needed <br>
by computing a standard name based on the system OS name,
the kernel name, the release number, etc... Since this
information is likely to change rapidly, I&rsquo;m not
documenting it <br>
here. You have to reverse engineer the code from
Oldconfig.U.</p>

<p style="margin-top: 1em">When you first release your
package, your hints file directory should be empty. If the
users of your package complain that they have problem with
Configure defaults on a partic&acirc; <br>
ular system, you have to see whether this is a
platform-specific problem or a general one. In the former
case, it&rsquo;s time to introduce a new hint file, while in
the latter, the <br>
corresponding unit should be revised.</p>

<p style="margin-top: 1em">For instance, SGI systems are
known to have a broken vfork() system call, as of this
writing. And the corresponding hint file name is sgi.sh. So
all you need to do is create a <br>
hints/sgi.sh file in which you write:</p>

<p style="margin-top: 1em">d_vfork=&quot;$define&quot;</p>

<p style="margin-top: 1em">which will always remap vfork on
fork (see d_vfork.U). When running on SGI systems for the
first time, Configure will detect that there is an
hints/sgi.sh file, and that we are <br>
on an IRIX machine (the kernel name is often /irix),
therefore it will propose sgi as a possible hint. If the
user accepts it, and since the $d_vfork value is modified
via the <br>
$setvar call, a whoa! will be emitted to warn that we are
about to override the value computed by Configure.</p>

<p style="margin-top: 1em">Note that you don&rsquo;t have
to provide all the hints known by Oldconfig.U. If a hint
file is missing, it will not be proposed as a possible
choice. The heuristic tests ran to com&acirc; <br>
pute the possible hint candidates are flaky. If you have new
values or different tests, please send them to me...</p>

<p style="margin-top: 1em">Overriding Choices <br>
If you create a config.over file in the top level directory,
Configure will ask you if you wish to load it to override
the default values. This is done prior creation of the
con&acirc; <br>
fig.sh file, so it gives you a chance to patch the values
stored in there.</p>

<p style="margin-top: 1em">This is distinct from the hints
approach in that it is a local file, which the user is free
to create for his own usage. You should not provide such a
file yourself, but let the <br>
user know about this possibility.</p>

<p style="margin-top: 1em">Configure Options <br>
The Configure script may be called with some options
specified on the command line, to slightly modify its
behaviour. Here are the allowed options:</p>

<p style="margin-top: 1em">-d Use defaults for all
answers.</p>

<p style="margin-top: 1em">-e Go on without questioning
past the production of config.sh.</p>

<p style="margin-top: 1em">-f file Use the specified file
as a default configuration. If this switch is not used, the
configuration is taken from config.sh, when present.</p>

<p style="margin-top: 1em">-h Print help message and
exit.</p>

<p style="margin-top: 1em">-r Reuse C symbols value if
possible. This will skip the costly nm symbol extraction. If
used the first time (with no previous configuration file),
Configure will try to <br>
compile and link a small program in order to know about the
presence of a symbol, or absence thereof.</p>

<p style="margin-top: 1em">-s Silent mode. Only strings
printed on file descriptor #4 will be seen on the screen
(that&rsquo;s the important messages). It&rsquo;s not
possible to completely turn off any output, <br>
but you may use &rsquo;Configure -ders &gt;/dev/null
2&gt;&amp;1&rsquo; to have a full batch run with no output
and no user interaction required.</p>

<p style="margin-top: 1em">-D symbol=value <br>
Pre-defines symbol to bear the specified value. It is also
possible to use &rsquo;-D symbol&rsquo; which will use a
default value of &rsquo;define&rsquo;.</p>

<p style="margin-top: 1em">-E Stop at the end of the
configuration questions, after having produced a config.sh.
This will not perform any &rsquo;make depend&rsquo; or .SH
files extraction.</p>

<p style="margin-top: 1em">-K Knowledgeable user. When you
use this option, you know what you are doing and therefore
the config.sh file will always be handled as if it was
intended to be re-used, <br>
even though it might have been generated on an alien system.
It also prevents aborting when Configure detects an unusable
C compiler or a wrong set of C flags. Further <br>
shortcuts might be turned on by this option as well in the
future. This option is documented in the Configure usage
message, to remind us about its existence, but the <br>
given description is hoped to be cryptic enough. :-)</p>

<p style="margin-top: 1em">-O Allow values specified via a
-D or -U to override settings from any loaded configuration
file. This is not the default behaviour since the overriding
will not be propa&acirc; <br>
gated to variables derived from those you are presently
altering. Naturally, without -O, the setting is only done
when no configuration file is loaded, which is safe <br>
since derivative variables have not been computed yet...</p>

<p style="margin-top: 1em">-S Perform variable substitution
on all the .SH files. You can combine it with the -f switch
to propagate any configuration you like.</p>

<p style="margin-top: 1em">-U symbol= <br>
Pre-sets symbol to bear an empty value. It is also possible
to use &rsquo;-U symbol&rsquo; which will set symbol to
&rsquo;undef&rsquo;.</p>

<p style="margin-top: 1em">-V Print the version number of
the metaconfig that generated this Configure script and
exit.</p>

<p style="margin-top: 1em">Running Environment <br>
Upon starting, Configure creates a local UU directory and
runs from there. The directory is removed when Configure
ends, but this means you must run the script from a place
where <br>
you can write, i.e. not from a read-only file system.</p>

<p style="margin-top: 1em">You can run Configure remotely
though, as in:</p>

<p style="margin-top: 1em">../package/Configure</p>

<p style="margin-top: 1em">to configure sources that are
not present locally. All the generated files will be put in
the directory where you&rsquo;re running the script from.
This magic is done thanks to the <br>
src.U unit, which is setting the $src and $rsrc variables to
point to the package sources. That path is full or relative,
depending on whether Configure was invoked via a full or
<br>
relative path.</p>

<p style="margin-top: 1em">From within the UU subdirectory,
you can use $rsrc to access the source files (units
referring to source files link hints shall always use this
mechanism and not assume the file <br>
is present in the parent directory). All the Makefiles
should use the $src variable as a pointer to the sources
from the top of the build directory (where Configure is
run), <br>
either directly or via a VPATH setting.</p>

<p style="margin-top: 1em">When running Configure remotely,
the .SH files are extracted in the build directory, not in
the source tree. However, it requires some kind of a make
support to be able to com&acirc; <br>
pile things in a build directory whilst the sources lie
elsewhere.</p>

<p style="margin-top: 1em">Using Magic Redefinitions <br>
By making use of the -M switch, some magic remappings may
take place within a confmagic.h file. That file needs to be
included after config.h, of course, but also after all the
<br>
other needed include files. Namely:</p>

<p style="margin-top: 1em">#include &quot;config.h&quot;
<br>
... <br>
... other inclusions ... <br>
... <br>
#include &quot;confmagic.h&quot;</p>

<p style="margin-top: 1em">Typically, confmagic.h will
attempt to remap bcopy() on memcpy() if no bcopy() is
available locally, or transform vfork into fork when
necessary, hence making it useless to <br>
bother about the HAS_VFORK symbol.</p>

<p style="margin-top: 1em">This configuration magic is
documented in the Glossary file.</p>

<p style="margin-top: 1em">Unit Templates <br>
There is a set of unit templates in the metaconfig source
directory, which are intended to be used by a (not yet
written) program to quickly produce new units for various
kind of <br>
situations. No documentation for this unfinished project,
but I thought I would mention it in the manual page in case
you wish to do it yourself and then contribute it...</p>

<p style="margin-top: 1em">AUTHORS <br>
Larry Wall &lt;lwall@netlabs.com&gt; for version 2.0. <br>
Harlan Stenn &lt;harlan@mumps.pfcs.com&gt; for important
unit extensions. <br>
Raphael Manfredi &lt;ram@hptnos02.grenoble.hp.com&gt;. <br>
Many other contributors for the metaconfig units. See the
credit file for a list.</p>

<p style="margin-top: 1em">FILES <br>
LIB/dist/mcon/U/*.U <br>
Public unit files <br>
U/*.U Private unit files <br>
LIB/dist/mcon/Glossary <br>
Glossary file, describing all the metaconfig symbols. <br>
Obsolete Lists all the obsolete symbols used by the sources.
<br>
Wanted Lists all the wanted symbols.</p>

<p style="margin-top: 1em">where LIB is
/usr/share/dist.</p>

<p style="margin-top: 1em">BUGS <br>
Units are sometimes included unnecessarily if one of its
symbols is accidentally mentioned, e.g. in a comment. Better
too many units than too few, however.</p>

<p style="margin-top: 1em">SEE ALSO <br>
pat(1), makeSH(1), makedist(1), metalint(1)</p>

<p style="margin-top: 1em">Version 3.5 PL0
METACONFIG(1)</p>
<hr>
</body>
</html>
