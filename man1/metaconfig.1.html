<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>METACONFIG(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">METACONFIG(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">METACONFIG(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
metaconfig - a Configure script generator
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>metaconfig</b> [ - <b>dhkmostvwGMV</b> ] [ - <b>L </b><i>dir</i> ]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>Metaconfig</i> is a program that generates Configure scripts. If you don't
  know what a Configure script is, please skip to the <b>TUTORIAL</b> section of
  this manual page. If you want a full (formal) description of the way to use
  <i>metaconfig</i> and its units, please look at the <b>REFERENCE</b> section.
  The following is a quick introduction and reference for knowledgeable users.
<div class="Pp"></div>
<b>Metaconfig</b> operates from set of <i>units</i> which define everything that
  metaconfig knows about portability. Each unit is self-contained, and does not
  have to be registered anywhere other than by inclusion in either the public U
  directory or your private U directory. If the dist package (of which
  metaconfig is a part) is installed in LIB, then the public U directory is
  LIB/dist/mcon/U. On this machine, the LIB directory is /usr/share/dist. Your
  private U directory, if you have one, is in the top level directory of your
  package. Before you can run <i>metaconfig</i> you must do a several things:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Create a .package file in the package's top level directory
      by running <i>packinit</i>. This program will ask you about your package
      and remember what you tell it so that all the dist programs can be
    smart.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Consult the Glossary (in LIB/dist/mcon) and write your
      shell scripts and C programs in terms of the symbols that metaconfig knows
      how to define. You don't need to tell metaconfig which symbols you used,
      since metaconfig will figure that out for you.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Generate any .SH scripts needed to write Makefiles or shell
      scripts that will depend on values defined by Configure. There is a
      program called <i>makeSH</i> that will help you convert a plain script
      into a script.SH template; some editing will still need to be performed on
      the resulting .SH file to move the variable configuration part in the top
      part of the script (see inline comments generated by <i>makeSH</i> within
      your .SH file).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Create a MANIFEST.new file in your top level directory that
      lists all the files in your package. This file will remain private and
      will not be part of the final distribution. (As a convenience, the
      MANIFEST file will be used by <i>metaconfig</i> if there is no
      MANIFEST.new file yet.) The filename should be the first field on each
      line. After some whitespace you can add a short comment describing your
      file. Only source files should be listed in there. The special file
      <i>patchlevel.h</i> (which is handled and maintained by the patching tools
      -- see <i>pat</i>(1)) should be part of the MANIFEST.new file, but may be
      silently ignored by some tools. As a rule of thumb, only files maintained
      by RCS should be listed in there, the <i>patchlevel.h</i> file being one
      important exception.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Optionally, you may wish to create a MANIFEST file, which
      will be an exported version of your MANIFEST.new. That file must be made
      part of the release, i.e. listed in both your MANIFEST.new and MANIFEST
      itself. One of the <i>metaconfig</i> units knows about this file and will
      force Configure to perform a release check, ensuring all the files listed
      there are part of the distribution. The MANIFEST and MANIFEST.new files
      should be distinct, not links.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Copy any .U files that you want to modify to your private U
      directory. Any .U files in your private U directory will be used in
      preference to the one in the public U directory. For example, one way to
      force inclusion of any unit is to copy the End.U file to your .U directory
      and add the name of the unit you want as a dependency on the end of the
      ?MAKE: line. Certain units can ONLY be forced in this way, namely those of
      the form Warn_*.U and Chk_*.U. You can also customize certain default
      Configure variables by copying Myinit.U to your package's private U
      directory and setting the variables in that unit.</dd>
</dl>
<div class="Pp"></div>
Now you are ready to run <i>metaconfig</i>. That will create a <i>Configure</i>
  file, and optionally a <i>config_h.SH</i> file (if your sources make any use
  of C symbols). The generated files will automatically be added to your
  MANIFEST.new if necessary. Do not forget to update your MANIFEST file though.
<div class="Pp"></div>
In order to create new units, do the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Copy a similar unit to a new .U file. The name you choose
      should be the name of a variable generated by the unit, although this is
      only a convenience for you, not a requirement. It should be 12 or less
      characters to prevent filename chopping. Actually, it should probably be
      10 or less so that those who want to use RCS can have a .U,v on the end
      without chopping. Metaconfig uses the case of the first letter to
      determine if any variable is actually produced by this unit, so don't
      Capitalize your unit name if it is supposed to produce a shell
    variable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Edit the new .U file to do what you want. The first ?MAKE:
      line indicates the dependencies; before the final list colon all the
      variables this unit defines, and after the final colon all the variables
      (or other units) on which this unit depends. It is very important that
      these lists be accurate. If a dependency is optional and a default value
      can be used, you should prefix the dependency with a '+' sign. The
      corresponding unit will not be loaded to compute the symbol, unless really
      required by another unit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">To the extent possible, parameterize your unit based on
      shell variable defined on ?INIT: lines. This will move the variable
      definitions up to the Init.U unit, where they can be overridden by
      definitions in Myinit.U, which is included after Init.U.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Add the definition of any C symbols desired as ?H: lines. A
      line beginning with ?H:?%&lt;: in the .U file will be added to the
      eventual config.h file if and only if metaconfig decides that this unit is
      needed. The %&lt; stands for the unit's name, which happens to be the name
      of the file too (without .U) if you followed the convention. Always put a
      comment on each ?H: line in case one of the variable substitutions earlier
      on the line starts a comment without finishing it. Any shell variable
      starting with d_ may do this, so beware. If you ommit the ?%&lt;:, then
      metaconfig will try to intuit the symbol whose definition is needed prior
      any inclusion in config.h.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Add glossary definitions as ?S: lines for shell variables
      and ?C: lines for C preprocessor variables. See a current unit for
      examples. It is VERY important to start each entry with a left justified
      symbol name, and end each entry with a ?C:. or ?S:. line. The algorithm
      that translates C preprocessor symbol entries for the Glossary into
      comments for config.h depends on this.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Make sure the order of all your ? lines is right. The
      correct order is:
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 10.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">?RCS: and ?X:</dt>
  <dd class="It-tag">basically just comments</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?MAKE:</dt>
  <dd class="It-tag">metaconfig dependencies</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?Y:</dt>
  <dd class="It-tag">unit layout directive</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?S:</dt>
  <dd class="It-tag">glossary shell definitions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?C:</dt>
  <dd class="It-tag">glossary C definitions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:</dt>
  <dd class="It-tag">config.h definitions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?M:</dt>
  <dd class="It-tag">confmagic.h definitions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?W:</dt>
  <dd class="It-tag">wanted symbols</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?V:</dt>
  <dd class="It-tag">visible symbols</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?F:</dt>
  <dd class="It-tag">files created by this unit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?T:</dt>
  <dd class="It-tag">temporary shell symbols used</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?D:</dt>
  <dd class="It-tag">optional dependencies default value</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?O:</dt>
  <dd class="It-tag">used to mark obsolete units</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?LINT:</dt>
  <dd class="It-tag">metalint hints</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?INIT:</dt>
  <dd class="It-tag">shell symbols initializations</dd>
</dl>
</div>
<div class="Pp"></div>
Here is an example to show the ordering of the lines and the various formats
  allowed: ?RCS: $RCS-Id$ ?RCS: Copyright information ?RCS: $RCS-Log$ ?X: ?X: A
  contrived example ?X: ?MAKE:d_one two: three +four Five ?MAKE:	-pick add $@
  %&lt; ?Y:DEFAULT ?S:d_one: ?S:	First shell symbol, conditionally defines ONE.
  ?S:. ?S:two: ?S:	Second shell symbol, value for TWO. ?S:. ?C:ONE: ?C:	First C
  symbol. ?C:. ?C:TWO: ?C:	Second C symbol. ?C:. ?H:#$d_one ONE	/**/ ?H:#define
  TWO &quot;$two&quot; ?H:#$d_one ONE_TWO &quot;$two&quot; ?H:. ?M:flip:
  HAS_FLIP ?M:#ifndef HAS_FLIP ?M:#define flip(x) flop(x) ?M:#endif ?M:.
  ?W:%&lt;:one_two ?V:p_one p_two:p_three ?F:file ./ftest !tmp ?T:tmp var
  ?D:two='undef' ?LINT:change three ?INIT:two_init='2' : shell code implementing
  the unit follows p_one='one' p_two='two' p_three=&quot;&quot; Let me state it
  one more time: the above unit definition is a <i>fake</i> one to only show the
  different possibilities. Such a unit would serve little purpose anyway... Some
  more advanced features are not described here. Please refer to the
  <b>REFERENCE</b> section for more complete information.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Put the unit into the public or private U directory as
      appropriate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Rerun <i>metaconfig</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Send your unit to ram@acri.fr (Raphael Manfredi) for
      inclusion in the master copy, if you think it's of general interest.</dd>
</dl>
<div class="Pp"></div>
In order to add a new program to be located:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Edit Loc.U, and add the name of the program both to the
      ?MAKE: line (between the two colons) and to either loclist or trylist
      (depending on whether the program is mandatory or not).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Rerun metaconfig.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Send your unit to me for inclusion in the master copy, if
      you think it's of general interest.</dd>
</dl>
<div class="Pp"></div>
Notes for writing .U files:
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Always use &quot;rm -f&quot; because there are systems
      where rm is interactive by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Do not use &quot;set -- ...&quot; because '--' does not
      work with every shell. Use &quot;set x ...; shift&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Do not use &quot;unset ENV&quot; since unset is not fully
      portable. Say &quot;ENV=''&quot; instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Always use echo &quot; &quot; (with a space) because of
      Eunice systems.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Only use <b>test</b> with -r, -w, -f or -d since those are
      the only portable switches. In particular, avoid &quot;test -x&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Use only programs that came with V7, so that you know
      everyone has them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Use $contains when you want to grep conditionally, since
      not all greps return a reasonable status. Be sure to redirect the output
      to /dev/null, by using '&gt;/dev/null 2&gt;&amp;1'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Use &quot;if test&quot; rather than &quot;if [...]&quot;
      since not every sh knows the latter construct.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Use the myread script for inputs so that they can do shell
      escapes and default evaluation. The general form is case
      &quot;$grimble&quot; in '') dflt=452;; *) dflt=&quot;$grimble&quot;;; esac
      rp='How many grimbles do you have?' . ./myread
    grimble=&quot;$ans&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Use the getfile script when asking for a file pathname in
      order to have optional ~name expansion and sanity checks. See the
      Getfile.U unit for a full decription.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Always put a 	$startsh at the top of every generated script
      that is going to be launched or sourced by <i>Configure</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Never assume common UNIX-isms like the fact that an object
      file ends with a <i>.o</i> and that a library name ends with <i>.a</i>.
      Use the <i>$_o</i> and <i>$_a</i> variables instead (see Unix.U).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">When doing a compile-link-execute test, always write it
      like this: $cc $ccflags $ldflags try.c -o try $libs because some systems
      require that linking flags be specified before the compiled target (with
      the exception of trailing linking libraries).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Issue important messages on file descriptor #4, by using
      '&gt;&amp;4' to redirect output. Only those messages will appear when the
      <b>-s</b> switch is given to <i>Configure</i> on the command line (silent
      mode).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Always try to determine whether a feature is present in the
      most specific way--don't say &quot;if bsd&quot; when you can grep libc.
      There are many hybrid systems out there, and each feature should stand or
      fall by itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Always try to determine whether a feature is present in the
      most general way, so that other packages can use your unit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">When in doubt, set a default and ask. Don't assume
      anything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">If you think the user is wrong, allow for the fact that he
      may be right. For instance, he could be running Configure on a different
      system than he is going to use the final product on.</dd>
</dl>
<div class="Pp"></div>
Metaconfig reserves the following names in your directory, and if you use such a
  name it may get clobbered or have other unforeseen effects:
<br/>
 .MT/* Configure Wanted Obsolete configure config_h.SH confmagic.h U/*
  MANIFEST.new Additionally, Configure may clobber these names in the directory
  it is run in: UU/* config.sh config.h
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
The following options are recognized by <i>metaconfig</i>:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b></dt>
  <dd class="It-tag">Turn on debug mode. Not really useful unless you are
      debugging <i>metaconfig</i> itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">Print help message and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b></dt>
  <dd class="It-tag">Keep temporary directory, so that you may examine the
      working files used by <i>metaconfig</i> to build your <i>Configure</i>
      script. Useful only when debugging the units.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m</b></dt>
  <dd class="It-tag">Assume lots of memory and swap space. This will speed up
      symbol lookup in source files by a significant amount of time, at the
      expense of memory consumption...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b></dt>
  <dd class="It-tag">Map obsolete symbols on new ones. Use this switch if you
      still have some obsolete symbols in your source code and do not want (or
      cannot) remove them for now. The obsolete symbols are otherwise ignored,
      although that will give you a warning from <i>metaconfig</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b></dt>
  <dd class="It-tag">Turn silent mode on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b></dt>
  <dd class="It-tag">Trace symbols as they are found.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag">Turn verbose mode on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b></dt>
  <dd class="It-tag">Assume Wanted file is up-to-date. This will skip the time
      and memory consuming phase of source code scanning, looking for known
      symbols. Use it only when you know your source file have not changed with
      respect to the pool of <i>metaconfig</i> symbols used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-G</b></dt>
  <dd class="It-tag">Also provide a GNU <i>configure</i>-like front end to the
      generated <i>Configure</i> script, to be included in the distribution as
      well. This is only a wrapper around the <i>Configure</i> script naturally,
      but it lets people familiar with the GNU tool to not be lost when facing a
      new distribution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b><i> dir</i></dt>
  <dd class="It-tag">Override default library location. Normally only useful for
      metaconfig maintainers to locally use the units being developed instead of
      the publicly available ones. The <i>dir</i> specified is the one
      containing the units <i>U</i> directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b></dt>
  <dd class="It-tag">Allow production of a <i>confmagic.h</i> file to
      automagically remap some well-known symbols to some other alternative,
      like <i>bcopy</i>() being remapped transparently to <i>memcpy()</i> when
      not available. This option is turned on automatically when a
      <i>confmagic.h</i> file exists in the top-level directory. Simply remove
      that file if you wish to disable this option permanently.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag">Print version number and exit.</dd>
</dl>
<h1 class="Sh" title="Sh" id="TUTORIAL"><a class="selflink" href="#TUTORIAL">TUTORIAL</a></h1>
This (long) section is an introduction to <i>metaconfig</i>, in which we will
  learn all the basics. If you already know how to use <i>metaconfig</i>, you
  may safely skip to the next section.
<h2 class="Ss" title="Ss" id="Overview"><a class="selflink" href="#Overview">Overview</a></h2>
Usually when you want to get some source package to compile on a given platform
  you have to edit the main Makefile (assuming there is one!), choose a C
  compiler, make sure you have the proper libraries, and then fire the
  <i>make</i> command. If the package is reasonably well written, it will
  compile (without a warning being an option :-). In itself, the last sentence
  is a real performance, since given the variety of UNIX platforms available
  today and the diversity of flavours, that means the author of the package has
  gone into deep trouble to figure out the right choices given some standard
  trial, guessing and messing around with system includes and types.
<div class="Pp"></div>
However, despite all his talent, the author cannot possibly know that some
  system has a broken system call, or that some system structure lacks one
  otherwise standard field, or simply whether a given include file exists or
  not. And I'm not considering the implicit assumptions, like the type returned
  by the <i>malloc()</i> function or the presence of the <i>rename()</i> system
  call to name a few. But that knowledge is necessary to achieve real
  portability.
<div class="Pp"></div>
Now let's not abuse ourselves. Using that information requires greater skills,
  yet it can lead to more portable programs since it is then written in a
  system-independant fashion and relies only on the fact that some assumption is
  true or false on a particular system, each assumption being unrelated with
  each other. That is to say, we do not say: We're on a BSD system or we are on
  a USG system. That's too fuzzy anyway nowadays. No, we want to say to the
  source code: this system does not have the <i>rename()</i> system call and
  <i>malloc()</i> returns a <i>(void *)</i> value.
<div class="Pp"></div>
Metaconfig is a tool that will let you do just that, with the additional benefit
  of not having to hand-edit the Makefile if all goes well. By running
  <i>metaconfig</i>, you create a shell script named <i>Configure</i>. Lots of
  efforts have been devoted to the Configure script internals to ensure it will
  run on 99% of the existing shells available as of this writing. Configure will
  probe the target system, asking questions when in doubt and gather all the
  answers in one single shell file, which in turn can be used to automatically
  generate configured Makefiles and C include files.
<div class="Pp"></div>
There is only a limited (but quite large) set of symbols available for your
  shell scripts and C programs. They are all documented in the Glossary file.
  All you need to do is learn about them and start using them to address
  portability and configuration problems. Then, by running <i>metaconfig</i>, a
  suitable Configure script will be generated for your package.
<div class="Pp"></div>
The Configure script is built out several units (more than 300), each unit being
  responsible for defining a small number of shell and/or C symbols. Units are
  assembled together at the final stage, honoring the dependency graph (one unit
  may need the result of several other units which are then placed before in the
  script).
<h2 class="Ss" title="Ss" id="Symbols"><a class="selflink" href="#Symbols">Symbols</a></h2>
Symbols are the most important thing in the <i>metaconfig</i> world. They are
  the smallest recognized entity, usually a word, and can be granted a value at
  the end of the Configure execution. For instance, the C pre-processor symbol
  <i>HAS_RENAME</i> is a <i>metaconfig</i> symbol that is guranteed to be
  defined if, and only if, the <i>rename()</i> system call is present. Likewise,
  the <i>$ranlib</i> shell variable will be set to either ':' or 'ranlib'
  depending on whether the call to the <i>ranlib</i> program is needed to order
  a library file. How this works is not important for now, what is important is
  to understand that those symbols are given a <i>life</i> (i.e. a value) upon
  <i>Configure</i> execution.
<div class="Pp"></div>
Using symbols is relatively straightforward. In a C source file, you simply use
  the symbol value, as a pre-processor directive (for instance an: <i>#ifdef</i>
  <i>HAS_RENAME</i>) or, if the symbol value is a string, directly as you would
  use a macro in C. And in a shell file or a Makefile, you may reference a shell
  symbol directly.
<div class="Pp"></div>
Actually, I'm lying, because that's not completely as magic as the previous
  paragraph could sound. In a C file, you need to include the Configure-produced
  <i>config.h</i> file, and you must wrap your shell script or Makefile in a .SH
  file and you may reference the shell symbol only in the variable substitution
  part of that .SH file. More on this later.
<h2 class="Ss" title="Ss" id="Source_Files"><a class="selflink" href="#Source_Files">Source
  Files</a></h2>
Symbols may only appear in a limited set of source files, because
  <i>metaconfig</i> will only scan those when looking for known symbols, trying
  to figure out which units it will need. You may use C symbols in C source
  files, i.e. files with a <i>.c</i>, <i>.h</i>, <i>.y</i> or <i>.l</i>
  extension, and shell symbols are looked for only in .SH files.
<div class="Pp"></div>
In order to get the value of a symbol, a C file needs to include the special
  <i>config.h</i> file, which is produced by <i>Configure</i> when C symbols are
  present. And .SH files are run through a shell, producing a new file. However,
  in the top section of the .SH file, the special <i>config.sh</i> file (also
  produced by running <i>Configure</i>) is sourced, and variable substitutions
  apply. Actually, <i>config.h</i> is produced by running the
  <i>metaconfig</i>-produced <i>config_h.SH</i> file, again using variable
  substitution. So we're going to look at that a little more closely since this
  is the heart of the whole <i>configuration</i> scheme...
<h2 class="Ss" title="Ss" id="Variable_Substitution"><a class="selflink" href="#Variable_Substitution">Variable
  Substitution</a></h2>
There is shell construct called <i>here document</i> which enables a command to
  take an input specified within the script itself. That input is interpreted by
  the shell as a double-quoted string or a single quoted string depending on the
  form of the here document specification.
<div class="Pp"></div>
To specify a here document, the '&lt;&lt;' token is used, followed by a single
  identifier. From then on, the remaining script lines form the input for the
  command, until the here document is found on a line by itself. Shell
  substitution (including shell variable substitutions) is done unless the
  identifier is surrounded by single quotes. For instance: var='first'
  tar='second' echo &quot;--&gt; first here document:&quot; cat &lt;&lt;EOM
  var='$var' tar='$tar' EOM echo &quot;--&gt; second here document:&quot; cat
  &lt;&lt;'EOM' echo $var echo $tar EOM echo &quot;--&gt; end.&quot; will
  produce, when run through a shell: --&gt; first here document: var='first'
  tar='second' --&gt; second here document: echo $var echo $tar --&gt; end. The
  first here document has its content interpreted whilst the second one is
  output as-is. Both are useful in a .SH script, as we are about to see.
<h2 class="Ss" title="Ss" id="Using_.SH_Scripts"><a class="selflink" href="#Using_.SH_Scripts">Using
  .SH Scripts</a></h2>
A .SH script is usually produced by running the <i>MakeSH</i> script other an
  existing file, transforming <i>file</i> into a <i>file.SH</i>. Let's take a
  single example. Here is a little script (let's call it <i>intsize</i>) which
  prints a single message, the size of the <b>int</b> datatype in C.
  Unfortunately, it has the value hardwired in it, thusly: #!/bin/sh intsize='4'
  echo &quot;On this machine, the int type is $intsize bytes&quot; Let's run
  <i>makeSH</i> on it by typing ' <i>makeSH intsize</i>'. We get a single
  <i>intsize.SH</i> file that looks like this: case $CONFIG in '') 	if test -f
  config.sh; then TOP=.; 	elif test -f ../config.sh; then TOP=..; 	elif test -f
  ../../config.sh; then TOP=../..; 	elif test -f ../../../config.sh; then
  TOP=../../..; 	elif test -f ../../../../config.sh; then TOP=../../../..; 	else
  		echo &quot;Can't find config.sh.&quot;; exit 1 	fi 	. $TOP/config.sh 	;;
  esac : This forces SH files to create target in same directory as SH file. :
  This is so that make depend always knows where to find SH derivatives. case
  &quot;$0&quot; in */*) cd `expr X$0 : 'X\(.*\)/'` ;; esac echo
  &quot;Extracting intsize (with variable substitutions)&quot; : This section of
  the file will have variable substitutions done on it. : Move anything that
  needs config subs from !NO!SUBS! section to !GROK!THIS!. : Protect any dollar
  signs and backticks that you do not want interpreted : by putting a backslash
  in front. You may delete these comments. $spitshell &gt;intsize
  &lt;&lt;!GROK!THIS! $startsh !GROK!THIS!
<div style="height: 1.00em;">&#x00A0;</div>
: In the following dollars and backticks do not need the extra backslash.
  $spitshell &gt;&gt;intsize &lt;&lt;'!NO!SUBS!' intsize='4' echo &quot;On this
  machine, the int type is $intsize bytes&quot; !NO!SUBS! chmod 755 intsize
  $eunicefix intsize The first part of this script (in the <i>case</i>
  statement) is trying to locate the <i>config.sh</i> file, in order to source
  it. The <i>$CONFIG</i> variable is false by default, by true when
  <i>config.sh</i> has been sourced already (which would be the case if this
  file was executed from within <i>Configure</i> itself, but let's not confuse
  the issue here).
<div class="Pp"></div>
Once the <i>config.sh</i> file has been sources, all the shell symbols defined
  by <i>Configure</i> are set. We know reach a second case statement, used to
  change the current directory should a path be used to reach this program (for
  instance if we said ' <i>sh ../scripts/intsize.SH</i>', we would first run '
  <i>cd ../scripts</i>' before continuing). If you do not understand this, don't
  worry about it.
<div class="Pp"></div>
Here comes the intersting stuff. This script uses the <i>$spitshell</i>
  variable, and it's not something we know about...yet. If you look through the
  Glossary file, you will see that this is a variable known by
  <i>metaconfig</i>. If you make this file part of your distribution (by
  including it in the MANIFEST.new file, we'll come back to that later on) and
  run <i>metaconfig</i>, then the <i>Configure</i> script will determine a
  suitable value for this variable and it will be set in <i>config.sh</i>. Same
  goes for <i>$startsh</i> and the mysterious <i>$eunicefix</i> at the end. On a
  reasonable system, the relevant part of <i>config.sh</i> would look like this:
  spitshell='cat' startsh='#!/bin/sh' eunicefix=':' Ah! We're getting there. Now
  it looks familiar. We're facing a single <i>cat</i> command whose input comes
  from a variable-interpolated here document and whose output is redirected to
  <i>intsize</i>. The value will be that of <i>$startsh</i>, i.e. '#!/bin/sh'.
  Fine so far.
<div class="Pp"></div>
Then we reach the second here document expansion, to get the remaining of the
  script. This time, the here document symbol is surrounded by single quotes so
  the contents will be appended verbatim to the <i>intsize</i> file. So, by
  running ' <i>sh intsize.SH</i>', we get the following output: Extracting
  intsize (with variable substitutions) and by looking at the produced intsize
  file, we see: #!/bin/sh intsize='4' echo &quot;On this machine, the int type
  is $intsize bytes&quot; which is exactly what we had at the beginning. So far,
  it's a no-operation procedure... But, how marvelous! It so happens (pure
  coincidence, trust me!), that <i>metaconfig</i> knows about the
  <i>$intsize</i> shell symbol. By moving the initialization of intsize to the
  variable-interpolated area of the .SH script and initializing it with the
  <i>Configure</i>-computed value, and removing the now useless comments added
  by <i>makeSH</i>, we get: case $CONFIG in '') 	if test -f config.sh; then
  TOP=.; 	elif test -f ../config.sh; then TOP=..; 	elif test -f ../../config.sh;
  then TOP=../..; 	elif test -f ../../../config.sh; then TOP=../../..; 	elif
  test -f ../../../../config.sh; then TOP=../../../..; 	else 		echo &quot;Can't
  find config.sh.&quot;; exit 1 	fi 	. $TOP/config.sh 	;; esac case
  &quot;$0&quot; in */*) cd `expr X$0 : 'X\(.*\)/'` ;; esac echo
  &quot;Extracting intsize (with variable substitutions)&quot; $spitshell
  &gt;intsize &lt;&lt;!GROK!THIS! $startsh intsize='$intsize' !GROK!THIS!
<div style="height: 1.00em;">&#x00A0;</div>
$spitshell &gt;&gt;intsize &lt;&lt;'!NO!SUBS!' echo &quot;On this machine, the
  int type is $intsize bytes&quot; !NO!SUBS! chmod 755 intsize $eunicefix
  intsize Of course, running this script through a shell will again output the
  same script. But if we run <i>Configure</i> on a machine where an <b>int</b>
  is stored as a 64 bits quantity, <i>config.sh</i> will set <i>intsize</i> to 8
  and the <i>intsize</i> script will bear the right value and print: On this
  machine, the int type is 8 bytes which is correct. Congratulations! We have
  just configured a shell script!!
<h2 class="Ss" title="Ss" id="Producing_config.h"><a class="selflink" href="#Producing_config.h">Producing
  config.h</a></h2>
We can now have a look at the way <i>config.h</i> is produced out of
  <i>config_h.SH</i>. We know that running <i>Configure</i> produces a
  <i>config.sh</i> script (how exactly this is done is not strictly relevant
  here, but for the curious, it's another here document substitution within
  <i>Configure</i> itself). The <i>config_h.SH</i> itself is built by
  <i>metaconfig</i> at the same time <i>Configure</i> is, provided you make use
  of at least one C symbol within your sources.
<div class="Pp"></div>
Let's have a look at some random <i>config_h.SH</i> file to see what really
  happens: case $CONFIG in '') 	if test -f config.sh; then TOP=.; 	elif test -f
  ../config.sh; then TOP=..; 	elif test -f ../../config.sh; then TOP=../..;
  	elif test -f ../../../config.sh; then TOP=../../..; 	elif test -f
  ../../../../config.sh; then TOP=../../../..; 	else 		echo &quot;Can't find
  config.sh.&quot;; exit 1 	fi 	. $TOP/config.sh 	;; esac case &quot;$0&quot; in
  */*) cd `expr X$0 : 'X\(.*\)/'` ;; esac echo &quot;Extracting config.h (with
  variable substitutions)&quot; sed &lt;&lt;!GROK!THIS! &gt;config.h -e
  's!^#undef!/define!' -e 's!^#un-def!#undef!' /*
<br/>
 * This file was produced by running the config_h.SH script, which
<br/>
 * gets its values from config.sh, which is generally produced by
<br/>
 * running Configure.
<br/>
 *
<br/>
 * Feel free to modify any of this as the need arises. Note, however,
<br/>
 * that running config.h.SH again will wipe out any changes you've made.
<br/>
 * For a more permanent change edit config.sh and rerun config.h.SH.
<br/>
 */
<div style="height: 1.00em;">&#x00A0;</div>
/* Configuration time: $cf_time
<br/>
 * Configured by: $cf_by
<br/>
 * Target system: $myuname
<br/>
 */
<div style="height: 1.00em;">&#x00A0;</div>
#ifndef _config_h_ #define _config_h_
<div style="height: 1.00em;">&#x00A0;</div>
/* bcopy:
<br/>
 *	This symbol is maped to memcpy if the bcopy() routine is not
<br/>
 *	available to copy strings.
<br/>
 */ /* HAS_BCOPY:
<br/>
 *	This symbol is defined if the bcopy() routine is available to
<br/>
 *	copy blocks of memory. You should not use this symbol under
<br/>
 *	normal circumstances and use bcopy() directly instead, which
<br/>
 *	will get mapped to memcpy() if bcopy is not available.
<br/>
 */ #$d_bcopy HAS_BCOPY	/**/ #ifndef HAS_BCOPY #ifdef bcopy #un-def bcopy #endif
  #define bcopy(s,d,l) memcpy((d),(s),(l))		/* mapped to memcpy */ #endif
<div style="height: 1.00em;">&#x00A0;</div>
/* HAS_DUP2:
<br/>
 *	This symbol, if defined, indicates that the dup2 routine is
<br/>
 *	available to duplicate file descriptors.
<br/>
 */ #$d_dup2 HAS_DUP2	/**/
<div style="height: 1.00em;">&#x00A0;</div>
/* I_STRING:
<br/>
 *	This symbol, if defined, indicates to the C program that it should
<br/>
 *	include &lt;string.h&gt; (USG systems) instead of &lt;strings.h&gt; (BSD
  systems).
<br/>
 */ #$i_string I_STRING		/**/
<div style="height: 1.00em;">&#x00A0;</div>
#endif !GROK!THIS! At the top of the file, we recognize the standard .SH
  construct that we have already studied in detail. Next comes the extraction of
  the file itself, via a here document with variable substitutions. However,
  here we do not use a plain <i>cat</i> but a <i>sed</i> instead, since we need
  to do some further editing on-the-fly. We'll see why later on, so let's forget
  about it right now.
<div class="Pp"></div>
We now reach the leading comment, and the file is tagged with the configuration
  time, the target system, etc... (those variables coming from the sourced
  <i>config.sh</i> file have been set up by <i>Configure</i>). That comment
  header is followed by a '#ifndef' protection to guard against multiple
  inclusions of this file. Then comes the heart of the file...
<div class="Pp"></div>
It helps to know that <i>$d_*</i> and <i>$i_*</i> variables are set to either '
  <i>define</i>' or '<i>undef</i>' by <i>Configure</i>, depending on whether a
  function or an include file is present on the system or not. That means the:
  #$d_bcopy HAS_BCOPY /**/ line will be expanded to either: #define HAS_BCOPY
  /**/ if the $d_bcopy variable is set to 'define' or: #undef HAS_BCOPY /**/ if
  $d_bcopy was set to 'undef', because the feature was not there. However,
  that's not what gets written in the <i>config.h</i> file because of the
  <i>sed</i> filter we have already seen, which will transform the second form
  into: /*#define HAS_BCOPY /**/ That's a handy form for later editing of
  <i>config.h</i> because you only need to remove the leading '/*' if you want
  to override <i>Configure</i>'s choice. Likewise, you may add a single '/*' at
  the beginning of a '#define' line to avoid the definition of a particular
  symbol. This is why each symbol definition is protected by a trailing '/**/',
  to close the leading comment opened by '/*' (comments are not nested in C).
<div class="Pp"></div>
Now transforming '#undef' into '/*#define' is nice, but if we want to actually
  write a '#undef', we're stuck... unless we write it as '#un-def' and let
  <i>sed</i> fix that to '#undef' while producing <i>config.h</i>, which is what
  is actually done here.
<div class="Pp"></div>
The same kind of reasoning applies to those two lines: #$d_dup2 HAS_DUP2 /**/
  #$i_string I_STRING /**/ and assuming <i>config.sh</i> defines:
  d_dup2='define' i_string='undef' we'll get in the produced <i>config.h</i>:
  #define HAS_DUP2 /**/ /*#define I_STRING /**/ Clear as running water? Good!
<div class="Pp"></div>
Now it should be obvious that by including <i>config.h</i> in all your C source
  files, you get to know what <i>Configure</i> has guessed on your system. In
  effect, by using those symbols, you are writing configured C code, since
  <i>metaconfig</i> will know that you need those symbols and will generate a
  suitable <i>config_h.SH</i> file as well as all the necessary code in
  <i>Configure</i> to compute a proper value for them (by assigning values to
  associated shell variables).
<h2 class="Ss" title="Ss" id="Running_Metaconfig"><a class="selflink" href="#Running_Metaconfig">Running
  Metaconfig</a></h2>
Let's focus on the <i>metaconfig</i> program for a while to understand how it
  uses its units and your source code to produce all the needed configuration
  files. If you intend to write new units, you should have a good understanding
  of the whole scheme.
<div class="Pp"></div>
If there is no MANIFEST.new file, <i>metaconfig</i> will try to use the MANIFEST
  file instead, for convenience. Everywhere we mention MANIFEST.new, it can be
  understood as MANIFEST provided there is no MANIFEST.new file found at the
  root of your package.
<div class="Pp"></div>
Assuming your MANIFEST.new file is properly set and lists all the source files
  you wish to configure, and that you have run <i>packint</i> in your root
  source directory to create a <i>.package</i> file, you may run
  <i>metaconfig</i> and you'll get the following: $ metaconfig Locating units...
  Extracting dependency lists from 312 units... Extracting filenames (*.[chyl]
  and *.SH) from MANIFEST.new... Building a Wanted file...
<br/>
Scanning .[chyl] files for symbols... Scanning .SH files for symbols...
<br/>
Computing optimal dependency graph...
<br/>
Building private make file... Determining loadable units... Updating make
  file...
<br/>
Determining the correct order for the units... Creating Configure... Done. The
  first phase looks for all the units files (ending with .U) in the public
  directory first, then in your private one. If you copy a public file in your
  private U directory (i.e. a directory named U at the top level of your
  package), it will override the public version. Once it has a list of all the
  available units, it parses them and extracts all the ?MAKE: lines to know
  about the dependencies and the known shell symbols. It also focuses on the ?H:
  lines to learn about the C symbols and which shell symbols needs to be
  computed to get a proper value for that C symbol (so we have another level of
  dependencies here).
<div class="Pp"></div>
Next, the proper filenames are extracted from the MANIFEST.new files and a
  <i>Wanted</i> file is built: that file lists all the C symbols and the shell
  symbols needed for that package. We first scan the C-type files for C symbols,
  then propagate the dependencies to their associated shell symbols (gathered
  from ?H: lines). Next .SH files are scanned and finally all the shell symbols
  are known.
<div class="Pp"></div>
A temporary Makefile is built and metaconfig tries to <i>make</i> all the shell
  symbols to see what commands (listed on the second ?MAKE: lines) are executed,
  and thus which units are really needed. Optional units not otherwise required
  are removed and a second Makefile is generated. This time, we know about all
  the units and their respective orders, optional units having been removed and
  default values computed for their shell symbols. The <i>Configure</i> script
  can then be generated, along with <i>config_h.SH</i>. We're done.
<h2 class="Ss" title="Ss" id="Conventions"><a class="selflink" href="#Conventions">Conventions</a></h2>
Proper conventions needs to be followed to make the whole process sound. There
  is a case convention for units and a variable naming convention.
<div class="Pp"></div>
All units should have their first letter lower-cased, unless they are special
  units. By special, we mean they do not really define new shell variables that
  can be used by the user in his .SH files, but rather units producing scripts
  or shell variables that are to be used internally by the <i>Configure</i>
  script. Typical examples are the <i>Init.U</i> file which is the main variable
  initialization, or <i>Myread.U</i> which produces the <i>myread</i> script
  used almost everywhere in <i>Configure</i> when a question is to be asked to
  the user.
<div class="Pp"></div>
Non-special units then subdivise in two distinct groups: units defining
  variables associated to a C symbol and units defining shell variables of their
  own. The first group is further divided in variables related to include files
  (their name begin with <i>i_</i>) and variables related to other definitions
  (name starting with <i>d_</i>). The second group have names standing for
  itself, for instance <i>cc.U</i> defines the <i>$cc</i> shell variable whose
  value is the C compiler to be used.
<div class="Pp"></div>
Special units sometimes reserve themselves some pre-defined variable and return
  &quot;results&quot; in other well-known variables. For instance, the
  <i>myread</i> script produced by Myread.U expects the prompt in <i>$rp</i>,
  the default answer in <i>$dflt</i> and places the user answer in <i>$ans</i>.
  This is not documented in this manual page: you have to go and look at the
  unit itself to understand which variables are used and how the unit is to be
  used.
<h2 class="Ss" title="Ss" id="Using_The_Glossary"><a class="selflink" href="#Using_The_Glossary">Using
  The Glossary</a></h2>
The Glossary file is automatically produced by the <i>makegloss</i> script,
  which extracts the information from ?S:, ?C: and ?MAKE: lines and reformats
  them into an alphabetically sorted glossary. It is important to read the
  Glossary to know about the symbols you are allowed to use. However, the
  Glossary will not tell you how to use them. Usually, that's up to you.
<div class="Pp"></div>
One day, you will probably write your own units and you will know enough about
  <i>metaconfig</i> to do so quickly and efficiently. However, never forget to
  properly document your work in the ?S: and ?C: lines, or other people will not
  be able to reuse it. Remember about the time where you had only the Glossary
  and this manual page to get started.
<h2 class="Ss" title="Ss" id="Conclusion"><a class="selflink" href="#Conclusion">Conclusion</a></h2>
Now that you know the <i>metaconfig</i> basics, you should read the
  <i>DESCRIPTION</i> section, then skip to the <i>REFERENCE</i> section to learn
  about all the gory details such as the allowed syntax for unit control lines
  (lines starting with a '?') or the distinct MAKE commands you are allowed to
  use.
<h1 class="Sh" title="Sh" id="REFERENCE"><a class="selflink" href="#REFERENCE">REFERENCE</a></h1>
This section documents the internals of <i>metaconfig</i>, basically the unit
  syntax, the special units you should know about and the hint files.
<h2 class="Ss" title="Ss" id="General_Unit_Syntax"><a class="selflink" href="#General_Unit_Syntax">General
  Unit Syntax</a></h2>
A metaconfig unit is divided into two distinct parts. The header section (lines
  starting with '?') and a shell section (code to be included in the
  <i>Configure</i> script). It is possible to add '?X:' comments anywhere within
  the unit, but the other '?' lines (also called <i>control lines</i>) have a
  strict ordering policy.
<div class="Pp"></div>
If a control line is too long, it is possible to use a continuation by escaping
  the final new-line with a backslash and continuing on the next line (which
  should then be indented by spaces or tabs).
<div class="Pp"></div>
The following is a formal description of each of the control lines. Unless
  stated otherwise, the order of this presentation is the order to be used
  within the unit.
<dl class="Bl-tag">
  <dt class="It-tag">?RCS: <i>free text</i></dt>
  <dd class="It-tag">To be used for RCS comments, at the top of the unit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?X: <i>any text</i></dt>
  <dd class="It-tag">General purpose comments. May appear anywhere in the unit
      but must be left justfied. For RCS comments, please use the ?RCS: comment
      form.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?MAKE:<i>symbol list</i>: <i>dependency list</i>
    [<i>+optional</i>]</dt>
  <dd class="It-tag">This is the first dependency line. The first <i>symbol
      list</i> should list all the symbols built by this unit (i.e. whose value
      is computed by the shell section of the unit). Symbols should be space
      separated. If a defined symbol is for internal use only and should not
      appear in the generated <i>config.sh</i> file, then it should be preceded
      by a '+' (not to be confused with optional dependencies defined
      hereafter). The second part of the list (after the middle ':') is the unit
      dependency. It should list all the needed special units, as well as all
      the symbols used by the shell implementation. If a symbol is nedded but
      its configuration value is not critical, it can be preceded by a '+', in
      which case it is called a conditional dependency: its corresponding unit
      will be loaded if, and only if, that symbol is otherwise really wanted;
      otherwise the default value will be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?MAKE:<i>tab</i> <i>command</i></dt>
  <dd class="It-tag">There can be one or more command lines following the
      initial dependency lines. Those commands will be executed when the unit is
      wanted to load them into <i>Configure</i>. See the paragraph about make
      commands for more information. Note that the leading <i>tab</i> character
      is required before the <i>command</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?Y:<i>layout</i></dt>
  <dd class="It-tag">Declare a layout directive for this unit. That directive
      may be one of the strings <i>top</i>, <i>default</i> or <i>bottom</i>
      (case does not matter, recommended style is to spell them out uppercased).
      If omitted, <i>default</i> is assumed.
    <div style="height: 1.00em;">&#x00A0;</div>
    This directive is only required if you wish to force a unit at the top or
      the bottom of the generated <i>Configure</i> script, as unit dependencies
      permit it. Important questions may thus be forced at the beginning. Within
      the same layout class, units are sorted alphabetically with two special
      cases for d_* and i_* units, forced respectively at the top and bottom of
      their classes (but these should belong to the default class).
    <div style="height: 1.00em;">&#x00A0;</div>
    It you force at the top a unit whose dependencies require all the other unit
      to precede it, you achieve nothing interesting. Therefore, that directive
      should really be used to increase the priority of some interactive units
      that do not depend on many other user-visible symbols, like path-related
      questions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?S:<i>symbol_name</i> [(<i>obsolete symbol list</i>)]:</dt>
  <dd class="It-tag">Introduces a shell symbol. This first line names the
      symbol, optionally followed by a list enclosed between parenthesis and
      giving the obsolete equivalent. Those obsolete symbols will be remapped to
      the new <i>symbol_name</i> if the <b>-o</b> option is given to
      <i>metaconfig</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?S:<i>any text, for Glossary</i></dt>
  <dd class="It-tag">Basically a comment describing the shell symbol, which will
      be extracted by <i>makegloss</i> into the Glossary file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?S:.</dt>
  <dd class="It-tag">Closes the shell symbol comment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?C:<i>symbol_name</i> [~ <i>alias</i>] [(<i>obsolete symbol
    list</i>)]:</dt>
  <dd class="It-tag">Introduces a new C symbol. The <i>alias</i> name is the
      name under which the C symbol will be controlled, i.e. if the <i>alias</i>
      symbol is wanted, then that C symbol will be written in the
      <i>config_h.SH</i> file. Usually, the alias is just '%&lt;' (stands for
      the unit's name) and there is also a ?W: line mapping a C symbol to the
      <i>alias</i>. Also the relevant parts of the ?H: lines are explicitly
      protected by a '?%&lt;' condition. See the symbol aliasing paragraph for
      more details. The remaining of the line is the optional <i>obsolete symbol
      list</i>, which lists old equivalents for the new <i>symbol_name</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?C:<i>any text, for Glossary and config_h.SH</i></dt>
  <dd class="It-tag">Basically a comment describing the C symbol, which will be
      extracted by <i>makegloss</i> into the Glossary file and by
      <i>metaconfig</i> into the <i>config_h.SH</i> file if the symbol is wanted
      (or if its alias is wanted when symbol aliasing is used).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?C:.</dt>
  <dd class="It-tag">Closes the C symbol comment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:?<i>symbol</i>:<i>config_h.SH stuff</i></dt>
  <dd class="It-tag">This is the general inclusion request into
      <i>config_h.SH</i>. The line is only written when the guarding
      <i>symbol</i> is really wanted. This general form is needed when C symbol
      aliasing was used. Otherwise, if you use one of the other
      &quot;standard&quot; forms, the guarding is automatically done by
      <i>metaconfig</i> itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:#<i>$d_var VAR</i> &quot;<i>$var</i>&quot;</dt>
  <dd class="It-tag">Conditionally defines the <i>VAR</i> C symbol into
      <i>$var</i> when <i></i> is set to ' <i>define</i>'. Implies a
      '?<i>VAR</i>:' guarding condition, and <i>metaconfig</i> automatically
      links <i>VAR</i> to its two shell variable dependencies (i.e. both
      <i>$d_var</i> and <i>$var</i> will be flagged as <i>wanted</i> if
      <i>VAR</i> is used in C sources).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:#define <i>VAR</i> [<i>optional text</i>]</dt>
  <dd class="It-tag">Always defines the <i>VAR</i> C symbol to some value.
      Implies a '? <i>VAR</i>:' guarding condition. An automatic shell
      dependency is made to the unit itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:#define <i>VAR(x,y,z)</i> <i>$var</i></dt>
  <dd class="It-tag">Always defines the macro <i>VAR</i> to be the value of the
      <i>$var</i> variable. It is up to the unit to ensure <i>$var</i> holds a
      sensible value. An automatic dependency between the C macro <i>VAR</i> and
      the shell variable is established, and the whole line is guarded by an
      implicit '? <i>VAR</i>:'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:#<i>$d_var VAR</i></dt>
  <dd class="It-tag">Conditionally defines <i>VAR</i> if <i>$d_var</i> is set to
      ' <i>define</i>'. Implies a '? <i>VAR</i>:' guarding condition. An
      automatic shell dependency is generated towards <i>$d_war</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:#define <i>VAR</i> &quot;<i>$var</i>&quot;</dt>
  <dd class="It-tag">Assigns a configured value to the <i>VAR</i> C symbol.
      Implies a '? <i>VAR</i>:' gurading condition. An automatic shell
      dependency is generated to link <i>VAR</i> and <i>$var</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?H:.</dt>
  <dd class="It-tag">Closes the <i>config_h.SH</i> inclusion requests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?M:<i>C symbol</i>: <i>C dependencies</i></dt>
  <dd class="It-tag">Introduces magic definition concerning the C symbol, for
      <i>confmagic.h</i>, and defines the guarding symbol for the remaining ?M:
      definitions. This line silently implies '?W:%&lt;: <i>C symbol</i>', i.e.
      the unit will be loaded into Configure if the C symbol appears within the
      C sources, whether magic is used or not. The C dependencies are activated
      when magic is used, in order to force their definition in
      <i>config_h.SH</i>. However, if magic is <b>not</b> used but the C symbol
      appears in the source without the needed C dependencies, you will be
      warned every time the Wanted file is built, since it may be a portability
      issue (and also because the unit is unconditionally loaded into Configure
      whenever the C symbol is used, regardless of the other ?C: lines from the
      unit).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?M:<i>cpp defs</i></dt>
  <dd class="It-tag">Defines the magic cpp mapping to be introduced in
      confmagic.h whenever the concerned symbol is used. There is an implicit '?
      <i>sym</i>' guarding where <i>sym</i> is the symbol name defined by the
      leading ?M: line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?M:.</dt>
  <dd class="It-tag">Closes the <i>confmagic.h</i> inclusion request.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?W:<i>shell symbol list</i>:<i>C symbol list</i></dt>
  <dd class="It-tag">Ties up the destiny of the shell symbols with that of the C
      symbols: if any of the C symbols listed is wanted, then all the shell
      symbols are marked as wanted. Useful to force inclusion of a unit (shell
      symbol list set to '%&lt;') when the presence of some C symbol is
      detected. The shell symbol list may be left empty, to benefit from the
      side effect of C symbol location within the builtin pre-processor (symbol
      being <i>defined</i> for that pre-processor if located in the source). To
      look for patterns with a space in them, you need to quote the C symbols
      within simple quotes, as in 'struct timezone'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?V:<i>read-only symbols</i>:<i>read-write symbols</i></dt>
  <dd class="It-tag">This is a <i>metalint</i> hint and should be used only in
      special units exporting some shell variables. The variables before the
      middle ':' are exported read-only (changing them will issue a warning),
      while other symbols may be freely read and changed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?F:<i>files created</i></dt>
  <dd class="It-tag">This line serves two purposes: it is a <i>metalint</i>
      hint, and also a placeholder for future <i>jmake</i> use. It must list
      three kind of files: the temporary one which are created for a test, the
      private UU ones created in the UU directory for later perusal, and the
      public ones left in the root directory of the package. Temporary files
      must be listed with a preceding '!' character (meaning &quot;no! they're
      not re-used later!&quot;), private UU files should be preceded by a './'
      (meaning: to use them, say <i>./file</i>, not just <i>file</i>), and
      public ones should be named as-is.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?T:<i>shell temporaries</i></dt>
  <dd class="It-tag">Another <i>metalint</i> hint. This line lists all the shell
      variables used as temporaries within the shell section of this unit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?D:<i>symbol</i>='<i>value</i>'</dt>
  <dd class="It-tag">Initialization value for symbols used as conditional
      dependencies. If no ?D: line is found, then a null value is used instead.
      The <i>metalint</i> program will warn you if a symbol is used at least
      once as a conditional dependency and does not have a proper ?D:
      initialization. It's a good practice to add those lines even for a null
      initialization since it emphasizes on the possibly optional nature of a
      symbol.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?O:<i>any message you want</i></dt>
  <dd class="It-tag">This directive indicates that this unit is obsolete as a
      whole. Whenever usage of any of its symbols is made (or indirect usage via
      dependencies), the message is output on the screen (on stderr). You can
      put one ore more lines, in which case each line will be printed, in
    order.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?LINT:<i>metalint hints</i></dt>
  <dd class="It-tag">See the <i>metalint</i> manual page for an explaination of
      the distinct hints that can be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?INIT:<i>initialization code</i></dt>
  <dd class="It-tag">The initialization code specified by this line will be
      loaded at the top of the <i>Configure</i> script provided the unit is
      needed.</dd>
</dl>
<h2 class="Ss" title="Ss" id="C_Symbol_Aliasing"><a class="selflink" href="#C_Symbol_Aliasing">C
  Symbol Aliasing</a></h2>
Sometimes it is not possible to rely on <i>metaconfig</i>'s own default
  selection for <i>config_h.SH</i> comments and C symbol definition. That's
  where aliasing comes into play. Since it's rather tricky to explain, we'll
  study an example to understand the underlying mechanism.
<div class="Pp"></div>
The d_const.U unit tries to determine whether or not your C compiler known about
  the <i>const</i> keyword. If it doesn't we want to remap that keyword to a
  null string, in order to let the program compile. Moreover, we want to
  automatically trigger the test when the <i>const</i> word is used.
<div class="Pp"></div>
Here are the relevant parts of the d_const.U unit: ?MAKE:d_const: cat cc ccflags
  Setvar ?MAKE:	-pick add $@ %&lt; ?S:d_const: ?S:	This variable conditionally
  defines the HASCONST symbol, which ?S:	indicates to the C program that this C
  compiler knows about the ?S:	const type. ?S:. ?C:HASCONST ~ %&lt;: ?C:	This
  symbol, if defined, indicates that this C compiler knows about ?C:	the const
  type. There is no need to actually test for that symbol ?C:	within your
  programs. The mere use of the &quot;const&quot; keyword will ?C:	trigger the
  necessary tests. ?C:. ?H:?%&lt;:#$d_const HASCONST	/**/ ?H:?%&lt;:#ifndef
  HASCONST ?H:?%&lt;:#define const ?H:?%&lt;:#endif ?H:. ?W:%&lt;:const
  ?LINT:set d_const ?LINT:known const : check for const keyword echo &quot;
  &quot; echo 'Checking to see if your C compiler knows about
  &quot;const&quot;...' &gt;&amp;4 /bin/cat &gt;const.c &lt;&lt;'EOCP' main() {
  	const char *foo; } EOCP if $cc -c $ccflags const.c &gt;/dev/null 2&gt;&amp;1
  ; then 	val=&quot;$define&quot; 	echo &quot;Yup, it does.&quot; else
  	val=&quot;$undef&quot; 	echo &quot;Nope, it doesn't.&quot; fi set d_const
  eval $setvar First we notice the use of a ?W: line, which basically says:
  &quot;This unit is wanted when the <i>const</i> keyword is used in a C
  file.&quot;. In order to conditionally remap <i>const</i> to a null string in
  <i>config.h</i>, I chose to conditionally define <i>HASCONST</i> via
  <i>$d_const</i>.
<div class="Pp"></div>
However, this raises a problem, because the <i>HASCONST</i> symbol is not going
  to be used in the sources, only the <i>const</i> token is. And the ?H: line
  defining <i>HASCONST</i> is implicitely guarded by '?HASCONST'. Therefore, we
  must add the explicit '?%&lt;' constraint to tell <i>metaconfig</i> that those
  lines should be included in <i>config_h.SH</i> whenever the '%&lt;' symbol
  gets wanted (%&lt; refers to the unit's name, here <i>d_const</i>).
<div class="Pp"></div>
That's almost perfect, because the ?W: line will want <i>d_const</i> whenever
  <i>const</i> is used, then the ?H: lines will get included in the
  <i>config_h.SH</i> file. However, the leading comment (?C: lines) attached to
  <i>HASCONST</i> is itself also guarded via <i>HASCONST</i>, i.e. it has an
  implicit '?HASCONST' constraint. Hence the need for <i>aliasing</i> the
  <i>HASCONST</i> symbol to '%&lt;'.
<div class="Pp"></div>
The remaining part of the unit (the shell part) is really straightforward. It
  simply tries to compile a sample C program using the <i>const</i> keyword. If
  it can, then it will define <i>$d_const</i> via the <i>$setvar</i> fonction
  (defined by the <i>Setvar.U</i> unit). See the paragraph about special units
  for more details.
<h2 class="Ss" title="Ss" id="Make_Commands"><a class="selflink" href="#Make_Commands">Make
  Commands</a></h2>
On the ?MAKE: command line, you may write a shell command to be executed as-is
  or a special <i>-pick</i> command which is trapped by <i>metaconfig</i> and
  parsed to see what should be done. The leading '-' is only there to prevent
  <i>make</i> from failing when the command returns a non-zero status -- it's
  not really needed since we use ' <i>make -n</i>' to resolve the dependencies,
  but I advise you to keep it in case it becomes mandatory in future versions.
  The syntax of the <i>pick</i> command is: -pick <i>cmd</i> $@
  <i>target_file</i> where <i>$@</i> is the standard macro within Makefiles
  standing for the current target (the name of the unit being built, with the
  final .U extension stripped). The <i>cmd</i> part is the actual
  <i>metaconfig</i> command to be run, and the <i>target_file</i> is yet another
  parameter, whose interpretation depends on the <i>cmd</i> itself. It also has
  its final .U extension stripped and normally refers to a unit file, unless it
  start with './' in which case it references one of the <i>metaconfig</i>
  control files in the ' <i>.MT</i> directory.
<div class="Pp"></div>
The available commands are:
<dl class="Bl-tag">
  <dt class="It-tag">add</dt>
  <dd class="It-tag">Adds the <i>target_file</i> to <i>Configure</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">add.Config_sh</dt>
  <dd class="It-tag">Fills in that part of <i>Configure</i> producing the
      <i>config.sh</i> file. Only used variables are added, conditional ones
      (from conditional dependencies) are skipped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">add.Null</dt>
  <dd class="It-tag">Adds the section initializing all the shell variables used
      to an empty string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">c_h_weed</dt>
  <dd class="It-tag">Produces the <i>config_h.SH</i> file. Only the necessary
      lines are printed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cm_h_weed</dt>
  <dd class="It-tag">Produces the <i>confmagic.h</i> file. Only the necessary
      lines are printed. This command is only enabled when the <b>-M</b> switch
      is given, or when a <i>confmagic.h</i> file already exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">close.Config_sh</dt>
  <dd class="It-tag">Adds the final 'EOT' symbol on a line by itself to end the
      here document construct producing the <i>config.sh</i> file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">prepend</dt>
  <dd class="It-tag">Prepends the content of the target to the
      <i>target_file</i> if that file is not empty.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">weed</dt>
  <dd class="It-tag">Adds the unit to <i>Configure</i> like the <i>add</i>
      command, but make some additional tests to remove the '? <i>symbol</i>'
      and '% <i>symbol</i>' lines from the <i>target_file</i> if the symbol is
      not wanted or conditionally wanted. The '%' form is only used internally
      by <i>metaconfig</i> while producing its own .U files in the ' <i>.MT</i>'
      directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">wipe</dt>
  <dd class="It-tag">Same as <i>add</i> really, but performs an additional macro
      substitution. The available macros are described in the <i>Hardwired
      Macros</i> paragraph.</dd>
</dl>
<div class="Pp"></div>
As a side note, <i>metaconfig</i> generates a <i>-cond</i> command internally to
  deal with conditional dependencies. You should not use it by yourself, but you
  will see it if scanning the generated <i>Makefile</i> in the <i>.MT</i>
  directory.
<h2 class="Ss" title="Ss" id="Hardwired_Macros"><a class="selflink" href="#Hardwired_Macros">Hardwired
  Macros</a></h2>
The following macros are recognized by the <i>wipe</i> command and subsituted
  before inclusion in <i>Configure</i>:
<dl class="Bl-tag">
  <dt class="It-tag">&lt;BASEREV&gt;</dt>
  <dd class="It-tag">The base revision number of the package, derived from
      <i>.package</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;DATE&gt;</dt>
  <dd class="It-tag">The current date.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;MAINTLOC&gt;</dt>
  <dd class="It-tag">The e-mail address of the maintainer of this package,
      derived from your <i>.package</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;PACKAGENAME&gt;</dt>
  <dd class="It-tag">The name of the package, as derived from your
      <i>.package</i> file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;PATCHLEVEL&gt;</dt>
  <dd class="It-tag">The patch level of the <i>metaconfig</i> program
      (deprecated in favor of &lt;REVISION&gt;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;REVISION&gt;</dt>
  <dd class="It-tag">The SVN revision level of the <i>metaconfig</i>
    program.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;VERSION&gt;</dt>
  <dd class="It-tag">The version number of the <i>metaconfig</i> program.</dd>
</dl>
<div class="Pp"></div>
Those macros are mainly used to identify the <i>metaconfig</i> version that
  generated a particular <i>Configure</i> script and for which package it was
  done. The e-mail address of the maintainer is hardwired in the leading
  instructions that <i>Configure</i> prints when starting.
<div class="Pp"></div>
Recent <i>metaconfig</i> versions understand a much more general syntax of the
  form: 	&lt;$variable&gt; which is replaced at Configure-generation time by the
  value of <i>variable</i> taken from your <i>.package</i> file. Eventually, the
  old hardwired macro format will disappear, and &lt;$baserev&gt; will replace
  &lt;BASEREV&gt; in all the supplied units.
<h2 class="Ss" title="Ss" id="Special_Units"><a class="selflink" href="#Special_Units">Special
  Units</a></h2>
The following special units are used to factorize code and provide higher level
  functionalities. They either produce a shell script that can be sourced or a
  shell variable that can be <i>eval</i>'ed. Parameter passing is done via
  well-know variables, either named or anonymous like $1, $2, etc... (which can
  be easily set via the shell <i>set</i> operator). When <i>Configure</i>
  executes, it creates and goes into a <i>UU</i> directory, so every produced
  script lies in there and does not interfere with the files from your package.
<div class="Pp"></div>
Here are the sepcial units that you should know about, and the way to use them.
<dl class="Bl-tag">
  <dt class="It-tag">Cppsym.U</dt>
  <dd class="It-tag">This unit produces a shell script called <i>Cppsym</i>,
      which can be used to determine whether any symbol in a list is defined by
      the C preprocessor or C compiler you have specified. It can determine the
      status of any symbol, though the symbols in <i></i> (attribute list) are
      more easily determined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Csym.U</dt>
  <dd class="It-tag">This sets the $csym shell variable, used internally by
      <i>Configure</i> to check whether a given C symbol is defined or not. A
      typical use is: set symbol result [-fva] [previous] eval $csym That will
      set the <i>result</i> variable to 'true' if the function [-f], variable
      [-v] or array [-a] is defined, 'false' otherwise. If a previous value is
      given and the <b>-r</b> switch was provided to <i>Configure</i> (see the
      <i>Configure Options</i> paragraph), then that value is re-used without
      questioning.
    <div style="height: 1.00em;">&#x00A0;</div>
    The way this computation is done depends on the answer the user gives to the
      question <i>Configure</i> will ask about whether it should perform an
      <i>nm</i> extraction or not. If the exctraction was performed, the unit
      simply looks through the symbol list, otherwise it performs a compile-link
      test, unless <b>-r</b> was given to reuse the previously computed value,
      naturally...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">End.U</dt>
  <dd class="It-tag">By copying this unit into your private <i>U</i> directory
      and appending dependencies on the ?MAKE: line, you can force a given unit
      to be loaded into <i>Configure</i> even if it is not otherwise wanted.
      Some units may only be forced into <i>Configure</i> that way.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Filexp.U</dt>
  <dd class="It-tag">This unit produces a shell script <i>filexp</i> which will
      expand filenames beginning with tildes. A typical use is:
      exp_name=`./filexp $name` to assign the expanded file name in
      <i>exp_name</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Findhdr.U</dt>
  <dd class="It-tag">This unit produces a <i>findhdr</i> script which is used to
      locate the header files in <i>$usrinc</i> or other stranger places using
      cpp capabilities. The script is given an include file base name like
      'stdio.h' or 'sys/file.h' and it returns the full path of the inlcude file
      and a zero status if found, or an empty string and a non-zero status if
      the file could not be located.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Getfile.U</dt>
  <dd class="It-tag">This unit produces a bit of shell code that must be sourced
      in order to get a file name and make some sanity checks. Optionally, a
      ~name expansion is performed.
    <div style="height: 1.00em;">&#x00A0;</div>
    To use this unit, <i>$rp</i> and <i>$dflt</i> must hold the question and the
      default answer, which will be passed as-is to the <i>myread</i> script
      (see forthcoming <i>Myread.U</i>). The <i>$fn</i> variable controls the
      operation and the result is returned into <i>$ans</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To locate a file or directory, put 'f' or 'd' in <i>f~/</i>. If a '~'
      appears, then ~name substitution is allowed. If a '/' appears, only
      absolute pathnames are accepted and ~name subsitutions are always expanded
      before returning. If '+' is specified, existence checks are skipped. If
      'n' appears within <i>$fn</i>, then the user is allowed to answer 'none'.
    <div style="height: 1.00em;">&#x00A0;</div>
    Usually, unless you asked for portability, ~name substitution occurs when
      requested. However, there are some times you wish to bypass portability
      and force the substitution. You may use the 'e' letter (expand) to do
      that.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the special 'l' (locate) type is used, then the <i>$fn</i> variable must
      end with a ':', followed by a file basename. If the answer is a directory,
      the file basename will be appended before testing for file existence. This
      is useful in locate-style questions like this: dflt='~news/lib' : no need
      to specify 'd' or 'f' when 'l' is used fn='l~:active' rp='Where is the
      active file?' . ./getfile active=&quot;$ans&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Additionally, the 'p' (path) letter may be used in conjunction with 'l' to
      tell <i>getfile</i> that an answer without a '/' in it should be accepted,
      assuming that it will be in everyone's PATH at the time this value will be
      needed.
    <div style="height: 1.00em;">&#x00A0;</div>
    Also useful is the possibility to specify a list of answers that should be
      accepted verbatim, bypassing all the checks. This list must be within
      parenthesis and items must be comma separated, with no interleaving
      spaces. Don't forget to quote the resulting string since parenthesis are
      meaningful to the shell. For instance: dflt='/bin/install'
      fn='/fe~(install,./install)' rp='Use which install program?' . ./getfile
      install=&quot;$ans&quot; would let the user only specify fully qualified
      paths referring to existing files, but still allow the special
      &quot;install&quot; and &quot;./install&quot; answers as-is (assuming of
      course something will deal with them specially later on in the chain since
      they do not conform with the general expected frame).
    <div style="height: 1.00em;">&#x00A0;</div>
    If the answer to the question is 'none', then the existence checks are
      skipped and the empty string is returned. Note that since <i>getfile</i>
      calls <i>myread</i> internally, all the features available with
      <i>myread</i> apply here to.
    <div style="height: 1.00em;">&#x00A0;</div>
    If a completely expanded value is needed (for instance in a Makefile), you
      may use the <i>$ansexp</i> variable which is always set up properly by
      <i>getfile</i> as the expanded version of <i>$ans</i>. Of course, it will
      not expand ~name if you did not allow that in the first place in the
      <i>$fn</i> variable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Inhdr.U</dt>
  <dd class="It-tag">This unit produces the <i>$inhdr</i> shell variable, used
      internally by <i>Configure</i> to check whether a set of headers exist or
      not. A typical use is: set header i_header [ header2 i_header2 ... ] eval
      $inhdr That will print a message, saying whether the header was found or
      not and set the <i>i_header</i> variable accordingly. If more than one
      header is specified and the first header is not found, we try the next
      one, until the list is empty or one is found.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Inlibc.U</dt>
  <dd class="It-tag">This unit produces the <i>$inlibc</i> shell variable, used
      internally by <i>Configure</i> to check whether a given C function is
      defined or not. A typical use is: set function d_func eval $inlibc That
      will print a message, saying whether the function was found or not and set
      <i>$d_func</i> accordingly. Internally, it used the <i>$csym</i>
    routine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Loc.U</dt>
  <dd class="It-tag">This important unit produces a shell script <i>loc</i>
      which can be used to find out where in a list of directories a given file
      lies. The first argument specifies the file to be located, the second
      argument is what will be returned if the search fails, and the reamining
      arguments are a list of directories where the file is to be searched. For
      instance: dflt=`./loc sendmail.cf X /usr/lib /var/lib/sendmail /lib` would
      set <i>$dflt</i> to <i>X</i> if no <i>sendmail.cf</i> file was found under
      the listed directories, or something like <i>/usr/lib/sendmail.cf</i> on
      some systems. See also <i>Getfile.U</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MailAuthor.U</dt>
  <dd class="It-tag">This unit needs to be included on the ?MAKE: line of your
      own private End.U to make it into <i>Configure</i>. It offers the user to
      register himself to the author, optionally being notified when new patches
      arrive or receiving them automatically when issued. You need to install
      <i>mailagent</i> to do this (at least version 3.0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MailList.U</dt>
  <dd class="It-tag">This unit needs to be included on the ?MAKE: line of your
      own private End.U to make it into <i>Configure</i>. It offers the user to
      subscribe or unsubscribe to a mailing list where discussion related to the
      package are taking place. You need to run <i>packinit</i> and answer the
      mailing list related questions to set up the proper variables in your
      <i>.package</i> before this unit may become operational.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Myinit.U</dt>
  <dd class="It-tag">Copy this unit into your private <i>U</i> directory to add
      your own default values to some internal variables. This unit is loaded
      into <i>Configure</i> after all the default initializations have been
      done.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Myread.U</dt>
  <dd class="It-tag">This unit produces the <i>myread</i> shell script that must
      be sourced in order to do a read. It allows shell escapes, default
      assignment and parameter evaluation, as documented in the Instruct.U unit.
      It also allows dynamic setting of the <b>-d</b> option, which will be used
      for the remaining of the script execution.
    <div style="height: 1.00em;">&#x00A0;</div>
    To use this unit, <i>$rp</i> must hold the question and <i>$dflt</i> should
      contain the default answer. The question will be printed by the script
      itself, and the result is returned in the <i>$ans</i> variable.
    <div style="height: 1.00em;">&#x00A0;</div>
    Here is a typical usage: dflt='y' rp='Question?' . ./myread
      value=&quot;$ans&quot; See the unit itself for more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Oldconfig.U</dt>
  <dd class="It-tag">This unit must be part of your dependency ?MAKE: line when
      some of your units tries to reuse an old symbol value. This unit is
      responsible for getting the old answers from <i>config.sh</i> or providing
      useful hints when running on a given platform for the first time. See the
      <i>Configure</i> <i>Hints</i> paragraph for more information about
    hints.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Prefixit.U</dt>
  <dd class="It-tag">The purpose of this unit is to detect changes in the
      installation prefix directory to recompute automatically suitable defaults
      from previous answers. It relies on the value of the <i>$oldprefix</i>
      variable which holds the previous prefix directory when it changed, and is
      empty otherwise. For instance, if the prefix was changed from <i>/opt</i>
      to <i>/usr/local</i>, then the previous binary installation directory will
      be changed from <i>/opt/bin</i> to <i>/usr/local/bin</i>, or will remain
      unchanged if it was, say, <i>/bin</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    You need to call <b>set</b> before issuing an <b>eval</b> on
      <i>$prefixit</i>, such as: set dflt var [dir] eval $prefixit which would
      set <i>$dflt</i> to <i>$var</i> or <i>$prefix/dir</i> depending on whether
      the prefix remained the same or not. If <i>dir</i> is the string
      <i>none</i>, a single space value in <i>$dflt</i> is kept as-is, even when
      the prefix changes. If <i>dir</i> is omitted, then <i>$dflt</i> is set to
      an empty string if the prefix changed, to <i>$var</i> otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Prefixup.U</dt>
  <dd class="It-tag">The intent of thit unit is similar to that of Prefixit.U,
      i.e. it helps fixing the default string to accommodate prefix changes.
      However, the shell variable <i>$prefixup</i>, when evaluated, will only
      restore ~name expansions, should prefix use such an escape mechanism. Use
      it as: set dflt eval $prefixup before prompting via <i>getfile</i> for
      instance. If the prefix does not make use of ~name expanstion, then the
      above will be a no-op on the <i>y</i> variable, naturally.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Typedef.U</dt>
  <dd class="It-tag">This unit produces the <i>$typedef</i> shell variable, used
      internally by <i>Configure</i> to check whether a typedef exists or not. A
      typical use is: set typedef val_t default [ includes ] eval $typedef This
      will set the variable <i>val_t</i> to the value of <i>default</i> if the
      typedef was not found among the listed include files, or to <i>typedef</i>
      if found. If no include files are specified, the unit looks in
      <i>&lt;sys/types.h&gt;</i> only. If you specifiy some includes, only those
      are looked at.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Unix.U</dt>
  <dd class="It-tag">The purpose of this unit is to define some of the most
      common UNIX-isms via variables which can be altered from the command line
      or via proper hint files. In particular, <i>$_exe</i>, <i>$_o</i> and
      <i>$_a</i> are set. All the units should refer to <i>$_o</i> and not to
      <i>.o</i> directly. The '.' is part of these variables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Setvar.U</dt>
  <dd class="It-tag">This unit produces the <i></i> variable, which is used
      internally by <i>Configure</i> to set a <i>define</i>/undef value to a
      given symbol, emitting a warning when it suddenly changes from a previous
      value. For instance: val=&quot;$define&quot; set d_variable eval $setvar
      If the previous <i>$d_variable</i> value was non-null and <i>$val</i> is
      different, a &quot;whoa&quot; warning is issued.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Whoa.U</dt>
  <dd class="It-tag">This unit produces the <i>whoa</i> script, which emits a
      warning when the <i>value</i> in variable whose name is <i>$var</i> is not
      the same as its old previous value held in <i>$was</i>. Upon return,
      <i>$td</i> and <i>$tu</i> hold the proper value to <i>define</i> or
      <i>undef</i> the variable. See examples in <i>Inlibc.U</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Builtin_Pre-processor"><a class="selflink" href="#Builtin_Pre-processor">Builtin
  Pre-processor</a></h2>
Each unit to be included in <i>Configure</i> is ran through a built-in
  pre-processor. Pre-processor statements are introduced by the '@' character
  ('#' is the shell comment character). It functions merely as the C
  pre-processor does but allows for shell and perl escapes. Here are the
  available functions:
<dl class="Bl-tag">
  <dt class="It-tag">@if <i>expression</i></dt>
  <dd class="It-tag">If <i>expression</i> is true, continue loading code until
      @end, @elsif or @else.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@elsif <i>expression</i></dt>
  <dd class="It-tag">Alternative choice. If <i>expression</i> is true, continue
      loading code until @end, another @elsif or @else.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@else</dt>
  <dd class="It-tag">Default code to be loaded if the @if <i>expression</i> was
      false and none of the optional @elsif matched. Load until @end.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@end</dt>
  <dd class="It-tag">Close the conditional loading statement opened by @if.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@define <i>symbol</i></dt>
  <dd class="It-tag">Tells the pre-processor that <i>symbol</i> is defined from
      now on.</dd>
</dl>
<div class="Pp"></div>
The conditional <i>expression</i> can include symbol names (value is true if
  symbol is wanted or defined via <i>@define</i> or shell/perl escapes. Those
  atoms can be combined using the traditional boolean operators '!' for
  negation, '&amp;&amp;' for logical and, and '||' for logical or.
<div class="Pp"></div>
Text enclosed within single brackets is a shell test, while text between double
  brakets is a perl test. Namely the expressions: { <i>shell text</i> } {{
  <i>perl text</i> }} are translated into: if <i>shell text</i> &gt;/dev/null
  2&gt;&amp;1; then exit 0; else exit 1; fi if ( <i>perl text</i>) {exit 0;}
  else {exit 1;} and the exit status is used in the standard way to get a
  boolean value, i.e. 0 is true and everything else is false. Note that only
  simple conditions can be expressed in perl, until some complex code can be
  loaded within <i>metaconfig</i> and executed.
<div class="Pp"></div>
The built-in pre-processor can be used to finely tune some units (see
  <i>d_gethname.U</i> for a complex example) depending on the symbols actually
  used by the program or the files present in the distribution. For instance,
  the <i>Oldconfig.U</i> uses a test like: @if {test -d ../hints} and
  <i>Configure</i> will contain hint-dependent code only if there is a
  <i>hints</i> directory in the package's top level directory. Note that tests
  are ran from within the ' <i>.MT</i>' directory, hence the needed '../' in the
  test.
<div class="Pp"></div>
The pre-processor can also be used to avoid putting useless code when a symbol
  is not defined. Units defining more than one symbol can be protected that way
  (since the unit is loaded as a whole) by gathering symbol-dependent code
  within an @if/@end pair. For instance: @if I_TIME || I_SYS_TIME ||
  I_SYS_TIME_KERNEL need_time_h='true' @else need_time_h='false' @end will test
  whether the source code makes any use of one of the three symbols that control
  the <i>time.h</i> or <i>sys/time.h</i> inclusion and define the shell symbol
  accordingly. That gives <i>Configure</i> a feedback on what the sources need
  and avoid the drawback of having fixed frozen units.
<div class="Pp"></div>
Via the '?W:' lines, you can get intersting combinations. For instance, the
  <i>i_time.U</i> unit needs to know whether the C sources make any use of the
  <i>struct timezone</i> type. Therefore, the line: ?W::timezone is used for its
  side-effect of defining the symbol <i>timezone</i> for the pre-processor. The
  unit code can then say: @if timezone for s_timezone in '-DS_TIMEZONE' ''; do
  @else s_timezone='' @end
<div style="height: 1.00em;">&#x00A0;</div>
... code using s_timezone ...
<div style="height: 1.00em;">&#x00A0;</div>
@if timezone done @end and have an extra loop trying two successive values for
  the <i>s_timezone</i> variable, but only if needed.
<h2 class="Ss" title="Ss" id="Obsolete_Symbols"><a class="selflink" href="#Obsolete_Symbols">Obsolete
  Symbols</a></h2>
Obsolete symbols are preserved to ease the transition with older
  <i>metaconfig</i> units. Unless the <b>-o</b> switch is passed to
  <i>metaconfig</i> they will be ignored. However, an <i>Obsolete</i> file will
  be generated, telling you which files are making use of those obsolete symbols
  and what are the new symbols to be used.
<div class="Pp"></div>
The lifetime for obsolete symbols is one full revision, i.e. they will be
  removed when the next base revision is issued (patch upgrades do not count of
  course). Therefore, it is wise to translate your sources and start using the
  new symbols as soon as possible.
<h2 class="Ss" title="Ss" id="Configure_Hints"><a class="selflink" href="#Configure_Hints">Configure
  Hints</a></h2>
It may happen that the internal configuration logic makes the wrong choices. For
  instance, on some platform, the <i>vfork()</i> system call is present but
  broken, so it should not be used. It is not possible to include that knowledge
  in the units themselves, because that might be a temporary problem which the
  vendor will eventually fix, or something that was introduced by a new OS
  upgrade.
<div class="Pp"></div>
Anyway, for all those tiny little problems that are too system-specific,
  <i>metaconfig</i> provides hint files support. To use it, you need to create a
  <i>hints</i> directory in the package's top level directory, and have it when
  you run <i>metaconfig</i>. That will load the hint-related part from
  <i>Oldconfig.U</i>.
<div class="Pp"></div>
From then on, you may pre-set some of the shell variables <i>Configure</i> uses
  in an OS-specific .sh file. There is code in <i>Oldconfig.U</i> that tries to
  guess which hint files are needed by computing a standard name based on the
  system OS name, the kernel name, the release number, etc... Since this
  information is likely to change rapidly, I'm not documenting it here. You have
  to reverse engineer the code from <i>Oldconfig.U</i>.
<div class="Pp"></div>
When you first release your package, your hints file directory should be empty.
  If the users of your package complain that they have problem with
  <i>Configure</i> defaults on a particular system, you have to see whether this
  is a platform-specific problem or a general one. In the former case, it's time
  to introduce a new hint file, while in the latter, the corresponding unit
  should be revised.
<div class="Pp"></div>
For instance, SGI systems are known to have a broken <i>vfork()</i> system call,
  as of this writing. And the corresponding hint file name is <i>sgi.sh</i>. So
  all you need to do is create a <i>hints/sgi.sh</i> file in which you write:
  d_vfork=&quot;$define&quot; which will always remap <i>vfork</i> on
  <i>fork</i> (see <i>d_vfork.U</i>). When running on SGI systems for the first
  time, <i>Configure</i> will detect that there is an <i>hints/sgi.sh</i> file,
  and that we are on an IRIX machine (the kernel name is often /irix), therefore
  it will propose <i>sgi</i> as a possible hint. If the user accepts it, and
  since the <i>$d_vfork</i> value is modified via the <i>$setvar</i> call, a
  <i>whoa!</i> will be emitted to warn that we are about to override the value
  computed by <i>Configure</i>.
<div class="Pp"></div>
Note that you don't have to provide <i>all</i> the hints known by
  <i>Oldconfig.U</i>. If a hint file is missing, it will not be proposed as a
  possible choice. The heuristic tests ran to compute the possible hint
  candidates are flaky. If you have new values or different tests, please send
  them to me...
<h2 class="Ss" title="Ss" id="Overriding_Choices"><a class="selflink" href="#Overriding_Choices">Overriding
  Choices</a></h2>
If you create a <i>config.over</i> file in the top level directory,
  <i>Configure</i> will ask you if you wish to load it to override the default
  values. This is done prior creation of the <i>config.sh</i> file, so it gives
  you a chance to patch the values stored in there.
<div class="Pp"></div>
This is distinct from the hints approach in that it is a local file, which the
  user is free to create for his own usage. You should not provide such a file
  yourself, but let the user know about this possibility.
<h2 class="Ss" title="Ss" id="Configure_Options"><a class="selflink" href="#Configure_Options">Configure
  Options</a></h2>
The <i>Configure</i> script may be called with some options specified on the
  command line, to slightly modify its behaviour. Here are the allowed options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b></dt>
  <dd class="It-tag">Use defaults for all answers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b></dt>
  <dd class="It-tag">Go on without questioning past the production of
      <i>config.sh</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f <i>file</i></b></dt>
  <dd class="It-tag">Use the specified file as a default configuration. If this
      switch is not used, the configuration is taken from <i>config.sh</i>, when
      present.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">Print help message and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b></dt>
  <dd class="It-tag">Reuse C symbols value if possible. This will skip the
      costly <i>nm</i> symbol extraction. If used the first time (with no
      previous configuration file), <i>Configure</i> will try to compile and
      link a small program in order to know about the presence of a symbol, or
      absence thereof.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b></dt>
  <dd class="It-tag">Silent mode. Only strings printed on file descriptor #4
      will be seen on the screen (that's the important messages). It's not
      possible to completely turn off any output, but you may use ' <i>Configure
      -ders &gt;/dev/null 2&gt;&amp;1</i>' to have a full batch run with no
      output and no user interaction required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D<i> symbol=value</i></b></dt>
  <dd class="It-tag">Pre-defines <i>symbol</i> to bear the specified
      <i>value</i>. It is also possible to use ' <b>-D</b><i> symbol</i>' which
      will use a default value of 'define'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E</b></dt>
  <dd class="It-tag">Stop at the end of the configuration questions, after
      having produced a <i>config.sh</i>. This will not perform any '<i>make
      depend</i>' or .SH files extraction.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-K</b></dt>
  <dd class="It-tag">Knowledgeable user. When you use this option, you know what
      you are doing and therefore the <i>config.sh</i> file will always be
      handled as if it was intended to be re-used, even though it might have
      been generated on an alien system. It also prevents aborting when
      <i>Configure</i> detects an unusable C compiler or a wrong set of C flags.
      Further shortcuts might be turned on by this option as well in the future.
      This option is documented in the <i>Configure</i> usage message, to remind
      us about its existence, but the given description is hoped to be cryptic
      enough. :-)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-O</b></dt>
  <dd class="It-tag">Allow values specified via a <b>-D</b> or <b>-U</b> to
      override settings from any loaded configuration file. This is not the
      default behaviour since the overriding will not be propagated to variables
      derived from those you are presently altering. Naturally, without
      <b>-O</b>, the setting is only done when no configuration file is loaded,
      which is safe since derivative variables have not been computed
    yet...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b></dt>
  <dd class="It-tag">Perform variable substitution on all the .SH files. You can
      combine it with the <b>-f</b> switch to propagate any configuration you
      like.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-U<i> symbol=</i></b></dt>
  <dd class="It-tag">Pre-sets <i>symbol</i> to bear an empty value. It is also
      possible to use ' <b>-U</b><i> symbol</i>' which will set <i>symbol</i> to
      'undef'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag">Print the version number of the <i>metaconfig</i> that
      generated this <i>Configure</i> script and exit.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Running_Environment"><a class="selflink" href="#Running_Environment">Running
  Environment</a></h2>
Upon starting, <i>Configure</i> creates a local <i>UU</i> directory and runs
  from there. The directory is removed when Configure ends, but this means you
  must run the script from a place where you can write, i.e. not from a
  read-only file system.
<div class="Pp"></div>
You can run <i>Configure</i> remotely though, as in: 	../package/Configure to
  configure sources that are not present locally. All the generated files will
  be put in the directory where you're running the script from. This magic is
  done thanks to the src.U unit, which is setting the <i>$src</i> and
  <i>$rsrc</i> variables to point to the package sources. That path is full or
  relative, depending on whether <i>Configure</i> was invoked via a full or
  relative path.
<div class="Pp"></div>
From within the <i>UU</i> subdirectory, you can use <i>$rsrc</i> to access the
  source files (units referring to source files link hints shall always use this
  mechanism and not assume the file is present in the parent directory). All the
  Makefiles should use the $src variable as a pointer to the sources from the
  top of the build directory (where <i>Configure</i> is run), either directly or
  via a VPATH setting.
<div class="Pp"></div>
When running <i>Configure</i> remotely, the .SH files are extracted in the build
  directory, not in the source tree. However, it requires some kind of a
  <i>make</i> support to be able to compile things in a build directory whilst
  the sources lie elsewhere.
<h2 class="Ss" title="Ss" id="Using_Magic_Redefinitions"><a class="selflink" href="#Using_Magic_Redefinitions">Using
  Magic Redefinitions</a></h2>
By making use of the <b>-M</b> switch, some magic remappings may take place
  within a <i>confmagic.h</i> file. That file needs to be included after
  <i>config.h</i>, of course, but also after all the other needed include files.
  Namely: #include &quot;config.h&quot; ... ... <i>other inclusions</i> ... ...
  #include &quot;confmagic.h&quot; Typically, <i>confmagic.h</i> will attempt to
  remap <i>bcopy()</i> on <i>memcpy()</i> if no <i>bcopy()</i> is available
  locally, or transform <i>vfork</i> into <i>fork</i> when necessary, hence
  making it useless to bother about the <i>HAS_VFORK</i> symbol.
<div class="Pp"></div>
This configuration magic is documented in the Glossary file.
<h2 class="Ss" title="Ss" id="Unit_Templates"><a class="selflink" href="#Unit_Templates">Unit
  Templates</a></h2>
There is a set of unit templates in the <i>metaconfig</i> source directory,
  which are intended to be used by a (not yet written) program to quickly
  produce new units for various kind of situations. No documentation for this
  unfinished project, but I thought I would mention it in the manual page in
  case you wish to do it yourself and then contribute it...
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Larry Wall &lt;lwall@netlabs.com&gt; for version 2.0.
<div>&#x00A0;</div>
Harlan Stenn &lt;harlan@mumps.pfcs.com&gt; for important unit extensions.
<div>&#x00A0;</div>
Raphael Manfredi &lt;ram@hptnos02.grenoble.hp.com&gt;.
<div>&#x00A0;</div>
Many other contributors for the <i>metaconfig</i> units. See the credit file for
  a list.
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">LIB/dist/mcon/U/*.U</dt>
  <dd class="It-tag">Public unit files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">U/*.U</dt>
  <dd class="It-tag">Private unit files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">LIB/dist/mcon/Glossary</dt>
  <dd class="It-tag">Glossary file, describing all the metaconfig symbols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Obsolete</dt>
  <dd class="It-tag">Lists all the obsolete symbols used by the sources.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Wanted</dt>
  <dd class="It-tag">Lists all the wanted symbols.
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
    where LIB is /usr/share/dist.
    <br/>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Units are sometimes included unnecessarily if one of its symbols is accidentally
  mentioned, e.g. in a comment. Better too many units than too few, however.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
pat(1), makeSH(1), makedist(1), metalint(1)</div>
<table class="foot">
  <tr>
    <td class="foot-date">Version 3.5 PL0</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
