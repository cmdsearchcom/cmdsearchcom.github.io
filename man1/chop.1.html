<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:58:24 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>chop(1) User Commands chop(1)</p>

<p style="margin-top: 1em">NAME <br>
chop - find irreducible constituents of a matrix</p>

<p style="margin-top: 1em">SYNOPSIS <br>
chop [OPTIONS] &lt;Name&gt;</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This program calculates the irreducible constituents of a
given matrix representation. The representing matrices of
the generators are read from input files, see &quot;INPUT
FILES&quot; <br>
below. Unless a different number of generators has been
specified with -g, two generators are expected. However, if
the -i option is used, and the file Name.cfinfo exists, chop
<br>
takes the number of generators from this file and ignores
the -g option.</p>

<p style="margin-top: 1em">For each composition factor chop
writes the action of the generators to CFName.1, CFName.2,
.... CFName is the name of the composition factor, which is
constructed by appending <br>
the dimension and a letter to the module name. For example,
&quot;X10a.1&quot; is the action of the first generator on
the first composition factor of dimension 10 of the module
X. If a <br>
second, inequivalent composition factor of dimension 10 was
found, it would be named &quot;X10b&quot; and so on. Chop
also creates the file Name.cfinfo containing a list of all
composi&acirc; <br>
tion factors. This file is used by subsequent programs such
as pwkond(1).</p>

<p style="margin-top: 1em">OPTIONS <br>
-Q Quiet, no messages.</p>

<p style="margin-top: 1em">-V Verbose, more messages.</p>

<p style="margin-top: 1em">-T &lt;MaxTime&gt; <br>
Set CPU time limit</p>

<p style="margin-top: 1em">-G, --gap <br>
Produce output in GAP format. This option implies -Q.</p>

<p style="margin-top: 1em">-g &lt;NGen&gt; <br>
Set the number of generators. Default: 2.</p>

<p style="margin-top: 1em">-s &lt;Word&gt; <br>
Start with word number Word. Default: 1.</p>

<p style="margin-top: 1em">-n &lt;MaxNul&gt; <br>
Set limit on nullity. Default: 3.</p>

<p style="margin-top: 1em">-d &lt;MaxDeg&gt; <br>
Set limit on degrees of polynomials. Default: 5.</p>

<p style="margin-top: 1em">-i, --read-cfinfo <br>
Read Name.cfinfo, if it exists</p>

<p style="margin-top: 1em">IMPLEMENTATION DETAILS <br>
Chop repeatedly splits a module into submodule and quotient
until it arrives at the irreducible constituents. Thus, it
finds a composition series. The program assumes that the
<br>
algebra generated by the input matrices contains the unit
matrix.</p>

<p style="margin-top: 1em">In order to split a given module
or to prove its irreducibility the algorithm needs an
element of the algebra with a nontrivial but low-dimensional
kernel. Such elements are <br>
searched by taking linear combinations of certain products
of the generators (&quot;words&quot;). By default, chop
tries all words in the order defined by the word generator.
The -s <br>
option may be used to make chop start with a word different
from 1.</p>

<p style="margin-top: 1em">For each word A generated in
this way, the program calculates its characteristic
polynomial and examines the irreducible factors. If p(x) is
an irreducible factor, p(A) has a <br>
nontrivial kernel. Then, one vector of the kernel is chosen
and the smallest submodule containing this vector is
calculated. If the vector spans a proper submodule, the
action <br>
of the generators on this submodule as well as on the
quotient are calculated and the same procedure is applied
recursively to both submodule and quotient.</p>

<p style="margin-top: 1em">To avoid expensive matrix
multiplications in the calculation of p(A), there is a limit
on the degree of p(x). This limit can be set with the -d
option and defaults to 5.</p>

<p style="margin-top: 1em">If a module cannot be split by
the program, it may be irreducible. In order to prove this,
chop uses Norton&rsquo;s criterion. This requires, however,
to find an algebra element with <br>
a small kernel, because up to scalar multiples each vector
in the kernel must be examined to see whether it spins up to
the whole module. For this reason a &quot;nullity
threshold&quot; m <br>
is maintained by the program. Initially, m is set to 3 or to
the value given in the -n option. Each algebra element that
has a nullity less then or equal to m is used for the <br>
Norton test.</p>

<p style="margin-top: 1em">In some cases the algorithm
described is not able to split the module although it is
reducible. These exceptional cases are treated with an
alternative strategy described in Lux <br>
and Ivanyos, &quot;Treating the exceptional cases of the
Meataxe&quot;, 19 Feb 1998 (unpublished).</p>

<p style="margin-top: 1em">Algebra elements with trivial
kernel are useless for the algorithm, so an attempt is made
to avoid unnecessary computation of such elements. Once an
element is known to have a <br>
trivial kernel on a given module M, the program will mark it
as invertible and ignore it for all constituents of M.</p>

<p style="margin-top: 1em">If a constituent is irreducible
but not absolutely irreducible, the nullity of any element
in the algebra will be a multiple of [E:F], where F is the
ground field and E the <br>
splitting field. This situation is recognized by calculating
the greatest common divisor d of all nullities which occur
during the search. In order to prove that the splitting <br>
field degree is equal to d, the following method is used:
Take a word with nullity d and two vectors v1, v2 in its
null-space. Use these vectors as seeds for a standard basis
<br>
algorithm. If the resulting representations are different,
[E:F] is less than d, and the word is discarded. Otherwise,
the linear map which transforms one standard basis into <br>
the other is an endomorphism e of the module. If v1, under
the action of e, spins up to the whole null space, then
[E:F]=d. Otherwise, take a third vector not in the span and
<br>
repeat the procedure above. Again, this yields an
endomorphism, or it turns out that [E:F]&lt;d. These steps
are repeated until a word with nullity [E:F] is found.</p>

<p style="margin-top: 1em">INPUT FILES <br>
Name.{1,2,...} <br>
Generators.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
Name.cfinfo <br>
Constituent info file</p>

<p style="margin-top: 1em">CFName.{1,2,...} <br>
Generators on the constituents.</p>

<p style="margin-top: 1em">SEE ALSO <br>
cfcomp(1), pseudochop(q), pwkond(1)</p>

<p style="margin-top: 1em">MeatAxe 2.4.24 chop(1)</p>
<hr>
</body>
</html>
