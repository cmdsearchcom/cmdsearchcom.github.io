<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>OGMMERGE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">OGMMERGE(1)</td>
    <td class="head-vol">User Commands</td>
    <td class="head-rtitle">OGMMERGE(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
ogmmerge - Merge multimedia streams into an OGG/OGM file
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>ogmmerge</b> [ <i>global options</i>] -o <i>out</i> [<i>options</i>]
  &lt;file1&gt; [[ <i>options</i>] &lt;file2&gt; ...]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This program takes the input from several media files and joins their streams
  (all of them or just a selection) into an OGM. It was formerly known as
  'oggmerge' and is based on the 'oggmerge' CVS module from Xiph's repository
  <a class="Lk" title="Lk" href="http://www.xiph.org/">(&lt;http://www.xiph.org/&gt;).</a>
<div class="Pp"></div>
Global options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b>, <b>--verbose</b></dt>
  <dd class="It-tag">Increase verbosity.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b>, <b>--quiet</b></dt>
  <dd class="It-tag">Suppress status output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b>, <b>--output</b> <i>out</i></dt>
  <dd class="It-tag">Write to the file '<i>out</i>'.</dd>
</dl>
<div class="Pp"></div>
Options that can be used for each input file:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b>, <b>--astreams</b>
    &lt;<i>n</i>,<i>m</i>,...&gt;</dt>
  <dd class="It-tag">Copy the <i>n</i>'th audio stream, NOT the stream with the
      serial no. <i>n</i>. Default: copy all audio streams.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b>, <b>--vstreams</b>
    &lt;<i>n</i>,<i>m</i>,...&gt;</dt>
  <dd class="It-tag">Copy the <i>n</i>'th video stream, NOT the stream with the
      serial no. <i>n</i>. Default: copy all video streams.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b>, <b>--tstreams</b>
    &lt;<i>n</i>,<i>m</i>,...&gt;</dt>
  <dd class="It-tag">Copy the <i>n</i>'th text stream, NOT the stream with the
      serial no. <i>n</i>. Default: copy all text streams.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b>, <b>--noaudio</b></dt>
  <dd class="It-tag">Don't copy any audio stream from this file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b>, <b>--novideo</b></dt>
  <dd class="It-tag">Don't copy any video stream from this file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b>, <b>--notext</b></dt>
  <dd class="It-tag">Don't copy any text stream from this file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b>, <b>--sync</b>
    &lt;<i>d</i>[,<i>o</i>[/<i>p</i>]]&gt;</dt>
  <dd class="It-tag">Synchronize manually, delay the audio stream by <i>d</i>
      ms.
    <div>&#x00A0;</div>
     <i>d</i> &gt; 0: Pad with silent samples.
    <div>&#x00A0;</div>
     <i>d</i> &lt; 0: Remove samples from the beginning.
    <div>&#x00A0;</div>
     <i>o</i>/<i>p</i>: adjust the timestamps by <i>o</i>/<i>p</i> to fix linear
      drifts. <i>p</i> defaults to 1000 if omitted. Both <i>o</i> and <i>p</i>
      can be floating point numbers.
    <div>&#x00A0;</div>
    Defaults: no manual synch correction (which is the same as <i>d</i> = 0 and
      <i>o</i>/<i>p</i> = 1.0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b>, <b>--range</b>
    &lt;<i>start</i>-<i>end</i>&gt;</dt>
  <dd class="It-tag">Only process from <i>start</i> to <i>end</i>. Both values
      take the form ' <i>HH:MM:SS.mmm</i>' or '<i>SS.mmm</i>', e.g.
      '00:01:00.500' or '60.500'. If one of <i>start</i> or <i>end</i> is
      omitted then it defaults to 0 or to end of the file respectively.
    <div>&#x00A0;</div>
    If you want to split a file into smaller ones I strongly suggest you use
      <b>ogmsplit(1)</b> as it can do a much better job than using the <b>-r</b>
      option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b>, <b>--comment</b> '<i>A=B#C=D</i>' or
    '<i>@filename</i>'</dt>
  <dd class="It-tag">Set additional comment fields for the streams. Sensitive
      values would be ' <i>LANGUAGE=English</i>' or '<i>TITLE=Ally McBeal</i>'.
      If the parameter starts with '@' then the comments will be read from a
      file with the same name without the leading '@'. <b>-c</b> can be
      specified multiple times per file. The comments will all be
    concatenated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b>, <b>--fourcc</b> &lt;<i>FourCC</i>&gt;</dt>
  <dd class="It-tag">Forces the FourCC to the specified value. Works only for
      video streams. Note that you cannot simply use a hex editor and change the
      FourCC by hand as the OGG file format uses checksums which would be wrong
      after such a change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--omit-empty-packets</b></dt>
  <dd class="It-tag">Normally, when a subtitle entry should be removed, an empty
      packet is created and inserted with the appropriate timestamp. With this
      option these empty packets are omitted completely.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--old-headers</b></dt>
  <dd class="It-tag">Assume that the input file has been created with an older
      version of <b>ogmmerge</b> ( &lt; 1.1). This may be needed if ogmmerge
      cannot read such a file correctly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--nav-seek</b> &lt;<i>filename</i>&gt;</dt>
  <dd class="It-tag">Use an external AVI index file as generated by
      <b>aviindex</b> from the transcode package. Can be used if an AVI file has
      a broken index.</dd>
</dl>
<div class="Pp"></div>
Other options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b>, <b>--list-types</b></dt>
  <dd class="It-tag">List supported input file types.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>, <b>--help</b></dt>
  <dd class="It-tag">Show usage information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b>, <b>--version</b></dt>
  <dd class="It-tag">Show version information.</dd>
</dl>
<h1 class="Sh" title="Sh" id="USAGE"><a class="selflink" href="#USAGE">USAGE</a></h1>
For each file the user can select which tracks <b>ogmmerge</b> should take. They
  are all put into the file specified with '-o'. A list of known (and supported)
  source formats can be obtained with the '-l' option.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
Let's assume you have a file called <i>MyMovie.avi</i> and the audio track in a
  separate file, e.g. <i>MyMovie.wav</i>. First you want to encode the audio to
  OGG:
<div class="Pp"></div>
$ <b>oggenc -q4 -oMyMovie.ogg MyMovie.wav</b>
<div class="Pp"></div>
After a couple of minutes you can join video and audio:
<div class="Pp"></div>
$ <b>ogmmerge -o MyMovie-with-sound.ogm MyMovie.avi MyMovie.ogg</b>
<div class="Pp"></div>
If your AVI already contains an audio track then it will be copied aswell (if
  <b>ogmmerge</b> supports the audio format). To avoid that simply do
<div class="Pp"></div>
$ <b>ogmmerge -o MyMovie-with-sound.ogm -A MyMovie.avi MyMovie.ogg</b>
<div class="Pp"></div>
After some minutes of consideration you rip another audio track, e.g. the
  director's comments or another language to <i>MyMovie-add-audio.wav</i>.
  Encode it again and join it up with the other file:
<div class="Pp"></div>
$ <b>oggenc -q4 -oMyMovie-add-audio.ogg MyMovie-add-audio.wav</b>
<div>&#x00A0;</div>
$ <b>ogmmerge -o MM-complete.ogm MyMovie-with-sound.ogm
  MyMovie-add-audio.ogg</b>
<div class="Pp"></div>
The same result can be achieved with
<div class="Pp"></div>
$ <b>ogmmerge -o MM-complete.ogm -A MyMovie.avi MyMovie.ogg \</b>
<div>&#x00A0;</div>
<br/>
 <b>MyMovie-add-audio.ogg</b>
<div class="Pp"></div>
Now fire up mplayer and enjoy. If you have multiple audio tracks (or even video
  tracks) then you can tell mplayer which track to play with the ' <b>-vid</b>'
  and ' <b>-aid</b>' parameters. These are 0-based and do not distinguish
  between video and audio.
<div class="Pp"></div>
If you need an audio track synchronized you can do that easily with
<div class="Pp"></div>
$ <b>ogmmerge -o goodsync.ogm -A source.avi -s 200 outofsync.ogg</b>
<div class="Pp"></div>
This would add 200ms of silence at the beginning of the audio tracks taken from
  <i>outofsync.ogg</i>. And <b>-s</b> always applies to all audio tracks in a
  source file. If you want to apply <b>-s</b> only to a specific track then take
  the same source file more than once and add <b>-a</b> and <b>-s</b>
  accordingly.
<div class="Pp"></div>
Some movies start synced correctly but slowly drift out of sync. For these kind
  of movies you can specify a delay factor that is applied to all timestamps -
  no data is added or removed. So if you make that factor too big or too small
  you'll get bad results. An example is that an episode I transcoded was 0.2
  seconds out of sync at the end of the movie which was 77340 frames long. At
  29.97fps 0.2 seconds correspond to approx. 6 frames. So I did
<div class="Pp"></div>
$ <b>ogmmerge -o goodsync.ogm -s 0,77346/77340 outofsync.ogm</b>
<div class="Pp"></div>
The result was fine.
<div class="Pp"></div>
The sync options can also be used for subtitles in the same manner.
<div class="Pp"></div>
For text subtitles you can either use some Windows software (like
  <b>SubRipper</b>) or the <b>subrip</b> package found in <b>transcode(1)</b>'s
  sources (in <b>contrib/subrip</b>). The general process is:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">extract a raw subtitle stream from the source:
    <div>&#x00A0;</div>
    $ <b>tccat -i /path/to/copied/dvd/ -T 1 -L | \</b>
    <div>&#x00A0;</div>
    <br/>
     tcextract -x ps1 -t vob -a 0x20 | \
    <div>&#x00A0;</div>
    <br/>
     subtitle2pgm -o mymovie <b></b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">convert the resulting PGM images to text with <b>gocr</b>:
    <div>&#x00A0;</div>
    $ <b>pgm2txt mymovie</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">spell-check the resulting text files:
    <div>&#x00A0;</div>
    $ <b>ispell -d american *txt</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">convert the text files to a SRT file:
    <div>&#x00A0;</div>
    $ <b>srttool -s -w -i mymovie.srtx -o mymovie.srt</b></dd>
</dl>
<div class="Pp"></div>
The resulting file can be used as another input file for <b>ogmmerge</b>:
<div class="Pp"></div>
$ <b>ogmmerge -o mymovie.ogm -c 'TITLE=My Movie' mymovie.avi \</b>
<div>&#x00A0;</div>
<br/>
 -c LANGUAGE=English mymovie.ogg -c LANGUAGE=English mymovie.srt <b></b>
<h1 class="Sh" title="Sh" id="FILE_SIZE"><a class="selflink" href="#FILE_SIZE">FILE
  SIZE</a></h1>
Using OGG as the container format introduces overhead - each OGG packet has a
  header, and each OGG packet can span one or more OGG pages, which itself again
  contain headers. Several tests show that the overhead is bigger than the
  overhead introduced by AVI (comparing video only files and files with video
  and MP3 audio).
<div class="Pp"></div>
The overhead is defined as <i>file size</i> - <i>raw stream size</i>.
  <b>mencoder</b> prints the raw stream size after encoding, so you'll be able
  to get that information rather easily.
<div class="Pp"></div>
Most of the times you want to calculate the overhead prior to encoding in order
  to adjust the bitrate accordingly. Unfortunately the overhead per frame is not
  constant - only the percentage is constant. This percentage is calculated as
  100 * ( <i>OGG size</i> - <i>raw size</i>) / <i>raw size</i> and seems to be
  somewhere between <b>1.1%</b> and <b>1.2%</b>. This depends on the number of
  streams and the stream types used.
<div class="Pp"></div>
The <i>raw size</i> itself can be approximated by
<div>&#x00A0;</div>
<br/>
 <i>frames</i> * <i>vbitrate</i>
<div>&#x00A0;</div>
<i>raw size</i> = ( ----------------- + <i>length</i> * <i>abitrate</i> ) / 8 *
  1000 * 1024
<div>&#x00A0;</div>
<br/>
 <i>frames per sec</i>
<div>&#x00A0;</div>
assuming that <i>vbitrate</i> and <i>abitrate</i> are given in kbit/s = 1000
  bit/s, and <i>length</i> is given in seconds.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
What works:
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">AVI as the video and audio source (currently only raw PCM,
      MP3 and AC3 audio tracks)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">OGG as the source for video, audio (Vorbis, raw PCM, MP3
      and AC3 audio) and text streams (subtitles).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">WAV as the audio source</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">MP3 audio files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">AC3 audio files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Track selection</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Manual audio synchronization by adding silence/removing
      packets for Vorbis audio and for text streams by adjusting the starting
      point and duration.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Manual audio synchronization for AC3 and MP3 audio by
      duplicating/removing packets at the beginning.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Adding user comments to the mandatory comment headers (only
      the headers are mandatory. Comments themselves are not mandatory.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Text subtitles can be read from SRT (SubRipper / subrip)
      and MicroDVD files or taken from other OGM files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">PCM, AC3 and MP3 audio work well under Windows and with
      MPlayer now.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Chapter information as generated by <b>dvdxchap</b> are
      supported.</dd>
</dl>
<div class="Pp"></div>
What not works:
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Manual audio synchronization for PCM sound (who needs it
      anyway?)</dd>
</dl>
<div class="Pp"></div>
Planned functionality:
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">support for other subtitle formats</dd>
</dl>
<h1 class="Sh" title="Sh" id="CHAPTERS"><a class="selflink" href="#CHAPTERS">CHAPTERS</a></h1>
<b>ogmmerge</b> supports chapter information as generated by <b>dvdxchap(1)</b>.
  The format is very simple:
<div class="Pp"></div>
CHAPTER01=HH:MM:SS.sss
<div>&#x00A0;</div>
CHAPTER01NAME=the first chapter
<div>&#x00A0;</div>
CHAPTER02=HH:MM:SS.sss
<div>&#x00A0;</div>
CHAPTER02NAME=another chapter
<div class="Pp"></div>
with HH = hour, MM = minute, SS = seconds, sss = milliseconds.
<div class="Pp"></div>
The chapter information is stored in the video stream's comments. Therefore you
  could also specify the chapters with <i>-c CHAPTER01=...</i> Using a chapter
  file has an advantage: If the video stream's comments already contain chapter
  information and the command line contains a chapter information file then the
  existing chapter information will be completely replaced.
<h1 class="Sh" title="Sh" id="TECHNICAL_ASPECTS"><a class="selflink" href="#TECHNICAL_ASPECTS">TECHNICAL
  ASPECTS</a></h1>
This section is not needed by the average user.
<div class="Pp"></div>
<b>ogmmerge</b> consists of three parts:
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Demultiplexers (called readers) open and read input files
      specified on the command line and extract specific tracks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">Packetizers (or output modules) take data from a
      demultiplexer and encapsulate them into OGG pages. These are stored in
      queues.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">The main program requests from every known demultiplexer
      that it should read some data. It then gets the OGG page with the smallest
      timestamp from all the packetizer queues. This page is written to the
      output file.</dd>
</dl>
<div class="Pp"></div>
The general class definitions for the readers and the packetizers can be found
  in <b>ogmmerge.h</b>.
<div class="Pp"></div>
The main loop expects that the queues managed by the demuxer's packetizers are
  filled with at least one page after a call to the demuxer's <b>read()</b>
  function. The demuxer must make sure that enough data is passed to each of its
  associated packetizers. Have a look at <b>r_ogm.cpp</b>.
<div class="Pp"></div>
A possible setup might look like this:
<div class="Pp"></div>
<br/>
 +-&gt; p_video
<div>&#x00A0;</div>
<br/>
 +-&gt; r_avi -+
<div>&#x00A0;</div>
<br/>
 | +-&gt; p_pcm
<div>&#x00A0;</div>
<br/>
 |
<div>&#x00A0;</div>
<b>ogmmerge</b> -+-&gt; r_ogm ---&gt; p_vorbis
<div>&#x00A0;</div>
<br/>
 |
<div>&#x00A0;</div>
<br/>
 | +-&gt; p_video
<div>&#x00A0;</div>
<br/>
 | |
<div>&#x00A0;</div>
<br/>
 +-&gt; r_ogm -+-&gt; p_vorbis
<div>&#x00A0;</div>
<br/>
 |
<div>&#x00A0;</div>
<br/>
 +-&gt; p_vorbis
<div class="Pp"></div>
One AVI source with a video and an audio track, one OGG/OGM source with only one
  Vorbis track, another OGG/OGM source with a video and two Vorbis tracks.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
<i>ogmmerge</i> was written by Moritz Bunkus &lt;moritz@bunkus.org&gt;.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>ogmdemux</b>(1), <b>ogmsplit</b>(1), <b>ogminfo</b>(1), <b>ogmcat</b>(1),
  <b>dvdxchap</b>(1)
<h1 class="Sh" title="Sh" id="WWW"><a class="selflink" href="#WWW">WWW</a></h1>
The newest version can always be found at
  <a class="Lk" title="Lk" href="http://www.bunkus.org/videotools/ogmtools/">&lt;http://www.bunkus.org/videotools/ogmtools/&gt;</a></div>
<table class="foot">
  <tr>
    <td class="foot-date">November 2004</td>
    <td class="foot-os">ogmmerge v1.5</td>
  </tr>
</table>
</body>
</html>
