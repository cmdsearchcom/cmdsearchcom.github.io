<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:28:26 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OGMMERGE(1) User Commands OGMMERGE(1)</p>

<p style="margin-top: 1em">NAME <br>
ogmmerge - Merge multimedia streams into an OGG/OGM file</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ogmmerge [global options] -o out [options] &lt;file1&gt;
[[options] &lt;file2&gt; ...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This program takes the input from several media files and
joins their streams (all of them or just a selection) into
an OGM. It was formerly known as &rsquo;oggmerge&rsquo; and
is based on <br>
the &rsquo;oggmerge&rsquo; CVS module from Xiph&rsquo;s
repository (&lt;http://www.xiph.org/&gt;).
&acirc;&uml;http://www.xiph.org/&acirc;&copy;</p>

<p style="margin-top: 1em">Global options:</p>

<p style="margin-top: 1em">-v, --verbose <br>
Increase verbosity.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Suppress status output.</p>

<p style="margin-top: 1em">-o, --output out <br>
Write to the file &rsquo;out&rsquo;.</p>

<p style="margin-top: 1em">Options that can be used for
each input file:</p>

<p style="margin-top: 1em">-a, --astreams &lt;n,m,...&gt;
<br>
Copy the n&rsquo;th audio stream, NOT the stream with the
serial no. n. Default: copy all audio streams.</p>

<p style="margin-top: 1em">-d, --vstreams &lt;n,m,...&gt;
<br>
Copy the n&rsquo;th video stream, NOT the stream with the
serial no. n. Default: copy all video streams.</p>

<p style="margin-top: 1em">-t, --tstreams &lt;n,m,...&gt;
<br>
Copy the n&rsquo;th text stream, NOT the stream with the
serial no. n. Default: copy all text streams.</p>

<p style="margin-top: 1em">-A, --noaudio <br>
Don&rsquo;t copy any audio stream from this file.</p>

<p style="margin-top: 1em">-D, --novideo <br>
Don&rsquo;t copy any video stream from this file.</p>

<p style="margin-top: 1em">-T, --notext <br>
Don&rsquo;t copy any text stream from this file.</p>

<p style="margin-top: 1em">-s, --sync &lt;d[,o[/p]]&gt;
<br>
Synchronize manually, delay the audio stream by d ms. <br>
d &gt; 0: Pad with silent samples. <br>
d &lt; 0: Remove samples from the beginning. <br>
o/p: adjust the timestamps by o/p to fix linear drifts. p
defaults to 1000 if omitted. Both o and p can be floating
point numbers. <br>
Defaults: no manual synch correction (which is the same as d
= 0 and o/p = 1.0).</p>

<p style="margin-top: 1em">-r, --range &lt;start-end&gt;
<br>
Only process from start to end. Both values take the form
&rsquo;HH:MM:SS.mmm&rsquo; or &rsquo;SS.mmm&rsquo;, e.g.
&rsquo;00:01:00.500&rsquo; or &rsquo;60.500&rsquo;. If one
of start or end is omitted then it defaults <br>
to 0 or to end of the file respectively. <br>
If you want to split a file into smaller ones I strongly
suggest you use ogmsplit(1) as it can do a much better job
than using the -r option.</p>

<p style="margin-top: 1em">-c, --comment
&rsquo;A=B#C=D&rsquo; or &rsquo;@filename&rsquo; <br>
Set additional comment fields for the streams. Sensitive
values would be &rsquo;LANGUAGE=English&rsquo; or
&rsquo;TITLE=Ally McBeal&rsquo;. If the parameter starts
with &rsquo;@&rsquo; then the comments will <br>
be read from a file with the same name without the leading
&rsquo;@&rsquo;. -c can be specified multiple times per
file. The comments will all be concatenated.</p>

<p style="margin-top: 1em">-f, --fourcc &lt;FourCC&gt; <br>
Forces the FourCC to the specified value. Works only for
video streams. Note that you cannot simply use a hex editor
and change the FourCC by hand as the OGG file format <br>
uses checksums which would be wrong after such a change.</p>

<p style="margin-top: 1em">--omit-empty-packets <br>
Normally, when a subtitle entry should be removed, an empty
packet is created and inserted with the appropriate
timestamp. With this option these empty packets are omitted
<br>
completely.</p>

<p style="margin-top: 1em">--old-headers <br>
Assume that the input file has been created with an older
version of ogmmerge ( &lt; 1.1). This may be needed if
ogmmerge cannot read such a file correctly.</p>

<p style="margin-top: 1em">--nav-seek &lt;filename&gt; <br>
Use an external AVI index file as generated by aviindex from
the transcode package. Can be used if an AVI file has a
broken index.</p>

<p style="margin-top: 1em">Other options:</p>

<p style="margin-top: 1em">-l, --list-types <br>
List supported input file types.</p>

<p style="margin-top: 1em">-h, --help <br>
Show usage information.</p>

<p style="margin-top: 1em">-V, --version <br>
Show version information.</p>

<p style="margin-top: 1em">USAGE <br>
For each file the user can select which tracks ogmmerge
should take. They are all put into the file specified with
&rsquo;-o&rsquo;. A list of known (and supported) source
formats can be <br>
obtained with the &rsquo;-l&rsquo; option.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Let&rsquo;s assume you have a file called MyMovie.avi and
the audio track in a separate file, e.g. MyMovie.wav. First
you want to encode the audio to OGG:</p>

<p style="margin-top: 1em">$ oggenc -q4 -oMyMovie.ogg
MyMovie.wav</p>

<p style="margin-top: 1em">After a couple of minutes you
can join video and audio:</p>

<p style="margin-top: 1em">$ ogmmerge -o
MyMovie-with-sound.ogm MyMovie.avi MyMovie.ogg</p>

<p style="margin-top: 1em">If your AVI already contains an
audio track then it will be copied aswell (if ogmmerge
supports the audio format). To avoid that simply do</p>

<p style="margin-top: 1em">$ ogmmerge -o
MyMovie-with-sound.ogm -A MyMovie.avi MyMovie.ogg</p>

<p style="margin-top: 1em">After some minutes of
consideration you rip another audio track, e.g. the
director&rsquo;s comments or another language to
MyMovie-add-audio.wav. Encode it again and join it up with
<br>
the other file:</p>

<p style="margin-top: 1em">$ oggenc -q4
-oMyMovie-add-audio.ogg MyMovie-add-audio.wav <br>
$ ogmmerge -o MM-complete.ogm MyMovie-with-sound.ogm
MyMovie-add-audio.ogg</p>

<p style="margin-top: 1em">The same result can be achieved
with</p>

<p style="margin-top: 1em">$ ogmmerge -o MM-complete.ogm -A
MyMovie.avi MyMovie.ogg MyMovie-add-audio.ogg</p>

<p style="margin-top: 1em">Now fire up mplayer and enjoy.
If you have multiple audio tracks (or even video tracks)
then you can tell mplayer which track to play with the
&rsquo;-vid&rsquo; and &rsquo;-aid&rsquo; parameters. These
<br>
are 0-based and do not distinguish between video and
audio.</p>

<p style="margin-top: 1em">If you need an audio track
synchronized you can do that easily with</p>

<p style="margin-top: 1em">$ ogmmerge -o goodsync.ogm -A
source.avi -s 200 outofsync.ogg</p>

<p style="margin-top: 1em">This would add 200ms of silence
at the beginning of the audio tracks taken from
outofsync.ogg. And -s always applies to all audio tracks in
a source file. If you want to apply -s <br>
only to a specific track then take the same source file more
than once and add -a and -s accordingly.</p>

<p style="margin-top: 1em">Some movies start synced
correctly but slowly drift out of sync. For these kind of
movies you can specify a delay factor that is applied to all
timestamps - no data is added or <br>
removed. So if you make that factor too big or too small
you&rsquo;ll get bad results. An example is that an episode
I transcoded was 0.2 seconds out of sync at the end of the
movie <br>
which was 77340 frames long. At 29.97fps 0.2 seconds
correspond to approx. 6 frames. So I did</p>

<p style="margin-top: 1em">$ ogmmerge -o goodsync.ogm -s
0,77346/77340 outofsync.ogm</p>

<p style="margin-top: 1em">The result was fine.</p>

<p style="margin-top: 1em">The sync options can also be
used for subtitles in the same manner.</p>

<p style="margin-top: 1em">For text subtitles you can
either use some Windows software (like SubRipper) or the
subrip package found in transcode(1)&rsquo;s sources (in
contrib/subrip). The general process is:</p>

<p style="margin-top: 1em">1. extract a raw subtitle stream
from the source: <br>
$ tccat -i /path/to/copied/dvd/ -T 1 -L | tcextract -x ps1
-t vob -a 0x20 | subtitle2pgm -o mymovie</p>

<p style="margin-top: 1em">2. convert the resulting PGM
images to text with gocr: <br>
$ pgm2txt mymovie</p>

<p style="margin-top: 1em">3. spell-check the resulting
text files: <br>
$ ispell -d american *txt</p>

<p style="margin-top: 1em">4. convert the text files to a
SRT file: <br>
$ srttool -s -w -i mymovie.srtx -o mymovie.srt</p>

<p style="margin-top: 1em">The resulting file can be used
as another input file for ogmmerge:</p>

<p style="margin-top: 1em">$ ogmmerge -o mymovie.ogm -c
&rsquo;TITLE=My Movie&rsquo; mymovie.avi -c LANGUAGE=English
mymovie.ogg -c LANGUAGE=English mymovie.srt</p>

<p style="margin-top: 1em">FILE SIZE <br>
Using OGG as the container format introduces overhead - each
OGG packet has a header, and each OGG packet can span one or
more OGG pages, which itself again contain headers.
Sev&acirc; <br>
eral tests show that the overhead is bigger than the
overhead introduced by AVI (comparing video only files and
files with video and MP3 audio).</p>

<p style="margin-top: 1em">The overhead is defined as file
size - raw stream size. mencoder prints the raw stream size
after encoding, so you&rsquo;ll be able to get that
information rather easily.</p>

<p style="margin-top: 1em">Most of the times you want to
calculate the overhead prior to encoding in order to adjust
the bitrate accordingly. Unfortunately the overhead per
frame is not constant - only the <br>
percentage is constant. This percentage is calculated as 100
* (OGG size - raw size) / raw size and seems to be somewhere
between 1.1% and 1.2%. This depends on the number of <br>
streams and the stream types used.</p>

<p style="margin-top: 1em">The raw size itself can be
approximated by <br>
frames * vbitrate <br>
raw size = ( ----------------- + length * abitrate ) / 8 *
1000 * 1024 <br>
frames per sec <br>
assuming that vbitrate and abitrate are given in kbit/s =
1000 bit/s, and length is given in seconds.</p>

<p style="margin-top: 1em">NOTES <br>
What works:</p>

<p style="margin-top: 1em">* AVI as the video and audio
source (currently only raw PCM, MP3 and AC3 audio
tracks)</p>

<p style="margin-top: 1em">* OGG as the source for video,
audio (Vorbis, raw PCM, MP3 and AC3 audio) and text streams
(subtitles).</p>

<p style="margin-top: 1em">* WAV as the audio source</p>

<p style="margin-top: 1em">* MP3 audio files</p>

<p style="margin-top: 1em">* AC3 audio files</p>

<p style="margin-top: 1em">* Track selection</p>

<p style="margin-top: 1em">* Manual audio synchronization
by adding silence/removing packets for Vorbis audio and for
text streams by adjusting the starting point and
duration.</p>

<p style="margin-top: 1em">* Manual audio synchronization
for AC3 and MP3 audio by duplicating/removing packets at the
beginning.</p>

<p style="margin-top: 1em">* Adding user comments to the
mandatory comment headers (only the headers are mandatory.
Comments themselves are not mandatory.)</p>

<p style="margin-top: 1em">* Text subtitles can be read
from SRT (SubRipper / subrip) and MicroDVD files or taken
from other OGM files.</p>

<p style="margin-top: 1em">* PCM, AC3 and MP3 audio work
well under Windows and with MPlayer now.</p>

<p style="margin-top: 1em">* Chapter information as
generated by dvdxchap are supported.</p>

<p style="margin-top: 1em">What not works:</p>

<p style="margin-top: 1em">* Manual audio synchronization
for PCM sound (who needs it anyway?)</p>

<p style="margin-top: 1em">Planned functionality:</p>

<p style="margin-top: 1em">* support for other subtitle
formats</p>

<p style="margin-top: 1em">CHAPTERS <br>
ogmmerge supports chapter information as generated by
dvdxchap(1). The format is very simple:</p>

<p style="margin-top: 1em">CHAPTER01=HH:MM:SS.sss <br>
CHAPTER01NAME=the first chapter <br>
CHAPTER02=HH:MM:SS.sss <br>
CHAPTER02NAME=another chapter</p>

<p style="margin-top: 1em">with HH = hour, MM = minute, SS
= seconds, sss = milliseconds.</p>

<p style="margin-top: 1em">The chapter information is
stored in the video stream&rsquo;s comments. Therefore you
could also specify the chapters with -c CHAPTER01=... Using
a chapter file has an advantage: If <br>
the video stream&rsquo;s comments already contain chapter
information and the command line contains a chapter
information file then the existing chapter information will
be completely <br>
replaced.</p>

<p style="margin-top: 1em">TECHNICAL ASPECTS <br>
This section is not needed by the average user.</p>

<p style="margin-top: 1em">ogmmerge consists of three
parts:</p>

<p style="margin-top: 1em">* Demultiplexers (called
readers) open and read input files specified on the command
line and extract specific tracks.</p>

<p style="margin-top: 1em">* Packetizers (or output
modules) take data from a demultiplexer and encapsulate them
into OGG pages. These are stored in queues.</p>

<p style="margin-top: 1em">* The main program requests from
every known demultiplexer that it should read some data. It
then gets the OGG page with the smallest timestamp from all
the packetizer <br>
queues. This page is written to the output file.</p>

<p style="margin-top: 1em">The general class definitions
for the readers and the packetizers can be found in
ogmmerge.h.</p>

<p style="margin-top: 1em">The main loop expects that the
queues managed by the demuxer&rsquo;s packetizers are filled
with at least one page after a call to the demuxer&rsquo;s
read() function. The demuxer must make <br>
sure that enough data is passed to each of its associated
packetizers. Have a look at r_ogm.cpp.</p>

<p style="margin-top: 1em">A possible setup might look like
this:</p>

<p style="margin-top: 1em">+-&gt; p_video <br>
+-&gt; r_avi -+ <br>
| +-&gt; p_pcm <br>
| <br>
ogmmerge -+-&gt; r_ogm ---&gt; p_vorbis <br>
| <br>
| +-&gt; p_video <br>
| | <br>
+-&gt; r_ogm -+-&gt; p_vorbis <br>
| <br>
+-&gt; p_vorbis</p>

<p style="margin-top: 1em">One AVI source with a video and
an audio track, one OGG/OGM source with only one Vorbis
track, another OGG/OGM source with a video and two Vorbis
tracks.</p>

<p style="margin-top: 1em">AUTHOR <br>
ogmmerge was written by Moritz Bunkus
&lt;moritz@bunkus.org&gt;.</p>

<p style="margin-top: 1em">SEE ALSO <br>
ogmdemux(1), ogmsplit(1), ogminfo(1), ogmcat(1),
dvdxchap(1)</p>

<p style="margin-top: 1em">WWW <br>
The newest version can always be found at
&lt;http://www.bunkus.org/videotools/ogmtools/&gt;
&acirc;&uml;http://www.bunkus.org/videotools/ogmtools/&acirc;&copy;</p>

<p style="margin-top: 1em">ogmmerge v1.5 November 2004
OGMMERGE(1)</p>
<hr>
</body>
</html>
