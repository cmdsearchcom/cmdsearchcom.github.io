<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:50 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>JIRB1.3(1) General Commands Manual JIRB1.3(1)</p>

<p style="margin-top: 1em">NAME <br>
jirb1.3 - interactive JRuby</p>

<p style="margin-top: 1em">SYNOPSIS <br>
jirb [options]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
irb stands for &lsquo;interactive JRuby&rsquo;. irb is a
tool to execute interactively JRuby expressions read from
stdin. Use of jirb is easy if you know JRuby. Executing
jirb, prompts are <br>
displayed as follows. Then, enter expression of ruby. A
input is executed when it is syntacticaly completed.</p>

<p style="margin-top: 1em">$ jirb1.3 <br>
irb(main):001:0&gt; 1+2 <br>
3 <br>
irb(main):002:0&gt; class Foo <br>
irb(main):003:1&gt; def foo <br>
irb(main):004:2&gt; print 1 <br>
irb(main):005:2&gt; end <br>
irb(main):006:1&gt; end <br>
nil <br>
irb(main):007:0&gt;</p>

<p style="margin-top: 1em">And, Readline extesion module
can be used with irb. Using Readline is the standard default
action if Readline is installed.</p>

<p style="margin-top: 1em">OPTIONS <br>
-f suppress read ~/.irbrc</p>

<p style="margin-top: 1em">-m bc mode (fraction or matrix
are available)</p>

<p style="margin-top: 1em">-d set $DEBUG to true (same as
&lsquo;ruby -d&rsquo;)</p>

<p style="margin-top: 1em">-r load-module <br>
same as &lsquo;ruby -r&rsquo;</p>

<p style="margin-top: 1em">--inspect <br>
uses &lsquo;inspect&rsquo; for output (the default except bc
mode)</p>

<p style="margin-top: 1em">--noinspect <br>
doesn&rsquo;t uses inspect for output</p>

<p style="margin-top: 1em">--readline <br>
uses Readline extension module</p>

<p style="margin-top: 1em">--noreadline <br>
doesn&rsquo;t use Readline extension module</p>

<p style="margin-top: 1em">--prompt prompt-mode</p>

<p style="margin-top: 1em">--prompt-mode prompt-mode <br>
switches prompt mode. Pre-defined prompt modes are
&lsquo;default&rsquo;, &lsquo;simple&rsquo;,
&lsquo;xmp&rsquo; and &lsquo;inf-ruby&rsquo;</p>

<p style="margin-top: 1em">--inf-ruby-mode <br>
uses prompt appreciate for inf-ruby-mode on emacs.
Suppresses --readline.</p>

<p style="margin-top: 1em">--simple-prompt <br>
simple prompt mode</p>

<p style="margin-top: 1em">--noprompt <br>
no prompt</p>

<p style="margin-top: 1em">--tracer <br>
display trace for each execution of commands.</p>

<p style="margin-top: 1em">--back-trace-limit n <br>
displayes backtrace top n and tail n. The default value is
16.</p>

<p style="margin-top: 1em">--irb_debug n <br>
sets internal debug level to n (It shouldn&rsquo;t be
used)</p>

<p style="margin-top: 1em">-v, --version <br>
prints the version of irb</p>

<p style="margin-top: 1em">CONFIGURATIONS <br>
jirb reads &lsquo;~/.irbrc&rsquo; when it is invoked. If
&lsquo;~/.irbrb&rsquo; doesn&rsquo;t exist jirb try to read
in the order &lsquo;.irbrc&rsquo;, &lsquo;irb.rc&rsquo;,
&lsquo;_irbrc&rsquo; then &lsquo;$irbrc&rsquo;. The
following is altanative to <br>
the command line option. To use them type as follows in a
jirb session.</p>


<p style="margin-top: 1em">IRB.conf[:IRB_NAME]=&quot;irb&quot;
<br>
IRB.conf[:MATH_MODE]=false <br>
IRB.conf[:USE_TRACER]=false <br>
IRB.conf[:USE_LOADER]=false <br>
IRB.conf[:IGNORE_SIGINT]=true <br>
IRB.conf[:IGNORE_EOF]=false <br>
IRB.conf[:INSPECT_MODE]=nil <br>
IRB.conf[:IRB_RC] = nil <br>
IRB.conf[:BACK_TRACE_LIMIT]=16 <br>
IRB.conf[:USE_LOADER] = false <br>
IRB.conf[:USE_READLINE] = nil <br>
IRB.conf[:USE_TRACER] = false <br>
IRB.conf[:IGNORE_SIGINT] = true <br>
IRB.conf[:IGNORE_EOF] = false <br>
IRB.conf[:PROMPT_MODE] = :DEFALUT <br>
IRB.conf[:PROMPT] = {...} <br>
IRB.conf[:DEBUG_LEVEL]=0 <br>
IRB.conf[:VERBOSE]=true</p>

<p style="margin-top: 1em">Customizing prompt <br>
To costomize the prompt you set a variable</p>

<p style="margin-top: 1em">IRB.conf[:PROMPT]</p>

<p style="margin-top: 1em">For example, describe as follows
in &lsquo;.irbrc&rsquo;.</p>

<p style="margin-top: 1em">IRB.conf[:PROMPT][:MY_PROMPT] =
{ # name of prompt mode <br>
:PROMPT_I =&gt; nil, # normal prompt <br>
:PROMPT_S =&gt; nil, # prompt for continuated strings <br>
:PROMPT_C =&gt; nil, # prompt for continuated statement <br>
:RETURN =&gt; &quot; ==&gt;%s0 # format to return value <br>
}</p>

<p style="margin-top: 1em">Then, invoke irb with the above
prompt mode by</p>

<p style="margin-top: 1em">$ jirb1.3 --prompt my-prompt</p>

<p style="margin-top: 1em">Or add the following in
&lsquo;.irbrc&rsquo;.</p>

<p style="margin-top: 1em">IRB.conf[:PROMPT_MODE] =
:MY_PROMPT</p>

<p style="margin-top: 1em">Constants PROMPT_I, PROMPT_S and
PROMPT_C specifies the format. In the prompt specification,
some special strings are available.</p>

<p style="margin-top: 1em">%N command name which is running
<br>
%m to_s of main object (self) <br>
%M inspect of main object (self) <br>
%l type of string(&quot;, &rsquo;, /, ]), &lsquo;]&rsquo; is
inner %w[...] <br>
%NNi indent level. NN is degits and means as same as
printf(&quot;%NNd&quot;). <br>
It can be ommited <br>
%NNn line number. <br>
%% % <br>
For instance, the default prompt mode is defined as follows:
IRB.conf[:PROMPT_MODE][:DEFAULT] = {</p>

<p style="margin-top: 1em">PROMPT_I =&gt;
&quot;%N(%m):%03n:%i&gt; &quot;,</p>

<p style="margin-top: 1em">PROMPT_S =&gt;
&quot;%N(%m):%03n:%i%l &quot;,</p>

<p style="margin-top: 1em">PROMPT_C =&gt;
&quot;%N(%m):%03n:%i* &quot;,</p>

<p style="margin-top: 1em">RETURN =&gt; &quot;%s0} <br>
RETURN is used to printf.</p>

<p style="margin-top: 1em">Configurating subirb <br>
The command line option or IRB.conf specify the default
behavior of (sub)irb. On the other hand, each conf of in the
next sction &lsquo;6. Command&rsquo; is used to individually
configurate <br>
(sub)irb. If proc is set to IRB.conf[:IRB_RC], its subirb
will be invoked after execution of that proc under giving
the context of irb as its aregument. By this mechanism each
<br>
subirb can be configurated.</p>

<p style="margin-top: 1em">Command <br>
For irb commands, both simple name and
&lsquo;irb_&rsquo;-prefixed name are prepared.</p>

<p style="margin-top: 1em">exit, quit, irb_exit <br>
Quits (sub)irb. if you&rsquo;ve done cb (see below), exit
from the binding mode.</p>

<p style="margin-top: 1em">conf, irb_context <br>
Displays current configuration. Modifing the configuration
is achieved by sending message to &lsquo;conf&rsquo;.</p>

<p style="margin-top: 1em">conf.back_trace_limit <br>
Sets display lines of backtrace as top n and tail n. The
default value is 16.</p>

<p style="margin-top: 1em">conf.debug_level = N <br>
Sets debug level of irb.</p>

<p style="margin-top: 1em">conf.ignore_eof = true/false
<br>
Whether ^D (control-d) will be ignored or not. If false is
set, ^D means quit.</p>

<p style="margin-top: 1em">conf.ignore_sigint= true/false
<br>
Whether ^C (control-c) will be ignored or not. If false is
set, ^D means quit. If true, <br>
during input: cancel inputing then return to top level. <br>
during execute: abondon current execution.</p>

<p style="margin-top: 1em">conf.inf_ruby_mode = true/false
<br>
Whether inf-ruby-mode or not. The default value is
false.</p>

<p style="margin-top: 1em">conf.inspect_mode =
true/false/nil <br>
Specifies inspect mode. true: display inspect false: display
to_s nil: inspect mode in non math mode, <br>
non inspect mode in math mode.</p>

<p style="margin-top: 1em">conf.irb_level <br>
The level of cb.</p>

<p style="margin-top: 1em">conf.math_mode <br>
Whether bc mode or not.</p>

<p style="margin-top: 1em">conf.use_loader = true/false
<br>
Whether irb&rsquo;s own file reader method is used when
load/require or not. This mode is globaly affected (irb
wide).</p>

<p style="margin-top: 1em">conf.prompt_c <br>
prompt for a continuating statement (e.g, immediately after
of &lsquo;if&rsquo;)</p>

<p style="margin-top: 1em">conf.prompt_i <br>
standard prompt</p>

<p style="margin-top: 1em">conf.prompt_s <br>
prompt for a continuating string</p>

<p style="margin-top: 1em">conf.rc <br>
Whether ~/.irbrc is read or not.</p>

<p style="margin-top: 1em">conf.use_prompt = true/false
<br>
Prompting or not.</p>

<p style="margin-top: 1em">conf.use_readline =
true/false/nil <br>
Whether readline is used or not. true: uses false:
doen&rsquo;t use nil: intends to use readline except for
inf-reuby-mode (default)</p>

<p style="margin-top: 1em">conf.verbose=T/F <br>
Whether verbose messages are display or not.</p>

<p style="margin-top: 1em">cb, irb_change_binding [obj]
<br>
Enter new binding which has a distinct scope of local
variables. If obj is given, obj will be self.</p>

<p style="margin-top: 1em">irb [obj] <br>
Invoke subirb. If obj is given, obj will be self.</p>

<p style="margin-top: 1em">jobs, irb_jobs <br>
List of subirb</p>

<p style="margin-top: 1em">fg n, irb_fg n <br>
Switch into specified subirb. The following is candidates of
n: <br>
irb number <br>
thhread <br>
irb object <br>
self(obj which is specified of irb obj)</p>

<p style="margin-top: 1em">kill n, irb_kill n <br>
Kill subirb. The means of n is as same as the case of
irb_fg.</p>

<p style="margin-top: 1em">System variable <br>
_ The latest value of evaluation (it is local)</p>

<p style="margin-top: 1em">Session Example <br>
$ jirb1.3 <br>
irb(main):001:0&gt; irb # invoke subirb <br>
irb#1(main):001:0&gt; jobs # list of subirbs <br>
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop) <br>
#1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : running)
<br>
nil <br>
irb#1(main):002:0&gt; fg 0 # switch job <br>
nil <br>
irb(main):002:0&gt; class Foo;end <br>
nil <br>
irb(main):003:0&gt; irb Foo # invoke subirb which has the
<br>
# context of Foo <br>
irb#2(Foo):001:0&gt; def foo # define Foo#foo <br>
irb#2(Foo):002:1&gt; print 1 <br>
irb#2(Foo):003:1&gt; end <br>
nil <br>
irb#2(Foo):004:0&gt; fg 0 # switch job <br>
nil <br>
irb(main):004:0&gt; jobs # list of job <br>
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
<br>
#1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
<br>
#2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop) <br>
nil <br>
irb(main):005:0&gt; Foo.instance_methods # Foo#foo is
defined asurely <br>
[&quot;foo&quot;] <br>
irb(main):006:0&gt; fg 2 # switch job <br>
nil <br>
irb#2(Foo):005:0&gt; def bar # define Foo#bar <br>
irb#2(Foo):006:1&gt; print &quot;bar&quot; <br>
irb#2(Foo):007:1&gt; end <br>
nil <br>
irb#2(Foo):010:0&gt; Foo.instance_methods <br>
[&quot;bar&quot;, &quot;foo&quot;] <br>
irb#2(Foo):011:0&gt; fg 0 <br>
nil <br>
irb(main):007:0&gt; f = Foo.new <br>
#&lt;Foo:0x4010af3c&gt; <br>
irb(main):008:0&gt; irb f # invoke subirb which has the <br>
# context of f (instance of Foo) <br>
irb#3(#&lt;Foo:0x4010af3c&gt;):001:0&gt; jobs <br>
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop) <br>
#1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
<br>
#2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop) <br>
#3-&gt;irb#3 on #&lt;Foo:0x4010af3c&gt;
(#&lt;Thread:0x4010a1e0&gt; : running) <br>
nil <br>
irb#3(#&lt;Foo:0x4010af3c&gt;):002:0&gt; foo # evaluate
f.foo <br>
1nil <br>
irb#3(#&lt;Foo:0x4010af3c&gt;):003:0&gt; bar # evaluate
f.bar <br>
barnil <br>
irb#3(#&lt;Foo:0x4010af3c&gt;):004:0&gt; kill 1, 2, 3# kill
job <br>
nil <br>
irb(main):009:0&gt; jobs <br>
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
<br>
nil <br>
irb(main):010:0&gt; exit # exit</p>

<p style="margin-top: 1em">Restrictions <br>
Because irb evaluates the inputs immediately after the imput
is syntactically completed, irb gives slight different
result than directly use ruby. Known difference is pointed
out <br>
here.</p>

<p style="margin-top: 1em">Declaration of the local
variable <br>
The following causes an error in ruby:</p>

<p style="margin-top: 1em">eval &quot;foo = 0&quot; <br>
foo <br>
-- <br>
-:2: undefined local variable or method &lsquo;foo&rsquo;
for #&lt;Object:0x40283118&gt; (NameError) <br>
--- <br>
NameError</p>

<p style="margin-top: 1em">Though, the above will
successfully done by irb.</p>

<p style="margin-top: 1em">&gt;&gt; eval &quot;foo =
0&quot; <br>
=&gt; 0 <br>
&gt;&gt; foo <br>
=&gt; 0</p>

<p style="margin-top: 1em">Ruby evaluates a code after
reading entire of code and determination of the scope of
local variables. On the other hand, irb do immediately. More
precisely, irb evaluate at first</p>

<p style="margin-top: 1em">evel &quot;foo = 0&quot;</p>

<p style="margin-top: 1em">then foo is defined on this
timing. It is because of this incompatibility. If
you&rsquo;d like to detect those differences, begin...end
can be used:</p>

<p style="margin-top: 1em">&gt;&gt; begin <br>
?&gt; eval &quot;foo = 0&quot; <br>
&gt;&gt; foo <br>
&gt;&gt; end <br>
NameError: undefined local variable or method
&lsquo;foo&rsquo; for #&lt;Object:0x4013d0f0&gt; <br>
(irb):3 <br>
(irb_local_binding):1:in &lsquo;eval&rsquo;</p>

<p style="margin-top: 1em">Here-document <br>
Implementation of Here-document is incomplete.</p>

<p style="margin-top: 1em">Symbol <br>
Irb can not always recognize a symbol as to be Symbol.
Concretely, an expression have completed, however Irb regard
it as continuation line.</p>

<p style="margin-top: 1em">April 2007 JIRB1.3(1)</p>
<hr>
</body>
</html>
