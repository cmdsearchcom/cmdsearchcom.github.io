<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>dd_rescue(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">dd_rescue(1)</td>
    <td class="head-vol">Data recovery and protection tool</td>
    <td class="head-rtitle">dd_rescue(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
dd_rescue - Data recovery and protection tool
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>dd_rescue</b> [options] infile outfile
<div>&#x00A0;</div>
<b>dd_rescue</b> [options] [-2/-3/-4/-z/-Z seed/seedfile] outfile
<div>&#x00A0;</div>
<b>dd_rescue</b> [options] [--shred2/--shred3/--shred4/--random/--frandom
  seed/seedfile] outfile
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>dd_rescue</b> is a tool that copies data from a source (file, block device,
  pipe, ...) to one (or several) output file(s).
<div class="Pp"></div>
If input and output files are seekable (block devices or regular files),
  <b>dd_rescue</b> does copy with large blocks (softbs) to increase performance.
  When a read error is encountered, <b>dd_rescue</b> falls back to reading
  smaller blocks (hardbs), to allow to recover the maximum amount of data. If
  blocks can still not be read, <b>dd_rescue</b> by default skips over them also
  in the output file, avoiding to overwrite data that might have been copied
  there successfully in a previous run. (Option -A / --alwayswrite changes
  this.).
<div class="Pp"></div>
<b>dd_rescue</b> can copy in reverse direction as well, allowing to approach a
  bad spot from both directions. As trying to read over a bad spot of
  significant size can take very long (and potentially cause further damage),
  this is an important optimization when recovering data. The <b>dd_rhelp</b>
  tool takes advantage of this and automates data recovery. <b>dd_rescue</b>
  does not (by default) truncate the output file.
<div class="Pp"></div>
<b>dd_rescue</b> by default reports on progress, and optionally also writes into
  a logfile. It has a progress bar and gives an estimate for the remaining time.
  <b>dd_rescue</b> has a wealth of options that influence its behavior, such as
  the possibility to use direct IO for input/output, to use fallocate() to
  preallocate space for the output file, using splice copy (in kernel zerocopy)
  for efficiency, looking for empty blocks to create sparse files, or using a
  pseudo random number generator (PRNG) to quickly overwrite data with random
  numbers.
<div class="Pp"></div>
The modes to overwrite partitions or files with pseudo random numbers make
  <b>dd_rescue</b> a tool that can be used for secure data deletion and thus not
  just a data recovery and backup tool but also a data protection tool.
<div class="Pp"></div>
You can use &quot;-&quot; as infile or outfile, meaning stdin or stdout. Note
  that this means that either file is not seekable, limiting the usefulness of
  some of dd_rescues features.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
When parsing numbers, <b>dd_rescue</b> assumes bytes. It accepts the following
  suffixes:
<div>&#x00A0;</div>
b -- 512 size units (blocks)
<div>&#x00A0;</div>
k -- 1024 size units (binary kilobytes, kiB)
<div>&#x00A0;</div>
M -- 1024^2 size units (binary megabytes, MiB)
<div>&#x00A0;</div>
G -- 1024^3 size units (binary gigabytes, GiB)
<div class="Pp"></div>
The following options may be used to modify the behavior of <b>dd_rescue .</b>
<h2 class="Ss" title="Ss" id="General_options"><a class="selflink" href="#General_options">General
  options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>, <b>--help</b></dt>
  <dd class="It-tag">This option tells <b>dd_rescue</b> to output a list of
      options and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b>, <b>--version</b></dt>
  <dd class="It-tag">Display version number and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b>, <b>--quiet</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to be less verbose.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b>, <b>--verbose</b></dt>
  <dd class="It-tag">makes <b>dd_rescue</b> more verbose.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c&#x00A0;</b><i>0/1</i><b>,&#x00A0;<b>--color=</b></b><i><b>0/1</b></i></dt>
  <dd class="It-tag">controls whether <b>dd_rescue</b> uses colors. By default
      it does, unless the terminal type from TERM is unknown or dumb or ends in
      -m or -mono.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b>, <b>--force</b></dt>
  <dd class="It-tag">makes <b>dd_rescue</b> skip some sanity checks (e.g.
      automatically setting reverse direction when input and output file are the
      same and ipos &lt; opos).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b>, <b>--interactive</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to ask before overwriting existing
      files.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Block_sizes"><a class="selflink" href="#Block_sizes">Block
  sizes</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b&#x00A0;</b><i>softbs</i><b>,&#x00A0;<b>--softbs=</b></b><i><b>softbs</b></i><b><b></b>,&#x00A0;<b>--bs=</b></b><i><b>softbs</b></i></dt>
  <dd class="It-tag">sets the (larger) block size to <i>softbs</i> bytes.
      <b>dd_rescue</b> will transfer chunks of that size unless a read error is
      encountered (or the end of the input file or the maximum transfer size has
      been reached). The default value for this is 64k for buffered I/O and 1M
      for direct I/O.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B&#x00A0;</b><i>hardbs</i><b>,&#x00A0;<b>--hardbs=</b></b><i><b>hardbs</b></i><b><b></b>,&#x00A0;<b>--block-size=</b></b><i><b>hardbs</b></i></dt>
  <dd class="It-tag">sets the (smaller) fallback block size to <i>hardbs</i>
      bytes. When <b>dd_rescue</b> encounters read errors, it will fall back to
      copying data in chunks of this size. This value defaults to 4k for
      buffered I/O and 512 bytes for direct I/O.
    <div>&#x00A0;</div>
    <i>hardbs</i> should be equal to or smaller than <i>softbs</i>. If both
      block sizes are identical, no fallback mechanism (and thus no retry) will
      take place on read errors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-y&#x00A0;</b><i>syncsize</i><b>,&#x00A0;<b>--syncfreq=</b></b><i><b>syncsize</b></i></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to call fsync() on the output file
      every <i>syncsize</i> bytes (will be rounded to multiples of <i>softbs</i>
      sized blocks). It will also update the progress indicator at least as
      often. By default, <i>syncsize</i> is set to 0, meaning that fsync() is
      only issued at the end of the copy operation.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Positions_and_length"><a class="selflink" href="#Positions_and_length">Positions
  and length</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s&#x00A0;</b><i>ipos</i><b>,&#x00A0;<b>--ipos=</b></b><i><b>ipos</b></i><b><b></b>,&#x00A0;<b>--input-position=</b></b><i><b>ipos</b></i></dt>
  <dd class="It-tag">sets the starting position of the <i>infile</i> to
      <i>ipos</i>. Note that ipos is specified in bytes (but suffixes can be
      used, see above), not in terms of <i>softbs</i> or <i>hardbs</i> sized
      blocks. The default value for this is 0. When reverse direction copy is
      used, an <i>ipos</i> of 0 is treated specially, meaning the end of file.
    <div>&#x00A0;</div>
    Negative positions result in an error message.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S&#x00A0;</b><i>opos</i><b>,&#x00A0;<b>--opos=</b></b><i><b>opos</b></i><b><b></b>,&#x00A0;<b>--output-position=</b></b><i><b>opos</b></i></dt>
  <dd class="It-tag">sets the starting position of the <i>outfile</i> to
      <i>opos</i>. If not specified, <i>opos</i> is set to <i>ipos</i>, so the
      file offsets in input and output file are the same. For reverse direction
      copy, an explicit <i>opos</i> of 0 will position at the end of the output
      file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b>, <b>--extend</b>, <b>--append</b></dt>
  <dd class="It-tag">changes the interpretation of the output position to start
      at the end of the existing output file, making appending to a file
      convenient. If the output file does not exist, an error will be reported
      and <b>dd_rescue</b> aborted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m&#x00A0;</b><i>maxxfer</i><b>,&#x00A0;<b>--maxxfer=</b></b><i><b>maxxfer</b></i><b><b></b>,&#x00A0;<b>--max-size=</b></b><i><b>maxxfer</b></i></dt>
  <dd class="It-tag">specifies the maximum number of bytes (suffixes apply, but
      it's NOT counted in blocks) that <b>dd_rescue</b> copies. If EOF is
      encountered before <i>maxxfer</i> bytes have been transferred, this option
      will be silently ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b>, <b>--noextend</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to not extend the output file. This
      option is particularly helpful when overwriting a file with random data or
      zeroes for safe data destruction. If the output file does not exist, an
      error message will be generated and the program be aborted.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Error_handling"><a class="selflink" href="#Error_handling">Error
  handling</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e&#x00A0;</b><i>maxerr</i><b>,&#x00A0;<b>--maxerr=</b></b><i><b>maxerr</b></i></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to exit, after <i>maxerr</i> read
      errors have been encountered. By default, this is set to 0, resulting in
      <b>dd_rescue</b> trying to move on until it hits EOF (or <i>maxxfer</i>
      bytes have been transferred).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b>, <b>--abort_we</b></dt>
  <dd class="It-tag">makes <b>dd_rescue</b> abort on any write errors. By
      default, on reported write errors, <b>dd_rescue</b> tries to rewrite the
      blocks with small block size writes, so a small failure in a larger block
      will not cause the whole block not to be written. Note that this may be
      handled similarly by your Operating System kernel with buffered writes
      without the user or dd_rescue noticing; the write retry logic in dd_rescue
      is mostly useful for direct I/O writes where write errors can be reliably
      detected.
    <div>&#x00A0;</div>
    Write error detection with buffered writes is unreliable; the kernel reports
      success and traces of the failing writeback operations later may only
      appear in your syslog. dd_rescue does try to notice the user by calling
      fsync() and carefully checking the return values of fsync() and close()
      calls.
    <div>&#x00A0;</div>
    Note that <b>dd_rescue</b> does exit if writes to the output file result in
      the Operating System reporting that no space is left.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Sparse_files_and_write_avoidance"><a class="selflink" href="#Sparse_files_and_write_avoidance">Sparse
  files and write avoidance</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b>, <b>--alwayswrite</b></dt>
  <dd class="It-tag">changes the behavior of <b>dd_rescue</b> to write zeroes to
      the output file when the input file could not be read. By default, it just
      skips over, leaving whatever content was in the output file at the file
      position before. The default behavior may be desired, if e.g. previous
      copy operations may have resulted in good data being in place; it may be
      undesired if the output file may contain garbage (or sensitive
      information) that should rather be overwritten with zeroes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b>, <b>--sparse</b></dt>
  <dd class="It-tag">will make <b>dd_rescue</b> look for empty blocks (of at
      least half of <i>softbs</i> size), i.e. blocks filled with zeroes. Rather
      than writing those zeroes to the output file, it will then skip forward in
      the output file, resulting in a sparse file, saving space in the output
      file system (if it supports sparse files). Note that if the output file
      does already exist and already has data stored at the location where
      zeroes are skipped over, this will result in an incomplete copy in that
      the output file is different from the input file at the location where
      blocks of zeroes were skipped over. <b>dd_rescue</b> tries to detect this
      and issue a warning, but it does not prevent this from happening</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-W</b>, <b>--avoidwrite</b></dt>
  <dd class="It-tag">results in <b>dd_rescue</b> reading a block ( <i>softbs</i>
      sized) from the output file prior to writing it. If it is already
      identical with the data that would be written to it, the writes are
      actually avoided. This option may be useful for devices, where e.g. writes
      should be avoided (e.g. because they may impact the remaining lifetime or
      because they are very slow compared to reads).</dd>
</dl>
<h2 class="Ss" title="Ss" id="Other_optimization"><a class="selflink" href="#Other_optimization">Other
  optimization</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b>, <b>--repeat</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to only read one block (
      <i>softbs</i> sized) and then repeatedly write it to the output file. Note
      that this results in never hitting EOF on the input file and should be
      used with a limit for the transfer size (options -m or -M) or when filling
      up an output device completely.
    <div>&#x00A0;</div>
    This option is automatically set, if the input file name equals
      &quot;/dev/zero&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-u</b>, <b>--rmvtrim</b></dt>
  <dd class="It-tag">instructs <b>dd_rescue</b> to remove the output file after
      writing to it has completed and issue a FITRIM on the file system that
      contains the output file. This makes only sense if writing zeros (or
      random numbers) as opposed to useful content from another file. (dd_rescue
      will ask for confirmation if this is specified with a normal input file
      and no -f (--force) is used.) This option may be used to ensure that all
      empty blocks of a file system are filled with zeros (rather than
      containing fragments of deleted files with possibly sensitive
      information).
    <div>&#x00A0;</div>
    The FITRIM ioctl (on Linux) tells the flash storage to consider the freed
      space as unused (like the fstrim tool or the discard option) by issuing
      ATA TRIM commands. This will only succeed with superuser privileges (but
      the error can otherwise be safely ignored). This is useful to ensure full
      performance of flash memory / SSDs. Note that FITRIM can take a while on
      large file systems, especially if the file systems are not mounted with
      the discard option and have not been trimmed (with e.g. fstrim) for a
      while. Not all file systems and not all flash-based storage support
    this.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b>, <b>--splice</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to use the Linux in-kernel zerocopy
      splice() copy operation rather than reading blocks into a user space
      buffer. Note that this operation mode does prevent the support of a number
      of <b>dd_rescue</b> features that can normally be used, such as falling
      back to smaller block sizes, avoiding writes, sparse mode, repeat
      optimization, reverse direction copy. A warning is issued to make the user
      aware.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b>, <b>--fallocate</b></dt>
  <dd class="It-tag">results in <b>dd_rescue</b> calling fallocate() on the
      output file, telling the file system how much space to preallocate for the
      output file. (The size is determined by the expected last position, as
      inferred from the input file length and <i>maxxfer</i> ). On file systems
      that support it, this results in them making better allocation decisions,
      avoiding fragmentation. (Note that it does not make sense to use sparse
      together with fallocate().)
    <div>&#x00A0;</div>
    This option is only available if dd_rescue is compiled with fallocate()
      support. For optimal support, it should be compiled with the libfallocate
      library.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C&#x00A0;</b><i>rate</i><b>,&#x00A0;<b>&#x00A0;--ratecontrol=</b></b><i><b>rate</b></i></dt>
  <dd class="It-tag">limits the transfer speed of <b>dd_rescue</b> to the
      <i>rate</i> (per second). The usual suffixes are allowed. Note that this
      limits the average speed; the current speed may be up to twice this limit.
      Default is unlimited. Note that you will have to use smaller
      softblocksizes if you want to go below 32k (kB/s).</dd>
</dl>
<h2 class="Ss" title="Ss" id="Misc_options"><a class="selflink" href="#Misc_options">Misc
  options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b>, <b>--reverse</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to copy in reverse direction,
      starting at <i>ipos</i> (with special case 0 meaning EOF) and working
      towards the beginning of the file. This is especially helpful if the input
      file has a bad spot which can be extremely slow to skip over, so
      approaching it from both directions saves a lot of time (and may prevent
      further damage).
    <div>&#x00A0;</div>
    Note that <b>dd_rescue</b> does automatically switch to reverse direction
      copy, if input and output file are identical and the input position is
      smaller than the output position, similar to the intelligence that
      memmove() uses to prevent loss of data when overlapping areas are copied.
      The option -f / --force does prevent this intelligence from
    happening.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b>, <b>--preserve</b></dt>
  <dd class="It-tag">When copying files, this option does result in file
      metadata (timestamps, ownership, access rights, xattrs) to be copied,
      similar to the option with the same name in the cp program.
    <div>&#x00A0;</div>
    Note that ACLs and xattrs will only be copied if <b>dd_rescue</b> has been
      compiled with libxattr support and the library can be dynamically loaded
      on the system. Also note that failing to copy the attributes with
      <i>-p</i> is not considered a failure and thus won't negatively affect the
      exit code of dd_rescue.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b>, <b>--truncate</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to open the output file with
      O_TRUNC, resulting in the output file (if it is a regular file) to be
      truncated to 0 bytes before writing to it, removing all previous content
      that the file may have contained. By default, <b>dd_rescue</b> does not
      remove previous content.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b>, <b>--trunclast</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to truncate the output file to the
      highest copied position after the copy operation completed, thus ensuring
      there's no data beyond the end of the data that has been copied in this
      run.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b>, <b>--odir_in</b></dt>
  <dd class="It-tag">instructs <b>dd_rescue</b> to open <i>infile</i> with
      O_DIRECT, bypassing the kernel buffers. While this option has a negative
      effect on performance (the kernel does read-ahead for buffered I/O), it
      will result in errors to be detected more quickly (kernel won't retry) and
      allows for smaller I/O units (hardware sector size, 512bytes for most hard
      disks).
    <div>&#x00A0;</div>
    O_DIRECT may not be available on all platforms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b>, <b>--odir_out</b></dt>
  <dd class="It-tag">tells <b>dd_rescue</b> to open <i>outfile</i> with
      O_DIRECT, bypassing kernel buffers. This has a significant negative effect
      on performance, as the program needs to wait for writes to hit the disks
      as opposed to the asynchronous nature of buffered writeback. On the flip
      side, the return status from writing is reliable this way and smaller I/O
      chunks (hardware sector size, 512bytes) are possible.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Logging"><a class="selflink" href="#Logging">Logging</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l&#x00A0;</b><i>logfile</i><b>,&#x00A0;<b>--logfile=</b></b><i><b>logfile</b></i></dt>
  <dd class="It-tag">Unless in quiet mode, <b>dd_rescue</b> does produce
      constant updates on the status of the copy operation to stderr. With this
      option, these updates are also written to the specified <i>logfile</i>.
      The control characters (to move the cursor up to overwrite the existing
      status lines) are not written to the logfile.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o&#x00A0;</b><i>bbfile</i><b>,&#x00A0;<b>--bbfile=</b></b><i><b>bbfile</b></i></dt>
  <dd class="It-tag">instructs <b>dd_rescue</b> to write a list of bad blocks to
      <i>bbfile</i>. The file will contain a list of numbers (ASCII), one per
      line, where the numbers indicate the offset in terms of <i>hardbs</i>
      sized blocks. The file format is compatible with that of badblocks. Using
      dd_rescue on a block device (partition) and setting <i>hardbs</i> to the
      block size of a file system that you want to create, you should be able to
      feed the <i>bbfile</i> to mke2fs with the option -l.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Multiple_output_files"><a class="selflink" href="#Multiple_output_files">Multiple
  output files</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Y&#x00A0;</b><i>ofileX</i><b>,&#x00A0;<b>--outfile=</b></b><i><b>ofileX</b></i><b><b></b>,&#x00A0;<b>--of=</b></b><i><b>ofileX</b></i></dt>
  <dd class="It-tag">If you want to copy data to multiple files simultaneously,
      you can specify this option. It can be specified multiple times, so many
      copies can be made. Note that these files are secondary output files; they
      share file position with the primary output file <i>outfile</i>. Errors
      when writing to a secondary output file are ignored.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Data_protection_by_overwriting_with_random_numbers"><a class="selflink" href="#Data_protection_by_overwriting_with_random_numbers">Data
  protection by overwriting with random numbers</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-z&#x00A0;</b><i>RANDSEED</i><b>,&#x00A0;<b>--random=</b></b><i><b>RANDSEED</b></i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Z&#x00A0;</b><i>RANDSEED</i><b>,&#x00A0;<b>--frandom=</b></b><i><b>RANDSEED</b></i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-2&#x00A0;</b><i>RANDSEED</i><b>,&#x00A0;<b>--shred2=</b></b><i><b>RANDSEED</b></i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-3&#x00A0;</b><i>RANDSEED</i><b>,&#x00A0;<b>--shred3=</b></b><i><b>RANDSEED</b></i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-4&#x00A0;</b><i>RANDSEED</i><b>,&#x00A0;<b>--shred4=</b></b><i><b>RANDSEED</b></i></dt>
  <dd class="It-tag">When you want to overwrite a file, partition or disk with
      random data, using /dev/urandom (on Linux) as input is not a very good
      idea; the interface has not been designed to yield a high bandwidth. It's
      better to use a user space Pseudo Random Number Generator (PRNG). With
      option -z / --random, the C library's PRNG is used. With -Z / --frandom
      and the -2/-3/-4 / --shred2/3/4 options, an RC4 based PRNG is used.
    <div>&#x00A0;</div>
    Note that in this mode, there is no <i>infile</i> so the first non-option
      argument is the output file.
    <div>&#x00A0;</div>
    The PRNG needs seeding; the C libraries PRNG takes a 32bit integer (4
      bytes); the RC4 based PRNG takes 256 bytes. If <i>RANDSEED</i> is an
      integer, the integer number will be used to seed the C library's PRNG. For
      the RC4 method, the C library's PRNG then generates the 256 bytes to seed
      it. This creates repeatable PRNG data. The RANDSEED value of 0 is special;
      it will create a seedval that's based on the current time and the process'
      PID and should be different for multiple runs of <b>dd_rescue .</b>
    <div>&#x00A0;</div>
    If <i>RANDSEED</i> is not an integer, it's assumed to be a file name from
      which the seed values can be read. <b>dd_rescue</b> will read 4 or 256
      bytes from the file to seed the C library's or the RC4 PRNG. For good
      pseudo random numbers, using /dev/urandom to seed is a good idea.
    <div>&#x00A0;</div>
    The modes -2/-3/-4 resp. --shred2/--shred3/--shred4 will overwrite the
      output file multiple times; after each pass, fsync() will ensure that the
      data does indeed hit the file. The last pass for these modes will
      overwrite the file with zeroes. The rationale behind doing this is to make
      it easier to hide that important data may have been overwritten, to make
      it easier for intelligent storage systems (such as SSDs) to recycle the
      empty blocks and to allow for better compression of a file system image
      containing such data.
    <div>&#x00A0;</div>
    With -2 / --shred2, one pass with RC4 generated PRNG is happening and then
      zeroes are written. With -3 / --shred3, there are two passes with RC4 PRNG
      generated random numbers and a zero pass; the second PRNG pass writes the
      inverse (bit-wise reversed) numbers from the first pass. -4 / --shred4
      works like -3 / --shred3, with an additional pass with independent random
      numbers as third pass.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Plugins"><a class="selflink" href="#Plugins">Plugins</a></h2>
Since version 1.42, <b>dd_rescue</b> has an interface for plugins. Plugins have
  the ability to analyze the copied data or to transform it prior to it being
  written.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L&#x00A0;</b><i>plugin1[=param1[:param2[:..]]][,plugin2[=..][,..]]</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--plugins=</b><i>plugin1[=param1[:param2[:..]]][,plugin2[=..][,..]]</i></dt>
  <dd class="It-tag">loads plugins plugin1 ... and passes parameters to it. All
      plugins should support at least the help parameter and provide information
      on their usage.
    <div>&#x00A0;</div>
    Plugins may impose limits on dd_rescue. Plugins that look at the data can't
      work with splice, as this avoids copying data to user space. Also the
      interface currently does not facilitate reverse direction copy. Some
      plugins may impose further restrictions w.r.t. alignment of data in the
      file or not using sparse detection.
    <div>&#x00A0;</div>
    See section <b>PLUGINS</b> for an overview of available plugins.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="PLUGINS"><a class="selflink" href="#PLUGINS">PLUGINS</a></h1>
<h2 class="Ss" title="Ss" id="null"><a class="selflink" href="#null">null</a></h2>
The null plugin (ddr_null) does nothing, except if you specify the
  <b>[no]lnchange</b> or the <b>[no]change</b> options in which case the plugin
  indicates to others that it transforms the length of the output or the data of
  the stream. (With the no prefix, it's reset to the default no-change
  indication again.) This may be helpful for testing or to influence which file
  the hash plugin considers for reading/writing extended attributes from/to and
  for plugins to change their behavior with respect to hole detection.
<div>&#x00A0;</div>
ddr_null_ddr also allows you to specify <b>debug</b> in which case it just
  reports the blocks that it passes on.
<h2 class="Ss" title="Ss" id="hash"><a class="selflink" href="#hash">hash</a></h2>
When the hash plugin (subsequently referred to as ddr_hash) is loaded, it will
  calculate a cryptographic hash and optionally also a HMAC over the copied data
  and print the result at the end of the copy operations. The hash algorithm can
  be chosen by specifying <b>alg[o[rithm]]=ALG</b> where ALG is one of md5,
  sha1, sha256, sha224, sha512, sha384. (Specify alg=help to get a list.) To
  abbreviate the syntax, the alg= piece can be omitted.
<div>&#x00A0;</div>
For backwards compatibility, the hash plugin can also be referred to with the
  old MD5 name; it then defaults to the md5 algorithm.
<div>&#x00A0;</div>
The computed value should be identical to calling md5sum/sha256sum/... on the
  target file (unless you only write part of the file), but saves time by not
  accessing the (possibly large) file a second time. The hash plugin handles
  sparse writes and arbitrary offsets fine.
<div class="Pp"></div>
ddr_hash also supports the parameter <b>append=STRING</b> which appends the
  given STRING to the output before computing the cryptographic hash. Treating
  the STRING as a shared secret, this can actually be used to protect against
  someone not knowing the secret altering the contents (and recomputing the
  hash) without anyone noticing. It's thus a cheap way of a cryptographic
  signature (but with preshared secrets as opposed to public key cryptography).
  Use HMAC for a somewhat better way to sign data with a shared secret.
<div>&#x00A0;</div>
ddr_hash also supports <b>prepend=STRING</b> which is likely harder to attack
  with brute force than an appended string. Note that ddr_hash always prepends
  multiples of the hash algorithm's block size and pads the STRING with 0 to
  match.
<div class="Pp"></div>
ddr_hash can be used to compute a HMAC (Hash-based Message Authentication Code)
  instead of the plain hash. The HMAC uses a password that's prepended and
  transformed twice to the data which is then hashed twice. HMAC is believed to
  protect somewhat better against extension or collision attacks than a plain
  hash (with a plain prepended secret), so it's a better way to authenticate
  data with a shared secret. (You can use append/prepend in addition to HMAC, if
  you have a need for a scheme with more than one secret.)
<div>&#x00A0;</div>
When HMAC is enabled with one of the following parameters, both the plain hash
  and the HMAC are computed by ddr_hash. Both are output to the console/log, but
  the HMAC is used instead of the hash value to be written to a CHECKSUMS file
  or to an extended attribute or checked against (see below).
  <b>hmacpwd=STRING</b> sets the shared secret (password) for computing the
  HMAC. Passing the secret on the command line has the disadvantage that the
  shell may mistreat some bytes as special characters and that the command line
  may be visible to all logged in users on the system. <b>hmacpwdfd=INT</b> sets
  a file descriptor from with the secret (password) for HMAC computation will be
  read. Specifying 0 means standard input, in which case ddr_hash even prints a
  prompt for you ... Other numbers may be useful if dd_rescue is called from
  another program that opens a pipe to pass the secret. <b>hmacpwdnm=INNAME</b>
  sets a file from which the shared secret (password) is read. Note that all
  bytes (up to 2048 of them) are read and used, including trailing white space,
  0-bytes or newlines.
<div>&#x00A0;</div>
Please note that the ddr_hash plugin at this point does NOT take a lot of care
  to prevent the password/pre/appended secret from remaining in memory or
  leaking into a swap/page file. (This will be improved once I look into
  encryption plugins.)
<div class="Pp"></div>
ddr_hash accepts the parameter <b>output</b> , which will cause ddr_hash to
  output the cryptographic hash to stdout in the same format that
  md5sum/sha256sum/... use. You can also specify <b>outfd=INT</b> to have the
  plugin write the hash to a different file descriptor specified by the integer
  number INT. Note that ddr_hash always processes data in binary mode and
  correctly indicates this with a star (*) in the output generated with
  output/outfd=.
<div>&#x00A0;</div>
The checksum can also be written to a file by giving the <b>outnm=OUTNAME</b>
  parameter. Then a file with OUTNAME will be created and a md5sum/sha256sum/...
  compatible line will be printed to the file. If the file exists and contains
  an entry for the file, it will be updated. If the file exists and does not
  contain an entry for the file, one will be appended. If OUTNAME is omitted,
  the file name CHECKSUMS.alg (or HMACS.alg if HMAC is enabled) will be used
  (alg is replaced by the chosen algorithm). If the checksum can't be written, a
  warning will be printed and the exit code of dd_rescue will become non-zero.
<div class="Pp"></div>
The checksum can be validated using <b>checknm=CHKNAME .</b> The file will be
  read and ddr_hash will look for an md5sum/sha256sum/... compatible line with a
  matching file name to take the checksum from and compare it to the one
  computed. If NAME is omitted, the same default as described above (in
  outnm=...) will be used. You can also read the checksum from stdin if you
  prefer by specifying the <b>check</b> option.
<div>&#x00A0;</div>
Note that in any case, the check is only performed after the copy operation is
  completed -- a faulty checksum will thus NOT result in the copy not taking
  place. However, the exit code of dd_rescue will indicate the error. (If you
  want to avoid copying data with a broken checksum into the final target, use a
  temporary target that you delete upon error and only move to the final
  location if dd_rescue's exit value is 0; you can of course also copy to
  /dev/null for testing beforehand, but it might be too costly reading the input
  file twice.)
<div class="Pp"></div>
You can store the cryptographic hash into the files by using the
  <b>set_xattr</b> option. The hash will be stored into the extended attribute
  user.checksum.ALG by default (user.hmac.ALG if HMAC is enabled), but you can
  override the name of the attribute by specifying <b>set_xattr=XATTR.NAME</b>
  instead. If the xattr can't be written, an error will be reported, unless you
  also specify the <b>fallb[ack][=CHKNAME]</b> option. In that case, ddr_hash
  tries to write the checksum to the CHKNAME checksums file. (For the default
  for CHKNAME, see outnm= option above.)
<div>&#x00A0;</div>
<b>chk_xattr</b> will validate that the computed hash matches the one read from
  the extended attribute. The same default attribute name applies and you can
  likewise override it with <b>chk_xattr=XATTR.NAME .</b> A missing attribute is
  considered an error (although the same fallback is tried if you specify the
  fallback option). A broken checksum is of course considered an error as well,
  but just like with checknm=CHKNAME won't prevent the copy. See the discussion
  there.
<div class="Pp"></div>
Note that for output,outfd,outnm=,set_xattr ddr_hash will use the output file
  name to attach the checksum to (be it by setting xattr or the file name used
  in the checksum file), unless a plugin in the chain after ddr_hash indicates
  that it changes the data. In that case, it will warn and associate the
  checksum with the input file name, unless there's another plugin before
  ddr_hash in the chain which indicates data transformation as well. In that
  case, there is no file that the checksum could be associated with and ddr_hash
  will report an error.
<div>&#x00A0;</div>
Likewise for chknm=,check,chk_xattr ddr_hash will use the input file name to get
  the checksum (be it by reading the xattr or by looking for the input file name
  in a checksums file) unless there's a plugin in the chain before ddr_hash that
  indicates that it changes the data. The output file name will then be used,
  unless there's another plugin after ddr_hash indicating data change as well,
  in which case there's no file we could get the checksum for and thus an error
  is reported.
<div class="Pp"></div>
If your system supports extended attributes, those have the advantage of
  traveling with the files; thus a rename or copy (with dd_rescue -p) will
  maintain the checksum. Checksum files on the other hand can be handled
  everywhere (including the transfer via ftp or http) and can be
  cryptographically signed with PGP/GnuPG.
<div class="Pp"></div>
Please note that the md5 algorithm is NOT recommended any more for good
  protection against malicious attempts to hide data modification; it's not
  considered strong enough any more to prevent hash collisions. sha1 is better,
  but the recommendation is to use the SHA-2 family of hashes. On 32bit
  machines, I'd recommend sha256, while on 64bit machines, sha512 is faster and
  thus the best choice.
<div class="Pp"></div>
ddr_hash also supports using the HMAC code and hashes for deriving keys from
  passwords using the PKCS5 PBKDF2 (password-based key derivation function) that
  allows you to improve the protection from mediocre passwords by using a salt
  and a relatively expensive key stretching operation. This is only meant for
  testing and may be removed in the future. It's thus not documented in this man
  page. See the built-in help function for a brief summary on the usage.
<h2 class="Ss" title="Ss" id="lzo"><a class="selflink" href="#lzo">lzo</a></h2>
The lzo plugin allows to compress and decompress data using liblzo2. lzo is an
  algorithm that is faster than most other algorithms but does not compress as
  well. See the <b>ddr_lzo</b>(1) man page for more details.
<h2 class="Ss" title="Ss" id="crypt"><a class="selflink" href="#crypt">crypt</a></h2>
The crypt plugin allows to encrypt and decrypt data on the fly. It currently
  supports a variety of AES ciphers. See the <b>ddr_crypt</b>(1) man page for
  more details.
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
On successful completion, <b>dd_rescue</b> returns an exit code of 0. Any other
  exit code indicates that the program has aborted because of an error condition
  or that copying of the data has not been entirely successful.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dd_rescue&#x00A0;-k&#x00A0;-P&#x00A0;-p&#x00A0;-t&#x00A0;infile&#x00A0;outfile</b></dt>
  <dd class="It-tag">copies <i>infile</i> to <i>outfile</i> and does truncate
      the output file on opening (so deleting any previous data in it), copies
      mode, times, ownership at the end, uses fallocate to reserve the space for
      the output file and uses efficient in kernel splice copy method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dd_rescue&#x00A0;-A&#x00A0;-d&#x00A0;-D&#x00A0;-b&#x00A0;512&#x00A0;/dev/sda&#x00A0;/dev/sda</b></dt>
  <dd class="It-tag">reads the contents of every sector of disk sda and writes
      it back to the same location. Typical hard disks reallocate flaky and
      faulty sectors on writes, so this operation may result in the complete
      disk being usable again when there were errors before. Unreadable blocks
      however will contain zeroes after this.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dd_rescue&#x00A0;-2&#x00A0;/dev/urandom&#x00A0;-M&#x00A0;outfile</b></dt>
  <dd class="It-tag">overwrites the file <i>outfile</i> twice; once with good
      pseudo random numbers and then with zeroes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dd_rescue&#x00A0;-t&#x00A0;-a&#x00A0;image1.raw&#x00A0;image2.raw</b></dt>
  <dd class="It-tag">copies a file system image and looks for empty blocks to
      create a sparse output file to save disk space. (If the source file system
      has been used a bit, on that file system creating a large file with zeroes
      and removing it again prior to this operation will result in more sectors
      with zeroes. <b>dd_rescue&#x00A0;-u&#x00A0;/dev/zero&#x00A0;DUMMY</b> will
      achieve this ...)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dd_rescue&#x00A0;-ATL&#x00A0;hash=md5:output,lzo=compress:bench,MD5:output&#x00A0;in&#x00A0;out.lzo</b></dt>
  <dd class="It-tag">copies the file <i>in</i> to <i>out.lzo</i> with using lzo
      (lzo1x_1) compression and calculating an md5 hash (checksum) on both
      files. The md5 hashes for both are also written to stdout in the md5sum
      output format. Note that the compress parameter to lzo is not strictly
      required here; the plugin could have deduced it from the file names. This
      example shows that you can specify multiple plugins with multiple
      parameters; the plugins are forming a filter chain. You can specify the
      same plugin multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dd_rescue&#x00A0;-L&#x00A0;hash=sha512:set_xattr:fallb,null=change&#x00A0;infile&#x00A0;/dev/null</b></dt>
  <dd class="It-tag">reads the file <i>infile</i> and computes its sha512 hash.
      It stores it in the input file's user.checksum.sha512 attribute (and falls
      back to writing it to CHECKSUMS.sha512 if xattrs can't be written). Note
      the use of the null plugin with faking data change with the change
      parameter; this causes the hash plugin to write to the input file which it
      would not normally have done. Of course this will fail if you don't have
      the appropriate privileges to write xattrs to infile nor to write the
      checksum to CHECKSUMS.sha512.</dd>
</dl>
<div class="Pp"></div>
See also README.dd_rescue and ddr_lzo(1) to learn about the possibilities.
<h1 class="Sh" title="Sh" id="TESTING"><a class="selflink" href="#TESTING">TESTING</a></h1>
Untested code is buggy, almost always. I happen to have a damaged hard disk that
  I use for testing dd_rescue from time to time. But to allow for automated
  testing of error recovery, it's better to have predictable failures for the
  program to deal with. So there is a fault injection framework.
<div>&#x00A0;</div>
Specifying <b>-F&#x00A0;5w/1,17r/3,42r/-1,80-84r/0</b> on the command-line will
  result in in the 5th block (counted in hardblocksize) will fail to be written
  once (from which dd_rescue should recover, as it tries a second time for
  failed writes), block no 17 will fail to be read 3 times, block no 42 will
  read fine once, but then fail afterwards, whereas blocks 80 through 83 are
  completely unreadable (will fail infinite times). Note that the range excludes
  the last block (80-84 means 4 blocks starting @ 80).
<div>&#x00A0;</div>
Block offsets are always counted in absolute positions, so starting in the
  middle of a file with -s or reverse copying won't affect the absolute position
  that is hit with the fault injection. (This has changed since 1.98.)
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="BUGS/LIMITATIONS"><a class="selflink" href="#BUGS/LIMITATIONS">BUGS/LIMITATIONS</a></h1>
The source code does use the 64bit functions provided by glibc for file
  positioning. However, your kernel might not support it, so you might be unable
  to copy partitions larger then 2GB into a file.
<div>&#x00A0;</div>
This program has been written using Linux and only tested on a couple of Linux
  systems. People have reported to have successfully used it on other Un*xish
  systems (such as xBSD or M*cOS), but these systems get little regular test
  coverage; so please be advised to test properly (possibly using the make check
  test suite included with the source distribution) before relying on dd_rescue
  on non Linux based systems.
<div>&#x00A0;</div>
Currently, the escape sequence for moving the cursor up is hard coded in the
  sources. It's fine for most terminal emulations (including vt100 and linux),
  but it should use the terminal description database instead.
<div>&#x00A0;</div>
Since dd_rescue-1.10, non-seekable input or output files are supported, but
  there's of course limitations to recover errors in such cases.
<div class="Pp"></div>
dd_rescue does not automate the recovery of faulty files or partitions by
  automatically keeping a list of copied sectors and approaching bad spots from
  both sides. There is a helper script dd_rhelp from LAB Valentin that does
  this. Integration of such a mode into <b>dd_rescue</b> itself is non-trivial
  and due to the complexity of the source code might not happen.
<div>&#x00A0;</div>
There also is a tool, GNU ddrescue, that is a reimplementation of this tool and
  which contains the capabilities to automate recovery of bad files in the way
  dd_rhelp does. It does not have the feature richness of dd_rescue, but is
  reported to be easier to operate for error recovery than dd_rescue with
  dd_rhelp.
<div class="Pp"></div>
If your data is very valuable and you are considering sending your disk to a
  data recovery company, you might be better off NOT trying to use imaging tools
  like dd_rescue, dd_rhelp or GNU ddrescue. If you're unlucky, the disk has
  suffered some mechanical damage (e.g. by having been dropped), and continuing
  to use it may make the head damage the surface further. You may be able to
  detect this condition by quickly raising error counts in the SMART attributes
  or by a clicking noise.
<div class="Pp"></div>
Please report bugs to me via email.
<h2 class="Ss" title="Ss" id="Data_destruction_considerations"><a class="selflink" href="#Data_destruction_considerations">Data
  destruction considerations</a></h2>
The modes for overwriting data with pseudo random numbers to securely delete
  sensitive data on purpose only implement a limited number of overwrites. While
  Peter Gutmann's classic analysis concludes that the then current hard disk
  technology requires more overwrites to be really secure, the author believes
  that modern hard disk technology does not allow data restoration of sectors
  that have been overwritten with the --shred4 mode. This is in compliance with
  the recommendations from BSI GSDS M7.15.
<div>&#x00A0;</div>
Overwriting whole partitions or disks with random numbers is a fairly safe way
  to destroy data, unless the underlying storage device does too much magic.
  SSDs are doing fancy stuff in their Flash Translation Layer (FTL), so this
  tool might be insufficient to get rid of data. Use SECURITY_ERASE (use hdparm)
  there or -- if available -- encrypt data with AES256 and safely destroy the
  key. Normal hard disks have a small risk of leaking a few sectors due to
  reallocation of flaky sectors.
<div>&#x00A0;</div>
For securely destroying single files, your mileage may vary. The more advanced
  your file system, the less likely dd_rescue's destruction will be effective.
  In particular, journaling file systems may carry old data in the journal. File
  systems that do copy-on-write (COW) such as btrfs, are very likely to have old
  copies of your supposedly erased file. It might help somewhat to fill the file
  systems with zeros (dd_rescue -u /dev/zero /path/to/fs/DUMMYNAME) to force the
  file system to release and overwrite non-current data after overwriting
  critical files with random numbers. If you can, better destroy a whole
  partition or disk.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>README.dd_rescue</b> <b>README.dd_rhelp</b> <b>ddr_lzo</b>(1)
<div>&#x00A0;</div>
<b>wipe</b>(1) <b>shred</b>(1) <b>ddrescue</b>(1) <b>dd</b>(1)
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Kurt Garloff &lt;kurt@garloff.de&gt;
<h1 class="Sh" title="Sh" id="CREDITS"><a class="selflink" href="#CREDITS">CREDITS</a></h1>
Many little issues were reported by Valentin LAB, the author of <b>dd_rhelp
  .</b>
<div>&#x00A0;</div>
The RC4 PRNG (frandom) is a port from Eli Billauer's kernel mode PRNG.
<div>&#x00A0;</div>
A number of recent ideas and suggestions came from Thomas.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
This program is protected by the GNU General Public License (GPL) v2 or v3 - at
  your option.
<h1 class="Sh" title="Sh" id="HISTORY"><a class="selflink" href="#HISTORY">HISTORY</a></h1>
Since version 1.10, non seekable input and output files are supported.
<div>&#x00A0;</div>
Splice copy -k is supported since 1.15.
<div>&#x00A0;</div>
A progress bar exists since 1.17.
<div>&#x00A0;</div>
Support for preallocation (fallocate) -P exists since 1.19.
<div>&#x00A0;</div>
Since 1.23, we default to -y0, enhancing performance.
<div>&#x00A0;</div>
The Pseudo Random Number modes have been started with 1.29.
<div>&#x00A0;</div>
Write avoidance -W has been implemented in 1.30
<div>&#x00A0;</div>
Multiple output files -Y have been added in 1.32.
<div>&#x00A0;</div>
Long options and man page came with 1.33.
<div>&#x00A0;</div>
Optimized sparse detection (SSE2, armv6, armv8 asm, AVX2) has been present since
  1.35 and been enhanced until 1.43.
<div>&#x00A0;</div>
We support copying extended attributes since 1.40 using libxattr.
<div>&#x00A0;</div>
Removing and (fs)trimming the output file's file system exists since 1.41.
  Support for compilation with bionic (Android's C library) with most features
  enabled also came with 1.41.
<div>&#x00A0;</div>
Plugins exist since 1.42, the MD5 plugin came with 1.42, the lzo plugin with
  1.43. 1.44 renamed the MD5 plugin to hash and added support for the SHA-2
  family of hashes. 1.45 added SHA-1 and the ability to store and validate
  checksums.
<div>&#x00A0;</div>
1.98 brought encryption and the fault injection framework, 1.99 support for
  ARMv8 crypto acceleration. 1.99.5 brought ratecontrol.
<div class="Pp"></div>
Some additional information can be found on
<div>&#x00A0;</div>
http://garloff.de/kurt/linux/ddrescue/
<div>&#x00A0;</div>
LAB Valentin's <b>dd_rhelp</b> can be found on
<div>&#x00A0;</div>
http://www.kalysto.org/utilities/dd_rhelp/index.en.html</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-12-29</td>
    <td class="foot-os">Kurt Garloff</td>
  </tr>
</table>
</body>
</html>
