<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:56:16 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CSH(1) BSD General Commands Manual CSH(1)</p>

<p style="margin-top: 1em">NAME <br>
csh &acirc; a shell (command interpreter) with C-like
syntax</p>

<p style="margin-top: 1em">SYNOPSIS <br>
csh [-bcefimnstVvXx] [argument ...] <br>
csh [-l]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
csh is a command language interpreter incorporating a
history mechanism (see History substitutions), job control
facilities (see Jobs), interactive file name and user name
comple&acirc; <br>
tion (see File name completion), and a C-like syntax. It is
used both as an interactive login shell and a shell script
command processor.</p>

<p style="margin-top: 1em">Argument list processing <br>
If the first argument (argument 0) to the shell is a dash
(&acirc;-&acirc;), then this is a login shell. A login shell
also can be specified by invoking the shell with the -l flag
as the only <br>
argument.</p>

<p style="margin-top: 1em">The rest of the flag arguments
are interpreted as follows:</p>

<p style="margin-top: 1em">-b This flag forces a
&acirc;break&acirc; from option processing, causing any
further shell arguments to be treated as non-option
arguments. The remaining arguments will not be inter&acirc;
<br>
preted as shell options. This may be used to pass options to
a shell script without confusion or possible subterfuge. The
shell will not run a set-user-ID script without <br>
this option.</p>

<p style="margin-top: 1em">-c Commands are read from the
(single) following argument which must be present. Any
remaining arguments are placed in argv.</p>

<p style="margin-top: 1em">-e The shell exits if any
invoked command terminates abnormally or yields a non-zero
exit status.</p>

<p style="margin-top: 1em">-f The shell will start faster,
because it will neither search for nor execute commands from
the file .cshrc in the invoker&rsquo;s home directory. Note:
if the environment variable <br>
HOME is not set, fast startup is the default.</p>

<p style="margin-top: 1em">-i The shell is interactive and
prompts for its top-level input, even if it appears not to
be a terminal. Shells are interactive without this option if
their inputs and out&acirc; <br>
puts are terminals.</p>

<p style="margin-top: 1em">-l The shell is a login shell
(only applicable if -l is the only flag specified).</p>

<p style="margin-top: 1em">-m Read .cshrc, regardless of
its owner and group. This option is dangerous and should
only be used by su(1).</p>

<p style="margin-top: 1em">-n Commands are parsed, but not
executed. This aids in syntactic checking of shell scripts.
When used interactively, the shell can be terminated by
pressing control-D (end- <br>
of-file character), since exit will not work.</p>

<p style="margin-top: 1em">-s Command input is taken from
the standard input.</p>

<p style="margin-top: 1em">-t A single line of input is
read and executed. A backslash (&acirc;&acirc;) may be used
to escape the newline at the end of this line and continue
onto another line.</p>

<p style="margin-top: 1em">-V Causes the verbose variable
to be set even before .cshrc is executed.</p>

<p style="margin-top: 1em">-v Causes the verbose variable
to be set, with the effect that command input is echoed
after history substitution.</p>

<p style="margin-top: 1em">-X Causes the echo variable to
be set even before .cshrc is executed.</p>

<p style="margin-top: 1em">-x Causes the echo variable to
be set, so that commands are echoed immediately before
execution.</p>

<p style="margin-top: 1em">After processing of flag
arguments, if arguments remain but none of the -c, -i, -s,
or -t options were given, the first argument is taken as the
name of a file of commands to be <br>
executed. The shell opens this file, and saves its name for
possible resubstitution by &acirc;$0&acirc;. Since many
systems use either the standard version 6 or version 7
shells whose shell <br>
scripts are not compatible with this shell, the shell will
execute such a &acirc;standard&acirc; shell if the first
character of a script is not a hash mark (&acirc;#&acirc;);
i.e., if the script does not <br>
start with a comment. Remaining arguments initialize the
variable argv.</p>

<p style="margin-top: 1em">An instance of csh begins by
executing commands from the file /etc/csh.cshrc and, if this
is a login shell, /etc/csh.login. It then executes commands
from .cshrc in the home <br>
directory of the invoker, and, if this is a login shell, the
file .login in the same location. It is typical for users on
CRTs to put the command stty crt in their .login file, <br>
and to also invoke tset(1) there.</p>

<p style="margin-top: 1em">In the normal case, the shell
will begin reading commands from the terminal, prompting
with &acirc;% .&acirc; Processing of arguments and the use
of the shell to process files containing com&acirc; <br>
mand scripts will be described later.</p>

<p style="margin-top: 1em">The shell repeatedly performs
the following actions: a line of command input is read and
broken into &acirc;words&acirc;. This sequence of words is
placed on the command history list and <br>
parsed. Finally each command in the current line is
executed.</p>

<p style="margin-top: 1em">When a login shell terminates it
executes commands from the files .logout in the user&rsquo;s
home directory and /etc/csh.logout.</p>

<p style="margin-top: 1em">Lexical structure <br>
The shell splits input lines into words at blanks and tabs
with the following exceptions. The characters
&acirc;&amp;&acirc;, &acirc;|&acirc;, &acirc;;&acirc;,
&acirc;&lt;&acirc;, &acirc;&gt;&acirc;, &acirc;(&acirc;, and
&acirc;)&acirc; form separate words. If doubled in <br>
&acirc;&amp;&amp;&acirc;, &acirc;||&acirc;,
&acirc;&lt;&lt;&acirc;, or &acirc;&gt;&gt;&acirc;, these
pairs form single words. These parser metacharacters may be
made part of other words, or have their special meaning
prevented, by preceding them <br>
with a backslash (&acirc;&acirc;). A newline preceded by a
&acirc;&acirc; is equivalent to a blank.</p>

<p style="margin-top: 1em">Strings enclosed in matched
pairs of quotations, &acirc;&rsquo;&acirc;,
&acirc;&lsquo;&acirc;, or &acirc;&quot;&acirc;, form parts
of a word; metacharacters in these strings, including blanks
and tabs, do not form separate words. <br>
These quotations have semantics to be described later.
Within pairs of &acirc;&rsquo;&acirc; or
&acirc;&quot;&acirc; characters, a newline preceded by a
&acirc;&acirc; gives a true newline character.</p>

<p style="margin-top: 1em">When the shell&rsquo;s input is
not a terminal, the character &acirc;#&acirc; introduces a
comment that continues to the end of the input line. This
special meaning is prevented when preceded by <br>
&acirc;&acirc; and in quotations using
&acirc;&lsquo;&acirc;, &acirc;&rsquo;&acirc;, and
&acirc;&quot;&acirc;.</p>

<p style="margin-top: 1em">Commands <br>
A simple command is a sequence of words, the first of which
specifies the command to be executed. A simple command or a
sequence of simple commands separated by &acirc;|&acirc;
characters <br>
forms a pipeline. The output of each command in a pipeline
is connected to the input of the next. Sequences of
pipelines may be separated by &acirc;;&acirc;, and are then
executed sequen&acirc; <br>
tially. A sequence of pipelines may be executed without
immediately waiting for it to terminate by following it with
a &acirc;&amp;&acirc;.</p>

<p style="margin-top: 1em">Any of the above may be placed
in &acirc;(&acirc; &acirc;)&acirc; to form a simple command
(that may be a component of a pipeline, for example). It is
also possible to separate pipelines with &acirc;||&acirc; or
<br>
&acirc;&amp;&amp;&acirc; showing, as in the C language, that
the second is to be executed only if the first fails or
succeeds, respectively. (See Expressions.)</p>

<p style="margin-top: 1em">Jobs <br>
The shell associates a job with each pipeline. It keeps a
table of current jobs, printed by the jobs command, and
assigns them small integer numbers. When a job is started
asyn&acirc; <br>
chronously with &acirc;&amp;&acirc;, the shell prints a line
that looks like:</p>

<p style="margin-top: 1em">[1] 1234</p>

<p style="margin-top: 1em">showing that the job which was
started asynchronously was job number 1 and had one
(top-level) process, whose process ID was 1234.</p>

<p style="margin-top: 1em">If you are running a job and
wish to do something else you may hit ^Z (control-Z), which
sends a SIGSTOP signal to the current job. The shell will
then normally show that the job <br>
has been &acirc;Stopped&acirc;, and print another prompt.
You can then manipulate the state of this job, putting it in
the background with the bg command, or run some other
commands and even&acirc; <br>
tually bring the job back into the foreground with the fg
command. A ^Z takes effect immediately and is like an
interrupt in that pending output and unread input are
discarded <br>
when it is typed. There is another special key ^Y that does
not generate a SIGSTOP signal until a program attempts to
read(2) it. This request can usefully be typed ahead when
<br>
you have prepared some commands for a job that you wish to
stop after it has read them.</p>

<p style="margin-top: 1em">A job being run in the
background will stop if it tries to read from the terminal.
Background jobs are normally allowed to produce output, but
this can be disabled by giving the <br>
command stty tostop. If you set this tty option, then
background jobs will stop when they try to produce output
like they do when they try to read input.</p>

<p style="margin-top: 1em">There are several ways to refer
to jobs in the shell. The character &acirc;%&acirc;
introduces a job name. If you wish to refer to job number 1,
you can name it as &acirc;%1&acirc;. Just naming a job <br>
brings it to the foreground; thus %1 is a synonym for fg %1,
bringing job number 1 back into the foreground. Similarly,
saying %1 &amp; resumes job number 1 in the background. Jobs
<br>
can also be named by prefixes of the string typed in to
start them, if these prefixes are unambiguous; thus %ex
would normally restart a suspended ex(1) job, if there were
only one <br>
suspended job whose name began with the string
&quot;ex&quot;. It is also possible to say %?string, which
specifies a job whose text contains string, if there is only
one such job.</p>

<p style="margin-top: 1em">The shell maintains a notion of
the current and previous jobs. In output about jobs, the
current job is marked with a &acirc;+&acirc; and the
previous job with a &acirc;-&acirc;. The abbreviation
&acirc;%+&acirc; <br>
refers to the current job and &acirc;%-&acirc; refers to the
previous job. For close analogy with the syntax of the
history mechanism (described below), &acirc;%%&acirc; is
also a synonym for the current <br>
job.</p>

<p style="margin-top: 1em">The job control mechanism
requires that the stty(1) option new be set. It is an
artifact from a new implementation of the tty driver that
allows generation of interrupt characters <br>
from the keyboard to tell jobs to stop. See stty(1) for
details on setting options in the new tty driver.</p>

<p style="margin-top: 1em">Status reporting <br>
The shell learns immediately whenever a process changes
state. It normally informs you whenever a job becomes
blocked so that no further progress is possible, but only
just before <br>
it prints a prompt. This is done so that it does not
otherwise disturb your work. If, however, you set the shell
variable notify, the shell will notify you immediately of
changes <br>
of status in background jobs. There is also a shell command
notify that marks a single process so that its status
changes will be immediately reported. By default notify
marks <br>
the current process; simply say notify after starting a
background job to mark it.</p>

<p style="margin-top: 1em">When you try to leave the shell
while jobs are stopped, you will be warned that &acirc;You
have stopped jobs&acirc;. You may use the jobs command to
see what they are. If you try to exit <br>
again immediately, the shell will not warn you a second
time, and the suspended jobs will be terminated.</p>

<p style="margin-top: 1em">File name completion <br>
When the file name completion feature is enabled by setting
the shell variable filec (see set), csh will interactively
complete file names and user names from unique prefixes when
<br>
they are input from the terminal followed by the escape
character (the escape key, or control-[). For example, if
the current directory looks like</p>

<p style="margin-top: 1em">DSC.OLD bin cmd lib xmpl.c <br>
DSC.NEW chaosnet cmtest mail xmpl.o <br>
bench class dev mbox xmpl.out</p>

<p style="margin-top: 1em">and the input is</p>

<p style="margin-top: 1em">% vi ch&lt;escape&gt;</p>

<p style="margin-top: 1em">csh will complete the prefix
&acirc;ch&acirc; to the only matching file name
&acirc;chaosnet&acirc;, changing the input line to</p>

<p style="margin-top: 1em">% vi chaosnet</p>

<p style="margin-top: 1em">However, given</p>

<p style="margin-top: 1em">% vi D&lt;escape&gt;</p>

<p style="margin-top: 1em">csh will only expand the input
to</p>

<p style="margin-top: 1em">% vi DSC.</p>

<p style="margin-top: 1em">and will sound the terminal bell
to indicate that the expansion is incomplete, since there
are two file names matching the prefix &acirc;D&acirc;.</p>

<p style="margin-top: 1em">If a partial file name is
followed by the end-of-file character (usually control-D),
then, instead of completing the name, csh will list all file
names matching the prefix. For <br>
example, the input</p>

<p style="margin-top: 1em">% vi D&lt;control-D&gt;</p>

<p style="margin-top: 1em">causes all files beginning with
&acirc;D&acirc; to be listed:</p>

<p style="margin-top: 1em">DSC.NEW DSC.OLD</p>

<p style="margin-top: 1em">while the input line remains
unchanged.</p>

<p style="margin-top: 1em">The same system of escape and
end-of-file can also be used to expand partial user names,
if the word to be completed (or listed) begins with the
tilde character (&acirc;~&acirc;). For exam&acirc; <br>
ple, typing</p>

<p style="margin-top: 1em">cd ~ro&lt;escape&gt;</p>

<p style="margin-top: 1em">may produce the expansion</p>

<p style="margin-top: 1em">cd ~root</p>

<p style="margin-top: 1em">The use of the terminal bell to
signal errors or multiple matches can be inhibited by
setting the variable nobeep.</p>

<p style="margin-top: 1em">Normally, all files in the
particular directory are candidates for name completion.
Files with certain suffixes can be excluded from
consideration by setting the variable fignore <br>
to the list of suffixes to be ignored. Thus, if fignore is
set by the command</p>

<p style="margin-top: 1em">% set fignore = (.o .out)</p>

<p style="margin-top: 1em">then typing</p>

<p style="margin-top: 1em">% vi x&lt;escape&gt;</p>

<p style="margin-top: 1em">would result in the completion
to</p>

<p style="margin-top: 1em">% vi xmpl.c</p>

<p style="margin-top: 1em">ignoring the files
&quot;xmpl.o&quot; and &quot;xmpl.out&quot;. However, if the
only completion possible requires not ignoring these
suffixes, then they are not ignored. In addition, fignore
does <br>
not affect the listing of file names by control-D. All files
are listed regardless of their suffixes.</p>

<p style="margin-top: 1em">Substitutions <br>
We now describe the various transformations the shell
performs on the input in the order in which they occur.</p>

<p style="margin-top: 1em">History substitutions <br>
History substitutions place words from previous command
input as portions of new commands, making it easy to repeat
commands, repeat arguments of a previous command in the
current <br>
command, or fix spelling mistakes in the previous command
with little typing and a high degree of confidence. History
substitutions begin with the character &acirc;!&acirc; and
may begin <br>
anywhere in the input stream (with the proviso that they do
not nest). This &acirc;!&acirc; may be preceded by a
&acirc;&acirc; to prevent its special meaning; for
convenience, a &acirc;!&acirc; character is passed <br>
unchanged when it is followed by a blank, tab, newline,
&acirc;=&acirc; or &acirc;(&acirc;. (History substitutions
also occur when an input line begins with &acirc;^&acirc;.
This special abbreviation will be <br>
described later.) Any input line that contains history
substitution is echoed on the terminal before it is executed
as it would have been typed without history
substitution.</p>

<p style="margin-top: 1em">Commands input from the terminal
that consist of one or more words are saved on the history
list. The history substitutions reintroduce sequences of
words from these saved com&acirc; <br>
mands into the input stream. The size of the history list is
controlled by the history variable; the previous command is
always retained, regardless of the value of the history <br>
variable. Commands are numbered sequentially from 1.</p>

<p style="margin-top: 1em">For definiteness, consider the
following output from the history command:</p>

<p style="margin-top: 1em">09 write michael <br>
10 ex write.c <br>
11 cat oldwrite.c <br>
12 diff *write.c</p>

<p style="margin-top: 1em">The commands are shown with
their event numbers. It is not usually necessary to use
event numbers, but the current event number can be made part
of the prompt by placing a &acirc;!&acirc; in <br>
the prompt string.</p>

<p style="margin-top: 1em">With the current event 13 we can
refer to previous events by event number &acirc;!11&acirc;,
relatively as in &acirc;!-2&acirc; (referring to the same
event), by a prefix of a command word as in &acirc;!d&acirc;
for <br>
event 12 or &acirc;!wri&acirc; for event 9, or by a string
contained in a word in the command as in
&acirc;!?mic?&acirc; also referring to event 9. These forms,
without further change, simply reintroduce <br>
the words of the specified events, each separated by a
single blank. As a special case, &acirc;!!&acirc; refers to
the previous command; thus &acirc;!!&acirc; alone is a
redo.</p>

<p style="margin-top: 1em">To select words from an event we
can follow the event specification by a &acirc;:&acirc; and
a designator for the desired words. The words of an input
line are numbered from 0, the first <br>
(usually command) word being 0, the second word (first
argument) being 1, etc. The basic word designators are:</p>

<p style="margin-top: 1em">0 first (command) word <br>
n n&rsquo;th argument <br>
^ first argument; i.e., &acirc;1&acirc; <br>
$ last argument <br>
% word matched by (immediately preceding) ?s? search <br>
x-y range of words <br>
-y abbreviates &acirc;0-y&acirc; <br>
* abbreviates &acirc;^-$&acirc;, or nothing if only 1 word
in event <br>
x* abbreviates &acirc;x-$&acirc; <br>
x- like &acirc;x*&acirc; but omitting word
&acirc;$&acirc;</p>

<p style="margin-top: 1em">The &acirc;:&acirc; separating
the event specification from the word designator can be
omitted if the argument selector begins with a
&acirc;^&acirc;, &acirc;$&acirc;, &acirc;*&acirc;,
&acirc;-&acirc;, or &acirc;%&acirc;. After the optional word
des&acirc; <br>
ignator, a sequence of modifiers can be placed, each
preceded by a &acirc;:&acirc;. The following modifiers are
defined:</p>

<p style="margin-top: 1em">h Remove a trailing pathname
component, leaving the head. <br>
r Remove a trailing &acirc;.xxx&acirc; component, leaving
the root name. <br>
e Remove all but the extension &acirc;.xxx&acirc; part. <br>
s/l/r/ Substitute l for r. <br>
t Remove all leading pathname components, leaving the tail.
<br>
&amp; Repeat the previous substitution. <br>
g Apply the change once on each word, prefixing the above;
e.g., &acirc;g&amp;&acirc;. <br>
a Apply the change as many times as possible on a single
word, prefixing the above. It can be used together with
&acirc;g&acirc; to apply a substitution globally. <br>
p Print the new command line but do not execute it. <br>
q Quote the substituted words, preventing further
substitutions. <br>
x Like &acirc;q&acirc;, but break into words at blanks,
tabs, and newlines.</p>

<p style="margin-top: 1em">Unless preceded by a
&acirc;g&acirc; the change is applied only to the first
modifiable word. With substitutions, it is an error for no
word to be applicable.</p>

<p style="margin-top: 1em">The left-hand side of
substitutions are not regular expressions in the sense of
the editors, but instead strings. Any character may be used
as the delimiter in place of &acirc;/&acirc;; a
&acirc;&acirc; <br>
quotes the delimiter into the l and r strings. The character
&acirc;&amp;&acirc; in the right-hand side is replaced by
the text from the left. A &acirc;&acirc; also quotes
&acirc;&amp;&acirc;. A NULL l (&acirc;//&acirc;) uses <br>
the previous string either from an l or from a contextual
scan string s in &acirc;!?s may the trailing &acirc;?&acirc;
in a contextual scan.</p>

<p style="margin-top: 1em">A history reference may be given
without an event specification; e.g., &acirc;!$&acirc;.
Here, the reference is to the previous command unless a
previous history reference occurred on the <br>
same line in which case this form repeats the previous
reference. Thus &acirc;!?foo?^ !$&acirc; gives the first and
last arguments from the command matching
&acirc;?foo?&acirc;.</p>

<p style="margin-top: 1em">A special abbreviation of a
history reference occurs when the first non-blank character
of an input line is a &acirc;^&acirc;. This is equivalent to
&acirc;!:s^&acirc; providing a convenient shorthand <br>
for substitutions on the text of the previous line. Thus
^lb^lib fixes the spelling of &acirc;lib&acirc; in the
previous command. Finally, a history substitution may be
surrounded with &acirc;{&acirc; <br>
and &acirc;}&acirc; if necessary to insulate it from the
characters that follow. Thus, after ls -ld ~paul we might do
!{l}a to do ls -ld ~paula, while !la would look for a
command starting <br>
with &acirc;la&acirc;.</p>

<p style="margin-top: 1em">Quotations with &Acirc;&acute;
and &quot; <br>
The quotation of strings by &acirc;&rsquo;&acirc; and
&acirc;&quot;&acirc; can be used to prevent all or some of
the remaining substitutions. Strings enclosed in
&acirc;&rsquo;&acirc; are prevented from any further
interpretation. <br>
Strings enclosed in &acirc;&quot;&acirc; may be expanded as
described below.</p>

<p style="margin-top: 1em">In both cases the resulting text
becomes (all or part of) a single word; only in one special
case (see Command Substitution below) does a
&acirc;&quot;&acirc; quoted string yield parts of more than
<br>
one word; &acirc;&rsquo;&acirc; quoted strings never do.</p>

<p style="margin-top: 1em">Alias substitution <br>
The shell maintains a list of aliases that can be
established, displayed and modified by the alias and unalias
commands. After a command line is scanned, it is parsed into
dis&acirc; <br>
tinct commands and the first word of each command,
left-to-right, is checked to see if it has an alias. If it
does, then the text that is the alias for that command is
reread with <br>
the history mechanism available as though that command were
the previous input line. The resulting words replace the
command and argument list. If no reference is made to the
<br>
history list, then the argument list is left unchanged.</p>

<p style="margin-top: 1em">Thus if the alias for
&acirc;ls&acirc; is &acirc;ls -l&acirc;, the command ls /usr
would map to ls -l /usr, the argument list here being
undisturbed. Similarly, if the alias for
&acirc;lookup&acirc; was &acirc;grep !^ <br>
/etc/passwd&acirc; then lookup bill would map to grep bill
/etc/passwd.</p>

<p style="margin-top: 1em">If an alias is found, the word
transformation of the input text is performed and the
aliasing process begins again on the reformed input line.
Looping is prevented if the first <br>
word of the new text is the same as the old by flagging it
to prevent further aliasing. Other loops are detected and
cause an error.</p>

<p style="margin-top: 1em">Note that the mechanism allows
aliases to introduce parser metasyntax. Thus, we can alias
print &rsquo;pr * | lpr&rsquo; to make a command that
pr&rsquo;s its arguments to the line printer.</p>

<p style="margin-top: 1em">Variable substitution <br>
The shell maintains a set of variables, each of which has as
value a list of zero or more words. Some of these variables
are set by the shell or referred to by it. For instance,
<br>
the argv variable is an image of the shell&rsquo;s argument
list, and words of this variable&rsquo;s value are referred
to in special ways.</p>

<p style="margin-top: 1em">The values of variables may be
displayed and changed by using the set and unset commands.
Of the variables referred to by the shell a number are
toggles; the shell does not care <br>
what their value is, only whether they are set or not. For
instance, the verbose variable is a toggle that causes
command input to be echoed. The setting of this variable
results <br>
from the -v command-line option.</p>

<p style="margin-top: 1em">Other operations treat variables
numerically. The @ command permits numeric calculations to
be performed and the result assigned to a variable. Variable
values are, however, <br>
always represented as (zero or more) strings. For the
purposes of numeric operations, the null string is
considered to be zero, and the second and additional words
of multiword <br>
values are ignored.</p>

<p style="margin-top: 1em">After the input line is aliased
and parsed, and before each command is executed, variable
substitution is performed, keyed by &acirc;$&acirc;
characters. This expansion can be prevented by <br>
preceding the &acirc;$&acirc; with a &acirc;&acirc; except
within double quotes (&lsquo;&quot;&rsquo;), where it always
occurs, and within single quotes (&lsquo;&rsquo;&rsquo;),
where it never occurs. Strings quoted by backticks (&lsquo;
&lsquo;) <br>
are interpreted later (see Command substitution below), so
&acirc;$&acirc; substitution does not occur there until
later, if at all. A &acirc;$&acirc; is passed unchanged if
followed by a blank, tab, or <br>
end-of-line.</p>

<p style="margin-top: 1em">Input/output redirections are
recognized before variable expansion, and are variable
expanded separately. Otherwise, the command name and entire
argument list are expanded <br>
together. It is thus possible for the first (command) word
(to this point) to generate more than one word, the first of
which becomes the command name, and the rest of which <br>
become arguments.</p>

<p style="margin-top: 1em">Unless enclosed in
&acirc;&quot;&acirc; or given the &acirc;:q&acirc; modifier,
the results of variable substitution may eventually be
command and filename substituted. Within
&acirc;&quot;&acirc;, a variable whose value con&acirc; <br>
sists of multiple words expands to (a portion of) a single
word, with the words of the variable&rsquo;s value separated
by blanks. When the &acirc;:q&acirc; modifier is applied to
a substitution <br>
the variable will expand to multiple words with each word
separated by a blank and quoted to prevent later command or
filename substitution.</p>

<p style="margin-top: 1em">The following metasequences are
provided for introducing variable values into the shell
input. Except as noted, it is an error to reference a
variable that is not set.</p>

<p style="margin-top: 1em">$name <br>
${name} <br>
Are replaced by the words of the value of variable name,
each separated by a blank. Braces insulate name from
following characters that would otherwise be part of <br>
it. Shell variables have names consisting of up to 20
letters and digits starting with a letter. The underscore
character is considered a letter. If name is not a <br>
shell variable, but is set in the environment, then that
value is returned (but &acirc;:&acirc; modifiers and the
other forms given below are not available here). <br>
$name[selector] <br>
${name[selector]} <br>
May be used to select only some of the words from the value
of name. The selector is subjected to &acirc;$&acirc;
substitution and may consist of a single number or two
numbers <br>
separated by a &acirc;-&acirc;. The first word of a
variable&rsquo;s value is numbered &acirc;1&acirc;. If the
first number of a range is omitted it defaults to
&acirc;1&acirc;. If the last number of a <br>
range is omitted it defaults to &acirc;$#name&acirc;. The
selector &acirc;*&acirc; selects all words. It is not an
error for a range to be empty if the second argument is
omitted or in <br>
range. <br>
$#name <br>
${#name} <br>
Gives the number of words in the variable. This is useful
for later use in a &acirc;$argv[selector]&acirc;. <br>
$0 Substitutes the name of the file from which command input
is being read. An error occurs if the name is not known.
<br>
$number <br>
${number} <br>
Equivalent to &acirc;$argv[number]&acirc;. <br>
$* Equivalent to &acirc;$argv[*]&acirc;.</p>

<p style="margin-top: 1em">The modifiers &acirc;:e&acirc;,
&acirc;:h&acirc;, &acirc;:t&acirc;, &acirc;:r&acirc;,
&acirc;:q&acirc;, and &acirc;:x&acirc; may be applied to the
substitutions above as may &acirc;:gh&acirc;,
&acirc;:gt&acirc;, and &acirc;:gr&acirc;. If braces
&acirc;{&acirc; &acirc;}&acirc; appear in the command form
then <br>
the modifiers must appear within the braces. The current
implementation allows only one &acirc;:&acirc; modifier on
each &acirc;$&acirc; expansion.</p>

<p style="margin-top: 1em">The following substitutions may
not be modified with &acirc;:&acirc; modifiers. <br>
$?name <br>
${?name} <br>
Substitutes the string &acirc;1&acirc; if name is set,
&acirc;0&acirc; if it is not. <br>
$?0 Substitutes &acirc;1&acirc; if the current input
filename is known, &acirc;0&acirc; if it is not. <br>
$$ Substitute the (decimal) process number of the (parent)
shell. Do NOT use this mechanism for generating temporary
file names; see mktemp(1) instead. <br>
$! Substitute the (decimal) process number of the last
background process started by this shell. <br>
$&lt; Substitutes a line from the standard input, with no
further interpretation. It can be used to read from the
keyboard in a shell script.</p>

<p style="margin-top: 1em">Command and filename
substitution <br>
The remaining substitutions, command and filename
substitution, are applied selectively to the arguments of
built-in commands. By selectively, we mean that portions of
expressions <br>
which are not evaluated are not subjected to these
expansions. For commands that are not internal to the shell,
the command name is substituted separately from the argument
list. <br>
This occurs very late, after input-output redirection is
performed, and in a child of the main shell.</p>

<p style="margin-top: 1em">Command substitution <br>
Command substitution is shown by a command enclosed in
&acirc;&lsquo;&acirc;. The output from such a command is
normally broken into separate words at blanks, tabs, and
newlines, with null words <br>
being discarded; this text then replaces the original
string. Within double quotes (&lsquo;&quot;&rsquo;), only
newlines force new words; blanks and tabs are preserved.</p>

<p style="margin-top: 1em">In any case, the single final
newline does not force a new word. Note that it is thus
possible for a command substitution to yield only part of a
word, even if the command outputs <br>
a complete line.</p>

<p style="margin-top: 1em">Filename substitution <br>
If a word contains any of the characters &acirc;*&acirc;,
&acirc;?&acirc;, &acirc;[&acirc;, or &acirc;{&acirc;, or
begins with the character &acirc;~&acirc;, then that word is
a candidate for filename substitution, also known as
&acirc;globbing&acirc;. <br>
This word is then regarded as a pattern, and replaced with
an alphabetically sorted list of file names that match the
pattern. In a list of words specifying filename substitution
<br>
it is an error for no pattern to match an existing file
name, but it is not required for each pattern to match. Only
the metacharacters &acirc;*&acirc;, &acirc;?&acirc;, and
&acirc;[&acirc; imply pattern matching, <br>
the characters &acirc;~&acirc; and &acirc;{&acirc; being
more akin to abbreviations.</p>

<p style="margin-top: 1em">In matching filenames, the
character &acirc;.&acirc; at the beginning of a filename or
immediately following a &acirc;/&acirc;, as well as the
character &acirc;/&acirc; must be matched explicitly. The
character &acirc;*&acirc; <br>
matches any string of characters, including the null string.
The character &acirc;?&acirc; matches any single
character.</p>

<p style="margin-top: 1em">The sequence &acirc;[...]&acirc;
matches any one of the characters enclosed. Within
&acirc;[...]&acirc;, a pair of characters separated by
&acirc;-&acirc; matches any character lexically between the
two (inclusive). <br>
Within &acirc;[...]&acirc;, the name of a character class
enclosed in &acirc;[:&acirc; and &acirc;:]&acirc; stands for
the list of all characters belonging to that class.
Supported character classes:</p>

<p style="margin-top: 1em">alnum cntrl lower space <br>
alpha digit print upper <br>
blank graph punct xdigit</p>

<p style="margin-top: 1em">These match characters using the
macros specified in ctype(3). A character class may not be
used as an endpoint of a range.</p>

<p style="margin-top: 1em">The character &acirc;~&acirc; at
the beginning of a filename refers to home directories.
Standing alone, i.e., &acirc;~&acirc;, it expands to the
invoker&rsquo;s home directory as reflected in the value of
the <br>
variable home. When followed by a name consisting of
letters, digits, and &acirc;-&acirc; characters, the shell
searches for a user with that name and substitutes their
home directory; thus <br>
&acirc;~ken&acirc; might expand to &acirc;/usr/ken&acirc;
and &acirc;~ken/chmach&acirc; to
&acirc;/usr/ken/chmach&acirc;. If the character
&acirc;~&acirc; is followed by a character other than a
letter or &acirc;/&acirc;, or does not appear at the <br>
beginning of a word, it is left undisturbed.</p>

<p style="margin-top: 1em">The metanotation
&acirc;a{b,c,d}e&acirc; is a shorthand for &acirc;abe ace
ade&acirc;. Left to right order is preserved, with results
of matches being sorted separately at a low level to
preserve this <br>
order. This construct may be nested. Thus,
&acirc;~source/s1/{oldls,ls}.c&acirc; expands to
&acirc;/usr/source/s1/oldls.c /usr/source/s1/ls.c&acirc;
without chance of error if the home directory for <br>
&acirc;source&acirc; is &acirc;/usr/source&acirc;. Similarly
&acirc;../{memo,*box}&acirc; might expand to &acirc;../memo
../box ../mbox&acirc;. (Note that &acirc;memo&acirc; was not
sorted with the results of the match to &acirc;*box&acirc;.)
As a <br>
special case &acirc;{&acirc;, &acirc;}&acirc;, and
&acirc;{}&acirc; are passed undisturbed.</p>

<p style="margin-top: 1em">Input/output <br>
The standard input and the standard output of a command may
be redirected with the following syntax:</p>

<p style="margin-top: 1em">&lt; name Open file name (which
is first variable, command, and filename expanded) as the
standard input. <br>
&lt;&lt; word <br>
Read the shell input up to a line that is identical to word.
word is not subjected to variable, command, or filename
substitution, and each input line is compared to <br>
word before any substitutions are done on the input line.
Unless a quoting &acirc;&acirc;, &acirc;&quot;&acirc;,
&acirc;&rsquo;&acirc; or &acirc;&lsquo;&acirc; appears in
word, variable and command substitution is performed on <br>
the intervening lines, allowing &acirc;&acirc; to quote
&acirc;$&acirc;, &acirc;&acirc; and &acirc;&lsquo;&acirc;.
Commands that are substituted have all blanks, tabs, and
newlines preserved, except for the final new&acirc; <br>
line which is dropped. The resultant text is placed in an
anonymous temporary file that is given to the command as its
standard input. <br>
&gt; name <br>
&gt;! name <br>
&gt;&amp; name <br>
&gt;&amp;! name <br>
The file name is used as the standard output. If the file
does not exist then it is created; if the file exists, it is
truncated; its previous contents are lost.</p>

<p style="margin-top: 1em">If the variable noclobber is
set, then the file must not exist or be a character special
file (e.g., a terminal or /dev/null) or an error results.
This helps prevent <br>
accidental destruction of files. Here, the &acirc;!&acirc;
forms can be used to suppress this check.</p>

<p style="margin-top: 1em">The forms involving
&acirc;&amp;&acirc; route the standard error output into the
specified file as well as the standard output. name is
expanded in the same way as &acirc;&lt;&acirc; input
file&acirc; <br>
names are. <br>
&gt;&gt; name <br>
&gt;&gt;&amp; name <br>
&gt;&gt;! name <br>
&gt;&gt;&amp;! name <br>
Uses file name as the standard output; like
&acirc;&gt;&acirc; but places output at the end of the file.
If the variable noclobber is set, then it is an error for
the file not to <br>
exist unless one of the &acirc;!&acirc; forms is given.
Otherwise similar to &acirc;&gt;&acirc;.</p>

<p style="margin-top: 1em">A command receives the
environment in which the shell was invoked as modified by
the input-output parameters and the presence of the command
in a pipeline. Thus, unlike some pre&acirc; <br>
vious shells, commands run from a file of shell commands
have no access to the text of the commands by default;
instead they receive the original standard input of the
shell. The <br>
&acirc;&lt;&lt;&acirc; mechanism should be used to present
inline data. This permits shell command scripts to function
as components of pipelines and allows the shell to block
read its input. Note <br>
that the default standard input for a command run detached
is not modified to be the empty file /dev/null; instead the
standard input remains as the original standard input of the
<br>
shell. If this is a terminal and if the process attempts to
read from the terminal, then the process will block and the
user will be notified (see Jobs above).</p>

<p style="margin-top: 1em">The standard error output may be
directed through a pipe with the standard output. Simply use
the form &acirc;|&amp;&acirc; instead of just
&acirc;|&acirc;.</p>

<p style="margin-top: 1em">Expressions <br>
Several of the built-in commands (to be described later)
take expressions, in which the operators are similar to
those of C, with the same precedence, but with the opposite
<br>
grouping: right to left. These expressions appear in the @,
exit, if, and while commands. The following operators are
available:</p>

<p style="margin-top: 1em">|| &amp;&amp; | &acirc; &amp; ==
!= =~ !~ &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt; + - * / % !
~ ( )</p>

<p style="margin-top: 1em">Here the precedence increases to
the right, &acirc;==&acirc; &acirc;!=&acirc;
&acirc;=~&acirc; and &acirc;!~&acirc;, &acirc;&lt;=&acirc;
&acirc;&gt;=&acirc; &acirc;&lt;&acirc; and
&acirc;&gt;&acirc;, &acirc;&lt;&lt;&acirc; and
&acirc;&gt;&gt;&acirc;, &acirc;+&acirc; and &acirc;-&acirc;,
&acirc;*&acirc; &acirc;/&acirc; and &acirc;%&acirc; being,
in groups, at the same level. The <br>
&acirc;==&acirc; &acirc;!=&acirc; &acirc;=~&acirc; and
&acirc;!~&acirc; operators compare their arguments as
strings; all others operate on numbers. The operators
&acirc;=~&acirc; and &acirc;!~&acirc; are like
&acirc;!=&acirc; and &acirc;==&acirc; except that the right
hand <br>
side is a pattern (containing, e.g., *&rsquo;s, ?&rsquo;s,
and instances of &acirc;[...]&acirc;) against which the
left-hand operand is matched. This reduces the need for use
of the switch statement in <br>
shell scripts when all that is really needed is pattern
matching.</p>

<p style="margin-top: 1em">Strings that begin with
&acirc;0&acirc; are considered octal numbers. Null or
missing arguments are considered &acirc;0&acirc;. The
results of all expressions are strings, which represent
decimal num&acirc; <br>
bers. It is important to note that no two components of an
expression can appear in the same word; except when adjacent
to components of expressions that are syntactically
signif&acirc; <br>
icant to the parser (&acirc;&amp;&acirc;, &acirc;|&acirc;,
&acirc;&lt;&acirc;, &acirc;&gt;&acirc;, &acirc;(&acirc;, and
&acirc;)&acirc;), they should be surrounded by spaces.</p>

<p style="margin-top: 1em">Also available in expressions as
primitive operands are command executions enclosed in
&acirc;{&acirc; and &acirc;}&acirc; and file enquiries of
the form -l name where l is one of:</p>

<p style="margin-top: 1em">r read access <br>
w write access <br>
x execute access <br>
e existence <br>
o ownership <br>
z zero size <br>
f plain file <br>
d directory</p>

<p style="margin-top: 1em">The specified name is command
and filename expanded and then tested to see if it has the
specified relationship to the real user. If the file does
not exist or is inaccessible <br>
then all enquiries return false, i.e., &acirc;0&acirc;.
Command executions succeed, returning true, i.e.,
&acirc;1&acirc;, if the command exits with status 0,
otherwise they fail, returning false, i.e., <br>
&acirc;0&acirc;. If more detailed status information is
required then the command should be executed outside an
expression and the variable status examined.</p>

<p style="margin-top: 1em">Control flow <br>
The shell contains several commands that can be used to
regulate the flow of control in command files (shell
scripts) and (in limited but useful ways) from terminal
input. These <br>
commands all operate by forcing the shell to reread or skip
in its input and, because of the implementation, restrict
the placement of some of the commands.</p>

<p style="margin-top: 1em">The foreach, switch, and while
statements, as well as the if-then-else form of the if
statement require that the major keywords appear in a single
simple command on an input line <br>
as shown below.</p>

<p style="margin-top: 1em">If the shell&rsquo;s input is
not seekable, the shell buffers up input whenever a loop is
being read and performs seeks in this internal buffer to
accomplish the rereading implied by the <br>
loop. (To the extent that this allows, backward goto&rsquo;s
will succeed on non-seekable inputs.)</p>

<p style="margin-top: 1em">Built-in commands <br>
Built-in commands are executed within the shell. If a
built-in command occurs as any component of a pipeline
except the last then it is executed in a sub-shell.</p>

<p style="margin-top: 1em">alias <br>
alias name <br>
alias name wordlist <br>
The first form prints all aliases. The second form prints
the alias for name. The final form assigns the specified
wordlist as the alias of name; wordlist is com&acirc; <br>
mand and filename substituted. name is not allowed to be
&acirc;alias&acirc; or &acirc;unalias&acirc;.</p>

<p style="margin-top: 1em">alloc Shows the amount of
dynamic memory acquired, broken down into used and free
memory. With an argument shows the number of free and used
blocks in each size category. <br>
The categories start at size 8 and double at each step. This
command&rsquo;s output may vary across system types, since
systems other than the VAX may use a different mem&acirc;
<br>
ory allocator.</p>

<p style="margin-top: 1em">bg <br>
bg %job ... <br>
Puts the current or specified jobs into the background,
continuing them if they were stopped.</p>

<p style="margin-top: 1em">break Causes execution to resume
after the end of the nearest enclosing foreach or while. The
remaining commands on the current line are executed.
Multi-level breaks are <br>
thus possible by writing them all on one line.</p>

<p style="margin-top: 1em">breaksw <br>
Causes a break from a switch, resuming after the endsw.</p>

<p style="margin-top: 1em">case label: <br>
A label in a switch statement as discussed below.</p>

<p style="margin-top: 1em">cd <br>
cd name <br>
chdir <br>
chdir name <br>
Change the shell&rsquo;s working directory to directory
name. If no argument is given then change to the home
directory of the user. If name is not found as a
subdirec&acirc; <br>
tory of the current directory (and does not begin with
&acirc;/&acirc;, &acirc;./&acirc; or &acirc;../&acirc;),
then each component of the variable cdpath is checked to see
if it has a subdirectory <br>
name. Finally, if all else fails but name is a shell
variable whose value begins with &acirc;/&acirc;, then this
is tried to see if it is a directory.</p>

<p style="margin-top: 1em">continue <br>
Continue execution of the nearest enclosing while or
foreach. The rest of the commands on the current line are
executed.</p>

<p style="margin-top: 1em">default: <br>
Labels the default case in a switch statement. The default
should come after all case labels.</p>

<p style="margin-top: 1em">dirs Prints the directory stack;
the top of the stack is at the left, the first directory in
the stack being the current directory.</p>

<p style="margin-top: 1em">echo wordlist <br>
echo -n wordlist <br>
The specified words are written to the shell&rsquo;s
standard output, separated by spaces, and terminated with a
newline unless the -n option is specified.</p>

<p style="margin-top: 1em">else <br>
end <br>
endif <br>
endsw See the description of the foreach, if, switch, and
while statements below.</p>

<p style="margin-top: 1em">eval arg ... <br>
(As in sh(1).) The arguments are read as input to the shell
and the resulting command(s) executed in the context of the
current shell. This is usually used to exe&acirc; <br>
cute commands generated as the result of command or variable
substitution, since parsing occurs before these
substitutions. See tset(1) for an example of using eval.</p>

<p style="margin-top: 1em">exec command <br>
The specified command is executed in place of the current
shell.</p>

<p style="margin-top: 1em">exit <br>
exit (expr) <br>
The shell exits either with the value of the status variable
(first form) or with the value of the specified expr (second
form).</p>

<p style="margin-top: 1em">fg <br>
fg %job ... <br>
Brings the current or specified jobs into the foreground,
continuing them if they were stopped.</p>

<p style="margin-top: 1em">foreach name (wordlist) <br>
... <br>
end The variable name is successively set to each member of
wordlist and the sequence of commands between this command
and the matching end are executed. (Both foreach <br>
and end must appear alone on separate lines.) The built-in
command continue may be used to continue the loop
prematurely and the built-in command break to terminate <br>
it prematurely. When this command is read from the terminal,
the loop is read once prompting with &acirc;?&acirc; before
any statements in the loop are executed. If you make a <br>
mistake typing in a loop at the terminal you can rub it
out.</p>

<p style="margin-top: 1em">glob wordlist <br>
Like echo but no &acirc;&acirc; escapes are recognized and
words are delimited by NUL characters in the output. Useful
for programs that wish to use the shell to filename <br>
expand a list of words.</p>

<p style="margin-top: 1em">goto word <br>
The specified word is filename and command expanded to yield
a string of the form &acirc;label&acirc;. The shell rewinds
its input as much as possible and searches for a line of
<br>
the form &acirc;label:&acirc;, possibly preceded by blanks
or tabs. Execution continues after the specified line.</p>

<p style="margin-top: 1em">hashstat <br>
Print a statistics line showing how effective the internal
hash table has been at locating commands (and avoiding
exec&Acirc;&acute;s). An exec is attempted for each
component of <br>
the path where the hash function indicates a possible hit,
and in each component that does not begin with a
&acirc;/&acirc;.</p>

<p style="margin-top: 1em">history <br>
history n <br>
history -h n <br>
history -r n <br>
Displays the history event list; if n is given, only the n
most recent events are printed. The -h option causes the
history list to be printed without leading num&acirc; <br>
bers. This format produces files suitable for sourcing using
the -h option to source. The -r option reverses the order of
printout to be most recent first instead <br>
of oldest first.</p>

<p style="margin-top: 1em">if (expr) command <br>
If the specified expression evaluates to true, then the
single command with arguments is executed. Variable
substitution on command happens early, at the same time <br>
it does for the rest of the if command. command must be a
simple command, not a pipeline, a command list, or a
parenthesized command list. Input/output redirection <br>
occurs even if expr is false, i.e., when command is not
executed (this is a bug).</p>

<p style="margin-top: 1em">if (expr) then <br>
... <br>
else if (expr2) then <br>
... <br>
else <br>
... <br>
endif If the specified expr is true then the commands up to
the first else are executed; otherwise if expr2 is true then
the commands up to the second else are executed, <br>
etc. Any number of else-if pairs are possible; only one
endif is needed. The else part is likewise optional. (The
words else and endif must appear at the beginning <br>
of input lines; the if must appear alone on its input line
or after an else.)</p>

<p style="margin-top: 1em">jobs <br>
jobs -l <br>
Lists the active jobs; the -l option lists process IDs in
addition to the normal information.</p>

<p style="margin-top: 1em">kill %job <br>
kill [-s signal_name] pid <br>
kill -sig pid ... <br>
kill -l [exit_status] <br>
Sends either the SIGTERM (terminate) signal or the specified
signal to the specified jobs or processes. Signals are
either given by number or by names (as given in <br>
&acirc;&uml;signal.h&acirc;&copy;, stripped of the prefix
&acirc;SIG&acirc;). The signal names are listed by
&acirc;kill -l&acirc;; if an exit_status is specified, only
the corresponding signal name will be writ&acirc; <br>
ten. There is no default; just saying &acirc;kill&acirc;
does not send a signal to the current job. If the signal
being sent is SIGTERM (terminate) or SIGHUP (hangup), then
the <br>
job or process will be sent a SIGCONT (continue) signal as
well.</p>

<p style="margin-top: 1em">limit <br>
limit resource <br>
limit resource maximum-use <br>
limit -h <br>
limit -h resource <br>
limit -h resource maximum-use <br>
Limits the consumption by the current process and each
process it creates to not individually exceed maximum-use on
the specified resource. If no maximum-use is <br>
given, then the current limit is printed; if no resource is
given, then all limitations are given. If the -h flag is
given, the hard limits are used instead of the <br>
current limits. The hard limits impose a ceiling on the
values of the current limits. Only the superuser may raise
the hard limits, but a user may lower or raise <br>
the current limits within the legal range.</p>

<p style="margin-top: 1em">Resources controllable currently
include:</p>

<p style="margin-top: 1em">cputime the maximum number of
CPU-seconds to be used by each process.</p>

<p style="margin-top: 1em">filesize the largest single file
(in bytes) that can be created.</p>

<p style="margin-top: 1em">datasize the maximum growth of
the data+stack region via sbrk(2) beyond the end of the
program text.</p>

<p style="margin-top: 1em">stacksize the maximum size of
the automatically-extended stack region.</p>

<p style="margin-top: 1em">coredumpsize the size of the
largest core dump (in bytes) that will be created.</p>

<p style="margin-top: 1em">memoryuse the maximum size (in
bytes) to which a process&rsquo;s resident set size (RSS)
may grow.</p>

<p style="margin-top: 1em">memorylocked The maximum size
(in bytes) which a process may lock into memory using the
mlock(2) function.</p>

<p style="margin-top: 1em">maxproc The maximum number of
simultaneous processes for this user ID.</p>

<p style="margin-top: 1em">openfiles The maximum number of
simultaneous open files for this user ID.</p>

<p style="margin-top: 1em">vmemoryuse the maximum size (in
bytes) to which a process&rsquo;s total size may grow.</p>

<p style="margin-top: 1em">The maximum-use may be given as
a (floating point or integer) number followed by a scale
factor. For all limits other than cputime the default scale
is &acirc;k&acirc; or <br>
&acirc;kilobytes&acirc; (1024 bytes); a scale factor of
&acirc;m&acirc; or &acirc;megabytes&acirc; may also be used.
For cputime the default scale is &acirc;seconds&acirc;; a
scale factor of &acirc;m&acirc; for minutes or
&acirc;h&acirc; <br>
for hours, or a time of the form &acirc;mm:ss&acirc; giving
minutes and seconds also may be used.</p>

<p style="margin-top: 1em">For both resource names and
scale factors, unambiguous prefixes of the names
suffice.</p>

<p style="margin-top: 1em">login Terminate a login shell,
replacing it with an instance of /usr/bin/login. This is one
way to log off, included for compatibility with sh(1).</p>

<p style="margin-top: 1em">logout Terminate a login shell.
Especially useful if ignoreeof is set.</p>

<p style="margin-top: 1em">nice <br>
nice +number <br>
nice command <br>
nice +number command <br>
The first form sets the scheduling priority for this shell
to 4. The second form sets the priority to the given number.
The final two forms run command at priority <br>
4 and number respectively. The greater the number, the less
CPU the process will get. The superuser may specify negative
priority by using &acirc;nice -number ...&acirc;. <br>
command is always executed in a sub-shell, and the
restrictions placed on commands in simple if statements
apply.</p>

<p style="margin-top: 1em">nohup <br>
nohup command <br>
The first form can be used in shell scripts to cause hangups
to be ignored for the remainder of the script. The second
form causes the specified command to be run <br>
with hangups ignored. All processes detached with
&acirc;&amp;&acirc; are effectively
nohup&Acirc;&acute;ed.</p>

<p style="margin-top: 1em">notify <br>
notify %job ... <br>
Causes the shell to notify the user asynchronously when the
status of the current or specified jobs change; normally
notification is presented before a prompt. This <br>
is automatic if the shell variable notify is set.</p>

<p style="margin-top: 1em">onintr <br>
onintr - <br>
onintr label <br>
Control the action of the shell on interrupts. The first
form restores the default action of the shell on interrupts,
which is to terminate shell scripts or to <br>
return to the terminal command input level. The second form
onintr - causes all interrupts to be ignored. The final form
causes the shell to execute a goto label <br>
when an interrupt is received or a child process terminates
because it was interrupted.</p>

<p style="margin-top: 1em">In any case, if the shell is
running detached and interrupts are being ignored, all forms
of onintr have no meaning and interrupts continue to be
ignored by the shell <br>
and all invoked commands. Finally, onintr statements are
ignored in the system startup files where interrupts are
disabled (/etc/csh.cshrc, /etc/csh.login).</p>

<p style="margin-top: 1em">popd <br>
popd +n <br>
Pops the directory stack, returning to the new top
directory. With an argument &acirc;+n&acirc; discards the
n&Acirc;&acute;th entry in the stack. The members of the
directory stack are <br>
numbered from the top starting at 0.</p>

<p style="margin-top: 1em">pushd <br>
pushd name <br>
pushd +n <br>
With no arguments, pushd exchanges the top two elements of
the directory stack. Given a name argument, pushd changes to
the new directory (ala cd) and pushes the old <br>
current working directory (as in cwd) onto the directory
stack. With a numeric argument, pushd rotates the
n&Acirc;&acute;th argument of the directory stack around to
be the top <br>
element and changes to it. The members of the directory
stack are numbered from the top starting at 0.</p>

<p style="margin-top: 1em">rehash Causes the internal hash
table of the contents of the directories in the path
variable to be recomputed. This is needed if new commands
are added to directories in <br>
the path while you are logged in. This should only be
necessary if you add commands to one of your own
directories, or if a systems programmer changes the contents
<br>
of a system directory.</p>

<p style="margin-top: 1em">repeat count command <br>
The specified command, which is subject to the same
restrictions as the command in the one line if statement
above, is executed count times. I/O redirections occur <br>
exactly once, even if count is 0.</p>

<p style="margin-top: 1em">set <br>
set name <br>
set name=word <br>
set name[index]=word <br>
set name=(wordlist) <br>
The first form of the command shows the value of all shell
variables. Variables that have other than a single word as
their value print as a parenthesized word list. <br>
The second form sets name to the null string. The third form
sets name to the single word. The fourth form sets the
index&rsquo;th component of name to word; this compo&acirc;
<br>
nent must already exist. The final form sets name to the
list of words in wordlist. The value is always command and
filename expanded.</p>

<p style="margin-top: 1em">These arguments may be repeated
to set multiple values in a single set command. Note
however, that variable expansion happens for all arguments
before any setting <br>
occurs.</p>

<p style="margin-top: 1em">setenv <br>
setenv name <br>
setenv name value <br>
The first form lists all current environment variables. It
is equivalent to printenv(1). The last form sets the value
of environment variable name to be value, a <br>
single string. The second form sets name to an empty string.
The most commonly used environment variables USER, TERM, and
PATH are automatically imported to and <br>
exported from the csh variables user, term, and path; there
is no need to use setenv for these.</p>

<p style="margin-top: 1em">shift <br>
shift variable <br>
The members of argv are shifted to the left, discarding
argv[1]. It is an error for argv not to be set or to have
less than one word as value. The second form per&acirc; <br>
forms the same function on the specified variable.</p>

<p style="margin-top: 1em">source name <br>
source -h name <br>
The shell reads commands from name. source commands may be
nested; if they are nested too deeply the shell may run out
of file descriptors. An error in a source at <br>
any level terminates all nested source commands. Normally
input during source commands is not placed on the history
list; the -h option causes the commands to be <br>
placed on the history list without being executed.</p>

<p style="margin-top: 1em">stop <br>
stop %job ... <br>
Stops the current or specified jobs that are executing in
the background.</p>

<p style="margin-top: 1em">suspend <br>
Causes the shell to stop in its tracks, much as if it had
been sent a stop signal with ^Z. This is most often used to
stop shells started by su(1).</p>

<p style="margin-top: 1em">switch (string) <br>
case str1: <br>
... <br>
breaksw <br>
... <br>
default: <br>
... <br>
breaksw <br>
endsw Each case label is successively matched against the
specified string, which is first command and filename
expanded. The file metacharacters &acirc;*&acirc;,
&acirc;?&acirc; and &acirc;[...]&acirc; may <br>
be used in the case labels, which are variable expanded. If
none of the labels match before the &acirc;default&acirc;
label is found, then the execution begins after the default
<br>
label. Each case label and the default label must appear at
the beginning of a line. The command breaksw causes
execution to continue after the endsw. Otherwise <br>
control may fall through case labels and the default label
as in C. If no label matches and there is no default,
execution continues after the endsw.</p>

<p style="margin-top: 1em">time <br>
time command <br>
With no argument, a summary of time used by this shell and
its children is printed. If arguments are given the
specified simple command is timed and a time summary <br>
as described under the time variable is printed. If
necessary, an extra shell is created to print the time
statistic when the command completes.</p>

<p style="margin-top: 1em">umask <br>
umask value <br>
The file creation mask is displayed (first form) or set to
the specified value (second form). The mask is given in
octal. Common values for the mask are 002 giving <br>
all access to the group and read and execute access to
others or 022 giving all access except write access for
users in the group or others.</p>

<p style="margin-top: 1em">unalias pattern <br>
All aliases whose names match the specified pattern are
discarded. Thus all aliases are removed by unalias *. It is
not an error for nothing to be unaliased.</p>

<p style="margin-top: 1em">unhash Use of the internal hash
table to speed location of executed programs is
disabled.</p>

<p style="margin-top: 1em">unlimit <br>
unlimit resource <br>
unlimit -h <br>
unlimit -h resource <br>
Removes the limitation on resource. If no resource is
specified, then all resource limitations are removed. If -h
is given, the corresponding hard limits are <br>
removed. Only the superuser may do this.</p>

<p style="margin-top: 1em">unset pattern <br>
All variables whose names match the specified pattern are
removed. Thus all variables are removed by unset *; this has
noticeably distasteful side-effects. It is <br>
not an error for nothing to be unset.</p>

<p style="margin-top: 1em">unsetenv pattern <br>
Removes all variables whose names match the specified
pattern from the environment. See also the setenv command
above and printenv(1).</p>

<p style="margin-top: 1em">wait Wait for all background
jobs. If the shell is interactive, then an interrupt can
disrupt the wait. After the interrupt, the shell prints
names and job numbers of <br>
all jobs known to be outstanding.</p>

<p style="margin-top: 1em">which command <br>
Displays the resolved command that will be executed by the
shell.</p>

<p style="margin-top: 1em">while (expr) <br>
... <br>
end While the specified expression evaluates to non-zero,
the commands between the while and the matching end are
evaluated. break and continue may be used to terminate <br>
or continue the loop prematurely. (The while and end must
appear alone on their input lines.) Prompting occurs here
the first time through the loop as for the <br>
foreach statement if the input is a terminal.</p>

<p style="margin-top: 1em">%job Brings the specified job
into the foreground.</p>

<p style="margin-top: 1em">%job &amp; Continues the
specified job in the background.</p>

<p style="margin-top: 1em">@ <br>
@ name= expr <br>
@ name[index]= expr <br>
The first form prints the values of all the shell variables.
The second form sets the specified name to the value of
expr. If the expression contains &acirc;&lt;&acirc;,
&acirc;&gt;&acirc;, &acirc;&amp;&acirc; <br>
or &acirc;|&acirc; then at least this part of the expression
must be placed within &acirc;(&acirc; &acirc;)&acirc;. The
third form assigns the value of expr to the index&rsquo;th
argument of name. Both name <br>
and its index&rsquo;th component must already exist.</p>

<p style="margin-top: 1em">The operators &acirc;*=&acirc;,
&acirc;+=&acirc;, etc. are available as in C. The space
separating the name from the assignment operator is
optional. Spaces are, however, mandatory in sep&acirc; <br>
arating components of expr, which would otherwise be single
words.</p>

<p style="margin-top: 1em">Special postfix &acirc;++&acirc;
and &acirc;--&acirc; operators increment and decrement name
respectively; i.e., &acirc;@ i++&acirc;.</p>

<p style="margin-top: 1em">Pre-defined and environment
variables <br>
The following variables have special meaning to the shell.
Of these, argv, cwd, home, path, prompt, shell and status
are always set by the shell. Except for cwd and status, this
<br>
setting occurs only at initialization; these variables will
not then be modified unless done explicitly by the user.</p>

<p style="margin-top: 1em">The shell copies the environment
variable USER into the variable user, TERM into term, and
HOME into home, and copies these back into the environment
whenever the normal shell <br>
variables are reset. The environment variable PATH is
likewise handled; it is not necessary to worry about its
setting other than in the file .cshrc as inferior csh
processes will <br>
import the definition of path from the environment, and
re-export it if you then change it.</p>

<p style="margin-top: 1em">argv Set to the arguments to the
shell, it is from this variable that positional parameters
are substituted; i.e., &acirc;$1&acirc; is replaced by
&acirc;$argv[1]&acirc;, etc.</p>

<p style="margin-top: 1em">cdpath Gives a list of alternate
directories searched to find subdirectories in chdir
commands.</p>

<p style="margin-top: 1em">cwd The full pathname of the
current directory.</p>

<p style="margin-top: 1em">echo Set when the -x
command-line option is given. Causes each command and its
arguments to be echoed just before it is executed. For
non-built-in commands all expansions <br>
occur before echoing. Built-in commands are echoed before
command and filename substitution, since these substitutions
are then done selectively.</p>

<p style="margin-top: 1em">filec Enable file name
completion.</p>

<p style="margin-top: 1em">histchars Can be given a string
value to change the characters used in history substitution.
The first character of its value is used as the history
substitution character, <br>
replacing the default character &acirc;!&acirc;. The second
character of its value replaces the character
&acirc;^&acirc; in quick substitutions.</p>

<p style="margin-top: 1em">histfile Can be set to the
pathname where history is going to be saved/restored.</p>

<p style="margin-top: 1em">history Can be given a numeric
value to control the size of the history list. Any command
that has been referenced in this many events will not be
discarded. Too large values <br>
of history may run the shell out of memory. The last
executed command is always saved on the history list.</p>

<p style="margin-top: 1em">home The home directory of the
invoker, initialized from the environment. The filename
expansion of &acirc;~&acirc; refers to this variable.</p>

<p style="margin-top: 1em">ignoreeof If set the shell
ignores end-of-file from input devices which are terminals.
This prevents shells from accidentally being killed by
control-Ds.</p>

<p style="margin-top: 1em">mail The files where the shell
checks for mail. This checking is done after each command
completion that will result in a prompt, if a specified
interval has elapsed. The <br>
shell says &acirc;You have new mail.&acirc; if the file
exists with an access time not greater than its modify
time.</p>

<p style="margin-top: 1em">If the first word of the value
of mail is numeric it specifies a different mail checking
interval, in seconds, than the default, which is 10
minutes.</p>

<p style="margin-top: 1em">If multiple mail files are
specified, then the shell says &acirc;New mail in
name&acirc; when there is mail in the file name.</p>

<p style="margin-top: 1em">noclobber As described in the
section on Input/output, restrictions are placed on output
redirection to ensure that files are not accidentally
destroyed, and that &acirc;&gt;&gt;&acirc; redirec&acirc;
<br>
tions refer to existing files.</p>

<p style="margin-top: 1em">noglob If set, filename
expansion is inhibited. This inhibition is most useful in
shell scripts that are not dealing with filenames, or after
a list of filenames has been <br>
obtained and further expansions are not desirable.</p>

<p style="margin-top: 1em">nonomatch If set, it is not an
error for a filename expansion to not match any existing
files; instead the primitive pattern is returned. It is
still an error for the primitive <br>
pattern to be malformed; i.e., &acirc;echo [&acirc; still
gives an error.</p>

<p style="margin-top: 1em">notify If set, the shell
notifies asynchronously of job completions; the default is
to present job completions just before printing a
prompt.</p>

<p style="margin-top: 1em">path Each word of the path
variable specifies a directory in which commands are to be
sought for execution. A null word specifies the current
directory. If there is no path <br>
variable then only full path names will execute. The usual
search path is &acirc;.&acirc;, &acirc;/bin&acirc;,
&acirc;/usr/bin&acirc;, &acirc;/sbin&acirc; and
&acirc;/usr/sbin&acirc;, but this may vary from system to
system. <br>
For the superuser the default search path is
&acirc;/bin&acirc;, &acirc;/usr/bin&acirc;,
&acirc;/sbin&acirc;, and &acirc;/usr/sbin&acirc;. A shell
that is given neither the -c nor the -t option will normally
hash the <br>
contents of the directories in the path variable after
reading .cshrc, and each time the path variable is reset. If
new commands are added to these directories while <br>
the shell is active, it may be necessary to do a rehash or
the commands may not be found.</p>

<p style="margin-top: 1em">prompt The string that is
printed before each command is read from an interactive
terminal input. If a &acirc;!&acirc; appears in the string
it will be replaced by the current event num&acirc; <br>
ber unless a preceding &acirc;&acirc; is given. Default is
&acirc;%&acirc;, or &acirc;#&acirc; for the superuser.</p>

<p style="margin-top: 1em">savehist Is given a numeric
value to control the number of entries of the history list
that are saved in ~/.history when the user logs out. Any
command that has been referenced <br>
in this many events will be saved. During start up the shell
sources ~/.history into the history list enabling history to
be saved across logins. Too large values of <br>
savehist will slow down the shell during start up. If
savehist is just set, the shell will use the value of
history.</p>

<p style="margin-top: 1em">shell The file in which the
shell resides. This variable is used in forking shells to
interpret files that have execute bits set, but which are
not executable by the system. <br>
(See the description of Non-built-in command execution
below.) Initialized to the (system-dependent) home of the
shell.</p>

<p style="margin-top: 1em">status The status returned by
the last command. If it terminated abnormally, then 0200 is
added to the status. Built-in commands that fail return exit
status 1, all other <br>
built-in commands set status to 0.</p>

<p style="margin-top: 1em">time Controls automatic timing
of commands. If set, then any command that takes more than
this many CPU seconds will cause a line giving user, system,
and real times, and a <br>
utilization percentage which is the ratio of user plus
system times to real time to be printed when it
terminates.</p>

<p style="margin-top: 1em">verbose Set by the -v
command-line option, causes the words of each command to be
printed after history substitution.</p>

<p style="margin-top: 1em">Non-built-in command execution
<br>
When a command to be executed is found to not be a built-in
command the shell attempts to execute the command via
execve(2). Each word in the variable path names a directory
from <br>
which the shell will attempt to execute the command. If it
is given neither a -c nor a -t option, the shell will hash
the names in these directories into an internal table so
that <br>
it will only try an exec in a directory if there is a
possibility that the command resides there. This shortcut
greatly speeds command location when many directories are
present <br>
in the search path. If this mechanism has been turned off
(via unhash), or if the shell was given a -c or -t argument,
and in any case for each directory component of path that
<br>
does not begin with a &acirc;/&acirc;, the shell
concatenates with the given command name to form a path name
of a file which it then attempts to execute.</p>

<p style="margin-top: 1em">Parenthesized commands are
always executed in a sub-shell. Thus</p>

<p style="margin-top: 1em">(cd; pwd); pwd</p>

<p style="margin-top: 1em">prints the home directory;
leaving you where you were (printing this after the home
directory), while</p>

<p style="margin-top: 1em">cd; pwd</p>

<p style="margin-top: 1em">leaves you in the home
directory. Parenthesized commands are most often used to
prevent chdir from affecting the current shell.</p>

<p style="margin-top: 1em">If the file has execute
permissions but is not an executable binary to the system,
then it is assumed to be a file containing shell commands
and a new shell is spawned to read it.</p>

<p style="margin-top: 1em">If there is an alias for shell
then the words of the alias will be prepended to the
argument list to form the shell command. The first word of
the alias should be the full path <br>
name of the shell (e.g., &acirc;$shell&acirc;). Note that
this is a special, late occurring, case of alias
substitution, and only allows words to be prepended to the
argument list without <br>
change.</p>

<p style="margin-top: 1em">Signal handling <br>
The shell normally ignores SIGQUIT signals. Jobs running
detached (either by &amp; or the bg or %... &amp; commands)
are immune to signals generated from the keyboard, including
hangups. <br>
Other signals have the values which the shell inherited from
its parent. The shell&rsquo;s handling of interrupts and
terminate signals in shell scripts can be controlled by
onintr. <br>
Login shells catch the SIGTERM (terminate) signal; otherwise
this signal is passed on to children from the state in the
shell&rsquo;s parent. Interrupts are not allowed when a
login <br>
shell is reading the file .logout.</p>

<p style="margin-top: 1em">LIMITATIONS <br>
Word lengths - Words can be no longer than 1024 characters.
The number of arguments to a command that involves filename
expansion is limited to 1/6th the number of characters <br>
allowed in an argument list. Command substitutions may
substitute no more characters than are allowed in an
argument list. To detect looping, the shell restricts the
number of <br>
alias substitutions on a single line to 20.</p>

<p style="margin-top: 1em">FILES <br>
~/.cshrc read at beginning of execution by each shell <br>
~/.login read by login shell, after .cshrc at login <br>
~/.logout read by login shell, at logout <br>
/bin/sh standard shell, for shell scripts not starting with
a &acirc;#&acirc; <br>
/tmp/sh.* temporary file for &acirc;&lt;&lt;&acirc; <br>
/etc/passwd source of home directories for
&acirc;~name&acirc;</p>

<p style="margin-top: 1em">SEE ALSO <br>
sh(1), access(2), execve(2), fork(2), pipe(2), setrlimit(2),
umask(2), wait(2), killpg(3), sigvec(3), tty(4), a.out(5),
environ(7), script(7)</p>

<p style="margin-top: 1em">HISTORY <br>
csh appeared in 3BSD. It was a first implementation of a
command language interpreter incorporating a history
mechanism (see History substitutions), job control
facilities (see <br>
Jobs), interactive file name and user name completion (see
File name completion), and a C-like syntax. There are now
many shells that also have these mechanisms, plus a few more
<br>
(and maybe some bugs too), which are available through the
usenet.</p>

<p style="margin-top: 1em">AUTHORS <br>
William Joy. Job control and directory stack features first
implemented by J.E. Kulp of IIASA, Laxenburg, Austria, with
different syntax than that used now. File name completion
<br>
code written by Ken Greer, HP Labs. Eight-bit implementation
Christos S. Zoulas, Cornell University.</p>

<p style="margin-top: 1em">BUGS <br>
When a command is restarted from a stop, the shell prints
the directory it started in if this is different from the
current directory; this can be misleading (i.e., wrong) as
the <br>
job may have changed directories internally.</p>

<p style="margin-top: 1em">Shell built-in functions are not
stoppable/restartable. Command sequences of the form
&acirc;a ; b ; c&acirc; are also not handled gracefully when
stopping is attempted. If you suspend &acirc;b&acirc;, <br>
the shell will immediately execute &acirc;c&acirc;. This is
especially noticeable if this expansion results from an
alias. It suffices to place the sequence of commands in
()&rsquo;s to force it <br>
to a sub-shell; i.e., &acirc;(a ; b ; c)&acirc;.</p>

<p style="margin-top: 1em">Control over tty output after
processes are started is primitive; perhaps this will
inspire someone to work on a good virtual terminal
interface. In a virtual terminal interface <br>
much more interesting things could be done with output
control.</p>

<p style="margin-top: 1em">Alias substitution is most often
used to clumsily simulate shell procedures; shell procedures
should be provided instead of aliases.</p>

<p style="margin-top: 1em">Commands within loops, prompted
for by &acirc;?&acirc;, are not placed on the history list.
Control structure should be parsed instead of being
recognized as built-in commands. This would <br>
allow control commands to be placed anywhere, to be combined
with &acirc;|&acirc;, and to be used with
&acirc;&amp;&acirc; and &acirc;;&acirc; metasyntax.</p>

<p style="margin-top: 1em">It should be possible to use the
&acirc;:&acirc; modifiers on the output of command
substitutions.</p>

<p style="margin-top: 1em">The way the filec facility is
implemented is ugly and expensive.</p>

<p style="margin-top: 1em">BSD May 2, 2011 BSD</p>
<hr>
</body>
</html>
