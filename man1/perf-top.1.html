<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:31 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERF-TOP(1) perf Manual PERF-TOP(1)</p>

<p style="margin-top: 1em">NAME <br>
perf-top - System profiling tool.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
perf top [-e &lt;EVENT&gt; | --event=EVENT]
[&lt;options&gt;]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This command generates and displays a performance counter
profile in real time.</p>

<p style="margin-top: 1em">OPTIONS <br>
-a, --all-cpus <br>
System-wide collection. (default)</p>

<p style="margin-top: 1em">-c &lt;count&gt;,
--count=&lt;count&gt; <br>
Event period to sample.</p>

<p style="margin-top: 1em">-C &lt;cpu-list&gt;,
--cpu=&lt;cpu&gt; <br>
Monitor only on the list of CPUs provided. Multiple CPUs can
be provided as a comma-separated list with no space: 0,1.
Ranges of CPUs are specified with -: 0-2. Default is to <br>
monitor all CPUS.</p>

<p style="margin-top: 1em">-d &lt;seconds&gt;,
--delay=&lt;seconds&gt; <br>
Number of seconds to delay between refreshes.</p>

<p style="margin-top: 1em">-e &lt;event&gt;,
--event=&lt;event&gt; <br>
Select the PMU event. Selection can be a symbolic event name
(use perf list to list all events) or a raw PMU event
(eventsel+umask) in the form of rNNN where NNN is a <br>
hexadecimal event descriptor.</p>

<p style="margin-top: 1em">-E &lt;entries&gt;,
--entries=&lt;entries&gt; <br>
Display this many functions.</p>

<p style="margin-top: 1em">-f &lt;count&gt;,
--count-filter=&lt;count&gt; <br>
Only display functions with more events than this.</p>

<p style="margin-top: 1em">--group <br>
Put the counters into a counter group.</p>

<p style="margin-top: 1em">-F &lt;freq&gt;,
--freq=&lt;freq&gt; <br>
Profile at this frequency.</p>

<p style="margin-top: 1em">-i, --inherit <br>
Child tasks do not inherit counters.</p>

<p style="margin-top: 1em">-k &lt;path&gt;,
--vmlinux=&lt;path&gt; <br>
Path to vmlinux. Required for annotation functionality.</p>

<p style="margin-top: 1em">-m &lt;pages&gt;,
--mmap-pages=&lt;pages&gt; <br>
Number of mmap data pages (must be a power of two) or size
specification with appended unit character - B/K/M/G. The
size is rounded up to have nearest pages power of two <br>
value.</p>

<p style="margin-top: 1em">-p &lt;pid&gt;,
--pid=&lt;pid&gt; <br>
Profile events on existing Process ID (comma separated
list).</p>

<p style="margin-top: 1em">-t &lt;tid&gt;,
--tid=&lt;tid&gt; <br>
Profile events on existing thread ID (comma separated
list).</p>

<p style="margin-top: 1em">-u, --uid= <br>
Record events in threads owned by uid. Name or number.</p>

<p style="margin-top: 1em">-r &lt;priority&gt;,
--realtime=&lt;priority&gt; <br>
Collect data with this RT SCHED_FIFO priority.</p>

<p style="margin-top: 1em">--sym-annotate=&lt;symbol&gt;
<br>
Annotate this symbol.</p>

<p style="margin-top: 1em">-K, --hide_kernel_symbols <br>
Hide kernel symbols.</p>

<p style="margin-top: 1em">-U, --hide_user_symbols <br>
Hide user symbols.</p>

<p style="margin-top: 1em">--demangle-kernel <br>
Demangle kernel symbols.</p>

<p style="margin-top: 1em">-D, --dump-symtab <br>
Dump the symbol table used for profiling.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Be more verbose (show counter open errors, etc).</p>

<p style="margin-top: 1em">-z, --zero <br>
Zero history across display updates.</p>

<p style="margin-top: 1em">-s, --sort <br>
Sort by key(s): pid, comm, dso, symbol, parent, srcline,
weight, local_weight, abort, in_tx, transaction, overhead,
sample, period. Please see description of --sort in the <br>
perf-report man page.</p>

<p style="margin-top: 1em">--fields= <br>
Specify output field - multiple keys can be specified in CSV
format. Following fields are available: overhead,
overhead_sys, overhead_us, overhead_children, sample and
<br>
period. Also it can contain any sort key(s).</p>

<p style="margin-top: 1em">By default, every sort keys not
specified in --field will be appended <br>
automatically.</p>

<p style="margin-top: 1em">-n, --show-nr-samples <br>
Show a column with the number of samples.</p>

<p style="margin-top: 1em">--show-total-period <br>
Show a column with the sum of periods.</p>

<p style="margin-top: 1em">--dsos <br>
Only consider symbols in these dsos. This option will affect
the percentage of the overhead column. See --percentage for
more info.</p>

<p style="margin-top: 1em">--comms <br>
Only consider symbols in these comms. This option will
affect the percentage of the overhead column. See
--percentage for more info.</p>

<p style="margin-top: 1em">--symbols <br>
Only consider these symbols. This option will affect the
percentage of the overhead column. See --percentage for more
info.</p>

<p style="margin-top: 1em">-M, --disassembler-style= <br>
Set disassembler style for objdump.</p>

<p style="margin-top: 1em">--source <br>
Interleave source code with assembly code. Enabled by
default, disable with --no-source.</p>

<p style="margin-top: 1em">--asm-raw <br>
Show raw instruction encoding of assembly instructions.</p>

<p style="margin-top: 1em">-g <br>
Enables call-graph (stack chain/backtrace) recording.</p>

<p style="margin-top: 1em">--call-graph
[mode,type,min[,limit],order[,key][,branch]] <br>
Setup and enable call-graph (stack chain/backtrace)
recording, implies -g. See --call-graph section in
perf-record and perf-report man pages for details.</p>

<p style="margin-top: 1em">--children <br>
Accumulate callchain of children to parent entry so that
then can show up in the output. The output will have a new
&quot;Children&quot; column and will be sorted on the data.
It <br>
requires -g/--call-graph option enabled. See the
&acirc;overhead calculation&acirc; section for more
details.</p>

<p style="margin-top: 1em">--max-stack <br>
Set the stack depth limit when parsing the callchain,
anything beyond the specified depth will be ignored. This is
a trade-off between information loss and faster processing
<br>
especially for workloads that can have a very long callchain
stack.</p>

<p style="margin-top: 1em">Default: 127</p>

<p style="margin-top: 1em">--ignore-callees=&lt;regex&gt;
<br>
Ignore callees of the function(s) matching the given regex.
This has the effect of collecting the callers of each such
function into one place in the call-graph tree.</p>

<p style="margin-top: 1em">--percent-limit <br>
Do not show entries which have an overhead under that
percent. (Default: 0).</p>

<p style="margin-top: 1em">--percentage <br>
Determine how to display the overhead percentage of filtered
entries. Filters can be applied by --comms, --dsos and/or
--symbols options and Zoom operations on the TUI <br>
(thread, dso, etc).</p>

<p style="margin-top: 1em">&quot;relative&quot; means
it&rsquo;s relative to filtered entries only so that the
<br>
sum of shown entries will be always 100%.
&quot;absolute&quot; means it retains <br>
the original value before and after the filter is
applied.</p>

<p style="margin-top: 1em">-w,
--column-widths=&lt;width[,width...]&gt; <br>
Force each column width to the provided list, for large
terminal readability. 0 means no limit (default
behavior).</p>

<p style="margin-top: 1em">--proc-map-timeout <br>
When processing pre-existing threads /proc/XXX/mmap, it may
take a long time, because the file may be huge. A time out
is needed in such cases. This option sets the time out <br>
limit. The default value is 500 ms.</p>

<p style="margin-top: 1em">-b, --branch-any <br>
Enable taken branch stack sampling. Any type of taken branch
may be sampled. This is a shortcut for --branch-filter any.
See --branch-filter for more infos.</p>

<p style="margin-top: 1em">-j, --branch-filter <br>
Enable taken branch stack sampling. Each sample captures a
series of consecutive taken branches. The number of branches
captured with each sample depends on the underlying <br>
hardware, the type of branches of interest, and the executed
code. It is possible to select the types of branches
captured by enabling filters. For a full list of modifiers
<br>
please see the perf record manpage.</p>

<p style="margin-top: 1em">The option requires at least one
branch type among any, any_call, any_ret, ind_call, cond.
<br>
The privilege levels may be omitted, in which case, the
privilege levels of the associated <br>
event are applied to the branch filter. Both kernel (k) and
hypervisor (hv) privilege <br>
levels are subject to permissions. When sampling on multiple
events, branch stack sampling <br>
is enabled for all the sampling events. The sampled branch
type is the same for all events. <br>
The various filters must be specified as a comma separated
list: --branch-filter any_ret,u,k <br>
Note that this feature may not be available on all
processors.</p>

<p style="margin-top: 1em">--raw-trace <br>
When displaying traceevent output, do not use print fmt or
plugins.</p>

<p style="margin-top: 1em">--hierarchy <br>
Enable hierarchy output.</p>

<p style="margin-top: 1em">INTERACTIVE PROMPTING KEYS <br>
[d] <br>
Display refresh delay.</p>

<p style="margin-top: 1em">[e] <br>
Number of entries to display.</p>

<p style="margin-top: 1em">[E] <br>
Event to display when multiple counters are active.</p>

<p style="margin-top: 1em">[f] <br>
Profile display filter (&gt;= hit count).</p>

<p style="margin-top: 1em">[F] <br>
Annotation display filter (&gt;= % of total).</p>

<p style="margin-top: 1em">[s] <br>
Annotate symbol.</p>

<p style="margin-top: 1em">[S] <br>
Stop annotation, return to full profile display.</p>

<p style="margin-top: 1em">[z] <br>
Toggle event count zeroing across display updates.</p>

<p style="margin-top: 1em">[qQ] <br>
Quit.</p>

<p style="margin-top: 1em">Pressing any unmapped key
displays a menu, and prompts for input.</p>

<p style="margin-top: 1em">OVERHEAD CALCULATION <br>
The overhead can be shown in two columns as Children and
Self when perf collects callchains. The self overhead is
simply calculated by adding all period values of the entry -
<br>
usually a function (symbol). This is the value that perf
shows traditionally and sum of all the self overhead values
should be 100%.</p>

<p style="margin-top: 1em">The children overhead is
calculated by adding all period values of the child
functions so that it can show the total overhead of the
higher level functions even if they don&acirc;t <br>
directly execute much. Children here means functions that
are called from another (parent) function.</p>

<p style="margin-top: 1em">It might be confusing that the
sum of all the children overhead values exceeds 100% since
each of them is already an accumulation of self overhead of
its child functions. But <br>
with this enabled, users can find which function has the
most overhead even if samples are spread over the
children.</p>

<p style="margin-top: 1em">Consider the following example;
there are three functions like below.</p>

<p style="margin-top: 1em">.ft C <br>
void foo(void) { <br>
/* do something */ <br>
}</p>

<p style="margin-top: 1em">void bar(void) { <br>
/* do something */ <br>
foo(); <br>
}</p>

<p style="margin-top: 1em">int main(void) { <br>
bar() <br>
return 0; <br>
} <br>
.ft</p>

<p style="margin-top: 1em">In this case foo is a child of
bar, and bar is an immediate child of main so foo also is a
child of main. In other words, main is a parent of foo and
bar, and bar is a parent of <br>
foo.</p>

<p style="margin-top: 1em">Suppose all samples are recorded
in foo and bar only. When it&acirc;s recorded with
callchains the output will show something like below in the
usual (self-overhead-only) output of <br>
perf report:</p>

<p style="margin-top: 1em">.ft C <br>
Overhead Symbol <br>
........ ..................... <br>
60.00% foo <br>
| <br>
--- foo <br>
bar <br>
main <br>
__libc_start_main</p>

<p style="margin-top: 1em">40.00% bar <br>
| <br>
--- bar <br>
main <br>
__libc_start_main <br>
.ft</p>

<p style="margin-top: 1em">When the --children option is
enabled, the self overhead values of child functions (i.e.
foo and bar) are added to the parents to calculate the
children overhead. In this case <br>
the report could be displayed as:</p>

<p style="margin-top: 1em">.ft C <br>
Children Self Symbol <br>
........ ........ .................... <br>
100.00% 0.00% __libc_start_main <br>
| <br>
--- __libc_start_main</p>

<p style="margin-top: 1em">100.00% 0.00% main <br>
| <br>
--- main <br>
__libc_start_main</p>

<p style="margin-top: 1em">100.00% 40.00% bar <br>
| <br>
--- bar <br>
main <br>
__libc_start_main</p>

<p style="margin-top: 1em">60.00% 60.00% foo <br>
| <br>
--- foo <br>
bar <br>
main <br>
__libc_start_main <br>
.ft</p>

<p style="margin-top: 1em">In the above output, the self
overhead of foo (60%) was add to the children overhead of
bar, main and __libc_start_main. Likewise, the self overhead
of bar (40%) was added to the <br>
children overhead of main and __libc_start_main.</p>

<p style="margin-top: 1em">So __libc_start_main and main
are shown first since they have same (100%) children
overhead (even though they have zero self overhead) and they
are the parents of foo and bar.</p>

<p style="margin-top: 1em">Since v3.16 the children
overhead is shown by default and the output is sorted by its
values. The children overhead is disabled by specifying
--no-children option on the command <br>
line or by adding report.children = false or top.children =
false in the perf config file.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perf-stat(1), perf-list(1), perf-report(1)</p>

<p style="margin-top: 1em">perf 07/04/2017 PERF-TOP(1)</p>
<hr>
</body>
</html>
