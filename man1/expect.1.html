<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:08:38 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>EXPECT(1) General Commands Manual EXPECT(1)</p>

<p style="margin-top: 1em">NAME <br>
expect - programmed dialogue with interactive programs,
Version 5</p>

<p style="margin-top: 1em">SYNOPSIS <br>
expect [ -dDinN ] [ -c cmds ] [ [ -[f|b] ] cmdfile ] [ args
]</p>

<p style="margin-top: 1em">INTRODUCTION <br>
Expect is a program that &quot;talks&quot; to other
interactive programs according to a script. Following the
script, Expect knows what can be expected from a program and
what the correct <br>
response should be. An interpreted language provides
branching and high-level control structures to direct the
dialogue. In addition, the user can take control and
interact <br>
directly when desired, afterward returning control to the
script.</p>

<p style="margin-top: 1em">Expectk is a mixture of Expect
and Tk. It behaves just like Expect and Tk&rsquo;s wish.
Expect can also be used directly in C or C++ (that is,
without Tcl). See libexpect(3).</p>

<p style="margin-top: 1em">The name &quot;Expect&quot;
comes from the idea of send/expect sequences popularized by
uucp, kermit and other modem control programs. However
unlike uucp, Expect is generalized so that <br>
it can be run as a user-level command with any program and
task in mind. Expect can actually talk to several programs
at the same time.</p>

<p style="margin-top: 1em">For example, here are some
things Expect can do:</p>

<p style="margin-top: 1em">&Acirc;&middot; Cause your
computer to dial you back, so that you can login without
paying for the call.</p>

<p style="margin-top: 1em">&Acirc;&middot; Start a game
(e.g., rogue) and if the optimal configuration doesn&rsquo;t
appear, restart it (again and again) until it does, then
hand over control to you.</p>

<p style="margin-top: 1em">&Acirc;&middot; Run fsck, and in
response to its questions, answer &quot;yes&quot;,
&quot;no&quot; or give control back to you, based on
predetermined criteria.</p>

<p style="margin-top: 1em">&Acirc;&middot; Connect to
another network or BBS (e.g., MCI Mail, CompuServe) and
automatically retrieve your mail so that it appears as if it
was originally sent to your local sys&acirc; <br>
tem.</p>

<p style="margin-top: 1em">&Acirc;&middot; Carry
environment variables, current directory, or any kind of
information across rlogin, telnet, tip, su, chgrp, etc.</p>

<p style="margin-top: 1em">There are a variety of reasons
why the shell cannot perform these tasks. (Try, you&rsquo;ll
see.) All are possible with Expect.</p>

<p style="margin-top: 1em">In general, Expect is useful for
running any program which requires interaction between the
program and the user. All that is necessary is that the
interaction can be character&acirc; <br>
ized programmatically. Expect can also give the user back
control (without halting the program being controlled) if
desired. Similarly, the user can return control to the <br>
script at any time.</p>

<p style="margin-top: 1em">USAGE <br>
Expect reads cmdfile for a list of commands to execute.
Expect may also be invoked implicitly on systems which
support the #! notation by marking the script executable,
and mak&acirc; <br>
ing the first line in your script:</p>

<p style="margin-top: 1em">#!/usr/local/bin/expect -f</p>

<p style="margin-top: 1em">Of course, the path must
accurately describe where Expect lives. /usr/local/bin is
just an example.</p>

<p style="margin-top: 1em">The -c flag prefaces a command
to be executed before any in the script. The command should
be quoted to prevent being broken up by the shell. This
option may be used multiple <br>
times. Multiple commands may be executed with a single -c by
separating them with semicolons. Commands are executed in
the order they appear. (When using Expectk, this option <br>
is specified as -command.)</p>

<p style="margin-top: 1em">The -d flag enables some
diagnostic output, which primarily reports internal activity
of commands such as expect and interact. This flag has the
same effect as &quot;exp_internal 1&quot; <br>
at the beginning of an Expect script, plus the version of
Expect is printed. (The strace command is useful for tracing
statements, and the trace command is useful for tracing <br>
variable assignments.) (When using Expectk, this option is
specified as -diag.)</p>

<p style="margin-top: 1em">The -D flag enables an
interactive debugger. An integer value should follow. The
debugger will take control before the next Tcl procedure if
the value is non-zero or if a ^C is <br>
pressed (or a breakpoint is hit, or other appropriate
debugger command appears in the script). See the README file
or SEE ALSO (below) for more information on the debugger.
<br>
(When using Expectk, this option is specified as
-Debug.)</p>

<p style="margin-top: 1em">The -f flag prefaces a file from
which to read commands from. The flag itself is optional as
it is only useful when using the #! notation (see above), so
that other arguments <br>
may be supplied on the command line. (When using Expectk,
this option is specified as -file.)</p>

<p style="margin-top: 1em">By default, the command file is
read into memory and executed in its entirety. It is
occasionally desirable to read files one line at a time. For
example, stdin is read this <br>
way. In order to force arbitrary files to be handled this
way, use the -b flag. (When using Expectk, this option is
specified as -buffer.) Note that stdio-buffering may still
<br>
take place however this shouldn&rsquo;t cause problems when
reading from a fifo or stdin.</p>

<p style="margin-top: 1em">If the string &quot;-&quot; is
supplied as a filename, standard input is read instead. (Use
&quot;./-&quot; to read from a file actually named
&quot;-&quot;.)</p>

<p style="margin-top: 1em">The -i flag causes Expect to
interactively prompt for commands instead of reading them
from a file. Prompting is terminated via the exit command or
upon EOF. See interpreter <br>
(below) for more information. -i is assumed if neither a
command file nor -c is used. (When using Expectk, this
option is specified as -interactive.)</p>

<p style="margin-top: 1em">-- may be used to delimit the
end of the options. This is useful if you want to pass an
option-like argument to your script without it being
interpreted by Expect. This can <br>
usefully be placed in the #! line to prevent any flag-like
interpretation by Expect. For example, the following will
leave the original arguments (including the script name) in
<br>
the variable argv.</p>

<p style="margin-top: 1em">#!/usr/local/bin/expect --</p>

<p style="margin-top: 1em">Note that the usual getopt(3)
and execve(2) conventions must be observed when adding
arguments to the #! line.</p>

<p style="margin-top: 1em">The file $exp_library/expect.rc
is sourced automatically if present, unless the -N flag is
used. (When using Expectk, this option is specified as
-NORC.) Immediately after <br>
this, the file ~/.expect.rc is sourced automatically, unless
the -n flag is used. If the environment variable DOTDIR is
defined, it is treated as a directory and .expect.rc is <br>
read from there. (When using Expectk, this option is
specified as -norc.) This sourcing occurs only after
executing any -c flags.</p>

<p style="margin-top: 1em">-v causes Expect to print its
version number and exit. (The corresponding flag in Expectk,
which uses long flag names, is -version.)</p>

<p style="margin-top: 1em">Optional args are constructed
into a list and stored in the variable named argv. argc is
initialized to the length of argv.</p>

<p style="margin-top: 1em">argv0 is defined to be the name
of the script (or binary if no script is used). For example,
the following prints out the name of the script and the
first three arguments:</p>

<p style="margin-top: 1em">send_user &quot;$argv0 [lrange
$argv 0 2]0</p>

<p style="margin-top: 1em">COMMANDS <br>
Expect uses Tcl (Tool Command Language). Tcl provides
control flow (e.g., if, for, break), expression evaluation
and several other features such as recursion, procedure
defini&acirc; <br>
tion, etc. Commands used here but not defined (e.g., set,
if, exec) are Tcl commands (see tcl(3)). Expect supports
additional commands, described below. Unless otherwise
spec&acirc; <br>
ified, commands return the empty string.</p>

<p style="margin-top: 1em">Commands are listed
alphabetically so that they can be quickly located. However,
new users may find it easier to start by reading the
descriptions of spawn, send, expect, and <br>
interact, in that order.</p>

<p style="margin-top: 1em">Note that the best introduction
to the language (both Expect and Tcl) is provided in the
book &quot;Exploring Expect&quot; (see SEE ALSO below).
Examples are included in this man page but <br>
they are very limited since this man page is meant primarily
as reference material.</p>

<p style="margin-top: 1em">Note that in the text of this
man page, &quot;Expect&quot; with an uppercase &quot;E&quot;
refers to the Expect program while &quot;expect&quot; with a
lower-case &quot;e&quot; refers to the expect command within
the <br>
Expect program.)</p>

<p style="margin-top: 1em">close [-slave] [-onexec 0|1] [-i
spawn_id] <br>
closes the connection to the current process. Most
interactive programs will detect EOF on their stdin and
exit; thus close usually suffices to kill the process as
well. <br>
The -i flag declares the process to close corresponding to
the named spawn_id.</p>

<p style="margin-top: 1em">Both expect and interact will
detect when the current process exits and implicitly do a
close. But if you kill the process by, say, &quot;exec kill
$pid&quot;, you will need to <br>
explicitly call close.</p>

<p style="margin-top: 1em">The -onexec flag determines
whether the spawn id will be closed in any new spawned
processes or if the process is overlayed. To leave a spawn
id open, use the value 0. A <br>
non-zero integer value will force the spawn closed (the
default) in any new processes.</p>

<p style="margin-top: 1em">The -slave flag closes the slave
associated with the spawn id. (See &quot;spawn -pty&quot;.)
When the connection is closed, the slave is automatically
closed as well if still open.</p>

<p style="margin-top: 1em">No matter whether the connection
is closed implicitly or explicitly, you should call wait to
clear up the corresponding kernel process slot. close does
not call wait since <br>
there is no guarantee that closing a process connection will
cause it to exit. See wait below for more info.</p>

<p style="margin-top: 1em">debug [[-now] 0|1] <br>
controls a Tcl debugger allowing you to step through
statements, set breakpoints, etc.</p>

<p style="margin-top: 1em">With no arguments, a 1 is
returned if the debugger is not running, otherwise a 0 is
returned.</p>

<p style="margin-top: 1em">With a 1 argument, the debugger
is started. With a 0 argument, the debugger is stopped. If a
1 argument is preceded by the -now flag, the debugger is
started immediately <br>
(i.e., in the middle of the debug command itself).
Otherwise, the debugger is started with the next Tcl
statement.</p>

<p style="margin-top: 1em">The debug command does not
change any traps. Compare this to starting Expect with the
-D flag (see above).</p>

<p style="margin-top: 1em">See the README file or SEE ALSO
(below) for more information on the debugger.</p>

<p style="margin-top: 1em">disconnect <br>
disconnects a forked process from the terminal. It continues
running in the background. The process is given its own
process group (if possible). Standard I/O is redi&acirc;
<br>
rected to /dev/null.</p>

<p style="margin-top: 1em">The following fragment uses
disconnect to continue running the script in the
background.</p>

<p style="margin-top: 1em">if {[fork]!=0} exit <br>
disconnect <br>
. . .</p>

<p style="margin-top: 1em">The following script reads a
password, and then runs a program every hour that demands a
password each time it is run. The script supplies the
password so that you only <br>
have to type it once. (See the stty command which
demonstrates how to turn off password echoing.)</p>

<p style="margin-top: 1em">send_user
&quot;password?&nbsp;&quot; <br>
expect_user -re &quot;(.*)0 <br>
for {} 1 {} { <br>
if {[fork]!=0} {sleep 3600;continue} <br>
disconnect <br>
spawn priv_prog <br>
expect Password: &quot; <br>
send &quot;$expect_out(1,string) <br>
. . . <br>
exit <br>
}</p>

<p style="margin-top: 1em">An advantage to using disconnect
over the shell asynchronous process feature (&amp;) is that
Expect can save the terminal parameters prior to
disconnection, and then later <br>
apply them to new ptys. With &amp;, Expect does not have a
chance to read the terminal&rsquo;s parameters since the
terminal is already disconnected by the time Expect receives
con&acirc; <br>
trol.</p>

<p style="margin-top: 1em">exit [-opts] [status] <br>
causes Expect to exit or otherwise prepare to do so.</p>

<p style="margin-top: 1em">The -onexit flag causes the next
argument to be used as an exit handler. Without an argument,
the current exit handler is returned.</p>

<p style="margin-top: 1em">The -noexit flag causes Expect
to prepare to exit but stop short of actually returning
control to the operating system. The user-defined exit
handler is run as well as <br>
Expect&rsquo;s own internal handlers. No further Expect
commands should be executed. This is useful if you are
running Expect with other Tcl extensions. The current
inter&acirc; <br>
preter (and main window if in the Tk environment) remain so
that other Tcl extensions can clean up. If Expect&rsquo;s
exit is called again (however this might occur), the
han&acirc; <br>
dlers are not rerun.</p>

<p style="margin-top: 1em">Upon exiting, all connections to
spawned processes are closed. Closure will be detected as an
EOF by spawned processes. exit takes no other actions beyond
what the normal <br>
_exit(2) procedure does. Thus, spawned processes that do not
check for EOF may continue to run. (A variety of conditions
are important to determining, for example, what <br>
signals a spawned process will be sent, but these are
system-dependent, typically documented under exit(3).)
Spawned processes that continue to run will be inherited by
<br>
init.</p>

<p style="margin-top: 1em">status (or 0 if not specified)
is returned as the exit status of Expect. exit is implicitly
executed if the end of the script is reached.</p>

<p style="margin-top: 1em">exp_continue [-continue_timer]
<br>
The command exp_continue allows expect itself to continue
executing rather than returning as it normally would. By
default exp_continue resets the timeout timer. The
-con&acirc; <br>
tinue_timer flag prevents timer from being restarted. (See
expect for more information.)</p>

<p style="margin-top: 1em">exp_internal [-f file] value
<br>
causes further commands to send diagnostic information
internal to Expect to stderr if value is non-zero. This
output is disabled if value is 0. The diagnostic
informa&acirc; <br>
tion includes every character received, and every attempt
made to match the current output against the patterns.</p>

<p style="margin-top: 1em">If the optional file is
supplied, all normal and debugging output is written to that
file (regardless of the value of value). Any previous
diagnostic output file is <br>
closed.</p>

<p style="margin-top: 1em">The -info flag causes
exp_internal to return a description of the most recent
non-info arguments given.</p>

<p style="margin-top: 1em">exp_open [args] [-i spawn_id]
<br>
returns a Tcl file identifier that corresponds to the
original spawn id. The file identifier can then be used as
if it were opened by Tcl&rsquo;s open command. (The spawn id
<br>
should no longer be used. A wait should not be executed.</p>

<p style="margin-top: 1em">The -leaveopen flag leaves the
spawn id open for access through Expect commands. A wait
must be executed on the spawn id.</p>

<p style="margin-top: 1em">exp_pid [-i spawn_id] <br>
returns the process id corresponding to the currently
spawned process. If the -i flag is used, the pid returned
corresponds to that of the given spawn id.</p>

<p style="margin-top: 1em">exp_send <br>
is an alias for send.</p>

<p style="margin-top: 1em">exp_send_error <br>
is an alias for send_error.</p>

<p style="margin-top: 1em">exp_send_log <br>
is an alias for send_log.</p>

<p style="margin-top: 1em">exp_send_tty <br>
is an alias for send_tty.</p>

<p style="margin-top: 1em">exp_send_user <br>
is an alias for send_user.</p>

<p style="margin-top: 1em">exp_version [[-exit] version]
<br>
is useful for assuring that the script is compatible with
the current version of Expect.</p>

<p style="margin-top: 1em">With no arguments, the current
version of Expect is returned. This version may then be
encoded in your script. If you actually know that you are
not using features of <br>
recent versions, you can specify an earlier version.</p>

<p style="margin-top: 1em">Versions consist of three
numbers separated by dots. First is the major number.
Scripts written for versions of Expect with a different
major number will almost certainly <br>
not work. exp_version returns an error if the major numbers
do not match.</p>

<p style="margin-top: 1em">Second is the minor number.
Scripts written for a version with a greater minor number
than the current version may depend upon some new feature
and might not run. <br>
exp_version returns an error if the major numbers match, but
the script minor number is greater than that of the running
Expect.</p>

<p style="margin-top: 1em">Third is a number that plays no
part in the version comparison. However, it is incremented
when the Expect software distribution is changed in any way,
such as by addi&acirc; <br>
tional documentation or optimization. It is reset to 0 upon
each new minor version.</p>

<p style="margin-top: 1em">With the -exit flag, Expect
prints an error and exits if the version is out of date.</p>

<p style="margin-top: 1em">expect [[-opts] pat1 body1] ...
[-opts] patn [bodyn] <br>
waits until one of the patterns matches the output of a
spawned process, a specified time period has passed, or an
end-of-file is seen. If the final body is empty, it may <br>
be omitted.</p>

<p style="margin-top: 1em">Patterns from the most recent
expect_before command are implicitly used before any other
patterns. Patterns from the most recent expect_after command
are implicitly used <br>
after any other patterns.</p>

<p style="margin-top: 1em">If the arguments to the entire
expect statement require more than one line, all the
arguments may be &quot;braced&quot; into one so as to avoid
terminating each line with a back&acirc; <br>
slash. In this one case, the usual Tcl substitutions will
occur despite the braces.</p>

<p style="margin-top: 1em">If a pattern is the keyword eof,
the corresponding body is executed upon end-of-file. If a
pattern is the keyword timeout, the corresponding body is
executed upon timeout. <br>
If no timeout keyword is used, an implicit null action is
executed upon timeout. The default timeout period is 10
seconds but may be set, for example to 30, by the command
<br>
&quot;set timeout 30&quot;. An infinite timeout may be
designated by the value -1. If a pattern is the keyword
default, the corresponding body is executed upon either
timeout or <br>
end-of-file.</p>

<p style="margin-top: 1em">If a pattern matches, then the
corresponding body is executed. expect returns the result of
the body (or the empty string if no pattern matched). In the
event that multi&acirc; <br>
ple patterns match, the one appearing first is used to
select a body.</p>

<p style="margin-top: 1em">Each time new output arrives, it
is compared to each pattern in the order they are listed.
Thus, you may test for absence of a match by making the last
pattern something <br>
guaranteed to appear, such as a prompt. In situations where
there is no prompt, you must use timeout (just like you
would if you were interacting manually).</p>

<p style="margin-top: 1em">Patterns are specified in three
ways. By default, patterns are specified as with Tcl&rsquo;s
string match command. (Such patterns are also similar to
C-shell regular expres&acirc; <br>
sions usually referred to as &quot;glob&quot; patterns). The
-gl flag may may be used to protect patterns that might
otherwise match expect flags from doing so. Any pattern
begin&acirc; <br>
ning with a &quot;-&quot; should be protected this way. (All
strings starting with &quot;-&quot; are reserved for future
options.)</p>

<p style="margin-top: 1em">For example, the following
fragment looks for a successful login. (Note that abort is
presumed to be a procedure defined elsewhere in the
script.)</p>

<p style="margin-top: 1em">expect { <br>
busy {puts busy; exp_continue} <br>
failed abort <br>
&quot;invalid password&quot; abort <br>
timeout abort <br>
connected <br>
}</p>

<p style="margin-top: 1em">Quotes are necessary on the
fourth pattern since it contains a space, which would
otherwise separate the pattern from the action. Patterns
with the same action (such as <br>
the 3rd and 4th) require listing the actions again. This can
be avoid by using regexp-style patterns (see below). More
information on forming glob-style patterns can be <br>
found in the Tcl manual.</p>

<p style="margin-top: 1em">Regexp-style patterns follow the
syntax defined by Tcl&rsquo;s regexp (short for
&quot;regular expression&quot;) command. regexp patterns are
introduced with the flag -re. The previous <br>
example can be rewritten using a regexp as:</p>

<p style="margin-top: 1em">expect { <br>
busy {puts busy; exp_continue} <br>
-re &quot;failed|invalid password&quot; abort <br>
timeout abort <br>
connected <br>
}</p>

<p style="margin-top: 1em">Both types of patterns are
&quot;unanchored&quot;. This means that patterns do not have
to match the entire string, but can begin and end the match
anywhere in the string (as long <br>
as everything else matches). Use ^ to match the beginning of
a string, and $ to match the end. Note that if you do not
wait for the end of a string, your responses can <br>
easily end up in the middle of the string as they are echoed
from the spawned process. While still producing correct
results, the output can look unnatural. Thus, use of <br>
$ is encouraged if you can exactly describe the characters
at the end of a string.</p>

<p style="margin-top: 1em">Note that in many editors, the ^
and $ match the beginning and end of lines respectively.
However, because expect is not line oriented, these
characters match the beginning <br>
and end of the data (as opposed to lines) currently in the
expect matching buffer. (Also, see the note below on
&quot;system indigestion.&quot;)</p>

<p style="margin-top: 1em">The -ex flag causes the pattern
to be matched as an &quot;exact&quot; string. No
interpretation of *, ^, etc is made (although the usual Tcl
conventions must still be observed). <br>
Exact patterns are always unanchored.</p>

<p style="margin-top: 1em">The -nocase flag causes
uppercase characters of the output to compare as if they
were lowercase characters. The pattern is not affected.</p>

<p style="margin-top: 1em">While reading output, more than
2000 bytes can force earlier bytes to be
&quot;forgotten&quot;. This may be changed with the function
match_max. (Note that excessively large values <br>
can slow down the pattern matcher.) If patlist is
full_buffer, the corresponding body is executed if match_max
bytes have been received and no other patterns have matched.
<br>
Whether or not the full_buffer keyword is used, the
forgotten characters are written to expect_out(buffer).</p>

<p style="margin-top: 1em">If patlist is the keyword null,
and nulls are allowed (via the remove_nulls command), the
corresponding body is executed if a single ASCII 0 is
matched. It is not possible <br>
to match 0 bytes via glob or regexp patterns.</p>

<p style="margin-top: 1em">Upon matching a pattern (or eof
or full_buffer), any matching and previously unmatched
output is saved in the variable expect_out(buffer). Up to 9
regexp substring matches <br>
are saved in the variables expect_out(1,string) through
expect_out(9,string). If the -indices flag is used before a
pattern, the starting and ending indices (in a form <br>
suitable for lrange) of the 10 strings are stored in the
variables expect_out(X,start) and expect_out(X,end) where X
is a digit, corresponds to the substring position in <br>
the buffer. 0 refers to strings which matched the entire
pattern and is generated for glob patterns as well as regexp
patterns. For example, if a process has produced <br>
output of &quot;abcdefgh0, the result of:</p>

<p style="margin-top: 1em">expect &quot;cd&quot;</p>

<p style="margin-top: 1em">is as if the following
statements had executed:</p>

<p style="margin-top: 1em">set expect_out(0,string) cd <br>
set expect_out(buffer) abcd</p>

<p style="margin-top: 1em">and &quot;efgh0 is left in the
output buffer. If a process produced the output
&quot;abbbcabkkkka0, the result of:</p>

<p style="margin-top: 1em">expect -indices -re
&quot;b(b*).*(k+)&quot;</p>

<p style="margin-top: 1em">is as if the following
statements had executed:</p>

<p style="margin-top: 1em">set expect_out(0,start) 1 <br>
set expect_out(0,end) 10 <br>
set expect_out(0,string) bbbcabkkkk <br>
set expect_out(1,start) 2 <br>
set expect_out(1,end) 3 <br>
set expect_out(1,string) bb <br>
set expect_out(2,start) 10 <br>
set expect_out(2,end) 10 <br>
set expect_out(2,string) k <br>
set expect_out(buffer) abbbcabkkkk</p>

<p style="margin-top: 1em">and &quot;a0 is left in the
output buffer. The pattern &quot;*&quot; (and -re
&quot;.*&quot;) will flush the output buffer without reading
any more output from the process.</p>

<p style="margin-top: 1em">Normally, the matched output is
discarded from Expect&rsquo;s internal buffers. This may be
prevented by prefixing a pattern with the -notransfer flag.
This flag is especially <br>
useful in experimenting (and can be abbreviated to
&quot;-not&quot; for convenience while experimenting).</p>

<p style="margin-top: 1em">The spawn id associated with the
matching output (or eof or full_buffer) is stored in
expect_out(spawn_id).</p>

<p style="margin-top: 1em">The -timeout flag causes the
current expect command to use the following value as a
timeout instead of using the value of the timeout
variable.</p>

<p style="margin-top: 1em">By default, patterns are matched
against output from the current process, however the -i flag
declares the output from the named spawn_id list be matched
against any fol&acirc; <br>
lowing patterns (up to the next -i). The spawn_id list
should either be a whitespace separated list of spawn_ids or
a variable referring to such a list of spawn_ids.</p>

<p style="margin-top: 1em">For example, the following
example waits for &quot;connected&quot; from the current
process, or &quot;busy&quot;, &quot;failed&quot; or
&quot;invalid password&quot; from the spawn_id named by
$proc2.</p>

<p style="margin-top: 1em">expect { <br>
-i $proc2 busy {puts busy; exp_continue} <br>
-re &quot;failed|invalid password&quot; abort <br>
timeout abort <br>
connected <br>
}</p>

<p style="margin-top: 1em">The value of the global variable
any_spawn_id may be used to match patterns to any spawn_ids
that are named with all other -i flags in the current expect
command. The <br>
spawn_id from a -i flag with no associated pattern (i.e.,
followed immediately by another -i) is made available to any
other patterns in the same expect command associated <br>
with any_spawn_id.</p>

<p style="margin-top: 1em">The -i flag may also name a
global variable in which case the variable is read for a
list of spawn ids. The variable is reread whenever it
changes. This provides a way of <br>
changing the I/O source while the command is in execution.
Spawn ids provided this way are called &quot;indirect&quot;
spawn ids.</p>

<p style="margin-top: 1em">Actions such as break and
continue cause control structures (i.e., for, proc) to
behave in the usual way. The command exp_continue allows
expect itself to continue execut&acirc; <br>
ing rather than returning as it normally would.</p>

<p style="margin-top: 1em">This is useful for avoiding
explicit loops or repeated expect statements. The following
example is part of a fragment to automate rlogin. The
exp_continue avoids having <br>
to write a second expect statement (to look for the prompt
again) if the rlogin prompts for a password.</p>

<p style="margin-top: 1em">expect { <br>
Password: { <br>
stty -echo <br>
send_user &quot;password (for $user) on $host: &quot; <br>
expect_user -re &quot;(.*)0 <br>
send_user &quot;0 &quot; <br>
send &quot;$expect_out(1,string) <br>
stty echo <br>
exp_continue <br>
} incorrect { <br>
send_user &quot;invalid password or account0 <br>
exit <br>
} timeout { <br>
send_user &quot;connection to $host timed out0 <br>
exit <br>
} eof { <br>
send_user &quot;connection to host failed:
$expect_out(buffer)&quot; <br>
exit <br>
} -re $prompt <br>
}</p>

<p style="margin-top: 1em">For example, the following
fragment might help a user guide an interaction that is
already totally automated. In this case, the terminal is put
into raw mode. If the user <br>
presses &quot;+&quot;, a variable is incremented. If
&quot;p&quot; is pressed, several returns are sent to the
process, perhaps to poke it in some way, and &quot;i&quot;
lets the user interact with the <br>
process, effectively stealing away control from the script.
In each case, the exp_continue allows the current expect to
continue pattern matching after executing the cur&acirc;
<br>
rent action.</p>

<p style="margin-top: 1em">stty raw -echo <br>
expect_after { <br>
-i $user_spawn_id &quot;; exp_continue} <br>
&quot;p&quot; {send &quot; <br>
&quot;+&quot; {incr foo; exp_continue} <br>
&quot;i&quot; {interact; exp_continue} <br>
&quot;quit&quot; exit <br>
}</p>

<p style="margin-top: 1em">By default, exp_continue resets
the timeout timer. The timer is not restarted, if
exp_continue is called with the -continue_timer flag.</p>

<p style="margin-top: 1em">expect_after [expect_args] <br>
works identically to the expect_before except that if
patterns from both expect and expect_after can match, the
expect pattern is used. See the expect_before command for
<br>
more information.</p>

<p style="margin-top: 1em">expect_background [expect_args]
<br>
takes the same arguments as expect, however it returns
immediately. Patterns are tested whenever new input arrives.
The pattern timeout and default are meaningless to <br>
expect_background and are silently discarded. Otherwise, the
expect_background command uses expect_before and
expect_after patterns just like expect does.</p>

<p style="margin-top: 1em">When expect_background actions
are being evaluated, background processing for the same
spawn id is blocked. Background processing is unblocked when
the action completes. <br>
While background processing is blocked, it is possible to do
a (foreground) expect on the same spawn id.</p>

<p style="margin-top: 1em">It is not possible to execute an
expect while an expect_background is unblocked.
expect_background for a particular spawn id is deleted by
declaring a new expect_back&acirc; <br>
ground with the same spawn id. Declaring expect_background
with no pattern removes the given spawn id from the ability
to match patterns in the background.</p>

<p style="margin-top: 1em">expect_before [expect_args] <br>
takes the same arguments as expect, however it returns
immediately. Pattern-action pairs from the most recent
expect_before with the same spawn id are implicitly added to
<br>
any following expect commands. If a pattern matches, it is
treated as if it had been specified in the expect command
itself, and the associated body is executed in the <br>
context of the expect command. If patterns from both
expect_before and expect can match, the expect_before
pattern is used.</p>

<p style="margin-top: 1em">If no pattern is specified, the
spawn id is not checked for any patterns.</p>

<p style="margin-top: 1em">Unless overridden by a -i flag,
expect_before patterns match against the spawn id defined at
the time that the expect_before command was executed (not
when its pattern is <br>
matched).</p>

<p style="margin-top: 1em">The -info flag causes
expect_before to return the current specifications of what
patterns it will match. By default, it reports on the
current spawn id. An optional spawn <br>
id specification may be given for information on that spawn
id. For example</p>

<p style="margin-top: 1em">expect_before -info -i $proc</p>

<p style="margin-top: 1em">At most one spawn id
specification may be given. The flag -indirect suppresses
direct spawn ids that come only from indirect
specifications.</p>

<p style="margin-top: 1em">Instead of a spawn id
specification, the flag &quot;-all&quot; will cause
&quot;-info&quot; to report on all spawn ids.</p>

<p style="margin-top: 1em">The output of the -info flag can
be reused as the argument to expect_before.</p>

<p style="margin-top: 1em">expect_tty [expect_args] <br>
is like expect but it reads characters from /dev/tty (i.e.
keystrokes from the user). By default, reading is performed
in cooked mode. Thus, lines must end with a return <br>
in order for expect to see them. This may be changed via
stty (see the stty command below).</p>

<p style="margin-top: 1em">expect_user [expect_args] <br>
is like expect but it reads characters from stdin (i.e.
keystrokes from the user). By default, reading is performed
in cooked mode. Thus, lines must end with a return in <br>
order for expect to see them. This may be changed via stty
(see the stty command below).</p>

<p style="margin-top: 1em">fork creates a new process. The
new process is an exact copy of the current Expect process.
On success, fork returns 0 to the new (child) process and
returns the process ID of <br>
the child process to the parent process. On failure
(invariably due to lack of resources, e.g., swap space,
memory), fork returns -1 to the parent process, and no child
<br>
process is created.</p>

<p style="margin-top: 1em">Forked processes exit via the
exit command, just like the original process. Forked
processes are allowed to write to the log files. If you do
not disable debugging or <br>
logging in most of the processes, the result can be
confusing.</p>

<p style="margin-top: 1em">Some pty implementations may be
confused by multiple readers and writers, even momentarily.
Thus, it is safest to fork before spawning processes.</p>

<p style="margin-top: 1em">interact [string1 body1] ...
[stringn [bodyn]] <br>
gives control of the current process to the user, so that
keystrokes are sent to the current process, and the stdout
and stderr of the current process are returned.</p>

<p style="margin-top: 1em">String-body pairs may be
specified as arguments, in which case the body is executed
when the corresponding string is entered. (By default, the
string is not sent to the <br>
current process.) The interpreter command is assumed, if the
final body is missing.</p>

<p style="margin-top: 1em">If the arguments to the entire
interact statement require more than one line, all the
arguments may be &quot;braced&quot; into one so as to avoid
terminating each line with a back&acirc; <br>
slash. In this one case, the usual Tcl substitutions will
occur despite the braces.</p>

<p style="margin-top: 1em">For example, the following
command runs interact with the following string-body pairs
defined: When ^Z is pressed, Expect is suspended. (The
-reset flag restores the ter&acirc; <br>
minal modes.) When ^A is pressed, the user sees &quot;you
typed a control-A&quot; and the process is sent a ^A. When $
is pressed, the user sees the date. When ^C is pressed, <br>
Expect exits. If &quot;foo&quot; is entered, the user sees
&quot;bar&quot;. When ~~ is pressed, the Expect interpreter
runs interactively.</p>

<p style="margin-top: 1em">set CTRLZ 32 <br>
interact { <br>
-reset $CTRLZ {exec kill -STOP [pid]} <br>
01 {send_user &quot;you typed a control-A0; <br>
send &quot; 01&quot; <br>
} <br>
$ {send_user &quot;The date is [clock format [clock
seconds]].&quot;} <br>
03 exit <br>
foo {send_user &quot;bar&quot;} <br>
~~ <br>
}</p>

<p style="margin-top: 1em">In string-body pairs, strings
are matched in the order they are listed as arguments.
Strings that partially match are not sent to the current
process in anticipation of <br>
the remainder coming. If characters are then entered such
that there can no longer possibly be a match, only the part
of the string will be sent to the process that cannot <br>
possibly begin another match. Thus, strings that are
substrings of partial matches can match later, if the
original strings that was attempting to be match ultimately
<br>
fails.</p>

<p style="margin-top: 1em">By default, string matching is
exact with no wild cards. (In contrast, the expect command
uses glob-style patterns by default.) The -ex flag may be
used to protect pat&acirc; <br>
terns that might otherwise match interact flags from doing
so. Any pattern beginning with a &quot;-&quot; should be
protected this way. (All strings starting with &quot;-&quot;
are <br>
reserved for future options.)</p>

<p style="margin-top: 1em">The -re flag forces the string
to be interpreted as a regexp-style pattern. In this case,
matching substrings are stored in the variable interact_out
similarly to the way <br>
expect stores its output in the variable expect_out. The
-indices flag is similarly supported.</p>

<p style="margin-top: 1em">The pattern eof introduces an
action that is executed upon end-of-file. A separate eof
pattern may also follow the -output flag in which case it is
matched if an eof is <br>
detected while writing output. The default eof action is
&quot;return&quot;, so that interact simply returns upon any
EOF.</p>

<p style="margin-top: 1em">The pattern timeout introduces a
timeout (in seconds) and action that is executed after no
characters have been read for a given time. The timeout
pattern applies to the <br>
most recently specified process. There is no default
timeout. The special variable &quot;timeout&quot; (used by
the expect command) has no affect on this timeout.</p>

<p style="margin-top: 1em">For example, the following
statement could be used to autologout users who have not
typed anything for an hour but who still get frequent system
messages:</p>

<p style="margin-top: 1em">interact -input $user_spawn_id
timeout 3600 return -output $spawn_id</p>

<p style="margin-top: 1em">If the pattern is the keyword
null, and nulls are allowed (via the remove_nulls command),
the corresponding body is executed if a single ASCII 0 is
matched. It is not pos&acirc; <br>
sible to match 0 bytes via glob or regexp patterns.</p>

<p style="margin-top: 1em">Prefacing a pattern with the
flag -iwrite causes the variable interact_out(spawn_id) to
be set to the spawn_id which matched the pattern (or
eof).</p>

<p style="margin-top: 1em">Actions such as break and
continue cause control structures (i.e., for, proc) to
behave in the usual way. However return causes interact to
return to its caller, while <br>
inter_return causes interact to cause a return in its
caller. For example, if &quot;proc foo&quot; called interact
which then executed the action inter_return, proc foo would
<br>
return. (This means that if interact calls interpreter
interactively typing return will cause the interact to
continue, while inter_return will cause the interact to <br>
return to its caller.)</p>

<p style="margin-top: 1em">During interact, raw mode is
used so that all characters may be passed to the current
process. If the current process does not catch job control
signals, it will stop if <br>
sent a stop signal (by default ^Z). To restart it, send a
continue signal (such as by &quot;kill -CONT
&lt;pid&gt;&quot;). If you really want to send a SIGSTOP to
such a process (by ^Z), <br>
consider spawning csh first and then running your program.
On the other hand, if you want to send a SIGSTOP to Expect
itself, first call interpreter (perhaps by using an <br>
escape character), and then press ^Z.</p>

<p style="margin-top: 1em">String-body pairs can be used as
a shorthand for avoiding having to enter the interpreter and
execute commands interactively. The previous terminal mode
is used while the <br>
body of a string-body pair is being executed.</p>

<p style="margin-top: 1em">For speed, actions execute in
raw mode by default. The -reset flag resets the terminal to
the mode it had before interact was executed (invariably,
cooked mode). Note <br>
that characters entered when the mode is being switched may
be lost (an unfortunate feature of the terminal driver on
some systems). The only reason to use -reset is if <br>
your action depends on running in cooked mode.</p>

<p style="margin-top: 1em">The -echo flag sends characters
that match the following pattern back to the process that
generated them as each character is read. This may be useful
when the user needs <br>
to see feedback from partially typed patterns.</p>

<p style="margin-top: 1em">If a pattern is being echoed but
eventually fails to match, the characters are sent to the
spawned process. If the spawned process then echoes them,
the user will see the <br>
characters twice. -echo is probably only appropriate in
situations where the user is unlikely to not complete the
pattern. For example, the following excerpt is from <br>
rftp, the recursive-ftp script, where the user is prompted
to enter ~g, ~p, or ~l, to get, put, or list the current
directory recursively. These are so far away from the <br>
normal ftp commands, that the user is unlikely to type ~
followed by anything else, except mistakenly, in which case,
they&rsquo;ll probably just ignore the result anyway.</p>

<p style="margin-top: 1em">interact { <br>
-echo ~g {getcurdirectory 1} <br>
-echo ~l {getcurdirectory 0} <br>
-echo ~p {putcurdirectory} <br>
}</p>

<p style="margin-top: 1em">The -nobuffer flag sends
characters that match the following pattern on to the output
process as characters are read.</p>

<p style="margin-top: 1em">This is useful when you wish to
let a program echo back the pattern. For example, the
following might be used to monitor where a person is dialing
(a Hayes-style modem). <br>
Each time &quot;atd&quot; is seen the script logs the rest
of the line.</p>

<p style="margin-top: 1em">proc lognumber {} { &quot;
return <br>
interact -nobuffer -re &quot;(.*) <br>
puts $log &quot;[clock format [clock seconds]]: dialed
$interact_out(1,string)&quot; <br>
}</p>

<p style="margin-top: 1em">interact -nobuffer
&quot;atd&quot; lognumber</p>

<p style="margin-top: 1em">During interact, previous use of
log_user is ignored. In particular, interact will force its
output to be logged (sent to the standard output) since it
is presumed the <br>
user doesn&rsquo;t wish to interact blindly.</p>

<p style="margin-top: 1em">The -o flag causes any following
key-body pairs to be applied to the output of the current
process. This can be useful, for example, when dealing with
hosts that send <br>
unwanted characters during a telnet session.</p>

<p style="margin-top: 1em">By default, interact expects the
user to be writing stdin and reading stdout of the Expect
process itself. The -u flag (for &quot;user&quot;) makes
interact look for the user as the <br>
process named by its argument (which must be a spawned
id).</p>

<p style="margin-top: 1em">This allows two unrelated
processes to be joined together without using an explicit
loop. To aid in debugging, Expect diagnostics always go to
stderr (or stdout for cer&acirc; <br>
tain logging and debugging information). For the same
reason, the interpreter command will read interactively from
stdin.</p>

<p style="margin-top: 1em">For example, the following
fragment creates a login process. Then it dials the user
(not shown), and finally connects the two together. Of
course, any process may be sub&acirc; <br>
stituted for login. A shell, for example, would allow the
user to work without supplying an account and password.</p>

<p style="margin-top: 1em">spawn login <br>
set login $spawn_id <br>
spawn tip modem <br>
# dial back out to user <br>
# connect user to login <br>
interact -u $login</p>

<p style="margin-top: 1em">To send output to multiple
processes, list each spawn id list prefaced by a -output
flag. Input for a group of output spawn ids may be
determined by a spawn id list pref&acirc; <br>
aced by a -input flag. (Both -input and -output may take
lists in the same form as the -i flag in the expect command,
except that any_spawn_id is not meaningful in inter&acirc;
<br>
act.) All following flags and strings (or patterns) apply to
this input until another -input flag appears. If no -input
appears, -output implies &quot;-input $user_spawn_id <br>
-output&quot;. (Similarly, with patterns that do not have
-input.) If one -input is specified, it overrides
$user_spawn_id. If a second -input is specified, it
overrides <br>
$spawn_id. Additional -input flags may be specified.</p>

<p style="margin-top: 1em">The two implied input processes
default to having their outputs specified as $spawn_id and
$user_spawn_id (in reverse). If a -input flag appears with
no -output flag, <br>
characters from that process are discarded.</p>

<p style="margin-top: 1em">The -i flag introduces a
replacement for the current spawn_id when no other -input or
-output flags are used. A -i flag implies a -o flag.</p>

<p style="margin-top: 1em">It is possible to change the
processes that are being interacted with by using indirect
spawn ids. (Indirect spawn ids are described in the section
on the expect command.) <br>
Indirect spawn ids may be specified with the -i, -u, -input,
or -output flags.</p>

<p style="margin-top: 1em">interpreter [args] <br>
causes the user to be interactively prompted for Expect and
Tcl commands. The result of each command is printed.</p>

<p style="margin-top: 1em">Actions such as break and
continue cause control structures (i.e., for, proc) to
behave in the usual way. However return causes interpreter
to return to its caller, while <br>
inter_return causes interpreter to cause a return in its
caller. For example, if &quot;proc foo&quot; called
interpreter which then executed the action inter_return,
proc foo would <br>
return. Any other command causes interpreter to continue
prompting for new commands.</p>

<p style="margin-top: 1em">By default, the prompt contains
two integers. The first integer describes the depth of the
evaluation stack (i.e., how many times Tcl_Eval has been
called). The second <br>
integer is the Tcl history identifier. The prompt can be set
by defining a procedure called &quot;prompt1&quot; whose
return value becomes the next prompt. If a statement has
open <br>
quotes, parens, braces, or brackets, a secondary prompt (by
default &quot;+&gt; &quot;) is issued upon newline. The
secondary prompt may be set by defining a procedure called
<br>
&quot;prompt2&quot;.</p>

<p style="margin-top: 1em">During interpreter, cooked mode
is used, even if the its caller was using raw mode.</p>

<p style="margin-top: 1em">If stdin is closed, interpreter
will return unless the -eof flag is used, in which case the
subsequent argument is invoked.</p>

<p style="margin-top: 1em">log_file [args] [[-a] file] <br>
If a filename is provided, log_file will record a transcript
of the session (beginning at that point) in the file.
log_file will stop recording if no argument is given. <br>
Any previous log file is closed.</p>

<p style="margin-top: 1em">Instead of a filename, a Tcl
file identifier may be provided by using the -open or
-leaveopen flags. This is similar to the spawn command. (See
spawn for more info.)</p>

<p style="margin-top: 1em">The -a flag forces output to be
logged that was suppressed by the log_user command.</p>

<p style="margin-top: 1em">By default, the log_file command
appends to old files rather than truncating them, for the
convenience of being able to turn logging off and on
multiple times in one ses&acirc; <br>
sion. To truncate files, use the -noappend flag.</p>

<p style="margin-top: 1em">The -info flag causes log_file
to return a description of the most recent non-info
arguments given.</p>

<p style="margin-top: 1em">log_user -info|0|1 <br>
By default, the send/expect dialogue is logged to stdout
(and a logfile if open). The logging to stdout is disabled
by the command &quot;log_user 0&quot; and reenabled by
&quot;log_user <br>
1&quot;. Logging to the logfile is unchanged.</p>

<p style="margin-top: 1em">The -info flag causes log_user
to return a description of the most recent non-info
arguments given.</p>

<p style="margin-top: 1em">match_max [-d] [-i spawn_id]
[size] <br>
defines the size of the buffer (in bytes) used internally by
expect. With no size argument, the current size is
returned.</p>

<p style="margin-top: 1em">With the -d flag, the default
size is set. (The initial default is 2000.) With the -i
flag, the size is set for the named spawn id, otherwise it
is set for the current <br>
process.</p>

<p style="margin-top: 1em">overlay [-# spawn_id] [-#
spawn_id] [...] program [args] <br>
executes program args in place of the current Expect
program, which terminates. A bare hyphen argument forces a
hyphen in front of the command name as if it was a login
<br>
shell. All spawn_ids are closed except for those named as
arguments. These are mapped onto the named file
identifiers.</p>

<p style="margin-top: 1em">Spawn_ids are mapped to file
identifiers for the new program to inherit. For example, the
following line runs chess and allows it to be controlled by
the current process - <br>
say, a chess master.</p>

<p style="margin-top: 1em">overlay -0 $spawn_id -1
$spawn_id -2 $spawn_id chess</p>

<p style="margin-top: 1em">This is more efficient than
&quot;interact -u&quot;, however, it sacrifices the ability
to do programmed interaction since the Expect process is no
longer in control.</p>

<p style="margin-top: 1em">Note that no controlling
terminal is provided. Thus, if you disconnect or remap
standard input, programs that do job control (shells, login,
etc) will not function prop&acirc; <br>
erly.</p>

<p style="margin-top: 1em">parity [-d] [-i spawn_id]
[value] <br>
defines whether parity should be retained or stripped from
the output of spawned processes. If value is zero, parity is
stripped, otherwise it is not stripped. With no <br>
value argument, the current value is returned.</p>

<p style="margin-top: 1em">With the -d flag, the default
parity value is set. (The initial default is 1, i.e., parity
is not stripped.) With the -i flag, the parity value is set
for the named spawn <br>
id, otherwise it is set for the current process.</p>

<p style="margin-top: 1em">remove_nulls [-d] [-i spawn_id]
[value] <br>
defines whether nulls are retained or removed from the
output of spawned processes before pattern matching or
storing in the variable expect_out or interact_out. If value
<br>
is 1, nulls are removed. If value is 0, nulls are not
removed. With no value argument, the current value is
returned.</p>

<p style="margin-top: 1em">With the -d flag, the default
value is set. (The initial default is 1, i.e., nulls are
removed.) With the -i flag, the value is set for the named
spawn id, otherwise it <br>
is set for the current process.</p>

<p style="margin-top: 1em">Whether or not nulls are
removed, Expect will record null bytes to the log and
stdout.</p>

<p style="margin-top: 1em">send [-flags] string <br>
Sends string to the current process. For example, the
command &quot;</p>

<p style="margin-top: 1em">send &quot;hello world</p>

<p style="margin-top: 1em">sends the characters, h e l l o
&lt;blank&gt; w o r l d &lt;return&gt; to the current
process. (Tcl includes a printf-like command (called format)
which can build arbitrarily complex <br>
strings.)</p>

<p style="margin-top: 1em">Characters are sent immediately
although programs with line-buffered input will not read the
characters until a return character is sent. A return
character is denoted&quot;. <br>
&quot;</p>

<p style="margin-top: 1em">The -- flag forces the next
argument to be interpreted as a string rather than a flag.
Any string can be preceded by &quot;--&quot; whether or not
it actually looks like a flag. <br>
This provides a reliable mechanism to specify variable
strings without being tripped up by those that accidentally
look like flags. (All strings starting with &quot;-&quot;
are <br>
reserved for future options.)</p>

<p style="margin-top: 1em">The -i flag declares that the
string be sent to the named spawn_id. If the spawn_id is
user_spawn_id, and the terminal is in raw mode, newlines in
the string are trans&acirc; <br>
lated to return-newline sequences so that they appear as if
the terminal was in cooked mode. The -raw flag disables this
translation.</p>

<p style="margin-top: 1em">The -null flag sends null
characters (0 bytes). By default, one null is sent. An
integer may follow the -null to indicate how many nulls to
send.</p>

<p style="margin-top: 1em">The -break flag generates a
break condition. This only makes sense if the spawn id
refers to a tty device opened via &quot;spawn -open&quot;.
If you have spawned a process such as <br>
tip, you should use tip&rsquo;s convention for generating a
break.</p>

<p style="margin-top: 1em">The -s flag forces output to be
sent &quot;slowly&quot;, thus avoid the common situation
where a computer outtypes an input buffer that was designed
for a human who would never out&acirc; <br>
type the same buffer. This output is controlled by the value
of the variable &quot;send_slow&quot; which takes a two
element list. The first element is an integer that describes
<br>
the number of bytes to send atomically. The second element
is a real number that describes the number of seconds by
which the atomic sends must be separated. For example, <br>
&quot;set send_slow {10 .001}&quot; would force &quot;send
-s&quot; to send strings with 1 millisecond in between each
10 characters sent.</p>

<p style="margin-top: 1em">The -h flag forces output to be
sent (somewhat) like a human actually typing. Human-like
delays appear between the characters. (The algorithm is
based upon a Weibull dis&acirc; <br>
tribution, with modifications to suit this particular
application.) This output is controlled by the value of the
variable &quot;send_human&quot; which takes a five element
list. <br>
The first two elements are average interarrival time of
characters in seconds. The first is used by default. The
second is used at word endings, to simulate the subtle <br>
pauses that occasionally occur at such transitions. The
third parameter is a measure of variability where .1 is
quite variable, 1 is reasonably variable, and 10 is quite
<br>
invariable. The extremes are 0 to infinity. The last two
parameters are, respectively, a minimum and maximum
interarrival time. The minimum and maximum are used last and
<br>
&quot;clip&quot; the final time. The ultimate average can be
quite different from the given average if the minimum and
maximum clip enough values.</p>

<p style="margin-top: 1em">As an example, the following
command emulates a fast and consistent typist:</p>

<p style="margin-top: 1em">set send_human {.1 .3 1 .05 2}
<br>
send -h &quot;I&rsquo;m hungry. Let&rsquo;s do
lunch.&quot;</p>

<p style="margin-top: 1em">while the following might be
more suitable after a hangover:</p>

<p style="margin-top: 1em">set send_human {.4 .4 .2 .5 100}
<br>
send -h &quot;Goodd party lash night!&quot;</p>

<p style="margin-top: 1em">Note that errors are not
simulated, although you can set up error correction
situations yourself by embedding mistakes and corrections in
a send argument.</p>

<p style="margin-top: 1em">The flags for sending null
characters, for sending breaks, for forcing slow output and
for human-style output are mutually exclusive. Only the one
specified last will be <br>
used. Furthermore, no string argument can be specified with
the flags for sending null characters or breaks.</p>

<p style="margin-top: 1em">It is a good idea to precede the
first send to a process by an expect. expect will wait for
the process to start, while send cannot. In particular, if
the first send com&acirc; <br>
pletes before the process starts running, you run the risk
of having your data ignored. In situations where interactive
programs offer no initial prompt, you can precede <br>
send by a delay as in:</p>

<p style="margin-top: 1em"># To avoid giving hackers hints
on how to break in, <br>
# this system does not prompt for an external password. <br>
# Wait for 5 seconds for exec to complete <br>
spawn telnet very.secure.gov <br>
sleep 5 <br>
send password</p>

<p style="margin-top: 1em">exp_send is an alias for send.
If you are using Expectk or some other variant of Expect in
the Tk environment, send is defined by Tk for an entirely
different purpose. <br>
exp_send is provided for compatibility between environments.
Similar aliases are provided for other Expect&rsquo;s other
send commands.</p>

<p style="margin-top: 1em">send_error [-flags] string <br>
is like send, except that the output is sent to stderr
rather than the current process.</p>

<p style="margin-top: 1em">send_log [--] string <br>
is like send, except that the string is only sent to the log
file (see log_file.) The arguments are ignored if no log
file is open.</p>

<p style="margin-top: 1em">send_tty [-flags] string <br>
is like send, except that the output is sent to /dev/tty
rather than the current process.</p>

<p style="margin-top: 1em">send_user [-flags] string <br>
is like send, except that the output is sent to stdout
rather than the current process.</p>

<p style="margin-top: 1em">sleep seconds <br>
causes the script to sleep for the given number of seconds.
Seconds may be a decimal number. Interrupts (and Tk events
if you are using Expectk) are processed while <br>
Expect sleeps.</p>

<p style="margin-top: 1em">spawn [args] program [args] <br>
creates a new process running program args. Its stdin,
stdout and stderr are connected to Expect, so that they may
be read and written by other Expect commands. The con&acirc;
<br>
nection is broken by close or if the process itself closes
any of the file identifiers.</p>

<p style="margin-top: 1em">When a process is started by
spawn, the variable spawn_id is set to a descriptor
referring to that process. The process described by spawn_id
is considered the current <br>
process. spawn_id may be read or written, in effect
providing job control.</p>

<p style="margin-top: 1em">user_spawn_id is a global
variable containing a descriptor which refers to the user.
For example, when spawn_id is set to this value, expect
behaves like expect_user.</p>

<p style="margin-top: 1em">error_spawn_id is a global
variable containing a descriptor which refers to the
standard error. For example, when spawn_id is set to this
value, send behaves like <br>
send_error.</p>

<p style="margin-top: 1em">tty_spawn_id is a global
variable containing a descriptor which refers to /dev/tty.
If /dev/tty does not exist (such as in a cron, at, or batch
script), then tty_spawn_id <br>
is not defined. This may be tested as:</p>

<p style="margin-top: 1em">if {[info vars tty_spawn_id]} {
<br>
# /dev/tty exists <br>
} else { <br>
# /dev/tty doesn&rsquo;t exist <br>
# probably in cron, batch, or at script <br>
}</p>

<p style="margin-top: 1em">spawn returns the UNIX process
id. If no process is spawned, 0 is returned. The variable
spawn_out(slave,name) is set to the name of the pty slave
device.</p>

<p style="margin-top: 1em">By default, spawn echoes the
command name and arguments. The -noecho flag stops spawn
from doing this.</p>

<p style="margin-top: 1em">The -console flag causes console
output to be redirected to the spawned process. This is not
supported on all systems.</p>

<p style="margin-top: 1em">Internally, spawn uses a pty,
initialized the same way as the user&rsquo;s tty. This is
further initialized so that all settings are
&quot;sane&quot; (according to stty(1)). If the vari&acirc;
<br>
able stty_init is defined, it is interpreted in the style of
stty arguments as further configuration. For example,
&quot;set stty_init raw&quot; will cause further spawned
pro&acirc; <br>
cesses&rsquo;s terminals to start in raw mode. -nottycopy
skips the initialization based on the user&rsquo;s tty.
-nottyinit skips the &quot;sane&quot; initialization.</p>

<p style="margin-top: 1em">Normally, spawn takes little
time to execute. If you notice spawn taking a significant
amount of time, it is probably encountering ptys that are
wedged. A number of tests <br>
are run on ptys to avoid entanglements with errant
processes. (These take 10 seconds per wedged pty.) Running
Expect with the -d option will show if Expect is
encounter&acirc; <br>
ing many ptys in odd states. If you cannot kill the
processes to which these ptys are attached, your only
recourse may be to reboot.</p>

<p style="margin-top: 1em">If program cannot be spawned
successfully because exec(2) fails (e.g. when program
doesn&rsquo;t exist), an error message will be returned by
the next interact or expect command <br>
as if program had run and produced the error message as
output. This behavior is a natural consequence of the
implementation of spawn. Internally, spawn forks, after <br>
which the spawned process has no way to communicate with the
original Expect process except by communication via the
spawn_id.</p>

<p style="margin-top: 1em">The -open flag causes the next
argument to be interpreted as a Tcl file identifier (i.e.,
returned by open.) The spawn id can then be used as if it
were a spawned process. <br>
(The file identifier should no longer be used.) This lets
you treat raw devices, files, and pipelines as spawned
processes without using a pty. 0 is returned to indicate
<br>
there is no associated process. When the connection to the
spawned process is closed, so is the Tcl file identifier.
The -leaveopen flag is similar to -open except that <br>
-leaveopen causes the file identifier to be left open even
after the spawn id is closed.</p>

<p style="margin-top: 1em">The -pty flag causes a pty to be
opened but no process spawned. 0 is returned to indicate
there is no associated process. Spawn_id is set as
usual.</p>

<p style="margin-top: 1em">The variable spawn_out(slave,fd)
is set to a file identifier corresponding to the pty slave.
It can be closed using &quot;close -slave&quot;.</p>

<p style="margin-top: 1em">The -ignore flag names a signal
to be ignored in the spawned process. Otherwise, signals get
the default behavior. Signals are named as in the trap
command, except that <br>
each signal requires a separate flag.</p>

<p style="margin-top: 1em">strace level <br>
causes following statements to be printed before being
executed. (Tcl&rsquo;s trace command traces variables.)
level indicates how far down in the call stack to trace. For
<br>
example, the following command runs Expect while tracing the
first 4 levels of calls, but none below that.</p>

<p style="margin-top: 1em">expect -c &quot;strace 4&quot;
script.exp</p>

<p style="margin-top: 1em">The -info flag causes strace to
return a description of the most recent non-info arguments
given.</p>

<p style="margin-top: 1em">stty args <br>
changes terminal modes similarly to the external stty
command.</p>

<p style="margin-top: 1em">By default, the controlling
terminal is accessed. Other terminals can be accessed by
appending &quot;&lt; /dev/tty...&quot; to the command. (Note
that the arguments should not be <br>
grouped into a single argument.)</p>

<p style="margin-top: 1em">Requests for status return it as
the result of the command. If no status is requested and the
controlling terminal is accessed, the previous status of the
raw and echo <br>
attributes are returned in a form which can later be used by
the command.</p>

<p style="margin-top: 1em">For example, the arguments raw
or -cooked put the terminal into raw mode. The arguments
-raw or cooked put the terminal into cooked mode. The
arguments echo and -echo put <br>
the terminal into echo and noecho mode respectively.</p>

<p style="margin-top: 1em">The following example
illustrates how to temporarily disable echoing. This could
be used in otherwise-automatic scripts to avoid embedding
passwords in them. (See more <br>
discussion on this under EXPECT HINTS below.)</p>

<p style="margin-top: 1em">stty -echo <br>
send_user &quot;Password: &quot; <br>
expect_user -re &quot;(.*)0 <br>
set password $expect_out(1,string) <br>
stty echo</p>

<p style="margin-top: 1em">system args <br>
gives args to sh(1) as input, just as if it had been typed
as a command from a terminal. Expect waits until the shell
terminates. The return status from sh is handled the <br>
same way that exec handles its return status.</p>

<p style="margin-top: 1em">In contrast to exec which
redirects stdin and stdout to the script, system performs no
redirection (other than that indicated by the string
itself). Thus, it is possible <br>
to use programs which must talk directly to /dev/tty. For
the same reason, the results of system are not recorded in
the log.</p>

<p style="margin-top: 1em">timestamp [args] <br>
returns a timestamp. With no arguments, the number of
seconds since the epoch is returned.</p>

<p style="margin-top: 1em">The -format flag introduces a
string which is returned but with substitutions made
according to the POSIX rules for strftime. For example %a is
replaced by an abbreviated <br>
weekday name (i.e., Sat). Others are: <br>
%a abbreviated weekday name <br>
%A full weekday name <br>
%b abbreviated month name <br>
%B full month name <br>
%c date-time as in: Wed Oct 6 11:45:56 1993 <br>
%d day of the month (01-31) <br>
%H hour (00-23) <br>
%I hour (01-12) <br>
%j day (001-366) <br>
%m month (01-12) <br>
%M minute (00-59) <br>
%p am or pm <br>
%S second (00-61) <br>
%u day (1-7, Monday is first day of week) <br>
%U week (00-53, first Sunday is first day of week one) <br>
%V week (01-53, ISO 8601 style) <br>
%w day (0-6) <br>
%W week (00-53, first Monday is first day of week one) <br>
%x date-time as in: Wed Oct 6 1993 <br>
%X time as in: 23:59:59 <br>
%y year (00-99) <br>
%Y year as in: 1993 <br>
%Z timezone (or nothing if not determinable) <br>
%% a bare percent sign</p>

<p style="margin-top: 1em">Other % specifications are
undefined. Other characters will be passed through
untouched. Only the C locale is supported.</p>

<p style="margin-top: 1em">The -seconds flag introduces a
number of seconds since the epoch to be used as a source
from which to format. Otherwise, the current time is
used.</p>

<p style="margin-top: 1em">The -gmt flag forces timestamp
output to use the GMT timezone. With no flag, the local
timezone is used.</p>

<p style="margin-top: 1em">trap [[command] signals] <br>
causes the given command to be executed upon future receipt
of any of the given signals. The command is executed in the
global scope. If command is absent, the signal <br>
action is returned. If command is the string SIG_IGN, the
signals are ignored. If command is the string SIG_DFL, the
signals are result to the system default. signals is <br>
either a single signal or a list of signals. Signals may be
specified numerically or symbolically as per signal(3). The
&quot;SIG&quot; prefix may be omitted.</p>

<p style="margin-top: 1em">With no arguments (or the
argument -number), trap returns the signal number of the
trap command currently being executed.</p>

<p style="margin-top: 1em">The -code flag uses the return
code of the command in place of whatever code Tcl was about
to return when the command originally started running.</p>

<p style="margin-top: 1em">The -interp flag causes the
command to be evaluated using the interpreter active at the
time the command started running rather than when the trap
was declared.</p>

<p style="margin-top: 1em">The -name flag causes the trap
command to return the signal name of the trap command
currently being executed.</p>

<p style="margin-top: 1em">The -max flag causes the trap
command to return the largest signal number that can be
set.</p>

<p style="margin-top: 1em">For example, the command
&quot;trap {send_user &quot;Ouch!&quot;} SIGINT&quot; will
print &quot;Ouch!&quot; each time the user presses ^C.</p>

<p style="margin-top: 1em">By default, SIGINT (which can
usually be generated by pressing ^C) and SIGTERM cause
Expect to exit. This is due to the following trap, created
by default when Expect <br>
starts.</p>

<p style="margin-top: 1em">trap exit {SIGINT SIGTERM}</p>

<p style="margin-top: 1em">If you use the -D flag to start
the debugger, SIGINT is redefined to start the interactive
debugger. This is due to the following trap:</p>

<p style="margin-top: 1em">trap {exp_debug 1} SIGINT</p>

<p style="margin-top: 1em">The debugger trap can be changed
by setting the environment variable EXPECT_DEBUG_INIT to a
new trap command.</p>

<p style="margin-top: 1em">You can, of course, override
both of these just by adding trap commands to your script.
In particular, if you have your own &quot;trap exit
SIGINT&quot;, this will override the <br>
debugger trap. This is useful if you want to prevent users
from getting to the debugger at all.</p>

<p style="margin-top: 1em">If you want to define your own
trap on SIGINT but still trap to the debugger when it is
running, use:</p>

<p style="margin-top: 1em">if {![exp_debug]} {trap mystuff
SIGINT}</p>

<p style="margin-top: 1em">Alternatively, you can trap to
the debugger using some other signal.</p>

<p style="margin-top: 1em">trap will not let you override
the action for SIGALRM as this is used internally to Expect.
The disconnect command sets SIGALRM to SIG_IGN (ignore). You
can reenable this <br>
as long as you disable it during subsequent spawn
commands.</p>

<p style="margin-top: 1em">See signal(3) for more info.</p>

<p style="margin-top: 1em">wait [args] <br>
delays until a spawned process (or the current process if
none is named) terminates.</p>

<p style="margin-top: 1em">wait normally returns a list of
four integers. The first integer is the pid of the process
that was waited upon. The second integer is the
corresponding spawn id. The <br>
third integer is -1 if an operating system error occurred,
or 0 otherwise. If the third integer was 0, the fourth
integer is the status returned by the spawned process. <br>
If the third integer was -1, the fourth integer is the value
of errno set by the operating system. The global variable
errorCode is also set.</p>

<p style="margin-top: 1em">Additional elements may appear
at the end of the return value from wait. An optional fifth
element identifies a class of information. Currently, the
only possible value <br>
for this element is CHILDKILLED in which case the next two
values are the C-style signal name and a short textual
description.</p>

<p style="margin-top: 1em">The -i flag declares the process
to wait corresponding to the named spawn_id (NOT the process
id). Inside a SIGCHLD handler, it is possible to wait for
any spawned process <br>
by using the spawn id -1.</p>

<p style="margin-top: 1em">The -nowait flag causes the wait
to return immediately with the indication of a successful
wait. When the process exits (later), it will automatically
disappear without <br>
the need for an explicit wait.</p>

<p style="margin-top: 1em">The wait command may also be
used wait for a forked process using the arguments &quot;-i
-1&quot;. Unlike its use with spawned processes, this
command can be executed at any time. <br>
There is no control over which process is reaped. However,
the return value can be checked for the process id.</p>

<p style="margin-top: 1em">LIBRARIES <br>
Expect automatically knows about two built-in libraries for
Expect scripts. These are defined by the directories named
in the variables exp_library and exp_exec_library. Both <br>
are meant to contain utility files that can be used by other
scripts.</p>

<p style="margin-top: 1em">exp_library contains
architecture-independent files. exp_exec_library contains
architecture-dependent files. Depending on your system, both
directories may be totally empty. <br>
The existence of the file $exp_exec_library/cat-buffers
describes whether your /bin/cat buffers by default.</p>

<p style="margin-top: 1em">PRETTY-PRINTING <br>
A vgrind definition is available for pretty-printing Expect
scripts. Assuming the vgrind definition supplied with the
Expect distribution is correctly installed, you can use it
<br>
as:</p>

<p style="margin-top: 1em">vgrind -lexpect file</p>

<p style="margin-top: 1em">EXAMPLES <br>
It many not be apparent how to put everything together that
the man page describes. I encourage you to read and try out
the examples in the example directory of the Expect
dis&acirc; <br>
tribution. Some of them are real programs. Others are simply
illustrative of certain techniques, and of course, a couple
are just quick hacks. The INSTALL file has a quick <br>
overview of these programs.</p>

<p style="margin-top: 1em">The Expect papers (see SEE ALSO)
are also useful. While some papers use syntax corresponding
to earlier versions of Expect, the accompanying rationales
are still valid and go <br>
into a lot more detail than this man page.</p>

<p style="margin-top: 1em">CAVEATS <br>
Extensions may collide with Expect&rsquo;s command names.
For example, send is defined by Tk for an entirely different
purpose. For this reason, most of the Expect commands are
also <br>
available as &quot;exp_XXXX&quot;. Commands and variables
beginning with &quot;exp&quot;, &quot;inter&quot;,
&quot;spawn&quot;, and &quot;timeout&quot; do not have
aliases. Use the extended command names if you need this
com&acirc; <br>
patibility between environments.</p>

<p style="margin-top: 1em">Expect takes a rather liberal
view of scoping. In particular, variables read by commands
specific to the Expect program will be sought first from the
local scope, and if not <br>
found, in the global scope. For example, this obviates the
need to place &quot;global timeout&quot; in every procedure
you write that uses expect. On the other hand, variables
written <br>
are always in the local scope (unless a &quot;global&quot;
command has been issued). The most common problem this
causes is when spawn is executed in a procedure. Outside the
procedure, <br>
spawn_id no longer exists, so the spawned process is no
longer accessible simply because of scoping. Add a
&quot;global spawn_id&quot; to such a procedure.</p>

<p style="margin-top: 1em">If you cannot enable the
multispawning capability (i.e., your system supports neither
select (BSD *.*), poll (SVR&gt;2), nor something
equivalent), Expect will only be able to con&acirc; <br>
trol a single process at a time. In this case, do not
attempt to set spawn_id, nor should you execute processes
via exec while a spawned process is running. Furthermore,
you <br>
will not be able to expect from multiple processes
(including the user as one) at the same time.</p>

<p style="margin-top: 1em">Terminal parameters can have a
big effect on scripts. For example, if a script is written
to look for echoing, it will misbehave if echoing is turned
off. For this reason, <br>
Expect forces sane terminal parameters by default.
Unfortunately, this can make things unpleasant for other
programs. As an example, the emacs shell wants to change the
&quot;usual&quot; <br>
mappings: newlines get mapped to newlines instead of
carriage-return newlines, and echoing is disabled. This
allows one to use emacs to edit the input line.
Unfortunately, <br>
Expect cannot possibly guess this.</p>

<p style="margin-top: 1em">You can request that Expect not
override its default setting of terminal parameters, but you
must then be very careful when writing scripts for such
environments. In the case of <br>
emacs, avoid depending upon things like echoing and
end-of-line mappings.</p>

<p style="margin-top: 1em">The commands that accepted
arguments braced into a single list (the expect variants and
interact) use a heuristic to decide if the list is actually
one argument or many. The <br>
heuristic can fail only in the case when the list actually
does represent a single argument which has multiple embedded
0s with non-whitespace characters between them. This <br>
seems sufficiently improbable, however the argument
&quot;-nobrace&quot; can be used to force a single argument
to be handled as a single argument. This could conceivably
be used with <br>
machine-generated Expect code. Similarly, -brace forces a
single argument to be handle as multiple
patterns/actions.</p>

<p style="margin-top: 1em">BUGS <br>
It was really tempting to name the program &quot;sex&quot;
(for either &quot;Smart EXec&quot; or
&quot;Send-EXpect&quot;), but good sense (or perhaps just
Puritanism) prevailed.</p>

<p style="margin-top: 1em">On some systems, when a shell is
spawned, it complains about not being able to access the tty
but runs anyway. This means your system has a mechanism for
gaining the controlling <br>
tty that Expect doesn&rsquo;t know about. Please find out
what it is, and send this information back to me.</p>

<p style="margin-top: 1em">Ultrix 4.1 (at least the latest
versions around here) considers timeouts of above 1000000 to
be equivalent to 0.</p>

<p style="margin-top: 1em">Digital UNIX 4.0A (and probably
other versions) refuses to allocate ptys if you define a
SIGCHLD handler. See grantpt page for more info.</p>

<p style="margin-top: 1em">IRIX 6.0 does not handle pty
permissions correctly so that if Expect attempts to allocate
a pty previously used by someone else, it fails. Upgrade to
IRIX 6.1.</p>

<p style="margin-top: 1em">Telnet (verified only under
SunOS 4.1.2) hangs if TERM is not set. This is a problem
under cron, at and in cgi scripts, which do not define TERM.
Thus, you must set it explic&acirc; <br>
itly - to what type is usually irrelevant. It just has to be
set to something! The following probably suffices for most
cases.</p>

<p style="margin-top: 1em">set env(TERM) vt100</p>

<p style="margin-top: 1em">Tip (verified only under BSDI
BSD/OS 3.1 i386) hangs if SHELL and HOME are not set. This
is a problem under cron, at and in cgi scripts, which do not
define these environment <br>
variables. Thus, you must set them explicitly - to what type
is usually irrelevant. It just has to be set to something!
The following probably suffices for most cases.</p>

<p style="margin-top: 1em">set env(SHELL) /bin/sh <br>
set env(HOME) /usr/local/bin</p>

<p style="margin-top: 1em">Some implementations of ptys are
designed so that the kernel throws away any unread output
after 10 to 15 seconds (actual number is
implementation-dependent) after the process <br>
has closed the file descriptor. Thus Expect programs such
as</p>

<p style="margin-top: 1em">spawn date <br>
sleep 20 <br>
expect</p>

<p style="margin-top: 1em">will fail. To avoid this, invoke
non-interactive programs with exec rather than spawn. While
such situations are conceivable, in practice I have never
encountered a situation <br>
in which the final output of a truly interactive program
would be lost due to this behavior.</p>

<p style="margin-top: 1em">On the other hand, Cray UNICOS
ptys throw away any unread output immediately after the
process has closed the file descriptor. I have reported this
to Cray and they are working <br>
on a fix.</p>

<p style="margin-top: 1em">Sometimes a delay is required
between a prompt and a response, such as when a tty
interface is changing UART settings or matching baud rates
by looking for start/stop bits. Usu&acirc; <br>
ally, all this is require is to sleep for a second or two. A
more robust technique is to retry until the hardware is
ready to receive input. The following example uses both <br>
strategies: &quot;;</p>

<p style="margin-top: 1em">send &quot;speed 9600 <br>
sleep 1 <br>
expect { &quot;; exp_continue} <br>
timeout {send &quot; <br>
$prompt <br>
}</p>

<p style="margin-top: 1em">trap -code will not work with
any command that sits in Tcl&rsquo;s event loop, such as
sleep. The problem is that in the event loop, Tcl discards
the return codes from async event <br>
handlers. A workaround is to set a flag in the trap code.
Then check the flag immediately after the command (i.e.,
sleep).</p>

<p style="margin-top: 1em">The expect_background command
ignores -timeout arguments and has no concept of timeouts in
general.</p>

<p style="margin-top: 1em">EXPECT HINTS <br>
There are a couple of things about Expect that may be
non-intuitive. This section attempts to address some of
these things with a couple of suggestions.</p>

<p style="margin-top: 1em">A common expect problem is how
to recognize shell prompts. Since these are customized
differently by differently people and different shells,
portably automating rlogin can be <br>
difficult without knowing the prompt. A reasonable
convention is to have users store a regular expression
describing their prompt (in particular, the end of it) in
the environ&acirc; <br>
ment variable EXPECT_PROMPT. Code like the following can be
used. If EXPECT_PROMPT doesn&rsquo;t exist, the code still
has a good chance of functioning correctly.</p>

<p style="margin-top: 1em">set prompt &quot;(%|#|\$)
$&quot; ;# default prompt <br>
catch {set prompt $env(EXPECT_PROMPT)}</p>

<p style="margin-top: 1em">expect -re $prompt</p>

<p style="margin-top: 1em">I encourage you to write expect
patterns that include the end of whatever you expect to see.
This avoids the possibility of answering a question before
seeing the entire thing. <br>
In addition, while you may well be able to answer questions
before seeing them entirely, if you answer early, your
answer may appear echoed back in the middle of the question.
<br>
In other words, the resulting dialogue will be correct but
look scrambled.</p>

<p style="margin-top: 1em">Most prompts include a space
character at the end. For example, the prompt from ftp is
&rsquo;f&rsquo;, &rsquo;t&rsquo;, &rsquo;p&rsquo;,
&rsquo;&gt;&rsquo; and &lt;blank&gt;. To match this prompt,
you must account for each of these <br>
characters. It is a common mistake not to include the blank.
Put the blank in explicitly.</p>

<p style="margin-top: 1em">If you use a pattern of the form
X*, the * will match all the output received from the end of
X to the last thing received. This sounds intuitive but can
be somewhat confusing <br>
because the phrase &quot;last thing received&quot; can vary
depending upon the speed of the computer and the processing
of I/O both by the kernel and the device driver.</p>

<p style="margin-top: 1em">In particular, humans tend to
see program output arriving in huge chunks (atomically) when
in reality most programs produce output one line at a time.
Assuming this is the case, <br>
the * in the pattern of the previous paragraph may only
match the end of the current line even though there seems to
be more, because at the time of the match that was all the
<br>
output that had been received.</p>

<p style="margin-top: 1em">expect has no way of knowing
that further output is coming unless your pattern
specifically accounts for it.</p>

<p style="margin-top: 1em">Even depending on line-oriented
buffering is unwise. Not only do programs rarely make
promises about the type of buffering they do, but system
indigestion can break output lines <br>
up so that lines break at seemingly random places. Thus, if
you can express the last few characters of a prompt when
writing patterns, it is wise to do so.</p>

<p style="margin-top: 1em">If you are waiting for a pattern
in the last output of a program and the program emits
something else instead, you will not be able to detect that
with the timeout keyword. The <br>
reason is that expect will not timeout - instead it will get
an eof indication. Use that instead. Even better, use both.
That way if that line is ever moved around, you won&rsquo;t
<br>
have to edit the line itself.</p>

<p style="margin-top: 1em">Newlines are usually converted
to carriage return, linefeed sequences when output by the
terminal driver. Thus, if you want a pattern that explicitly
matches the two lines, <br>
from, say, printf(&quot;foo0ar&quot;), you should use the
pattern0ar&quot;. &quot;foo</p>

<p style="margin-top: 1em">A similar translation occurs
when reading from the user, via expect_user. In this case,
when you press return, it will be translated to a newline.
If Expect then passes that to <br>
a program which sets its terminal to raw mode (like telnet),
there is going to be a problem, as the program expects a
true return. (Some programs are actually forgiving in that
<br>
they will automatically translate newlines to returns, but
most don&rsquo;t.) Unfortunately, there is no way to find
out that a program put its terminal into raw mode.</p>

<p style="margin-top: 1em">Rather than manually replacing
newlines with returns, the solution is to use the command
&quot;stty raw&quot;, which will stop the translation. Note,
however, that this means that you <br>
will no longer get the cooked line-editing features.</p>

<p style="margin-top: 1em">interact implicitly sets your
terminal to raw mode so this problem will not arise
then.</p>

<p style="margin-top: 1em">It is often useful to store
passwords (or other private information) in Expect scripts.
This is not recommended since anything that is stored on a
computer is susceptible to <br>
being accessed by anyone. Thus, interactively prompting for
passwords from a script is a smarter idea than embedding
them literally. Nonetheless, sometimes such embedding is
<br>
the only possibility.</p>

<p style="margin-top: 1em">Unfortunately, the UNIX file
system has no direct way of creating scripts which are
executable but unreadable. Systems which support setgid
shell scripts may indirectly simulate <br>
this as follows:</p>

<p style="margin-top: 1em">Create the Expect script (that
contains the secret data) as usual. Make its permissions be
750 (-rwxr-x---) and owned by a trusted group, i.e., a group
which is allowed to read <br>
it. If necessary, create a new group for this purpose. Next,
create a /bin/sh script with permissions 2751 (-rwxr-s--x)
owned by the same group as before.</p>

<p style="margin-top: 1em">The result is a script which may
be executed (and read) by anyone. When invoked, it runs the
Expect script.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Tcl(3), libexpect(3) <br>
&quot;Exploring Expect: A Tcl-Based Toolkit for Automating
Interactive Programs&quot; by Don Libes, pp. 602, ISBN
1-56592-090-2, O&rsquo;Reilly and Associates, 1995. <br>
&quot;expect: Curing Those Uncontrollable Fits of
Interactivity&quot; by Don Libes, Proceedings of the Summer
1990 USENIX Conference, Anaheim, California, June 11-15,
1990. <br>
&quot;Using expect to Automate System Administration
Tasks&quot; by Don Libes, Proceedings of the 1990 USENIX
Large Installation Systems Administration Conference,
Colorado Springs, Col&acirc; <br>
orado, October 17-19, 1990. <br>
&quot;Tcl: An Embeddable Command Language&quot; by John
Ousterhout, Proceedings of the Winter 1990 USENIX
Conference, Washington, D.C., January 22-26, 1990. <br>
&quot;expect: Scripts for Controlling Interactive
Programs&quot; by Don Libes, Computing Systems, Vol. 4, No.
2, University of California Press Journals, November 1991.
<br>
&quot;Regression Testing and Conformance Testing Interactive
Programs&quot;, by Don Libes, Proceedings of the Summer 1992
USENIX Conference, pp. 135-144, San Antonio, TX, June 12-15,
1992. <br>
&quot;Kibitz - Connecting Multiple Interactive Programs
Together&quot;, by Don Libes, Software - Practice &amp;
Experience, John Wiley &amp; Sons, West Sussex, England,
Vol. 23, No. 5, May, 1993. <br>
&quot;A Debugger for Tcl Applications&quot;, by Don Libes,
Proceedings of the 1993 Tcl/Tk Workshop, Berkeley, CA, June
10-11, 1993.</p>

<p style="margin-top: 1em">AUTHOR <br>
Don Libes, National Institute of Standards and
Technology</p>

<p style="margin-top: 1em">ACKNOWLEDGMENTS <br>
Thanks to John Ousterhout for Tcl, and Scott Paisley for
inspiration. Thanks to Rob Savoye for Expect&rsquo;s
autoconfiguration code.</p>

<p style="margin-top: 1em">The HISTORY file documents much
of the evolution of expect. It makes interesting reading and
might give you further insight to this software. Thanks to
the people mentioned in <br>
it who sent me bug fixes and gave other assistance.</p>

<p style="margin-top: 1em">Design and implementation of
Expect was paid for in part by the U.S. government and is
therefore in the public domain. However the author and NIST
would like credit if this pro&acirc; <br>
gram and documentation or portions of them are used.</p>

<p style="margin-top: 1em">29 December 1994 EXPECT(1)</p>
<hr>
</body>
</html>
