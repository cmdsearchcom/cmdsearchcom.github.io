<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:09:56 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FILEPP(1) General Commands Manual FILEPP(1)</p>

<p style="margin-top: 1em">NAME <br>
filepp - A generic file preprocessor</p>

<p style="margin-top: 1em">SYNOPSIS <br>
filepp [options] filename(s)</p>

<p style="margin-top: 1em">DESCRIPTION <br>
filepp is a generic file preprocessor designed to allow the
functionality provided by the C preprocessor cpp(1) to be
used with any file type. filepp is designed to be easily
<br>
customised and extended.</p>

<p style="margin-top: 1em">OPTIONS <br>
filepp accepts the following command line options:</p>

<p style="margin-top: 1em">-b Suppress blank lines
originating from include files (this has no effect on the
top-level file).</p>

<p style="margin-top: 1em">-c Read input from STDIN instead
of a file. Note: if both -c and input files are specified,
both are used as inputs in the order given.</p>

<p style="margin-top: 1em">-Dmacro <br>
Predefine macro to have a definition of &lsquo;1&rsquo;.</p>

<p style="margin-top: 1em">-Dmacro=defn <br>
Predefine macro to have a definition of defn.</p>

<p style="margin-top: 1em">-d Output debugging
information.</p>

<p style="margin-top: 1em">-dd Output verbose debugging
information. This option shows all normal debugging
information, plus the full list of defined macros every time
the list changes.</p>

<p style="margin-top: 1em">-dl Output light debugging
information. This option shows minimal debugging
information.</p>

<p style="margin-top: 1em">-dprechar <br>
Prefix all debugging information with char (can be character
or string), can be used to make debugging easier to
read.</p>

<p style="margin-top: 1em">-dpostchar <br>
Postfix all debugging information with char (can be
character or string), this defaults to a newline. If char
does not contain a newline, then no newline will be printed
<br>
after debugging messages. (Newlines can be put in char using
the __NEWLINE__ macro.)</p>

<p style="margin-top: 1em">-ds Print debugging info on
stdout rather than stderr.</p>

<p style="margin-top: 1em">-e Define all environment
variables as macros with prefix envchar.</p>

<p style="margin-top: 1em">-ec char <br>
Set envchar (prefix of environment variables defined as
macros) to char, defaults to $. (Note: this option only
takes effect at the time the environment variables are
con&acirc; <br>
verted to macros).</p>

<p style="margin-top: 1em">-ecn Set envchar (prefix of
environment variables defined as macros) to nothing (no
prefix).</p>

<p style="margin-top: 1em">-h Show summary of options.</p>

<p style="margin-top: 1em">-Idir Append directory dir to
the list of directories searched for include files.</p>

<p style="margin-top: 1em">-imacros file <br>
Reads in macros from file, but discards everything else in
the file.</p>

<p style="margin-top: 1em">-k Turn off parsing of all
keywords. This is useful if you just want to use the macro
expansion facilities of filepp. With this option all
keywords found will be ignored, <br>
filepp will just replace any macros specified with the
-Dmacro=defn option.</p>

<p style="margin-top: 1em">-kc char <br>
Set keyword prefix character to char (can also be a string).
All filepp keywords are prefixed with the character # by
default. This option allows the prefix to be <br>
changed to something else.</p>

<p style="margin-top: 1em">-lc char <br>
Set line continuation character to char (can also be a
string). When the line continuation character is found with
a newline following it, it and the newline are replaced <br>
by the line continuation replacement character. Default is
&nbsp;(cpp(1) style).</p>

<p style="margin-top: 1em">-lec char <br>
Set optional keyword line end character to char (can also be
a string). This allows extra characters to be placed at the
end of a line containing a keyword. The extra <br>
characters will be ignored. This is useful if keywords are
to be embedded in HTML or C style comments. For example, to
embed keywords in an HTML comment the keyword pre&acirc;
<br>
fix character could be set to &lt;--!# and the optional
keyword line end character set to --&gt;. An example keyword
would then be:</p>

<p style="margin-top: 1em">&lt;!--#include
&quot;header.h&quot; --&gt;</p>

<p style="margin-top: 1em">In the case the optional keyword
line end characters --&gt; would be ignored.</p>

<p style="margin-top: 1em">-lr char <br>
Set line continuation replacement character to char (can
also be a string). Default is a null string (cpp(1)
style).</p>

<p style="margin-top: 1em">-lrn Set line continuation
replacement character to be a newline.</p>

<p style="margin-top: 1em">-m module.pm <br>
Load module module.pm. module.pm is a perl(1) module which
can be used to extend or modify the behaviour of filepp. See
section FILEPP MODULES for details of modules <br>
included with filepp and FILEPP MODULE API for details on
how to write your own modules.</p>

<p style="margin-top: 1em">-Mdir Append directory dir to
the list of directories searched for filepp modules. This
list defaults to the directory the filepp modules are
installed (if any) plus the <br>
default Perl module paths. (Note: this adds the directory to
the Perl @INC list.)</p>

<p style="margin-top: 1em">-mp char <br>
Prefix all macros with char. Macros are defined in the
normal way, but will only be replaced when found prefixed
with char. For example, filepp macros will behave
simi&acirc; <br>
lar to Bourne shell (sh(1)) variables if char is set to
$.</p>

<p style="margin-top: 1em">-mpnk Turns off macro prefixes
within keywords. When using a macro prefix character this
option allows macros to be used without the prefix in
keyword processing. For example, <br>
if the macro prefix is $ then and #if would be written
as:</p>

<p style="margin-top: 1em">#if $MACRO == 1</p>

<p style="margin-top: 1em">Using the mpnk option allows the
#if to be written as:</p>

<p style="margin-top: 1em">#if MACRO == 1</p>

<p style="margin-top: 1em">-o name <br>
Write output to name instead of STDOUT. If there is only one
input file and it has the same name as the output file, the
original input file will be backed-up as name~.</p>

<p style="margin-top: 1em">-ov Overwrite mode, causes the
output file to overwrite the input file. Useful when
modifying a large number of files at once, eg:</p>

<p style="margin-top: 1em">filepp -ov -DTHIS=THAT *</p>

<p style="margin-top: 1em">The original input file(s) will
be backed-up as name~.</p>

<p style="margin-top: 1em">-ovc IN=OUT <br>
Similar to overwrite mode, the difference is the output
filename is input filename with IN part converted to OUT.
For example, to process a set of files all ending with <br>
.in and have the output files all ending in .out do:</p>

<p style="margin-top: 1em">filepp -ovc .in=.out *.in</p>

<p style="margin-top: 1em">In this case a file called
test.in will be processed and the output file will be
test.out. Note: if the input file does not contain IN then
the output file will have the <br>
same name as the input file and the original input file(s)
will be backed-up as name~!</p>

<p style="margin-top: 1em">-pb Preserve blank lines. Using
this option attempts to keep as many lines in the output
file as are in the input file, so all blank lines which
normally would not get <br>
printed are printed. Useful when comparing intput file with
output.</p>

<p style="margin-top: 1em">-re Treat keyword and macro
prefix characters and line continuation character as Perl
regular expressions instead of normal strings.</p>

<p style="margin-top: 1em">-s Run filepp in safe mode. This
turns off the pragma keyword.</p>

<p style="margin-top: 1em">-Umacro <br>
Undefine previously defined macro.</p>

<p style="margin-top: 1em">-u Undefine all currently
defined macros, including predefined ones.</p>

<p style="margin-top: 1em">-v Show version of program.</p>

<p style="margin-top: 1em">-w Turn on word boundaries when
replacing macros. When word boundaries are on, macros will
only be replaced if the macro appears in the text as a word.
For example, by <br>
default macro would be replaced in both cases of the
following text:</p>

<p style="margin-top: 1em">macro as word, macroNOTaword</p>

<p style="margin-top: 1em">but only the first occurrence
would be replaced with the -w option.</p>

<p style="margin-top: 1em">With this option enabled filepp
will only replace macros which contain alphanumeric
characters. International (non-ASCII) character sets can be
supported using Perl&rsquo;s <br>
locale handling.</p>

<p style="margin-top: 1em">KEYWORDS <br>
filepp supports the following keywords:</p>

<p style="margin-top: 1em">#include &lt;FILE&gt; <br>
Include a file in the file being processed. This variant is
used for &quot;system&quot; include files. It searches for a
file named FILE in a list of directories specified by you.
<br>
Directories are specified with the command option
&lsquo;-I&rsquo;. filepp does not predefine any system
directories in which to search for files.</p>

<p style="margin-top: 1em">#include &quot;FILE&quot; <br>
Include a file in the file being processed. This variant is
used for include files of your own project. It searches for
a file named FILE first in the current directory, <br>
then in the list of directories specified with the command
option &lsquo;-I&rsquo;. The current directory is the
directory the base input file is in.</p>

<p style="margin-top: 1em">#define macro <br>
Define the macro macro to have a definition of
&lsquo;1&rsquo;. macro can then be used with the keywords
#ifdef and #ifndef.</p>

<p style="margin-top: 1em">#define macro defn <br>
Define the macro macro to have the value defn. macro can
then be used with the keywords #ifdef and #ifndef. Also, all
instances of macro following the #define statement <br>
will be replaced with the string defn. The string defn is
taken to be all the characters on the line following
macro.</p>

<p style="margin-top: 1em">#define macro(arg1, arg2, ...)
defn <br>
Define the macro macro to have the value defn with arguments
(arg1, arg2, ...). macro can be used as follows:</p>

<p style="margin-top: 1em">#define macro(foo) defn with foo
in</p>

<p style="margin-top: 1em">Now when replacing occurs:</p>

<p style="margin-top: 1em">macro(bar)</p>

<p style="margin-top: 1em">will become:</p>

<p style="margin-top: 1em">defn with bar in</p>

<p style="margin-top: 1em">Macros can have any number of
comma separated arguments.</p>

<p style="margin-top: 1em">Macros can also have variable
numbers of arguments if the final macro ends in ..., for
example:</p>

<p style="margin-top: 1em">#define error(string, args...)
fprintf(stderr, string, args);</p>

<p style="margin-top: 1em">Here the first argument given
becomes string and all other arguments will become args. If
called as: error(&quot;%d,%s&quot;, i, string) it will
give</p>

<p style="margin-top: 1em">fprintf(stderr,
&quot;%d,%s&quot;, i, string);</p>

<p style="margin-top: 1em">Also, if a macro with a variable
number of arguments is passed no arguments for the variable
argument, then commas can be optionally removed from the
definition by preced&acirc; <br>
ing the definition with &quot;##&quot;. For example:</p>

<p style="margin-top: 1em">#define error(string, args...)
fprintf(stderr, string, ##args);</p>

<p style="margin-top: 1em">If this is called as:
error(&quot;empty&quot;) then result will be:</p>

<p style="margin-top: 1em">fprintf(stderr,
&quot;empty&quot;);</p>

<p style="margin-top: 1em">The comma immediately before
##args has been removed.</p>

<p style="margin-top: 1em">#if expr <br>
A conditional statement, expr will be evaluated to true (1)
or false (0). If expr evaluates to true, the text between
the #if and the next #else or #endif will be <br>
included. If expr evaluates to false, the text between the
#if and the next #else or #endif will be ignored. expr can
use all the usual cpp style comparisons (==, !=, &lt;, <br>
&gt;, etc.). Multiple comparisons can be combined with and
(&amp;&amp;) and or (||). The defined keyword can also be
used to check if macros are defined. For example:</p>

<p style="margin-top: 1em">#if defined macro &amp;&amp;
macro == defn</p>

<p style="margin-top: 1em">Note: filepp&rsquo;s #if does
not work in exactly the same way as cpp(1)&rsquo;s #if.
cpp(1)&rsquo;s #if only does numerical style comparisons.
Filepp&rsquo;s #if statement can also compare <br>
strings and regular expressions using perl(1)&rsquo;s full
range of comaprison operations. For example, to test if two
strings are exactly equal use:</p>

<p style="margin-top: 1em">#if &quot;MACRO&quot; eq
&quot;string&quot;</p>

<p style="margin-top: 1em">To test if strings are not equal
use ne instead of eq. Regular expressions can also be
tested, for example to test if a macro has any whitespace in
it use:</p>

<p style="margin-top: 1em">#if &quot;MACRO&quot; =~ /</p>

<p style="margin-top: 1em">To test if a macro does not have
any whitespace in it =~ can be replaced with !~.</p>

<p style="margin-top: 1em">Perl experts: #if works by first
parsing expr for the defined keyword and checking if the
macro it refers to is defined, replacing it with 1 if it is
and 0 if it isn&rsquo;t. <br>
It then checks expr for any other macros and replaces them
with their definition. Finally it passes expr through
Perl&rsquo;s eval function, which returns true or false.</p>

<p style="margin-top: 1em">#elif expr <br>
#elif stands for &quot;else if&quot;. Like #else, it goes in
the middle of a #if[n][def]-#endif pair and subdivides it;
it does not require a matching #endif of its own. Like #if,
<br>
the #elif directive includes an expression to be tested.</p>

<p style="margin-top: 1em">#ifdef macro <br>
A conditional statement, if macro has been defined the text
between the #ifdef and the next #else or #endif will be
included. If macro has not been defined the text <br>
between the #ifdef and the next #else or #endif will be
ignored.</p>

<p style="margin-top: 1em">#ifndef macro <br>
The reverse case of the #ifdef conditional.</p>

<p style="margin-top: 1em">#else The #else directive can be
added to a conditional to provide alternative text to be
used if the condition is false.</p>

<p style="margin-top: 1em">#endif Used to terminate a
conditional statement. Normal processing resumes following
the #endif.</p>

<p style="margin-top: 1em">#undef macro <br>
Undefine a previously defined macro.</p>

<p style="margin-top: 1em">#error mesg <br>
Causes filepp to exit with the error message mesg.</p>

<p style="margin-top: 1em">#warning mesg <br>
Causes filepp to issue the warning message mesg.</p>

<p style="margin-top: 1em">#comment mesg <br>
As filepp is supposed to be a generic file preprocessor, it
cannot support any known comment styles, therefore it
defines its own with this keyword. All lines starting <br>
with #comment are treated as comments and removed by
filepp.</p>

<p style="margin-top: 1em">#pragma filepp function arg1,
arg2, ... <br>
The #pragma keyword immediately followed by the word filepp
allows the user to execute a Perl function during parsing.
The word immediately following filepp is taken as <br>
the name of the function and the remainder of the line is
taken to be a comma separated list of arguments to the
function. Any of the filepp internal functions (see
sec&acirc; <br>
tion FILEPP MODULE API) can be called with the #pragma
keyword.</p>

<p style="margin-top: 1em">Warning: There are obvious
security risks with allowing arbitrary functions to be run,
so the -s (safe mode) command line option has been added
which turns the #pragma <br>
keyword off.</p>

<p style="margin-top: 1em">PREDEFINED MACROS <br>
filepp supports a set of predefined macros. All the
predefined macros are of the form __MACRO__, where MACRO
is:</p>

<p style="margin-top: 1em">FILE This macro expands to the
name of the current input file.</p>

<p style="margin-top: 1em">LINE This macro expands to the
current input line number.</p>

<p style="margin-top: 1em">DATE This macro expands to a
string that describes the date on which the preprocessor is
being run. The string contains eleven characters and looks
like &quot;Oct 24 2016&quot;.</p>

<p style="margin-top: 1em">ISO_DATE <br>
This macro expands to a string that describes the date on
which the preprocessor is being run. The string is in the
format specified by ISO 8601 (YYYY-MM-DD) and looks <br>
like &quot;2016-10-24&quot;.</p>

<p style="margin-top: 1em">TIME This macro expands to a
string that describes the time at which the preprocessor is
being run. The string contains eight characters and looks
like &quot;21:11:38&quot;.</p>

<p style="margin-top: 1em">BASE_FILE <br>
This macro expands to the name of the main input file.</p>

<p style="margin-top: 1em">INCLUDE_LEVEL <br>
This macro expands to a decimal integer constant that
represents the depth of nesting in include files. The value
of this macro is incremented on every #include directive
<br>
and decremented at every end of file.</p>

<p style="margin-top: 1em">NEWLINE <br>
This macro expands to a newline.</p>

<p style="margin-top: 1em">TAB This macro expands to a
tab.</p>

<p style="margin-top: 1em">NULL This macro expands to
nothing. It is useful if you want to define something to be
nothing.</p>

<p style="margin-top: 1em">VERSION <br>
This macro expands to a string constant which describes the
version number of filepp. The string is a sequence of
decimal numbers separated by periods and looks like <br>
&quot;1.8.0&quot;.</p>

<p style="margin-top: 1em">FILEPP_INPUT <br>
This macro expands to a string constant which says the file
was generated automatically from the current BASE_FILE and
looks like &quot;Generated automatically from <br>
./filepp.1.in by filepp&quot;.</p>

<p style="margin-top: 1em">FILEPP MODULES <br>
The following modules are included with the main filepp
distribution:</p>

<p style="margin-top: 1em">FOR MODULE - for.pm <br>
The for module implements a simple for loop. Its file name
is for.pm.</p>

<p style="margin-top: 1em">The for loop is similar in
functionality to that of other programming languages such as
Perl or or C. It has a single variable (a filepp macro)
which is assigned a numerical <br>
value. This numerical value changes by a set increment on
each iteration through the loop. The loop termiates when the
value no longer passes a comparison test.</p>

<p style="margin-top: 1em">The for module implements the
following keywords:</p>

<p style="margin-top: 1em">#for macro start compare end
increment <br>
The #for keyword is functionally equivalent to the following
Perl or C style loop:</p>

<p style="margin-top: 1em">for(macro=start; macro compare
end; macro+=increment)</p>

<p style="margin-top: 1em">The #for keyword requires the
following space separated parameters:</p>

<p style="margin-top: 1em">macro : The name of the macro to
which the for loop should assign its numerical value.</p>

<p style="margin-top: 1em">start : The value macro should
be assigned at the start of the loop. start should be a
numerical value.</p>

<p style="margin-top: 1em">compare : The comparison to make
between the current value of macro and the value end to
determine when the loop should terminate. Valid values for
compare are &lt;, &gt;, &gt;=, <br>
&lt;=.</p>

<p style="margin-top: 1em">end : the for loop will
terminate when the test</p>

<p style="margin-top: 1em">macro compare end</p>

<p style="margin-top: 1em">fails. end should be a numerical
value.</p>

<p style="margin-top: 1em">increment : The value to
increment macro on each iteration of the loop. At the end of
each iteration the value of increment is added to the
current value of macro. <br>
increment should be a numerical value.</p>

<p style="margin-top: 1em">#endfor <br>
The #endfor keyword is used to signify the end of the loop.
Everything within the opening #for and the closing #endfor
will be processed on each iteration of the loop.</p>

<p style="margin-top: 1em">Example usage:</p>

<p style="margin-top: 1em">#for COUNTER 10 &gt; 1 -2.5</p>

<p style="margin-top: 1em">COUNTER</p>

<p style="margin-top: 1em">#endfor</p>

<p style="margin-top: 1em">In the above example COUNTER
will be defined to have values 10, 7.5, 5 and 2.5 for each
successive iteration through the loop.</p>

<p style="margin-top: 1em">Nested loops are also possible,
as is changing the value of the macro within the loop.
start, end and increment should all be numerical values,
however it is possible to use <br>
macros instead provided the macros are defined to have
numerical values.</p>

<p style="margin-top: 1em">FOREACH MODULE - foreach.pm <br>
The foreach module implements a simple foreach loop. Its
file name is foreach.pm.</p>

<p style="margin-top: 1em">The foreach loop is similar in
functionality to that of other programming languages such as
Perl. It takes a list of values separated by a user
definable delimiter (&rsquo;,&rsquo; by <br>
default). It then iterates through all values in the list,
defining a macro to be each individual value for each
iteration of the loop. The loop terminates when all values
have <br>
been used.</p>

<p style="margin-top: 1em">The foreach module implements
the following keywords:</p>

<p style="margin-top: 1em">#foreach macro list <br>
The #foreach keyword is functionally equivalent to the
following Perl style loop:</p>

<p style="margin-top: 1em">foreach macro (split(/delim/,
list))</p>

<p style="margin-top: 1em">The #foreach keyword requires
the following space separated parameters:</p>

<p style="margin-top: 1em">macro : The name of the macro to
which the foreach loop should assign the current list
value.</p>

<p style="margin-top: 1em">list : The list of values,
separated by delim (see #foreachdelim keyword for how to set
delim). list can also be a macro or contain macros.</p>

<p style="margin-top: 1em">The loop will run from the
#foreach keyword to the next #endforeach keyword.</p>

<p style="margin-top: 1em">#endforeach <br>
The #endforeach keyword is used to signify the end of the
loop. Everything within the opening #foreach and the closing
#endforeach will be processed on each iteration of <br>
the loop.</p>

<p style="margin-top: 1em">Example usage:</p>

<p style="margin-top: 1em">#foreach VALUE one, two, three,
four</p>

<p style="margin-top: 1em">VALUE</p>

<p style="margin-top: 1em">#endforeach</p>

<p style="margin-top: 1em">In the above example VALUE will
be defined to have values one, two, three and four for each
successive iteration through the loop.</p>

<p style="margin-top: 1em">Nested loops are also
possible.</p>

<p style="margin-top: 1em">#foreachdelim /delim/ <br>
The #foreachdelim keyword is used to set the delimiter used
in each list. The delimiter can be any character, string or
regular expression. The delimiter should be <br>
enclosed in forward slashes, in the same style as Perl
regular expressions. The default value for delim is
&rsquo;,&rsquo;. To set the delimiter to be a single space
do:</p>

<p style="margin-top: 1em">#foreachdelim / /</p>

<p style="margin-top: 1em">To set delim to be any amount of
white space do:</p>

<p style="margin-top: 1em">#foreachdelim /</p>

<p style="margin-top: 1em">See the Perl documentation on
regular expressions for more advanced uses.</p>

<p style="margin-top: 1em">LITERAL MODULE - literal.pm <br>
The literal module prevents macros appearing in literal
strings from being replaced. A literal string is defined as
having the form:</p>

<p style="margin-top: 1em">&quot;literal string with macro
in&quot;</p>

<p style="margin-top: 1em">In the above example, macro will
not be replaced.</p>

<p style="margin-top: 1em">The behaviour of the literal
module can be reveresed by defining the macro
LITERAL_REVERSE before loading the module, for example:</p>

<p style="margin-top: 1em">filepp -DLITERAL_REVERSE -m
literal.pm &lt;files&gt;</p>

<p style="margin-top: 1em">This has the effect of only
replacing macros which appear in strings.</p>

<p style="margin-top: 1em">TOUPPER MODULE - toupper.pm <br>
The toupper module converts all lowercase letters to
uppercase.</p>

<p style="margin-top: 1em">TOLOWER MODULE - tolower.pm <br>
The tolower module converts all uppercase letters to
lowercase.</p>

<p style="margin-top: 1em">C/C++ COMMENT MODULE -
c-comment.pm <br>
The c-comment module removes all C style:</p>

<p style="margin-top: 1em">/* comment */</p>

<p style="margin-top: 1em">and C++ style:</p>

<p style="margin-top: 1em">// comment</p>

<p style="margin-top: 1em">comments from a file. C and C++
comments are removed after keywords have been processed. If
you wish to remove C and C++ comments before keywords are
processed, define the <br>
macro REMOVE_C_COMMENTS_FIRST before loading the module,
eg:</p>

<p style="margin-top: 1em">filepp -DREMOVE_C_COMMENTS_FIRST
-m c-comment.pm</p>

<p style="margin-top: 1em">HASH COMMENT MODULE -
hash-comment.pm <br>
The hash-comment module removes all comments of the
style:</p>

<p style="margin-top: 1em"># comment</p>

<p style="margin-top: 1em">from a file. This is the
commenting style used by Perl, Bourne Shell, C Shell and
many other programs and configuration files. Hash comments
are removed after keywords have <br>
been processed. If you wish to remove hash comments before
keywords are processed, define the macro
REMOVE_HASH_COMMENTS_FIRST before loading the module (Note:
if you do this <br>
and also use # as the keyword character then the keywords
will be removed BEFORE they are processed).</p>

<p style="margin-top: 1em">FUNCTION MODULE - function.pm
<br>
The function module allows the user write macros which call
Perl functions. Its file name is function.pm.</p>

<p style="margin-top: 1em">The function module allows
macros of the form:</p>

<p style="margin-top: 1em">macro(arg1, arg2, arg3, ...)</p>

<p style="margin-top: 1em">to be added to a file. When the
macro is found, it will run a function from a Perl module,
with arguments arg1, arg2, arg3, ... passed to the function.
The function must return <br>
a string. The returned string will replace the call to the
function in the output. The function can have any number of
arguments. If the function has no arguments it should be
<br>
called with an empty argument list:</p>

<p style="margin-top: 1em">macro()</p>

<p style="margin-top: 1em">If the word macro is found in
the input file without being followed by a ( it will be
ignored.</p>

<p style="margin-top: 1em">To use the function module, the
user must provide a Perl function which optionally takes in
arguments and returns a string. The function can either be
one of filepp&rsquo;s internal <br>
functions or one of the user&rsquo;s own provided in a Perl
module. The function can be added in two ways. The first way
is through the function keyword:</p>

<p style="margin-top: 1em">#function macro function <br>
macro is the name of the macro which is used to signify a
call to the function in the input file and function is the
name of the function to be called.</p>

<p style="margin-top: 1em">The second method of adding a
function is to call the Perl function:</p>


<p style="margin-top: 1em">Function::AddFunction($macro,$function)
<br>
which has the same inputs as the function keyword.</p>

<p style="margin-top: 1em">Functions can be removed either
through the keyword:</p>

<p style="margin-top: 1em">#rmfunction macro <br>
or through the Perl function</p>


<p style="margin-top: 1em">Function::RemoveFunction($macro)</p>

<p style="margin-top: 1em">MATHS MODULE - maths.pm <br>
The module provides a set of macros which perform
mathematical operations. When the macros are encoutered in
an input file, they are evaluated and the result is returned
in the <br>
output.</p>

<p style="margin-top: 1em">The maths module includes the
following macros:</p>

<p style="margin-top: 1em">add(a, b, c, ...) <br>
Takes in any number of arguments and returns their sum: (a +
b + c + ...)</p>

<p style="margin-top: 1em">sub(a, b) <br>
Returns a minus b: (a - b)</p>

<p style="margin-top: 1em">mul(a, b, c, ...) <br>
Takes in any number of arguments and returns their product:
(a * b * c * ...)</p>

<p style="margin-top: 1em">div(a, b) <br>
Returns a over b: (a / b)</p>

<p style="margin-top: 1em">abs(a) Returns the absoulte
value of a.</p>

<p style="margin-top: 1em">atan2(a, b) <br>
Returns the arctangent of a/b in the range -pi to pi.</p>

<p style="margin-top: 1em">cos(a) Returns the cosine of a
in radians.</p>

<p style="margin-top: 1em">exp(a) Returns the e to the
power of a.</p>

<p style="margin-top: 1em">int(a) Returns the integer
portion of a.</p>

<p style="margin-top: 1em">log(a) Returns the natural
logarithm (base e) of a.</p>

<p style="margin-top: 1em">rand(a) <br>
Returns a random fractional number between the range 0 and
a. If a is omitted, returns a value between 0 and 1.</p>

<p style="margin-top: 1em">sin(a) Returns the sine of a in
radians.</p>

<p style="margin-top: 1em">sqrt(a) <br>
Returns the square root of a.</p>

<p style="margin-top: 1em">srand(a) <br>
Sets the random number seed for rand().</p>

<p style="margin-top: 1em">The maths module also defines pi
as M_PI as e as M_E.</p>

<p style="margin-top: 1em">The maths macros are implemented
using the function.pm module. Nested macros are allowed, as
is passing other macros with numerical defintions as
arguments.</p>

<p style="margin-top: 1em">FORMAT MODULE - format.pm <br>
This module provides a set of macros for formating strings
and numbers.</p>

<p style="margin-top: 1em">The format module provides the
following macros:</p>

<p style="margin-top: 1em">printf(format, arg1, arg2, ...)
<br>
The printf macro behaves in the same way as the Perl/C
function printf. It takes in a format string followed by a
list of arguments to print. See the printf(3) man page <br>
or Perl documentation for full details of the printf
function.</p>

<p style="margin-top: 1em">toupper(string) <br>
Converts input string to upper case.</p>

<p style="margin-top: 1em">toupperfirst(string) <br>
Converts first character of input string to upper case.</p>

<p style="margin-top: 1em">tolower(string) <br>
Converts input string to lower case.</p>

<p style="margin-top: 1em">tolowerfirst(string) <br>
Converts first character of input string to lower case.</p>

<p style="margin-top: 1em">substr(string, offset, length)
<br>
Extracts a substring from input string. substr behaves in
the same way as the Perl substr function. offset is used to
specifiy the first character of the string to out&acirc;
<br>
put (negative for offset from end of string), length is the
length of the string to output. If length is omitted
everything from the offset is returned. For further <br>
information on substr see the Perl documentation.</p>

<p style="margin-top: 1em">The format macros are
implemented using the function.pm module.</p>

<p style="margin-top: 1em">BIGDEF MODULE - bigdef.pm <br>
The bigdef module allows easy definition of multi-line
macros. Its file name is bigdef.pm.</p>

<p style="margin-top: 1em">A multi-line macro is a macro
which has a definition which spans more than one line. The
normal way to define these is to place a line continuation
character at the end of each <br>
line in the definition. However, this can be annoying and
unreadable for large multi-line macros. The bigdef module
tries to improve on this by providing two keywords:</p>

<p style="margin-top: 1em">#bigdef macro definition... <br>
The #bigdef keyword has the same syntax as #define, the only
difference being the macro definition is everything
following the macro name including all following lines up
<br>
to the next #endbigdef keyword.</p>

<p style="margin-top: 1em">#endbigdef <br>
Ends a bigdef. Everything between this keyword and the last
preceding #bigdef is included in the macro.</p>

<p style="margin-top: 1em">Any keywords found in the
definition will be evaluated as normal AT THE TIME THE MACRO
IS DEFINED and any output from these will be included in the
definition.</p>

<p style="margin-top: 1em">Note: The difference between
bigfunc and bigdef is the time keywords in the definition
are evaluated. Bigdef evaluates them as the macro is
DEFINED, bigfunc evaluates them when&acirc; <br>
ever the macro is REPLACED.</p>

<p style="margin-top: 1em">BIGFUNC MODULE - bigfunc.pm <br>
The bigfunc module allows easy definition of multi-line
macros. Its file name is bigfunc.pm.</p>

<p style="margin-top: 1em">A multi-line macro is a macro
which has a definition which spans more than one line. The
normal way to define these is to place a line continuation
character at the end of each <br>
line in the definition. However, this can be annoying and
unreadable for large multi-line macros. The bigfunc module
tries to improve on this by providing two keywords:</p>

<p style="margin-top: 1em">#bigfunc macro definition...
<br>
The #bigfunc keyword has the same syntax as #define, the
only difference being the macro definition is everything
following the macro name including all following lines up
<br>
to the next #endbigfunc keyword.</p>

<p style="margin-top: 1em">#endbigfunc <br>
Ends a bigfunc. Everything between this keyword and the last
preceding #bigfunc is included in the macro.</p>

<p style="margin-top: 1em">Any keywords found in the
definition will be evaluated as normal AT THE TIME THE MACRO
IS REPLACED and any output from these will be included in
the definition.</p>

<p style="margin-top: 1em">Note: The difference between
bigfunc and bigdef is the time keywords in the definition
are evaluated. Bigdef evaluates them as the macro is
DEFINED, bigfunc evaluates them when&acirc; <br>
ever the macro is REPLACED.</p>

<p style="margin-top: 1em">DEFPLUS MODULE - defplus.pm <br>
The defplus module allows extra information to be appended
to an existing macro. Its file name is defplus.pm.</p>

<p style="margin-top: 1em">The defplus module allows
further things to be appended to existing macros. The module
implements one keyword:</p>

<p style="margin-top: 1em">#defplus macro definition...
<br>
The #defplus keyword has the same syntax as #define, the
only difference being if the macro is already defined then
definition is appended to the existing definition of <br>
the macro. If the macro is undefined then #defplus behaves
in exactly the same way as #define.</p>

<p style="margin-top: 1em">REGEXP MODULE - regexp.pm <br>
The regexp module allows Perl regular expression replacement
to be done with filepp. Its file name is regexp.pm.</p>

<p style="margin-top: 1em">Perl regular expression
replacement allows a regular expression to be searched for
and replaced with something else. Regular expressions are
defined as follows:</p>

<p style="margin-top: 1em">#regexp /regexp/replacement/
<br>
It is very similar to the Perl syntax and the following Perl
code will be executed on each line of the input file:</p>

<p style="margin-top: 1em">$line =~ s/regexp/replacement/g
<br>
For users who don&rsquo;t understand Perl, this means
replace all occurrences of regexp in the current line with
replacement.</p>

<p style="margin-top: 1em">A full description of regular
expressions and possible replacements is beyond the scope of
this man page. More information can be found in the Perl
documentation using the com&acirc; <br>
mand:</p>

<p style="margin-top: 1em">perldoc perlre</p>

<p style="margin-top: 1em">Any number of regular
expressions can be defined. Each regular expression is
evaluated once for each line of the input file. Regular
expressions are evaluated in the order they <br>
are defined.</p>

<p style="margin-top: 1em">Regular expressions can be
undefined in the following way:</p>

<p style="margin-top: 1em">#rmregexp /regexp/replacement/
<br>
This will remove the specified regular expression.</p>

<p style="margin-top: 1em">In debugging mode the current
list of regular expressions can be viewed using the pragma
keyword:</p>

<p style="margin-top: 1em">#pragma filepp ShowRegexp <br>
When not in debugging mode, this will produce no output.</p>

<p style="margin-top: 1em">A single regular expression can
also be defined on the command line using the REGEXP macro,
for example:</p>

<p style="margin-top: 1em">filepp
-DREGEXP=/regexp/replacement/ -m regexp.pm inputfile</p>

<p style="margin-top: 1em">Note: the REGEXP macro must be
defined BEFORE the regexp module is loaded, putting
-DREGEXP... after -m regexp.pm will not work. When using the
command line approach, if the <br>
REGEXP macro is successfully parsed as a regular expression
it will be undefined from the normal filepp macro list
before processing starts. Care should obviously be taken
when <br>
escaping special characters in the shell with command line
regexps.</p>

<p style="margin-top: 1em">BLC MODULE - blc.pm <br>
The Bracket Line Continuation module causes lines to be
continued if they have more open brackets: &quot;(&quot;
than close brackets: &quot;)&quot; on a line. The line will
be continued until an <br>
equal number of open and close brackets are found.</p>

<p style="margin-top: 1em">Brackets can be prevented from
being counted for line continuation by escaping them with a
backslash: &quot;and &quot;&quot;. Any brackets found with a
preceding backslash will be <br>
ignored when deciding if line continuation should be done
and then have the backslash removed once the full line has
been found.</p>

<p style="margin-top: 1em">C MACROS MODULE - cmacros.pm
<br>
The cmacros module causes the definition of the following
predefined macros to be quoted: DATE, TIME, VERSION,
BASE_FILE, FILE, (note: predefined macros are written as
<br>
__MACRO__).</p>

<p style="margin-top: 1em">This makes the macros more
&quot;C&quot; like, as the C preprocessor also puts quotes
around these macros.</p>

<p style="margin-top: 1em">C MACROS MODULE - cpp.pm <br>
The cpp makes filepp behave in a similar manner to a C
preprocessor cpp(1).</p>

<p style="margin-top: 1em">DISCLAIMER: filepp is not meant
to be a drop in replacement for a C preprocessor even with
this module. I would not recommend using filepp as a C
preprocessor unless you fully <br>
understand how it differs from a real C preprocessor. The
output from filepp with the cpp module will not be the same
as a real C preprocessor.</p>

<p style="margin-top: 1em">GRAB MODULE - grab.pm <br>
The grab module is used to grab input before processing. Its
file name is grab.pm.</p>

<p style="margin-top: 1em">The grab module is mainly for
use in other modules, such as for.pm and bigfunc.pm. It
grabs all input from a file before any processing is done on
it. This allows other modules <br>
to do processing on the original input data before the main
processing is done. For example, the for module will store
the original input inside a loop and re-use it each time
<br>
the loop is processed.</p>

<p style="margin-top: 1em">#grab macro definition... <br>
The grab module will start grabbing of all input from the
grab keyword, onwards.</p>

<p style="margin-top: 1em">#endgrab <br>
Ends a grab. Everything between this keyword and the last
preceding #grab will be grabbed and stored for use in other
modules.</p>

<p style="margin-top: 1em">Grabs can be nested if
required.</p>

<p style="margin-top: 1em">When calling grab from another
module, use the following functions:</p>


<p style="margin-top: 1em">Grab::StartGrab($startkeyword,$endkeyword)
<br>
$startkeyword is the keyword that StartGrab is called from.
$endkeyword is the keyword that grabbing should stop at.</p>

<p style="margin-top: 1em">@List=Grab::GetInput() <br>
Returns a Perl list containing all input grabbed from when
grab was last run.</p>

<p style="margin-top: 1em">$line=Grab::GetInputLine() <br>
Returns the line number of the input file where grabbing
last started.</p>

<p style="margin-top: 1em">FILEPP MODULE API <br>
The behaviour of filepp can be modified or extended through
the use of modules. filepp modules are in fact perl(1)
modules, and the rest of this section assumes the reader has
a <br>
knowledge of Perl.</p>

<p style="margin-top: 1em">filepp modules are perl(1)
modules which extend or modify filepp&rsquo;s behaviour by
either calling or replacing filepp&rsquo;s internal
functions. filepp has the Perl package name Filepp <br>
so its internal functions can be called within modules
either as Filepp::function() or just function(). Any of
filepp&rsquo;s internal functions can be called or replaced
from within <br>
a filepp module, the most useful ones are:</p>

<p style="margin-top: 1em">Debug($string,$number) <br>
Print $string as debugging information if debugging is
enabled. $number is optional and can be used to set the
debugging level at which $string should be printed, lower
<br>
numbers being higher priority. Command line option d prints
all debugging info for 2 and below, option dd prints all
debugging information for 3 and below and option dl <br>
prints all debugging information for 1 and below. If $number
is not provided, defaults to 1.</p>


<p style="margin-top: 1em">AddProcessor($function,$pos,$type)
<br>
Allows the module to add a function named $function to
filepp&rsquo;s processing chain. The processing chain is a
set of functions which are run on each line of a file as it
is <br>
processed. The default functions in the processing chain are
ParseKeywords which does keyword parsing and ReplaceDefines
which does macro replacement. Further functions <br>
can be added to the chain, with each function taking a
string (the current line) as input and returning the
processed string as output.</p>

<p style="margin-top: 1em">By default, or if $pos is set to
0, the processor is added to the end of the processing
chain. If $pos is set to 1 the processor is added to the
start of the processing <br>
chain.</p>

<p style="margin-top: 1em">$type controls what the
processor is run on. There are three options for this, 0
(default): the processor runs on everything passed to the
processing chain; 1: the pro&acirc; <br>
cessor runs on full lines only; 2: the processor runs on
part lines only (a part line is the text following a keyword
such as if which needs to be parsed for macros).</p>

<p style="margin-top: 1em">Both $pos and $type are optional
parameters.</p>


<p style="margin-top: 1em">AddProcessorAfter($function,$existing,$type)
<br>
Adds function $function to the processing chain directly
after existing processor $existing. If $existing is not
found then $function is added to the end of the
process&acirc; <br>
ing chain. Regular expression matching is used to compare
$existing with the names of the functions in the processing
chain.</p>

<p style="margin-top: 1em">$type is optional.</p>


<p style="margin-top: 1em">AddProcessorBefore($function,$existing,$type)
<br>
Adds function $function to the processing chain directly
before existing processor $existing. If $existing is not
found then $function is added to the start of the pro&acirc;
<br>
cessing chain. Regular expression matching is used to
compare $existing with the names of the functions in the
processing chain.</p>

<p style="margin-top: 1em">$type is optional.</p>

<p style="margin-top: 1em">RemoveProcessor($function) <br>
Removes the processor function $function from the processing
chain.</p>

<p style="margin-top: 1em">$string=ReplaceDefines($string)
<br>
Replaces all macros in $string with their definitions and
returns the processed string.</p>

<p style="margin-top: 1em">AddKeyword($string,$function)
<br>
Add the keyword named $string. When the keyword is found in
text processing the function named $function will be run
with everything following the keyword passed as a <br>
single argument.</p>

<p style="margin-top: 1em">RemoveKeyword($string) <br>
Removes the keyword named $string.</p>

<p style="margin-top: 1em">RemoveAllKeywords() <br>
Removes all the keywords currently defined for filepp (used
for the -k command line option).</p>

<p style="margin-top: 1em">AddIfword($string) <br>
Adds keyword named $string to Ifword list. An Ifword takes
in the string following the keyword and optionally parses
it, returning a 1 if the string parses to true and 0 <br>
for false. The default Ifwords are if, ifdef and ifndef.</p>

<p style="margin-top: 1em">RemoveIfword($string) <br>
Removes keyword named $string from Ifword list (note: this
does NOT remove the keyword, use RemoveKeyword for
that).</p>

<p style="margin-top: 1em">AddElseword($string) <br>
Adds keyword named $string to Elseword list. An Elseword
takes in the string following the keyword and optionally
parses it, returning a 1 if the string parses to true <br>
and 0 for false. The default Elsewords are else and
elif.</p>

<p style="margin-top: 1em">RemoveElseword($string) <br>
Removes keyword named $string from Elseword list.</p>

<p style="margin-top: 1em">AddEndifword($string) <br>
Adds keyword named $string to Endifword list. An Endifword
should return a 1 to indicate successful termination of the
if block. If the Endifword returns 0 the Endifword <br>
is ignored and filepp assumes the current if block carries
on after the Endifword. The default Endifword is endif.</p>

<p style="margin-top: 1em">RemoveEndifword($string) <br>
Removes keyword named $string from Endifword list.</p>

<p style="margin-top: 1em">AddIncludePath($string) <br>
Adds the include path $string to the list of directories to
search for include files (used for the -I command line
option).</p>

<p style="margin-top: 1em">AddModulePath($string) <br>
Adds the path $string to the list of directories to search
for filepp modules (used for the -M command line
option).</p>

<p style="margin-top: 1em">AddOpenInputFunc($function) <br>
Adds a $function to a list of functions to be run each time
a new base input file is opened.</p>

<p style="margin-top: 1em">AddCloseInputFunc($function)
<br>
Adds a $function to a list of functions to be run each time
a new base input file is closed.</p>

<p style="margin-top: 1em">AddOpenOutputFunc($function)
<br>
Adds a $function to a list of functions to be run each time
an output file is opened.</p>

<p style="margin-top: 1em">AddCloseOutputFunc($function)
<br>
Adds a $function to a list of functions to be run each time
an output file is closed.</p>

<p style="margin-top: 1em">AddInputFile($string) <br>
Adds another input file to the list of files to be processed
(used for adding input files at the command line).</p>

<p style="margin-top: 1em">ChangeOutputFile($string) <br>
Closes the current output file and attempts to open a new
one named $string.</p>

<p style="margin-top: 1em">SetKeywordchar($string) <br>
Set the initial keyword char to $string (used for the -kc
command line option).</p>

<p style="margin-top: 1em">SetContchar($string) <br>
Set the line continuation char to $string (used for the -lc
command line option).</p>

<p style="margin-top: 1em">SetContrepchar($string) <br>
Set the line continuation replacement char to $string (used
for the -lr command line option).</p>

<p style="margin-top: 1em">SetOptLineEndchar($string) <br>
Set the optional keyword line end character to $string (used
for the -lec command line option).</p>

<p style="margin-top: 1em">SetBlankSupp(1/0) <br>
Turns blank-line suppression on/off (1 = suppress, 0 =
don&rsquo;t suppress). When blank-line suppression is on,
blank lines in input files will not be copied to the output.
<br>
Unlike the corresponding command-line option (-b), this
function can also have effect in the top-level file. The
setting of blank-line suppression applies to the current
<br>
file being processed and all files included in the current
file.</p>

<p style="margin-top: 1em">ResetBlankSupp() <br>
Resets blank-line suppression to the command-line specified
value. This only affects the output of blank lines from the
current file being processed and all files <br>
included in the current file. In the top-level file, this
always turns blank-line suppression off.</p>

<p style="margin-top: 1em">SetEatTrail($string) <br>
If $string is a macro, whenever the macro is replaced all
blank space between the macro&rsquo;s replacement and the
next character on the line will be eaten. For example, if
<br>
macro foo is defined to bar and foo has been set to have
it&rsquo;s trail eaten, the following:</p>

<p style="margin-top: 1em">eat my foo trail</p>

<p style="margin-top: 1em">is replaced with</p>

<p style="margin-top: 1em">eat my bartrail</p>

<p style="margin-top: 1em">CheckEatTrail($string) <br>
Returns 1 if macro $string will have it&rsquo;s tail eaten,
0 otherwise.</p>

<p style="margin-top: 1em">SetEnvchar($string) <br>
Set the prefix of environment variables converted to macros
(envchar) to $string (used for -ec and -ecn command line
options).</p>

<p style="margin-top: 1em">DefineEnv() <br>
Define all environment variables as macros with prefix
envchar (used for -e command line option).</p>

<p style="margin-top: 1em">SetOutput(1/0) <br>
Turns writing of parsed input file to output file on/off.
This takes either 1 (output on) or 0 (output off) as input.
When the output is turned off, the only output pro&acirc;
<br>
duced from filepp will be that generated by modules.</p>

<p style="margin-top: 1em">SetWordBoundaries(1/0) <br>
Turns on(1) or off(0) word boundary checking when replacing
macros (used for the -w command line option).</p>

<p style="margin-top: 1em">SetCharPerlre(1/0) <br>
Turns on(1) or off(0) allowing of keyword prefix char and
line continuation char to be Perl regular expressions (used
for the -re command line option).</p>

<p style="margin-top: 1em">UndefAll() <br>
Undefines all currently defined macros, including predefined
ones (used for the -u command line option).</p>

<p style="margin-top: 1em">UseModule($string) <br>
Loads a perl(1) module named $string using the Perl command
require (used for the -m command line option).</p>

<p style="margin-top: 1em">SetParseLineEnd($function) <br>
Sets the function to determine if line continuation should
be done on current line to $function.</p>

<p style="margin-top: 1em">$string=GetNextLine() <br>
Returns the next line (after line continuation has been
dealt with) of the input file currently being processed.
Returns NULL for end of file.</p>

<p style="margin-top: 1em">Write($string) <br>
Writes $string to the current output file.</p>

<p style="margin-top: 1em">Output($string) <br>
Conditionally writes $string to the current output file. If
output is turned on then writes $string. Output is toggled
off/on using SetOutput function.</p>

<p style="margin-top: 1em">In addition all the standard
filepp keywords have equivalent functions which optionally
take a single argument. The functions have the same name as
the keyword, only with a cap&acirc; <br>
ital first letter (eg: #define string calls the function
Define(string)).</p>

<p style="margin-top: 1em">A full description of the Parse
function and all the other filepp internal functions is
beyond the scope of this man page. The filepp script is well
commented and hopefully <br>
readable by a Perl programmer, so use the source Luke!</p>

<p style="margin-top: 1em">BUGS <br>
filepp has no known bugs, only &quot;features&quot;. If you
find any &quot;features&quot;, please report them to the
author.</p>

<p style="margin-top: 1em">COPYING <br>
Copyright (C) 2000-2007 Darren Miller</p>

<p style="margin-top: 1em">filepp is free software; you can
redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software
Foundation; either version 2 <br>
of the License, or (at your option) any later version.</p>

<p style="margin-top: 1em">This program is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PUR&acirc; <br>
POSE. See the GNU General Public License for more
details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program;
see the file COPYING. If not, write to the Free Software
Foundation, 675 Mass Ave, <br>
Cambridge, MA 02139, USA.</p>

<p style="margin-top: 1em">SEE ALSO <br>
cpp(1), perl(1)</p>

<p style="margin-top: 1em">AUTHOR <br>
Darren Miller &lt;darren@cabaret.demon.co.uk&gt;.</p>

<p style="margin-top: 1em">Version: 1.8.0 Oct 24 2016
FILEPP(1)</p>
<hr>
</body>
</html>
