<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:01:18 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CRYPTOMINISAT(1) User Commands CRYPTOMINISAT(1)</p>

<p style="margin-top: 1em">NAME <br>
cryptominisat - conflict-driven SAT solver</p>

<p style="margin-top: 1em">SYNOPSIS <br>
cryptominisat [OPTIONS] &lt;input-files&gt;</p>

<p style="margin-top: 1em">DESCRIPTION <br>
CryptoMiniSat is a SAT solver, solving problems given in
CNF, or conjunctive normal form. CryptoMiniSat retains much
of the API of MiniSat, but offers more versatility and
better <br>
speed on many problems.</p>

<p style="margin-top: 1em">The program is a classical
conflict-driven solver, with variable activities, clause
learning and clause deletion. It however incorporates a
number of advanced CNF simplification <br>
functionalities which should help the speed of solving.
Further, it incorporates some advanced memory-management
features that should help in getting the most out of modern
CPU <br>
caches.</p>

<p style="margin-top: 1em">The input format is that of
DIMACS CNF, i.e. a header of the form</p>

<p style="margin-top: 1em">p cnf VARS CLAUSES</p>

<p style="margin-top: 1em">where VARS is the number of
variables, and CLAUSES is the number of clauses in the
problem. It then lists the set of clauses such as:</p>

<p style="margin-top: 1em">1 -2 0</p>

<p style="margin-top: 1em">which is equivalent to the
2-long clause &quot;v1 OR NOT v2 = TRUE&quot;</p>

<p style="margin-top: 1em">OPTIONS <br>
-h,--help <br>
Print help text.</p>

<p style="margin-top: 1em">-v,--version <br>
Print cryptominisat&rsquo;s version number.</p>

<p style="margin-top: 1em">--input =
&lt;file1,file2,...&gt; <br>
Specify the file(s) to read.</p>

<p style="margin-top: 1em">-r,--random = &lt;seed&gt; [0 -
2^32-1] <br>
Sets the random seed, used for picking decision variables
(default = 0).</p>

<p style="margin-top: 1em">-t,--threads = &lt;num&gt; [1..]
<br>
Number of threads (default is 1).</p>

<p style="margin-top: 1em">--sync = &lt;num&gt; <br>
Sync threads every num conflicts (default = 6000).</p>

<p style="margin-top: 1em">--maxtime = &lt;num&gt; <br>
Stop solving after this much time, print stats and exit.</p>

<p style="margin-top: 1em">--maxconfl = &lt;num&gt; <br>
Stop solving after this many conflicts, print stats and
exit.</p>

<p style="margin-top: 1em">--occsimp = {0,1} <br>
Perform occurrence-list-based optimizations, such as
variable eliminiation, subsumption, and bounded variable
addition. Default is 1.</p>

<p style="margin-top: 1em">--clbtwsimp = &lt;num&gt; <br>
Perform this many cleaning iterations between simplification
rounds (default = 2).</p>

<p style="margin-top: 1em">-d,--drup = {0,1} <br>
Put DRUP verification information into this file.</p>

<p style="margin-top: 1em">--drupexistscheck = {0,1} <br>
Check if the DRUP file provided already exists (default =
1).</p>

<p style="margin-top: 1em">--drupdebug = {0,1} <br>
Output DRUP verification to the console. This is helpful to
see where DRUP fails. Use in conjunction with --verb 20.</p>

<p style="margin-top: 1em">RESTART <br>
--agilg = &lt;num&gt; <br>
See paper by Armin Biere on agilities.</p>

<p style="margin-top: 1em">--restart =
{geom,agility,glue,glueagility} <br>
Choose the restart strategy to follow.</p>

<p style="margin-top: 1em">--agillim = &lt;num&gt; <br>
The agility below which the agility is considered too low
(default = 0.03).</p>

<p style="margin-top: 1em">--agilviollim = &lt;num&gt; <br>
The number of agility violations over which to demand a
restart (default = 20).</p>

<p style="margin-top: 1em">--gluehist = &lt;num&gt; <br>
The size of the moving window for short term glue history of
redundant clauses (default = 100). If higher, the minimal
number of conflicts between restarts is longer.</p>

<p style="margin-top: 1em">--blkrest = {0,1} <br>
Perform blocking restarts as per Glucose 3.0 (default =
1).</p>

<p style="margin-top: 1em">--blkrestlen = &lt;num&gt; <br>
The length of the long term trail size for blocking restart
(default = 5000).</p>

<p style="margin-top: 1em">--blkrestmultip = &lt;num&gt;
<br>
Multiplier used for blocking restart cut-off, called
&quot;R&quot; in Glucose 3.0 (default = 1.4).</p>

<p style="margin-top: 1em">PRINTING <br>
--verb = &lt;num&gt; [0-10] <br>
Verbosity of the solver (default = 2). Verbosity 0 only
prints the results.</p>

<p style="margin-top: 1em">--verbstat = {0,1} <br>
Turns off verbose stats if needed (default = 1).</p>

<p style="margin-top: 1em">--printfull = {0,1} <br>
Print more thorough, but different, stats (default = 0).</p>

<p style="margin-top: 1em">-s,--printsol = {0,1} <br>
Print the satisfying assignment if the solution is SAT
(default = 1).</p>

<p style="margin-top: 1em">--printtrail = &lt;num&gt; <br>
Print the longest decision trail of the last N conflicts; if
0, the decision trail is not printed (default = 0).</p>

<p style="margin-top: 1em">--printbest = &lt;num&gt; <br>
Print the best N irredundant longer-than-3 learnt clauses;
if 0, nothing is printed (default = 0).</p>

<p style="margin-top: 1em">--printtimes = {0,1} <br>
Print the time taken for each simplification run; if 0,
nothing is printed, which makes logs easier to compare
(default = 1).</p>

<p style="margin-top: 1em">PROPAGATION <br>
--updateglue = {0,1} <br>
Update glues while propagating (default = 1).</p>

<p style="margin-top: 1em">--lhbr = {0,1} <br>
Perform lazy hyper-binary resolution while propagating
(default = 0).</p>

<p style="margin-top: 1em">--binpri = {0,1} <br>
Propagated binary clauses are strictly first (default =
0).</p>

<p style="margin-top: 1em">--otfhyper = {0,1} <br>
Perform hyper-binary resolution at decision level 1 after
every restart and during probing (default = 1).</p>

<p style="margin-top: 1em">REDUNDANT CLAUSE REMOVAL <br>
--ltclean = &lt;num&gt; [0-1] <br>
Remove at least this ratio of redundant clauses when doing
redundant clause cleaning (default = 0.5).</p>

<p style="margin-top: 1em">--clean =
{size,glue,activity,prconf,confdep} <br>
Metric used to clean clauses (default = prconf). Use
&quot;prconf&quot; for the sum of propagations and
conflicts. Use &quot;confdep&quot; for (propagations +
conflicts) / (depth at which <br>
they were caused).</p>

<p style="margin-top: 1em">--noremfreshgl2 = {0,1} <br>
Don&rsquo;t remove glue 2 clauses that are fresh (default =
0).</p>

<p style="margin-top: 1em">--cleanconflmult = &lt;num&gt;
<br>
If propagations and conflicts are used to clean, the value
by which conflicts are multiplied relative to propagations
(default = 1). Conflicts are much rarer, but maybe <br>
more useful.</p>

<p style="margin-top: 1em">--lockuip = &lt;num&gt; <br>
The number of clauses to lock into the database per cleaning
based on UIP usage (default = 500).</p>

<p style="margin-top: 1em">--locktop = &lt;num&gt; <br>
The number of clauses to lock into the database per cleaning
based on the best uncleaned clauses as per the selected
heuristic (default = 0).</p>

<p style="margin-top: 1em">--perfmult = &lt;num&gt; <br>
Value by which to multiply clause performance values after
every clause cleaning (default = 0).</p>

<p style="margin-top: 1em">--clearstat = {0,1} <br>
Clear clause statistics data of each clause after clause
cleaning (default = 1).</p>

<p style="margin-top: 1em">--startclean = &lt;num&gt; <br>
Clean the first time after this many conflicts (default =
10000).</p>

<p style="margin-top: 1em">--incclean = &lt;num&gt; <br>
Clean increment cleaning by this factor for the next
cleaning (default = 1.1).</p>

<p style="margin-top: 1em">--maxredratio = &lt;num&gt; <br>
Never have more than N * (irred_clauses) redundant clauses
(default = 10).</p>

<p style="margin-top: 1em">VARIABLE BRANCHING <br>
--vincmult = &lt;num&gt; <br>
Variable activity increase multipler (default = 11).</p>

<p style="margin-top: 1em">--vincdiv = &lt;num&gt; <br>
Variable activity increase divider (default = 10); it must
be smaller than the multiplier.</p>

<p style="margin-top: 1em">--vincvary = &lt;num&gt; <br>
Variable activity divider and multiplier are both changed
+/- this amount, randomly, in sync (default = 0).</p>

<p style="margin-top: 1em">--vincstart = &lt;num&gt; <br>
Variable activity increase stars with this value. Make sure
that this, multiplied by the multiplier and divided by the
divider, is larger than itself (default = 128).</p>

<p style="margin-top: 1em">--freq = &lt;num&gt; [0-1] <br>
Frequency of picking decision variables at random (default =
0).</p>

<p style="margin-top: 1em">--dompickf = &lt;num&gt; <br>
Use the dominating literal once in every N when picking
decision literal (default = 400).</p>

<p style="margin-top: 1em">--morebump = {0,1} <br>
Bump variables&rsquo; activities based on the glue of
redundant clauses there are in during UIP generation, as per
Glucose (default = 1).</p>

<p style="margin-top: 1em">VARIABLE POLARITY <br>
--polar = {true,false,rnd,auto} <br>
Selects the polarity mode (default = auto). True selects
only positive polarity when branching. False selects only
negative polarity when branching. Auto selects the <br>
last polarity used (also called &rsquo;caching&rsquo;).</p>

<p style="margin-top: 1em">--calcpolar1st = {0,1} <br>
Calculate the polarity of variables based on their
occurrences at startup of solve() (default = 1).</p>

<p style="margin-top: 1em">--calcpolarall = {0,1} <br>
Calculate the polarity of variables based on their
occurrences at startup and after every simplification
(default = 1).</p>

<p style="margin-top: 1em">CONFLICT <br>
--recur = {0,1} <br>
Perform recursive minimisation.</p>

<p style="margin-top: 1em">--moreminim = {0,1} <br>
Perform strong minimisation at conflict gen.</p>

<p style="margin-top: 1em">--moreminimcache = &lt;num&gt;
<br>
Timeout in microsteps for each more minimisation with cache
(default = 200). Only active if &rsquo;moreminim&rsquo; is
on.</p>

<p style="margin-top: 1em">--moreminimbin = &lt;num&gt;
<br>
Timeout in microsteps for each more minimisation with binary
clauses (default = 100). Only active if
&rsquo;moreminim&rsquo; is on.</p>

<p style="margin-top: 1em">--alwaysmoremin = {0,1} <br>
Always strong-minimise clauses.</p>

<p style="margin-top: 1em">--otfsubsume = {0,1} <br>
Perform on-the-fly subsumption.</p>

<p style="margin-top: 1em">--rewardotfsubsume = &lt;num&gt;
<br>
Reward with this many propagations and conflicts a clause
that has been shortened with on-the-fly subsumption (default
= 3).</p>

<p style="margin-top: 1em">--printimpldot = {0,1} <br>
Print implication graph DOT files, for input into
graphviz.</p>

<p style="margin-top: 1em">ITERATIVE SOLVE <br>
--maxsol = &lt;num&gt; <br>
Search for the given number of solutions (default = 1).</p>

<p style="margin-top: 1em">--dumpred = &lt;filename&gt;
<br>
If stopped, dump redundant clauses here.</p>

<p style="margin-top: 1em">--maxdump = &lt;num&gt; <br>
Maximum length of redundant clauses to dump.</p>

<p style="margin-top: 1em">--dumpirred = &lt;filename&gt;
<br>
If stopped, dump irredundant original problems here.</p>

<p style="margin-top: 1em">--debuglib <br>
Solve at specific c Solver::solve() points in the CNF file.
Used to debug file generated by Solver&rsquo;s
needLibraryCNFFile() function.</p>

<p style="margin-top: 1em">--dumpresult = &lt;filename&gt;
<br>
Write result(s) to this file.</p>

<p style="margin-top: 1em">PROBING <br>
--bothprop = {0,1} <br>
Do propagations solely to propagate the same value twice
(default = 1).</p>

<p style="margin-top: 1em">--probe = {0,1} <br>
Carry out probing (default = 1).</p>

<p style="margin-top: 1em">--probemaxm = &lt;num&gt; <br>
Time in mega-bogoprops to perform probing (default =
1900).</p>

<p style="margin-top: 1em">--transred = {0,1} <br>
Remove useless binary clauses; i.e., transitive reduction
(default = 1).</p>

<p style="margin-top: 1em">STAMPING <br>
--stamp = {0,1} <br>
Use time stamping as per the Heule, Javisalo, and Biere
paper (default = 1).</p>

<p style="margin-top: 1em">--cache = {0,1} <br>
Use an implication cache (default = 1). This option may use
a lot of memory.</p>

<p style="margin-top: 1em">--cachesize = &lt;num&gt; <br>
Maximum size of the implication cache in MB (default =
2048). The cache may temporarily use more memory, but will
be deleted and disabled if this limit is reached.</p>

<p style="margin-top: 1em">--calcreach = {0,1} <br>
Calculate literal reachability (default = 1).</p>

<p style="margin-top: 1em">--cachecutoff = &lt;num&gt; <br>
If the number of literals propagated by a literal is greater
than this value, the literal is not included in the
implication cache (default = 2000).</p>

<p style="margin-top: 1em">SIMPLIFICATION <br>
--schedsimp = {0,1} <br>
Perform regular simplification rounds (default = 1).</p>

<p style="margin-top: 1em">--presimp = {0,1} <br>
Perform simplification at the very start (default = 0).</p>

<p style="margin-top: 1em">--varelim = {0,1} <br>
Perform variable elimination as per Een and Biere (default =
1).</p>

<p style="margin-top: 1em">--emptyelim = {0,1} <br>
Perform empty resolvent elimination using the bit-map trick
(default = 1).</p>

<p style="margin-top: 1em">--elimstrgy =
{heuristic,calculate} <br>
The strategy used to sort variable elimination order
(default = heuristic). The heuristic strategy uses
intelligent guessing. The calculate strategy uses exact
calcula&acirc; <br>
tion.</p>

<p style="margin-top: 1em">--elimcplxupd = {0,1} <br>
Update estimated elimination complexity on-the-fly while
eliminating (default = 1).</p>

<p style="margin-top: 1em">--elimcoststrategy = &lt;num&gt;
[0-1] <br>
How the simple guessing strategy is calculated.</p>

<p style="margin-top: 1em">--strengthen = {0,1} <br>
Perform clause contraction through resolution (default =
1).</p>

<p style="margin-top: 1em">--bva = {0,1} <br>
Perform bounded variable addition (default = 1).</p>

<p style="margin-top: 1em">--bvalim = &lt;num&gt; <br>
Maximum number of variables to add by bounded variable
addition per call (default = 150000).</p>

<p style="margin-top: 1em">--bva2lit = {0,1} <br>
Bounded variable addition with 2-literal difference hack,
too (default = 1). Beware, this reduces the effectiveness of
1-literal difference.</p>

<p style="margin-top: 1em">--noextbinsubs = {0,1} <br>
No extended subsumption with binary clauses (default =
1).</p>

<p style="margin-top: 1em">--eratio = &lt;num&gt; [0-1]
<br>
Eliminate this ratio of free variables at most per variable
elimination iteration (default = 0.12).</p>

<p style="margin-top: 1em">--skipresol = {0,1} <br>
Skip BVE resolvents in case they belong to a gate (default =
0).</p>

<p style="margin-top: 1em">--occredmax = &lt;num&gt; <br>
Don&rsquo;t add any redundant clauses larger than this to
the occur list (default = 200).</p>

<p style="margin-top: 1em">--occirredmaxmb = &lt;num&gt;
<br>
Don&rsquo;t allow the irredundant occur size to be more than
this many MB (default = 800).</p>

<p style="margin-top: 1em">--occredmaxmb = &lt;num&gt; <br>
Don&rsquo;t allow the redundant occur size to be more than
this many MB (default = 800).</p>

<p style="margin-top: 1em">EQUIVALENT LITERAL <br>
--scc = {0,1} <br>
Find equivalent literals through SCC and replace them
(default = 1).</p>

<p style="margin-top: 1em">--extscc = {0,1} <br>
Perform SCC using cache (default = 1).</p>

<p style="margin-top: 1em">--sccperc = &lt;num&gt; [0-1]
<br>
Perform SCC only if the number of new binary clauses is at
least this percentage of the number of free variables
(default = 0.02).</p>

<p style="margin-top: 1em">COMPONENT <br>
--findcomp = {0,1} <br>
Find components, but do not treat them (default = 0).</p>

<p style="margin-top: 1em">--comps = {0,1} <br>
Perform component-finding and separate handling (default =
1).</p>

<p style="margin-top: 1em">--compsfrom = &lt;num&gt; <br>
Do component finding only after this many simplification
rounds (default = 0).</p>

<p style="margin-top: 1em">--compsvar = &lt;num&gt; <br>
Only use components when the number of variables is below
this limit (default = 1000000).</p>

<p style="margin-top: 1em">--compslimit = &lt;num&gt; <br>
Limit how much time is spent in component finding (default =
500).</p>

<p style="margin-top: 1em">XOR-RELATED <br>
--xor = {0,1} <br>
Discover long XORs (default = 1).</p>

<p style="margin-top: 1em">--xorcache = {0,1} <br>
Use cache when finding XORs (default = 0). This finds a lot
more XORs, but takes a lot more time.</p>

<p style="margin-top: 1em">--echelonxor = {0,1} <br>
Extract data from XORs through echelonization at the top
level only (default = 1).</p>

<p style="margin-top: 1em">--maxxormat = &lt;num&gt; <br>
The maximum matrix size (i.e., number of elements) that we
should try to echelonize (default = 10000000).</p>

<p style="margin-top: 1em">GATE-RELATED <br>
--gates = {0,1} <br>
Find gates (default = 1). Disables all other gate-related
sub-options.</p>

<p style="margin-top: 1em">--gorshort = {0,1} <br>
Shorten clauses with OR gates (default = 1).</p>

<p style="margin-top: 1em">--gandrem = {0,1} <br>
Remove clauses with AND gates (default = 1).</p>

<p style="margin-top: 1em">--gateeqlit = {0,1} <br>
Find equivalent literals using gates (default = 1).</p>

<p style="margin-top: 1em">--printgatedot = {0,1} <br>
Print gate structure regularly to the file
&rsquo;gatesX.dot&rsquo; (default = 0).</p>

<p style="margin-top: 1em">SQL <br>
--sql = {0,1,2} <br>
Write to SQL (default = 1). 0 means do not attempt to write
to the database. 1 means to try to write to the database,
but continue if the attempt fails. 2 means to <br>
abort if the database cannot be written.</p>

<p style="margin-top: 1em">--topnvars = &lt;num&gt; <br>
At every restart, dump data about the top N variables
(default = 0). If set to 0, nothing is dumped.</p>

<p style="margin-top: 1em">--dumptreevar = {0,1} <br>
Dump variance stats of the variables&rsquo; decision and
trail depths (default = 0).</p>

<p style="margin-top: 1em">--sqluser = &lt;username&gt;
<br>
The SQL user to connect with (default = cmsat_solver).</p>

<p style="margin-top: 1em">--sqlpass = &lt;password&gt;
<br>
The SQL password to connect with.</p>

<p style="margin-top: 1em">--sqldb = &lt;database&gt; <br>
The SQL database name (default = cmsat). The default is used
by the PHP system, so it is highly recommended.</p>

<p style="margin-top: 1em">--sqlserver = &lt;hostname&gt;
<br>
The SQL server hostname or IP address (default =
localhost).</p>

<p style="margin-top: 1em">MISCELLANEOUS <br>
--vivif = {0,1} <br>
Regularly execute clause vivification (default = 1).</p>

<p style="margin-top: 1em">--viviflongmaxm = &lt;num&gt;
<br>
Maximum time in mega-bogoprops to spend on vivifying long
irreducible clauses by enqueueing and propagating (default =
20).</p>

<p style="margin-top: 1em">--viviffastmaxm = &lt;num&gt;
<br>
Maximum time in mega-bogoprops to spend on vivifying long
irreducible clauses through watches, cache and stamps
(default = 400).</p>

<p style="margin-top: 1em">--sortwatched = {0,1} <br>
Sort watches according to size (default = 1).</p>

<p style="margin-top: 1em">--renumber = {0,1} <br>
Renumber variables to increase CPU cache efficiency (default
= 1).</p>

<p style="margin-top: 1em">--savemem = {0,1} <br>
Save memory by deallocating variable space after renumbering
(default = 1). This only works if renumbering is active.</p>

<p style="margin-top: 1em">--implicitmanip = {0,1} <br>
Subsume and strengthen implicit clauses with each other
(default = 1).</p>

<p style="margin-top: 1em">--implsubsto = &lt;num&gt; <br>
The timeout of implicit subsumption in mega-bogoprops
(default = 1900).</p>

<p style="margin-top: 1em">--burst = &lt;num&gt; <br>
The number of conflicts to do in burst search (default =
300).</p>

<p style="margin-top: 1em">--clearinter = {0,1} <br>
Interrupt threads cleanly, all the time (default = 0).</p>

<p style="margin-top: 1em">--zero-exit-status = {0,1} <br>
Exit with status zero in case the solving has finished
without an issue.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The output is a solution, together with some timing
information. If --zero-exit-status has not been specified,
then the exit status is as follows:</p>

<p style="margin-top: 1em">10 The problem is
satisfiable.</p>

<p style="margin-top: 1em">15 The problem&rsquo;s
satisfiability was not determined.</p>

<p style="margin-top: 1em">20 The problem is
unsatisfiable.</p>

<p style="margin-top: 1em">AUTHOR <br>
Mate Soos (soos@srlabs.de)</p>

<p style="margin-top: 1em">SEE ALSO <br>
The DIMACS input format can be looked up here:</p>


<p style="margin-top: 1em">http://www.satcompetition.org/2009/format-benchmarks2009.html</p>

<p style="margin-top: 1em">Mate Soos 4.5.3
CRYPTOMINISAT(1)</p>
<hr>
</body>
</html>
