<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>CRYPTOMINISAT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CRYPTOMINISAT(1)</td>
    <td class="head-vol">User Commands</td>
    <td class="head-rtitle">CRYPTOMINISAT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
cryptominisat - conflict-driven SAT solver
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>cryptominisat</b> [ <i>OPTIONS</i>] &lt;<i>input-files</i>&gt;
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
CryptoMiniSat is a SAT solver, solving problems given in CNF, or conjunctive
  normal form. CryptoMiniSat retains much of the API of MiniSat, but offers more
  versatility and better speed on many problems.
<div style="height: 1.00em;">&#x00A0;</div>
The program is a classical conflict-driven solver, with variable activities,
  clause learning and clause deletion. It however incorporates a number of
  advanced CNF simplification functionalities which should help the speed of
  solving. Further, it incorporates some advanced memory-management features
  that should help in getting the most out of modern CPU caches.
<div style="height: 1.00em;">&#x00A0;</div>
The input format is that of DIMACS CNF, i.e. a header of the form
<div style="height: 1.00em;">&#x00A0;</div>
p cnf VARS CLAUSES
<div style="height: 1.00em;">&#x00A0;</div>
where VARS is the number of variables, and CLAUSES is the number of clauses in
  the problem. It then lists the set of clauses such as:
<div style="height: 1.00em;">&#x00A0;</div>
1 -2 0
<div style="height: 1.00em;">&#x00A0;</div>
which is equivalent to the 2-long clause &quot;v1 OR NOT v2 = TRUE&quot;
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h,--help</b></dt>
  <dd class="It-tag">Print help text.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v,--version</b></dt>
  <dd class="It-tag">Print cryptominisat's version number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--input</b> = &lt;<i>file1</i>,<i>file2</i>,...&gt;</dt>
  <dd class="It-tag">Specify the file(s) to read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r,--random</b> = &lt;<i>seed</i>&gt; [0 - 2^32-1]</dt>
  <dd class="It-tag">Sets the random seed, used for picking decision variables
      (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t,--threads</b> = &lt;<i>num</i>&gt; [1..]</dt>
  <dd class="It-tag">Number of threads (default is 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sync</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Sync threads every <i>num</i> conflicts (default =
    6000).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maxtime</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Stop solving after this much time, print stats and
    exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maxconfl</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Stop solving after this many conflicts, print stats and
      exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--occsimp</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform occurrence-list-based optimizations, such as
      variable eliminiation, subsumption, and bounded variable addition. Default
      is 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clbtwsimp</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Perform this many cleaning iterations between
      simplification rounds (default = 2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d,--drup</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Put DRUP verification information into this file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--drupexistscheck</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Check if the DRUP file provided already exists (default =
      1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--drupdebug</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Output DRUP verification to the console. This is helpful to
      see where DRUP fails. Use in conjunction with <b>--verb 20</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="RESTART"><a class="selflink" href="#RESTART">RESTART</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--agilg</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">See paper by Armin Biere on agilities.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--restart</b> =
    <i>{geom,agility,glue,glueagility}</i></dt>
  <dd class="It-tag">Choose the restart strategy to follow.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--agillim</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The agility below which the agility is considered too low
      (default = 0.03).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--agilviollim</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The number of agility violations over which to demand a
      restart (default = 20).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--gluehist</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The size of the moving window for short term glue history
      of redundant clauses (default = 100). If higher, the minimal number of
      conflicts between restarts is longer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--blkrest</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform blocking restarts as per Glucose 3.0 (default =
    1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--blkrestlen</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The length of the long term trail size for blocking restart
      (default = 5000).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--blkrestmultip</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Multiplier used for blocking restart cut-off, called
      &quot;R&quot; in Glucose 3.0 (default = 1.4).</dd>
</dl>
<h2 class="Ss" title="Ss" id="PRINTING"><a class="selflink" href="#PRINTING">PRINTING</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verb</b> = &lt;<i>num</i>&gt; [0-10]</dt>
  <dd class="It-tag">Verbosity of the solver (default = 2). Verbosity 0 only
      prints the results.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbstat</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Turns off verbose stats if needed (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--printfull</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Print more thorough, but different, stats (default =
    0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s,--printsol</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Print the satisfying assignment if the solution is SAT
      (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--printtrail</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Print the longest decision trail of the last N conflicts;
      if 0, the decision trail is not printed (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--printbest</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Print the best N irredundant longer-than-3 learnt clauses;
      if 0, nothing is printed (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--printtimes</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Print the time taken for each simplification run; if 0,
      nothing is printed, which makes logs easier to compare (default = 1).</dd>
</dl>
<h2 class="Ss" title="Ss" id="PROPAGATION"><a class="selflink" href="#PROPAGATION">PROPAGATION</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--updateglue</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Update glues while propagating (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lhbr</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform lazy hyper-binary resolution while propagating
      (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--binpri</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Propagated binary clauses are strictly first (default =
    0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--otfhyper</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform hyper-binary resolution at decision level 1 after
      every restart and during probing (default = 1).</dd>
</dl>
<h2 class="Ss" title="Ss" id="REDUNDANT_CLAUSE_REMOVAL"><a class="selflink" href="#REDUNDANT_CLAUSE_REMOVAL">REDUNDANT
  CLAUSE REMOVAL</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ltclean</b> = &lt;<i>num</i>&gt; [0-1]</dt>
  <dd class="It-tag">Remove at least this ratio of redundant clauses when doing
      redundant clause cleaning (default = 0.5).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clean</b> =
    <i>{size,glue,activity,prconf,confdep}</i></dt>
  <dd class="It-tag">Metric used to clean clauses (default = prconf). Use
      &quot;prconf&quot; for the sum of propagations and conflicts. Use
      &quot;confdep&quot; for (propagations + conflicts) / (depth at which they
      were caused).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--noremfreshgl2</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Don't remove glue 2 clauses that are fresh (default =
    0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cleanconflmult</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">If propagations and conflicts are used to clean, the value
      by which conflicts are multiplied relative to propagations (default = 1).
      Conflicts are much rarer, but maybe more useful.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--lockuip</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The number of clauses to lock into the database per
      cleaning based on UIP usage (default = 500).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--locktop</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The number of clauses to lock into the database per
      cleaning based on the best uncleaned clauses as per the selected heuristic
      (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--perfmult</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Value by which to multiply clause performance values after
      every clause cleaning (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clearstat</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Clear clause statistics data of each clause after clause
      cleaning (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--startclean</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Clean the first time after this many conflicts (default =
      10000).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--incclean</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Clean increment cleaning by this factor for the next
      cleaning (default = 1.1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maxredratio</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Never have more than N * (irred_clauses) redundant clauses
      (default = 10).</dd>
</dl>
<h2 class="Ss" title="Ss" id="VARIABLE_BRANCHING"><a class="selflink" href="#VARIABLE_BRANCHING">VARIABLE
  BRANCHING</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vincmult</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Variable activity increase multipler (default = 11).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vincdiv</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Variable activity increase divider (default = 10); it
      <b>must</b> be smaller than the multiplier.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vincvary</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Variable activity divider and multiplier are both changed
      +/- this amount, randomly, in sync (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vincstart</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Variable activity increase stars with this value. Make sure
      that this, multiplied by the multiplier and divided by the divider, is
      larger than itself (default = 128).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--freq</b> = &lt;<i>num</i>&gt; [0-1]</dt>
  <dd class="It-tag">Frequency of picking decision variables at random (default
      = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dompickf</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Use the dominating literal once in every N when picking
      decision literal (default = 400).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--morebump</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Bump variables' activities based on the glue of redundant
      clauses there are in during UIP generation, as per Glucose (default =
    1).</dd>
</dl>
<h2 class="Ss" title="Ss" id="VARIABLE_POLARITY"><a class="selflink" href="#VARIABLE_POLARITY">VARIABLE
  POLARITY</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--polar</b> = <i>{true,false,rnd,auto}</i></dt>
  <dd class="It-tag">Selects the polarity mode (default = auto). True selects
      only positive polarity when branching. False selects only negative
      polarity when branching. Auto selects the last polarity used (also called
      'caching').</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--calcpolar1st</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Calculate the polarity of variables based on their
      occurrences at startup of solve() (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--calcpolarall</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Calculate the polarity of variables based on their
      occurrences at startup and after every simplification (default = 1).</dd>
</dl>
<h2 class="Ss" title="Ss" id="CONFLICT"><a class="selflink" href="#CONFLICT">CONFLICT</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--recur</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform recursive minimisation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--moreminim</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform strong minimisation at conflict gen.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--moreminimcache</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Timeout in microsteps for each more minimisation with cache
      (default = 200). Only active if 'moreminim' is on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--moreminimbin</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Timeout in microsteps for each more minimisation with
      binary clauses (default = 100). Only active if 'moreminim' is on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--alwaysmoremin</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Always strong-minimise clauses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--otfsubsume</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform on-the-fly subsumption.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rewardotfsubsume</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Reward with this many propagations and conflicts a clause
      that has been shortened with on-the-fly subsumption (default = 3).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--printimpldot</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Print implication graph DOT files, for input into
    graphviz.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ITERATIVE_SOLVE"><a class="selflink" href="#ITERATIVE_SOLVE">ITERATIVE
  SOLVE</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maxsol</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Search for the given number of solutions (default =
    1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dumpred</b> = &lt;<i>filename</i>&gt;</dt>
  <dd class="It-tag">If stopped, dump redundant clauses here.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maxdump</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Maximum length of redundant clauses to dump.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dumpirred</b> = &lt;<i>filename</i>&gt;</dt>
  <dd class="It-tag">If stopped, dump irredundant original problems here.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debuglib</b></dt>
  <dd class="It-tag">Solve at specific <b>c Solver::solve()</b> points in the
      CNF file. Used to debug file generated by Solver's
      <b>needLibraryCNFFile()</b> function.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dumpresult</b> = &lt;<i>filename</i>&gt;</dt>
  <dd class="It-tag">Write result(s) to this file.</dd>
</dl>
<h2 class="Ss" title="Ss" id="PROBING"><a class="selflink" href="#PROBING">PROBING</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bothprop</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Do propagations solely to propagate the same value twice
      (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--probe</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Carry out probing (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--probemaxm</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Time in mega-bogoprops to perform probing (default =
    1900).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--transred</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Remove useless binary clauses; i.e., transitive reduction
      (default = 1).</dd>
</dl>
<h2 class="Ss" title="Ss" id="STAMPING"><a class="selflink" href="#STAMPING">STAMPING</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--stamp</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Use time stamping as per the Heule, Javisalo, and Biere
      paper (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cache</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Use an implication cache (default = 1). This option may use
      a lot of memory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cachesize</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Maximum size of the implication cache in MB (default =
      2048). The cache may temporarily use more memory, but will be deleted and
      disabled if this limit is reached.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--calcreach</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Calculate literal reachability (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cachecutoff</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">If the number of literals propagated by a literal is
      greater than this value, the literal is not included in the implication
      cache (default = 2000).</dd>
</dl>
<h2 class="Ss" title="Ss" id="SIMPLIFICATION"><a class="selflink" href="#SIMPLIFICATION">SIMPLIFICATION</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--schedsimp</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform regular simplification rounds (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--presimp</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform simplification at the very start (default =
    0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--varelim</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform variable elimination as per Een and Biere (default
      = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--emptyelim</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform empty resolvent elimination using the bit-map trick
      (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--elimstrgy</b> = <i>{heuristic,calculate}</i></dt>
  <dd class="It-tag">The strategy used to sort variable elimination order
      (default = heuristic). The heuristic strategy uses intelligent guessing.
      The calculate strategy uses exact calculation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--elimcplxupd</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Update estimated elimination complexity on-the-fly while
      eliminating (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--elimcoststrategy</b> = &lt;<i>num</i>&gt; [0-1]</dt>
  <dd class="It-tag">How the simple guessing strategy is calculated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--strengthen</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform clause contraction through resolution (default =
      1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bva</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform bounded variable addition (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bvalim</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Maximum number of variables to add by bounded variable
      addition per call (default = 150000).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bva2lit</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Bounded variable addition with 2-literal difference hack,
      too (default = 1). Beware, this reduces the effectiveness of 1-literal
      difference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--noextbinsubs</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">No extended subsumption with binary clauses (default =
    1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--eratio</b> = &lt;<i>num</i>&gt; [0-1]</dt>
  <dd class="It-tag">Eliminate this ratio of free variables at most per variable
      elimination iteration (default = 0.12).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--skipresol</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Skip BVE resolvents in case they belong to a gate (default
      = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--occredmax</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Don't add any redundant clauses larger than this to the
      occur list (default = 200).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--occirredmaxmb</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Don't allow the irredundant occur size to be more than this
      many MB (default = 800).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--occredmaxmb</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Don't allow the redundant occur size to be more than this
      many MB (default = 800).</dd>
</dl>
<h2 class="Ss" title="Ss" id="EQUIVALENT_LITERAL"><a class="selflink" href="#EQUIVALENT_LITERAL">EQUIVALENT
  LITERAL</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--scc</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Find equivalent literals through SCC and replace them
      (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--extscc</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform SCC using cache (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sccperc</b> = &lt;<i>num</i>&gt; [0-1]</dt>
  <dd class="It-tag">Perform SCC only if the number of new binary clauses is at
      least this percentage of the number of free variables (default =
    0.02).</dd>
</dl>
<h2 class="Ss" title="Ss" id="COMPONENT"><a class="selflink" href="#COMPONENT">COMPONENT</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--findcomp</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Find components, but do not treat them (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--comps</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Perform component-finding and separate handling (default =
      1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--compsfrom</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Do component finding only after this many simplification
      rounds (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--compsvar</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Only use components when the number of variables is below
      this limit (default = 1000000).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--compslimit</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Limit how much time is spent in component finding (default
      = 500).</dd>
</dl>
<h2 class="Ss" title="Ss" id="XOR-RELATED"><a class="selflink" href="#XOR-RELATED">XOR-RELATED</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xor</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Discover long XORs (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xorcache</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Use cache when finding XORs (default = 0). This finds a
      <i>lot</i> more XORs, but takes a lot more time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--echelonxor</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Extract data from XORs through echelonization <i>at the top
      level only</i> (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--maxxormat</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The maximum matrix size (i.e., number of elements) that we
      should try to echelonize (default = 10000000).</dd>
</dl>
<h2 class="Ss" title="Ss" id="GATE-RELATED"><a class="selflink" href="#GATE-RELATED">GATE-RELATED</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--gates</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Find gates (default = 1). Disables all other gate-related
      sub-options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--gorshort</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Shorten clauses with OR gates (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--gandrem</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Remove clauses with AND gates (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--gateeqlit</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Find equivalent literals using gates (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--printgatedot</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Print gate structure regularly to the file 'gatesX.dot'
      (default = 0).</dd>
</dl>
<h2 class="Ss" title="Ss" id="SQL"><a class="selflink" href="#SQL">SQL</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sql</b> = <i>{0,1,2}</i></dt>
  <dd class="It-tag">Write to SQL (default = 1). 0 means do not attempt to write
      to the database. 1 means to try to write to the database, but continue if
      the attempt fails. 2 means to abort if the database cannot be
    written.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--topnvars</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">At every restart, dump data about the top N variables
      (default = 0). If set to 0, nothing is dumped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dumptreevar</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Dump variance stats of the variables' decision and trail
      depths (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sqluser</b> = &lt;<i>username</i>&gt;</dt>
  <dd class="It-tag">The SQL user to connect with (default = cmsat_solver).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sqlpass</b> = &lt;<i>password</i>&gt;</dt>
  <dd class="It-tag">The SQL password to connect with.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sqldb</b> = &lt;<i>database</i>&gt;</dt>
  <dd class="It-tag">The SQL database name (default = cmsat). The default is
      used by the PHP system, so it is highly recommended.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sqlserver</b> = &lt;<i>hostname</i>&gt;</dt>
  <dd class="It-tag">The SQL server hostname or IP address (default =
      localhost).</dd>
</dl>
<h2 class="Ss" title="Ss" id="MISCELLANEOUS"><a class="selflink" href="#MISCELLANEOUS">MISCELLANEOUS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vivif</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Regularly execute clause vivification (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--viviflongmaxm</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Maximum time in mega-bogoprops to spend on vivifying long
      irreducible clauses by enqueueing and propagating (default = 20).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--viviffastmaxm</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">Maximum time in mega-bogoprops to spend on vivifying long
      irreducible clauses through watches, cache and stamps (default =
    400).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sortwatched</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Sort watches according to size (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--renumber</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Renumber variables to increase CPU cache efficiency
      (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--savemem</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Save memory by deallocating variable space after
      renumbering (default = 1). This only works if renumbering is active.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--implicitmanip</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Subsume and strengthen implicit clauses with each other
      (default = 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--implsubsto</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The timeout of implicit subsumption in mega-bogoprops
      (default = 1900).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--burst</b> = &lt;<i>num</i>&gt;</dt>
  <dd class="It-tag">The number of conflicts to do in burst search (default =
      300).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--clearinter</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Interrupt threads cleanly, all the time (default = 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--zero-exit-status</b> = <i>{0,1}</i></dt>
  <dd class="It-tag">Exit with status zero in case the solving has finished
      without an issue.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
The output is a solution, together with some timing information. If
  --zero-exit-status has not been specified, then the exit status is as follows:
<dl class="Bl-tag">
  <dt class="It-tag">10</dt>
  <dd class="It-tag">The problem is satisfiable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">15</dt>
  <dd class="It-tag">The problem's satisfiability was not determined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">20</dt>
  <dd class="It-tag">The problem is unsatisfiable.</dd>
</dl>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Mate Soos (soos@srlabs.de)
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The DIMACS input format can be looked up here:
<div style="height: 1.00em;">&#x00A0;</div>
http://www.satcompetition.org/2009/format-benchmarks2009.html</div>
<table class="foot">
  <tr>
    <td class="foot-date">4.5.3</td>
    <td class="foot-os">Mate Soos</td>
  </tr>
</table>
</body>
</html>
