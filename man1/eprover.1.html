<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:07:29 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>E(1) User Commands E(1)</p>

<p style="margin-top: 1em">NAME <br>
E - manual page for E 2.0 Turzum</p>

<p style="margin-top: 1em">SYNOPSIS <br>
eprover [options] [files]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
E 2.0 &quot;Turzum&quot;</p>

<p style="margin-top: 1em">Read a set of first-order
clauses and formulae and try to refute it.</p>

<p style="margin-top: 1em">OPTIONS <br>
-h</p>

<p style="margin-top: 1em">--help</p>

<p style="margin-top: 1em">Print a short description of
program usage and options.</p>

<p style="margin-top: 1em">-V</p>

<p style="margin-top: 1em">--version</p>

<p style="margin-top: 1em">Print the version number of the
prover. Please include this with all bug reports (if
any).</p>

<p style="margin-top: 1em">-v</p>

<p style="margin-top: 1em">--verbose[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Verbose comments on the progress
of the program. This differs from the output level (below)
in that technical information is printed to stderr, while
the output level <br>
determines which logical manipulations of the clauses are
printed to stdout. The short form or the long form without
the optional argument is equivalent to --verbose=1.</p>

<p style="margin-top: 1em">-o &lt;arg&gt;</p>

<p style="margin-top: 1em">--output-file=&lt;arg&gt;</p>

<p style="margin-top: 1em">Redirect output into the named
file.</p>

<p style="margin-top: 1em">-s</p>

<p style="margin-top: 1em">--silent</p>

<p style="margin-top: 1em">Equivalent to
--output-level=0.</p>

<p style="margin-top: 1em">-l &lt;arg&gt;</p>

<p style="margin-top: 1em">--output-level=&lt;arg&gt;</p>

<p style="margin-top: 1em">Select an output level, greater
values imply more verbose output. Level 0 produces nearly no
output, level 1 will output each clause as it is processed,
level 2 will out&acirc; <br>
put generating inferences, level 3 will give a full protocol
including rewrite steps and level 4 will include some
internal clause renamings. Levels &gt;= 2 also imply PCL2
<br>
or TSTP formats (which can be post-processed with suitable
tools).</p>

<p style="margin-top: 1em">-p</p>


<p style="margin-top: 1em">--proof-object[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Generate (and print, in case of
success) an internal proof object. Level 0 will not build a
proof object, level 1 will build a simple, compact proof
object that only con&acirc; <br>
tains inference rules and dependencies, level 2 will build a
proof object where inferences are unambiguously described by
giving inference positions, and level 3 will <br>
expand this to a proof object where all intermediate results
are explicit. This feature is under development, so far only
level 0 and 1 are operational. The short form or <br>
the long form without the optional argument is equivalent to
--proof-object=1.</p>

<p style="margin-top: 1em">--proof-graph[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Generate (and print, in case of
success) an internal proof object in the form of a GraphViz
dot graph. The optional argument can be 1 (nodes are
labelled with just name of <br>
the clause), 2 (nodes are labelled with just the TPTP
clause/formula) or 3 (nodes also labelled with
source/inference record. The option without the optional
argument is <br>
equivalent to --proof-graph=3.</p>

<p style="margin-top: 1em">-d</p>

<p style="margin-top: 1em">--full-deriv</p>

<p style="margin-top: 1em">Include all derived
formuas/clauses in the proof graph/proof object, not just
the ones contributing to the actual proof.</p>

<p style="margin-top: 1em">--record-gcs</p>

<p style="margin-top: 1em">Record given-clause selection as
separate (pseudo-)inferences and preserve the form of given
clauses evaluated and selected via archiving for analysis
and possibly machine <br>
learning.</p>


<p style="margin-top: 1em">--training-examples[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Generate and process training
examples from the proof search object. Implies --record-gcs.
The argument is a binary or of the desired processig. Bit
zero prints positive <br>
exampels. Bit 1 prints negative examples. Additional
selectors will be added later. The option without the
optional argument is equivalent to
--training-examples=1.</p>

<p style="margin-top: 1em">--pcl-terms-compressed</p>

<p style="margin-top: 1em">Print terms in the PCL output in
shared representation.</p>

<p style="margin-top: 1em">--pcl-compact</p>

<p style="margin-top: 1em">Print PCL steps without
additional spaces for formatting (safes disk space for large
protocols).</p>


<p style="margin-top: 1em">--pcl-shell-level[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Determines level to which
clauses and formulas are suppressed in the output. Level 0
will print all, level 1 will only print initial
clauses/formulas, level 2 will print <br>
no clauses or axioms. All levels will still print the
dependency graph. The option without the optional argument
is equivalent to --pcl-shell-level=1.</p>

<p style="margin-top: 1em">--print-statistics</p>

<p style="margin-top: 1em">Print the inference statistics
(only relevant for output level 0, otherwise they are
printed automatically.</p>

<p style="margin-top: 1em">-0</p>

<p style="margin-top: 1em">--print-detailed-statistics</p>

<p style="margin-top: 1em">Print data about the proof state
that is potentially expensive to collect. Includes number of
term cells and number of rewrite steps.</p>

<p style="margin-top: 1em">-S</p>


<p style="margin-top: 1em">--print-saturated[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Print the (semi-) saturated
clause sets after terminating the saturation process. The
argument given describes which parts should be printed in
which order. Legal charac&acirc; <br>
ters are &rsquo;eigEIGaA&rsquo;, standing for processed
positive units, processed negative units, processed
non-units, unprocessed positive units, unprocessed negative
units, unpro&acirc; <br>
cessed non-units, and two types of additional equality
axioms, respectively. Equality axioms will only be printed
if the original specification contained real equality. <br>
In this case, &rsquo;a&rsquo; requests axioms in which a
separate substitutivity axiom is given for each argument
position of a function or predicate symbol, while
&rsquo;A&rsquo; requests a sin&acirc; <br>
gle substitutivity axiom (covering all positions) for each
symbol. The short form or the long form without the optional
argument is equivalent to --print-saturated=eigEIG.</p>

<p style="margin-top: 1em">--print-sat-info</p>

<p style="margin-top: 1em">Print additional information
(clause number, weight, etc) as a comment for clauses from
the semi-saturated end system.</p>


<p style="margin-top: 1em">--filter-saturated[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Filter the <br>
(semi-) saturated clause sets after terminating the</p>

<p style="margin-top: 1em">saturation process. The argument
is a string describing which operations to take (and in
which order). Options are &rsquo;u&rsquo; (remove all
clauses with more than one literal), &rsquo;c&rsquo; <br>
(delete all but one copy of identical clauses,
&rsquo;n&rsquo;, &rsquo;r&rsquo;, &rsquo;f&rsquo; (forward
contraction, unit-subsumption only, no rewriting, rewriting
with rules only, full rewriting, respec&acirc; <br>
tively), and &rsquo;N&rsquo;, &rsquo;R&rsquo; and
&rsquo;F&rsquo; (as their lower case counterparts, but with
non-unit-subsumption enabled as well). The option without
the optional argument is equivalent to <br>
--filter-saturated=Fc.</p>

<p style="margin-top: 1em">--prune</p>

<p style="margin-top: 1em">Stop after relevancy pruning,
SInE pruning, and output of the initial clause- and formula
set. This will automatically set output level to 4 so that
the pruned problem <br>
specification is printed. Note that the desired pruning
methods must still be specified (e.g.
&rsquo;--sine=Auto&rsquo;).</p>

<p style="margin-top: 1em">--cnf</p>

<p style="margin-top: 1em">Convert the input problem into
clause normal form and print it. This is (nearly) equivalent
to &rsquo;--print-saturated=eigEIG
--processed-clauses-limit=0&rsquo; and will by default <br>
perform some usually useful simplifications. You can
additionally specify e.g. &rsquo;--no-preprocessing&rsquo;
if you want just the result of CNF translation.</p>

<p style="margin-top: 1em">--print-pid</p>

<p style="margin-top: 1em">Print the process id of the
prover as a comment after option processing.</p>

<p style="margin-top: 1em">--print-version</p>

<p style="margin-top: 1em">Print the version number of the
prover as a comment after option processing. Note that
unlike -version, the prover will not terminate, but proceed
normally.</p>

<p style="margin-top: 1em">--error-on-empty</p>

<p style="margin-top: 1em">Return with an error code if the
input file contains no clauses. Formally, the empty clause
set (as an empty conjunction of clauses) is trivially
satisfiable, and E will <br>
treat any empty input set as satisfiable. However, in
composite systems this is more often a sign that something
went wrong. Use this option to catch such bugs.</p>

<p style="margin-top: 1em">-m &lt;arg&gt;</p>

<p style="margin-top: 1em">--memory-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">Limit the memory the prover may
use. The argument is the allowed amount of memory in MB. If
you use the argument &rsquo;Auto&rsquo;, the system will try
to figure out the amount of <br>
physical memory of your machine and claim most of it. This
option may not work everywhere, due to broken and/or strange
behaviour of setrlimit() in some UNIX implementa&acirc; <br>
tions, and due to the fact that I know of no portable way to
figure out the physical memory in a machine. Both the option
and the &rsquo;Auto&rsquo; version do work under all tested
<br>
versions of Solaris and GNU/Linux. Due to problems with
limit data types, it is currently impossible to set a limit
of more than 2 GB (2048 MB).</p>

<p style="margin-top: 1em">--cpu-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Limit the cpu time the prover
should run. The optional argument is the CPU time in
seconds. The prover will terminate immediately after
reaching the time limit, regardless <br>
of internal state. This option may not work everywhere, due
to broken and/or strange behaviour of setrlimit() in some
UNIX implementations. It does work under all tested <br>
versions of Solaris, HP-UX, MacOS-X, and GNU/Linux. As a
side effect, this option will inhibit core file writing.
Please note that if you use both --cpu-limit and <br>
--soft-cpu-limit, the soft limit has to be smaller than the
hard limit to have any effect. The option without the
optional argument is equivalent to --cpu-limit=300.</p>


<p style="margin-top: 1em">--soft-cpu-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Limit the cpu time the prover
should spend in the main saturation phase. The prover will
then terminate gracefully, i.e. it will perform
post-processing, filtering and <br>
printing of unprocessed clauses, if these options are
selected. Note that for some filtering options (in
particular those which perform full subsumption), the
post-pro&acirc; <br>
cessing time may well be larger than the saturation time.
This option is particularly useful if you want to use E as a
preprocessor or lemma generator in a larger system. <br>
The option without the optional argument is equivalent to
--soft-cpu-limit=290.</p>

<p style="margin-top: 1em">-R</p>

<p style="margin-top: 1em">--resources-info</p>

<p style="margin-top: 1em">Give some information about the
resources used by the prover. You will usually get CPU time
information. On systems returning more information with the
rusage() system <br>
call, you will also get information about memory
consumption.</p>

<p style="margin-top: 1em">-C &lt;arg&gt;</p>


<p style="margin-top: 1em">--processed-clauses-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the maximal number of
clauses to process (i.e. the number of traversals of the
main-loop).</p>

<p style="margin-top: 1em">-P &lt;arg&gt;</p>


<p style="margin-top: 1em">--processed-set-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the maximal size of the set
of processed clauses. This differs from the previous option
in that redundant and back-simplified processed clauses are
not counted.</p>

<p style="margin-top: 1em">-U &lt;arg&gt;</p>


<p style="margin-top: 1em">--unprocessed-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the maximal size of the set
of unprocessed clauses. This is a termination condition, not
something to use to control the deletion of bad clauses.
Compare <br>
--delete-bad-limit.</p>

<p style="margin-top: 1em">-T &lt;arg&gt;</p>


<p style="margin-top: 1em">--total-clause-set-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the maximal size of the set
of all clauses. See previous option.</p>


<p style="margin-top: 1em">--generated-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the maximal number of
generated clauses before the proof search stops. This is a
reasonable (though not great) estimate of the work done.</p>


<p style="margin-top: 1em">--tb-insert-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the maximal number of of
term bank term top insertions. This is a reasonable (though
not great) estimate of the work done.</p>

<p style="margin-top: 1em">--answers[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the maximal number of
answers to print for existentially quantified questions.
Without this option, the prover terminates after the first
answer found. If the value is <br>
different from 1, the prover is no longer guaranteed to
terminate, even if there is a finite number of answers. The
option without the optional argument is equivalent to <br>
--answers=2147483647.</p>

<p style="margin-top: 1em">--conjectures-are-questions</p>

<p style="margin-top: 1em">Treat all conjectures as
questions to be answered. This is a wart necessary because
CASC-J6 has categories requiring answers, but does not yet
support the &rsquo;question&rsquo; type <br>
for formulas.</p>

<p style="margin-top: 1em">-n</p>

<p style="margin-top: 1em">--eqn-no-infix</p>

<p style="margin-top: 1em">In LOP, print equations in
prefix notation equal(x,y).</p>

<p style="margin-top: 1em">-e</p>

<p style="margin-top: 1em">--full-equational-rep</p>

<p style="margin-top: 1em">In LOP. print all literals as
equations, even non-equational ones.</p>

<p style="margin-top: 1em">--lop-in</p>

<p style="margin-top: 1em">Set E-LOP as the input format.
If no input format is selected by this or one of the
following options, E will guess the input format based on
the first token. It will <br>
almost always correctly recognize TPTP-3, but it may
misidentify E-LOP files that use TPTP meta-identifiers as
logical symbols.</p>

<p style="margin-top: 1em">--pcl-out</p>

<p style="margin-top: 1em">Set PCL as the proof object
output format.</p>

<p style="margin-top: 1em">--tptp-in</p>

<p style="margin-top: 1em">Set TPTP-2 as the input format
(but note that includes are still handled according to
TPTP-3 semantics).</p>

<p style="margin-top: 1em">--tptp-out</p>

<p style="margin-top: 1em">Print TPTP format instead of
E-LOP. Implies --eqn-no-infix and will ignore
--full-equational-rep.</p>

<p style="margin-top: 1em">--tptp-format</p>

<p style="margin-top: 1em">Equivalent to --tptp-in and
--tptp-out.</p>

<p style="margin-top: 1em">--tptp2-in</p>

<p style="margin-top: 1em">Synonymous with --tptp-in.</p>

<p style="margin-top: 1em">--tptp2-out</p>

<p style="margin-top: 1em">Synonymous with --tptp-out.</p>

<p style="margin-top: 1em">--tptp2-format</p>

<p style="margin-top: 1em">Synonymous with
--tptp-format.</p>

<p style="margin-top: 1em">--tstp-in</p>

<p style="margin-top: 1em">Set TPTP-3 as the input format
(Note that TPTP-3 syntax is still under development, and the
version in E may not be fully conforming at all times. E
works on all TPTP <br>
6.3.0 FOF and CNF files (including includes).</p>

<p style="margin-top: 1em">--tstp-out</p>

<p style="margin-top: 1em">Print output clauses in TPTP-3
syntax. In particular, for output levels &gt;=2, write
derivations as TPTP-3 derivations.</p>

<p style="margin-top: 1em">--tstp-format</p>

<p style="margin-top: 1em">Equivalent to --tstp-in and
--tstp-out.</p>

<p style="margin-top: 1em">--tptp3-in</p>

<p style="margin-top: 1em">Synonymous with --tstp-in.</p>

<p style="margin-top: 1em">--tptp3-out</p>

<p style="margin-top: 1em">Synonymous with --tstp-out.</p>

<p style="margin-top: 1em">--tptp3-format</p>

<p style="margin-top: 1em">Synonymous with
--tstp-format.</p>

<p style="margin-top: 1em">--auto</p>

<p style="margin-top: 1em">Automatically determine settings
for proof search. This is equivalent to -xAuto -tAuto
--sine=Auto.</p>

<p style="margin-top: 1em">--satauto</p>

<p style="margin-top: 1em">Automatically determine settings
for proof/saturation search. This is equivalent to -xAuto
-tAuto.</p>

<p style="margin-top: 1em">--autodev</p>

<p style="margin-top: 1em">Automatically determine settings
for proof search (development version). This is equivalent
to -xAutoDev -tAutoDev --sine=Auto.</p>

<p style="margin-top: 1em">--satautodev</p>

<p style="margin-top: 1em">Automatically determine settings
for proof/saturation search (development version). This is
equivalent to -xAutoDev -tAutoDev.</p>

<p style="margin-top: 1em">--auto-schedule</p>

<p style="margin-top: 1em">Use the (experimental) strategy
scheduling. This will try several different fully specified
search strategies (aka &quot;Auto-Modes&quot;), one after
the other, until a proof or <br>
saturation is found, or the time limit is exceeded.</p>

<p style="margin-top: 1em">--satauto-schedule</p>

<p style="margin-top: 1em">Use the (experimental) strategy
scheduling without SInE, thus maintaining completeness.</p>

<p style="margin-top: 1em">--no-preprocessing</p>

<p style="margin-top: 1em">Do not perform preprocessing on
the initial clause set. Preprocessing currently removes
tautologies and orders terms, literals and clauses in a
certain (&quot;canonical&quot;) way <br>
before anything else happens. Unless limited by one of the
following options, it will also unfold equational
definitions.</p>


<p style="margin-top: 1em">--eq-unfold-limit=&lt;arg&gt;</p>

<p style="margin-top: 1em">During preprocessing, limit
unfolding (and removing) of equational definitions to those
where the expanded definition is at most the given limit
bigger (in terms of stan&acirc; <br>
dard weight) than the defined term.</p>


<p style="margin-top: 1em">--eq-unfold-maxclauses=&lt;arg&gt;</p>

<p style="margin-top: 1em">During preprocessing,
don&rsquo;t try unfolding of equational definitions if the
problem has more than this limit of clauses.</p>

<p style="margin-top: 1em">--no-eq-unfolding</p>

<p style="margin-top: 1em">During preprocessing, abstain
from unfolding (and removing) equational definitions.</p>

<p style="margin-top: 1em">--sine[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Apply SInE to prune the
unprocessed axioms with the specified filter.
&rsquo;Auto&rsquo; will automatically pick a filter. The
option without the optional argument is equivalent to <br>
--sine=Auto.</p>


<p style="margin-top: 1em">--rel-pruning-level[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Perform relevancy pruning up to
the given level on the unprocessed axioms. The option
without the optional argument is equivalent to
--rel-pruning-level=3.</p>

<p style="margin-top: 1em">--presat-simplify</p>

<p style="margin-top: 1em">Before proper saturation do a
complete interreduction of the proof state.</p>

<p style="margin-top: 1em">--ac-handling[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Select AC handling mode, i.e.
determine what to do with redundant AC tautologies. The
default is equivalent to &rsquo;DiscardAll&rsquo;, the other
possible values are &rsquo;None&rsquo; (to dis&acirc; <br>
able AC handling), &rsquo;KeepUnits&rsquo;, and
&rsquo;KeepOrientable&rsquo;. The option without the
optional argument is equivalent to
--ac-handling=KeepUnits.</p>

<p style="margin-top: 1em">--ac-non-aggressive</p>

<p style="margin-top: 1em">Do AC resolution on negative
literals only on processing (by default, AC resolution is
done after clause creation). Only effective if AC handling
is not disabled.</p>

<p style="margin-top: 1em">-W &lt;arg&gt;</p>


<p style="margin-top: 1em">--literal-selection-strategy=&lt;arg&gt;</p>

<p style="margin-top: 1em">Choose a strategy for selection
of negative literals. There are two special values for this
option: NoSelection will select no literal (i.e. perform
normal superposition) <br>
and NoGeneration will inhibit all generating inferences. For
a list of the other (hopefully self-documenting) values run
&rsquo;eprover -W none&rsquo;. There are two variants of
each <br>
strategy. The one prefixed with &rsquo;P&rsquo; will allow
paramodulation into maximal positive literals in addition to
paramodulation into maximal selected negative literals.</p>

<p style="margin-top: 1em">--no-generation</p>

<p style="margin-top: 1em">Don&rsquo;t perform any
generating inferences (equivalent to
--literal-selection-strategy=NoGeneration).</p>

<p style="margin-top: 1em">--select-on-processing-only</p>

<p style="margin-top: 1em">Perform literal selection at
processing time only (i.e. select only in the _given
clause_), not before clause evaluation. This is relevant
because many clause selection <br>
heuristics give special consideration to maximal or selected
literals.</p>

<p style="margin-top: 1em">-i</p>

<p style="margin-top: 1em">--inherit-paramod-literals</p>

<p style="margin-top: 1em">Always select the negative
literals a previous inference paramodulated into (if
possible). If no such literal exists, select as dictated by
the selection strategy.</p>

<p style="margin-top: 1em">-j</p>

<p style="margin-top: 1em">--inherit-goal-pm-literals</p>

<p style="margin-top: 1em">In a goal (all negative clause),
always select the negative literals a previous inference
paramodulated into (if possible). If no such literal exists,
select as dictated <br>
by the selection strategy.</p>


<p style="margin-top: 1em">--inherit-conjecture-pm-literals</p>

<p style="margin-top: 1em">In a conjecture-derived clause,
always select the negative literals a previous inference
paramodulated into (if possible). If no such literal exists,
select as dictated by <br>
the selection strategy.</p>


<p style="margin-top: 1em">--selection-pos-min=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set a lower limit for the number
of positive literals a clause must have to be eligible for
literal selection.</p>


<p style="margin-top: 1em">--selection-pos-max=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set a upper limit for the number
of positive literals a clause can have to be eligible for
literal selection.</p>


<p style="margin-top: 1em">--selection-neg-min=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set a lower limit for the number
of negative literals a clause must have to be eligible for
literal selection.</p>


<p style="margin-top: 1em">--selection-neg-max=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set a upper limit for the number
of negative literals a clause can have to be eligible for
literal selection.</p>


<p style="margin-top: 1em">--selection-all-min=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set a lower limit for the number
of literals a clause must have to be eligible for literal
selection.</p>


<p style="margin-top: 1em">--selection-all-max=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set an upper limit for the
number of literals a clause must have to be eligible for
literal selection.</p>


<p style="margin-top: 1em">--selection-weight-min=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the minimum weight a clause
must have to be eligible for literal selection.</p>

<p style="margin-top: 1em">--prefer-initial-clauses</p>

<p style="margin-top: 1em">Always process all initial
clauses first.</p>

<p style="margin-top: 1em">-x &lt;arg&gt;</p>


<p style="margin-top: 1em">--expert-heuristic=&lt;arg&gt;</p>

<p style="margin-top: 1em">Select one of the clause
selection heuristics. Currently at least available: Auto,
Weight, StandardWeight, RWeight, FIFO, LIFO, Uniq,
UseWatchlist. For a full list check <br>
HEURISTICS/che_proofcontrol.c. Auto is recommended if you
only want to find a proof. It is special in that it will
also set some additional options. To have optimal per&acirc;
<br>
formance, you also should specify -tAuto to select a good
term ordering. LIFO is unfair and will make the prover
incomplete. Uniq is used internally and is not very useful
<br>
in most cases. You can define more heuristics using the
option -H (see below).</p>


<p style="margin-top: 1em">--filter-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the limit on the number of
&rsquo;storage units&rsquo; in the proof state, after which
the set of unprocessed clauses will be filtered against the
processed clauses to eliminate <br>
redundant clauses. As of E 0.7, a &rsquo;storage unit&rsquo;
is approximately one byte, however, storage is estimated in
an abstract way, independent of hardware or memory
allocation <br>
library, and the storage estimate is only an approximation.
The option without the optional argument is equivalent to
--filter-limit=1000000.</p>


<p style="margin-top: 1em">--filter-copies-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the number of storage units
in new unprocessed clauses after which the set of
unprocessed clauses will be filtered for equivalent copies
of clauses (see above). As <br>
this operation is cheaper, you may want to set this limit
lower than --filter-limit. The option without the optional
argument is equivalent to --fil&acirc; <br>
ter-copies-limit=800000.</p>


<p style="margin-top: 1em">--delete-bad-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the number of storage units
after which bad clauses are deleted without further
consideration. This causes the prover to be potentially
incomplete, but will allow you <br>
to limit the maximum amount of memory used fairly well. The
prover will tell you if a proof attempt failed due to the
incompleteness introduced by this option. It is rec&acirc;
<br>
ommended to set this limit significantly higher than
--filter-limit or --filter-copies-limit. If you select
-xAuto and set a memory limit, the prover will determine a
good <br>
value automatically. The option without the optional
argument is equivalent to --delete-bad-limit=1500000.</p>

<p style="margin-top: 1em">--assume-completeness</p>

<p style="margin-top: 1em">There are various way (e.g. the
next few options) to configure the prover to be strongly
incomplete in the general case. E will detect when such an
option is selected and <br>
return corresponding exit states (i.e. it will not claim
satisfiability just because it ran out of unprocessed
clauses). If you _know_ that for your class of problems the
<br>
selected strategy is still complete, use this option to tell
the system that this is the case.</p>

<p style="margin-top: 1em">--assume-incompleteness</p>

<p style="margin-top: 1em">This option instructs the prover
to assume incompleteness (typically because the
axiomatization already is incomplete because axioms have
been filtered before they are <br>
handed to the system.</p>

<p style="margin-top: 1em">--disable-eq-factoring</p>

<p style="margin-top: 1em">Disable equality factoring. This
makes the prover incomplete for general non-Horn problems,
but helps for some specialized classes. It is not necessary
to disable equality <br>
factoring for Horn problems, as Horn clauses are not
factored anyways.</p>


<p style="margin-top: 1em">--disable-paramod-into-neg-units</p>

<p style="margin-top: 1em">Disable paramodulation into
negative unit clause. This makes the prover incomplete in
the general case, but helps for some specialized
classes.</p>

<p style="margin-top: 1em">--condense</p>

<p style="margin-top: 1em">Enable condensing for the given
clause. Condensing replaces a clause by a more general
factor (if such a factor exists).</p>

<p style="margin-top: 1em">--condense-aggressive</p>

<p style="margin-top: 1em">Enable condensing for the given
and newly generated clauses.</p>


<p style="margin-top: 1em">--disable-given-clause-fw-contraction</p>

<p style="margin-top: 1em">Disable simplification and
subsumption of the newly selected given clause (clauses are
still simplified when they are generated). In general, this
breaks some basic <br>
assumptions of the DISCOUNT loop proof search procedure.
However, there are some problem classes in which this
simplifications empirically never occurs. In such cases, we
<br>
can save significant overhead. The option _should_ work in
all cases, but is not expected to improve things in most
cases.</p>

<p style="margin-top: 1em">--simul-paramod</p>

<p style="margin-top: 1em">Use simultaneous paramodulation
to implement superposition. Default is to use plain
paramodulation.</p>

<p style="margin-top: 1em">--oriented-simul-paramod</p>

<p style="margin-top: 1em">Use simultaneous paramodulation
for oriented from-literals. This is an experimental
feature.</p>


<p style="margin-top: 1em">--split-clauses[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Determine which clauses should
be subject to splitting. The argument is the binary
&rsquo;OR&rsquo; of values for the desired classes:</p>

<p style="margin-top: 1em">1: Horn clauses</p>

<p style="margin-top: 1em">2: Non-Horn clauses</p>

<p style="margin-top: 1em">4: Negative clauses</p>

<p style="margin-top: 1em">8: Positive clauses</p>

<p style="margin-top: 1em">16: Clauses with both positive
and negative literals</p>

<p style="margin-top: 1em">Each set bit adds that class to
the set of clauses which will be split. The option without
the optional argument is equivalent to
--split-clauses=7.</p>

<p style="margin-top: 1em">--split-method=&lt;arg&gt;</p>

<p style="margin-top: 1em">Determine how to treat ground
literals in splitting. The argument is either
&rsquo;0&rsquo; to denote no splitting of ground literals
(they are all assigned to the first split clause <br>
produced), &rsquo;1&rsquo; to denote that all ground
literals should form a single new clause, or
&rsquo;2&rsquo;, in which case ground literals are treated
as usual and are all split off into <br>
individual clauses.</p>

<p style="margin-top: 1em">--split-aggressive</p>

<p style="margin-top: 1em">Apply splitting to new clauses
(after simplification) and before evaluation. By default,
splitting (if activated) is only performed on selected
clauses.</p>

<p style="margin-top: 1em">--split-reuse-defs</p>

<p style="margin-top: 1em">If possible, reuse previous
definitions for splitting.</p>


<p style="margin-top: 1em">--reweight-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the number of new
unprocessed clauses after which the set of unprocessed
clauses will be reevaluated. The option without the optional
argument is equivalent to <br>
--reweight-limit=30000.</p>

<p style="margin-top: 1em">-t &lt;arg&gt;</p>

<p style="margin-top: 1em">--term-ordering=&lt;arg&gt;</p>

<p style="margin-top: 1em">Select an ordering type
(currently Auto, LPO, LPO4, KBO or KBO6). -tAuto is
suggested, in particular with -xAuto. KBO and KBO6 are
different implementations of the same <br>
ordering, KBO6 is usually faster and has had more testing.
Similarly, LPO4 is a new, equivalent but superior
implementation of LPO.</p>

<p style="margin-top: 1em">-w &lt;arg&gt;</p>


<p style="margin-top: 1em">--order-weight-generation=&lt;arg&gt;</p>

<p style="margin-top: 1em">Select a method for the
generation of weights for use with the term ordering. Run
&rsquo;eprover -w none&rsquo; for a list of options.</p>

<p style="margin-top: 1em">--order-weights=&lt;arg&gt;</p>

<p style="margin-top: 1em">Describe a (partial) assignments
of weights to function symbols for term orderings (in
particular, KBO). You can specify a list of weights of the
form &rsquo;f1:w1,f2:w2, ...&rsquo;. <br>
Since a total weight assignment is needed, E will _first_
apply any weight generation scheme specified (or the default
one), and then modify the weights as specified. Note <br>
that E performs only very basic sanity checks, so you
probably can specify weights that break KBO constraints.</p>

<p style="margin-top: 1em">-G &lt;arg&gt;</p>


<p style="margin-top: 1em">--order-precedence-generation=&lt;arg&gt;</p>

<p style="margin-top: 1em">Select a method for the
generation of a precedence for use with the term ordering.
Run &rsquo;eprover -G none&rsquo; for a list of options.</p>

<p style="margin-top: 1em">-c &lt;arg&gt;</p>


<p style="margin-top: 1em">--order-constant-weight=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set a special weight &gt; 0 for
constants in the term ordering. By default, constants are
treated like other function symbols.</p>

<p style="margin-top: 1em">--precedence[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Describe a (partial) precedence
for the term ordering used for the proof attempt. You can
specify a comma-separated list of precedence chains, where a
precedence chain is <br>
a list of function symbols (which all have to appear in the
proof problem), connected by &gt;, &lt;, or =. If this
option is used in connection with
--order-precedence-genera&acirc; <br>
tion, the partial ordering will be completed using the
selected method, otherwise the prover runs with a
non-ground-total ordering. The option without the optional
argu&acirc; <br>
ment is equivalent to --precedence=.</p>


<p style="margin-top: 1em">--lpo-recursion-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set a depth limit for LPO
comparisons. Most comparisons do not need more than 10 or 20
levels of recursion. By default, recursion depth is limited
to 1000 to avoid stack <br>
overflow problems. If the limit is reached, the prover
assumes that the terms are uncomparable. Smaller values make
the comparison attempts faster, but less exact. Larger <br>
values have the opposite effect. Values up to 20000 should
be save on most operating systems. If you run into
segmentation faults while using LPO or LPO4, first try to
set <br>
this limit to a reasonable value. If the problem persists,
send a bug report ;-) The option without the optional
argument is equivalent to --lpo-recursion-limit=100.</p>


<p style="margin-top: 1em">--restrict-literal-comparisons</p>

<p style="margin-top: 1em">Make all literals uncomparable
in the term ordering (i.e. do not use the term ordering to
restrict paramodulation, equality resolution and factoring
to certain literals. <br>
This is necessary to make Set-of-Support-strategies complete
for the non-equational case (It still is incomplete for the
equational case, but pretty useless anyways).</p>

<p style="margin-top: 1em">--sos-uses-input-types</p>

<p style="margin-top: 1em">If input is TPTP format, use
TPTP conjectures for initializing the Set of Support. If not
in TPTP format, use E-LOP queries (clauses of the form
?-l(X),...,m(Y)). Nor&acirc; <br>
mally, all negative clauses are used. Please note that most
E heuristics do not use this information at all, it is
currently only useful for certain parameter settings <br>
(including the SimulateSOS priority function).</p>

<p style="margin-top: 1em">--destructive-er</p>

<p style="margin-top: 1em">Allow destructive equality
resolution inferences on pure-variable literals of the form
X!=Y, i.e. replace the original clause with the result of an
equality resolution <br>
inference on this literal.</p>

<p style="margin-top: 1em">--strong-destructive-er</p>

<p style="margin-top: 1em">Allow destructive equality
resolution inferences on literals of the form X!=t (where X
does not occur in t), i.e. replace the original clause with
the result of an equal&acirc; <br>
ity resolution inference on this literal. Unless I am
brain-dead, this maintains completeness, although the proof
is rather tricky.</p>

<p style="margin-top: 1em">--destructive-er-aggressive</p>

<p style="margin-top: 1em">Apply destructive equality
resolution to all newly generated clauses, not just to
selected clauses. Implies --destructive-er.</p>

<p style="margin-top: 1em">--forward-context-sr</p>

<p style="margin-top: 1em">Apply contextual
simplify-reflect with processed clauses to the given
clause.</p>


<p style="margin-top: 1em">--forward-context-sr-aggressive</p>

<p style="margin-top: 1em">Apply contextual
simplify-reflect with processed clauses to new clauses.
Implies --forward-context-sr.</p>

<p style="margin-top: 1em">--backward-context-sr</p>

<p style="margin-top: 1em">Apply contextual
simplify-reflect with the given clause to processed
clauses.</p>

<p style="margin-top: 1em">-g</p>


<p style="margin-top: 1em">--prefer-general-demodulators</p>

<p style="margin-top: 1em">Prefer general demodulators. By
default, E prefers specialized demodulators. This affects in
which order the rewrite index is traversed.</p>

<p style="margin-top: 1em">-F &lt;arg&gt;</p>


<p style="margin-top: 1em">--forward_demod_level=&lt;arg&gt;</p>

<p style="margin-top: 1em">Set the desired level for
rewriting of unprocessed clauses. A value of 0 means no
rewriting, 1 indicates to use rules (orientable equations)
only, 2 indicates full rewrit&acirc; <br>
ing with rules and instances of unorientable equations.
Default behavior is 2.</p>

<p style="margin-top: 1em">--strong-rw-inst</p>

<p style="margin-top: 1em">Instantiate unbound variables in
matching potential demodulators with a small constant
terms.</p>

<p style="margin-top: 1em">-u</p>


<p style="margin-top: 1em">--strong-forward-subsumption</p>

<p style="margin-top: 1em">Try multiple positions and
unit-equations to try to equationally subsume a single new
clause. Default is to search for a single position.</p>

<p style="margin-top: 1em">--watchlist[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Give the name for a file
containing clauses to be watched for during the saturation
process. If a clause is generated that subsumes a watchlist
clause, the subsumed clause <br>
is removed from the watchlist. The prover will terminate
when the watchlist is empty. If you want to use the
watchlist for guiding the proof, put the empty clause onto
the <br>
list and use the built-in clause selection heuristic
&rsquo;UseWatchlist&rsquo; (or build a heuristic yourself
using the priority functions &rsquo;PreferWatchlist&rsquo;
and &rsquo;DeferWatchlist&rsquo;). <br>
Use the argument &rsquo;Use inline watchlist type&rsquo; (or
no argument) and the special clause type
&rsquo;watchlist&rsquo; if you want to put watchlist clauses
into the normal input stream. <br>
This is only supported for TPTP input formats. The option
without the optional argument is equivalent to
--watchlist=&rsquo;Use inline watchlist type&rsquo;.</p>


<p style="margin-top: 1em">--no-watchlist-simplification</p>

<p style="margin-top: 1em">Normally, that watchlist is
brought into normal form with respect to the current
processed clause set and certain simplifications. This
option disables this behaviour.</p>

<p style="margin-top: 1em">--conventional-subsumption</p>

<p style="margin-top: 1em">Equivalent to
--subsumption-indexing=None.</p>


<p style="margin-top: 1em">--subsumption-indexing=&lt;arg&gt;</p>

<p style="margin-top: 1em">Determine choice of indexing for
(most) subsumption operations. Choices are
&rsquo;None&rsquo; for naive subsumption,
&rsquo;Direct&rsquo; for direct mapped FV-Indexing,
&rsquo;Perm&rsquo; for permuted <br>
FV-Indexing and &rsquo;PermOpt&rsquo; for permuted
FV-Indexing with deletion of (suspected) non-informative
features. Default behaviour is &rsquo;Perm&rsquo;.</p>


<p style="margin-top: 1em">--fvindex-featuretypes=&lt;arg&gt;</p>

<p style="margin-top: 1em">Select the feature types used
for indexing. Choices are &quot;None&quot; to disable
FV-indexing, &quot;AC&quot; for AC compatible features (the
default) (literal number and symbol counts), <br>
&quot;SS&quot; for set subsumption compatible features
(symbol depth), and &quot;All&quot; for all features.Unless
you want to measure the effects of the different features, I
suggest you <br>
stick with the default.</p>


<p style="margin-top: 1em">--fvindex-maxfeatures[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the maximum initial number
of symbols for feature computation. Depending on the feature
selection, a value of X here will convert into 2X+2 features
(for set subsump&acirc; <br>
tion features), 2X+4 features (for AC-compatible features)
or 4X+6 features (if all features are used, the default).
Note that the actually used set of features may be <br>
smaller than this if the signature does not contain enough
symbols.For the Perm and PermOpt version, this is _also_
used to set the maximum depth of the feature vector <br>
index. Yes, I should probably make this into two separate
options. If you select a small value here, you should
probably not use &quot;Direct&quot; for the
--subsumption-indexing <br>
option. The option without the optional argument is
equivalent to --fvindex-maxfeatures=200.</p>


<p style="margin-top: 1em">--fvindex-slack[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the number of slots reserved
in the index for function symbols that may be introduced
into the signature later, e.g. by splitting. If no new
symbols are introduced, <br>
this just wastes time and memory. If PermOpt is chosen, the
slackness slots will be deleted from the index anyways, but
will still waste (a little) time in computing fea&acirc;
<br>
ture vectors. The option without the optional argument is
equivalent to --fvindex-slack=0.</p>

<p style="margin-top: 1em">--rw-bw-index[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Select fingerprint function for
backwards rewrite index. &quot;NoIndex&quot; will disable
paramodulation indexing. For a list of the other values run
&rsquo;eprover --pm-index=none&rsquo;. FPX <br>
functions will use a fingerprint of X positions, the letters
disambiguate between different fingerprints with the same
sample size. The option without the optional argu&acirc;
<br>
ment is equivalent to --rw-bw-index=FP7.</p>


<p style="margin-top: 1em">--pm-from-index[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Select fingerprint function for
the index for paramodulation from indexed clauses.
&quot;NoIndex&quot; will disable paramodulation indexing.
For a list of the other values run <br>
&rsquo;eprover --pm-index=none&rsquo;. FPX functionswill use
a fingerprint of X positions, the letters disambiguate
between different fingerprints with the same sample size.
The <br>
option without the optional argument is equivalent to
--pm-from-index=FP7.</p>


<p style="margin-top: 1em">--pm-into-index[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Select fingerprint function for
the index for paramodulation into the indexed clauses.
&quot;NoIndex&quot; will disable paramodulation indexing.
For a list of the other values run <br>
&rsquo;eprover --pm-index=none&rsquo;. FPX functionswill use
a fingerprint of X positions, the letters disambiguate
between different fingerprints with the same sample size.
The <br>
option without the optional argument is equivalent to
--pm-into-index=FP7.</p>

<p style="margin-top: 1em">--fp-index[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Select fingerprint function for
all fingerprint indices. See above. The option without the
optional argument is equivalent to --fp-index=FP7.</p>

<p style="margin-top: 1em">--fp-no-size-constr</p>

<p style="margin-top: 1em">Disable usage of size
constraints for matching with fingerprint indexing.</p>

<p style="margin-top: 1em">--pdt-no-size-constr</p>

<p style="margin-top: 1em">Disable usage of size
constraints for matching with perfect discrimination trees
indexing.</p>

<p style="margin-top: 1em">--pdt-no-age-constr</p>

<p style="margin-top: 1em">Disable usage of age constraints
for matching with perfect discrimination trees indexing.</p>

<p style="margin-top: 1em">--detsort-rw</p>

<p style="margin-top: 1em">Sort set of clauses eliminated
by backward rewriting using a total syntactic ordering.</p>

<p style="margin-top: 1em">--detsort-new</p>

<p style="margin-top: 1em">Sort set of newly generated and
backward simplified clauses using a total syntactic
ordering.</p>

<p style="margin-top: 1em">-D &lt;arg&gt;</p>


<p style="margin-top: 1em">--define-weight-function=&lt;arg&gt;</p>

<p style="margin-top: 1em">Define <br>
a weight function (see manual for details). Later
definitions</p>

<p style="margin-top: 1em">override previous
definitions.</p>

<p style="margin-top: 1em">-H &lt;arg&gt;</p>


<p style="margin-top: 1em">--define-heuristic=&lt;arg&gt;</p>

<p style="margin-top: 1em">Define a clause selection
heuristic (see manual for details). Later definitions
override previous definitions.</p>

<p style="margin-top: 1em">--free-numbers</p>

<p style="margin-top: 1em">Treat numbers (strings of
decimal digits) as normal free function symbols in the
input. By default, number now are supposed to denote domain
constants and to be implicitly <br>
different from each other.</p>

<p style="margin-top: 1em">--free-objects</p>

<p style="margin-top: 1em">Treat object identifiers
(strings in double quotes) as normal free function symbols
in the input. By default, object identifiers now represent
domain objects and are <br>
implicitly different from each other (and from numbers,
unless those are declared to be free).</p>


<p style="margin-top: 1em">--definitional-cnf[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Tune the clausification
algorithm to introduces definitions for subformulae to avoid
exponential blow-up. The optional argument is a fudge factor
that determines when def&acirc; <br>
initions are introduced. 0 disables definitions completely.
The default works well. The option without the optional
argument is equivalent to --definitional-cnf=24.</p>

<p style="margin-top: 1em">--old-cnf[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">As the previous option, but use
the classical, well-tested clausification algorithm as
opposed to the newewst one which avoides some algorithmic
pitfalls and hence works <br>
better on some exotic formulae. The two may produce slightly
different (but equisatisfiable) clause normal forms. The
option without the optional argument is equivalent to <br>
--old-cnf=24.</p>


<p style="margin-top: 1em">--miniscope-limit[=&lt;arg&gt;]</p>

<p style="margin-top: 1em">Set the limit of variables to
miniscope per input formula. The build-in default is 1000.
Only applies to the new (default) clausification algorithm
The option without the <br>
optional argument is equivalent to
--miniscope-limit=2147483648.</p>

<p style="margin-top: 1em">--print-types</p>

<p style="margin-top: 1em">Print the type of every term.
Useful for debugging purposes.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to &lt;schulz@eprover.org&gt;. Please include
the following, if possible:</p>

<p style="margin-top: 1em">* The version of the package as
reported by eprover --version.</p>

<p style="margin-top: 1em">* The operating system and
version.</p>

<p style="margin-top: 1em">* The exact command line that
leads to the unexpected behaviour.</p>

<p style="margin-top: 1em">* A description of what you
expected and what actually happend.</p>

<p style="margin-top: 1em">* If possible all input files
necessary to reproduce the bug.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright 1998-2017 by Stephan Schulz, schulz@eprover.org,
and the E contributors (see DOC/CONTRIBUTORS).</p>

<p style="margin-top: 1em">This program is a part of the
distribution of the equational theorem prover E. You can
find the latest version of the E distribution as well as
additional information at <br>
http://www.eprover.org</p>

<p style="margin-top: 1em">This program is free software;
you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free
Software Foundation; either <br>
version 2 of the License, or (at your option) any later
version.</p>

<p style="margin-top: 1em">This program is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PUR&acirc; <br>
POSE. See the GNU General Public License for more
details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program
(it should be contained in the top level directory of the
distribution in the file COPY&acirc; <br>
ING); if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</p>

<p style="margin-top: 1em">The original copyright holder
can be contacted via email or as</p>

<p style="margin-top: 1em">Stephan Schulz DHBW Stuttgart
Fakultaet Technik Informatik Rotebuehlplatz 41 70178
Stuttgart Germany</p>

<p style="margin-top: 1em">E 2.0 Turzum July 2017 E(1)</p>
<hr>
</body>
</html>
