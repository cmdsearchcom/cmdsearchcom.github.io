<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>E(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">E(1)</td>
    <td class="head-vol">User Commands</td>
    <td class="head-rtitle">E(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
E - manual page for E 2.0 Turzum
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>eprover</b> [ <i>options</i>] [<i>files</i>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
E 2.0 &quot;Turzum&quot;
<div class="Pp"></div>
Read a set of first-order clauses and formulae and try to refute it.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-h</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--help</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print a short description of program usage and
    options.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-V</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--version</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print the version number of the prover. Please include this
      with all bug reports (if any).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-v</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--verbose[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Verbose comments on the progress of the program. This
      differs from the output level (below) in that technical information is
      printed to stderr, while the output level determines which logical
      manipulations of the clauses are printed to stdout. The short form or the
      long form without the optional argument is equivalent to
      <b>--verbose</b>=<i>1</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-o</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--output-file=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Redirect output into the named file.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-s</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--silent</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Equivalent to <b>--output-level</b>=<i>0</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-l</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--output-level=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select an output level, greater values imply more verbose
      output. Level 0 produces nearly no output, level 1 will output each clause
      as it is processed, level 2 will output generating inferences, level 3
      will give a full protocol including rewrite steps and level 4 will include
      some internal clause renamings. Levels &gt;= 2 also imply PCL2 or TSTP
      formats (which can be post-processed with suitable tools).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-p</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--proof-object[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Generate (and print, in case of success) an internal proof
      object. Level 0 will not build a proof object, level 1 will build a
      simple, compact proof object that only contains inference rules and
      dependencies, level 2 will build a proof object where inferences are
      unambiguously described by giving inference positions, and level 3 will
      expand this to a proof object where all intermediate results are explicit.
      This feature is under development, so far only level 0 and 1 are
      operational. The short form or the long form without the optional argument
      is equivalent to <b>--proof-object</b>=<i>1</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--proof-graph[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Generate (and print, in case of success) an internal proof
      object in the form of a GraphViz dot graph. The optional argument can be 1
      (nodes are labelled with just name of the clause), 2 (nodes are labelled
      with just the TPTP clause/formula) or 3 (nodes also labelled with
      source/inference record. The option without the optional argument is
      equivalent to <b>--proof-graph</b>=<i>3</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-d</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--full-deriv</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Include all derived formuas/clauses in the proof
      graph/proof object, not just the ones contributing to the actual
    proof.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--record-gcs</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Record given-clause selection as separate
      (pseudo-)inferences and preserve the form of given clauses evaluated and
      selected via archiving for analysis and possibly machine learning.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--training-examples[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Generate and process training examples from the proof
      search object. Implies <b>--record-gcs</b>. The argument is a binary or of
      the desired processig. Bit zero prints positive exampels. Bit 1 prints
      negative examples. Additional selectors will be added later. The option
      without the optional argument is equivalent to
      <b>--training-examples</b>=<i>1</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pcl-terms-compressed</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print terms in the PCL output in shared
    representation.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pcl-compact</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print PCL steps without additional spaces for formatting
      (safes disk space for large protocols).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pcl-shell-level[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Determines level to which clauses and formulas are
      suppressed in the output. Level 0 will print all, level 1 will only print
      initial clauses/formulas, level 2 will print no clauses or axioms. All
      levels will still print the dependency graph. The option without the
      optional argument is equivalent to <b>--pcl-shell-level</b>=<i>1</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--print-statistics</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print the inference statistics (only relevant for output
      level 0, otherwise they are printed automatically.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-0</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--print-detailed-statistics</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print data about the proof state that is potentially
      expensive to collect. Includes number of term cells and number of rewrite
      steps.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-S</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--print-saturated[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print the (semi-) saturated clause sets after terminating
      the saturation process. The argument given describes which parts should be
      printed in which order. Legal characters are 'eigEIGaA', standing for
      processed positive units, processed negative units, processed non-units,
      unprocessed positive units, unprocessed negative units, unprocessed
      non-units, and two types of additional equality axioms, respectively.
      Equality axioms will only be printed if the original specification
      contained real equality. In this case, 'a' requests axioms in which a
      separate substitutivity axiom is given for each argument position of a
      function or predicate symbol, while 'A' requests a single substitutivity
      axiom (covering all positions) for each symbol. The short form or the long
      form without the optional argument is equivalent to
      <b>--print-saturated</b>= <i>eigEIG</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--print-sat-info</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print additional information (clause number, weight, etc)
      as a comment for clauses from the semi-saturated end system.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--filter-saturated[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag">Filter the</dt>
  <dd class="It-tag">(semi-) saturated clause sets after terminating the</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">saturation process. The argument is a string describing
      which operations to take (and in which order). Options are 'u' (remove all
      clauses with more than one literal), 'c' (delete all but one copy of
      identical clauses, 'n', 'r', 'f' (forward contraction, unit-subsumption
      only, no rewriting, rewriting with rules only, full rewriting,
      respectively), and 'N', 'R' and 'F' (as their lower case counterparts, but
      with non-unit-subsumption enabled as well). The option without the
      optional argument is equivalent to
    <b>--filter-saturated</b>=<i>Fc</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--prune</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Stop after relevancy pruning, SInE pruning, and output of
      the initial clause- and formula set. This will automatically set output
      level to 4 so that the pruned problem specification is printed. Note that
      the desired pruning methods must still be specified (e.g.
    '--sine=Auto').</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--cnf</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Convert the input problem into clause normal form and print
      it. This is (nearly) equivalent to '--print-saturated=eigEIG
      <b>--processed-clauses-limit</b>= <i>0</i>' and will by default perform
      some usually useful simplifications. You can additionally specify e.g.
      '--no-preprocessing' if you want just the result of CNF translation.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--print-pid</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print the process id of the prover as a comment after
      option processing.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--print-version</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print the version number of the prover as a comment after
      option processing. Note that unlike <b>-version</b>, the prover will not
      terminate, but proceed normally.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--error-on-empty</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Return with an error code if the input file contains no
      clauses. Formally, the empty clause set (as an empty conjunction of
      clauses) is trivially satisfiable, and E will treat any empty input set as
      satisfiable. However, in composite systems this is more often a sign that
      something went wrong. Use this option to catch such bugs.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-m</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--memory-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Limit the memory the prover may use. The argument is the
      allowed amount of memory in MB. If you use the argument 'Auto', the system
      will try to figure out the amount of physical memory of your machine and
      claim most of it. This option may not work everywhere, due to broken
      and/or strange behaviour of setrlimit() in some UNIX implementations, and
      due to the fact that I know of no portable way to figure out the physical
      memory in a machine. Both the option and the 'Auto' version do work under
      all tested versions of Solaris and GNU/Linux. Due to problems with limit
      data types, it is currently impossible to set a limit of more than 2 GB
      (2048 MB).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--cpu-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Limit the cpu time the prover should run. The optional
      argument is the CPU time in seconds. The prover will terminate immediately
      after reaching the time limit, regardless of internal state. This option
      may not work everywhere, due to broken and/or strange behaviour of
      setrlimit() in some UNIX implementations. It does work under all tested
      versions of Solaris, HP-UX, MacOS-X, and GNU/Linux. As a side effect, this
      option will inhibit core file writing. Please note that if you use both
      <b>--cpu-limit</b> and <b>--soft-cpu-limit</b>, the soft limit has to be
      smaller than the hard limit to have any effect. The option without the
      optional argument is equivalent to <b>--cpu-limit</b>=<i>300</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--soft-cpu-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Limit the cpu time the prover should spend in the main
      saturation phase. The prover will then terminate gracefully, i.e. it will
      perform post-processing, filtering and printing of unprocessed clauses, if
      these options are selected. Note that for some filtering options (in
      particular those which perform full subsumption), the post-processing time
      may well be larger than the saturation time. This option is particularly
      useful if you want to use E as a preprocessor or lemma generator in a
      larger system. The option without the optional argument is equivalent to
      <b>--soft-cpu-limit</b>=<i>290</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-R</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--resources-info</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Give some information about the resources used by the
      prover. You will usually get CPU time information. On systems returning
      more information with the rusage() system call, you will also get
      information about memory consumption.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-C</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--processed-clauses-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximal number of clauses to process (i.e. the
      number of traversals of the main-loop).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-P</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--processed-set-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximal size of the set of processed clauses. This
      differs from the previous option in that redundant and back-simplified
      processed clauses are not counted.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-U</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--unprocessed-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximal size of the set of unprocessed clauses.
      This is a termination condition, not something to use to control the
      deletion of bad clauses. Compare <b>--delete-bad-limit</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-T</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--total-clause-set-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximal size of the set of all clauses. See
      previous option.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--generated-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximal number of generated clauses before the
      proof search stops. This is a reasonable (though not great) estimate of
      the work done.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tb-insert-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximal number of of term bank term top insertions.
      This is a reasonable (though not great) estimate of the work done.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--answers[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximal number of answers to print for
      existentially quantified questions. Without this option, the prover
      terminates after the first answer found. If the value is different from 1,
      the prover is no longer guaranteed to terminate, even if there is a finite
      number of answers. The option without the optional argument is equivalent
      to <b>--answers</b>=<i>2147483647</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--conjectures-are-questions</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Treat all conjectures as questions to be answered. This is
      a wart necessary because CASC-J6 has categories requiring answers, but
      does not yet support the 'question' type for formulas.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-n</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--eqn-no-infix</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In LOP, print equations in prefix notation equal(x,y).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-e</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--full-equational-rep</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In LOP. print all literals as equations, even
      non-equational ones.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--lop-in</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set E-LOP as the input format. If no input format is
      selected by this or one of the following options, E will guess the input
      format based on the first token. It will almost always correctly recognize
      TPTP-3, but it may misidentify E-LOP files that use TPTP meta-identifiers
      as logical symbols.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pcl-out</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set PCL as the proof object output format.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp-in</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set TPTP-2 as the input format (but note that includes are
      still handled according to TPTP-3 semantics).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp-out</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print TPTP format instead of E-LOP. Implies
      <b>--eqn-no-infix</b> and will ignore <b>--full-equational-rep</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp-format</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Equivalent to <b>--tptp-in</b> and <b>--tptp-out</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp2-in</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Synonymous with <b>--tptp-in</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp2-out</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Synonymous with <b>--tptp-out</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp2-format</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Synonymous with <b>--tptp-format</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tstp-in</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set TPTP-3 as the input format (Note that TPTP-3 syntax is
      still under development, and the version in E may not be fully conforming
      at all times. E works on all TPTP 6.3.0 FOF and CNF files (including
      includes).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tstp-out</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print output clauses in TPTP-3 syntax. In particular, for
      output levels &gt;=2, write derivations as TPTP-3 derivations.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tstp-format</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Equivalent to <b>--tstp-in</b> and <b>--tstp-out</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp3-in</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Synonymous with <b>--tstp-in</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp3-out</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Synonymous with <b>--tstp-out</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--tptp3-format</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Synonymous with <b>--tstp-format</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--auto</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Automatically determine settings for proof search. This is
      equivalent to <b>-xAuto</b> <b>-tAuto</b> <b>--sine</b>=<i>Auto</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--satauto</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Automatically determine settings for proof/saturation
      search. This is equivalent to <b>-xAuto</b> <b>-tAuto</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--autodev</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Automatically determine settings for proof search
      (development version). This is equivalent to <b>-xAutoDev</b>
      <b>-tAutoDev</b> <b>--sine</b>=<i>Auto</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--satautodev</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Automatically determine settings for proof/saturation
      search (development version). This is equivalent to <b>-xAutoDev</b>
      <b>-tAutoDev</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--auto-schedule</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Use the (experimental) strategy scheduling. This will try
      several different fully specified search strategies (aka
      &quot;Auto-Modes&quot;), one after the other, until a proof or saturation
      is found, or the time limit is exceeded.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--satauto-schedule</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Use the (experimental) strategy scheduling without SInE,
      thus maintaining completeness.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--no-preprocessing</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Do not perform preprocessing on the initial clause set.
      Preprocessing currently removes tautologies and orders terms, literals and
      clauses in a certain (&quot;canonical&quot;) way before anything else
      happens. Unless limited by one of the following options, it will also
      unfold equational definitions.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--eq-unfold-limit=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">During preprocessing, limit unfolding (and removing) of
      equational definitions to those where the expanded definition is at most
      the given limit bigger (in terms of standard weight) than the defined
      term.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--eq-unfold-maxclauses=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">During preprocessing, don't try unfolding of equational
      definitions if the problem has more than this limit of clauses.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--no-eq-unfolding</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">During preprocessing, abstain from unfolding (and removing)
      equational definitions.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--sine[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Apply SInE to prune the unprocessed axioms with the
      specified filter. 'Auto' will automatically pick a filter. The option
      without the optional argument is equivalent to
    <b>--sine</b>=<i>Auto</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--rel-pruning-level[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Perform relevancy pruning up to the given level on the
      unprocessed axioms. The option without the optional argument is equivalent
      to <b>--rel-pruning-level</b>=<i>3</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--presat-simplify</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Before proper saturation do a complete interreduction of
      the proof state.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--ac-handling[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select AC handling mode, i.e. determine what to do with
      redundant AC tautologies. The default is equivalent to 'DiscardAll', the
      other possible values are 'None' (to disable AC handling), 'KeepUnits',
      and 'KeepOrientable'. The option without the optional argument is
      equivalent to <b>--ac-handling</b>=<i>KeepUnits</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--ac-non-aggressive</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Do AC resolution on negative literals only on processing
      (by default, AC resolution is done after clause creation). Only effective
      if AC handling is not disabled.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-W</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--literal-selection-strategy=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Choose a strategy for selection of negative literals. There
      are two special values for this option: NoSelection will select no literal
      (i.e. perform normal superposition) and NoGeneration will inhibit all
      generating inferences. For a list of the other (hopefully
      self-documenting) values run 'eprover <b>-W</b> none'. There are two
      variants of each strategy. The one prefixed with 'P' will allow
      paramodulation into maximal positive literals in addition to
      paramodulation into maximal selected negative literals.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--no-generation</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Don't perform any generating inferences (equivalent to
      <b>--literal-selection-strategy</b>= <i>NoGeneration</i>).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--select-on-processing-only</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Perform literal selection at processing time only (i.e.
      select only in the _given clause_), not before clause evaluation. This is
      relevant because many clause selection heuristics give special
      consideration to maximal or selected literals.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-i</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--inherit-paramod-literals</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Always select the negative literals a previous inference
      paramodulated into (if possible). If no such literal exists, select as
      dictated by the selection strategy.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-j</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--inherit-goal-pm-literals</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In a goal (all negative clause), always select the negative
      literals a previous inference paramodulated into (if possible). If no such
      literal exists, select as dictated by the selection strategy.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--inherit-conjecture-pm-literals</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In a conjecture-derived clause, always select the negative
      literals a previous inference paramodulated into (if possible). If no such
      literal exists, select as dictated by the selection strategy.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--selection-pos-min=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set a lower limit for the number of positive literals a
      clause must have to be eligible for literal selection.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--selection-pos-max=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set a upper limit for the number of positive literals a
      clause can have to be eligible for literal selection.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--selection-neg-min=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set a lower limit for the number of negative literals a
      clause must have to be eligible for literal selection.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--selection-neg-max=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set a upper limit for the number of negative literals a
      clause can have to be eligible for literal selection.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--selection-all-min=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set a lower limit for the number of literals a clause must
      have to be eligible for literal selection.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--selection-all-max=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set an upper limit for the number of literals a clause must
      have to be eligible for literal selection.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--selection-weight-min=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the minimum weight a clause must have to be eligible
      for literal selection.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--prefer-initial-clauses</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Always process all initial clauses first.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-x</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--expert-heuristic=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select one of the clause selection heuristics. Currently at
      least available: Auto, Weight, StandardWeight, RWeight, FIFO, LIFO, Uniq,
      UseWatchlist. For a full list check HEURISTICS/che_proofcontrol.c. Auto is
      recommended if you only want to find a proof. It is special in that it
      will also set some additional options. To have optimal performance, you
      also should specify <b>-tAuto</b> to select a good term ordering. LIFO is
      unfair and will make the prover incomplete. Uniq is used internally and is
      not very useful in most cases. You can define more heuristics using the
      option <b>-H</b> (see below).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--filter-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the limit on the number of 'storage units' in the proof
      state, after which the set of unprocessed clauses will be filtered against
      the processed clauses to eliminate redundant clauses. As of E 0.7, a
      'storage unit' is approximately one byte, however, storage is estimated in
      an abstract way, independent of hardware or memory allocation library, and
      the storage estimate is only an approximation. The option without the
      optional argument is equivalent to
    <b>--filter-limit</b>=<i>1000000</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--filter-copies-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the number of storage units in new unprocessed clauses
      after which the set of unprocessed clauses will be filtered for equivalent
      copies of clauses (see above). As this operation is cheaper, you may want
      to set this limit lower than <b>--filter-limit</b>. The option without the
      optional argument is equivalent to
      <b>--filter-copies-limit</b>=<i>800000</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--delete-bad-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the number of storage units after which bad clauses are
      deleted without further consideration. This causes the prover to be
      potentially incomplete, but will allow you to limit the maximum amount of
      memory used fairly well. The prover will tell you if a proof attempt
      failed due to the incompleteness introduced by this option. It is
      recommended to set this limit significantly higher than
      <b>--filter-limit</b> or <b>--filter-copies-limit</b>. If you select
      <b>-xAuto</b> and set a memory limit, the prover will determine a good
      value automatically. The option without the optional argument is
      equivalent to <b>--delete-bad-limit</b>=<i>1500000</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--assume-completeness</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">There are various way (e.g. the next few options) to
      configure the prover to be strongly incomplete in the general case. E will
      detect when such an option is selected and return corresponding exit
      states (i.e. it will not claim satisfiability just because it ran out of
      unprocessed clauses). If you _know_ that for your class of problems the
      selected strategy is still complete, use this option to tell the system
      that this is the case.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--assume-incompleteness</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This option instructs the prover to assume incompleteness
      (typically because the axiomatization already is incomplete because axioms
      have been filtered before they are handed to the system.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--disable-eq-factoring</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Disable equality factoring. This makes the prover
      incomplete for general non-Horn problems, but helps for some specialized
      classes. It is not necessary to disable equality factoring for Horn
      problems, as Horn clauses are not factored anyways.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--disable-paramod-into-neg-units</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Disable paramodulation into negative unit clause. This
      makes the prover incomplete in the general case, but helps for some
      specialized classes.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--condense</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Enable condensing for the given clause. Condensing replaces
      a clause by a more general factor (if such a factor exists).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--condense-aggressive</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Enable condensing for the given and newly generated
      clauses.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--disable-given-clause-fw-contraction</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Disable simplification and subsumption of the newly
      selected given clause (clauses are still simplified when they are
      generated). In general, this breaks some basic assumptions of the DISCOUNT
      loop proof search procedure. However, there are some problem classes in
      which this simplifications empirically never occurs. In such cases, we can
      save significant overhead. The option _should_ work in all cases, but is
      not expected to improve things in most cases.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--simul-paramod</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Use simultaneous paramodulation to implement superposition.
      Default is to use plain paramodulation.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--oriented-simul-paramod</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Use simultaneous paramodulation for oriented from-literals.
      This is an experimental feature.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--split-clauses[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Determine which clauses should be subject to splitting. The
      argument is the binary 'OR' of values for the desired classes:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1:</dt>
  <dd class="It-tag">Horn clauses</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2:</dt>
  <dd class="It-tag">Non-Horn clauses</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4:</dt>
  <dd class="It-tag">Negative clauses</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">8:</dt>
  <dd class="It-tag">Positive clauses</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">16:</dt>
  <dd class="It-tag">Clauses with both positive and negative literals</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Each set bit adds that class to the set of clauses which
      will be split. The option without the optional argument is equivalent to
      <b>--split-clauses</b>=<i>7</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--split-method=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Determine how to treat ground literals in splitting. The
      argument is either '0' to denote no splitting of ground literals (they are
      all assigned to the first split clause produced), '1' to denote that all
      ground literals should form a single new clause, or '2', in which case
      ground literals are treated as usual and are all split off into individual
      clauses.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--split-aggressive</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Apply splitting to new clauses (after simplification) and
      before evaluation. By default, splitting (if activated) is only performed
      on selected clauses.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--split-reuse-defs</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If possible, reuse previous definitions for splitting.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--reweight-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the number of new unprocessed clauses after which the
      set of unprocessed clauses will be reevaluated. The option without the
      optional argument is equivalent to
    <b>--reweight-limit</b>=<i>30000</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-t</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--term-ordering=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select an ordering type (currently Auto, LPO, LPO4, KBO or
      KBO6). <b>-tAuto</b> is suggested, in particular with <b>-xAuto</b>. KBO
      and KBO6 are different implementations of the same ordering, KBO6 is
      usually faster and has had more testing. Similarly, LPO4 is a new,
      equivalent but superior implementation of LPO.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-w</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--order-weight-generation=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select a method for the generation of weights for use with
      the term ordering. Run 'eprover <b>-w</b> none' for a list of
    options.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--order-weights=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Describe a (partial) assignments of weights to function
      symbols for term orderings (in particular, KBO). You can specify a list of
      weights of the form 'f1:w1,f2:w2, ...'. Since a total weight assignment is
      needed, E will _first_ apply any weight generation scheme specified (or
      the default one), and then modify the weights as specified. Note that E
      performs only very basic sanity checks, so you probably can specify
      weights that break KBO constraints.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-G</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--order-precedence-generation=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select a method for the generation of a precedence for use
      with the term ordering. Run 'eprover <b>-G</b> none' for a list of
      options.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-c</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--order-constant-weight=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set a special weight &gt; 0 for constants in the term
      ordering. By default, constants are treated like other function
    symbols.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--precedence[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Describe a (partial) precedence for the term ordering used
      for the proof attempt. You can specify a comma-separated list of
      precedence chains, where a precedence chain is a list of function symbols
      (which all have to appear in the proof problem), connected by &gt;, &lt;,
      or =. If this option is used in connection with
      <b>--order-precedence-generation</b>, the partial ordering will be
      completed using the selected method, otherwise the prover runs with a
      non-ground-total ordering. The option without the optional argument is
      equivalent to <b>--precedence=</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--lpo-recursion-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set a depth limit for LPO comparisons. Most comparisons do
      not need more than 10 or 20 levels of recursion. By default, recursion
      depth is limited to 1000 to avoid stack overflow problems. If the limit is
      reached, the prover assumes that the terms are uncomparable. Smaller
      values make the comparison attempts faster, but less exact. Larger values
      have the opposite effect. Values up to 20000 should be save on most
      operating systems. If you run into segmentation faults while using LPO or
      LPO4, first try to set this limit to a reasonable value. If the problem
      persists, send a bug report ;-) The option without the optional argument
      is equivalent to <b>--lpo-recursion-limit</b>=<i>100</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--restrict-literal-comparisons</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Make all literals uncomparable in the term ordering (i.e.
      do not use the term ordering to restrict paramodulation, equality
      resolution and factoring to certain literals. This is necessary to make
      Set-of-Support-strategies complete for the non-equational case (It still
      is incomplete for the equational case, but pretty useless anyways).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--sos-uses-input-types</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If input is TPTP format, use TPTP conjectures for
      initializing the Set of Support. If not in TPTP format, use E-LOP queries
      (clauses of the form ?-l(X),...,m(Y)). Normally, all negative clauses are
      used. Please note that most E heuristics do not use this information at
      all, it is currently only useful for certain parameter settings (including
      the SimulateSOS priority function).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--destructive-er</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Allow destructive equality resolution inferences on
      pure-variable literals of the form X!=Y, i.e. replace the original clause
      with the result of an equality resolution inference on this literal.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--strong-destructive-er</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Allow destructive equality resolution inferences on
      literals of the form X!=t (where X does not occur in t), i.e. replace the
      original clause with the result of an equality resolution inference on
      this literal. Unless I am brain-dead, this maintains completeness,
      although the proof is rather tricky.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--destructive-er-aggressive</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Apply destructive equality resolution to all newly
      generated clauses, not just to selected clauses. Implies
      <b>--destructive-er</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--forward-context-sr</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Apply contextual simplify-reflect with processed clauses to
      the given clause.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--forward-context-sr-aggressive</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Apply contextual simplify-reflect with processed clauses to
      new clauses. Implies <b>--forward-context-sr</b>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--backward-context-sr</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Apply contextual simplify-reflect with the given clause to
      processed clauses.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-g</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--prefer-general-demodulators</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Prefer general demodulators. By default, E prefers
      specialized demodulators. This affects in which order the rewrite index is
      traversed.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-F</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--forward_demod_level=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the desired level for rewriting of unprocessed clauses.
      A value of 0 means no rewriting, 1 indicates to use rules (orientable
      equations) only, 2 indicates full rewriting with rules and instances of
      unorientable equations. Default behavior is 2.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--strong-rw-inst</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Instantiate unbound variables in matching potential
      demodulators with a small constant terms.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-u</b></div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--strong-forward-subsumption</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Try multiple positions and unit-equations to try to
      equationally subsume a single new clause. Default is to search for a
      single position.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--watchlist[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Give the name for a file containing clauses to be watched
      for during the saturation process. If a clause is generated that subsumes
      a watchlist clause, the subsumed clause is removed from the watchlist. The
      prover will terminate when the watchlist is empty. If you want to use the
      watchlist for guiding the proof, put the empty clause onto the list and
      use the built-in clause selection heuristic 'UseWatchlist' (or build a
      heuristic yourself using the priority functions 'PreferWatchlist' and
      'DeferWatchlist'). Use the argument 'Use inline watchlist type' (or no
      argument) and the special clause type 'watchlist' if you want to put
      watchlist clauses into the normal input stream. This is only supported for
      TPTP input formats. The option without the optional argument is equivalent
      to <b>--watchlist=</b>'Use inline watchlist type'.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--no-watchlist-simplification</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Normally, that watchlist is brought into normal form with
      respect to the current processed clause set and certain simplifications.
      This option disables this behaviour.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--conventional-subsumption</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Equivalent to
    <b>--subsumption-indexing</b>=<i>None</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--subsumption-indexing=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Determine choice of indexing for (most) subsumption
      operations. Choices are 'None' for naive subsumption, 'Direct' for direct
      mapped FV-Indexing, 'Perm' for permuted FV-Indexing and 'PermOpt' for
      permuted FV-Indexing with deletion of (suspected) non-informative
      features. Default behaviour is 'Perm'.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--fvindex-featuretypes=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select the feature types used for indexing. Choices are
      &quot;None&quot; to disable FV-indexing, &quot;AC&quot; for AC compatible
      features (the default) (literal number and symbol counts), &quot;SS&quot;
      for set subsumption compatible features (symbol depth), and
      &quot;All&quot; for all features.Unless you want to measure the effects of
      the different features, I suggest you stick with the default.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--fvindex-maxfeatures[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the maximum initial number of symbols for feature
      computation. Depending on the feature selection, a value of X here will
      convert into 2X+2 features (for set subsumption features), 2X+4 features
      (for AC-compatible features) or 4X+6 features (if all features are used,
      the default). Note that the actually used set of features may be smaller
      than this if the signature does not contain enough symbols.For the Perm
      and PermOpt version, this is _also_ used to set the maximum depth of the
      feature vector index. Yes, I should probably make this into two separate
      options. If you select a small value here, you should probably not use
      &quot;Direct&quot; for the <b>--subsumption-indexing</b> option. The
      option without the optional argument is equivalent to
      <b>--fvindex-maxfeatures</b>= <i>200</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--fvindex-slack[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the number of slots reserved in the index for function
      symbols that may be introduced into the signature later, e.g. by
      splitting. If no new symbols are introduced, this just wastes time and
      memory. If PermOpt is chosen, the slackness slots will be deleted from the
      index anyways, but will still waste (a little) time in computing feature
      vectors. The option without the optional argument is equivalent to
      <b>--fvindex-slack</b>= <i>0</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--rw-bw-index[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select fingerprint function for backwards rewrite index.
      &quot;NoIndex&quot; will disable paramodulation indexing. For a list of
      the other values run 'eprover <b>--pm-index</b>=<i>none</i>'. FPX
      functions will use a fingerprint of X positions, the letters disambiguate
      between different fingerprints with the same sample size. The option
      without the optional argument is equivalent to
      <b>--rw-bw-index</b>=<i>FP7</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pm-from-index[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select fingerprint function for the index for
      paramodulation from indexed clauses. &quot;NoIndex&quot; will disable
      paramodulation indexing. For a list of the other values run 'eprover
      <b>--pm-index</b>= <i>none</i>'. FPX functionswill use a fingerprint of X
      positions, the letters disambiguate between different fingerprints with
      the same sample size. The option without the optional argument is
      equivalent to <b>--pm-from-index</b>=<i>FP7</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pm-into-index[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select fingerprint function for the index for
      paramodulation into the indexed clauses. &quot;NoIndex&quot; will disable
      paramodulation indexing. For a list of the other values run 'eprover
      <b>--pm-index</b>= <i>none</i>'. FPX functionswill use a fingerprint of X
      positions, the letters disambiguate between different fingerprints with
      the same sample size. The option without the optional argument is
      equivalent to <b>--pm-into-index</b>=<i>FP7</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--fp-index[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Select fingerprint function for all fingerprint indices.
      See above. The option without the optional argument is equivalent to
      <b>--fp-index</b>= <i>FP7</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--fp-no-size-constr</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Disable usage of size constraints for matching with
      fingerprint indexing.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pdt-no-size-constr</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Disable usage of size constraints for matching with perfect
      discrimination trees indexing.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--pdt-no-age-constr</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Disable usage of age constraints for matching with perfect
      discrimination trees indexing.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--detsort-rw</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Sort set of clauses eliminated by backward rewriting using
      a total syntactic ordering.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--detsort-new</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Sort set of newly generated and backward simplified clauses
      using a total syntactic ordering.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-D</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--define-weight-function=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag">Define</dt>
  <dd class="It-tag">a weight function (see manual for details). Later
      definitions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">override previous definitions.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>-H</b>
  &lt;arg&gt;</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--define-heuristic=</b>&lt;arg&gt;</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Define a clause selection heuristic (see manual for
      details). Later definitions override previous definitions.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--free-numbers</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Treat numbers (strings of decimal digits) as normal free
      function symbols in the input. By default, number now are supposed to
      denote domain constants and to be implicitly different from each
    other.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--free-objects</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Treat object identifiers (strings in double quotes) as
      normal free function symbols in the input. By default, object identifiers
      now represent domain objects and are implicitly different from each other
      (and from numbers, unless those are declared to be free).</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--definitional-cnf[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Tune the clausification algorithm to introduces definitions
      for subformulae to avoid exponential blow-up. The optional argument is a
      fudge factor that determines when definitions are introduced. 0 disables
      definitions completely. The default works well. The option without the
      optional argument is equivalent to
    <b>--definitional-cnf</b>=<i>24</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--old-cnf[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">As the previous option, but use the classical, well-tested
      clausification algorithm as opposed to the newewst one which avoides some
      algorithmic pitfalls and hence works better on some exotic formulae. The
      two may produce slightly different (but equisatisfiable) clause normal
      forms. The option without the optional argument is equivalent to
      <b>--old-cnf</b>= <i>24</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--miniscope-limit[=</b>&lt;arg&gt;]</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Set the limit of variables to miniscope per input formula.
      The build-in default is 1000. Only applies to the new (default)
      clausification algorithm The option without the optional argument is
      equivalent to <b>--miniscope-limit</b>=<i>2147483648</i>.</dd>
</dl>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"><b>--print-types</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Print the type of every term. Useful for debugging
      purposes.</dd>
</dl>
<h1 class="Sh" title="Sh" id="REPORTING_BUGS"><a class="selflink" href="#REPORTING_BUGS">REPORTING
  BUGS</a></h1>
Report bugs to &lt;schulz@eprover.org&gt;. Please include the following, if
  possible:
<div class="Pp"></div>
* The version of the package as reported by <b>eprover --version</b>.
<div class="Pp"></div>
* The operating system and version.
<div class="Pp"></div>
* The exact command line that leads to the unexpected behaviour.
<div class="Pp"></div>
* A description of what you expected and what actually happend.
<div class="Pp"></div>
* If possible all input files necessary to reproduce the bug.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 1998-2017 by Stephan Schulz, schulz@eprover.org, and the E
  contributors (see DOC/CONTRIBUTORS).
<div class="Pp"></div>
This program is a part of the distribution of the equational theorem prover E.
  You can find the latest version of the E distribution as well as additional
  information at http://www.eprover.org
<div class="Pp"></div>
This program is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any later
  version.
<div class="Pp"></div>
This program is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU General Public License for more details.
<div class="Pp"></div>
You should have received a copy of the GNU General Public License along with
  this program (it should be contained in the top level directory of the
  distribution in the file COPYING); if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
<div class="Pp"></div>
The original copyright holder can be contacted via email or as
<div class="Pp"></div>
Stephan Schulz DHBW Stuttgart Fakultaet Technik Informatik Rotebuehlplatz 41
  70178 Stuttgart Germany</div>
<table class="foot">
  <tr>
    <td class="foot-date">July 2017</td>
    <td class="foot-os">E 2.0 Turzum</td>
  </tr>
</table>
</body>
</html>
