<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:20:13 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>KAK_COMMANDS(1) commands KAK_COMMANDS(1)</p>

<p style="margin-top: 1em">NAME <br>
commands - a</p>

<p style="margin-top: 1em">PRIMITIVES <br>
Some commands take an exclamation mark (!), which can be
used to force the execution of the command (i.e. to quit a
modified buffer, the command q! has to be used).</p>

<p style="margin-top: 1em">cd [&lt;directory&gt;] <br>
change the current directory to directory, or the home
directory if unspecified</p>

<p style="margin-top: 1em">doc &lt;topic&gt; <br>
display documentation about a topic. The completion list
displays the available topics</p>

<p style="margin-top: 1em">e[dit][!] &lt;filename&gt;
[&lt;line&gt; [&lt;column&gt;]] <br>
open buffer on file, go to given line and column. If file is
already opened, just switch to this file. Use edit! to force
reloading</p>

<p style="margin-top: 1em">w[rite] [&lt;filename&gt;] <br>
write buffer to &lt;filename&gt; or use it&acirc;s name if
filename is not given</p>

<p style="margin-top: 1em">w[rite]a[ll] <br>
write all buffers that are associated to a file</p>

<p style="margin-top: 1em">q[uit][!] <br>
exit Kakoune, use quit! to force quitting even if there is
some unsaved buffers remaining</p>

<p style="margin-top: 1em">kill <br>
terminate the current session, all the clients as well as
the server</p>

<p style="margin-top: 1em">w[a]q[!] <br>
write the current buffer (or all buffers when waq is used)
and quit</p>

<p style="margin-top: 1em">b[uffer] &lt;name&gt; <br>
switch to buffer &lt;name&gt;</p>

<p style="margin-top: 1em">b[uffer]n[ext] <br>
switch to the next buffer</p>

<p style="margin-top: 1em">b[uffer]p[rev] <br>
switch to the previous buffer</p>

<p style="margin-top: 1em">d[el]b[uf][!] [&lt;name&gt;]
<br>
delete the buffer &lt;name&gt;</p>

<p style="margin-top: 1em">source &lt;filename&gt; <br>
execute commands in &lt;filename&gt;</p>

<p style="margin-top: 1em">runtime &lt;filename&gt; <br>
execute commands in &lt;filename&gt;, &lt;filename&gt; is
relative to kak executable path</p>

<p style="margin-top: 1em">colorscheme &lt;name&gt; <br>
load named colorscheme</p>

<p style="margin-top: 1em">rename-client &lt;name&gt; <br>
set current client name</p>

<p style="margin-top: 1em">rename-buffer &lt;name&gt; <br>
set current buffer name</p>

<p style="margin-top: 1em">rename-session &lt;name&gt; <br>
set current session name</p>

<p style="margin-top: 1em">echo [options] &lt;text&gt; <br>
show text in status line, with the following options:</p>

<p style="margin-top: 1em">-color &lt;face&gt; <br>
print the given text with face, most commonly Error or
Information</p>

<p style="margin-top: 1em">-markup <br>
expand the markup strings in text (c.f. the expansions
documentation page)</p>

<p style="margin-top: 1em">-debug <br>
print the given text to the ebug* buffer</p>

<p style="margin-top: 1em">nop <br>
does nothing, but arguments will be evaluated (e.g. shell
expansion)</p>

<p style="margin-top: 1em">set &lt;scope&gt; &lt;name&gt;
&lt;value&gt; <br>
change the value of an option (c.f. the options
documentation page), note that the name of a particular
buffer can be specified when the target scope is buffer,
e.g. set <br>
buffer=/path/to/buffer foo &quot;bar&quot;; the scope can
also take the current special value, which will
automatically point to the narrowest scope available in the
current context</p>

<p style="margin-top: 1em">unset &lt;scope&gt; &lt;name&gt;
<br>
unset the value of an option (c.f. the options documentation
page)</p>

<p style="margin-top: 1em">alias &lt;scope&gt; &lt;name&gt;
&lt;command&gt; <br>
define a new alias, within the context of a scope</p>

<p style="margin-top: 1em">unalias &lt;scope&gt;
&lt;name&gt; [&lt;command&gt;] <br>
remove an alias if its current value is the same as the one
passed as an optional parameter, remove it unconditionally
otherwise</p>

<p style="margin-top: 1em">declare-option [-hidden]
&lt;type&gt; &lt;name&gt; [&lt;value&gt;] <br>
declare a new option, the -hidden hides the option in
completion suggestions (c.f. the options documentation
page)</p>

<p style="margin-top: 1em">face &lt;name&gt;
&lt;facespec&gt; <br>
define a face (c.f. the faces documentation page)</p>

<p style="margin-top: 1em">exec [&lt;flags&gt;] &lt;key&gt;
... <br>
execute a series of keys, as if they were hit (c.f. the
execeval documentation page)</p>

<p style="margin-top: 1em">eval [&lt;flags&gt;]
&lt;command&gt; ... <br>
execute commands, as if they were entered in the command
prompt (c.f. the execeval documentation page)</p>

<p style="margin-top: 1em">define-command [&lt;flags&gt;]
&lt;name&gt; &lt;command&gt; <br>
define a new command (c.f. the Declaring new commands
section below)</p>

<p style="margin-top: 1em">map &lt;scope&gt; &lt;mode&gt;
&lt;key&gt; &lt;keys&gt; <br>
make key behave as if keys were typed. with scope being one
of global, buffer or window, mode being insert, normal,
prompt, menu or user.</p>

<p style="margin-top: 1em">*user* mode allows for user
mapping behind the *,* key. Keys <br>
will be executed in normal mode.</p>

<p style="margin-top: 1em">unmap &lt;scope&gt; &lt;mode&gt;
&lt;key&gt; [&lt;expected&gt;] <br>
remove the mapping of key in given scope and mode, if
expected is specified, only remove the mapping it if matches
the expected keys.</p>

<p style="margin-top: 1em">hook [-group &lt;group&gt;]
&lt;scope&gt; &lt;hook_name&gt; &lt;filtering_regex&gt;
&lt;command&gt; <br>
execute a command whenever an event is triggered (c.f. the
hooks documentation page)</p>

<p style="margin-top: 1em">remove-hooks &lt;scope&gt;
&lt;group&gt; <br>
remove every hooks in scope that are part of the given group
(c.f. the hooks documentation page)</p>

<p style="margin-top: 1em">add-highlighter [&lt;flags&gt;]
&lt;highlighter_name&gt; &lt;highlighter_parameters&gt; ...
<br>
add a highlighter to the current window (c.f. the
highlighters documentation page)</p>

<p style="margin-top: 1em">remove-highlighter
&lt;highlighter_id&gt; <br>
remove the highlighter whose id is highlighter_id (c.f. the
highlighters documentation page)</p>

<p style="margin-top: 1em">HELPERS <br>
Kakoune provides some helper commands that can be used to
define composite commands:</p>

<p style="margin-top: 1em">prompt &lt;prompt&gt;
&lt;command&gt; <br>
prompt the user for a string, when the user validates,
executes the command. The entered text is available in the
text value accessible through $kak_text in shells or <br>
%val{text} in commands.</p>

<p style="margin-top: 1em">The *-init &lt;str&gt;* switch
allows setting initial content, the <br>
*-password* switch hides the entered text and clears the
register <br>
after command execution.</p>

<p style="margin-top: 1em">on-key &lt;command&gt; <br>
wait for next key from user, then execute &lt;command&gt;,
the key is available through the key value, accessible
through $kak_key in shells, or %val{key} in commands.</p>

<p style="margin-top: 1em">menu &lt;label1&gt;
&lt;commands1&gt; &lt;label2&gt; &lt;commands2&gt; ... <br>
display a menu using labels, the selected label&acirc;s
commands are executed. menu can take an -auto-single
argument, to automatically run commands when only one choice
is <br>
provided, and a -select-cmds argument, in which case menu
takes three argument per item, the last one being a command
to execute when the item is selected (but not validated)</p>

<p style="margin-top: 1em">info [options] &lt;text&gt; <br>
display text in an information box with the following
options:</p>

<p style="margin-top: 1em">-anchor
&lt;line&gt;.&lt;column&gt; <br>
print the text at the given coordinates</p>

<p style="margin-top: 1em">-placement {above,below} <br>
set the placement relative to the anchor</p>

<p style="margin-top: 1em">-title &lt;text&gt; <br>
set the title of the message box</p>

<p style="margin-top: 1em">try &lt;commands&gt; catch
&lt;on_error_commands&gt; <br>
prevent an error in commands from aborting the whole
commands execution, execute on_error_commands instead. If
nothing is to be done on error, the catch part can be
omitted</p>

<p style="margin-top: 1em">reg &lt;name&gt; &lt;content&gt;
<br>
set register name to content</p>

<p style="margin-top: 1em">select
&lt;anchor_line&gt;.&lt;anchor_column&gt;,&lt;cursor_line&gt;.&lt;cursor_column&gt;:...
<br>
replace the current selections with the one described in the
argument</p>

<p style="margin-top: 1em">debug
{info,buffers,options,memory,shared-strings} <br>
print some debug information in the ebug* buffer</p>

<p style="margin-top: 1em">Note that those commands are
also available in the interactive mode, but are not really
useful in that context.</p>

<p style="margin-top: 1em">MULTIPLE COMMANDS <br>
Commands (c.f. previous sections) can be chained, by being
separated either by new lines or by semicolons, as such a
semicolon must be escaped with a backslash (;) to be <br>
considered as a literal semicolon argument</p>

<p style="margin-top: 1em">DECLARING NEW COMMANDS <br>
New commands can be defined using the define-command
command:</p>

<p style="margin-top: 1em">define-command [flags]
&lt;command_name&gt; &lt;commands&gt; <br>
commands is a string containing the commands to execute, and
flags can be any combination of the following
parameters:</p>

<p style="margin-top: 1em">-params &lt;num&gt; <br>
the command accepts a num parameter, which can be either a
number, or of the form &lt;min&gt;..&lt;max&gt;, with both
&lt;min&gt; and &lt;max&gt; omittable</p>

<p style="margin-top: 1em">-file-completion <br>
try file completion on any parameter passed to this
command</p>

<p style="margin-top: 1em">-client-completion <br>
try client name completion on any parameter passed to this
command</p>

<p style="margin-top: 1em">-buffer-completion <br>
try buffer name completion on any parameter passed to this
command</p>

<p style="margin-top: 1em">-shell-completion <br>
following string is a shell command which takes parameters
as positional params and output one completion candidate per
line</p>

<p style="margin-top: 1em">-allow-override <br>
allow the new command to replace an existing one with the
same name</p>

<p style="margin-top: 1em">-hidden <br>
do not show the command in command name completions</p>

<p style="margin-top: 1em">-docstring <br>
define the documentation string for the command</p>

<p style="margin-top: 1em">Using shell expansion allows one
to define complex commands or to access Kakoune state:</p>

<p style="margin-top: 1em">def &quot; print_selection %{
echo %sh{ ${kak_selection} } }&quot;</p>
 
<p style="margin-top: 1em">KAK_COMMANDS(1)</p>
<hr>
</body>
</html>
