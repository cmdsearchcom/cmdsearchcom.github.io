<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>NCGEN(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">NCGEN(1)</td>
    <td class="head-vol">UNIDATA UTILITIES</td>
    <td class="head-rtitle">NCGEN(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
ncgen - From a CDL file generate a netCDF-3 file, a netCDF-4 file or a C program
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;">ncgen [-b]
  [-c] [-f] [-k <i>format_name</i>] [- <i>format_code</i>] [-l <i>output
  language</i>] [-n] [-o <i>netcdf_filename</i>] [-x] [ <i>input_file</i>]</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>ncgen</b> generates either a netCDF-3 (i.e. classic) binary .nc file, a
  netCDF-4 (i.e. enhanced) binary .nc file or a file in some source language
  that when executed will construct the corresponding binary .nc file. The input
  to <b>ncgen</b> is a description of a netCDF file in a small language known as
  CDL (network Common Data form Language), described below. Input is read from
  standard input if no input_file is specified. If no options are specified in
  invoking <b>ncgen</b>, it merely checks the syntax of the input CDL file,
  producing error messages for any violations of CDL syntax. Other options can
  be used, for example, to create the corresponding netCDF file, or to generate
  a C program that uses the netCDF C interface to create the netCDF file.
<div class="Pp"></div>
Note that this version of ncgen was originally called ncgen4. The older ncgen
  program has been renamed to ncgen3.
<div class="Pp"></div>
<b>ncgen</b> may be used with the companion program <b>ncdump</b> to perform
  some simple operations on netCDF files. For example, to rename a dimension in
  a netCDF file, use <b>ncdump</b> to get a CDL version of the netCDF file, edit
  the CDL file to change the name of the dimensions, and use <b>ncgen</b> to
  generate the corresponding netCDF file from the edited CDL file.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b></dt>
  <dd class="It-tag">Create a (binary) netCDF file. If the <b>-o</b> option is
      absent, a default file name will be constructed from the basename of the
      CDL file, with any suffix replaced by the `.nc' extension. If a file
      already exists with the specified name, it will be overwritten.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag">Generate <b>C</b> source code that will create a netCDF
      file matching the netCDF specification. The C source code is written to
      standard output; equivalent to -lc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b></dt>
  <dd class="It-tag">Generate <b>FORTRAN 77</b> source code that will create a
      netCDF file matching the netCDF specification. The source code is written
      to standard output; equivalent to -lf77.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b> netcdf_file</dt>
  <dd class="It-tag">Name of the file to pass to calls to
      &quot;nc_create()&quot;. If this option is specified it implies (in the
      absence of any explicit -l flag) the &quot; <b>-b</b>&quot; option. This
      option is necessary because netCDF files cannot be written directly to
      standard output, since standard output is not seekable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k </b><i>format_name</i><b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-</b><i>format_code</i><b></b></dt>
  <dd class="It-tag">The -k flag specifies the format of the file to be created
      and, by inference, the data model accepted by ncgen (i.e. netcdf-3
      (classic) versus netcdf-4 vs netcdf-5). As a shortcut, a numeric
      <i>format_code</i> may be specified instead. The possible
      <i>format_name</i> values for the -k option are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">'classic' or 'nc3' =&gt; netCDF classic format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'64-bit offset' or 'nc6' =&gt; netCDF 64-bit format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'64-bit data or 'nc5' =&gt; netCDF-5 (64-bit data)
    format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'netCDF-4' 0r 'nc4' =&gt; netCDF-4 format (enhanced data
    model)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'netCDF-4 classic model' or 'nc7' =&gt; netCDF-4 classic
    model format</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
</div>
Accepted <i>format_number</i> arguments, just shortcuts for format_names, are:
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">3 =&gt; netcdf classic format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5 =&gt; netcdf 5 format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6 =&gt; netCDF 64-bit format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4 =&gt; netCDF-4 format (enhanced data model)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">7 =&gt; netCDF-4 classic model format</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
</div>
The numeric code &quot;7&quot; is used because &quot;7=3+4&quot;, a mnemonic for
  the format that uses the netCDF-3 data model for compatibility with the
  netCDF-4 storage format for performance. Credit is due to NCO for use of these
  numeric codes instead of the old and confusing format numbers.
<div class="Pp"></div>
Note: The old version format numbers '1', '2', '3', '4', equivalent to the
  format names 'nc3', 'nc6', 'nc4', or 'nc7' respectively, are also still
  accepted but deprecated, due to easy confusion between format numbers and
  format names. Various old format name aliases are also accepted but
  deprecated, e.g. 'hdf5', 'enhanced-nc3', etc. Also, note that -v is accepted
  to mean the same thing as -k for backward compatibility.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b></dt>
  <dd class="It-tag">Don't initialize data with fill values. This can speed up
      creation of large netCDF files greatly, but later attempts to read
      unwritten data from the generated file will not be easily detectable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l </b>output_language<b></b></dt>
  <dd class="It-tag">The -l flag specifies the output language to use when
      generating source code that will create or define a netCDF file matching
      the netCDF specification. The output is written to standard output. The
      currently supported languages have the following flags.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">c|C' =&gt; C language output.</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">f77|fortran77' =&gt; FORTRAN 77 language output</dt>
  <dd class="It-tag">; note that currently only the classic model is
    supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">j|java' =&gt; (experimental) Java language output</dt>
  <dd class="It-tag">; targets the existing Unidata Java interface, which means
      that only the classic model is supported.</dd>
</dl>
</div>
</div>
<h1 class="Sh" title="Sh" id="Choosing_the_output_format"><a class="selflink" href="#Choosing_the_output_format">Choosing
  the output format</a></h1>
The choice of output format is determined by three flags.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k flag.</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>_Format attribute (see below).</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Occurrence of CDF-5 (64-bit data) or</b></dt>
  <dd class="It-tag">netcdf-4 constructs in the input CDL.<b>&quot;</b> <b>The
      term &quot;netCDF-4 constructs&quot; means</b> <b>constructs from the
      enhanced data model,</b> <b>not just special performance-related
      attributes such as</b>
    <br/>
    <b> _ChunkSizes, _DeflateLevel, _Endianness, etc.</b> <b>The term
      &quot;CDF-5 constructs&quot; means</b> <b>extended unsigned integer types
      allowed in the 64-bit data model.</b></dd>
</dl>
<div class="Pp"></div>
Note that there is an ambiguity between the netCDF-4 case and the CDF-5 case is
  only an unsigned type is seen in the input.
<div class="Pp"></div>
The rules are as follows, in order of application.
<dl class="Bl-tag">
  <dt class="It-tag"><b>1.</b></dt>
  <dd class="It-tag">If either Fortran or Java output is specified, then -k flag
      value of 1 (classic model) will be used. Conflicts with the use of
      enhanced constructs in the CDL will report an error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>2.</b></dt>
  <dd class="It-tag">If both the -k flag and _Format attribute are specified,
      the _Format flag will be ignored. If no -k flag is specified, and a
      _Format attribute value is specified, then the -k flag value will be set
      to that of the _Format attribute. Otherwise the -k flag is undefined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>3.</b></dt>
  <dd class="It-tag">If the -k option is defined and is consistent with the CDL,
      ncgen will output a file in the requested form, else an error will be
      reported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>4.</b></dt>
  <dd class="It-tag">If the -k flag is undefined, and if there are CDF-5
      constructs, only, in the CDL, a -k flag value of 5 (64-bit data model)
      will be used. If there are true netCDF-4 constructs in the CDL, a -k flag
      value of 3 (enhanced model) will be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>5.</b></dt>
  <dd class="It-tag">If special performance-related attributes are specified in
      the CDL, a -k flag value of 4 (netCDF-4 classic model) will be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>6.</b></dt>
  <dd class="It-tag">Otherwise ncgen will set the -k flag to 1 (classic
    model).</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
Check the syntax of the CDL file ` <b>foo.cdl</b>':
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;">ncgen
  foo.cdl</div>
</div>
<div class="Pp"></div>
From the CDL file ` <b>foo.cdl</b>', generate an equivalent binary netCDF file
  named ` <b>x.nc</b>':
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;">ncgen -o x.nc
  foo.cdl</div>
</div>
<div class="Pp"></div>
From the CDL file ` <b>foo.cdl</b>', generate a C program containing the netCDF
  function invocations necessary to create an equivalent binary netCDF file
  named ` <b>x.nc</b>':
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;">ncgen -lc
  foo.cdl &gt;x.c</div>
</div>
<h1 class="Sh" title="Sh" id="USAGE"><a class="selflink" href="#USAGE">USAGE</a></h1>
<h2 class="Ss" title="Ss" id="CDL_Syntax_Overview"><a class="selflink" href="#CDL_Syntax_Overview">CDL
  Syntax Overview</a></h2>
Below is an example of CDL syntax, describing a netCDF file with several named
  dimensions (lat, lon, and time), variables (Z, t, p, rh, lat, lon, time),
  variable attributes (units, long_name, valid_range, _FillValue), and some
  data. CDL keywords are in boldface. (This example is intended to illustrate
  the syntax; a real CDL file would have a more complete set of attributes so
  that the data would be more completely self-describing.)
<div style="margin-left: 5.00ex;">
<pre>
netcdf foo {  // an example netCDF specification in CDL
<div class="Pp"></div>
<b>types</b>:
     <i>ubyte</i> <i>enum</i> enum_t {Clear = 0, Cumulonimbus = 1, Stratus = 2};
     <i>opaque</i>(11) opaque_t;
     <i>int</i>(*) vlen_t;
<div class="Pp"></div>
<b>dimensions</b>:
	lat = 10, lon = 5, time =  <i>unlimited</i> ;
<div class="Pp"></div>
<b>variables</b>:
	 <i>long</i>    lat(lat), lon(lon), time(time);
	 <i>float</i>   Z(time,lat,lon), t(time,lat,lon);
	 <i>double</i>  p(time,lat,lon);
	 <i>long</i>    rh(time,lat,lon);
<div class="Pp"></div>
	 <i>string</i>  country(time,lat,lon);
	 <i>ubyte</i>   tag;
<div class="Pp"></div>
	// variable attributes
	lat:long_name = &quot;latitude&quot;;
	lat:units = &quot;degrees_north&quot;;
	lon:long_name = &quot;longitude&quot;;
	lon:units = &quot;degrees_east&quot;;
	time:units = &quot;seconds since 1992-1-1 00:00:00&quot;;
<div class="Pp"></div>
	// typed variable attributes
	 <i>string</i> Z:units = &quot;geopotential meters&quot;;
	 <i>float</i> Z:valid_range = 0., 5000.;
	 <i>double</i> p:_FillValue = -9999.;
	 <i>long</i> rh:_FillValue = -1;
	 <i>vlen_t</i> :globalatt = {17, 18, 19};
<b>data</b>:
	lat   = 0, 10, 20, 30, 40, 50, 60, 70, 80, 90;
	lon   = -140, -118, -96, -84, -52;
<b>group</b>: g {
<b>types</b>:
     <i>compound</i> cmpd_t { <i>vlen_t</i> f1; <i>enum_t</i> f2;};
} // group g
<b>group</b>: h {
<b>variables</b>:
	/g/ <i>cmpd_t</i>  compoundvar;
<b>data</b>:
        compoundvar = { {3,4,5}, enum_t.Stratus } ;
} // group h
}
</pre>
</div>
<div class="Pp"></div>
All CDL statements are terminated by a semicolon. Spaces, tabs, and newlines can
  be used freely for readability. Comments may follow the characters `//' on any
  line.
<div class="Pp"></div>
A CDL description consists of five optional parts: <i>types</i>,
  <i>dimensions</i>, <i>variables</i>, <i>data</i>, beginning with the keyword
  <b>`types:'</b>, <b>`dimensions:'</b>, <b>`variables:'</b>, and
  <b>`data:',</b> respectively. Note several things: (1) the keyword includes
  the trailing colon, so there must not be any space before the colon character,
  and (2) the keywords are required to be lower case.
<div class="Pp"></div>
The <b>variables:</b> section may contain <i>variable declarations</i> and
  <i>attribute assignments</i>. All sections may contain global attribute
  assignments.
<div class="Pp"></div>
In addition, after the <b>data:</b> section, the user may define a series of
  groups (see the example above). Groups themselves can contain types,
  dimensions, variables, data, and other (nested) groups.
<div class="Pp"></div>
The netCDF <b>types:</b> section declares the user defined types. These may be
  constructed using any of the following types: <b>enum</b>, <b>vlen</b>,
  <b>opaque</b>, or <b>compound</b>.
<div class="Pp"></div>
A netCDF <i>dimension</i> is used to define the shape of one or more of the
  multidimensional variables contained in the netCDF file. A netCDF dimension
  has a name and a size. A dimension can have the <b>unlimited</b> size, which
  means a variable using this dimension can grow to any length in that
  dimension.
<div class="Pp"></div>
A <i>variable</i> represents a multidimensional array of values of the same
  type. A variable has a name, a data type, and a shape described by its list of
  dimensions. Each variable may also have associated <i>attributes</i> (see
  below) as well as data values. The name, data type, and shape of a variable
  are specified by its declaration in the <i>variable</i> section of a CDL
  description. A variable may have the same name as a dimension; by convention
  such a variable is one-dimensional and contains coordinates of the dimension
  it names. Dimensions need not have corresponding variables.
<div class="Pp"></div>
A netCDF <i>attribute</i> contains information about a netCDF variable or about
  the whole netCDF dataset. Attributes are used to specify such properties as
  units, special values, maximum and minimum valid values, scaling factors,
  offsets, and parameters. Attribute information is represented by single values
  or arrays of values. For example, &quot;units&quot; is an attribute
  represented by a character array such as &quot;celsius&quot;. An attribute has
  an associated variable, a name, a data type, a length, and a value. In
  contrast to variables that are intended for data, attributes are intended for
  metadata (data about data). Unlike netCDF-3, attribute types can be any user
  defined type as well as the usual built-in types.
<div class="Pp"></div>
In CDL, an attribute is designated by a a type, a variable, a ':', and then an
  attribute name. The type is optional and if missing, it will be inferred from
  the values assigned to the attribute. It is possible to assign <i>global</i>
  attributes not associated with any variable to the netCDF as a whole by
  omitting the variable name in the attribute declaration. Notice that there is
  a potential ambiguity in a specification such as
<pre>
x : a = ...
</pre>
In this situation, x could be either a type for a global attribute, or the
  variable name for an attribute. Since there could both be a type named x and a
  variable named x, there is an ambiguity. The rule is that in this situation, x
  will be interpreted as a type if possible, and otherwise as a variable.
<div class="Pp"></div>
If not specified, the data type of an attribute in CDL is derived from the type
  of the value(s) assigned to it. The length of an attribute is the number of
  data values assigned to it, or the number of characters in the character
  string assigned to it. Multiple values are assigned to non-character
  attributes by separating the values with commas. All values assigned to an
  attribute must be of the same type.
<div class="Pp"></div>
The names for CDL dimensions, variables, attributes, types, and groups may
  contain any non-control utf-8 character except the forward slash character
  (`/'). However, certain characters must escaped if they are used in a name,
  where the escape character is the backward slash `\'. In particular, if the
  leading character off the name is a digit (0-9), then it must be preceded by
  the escape character. In addition, the characters `
  !&quot;#$%&amp;()*,:;&lt;=&gt;?[]^`&#x00B4;{}|~\' must be escaped if they
  occur anywhere in a name. Note also that attribute names that begin with an
  underscore (`_') are reserved for the use of Unidata and should not be used in
  user defined attributes.
<div class="Pp"></div>
Note also that the words `variable', `dimension', `data', `group', and `types'
  are legal CDL names, but be careful that there is a space between them and any
  following colon character when used as a variable name. This is mostly an
  issue with attribute declarations. For example, consider this.
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;"></div>
<div style="margin-left: 5.00ex;">
<pre>
 netcdf ... {
 ...
 variables:
    int dimensions;
        dimensions: attribute=0 ; // this will cause an error
        dimensions : attribute=0 ; // this is ok.
	...
 }
</pre>
</div>
<div class="Pp"></div>
The optional <b>data:</b> section of a CDL specification is where netCDF
  variables may be initialized. The syntax of an initialization is simple: a
  variable name, an equals sign, and a comma-delimited list of constants
  (possibly separated by spaces, tabs and newlines) terminated with a semicolon.
  For multi-dimensional arrays, the last dimension varies fastest. Thus
  row-order rather than column order is used for matrices. If fewer values are
  supplied than are needed to fill a variable, it is extended with a
  type-dependent `fill value', which can be overridden by supplying a value for
  a distinguished variable attribute named `_FillValue'. The types of constants
  need not match the type declared for a variable; coercions are done to convert
  integers to floating point, for example. The constant `_' can be used to
  designate the fill value for a variable. If the type of the variable is
  explicitly `string', then the special constant `NIL` can be used to represent
  a nil string, which is not the same as a zero length string.
<h2 class="Ss" title="Ss" id="Primitive_Data_Types"><a class="selflink" href="#Primitive_Data_Types">Primitive
  Data Types</a></h2>
<div style="margin-left: 5.00ex;">
<pre>
<b>char</b>	characters
<b>byte</b>	8-bit data
<b>short</b>	16-bit signed integers
<b>int</b>	32-bit signed integers
<b>long</b>	(synonymous with <b>int</b>)
<b>int64</b>	64-bit signed integers
<b>float</b>	IEEE single precision floating point (32 bits)
<b>real</b>	(synonymous with <b>float</b>)
<b>double</b>	IEEE double precision floating point (64 bits)
<b>ubyte</b>	unsigned 8-bit data
<b>ushort</b>	16-bit unsigned integers
<b>uint</b>	32-bit unsigned integers
<b>uint64</b>	64-bit unsigned integers
<b>string</b>	arbitrary length strings
</pre>
</div>
<div class="Pp"></div>
CDL supports a superset of the primitive data types of C. The names for the
  primitive data types are reserved words in CDL, so the names of variables,
  dimensions, and attributes must not be primitive type names. In declarations,
  type names may be specified in either upper or lower case.
<div class="Pp"></div>
Bytes are intended to hold a full eight bits of data, and the zero byte has no
  special significance, as it mays for character data. <b>ncgen</b> converts
  <b>byte</b> declarations to <b>char</b> declarations in the output C code and
  to the nonstandard <b>BYTE</b> declaration in output Fortran code.
<div class="Pp"></div>
Shorts can hold values between -32768 and 32767. <b>ncgen</b> converts
  <b>short</b> declarations to <b>short</b> declarations in the output C code
  and to the nonstandard <b>INTEGER*2</b> declaration in output Fortran code.
<div class="Pp"></div>
Ints can hold values between -2147483648 and 2147483647. <b>ncgen</b> converts
  <b>int</b> declarations to <b>int</b> declarations in the output C code and to
  <b>INTEGER</b> declarations in output Fortran code. <b>long</b> is accepted as
  a synonym for <b>int</b> in CDL declarations, but is deprecated since there
  are now platforms with 64-bit representations for C longs.
<div class="Pp"></div>
Int64 can hold values between -9223372036854775808 and 9223372036854775807.
  <b>ncgen</b> converts <b>int64</b> declarations to <b>longlong</b>
  declarations in the output C code.
<div class="Pp"></div>
Floats can hold values between about -3.4+38 and 3.4+38. Their external
  representation is as 32-bit IEEE normalized single-precision floating point
  numbers. <b>ncgen</b> converts <b>float</b> declarations to <b>float</b>
  declarations in the output C code and to <b>REAL</b> declarations in output
  Fortran code. <b>real</b> is accepted as a synonym for <b>float</b> in CDL
  declarations.
<div class="Pp"></div>
Doubles can hold values between about -1.7+308 and 1.7+308. Their external
  representation is as 64-bit IEEE standard normalized double-precision floating
  point numbers. <b>ncgen</b> converts <b>double</b> declarations to
  <b>double</b> declarations in the output C code and to <b>DOUBLE PRECISION</b>
  declarations in output Fortran code.
<div class="Pp"></div>
The unsigned counterparts of the above integer types are mapped to the
  corresponding unsigned C types. Their ranges are suitably modified to start at
  zero.
<div class="Pp"></div>
The technical interpretation of the char type is that it is an unsigned 8-bit
  value. The encoding of the 256 possible values is unspecified by default. A
  variable of char type may be marked with an &quot;_Encoding&quot; attribute to
  indicate the character set to be used: US-ASCII, ISO-8859-1, etc. Note that
  specifying the encoding of UTF-8 is equivalent to specifying US-ASCII This is
  because multi-byte UTF-8 characters cannot be stored in an 8-bit character.
  The only legal single byte UTF-8 values are by definition the 7-bit US-ASCII
  encoding with the top bit set to zero.
<div class="Pp"></div>
Strings are assumed by default to be encoded using UTF-8. Note that this means
  that multi-byte UTF-8 encodings may be present in the string, so it is
  possible that the number of distinct UTF-8 characters in a string is smaller
  than the number of 8-bit bytes used to store the string.
<h2 class="Ss" title="Ss" id="CDL_Constants"><a class="selflink" href="#CDL_Constants">CDL
  Constants</a></h2>
Constants assigned to attributes or variables may be of any of the basic netCDF
  types. The syntax for constants is similar to C syntax, except that type
  suffixes must be appended to shorts and floats to distinguish them from longs
  and doubles.
<div class="Pp"></div>
A <i>byte</i> constant is represented by an integer constant with a `b' (or `B')
  appended. In the old netCDF-2 API, byte constants could also be represented
  using single characters or standard C character escape sequences such as `a'
  or `0. This is still supported for backward compatibility, but deprecated to
  make the distinction clear between the numeric byte type and the textual char
  type. Example byte constants include:
<div style="margin-left: 5.00ex;">
<pre>
 0b             // a zero byte
 -1b            // -1 as an 8-bit byte
 255b           // also -1 as a signed 8-bit byte
</pre>
</div>
<div class="Pp"></div>
<i>short</i> integer constants are intended for representing 16-bit signed
  quantities. The form of a <i>short</i> constant is an integer constant with an
  `s' or `S' appended. If a <i>short</i> constant begins with `0', it is
  interpreted as octal, except that if it begins with `0x', it is interpreted as
  a hexadecimal constant. For example:
<div style="margin-left: 5.00ex;">
<pre>
-2s	// a short -2
0123s	// octal
0x7ffs  //hexadecimal
</pre>
</div>
<div class="Pp"></div>
<i>int</i> integer constants are intended for representing 32-bit signed
  quantities. The form of an <i>int</i> constant is an ordinary integer
  constant, although it is acceptable to optionally append a single `l' or `L'
  (again, deprecated). Be careful, though, the L suffix is interpreted as a 32
  bit integer, and never as a 64 bit integer. This can be confusing since the C
  long type can ambigously be either 32 bit or 64 bit.
<div class="Pp"></div>
If an <i>int</i> constant begins with `0', it is interpreted as octal, except
  that if it begins with `0x', it is interpreted as a hexadecimal constant (but
  see opaque constants below). Examples of valid <i>int</i> constants include:
<div style="margin-left: 5.00ex;">
<pre>
-2
1234567890L
0123		// octal
0x7ff		// hexadecimal
</pre>
</div>
<div class="Pp"></div>
<i>int64</i> integer constants are intended for representing 64-bit signed
  quantities. The form of an <i>int64</i> constant is an integer constant with
  an `ll' or `LL' appended. If an <i>int64</i> constant begins with `0', it is
  interpreted as octal, except that if it begins with `0x', it is interpreted as
  a hexadecimal constant. For example:
<div style="margin-left: 5.00ex;">
<pre>
-2ll	// an unsigned -2
0123LL	// octal
0x7ffLL  //hexadecimal
</pre>
</div>
<div class="Pp"></div>
Floating point constants of type <i>float</i> are appropriate for representing
  floating point data with about seven significant digits of precision. The form
  of a <i>float</i> constant is the same as a C floating point constant with an
  `f' or `F' appended. For example the following are all acceptable <i>float</i>
  constants:
<div style="margin-left: 5.00ex;">
<pre>
-2.0f
3.14159265358979f	// will be truncated to less precision
1.f
<div class="Pp"></div>
</pre>
</div>
<div class="Pp"></div>
Floating point constants of type <i>double</i> are appropriate for representing
  floating point data with about sixteen significant digits of precision. The
  form of a <i>double</i> constant is the same as a C floating point constant.
  An optional `d' or `D' may be appended. For example the following are all
  acceptable <i>double</i> constants:
<div style="margin-left: 5.00ex;">
<pre>
-2.0
3.141592653589793
1.0e-20
1.d
</pre>
</div>
<div class="Pp"></div>
Unsigned integer constants can be created by appending the character 'U' or 'u'
  between the constant and any trailing size specifier, or immediately at the
  end of the size specifier. Thus one could say 10U, 100su, 100000ul, or
  1000000llu, for example.
<div class="Pp"></div>
Single character constants may be enclosed in single quotes. If a sequence of
  one or more characters is enclosed in double quotes, then its interpretation
  must be inferred from the context. If the dataset is created using the netCDF
  classic model, then all such constants are interpreted as a character array,
  so each character in the constant is interpreted as if it were a single
  character. If the dataset is netCDF extended, then the constant may be
  interpreted as for the classic model or as a true string (see below) depending
  on the type of the attribute or variable into which the string is contained.
<div class="Pp"></div>
The interpretation of char constants is that those that are in the printable
  ASCII range (' '..'~') are assumed to be encoded as the 1-byte subset ofUTF-8,
  which is equivalent to US-ASCII. In all cases, the usual C string escape
  conventions are honored for values from 0 thru 127. Values greater than 127
  are allowed, but their encoding is undefined. For netCDF extended, the use of
  the char type is deprecated in favor of the string type.
<div class="Pp"></div>
Some character constant examples are as follows.
<div style="margin-left: 5.00ex;">
<pre>
 'a'		// ASCII `a'
 &quot;a&quot;		// equivalent to 'a'
 &quot;Two\nlines\n&quot;	// a 10-character string with two embedded newlines
 &quot;a bell:\007&quot;	// a string containing an ASCII bell
</pre>
</div>
Note that the netCDF character array &quot;a&quot; would fit in a one-element
  variable, since no terminating NULL character is assumed. However, a zero byte
  in a character array is interpreted as the end of the significant characters
  by the <b>ncdump</b> program, following the C convention. Therefore, a NULL
  byte should not be embedded in a character string unless at the end: use the
  <i>byte</i> data type instead for byte arrays that contain the zero byte.
<div class="Pp"></div>
<i>String</i> constants are, like character constants, represented using double
  quotes. This represents a potential ambiguity since a multi-character string
  may also indicate a dimensioned character value. Disambiguation usually occurs
  by context, but care should be taken to specify the <i>string</i> type to
  ensure the proper choice. String constants are assumed to always be UTF-8
  encoded. This specifically means that the string constant may actually contain
  multi-byte UTF-8 characters. The special constant `NIL` can be used to
  represent a nil string, which is not the same as a zero length string.
<div class="Pp"></div>
<i>Opaque</i> constants are represented as sequences of hexadecimal digits
  preceded by 0X or 0x: 0xaa34ffff, for example. These constants can still be
  used as integer constants and will be either truncated or extended as
  necessary.
<h2 class="Ss" title="Ss" id="Compound_Constant_Expressions"><a class="selflink" href="#Compound_Constant_Expressions">Compound
  Constant Expressions</a></h2>
In order to assign values to variables (or attributes) whose type is
  user-defined type, the constant notation has been extended to include
  sequences of constants enclosed in curly brackets (e.g.
  &quot;{&quot;...&quot;}&quot;). Such a constant is called a compound constant,
  and compound constants can be nested.
<div class="Pp"></div>
Given a type &quot;T(*) vlen_t&quot;, where T is some other arbitrary base type,
  constants for this should be specified as follows.
<pre>
    vlen_t var[2] = {t11,t12,...t1N}, {t21,t22,...t2m};
</pre>
The values tij, are assumed to be constants of type T.
<div class="Pp"></div>
Given a type &quot;compound cmpd_t {T1 f1; T2 f2...Tn fn}&quot;, where the Ti
  are other arbitrary base types, constants for this should be specified as
  follows.
<pre>
    cmpd_t var[2] = {t11,t12,...t1N}, {t21,t22,...t2n};
</pre>
The values tij, are assumed to be constants of type Ti. If the fields are
  missing, then they will be set using any specified or default fill value for
  the field's base type.
<div class="Pp"></div>
The general set of rules for using braces are defined in the <b>Specifying</b>
  <b>Datalists</b> section below.
<h2 class="Ss" title="Ss" id="Scoping_Rules"><a class="selflink" href="#Scoping_Rules">Scoping
  Rules</a></h2>
With the addition of groups, the name space for defined objects is no longer
  flat. References (names) of any type, dimension, or variable may be prefixed
  with the absolute path specifying a specific declaration. Thus one might say
<pre>
    variables:
        /g1/g2/t1 v1;
</pre>
The type being referenced (t1) is the one within group g2, which in turn is
  nested in group g1. The similarity of this notation to Unix file paths is
  deliberate, and one can consider groups as a form of directory structure.
<div class="Pp"></div>
When name is not prefixed, then scope rules are applied to locate the specified
  declaration. Currently, there are three rules: one for dimensions, one for
  types and enumeration constants, and one for all others.
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;">When an
  unprefixed name of a dimension is used (as in a variable declaration), ncgen
  first looks in the immediately enclosing group for the dimension. If it is not
  found there, then it looks in the group enclosing this group. This continues
  up the group hierarchy until the dimension is found, or there are no more
  groups to search.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;">2. When an
  unprefixed name of a type or an enumeration constant is used, ncgen searches
  the group tree using a pre-order depth-first search. This essentially means
  that it will find the matching declaration that precedes the reference
  textually in the cdl file and that is &quot;highest&quot; in the group
  hierarchy.</div>
<div class="Pp"></div>
<div class="Pp" style="margin-left: 5.00ex; text-indent: -5.00ex;">3. For all
  other names, only the immediately enclosing group is searched.</div>
<div class="Pp"></div>
One final note. Forward references are not allowed. This means that specifying,
  for example, /g1/g2/t1 will fail if this reference occurs before g1 and/or g2
  are defined.
<h2 class="Ss" title="Ss" id="Specifying_Enumeration_Constants"><a class="selflink" href="#Specifying_Enumeration_Constants">Specifying
  Enumeration Constants</a></h2>
References to Enumeration constants (in data lists) can be ambiguous since the
  same enumeration constant name can be defined in more than one enumeration. If
  a cdl file specified an ambiguous constant, then ncgen will signal an error.
  Such constants can be disambiguated in two ways.
<dl class="Bl-tag">
  <dt class="It-tag"><b>1.</b></dt>
  <dd class="It-tag">Prefix the enumeration constant with the name of the
      enumeration separated by a dot: <i>enum.econst</i>, for example.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>2.</b></dt>
  <dd class="It-tag">If case one is not sufficient to disambiguate the
      enumeration constant, then one must specify the precise enumeration type
      using a group path: <i>/g1/g2/enum.econst</i>, for example.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Special_Attributes"><a class="selflink" href="#Special_Attributes">Special
  Attributes</a></h2>
Special, virtual, attributes can be specified to provide performance-related
  information about the file format and about variable properties. The file must
  be a netCDF-4 file for these to take effect.
<div class="Pp"></div>
These special virtual attributes are not actually part of the file, they are
  merely a convenient way to set miscellaneous properties of the data in CDL
<div class="Pp"></div>
The special attributes currently supported are as follows: `_Format',
  `_Fletcher32, `_ChunkSizes', `_Endianness', `_DeflateLevel', `_Shuffle', and
  `_Storage'.
<div class="Pp"></div>
`_Format' is a global attribute specifying the netCDF format variant. Its value
  must be a single string matching one of `classic', `64-bit offset', `64-bit
  data', `netCDF-4', or `netCDF-4 classic model'.
<div class="Pp"></div>
The rest of the special attributes are all variable attributes. Essentially all
  of then map to some corresponding `nc_def_var_XXX' function as defined in the
  netCDF-4 API. For the attributes that are essentially boolean (_Fletcher32,
  _Shuffle, and _NOFILL), the value true can be specified by using the strings
  `true' or `1', or by using the integer 1. The value false expects either
  `false', `0', or the integer 0. The actions associated with these attributes
  are as follows.
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">`_Fletcher32 sets the `fletcher32' property for a
    variable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">`_Endianness' is either `little' or `big', depending on how
      the variable is stored when first written.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">`_DeflateLevel' is an integer between 0 and 9 inclusive if
      compression has been specified for the variable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">`_Shuffle' specifies if the the shuffle filter should be
      used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">`_Storage' is `contiguous' or `chunked'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6.</dt>
  <dd class="It-tag">`_ChunkSizes' is a list of chunk sizes for each dimension
      of the variable</dd>
</dl>
<div class="Pp"></div>
Note that attributes such as &quot;add_offset&quot; or &quot;scale_factor&quot;
  have no special meaning to ncgen. These attributes are currently conventions,
  handled above the library layer by other utility packages, for example NCO.
<h2 class="Ss" title="Ss" id="Specifying_Datalists"><a class="selflink" href="#Specifying_Datalists">Specifying
  Datalists</a></h2>
Specifying datalists for variables in the `data:` section can be somewhat
  complicated. There are some rules that must be followed to ensure that
  datalists are parsed correctly by ncgen.
<div class="Pp"></div>
First, the top level is automatically assumed to be a list of items, so it
  should not be inside {...}. That means that if the variable is a scalar, there
  will be a single top-level element and if the variable is an array, there will
  be N top-level elements. For each element of the top level list, the following
  rules should be applied.
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Instances of UNLIMITED dimensions (other than the first
      dimension) must be surrounded by {...} in order to specify the size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Compound instances must be embedded in {...}</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Non-scalar fields of compound instances must be embedded in
      {...}.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">Instances of vlens must be surrounded by {...} in order to
      specify the size.</dd>
</dl>
<div class="Pp"></div>
Datalists associated with attributes are implicitly a vector (i.e., a list) of
  values of the type of the attribute and the above rules must apply with that
  in mind.
<dl class="Bl-tag">
  <dt class="It-tag">7.</dt>
  <dd class="It-tag">No other use of braces is allowed.</dd>
</dl>
<div class="Pp"></div>
Note that one consequence of these rules is that arrays of values cannot have
  subarrays within braces. Consider, for example, int var(d1)(d2)...(dn), where
  none of d2...dn are unlimited. A datalist for this variable must be a single
  list of integers, where the number of integers is no more than D=d1*d2*...dn
  values; note that the list can be less than D, in which case fill values will
  be used to pad the list.
<div class="Pp"></div>
Rule 6 about attribute datalist has the following consequence. If the type of
  the attribute is a compound (or vlen) type, and if the number of entries in
  the list is one, then the compound instances must be enclosed in braces.
<h2 class="Ss" title="Ss" id="Specifying_Character_Datalists"><a class="selflink" href="#Specifying_Character_Datalists">Specifying
  Character Datalists</a></h2>
Specifying datalists for variables of type char also has some complications.
  consider, for example
<div style="margin-left: 5.00ex;">
<pre>
dimensions: u=UNLIMITED; d1=1; d2=2; d3=3;
            d4=4; d5=5; u2=UNLIMITED;
variables: char var(d4,d5);
datalist: var=&quot;1&quot;, &quot;two&quot;, &quot;three&quot;;
</pre>
</div>
<div class="Pp"></div>
We have twenty elements of var to fill (d5 X d4) and we have three strings of
  length 1, 3, 5. How do we assign the characters in the strings to the twenty
  elements?
<div class="Pp"></div>
This is challenging because it is desirable to mimic the original ncgen
  (ncgen3). The core algorithm is notionally as follows.
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Assume we have a set of dimensions D1..Dn, where D1 may
      optionally be an Unlimited dimension. It is assumed that the sizes of the
      Di are all known (including unlimited dimensions).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Given a sequence of string or character constants C1..Cm,
      our goal is to construct a single string whose length is the cross product
      of D1 thru Dn. Note that for purposes of this algorithm, character
      constants are treated as strings of size 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Construct Dx = cross product of D1 thru D(n-1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">For each constant Ci, add fill characters as needed so that
      its length is a multiple of Dn.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">Concatenate the modified C1..Cm to produce string S.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6.</dt>
  <dd class="It-tag">Add fill characters to S to make its length be a multiple
      of Dn.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">8.</dt>
  <dd class="It-tag">If S is longer than the Dx * Dn, then truncate and generate
      a warning.</dd>
</dl>
<div class="Pp"></div>
There are three other cases of note.
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">If there is only a single, unlimited dimension, then all of
      the constants are concatenated and fill characters are added to the end of
      the resulting string to make its length be that of the unlimited
      dimension. If the length is larger than the unlimited dimension, then it
      is truncated with a warning.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">For the case of character typed vlen, &quot;char(*)
      vlen_t&quot; for example. we simply concatenate all the constants with no
      filling at all.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">For the case of a character typed attribute, we simply
      concatenate all the constants.</dd>
</dl>
<div class="Pp"></div>
In netcdf-4, dimensions other than the first can be unlimited. Of course by the
  rules above, the interior unlimited instances must be delimited by {...}. For
  example.
<br/>
<pre>
variables: char var(u,u2);
datalist: var={&quot;1&quot;, &quot;two&quot;}, {&quot;three&quot;};
</pre>
<br/>
In this case u will have the effective length of two. Within each instance of
  u2, the rules above will apply, leading to this.
<br/>
datalist: var={&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;},
  {&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;};
<br/>
The effective size of u2 will be the max of the two instance lengths (five in
  this case) and the shorter will be padded to produce this.
<br/>
datalist:
  var={&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;,&quot;\0&quot;},
  {&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;};
<br/>
<div class="Pp"></div>
Consider an even more complicated case.
<br/>
<pre>
variables: char var(u,u2,u3);
datalist: var={{&quot;1&quot;, &quot;two&quot;}}, {{&quot;three&quot;},{&quot;four&quot;,&quot;xy&quot;}};
</pre>
<br/>
In this case u again will have the effective length of two. The u2 dimensions
  will have a size = max(1,2) = 2; Within each instance of u2, the rules above
  will apply, leading to this.
<br/>
<pre>
datalist: var={{&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;}}, {{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;},{&quot;f&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;,&quot;x&quot;,&quot;y&quot;}};
</pre>
<br/>
The effective size of u3 will be the max of the two instance lengths (six in
  this case) and the shorter ones will be padded to produce this.
<br/>
<pre>
datalist: var={{&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;,&quot;&#x2002;&quot;,&quot;&#x2002;&quot;}}, {{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;,&quot;&#x2002;&quot;},{&quot;f&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;,&quot;x&quot;,&quot;y&quot;}};
</pre>
<br/>
Note however that the first instance of u2 is less than the max length of u2, so
  we need to add a filler for another instance of u2, producing this.
<br/>
<pre>
datalist: var={{&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;,&quot;&#x2002;&quot;,&quot;&#x2002;&quot;},{&quot;&#x2002;&quot;,&quot;&#x2002;&quot;,&quot;&#x2002;&quot;,&quot;&#x2002;&quot;,&quot;&#x2002;&quot;,&quot;&#x2002;&quot;}}, {{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;,&quot;&#x2002;&quot;},{&quot;f&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;,&quot;x&quot;,&quot;y&quot;}};
</pre>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
The programs generated by <b>ncgen</b> when using the <b>-c</b> flag use
  initialization statements to store data in variables, and will fail to produce
  compilable programs if you try to use them for large datasets, since the
  resulting statements may exceed the line length or number of continuation
  statements permitted by the compiler.
<div class="Pp"></div>
The CDL syntax makes it easy to assign what looks like an array of
  variable-length strings to a netCDF variable, but the strings may simply be
  concatenated into a single array of characters. Specific use of the
  <i>string</i> type specifier may solve the problem
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="CDL_Grammar"><a class="selflink" href="#CDL_Grammar">CDL
  Grammar</a></h1>
The file ncgen.y is the definitive grammar for CDL, but a stripped down version
  is included here for completeness.
<div style="margin-left: 5.00ex;">
<pre>
ncdesc: NETCDF
	datasetid
        rootgroup
        ;
<div class="Pp"></div>
datasetid: DATASETID
<div class="Pp"></div>
rootgroup: '{'
           groupbody
           subgrouplist
           '}';
<div class="Pp"></div>
groupbody:
		attrdecllist
                typesection
                dimsection
                vasection
                datasection
                ;
<div class="Pp"></div>
subgrouplist:
	  /*empty*/
	| subgrouplist namedgroup
	;
<div class="Pp"></div>
namedgroup: GROUP ident '{'
            groupbody
            subgrouplist
            '}'
	    attrdecllist
	    ;
<div class="Pp"></div>
typesection:    /* empty */
                | TYPES
		| TYPES typedecls
                ;
<div class="Pp"></div>
typedecls:
	  type_or_attr_decl
	| typedecls type_or_attr_decl
	;
<div class="Pp"></div>
typename: ident ;
<div class="Pp"></div>
type_or_attr_decl:
	  typedecl
	| attrdecl ';'
	;
<div class="Pp"></div>
typedecl:
	  enumdecl optsemicolon
	| compounddecl optsemicolon
	| vlendecl optsemicolon
	| opaquedecl optsemicolon
	;
<div class="Pp"></div>
optsemicolon:
	  /*empty*/
	| ';'
	;
<div class="Pp"></div>
enumdecl: primtype ENUM typename ;
<div class="Pp"></div>
enumidlist:   enumid
	    | enumidlist ',' enumid
	    ;
<div class="Pp"></div>
enumid: ident '=' constint ;
<div class="Pp"></div>
opaquedecl: OPAQUE '(' INT_CONST ')' typename ;
<div class="Pp"></div>
vlendecl: typeref '(' '*' ')' typename ;
<div class="Pp"></div>
compounddecl: COMPOUND typename '{' fields '}' ;
<div class="Pp"></div>
fields:   field ';'
	| fields field ';'
	;
<div class="Pp"></div>
field: typeref fieldlist ;
<div class="Pp"></div>
primtype:         CHAR_K
                | BYTE_K
                | SHORT_K
                | INT_K
                | FLOAT_K
                | DOUBLE_K
                | UBYTE_K
                | USHORT_K
                | UINT_K
                | INT64_K
                | UINT64_K
                ;
<div class="Pp"></div>
dimsection:     /* empty */
                | DIMENSIONS
		| DIMENSIONS dimdecls
                ;
<div class="Pp"></div>
dimdecls:       dim_or_attr_decl ';'
                | dimdecls dim_or_attr_decl ';'
                ;
<div class="Pp"></div>
dim_or_attr_decl: dimdeclist  | attrdecl  ;
<div class="Pp"></div>
dimdeclist:     dimdecl
                | dimdeclist ',' dimdecl
                ;
<div class="Pp"></div>
dimdecl:
	  dimd '=' UINT_CONST
	| dimd '=' INT_CONST
        | dimd '=' DOUBLE_CONST
        | dimd '=' NC_UNLIMITED_K
        ;
<div class="Pp"></div>
dimd:           ident ;
<div class="Pp"></div>
vasection:      /* empty */
                | VARIABLES
                | VARIABLES vadecls
                ;
<div class="Pp"></div>
vadecls:        vadecl_or_attr ';'
                | vadecls vadecl_or_attr ';'
                ;
<div class="Pp"></div>
vadecl_or_attr: vardecl  | attrdecl  ;
<div class="Pp"></div>
vardecl:        typeref varlist ;
<div class="Pp"></div>
varlist:      varspec
            | varlist ',' varspec
            ;
<div class="Pp"></div>
varspec:        ident dimspec ;
<div class="Pp"></div>
dimspec:        /* empty */
                | '(' dimlist ')'
                ;
<div class="Pp"></div>
dimlist:        dimref
                | dimlist ',' dimref
                ;
<div class="Pp"></div>
dimref: path ;
<div class="Pp"></div>
fieldlist:
	  fieldspec
	| fieldlist ',' fieldspec
        ;
<div class="Pp"></div>
fieldspec: ident fielddimspec ;
<div class="Pp"></div>
fielddimspec:     /* empty */
                | '(' fielddimlist ')'
                ;
<div class="Pp"></div>
fielddimlist:
	  fielddim
	| fielddimlist ',' fielddim
        ;
<div class="Pp"></div>
fielddim:
	  UINT_CONST
	| INT_CONST
	;
<div class="Pp"></div>
/* Use this when referencing defined objects */
varref: type_var_ref ;
<div class="Pp"></div>
typeref: type_var_ref	   ;
<div class="Pp"></div>
type_var_ref:
    	  path
	| primtype
	;
<div class="Pp"></div>
/* Use this for all attribute decls */
/* Watch out; this is left recursive */
attrdecllist: /*empty*/  | attrdecl ';' attrdecllist  ;
<div class="Pp"></div>
attrdecl:
	  ':' ident '=' datalist
	| typeref type_var_ref ':' ident '=' datalist
	| type_var_ref ':' ident '=' datalist
	| type_var_ref ':' _FILLVALUE '=' datalist
	| typeref type_var_ref ':' _FILLVALUE '=' datalist
	| type_var_ref ':' _STORAGE '=' conststring
	| type_var_ref ':' _CHUNKSIZES '=' intlist
	| type_var_ref ':' _FLETCHER32 '=' constbool
	| type_var_ref ':' _DEFLATELEVEL '=' constint
	| type_var_ref ':' _SHUFFLE '=' constbool
	| type_var_ref ':' _ENDIANNESS '=' conststring
	| type_var_ref ':' _NOFILL '=' constbool
	| ':' _FORMAT '=' conststring
	;
<div class="Pp"></div>
path:
	  ident
	| PATH
	;
<div class="Pp"></div>
datasection:    /* empty */
                | DATA
                | DATA datadecls
                ;
<div class="Pp"></div>
datadecls:
	  datadecl ';'
	| datadecls datadecl ';'
	;
<div class="Pp"></div>
datadecl: varref '=' datalist ;
datalist:
	  datalist0
	| datalist1
	;
<div class="Pp"></div>
datalist0:
	/*empty*/
	;
<div class="Pp"></div>
/* Must have at least 1 element */
datalist1:
	  dataitem
	| datalist ',' dataitem
	;
<div class="Pp"></div>
dataitem:
	  constdata
	| '{' datalist '}'
	;
<div class="Pp"></div>
constdata:
	  simpleconstant
	| OPAQUESTRING
	| FILLMARKER
	| NIL
	| econstref
	| function
	;
<div class="Pp"></div>
econstref: path ;
<div class="Pp"></div>
function: ident '(' arglist ')' ;
<div class="Pp"></div>
arglist:
	  simpleconstant
	| arglist ',' simpleconstant
	;
<div class="Pp"></div>
simpleconstant:
	  CHAR_CONST /* never used apparently*/
	| BYTE_CONST
	| SHORT_CONST
	| INT_CONST
	| INT64_CONST
	| UBYTE_CONST
	| USHORT_CONST
	| UINT_CONST
	| UINT64_CONST
	| FLOAT_CONST
	| DOUBLE_CONST
	| TERMSTRING
	;
<div class="Pp"></div>
intlist:
	  constint
	| intlist ',' constint
	;
<div class="Pp"></div>
constint:
	  INT_CONST
	| UINT_CONST
	| INT64_CONST
	| UINT64_CONST
	;
<div class="Pp"></div>
conststring: TERMSTRING ;
<div class="Pp"></div>
constbool:
	  conststring
	| constint
	;
<div class="Pp"></div>
/* Push all idents thru here for tracking */
ident: IDENT ;
</pre>
</div>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">$Date: 2010/04/29 16:38:55 $</td>
    <td class="foot-os">Printed: 0-0-0</td>
  </tr>
</table>
</body>
</html>
