<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:26:58 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>NCGEN(1) UNIDATA UTILITIES NCGEN(1)</p>

<p style="margin-top: 1em">NAME <br>
ncgen - From a CDL file generate a netCDF-3 file, a netCDF-4
file or a C program</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ncgen [-b] [-c] [-f] [-k format_name] [-format_code] [-l
output language] [-n] [-o netcdf_filename] [-x]
[input_file]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
ncgen generates either a netCDF-3 (i.e. classic) binary .nc
file, a netCDF-4 (i.e. enhanced) binary .nc file or a file
in some source language that when executed will construct
<br>
the corresponding binary .nc file. The input to ncgen is a
description of a netCDF file in a small language known as
CDL (network Common Data form Language), described below.
<br>
Input is read from standard input if no input_file is
specified. If no options are specified in invoking ncgen, it
merely checks the syntax of the input CDL file, producing
er&acirc; <br>
ror messages for any violations of CDL syntax. Other options
can be used, for example, to create the corresponding netCDF
file, or to generate a C program that uses the netCDF C <br>
interface to create the netCDF file.</p>

<p style="margin-top: 1em">Note that this version of ncgen
was originally called ncgen4. The older ncgen program has
been renamed to ncgen3.</p>

<p style="margin-top: 1em">ncgen may be used with the
companion program ncdump to perform some simple operations
on netCDF files. For example, to rename a dimension in a
netCDF file, use ncdump to get a <br>
CDL version of the netCDF file, edit the CDL file to change
the name of the dimensions, and use ncgen to generate the
corresponding netCDF file from the edited CDL file.</p>

<p style="margin-top: 1em">OPTIONS <br>
-b Create a (binary) netCDF file. If the -o option is
absent, a default file name will be constructed from the
basename of the CDL file, with any suffix replaced by the
<br>
&lsquo;.nc&rsquo; extension. If a file already exists with
the specified name, it will be overwritten.</p>

<p style="margin-top: 1em">-c Generate C source code that
will create a netCDF file matching the netCDF specification.
The C source code is written to standard output; equivalent
to -lc.</p>

<p style="margin-top: 1em">-f Generate FORTRAN 77 source
code that will create a netCDF file matching the netCDF
specification. The source code is written to standard
output; equivalent to -lf77.</p>

<p style="margin-top: 1em">-o netcdf_file <br>
Name of the file to pass to calls to
&quot;nc_create()&quot;. If this option is specified it
implies (in the absence of any explicit -l flag) the
&quot;-b&quot; option. This option is nec&acirc; <br>
essary because netCDF files cannot be written directly to
standard output, since standard output is not seekable.</p>

<p style="margin-top: 1em">-k format_name</p>

<p style="margin-top: 1em">-format_code <br>
The -k flag specifies the format of the file to be created
and, by inference, the data model accepted by ncgen (i.e.
netcdf-3 (classic) versus netcdf-4 vs netcdf-5). As a <br>
shortcut, a numeric format_code may be specified instead.
The possible format_name values for the -k option are:</p>

<p style="margin-top: 1em">&rsquo;classic&rsquo; or
&rsquo;nc3&rsquo; =&gt; netCDF classic format</p>

<p style="margin-top: 1em">&rsquo;64-bit offset&rsquo; or
&rsquo;nc6&rsquo; =&gt; netCDF 64-bit format</p>

<p style="margin-top: 1em">&rsquo;64-bit data or
&rsquo;nc5&rsquo; =&gt; netCDF-5 (64-bit data) format</p>

<p style="margin-top: 1em">&rsquo;netCDF-4&rsquo; 0r
&rsquo;nc4&rsquo; =&gt; netCDF-4 format (enhanced data
model)</p>

<p style="margin-top: 1em">&rsquo;netCDF-4 classic
model&rsquo; or &rsquo;nc7&rsquo; =&gt; netCDF-4 classic
model format <br>
Accepted format_number arguments, just shortcuts for
format_names, are:</p>

<p style="margin-top: 1em">3 =&gt; netcdf classic
format</p>

<p style="margin-top: 1em">5 =&gt; netcdf 5 format</p>

<p style="margin-top: 1em">6 =&gt; netCDF 64-bit format</p>

<p style="margin-top: 1em">4 =&gt; netCDF-4 format
(enhanced data model)</p>

<p style="margin-top: 1em">7 =&gt; netCDF-4 classic model
format <br>
The numeric code &quot;7&quot; is used because
&quot;7=3+4&quot;, a mnemonic for the format that uses the
netCDF-3 data model for compatibility with the netCDF-4
storage format for performance. <br>
Credit is due to NCO for use of these numeric codes instead
of the old and confusing format numbers.</p>

<p style="margin-top: 1em">Note: The old version format
numbers &rsquo;1&rsquo;, &rsquo;2&rsquo;, &rsquo;3&rsquo;,
&rsquo;4&rsquo;, equivalent to the format names
&rsquo;nc3&rsquo;, &rsquo;nc6&rsquo;, &rsquo;nc4&rsquo;, or
&rsquo;nc7&rsquo; respectively, are also still accepted but
deprecated, due to <br>
easy confusion between format numbers and format names.
Various old format name aliases are also accepted but
deprecated, e.g. &rsquo;hdf5&rsquo;,
&rsquo;enhanced-nc3&rsquo;, etc. Also, note that -v is <br>
accepted to mean the same thing as -k for backward
compatibility.</p>

<p style="margin-top: 1em">-x Don&rsquo;t initialize data
with fill values. This can speed up creation of large netCDF
files greatly, but later attempts to read unwritten data
from the generated file will <br>
not be easily detectable.</p>

<p style="margin-top: 1em">-l output_language <br>
The -l flag specifies the output language to use when
generating source code that will create or define a netCDF
file matching the netCDF specification. The output is <br>
written to standard output. The currently supported
languages have the following flags.</p>

<p style="margin-top: 1em">c|C&rsquo; =&gt; C language
output.</p>

<p style="margin-top: 1em">f77|fortran77&rsquo; =&gt;
FORTRAN 77 language output <br>
; note that currently only the classic model is
supported.</p>

<p style="margin-top: 1em">j|java&rsquo; =&gt;
(experimental) Java language output <br>
; targets the existing Unidata Java interface, which means
that only the classic model is supported.</p>

<p style="margin-top: 1em">Choosing the output format <br>
The choice of output format is determined by three
flags.</p>

<p style="margin-top: 1em">-k flag.</p>

<p style="margin-top: 1em">_Format attribute (see
below).</p>

<p style="margin-top: 1em">Occurrence of CDF-5 (64-bit
data) or <br>
netcdf-4 constructs in the input CDL.&quot; The term
&quot;netCDF-4 constructs&quot; means constructs from the
enhanced data model, not just special performance-related
attributes such <br>
as <br>
_ChunkSizes, _DeflateLevel, _Endianness, etc. The term
&quot;CDF-5 constructs&quot; means extended unsigned integer
types allowed in the 64-bit data model.</p>

<p style="margin-top: 1em">Note that there is an ambiguity
between the netCDF-4 case and the CDF-5 case is only an
unsigned type is seen in the input.</p>

<p style="margin-top: 1em">The rules are as follows, in
order of application.</p>

<p style="margin-top: 1em">1. If either Fortran or Java
output is specified, then -k flag value of 1 (classic model)
will be used. Conflicts with the use of enhanced constructs
in the CDL will report <br>
an error.</p>

<p style="margin-top: 1em">2. If both the -k flag and
_Format attribute are specified, the _Format flag will be
ignored. If no -k flag is specified, and a _Format attribute
value is specified, then <br>
the -k flag value will be set to that of the _Format
attribute. Otherwise the -k flag is undefined.</p>

<p style="margin-top: 1em">3. If the -k option is defined
and is consistent with the CDL, ncgen will output a file in
the requested form, else an error will be reported.</p>

<p style="margin-top: 1em">4. If the -k flag is undefined,
and if there are CDF-5 constructs, only, in the CDL, a -k
flag value of 5 (64-bit data model) will be used. If there
are true netCDF-4 con&acirc; <br>
structs in the CDL, a -k flag value of 3 (enhanced model)
will be used.</p>

<p style="margin-top: 1em">5. If special
performance-related attributes are specified in the CDL, a
-k flag value of 4 (netCDF-4 classic model) will be
used.</p>

<p style="margin-top: 1em">6. Otherwise ncgen will set the
-k flag to 1 (classic model).</p>

<p style="margin-top: 1em">EXAMPLES <br>
Check the syntax of the CDL file &lsquo;foo.cdl&rsquo;:</p>

<p style="margin-top: 1em">ncgen foo.cdl</p>

<p style="margin-top: 1em">From the CDL file
&lsquo;foo.cdl&rsquo;, generate an equivalent binary netCDF
file named &lsquo;x.nc&rsquo;:</p>

<p style="margin-top: 1em">ncgen -o x.nc foo.cdl</p>

<p style="margin-top: 1em">From the CDL file
&lsquo;foo.cdl&rsquo;, generate a C program containing the
netCDF function invocations necessary to create an
equivalent binary netCDF file named &lsquo;x.nc&rsquo;:</p>

<p style="margin-top: 1em">ncgen -lc foo.cdl &gt;x.c</p>

<p style="margin-top: 1em">USAGE <br>
CDL Syntax Overview <br>
Below is an example of CDL syntax, describing a netCDF file
with several named dimensions (lat, lon, and time),
variables (Z, t, p, rh, lat, lon, time), variable attributes
<br>
(units, long_name, valid_range, _FillValue), and some data.
CDL keywords are in boldface. (This example is intended to
illustrate the syntax; a real CDL file would have a more
<br>
complete set of attributes so that the data would be more
completely self-describing.) <br>
netcdf foo { // an example netCDF specification in CDL</p>

<p style="margin-top: 1em">types: <br>
ubyte enum enum_t {Clear = 0, Cumulonimbus = 1, Stratus =
2}; <br>
opaque(11) opaque_t; <br>
int(*) vlen_t;</p>

<p style="margin-top: 1em">dimensions: <br>
lat = 10, lon = 5, time = unlimited ;</p>

<p style="margin-top: 1em">variables: <br>
long lat(lat), lon(lon), time(time); <br>
float Z(time,lat,lon), t(time,lat,lon); <br>
double p(time,lat,lon); <br>
long rh(time,lat,lon);</p>

<p style="margin-top: 1em">string country(time,lat,lon);
<br>
ubyte tag;</p>

<p style="margin-top: 1em">// variable attributes <br>
lat:long_name = &quot;latitude&quot;; <br>
lat:units = &quot;degrees_north&quot;; <br>
lon:long_name = &quot;longitude&quot;; <br>
lon:units = &quot;degrees_east&quot;; <br>
time:units = &quot;seconds since 1992-1-1
00:00:00&quot;;</p>

<p style="margin-top: 1em">// typed variable attributes
<br>
string Z:units = &quot;geopotential meters&quot;; <br>
float Z:valid_range = 0., 5000.; <br>
double p:_FillValue = -9999.; <br>
long rh:_FillValue = -1; <br>
vlen_t :globalatt = {17, 18, 19}; <br>
data: <br>
lat = 0, 10, 20, 30, 40, 50, 60, 70, 80, 90; <br>
lon = -140, -118, -96, -84, -52; <br>
group: g { <br>
types: <br>
compound cmpd_t { vlen_t f1; enum_t f2;}; <br>
} // group g <br>
group: h { <br>
variables: <br>
/g/cmpd_t compoundvar; <br>
data: <br>
compoundvar = { {3,4,5}, enum_t.Stratus } ; <br>
} // group h <br>
}</p>

<p style="margin-top: 1em">All CDL statements are
terminated by a semicolon. Spaces, tabs, and newlines can be
used freely for readability. Comments may follow the
characters &lsquo;//&rsquo; on any line.</p>

<p style="margin-top: 1em">A CDL description consists of
five optional parts: types, dimensions, variables, data,
beginning with the keyword &lsquo;types:&rsquo;,
&lsquo;dimensions:&rsquo;, &lsquo;variables:&rsquo;, and
&lsquo;data:&rsquo;, respective&acirc; <br>
ly. Note several things: (1) the keyword includes the
trailing colon, so there must not be any space before the
colon character, and (2) the keywords are required to be
lower <br>
case.</p>

<p style="margin-top: 1em">The variables: section may
contain variable declarations and attribute assignments. All
sections may contain global attribute assignments.</p>

<p style="margin-top: 1em">In addition, after the data:
section, the user may define a series of groups (see the
example above). Groups themselves can contain types,
dimensions, variables, data, and other <br>
(nested) groups.</p>

<p style="margin-top: 1em">The netCDF types: section
declares the user defined types. These may be constructed
using any of the following types: enum, vlen, opaque, or
compound.</p>

<p style="margin-top: 1em">A netCDF dimension is used to
define the shape of one or more of the multidimensional
variables contained in the netCDF file. A netCDF dimension
has a name and a size. A dimen&acirc; <br>
sion can have the unlimited size, which means a variable
using this dimension can grow to any length in that
dimension.</p>

<p style="margin-top: 1em">A variable represents a
multidimensional array of values of the same type. A
variable has a name, a data type, and a shape described by
its list of dimensions. Each variable <br>
may also have associated attributes (see below) as well as
data values. The name, data type, and shape of a variable
are specified by its declaration in the variable section of
<br>
a CDL description. A variable may have the same name as a
dimension; by convention such a variable is one-dimensional
and contains coordinates of the dimension it names.
Dimen&acirc; <br>
sions need not have corresponding variables.</p>

<p style="margin-top: 1em">A netCDF attribute contains
information about a netCDF variable or about the whole
netCDF dataset. Attributes are used to specify such
properties as units, special values, maxi&acirc; <br>
mum and minimum valid values, scaling factors, offsets, and
parameters. Attribute information is represented by single
values or arrays of values. For example, &quot;units&quot;
is an <br>
attribute represented by a character array such as
&quot;celsius&quot;. An attribute has an associated
variable, a name, a data type, a length, and a value. In
contrast to variables that <br>
are intended for data, attributes are intended for metadata
(data about data). Unlike netCDF-3, attribute types can be
any user defined type as well as the usual built-in
types.</p>

<p style="margin-top: 1em">In CDL, an attribute is
designated by a a type, a variable, a &rsquo;:&rsquo;, and
then an attribute name. The type is optional and if missing,
it will be inferred from the values assigned <br>
to the attribute. It is possible to assign global attributes
not associated with any variable to the netCDF as a whole by
omitting the variable name in the attribute declara&acirc;
<br>
tion. Notice that there is a potential ambiguity in a
specification such as <br>
x : a = ... <br>
In this situation, x could be either a type for a global
attribute, or the variable name for an attribute. Since
there could both be a type named x and a variable named x,
there <br>
is an ambiguity. The rule is that in this situation, x will
be interpreted as a type if possible, and otherwise as a
variable.</p>

<p style="margin-top: 1em">If not specified, the data type
of an attribute in CDL is derived from the type of the
value(s) assigned to it. The length of an attribute is the
number of data values assigned <br>
to it, or the number of characters in the character string
assigned to it. Multiple values are assigned to
non-character attributes by separating the values with
commas. All <br>
values assigned to an attribute must be of the same
type.</p>

<p style="margin-top: 1em">The names for CDL dimensions,
variables, attributes, types, and groups may contain any
non-control utf-8 character except the forward slash
character (&lsquo;/&rsquo;). However, certain <br>
characters must escaped if they are used in a name, where
the escape character is the backward slash &lsquo;&acute;.
In particular, if the leading character off the name is a
digit (0-9), <br>
then it must be preceded by the escape character. In
addition, the characters &lsquo;
!&quot;#$%&amp;()*,:;&lt;=&gt;?[]^&lsquo;&Acirc;&acute;{}|~&acute;
must be escaped if they occur anywhere in a name. Note also
that at&acirc; <br>
tribute names that begin with an underscore
(&lsquo;_&rsquo;) are reserved for the use of Unidata and
should not be used in user defined attributes.</p>

<p style="margin-top: 1em">Note also that the words
&lsquo;variable&rsquo;, &lsquo;dimension&rsquo;,
&lsquo;data&rsquo;, &lsquo;group&rsquo;, and
&lsquo;types&rsquo; are legal CDL names, but be careful that
there is a space between them and any following colon <br>
character when used as a variable name. This is mostly an
issue with attribute declarations. For example, consider
this.</p>

<p style="margin-top: 1em">netcdf ... { <br>
... <br>
variables: <br>
int dimensions; <br>
dimensions: attribute=0 ; // this will cause an error <br>
dimensions : attribute=0 ; // this is ok. <br>
... <br>
}</p>

<p style="margin-top: 1em">The optional data: section of a
CDL specification is where netCDF variables may be
initialized. The syntax of an initialization is simple: a
variable name, an equals sign, and a <br>
comma-delimited list of constants (possibly separated by
spaces, tabs and newlines) terminated with a semicolon. For
multi-dimensional arrays, the last dimension varies fastest.
<br>
Thus row-order rather than column order is used for
matrices. If fewer values are supplied than are needed to
fill a variable, it is extended with a type-dependent
&lsquo;fill value&rsquo;, <br>
which can be overridden by supplying a value for a
distinguished variable attribute named
&lsquo;_FillValue&rsquo;. The types of constants need not
match the type declared for a variable; <br>
coercions are done to convert integers to floating point,
for example. The constant &lsquo;_&rsquo; can be used to
designate the fill value for a variable. If the type of the
variable is <br>
explicitly &lsquo;string&rsquo;, then the special constant
&lsquo;NIL&lsquo; can be used to represent a nil string,
which is not the same as a zero length string.</p>

<p style="margin-top: 1em">Primitive Data Types <br>
char characters <br>
byte 8-bit data <br>
short 16-bit signed integers <br>
int 32-bit signed integers <br>
long (synonymous with int) <br>
int64 64-bit signed integers <br>
float IEEE single precision floating point (32 bits) <br>
real (synonymous with float) <br>
double IEEE double precision floating point (64 bits) <br>
ubyte unsigned 8-bit data <br>
ushort 16-bit unsigned integers <br>
uint 32-bit unsigned integers <br>
uint64 64-bit unsigned integers <br>
string arbitrary length strings</p>

<p style="margin-top: 1em">CDL supports a superset of the
primitive data types of C. The names for the primitive data
types are reserved words in CDL, so the names of variables,
dimensions, and attributes <br>
must not be primitive type names. In declarations, type
names may be specified in either upper or lower case.</p>

<p style="margin-top: 1em">Bytes are intended to hold a
full eight bits of data, and the zero byte has no special
significance, as it mays for character data. ncgen converts
byte declarations to char dec&acirc; <br>
larations in the output C code and to the nonstandard BYTE
declaration in output Fortran code.</p>

<p style="margin-top: 1em">Shorts can hold values between
-32768 and 32767. ncgen converts short declarations to short
declarations in the output C code and to the nonstandard
INTEGER*2 declaration in <br>
output Fortran code.</p>

<p style="margin-top: 1em">Ints can hold values between
-2147483648 and 2147483647. ncgen converts int declarations
to int declarations in the output C code and to INTEGER
declarations in output Fortran <br>
code. long is accepted as a synonym for int in CDL
declarations, but is deprecated since there are now
platforms with 64-bit representations for C longs.</p>

<p style="margin-top: 1em">Int64 can hold values between
-9223372036854775808 and 9223372036854775807. ncgen converts
int64 declarations to longlong declarations in the output C
code.</p>

<p style="margin-top: 1em">Floats can hold values between
about -3.4+38 and 3.4+38. Their external representation is
as 32-bit IEEE normalized single-precision floating point
numbers. ncgen converts <br>
float declarations to float declarations in the output C
code and to REAL declarations in output Fortran code. real
is accepted as a synonym for float in CDL declarations.</p>

<p style="margin-top: 1em">Doubles can hold values between
about -1.7+308 and 1.7+308. Their external representation is
as 64-bit IEEE standard normalized double-precision floating
point numbers. ncgen <br>
converts double declarations to double declarations in the
output C code and to DOUBLE PRECISION declarations in output
Fortran code.</p>

<p style="margin-top: 1em">The unsigned counterparts of the
above integer types are mapped to the corresponding unsigned
C types. Their ranges are suitably modified to start at
zero.</p>

<p style="margin-top: 1em">The technical interpretation of
the char type is that it is an unsigned 8-bit value. The
encoding of the 256 possible values is unspecified by
default. A variable of char type <br>
may be marked with an &quot;_Encoding&quot; attribute to
indicate the character set to be used: US-ASCII, ISO-8859-1,
etc. Note that specifying the encoding of UTF-8 is
equivalent to <br>
specifying US-ASCII This is because multi-byte UTF-8
characters cannot be stored in an 8-bit character. The only
legal single byte UTF-8 values are by definition the 7-bit
US- <br>
ASCII encoding with the top bit set to zero.</p>

<p style="margin-top: 1em">Strings are assumed by default
to be encoded using UTF-8. Note that this means that
multi-byte UTF-8 encodings may be present in the string, so
it is possible that the number of <br>
distinct UTF-8 characters in a string is smaller than the
number of 8-bit bytes used to store the string.</p>

<p style="margin-top: 1em">CDL Constants <br>
Constants assigned to attributes or variables may be of any
of the basic netCDF types. The syntax for constants is
similar to C syntax, except that type suffixes must be
append&acirc; <br>
ed to shorts and floats to distinguish them from longs and
doubles.</p>

<p style="margin-top: 1em">A byte constant is represented
by an integer constant with a &lsquo;b&rsquo; (or
&lsquo;B&rsquo;) appended. In the old netCDF-2 API, byte
constants could also be represented using single characters
or <br>
standard C character escape sequences such as
&lsquo;a&rsquo; or &lsquo;0. This is still supported for
backward compatibility, but deprecated to make the
distinction clear between the numeric <br>
byte type and the textual char type. Example byte constants
include: <br>
0b // a zero byte <br>
-1b // -1 as an 8-bit byte <br>
255b // also -1 as a signed 8-bit byte</p>

<p style="margin-top: 1em">short integer constants are
intended for representing 16-bit signed quantities. The form
of a short constant is an integer constant with an
&lsquo;s&rsquo; or &lsquo;S&rsquo; appended. If a short
con&acirc; <br>
stant begins with &lsquo;0&rsquo;, it is interpreted as
octal, except that if it begins with &lsquo;0x&rsquo;, it is
interpreted as a hexadecimal constant. For example: <br>
-2s // a short -2 <br>
0123s // octal <br>
0x7ffs //hexadecimal</p>

<p style="margin-top: 1em">int integer constants are
intended for representing 32-bit signed quantities. The form
of an int constant is an ordinary integer constant, although
it is acceptable to optional&acirc; <br>
ly append a single &lsquo;l&rsquo; or &lsquo;L&rsquo;
(again, deprecated). Be careful, though, the L suffix is
interpreted as a 32 bit integer, and never as a 64 bit
integer. This can be confusing since <br>
the C long type can ambigously be either 32 bit or 64
bit.</p>

<p style="margin-top: 1em">If an int constant begins with
&lsquo;0&rsquo;, it is interpreted as octal, except that if
it begins with &lsquo;0x&rsquo;, it is interpreted as a
hexadecimal constant (but see opaque constants below). <br>
Examples of valid int constants include: <br>
-2 <br>
1234567890L <br>
0123 // octal <br>
0x7ff // hexadecimal</p>

<p style="margin-top: 1em">int64 integer constants are
intended for representing 64-bit signed quantities. The form
of an int64 constant is an integer constant with an
&lsquo;ll&rsquo; or &lsquo;LL&rsquo; appended. If an int64
<br>
constant begins with &lsquo;0&rsquo;, it is interpreted as
octal, except that if it begins with &lsquo;0x&rsquo;, it is
interpreted as a hexadecimal constant. For example: <br>
-2ll // an unsigned -2 <br>
0123LL // octal <br>
0x7ffLL //hexadecimal</p>

<p style="margin-top: 1em">Floating point constants of type
float are appropriate for representing floating point data
with about seven significant digits of precision. The form
of a float constant is the <br>
same as a C floating point constant with an &lsquo;f&rsquo;
or &lsquo;F&rsquo; appended. For example the following are
all acceptable float constants: <br>
-2.0f <br>
3.14159265358979f // will be truncated to less precision
<br>
1.f</p>

<p style="margin-top: 1em">Floating point constants of type
double are appropriate for representing floating point data
with about sixteen significant digits of precision. The form
of a double constant is <br>
the same as a C floating point constant. An optional
&lsquo;d&rsquo; or &lsquo;D&rsquo; may be appended. For
example the following are all acceptable double constants:
<br>
-2.0 <br>
3.141592653589793 <br>
1.0e-20 <br>
1.d</p>

<p style="margin-top: 1em">Unsigned integer constants can
be created by appending the character &rsquo;U&rsquo; or
&rsquo;u&rsquo; between the constant and any trailing size
specifier, or immediately at the end of the size
speci&acirc; <br>
fier. Thus one could say 10U, 100su, 100000ul, or
1000000llu, for example.</p>

<p style="margin-top: 1em">Single character constants may
be enclosed in single quotes. If a sequence of one or more
characters is enclosed in double quotes, then its
interpretation must be inferred from <br>
the context. If the dataset is created using the netCDF
classic model, then all such constants are interpreted as a
character array, so each character in the constant is
inter&acirc; <br>
preted as if it were a single character. If the dataset is
netCDF extended, then the constant may be interpreted as for
the classic model or as a true string (see below)
depend&acirc; <br>
ing on the type of the attribute or variable into which the
string is contained.</p>

<p style="margin-top: 1em">The interpretation of char
constants is that those that are in the printable ASCII
range (&rsquo; &rsquo;..&rsquo;~&rsquo;) are assumed to be
encoded as the 1-byte subset ofUTF-8, which is equivalent to
<br>
US-ASCII. In all cases, the usual C string escape
conventions are honored for values from 0 thru 127. Values
greater than 127 are allowed, but their encoding is
undefined. For <br>
netCDF extended, the use of the char type is deprecated in
favor of the string type.</p>

<p style="margin-top: 1em">Some character constant examples
are as follows. <br>
&rsquo;a&rsquo; // ASCII &lsquo;a&rsquo; <br>
&quot;a&quot; // equivalent to &rsquo;a&rsquo; <br>
&quot;Two0ines0 // a 10-character string with two embedded
newlines <br>
&quot;a bell: 07&quot; // a string containing an ASCII bell
<br>
Note that the netCDF character array &quot;a&quot; would fit
in a one-element variable, since no terminating NULL
character is assumed. However, a zero byte in a character
array is inter&acirc; <br>
preted as the end of the significant characters by the
ncdump program, following the C convention. Therefore, a
NULL byte should not be embedded in a character string
unless at <br>
the end: use the byte data type instead for byte arrays that
contain the zero byte.</p>

<p style="margin-top: 1em">String constants are, like
character constants, represented using double quotes. This
represents a potential ambiguity since a multi-character
string may also indicate a dimen&acirc; <br>
sioned character value. Disambiguation usually occurs by
context, but care should be taken to specify thestring type
to ensure the proper choice. String constants are assumed to
<br>
always be UTF-8 encoded. This specifically means that the
string constant may actually contain multi-byte UTF-8
characters. The special constant &lsquo;NIL&lsquo; can be
used to represent a <br>
nil string, which is not the same as a zero length
string.</p>

<p style="margin-top: 1em">Opaque constants are represented
as sequences of hexadecimal digits preceded by 0X or 0x:
0xaa34ffff, for example. These constants can still be used
as integer constants and <br>
will be either truncated or extended as necessary.</p>

<p style="margin-top: 1em">Compound Constant Expressions
<br>
In order to assign values to variables (or attributes) whose
type is user-defined type, the constant notation has been
extended to include sequences of constants enclosed in <br>
curly brackets (e.g. &quot;{&quot;...&quot;}&quot;). Such a
constant is called a compound constant, and compound
constants can be nested.</p>

<p style="margin-top: 1em">Given a type &quot;T(*)
vlen_t&quot;, where T is some other arbitrary base type,
constants for this should be specified as follows. <br>
vlen_t var[2] = {t11,t12,...t1N}, {t21,t22,...t2m}; <br>
The values tij, are assumed to be constants of type T.</p>

<p style="margin-top: 1em">Given a type &quot;compound
cmpd_t {T1 f1; T2 f2...Tn fn}&quot;, where the Ti are other
arbitrary base types, constants for this should be specified
as follows. <br>
cmpd_t var[2] = {t11,t12,...t1N}, {t21,t22,...t2n}; <br>
The values tij, are assumed to be constants of type Ti. If
the fields are missing, then they will be set using any
specified or default fill value for the field&rsquo;s base
type.</p>

<p style="margin-top: 1em">The general set of rules for
using braces are defined in the Specifying Datalists section
below.</p>

<p style="margin-top: 1em">Scoping Rules <br>
With the addition of groups, the name space for defined
objects is no longer flat. References (names) of any type,
dimension, or variable may be prefixed with the absolute
path <br>
specifying a specific declaration. Thus one might say <br>
variables: <br>
/g1/g2/t1 v1; <br>
The type being referenced (t1) is the one within group g2,
which in turn is nested in group g1. The similarity of this
notation to Unix file paths is deliberate, and one can <br>
consider groups as a form of directory structure.</p>

<p style="margin-top: 1em">When name is not prefixed, then
scope rules are applied to locate the specified declaration.
Currently, there are three rules: one for dimensions, one
for types and enumeration <br>
constants, and one for all others.</p>

<p style="margin-top: 1em">When an unprefixed name of a
dimension is used (as in a variable declaration), ncgen
first looks in the immediately enclosing group for the
dimension. If it is not found there, <br>
then it looks in the group enclosing this group. This
continues up the group hierarchy until the dimension is
found, or there are no more groups to search.</p>

<p style="margin-top: 1em">2. When an unprefixed name of a
type or an enumeration constant is used, ncgen searches the
group tree using a pre-order depth-first search. This
essentially means that it will <br>
find the matching declaration that precedes the reference
textually in the cdl file and that is &quot;highest&quot; in
the group hierarchy.</p>

<p style="margin-top: 1em">3. For all other names, only the
immediately enclosing group is searched.</p>

<p style="margin-top: 1em">One final note. Forward
references are not allowed. This means that specifying, for
example, /g1/g2/t1 will fail if this reference occurs before
g1 and/or g2 are defined.</p>

<p style="margin-top: 1em">Specifying Enumeration Constants
<br>
References to Enumeration constants (in data lists) can be
ambiguous since the same enumeration constant name can be
defined in more than one enumeration. If a cdl file
specified <br>
an ambiguous constant, then ncgen will signal an error. Such
constants can be disambiguated in two ways.</p>

<p style="margin-top: 1em">1. Prefix the enumeration
constant with the name of the enumeration separated by a
dot: enum.econst, for example.</p>

<p style="margin-top: 1em">2. If case one is not sufficient
to disambiguate the enumeration constant, then one must
specify the precise enumeration type using a group path:
/g1/g2/enum.econst, for ex&acirc; <br>
ample.</p>

<p style="margin-top: 1em">Special Attributes <br>
Special, virtual, attributes can be specified to provide
performance-related information about the file format and
about variable properties. The file must be a netCDF-4 file
<br>
for these to take effect.</p>

<p style="margin-top: 1em">These special virtual attributes
are not actually part of the file, they are merely a
convenient way to set miscellaneous properties of the data
in CDL</p>

<p style="margin-top: 1em">The special attributes currently
supported are as follows: &lsquo;_Format&rsquo;,
&lsquo;_Fletcher32, &lsquo;_ChunkSizes&rsquo;,
&lsquo;_Endianness&rsquo;, &lsquo;_DeflateLevel&rsquo;,
&lsquo;_Shuffle&rsquo;, and &lsquo;_Storage&rsquo;.</p>

<p style="margin-top: 1em">&lsquo;_Format&rsquo; is a
global attribute specifying the netCDF format variant. Its
value must be a single string matching one of
&lsquo;classic&rsquo;, &lsquo;64-bit offset&rsquo;,
&lsquo;64-bit data&rsquo;, &lsquo;netCDF-4&rsquo;, or <br>
&lsquo;netCDF-4 classic model&rsquo;.</p>

<p style="margin-top: 1em">The rest of the special
attributes are all variable attributes. Essentially all of
then map to some corresponding &lsquo;nc_def_var_XXX&rsquo;
function as defined in the netCDF-4 API. For <br>
the attributes that are essentially boolean (_Fletcher32,
_Shuffle, and _NOFILL), the value true can be specified by
using the strings &lsquo;true&rsquo; or &lsquo;1&rsquo;, or
by using the integer 1. <br>
The value false expects either &lsquo;false&rsquo;,
&lsquo;0&rsquo;, or the integer 0. The actions associated
with these attributes are as follows.</p>

<p style="margin-top: 1em">1. &lsquo;_Fletcher32 sets the
&lsquo;fletcher32&rsquo; property for a variable.</p>

<p style="margin-top: 1em">2. &lsquo;_Endianness&rsquo; is
either &lsquo;little&rsquo; or &lsquo;big&rsquo;, depending
on how the variable is stored when first written.</p>

<p style="margin-top: 1em">3. &lsquo;_DeflateLevel&rsquo;
is an integer between 0 and 9 inclusive if compression has
been specified for the variable.</p>

<p style="margin-top: 1em">4. &lsquo;_Shuffle&rsquo;
specifies if the the shuffle filter should be used.</p>

<p style="margin-top: 1em">5. &lsquo;_Storage&rsquo; is
&lsquo;contiguous&rsquo; or &lsquo;chunked&rsquo;.</p>

<p style="margin-top: 1em">6. &lsquo;_ChunkSizes&rsquo; is
a list of chunk sizes for each dimension of the variable</p>

<p style="margin-top: 1em">Note that attributes such as
&quot;add_offset&quot; or &quot;scale_factor&quot; have no
special meaning to ncgen. These attributes are currently
conventions, handled above the library layer by oth&acirc;
<br>
er utility packages, for example NCO.</p>

<p style="margin-top: 1em">Specifying Datalists <br>
Specifying datalists for variables in the
&lsquo;data:&lsquo; section can be somewhat complicated.
There are some rules that must be followed to ensure that
datalists are parsed correctly by <br>
ncgen.</p>

<p style="margin-top: 1em">First, the top level is
automatically assumed to be a list of items, so it should
not be inside {...}. That means that if the variable is a
scalar, there will be a single top- <br>
level element and if the variable is an array, there will be
N top-level elements. For each element of the top level
list, the following rules should be applied.</p>

<p style="margin-top: 1em">1. Instances of UNLIMITED
dimensions (other than the first dimension) must be
surrounded by {...} in order to specify the size.</p>

<p style="margin-top: 1em">2. Compound instances must be
embedded in {...}</p>

<p style="margin-top: 1em">3. Non-scalar fields of compound
instances must be embedded in {...}.</p>

<p style="margin-top: 1em">4. Instances of vlens must be
surrounded by {...} in order to specify the size.</p>

<p style="margin-top: 1em">Datalists associated with
attributes are implicitly a vector (i.e., a list) of values
of the type of the attribute and the above rules must apply
with that in mind.</p>

<p style="margin-top: 1em">7. No other use of braces is
allowed.</p>

<p style="margin-top: 1em">Note that one consequence of
these rules is that arrays of values cannot have subarrays
within braces. Consider, for example, int
var(d1)(d2)...(dn), where none of d2...dn are <br>
unlimited. A datalist for this variable must be a single
list of integers, where the number of integers is no more
than D=d1*d2*...dn values; note that the list can be less
than <br>
D, in which case fill values will be used to pad the
list.</p>

<p style="margin-top: 1em">Rule 6 about attribute datalist
has the following consequence. If the type of the attribute
is a compound (or vlen) type, and if the number of entries
in the list is one, then <br>
the compound instances must be enclosed in braces.</p>

<p style="margin-top: 1em">Specifying Character Datalists
<br>
Specifying datalists for variables of type char also has
some complications. consider, for example <br>
dimensions: u=UNLIMITED; d1=1; d2=2; d3=3; <br>
d4=4; d5=5; u2=UNLIMITED; <br>
variables: char var(d4,d5); <br>
datalist: var=&quot;1&quot;, &quot;two&quot;,
&quot;three&quot;;</p>

<p style="margin-top: 1em">We have twenty elements of var
to fill (d5 X d4) and we have three strings of length 1, 3,
5. How do we assign the characters in the strings to the
twenty elements?</p>

<p style="margin-top: 1em">This is challenging because it
is desirable to mimic the original ncgen (ncgen3). The core
algorithm is notionally as follows.</p>

<p style="margin-top: 1em">1. Assume we have a set of
dimensions D1..Dn, where D1 may optionally be an Unlimited
dimension. It is assumed that the sizes of the Di are all
known (including unlimited dimen&acirc; <br>
sions).</p>

<p style="margin-top: 1em">2. Given a sequence of string or
character constants C1..Cm, our goal is to construct a
single string whose length is the cross product of D1 thru
Dn. Note that for purposes of <br>
this algorithm, character constants are treated as strings
of size 1.</p>

<p style="margin-top: 1em">3. Construct Dx = cross product
of D1 thru D(n-1).</p>

<p style="margin-top: 1em">4. For each constant Ci, add
fill characters as needed so that its length is a multiple
of Dn.</p>

<p style="margin-top: 1em">5. Concatenate the modified
C1..Cm to produce string S.</p>

<p style="margin-top: 1em">6. Add fill characters to S to
make its length be a multiple of Dn.</p>

<p style="margin-top: 1em">8. If S is longer than the Dx *
Dn, then truncate and generate a warning.</p>

<p style="margin-top: 1em">There are three other cases of
note.</p>

<p style="margin-top: 1em">1. If there is only a single,
unlimited dimension, then all of the constants are
concatenated and fill characters are added to the end of the
resulting string to make its length <br>
be that of the unlimited dimension. If the length is larger
than the unlimited dimension, then it is truncated with a
warning.</p>

<p style="margin-top: 1em">2. For the case of character
typed vlen, &quot;char(*) vlen_t&quot; for example. we
simply concatenate all the constants with no filling at
all.</p>

<p style="margin-top: 1em">3. For the case of a character
typed attribute, we simply concatenate all the
constants.</p>

<p style="margin-top: 1em">In netcdf-4, dimensions other
than the first can be unlimited. Of course by the rules
above, the interior unlimited instances must be delimited by
{...}. For example. <br>
variables: char var(u,u2); <br>
datalist: var={&quot;1&quot;, &quot;two&quot;},
{&quot;three&quot;}; <br>
In this case u will have the effective length of two. Within
each instance of u2, the rules above will apply, leading to
this. <br>
datalist:
var={&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;},
{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;};
<br>
The effective size of u2 will be the max of the two instance
lengths (five in this case) and the shorter will be padded
to produce this. <br>
datalist:
var={&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;,&quot;
&quot;},
{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;};</p>

<p style="margin-top: 1em">Consider an even more
complicated case. <br>
variables: char var(u,u2,u3); <br>
datalist: var={{&quot;1&quot;, &quot;two&quot;}},
{{&quot;three&quot;},{&quot;four&quot;,&quot;xy&quot;}};
<br>
In this case u again will have the effective length of two.
The u2 dimensions will have a size = max(1,2) = 2; Within
each instance of u2, the rules above will apply, leading to
<br>
this. <br>
datalist:
var={{&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;}},
{{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;},{&quot;f&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;,&quot;x&quot;,&quot;y&quot;}};
<br>
The effective size of u3 will be the max of the two instance
lengths (six in this case) and the shorter ones will be
padded to produce this. <br>
datalist:
var={{&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;,&quot;
&quot;,&quot; &quot;}},
{{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;,&quot;
&quot;},{&quot;f&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;,&quot;x&quot;,&quot;y&quot;}};
<br>
Note however that the first instance of u2 is less than the
max length of u2, so we need to add a filler for another
instance of u2, producing this. <br>
datalist:
var={{&quot;1&quot;,&quot;t&quot;,&quot;w&quot;,&quot;o&quot;,&quot;
&quot;,&quot; &quot;},{&quot; &quot;,&quot; &quot;,&quot;
&quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;}},
{{&quot;t&quot;,&quot;h&quot;,&quot;r&quot;,&quot;e&quot;,&quot;e&quot;,&quot;
&quot;},{&quot;f&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;,&quot;x&quot;,&quot;y&quot;}};</p>

<p style="margin-top: 1em">BUGS <br>
The programs generated by ncgen when using the -c flag use
initialization statements to store data in variables, and
will fail to produce compilable programs if you try to use
<br>
them for large datasets, since the resulting statements may
exceed the line length or number of continuation statements
permitted by the compiler.</p>

<p style="margin-top: 1em">The CDL syntax makes it easy to
assign what looks like an array of variable-length strings
to a netCDF variable, but the strings may simply be
concatenated into a single array of <br>
characters. Specific use of the string type specifier may
solve the problem</p>

<p style="margin-top: 1em">CDL Grammar <br>
The file ncgen.y is the definitive grammar for CDL, but a
stripped down version is included here for completeness.
<br>
ncdesc: NETCDF <br>
datasetid <br>
rootgroup <br>
;</p>

<p style="margin-top: 1em">datasetid: DATASETID</p>

<p style="margin-top: 1em">rootgroup: &rsquo;{&rsquo; <br>
groupbody <br>
subgrouplist <br>
&rsquo;}&rsquo;;</p>

<p style="margin-top: 1em">groupbody: <br>
attrdecllist <br>
typesection <br>
dimsection <br>
vasection <br>
datasection <br>
;</p>

<p style="margin-top: 1em">subgrouplist: <br>
/*empty*/ <br>
| subgrouplist namedgroup <br>
;</p>

<p style="margin-top: 1em">namedgroup: GROUP ident
&rsquo;{&rsquo; <br>
groupbody <br>
subgrouplist <br>
&rsquo;}&rsquo; <br>
attrdecllist <br>
;</p>

<p style="margin-top: 1em">typesection: /* empty */ <br>
| TYPES <br>
| TYPES typedecls <br>
;</p>

<p style="margin-top: 1em">typedecls: <br>
type_or_attr_decl <br>
| typedecls type_or_attr_decl <br>
;</p>

<p style="margin-top: 1em">typename: ident ;</p>

<p style="margin-top: 1em">type_or_attr_decl: <br>
typedecl <br>
| attrdecl &rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">typedecl: <br>
enumdecl optsemicolon <br>
| compounddecl optsemicolon <br>
| vlendecl optsemicolon <br>
| opaquedecl optsemicolon <br>
;</p>

<p style="margin-top: 1em">optsemicolon: <br>
/*empty*/ <br>
| &rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">enumdecl: primtype ENUM typename
;</p>

<p style="margin-top: 1em">enumidlist: enumid <br>
| enumidlist &rsquo;,&rsquo; enumid <br>
;</p>

<p style="margin-top: 1em">enumid: ident &rsquo;=&rsquo;
constint ;</p>

<p style="margin-top: 1em">opaquedecl: OPAQUE
&rsquo;(&rsquo; INT_CONST &rsquo;)&rsquo; typename ;</p>

<p style="margin-top: 1em">vlendecl: typeref
&rsquo;(&rsquo; &rsquo;*&rsquo; &rsquo;)&rsquo; typename
;</p>

<p style="margin-top: 1em">compounddecl: COMPOUND typename
&rsquo;{&rsquo; fields &rsquo;}&rsquo; ;</p>

<p style="margin-top: 1em">fields: field &rsquo;;&rsquo;
<br>
| fields field &rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">field: typeref fieldlist ;</p>

<p style="margin-top: 1em">primtype: CHAR_K <br>
| BYTE_K <br>
| SHORT_K <br>
| INT_K <br>
| FLOAT_K <br>
| DOUBLE_K <br>
| UBYTE_K <br>
| USHORT_K <br>
| UINT_K <br>
| INT64_K <br>
| UINT64_K <br>
;</p>

<p style="margin-top: 1em">dimsection: /* empty */ <br>
| DIMENSIONS <br>
| DIMENSIONS dimdecls <br>
;</p>

<p style="margin-top: 1em">dimdecls: dim_or_attr_decl
&rsquo;;&rsquo; <br>
| dimdecls dim_or_attr_decl &rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">dim_or_attr_decl: dimdeclist |
attrdecl ;</p>

<p style="margin-top: 1em">dimdeclist: dimdecl <br>
| dimdeclist &rsquo;,&rsquo; dimdecl <br>
;</p>

<p style="margin-top: 1em">dimdecl: <br>
dimd &rsquo;=&rsquo; UINT_CONST <br>
| dimd &rsquo;=&rsquo; INT_CONST <br>
| dimd &rsquo;=&rsquo; DOUBLE_CONST <br>
| dimd &rsquo;=&rsquo; NC_UNLIMITED_K <br>
;</p>

<p style="margin-top: 1em">dimd: ident ;</p>

<p style="margin-top: 1em">vasection: /* empty */ <br>
| VARIABLES <br>
| VARIABLES vadecls <br>
;</p>

<p style="margin-top: 1em">vadecls: vadecl_or_attr
&rsquo;;&rsquo; <br>
| vadecls vadecl_or_attr &rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">vadecl_or_attr: vardecl |
attrdecl ;</p>

<p style="margin-top: 1em">vardecl: typeref varlist ;</p>

<p style="margin-top: 1em">varlist: varspec <br>
| varlist &rsquo;,&rsquo; varspec <br>
;</p>

<p style="margin-top: 1em">varspec: ident dimspec ;</p>

<p style="margin-top: 1em">dimspec: /* empty */ <br>
| &rsquo;(&rsquo; dimlist &rsquo;)&rsquo; <br>
;</p>

<p style="margin-top: 1em">dimlist: dimref <br>
| dimlist &rsquo;,&rsquo; dimref <br>
;</p>

<p style="margin-top: 1em">dimref: path ;</p>

<p style="margin-top: 1em">fieldlist: <br>
fieldspec <br>
| fieldlist &rsquo;,&rsquo; fieldspec <br>
;</p>

<p style="margin-top: 1em">fieldspec: ident fielddimspec
;</p>

<p style="margin-top: 1em">fielddimspec: /* empty */ <br>
| &rsquo;(&rsquo; fielddimlist &rsquo;)&rsquo; <br>
;</p>

<p style="margin-top: 1em">fielddimlist: <br>
fielddim <br>
| fielddimlist &rsquo;,&rsquo; fielddim <br>
;</p>

<p style="margin-top: 1em">fielddim: <br>
UINT_CONST <br>
| INT_CONST <br>
;</p>

<p style="margin-top: 1em">/* Use this when referencing
defined objects */ <br>
varref: type_var_ref ;</p>

<p style="margin-top: 1em">typeref: type_var_ref ;</p>

<p style="margin-top: 1em">type_var_ref: <br>
path <br>
| primtype <br>
;</p>

<p style="margin-top: 1em">/* Use this for all attribute
decls */ <br>
/* Watch out; this is left recursive */ <br>
attrdecllist: /*empty*/ | attrdecl &rsquo;;&rsquo;
attrdecllist ;</p>

<p style="margin-top: 1em">attrdecl: <br>
&rsquo;:&rsquo; ident &rsquo;=&rsquo; datalist <br>
| typeref type_var_ref &rsquo;:&rsquo; ident &rsquo;=&rsquo;
datalist <br>
| type_var_ref &rsquo;:&rsquo; ident &rsquo;=&rsquo;
datalist <br>
| type_var_ref &rsquo;:&rsquo; _FILLVALUE &rsquo;=&rsquo;
datalist <br>
| typeref type_var_ref &rsquo;:&rsquo; _FILLVALUE
&rsquo;=&rsquo; datalist <br>
| type_var_ref &rsquo;:&rsquo; _STORAGE &rsquo;=&rsquo;
conststring <br>
| type_var_ref &rsquo;:&rsquo; _CHUNKSIZES &rsquo;=&rsquo;
intlist <br>
| type_var_ref &rsquo;:&rsquo; _FLETCHER32 &rsquo;=&rsquo;
constbool <br>
| type_var_ref &rsquo;:&rsquo; _DEFLATELEVEL &rsquo;=&rsquo;
constint <br>
| type_var_ref &rsquo;:&rsquo; _SHUFFLE &rsquo;=&rsquo;
constbool <br>
| type_var_ref &rsquo;:&rsquo; _ENDIANNESS &rsquo;=&rsquo;
conststring <br>
| type_var_ref &rsquo;:&rsquo; _NOFILL &rsquo;=&rsquo;
constbool <br>
| &rsquo;:&rsquo; _FORMAT &rsquo;=&rsquo; conststring <br>
;</p>

<p style="margin-top: 1em">path: <br>
ident <br>
| PATH <br>
;</p>

<p style="margin-top: 1em">datasection: /* empty */ <br>
| DATA <br>
| DATA datadecls <br>
;</p>

<p style="margin-top: 1em">datadecls: <br>
datadecl &rsquo;;&rsquo; <br>
| datadecls datadecl &rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">datadecl: varref &rsquo;=&rsquo;
datalist ; <br>
datalist: <br>
datalist0 <br>
| datalist1 <br>
;</p>

<p style="margin-top: 1em">datalist0: <br>
/*empty*/ <br>
;</p>

<p style="margin-top: 1em">/* Must have at least 1 element
*/ <br>
datalist1: <br>
dataitem <br>
| datalist &rsquo;,&rsquo; dataitem <br>
;</p>

<p style="margin-top: 1em">dataitem: <br>
constdata <br>
| &rsquo;{&rsquo; datalist &rsquo;}&rsquo; <br>
;</p>

<p style="margin-top: 1em">constdata: <br>
simpleconstant <br>
| OPAQUESTRING <br>
| FILLMARKER <br>
| NIL <br>
| econstref <br>
| function <br>
;</p>

<p style="margin-top: 1em">econstref: path ;</p>

<p style="margin-top: 1em">function: ident &rsquo;(&rsquo;
arglist &rsquo;)&rsquo; ;</p>

<p style="margin-top: 1em">arglist: <br>
simpleconstant <br>
| arglist &rsquo;,&rsquo; simpleconstant <br>
;</p>

<p style="margin-top: 1em">simpleconstant: <br>
CHAR_CONST /* never used apparently*/ <br>
| BYTE_CONST <br>
| SHORT_CONST <br>
| INT_CONST <br>
| INT64_CONST <br>
| UBYTE_CONST <br>
| USHORT_CONST <br>
| UINT_CONST <br>
| UINT64_CONST <br>
| FLOAT_CONST <br>
| DOUBLE_CONST <br>
| TERMSTRING <br>
;</p>

<p style="margin-top: 1em">intlist: <br>
constint <br>
| intlist &rsquo;,&rsquo; constint <br>
;</p>

<p style="margin-top: 1em">constint: <br>
INT_CONST <br>
| UINT_CONST <br>
| INT64_CONST <br>
| UINT64_CONST <br>
;</p>

<p style="margin-top: 1em">conststring: TERMSTRING ;</p>

<p style="margin-top: 1em">constbool: <br>
conststring <br>
| constint <br>
;</p>

<p style="margin-top: 1em">/* Push all idents thru here for
tracking */ <br>
ident: IDENT ;</p>

<p style="margin-top: 1em">Printed: 117-8-27 $Date:
2010/04/29 16:38:55 $ NCGEN(1)</p>
<hr>
</body>
</html>
