<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:04 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLREBACKSLASH(1) Perl Programmers Reference Guide
PERLREBACKSLASH(1)</p>

<p style="margin-top: 1em">NAME <br>
perlrebackslash - Perl Regular Expression Backslash
Sequences and Escapes</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The top level documentation about Perl regular expressions
is found in perlre.</p>

<p style="margin-top: 1em">This document describes all
backslash and escape sequences. After explaining the role of
the backslash, it lists all the sequences that have a
special meaning in Perl regular <br>
expressions (in alphabetical order), then describes each of
them.</p>

<p style="margin-top: 1em">Most sequences are described in
detail in different documents; the primary purpose of this
document is to have a quick reference guide describing all
backslash and escape <br>
sequences.</p>

<p style="margin-top: 1em">The backslash <br>
In a regular expression, the backslash can perform one of
two tasks: it either takes away the special meaning of the
character following it (for instance, &quot;&quot; matches a
vertical <br>
bar, it&rsquo;s not an alternation), or it is the start of a
backslash or escape sequence.</p>

<p style="margin-top: 1em">The rules determining what it is
are quite simple: if the character following the backslash
is an ASCII punctuation (non-word) character (that is,
anything that is not a letter, <br>
digit, or underscore), then the backslash just takes away
any special meaning of the character following it.</p>

<p style="margin-top: 1em">If the character following the
backslash is an ASCII letter or an ASCII digit, then the
sequence may be special; if so, it&rsquo;s listed below. A
few letters have not been used yet, <br>
so escaping them with a backslash doesn&rsquo;t change them
to be special. A future version of Perl may assign a special
meaning to them, so if you have warnings turned on, Perl
<br>
issues a warning if you use such a sequence. [1].</p>

<p style="margin-top: 1em">It is however guaranteed that
backslash or escape sequences never have a punctuation
character following the backslash, not now, and not in a
future version of Perl 5. So it is <br>
safe to put a backslash in front of a non-word
character.</p>

<p style="margin-top: 1em">Note that the backslash itself
is special; if you want to match a backslash, you have to
escape the backslash with a backslash: &quot;/\/&quot;
matches a single backslash.</p>

<p style="margin-top: 1em">[1] There is one exception. If
you use an alphanumeric character as the delimiter of your
pattern (which you probably shouldn&rsquo;t do for
readability reasons), you have to escape <br>
the delimiter if you want to match it. Perl won&rsquo;t warn
then. See also &quot;Gory details of parsing quoted
constructs&quot; in perlop.</p>

<p style="margin-top: 1em">All the sequences and escapes
<br>
Those not usable within a bracketed character class (like
&quot;[a-z]&quot;) are marked as &quot;Not in [].&quot;</p>

<p style="margin-top: 1em">00 Octal escape sequence. See
also . <br>
1 Absolute backreference. Not in []. <br>
Alarm or bell. <br>
0 Beginning of string. Not in []. <br>
Word/non-word boundary. (Backspace in []). <br>
0 Not a word/non-word boundary. Not in []. <br>
Single octet, even under UTF-8. Not in []. <br>
Character class for digits. <br>
Character class for non-digits. <br>
\ Escape character. &nbsp; <br>
Turn off Q, and U processing. Not in []. <br>
Form feed. <br>
Foldcase till . Not in []. <br>
}, Named, absolute or relative backreference. Not in [] <br>
G Pos assertion. Not in []. <br>
Character class for horizontal whitespace. <br>
Character class for non horizontal whitespace. <br>
}, &gt;, &rsquo; Named backreference. Not in []. <br>
K Keep the stuff left of K. Not in []. <br>
Lowercase next character. Not in []. <br>
Lowercase till . Not in []. <br>
(Logical) newline character. <br>
Any character but newline. Experimental. Not in []. <br>
Named or numbered (Unicode) character or sequence. . <br>
{}, P Character with the given Unicode property. <br>
P{}, PP Character without the given Unicode property. <br>
Q Quote (disable) pattern metacharacters till . Not <br>
in []. <br>
Return character. <br>
Generic new line. Not in []. <br>
Character class for whitespace. <br>
Character class for non whitespace. <br>
Tab character. <br>
Titlecase next character. Not in []. <br>
U Uppercase till . Not in []. <br>
Character class for vertical whitespace. <br>
Character class for non vertical whitespace. <br>
0 Character class for word characters. <br>
W Character class for non-word characters. <br>
, 0 Hexadecimal escape sequence. <br>
Unicode &quot;extended grapheme cluster&quot;. Not in [].
<br>
End of string. Not in []. <br>
End of string. Not in [].</p>

<p style="margin-top: 1em">Character Escapes <br>
Fixed characters</p>

<p style="margin-top: 1em">A handful of characters have a
dedicated character escape. The following table shows them,
along with their ASCII code points (in decimal and hex),
their ASCII name, the control <br>
escape on ASCII platforms and a short description. (For
EBCDIC platforms, see &quot;OPERATOR DIFFERENCES&quot; in
perlebcdic.)</p>

<p style="margin-top: 1em">Seq. Code Point ASCII Cntrl
Description. <br>
Dec Hex <br>
7 07 BEL 8 08 BS \ 27 1B ESC 12 0C FF13 0D CR 10 0A LF 9 09
TAB i s t h e b a c k s p a c e c h a r a c t e r o ni ls ya
iw no sr id d/ en ao cn h- <br>
[1] &quot;aw ro ar cd tb eo ru cn ld aa sr sy .. O u t s i d
e a c h a r a c t e r c l a s s ,</p>

<p style="margin-top: 1em">[2] &quot;0 matches a logical
newline. Perl converts between &quot;0 and your OS&rsquo;s
native newline character when reading from or writing to
text files.</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">$str =~ //; # Matches if $str
contains a (horizontal) tab.</p>

<p style="margin-top: 1em">Control characters</p>

<p style="margin-top: 1em">&quot; is chr(2), etc. The gory
details are in &quot;Regexp Quote-Like Operators&quot; in
perlop. A complete list of what chr(1), etc. means for ASCII
and EBCDIC platforms is in &quot;OPERATOR <br>
DIFFERENCES&quot; in perlebcdic.</p>

<p style="margin-top: 1em">Note that &quot; &quot;chr(28) .
&rsquo;X&rsquo;&quot; for all characters X.</p>

<p style="margin-top: 1em">To write platform-independent
code, you must use &quot;AME}&quot; instead, like
&quot;SCAPE}&quot; or &quot;+001B}&quot;, see charnames.</p>

<p style="margin-top: 1em">Mnemonic: control character.</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">$str =~ / <br>
Named or numbered characters and character sequences</p>

<p style="margin-top: 1em">Unicode characters have a
Unicode name and numeric code point (ordinal) value. Use the
&quot;&quot; construct to specify a character by either of
these values. Certain sequences of <br>
characters also have names.</p>

<p style="margin-top: 1em">To specify by name, the name of
the character or character sequence goes between the curly
braces.</p>

<p style="margin-top: 1em">To specify a character by
Unicode code point, use the form &quot;+code point}&quot;,
where code point is a number in hexadecimal that gives the
code point that Unicode has assigned to <br>
the desired character. It is customary but not required to
use leading zeros to pad the number to 4 digits. Thus
&quot;+0041}&quot; means &quot;LATIN CAPITAL LETTER A&quot;,
and you will <br>
rarely see it written without the two leading zeros.
&quot;+0041}&quot; means &quot;A&quot; even on EBCDIC
machines (where the ordinal value of &quot;A&quot; is not
0x41).</p>

<p style="margin-top: 1em">It is even possible to give your
own names to characters and character sequences. For
details, see charnames.</p>

<p style="margin-top: 1em">(There is an expanded internal
form that you may see in debug output: &quot;+code
point.code point...}&quot;. The &quot;...&quot; means any
number of these code points separated by dots. This <br>
represents the sequence formed by the characters. This is an
internal form only, subject to change, and you should not
try to use it yourself.)</p>

<p style="margin-top: 1em">Mnemonic: Named character.</p>

<p style="margin-top: 1em">Note that a character or
character sequence expressed as a named or numbered
character is considered a character without special meaning
by the regex engine, and will match &quot;as <br>
is&quot;.</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">$str =~ /HAI CHARACTER SO SO}/;
# Matches the Thai SO SO character</p>

<p style="margin-top: 1em">use charnames
&rsquo;Cyrillic&rsquo;; # Loads Cyrillic names. <br>
$str =~ /HE}A}/; # Match &quot;ZHE&quot; followed by
&quot;KA&quot;.</p>

<p style="margin-top: 1em">Octal escapes</p>

<p style="margin-top: 1em">There are two forms of octal
escapes. Each is used to specify a character by its code
point specified in octal notation.</p>

<p style="margin-top: 1em">One form, available starting in
Perl 5.14 looks like &quot;.</p>

<p style="margin-top: 1em">It was introduced to avoid the
potential problems with the other form, available in all
Perls. That form consists of a backslash followed by three
octal digits. One problem <br>
with this form is that it can look exactly like an old-style
backreference (see &quot;Disambiguation rules between
old-style octal escapes and backreferences&quot; below.) You
can avoid <br>
this by making the first of the three digits always a zero,
but that makes 77 the largest code point specifiable.</p>

<p style="margin-top: 1em">In some contexts, a backslash
followed by two or even one octal digits may be interpreted
as an octal escape, sometimes with a warning, and because of
some bugs, sometimes with <br>
surprising results. Also, if you are creating a regex out of
smaller snippets concatenated together, and you use fewer
than three digits, the beginning of one snippet may be <br>
interpreted as adding digits to the ending of the snippet
before it. See &quot;Absolute referencing&quot; for more
discussion and examples of the snippet problem.</p>

<p style="margin-top: 1em">Note that a character expressed
as an octal escape is considered a character without special
meaning by the regex engine, and will match &quot;as
is&quot;.</p>

<p style="margin-top: 1em">To summarize, the &quot;.</p>

<p style="margin-top: 1em">Mnemonic: 0ctal or octal.</p>

<p style="margin-top: 1em">Examples (assuming an ASCII
platform)</p>

<p style="margin-top: 1em">$str = &quot;Perl&quot;; <br>
$str =~ /. <br>
$str =~ /120/; # Same. <br>
$str =~ /e <br>
$str =~ /120+/; # Same. <br>
$str =~ /P 53/; # No match, &quot; 53&quot; is &quot;+&quot;
and taken literally. <br>
/. <br>
/)</p>

<p style="margin-top: 1em">Disambiguation rules between
old-style octal escapes and backreferences</p>

<p style="margin-top: 1em">Octal escapes of the &quot;
00&quot; form outside of bracketed character classes
potentially clash with old-style backreferences. (see
&quot;Absolute referencing&quot; below). They both consist
<br>
of a backslash followed by numbers. So Perl has to use
heuristics to determine whether it is a backreference or an
octal escape. Perl uses the following rules to
disambiguate:</p>

<p style="margin-top: 1em">1. If the backslash is followed
by a single digit, it&rsquo;s a backreference.</p>

<p style="margin-top: 1em">2. If the first digit following
the backslash is a 0, it&rsquo;s an octal escape.</p>

<p style="margin-top: 1em">3. If the number following the
backslash is N (in decimal), and Perl already has seen N
capture groups, Perl considers this a backreference.
Otherwise, it considers it an octal <br>
escape. If N has more than three digits, Perl takes only the
first three for the octal escape; the rest are matched as
is.</p>

<p style="margin-top: 1em">my $pat = &quot;(&quot; x 999;
<br>
$pat .= &quot;a&quot;; <br>
$pat .= &quot;)&quot; x 999; <br>
/^($pat)1000$/; # Matches &rsquo;aa&rsquo;; there are 1000
capture groups. <br>
/^$pat1000$/; # Matches &rsquo;a@0&rsquo;; there are 999
capture groups <br>
# and 1000 is seen as 100 (a &rsquo;@&rsquo;) and a
&rsquo;0&rsquo;</p>

<p style="margin-top: 1em">You can force a backreference
interpretation always by using the &quot;0...}&quot; form.
You can the force an octal interpretation always by using
the &quot;p <br>
through 77 (= 63 decimal), by using three digits, beginning
with a &quot;0&quot;.</p>

<p style="margin-top: 1em">Hexadecimal escapes</p>

<p style="margin-top: 1em">Like octal escapes, there are
two forms of hexadecimal escapes, but both start with the
same thing, &quot; This is followed by either exactly two
hexadecimal digits forming a <br>
number, or a hexadecimal number of arbitrary length
surrounded by curly braces. The hexadecimal number is the
code point of the character you want to express.</p>

<p style="margin-top: 1em">Note that a character expressed
as one of these escapes is considered a character without
special meaning by the regex engine, and will match &quot;as
is&quot;.</p>

<p style="margin-top: 1em">Mnemonic: hexadecimal.</p>

<p style="margin-top: 1em">Examples (assuming an ASCII
platform)</p>

<p style="margin-top: 1em">$str = &quot;Perl&quot;; <br>
$str =~ /0/; # Match, &quot;0&quot; is &quot;P&quot;. <br>
$str =~ /0+/; # Match, &quot;0&quot; is &quot;P&quot;, it is
repeated at least once <br>
$str =~ /PB/; # No match, &quot;B&quot; is &quot;+&quot; and
taken literally.</p>

<p style="margin-top: 1em">// # Snowman with an umbrella.
<br>
# The Unicode character 2603 is a snowman, <br>
# the Unicode character 2602 is an umbrella. <br>
/}/ # Black smiling face. <br>
/}/ # Same, the hex digits A - F are case insensitive.</p>

<p style="margin-top: 1em">Modifiers <br>
A number of backslash sequences have to do with changing the
character, or characters following them. &quot;ill lowercase
the character following it, while &quot;&quot; will
uppercase <br>
(or, more accurately, titlecase) the character following it.
They provide functionality similar to the functions
&quot;lcfirst&quot; and &quot;ucfirst&quot;.</p>

<p style="margin-top: 1em">To uppercase or lowercase
several characters, one might want to use &quot;r
&quot;U&quot;, which will lowercase/uppercase all characters
following them, until either the end of the <br>
pattern or the next occurrence of &quot;</p>

<p style="margin-top: 1em">&quot;Q&quot; is used to quote
(disable) pattern metacharacters, up to the next &quot; <br>
Perl. In the ASCII range, it quotes every character that
isn&rsquo;t a letter, digit, or underscore. See
&quot;quotemeta&quot; in perlfunc for details on what gets
quoted for non-ASCII code <br>
points. Using this ensures that any character between
&quot;Q&quot; and &quot;</p>

<p style="margin-top: 1em">&quot; can be used to casefold
all characters following, up to the next &quot;</p>

<p style="margin-top: 1em">Mnemonic: Lowercase, Uppercase,
Fold-case, Quotemeta, End.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">$sid = &quot;sid&quot;; <br>
$greg = &quot;GrEg&quot;; <br>
$miranda = &quot;(Miranda)&quot;; <br>
$str =~ /$sid/; # Matches &rsquo;Sid&rsquo; <br>
$str =~ /reg/; # Matches &rsquo;greg&rsquo; <br>
$str =~ /Q$miranda; # Matches &rsquo;(Miranda)&rsquo;, as if
the pattern <br>
# had been written as /randa/</p>

<p style="margin-top: 1em">Character classes <br>
Perl regular expressions have a large range of character
classes. Some of the character classes are written as a
backslash sequence. We will briefly discuss those here; full
<br>
details of character classes can be found in
perlrecharclass.</p>

<p style="margin-top: 1em">&quot;3480&quot; is a character
class <br>
that matches any decimal digit, while the character class
&quot;atches any whitespace character. New in perl 5.10.0
are the classes &quot;nd &quot;hich match horizontal and
<br>
vertical whitespace characters.</p>

<p style="margin-top: 1em">The exact set of characters
matched by &quot;&quot;, &quot; and &quot;2736 <br>
ASCII range by using the &quot;/a&quot; regular expression
modifier. See perlrecharclass.</p>

<p style="margin-top: 1em">The uppercase variants
(&quot;W&quot;, &quot; &quot; and &quot;) are character
classes that match, respectively, any character that
isn&rsquo;t a word character, digit, whitespace, horizontal
<br>
whitespace, or vertical whitespace.</p>

<p style="margin-top: 1em">Mnemonics: word, digit, space,
horizontal, vertical.</p>

<p style="margin-top: 1em">Unicode classes</p>

<p style="margin-top: 1em">&quot;P&quot; (where
&quot;P&quot; is a single letter) and &quot;{Property}&quot;
are used to match a character that matches the given Unicode
property; properties include things like &quot;letter&quot;,
or &quot;thai <br>
character&quot;. Capitalizing the sequence to &quot;PP&quot;
and &quot;P{Property}&quot; make the sequence match a
character that doesn&rsquo;t match the given Unicode
property. For more details, see <br>
&quot;Backslash sequences&quot; in perlrecharclass and
&quot;Unicode Character Properties&quot; in perlunicode.</p>

<p style="margin-top: 1em">Mnemonic: property.</p>

<p style="margin-top: 1em">Referencing <br>
If capturing parenthesis are used in a regular expression,
we can refer to the part of the source string that was
matched, and match exactly the same thing. There are three
ways <br>
of referring to such backreference: absolutely, relatively,
and by name.</p>

<p style="margin-top: 1em">Absolute referencing</p>

<p style="margin-top: 1em">Either &quot;&quot; (starting in
Perl 5.10.0), or &quot;ld-style) where N is a positive
(unsigned) decimal number of any length is an absolute
reference to a capturing group.</p>

<p style="margin-top: 1em">N refers to the Nth set of
parentheses, so &quot;&quot; refers to whatever has been
matched by that set of parentheses. Thus &quot;&quot; refers
to the first capture group in the regex.</p>

<p style="margin-top: 1em">The &quot;&quot; form can be
equivalently written as &quot;0N}&quot; which avoids
ambiguity when building a regex by concatenating shorter
strings. Otherwise if you had a regex &quot;qr/$a$b/&quot;,
and <br>
$a contained &quot;&quot;, and $b contained &quot;37&quot;,
you would get &quot;/37/&quot; which is probably not what
you intended.</p>

<p style="margin-top: 1em">In the &quot;orm, N must not
begin with a &quot;0&quot;, and there must be at least N
capturing groups, or else N is considered an octal escape
(but something like &quot;18&quot; is the same as <br>
&quot; 018&quot;; that is, the octal escape &quot; 01&quot;
followed by a literal digit &quot;8&quot;).</p>

<p style="margin-top: 1em">Mnemonic: group.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">/(1248 <br>
/(984 <br>
/(.)(.)/; # Match a four letter palindrome (e.g.
&quot;ABBA&quot;).</p>

<p style="margin-top: 1em">Relative referencing</p>

<p style="margin-top: 1em">&quot;N&quot; (starting in Perl
5.10.0) is used for relative addressing. (It can be written
as &quot;0-N&quot;.) It refers to the Nth group before the
&quot;0-N}&quot;.</p>

<p style="margin-top: 1em">The big advantage of this form
is that it makes it much easier to write patterns with
references that can be interpolated in larger patterns, even
if the larger pattern also <br>
contains capture groups.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">/(A) # Group 1 <br>
( # Group 2 <br>
(B) # Group 3 <br>
0-1} # Refers to group 3 (B) <br>
0-3} # Refers to group 1 (A) <br>
) <br>
/x; # Matches &quot;ABBA&quot;.</p>

<p style="margin-top: 1em">my $qr = qr /(.)(.)0-2}0-1}/; #
Matches &rsquo;abab&rsquo;, &rsquo;cdcd&rsquo;, etc. <br>
/$qr$qr/ # Matches &rsquo;ababcdcd&rsquo;.</p>

<p style="margin-top: 1em">Named referencing</p>

<p style="margin-top: 1em">&quot;0name}&quot; (starting in
Perl 5.10.0) can be used to back refer to a named capture
group, dispensing completely with having to think about
capture buffer positions.</p>

<p style="margin-top: 1em">To be compatible with .Net
regular expressions, &quot;0name}&quot; may also be written
as &quot;name}&quot;, &quot;name&gt;&quot; or
&quot;name&rsquo;&quot;.</p>

<p style="margin-top: 1em">To prevent any ambiguity, name
must not start with a digit nor contain a hyphen.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">/(?&lt;word&gt;1224 <br>
/(?&lt;word&gt;384 <br>
/(?&lt;word&gt;384 <br>
/(?&lt;letter1&gt;.)(?&lt;letter2&gt;.)0letter2}0letter1}/
<br>
# Match a four letter palindrome (e.g. &quot;ABBA&quot;)</p>

<p style="margin-top: 1em">Assertions <br>
Assertions are conditions that have to be true; they
don&rsquo;t actually match parts of the substring. There are
six assertions that are written as backslash sequences.</p>

<p style="margin-top: 1em">0&quot;0/m&quot; modifier
isn&rsquo;t used, then &quot;/0^/&quot;. However, if the
&quot;/m&quot; modifier is used, then &quot;/^/&quot; <br>
matches internal newlines, but the meaning of
&quot;/0m&quot; modifier. &quot;0/m&quot; modifier is <br>
used. , &quot;&quot;and &quot; matchmodifierat
theisn&rsquo;tend ofused,the string.then
&quot;/&quot;Ifisth/m&quot; equivalentthat is,
ittomatches$/&quot;; at the end of the string, or one
before</p>

<p style="margin-top: 1em">the newline at the end of the
string. If the &quot;/m&quot; modifier is used, then
&quot;/$/&quot; matches at internal newlines, but the
meaning of &quot;/&quot; isn&rsquo;tmodifier.changed by the
m&quot; <br>
&quot; matchesmodifierat theis endused.of the string (or
just before a trailing newline) regardless whether
th/m&quot;</p>

<p style="margin-top: 1em">&quot;&quot;is just like &quot;,
except thatat theit doesend notof matchthe beforestring a
trailing newline&quot;matches only, regardless of the
modifiers used, and not just <br>
before a newline. It is how to anchor the match to the true
end of the string under all conditions.</p>

<p style="margin-top: 1em">G &quot;G&quot; is usually used
only in combination with the &quot;/g&quot; modifier. If the
&quot;/g&quot; modifier is used and the match is done in
scalar context, Perl remembers where in the source <br>
string the last match ended, and the next time, it will
start the match from where it ended the previous time.</p>

<p style="margin-top: 1em">&quot;G&quot; matches the point
where the previous match on that string ended, or the
beginning of that string if there was no previous match.</p>

<p style="margin-top: 1em">Mnemonic: Global.0 &quot; 0
0</p>

<p style="margin-top: 1em">word character before the
beginning and after the end w i l l m a t c h a t t h e b e
g i n n i n g ( o r e n d ) o f t h e s of the source
string; so &quot;o u r c e s t r i n g i f t h e s o u r c e
s t r i n g b e g i n s ( o r <br>
ends) with a word character. Otherwise, &quot;0h e</p>

<p style="margin-top: 1em">Do not use something like
&quot;a&quot;, there must be a d <br>
word character immediately previous. All boundary
determinations look for word characters alone, not for
non-words characters nor for string ends. It may help to
understand a n d &lt; 0 w o r k b y e q u a t <br>
how &lt;i n g t h e m a s f o l l o w s :</p>

<p style="margin-top: 1em">really means (?:(?&lt;=144 <br>
0 really means (?:(?&lt;=144</p>

<p style="margin-top: 1em">Mnemonic: boundary.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&quot;cat&quot; =~ /0h. <br>
&quot;cat&quot; =~ /cat; # Match. <br>
&quot;cat0 =~ /cat; # Match. <br>
&quot;cat0 =~ /cat; # No match. a</p>

<p style="margin-top: 1em">&quot;cat&quot; =~ /ta <br>
&quot;cats&quot; =~ /t a t 0 ; # <br>
&quot;cat&quot; =~ /Nh. o m a t a t 0 ; <br>
&quot;cats&quot; =~ /#h. M a t</p>

<p style="margin-top: 1em">while (&quot;cat dog&quot; =~
/(144 <br>
print $1; # Prints &rsquo;catdog&rsquo; <br>
} <br>
while (&quot;cat dog&quot; =~ /G(144 <br>
print $1; # Prints &rsquo;cat&rsquo; <br>
}</p>

<p style="margin-top: 1em">Misc <br>
Here we document the backslash sequences that don&rsquo;t
fall in one of the categories above. These are:</p>

<p style="margin-top: 1em">&quot;always matches a single
octet, even if the source string is encoded in UTF-8 format,
and the character to be matched is a multi-octet character.
&quot;was introduced in <br>
perl 5.6. This is very dangerous, because it violates the
logical character abstraction and can cause UTF-8 sequences
to become malformed.</p>

<p style="margin-top: 1em">Mnemonic: oCtet.</p>

<p style="margin-top: 1em">K This appeared in perl 5.10.0.
Anything matched left of &quot;K&quot; is not included in
$&amp;, and will not be replaced if the pattern is used in a
substitution. This lets you write <br>
&quot;s/PAT1 K PAT2/REPL/x&quot; instead of &quot;s/(PAT1)
PAT2/${1}REPL/x&quot; or &quot;s/(?&lt;=PAT1)
PAT2/REPL/x&quot;.</p>

<p style="margin-top: 1em">Mnemonic: Keep.</p>

<p style="margin-top: 1em">This is an experimental feature
new to perl 5.12.0. It matches any character that is not a
newline. It is a short-hand for writing &quot;[^0&quot;, and
is identical to the &quot;.&quot; <br>
metasymbol, except under the &quot;/s&quot; flag, which
changes the meaning of &quot;.&quot;, but not &quot; <br>
Note that &quot; can mean a named or numbered
character .</p>

<p style="margin-top: 1em">Mnemonic: Complement of 0</p>

<p style="margin-top: 1em">&quot; generic newline; that is,
anything considered a linebreak sequence by Unicode. This
includes all characters matched by &quot;rtical whitespace),
and the <br>
multi character sequence &quot;DA&quot; (carriage return
followed by a line feed, sometimes called the network
newline; it&rsquo;s the end of line sequence used in
Microsoft text files <br>
opened in binary mode). &quot;quivalent to
&quot;(?&gt;DA|&quot;. (The reason it doesn&rsquo;t
backtrack is that the sequence is considered inseparable.
That means that</p>

<p style="margin-top: 1em">&quot;DA&quot; =~ /^ No
match</p>

<p style="margin-top: 1em">fails, because the &quot;he
entire string, and won&rsquo;t backtrack to match just the
&quot;D&quot;.) Since &quot;atch a sequence of more than one
character, it cannot be <br>
put inside a bracketed character class; &quot;/[s an error;
use &quot;nstead. &quot;ntroduced in perl 5.10.0.</p>

<p style="margin-top: 1em">Note that this does not respect
any locale that might be in effect; it matches according to
the platform&rsquo;s native character set.</p>

<p style="margin-top: 1em">Mnemonic: none really.
&quot;icked because PCRE already uses &quot;nd more
importantly because Unicode recommends such a regular
expression metacharacter, and suggests <br>
&quot;ts notation.</p>

<p style="margin-top: 1em">This matches a Unicode extended
grapheme cluster.</p>

<p style="margin-top: 1em">&quot; <br>
an arrow. There is no such single character in Unicode, but
one can be composed by using a G followed by a Unicode
&quot;COMBINING UPWARDS ARROW BELOW&quot;, and would be
displayed by <br>
Unicode-aware software as if it were a single character.</p>

<p style="margin-top: 1em">Mnemonic: eXtended Unicode
character.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&quot;&quot; =~ /^ # Match as
chr (0x256) takes 2 octets in UTF-8.</p>

<p style="margin-top: 1em">$str =~ s/fooKbar/baz/g; #
Change any &rsquo;bar&rsquo; following a &rsquo;foo&rsquo;
to &rsquo;baz&rsquo; <br>
$str =~ s/(.)K//g; # Delete duplicated characters.</p>

<p style="margin-top: 1em">&quot;0 =~ /^ Match, is a
generic newline. is a generic newline. &quot; =~ /^ Match,
<br>
&quot; is a generic newline. 0 =~ /^ Match, <br>
&quot;</p>

<p style="margin-top: 1em">&quot;P&quot; =~ /^</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLREBACKSLASH(1)</p>
<hr>
</body>
</html>
