<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:15 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLVMS(1) Perl Programmers Reference Guide
PERLVMS(1)</p>

<p style="margin-top: 1em">NAME <br>
perlvms - VMS-specific documentation for Perl</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Gathered below are notes describing details of Perl
5&rsquo;s behavior on VMS. They are a supplement to the
regular Perl 5 documentation, so we have focussed on the
ways in which Perl <br>
5 functions differently under VMS than it does under Unix,
and on the interactions between Perl and the rest of the
operating system. We haven&rsquo;t tried to duplicate
complete <br>
descriptions of Perl features from the main Perl
documentation, which can be found in the [.pod] subdirectory
of the Perl distribution.</p>

<p style="margin-top: 1em">We hope these notes will save
you from confusion and lost sleep when writing Perl scripts
on VMS. If you find we&rsquo;ve missed something you think
should appear here, please don&rsquo;t <br>
hesitate to drop a line to vmsperl@perl.org.</p>

<p style="margin-top: 1em">Installation <br>
Directions for building and installing Perl 5 can be found
in the file README.vms in the main source directory of the
Perl distribution..</p>

<p style="margin-top: 1em">Organization of Perl Images <br>
Core Images <br>
During the installation process, three Perl images are
produced. Miniperl.Exe is an executable image which contains
all of the basic functionality of Perl, but cannot take <br>
advantage of Perl extensions. It is used to generate several
files needed to build the complete Perl and various
extensions. Once you&rsquo;ve finished installing Perl, you
can <br>
delete this image.</p>

<p style="margin-top: 1em">Most of the complete Perl
resides in the shareable image PerlShr.Exe, which provides a
core to which the Perl executable image and all Perl
extensions are linked. You should <br>
place this image in Sys$Share, or define the logical name
PerlShr to translate to the full file specification of this
image. It should be world readable. (Remember that if a <br>
user has execute only access to PerlShr, VMS will treat it
as if it were a privileged shareable image, and will
therefore require all downstream shareable images to be
INSTALLed, <br>
etc.)</p>

<p style="margin-top: 1em">Finally, Perl.Exe is an
executable image containing the main entry point for Perl,
as well as some initialization code. It should be placed in
a public directory, and made world <br>
executable. In order to run Perl with command line
arguments, you should define a foreign command to invoke
this image.</p>

<p style="margin-top: 1em">Perl Extensions <br>
Perl extensions are packages which provide both XS and Perl
code to add new functionality to perl. (XS is a
meta-language which simplifies writing C code which
interacts with <br>
Perl, see perlxs for more details.) The Perl code for an
extension is treated like any other library module -
it&rsquo;s made available in your script through the
appropriate &quot;use&quot; or <br>
&quot;require&quot; statement, and usually defines a Perl
package containing the extension.</p>

<p style="margin-top: 1em">The portion of the extension
provided by the XS code may be connected to the rest of Perl
in either of two ways. In the static configuration, the
object code for the extension <br>
is linked directly into PerlShr.Exe, and is initialized
whenever Perl is invoked. In the dynamic configuration, the
extension&rsquo;s machine code is placed into a separate
shareable <br>
image, which is mapped by Perl&rsquo;s DynaLoader when the
extension is &quot;use&quot;d or &quot;require&quot;d in
your script. This allows you to maintain the extension as a
separate entity, at the <br>
cost of keeping track of the additional shareable image.
Most extensions can be set up as either static or
dynamic.</p>

<p style="margin-top: 1em">The source code for an extension
usually resides in its own directory. At least three files
are generally provided: Extshortname.xs (where Extshortname
is the portion of the <br>
extension&rsquo;s name following the last &quot;::&quot;),
containing the XS code, Extshortname.pm, the Perl library
module for the extension, and Makefile.PL, a Perl script
which uses the <br>
&quot;MakeMaker&quot; library modules supplied with Perl to
generate a Descrip.MMS file for the extension.</p>

<p style="margin-top: 1em">Installing static extensions
<br>
Since static extensions are incorporated directly into
PerlShr.Exe, you&rsquo;ll have to rebuild Perl to
incorporate a new extension. You should edit the main
Descrip.MMS or Makefile <br>
you use to build Perl, adding the extension&rsquo;s name to
the &quot;ext&quot; macro, and the extension&rsquo;s object
file to the &quot;extobj&quot; macro. You&rsquo;ll also need
to build the extension&rsquo;s object <br>
file, either by adding dependencies to the main Descrip.MMS,
or using a separate Descrip.MMS for the extension. Then,
rebuild PerlShr.Exe to incorporate the new code.</p>

<p style="margin-top: 1em">Finally, you&rsquo;ll need to
copy the extension&rsquo;s Perl library module to the
[.Extname] subdirectory under one of the directories in
@INC, where Extname is the name of the extension, <br>
with all &quot;::&quot; replaced by &quot;.&quot; (e.g. the
library module for extension Foo::Bar would be copied to a
[.Foo.Bar] subdirectory).</p>

<p style="margin-top: 1em">Installing dynamic extensions
<br>
In general, the distributed kit for a Perl extension
includes a file named Makefile.PL, which is a Perl program
which is used to create a Descrip.MMS file which can be used
to <br>
build and install the files required by the extension. The
kit should be unpacked into a directory tree not under the
main Perl source directory, and the procedure for building
<br>
the extension is simply</p>

<p style="margin-top: 1em">$ perl Makefile.PL ! Create
Descrip.MMS <br>
$ mmk ! Build necessary files <br>
$ mmk test ! Run test code, if supplied <br>
$ mmk install ! Install into public Perl tree</p>

<p style="margin-top: 1em">N.B. The procedure by which
extensions are built and tested creates several levels (at
least 4) under the directory in which the extension&rsquo;s
source files live. For this reason <br>
if you are running a version of VMS prior to V7.1 you
shouldn&rsquo;t nest the source directory too deeply in your
directory structure lest you exceed RMS&rsquo; maximum of 8
levels of <br>
subdirectory in a filespec. (You can use rooted logical
names to get another 8 levels of nesting, if you can&rsquo;t
place the files near the top of the physical directory
structure.)</p>

<p style="margin-top: 1em">VMS support for this process in
the current release of Perl is sufficient to handle most
extensions. However, it does not yet recognize extra
libraries required to build <br>
shareable images which are part of an extension, so these
must be added to the linker options file for the extension
by hand. For instance, if the PGPLOT extension to Perl <br>
requires the PGPLOTSHR.EXE shareable image in order to
properly link the Perl extension, then the line
&quot;PGPLOTSHR/Share&quot; must be added to the linker
options file PGPLOT.Opt <br>
produced during the build process for the Perl
extension.</p>

<p style="margin-top: 1em">By default, the shareable image
for an extension is placed in the
[.lib.site_perl.autoArch.Extname] directory of the installed
Perl directory tree (where Arch is VMS_VAX or <br>
VMS_AXP, and Extname is the name of the extension, with each
&quot;::&quot; translated to &quot;.&quot;). (See the
MakeMaker documentation for more details on installation
options for extensions.) <br>
However, it can be manually placed in any of several
locations:</p>

<p style="margin-top: 1em">&Acirc;&middot; the
[.Lib.Auto.Arch$PVersExtname] subdirectory of one of the
directories in @INC (where PVers is the version of Perl
you&rsquo;re using, as supplied in $], with &rsquo;.&rsquo;
converted to <br>
&rsquo;_&rsquo;), or</p>

<p style="margin-top: 1em">&Acirc;&middot; one of the
directories in @INC, or</p>

<p style="margin-top: 1em">&Acirc;&middot; a directory
which the extensions Perl library module passes to the
DynaLoader when asking it to map the shareable image, or</p>

<p style="margin-top: 1em">&Acirc;&middot; Sys$Share or
Sys$Library.</p>

<p style="margin-top: 1em">If the shareable image
isn&rsquo;t in any of these places, you&rsquo;ll need to
define a logical name Extshortname, where Extshortname is
the portion of the extension&rsquo;s name after the last
<br>
&quot;::&quot;, which translates to the full file
specification of the shareable image.</p>

<p style="margin-top: 1em">File specifications <br>
Syntax <br>
We have tried to make Perl aware of both VMS-style and
Unix-style file specifications wherever possible. You may
use either style, or both, on the command line and in
scripts, <br>
but you may not combine the two styles within a single file
specification. VMS Perl interprets Unix pathnames in much
the same way as the CRTL (e.g. the first component of an
<br>
absolute path is read as the device name for the VMS file
specification). There are a set of functions provided in the
&quot;VMS::Filespec&quot; package for explicit
interconversion <br>
between VMS and Unix syntax; its documentation provides more
details.</p>

<p style="margin-top: 1em">We&rsquo;ve tried to minimize
the dependence of Perl library modules on Unix syntax, but
you may find that some of these, as well as some scripts
written for Unix systems, will require <br>
that you use Unix syntax, since they will assume that
&rsquo;/&rsquo; is the directory separator, etc. If you find
instances of this in the Perl distribution itself, please
let us know, so <br>
we can try to work around them.</p>

<p style="margin-top: 1em">Also when working on Perl
programs on VMS, if you need a syntax in a specific
operating system format, then you need either to check the
appropriate DECC$ feature logical, or <br>
call a conversion routine to force it to that format.</p>

<p style="margin-top: 1em">The feature logical name
DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior
in the conversion of file specifications from Unix to VMS
format in order to follow the <br>
extended character handling rules now expected by the CRTL.
Specifically, when this feature is in effect, the
&quot;./.../&quot; in a Unix path is now translated to
&quot;[.^.^.^.]&quot; instead of <br>
the traditional VMS &quot;[...]&quot;. To be compatible with
what MakeMaker expects, if a VMS path cannot be translated
to a Unix path, it is passed through unchanged, so <br>
&quot;unixify(&quot;[...]&quot;)&quot; will return
&quot;[...]&quot;.</p>

<p style="margin-top: 1em">The handling of extended
characters is largely complete in the VMS-specific C
infrastructure of Perl, but more work is still needed to
fully support extended syntax filenames in <br>
several core modules. In particular, at this writing
PathTools has only partial support for directories
containing some extended characters.</p>

<p style="margin-top: 1em">There are several ambiguous
cases where a conversion routine cannot determine whether an
input filename is in Unix format or in VMS format, since now
both VMS and Unix file <br>
specifications may have characters in them that could be
mistaken for syntax delimiters of the other type. So some
pathnames simply cannot be used in a mode that allows either
<br>
type of pathname to be present. Perl will tend to assume
that an ambiguous filename is in Unix format.</p>

<p style="margin-top: 1em">Allowing &quot;.&quot; as a
version delimiter is simply incompatible with determining
whether a pathname is in VMS format or in Unix format with
extended file syntax. There is no way to <br>
know whether &quot;perl-5.8.6&quot; is a Unix
&quot;perl-5.8.6&quot; or a VMS &quot;perl-5.8;6&quot; when
passing it to unixify() or vmsify().</p>

<p style="margin-top: 1em">The DECC$FILENAME_UNIX_REPORT
logical name controls how Perl interprets filenames to the
extent that Perl uses the CRTL internally for many purposes,
and attempts to follow CRTL <br>
conventions for reporting filenames. The
DECC$FILENAME_UNIX_ONLY feature differs in that it expects
all filenames passed to the C run-time to be already in Unix
format. This <br>
feature is not yet supported in Perl since Perl uses
traditional OpenVMS file specifications internally and in
the test harness, and it is not yet clear whether this mode
will be <br>
useful or useable. The feature logical name
DECC$POSIX_COMPLIANT_PATHNAMES is new with the RMS Symbolic
Link SDK and included with OpenVMS v8.3, but is not yet
supported in <br>
Perl.</p>

<p style="margin-top: 1em">Filename Case <br>
Perl follows VMS defaults and override settings in
preserving (or not preserving) filename case. Case is not
preserved on ODS-2 formatted volumes on any architecture. On
ODS-5 <br>
volumes, filenames may be case preserved depending on
process and feature settings. Perl now honors
DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE on those
systems where the <br>
CRTL supports these features. When these features are not
enabled or the CRTL does not support them, Perl follows the
traditional CRTL behavior of downcasing command-line <br>
arguments and returning file specifications in lower case
only.</p>

<p style="margin-top: 1em">N. B. It is very easy to get
tripped up using a mixture of other programs, external
utilities, and Perl scripts that are in varying states of
being able to handle case <br>
preservation. For example, a file created by an older
version of an archive utility or a build utility such as MMK
or MMS may generate a filename in all upper case even on an
<br>
ODS-5 volume. If this filename is later retrieved by a Perl
script or module in a case preserving environment, that
upper case name may not match the mixed-case or lower-case
<br>
exceptions of the Perl code. Your best bet is to follow an
all-or-nothing approach to case preservation: either
don&rsquo;t use it at all, or make sure your entire
toolchain and <br>
application environment support and use it.</p>

<p style="margin-top: 1em">OpenVMS Alpha v7.3-1 and later
and all version of OpenVMS I64 support case sensitivity as a
process setting (see &quot;SET PROCESS
/CASE_LOOKUP=SENSITIVE&quot;). Perl does not currently <br>
support case sensitivity on VMS, but it may in the future,
so Perl programs should use the
&quot;File::Spec-&gt;case_tolerant&quot; method to determine
the state, and not the $^O variable.</p>

<p style="margin-top: 1em">Symbolic Links <br>
When built on an ODS-5 volume with symbolic links enabled,
Perl by default supports symbolic links when the requisite
support is available in the filesystem and CRTL (generally
<br>
64-bit OpenVMS v8.3 and later). There are a number of
limitations and caveats to be aware of when working with
symbolic links on VMS. Most notably, the target of a valid
<br>
symbolic link must be expressed as a Unix-style path and it
must exist on a volume visible from your POSIX root (see the
&quot;SHOW ROOT&quot; command in DCL help). For further
details on <br>
symbolic link capabilities and requirements, see chapter 12
of the CRTL manual that ships with OpenVMS v8.3 or
later.</p>

<p style="margin-top: 1em">Wildcard expansion <br>
File specifications containing wildcards are allowed both on
the command line and within Perl globs (e.g.
&quot;&lt;*.c&gt;&quot;). If the wildcard filespec uses VMS
syntax, the resultant <br>
filespecs will follow VMS syntax; if a Unix-style filespec
is passed in, Unix-style filespecs will be returned. Similar
to the behavior of wildcard globbing for a Unix shell, <br>
one can escape command line wildcards with double quotation
marks &quot;&quot;&quot; around a perl program command line
argument. However, owing to the stripping of
&quot;&quot;&quot; characters carried out <br>
by the C handling of argv you will need to escape a
construct such as this one (in a directory containing the
files PERL.C, PERL.EXE, PERL.H, and PERL.OBJ):</p>

<p style="margin-top: 1em">$ perl -e &quot;print
join(&rsquo; &rsquo;,@ARGV)&quot; perl.* <br>
perl.c perl.exe perl.h perl.obj</p>

<p style="margin-top: 1em">in the following triple quoted
manner:</p>

<p style="margin-top: 1em">$ perl -e &quot;print
join(&rsquo; &rsquo;,@ARGV)&quot;
&quot;&quot;&quot;perl.*&quot;&quot;&quot; <br>
perl.*</p>

<p style="margin-top: 1em">In both the case of unquoted
command line arguments or in calls to &quot;glob()&quot; VMS
wildcard expansion is performed. (csh-style wildcard
expansion is available if you use <br>
&quot;File::Glob::glob&quot;.) If the wildcard filespec
contains a device or directory specification, then the
resultant filespecs will also contain a device and
directory; otherwise, <br>
device and directory information are removed. VMS-style
resultant filespecs will contain a full device and
directory, while Unix-style resultant filespecs will contain
only as <br>
much of a directory path as was present in the input
filespec. For example, if your default directory is
Perl_Root:[000000], the expansion of &quot;[.t]*.*&quot;
will yield filespecs <br>
like &quot;perl_root:[t]base.dir&quot;, while the expansion
of &quot;t/*/*&quot; will yield filespecs like
&quot;t/base.dir&quot;. (This is done to match the behavior
of glob expansion performed by Unix <br>
shells.)</p>

<p style="margin-top: 1em">Similarly, the resultant
filespec will contain the file version only if one was
present in the input filespec.</p>

<p style="margin-top: 1em">Pipes <br>
Input and output pipes to Perl filehandles are supported;
the &quot;file name&quot; is passed to lib$spawn() for
asynchronous execution. You should be careful to close any
pipes you have <br>
opened in a Perl script, lest you leave any
&quot;orphaned&quot; subprocesses around when Perl
exits.</p>

<p style="margin-top: 1em">You may also use backticks to
invoke a DCL subprocess, whose output is used as the return
value of the expression. The string between the backticks is
handled as if it were the <br>
argument to the &quot;system&quot; operator (see below). In
this case, Perl will wait for the subprocess to complete
before continuing.</p>

<p style="margin-top: 1em">The mailbox (MBX) that perl can
create to communicate with a pipe defaults to a buffer size
of 8192 on 64-bit systems, 512 on VAX. The default buffer
size is adjustable via the <br>
logical name PERL_MBX_SIZE provided that the value falls
between 128 and the SYSGEN parameter MAXBUF inclusive. For
example, to set the mailbox size to 32767 use <br>
&quot;$ENV{&rsquo;PERL_MBX_SIZE&rsquo;} = 32767;&quot; and
then open and use pipe constructs. An alternative would be
to issue the command:</p>

<p style="margin-top: 1em">$ Define PERL_MBX_SIZE 32767</p>

<p style="margin-top: 1em">before running your wide record
pipe program. A larger value may improve performance at the
expense of the BYTLM UAF quota.</p>

<p style="margin-top: 1em">PERL5LIB and PERLLIB <br>
The PERL5LIB and PERLLIB logical names work as documented in
perl, except that the element separator is &rsquo;|&rsquo;
instead of &rsquo;:&rsquo;. The directory specifications may
use either VMS or <br>
Unix syntax.</p>

<p style="margin-top: 1em">The Perl Forked Debugger <br>
The Perl forked debugger places the debugger commands and
output in a separate X-11 terminal window so that commands
and output from multiple processes are not mixed
together.</p>

<p style="margin-top: 1em">Perl on VMS supports an
emulation of the forked debugger when Perl is run on a VMS
system that has X11 support installed.</p>

<p style="margin-top: 1em">To use the forked debugger, you
need to have the default display set to an X-11 Server and
some environment variables set that Unix expects.</p>

<p style="margin-top: 1em">The forked debugger requires the
environment variable &quot;TERM&quot; to be
&quot;xterm&quot;, and the environment variable
&quot;DISPLAY&quot; to exist. &quot;xterm&quot; must be in
lower case.</p>

<p style="margin-top: 1em">$define TERM
&quot;xterm&quot;</p>

<p style="margin-top: 1em">$define DISPLAY
&quot;hostname:0.0&quot;</p>

<p style="margin-top: 1em">Currently the value of
&quot;DISPLAY&quot; is ignored. It is recommended that it be
set to be the hostname of the display, the server and screen
in Unix notation. In the future the value <br>
of DISPLAY may be honored by Perl instead of using the
default display.</p>

<p style="margin-top: 1em">It may be helpful to always use
the forked debugger so that script I/O is separated from
debugger I/O. You can force the debugger to be forked by
assigning a value to the <br>
logical name &lt;PERLDB_PIDS&gt; that is not a process
identification number.</p>

<p style="margin-top: 1em">$define PERLDB_PIDS XXXX</p>

<p style="margin-top: 1em">PERL_VMS_EXCEPTION_DEBUG <br>
The PERL_VMS_EXCEPTION_DEBUG being defined as
&quot;ENABLE&quot; will cause the VMS debugger to be invoked
if a fatal exception that is not otherwise handled is
raised. The purpose of <br>
this is to allow debugging of internal Perl problems that
would cause such a condition.</p>

<p style="margin-top: 1em">This allows the programmer to
look at the execution stack and variables to find out the
cause of the exception. As the debugger is being invoked as
the Perl interpreter is about <br>
to do a fatal exit, continuing the execution in debug mode
is usually not practical.</p>

<p style="margin-top: 1em">Starting Perl in the VMS
debugger may change the program execution profile in a way
that such problems are not reproduced.</p>

<p style="margin-top: 1em">The &quot;kill&quot; function
can be used to test this functionality from within a
program.</p>

<p style="margin-top: 1em">In typical VMS style, only the
first letter of the value of this logical name is actually
checked in a case insensitive mode, and it is considered
enabled if it is the value <br>
&quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</p>

<p style="margin-top: 1em">This logical name must be
defined before Perl is started.</p>

<p style="margin-top: 1em">Command line <br>
I/O redirection and backgrounding <br>
Perl for VMS supports redirection of input and output on the
command line, using a subset of Bourne shell syntax:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;&lt;file&quot; reads stdin from &quot;file&quot;,</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;&gt;file&quot; writes stdout to &quot;file&quot;,</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;&gt;&gt;file&quot; appends stdout to
&quot;file&quot;,</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;2&gt;file&quot; writes stderr to &quot;file&quot;,</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;2&gt;&gt;file&quot; appends stderr to
&quot;file&quot;, and</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;2&gt;&amp;1&quot; redirects stderr to stdout.</p>

<p style="margin-top: 1em">In addition, output may be piped
to a subprocess, using the character &rsquo;|&rsquo;.
Anything after this character on the command line is passed
to a subprocess for execution; the <br>
subprocess takes the output of Perl as its input.</p>

<p style="margin-top: 1em">Finally, if the command line
ends with &rsquo;&amp;&rsquo;, the entire command is run in
the background as an asynchronous subprocess.</p>

<p style="margin-top: 1em">Command line switches <br>
The following command line switches behave differently under
VMS than described in perlrun. Note also that in order to
pass uppercase switches to Perl, you need to enclose them
<br>
in double-quotes on the command line, since the CRTL
downcases all unquoted strings.</p>

<p style="margin-top: 1em">On newer 64 bit versions of
OpenVMS, a process setting now controls if the quoting is
needed to preserve the case of command line arguments.</p>

<p style="margin-top: 1em">-i If the &quot;-i&quot; switch
is present but no extension for a backup copy is given, then
inplace editing creates a new version of a file; the
existing copy is not deleted. (Note that <br>
if an extension is given, an existing file is renamed to the
backup file, as is the case under other operating systems,
so it does not remain as a previous version under the <br>
original filename.)</p>

<p style="margin-top: 1em">-S If the &quot;-S&quot; or
&quot;-&quot;S&quot;&quot; switch is present and the script
name does not contain a directory, then Perl translates the
logical name DCL$PATH as a searchlist, using each <br>
translation as a directory in which to look for the script.
In addition, if no file type is specified, Perl looks in
each directory for a file matching the name specified, <br>
with a blank type, a type of .pl, and a type of .com, in
that order.</p>

<p style="margin-top: 1em">-u The &quot;-u&quot; switch
causes the VMS debugger to be invoked after the Perl program
is compiled, but before it has run. It does not create a
core dump file.</p>

<p style="margin-top: 1em">Perl functions <br>
As of the time this document was last revised, the following
Perl functions were implemented in the VMS port of Perl
(functions marked with * are discussed in more detail
below):</p>

<p style="margin-top: 1em">file tests*, abs, alarm, atan,
backticks*, binmode*, bless, <br>
caller, chdir, chmod, chown, chomp, chop, chr, <br>
close, closedir, cos, crypt*, defined, delete, die, do,
dump*, <br>
each, endgrent, endpwent, eof, eval, exec*, exists, exit,
exp, <br>
fileno, flock getc, getgrent*, getgrgid*, getgrnam,
getlogin, getppid, <br>
getpwent*, getpwnam*, getpwuid*, glob, gmtime*, goto, <br>
grep, hex, ioctl, import, index, int, join, keys, kill*,
<br>
last, lc, lcfirst, lchown*, length, link*, local, localtime,
log, lstat, m//, <br>
map, mkdir, my, next, no, oct, open, opendir, ord, pack,
<br>
pipe, pop, pos, print, printf, push, q//, qq//, qw//, <br>
qx//*, quotemeta, rand, read, readdir, readlink*, redo, ref,
rename, <br>
require, reset, return, reverse, rewinddir, rindex, <br>
rmdir, s///, scalar, seek, seekdir, select(internal), <br>
select (system call)*, setgrent, setpwent, shift, sin,
sleep, <br>
socketpair, sort, splice, split, sprintf, sqrt, srand, stat,
<br>
study, substr, symlink*, sysread, system*, syswrite, tell,
<br>
telldir, tie, time, times*, tr///, uc, ucfirst, umask, <br>
undef, unlink*, unpack, untie, unshift, use, utime*, <br>
values, vec, wait, waitpid*, wantarray, warn, write,
y///</p>

<p style="margin-top: 1em">The following functions were not
implemented in the VMS port, and calling them produces a
fatal error (usually) or undefined behavior (rarely, we
hope):</p>

<p style="margin-top: 1em">chroot, dbmclose, dbmopen,
fork*, getpgrp, getpriority, <br>
msgctl, msgget, msgsend, msgrcv, semctl, <br>
semget, semop, setpgrp, setpriority, shmctl, shmget, <br>
shmread, shmwrite, syscall</p>

<p style="margin-top: 1em">The following functions are
available on Perls compiled with Dec C 5.2 or greater and
running VMS 7.0 or greater:</p>

<p style="margin-top: 1em">truncate</p>

<p style="margin-top: 1em">The following functions are
available on Perls built on VMS 7.2 or greater:</p>

<p style="margin-top: 1em">fcntl (without locking)</p>

<p style="margin-top: 1em">The following functions may or
may not be implemented, depending on what type of socket
support you&rsquo;ve built into your copy of Perl:</p>

<p style="margin-top: 1em">accept, bind, connect,
getpeername, <br>
gethostbyname, getnetbyname, getprotobyname, <br>
getservbyname, gethostbyaddr, getnetbyaddr, <br>
getprotobynumber, getservbyport, gethostent, <br>
getnetent, getprotoent, getservent, sethostent, <br>
setnetent, setprotoent, setservent, endhostent, <br>
endnetent, endprotoent, endservent, getsockname, <br>
getsockopt, listen, recv, select(system call)*, <br>
send, setsockopt, shutdown, socket</p>

<p style="margin-top: 1em">The following function is
available on Perls built on 64 bit OpenVMS v8.2 with hard
links enabled on an ODS-5 formatted build disk. CRTL support
is in principle available as of <br>
OpenVMS v7.3-1, and better configuration support could
detect this.</p>

<p style="margin-top: 1em">link</p>

<p style="margin-top: 1em">The following functions are
available on Perls built on 64 bit OpenVMS v8.2 and later.
CRTL support is in principle available as of OpenVMS v7.3-2,
and better configuration <br>
support could detect this.</p>

<p style="margin-top: 1em">getgrgid, getgrnam, getpwnam,
getpwuid, <br>
setgrent, ttyname</p>

<p style="margin-top: 1em">The following functions are
available on Perls built on 64 bit OpenVMS v8.2 and
later.</p>

<p style="margin-top: 1em">statvfs, socketpair</p>

<p style="margin-top: 1em">File tests <br>
The tests &quot;-b&quot;, &quot;-B&quot;, &quot;-c&quot;,
&quot;-C&quot;, &quot;-d&quot;, &quot;-e&quot;,
&quot;-f&quot;, &quot;-o&quot;, &quot;-M&quot;,
&quot;-s&quot;, &quot;-S&quot;, &quot;-t&quot;,
&quot;-T&quot;, and &quot;-z&quot; work as advertised. The
return values for &quot;-r&quot;, &quot;-w&quot;, and
&quot;-x&quot; tell you <br>
whether you can actually access the file; this may not
reflect the UIC-based file protections. Since real and
effective UIC don&rsquo;t differ under VMS, &quot;-O&quot;,
&quot;-R&quot;, &quot;-W&quot;, and <br>
&quot;-X&quot; are equivalent to &quot;-o&quot;,
&quot;-r&quot;, &quot;-w&quot;, and &quot;-x&quot;.
Similarly, several other tests, including &quot;-A&quot;,
&quot;-g&quot;, &quot;-k&quot;, &quot;-l&quot;,
&quot;-p&quot;, and &quot;-u&quot;, aren&rsquo;t
particularly meaningful under <br>
VMS, and the values returned by these tests reflect whatever
your CRTL &quot;stat()&quot; routine does to the equivalent
bits in the st_mode field. Finally, &quot;-d&quot; returns
true if <br>
passed a device specification without an explicit directory
(e.g. &quot;DUA1:&quot;), as well as if passed a
directory.</p>

<p style="margin-top: 1em">There are DECC feature logical
names AND ODS-5 volume attributes that also control what
values are returned for the date fields.</p>

<p style="margin-top: 1em">Note: Some sites have reported
problems when using the file-access tests (&quot;-r&quot;,
&quot;-w&quot;, and &quot;-x&quot;) on files accessed via
DEC&rsquo;s DFS. Specifically, since DFS does not currently
<br>
provide access to the extended file header of files on
remote volumes, attempts to examine the ACL fail, and the
file tests will return false, with $! indicating that the
<br>
file does not exist. You can use &quot;stat&quot; on these
files, since that checks UIC-based protection only, and then
manually check the appropriate bits, as defined by your C
<br>
compiler&rsquo;s stat.h, in the mode value it returns, if
you need an approximation of the file&rsquo;s
protections.</p>

<p style="margin-top: 1em">backticks <br>
Backticks create a subprocess, and pass the enclosed string
to it for execution as a DCL command. Since the subprocess
is created directly via &quot;lib$spawn()&quot;, any valid
DCL <br>
command string may be specified.</p>

<p style="margin-top: 1em">binmode FILEHANDLE <br>
The &quot;binmode&quot; operator will attempt to insure that
no translation of carriage control occurs on input from or
output to this filehandle. Since this involves reopening the
<br>
file and then restoring its file position indicator, if this
function returns FALSE, the underlying filehandle may no
longer point to an open file, or may point to a <br>
different position in the file than before
&quot;binmode&quot; was called.</p>

<p style="margin-top: 1em">Note that &quot;binmode&quot; is
generally not necessary when using normal filehandles; it is
provided so that you can control I/O to existing
record-structured files when necessary. <br>
You can also use the &quot;vmsfopen&quot; function in the
VMS::Stdio extension to gain finer control of I/O to files
and devices with different record structures.</p>

<p style="margin-top: 1em">crypt PLAINTEXT, USER <br>
The &quot;crypt&quot; operator uses the
&quot;sys$hash_password&quot; system service to generate the
hashed representation of PLAINTEXT. If USER is a valid
username, the algorithm and salt <br>
values are taken from that user&rsquo;s UAF record. If it is
not, then the preferred algorithm and a salt of 0 are used.
The quadword encrypted value is returned as an <br>
8-character string.</p>

<p style="margin-top: 1em">The value returned by
&quot;crypt&quot; may be compared against the encrypted
password from the UAF returned by the &quot;getpw*&quot;
functions, in order to authenticate users. If you&rsquo;re
going <br>
to do this, remember that the encrypted password in the UAF
was generated using uppercase username and password strings;
you&rsquo;ll have to upcase the arguments to
&quot;crypt&quot; to <br>
insure that you&rsquo;ll get the proper value:</p>

<p style="margin-top: 1em">sub validate_passwd { <br>
my($user,$passwd) = @_; <br>
my($pwdhash); <br>
if ( !($pwdhash = (getpwnam($user))[1]) || <br>
$pwdhash ne crypt(&quot;U$passwd&quot;,&quot;U$name&quot;) )
{ <br>
intruder_alert($name); <br>
} <br>
return 1; <br>
}</p>

<p style="margin-top: 1em">die &quot;die&quot; will force
the native VMS exit status to be an SS$_ABORT code if
neither of the $! or $? status values are ones that would
cause the native status to be interpreted as <br>
being what VMS classifies as SEVERE_ERROR severity for DCL
error handling.</p>

<p style="margin-top: 1em">When
&quot;PERL_VMS_POSIX_EXIT&quot; is active (see
&quot;$?&quot; below), the native VMS exit status value will
have either one of the $! or $? or $^E or the Unix value 255
encoded into it in a <br>
way that the effective original value can be decoded by
other programs written in C, including Perl and the GNV
package. As per the normal non-VMS behavior of
&quot;die&quot; if <br>
either $! or $? are non-zero, one of those values will be
encoded into a native VMS status value. If both of the Unix
status values are 0, and the $^E value is set one of <br>
ERROR or SEVERE_ERROR severity, then the $^E value will be
used as the exit code as is. If none of the above apply, the
Unix value of 255 will be encoded into a native VMS <br>
exit status value.</p>

<p style="margin-top: 1em">Please note a significant
difference in the behavior of &quot;die&quot; in the
&quot;PERL_VMS_POSIX_EXIT&quot; mode is that it does not
force a VMS SEVERE_ERROR status on exit. The Unix exit <br>
values of 2 through 255 will be encoded in VMS status values
with severity levels of SUCCESS. The Unix exit value of 1
will be encoded in a VMS status value with a severity <br>
level of ERROR. This is to be compatible with how the VMS C
library encodes these values.</p>

<p style="margin-top: 1em">The minimum severity level set
by &quot;die&quot; in &quot;PERL_VMS_POSIX_EXIT&quot; mode
may be changed to be ERROR or higher in the future depending
on the results of testing and further <br>
review.</p>

<p style="margin-top: 1em">See &quot;$?&quot; for a
description of the encoding of the Unix value to produce a
native VMS status containing it.</p>

<p style="margin-top: 1em">dump <br>
Rather than causing Perl to abort and dump core, the
&quot;dump&quot; operator invokes the VMS debugger. If you
continue to execute the Perl program under the debugger,
control will <br>
be transferred to the label specified as the argument to
&quot;dump&quot;, or, if no label was specified, back to the
beginning of the program. All other state of the program
(e.g. <br>
values of variables, open file handles) are not affected by
calling &quot;dump&quot;.</p>

<p style="margin-top: 1em">exec LIST <br>
A call to &quot;exec&quot; will cause Perl to exit, and to
invoke the command given as an argument to &quot;exec&quot;
via &quot;lib$do_command&quot;. If the argument begins with
&rsquo;@&rsquo; or &rsquo;$&rsquo; (other than <br>
as part of a filespec), then it is executed as a DCL
command. Otherwise, the first token on the command line is
treated as the filespec of an image to run, and an attempt
is <br>
made to invoke it (using .Exe and the process defaults to
expand the filespec) and pass the rest of
&quot;exec&quot;&rsquo;s argument to it as parameters. If
the token has no file type, and <br>
matches a file with null type, then an attempt is made to
determine whether the file is an executable image which
should be invoked using &quot;MCR&quot; or a text file which
should be <br>
passed to DCL as a command procedure.</p>

<p style="margin-top: 1em">fork <br>
While in principle the &quot;fork&quot; operator could be
implemented via (and with the same rather severe limitations
as) the CRTL &quot;vfork()&quot; routine, and while some
internal support <br>
to do just that is in place, the implementation has never
been completed, making &quot;fork&quot; currently
unavailable. A true kernel &quot;fork()&quot; is expected in
a future version of VMS, <br>
and the pseudo-fork based on interpreter threads may be
available in a future version of Perl on VMS (see perlfork).
In the meantime, use &quot;system&quot;, backticks, or piped
<br>
filehandles to create subprocesses.</p>

<p style="margin-top: 1em">getpwent <br>
getpwnam <br>
getpwuid <br>
These operators obtain the information described in
perlfunc, if you have the privileges necessary to retrieve
the named user&rsquo;s UAF information via
&quot;sys$getuai&quot;. If not, <br>
then only the $name, $uid, and $gid items are returned. The
$dir item contains the login directory in VMS syntax, while
the $comment item contains the login directory in <br>
Unix syntax. The $gcos item contains the owner field from
the UAF record. The $quota item is not used.</p>

<p style="margin-top: 1em">gmtime <br>
The &quot;gmtime&quot; operator will function properly if
you have a working CRTL &quot;gmtime()&quot; routine, or if
the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the
number of <br>
seconds which must be added to UTC to yield local time.
(This logical name is defined automatically if you are
running a version of VMS with built-in UTC support.) If <br>
neither of these cases is true, a warning message is
printed, and &quot;undef&quot; is returned.</p>

<p style="margin-top: 1em">kill <br>
In most cases, &quot;kill&quot; is implemented via the
undocumented system service $SIGPRC, which has the same
calling sequence as $FORCEX, but throws an exception in the
target <br>
process rather than forcing it to call $EXIT. Generally
speaking, &quot;kill&quot; follows the behavior of the
CRTL&rsquo;s &quot;kill()&quot; function, but unlike that
function can be called from <br>
within a signal handler. Also, unlike the &quot;kill&quot;
in some versions of the CRTL, Perl&rsquo;s &quot;kill&quot;
checks the validity of the signal passed in and returns an
error rather than <br>
attempting to send an unrecognized signal.</p>

<p style="margin-top: 1em">Also, negative signal values
don&rsquo;t do anything special under VMS; they&rsquo;re
just converted to the corresponding positive value.</p>

<p style="margin-top: 1em">qx// <br>
See the entry on &quot;backticks&quot; above.</p>

<p style="margin-top: 1em">select (system call) <br>
If Perl was not built with socket support, the system call
version of &quot;select&quot; is not available at all. If
socket support is present, then the system call version of
<br>
&quot;select&quot; functions only for file descriptors
attached to sockets. It will not provide information about
regular files or pipes, since the CRTL &quot;select()&quot;
routine does not <br>
provide this functionality.</p>

<p style="margin-top: 1em">stat EXPR <br>
Since VMS keeps track of files according to a different
scheme than Unix, it&rsquo;s not really possible to
represent the file&rsquo;s ID in the &quot;st_dev&quot; and
&quot;st_ino&quot; fields of a &quot;struct <br>
stat&quot;. Perl tries its best, though, and the values it
uses are pretty unlikely to be the same for two different
files. We can&rsquo;t guarantee this, though, so caveat
scriptor.</p>

<p style="margin-top: 1em">system LIST <br>
The &quot;system&quot; operator creates a subprocess, and
passes its arguments to the subprocess for execution as a
DCL command. Since the subprocess is created directly via
<br>
&quot;lib$spawn()&quot;, any valid DCL command string may be
specified. If the string begins with &rsquo;@&rsquo;, it is
treated as a DCL command unconditionally. Otherwise, if the
first token <br>
contains a character used as a delimiter in file
specification (e.g. &quot;:&quot; or &quot;]&quot;), an
attempt is made to expand it using a default type of .Exe
and the process defaults, and <br>
if successful, the resulting file is invoked via
&quot;MCR&quot;. This allows you to invoke an image directly
simply by passing the file specification to
&quot;system&quot;, a common Unixish <br>
idiom. If the token has no file type, and matches a file
with null type, then an attempt is made to determine whether
the file is an executable image which should be invoked <br>
using &quot;MCR&quot; or a text file which should be passed
to DCL as a command procedure.</p>

<p style="margin-top: 1em">If LIST consists of the empty
string, &quot;system&quot; spawns an interactive DCL
subprocess, in the same fashion as typing SPAWN at the DCL
prompt.</p>

<p style="margin-top: 1em">Perl waits for the subprocess to
complete before continuing execution in the current process.
As described in perlfunc, the return value of
&quot;system&quot; is a fake &quot;status&quot; which <br>
follows POSIX semantics unless the pragma &quot;use vmsish
&rsquo;status&rsquo;&quot; is in effect; see the description
of $? in this document for more detail.</p>

<p style="margin-top: 1em">time <br>
The value returned by &quot;time&quot; is the offset in
seconds from 01-JAN-1970 00:00:00 (just like the
CRTL&rsquo;s times() routine), in order to make life easier
for code coming in from <br>
the POSIX/Unix world.</p>

<p style="margin-top: 1em">times <br>
The array returned by the &quot;times&quot; operator is
divided up according to the same rules the CRTL
&quot;times()&quot; routine. Therefore, the &quot;system
time&quot; elements will always be 0, <br>
since there is no difference between &quot;user time&quot;
and &quot;system&quot; time under VMS, and the time
accumulated by a subprocess may or may not appear separately
in the &quot;child time&quot; <br>
field, depending on whether &quot;times()&quot; keeps track
of subprocesses separately. Note especially that the VAXCRTL
(at least) keeps track only of subprocesses spawned using
<br>
&quot;fork()&quot; and &quot;exec()&quot;; it will not
accumulate the times of subprocesses spawned via pipes,
&quot;system()&quot;, or backticks.</p>

<p style="margin-top: 1em">unlink LIST <br>
&quot;unlink&quot; will delete the highest version of a file
only; in order to delete all versions, you need to say</p>

<p style="margin-top: 1em">1 while unlink LIST;</p>

<p style="margin-top: 1em">You may need to make this change
to scripts written for a Unix system which expect that after
a call to &quot;unlink&quot;, no files with the names passed
to &quot;unlink&quot; will exist. <br>
(Note: This can be changed at compile time; if you &quot;use
Config&quot; and
$Config{&rsquo;d_unlink_all_versions&rsquo;} is
&quot;define&quot;, then &quot;unlink&quot; will delete all
versions of a file on the <br>
first call.)</p>

<p style="margin-top: 1em">&quot;unlink&quot; will delete a
file if at all possible, even if it requires changing file
protection (though it won&rsquo;t try to change the
protection of the parent directory). You can <br>
tell whether you&rsquo;ve got explicit delete access to a
file by using the &quot;VMS::Filespec::candelete&quot;
operator. For instance, in order to delete only files to
which you have <br>
delete access, you could say something like</p>

<p style="margin-top: 1em">sub safe_unlink { <br>
my($file,$num); <br>
foreach $file (@_) { <br>
next unless VMS::Filespec::candelete($file); <br>
$num += unlink $file; <br>
} <br>
$num; <br>
}</p>

<p style="margin-top: 1em">(or you could just use
&quot;VMS::Stdio::remove&quot;, if you&rsquo;ve installed
the VMS::Stdio extension distributed with Perl). If
&quot;unlink&quot; has to change the file protection to
delete the <br>
file, and you interrupt it in midstream, the file may be
left intact, but with a changed ACL allowing you delete
access.</p>

<p style="margin-top: 1em">This behavior of
&quot;unlink&quot; is to be compatible with POSIX behavior
and not traditional VMS behavior.</p>

<p style="margin-top: 1em">utime LIST <br>
This operator changes only the modification time of the file
(VMS revision date) on ODS-2 volumes and ODS-5 volumes
without access dates enabled. On ODS-5 volumes with access
<br>
dates enabled, the true access time is modified.</p>

<p style="margin-top: 1em">waitpid PID,FLAGS <br>
If PID is a subprocess started by a piped &quot;open()&quot;
(see open), &quot;waitpid&quot; will wait for that
subprocess, and return its final status value in $?. If PID
is a subprocess <br>
created in some other way (e.g. SPAWNed before Perl was
invoked), &quot;waitpid&quot; will simply check once per
second whether the process has completed, and return when it
has. (If <br>
PID specifies a process that isn&rsquo;t a subprocess of the
current process, and you invoked Perl with the
&quot;-w&quot; switch, a warning will be issued.)</p>

<p style="margin-top: 1em">Returns PID on success, -1 on
error. The FLAGS argument is ignored in all cases.</p>

<p style="margin-top: 1em">Perl variables <br>
The following VMS-specific information applies to the
indicated &quot;special&quot; Perl variables, in addition to
the general information in perlvar. Where there is a
conflict, this <br>
information takes precedence.</p>

<p style="margin-top: 1em">%ENV <br>
The operation of the %ENV array depends on the translation
of the logical name PERL_ENV_TABLES. If defined, it should
be a search list, each element of which specifies a <br>
location for %ENV elements. If you tell Perl to read or set
the element &quot;$ENV{&quot;name&quot;}&quot;, then Perl
uses the translations of PERL_ENV_TABLES as follows:</p>

<p style="margin-top: 1em">CRTL_ENV <br>
This string tells Perl to consult the CRTL&rsquo;s internal
&quot;environ&quot; array of key-value pairs, using name as
the key. In most cases, this contains only a few keys, but
if <br>
Perl was invoked via the C &quot;exec[lv]e()&quot; function,
as is the case for CGI processing by some HTTP servers, then
the &quot;environ&quot; array may have been populated by the
calling <br>
program.</p>

<p style="margin-top: 1em">CLISYM_[LOCAL] <br>
A string beginning with &quot;CLISYM_&quot;tells Perl to
consult the CLI&rsquo;s symbol tables, using name as the
name of the symbol. When reading an element of %ENV, the
local symbol <br>
table is scanned first, followed by the global symbol
table.. The characters following &quot;CLISYM_&quot; are
significant when an element of %ENV is set or deleted: if
the <br>
complete string is &quot;CLISYM_LOCAL&quot;, the change is
made in the local symbol table; otherwise the global symbol
table is changed.</p>

<p style="margin-top: 1em">Any other string <br>
If an element of PERL_ENV_TABLES translates to any other
string, that string is used as the name of a logical name
table, which is consulted using name as the logical <br>
name. The normal search order of access modes is used.</p>

<p style="margin-top: 1em">PERL_ENV_TABLES is translated
once when Perl starts up; any changes you make while Perl is
running do not affect the behavior of %ENV. If
PERL_ENV_TABLES is not defined, <br>
then Perl defaults to consulting first the logical name
tables specified by LNM$FILE_DEV, and then the CRTL
&quot;environ&quot; array.</p>

<p style="margin-top: 1em">In all operations on %ENV, the
key string is treated as if it were entirely uppercase,
regardless of the case actually specified in the Perl
expression.</p>

<p style="margin-top: 1em">When an element of %ENV is read,
the locations to which PERL_ENV_TABLES points are checked in
order, and the value obtained from the first successful
lookup is returned. If <br>
the name of the %ENV element contains a semi-colon, it and
any characters after it are removed. These are ignored when
the CRTL &quot;environ&quot; array or a CLI symbol table is
<br>
consulted. However, the name is looked up in a logical name
table, the suffix after the semi-colon is treated as the
translation index to be used for the lookup. This lets <br>
you look up successive values for search list logical names.
For instance, if you say</p>

<p style="margin-top: 1em">$ Define STORY
once,upon,a,time,there,was <br>
$ perl -e &quot;for ($i = 0; $i &lt;= 6; $i++) &quot; - <br>
_$ -e &quot;{ print $ENV{&rsquo;story;&rsquo;.$i},&rsquo;
&rsquo;}&quot;</p>

<p style="margin-top: 1em">Perl will print &quot;ONCE UPON
A TIME THERE WAS&quot;, assuming, of course, that
PERL_ENV_TABLES is set up so that the logical name
&quot;story&quot; is found, rather than a CLI symbol or CRTL
<br>
&quot;environ&quot; element with the same name.</p>

<p style="margin-top: 1em">When an element of %ENV is set
to a defined string, the corresponding definition is made in
the location to which the first translation of
PERL_ENV_TABLES points. If this <br>
causes a logical name to be created, it is defined in
supervisor mode. (The same is done if an existing logical
name was defined in executive or kernel mode; an existing
<br>
user or supervisor mode logical name is reset to the new
value.) If the value is an empty string, the logical
name&rsquo;s translation is defined as a single NUL (ASCII
00) <br>
character, since a logical name cannot translate to a
zero-length string. (This restriction does not apply to CLI
symbols or CRTL &quot;environ&quot; values; they are set to
the empty <br>
string.) An element of the CRTL &quot;environ&quot; array
can be set only if your copy of Perl knows about the
CRTL&rsquo;s &quot;setenv()&quot; function. (This is present
only in some versions of <br>
the DECCRTL; check $Config{d_setenv} to see whether your
copy of Perl was built with a CRTL that has this
function.)</p>

<p style="margin-top: 1em">When an element of %ENV is set
to &quot;undef&quot;, the element is looked up as if it were
being read, and if it is found, it is deleted. (An item
&quot;deleted&quot; from the CRTL &quot;environ&quot; <br>
array is set to the empty string; this can only be done if
your copy of Perl knows about the CRTL &quot;setenv()&quot;
function.) Using &quot;delete&quot; to remove an element
from %ENV has a <br>
similar effect, but after the element is deleted, another
attempt is made to look up the element, so an inner-mode
logical name or a name in another location will replace the
<br>
logical name just deleted. In either case, only the first
value found searching PERL_ENV_TABLES is altered. It is not
possible at present to define a search list logical <br>
name via %ENV.</p>

<p style="margin-top: 1em">The element $ENV{DEFAULT} is
special: when read, it returns Perl&rsquo;s current default
device and directory, and when set, it resets them,
regardless of the definition of <br>
PERL_ENV_TABLES. It cannot be cleared or deleted; attempts
to do so are silently ignored.</p>

<p style="margin-top: 1em">Note that if you want to pass on
any elements of the C-local environ array to a subprocess
which isn&rsquo;t started by fork/exec, or isn&rsquo;t
running a C program, you can &quot;promote&quot; <br>
them to logical names in the current process, which will
then be inherited by all subprocesses, by saying</p>

<p style="margin-top: 1em">foreach my $key (qw[C-local keys
you want promoted]) { <br>
my $temp = $ENV{$key}; # read from C-local array <br>
$ENV{$key} = $temp; # and define as logical name <br>
}</p>

<p style="margin-top: 1em">(You can&rsquo;t just say
$ENV{$key} = $ENV{$key}, since the Perl optimizer is smart
enough to elide the expression.)</p>

<p style="margin-top: 1em">Don&rsquo;t try to clear %ENV by
saying &quot;%ENV = ();&quot;, it will throw a fatal error.
This is equivalent to doing the following from DCL:</p>

<p style="margin-top: 1em">DELETE/LOGICAL *</p>

<p style="margin-top: 1em">You can imagine how bad things
would be if, for example, the SYS$MANAGER or SYS$SYSTEM
logical names were deleted.</p>

<p style="margin-top: 1em">At present, the first time you
iterate over %ENV using &quot;keys&quot;, or
&quot;values&quot;, you will incur a time penalty as all
logical names are read, in order to fully populate %ENV.
<br>
Subsequent iterations will not reread logical names, so they
won&rsquo;t be as slow, but they also won&rsquo;t reflect
any changes to logical name tables caused by other
programs.</p>

<p style="margin-top: 1em">You do need to be careful with
the logical names representing process-permanent files, such
as &quot;SYS$INPUT&quot; and &quot;SYS$OUTPUT&quot;. The
translations for these logical names are <br>
prepended with a two-byte binary value (0x1B 0x00) that
needs to be stripped off if you wantto use it. (In previous
versions of Perl it wasn&rsquo;t possible to get the values
of <br>
these logical names, as the null byte acted as an
end-of-string marker)</p>

<p style="margin-top: 1em">$! The string value of $! is
that returned by the CRTL&rsquo;s strerror() function, so it
will include the VMS message for VMS-specific errors. The
numeric value of $! is the value <br>
of &quot;errno&quot;, except if errno is EVMSERR, in which
case $! contains the value of vaxc$errno. Setting $! always
sets errno to the value specified. If this value is EVMSERR,
<br>
it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the
string value of $! won&rsquo;t reflect the VMS error message
from before $! was set.</p>

<p style="margin-top: 1em">$^E This variable provides
direct access to VMS status values in vaxc$errno, which are
often more specific than the generic Unix-style error
messages in $!. Its numeric value is <br>
the value of vaxc$errno, and its string value is the
corresponding VMS message string, as retrieved by
sys$getmsg(). Setting $^E sets vaxc$errno to the value
specified.</p>

<p style="margin-top: 1em">While Perl attempts to keep the
vaxc$errno value to be current, if errno is not EVMSERR, it
may not be from the current operation.</p>

<p style="margin-top: 1em">$? The &quot;status value&quot;
returned in $? is synthesized from the actual exit status of
the subprocess in a way that approximates POSIX wait(5)
semantics, in order to allow Perl <br>
programs to portably test for successful completion of
subprocesses. The low order 8 bits of $? are always 0 under
VMS, since the termination status of a process may or may
<br>
not have been generated by an exception.</p>

<p style="margin-top: 1em">The next 8 bits contain the
termination status of the program.</p>

<p style="margin-top: 1em">If the child process follows the
convention of C programs compiled with the _POSIX_EXIT macro
set, the status value will contain the actual value of 0 to
255 returned by that <br>
program on a normal exit.</p>

<p style="margin-top: 1em">With the _POSIX_EXIT macro set,
the Unix exit value of zero is represented as a VMS native
status of 1, and the Unix values from 2 to 255 are encoded
by the equation:</p>

<p style="margin-top: 1em">VMS_status = 0x35a000 +
(unix_value * 8) + 1.</p>

<p style="margin-top: 1em">And in the special case of Unix
value 1 the encoding is:</p>

<p style="margin-top: 1em">VMS_status = 0x35a000 + 8 + 2 +
0x10000000.</p>

<p style="margin-top: 1em">For other termination statuses,
the severity portion of the subprocess&rsquo;s exit status
is used: if the severity was success or informational, these
bits are all 0; if the <br>
severity was warning, they contain a value of 1; if the
severity was error or fatal error, they contain the actual
severity bits, which turns out to be a value of 2 for error
<br>
and 4 for severe_error. Fatal is another term for the
severe_error status.</p>

<p style="margin-top: 1em">As a result, $? will always be
zero if the subprocess&rsquo;s exit status indicated
successful completion, and non-zero if a warning or error
occurred or a program compliant with <br>
encoding _POSIX_EXIT values was run and set a status.</p>

<p style="margin-top: 1em">How can you tell the difference
between a non-zero status that is the result of a VMS native
error status or an encoded Unix status? You can not unless
you look at the <br>
${^CHILD_ERROR_NATIVE} value. The ${^CHILD_ERROR_NATIVE}
value returns the actual VMS status value and check the
severity bits. If the severity bits are equal to 1, then if
<br>
the numeric value for $? is between 2 and 255 or 0, then $?
accurately reflects a value passed back from a Unix
application. If $? is 1, and the severity bits indicate a
VMS <br>
error (2), then $? is from a Unix application exit
value.</p>

<p style="margin-top: 1em">In practice, Perl scripts that
call programs that return _POSIX_EXIT type status values
will be expecting those values, and programs that call
traditional VMS programs will <br>
either be expecting the previous behavior or just checking
for a non-zero status.</p>

<p style="margin-top: 1em">And success is always the value
0 in all behaviors.</p>

<p style="margin-top: 1em">When the actual VMS termination
status of the child is an error, internally the $! value
will be set to the closest Unix errno value to that error so
that Perl scripts that <br>
test for error messages will see the expected Unix style
error message instead of a VMS message.</p>

<p style="margin-top: 1em">Conversely, when setting $? in
an END block, an attempt is made to convert the POSIX value
into a native status intelligible to the operating system
upon exiting Perl. What <br>
this boils down to is that setting $? to zero results in the
generic success value SS$_NORMAL, and setting $? to a
non-zero value results in the generic failure status <br>
SS$_ABORT. See also &quot;exit&quot; in perlport.</p>

<p style="margin-top: 1em">With the
&quot;PERL_VMS_POSIX_EXIT&quot; logical name defined as
&quot;ENABLE&quot;, setting $? will cause the new value to
be encoded into $^E so that either the original parent or
child exit <br>
status values <br>
0 to 255 can be automatically recovered by C programs
expecting _POSIX_EXIT behavior. If both a parent and a child
exit value are non-zero, then it will be assumed that <br>
this is actually a VMS native status value to be passed
through. The special value of 0xFFFF is almost a NOOP as it
will cause the current native VMS status in the C library
<br>
to become the current native Perl VMS status, and is handled
this way as it is known to not be a valid native VMS status
value. It is recommend that only values in the range <br>
of normal Unix parent or child status numbers, 0 to 255 are
used.</p>

<p style="margin-top: 1em">The pragma &quot;use vmsish
&rsquo;status&rsquo;&quot; makes $? reflect the actual VMS
exit status instead of the default emulation of POSIX status
described above. This pragma also disables the <br>
conversion of non-zero values to SS$_ABORT when setting $?
in an END block (but zero will still be converted to
SS$_NORMAL).</p>

<p style="margin-top: 1em">Do not use the pragma &quot;use
vmsish &rsquo;status&rsquo;&quot; with
&quot;PERL_VMS_POSIX_EXIT&quot; enabled, as they are at
times requesting conflicting actions and the consequence of
ignoring this <br>
advice will be undefined to allow future improvements in the
POSIX exit handling.</p>

<p style="margin-top: 1em">In general, with
&quot;PERL_VMS_POSIX_EXIT&quot; enabled, more detailed
information will be available in the exit status for DCL
scripts or other native VMS tools, and will give the <br>
expected information for Posix programs. It has not been
made the default in order to preserve backward
compatibility.</p>

<p style="margin-top: 1em">N.B. Setting
&quot;DECC$FILENAME_UNIX_REPORT&quot; implicitly enables
&quot;PERL_VMS_POSIX_EXIT&quot;.</p>

<p style="margin-top: 1em">$| Setting $| for an I/O stream
causes data to be flushed all the way to disk on each write
(i.e. not just to the underlying RMS buffers for a file). In
other words, it&rsquo;s <br>
equivalent to calling fflush() and fsync() from C.</p>

<p style="margin-top: 1em">Standard modules with
VMS-specific differences <br>
SDBM_File <br>
SDBM_File works properly on VMS. It has, however, one minor
difference. The database directory file created has a
.sdbm_dir extension rather than a .dir extension. .dir files
are <br>
VMS filesystem directory files, and using them for other
purposes could cause unacceptable problems.</p>

<p style="margin-top: 1em">Revision date <br>
Please see the git repository for revision history.</p>

<p style="margin-top: 1em">AUTHOR <br>
Charles Bailey bailey@cor.newman.upenn.edu Craig Berry
craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg
wb8tyw@qsl.net</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLVMS(1)</p>
<hr>
</body>
</html>
