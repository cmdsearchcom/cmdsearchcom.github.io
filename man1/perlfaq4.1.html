<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:50 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLFAQ4(1) Perl Programmers Reference Guide
PERLFAQ4(1)</p>

<p style="margin-top: 1em">NAME <br>
perlfaq4 - Data Manipulation</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This section of the FAQ answers questions related to
manipulating numbers, dates, strings, arrays, hashes, and
miscellaneous data issues.</p>

<p style="margin-top: 1em">Data: Numbers <br>
Why am I getting long decimals (eg, 19.9499999999999)
instead of the numbers I should be getting (eg, 19.95)? <br>
For the long explanation, see David Goldberg&rsquo;s
&quot;What Every Computer Scientist Should Know About
Floating-Point Arithmetic&quot; <br>

(&lt;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&gt;).</p>

<p style="margin-top: 1em">Internally, your computer
represents floating-point numbers in binary. Digital (as in
powers of two) computers cannot store all numbers exactly.
Some real numbers lose precision <br>
in the process. This is a problem with how computers store
numbers and affects all computer languages, not just
Perl.</p>

<p style="margin-top: 1em">perlnumber shows the gory
details of number representations and conversions.</p>

<p style="margin-top: 1em">To limit the number of decimal
places in your numbers, you can use the &quot;printf&quot;
or &quot;sprintf&quot; function. See &quot;Floating-point
Arithmetic&quot; in perlop for more details.</p>

<p style="margin-top: 1em">printf &quot;%.2f&quot;,
10/3;</p>

<p style="margin-top: 1em">my $number = sprintf
&quot;%.2f&quot;, 10/3;</p>

<p style="margin-top: 1em">Why is int() broken? <br>
Your &quot;int()&quot; is most probably working just fine.
It&rsquo;s the numbers that aren&rsquo;t quite what you
think.</p>

<p style="margin-top: 1em">First, see the answer to
&quot;Why am I getting long decimals (eg, 19.9499999999999)
instead of the numbers I should be getting (eg,
19.95)?&quot;.</p>

<p style="margin-top: 1em">For example, this</p>

<p style="margin-top: 1em">print int(0.6/0.2-2),
&quot;0;</p>

<p style="margin-top: 1em">will in most computers print 0,
not 1, because even such simple numbers as 0.6 and 0.2
cannot be presented exactly by floating-point numbers. What
you think in the above as <br>
&rsquo;three&rsquo; is really more like
2.9999999999999995559.</p>

<p style="margin-top: 1em">Why isn&rsquo;t my octal data
interpreted correctly? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">You&rsquo;re probably trying to
convert a string to a number, which Perl only converts as a
decimal number. When Perl converts a string to a number, it
ignores leading spaces and <br>
zeroes, then assumes the rest of the digits are in base
10:</p>

<p style="margin-top: 1em">my $string =
&rsquo;0644&rsquo;;</p>

<p style="margin-top: 1em">print $string + 0; # prints
644</p>

<p style="margin-top: 1em">print $string + 44; # prints
688, certainly not octal!</p>

<p style="margin-top: 1em">This problem usually involves
one of the Perl built-ins that has the same name a Unix
command that uses octal numbers as arguments on the command
line. In this example, &quot;chmod&quot; <br>
on the command line knows that its first argument is octal
because that&rsquo;s what it does:</p>

<p style="margin-top: 1em">%prompt&gt; chmod 644 file</p>

<p style="margin-top: 1em">If you want to use the same
literal digits (644) in Perl, you have to tell Perl to treat
them as octal numbers either by prefixing the digits with a
0 or using &quot;oct&quot;:</p>

<p style="margin-top: 1em">chmod( 0644, $filename ); #
right, has leading zero <br>
chmod( oct(644), $filename ); # also correct</p>

<p style="margin-top: 1em">The problem comes in when you
take your numbers from something that Perl thinks is a
string, such as a command line argument in @ARGV:</p>

<p style="margin-top: 1em">chmod( $ARGV[0], $filename ); #
wrong, even if &quot;0644&quot;</p>

<p style="margin-top: 1em">chmod( oct($ARGV[0]), $filename
); # correct, treat string as octal</p>

<p style="margin-top: 1em">You can always check the value
you&rsquo;re using by printing it in octal notation to
ensure it matches what you think it should be. Print it in
octal and decimal format:</p>

<p style="margin-top: 1em">printf &quot;0%o %d&quot;,
$number, $number;</p>

<p style="margin-top: 1em">Does Perl have a round()
function? What about ceil() and floor()? Trig functions?
<br>
Remember that &quot;int()&quot; merely truncates toward 0.
For rounding to a certain number of digits,
&quot;sprintf()&quot; or &quot;printf()&quot; is usually the
easiest route.</p>

<p style="margin-top: 1em">printf(&quot;%.3f&quot;,
3.1415926535); # prints 3.142</p>

<p style="margin-top: 1em">The POSIX module (part of the
standard Perl distribution) implements &quot;ceil()&quot;,
&quot;floor()&quot;, and a number of other mathematical and
trigonometric functions.</p>

<p style="margin-top: 1em">use POSIX; <br>
my $ceil = ceil(3.5); # 4 <br>
my $floor = floor(3.5); # 3</p>

<p style="margin-top: 1em">In 5.000 to 5.003 perls,
trigonometry was done in the Math::Complex module. With
5.004, the Math::Trig module (part of the standard Perl
distribution) implements the <br>
trigonometric functions. Internally it uses the
Math::Complex module and some functions can break out from
the real axis into the complex plane, for example the
inverse sine of <br>
2.</p>

<p style="margin-top: 1em">Rounding in financial
applications can have serious implications, and the rounding
method used should be specified precisely. In these cases,
it probably pays not to trust <br>
whichever system of rounding is being used by Perl, but
instead to implement the rounding function you need
yourself.</p>

<p style="margin-top: 1em">To see why, notice how
you&rsquo;ll still have an issue on half-way-point
alternation:</p>

<p style="margin-top: 1em">for (my $i = 0; $i &lt; 1.01; $i
+= 0.05) { printf &quot;%.1f &quot;,$i}</p>

<p style="margin-top: 1em">0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3
0.4 0.4 0.5 0.5 0.6 0.7 0.7 <br>
0.8 0.8 0.9 0.9 1.0 1.0</p>

<p style="margin-top: 1em">Don&rsquo;t blame Perl.
It&rsquo;s the same as in C. IEEE says we have to do this.
Perl numbers whose absolute values are integers under 2**31
(on 32-bit machines) will work pretty much like <br>
mathematical integers. Other numbers are not guaranteed.</p>

<p style="margin-top: 1em">How do I convert between numeric
representations/bases/radixes? <br>
As always with Perl there is more than one way to do it.
Below are a few examples of approaches to making common
conversions between number representations. This is intended
to <br>
be representational rather than exhaustive.</p>

<p style="margin-top: 1em">Some of the examples later in
perlfaq4 use the Bit::Vector module from CPAN. The reason
you might choose Bit::Vector over the perl built-in
functions is that it works with <br>
numbers of ANY size, that it is optimized for speed on some
operations, and for at least some programmers the notation
might be familiar.</p>

<p style="margin-top: 1em">How do I convert hexadecimal
into decimal <br>
Using perl&rsquo;s built in conversion of &quot;0x&quot;
notation:</p>

<p style="margin-top: 1em">my $dec = 0xDEADBEEF;</p>

<p style="margin-top: 1em">Using the &quot;hex&quot;
function:</p>

<p style="margin-top: 1em">my $dec =
hex(&quot;DEADBEEF&quot;);</p>

<p style="margin-top: 1em">Using &quot;pack&quot;:</p>

<p style="margin-top: 1em">my $dec = unpack(&quot;N&quot;,
pack(&quot;H8&quot;, substr(&quot;0&quot; x 8 .
&quot;DEADBEEF&quot;, -8)));</p>

<p style="margin-top: 1em">Using the CPAN module
&quot;Bit::Vector&quot;:</p>

<p style="margin-top: 1em">use Bit::Vector; <br>
my $vec = Bit::Vector-&gt;new_Hex(32, &quot;DEADBEEF&quot;);
<br>
my $dec = $vec-&gt;to_Dec();</p>

<p style="margin-top: 1em">How do I convert from decimal to
hexadecimal <br>
Using &quot;sprintf&quot;:</p>

<p style="margin-top: 1em">my $hex =
sprintf(&quot;%X&quot;, 3735928559); # upper case A-F <br>
my $hex = sprintf(&quot;%x&quot;, 3735928559); # lower case
a-f</p>

<p style="margin-top: 1em">Using &quot;unpack&quot;:</p>

<p style="margin-top: 1em">my $hex = unpack(&quot;H*&quot;,
pack(&quot;N&quot;, 3735928559));</p>

<p style="margin-top: 1em">Using Bit::Vector:</p>

<p style="margin-top: 1em">use Bit::Vector; <br>
my $vec = Bit::Vector-&gt;new_Dec(32, -559038737); <br>
my $hex = $vec-&gt;to_Hex();</p>

<p style="margin-top: 1em">And Bit::Vector supports odd bit
counts:</p>

<p style="margin-top: 1em">use Bit::Vector; <br>
my $vec = Bit::Vector-&gt;new_Dec(33, 3735928559); <br>
$vec-&gt;Resize(32); # suppress leading 0 if unwanted <br>
my $hex = $vec-&gt;to_Hex();</p>

<p style="margin-top: 1em">How do I convert from octal to
decimal <br>
Using Perl&rsquo;s built in conversion of numbers with
leading zeros:</p>

<p style="margin-top: 1em">my $dec = 033653337357; # note
the leading 0!</p>

<p style="margin-top: 1em">Using the &quot;oct&quot;
function:</p>

<p style="margin-top: 1em">my $dec =
oct(&quot;33653337357&quot;);</p>

<p style="margin-top: 1em">Using Bit::Vector:</p>

<p style="margin-top: 1em">use Bit::Vector; <br>
my $vec = Bit::Vector-&gt;new(32); <br>
$vec-&gt;Chunk_List_Store(3, split(//, reverse
&quot;33653337357&quot;)); <br>
my $dec = $vec-&gt;to_Dec();</p>

<p style="margin-top: 1em">How do I convert from decimal to
octal <br>
Using &quot;sprintf&quot;:</p>

<p style="margin-top: 1em">my $oct =
sprintf(&quot;%o&quot;, 3735928559);</p>

<p style="margin-top: 1em">Using Bit::Vector:</p>

<p style="margin-top: 1em">use Bit::Vector; <br>
my $vec = Bit::Vector-&gt;new_Dec(32, -559038737); <br>
my $oct = reverse join(&rsquo;&rsquo;,
$vec-&gt;Chunk_List_Read(3));</p>

<p style="margin-top: 1em">How do I convert from binary to
decimal <br>
Perl 5.6 lets you write binary numbers directly with the
&quot;0b&quot; notation:</p>

<p style="margin-top: 1em">my $number = 0b10110110;</p>

<p style="margin-top: 1em">Using &quot;oct&quot;:</p>

<p style="margin-top: 1em">my $input =
&quot;10110110&quot;; <br>
my $decimal = oct( &quot;0b$input&quot; );</p>

<p style="margin-top: 1em">Using &quot;pack&quot; and
&quot;ord&quot;:</p>

<p style="margin-top: 1em">my $decimal =
ord(pack(&rsquo;B8&rsquo;, &rsquo;10110110&rsquo;));</p>

<p style="margin-top: 1em">Using &quot;pack&quot; and
&quot;unpack&quot; for larger strings:</p>

<p style="margin-top: 1em">my $int = unpack(&quot;N&quot;,
pack(&quot;B32&quot;, <br>
substr(&quot;0&quot; x 32 .
&quot;11110101011011011111011101111&quot;, -32))); <br>
my $dec = sprintf(&quot;%d&quot;, $int);</p>

<p style="margin-top: 1em"># substr() is used to left-pad a
32-character string with zeros.</p>

<p style="margin-top: 1em">Using Bit::Vector:</p>

<p style="margin-top: 1em">my $vec =
Bit::Vector-&gt;new_Bin(32,
&quot;11011110101011011011111011101111&quot;); <br>
my $dec = $vec-&gt;to_Dec();</p>

<p style="margin-top: 1em">How do I convert from decimal to
binary <br>
Using &quot;sprintf&quot; (perl 5.6+):</p>

<p style="margin-top: 1em">my $bin =
sprintf(&quot;%b&quot;, 3735928559);</p>

<p style="margin-top: 1em">Using &quot;unpack&quot;:</p>

<p style="margin-top: 1em">my $bin = unpack(&quot;B*&quot;,
pack(&quot;N&quot;, 3735928559));</p>

<p style="margin-top: 1em">Using Bit::Vector:</p>

<p style="margin-top: 1em">use Bit::Vector; <br>
my $vec = Bit::Vector-&gt;new_Dec(32, -559038737); <br>
my $bin = $vec-&gt;to_Bin();</p>

<p style="margin-top: 1em">The remaining transformations
(e.g. hex -&gt; oct, bin -&gt; hex, etc.) are left as an
exercise to the inclined reader.</p>

<p style="margin-top: 1em">Why doesn&rsquo;t &amp; work the
way I want it to? <br>
The behavior of binary arithmetic operators depends on
whether they&rsquo;re used on numbers or strings. The
operators treat a string as a series of bits and work with
that (the string <br>
&quot;3&quot; is the bit pattern 00110011). The operators
work with the binary form of a number (the number 3 is
treated as the bit pattern 00000011).</p>

<p style="margin-top: 1em">So, saying &quot;11 &amp;
3&quot; performs the &quot;and&quot; operation on numbers
(yielding 3). Saying &quot;11&quot; &amp; &quot;3&quot;
performs the &quot;and&quot; operation on strings (yielding
&quot;1&quot;).</p>

<p style="margin-top: 1em">Most problems with
&quot;&amp;&quot; and &quot;|&quot; arise because the
programmer thinks they have a number but really it&rsquo;s a
string or vice versa. To avoid this, stringify the arguments
explicitly <br>
(using &quot;&quot; or &quot;qq()&quot;) or convert them to
numbers explicitly (using &quot;0+$arg&quot;). The rest
arise because the programmer says:</p>

<p style="margin-top: 1em">if (&quot; 20 20&quot; &amp;
&quot;101101&quot;) { <br>
# ... <br>
}</p>

<p style="margin-top: 1em">but a string consisting of two
null bytes (the result of &quot; 20 20&quot; &amp;
&quot;101101&quot;) is not a false value in Perl. You
need:</p>

<p style="margin-top: 1em">if ( (&quot; 20 20&quot; &amp;
&quot;101101&quot;) !~ /[^ 00]/) { <br>
# ... <br>
}</p>

<p style="margin-top: 1em">How do I multiply matrices? <br>
Use the Math::Matrix or Math::MatrixReal modules (available
from CPAN) or the PDL extension (also available from
CPAN).</p>

<p style="margin-top: 1em">How do I perform an operation on
a series of integers? <br>
To call a function on each element in an array, and collect
the results, use:</p>

<p style="margin-top: 1em">my @results = map { my_func($_)
} @array;</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">my @triple = map { 3 * $_ }
@single;</p>

<p style="margin-top: 1em">To call a function on each
element of an array, but ignore the results:</p>

<p style="margin-top: 1em">foreach my $iterator (@array) {
<br>
some_func($iterator); <br>
}</p>

<p style="margin-top: 1em">To call a function on each
integer in a (small) range, you can use:</p>

<p style="margin-top: 1em">my @results = map {
some_func($_) } (5 .. 25);</p>

<p style="margin-top: 1em">but you should be aware that in
this form, the &quot;..&quot; operator creates a list of all
integers in the range, which can take a lot of memory for
large ranges. However, the problem <br>
does not occur when using &quot;..&quot; within a
&quot;for&quot; loop, because in that case the range
operator is optimized to iterate over the range, without
creating the entire list. So</p>

<p style="margin-top: 1em">my @results = (); <br>
for my $i (5 .. 500_005) { <br>
push(@results, some_func($i)); <br>
}</p>

<p style="margin-top: 1em">or even</p>

<p style="margin-top: 1em">push(@results, some_func($_))
for 5 .. 500_005;</p>

<p style="margin-top: 1em">will not create an intermediate
list of 500,000 integers.</p>

<p style="margin-top: 1em">How can I output Roman numerals?
<br>
Get the http://www.cpan.org/modules/by-module/Roman
&lt;http://www.cpan.org/modules/by-module/Roman&gt;
module.</p>

<p style="margin-top: 1em">Why aren&rsquo;t my random
numbers random? <br>
If you&rsquo;re using a version of Perl before 5.004, you
must call &quot;srand&quot; once at the start of your
program to seed the random number generator.</p>

<p style="margin-top: 1em">BEGIN { srand() if $] &lt; 5.004
}</p>

<p style="margin-top: 1em">5.004 and later automatically
call &quot;srand&quot; at the beginning. Don&rsquo;t call
&quot;srand&quot; more than once--you make your numbers less
random, rather than more.</p>

<p style="margin-top: 1em">Computers are good at being
predictable and bad at being random (despite appearances
caused by bugs in your programs :-). The random article in
the &quot;Far More Than You Ever Wanted <br>
To Know&quot; collection in
&lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt;,
courtesy of Tom Phoenix, talks more about this. John von
Neumann said, &quot;Anyone who attempts to generate <br>
random numbers by deterministic means is, of course, living
in a state of sin.&quot;</p>

<p style="margin-top: 1em">Perl relies on the underlying
system for the implementation of &quot;rand&quot; and
&quot;srand&quot;; on some systems, the generated numbers
are not random enough (especially on Windows : see <br>
&lt;http://www.perlmonks.org/?node_id=803632&gt;). Several
CPAN modules in the &quot;Math&quot; namespace implement
better pseudorandom generators; see for example
Math::Random::MT (&quot;Mersenne <br>
Twister&quot;, fast), or Math::TrulyRandom (uses the
imperfections in the system&rsquo;s timer to generate random
numbers, which is rather slow). More algorithms for random
numbers are <br>
described in &quot;Numerical Recipes in C&quot; at
&lt;http://www.nr.com/&gt;</p>

<p style="margin-top: 1em">How do I get a random number
between X and Y? <br>
To get a random number between two values, you can use the
&quot;rand()&quot; built-in to get a random number between 0
and 1. From there, you shift that into the range that you
want.</p>

<p style="margin-top: 1em">&quot;rand($x)&quot; returns a
number such that &quot;0 &lt;= rand($x) &lt; $x&quot;. Thus
what you want to have perl figure out is a random number in
the range from 0 to the difference between your X and <br>
Y.</p>

<p style="margin-top: 1em">That is, to get a number between
10 and 15, inclusive, you want a random number between 0 and
5 that you can then add to 10.</p>

<p style="margin-top: 1em">my $number = 10 + int rand(
15-10+1 ); # ( 10,11,12,13,14, or 15 )</p>

<p style="margin-top: 1em">Hence you derive the following
simple function to abstract that. It selects a random
integer between the two given integers (inclusive), For
example: <br>
&quot;random_int_between(50,120)&quot;.</p>

<p style="margin-top: 1em">sub random_int_between { <br>
my($min, $max) = @_; <br>
# Assumes that the two arguments are integers themselves!
<br>
return $min if $min == $max; <br>
($min, $max) = ($max, $min) if $min &gt; $max; <br>
return $min + int rand(1 + $max - $min); <br>
}</p>

<p style="margin-top: 1em">Data: Dates <br>
How do I find the day or week of the year? <br>
The day of the year is in the list returned by the
&quot;localtime&quot; function. Without an argument
&quot;localtime&quot; uses the current time.</p>

<p style="margin-top: 1em">my $day_of_year =
(localtime)[7];</p>

<p style="margin-top: 1em">The POSIX module can also format
a date as the day of the year or week of the year.</p>

<p style="margin-top: 1em">use POSIX qw/strftime/; <br>
my $day_of_year = strftime &quot;%j&quot;, localtime; <br>
my $week_of_year = strftime &quot;%W&quot;, localtime;</p>

<p style="margin-top: 1em">To get the day of year for any
date, use POSIX&rsquo;s &quot;mktime&quot; to get a time in
epoch seconds for the argument to &quot;localtime&quot;.</p>

<p style="margin-top: 1em">use POSIX qw/mktime strftime/;
<br>
my $week_of_year = strftime &quot;%W&quot;, <br>
localtime( mktime( 0, 0, 0, 18, 11, 87 ) );</p>

<p style="margin-top: 1em">You can also use Time::Piece,
which comes with Perl and provides a &quot;localtime&quot;
that returns an object:</p>

<p style="margin-top: 1em">use Time::Piece; <br>
my $day_of_year = localtime-&gt;yday; <br>
my $week_of_year = localtime-&gt;week;</p>

<p style="margin-top: 1em">The Date::Calc module provides
two functions to calculate these, too:</p>

<p style="margin-top: 1em">use Date::Calc; <br>
my $day_of_year = Day_of_Year( 1987, 12, 18 ); <br>
my $week_of_year = Week_of_Year( 1987, 12, 18 );</p>

<p style="margin-top: 1em">How do I find the current
century or millennium? <br>
Use the following simple functions:</p>

<p style="margin-top: 1em">sub get_century { <br>
return int((((localtime(shift || time))[5] + 1999))/100);
<br>
}</p>

<p style="margin-top: 1em">sub get_millennium { <br>
return 1+int((((localtime(shift || time))[5] + 1899))/1000);
<br>
}</p>

<p style="margin-top: 1em">On some systems, the POSIX
module&rsquo;s &quot;strftime()&quot; function has been
extended in a non-standard way to use a %C format, which
they sometimes claim is the &quot;century&quot;. It
isn&rsquo;t, <br>
because on most such systems, this is only the first two
digits of the four-digit year, and thus cannot be used to
determine reliably the current century or millennium.</p>

<p style="margin-top: 1em">How can I compare two dates and
find the difference? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">You could just store all your
dates as a number and then subtract. Life isn&rsquo;t always
that simple though.</p>

<p style="margin-top: 1em">The Time::Piece module, which
comes with Perl, replaces localtime with a version that
returns an object. It also overloads the comparison
operators so you can compare them <br>
directly:</p>

<p style="margin-top: 1em">use Time::Piece; <br>
my $date1 = localtime( $some_time ); <br>
my $date2 = localtime( $some_other_time );</p>

<p style="margin-top: 1em">if( $date1 &lt; $date2 ) { <br>
print &quot;The date was in the past0; <br>
}</p>

<p style="margin-top: 1em">You can also get differences
with a subtraction, which returns a Time::Seconds
object:</p>

<p style="margin-top: 1em">my $diff = $date1 - $date2; <br>
print &quot;The difference is &quot;, $date_diff-&gt;days,
&quot; days0;</p>

<p style="margin-top: 1em">If you want to work with
formatted dates, the Date::Manip, Date::Calc, or DateTime
modules can help you.</p>

<p style="margin-top: 1em">How can I take a string and turn
it into epoch seconds? <br>
If it&rsquo;s a regular enough string that it always has the
same format, you can split it up and pass the parts to
&quot;timelocal&quot; in the standard Time::Local module.
Otherwise, you <br>
should look into the Date::Calc, Date::Parse, and
Date::Manip modules from CPAN.</p>

<p style="margin-top: 1em">How can I find the Julian Day?
<br>
(contributed by brian d foy and Dave Cross)</p>

<p style="margin-top: 1em">You can use the Time::Piece
module, part of the Standard Library, which can convert a
date/time to a Julian Day:</p>

<p style="margin-top: 1em">$ perl -MTime::Piece -le
&rsquo;print localtime-&gt;julian_day&rsquo; <br>
2455607.7959375</p>

<p style="margin-top: 1em">Or the modified Julian Day:</p>

<p style="margin-top: 1em">$ perl -MTime::Piece -le
&rsquo;print localtime-&gt;mjd&rsquo; <br>
55607.2961226851</p>

<p style="margin-top: 1em">Or even the day of the year
(which is what some people think of as a Julian day):</p>

<p style="margin-top: 1em">$ perl -MTime::Piece -le
&rsquo;print localtime-&gt;yday&rsquo; <br>
45</p>

<p style="margin-top: 1em">You can also do the same things
with the DateTime module:</p>

<p style="margin-top: 1em">$ perl -MDateTime
-le&rsquo;print DateTime-&gt;today-&gt;jd&rsquo; <br>
2453401.5 <br>
$ perl -MDateTime -le&rsquo;print
DateTime-&gt;today-&gt;mjd&rsquo; <br>
53401 <br>
$ perl -MDateTime -le&rsquo;print
DateTime-&gt;today-&gt;doy&rsquo; <br>
31</p>

<p style="margin-top: 1em">You can use the Time::JulianDay
module available on CPAN. Ensure that you really want to
find a Julian day, though, as many people have different
ideas about Julian days (see <br>
&lt;http://www.hermetic.ch/cal_stud/jdn.htm&gt; for
instance):</p>

<p style="margin-top: 1em">$ perl -MTime::JulianDay -le
&rsquo;print local_julian_day( time )&rsquo; <br>
55608</p>

<p style="margin-top: 1em">How do I find yesterday&rsquo;s
date? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">To do it correctly, you can use
one of the &quot;Date&quot; modules since they work with
calendars instead of times. The DateTime module makes it
simple, and give you the same time of day, <br>
only the day before, despite daylight saving time
changes:</p>

<p style="margin-top: 1em">use DateTime;</p>

<p style="margin-top: 1em">my $yesterday =
DateTime-&gt;now-&gt;subtract( days =&gt; 1 );</p>

<p style="margin-top: 1em">print &quot;Yesterday was
$yesterday0;</p>

<p style="margin-top: 1em">You can also use the Date::Calc
module using its &quot;Today_and_Now&quot; function.</p>

<p style="margin-top: 1em">use Date::Calc qw( Today_and_Now
Add_Delta_DHMS );</p>

<p style="margin-top: 1em">my @date_time = Add_Delta_DHMS(
Today_and_Now(), -1, 0, 0, 0 );</p>

<p style="margin-top: 1em">print &quot;@date_time0;</p>

<p style="margin-top: 1em">Most people try to use the time
rather than the calendar to figure out dates, but that
assumes that days are twenty-four hours each. For most
people, there are two days a year <br>
when they aren&rsquo;t: the switch to and from summer time
throws this off. For example, the rest of the suggestions
will be wrong sometimes:</p>

<p style="margin-top: 1em">Starting with Perl 5.10,
Time::Piece and Time::Seconds are part of the standard
distribution, so you might think that you could do something
like this:</p>

<p style="margin-top: 1em">use Time::Piece; <br>
use Time::Seconds;</p>

<p style="margin-top: 1em">my $yesterday = localtime() -
ONE_DAY; # WRONG <br>
print &quot;Yesterday was $yesterday0;</p>

<p style="margin-top: 1em">The Time::Piece module exports a
new &quot;localtime&quot; that returns an object, and
Time::Seconds exports the &quot;ONE_DAY&quot; constant that
is a set number of seconds. This means that it <br>
always gives the time 24 hours ago, which is not always
yesterday. This can cause problems around the end of
daylight saving time when there&rsquo;s one day that is 25
hours long.</p>

<p style="margin-top: 1em">You have the same problem with
Time::Local, which will give the wrong answer for those same
special cases:</p>

<p style="margin-top: 1em"># contributed by Gunnar
Hjalmarsson <br>
use Time::Local; <br>
my $today = timelocal 0, 0, 12, ( localtime )[3..5]; <br>
my ($d, $m, $y) = ( localtime $today-86400 )[3..5]; # WRONG
<br>
printf &quot;Yesterday: %d-%02d-%02d0, $y+1900, $m+1,
$d;</p>

<p style="margin-top: 1em">Does Perl have a Year 2000 or
2038 problem? Is Perl Y2K compliant? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">Perl itself never had a Y2K
problem, although that never stopped people from creating
Y2K problems on their own. See the documentation for
&quot;localtime&quot; for its proper use.</p>

<p style="margin-top: 1em">Starting with Perl 5.12,
&quot;localtime&quot; and &quot;gmtime&quot; can handle
dates past 03:14:08 January 19, 2038, when a 32-bit based
time would overflow. You still might get a warning on a <br>
32-bit &quot;perl&quot;:</p>

<p style="margin-top: 1em">% perl5.12 -E &rsquo;say scalar
localtime( 0x9FFF_FFFFFFFF )&rsquo; <br>
Integer overflow in hexadecimal number at -e line 1. <br>
Wed Nov 1 19:42:39 5576711</p>

<p style="margin-top: 1em">On a 64-bit &quot;perl&quot;,
you can get even larger dates for those really long running
projects:</p>

<p style="margin-top: 1em">% perl5.12 -E &rsquo;say scalar
gmtime( 0x9FFF_FFFFFFFF )&rsquo; <br>
Thu Nov 2 00:42:39 5576711</p>

<p style="margin-top: 1em">You&rsquo;re still out of luck
if you need to keep track of decaying protons though.</p>

<p style="margin-top: 1em">Data: Strings <br>
How do I validate input? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">There are many ways to ensure
that values are what you expect or want to accept. Besides
the specific examples that we cover in the perlfaq, you can
also look at the modules with <br>
&quot;Assert&quot; and &quot;Validate&quot; in their names,
along with other modules such as Regexp::Common.</p>

<p style="margin-top: 1em">Some modules have validation for
particular types of input, such as Business::ISBN,
Business::CreditCard, Email::Valid, and
Data::Validate::IP.</p>

<p style="margin-top: 1em">How do I unescape a string? <br>
It depends just what you mean by &quot;escape&quot;. URL
escapes are dealt with in perlfaq9. Shell escapes with the
backslash (&quot;</p>

<p style="margin-top: 1em">s/\(.)/$1/g;</p>

<p style="margin-top: 1em">This won&rsquo;t expand &quot;0
or &quot;&quot; or any other special escapes.</p>

<p style="margin-top: 1em">How do I remove consecutive
pairs of characters? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">You can use the substitution
operator to find pairs of characters (or runs of characters)
and replace them with a single instance. In this
substitution, we find a character in <br>
&quot;(.)&quot;. The memory parentheses store the matched
character in the back-reference &quot;&quot; and we use that
to require that the same thing immediately follow it. We
replace that part <br>
of the string with the character in $1.</p>

<p style="margin-top: 1em">s/(.)/$1/g;</p>

<p style="margin-top: 1em">We can also use the
transliteration operator, &quot;tr///&quot;. In this
example, the search list side of our &quot;tr///&quot;
contains nothing, but the &quot;c&quot; option complements
that so it contains <br>
everything. The replacement list also contains nothing, so
the transliteration is almost a no-op since it won&rsquo;t
do any replacements (or more exactly, replace the character
with <br>
itself). However, the &quot;s&quot; option squashes
duplicated and consecutive characters in the string so a
character does not show up next to itself</p>

<p style="margin-top: 1em">my $str = &rsquo;Haarlem&rsquo;;
# in the Netherlands <br>
$str =~ tr///cs; # Now Harlem, like in New York</p>

<p style="margin-top: 1em">How do I expand function calls
in a string? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">This is documented in perlref,
and although it&rsquo;s not the easiest thing to read, it
does work. In each of these examples, we call the function
inside the braces used to <br>
dereference a reference. If we have more than one return
value, we can construct and dereference an anonymous array.
In this case, we call the function in list context.</p>

<p style="margin-top: 1em">print &quot;The time values are
@{ [localtime] }.0;</p>

<p style="margin-top: 1em">If we want to call the function
in scalar context, we have to do a bit more work. We can
really have any code we like inside the braces, so we simply
have to end with the scalar <br>
reference, although how you do that is up to you, and you
can use code inside the braces. Note that the use of parens
creates a list context, so we need &quot;scalar&quot; to
force the <br>
scalar context on the function:</p>

<p style="margin-top: 1em">print &quot;The time is
${&sect;alar localtime)}.0</p>

<p style="margin-top: 1em">print &quot;The time is ${ my $x
= localtime; }.0;</p>

<p style="margin-top: 1em">If your function already returns
a reference, you don&rsquo;t need to create the reference
yourself.</p>

<p style="margin-top: 1em">sub timestamp { my $t =
localtime; }</p>

<p style="margin-top: 1em">print &quot;The time is ${
timestamp() }.0;</p>

<p style="margin-top: 1em">The &quot;Interpolation&quot;
module can also do a lot of magic for you. You can specify a
variable name, in this case &quot;E&quot;, to set up a tied
hash that does the interpolation for you. It <br>
has several other methods to do this as well.</p>

<p style="margin-top: 1em">use Interpolation E =&gt;
&rsquo;eval&rsquo;; <br>
print &quot;The time values are $E{localtime()}.0;</p>

<p style="margin-top: 1em">In most cases, it is probably
easier to simply use string concatenation, which also forces
scalar context.</p>

<p style="margin-top: 1em">print &quot;The time is &quot; .
localtime() . &quot;.0;</p>

<p style="margin-top: 1em">How do I find matching/nesting
anything? <br>
To find something between two single characters, a pattern
like &quot;/x([^x]*)x/&quot; will get the intervening bits
in $1. For multiple ones, then something more like
&quot;/alpha(.*?)omega/&quot; <br>
would be needed. For nested patterns and/or balanced
expressions, see the so-called (?PARNO) construct (available
since perl 5.10). The CPAN module Regexp::Common can help to
<br>
build such regular expressions (see in particular
Regexp::Common::balanced and Regexp::Common::delimited).</p>

<p style="margin-top: 1em">More complex cases will require
to write a parser, probably using a parsing module from
CPAN, like Regexp::Grammars, Parse::RecDescent, Parse::Yapp,
Text::Balanced, or Marpa::XS.</p>

<p style="margin-top: 1em">How do I reverse a string? <br>
Use &quot;reverse()&quot; in scalar context, as documented
in &quot;reverse&quot; in perlfunc.</p>

<p style="margin-top: 1em">my $reversed = reverse
$string;</p>

<p style="margin-top: 1em">How do I expand tabs in a
string? <br>
You can do it yourself:</p>

<p style="margin-top: 1em">1 while $string =~ s/+/&rsquo;
&rsquo; x (length($&amp;) * 8 - length($&lsquo;) % 8)/e;</p>

<p style="margin-top: 1em">Or you can just use the
Text::Tabs module (part of the standard Perl
distribution).</p>

<p style="margin-top: 1em">use Text::Tabs; <br>
my @expanded_lines = expand(@lines_with_tabs);</p>

<p style="margin-top: 1em">How do I reformat a paragraph?
<br>
Use Text::Wrap (part of the standard Perl distribution):</p>

<p style="margin-top: 1em">use Text::Wrap; <br>
print wrap(&quot;&quot;, &rsquo; &rsquo;, @paragraphs);</p>

<p style="margin-top: 1em">The paragraphs you give to
Text::Wrap should not contain embedded newlines. Text::Wrap
doesn&rsquo;t justify the lines (flush-right).</p>

<p style="margin-top: 1em">Or use the CPAN module
Text::Autoformat. Formatting files can be easily done by
making a shell alias, like so:</p>

<p style="margin-top: 1em">alias fmt=&quot;perl -i
-MText::Autoformat -n0777 -e &rsquo;print autoformat $_,
{all=&gt;1}&rsquo; $*&quot;</p>

<p style="margin-top: 1em">See the documentation for
Text::Autoformat to appreciate its many capabilities.</p>

<p style="margin-top: 1em">How can I access or change N
characters of a string? <br>
You can access the first characters of a string with
substr(). To get the first character, for example, start at
position 0 and grab the string of length 1.</p>

<p style="margin-top: 1em">my $string = &quot;Just another
Perl Hacker&quot;; <br>
my $first_char = substr( $string, 0, 1 ); #
&rsquo;J&rsquo;</p>

<p style="margin-top: 1em">To change part of a string, you
can use the optional fourth argument which is the
replacement string.</p>

<p style="margin-top: 1em">substr( $string, 13, 4,
&quot;Perl 5.8.0&quot; );</p>

<p style="margin-top: 1em">You can also use substr() as an
lvalue.</p>

<p style="margin-top: 1em">substr( $string, 13, 4 ) =
&quot;Perl 5.8.0&quot;;</p>

<p style="margin-top: 1em">How do I change the Nth
occurrence of something? <br>
You have to keep track of N yourself. For example,
let&rsquo;s say you want to change the fifth occurrence of
&quot;whoever&quot; or &quot;whomever&quot; into
&quot;whosoever&quot; or &quot;whomsoever&quot;, case <br>
insensitively. These all assume that $_ contains the string
to be altered.</p>

<p style="margin-top: 1em">$count = 0; <br>
s{((whom?)ever)}{ <br>
++$count == 5 # is it the 5th? <br>
? &quot;${2}soever&quot; # yes, swap <br>
: $1 # renege and leave it there <br>
}ige;</p>

<p style="margin-top: 1em">In the more general case, you
can use the &quot;/g&quot; modifier in a &quot;while&quot;
loop, keeping count of matches.</p>

<p style="margin-top: 1em">$WANT = 3; <br>
$count = 0; <br>
$_ = &quot;One fish two fish red fish blue fish&quot;; <br>
while (/(96 <br>
if (++$count == $WANT) { <br>
print &quot;The third fish is a $1 one.0; <br>
} <br>
}</p>

<p style="margin-top: 1em">That prints out: &quot;The third
fish is a red one.&quot; You can also use a repetition count
and repeated pattern like this:</p>

<p style="margin-top: 1em">/(?:216</p>

<p style="margin-top: 1em">How can I count the number of
occurrences of a substring within a string? <br>
There are a number of ways, with varying efficiency. If you
want a count of a certain single character (X) within a
string, you can use the &quot;tr///&quot; function like
so:</p>

<p style="margin-top: 1em">my $string =
&quot;ThisXlineXhasXsomeXx&rsquo;sXinXit&quot;; <br>
my $count = ($string =~ tr/X//); <br>
print &quot;There are $count X characters in the
string&quot;;</p>

<p style="margin-top: 1em">This is fine if you are just
looking for a single character. However, if you are trying
to count multiple character substrings within a larger
string, &quot;tr///&quot; won&rsquo;t work. What <br>
you can do is wrap a while() loop around a global pattern
match. For example, let&rsquo;s count negative integers:</p>

<p style="margin-top: 1em">my $string = &quot;-9 55 48 -2
23 -76 4 14 -44&quot;; <br>
my $count = 0; <br>
while ($string =~ /-+/g) { $count++ } <br>
print &quot;There are $count negative numbers in the
string&quot;;</p>

<p style="margin-top: 1em">Another version uses a global
match in list context, then assigns the result to a scalar,
producing a count of the number of matches.</p>

<p style="margin-top: 1em">my $count = () = $string =~
/-+/g;</p>

<p style="margin-top: 1em">How do I capitalize all the
words on one line? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">Damian Conway&rsquo;s
Text::Autoformat handles all of the thinking for you.</p>

<p style="margin-top: 1em">use Text::Autoformat; <br>
my $x = &quot;Dr. Strangelove or: How I Learned to Stop
&quot;. <br>
&quot;Worrying and Love the Bomb&quot;;</p>

<p style="margin-top: 1em">print $x, &quot;0; <br>
for my $style (qw( sentence title highlight )) { <br>
print autoformat($x, { case =&gt; $style }), &quot;0; <br>
}</p>

<p style="margin-top: 1em">How do you want to capitalize
those words?</p>

<p style="margin-top: 1em">FRED AND BARNEY&rsquo;S LODGE #
all uppercase <br>
Fred And Barney&rsquo;s Lodge # title case <br>
Fred and Barney&rsquo;s Lodge # highlight case</p>

<p style="margin-top: 1em">It&rsquo;s not as easy a problem
as it looks. How many words do you think are in there? Wait
for it... wait for it.... If you answered 5 you&rsquo;re
right. Perl words are groups of &quot;48 <br>
but that&rsquo;s not what you want to capitalize. How is
Perl supposed to know not to capitalize that &quot;s&quot;
after the apostrophe? You could try a regular
expression:</p>

<p style="margin-top: 1em">$string =~ s/ ( <br>
(^792 <br>
| # or <br>
( <small><small>24 <br>
) <br>
/U$1/xg;</small></small></p>

<p style="margin-top: 1em"><small><small>$string =~
s/([120</small></small></p>

<p style="margin-top: 1em"><small><small>Now, what if you
don&rsquo;t want to capitalize that &quot;and&quot;? Just
use Text::Autoformat and get on with the next problem.
:)</small></small></p>

<p style="margin-top: 1em"><small><small>How can I split a
[character]-delimited string except when inside [character]?
<br>
Several modules can handle this sort of
parsing--Text::Balanced, Text::CSV, Text::CSV_XS, and
Text::ParseWords, among others.</small></small></p>

<p style="margin-top: 1em"><small><small>Take the example
case of trying to split a string that is comma-separated
into its different fields. You can&rsquo;t use
&quot;split(/,/)&quot; because you shouldn&rsquo;t split if
the comma is inside <br>
quotes. For example, take a data line like
this:</small></small></p>


<p style="margin-top: 1em"><small><small>SAR001,&quot;&quot;,&quot;Cimetrix,
Inc&quot;,&quot;Bob
Smith&quot;,&quot;CAM&quot;,N,8,1,0,7,&quot;Error, Core
Dumped&quot;</small></small></p>

<p style="margin-top: 1em"><small><small>Due to the
restriction of the quotes, this is a fairly complex problem.
Thankfully, we have Jeffrey Friedl, author of Mastering
Regular Expressions, to handle these for us. He <br>
suggests (assuming your string is contained in
$text):</small></small></p>

<p style="margin-top: 1em"><small><small>my @new = (); <br>
push(@new, $+) while $text =~ m{ <br>
&quot;([^ <br>
| ([^,]+),? <br>
| , <br>
}gx; <br>
push(@new, undef) if substr($text,-1,1) eq
&rsquo;,&rsquo;;</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
represent quotation marks inside a quotation-mark-delimited
field, escape them with backslashes (eg,
&quot;like</small></small></p>

<p style="margin-top: 1em"><small><small>Alternatively, the
Text::ParseWords module (part of the standard Perl
distribution) lets you say:</small></small></p>

<p style="margin-top: 1em"><small><small>use
Text::ParseWords; <br>
@new = quotewords(&quot;,&quot;, 0,
$text);</small></small></p>

<p style="margin-top: 1em"><small><small>For parsing or
generating CSV, though, using Text::CSV rather than
implementing it yourself is highly recommended; you&rsquo;ll
save yourself odd bugs popping up later by just using <br>
code which has already been tried and tested in production
for years.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I strip
blank space from the beginning/end of a string? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>A substitution can
do this for you. For a single line, you want to replace all
the leading or trailing whitespace with nothing. You can do
that with a pair of substitutions:</small></small></p>

<p style="margin-top: 1em"><small><small>s/^/; <br>
s/;</small></small></p>

<p style="margin-top: 1em"><small><small>You can also write
that as a single substitution, although it turns out the
combined statement is slower than the separate ones. That
might not matter to you, though:</small></small></p>


<p style="margin-top: 1em"><small><small>s/^;</small></small></p>

<p style="margin-top: 1em"><small><small>In this regular
expression, the alternation matches either at the beginning
or the end of the string since the anchors have a lower
precedence than the alternation. With the &quot;/g&quot;
<br>
flag, the substitution makes all possible matches, so it
gets both. Remember, the trailing newline matches the &quot;
and the &quot;$&quot; anchor can match to the absolute end
of the <br>
string, so the newline disappears too. Just add the newline
to the output, which has the added benefit of preserving
&quot;blank&quot; (consisting entirely of whitespace) lines
which the <br>
&quot;^ould remove all by itself:</small></small></p>

<p style="margin-top: 1em"><small><small>while( &lt;&gt; )
{ <br>
s/^; <br>
print &quot;$_0; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>For a multi-line
string, you can apply the regular expression to each logical
line in the string by adding the &quot;/m&quot; flag (for
&quot;multi-line&quot;). With the &quot;/m&quot; flag, the
&quot;$&quot; matches <br>
before an embedded newline, so it doesn&rsquo;t remove it.
This pattern still removes the newline at the end of the
string:</small></small></p>

<p style="margin-top: 1em"><small><small>$string =~
s/^m;</small></small></p>

<p style="margin-top: 1em"><small><small>Remember that
lines consisting entirely of whitespace will disappear,
since the first part of the alternation can match the entire
string and replace it with nothing. If you need <br>
to keep embedded blank lines, you have to do a little more
work. Instead of matching any whitespace (since that
includes a newline), just match the other
whitespace:</small></small></p>

<p style="margin-top: 1em"><small><small>$string =~
s/^[]+|[]+$//mg;</small></small></p>

<p style="margin-top: 1em"><small><small>How do I pad a
string with blanks or pad a number with zeroes? <br>
In the following examples, $pad_len is the length to which
you wish to pad the string, $text or $num contains the
string to be padded, and $pad_char contains the padding <br>
character. You can use a single character string constant
instead of the $pad_char variable if you know what it is in
advance. And in the same way you can use an integer in place
<br>
of $pad_len if you know the pad length in
advance.</small></small></p>

<p style="margin-top: 1em"><small><small>The simplest
method uses the &quot;sprintf&quot; function. It can pad on
the left or right with blanks and on the left with zeroes
and it will not truncate the result. The &quot;pack&quot;
function <br>
can only pad strings on the right with blanks and it will
truncate the result to a maximum length of
$pad_len.</small></small></p>

<p style="margin-top: 1em"><small><small># Left padding a
string with blanks (no truncation): <br>
my $padded = sprintf(&quot;%${pad_len}s&quot;, $text); <br>
my $padded = sprintf(&quot;%*s&quot;, $pad_len, $text); #
same thing</small></small></p>

<p style="margin-top: 1em"><small><small># Right padding a
string with blanks (no truncation): <br>
my $padded = sprintf(&quot;%-${pad_len}s&quot;, $text); <br>
my $padded = sprintf(&quot;%-*s&quot;, $pad_len, $text); #
same thing</small></small></p>

<p style="margin-top: 1em"><small><small># Left padding a
number with 0 (no truncation): <br>
my $padded = sprintf(&quot;%0${pad_len}d&quot;, $num); <br>
my $padded = sprintf(&quot;%0*d&quot;, $pad_len, $num); #
same thing</small></small></p>

<p style="margin-top: 1em"><small><small># Right padding a
string with blanks using pack (will truncate): <br>
my $padded =
pack(&quot;A$pad_len&quot;,$text);</small></small></p>

<p style="margin-top: 1em"><small><small>If you need to pad
with a character other than blank or zero you can use one of
the following methods. They all generate a pad string with
the &quot;x&quot; operator and combine that with <br>
$text. These methods do not truncate
$text.</small></small></p>

<p style="margin-top: 1em"><small><small>Left and right
padding with any character, creating a new
string:</small></small></p>

<p style="margin-top: 1em"><small><small>my $padded =
$pad_char x ( $pad_len - length( $text ) ) . $text; <br>
my $padded = $text . $pad_char x ( $pad_len - length( $text
) );</small></small></p>

<p style="margin-top: 1em"><small><small>Left and right
padding with any character, modifying $text
directly:</small></small></p>

<p style="margin-top: 1em"><small><small>substr( $text, 0,
0 ) = $pad_char x ( $pad_len - length( $text ) ); <br>
$text .= $pad_char x ( $pad_len - length( $text )
);</small></small></p>

<p style="margin-top: 1em"><small><small>How do I extract
selected columns from a string? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>If you know the
columns that contain the data, you can use
&quot;substr&quot; to extract a single
column.</small></small></p>

<p style="margin-top: 1em"><small><small>my $column =
substr( $line, $start_column, $length );</small></small></p>

<p style="margin-top: 1em"><small><small>You can use
&quot;split&quot; if the columns are separated by whitespace
or some other delimiter, as long as whitespace or the
delimiter cannot appear as part of the
data.</small></small></p>

<p style="margin-top: 1em"><small><small>my $line = &rsquo;
fred barney betty &rsquo;; <br>
my @columns = split /, $line; <br>
# ( &rsquo;&rsquo;, &rsquo;fred&rsquo;,
&rsquo;barney&rsquo;, &rsquo;betty&rsquo;
);</small></small></p>

<p style="margin-top: 1em"><small><small>my $line =
&rsquo;fred||barney||betty&rsquo;; <br>
my @columns = split //, $line; <br>
# ( &rsquo;fred&rsquo;, &rsquo;&rsquo;,
&rsquo;barney&rsquo;, &rsquo;&rsquo;, &rsquo;betty&rsquo;
);</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
work with comma-separated values, don&rsquo;t do this since
that format is a bit more complicated. Use one of the
modules that handle that format, such as Text::CSV, <br>
Text::CSV_XS, or Text::CSV_PP.</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
break apart an entire line of fixed columns, you can use
&quot;unpack&quot; with the A (ASCII) format. By using a
number after the format specifier, you can denote the <br>
column width. See the &quot;pack&quot; and
&quot;unpack&quot; entries in perlfunc for more
details.</small></small></p>

<p style="margin-top: 1em"><small><small>my @fields =
unpack( $line, &quot;A8 A8 A8 A16 A4&quot;
);</small></small></p>

<p style="margin-top: 1em"><small><small>Note that spaces
in the format argument to &quot;unpack&quot; do not denote
literal spaces. If you have space separated data, you may
want &quot;split&quot; instead.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I find the
soundex value of a string? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>You can use the
&quot;Text::Soundex&quot; module. If you want to do fuzzy or
close matching, you might also try the String::Approx, and
Text::Metaphone, and Text::DoubleMetaphone
modules.</small></small></p>

<p style="margin-top: 1em"><small><small>How can I expand
variables in text strings? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>If you can avoid
it, don&rsquo;t, or if you can use a templating system, such
as Text::Template or Template Toolkit, do that instead. You
might even be able to get the job done with <br>
&quot;sprintf&quot; or
&quot;printf&quot;:</small></small></p>

<p style="margin-top: 1em"><small><small>my $string =
sprintf &rsquo;Say hello to %s and %s&rsquo;, $foo,
$bar;</small></small></p>

<p style="margin-top: 1em"><small><small>However, for the
one-off simple case where I don&rsquo;t want to pull out a
full templating system, I&rsquo;ll use a string that has two
Perl scalar variables in it. In this example, I want <br>
to expand $foo and $bar to their variable&rsquo;s
values:</small></small></p>

<p style="margin-top: 1em"><small><small>my $foo =
&rsquo;Fred&rsquo;; <br>
my $bar = &rsquo;Barney&rsquo;; <br>
$string = &rsquo;Say hello to $foo and
$bar&rsquo;;</small></small></p>

<p style="margin-top: 1em"><small><small>One way I can do
this involves the substitution operator and a double
&quot;/e&quot; flag. The first &quot;/e&quot; evaluates $1
on the replacement side and turns it into $foo. The second
/e starts <br>
with $foo and replaces it with its value. $foo, then, turns
into &rsquo;Fred&rsquo;, and that&rsquo;s finally
what&rsquo;s left in the string:</small></small></p>

<p style="margin-top: 1em"><small><small>$string =~
s/(w+)/$1/eeg; # &rsquo;Say hello to Fred and
Barney&rsquo;</small></small></p>

<p style="margin-top: 1em"><small><small>The &quot;/e&quot;
will also silently ignore violations of strict, replacing
undefined variable names with the empty string. Since
I&rsquo;m using the &quot;/e&quot; flag (twice even!), I
have all of the <br>
same security problems I have with &quot;eval&quot; in its
string form. If there&rsquo;s something odd in $foo, perhaps
something like &quot;@{[ system &quot;rm -rf /&quot;
]}&quot;, then I could get myself in <br>
trouble.</small></small></p>

<p style="margin-top: 1em"><small><small>To get around the
security problem, I could also pull the values from a hash
instead of evaluating variable names. Using a single
&quot;/e&quot;, I can check the hash to ensure the value
<br>
exists, and if it doesn&rsquo;t, I can replace the missing
value with a marker, in this case &quot;???&quot; to signal
that I missed something:</small></small></p>

<p style="margin-top: 1em"><small><small>my $string =
&rsquo;This has $foo and $bar&rsquo;;</small></small></p>

<p style="margin-top: 1em"><small><small>my %Replacements =
( <br>
foo =&gt; &rsquo;Fred&rsquo;, <br>
);</small></small></p>

<p style="margin-top: 1em"><small><small># $string =~
s/+)/$Replacements{$1}/g; <br>
$string =~ s/+)/ <br>
exists $Replacements{$1} ? $Replacements{$1} :
&rsquo;???&rsquo; <br>
/eg;</small></small></p>

<p style="margin-top: 1em"><small><small>print
$string;</small></small></p>

<p style="margin-top: 1em"><small><small>What&rsquo;s wrong
with always quoting &quot;$vars&quot;? <br>
The problem is that those double-quotes force
stringification--coercing numbers and references into
strings--even when you don&rsquo;t want them to be strings.
Think of it this way: <br>
double-quote expansion is used to produce new strings. If
you already have a string, why do you need
more?</small></small></p>

<p style="margin-top: 1em"><small><small>If you get used to
writing odd things like these:</small></small></p>

<p style="margin-top: 1em"><small><small>print
&quot;$var&quot;; # BAD <br>
my $new = &quot;$old&quot;; # BAD <br>
somefunc(&quot;$var&quot;); # BAD</small></small></p>

<p style="margin-top: 1em"><small><small>You&rsquo;ll be in
trouble. Those should (in 99.8% of the cases) be the simpler
and more direct:</small></small></p>

<p style="margin-top: 1em"><small><small>print $var; <br>
my $new = $old; <br>
somefunc($var);</small></small></p>

<p style="margin-top: 1em"><small><small>Otherwise, besides
slowing you down, you&rsquo;re going to break code when the
thing in the scalar is actually neither a string nor a
number, but a reference:</small></small></p>

<p style="margin-top: 1em"><small><small>func(@array); <br>
sub func { <br>
my $aref = shift; <br>
my $oref = &quot;$aref&quot;; # WRONG <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>You can also get
into subtle problems on those few operations in Perl that
actually do care about the difference between a string and a
number, such as the magical &quot;++&quot; <br>
autoincrement operator or the syscall()
function.</small></small></p>

<p style="margin-top: 1em"><small><small>Stringification
also destroys arrays.</small></small></p>

<p style="margin-top: 1em"><small><small>my @lines =
&lsquo;command&lsquo;; <br>
print &quot;@lines&quot;; # WRONG - extra blanks <br>
print @lines; # right</small></small></p>

<p style="margin-top: 1em"><small><small>Why don&rsquo;t my
&lt;&lt;HERE documents work? <br>
Here documents are found in perlop. Check for these three
things:</small></small></p>

<p style="margin-top: 1em"><small><small>There must be no
space after the &lt;&lt; part. <br>
There (probably) should be a semicolon at the end of the
opening token <br>
You can&rsquo;t (easily) have any space in front of the tag.
<br>
There needs to be at least a line separator after the end
token.</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
indent the text in the here document, you can do
this:</small></small></p>

<p style="margin-top: 1em"><small><small># all in one <br>
(my $VAR = &lt;&lt;HERE_TARGET) =~ s/^/gm; <br>
your text <br>
goes here <br>
HERE_TARGET</small></small></p>

<p style="margin-top: 1em"><small><small>But the
HERE_TARGET must still be flush against the margin. If you
want that indented also, you&rsquo;ll have to quote in the
indentation.</small></small></p>

<p style="margin-top: 1em"><small><small>(my $quote =
&lt;&lt;&rsquo; FINIS&rsquo;) =~ s/^/gm; <br>
...we will have peace, when you and all your works have <br>
perished--and the works of your dark master to whom you <br>
would deliver us. You are a liar, Saruman, and a corrupter
<br>
of men&rsquo;s hearts. --Theoden in /usr/src/perl/taint.c
<br>
FINIS <br>
$quote =~ s/-/0/;</small></small></p>

<p style="margin-top: 1em"><small><small>A nice
general-purpose fixer-upper function for indented here
documents follows. It expects to be called with a here
document as its argument. It looks to see whether each line
<br>
begins with a common substring, and if so, strips that
substring off. Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off
each <br>
subsequent line.</small></small></p>

<p style="margin-top: 1em"><small><small>sub fix { <br>
local $_ = shift; <br>
my ($white, $leader); # common whitespace and common leading
string <br>
if (/^(?:([^96?:?.*0+$/) { <br>
($white, $leader) = ($2, quotemeta($1)); <br>
} else { <br>
($white, $leader) = (/^(/, &rsquo;&rsquo;); <br>
} <br>
s/^?$leader(?:$white)?//gm; <br>
return $_; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>This works with
leading special strings, dynamically
determined:</small></small></p>

<p style="margin-top: 1em"><small><small>my
$remember_the_main = fix&lt;&lt;&rsquo;
MAIN_INTERPRETER_LOOP&rsquo;; <br>
@@@ int <br>
@@@ runops() { <br>
@@@ SAVEI32(runlevel); <br>
@@@ runlevel++; <br>
@@@ while ( op = (*op-&gt;op_ppaddr)() ); <br>
@@@ TAINT_NOT; <br>
@@@ return 0; <br>
@@@ } <br>
MAIN_INTERPRETER_LOOP</small></small></p>

<p style="margin-top: 1em"><small><small>Or with a fixed
amount of leading whitespace, with remaining indentation
correctly preserved:</small></small></p>

<p style="margin-top: 1em"><small><small>my $poem =
fix&lt;&lt;EVER_ON_AND_ON; <br>
Now far ahead the Road has gone, <br>
And I must follow, if I can, <br>
Pursuing it with eager feet, <br>
Until it joins some larger way <br>
Where many paths and errands meet. <br>
And whither then? I cannot say. <br>
--Bilbo in /usr/src/perl/pp_ctl.c <br>
EVER_ON_AND_ON</small></small></p>

<p style="margin-top: 1em"><small><small>Data: Arrays <br>
What is the difference between a list and an array? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>A list is a fixed
collection of scalars. An array is a variable that holds a
variable collection of scalars. An array can supply its
collection for list operations, so list <br>
operations also work on arrays:</small></small></p>

<p style="margin-top: 1em"><small><small># slices <br>
( &rsquo;dog&rsquo;, &rsquo;cat&rsquo;, &rsquo;bird&rsquo;
)[2,3]; <br>
@animals[2,3];</small></small></p>

<p style="margin-top: 1em"><small><small># iteration <br>
foreach ( qw( dog cat bird ) ) { ... } <br>
foreach ( @animals ) { ... }</small></small></p>

<p style="margin-top: 1em"><small><small>my @three = grep {
length == 3 } qw( dog cat bird ); <br>
my @three = grep { length == 3 }
@animals;</small></small></p>

<p style="margin-top: 1em"><small><small># supply an
argument list <br>
wash_animals( qw( dog cat bird ) ); <br>
wash_animals( @animals );</small></small></p>

<p style="margin-top: 1em"><small><small>Array operations,
which change the scalars, rearranges them, or adds or
subtracts some scalars, only work on arrays. These
can&rsquo;t work on a list, which is fixed. Array operations
<br>
include &quot;shift&quot;, &quot;unshift&quot;,
&quot;push&quot;, &quot;pop&quot;, and
&quot;splice&quot;.</small></small></p>

<p style="margin-top: 1em"><small><small>An array can also
change its length:</small></small></p>

<p style="margin-top: 1em"><small><small>$#animals = 1; #
truncate to two elements <br>
$#animals = 10000; # pre-extend to 10,001
elements</small></small></p>

<p style="margin-top: 1em"><small><small>You can change an
array element, but you can&rsquo;t change a list
element:</small></small></p>

<p style="margin-top: 1em"><small><small>$animals[0] =
&rsquo;Rottweiler&rsquo;; <br>
qw( dog cat bird )[0] = &rsquo;Rottweiler&rsquo;; # syntax
error!</small></small></p>

<p style="margin-top: 1em"><small><small>foreach ( @animals
) { <br>
s/^d/fr/; # works fine <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>foreach ( qw( dog
cat bird ) ) { <br>
s/^d/fr/; # Error! Modification of read only value! <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>However, if the
list element is itself a variable, it appears that you can
change a list element. However, the list element is the
variable, not the data. You&rsquo;re not changing the <br>
list element, but something the list element refers to. The
list element itself doesn&rsquo;t change: it&rsquo;s still
the same variable.</small></small></p>

<p style="margin-top: 1em"><small><small>You also have to
be careful about context. You can assign an array to a
scalar to get the number of elements in the array. This only
works for arrays, though:</small></small></p>

<p style="margin-top: 1em"><small><small>my $count =
@animals; # only works with arrays</small></small></p>

<p style="margin-top: 1em"><small><small>If you try to do
the same thing with what you think is a list, you get a
quite different result. Although it looks like you have a
list on the righthand side, Perl actually sees <br>
a bunch of scalars separated by a comma:</small></small></p>

<p style="margin-top: 1em"><small><small>my $scalar = (
&rsquo;dog&rsquo;, &rsquo;cat&rsquo;, &rsquo;bird&rsquo; );
# $scalar gets bird</small></small></p>

<p style="margin-top: 1em"><small><small>Since you&rsquo;re
assigning to a scalar, the righthand side is in scalar
context. The comma operator (yes, it&rsquo;s an operator!)
in scalar context evaluates its lefthand side, throws <br>
away the result, and evaluates it&rsquo;s righthand side and
returns the result. In effect, that list-lookalike assigns
to $scalar it&rsquo;s rightmost value. Many people mess this
up <br>
because they choose a list-lookalike whose last element is
also the count they expect:</small></small></p>

<p style="margin-top: 1em"><small><small>my $scalar = ( 1,
2, 3 ); # $scalar gets 3, accidentally</small></small></p>

<p style="margin-top: 1em"><small><small>What is the
difference between $array[1] and @array[1]? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>The difference is
the sigil, that special character in front of the array
name. The &quot;$&quot; sigil means &quot;exactly one
item&quot;, while the &quot;@&quot; sigil means &quot;zero
or more items&quot;. The &quot;$&quot; <br>
gets you a single scalar, while the &quot;@&quot; gets you a
list.</small></small></p>

<p style="margin-top: 1em"><small><small>The confusion
arises because people incorrectly assume that the sigil
denotes the variable type.</small></small></p>

<p style="margin-top: 1em"><small><small>The $array[1] is a
single-element access to the array. It&rsquo;s going to
return the item in index 1 (or undef if there is no item
there). If you intend to get exactly one element <br>
from the array, this is the form you should
use.</small></small></p>

<p style="margin-top: 1em"><small><small>The @array[1] is
an array slice, although it has only one index. You can pull
out multiple elements simultaneously by specifying
additional indices as a list, like <br>
@array[1,4,3,0].</small></small></p>

<p style="margin-top: 1em"><small><small>Using a slice on
the lefthand side of the assignment supplies list context to
the righthand side. This can lead to unexpected results. For
instance, if you want to read a single <br>
line from a filehandle, assigning to a scalar value is
fine:</small></small></p>

<p style="margin-top: 1em"><small><small>$array[1] =
&lt;STDIN&gt;;</small></small></p>

<p style="margin-top: 1em"><small><small>However, in list
context, the line input operator returns all of the lines as
a list. The first line goes into @array[1] and the rest of
the lines mysteriously disappear:</small></small></p>

<p style="margin-top: 1em"><small><small>@array[1] =
&lt;STDIN&gt;; # most likely not what you
want</small></small></p>

<p style="margin-top: 1em"><small><small>Either the
&quot;use warnings&quot; pragma or the -w flag will warn you
when you use an array slice with a single
index.</small></small></p>

<p style="margin-top: 1em"><small><small>How can I remove
duplicate elements from a list or array? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>Use a hash. When
you think the words &quot;unique&quot; or
&quot;duplicated&quot;, think &quot;hash
keys&quot;.</small></small></p>

<p style="margin-top: 1em"><small><small>If you don&rsquo;t
care about the order of the elements, you could just create
the hash then extract the keys. It&rsquo;s not important how
you create that hash: just that you use &quot;keys&quot; to
<br>
get the unique elements.</small></small></p>

<p style="margin-top: 1em"><small><small>my %hash = map {
$_, 1 } @array; <br>
# or a hash slice: @hash{ @array } = (); <br>
# or a foreach: $hash{$_} = 1 foreach ( @array
);</small></small></p>

<p style="margin-top: 1em"><small><small>my @unique = keys
%hash;</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to use
a module, try the &quot;uniq&quot; function from
List::MoreUtils. In list context it returns the unique
elements, preserving their order in the list. In scalar
context, <br>
it returns the number of unique
elements.</small></small></p>

<p style="margin-top: 1em"><small><small>use
List::MoreUtils qw(uniq);</small></small></p>

<p style="margin-top: 1em"><small><small>my @unique = uniq(
1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7 <br>
my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); #
7</small></small></p>

<p style="margin-top: 1em"><small><small>You can also go
through each element and skip the ones you&rsquo;ve seen
before. Use a hash to keep track. The first time the loop
sees an element, that element has no key in %Seen. <br>
The &quot;next&quot; statement creates the key and
immediately uses its value, which is &quot;undef&quot;, so
the loop continues to the &quot;push&quot; and increments
the value for that key. The next time <br>
the loop sees that same element, its key exists in the hash
and the value for that key is true (since it&rsquo;s not 0
or &quot;undef&quot;), so the next skips that iteration and
the loop goes <br>
to the next element.</small></small></p>

<p style="margin-top: 1em"><small><small>my @unique = ();
<br>
my %seen = ();</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $elem (
@array ) { <br>
next if $seen{ $elem }++; <br>
push @unique, $elem; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>You can write this
more briefly using a grep, which does the same
thing.</small></small></p>

<p style="margin-top: 1em"><small><small>my %seen = ();
<br>
my @unique = grep { ! $seen{ $_ }++ }
@array;</small></small></p>

<p style="margin-top: 1em"><small><small>How can I tell
whether a certain element is contained in a list or array?
<br>
(portions of this answer contributed by Anno Siegel and
brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>Hearing the word
&quot;in&quot; is an indication that you probably should
have used a hash, not a list or array, to store your data.
Hashes are designed to answer this question quickly and <br>
efficiently. Arrays aren&rsquo;t.</small></small></p>

<p style="margin-top: 1em"><small><small>That being said,
there are several ways to approach this. In Perl 5.10 and
later, you can use the smart match operator to check that an
item is contained in an array or a hash:</small></small></p>

<p style="margin-top: 1em"><small><small>use
5.010;</small></small></p>

<p style="margin-top: 1em"><small><small>if( $item ~~
@array ) { <br>
say &quot;The array contains $item&quot; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>if( $item ~~ %hash
) { <br>
say &quot;The hash contains $item&quot; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>With earlier
versions of Perl, you have to do a bit more work. If you are
going to make this query many times over arbitrary string
values, the fastest way is probably to invert <br>
the original array and maintain a hash whose keys are the
first array&rsquo;s values:</small></small></p>

<p style="margin-top: 1em"><small><small>my @blues =
qw/azure cerulean teal turquoise lapis-lazuli/; <br>
my %is_blue = (); <br>
for (@blues) { $is_blue{$_} = 1 }</small></small></p>

<p style="margin-top: 1em"><small><small>Now you can check
whether $is_blue{$some_color}. It might have been a good
idea to keep the blues all in a hash in the first
place.</small></small></p>

<p style="margin-top: 1em"><small><small>If the values are
all small integers, you could use a simple indexed array.
This kind of an array will take up less
space:</small></small></p>

<p style="margin-top: 1em"><small><small>my @primes = (2,
3, 5, 7, 11, 13, 17, 19, 23, 29, 31); <br>
my @is_tiny_prime = (); <br>
for (@primes) { $is_tiny_prime[$_] = 1 } <br>
# or simply @istiny_prime[@primes] = (1) x
@primes;</small></small></p>

<p style="margin-top: 1em"><small><small>Now you check
whether $is_tiny_prime[$some_number].</small></small></p>

<p style="margin-top: 1em"><small><small>If the values in
question are integers instead of strings, you can save quite
a lot of space by using bit strings
instead:</small></small></p>

<p style="margin-top: 1em"><small><small>my @articles = (
1..10, 150..2000, 2017 ); <br>
undef $read; <br>
for (@articles) { vec($read,$_,1) = 1 }</small></small></p>

<p style="margin-top: 1em"><small><small>Now check whether
&quot;vec($read,$n,1)&quot; is true for some
$n.</small></small></p>

<p style="margin-top: 1em"><small><small>These methods
guarantee fast individual tests but require a
re-organization of the original list or array. They only pay
off if you have to test multiple values against the same
<br>
array.</small></small></p>

<p style="margin-top: 1em"><small><small>If you are testing
only once, the standard module List::Util exports the
function &quot;first&quot; for this purpose. It works by
stopping once it finds the element. It&rsquo;s written in C
for <br>
speed, and its Perl equivalent looks like this
subroutine:</small></small></p>

<p style="margin-top: 1em"><small><small>sub first (&amp;@)
{ <br>
my $code = shift; <br>
foreach (@_) { <br>
return $_ if &amp;{$code}(); <br>
} <br>
undef; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>If speed is of
little concern, the common idiom uses grep in scalar context
(which returns the number of items that passed its
condition) to traverse the entire list. This does <br>
have the benefit of telling you how many matches it found,
though.</small></small></p>

<p style="margin-top: 1em"><small><small>my $is_there =
grep $_ eq $whatever, @array;</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
actually extract the matching elements, simply use grep in
list context.</small></small></p>

<p style="margin-top: 1em"><small><small>my @matches = grep
$_ eq $whatever, @array;</small></small></p>

<p style="margin-top: 1em"><small><small>How do I compute
the difference of two arrays? How do I compute the
intersection of two arrays? <br>
Use a hash. Here&rsquo;s code to do both and more. It
assumes that each element is unique in a given
array:</small></small></p>

<p style="margin-top: 1em"><small><small>my (@union,
@intersection, @difference); <br>
my %count = (); <br>
foreach my $element (@array1, @array2) { $count{$element}++
} <br>
foreach my $element (keys %count) { <br>
push @union, $element; <br>
push @{ $count{$element} &gt; 1 ? @intersection :
@difference }, $element; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Note that this is
the symmetric difference, that is, all elements in either A
or in B but not in both. Think of it as an xor
operation.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I test
whether two arrays or hashes are equal? <br>
With Perl 5.10 and later, the smart match operator can give
you the answer with the least amount of
work:</small></small></p>

<p style="margin-top: 1em"><small><small>use
5.010;</small></small></p>

<p style="margin-top: 1em"><small><small>if( @array1 ~~
@array2 ) { <br>
say &quot;The arrays are the same&quot;; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>if( %hash1 ~~
%hash2 ) # doesn&rsquo;t check values! { <br>
say &quot;The hash keys are the same&quot;; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>The following code
works for single-level arrays. It uses a stringwise
comparison, and does not distinguish defined versus
undefined empty strings. Modify if you have other <br>
needs.</small></small></p>

<p style="margin-top: 1em"><small><small>$are_equal =
compare_arrays(@frogs, @toads);</small></small></p>

<p style="margin-top: 1em"><small><small>sub compare_arrays
{ <br>
my ($first, $second) = @_; <br>
no warnings; # silence spurious -w undef complaints <br>
return 0 unless @$first == @$second; <br>
for (my $i = 0; $i &lt; @$first; $i++) { <br>
return 0 if $first-&gt;[$i] ne $second-&gt;[$i]; <br>
} <br>
return 1; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>For multilevel
structures, you may wish to use an approach more like this
one. It uses the CPAN module FreezeThaw:</small></small></p>

<p style="margin-top: 1em"><small><small>use FreezeThaw
qw(cmpStr); <br>
my @a = my @b = ( &quot;this&quot;, &quot;that&quot;, [
&quot;more&quot;, &quot;stuff&quot; ] );</small></small></p>

<p style="margin-top: 1em"><small><small>printf &quot;a and
b contain %s arrays0, <br>
cmpStr(@a, @b) == 0 <br>
? &quot;the same&quot; <br>
: &quot;different&quot;;</small></small></p>

<p style="margin-top: 1em"><small><small>This approach also
works for comparing hashes. Here we&rsquo;ll demonstrate two
different answers:</small></small></p>

<p style="margin-top: 1em"><small><small>use FreezeThaw
qw(cmpStr cmpStrHard);</small></small></p>

<p style="margin-top: 1em"><small><small>my %a = my %b = (
&quot;this&quot; =&gt; &quot;that&quot;, &quot;extra&quot;
=&gt; [ &quot;more&quot;, &quot;stuff&quot; ] ); <br>
$a{EXTRA} = b; <br>
$b{EXTRA} = a;</small></small></p>

<p style="margin-top: 1em"><small><small>printf &quot;a and
b contain %s hashes0, <br>
cmpStr(a, b) == 0 ? &quot;the same&quot; :
&quot;different&quot;;</small></small></p>

<p style="margin-top: 1em"><small><small>printf &quot;a and
b contain %s hashes0, <br>
cmpStrHard(a, b) == 0 ? &quot;the same&quot; :
&quot;different&quot;;</small></small></p>

<p style="margin-top: 1em"><small><small>The first reports
that both those the hashes contain the same data, while the
second reports that they do not. Which you prefer is left as
an exercise to the reader.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I find the
first array element for which a condition is true? <br>
To find the first array element which satisfies a condition,
you can use the &quot;first()&quot; function in the
List::Util module, which comes with Perl 5.8. This example
finds the first <br>
element that contains &quot;Perl&quot;.</small></small></p>

<p style="margin-top: 1em"><small><small>use List::Util
qw(first);</small></small></p>

<p style="margin-top: 1em"><small><small>my $element =
first { /Perl/ } @array;</small></small></p>

<p style="margin-top: 1em"><small><small>If you cannot use
List::Util, you can make your own loop to do the same thing.
Once you find the element, you stop the loop with
last.</small></small></p>

<p style="margin-top: 1em"><small><small>my $found; <br>
foreach ( @array ) { <br>
if( /Perl/ ) { $found = $_; last } <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>If you want the
array index, use the &quot;firstidx()&quot; function from
&quot;List::MoreUtils&quot;:</small></small></p>

<p style="margin-top: 1em"><small><small>use
List::MoreUtils qw(firstidx); <br>
my $index = firstidx { /Perl/ } @array;</small></small></p>

<p style="margin-top: 1em"><small><small>Or write it
yourself, iterating through the indices and checking the
array element at each index until you find one that
satisfies the condition:</small></small></p>

<p style="margin-top: 1em"><small><small>my( $found, $index
) = ( undef, -1 ); <br>
for( $i = 0; $i &lt; @array; $i++ ) { <br>
if( $array[$i] =~ /Perl/ ) { <br>
$found = $array[$i]; <br>
$index = $i; <br>
last; <br>
} <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>How do I handle
linked lists? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>Perl&rsquo;s
arrays do not have a fixed size, so you don&rsquo;t need
linked lists if you just want to add or remove items. You
can use array operations such as &quot;push&quot;,
&quot;pop&quot;, &quot;shift&quot;, <br>
&quot;unshift&quot;, or &quot;splice&quot; to do
that.</small></small></p>

<p style="margin-top: 1em"><small><small>Sometimes,
however, linked lists can be useful in situations where you
want to &quot;shard&quot; an array so you have have many
small arrays instead of a single big array. You can keep
<br>
arrays longer than Perl&rsquo;s largest array index, lock
smaller arrays separately in threaded programs, reallocate
less memory, or quickly insert elements in the middle of the
chain.</small></small></p>

<p style="margin-top: 1em"><small><small>Steve Lembark goes
through the details in his YAPC::NA 2009 talk &quot;Perly
Linked Lists&quot; (
http://www.slideshare.net/lembark/perly-linked-lists <br>

&lt;http://www.slideshare.net/lembark/perly-linked-lists&gt;
), although you can just use his LinkedList::Single
module.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I handle
circular lists? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
cycle through an array endlessly, you can increment the
index modulo the number of elements in the
array:</small></small></p>

<p style="margin-top: 1em"><small><small>my @array = qw( a
b c ); <br>
my $i = 0;</small></small></p>

<p style="margin-top: 1em"><small><small>while( 1 ) { <br>
print $array[ $i++ % @array ], &quot;0; <br>
last if $i &gt; 20; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>You can also use
Tie::Cycle to use a scalar that always has the next element
of the circular array:</small></small></p>

<p style="margin-top: 1em"><small><small>use
Tie::Cycle;</small></small></p>

<p style="margin-top: 1em"><small><small>tie my $cycle,
&rsquo;Tie::Cycle&rsquo;, [ qw( FFFFFF 000000 FFFF00 )
];</small></small></p>

<p style="margin-top: 1em"><small><small>print $cycle; #
FFFFFF <br>
print $cycle; # 000000 <br>
print $cycle; # FFFF00</small></small></p>

<p style="margin-top: 1em"><small><small>The
Array::Iterator::Circular creates an iterator object for
circular arrays:</small></small></p>

<p style="margin-top: 1em"><small><small>use
Array::Iterator::Circular;</small></small></p>

<p style="margin-top: 1em"><small><small>my $color_iterator
= Array::Iterator::Circular-&gt;new( <br>
qw(red green blue orange) <br>
);</small></small></p>

<p style="margin-top: 1em"><small><small>foreach ( 1 .. 20
) { <br>
print $color_iterator-&gt;next, &quot;0; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>How do I shuffle
an array randomly? <br>
If you either have Perl 5.8.0 or later installed, or if you
have Scalar-List-Utils 1.03 or later installed, you can
say:</small></small></p>

<p style="margin-top: 1em"><small><small>use List::Util
&rsquo;shuffle&rsquo;;</small></small></p>

<p style="margin-top: 1em"><small><small>@shuffled =
shuffle(@list);</small></small></p>

<p style="margin-top: 1em"><small><small>If not, you can
use a Fisher-Yates shuffle.</small></small></p>

<p style="margin-top: 1em"><small><small>sub
fisher_yates_shuffle { <br>
my $deck = shift; # $deck is a reference to an array <br>
return unless @$deck; # must not be
empty!</small></small></p>

<p style="margin-top: 1em"><small><small>my $i = @$deck;
<br>
while (--$i) { <br>
my $j = int rand ($i+1); <br>
@$deck[$i,$j] = @$deck[$j,$i]; <br>
} <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small># shuffle my mpeg
collection <br>
# <br>
my @mpeg = &lt;audio/*/*.mp3&gt;; <br>
fisher_yates_shuffle( @mpeg ); # randomize @mpeg in place
<br>
print @mpeg;</small></small></p>

<p style="margin-top: 1em"><small><small>Note that the
above implementation shuffles an array in place, unlike the
&quot;List::Util::shuffle()&quot; which takes a list and
returns a new shuffled list.</small></small></p>

<p style="margin-top: 1em"><small><small>You&rsquo;ve
probably seen shuffling algorithms that work using splice,
randomly picking another element to swap the current element
with</small></small></p>

<p style="margin-top: 1em"><small><small>srand; <br>
@new = (); <br>
@old = 1 .. 10; # just a demo <br>
while (@old) { <br>
push(@new, splice(@old, rand @old, 1)); <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>This is bad
because splice is already O(N), and since you do it N times,
you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so <br>
efficient that you probably won&rsquo;t notice this until
you have rather largish arrays.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I
process/modify each element of an array? <br>
Use &quot;for&quot;/&quot;foreach&quot;:</small></small></p>

<p style="margin-top: 1em"><small><small>for (@lines) {
<br>
s/foo/bar/; # change that word <br>
tr/XZ/ZX/; # swap those letters <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Here&rsquo;s
another; let&rsquo;s compute spherical
volumes:</small></small></p>

<p style="margin-top: 1em"><small><small>my @volumes =
@radii; <br>
for (@volumes) { # @volumes has changed parts <br>
$_ **= 3; <br>
$_ *= (4/3) * 3.14159; # this will be constant folded <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>which can also be
done with &quot;map()&quot; which is made to transform one
list into another:</small></small></p>

<p style="margin-top: 1em"><small><small>my @volumes = map
{$_ ** 3 * (4/3) * 3.14159} @radii;</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to do
the same thing to modify the values of the hash, you can use
the &quot;values&quot; function. As of Perl 5.6 the values
are not copied, so if you modify $orbit (in this <br>
case), you modify the value.</small></small></p>

<p style="margin-top: 1em"><small><small>for my $orbit (
values %orbits ) { <br>
($orbit **= 3) *= (4/3) * 3.14159; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Prior to perl 5.6
&quot;values&quot; returned copies of the values, so older
perl code often contains constructions such as @orbits{keys
%orbits} instead of &quot;values %orbits&quot; where the
hash <br>
is to be modified.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I select a
random element from an array? <br>
Use the &quot;rand()&quot; function (see &quot;rand&quot; in
perlfunc):</small></small></p>

<p style="margin-top: 1em"><small><small>my $index = rand
@array; <br>
my $element = $array[$index];</small></small></p>

<p style="margin-top: 1em"><small><small>Or,
simply:</small></small></p>

<p style="margin-top: 1em"><small><small>my $element =
$array[ rand @array ];</small></small></p>

<p style="margin-top: 1em"><small><small>How do I permute N
elements of a list? <br>
Use the List::Permutor module on CPAN. If the list is
actually an array, try the Algorithm::Permute module (also
on CPAN). It&rsquo;s written in XS code and is very
efficient:</small></small></p>

<p style="margin-top: 1em"><small><small>use
Algorithm::Permute;</small></small></p>

<p style="margin-top: 1em"><small><small>my @array =
&rsquo;a&rsquo;..&rsquo;d&rsquo;; <br>
my $p_iterator = Algorithm::Permute-&gt;new ( @array
);</small></small></p>

<p style="margin-top: 1em"><small><small>while (my @perm =
$p_iterator-&gt;next) { <br>
print &quot;next permutation: (@perm)0; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>For even faster
execution, you could do:</small></small></p>

<p style="margin-top: 1em"><small><small>use
Algorithm::Permute;</small></small></p>

<p style="margin-top: 1em"><small><small>my @array =
&rsquo;a&rsquo;..&rsquo;d&rsquo;;</small></small></p>


<p style="margin-top: 1em"><small><small>Algorithm::Permute::permute
{ <br>
print &quot;next permutation: (@array)0; <br>
} @array;</small></small></p>

<p style="margin-top: 1em"><small><small>Here&rsquo;s a
little program that generates all permutations of all the
words on each line of input. The algorithm embodied in the
&quot;permute()&quot; function is discussed in Volume 4
(still <br>
unpublished) of Knuth&rsquo;s The Art of Computer
Programming and will work on any list:</small></small></p>

<p style="margin-top: 1em"><small><small>#!/usr/bin/perl -n
<br>
# Fischer-Krause ordered permutation
generator</small></small></p>

<p style="margin-top: 1em"><small><small>sub permute
(&amp;@) { <br>
my $code = shift; <br>
my @idx = 0..$#_; <br>
while ( $code-&gt;(@_[@idx]) ) { <br>
my $p = $#idx; <br>
--$p while $idx[$p-1] &gt; $idx[$p]; <br>
my $q = $p or return; <br>
push @idx, reverse splice @idx, $p; <br>
++$q while $idx[$p-1] &gt; $idx[$q]; <br>
@idx[$p-1,$q]=@idx[$q,$p-1]; <br>
} <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>permute { print
&quot;@_0 } split;</small></small></p>

<p style="margin-top: 1em"><small><small>The
Algorithm::Loops module also provides the
&quot;NextPermute&quot; and &quot;NextPermuteNum&quot;
functions which efficiently find all unique permutations of
an array, even if it contains <br>
duplicate values, modifying it in-place: if its elements are
in reverse-sorted order then the array is reversed, making
it sorted, and it returns false; otherwise the next <br>
permutation is returned.</small></small></p>


<p style="margin-top: 1em"><small><small>&quot;NextPermute&quot;
uses string order and &quot;NextPermuteNum&quot; numeric
order, so you can enumerate all the permutations of 0..9
like this:</small></small></p>

<p style="margin-top: 1em"><small><small>use
Algorithm::Loops qw(NextPermuteNum);</small></small></p>

<p style="margin-top: 1em"><small><small>my @list= 0..9;
<br>
do { print &quot;@list0 } while NextPermuteNum
@list;</small></small></p>

<p style="margin-top: 1em"><small><small>How do I sort an
array by (anything)? <br>
Supply a comparison function to sort() (described in
&quot;sort&quot; in perlfunc):</small></small></p>

<p style="margin-top: 1em"><small><small>@list = sort { $a
&lt;=&gt; $b } @list;</small></small></p>

<p style="margin-top: 1em"><small><small>The default sort
function is cmp, string comparison, which would sort
&quot;(1, 2, 10)&quot; into &quot;(1, 10, 2)&quot;.
&quot;&lt;=&gt;&quot;, used above, is the numerical
comparison operator.</small></small></p>

<p style="margin-top: 1em"><small><small>If you have a
complicated function needed to pull out the part you want to
sort on, then don&rsquo;t do it inside the sort function.
Pull it out first, because the sort BLOCK can be <br>
called many times for the same element. Here&rsquo;s an
example of how to pull out the first word after the first
number on each item, and then sort those words
case-insensitively.</small></small></p>

<p style="margin-top: 1em"><small><small>my @idx; <br>
for (@data) { <br>
my $item; <br>
($item) = /+()/; <br>
push @idx, uc($item); <br>
} <br>
my @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 ..
$#idx ];</small></small></p>

<p style="margin-top: 1em"><small><small>which could also
be written this way, using a trick that&rsquo;s come to be
known as the Schwartzian Transform:</small></small></p>

<p style="margin-top: 1em"><small><small>my @sorted = map {
$_-&gt;[0] } <br>
sort { $a-&gt;[1] cmp $b-&gt;[1] } <br>
map { [ $_, uc( (/+()/)[0]) ] } @data;</small></small></p>

<p style="margin-top: 1em"><small><small>If you need to
sort on several fields, the following paradigm is
useful.</small></small></p>

<p style="margin-top: 1em"><small><small>my @sorted = sort
{ <br>
field1($a) &lt;=&gt; field1($b) || <br>
field2($a) cmp field2($b) || <br>
field3($a) cmp field3($b) <br>
} @data;</small></small></p>

<p style="margin-top: 1em"><small><small>This can be
conveniently combined with precalculation of keys as given
above.</small></small></p>

<p style="margin-top: 1em"><small><small>See the sort
article in the &quot;Far More Than You Ever Wanted To
Know&quot; collection in
&lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; for
more about this approach.</small></small></p>

<p style="margin-top: 1em"><small><small>See also the
question later in perlfaq4 on sorting
hashes.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I
manipulate arrays of bits? <br>
Use &quot;pack()&quot; and &quot;unpack()&quot;, or else
&quot;vec()&quot; and the bitwise
operations.</small></small></p>

<p style="margin-top: 1em"><small><small>For example, you
don&rsquo;t have to store individual bits in an array (which
would mean that you&rsquo;re wasting a lot of space). To
convert an array of bits to a string, use &quot;vec()&quot;
to <br>
set the right bits. This sets $vec to have bit N set only if
$ints[N] was set:</small></small></p>

<p style="margin-top: 1em"><small><small>my @ints = (...);
# array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... ) <br>
my $vec = &rsquo;&rsquo;; <br>
foreach( 0 .. $#ints ) { <br>
vec($vec,$_,1) = 1 if $ints[$_]; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>The string $vec
only takes up as many bits as it needs. For instance, if you
had 16 entries in @ints, $vec only needs two bytes to store
them (not counting the scalar variable <br>
overhead).</small></small></p>

<p style="margin-top: 1em"><small><small>Here&rsquo;s how,
given a vector in $vec, you can get those bits into your
@ints array:</small></small></p>

<p style="margin-top: 1em"><small><small>sub bitvec_to_list
{ <br>
my $vec = shift; <br>
my @ints; <br>
# Find null-byte density then select best algorithm <br>
if ($vec =~ tr/ // / length $vec &gt; 0.95) { <br>
use integer; <br>
my $i;</small></small></p>

<p style="margin-top: 1em"><small><small># This method is
faster with mostly null-bytes <br>
while($vec =~ /[^ ]/g ) { <br>
$i = -9 + 8 * pos $vec; <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
push @ints, $i if vec($vec, ++$i, 1); <br>
} <br>
} <br>
else { <br>
# This method is a fast general algorithm <br>
use integer; <br>
my $bits = unpack &quot;b*&quot;, $vec; <br>
push @ints, 0 if $bits =~ s/^()// &amp;&amp; $1; <br>
push @ints, pos $bits while($bits =~ /1/g); <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>return @ints; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>This method gets
faster the more sparse the bit vector is. (Courtesy of Tim
Bunce and Winfried Koenig.)</small></small></p>

<p style="margin-top: 1em"><small><small>You can make the
while loop a lot shorter with this suggestion from Benjamin
Goldberg:</small></small></p>

<p style="margin-top: 1em"><small><small>while($vec =~ /[^
]+/g ) { <br>
push @ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
<br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Or use the CPAN
module Bit::Vector:</small></small></p>

<p style="margin-top: 1em"><small><small>my $vector =
Bit::Vector-&gt;new($num_of_bits); <br>
$vector-&gt;Index_List_Store(@ints); <br>
my @ints =
$vector-&gt;Index_List_Read();</small></small></p>

<p style="margin-top: 1em"><small><small>Bit::Vector
provides efficient methods for bit vector, sets of small
integers and &quot;big int&quot; math.</small></small></p>

<p style="margin-top: 1em"><small><small>Here&rsquo;s a
more extensive illustration using vec():</small></small></p>

<p style="margin-top: 1em"><small><small># vec demo <br>
my $vector = &quot;f&quot;; <br>
print &quot;Ilya&rsquo;s string \xff\x0f\xef\xfe represents
the number &quot;, <br>
unpack(&quot;N&quot;, $vector), &quot;0; <br>
my $is_set = vec($vector, 23, 1); <br>
print &quot;Its 23rd bit is &quot;, $is_set ?
&quot;set&quot; : &quot;clear&quot;, &quot;.0; <br>
pvec($vector);</small></small></p>

<p style="margin-top: 1em"><small><small>set_vec(1,1,1);
<br>
set_vec(3,1,1); <br>
set_vec(23,1,1);</small></small></p>

<p style="margin-top: 1em"><small><small>set_vec(3,1,3);
<br>
set_vec(3,2,3); <br>
set_vec(3,4,3); <br>
set_vec(3,4,7); <br>
set_vec(3,8,3); <br>
set_vec(3,8,7);</small></small></p>

<p style="margin-top: 1em"><small><small>set_vec(0,32,17);
<br>
set_vec(1,32,17);</small></small></p>

<p style="margin-top: 1em"><small><small>sub set_vec { <br>
my ($offset, $width, $value) = @_; <br>
my $vector = &rsquo;&rsquo;; <br>
vec($vector, $offset, $width) = $value; <br>
print &quot;offset=$offset width=$width value=$value0; <br>
pvec($vector); <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>sub pvec { <br>
my $vector = shift; <br>
my $bits = unpack(&quot;b*&quot;, $vector); <br>
my $i = 0; <br>
my $BASE = 8;</small></small></p>

<p style="margin-top: 1em"><small><small>print &quot;vector
length in bytes: &quot;, length($vector), &quot;0; <br>
@bytes = unpack(&quot;A8&quot; x length($vector), $bits);
<br>
print &quot;bits are: @bytes0; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Why does defined()
return true on empty arrays and hashes? <br>
The short story is that you should probably only use defined
on scalars or functions, not on aggregates (arrays and
hashes). See &quot;defined&quot; in perlfunc in the 5.004
release or <br>
later of Perl for more detail.</small></small></p>

<p style="margin-top: 1em"><small><small>Data: Hashes
(Associative Arrays) <br>
How do I process an entire hash? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>There are a couple
of ways that you can process an entire hash. You can get a
list of keys, then go through each key, or grab a one
key-value pair at a time.</small></small></p>

<p style="margin-top: 1em"><small><small>To go through all
of the keys, use the &quot;keys&quot; function. This
extracts all of the keys of the hash and gives them back to
you as a list. You can then get the value through the <br>
particular key you&rsquo;re processing:</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $key (
keys %hash ) { <br>
my $value = $hash{$key} <br>
... <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Once you have the
list of keys, you can process that list before you process
the hash elements. For instance, you can sort the keys so
you can process them in lexical order:</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $key (
sort keys %hash ) { <br>
my $value = $hash{$key} <br>
... <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Or, you might want
to only process some of the items. If you only want to deal
with the keys that start with &quot;text:&quot;, you can
select just those using
&quot;grep&quot;:</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $key (
grep /^text:/, keys %hash ) { <br>
my $value = $hash{$key} <br>
... <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>If the hash is
very large, you might not want to create a long list of
keys. To save some memory, you can grab one key-value pair
at a time using &quot;each()&quot;, which returns a pair
<br>
you haven&rsquo;t seen yet:</small></small></p>

<p style="margin-top: 1em"><small><small>while( my( $key,
$value ) = each( %hash ) ) { <br>
... <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>The
&quot;each&quot; operator returns the pairs in apparently
random order, so if ordering matters to you, you&rsquo;ll
have to stick with the &quot;keys&quot;
method.</small></small></p>

<p style="margin-top: 1em"><small><small>The
&quot;each()&quot; operator can be a bit tricky though. You
can&rsquo;t add or delete keys of the hash while
you&rsquo;re using it without possibly skipping or
re-processing some pairs after Perl <br>
internally rehashes all of the elements. Additionally, a
hash has only one iterator, so if you mix &quot;keys&quot;,
&quot;values&quot;, or &quot;each&quot; on the same hash,
you risk resetting the iterator <br>
and messing up your processing. See the &quot;each&quot;
entry in perlfunc for more details.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I merge two
hashes? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>Before you decide
to merge two hashes, you have to decide what to do if both
hashes contain keys that are the same and if you want to
leave the original hashes as they were.</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
preserve the original hashes, copy one hash (%hash1) to a
new hash (%new_hash), then add the keys from the other hash
(%hash2 to the new hash. Checking that the <br>
key already exists in %new_hash gives you a chance to decide
what to do with the duplicates:</small></small></p>

<p style="margin-top: 1em"><small><small>my %new_hash =
%hash1; # make a copy; leave %hash1
alone</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $key2 (
keys %hash2 ) { <br>
if( exists $new_hash{$key2} ) { <br>
warn &quot;Key [$key2] is in both hashes!&quot;; <br>
# handle the duplicate (perhaps only warning) <br>
... <br>
next; <br>
} <br>
else { <br>
$new_hash{$key2} = $hash2{$key2}; <br>
} <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>If you don&rsquo;t
want to create a new hash, you can still use this looping
technique; just change the %new_hash to
%hash1.</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $key2 (
keys %hash2 ) { <br>
if( exists $hash1{$key2} ) { <br>
warn &quot;Key [$key2] is in both hashes!&quot;; <br>
# handle the duplicate (perhaps only warning) <br>
... <br>
next; <br>
} <br>
else { <br>
$hash1{$key2} = $hash2{$key2}; <br>
} <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>If you don&rsquo;t
care that one hash overwrites keys and values from the
other, you could just use a hash slice to add one hash to
another. In this case, values from %hash2 replace <br>
values from %hash1 when they have keys in
common:</small></small></p>

<p style="margin-top: 1em"><small><small>@hash1{ keys
%hash2 } = values %hash2;</small></small></p>

<p style="margin-top: 1em"><small><small>What happens if I
add or remove keys from a hash while iterating over it? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>The easy answer is
&quot;Don&rsquo;t do that!&quot;</small></small></p>

<p style="margin-top: 1em"><small><small>If you iterate
through the hash with each(), you can delete the key most
recently returned without worrying about it. If you delete
or add other keys, the iterator may skip or <br>
double up on them since perl may rearrange the hash table.
See the entry for &quot;each()&quot; in
perlfunc.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I look up a
hash element by value? <br>
Create a reverse hash:</small></small></p>

<p style="margin-top: 1em"><small><small>my %by_value =
reverse %by_key; <br>
my $key = $by_value{$value};</small></small></p>

<p style="margin-top: 1em"><small><small>That&rsquo;s not
particularly efficient. It would be more space-efficient to
use:</small></small></p>

<p style="margin-top: 1em"><small><small>while (my ($key,
$value) = each %by_key) { <br>
$by_value{$value} = $key; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>If your hash could
have repeated values, the methods above will only find one
of the associated keys. This may or may not worry you. If it
does worry you, you can always reverse <br>
the hash into a hash of arrays instead:</small></small></p>

<p style="margin-top: 1em"><small><small>while (my ($key,
$value) = each %by_key) { <br>
push @{$key_list_by_value{$value}}, $key; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>How can I know how
many entries are in a hash? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>This is very
similar to &quot;How do I process an entire hash?&quot;,
also in perlfaq4, but a bit simpler in the common
cases.</small></small></p>

<p style="margin-top: 1em"><small><small>You can use the
&quot;keys()&quot; built-in function in scalar context to
find out have many entries you have in a
hash:</small></small></p>

<p style="margin-top: 1em"><small><small>my $key_count =
keys %hash; # must be scalar context!</small></small></p>

<p style="margin-top: 1em"><small><small>If you want to
find out how many entries have a defined value, that&rsquo;s
a bit different. You have to check each value. A
&quot;grep&quot; is handy:</small></small></p>

<p style="margin-top: 1em"><small><small>my
$defined_value_count = grep { defined } values
%hash;</small></small></p>

<p style="margin-top: 1em"><small><small>You can use that
same structure to count the entries any way that you like.
If you want the count of the keys with vowels in them, you
just test for that instead:</small></small></p>

<p style="margin-top: 1em"><small><small>my $vowel_count =
grep { /[aeiou]/ } keys %hash;</small></small></p>

<p style="margin-top: 1em"><small><small>The
&quot;grep&quot; in scalar context returns the count. If you
want the list of matching items, just use it in list context
instead:</small></small></p>

<p style="margin-top: 1em"><small><small>my @defined_values
= grep { defined } values %hash;</small></small></p>

<p style="margin-top: 1em"><small><small>The
&quot;keys()&quot; function also resets the iterator, which
means that you may see strange results if you use this
between uses of other hash operators such as
&quot;each()&quot;.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I sort a
hash (optionally by value instead of key)? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>To sort a hash,
start with the keys. In this example, we give the list of
keys to the sort function which then compares them
ASCIIbetically (which might be affected by your <br>
locale settings). The output list has the keys in
ASCIIbetical order. Once we have the keys, we can go through
them to create a report which lists the keys in ASCIIbetical
order.</small></small></p>

<p style="margin-top: 1em"><small><small>my @keys = sort {
$a cmp $b } keys %hash;</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $key (
@keys ) { <br>
printf &quot;%-20s %6d0, $key, $hash{$key}; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>We could get more
fancy in the &quot;sort()&quot; block though. Instead of
comparing the keys, we can compute a value with them and use
that value as the comparison.</small></small></p>

<p style="margin-top: 1em"><small><small>For instance, to
make our report order case-insensitive, we use
&quot;lc&quot; to lowercase the keys before comparing
them:</small></small></p>

<p style="margin-top: 1em"><small><small>my @keys = sort {
lc $a cmp lc $b } keys %hash;</small></small></p>

<p style="margin-top: 1em"><small><small>Note: if the
computation is expensive or the hash has many elements, you
may want to look at the Schwartzian Transform to cache the
computation results.</small></small></p>

<p style="margin-top: 1em"><small><small>If we want to sort
by the hash value instead, we use the hash key to look it
up. We still get out a list of keys, but this time they are
ordered by their value.</small></small></p>

<p style="margin-top: 1em"><small><small>my @keys = sort {
$hash{$a} &lt;=&gt; $hash{$b} } keys
%hash;</small></small></p>

<p style="margin-top: 1em"><small><small>From there we can
get more complex. If the hash values are the same, we can
provide a secondary sort on the hash
key.</small></small></p>

<p style="margin-top: 1em"><small><small>my @keys = sort {
<br>
$hash{$a} &lt;=&gt; $hash{$b} <br>
or <br>
&quot;&quot; cmp &quot;&quot; <br>
} keys %hash;</small></small></p>

<p style="margin-top: 1em"><small><small>How can I always
keep my hash sorted? <br>
You can look into using the &quot;DB_File&quot; module and
&quot;tie()&quot; using the $DB_BTREE hash bindings as
documented in &quot;In Memory Databases&quot; in DB_File.
The Tie::IxHash module from CPAN <br>
might also be instructive. Although this does keep your hash
sorted, you might not like the slowdown you suffer from the
tie interface. Are you sure you need to do this?
:)</small></small></p>

<p style="margin-top: 1em"><small><small>What&rsquo;s the
difference between &quot;delete&quot; and &quot;undef&quot;
with hashes? <br>
Hashes contain pairs of scalars: the first is the key, the
second is the value. The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, <br>
or reference. If a key $key is present in %hash,
&quot;exists($hash{$key})&quot; will return true. The value
for a given key can be &quot;undef&quot;, in which case
$hash{$key} will be &quot;undef&quot; while <br>
&quot;exists $hash{$key}&quot; will return true. This
corresponds to ($key, &quot;undef&quot;) being in the
hash.</small></small></p>

<p style="margin-top: 1em"><small><small>Pictures help...
Here&rsquo;s the %hash table:</small></small></p>

<p style="margin-top: 1em"><small><small>keys values <br>
+------+------+ <br>
| a | 3 | <br>
| x | 7 | <br>
| d | 0 | <br>
| e | 2 | <br>
+------+------+</small></small></p>

<p style="margin-top: 1em"><small><small>And these
conditions hold</small></small></p>


<p style="margin-top: 1em"><small><small>$hash{&rsquo;a&rsquo;}
is true <br>
$hash{&rsquo;d&rsquo;} is false <br>
defined $hash{&rsquo;d&rsquo;} is true <br>
defined $hash{&rsquo;a&rsquo;} is true <br>
exists $hash{&rsquo;a&rsquo;} is true (Perl 5 only) <br>
grep ($_ eq &rsquo;a&rsquo;, keys %hash) is
true</small></small></p>

<p style="margin-top: 1em"><small><small>If you now
say</small></small></p>

<p style="margin-top: 1em"><small><small>undef
$hash{&rsquo;a&rsquo;}</small></small></p>

<p style="margin-top: 1em"><small><small>your table now
reads:</small></small></p>

<p style="margin-top: 1em"><small><small>keys values <br>
+------+------+ <br>
| a | undef| <br>
| x | 7 | <br>
| d | 0 | <br>
| e | 2 | <br>
+------+------+</small></small></p>

<p style="margin-top: 1em"><small><small>and these
conditions now hold; changes in caps:</small></small></p>


<p style="margin-top: 1em"><small><small>$hash{&rsquo;a&rsquo;}
is FALSE <br>
$hash{&rsquo;d&rsquo;} is false <br>
defined $hash{&rsquo;d&rsquo;} is true <br>
defined $hash{&rsquo;a&rsquo;} is FALSE <br>
exists $hash{&rsquo;a&rsquo;} is true (Perl 5 only) <br>
grep ($_ eq &rsquo;a&rsquo;, keys %hash) is
true</small></small></p>

<p style="margin-top: 1em"><small><small>Notice the last
two: you have an undef value, but a defined
key!</small></small></p>

<p style="margin-top: 1em"><small><small>Now, consider
this:</small></small></p>

<p style="margin-top: 1em"><small><small>delete
$hash{&rsquo;a&rsquo;}</small></small></p>

<p style="margin-top: 1em"><small><small>your table now
reads:</small></small></p>

<p style="margin-top: 1em"><small><small>keys values <br>
+------+------+ <br>
| x | 7 | <br>
| d | 0 | <br>
| e | 2 | <br>
+------+------+</small></small></p>

<p style="margin-top: 1em"><small><small>and these
conditions now hold; changes in caps:</small></small></p>


<p style="margin-top: 1em"><small><small>$hash{&rsquo;a&rsquo;}
is false <br>
$hash{&rsquo;d&rsquo;} is false <br>
defined $hash{&rsquo;d&rsquo;} is true <br>
defined $hash{&rsquo;a&rsquo;} is false <br>
exists $hash{&rsquo;a&rsquo;} is FALSE (Perl 5 only) <br>
grep ($_ eq &rsquo;a&rsquo;, keys %hash) is
FALSE</small></small></p>

<p style="margin-top: 1em"><small><small>See, the whole
entry is gone!</small></small></p>

<p style="margin-top: 1em"><small><small>Why don&rsquo;t my
tied hashes make the defined/exists distinction? <br>
This depends on the tied hash&rsquo;s implementation of
EXISTS(). For example, there isn&rsquo;t the concept of
undef with hashes that are tied to DBM* files. It also means
that exists() <br>
and defined() do the same thing with a DBM* file, and what
they end up doing is not what they do with ordinary
hashes.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I reset an
each() operation part-way through? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>You can use the
&quot;keys&quot; or &quot;values&quot; functions to reset
&quot;each&quot;. To simply reset the iterator used by
&quot;each&quot; without doing anything else, use one of
them in void context:</small></small></p>

<p style="margin-top: 1em"><small><small>keys %hash; #
resets iterator, nothing else. <br>
values %hash; # resets iterator, nothing
else.</small></small></p>

<p style="margin-top: 1em"><small><small>See the
documentation for &quot;each&quot; in
perlfunc.</small></small></p>

<p style="margin-top: 1em"><small><small>How can I get the
unique keys from two hashes? <br>
First you extract the keys from the hashes into lists, then
solve the &quot;removing duplicates&quot; problem described
above. For example:</small></small></p>

<p style="margin-top: 1em"><small><small>my %seen = ();
<br>
for my $element (keys(%foo), keys(%bar)) { <br>
$seen{$element}++; <br>
} <br>
my @uniq = keys %seen;</small></small></p>

<p style="margin-top: 1em"><small><small>Or more
succinctly:</small></small></p>

<p style="margin-top: 1em"><small><small>my @uniq = keys
%{{%foo,%bar}};</small></small></p>

<p style="margin-top: 1em"><small><small>Or if you really
want to save space:</small></small></p>

<p style="margin-top: 1em"><small><small>my %seen = ();
<br>
while (defined ($key = each %foo)) { <br>
$seen{$key}++; <br>
} <br>
while (defined ($key = each %bar)) { <br>
$seen{$key}++; <br>
} <br>
my @uniq = keys %seen;</small></small></p>

<p style="margin-top: 1em"><small><small>How can I store a
multidimensional array in a DBM file? <br>
Either stringify the structure yourself (no fun), or else
get the MLDBM (which uses Data::Dumper) module from CPAN and
layer it on top of either DB_File or GDBM_File. You might
<br>
also try DBM::Deep, but it can be a bit
slow.</small></small></p>

<p style="margin-top: 1em"><small><small>How can I make my
hash remember the order I put elements into it? <br>
Use the Tie::IxHash from CPAN.</small></small></p>

<p style="margin-top: 1em"><small><small>use
Tie::IxHash;</small></small></p>

<p style="margin-top: 1em"><small><small>tie my %myhash,
&rsquo;Tie::IxHash&rsquo;;</small></small></p>

<p style="margin-top: 1em"><small><small>for (my $i=0;
$i&lt;20; $i++) { <br>
$myhash{$i} = 2*$i; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>my @keys = keys
%myhash; <br>
# @keys = (0,1,2,3,...)</small></small></p>

<p style="margin-top: 1em"><small><small>Why does passing a
subroutine an undefined element in a hash create it? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>Are you using a
really old version of Perl?</small></small></p>

<p style="margin-top: 1em"><small><small>Normally,
accessing a hash key&rsquo;s value for a nonexistent key
will not create the key.</small></small></p>

<p style="margin-top: 1em"><small><small>my %hash = ();
<br>
my $value = $hash{ &rsquo;foo&rsquo; }; <br>
print &quot;This won&rsquo;t print0 if exists $hash{
&rsquo;foo&rsquo; };</small></small></p>

<p style="margin-top: 1em"><small><small>Passing $hash{
&rsquo;foo&rsquo; } to a subroutine used to be a special
case, though. Since you could assign directly to $_[0], Perl
had to be ready to make that assignment so it created <br>
the hash key ahead of time:</small></small></p>

<p style="margin-top: 1em"><small><small>my_sub( $hash{
&rsquo;foo&rsquo; } ); <br>
print &quot;This will print before 5.0040 if exists $hash{
&rsquo;foo&rsquo; };</small></small></p>

<p style="margin-top: 1em"><small><small>sub my_sub { <br>
# $_[0] = &rsquo;bar&rsquo;; # create hash key in case you
do this <br>
1; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Since Perl 5.004,
however, this situation is a special case and Perl creates
the hash key only when you make the
assignment:</small></small></p>

<p style="margin-top: 1em"><small><small>my_sub( $hash{
&rsquo;foo&rsquo; } ); <br>
print &quot;This will print, even after 5.0040 if exists
$hash{ &rsquo;foo&rsquo; };</small></small></p>

<p style="margin-top: 1em"><small><small>sub my_sub { <br>
$_[0] = &rsquo;bar&rsquo;; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>However, if you
want the old behavior (and think carefully about that
because it&rsquo;s a weird side effect), you can pass a hash
slice instead. Perl 5.004 didn&rsquo;t make this a special
<br>
case:</small></small></p>

<p style="margin-top: 1em"><small><small>my_sub( @hash{
qw/foo/ } );</small></small></p>

<p style="margin-top: 1em"><small><small>How can I make the
Perl equivalent of a C structure/C++ class/hash or array of
hashes or arrays? <br>
Usually a hash ref, perhaps like this:</small></small></p>

<p style="margin-top: 1em"><small><small>$record = { <br>
NAME =&gt; &quot;Jason&quot;, <br>
EMPNO =&gt; 132, <br>
TITLE =&gt; &quot;deputy peon&quot;, <br>
AGE =&gt; 23, <br>
SALARY =&gt; 37_000, <br>
PALS =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;,
&quot;Phineas&quot;], <br>
};</small></small></p>

<p style="margin-top: 1em"><small><small>References are
documented in perlref and perlreftut. Examples of complex
data structures are given in perldsc and perllol. Examples
of structures and object-oriented classes are <br>
in perltoot.</small></small></p>

<p style="margin-top: 1em"><small><small>How can I use a
reference as a hash key? <br>
(contributed by brian d foy and Ben
Morrow)</small></small></p>

<p style="margin-top: 1em"><small><small>Hash keys are
strings, so you can&rsquo;t really use a reference as the
key. When you try to do that, perl turns the reference into
its stringified form (for instance, <br>
&quot;HASH(0xDEADBEEF)&quot;). From there you can&rsquo;t
get back the reference from the stringified form, at least
without doing some extra work on your
own.</small></small></p>

<p style="margin-top: 1em"><small><small>Remember that the
entry in the hash will still be there even if the referenced
variable goes out of scope, and that it is entirely possible
for Perl to subsequently allocate a <br>
different variable at the same address. This will mean a new
variable might accidentally be associated with the value for
an old.</small></small></p>

<p style="margin-top: 1em"><small><small>If you have Perl
5.10 or later, and you just want to store a value against
the reference for lookup later, you can use the core
Hash::Util::Fieldhash module. This will also <br>
handle renaming the keys if you use multiple threads (which
causes all variables to be reallocated at new addresses,
changing their stringification), and garbage-collecting the
<br>
entries when the referenced variable goes out of
scope.</small></small></p>

<p style="margin-top: 1em"><small><small>If you actually
need to be able to get a real reference back from each hash
entry, you can use the Tie::RefHash module, which does the
required work for you.</small></small></p>

<p style="margin-top: 1em"><small><small>How can I check if
a key exists in a multilevel hash? <br>
(contributed by brian d foy)</small></small></p>

<p style="margin-top: 1em"><small><small>The trick to this
problem is avoiding accidental autovivification. If you want
to check three keys deep, you might naievely try
this:</small></small></p>

<p style="margin-top: 1em"><small><small>my %hash; <br>
if( exists $hash{key1}{key2}{key3} ) { <br>
...; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>Even though you
started with a completely empty hash, after that call to
&quot;exists&quot; you&rsquo;ve created the structure you
needed to check for &quot;key3&quot;:</small></small></p>

<p style="margin-top: 1em"><small><small>%hash = ( <br>
&rsquo;key1&rsquo; =&gt; { <br>
&rsquo;key2&rsquo; =&gt; {} <br>
} <br>
);</small></small></p>

<p style="margin-top: 1em"><small><small>That&rsquo;s
autovivification. You can get around this in a few ways. The
easiest way is to just turn it off. The lexical
&quot;autovivification&quot; pragma is available on CPAN.
Now you don&rsquo;t <br>
add to the hash:</small></small></p>

<p style="margin-top: 1em"><small><small>{ <br>
no autovivification; <br>
my %hash; <br>
if( exists $hash{key1}{key2}{key3} ) { <br>
...; <br>
} <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>The Data::Diver
module on CPAN can do it for you too. Its &quot;Dive&quot;
subroutine can tell you not only if the keys exist but also
get the value:</small></small></p>

<p style="margin-top: 1em"><small><small>use Data::Diver
qw(Dive);</small></small></p>

<p style="margin-top: 1em"><small><small>my @exists = Dive(
hash, qw(key1 key2 key3) ); <br>
if( ! @exists ) { <br>
...; # keys do not exist <br>
} <br>
elsif( ! defined $exists[0] ) { <br>
...; # keys exist but value is undef <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>You can easily do
this yourself too by checking each level of the hash before
you move onto the next level. This is essentially what
Data::Diver does for you:</small></small></p>

<p style="margin-top: 1em"><small><small>if( check_hash(
hash, qw(key1 key2 key3) ) ) { <br>
...; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>sub check_hash {
<br>
my( $hash, @keys ) = @_;</small></small></p>

<p style="margin-top: 1em"><small><small>return unless
@keys;</small></small></p>

<p style="margin-top: 1em"><small><small>foreach my $key (
@keys ) { <br>
return unless eval { exists $hash-&gt;{$key} }; <br>
$hash = $hash-&gt;{$key}; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>return 1; <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>How can I prevent
addition of unwanted keys into a hash? <br>
Since version 5.8.0, hashes can be restricted to a fixed
number of given keys. Methods for creating and dealing with
restricted hashes are exported by the Hash::Util
module.</small></small></p>

<p style="margin-top: 1em"><small><small>Data: Misc <br>
How do I handle binary data correctly? <br>
Perl is binary-clean, so it can handle binary data just
fine. On Windows or DOS, however, you have to use
&quot;binmode&quot; for binary files to avoid conversions
for line endings. In <br>
general, you should use &quot;binmode&quot; any time you
want to work with binary data.</small></small></p>

<p style="margin-top: 1em"><small><small>Also see
&quot;binmode&quot; in perlfunc or
perlopentut.</small></small></p>

<p style="margin-top: 1em"><small><small>If you&rsquo;re
concerned about 8-bit textual data then see perllocale. If
you want to deal with multibyte characters, however, there
are some gotchas. See the section on Regular <br>
Expressions.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I determine
whether a scalar is a number/whole/integer/float? <br>
Assuming that you don&rsquo;t care about IEEE notations like
&quot;NaN&quot; or &quot;Infinity&quot;, you probably just
want to use a regular expression:</small></small></p>

<p style="margin-top: 1em"><small><small>use
5.010;</small></small></p>

<p style="margin-top: 1em"><small><small>given( $number ) {
<br>
when( / { say &quot;has nondigits&quot;; continue } <br>
when( /^+/) <br>
{ say &quot;is a whole number&quot;; continue } <br>
when( /^-?+/) <br>
{ say &quot;is an integer&quot;; continue } <br>
when( /^[+-]?+/) <br>
{ say &quot;is a +/- integer&quot;; continue } <br>
when( /^-?(?:+.?|.)*/) <br>
{ say &quot;is a real number&quot;; continue } <br>
when( /^[+-]?(?=.?)*.?*(?:e[+-]?+)?i) <br>
{ say &quot;is a C float&quot; } <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>There are also
some commonly used modules for the task. Scalar::Util
(distributed with 5.8) provides access to perl&rsquo;s
internal function &quot;looks_like_number&quot; for
determining <br>
whether a variable looks like a number. Data::Types exports
functions that validate data types using both the above and
other regular expressions. Thirdly, there is <br>
Regexp::Common which has regular expressions to match
various types of numbers. Those three modules are available
from the CPAN.</small></small></p>

<p style="margin-top: 1em"><small><small>If you&rsquo;re on
a POSIX system, Perl supports the &quot;POSIX::strtod&quot;
function for converting strings to doubles (and also
&quot;POSIX::strtol&quot; for longs). Its semantics are
somewhat <br>
cumbersome, so here&rsquo;s a &quot;getnum&quot; wrapper
function for more convenient access. This function takes a
string and returns the number it found, or &quot;undef&quot;
for input that isn&rsquo;t a C <br>
float. The &quot;is_numeric&quot; function is a front end to
&quot;getnum&quot; if you just want to say, &quot;Is this a
float?&quot;</small></small></p>

<p style="margin-top: 1em"><small><small>sub getnum { <br>
use POSIX qw(strtod); <br>
my $str = shift; <br>
$str =~ s/^/; <br>
$str =~ s/; <br>
$! = 0; <br>
my($num, $unparsed) = strtod($str); <br>
if (($str eq &rsquo;&rsquo;) || ($unparsed != 0) || $!) {
<br>
return undef; <br>
} <br>
else { <br>
return $num; <br>
} <br>
}</small></small></p>

<p style="margin-top: 1em"><small><small>sub is_numeric {
defined getnum($_[0]) }</small></small></p>

<p style="margin-top: 1em"><small><small>Or you could check
out the String::Scanf module on the CPAN
instead.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I keep
persistent data across program calls? <br>
For some specific applications, you can use one of the DBM
modules. See AnyDBM_File. More generically, you should
consult the FreezeThaw or Storable modules from CPAN.
Starting <br>
from Perl 5.8, Storable is part of the standard
distribution. Here&rsquo;s one example using
Storable&rsquo;s &quot;store&quot; and &quot;retrieve&quot;
functions:</small></small></p>

<p style="margin-top: 1em"><small><small>use Storable; <br>
store(hash, &quot;filename&quot;);</small></small></p>

<p style="margin-top: 1em"><small><small># later on... <br>
$href = retrieve(&quot;filename&quot;); # by ref <br>
%hash = %{ retrieve(&quot;filename&quot;) }; # direct to
hash</small></small></p>

<p style="margin-top: 1em"><small><small>How do I print out
or copy a recursive data structure? <br>
The Data::Dumper module on CPAN (or the 5.005 release of
Perl) is great for printing out data structures. The
Storable module on CPAN (or the 5.8 release of Perl),
provides a <br>
function called &quot;dclone&quot; that recursively copies
its argument.</small></small></p>

<p style="margin-top: 1em"><small><small>use Storable
qw(dclone); <br>
$r2 = dclone($r1);</small></small></p>

<p style="margin-top: 1em"><small><small>Where $r1 can be a
reference to any kind of data structure you&rsquo;d like. It
will be deeply copied. Because &quot;dclone&quot; takes and
returns references, you&rsquo;d have to add extra <br>
punctuation if you had a hash of arrays that you wanted to
copy.</small></small></p>

<p style="margin-top: 1em"><small><small>%newhash = %{
dclone(oldhash) };</small></small></p>

<p style="margin-top: 1em"><small><small>How do I define
methods for every class/object? <br>
(contributed by Ben Morrow)</small></small></p>

<p style="margin-top: 1em"><small><small>You can use the
&quot;UNIVERSAL&quot; class (see UNIVERSAL). However, please
be very careful to consider the consequences of doing this:
adding methods to every object is very likely to <br>
have unintended consequences. If possible, it would be
better to have all your object inherit from some common base
class, or to use an object system like Moose that supports
<br>
roles.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I verify a
credit card checksum? <br>
Get the Business::CreditCard module from
CPAN.</small></small></p>

<p style="margin-top: 1em"><small><small>How do I pack
arrays of doubles or floats for XS code? <br>
The arrays.h/arrays.c code in the PGPLOT module on CPAN does
just this. If you&rsquo;re doing a lot of float or double
processing, consider using the PDL module from CPAN
instead--it <br>
makes number-crunching easy.</small></small></p>

<p style="margin-top: 1em"><small><small>See
&lt;http://search.cpan.org/dist/PGPLOT&gt; for the
code.</small></small></p>

<p style="margin-top: 1em"><small><small>AUTHOR AND
COPYRIGHT <br>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington,
and other authors as noted. All rights
reserved.</small></small></p>

<p style="margin-top: 1em"><small><small>This documentation
is free; you can redistribute it and/or modify it under the
same terms as Perl itself.</small></small></p>

<p style="margin-top: 1em"><small><small>Irrespective of
its distribution, all code examples in this file are hereby
placed into the public domain. You are permitted and
encouraged to use this code in your own programs <br>
for fun or for profit as you see fit. A simple comment in
the code giving credit would be courteous but is not
required.</small></small></p>

<p style="margin-top: 1em"><small><small>perl v5.16.3
2013-03-04 PERLFAQ4(1)</small></small></p>
<hr>
</body>
</html>
