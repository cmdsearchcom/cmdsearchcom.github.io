<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:02:05 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DACSTOKEN(1) DACS Commands Manual DACSTOKEN(1)</p>

<p style="margin-top: 1em">NAME <br>
dacstoken - administer hash-based one-time passwords</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dacstoken [dacsoptions[1]] [-all] [-base num] [-counter num]
[-digits num] <br>
[-disable | -enable] [-hotp-window num] [-ignore-key-length]
<br>
[-inkeys item_type] [-issuer name] [[-key keyval] |
[-key-enc enc] | [-key-file filename] | [-key-prompt] <br>
] [-mode otp-mode] [-nl] [-outkeys item_type] [[-pin pinval]
| [-pin-file filename] | [-pin-prompt]] <br>
[-pin-constraints str] [-rnd] [-seed str] [-serial str]
[-totp-delta num] [-totp-drift nwindows] <br>
[-totp-hash alg] [-totp-time secs] [-totp-timestep secs]
[-vfs vfs_uri] [op-spec] [username]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This program is part of the DACS suite.</p>

<p style="margin-top: 1em">The dacstoken utility
administers DACS accounts associated with one-time password
(OTP) generating devices (tokens) or software-based clients.
Using command line options, it also <br>
computes OTP values; token account parameters can be
overridden, but accounts are not even required.</p>

<p style="margin-top: 1em">Strong, two-factor
authentication can be provided when dacs_authenticate[2] is
configured to use the local_token_authenticate[3]
authentication module or when dacstoken is used <br>
as a standalone program to validate passwords. Two kinds of
one-time password algorithms are supported: the HMAC-based
one-time password mode (HOTP), based on an event counter
<br>
and specified by RFC 4226[4], and the time-based one-time
password mode (TOTP), as specified by RFC 6238[5].
Additional operational modes called OCRA (OATH
Challenge-Response <br>
Algorithms), described in RFC 6287[6], are not yet fully
supported.</p>

<p style="margin-top: 1em">Note <br>
This version of dacstoken incorporates many changes that are
not backward compatible with release 1.4.24a and earlier.
Some command line flags function differently, and the <br>
format of the account file has changed. If you have used
this command in earlier releases, please make a backup copy
of your token account file and review this manual page <br>
carefully before proceeding (note the -convert flag[7] in
particular).</p>

<p style="margin-top: 1em">Important <br>
No vendor-supplied software is required by dacstoken to
supply its functionality. The devices currently supported do
not need any registration or configuration interaction <br>
with vendors and dacstoken does not interact with
vendors&rsquo; servers or use any proprietary software.
Vendor-supplied software may be required to perform
initialization or <br>
configuration for other token devices, however, and
dacstoken does not provide such support for them.</p>

<p style="margin-top: 1em">Each token device generally
corresponds to exactly one account that is managed by
dacstoken, although some vendors produce tokens that can
support multiple accounts.</p>

<p style="margin-top: 1em">To summarize, this utility:</p>

<p style="margin-top: 1em">&Acirc;&middot; creates and
administers DACS accounts associated with counter-based and
time-based one-time passwords</p>

<p style="margin-top: 1em">&Acirc;&middot; provides
validation and testing functionality</p>

<p style="margin-top: 1em">&Acirc;&middot; provides a
command line authentication capability</p>

<p style="margin-top: 1em">Security <br>
Only the DACS administrator should be able to successfully
run this program from the command line. Because DACS keys
and configuration files, including the file used to store
<br>
accounts, must be restricted to the administrator, this will
normally be the case, but a careful administrator will set
file permissions to deny access to all other users.</p>

<p style="margin-top: 1em">Note <br>
The dacs_token(8)[8] web service provides users with limited
self-service functionality to set or reset their account PIN
and synchronize their token. It also has a <br>
demonstration mode to simplify testing and evaluation.</p>

<p style="margin-top: 1em">PINs (Account Passwords) <br>
A dacstoken account can optionally have a PIN (i.e., a
password) associated with it. To authenticate against such
an account, a user must provide the one-time password
produced <br>
by the token and the PIN. The TOKEN_REQUIRES_PIN[9]
configuration directive determines whether a PIN must be
provided when creating or importing an account. By default,
a PIN is <br>
required. The directive does not apply in conjunction with
the -delpin flag, since only an administrator should be able
to perform that function.</p>

<p style="margin-top: 1em">A hash of the PIN is stored in
the account record. The PIN is not stored. The same method
used by dacspasswd(1)[10] and dacs_passwd(8)[11] is applied,
and depends on the <br>
PASSWORD_DIGEST[12] and PASSWORD_SALT_PREFIX[13] directives
in effect. If PASSWORD_DIGEST[12] is configured, that
algorithm is used, otherwise a compile-time default (SHA-1)
is <br>
used. If a user forgets the PIN, the old one cannot be
recovered so it must either be deleted or a new one must be
set.</p>

<p style="margin-top: 1em">Some token devices and client
software have a PIN feature. The user must enter a PIN into
the device before the device will emit a one-time password.
This &quot;device PIN&quot; is <br>
completely distinct from the account PIN (a server-side
password) that is managed by dacstoken, and this manual is
only concerned with the dacstoken PIN. The device PIN should
<br>
always be used when possible; the dacstoken PIN is strongly
recommended and is required for two-factor authentication
(unless an additional authentication factor is applied in
<br>
some other way).</p>

<p style="margin-top: 1em">Since only the administrator is
allowed to run this command, no restrictions are imposed on
the length or quality of the PINs that the administrator
supplies; a warning message <br>
will be emitted, however, if the password is considered to
be weak as determined by the PASSWORD_CONSTRAINTS[14]
directive.</p>

<p style="margin-top: 1em">One-Time Passwords (OTPs) <br>
Both kinds of one-time password device compute a password
value by employing a secure keyed hash algorithm (RFC
2104[15], FIPS 198[16]). In the counter-based method, the
device <br>
and server share a secret key and a counter value which are
hashed to yield a numerical value displayed in a certain
radix with a certain number of digits. Successful <br>
authentication requires the device and server to compute
matching passwords. Each time the device produces a
password, it increments its counter. When the server
receives a <br>
matching password, it increments its counter. Because it is
possible for the two counters to become unsynchronized, the
server&rsquo;s matching algorithm will typically allow a
<br>
client&rsquo;s password to fall within a &quot;window&quot;
of counter values. The time-based method is similar, the
main difference being that the current Unix time (as
returned by time(3)[17], <br>
for instance) is used to establish a &quot;time-step
window&quot; that serves as a counter value in the
computation of the secure hash. Because the real-time clocks
on the device and <br>
server may not be sufficiently synchronized, the
server&rsquo;s matching algorithm must also allow a
client&rsquo;s password to fall within some number of
time-step windows for these <br>
devices.</p>

<p style="margin-top: 1em">Security <br>
A token may be assigned a permanent secret key (sometimes
called an OTP seed) by its manufacturer or the key may be
programmable. This secret key is used by the token&rsquo;s
<br>
password generation procedure and it is critical that it be
kept private. If the token is not programmable, the key is
obtained from the vendor (for a HOTP token, typically <br>
by providing the device&rsquo;s serial number and any three
consecutive passwords). A record of each mapping from serial
number to secret key should be kept in a secure
location.</p>

<p style="margin-top: 1em">If the secret key is
programmable, as it is likely to be with a software client,
it is required to be at least 128 bits in length; a minimum
of 160 bits is recommended (see <br>
RFC 4226[4]) and by default the key is represented as a 16
(or more) character long hexadecimal string. The minimum
length requirement can be overridden by the <br>
-ignore-key-length flag, and the algorithm used to encode
the key can be specified using the -key-enc flag. The key
must be syntactically correct for the specified encoding
<br>
algorithm and should be obtained from a
cryptographic-quality source of random bits. Some clients
may be capable of generating a suitable key, but you may use
<br>
dacsexpr(1)[18]:</p>

<p style="margin-top: 1em">% dacsexpr -e
&quot;random(string, 20)&quot; <br>
&quot;bb2504780e8075a49bd88891b228fc7216ac18d9&quot;</p>

<p style="margin-top: 1em">Tip <br>
Tokens can be used for authentication purposes other than
computer sign on. For example, by providing an account
number, PIN, and token value, customers can quickly be <br>
authenticated over the phone, reducing or eliminating the
need for expensive and time-consuming security
questions.</p>

<p style="margin-top: 1em">One-time password devices and
applications have the following operational parameters.
These parameters determine the password sequence that is
generated. Some operational <br>
parameters may be fixed (by the relevant standard or due to
the implementation), while others may be partially or
completely configurable by the user. Please refer to the
<br>
references and manufacturers&rsquo; documentation for
details.</p>

<p style="margin-top: 1em">base <br>
The radix in which passwords are displayed.</p>

<p style="margin-top: 1em">counter <br>
For HOTP mode only, the current counter value.</p>

<p style="margin-top: 1em">digits <br>
The number of digits in each one-time password.</p>

<p style="margin-top: 1em">key <br>
The secret key (OTP seed).</p>

<p style="margin-top: 1em">serial number <br>
A unique identifier or name for the device.</p>

<p style="margin-top: 1em">time step size <br>
For TOTP mode only, the width of each time interval, in
seconds. The same password will be generated within a given
interval; i.e., this is the &quot;lifetime&quot; or validity
period <br>
of each TOTP password.</p>

<p style="margin-top: 1em">In addition to these parameters,
dacstoken employs several per-account (i.e., per-device)
parameters:</p>

<p style="margin-top: 1em">accept-window <br>
When validating a HOTP password, the maximum number of
passwords to consider after the expected password.</p>

<p style="margin-top: 1em">drift <br>
For TOTP mode only, the number of seconds by which to adjust
the server&rsquo;s clock forward or backward to better
synchronize it with the device. This is used to compensate
for <br>
tokens or client software whose clocks are not well
synchronized with the server&rsquo;s.</p>

<p style="margin-top: 1em">drift-window <br>
For TOTP mode only, but analogous to the accept-window, the
maximum number of intervals (each of the time step size) to
search forward and backward when validating against a <br>
given password.</p>

<p style="margin-top: 1em">sync-otps <br>
For HOTP mode only, the number of consecutive one-time
passwords required to synchronize the account with the
device.</p>

<p style="margin-top: 1em">username <br>
The name of the DACS account bound to the device.</p>

<p style="margin-top: 1em">Authentication based on one-time
password devices has the following advantages:</p>

<p style="margin-top: 1em">&Acirc;&middot; Each time a user
authenticates, a different password will be generated (with
high probability); users cannot therefore jot down &quot;the
password&quot; because the password is always <br>
changing; users cannot forget their password;</p>

<p style="margin-top: 1em">&Acirc;&middot; Once used, a
HOTP mode password is immediately &quot;consumed&quot; and
is unlikely to be used again for a long time; with suitable
configuration parameters, a TOTP mode password <br>
automatically &quot;expires&quot; within a relatively short
time interval and is unlikely to be used again for a long
time;</p>

<p style="margin-top: 1em">&Acirc;&middot; If no correction
for clock drift is required, a TOTP mode account can have
read-only operation;</p>

<p style="margin-top: 1em">&Acirc;&middot; Because the
password is unlikely to be an easily-guessed number or
string, it should be stronger than most user-selected
passwords;</p>

<p style="margin-top: 1em">&Acirc;&middot; A HOTP token can
be the basis of a mutual (&quot;bidirectional&quot;)
authentication method; the server shows the user his
token&rsquo;s next password to confirm its identity (with
both <br>
parties advancing their counters), then the client shows the
server the next password to confirm his identity;</p>

<p style="margin-top: 1em">&Acirc;&middot; Should a key
sniffer be installed on the user&rsquo;s computer, a sniffed
password does not do an attacker any good unless a
man-in-the-middle attack[19] is possible; given N <br>
consecutive passwords it is still very difficult to compute
password N + 1 without knowing the secret key;</p>

<p style="margin-top: 1em">&Acirc;&middot; It is more
difficult for users to share an account (although users
might sometimes view this as an inconvenience);</p>

<p style="margin-top: 1em">&Acirc;&middot; If a dacstoken
PIN is assigned to an account and an attacker obtains the
account&rsquo;s token, it is still difficult for the
attacker to authenticate without knowing the PIN;</p>

<p style="margin-top: 1em">&Acirc;&middot; A quick and
immediately effective way to disable an account is by simply
seizing a hardware token (e.g., if an employee is fired),
although an account can be disabled by this <br>
program or using the revocation list[20];</p>

<p style="margin-top: 1em">&Acirc;&middot; In the case of a
software client that runs on a mobile device, such as a
phone or PDA, users are already carrying the device with
them; free clients are available, so there <br>
may be no additional cost (note that mobile devices may not
offer the same tamper-resistance, durability, key secrecy,
clock accuracy, etc. of a hardware token).</p>

<p style="margin-top: 1em">One-time password devices have
the following potential disadvantages:</p>

<p style="margin-top: 1em">&Acirc;&middot; There is a
one-time expense for a hardware token (depending on the
purchase volume, you can expect to pay $10-$100 USD each),
and there is the possibility of having to <br>
replace a lost or broken token, or a token&rsquo;s battery
(some units have a non-replaceable battery, making them
disposable after a few years);</p>

<p style="margin-top: 1em">&Acirc;&middot; Initial
configuration is somewhat more difficult than with other
authentication methods, and users unfamiliar with the
devices will have to be instructed on their use;</p>

<p style="margin-top: 1em">&Acirc;&middot; Although they
are typically quite small (e.g., 5cm x 2cm x 1cm) and can be
attached to a keychain or lanyard, or kept in a wallet,
users may wince at having to carry a token <br>
around with them;</p>

<p style="margin-top: 1em">&Acirc;&middot; Users can forget
to have their token with them or lose the token;</p>

<p style="margin-top: 1em">&Acirc;&middot; A mobile device
(with a software client) is probably a likely target for
theft, more so than a hardware token (hence the extra
importance of a PIN for this device);</p>

<p style="margin-top: 1em">&Acirc;&middot; Unlike a
hardware token where the key is burned into inaccessible,
tamper-proof memory, the key configured into a software
client is likely to be readable by its owner, <br>
making sharing of the account possible;</p>

<p style="margin-top: 1em">&Acirc;&middot; Entering a 40
character or longer seed value into a mobile device can be
frustrating and prone to error;</p>

<p style="margin-top: 1em">&Acirc;&middot; Once a TOTP
device generates a password, a new password cannot be
generated until the next time-step window, requiring the
user to wait 30 (or possibly 60) seconds (e.g., if <br>
an entry error is made);</p>

<p style="margin-top: 1em">&Acirc;&middot; Some devices are
difficult to read in low-light conditions; presbyopic users
and those with impaired vision may have difficulty reading
the display.</p>

<p style="margin-top: 1em">Accounts <br>
The accounts managed by dacstoken are completely separate
from the accounts used by local_passwd_authenticate[21] or
any other DACS authentication module.</p>

<p style="margin-top: 1em">Accounts for HOTP and TOTP
devices may either be stored together or kept separate. If
the virtual filestore item type auth_hotp_token is defined,
it is only used for accounts <br>
associated with HOTP tokens. Similarly, if the virtual
filestore item type auth_totp_token is defined, it is only
used for accounts associated with TOTP tokens. If either
item <br>
type is not defined, accounts are accessed through
DACS&rsquo;s virtual filestore using item type auth_token.
It is assumed that file permissions on the account databases
are such that <br>
all access is limited to the administrator and
local_token_authenticate.</p>

<p style="margin-top: 1em">If accounts for the two device
types are combined, because each username for an
authentication method must be unique, if an individual has
both types of token they must be <br>
assigned different usernames. So, for example, if Auggie has
one HOTP token and one TOTP token, the former might
correspond to the username auggie-hotp and the latter to
<br>
auggie-totp; the sign-on form might include a device-mode
input which would allow Auggie to simply type
&quot;auggie&quot; in the username field and JavaScript to
automatically append the <br>
appropriate suffix based on the select device mode. An
obvious disadvantage of this configuration is that it
results in two different DACS identities for the same
individual; <br>
this would have to be remembered if an access control rule
needed to identify Auggie explicitly. If both tokens should
map to the same DACS identity, the Auth clause could strip
<br>
the suffix off after successful authentication, but the
administrator would then need to beware of the case of two
different Auggies, each using a different device type.</p>

<p style="margin-top: 1em">Configuring both the
auth_hotp_token and auth_totp_token item types (or just one
of them and auth_token) keeps the accounts separate and
allows the same username to be used for <br>
both types of devices. Auggie could therefore have an
account record with the same username for both device types.
This approach requires the device mode to be specified when
an <br>
operation is requested so that the correct item type can be
used; this means that users must know which type of device
they are using (perhaps by afixing a label to it). Refer to
<br>
important details regarding DACS identities[22].</p>

<p style="margin-top: 1em">The -vfs can be used to
configure or reconfigure the item types.</p>

<p style="margin-top: 1em">Multiple instances of each item
type can exist, provided the appropriate one for dacstoken
to use can be determined at run time and specified through a
VFS[23] directive or -vfs <br>
flag.</p>

<p style="margin-top: 1em">Only keys that meet the minimum
key length requirement (16 bytes) may be stored with account
information (e.g., with -set or -import). In other contexts,
the requirement is not <br>
enforced.</p>

<p style="margin-top: 1em">The secret key is always
encrypted and converted to a base-64 representation when it
is stored in the account file by dacstoken. The virtual
filestore item type auth_token_keys <br>
identifies the encryption keys for dacstoken to use; the
-inkeys and -outkeys flags specify alternatives (see
dacskey(1)[24]). If the encryption keys are lost, the secret
keys <br>
are practically unrecoverable.</p>

<p style="margin-top: 1em">Important <br>
If an attacker discovers a secret key, generating usable
passwords without possessing the token will not be
difficult. For at least some hardware tokens, the key is
burned in <br>
to the device and cannot be changed; in this case, if the
key is leaked the device should be destroyed. If a token is
lost, the corresponding account should be disabled. In <br>
the event an attacker finds a lost token or discovers a
secret key, having a strong PIN associated with the account
will make it difficult for the attacker to gain access.</p>

<p style="margin-top: 1em">Important <br>
&Acirc;&middot; This authentication method has been tested
against the following OTP products:</p>

<p style="margin-top: 1em">&Acirc;&middot; Authenex A-Key
3600[25] one-time password (HOTP) hardware token;</p>

<p style="margin-top: 1em">&Acirc;&middot; Feitian
Technologies[26] OTP C100 and OTP C200 one-time password
hardware tokens, provided by HyperSecu Information
Systems[27]; and</p>

<p style="margin-top: 1em">&Acirc;&middot; Google
Authenticator[28].</p>

<p style="margin-top: 1em">&Acirc;&middot; The open
source[29] FreeOTP Authenticator[30] by Red Hat[31], which
is available for a variety of platforms.</p>

<p style="margin-top: 1em">&Acirc;&middot; OATH Token[32]
software application by Archie Cobbs, which implements both
HOTP and TOTP on the iPod Touch, iPhone, and iPad[33].</p>

<p style="margin-top: 1em">&Acirc;&middot; The OTP Auth[34]
software application for the iPod Touch, iPhone, and iPad by
Roland Moers.</p>

<p style="margin-top: 1em">There are many other free
software implementations. Other manufacturers interested in
having their products supported by DACS are welcome to
contact[35] Dss.</p>

<p style="margin-top: 1em">&Acirc;&middot; Photo[36]:
Feitian OTP C200, iPod Touch with the OATH Token app,
Authenex A-Key 3600 (clockwise from top left)</p>

<p style="margin-top: 1em">&Acirc;&middot; Although this
implementation should work with similar, conformant
products, only these products are officially supported by
DACS.</p>

<p style="margin-top: 1em">&Acirc;&middot; Hardware tokens
can be purchased directly from the vendors.</p>

<p style="margin-top: 1em">&Acirc;&middot; Any problems
with using tokens to authenticate through DACS are not the
responsibility of the token vendor.</p>

<p style="margin-top: 1em">Importing and Exporting OTP
Accounts <br>
Descriptions of accounts and their tokens can be loaded or
dumped (refer to the -import and -export flags). This
simplifies provisioning, backup, and portability. The
account <br>
information can be written in a simple, application-specific
(almost) XML format, or Google&rsquo;s KeyUriFormat[37],
which is understood by several OTP applications.</p>

<p style="margin-top: 1em">The -format flag (see
dacsoptions[38]) can be used to select the xml format (the
default) or the uri format for export.</p>

<p style="margin-top: 1em">Note <br>
At present, the uri format cannot be imported by
dacstoken.</p>

<p style="margin-top: 1em">Security <br>
Because imported records include the unencrypted secret keys
for the OTP devices, the exported file should be kept
encrypted (e.g., using openssl) or at least have <br>
appropriate file permissions.</p>

<p style="margin-top: 1em">Note <br>
An official standard format for OTP device provisioning is
being developed. This format may be understood by a future
version of dacstoken, or a conversion utility may be <br>
written. The standard format is likely to be considerably
more complex than the DACS format.</p>

<p style="margin-top: 1em">XML Provisioning Format <br>
The XML format understood by dacstoken consists of a root
element (&quot;otp_tokens&quot;), followed by zero or more
&quot;otp_token&quot; elements, one per line, each with
required and optional <br>
attributes (described below). The XML declaration must be
omitted. Leading whitespace and blank lines are ignored, as
are single line XML comments. Additionally, lines having
<br>
a &quot;#&quot; as the first non-whitespace character are
ignored. Optional attributes that are not present are
assigned default values. The default digest algorithm is
SHA-1. Short <br>
attribute names are used to save space. Unrecognized
attributes, and attributes irrelevant to the device mode,
are ignored. Single or double quote characters (or both)
within <br>
XML attribute values must be replaced by the corresponding
entity reference (&quot;&amp;apos;&quot; and
&quot;&amp;quot;&quot;, respectively), as must the
&quot;&lt;&quot; (less than) and &quot;&amp;&quot;
(ampersand) characters. <br>
A &quot;&gt;&quot; (greater than) character may optionally
be replaced by a &quot;&amp;gt;&quot; sequence, but no other
entity references are recognized.</p>

<p style="margin-top: 1em">Recognized attributes are:</p>

<p style="margin-top: 1em">&Acirc;&middot; b: <br>
base <br>
-- radix for OTP value <br>
[Optional: <br>
10 (default), <br>
16, or 32]</p>

<p style="margin-top: 1em">&Acirc;&middot; c: <br>
counter <br>
-- current counter value for HOTP, in hex if preceded <br>
by &quot;0x&quot; (or &quot;0X&quot;), decimal otherwise
<br>
[Optional: <br>
default is 0]</p>

<p style="margin-top: 1em">&Acirc;&middot; d: <br>
OTP device mode <br>
-- &quot;c&quot; (for HOTP) <br>
or &quot;t&quot; (for TOTP) <br>
[Required]</p>

<p style="margin-top: 1em">&Acirc;&middot; dn: <br>
digest-name <br>
-- one of the Secure Hash Algorithms <br>
[Optional: <br>
SHA-1 (default), <br>
SHA224, SHA256, <br>
SHA384, SHA512]</p>

<p style="margin-top: 1em">&Acirc;&middot; dr: <br>
clock-drift <br>
-- clock adjustment, in seconds, for TOTP <br>
[Optional]</p>

<p style="margin-top: 1em">&Acirc;&middot; ek: <br>
encrypted-key <br>
-- encrypted secret key, base-64 encoded <br>
[Required: <br>
OTP account records only]</p>

<p style="margin-top: 1em">&Acirc;&middot; en: <br>
enabled-status <br>
-- 1 for enabled, <br>
0 for disabled <br>
[Required]</p>

<p style="margin-top: 1em">&Acirc;&middot; k: <br>
plaintext-key <br>
-- unencrypted secret key <br>
[Required]</p>

<p style="margin-top: 1em">&Acirc;&middot; lu: <br>
last-update <br>
-- Unix time of last record update <br>
[Optional: default is current time]</p>

<p style="margin-top: 1em">&Acirc;&middot; nd: <br>
ndigits <br>
-- number of digits for OTP value <br>
[Optional: <br>
default is 6 for HOTP, <br>
8 for TOTP]</p>

<p style="margin-top: 1em">&Acirc;&middot; p: <br>
plaintext-PIN <br>
-- plaintext PIN value for the account <br>
[Required: <br>
unless ph is present, <br>
for import only]</p>

<p style="margin-top: 1em">&Acirc;&middot; ph: <br>
hashed-PIN <br>
-- hashed PIN value for the account <br>
[Optional: <br>
generated by dacstoken <br>
for export and OTP account files only]</p>

<p style="margin-top: 1em">&Acirc;&middot; s: <br>
serial-number <br>
-- unique identifier string for the device <br>
[Required]</p>

<p style="margin-top: 1em">&Acirc;&middot; ts: <br>
time-step <br>
-- time-step value, in seconds, for TOTP <br>
[Optional: <br>
default is 30]</p>

<p style="margin-top: 1em">&Acirc;&middot; u: <br>
username <br>
-- a valid DACS username associated with this account <br>
[Required]</p>

<p style="margin-top: 1em">The following example describes
two accounts that might be created using the -import
flag:</p>

<p style="margin-top: 1em">&lt;otp_tokens&gt; <br>
&lt;!-- Staff OTP tokens for DACS authentication --&gt; <br>
&lt;otp_token u=&quot;ietf&quot; d=&quot;t&quot;
en=&quot;1&quot; s=&quot;totp-ietf
&amp;quot;draft&amp;quot;&quot;
k=&quot;3132333435363738393031323334353637383930&quot;
dn=&quot;SHA1&quot; ts=&quot;30&quot;/&gt; <br>
&lt;otp_token u=&quot;ipod-c&quot; d=&quot;c&quot;
en=&quot;1&quot; s=&quot;ipodc-9C841SD4203&quot;
k=&quot;19c0a3519a89b4a8034c5b9306db&quot;
dn=&quot;SHA1&quot; c=&quot;0&quot; nd=&quot;6&quot;
b=&quot;10&quot;/&gt; <br>
&lt;/otp_tokens&gt;</p>

<p style="margin-top: 1em">KeyUriFormat Provisioning Format
<br>
The KeyUriFormat[37] provisioning format is supported by
several OTP clients, such as FreeOTP[30] and Google
Authenticator[28]. In this format, a URI describes the
current <br>
state of an account. The URI can be encoded into a QR
Code[39] image (a two-dimensional barcode), which these and
other OTP clients can recognize and conveniently and <br>
correctly import using a device&rsquo;s camera. Also,
software such as zbarimg, a component of the ZBar[40] suite,
can scan and decode barcodes that it finds in image
files.</p>

<p style="margin-top: 1em">An account can be created by
dacstoken, exported as a KeyUriFormat URI, converted to a QR
Code image, sent to a user (e.g., via email or an IM) or
displayed on a secure web <br>
page, and finally imported by a user&rsquo;s client
software. A QR Code generator that has been successfully
used for this purpose with the iPhone is qrencode, which is
distributed <br>
with the libqrencode library[41].</p>

<p style="margin-top: 1em">Notes <br>
&Acirc;&middot; Depending on QR Code generation parameters,
there is a limit to the length of the KeyUriFormat that can
be encoded. The maximum URI length is likely to be around
<br>
2,953 characters.</p>

<p style="margin-top: 1em">&Acirc;&middot; The secret query
parameter (the OTP seed) is base-32 encoded[42] without
padding.</p>

<p style="margin-top: 1em">&Acirc;&middot; A newline should
not be encoded in the barcode.</p>

<p style="margin-top: 1em">&Acirc;&middot; The -issuer flag
can be used to specify the name of the token issuer.</p>

<p style="margin-top: 1em">&Acirc;&middot; A QR barcode can
be easily copied by an attacker for reuse.</p>

<p style="margin-top: 1em">OPTIONS <br>
In addition to the standard dacsoptions[1], a lengthy list
of command line flags are recognized. When a username is
given, default values associated with that account are used,
<br>
otherwise recommended or implementation-specific defaults
are used. These default values can usually be overridden on
the command line. Some flags are only allowed with a <br>
particular token mode (e.g., -counter, -totp-show) and their
appearance implies that mode, making the -mode flag
unnecessary; other flags are mode independent (e.g.,
-delete, <br>
-enable). It is an error to use a mutually incompatible flag
combination. Flags that are meaningless with the selected
operation are ignored, although they still imply a mode.
<br>
Hexadecimal values are case insensitive. If a counter value
is required but unspecified (e.g., when creating an
account), an initial counter value of zero is used.</p>

<p style="margin-top: 1em">The op-spec specifies the
operation to be performed, together with zero or more
modifier flags. If op-spec is missing, the -list operation
is performed. An op-spec is one of the <br>
following:</p>

<p style="margin-top: 1em">-auth otp-value <br>
This flag is like -validate[43], except:</p>

<p style="margin-top: 1em">&Acirc;&middot; a username is
required, from which all parameters are obtained (such as
the key);</p>

<p style="margin-top: 1em">&Acirc;&middot; if the account
has a PIN, it must be provided;</p>

<p style="margin-top: 1em">&Acirc;&middot; if the account
is for a HOTP token, the counter will be updated if
authentication is successful.</p>

<p style="margin-top: 1em">An exit status of zero indicates
successful authentication, while any other value means
authentication failed.</p>

<p style="margin-top: 1em">-convert filename <br>
Load an older format (prior to release 1.4.25) token account
file from filename (&quot;-&quot; means to read from stdin),
convert it to the newer format, and write it to stdout (as
by <br>
-export). This flag is deprecated and this capability will
be removed in a future release of DACS.</p>

<p style="margin-top: 1em">-create <br>
Create an account for username, which must not already
exist. In other respects it works like -set[44]. When
creating a new account, -serial is required and -key is
implied. <br>
If no -enable flag is provided when creating an account,
-disable is implied. If no -counter flag is provided, a
default of zero is used. If one of the PIN flags is present,
<br>
the given PIN will be assigned to the account, otherwise the
account will not have a PIN (or the existing PIN will not be
changed).</p>

<p style="margin-top: 1em">-current <br>
Display the current moving factor (i.e., the counter value
for HOTP or the interval value for TOTP) and expected OTP
for username. For HOTP, the counter is advanced. All <br>
parameters are taken from the account.</p>

<p style="margin-top: 1em">-delete <br>
Delete the account for username. The device&rsquo;s secret
key and other operational parameters will be lost.</p>

<p style="margin-top: 1em">-delpin <br>
Delete the PIN, if present, on the account for username,
leaving the account without a PIN.</p>

<p style="margin-top: 1em">-export <br>
Write information about all accounts, or only one account if
username is given, to stdout. If a mode is selected,
however, only accounts having that mode will be written.
<br>
This information may be reloaded using -import or
-import-replace. The output should be stored in an encrypted
form, or at the very least have its file permissions set
<br>
appropriately. For example:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -export
| openssl enc -aes-256-cbc &gt; dacstoken-exported.enc</p>

<p style="margin-top: 1em">Later, you might do something
like:</p>

<p style="margin-top: 1em">% openssl enc -d -aes-256-cbc
&lt; dacstoken-exported.enc | dacstoken -uj EXAMPLE -import
-</p>

<p style="margin-top: 1em">-h <br>
-help <br>
Display a help message and exit.</p>

<p style="margin-top: 1em">-hotp-show num <br>
Display num consecutive HOTP passwords from a given counter
value and key. The -counter flag can be used to specify an
initial counter value. The key can be specified using <br>
-key, -key-file, or -key-prompt. If a username is provided,
the initial counter value and key are obtained from the
user&rsquo;s HOTP account, unless either value is overridden
on <br>
the command line; the account&rsquo;s stored counter value
is not modified. This is mainly intended for debugging
purposes.</p>

<p style="margin-top: 1em">-import filename <br>
-import-replace filename <br>
Load account and token information from filename; if
filename is &quot;-&quot;, stdin is read. If a mode is
selected, only accounts having that mode will be read. With
-import it is an <br>
error if an imported account already exists, and processing
stops; -import-replace will replace an existing account with
imported data.</p>

<p style="margin-top: 1em">-issuer name <br>
Use the string name as the token issuer when exporting an
account in KeyUriFormat format.</p>

<p style="margin-top: 1em">-l <br>
-list <br>
-L <br>
-long <br>
If username is provided, list the corresponding account (it
is an error if the account does not exist). Otherwise, if
the -serial flag is given, list the account with the <br>
specified serial number. If neither argument is given, list
all accounts having the mode specified by the -mode flag, or
if -mode is absent, all accounts. If -l <br>
(equivalently, -list) is repeated, or with the -long flag
(equivalently, -L), more detail is displayed for each
account:</p>

<p style="margin-top: 1em">&Acirc;&middot; account
name,.RE</p>

<p style="margin-top: 1em">&Acirc;&middot; device type
(mode of operation),.RE</p>

<p style="margin-top: 1em">&Acirc;&middot; account
status,.RE</p>

<p style="margin-top: 1em">&Acirc;&middot; device serial
number,.RE</p>

<p style="margin-top: 1em">&Acirc;&middot; counter value
(for HOTP),.RE</p>

<p style="margin-top: 1em">&Acirc;&middot; clock drift
value (for TOTP),.RE</p>

<p style="margin-top: 1em">&Acirc;&middot; whether or not
the account has a PIN (indicated by a &quot;+&quot; or
&quot;-&quot; symbol), and</p>

<p style="margin-top: 1em">&Acirc;&middot; the time and
date of the account&rsquo;s last modification..RE</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -long
<br>

bobo,hotp,disabled,&quot;foo17&quot;,000000000000000a,-PIN,10-Sep-2014@10:57:20
<br>

auggie,totp,enabled,&quot;c200-2009234172055&quot;,0,-PIN,20-May-2010@14:20:01
<br>
% dacstoken -uj EXAMPLE -mode hotp -L <br>

bobo,hotp,disabled,&quot;foo17&quot;,000000000000000a,-PIN,10-Sep-2014@10:57:20</p>

<p style="margin-top: 1em">-rename new-username <br>
Rename the existing account for username to be new-username,
and modify the new account using command line arguments (as
with -set[44]). As this <br>
requires two steps that are not done atomically, if an error
occurs it is possible for the new account to be created and
the old account to still <br>
exist.</p>

<p style="margin-top: 1em">-set <br>
The -set flag is used to modify the existing account for
username based on one or more modifier arguments (-base,
-counter, -digits, -disable or <br>
-enable, -key (or -key-file or -key-prompt), -pin (or
-pin-file or -pin-prompt), or -serial). The mode can also be
changed by specifying -mode, <br>
but mode-specific parameters associated with the account
will be lost (e.g., the current counter value will be
deleted if a HOTP account is <br>
changed to a TOTP account) and general parameters (such as
the serial number) will be retained unless overridden on the
command line.</p>

<p style="margin-top: 1em">-sync password-list <br>
In HOTP mode, this attempts to synchronize the server with
the token for username. The password-list is a
comma-separated list of three successive <br>
passwords produced by the user&rsquo;s token (this
&quot;auto-synchronize&quot; function is also available
through local_token_authenticate[3]). The given <br>
sequence must match the computed sequence exactly, given the
operational parameters in effect; e.g., leading zeroes are
significant, as is the <br>
display radix and number of OTP digits in effect. If
synchronization is successful, the user should be able to
authenticate using the next <br>
password produced by the device. An exhaustive search
algorithm using increasing counter values is employed, with
a compile-time limit on the <br>
maximum number of computations. The search begins at the
server&rsquo;s currently stored counter value, unless one is
provided using -counter. If <br>
unsuccessful, this operation could take a long time before
it terminates; the user must contact an administrator for
assistance.</p>

<p style="margin-top: 1em">In TOTP mode, attempt to
determine how closely synchronized the system clock is with
the token&rsquo;s clock and display the result. This
information <br>
can be used to update the user&rsquo;s token record to
compensate for poorly synchronized clocks, or to adjust
validation parameters. The token&rsquo;s key <br>
and the name of the digest algorithm are obtained for the
token record belonging to username, if it is given;
otherwise the key is prompted for <br>
and the digest algorithm to use is either obtained from the
command line or the default. Only the first password in
password-list is used. The <br>
-totp-timestep, -digits, and -totp-base options are
effective during this operation.</p>

<p style="margin-top: 1em">-test <br>
Perform some self-tests, then exit. A non-zero exit status
means an error occurred.</p>

<p style="margin-top: 1em">-totp-show num <br>
Display a sequence of TOTP passwords using the parameters
currently in effect: interval size (-totp-timestep), number
of digits (-digits), and <br>
base (-base). The account&rsquo;s stored parameters are not
modified. This is mainly intended for debugging
purposes.</p>

<p style="margin-top: 1em">If a username is provided (it
must be associated with a TOTP device), the key and other
stored parameters from the account are used unless <br>
overridden by command line flags. The sequence of passwords
for num intervals before and after the current time,
together with the password for <br>
the current time are printed.</p>

<p style="margin-top: 1em">If no username is given, the
program prompts for the key (which is echoed) if none has
been provided, and uses command line flags or default <br>
values for parameters. It then emits the TOTP password for
the current time each time Return/Enter is pressed; typing
EOF causes immediate <br>
termination. If num is zero, however, the program does not
wait for user input and prints only one password.</p>

<p style="margin-top: 1em">-validate otp-value <br>
If otp-value is the next expected one-time password, return
an exit status of zero to indicate success; any other value
indicates failure. If <br>
username is given, parameters for validation, including the
key, are obtained from that account unless overridden on the
command line. The <br>
server&rsquo;s state is not changed; e.g., a HOTP counter is
not advanced. If no username is given, the -mode flag must
be used and the parameters <br>
required for that mode must be given, including a key. For
HOTP mode, a counter value must be provided. For TOTP mode,
command line parameters are <br>
effective during this validation. dacstoken will test
whether otp-value validates against the parameters in
effect.</p>

<p style="margin-top: 1em">The following modifier flags are
understood:</p>

<p style="margin-top: 1em">-all <br>
With -set and no username, apply the changes to all
accounts. This can be used to enable or disable all
accounts, for example. The -inkeys and <br>
-outkeys flags are honoured. If an error occurs processing
stops immediately, in which case only some accounts may have
been modified.</p>

<p style="margin-top: 1em">-base num <br>
Use num as the base (radix) when displaying an OTP. The
value of num is restricted to 10 (the default), 16, or
32.</p>

<p style="margin-top: 1em">-counter num <br>
This is the 8-byte HOTP counter value to set, expressed as a
hex value if preceded by by &quot;0x&quot; (or
&quot;0X&quot;), decimal otherwise. Leading zeroes may be
<br>
elided. This implies HOTP mode. For token devices, it should
not be possible to reset a counter (modulo counter overflow)
because that will result <br>
in the password sequence being repeated, assuming that the
key is not changed; software implementations might not have
this restriction, however, <br>
so beware of the security implications.</p>

<p style="margin-top: 1em">-digits num <br>
Use num digits when displaying an OTP. The value of num is
restricted to 6, 7, 8 (the default), or 9 with base 10. It
is restricted to 6 with base <br>
32 and is ignored with base 16 (hex output).</p>

<p style="margin-top: 1em">-disable <br>
Disable the account for username. The
local_token_authenticate module, and -auth and -validate
flags, will not allow the user to authenticate <br>
until the account has been enabled, although other
operations may still be performed on the account. If -enable
is subsequently used, the account <br>
will become usable for authentication and is restored to its
state at the time it was disabled. It is not an error to
disable an already disabled <br>
account.</p>

<p style="margin-top: 1em">-enable <br>
Enable the account for username. The
local_token_authenticate module will allow the user to
authenticate. It is not an error to enable an already <br>
enabled account.</p>

<p style="margin-top: 1em">-hotp-window num <br>
If the expected HOTP password does not match the given
password, try to match up to num passwords after the
expected password in the sequence. A <br>
value of zero for num disables this search.</p>

<p style="margin-top: 1em">-ignore-key-length <br>
Do not enforce the minimum key length requirement (in bytes,
applied to the decoded keyval string argument specified by
-key).</p>

<p style="margin-top: 1em">-inkeys item_type <br>
For decrypting secret keys, use the store identified by
item_type, presumably configured in dacs.conf.</p>

<p style="margin-top: 1em">-key keyval <br>
Use keyval as the secret key, expressed as a hex digit
string by default (see -key-enc).</p>

<p style="margin-top: 1em">Security <br>
Supplying a key on the command line is not secure because it
may be visible to other processes.</p>

<p style="margin-top: 1em">-key-enc enc <br>
The secret key, however it is read by dacstoken, has been
encoded using algorithm enc. Recognized values (case
insensitive) for enc are &quot;hex&quot;, <br>
&quot;base32&quot; (RFC 4648[45]), and &quot;none&quot;
(plaintext). The default is &quot;hex&quot;.</p>

<p style="margin-top: 1em">-key-file filename <br>
Read the secret key from filename, expressed as a hex digit
string by default (see -key-enc). If filename is
&quot;-&quot;, the key is read from stdin.</p>

<p style="margin-top: 1em">-key-prompt <br>
Prompt for the secret key, expressed as a hex digit string
by default (see -key-enc). The input is not echoed.</p>

<p style="margin-top: 1em">-mode otp-mode <br>
This specifies (case insensitively) the type of token (the
OTP device mode) for use with -set, -create, listing
accounts, and validation and <br>
synchronization operations. The otp-mode may be either
counter or hotp for counter mode, or time or totp for
time-based mode, case insensitively. <br>
This flag is required when creating a new account.</p>

<p style="margin-top: 1em">-nl <br>
When exporting the uri format, suppress the newline. When
generating a QR barcode from the URI, a newline should not
be encoded.</p>

<p style="margin-top: 1em">-outkeys item_type <br>
For encrypting secret keys, use the store identified by
item_type, presumably defined in dacs.conf.</p>

<p style="margin-top: 1em">-pin pinval <br>
Use pinval as the secret PIN for the account.</p>

<p style="margin-top: 1em">Security <br>
Supplying a PIN on the command line is not secure because it
may be visible to other processes.</p>

<p style="margin-top: 1em">-pin-constraints str <br>
Instead of using PASSWORD_CONSTRAINTS[14], use str (having
the same syntax and semantics) to describe the requirements
for a PIN.</p>

<p style="margin-top: 1em">Note <br>
Requirements for a PIN apply to PINs obtained via a command
line flag and to those obtained through importing (using the
&quot;p&quot; attribute). <br>
Requirements are not &quot;retroactive&quot;, however, so
changing the requirements does not affect the PINs of
existing accounts or importing accounts <br>
that were previously exported (having a &quot;ph&quot;
attribute).</p>

<p style="margin-top: 1em">-pin-file filename <br>
Read the secret PIN from filename. If filename is
&quot;-&quot;, the PIN is read from stdin.</p>

<p style="margin-top: 1em">-pin-prompt <br>
Prompt for the secret PIN. The input is not echoed.</p>

<p style="margin-top: 1em">-rnd <br>
Reserved for future use.</p>

<p style="margin-top: 1em">-seed str <br>
Reserved for future use.</p>

<p style="margin-top: 1em">-serial str <br>
The serial number, str, is a (purportedly) unique identifier
assigned to the token. This option is used with the -set,
-create, and -list flags. A <br>
serial number identifies a specific OTP device and need not
be kept secret. The uniqueness property is enforced within
an item type storage unit; <br>
that is, serial numbers of all HOTP devices must be unique,
serial numbers of all TOTP devices must be unique, and if
accounts for the two device <br>
types are combined, all device serial numbers must be
unique. Any printable string is accepted. If a software
client is generating passwords, you <br>
may use the device&rsquo;s serial number, or choose any
suitably descriptive string not already assigned to a
device.</p>

<p style="margin-top: 1em">Note <br>
A jurisdiction that allows (or may eventually allow) both
hardware tokens and software-generating client applications
should consider adopting <br>
a formalized naming scheme for its tokens. For example, the
administrator might append &quot;-hw&quot; to the
vendor&rsquo;s serial number to form the <br>
dacstoken serial number. For software tokens, the
administrator might create a dacstoken serial number by
appending &quot;-sw&quot; to the vendor&rsquo;s <br>
serial number for the device.</p>

<p style="margin-top: 1em">-totp-delta num <br>
Adjust the base time by num intervals (each of the step size
number of seconds) when computing a TOTP. The num may be
negative, zero, or positive. <br>
This is used to correct for inadequately synchronized
clocks.</p>

<p style="margin-top: 1em">-totp-drift nwindows <br>
For TOTP, use a window size of nwindows (in terms of the
interval size) for validation. If nwindows is 0, the
computed TOTP value must match the <br>
given one exactly. If nwindows is 1, for example, dacstoken
will try to match the given TOTP value in the previous,
current, and next intervals. <br>
This allows the clocks in the system running dacstoken (or
local_token_authenticate) and token producing device to be
less well synchronized.</p>

<p style="margin-top: 1em">Security <br>
Although it compensates for poorly synchronized clocks,
increasing the value of nwindows weakens the system by
extending the lifetime of a <br>
one-time password.</p>

<p style="margin-top: 1em">-totp-hash alg <br>
Use alg as the digest algorithm with TOTP. The value of alg
is restricted to SHA1 (the default), SHA256, or SHA512.
Digest name matching is <br>
described in dacs.exprs(5)[46].</p>

<p style="margin-top: 1em">-totp-time secs <br>
Use secs, expressed as the number of seconds since the Unix
Epoch, instead of the current date and time.</p>

<p style="margin-top: 1em">-totp-timestep secs <br>
Use secs as the interval size when computing a TOTP. It must
be greater than zero. The default is 30 seconds.</p>

<p style="margin-top: 1em">Security <br>
Although it compensates for poorly synchronized clocks,
increasing the value of secs weakens the system by extending
the lifetime of a <br>
one-time password.</p>

<p style="margin-top: 1em">-vfs vfs_uri <br>
Use vfs_uri to override the VFS[23] configuration directive
in effect. This can be used to configure or reconfigure
auth_token, auth_hotp_token, <br>
or auth_totp_token to specify the storage method for the
accounts being acted upon.</p>

<p style="margin-top: 1em">Apart from error messages, which
are printed to the standard error, all output goes to the
standard output.</p>

<p style="margin-top: 1em">Ordinarily, a dacsoption will be
specified to select the jurisdiction on behalf of which
accounts are being managed.</p>

<p style="margin-top: 1em">EXAMPLES <br>
These examples assume that the jurisdiction name to use is
EXAMPLE and its federation domain is example.com.</p>

<p style="margin-top: 1em">To use this authentication
method, a DACS administrator might perform the following
steps for each OTP device assigned to a user:</p>

<p style="margin-top: 1em">1. Obtain a supported token or
software client, review how it is used for authentication,
and select values for the various parameters. For a hardware
device, obtain the secret <br>
key from the vendor, or if it is programmable, select a
suitable random key and program it into the device. For the
HOTP algorithm, note the initial counter value; it might
<br>
also be obtained from the vendor, although it is likely to
initialized to zero. For a programmable device or client,
set the initial counter value to zero. Decide whether a <br>
PIN will be required (see TOKEN_REQUIRES_PIN[9]).</p>

<p style="margin-top: 1em">If a software client is being
used, install the software on the user&rsquo;s device (or
have the user do so), and configure the software.</p>

<p style="margin-top: 1em">2. Decide where the account
information will be stored for DACS and, if necessary, add a
suitable VFS[23] directive to dacs.conf. The default (found
in site.conf) maintains the <br>
account information in a file named auth_tokens within each
jurisdiction&rsquo;s default private area:</p>

<p style="margin-top: 1em">VFS
&quot;[auth_token]dacs-kwv-fs:${Conf::FEDERATIONS_ROOT}/
${Conf::FEDERATION_DOMAIN}/${Conf::JURISDICTION_NAME}/auth_tokens&quot;</p>

<p style="margin-top: 1em">3. Generate keys to encrypt the
account information (see Tokens and secret keys[47]) and
decide where they will be stored; for example (your user ID,
group ID, path, <br>
jurisdiction name, and federation domain may vary):</p>

<p style="margin-top: 1em">% cd
/usr/local/dacs/federations_root/example.com/EXAMPLE <br>
% dacskey -uj EXAMPLE -q auth_token_keys <br>
% chgrp www auth_token_keys <br>
% chmod 0640 auth_token_keys</p>

<p style="margin-top: 1em">If necessary, add a suitable
VFS[23] directive to dacs.conf; the default, which is used
above, maintains the account information in a file named
auth_token_keys within each <br>
jurisdiction&rsquo;s default private area:</p>

<p style="margin-top: 1em">VFS
&quot;[auth_token_keys]dacs-fs:${Conf::FEDERATIONS_ROOT}/
${Conf::FEDERATION_DOMAIN}/${Conf::JURISDICTION_NAME}/auth_token_keys&quot;</p>

<p style="margin-top: 1em">4. If you need users to sign on
through dacs_authenticate(8)[2], you must configure a
suitable Auth clause in dacs.conf, for example:</p>

<p style="margin-top: 1em">&lt;Auth
id=&quot;token&quot;&gt; <br>
URL &quot;token&quot; <br>
STYLE &quot;pass&quot; <br>
CONTROL &quot;sufficient&quot; <br>
&lt;/Auth&gt;</p>

<p style="margin-top: 1em">5. There are several ways that
an administrator might proceed, depending on how much of the
effort can be done by users (e.g., whether they can be
trusted, their technical <br>
ability), how many users there are (a few, or thousands),
and the level of security required. Here is one way:</p>

<p style="margin-top: 1em">1. prepare a file containing an
XML record[48] for each account to be created; if PINs are
to be used, assign a random PIN to each account;</p>

<p style="margin-top: 1em">2. use the -import[49] flag to
create the accounts;</p>

<p style="margin-top: 1em">3. give the token device,
username, and (if necessary) initial PIN to the user
(perhaps verifying identity), providing any necessary
demonstration and instructions;</p>

<p style="margin-top: 1em">4. have the user set or reset
the PIN for the account, and ask the user to sign on using
the token to confirm correct operation.</p>

<p style="margin-top: 1em">Another method of provisioning a
token-based account using a QR barcode might follow steps
similar to these for user alice:</p>

<p style="margin-top: 1em">1.</p>

<p style="margin-top: 1em">% dacstoken -format uri -export
-issuer DSS -nl alice &gt; alice.uri <br>
% qrencode -o alice.png &lt; alice.uri <br>
% chmod 0600 alice.uri alice.png</p>

<p style="margin-top: 1em">The exported URI put in
alice.uri might look something like this:</p>


<p style="margin-top: 1em">otpauth://totp/DSS:alice?secret=NBSWY3DPFR3W64TMMQXGCYTDMRSQ&amp;issuer=DSS&amp;algorithm=SHA1&amp;digits=8&amp;period=30</p>

<p style="margin-top: 1em">2. The image file alice.png is
then sent to Alice over a sufficiently secure channel, after
which alice.png and alice.uri may be deleted.</p>

<p style="margin-top: 1em">3. Upon obtaining alice.png,
Alice scans or imports the URI using her OTP client. If the
user has a web browser that has been configured to associate
the otpauth URI scheme <br>
with a suitable OTP client, it may be possible for the user
to initialize the new account using the URI directly rather
than the equivalent QR barcode. Her client should <br>
now be capable of generating a password stream that is
synchronized with her DACS token account. If HOTP is being
used, several OTP values might be provided with <br>
alice.png so that Alice can verify that her client has
correctly initialized her account.</p>

<p style="margin-top: 1em">% dacstoken -hotp-show 3 alice
<br>
0000000000000000: 070440 <br>
0000000000000001: 089277 <br>
0000000000000002: 253240</p>

<p style="margin-top: 1em">Alternatively, a web page might
be provided to help users verify correct operation and
enable their account.</p>

<p style="margin-top: 1em">To create a disabled account for
user bobo for a HOTP device:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -mode
hotp -serial 37000752 -key-file bobo.key -create bobo</p>

<p style="margin-top: 1em">In this example, the secret key
for the account (which must not already exist) is read from
the file bobo.key. New accounts are disabled by default. Use
-enable to create an <br>
enabled account.</p>

<p style="margin-top: 1em">Once an account has been
created, it can be synchronized with the token. To
synchronize the HOTP token for user bobo:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -sync
433268,894121,615120 bobo</p>

<p style="margin-top: 1em">In this example, the particular
token produced the three consecutive passwords 433268,
894121, and 615120. Note that the password sequence string
that follows the -sync flag is a <br>
single argument that cannot have any embedded spaces. If the
key for this token is the value
19c0a3519a89b4a8034c5b9306db, supplied as a hex string, the
next password generated <br>
by this token should be 544323 (with counter value 13). This
can be verified using -hotp-show:</p>

<p style="margin-top: 1em">% dacstoken -hotp-show 5
-counter 10 -key 19c0a3519a89b4a8034c5b9306db
-ignore-key-length <br>
000000000000000a: 433268 <br>
000000000000000b: 894121 <br>
000000000000000c: 615120 <br>
000000000000000d: 544323 <br>
000000000000000e: 002442</p>

<p style="margin-top: 1em">To enable the account for user
bobo:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -enable
-set bobo</p>

<p style="margin-top: 1em">To both set the PIN and enable
the account for user bobo:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -enable
-pin &quot;CzAy&quot; -set bobo</p>

<p style="margin-top: 1em">To list all accounts in
detail:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE
-long</p>

<p style="margin-top: 1em">The -list flag is redundant
because it is the default operation. The -counter, etc.
modifiers have no effect when listing.</p>

<p style="margin-top: 1em">To list only the account for
bobo:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -list
bobo</p>

<p style="margin-top: 1em">The exit status will be non-zero
if this user does not have an account.</p>

<p style="margin-top: 1em">To display the account for the
device with serial number 37000752:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -serial
37000752</p>

<p style="margin-top: 1em">The serial number, which should
uniquely identify a token, is often printed on the token or
can be displayed by the token.</p>

<p style="margin-top: 1em">To set the counter value for the
existing account of bobo:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -counter
9 -set bobo</p>

<p style="margin-top: 1em">This operation might be used for
testing or with a software token. The -sync operation is
more appropriate for a hardware token.</p>

<p style="margin-top: 1em">To change the PIN for username
bobo:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE
-pin-prompt -set bobo</p>

<p style="margin-top: 1em">The program will prompt for the
new PIN.</p>

<p style="margin-top: 1em">To use an alternate account
file, /secure/auth_tokens:</p>

<p style="margin-top: 1em">% dacstoken -uj EXAMPLE -vfs
&quot;dacs-kwv-fs:/secure/auth_tokens&quot; -list</p>

<p style="margin-top: 1em">To use new keys (making the same
assumptions as earlier), add a suitable VFS directive to
dacs.conf; the default defines the item type
auth_token_keys_prev as follows:</p>

<p style="margin-top: 1em">VFS
&quot;[auth_token_keys_prev]dacs-fs:${Conf::FEDERATIONS_ROOT}/
${Conf::FEDERATION_DOMAIN}/${Conf::JURISDICTION_NAME}/auth_token_keys.prev&quot;</p>

<p style="margin-top: 1em">% cd
/usr/local/dacs/federations_root/example.com/EXAMPLE <br>
% mv auth_token_keys auth_token_keys.prev <br>
% dacskey -uj EXAMPLE -q auth_token_keys <br>
% chgrp www auth_token_keys <br>
% chmod 0640 auth_token_keys <br>
% dacstoken -uj EXAMPLE -inkeys auth_token_keys.prev
-set</p>

<p style="margin-top: 1em">The following examples outline
how dacstoken might be used to generate the same output
sequence as Google Authenticator[50] (tested with Version
2.1.0.2212). Here, the key is <br>
&quot;mfrggzdf&quot;, which is the base-32 encoding[42] of
the string &quot;abcde&quot;. Since this an unsafe,
five-byte long key, it must be expressly allowed by using
the -ignore-key_length flag. <br>
Google Authenticator produces codes composed of six decimal
digits. In HOTP (counter-based) mode, Google Authenticator
starts a new token with a counter value of one. Using this
<br>
command, dacstoken displays ten consecutive codes, starting
with the code for a counter value of one:</p>

<p style="margin-top: 1em">% dacsexpr -e
&rsquo;encode(base32,&quot;abcde&quot;)&rsquo; <br>
&quot;MFRGGZDF&quot; <br>
% dacstoken -un -hotp-show 10 -digits 6 -counter 1 -key
mfrggzdf -key-enc base32 -ignore-key-length <br>
0000000000000001: 106998 <br>
0000000000000002: 421654 <br>
0000000000000003: 118157 <br>
0000000000000004: 283104 <br>
0000000000000005: 848242 <br>
0000000000000006: 615855 <br>
0000000000000007: 507768 <br>
0000000000000008: 063257 <br>
0000000000000009: 974271 <br>
000000000000000a: 178655</p>

<p style="margin-top: 1em">Similarly, for TOTP (time-based)
mode, this displays the current time-based code that should
match the code produced by Google Authenticator during the
same time interval (if you <br>
try this your output code will most likely be
different):</p>

<p style="margin-top: 1em">% dacstoken -un -totp-show 0
-digits 6 -key mfrggzdf -key-enc base32 -ignore-key-length
<br>
TOTP=525711 [at t=1371760542]</p>

<p style="margin-top: 1em">To generate some of the RFC
6238[5], Appendix B test vector values:</p>

<p style="margin-top: 1em">% dacstoken -un -totp-show 0
-key 12345678901234567890 -key-enc none -totp-time 59 <br>
TOTP=94287082 [at t=59] <br>
% dacstoken -un -totp-show 0 -key
12345678901234567890123456789012 -totp-hash sha256 -key-enc
none -totp-time 59 <br>
TOTP=46119246 [at t=59] <br>
% dacstoken -un -totp-show 0 -key
1234567890123456789012345678901234567890123456789012345678901234
-totp-hash sha512 -key-enc none -totp-time 59 <br>
TOTP=90693936 [at t=59] <br>
% dacstoken -un -totp-show 0 -key 12345678901234567890
-key-enc none -totp-time 2000000000 <br>
TOTP=69279037 [at t=2000000000]</p>

<p style="margin-top: 1em">The dacsexpr(1)[18] base-32
encoding and decoding functions[51] may be helpful.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
The program exits 0, or 1 if an error occurred.</p>

<p style="margin-top: 1em">BUGS <br>
HOTP should probably be called COTP, but HOTP came before
TOTP. WOTP?</p>

<p style="margin-top: 1em">Listings may only be sorted by
username.</p>

<p style="margin-top: 1em">The drift adjustment for TOTP
accounts is tied to the real time clocks of a particular
client/server pair. If either clock is effectively changed
&quot;too much&quot; (e.g., by resetting a <br>
very fast server clock or replacing an old token that had a
relatively slower clock), then a user will observe the token
to suddenly stop working. Resynchronization is required <br>
in these cases. Sharing an account file amongst two or more
servers should be avoided in general (because locks are
unlikely to be visible across hosts), but also if their
clocks <br>
are not always well synchronized. It is recommended that the
Network Time Protocol (RFC 1305[52]) or equivalent be used
on any host that runs DACS commands or web services.</p>

<p style="margin-top: 1em">The implementation of time-based
tokens was originally based on the Internet-Draft available
at the time (draft-mraihi-totp-timebased-05.txt) but is
expected to conform to RFC <br>
6238[5], TOTP: Time-Based One-Time Password Algorithm, and
interoperate with other conformant hardware and software
tokens. DACS passes both documents&rsquo; test vectors.</p>

<p style="margin-top: 1em">TOTP password matching windows
are symmetrical.</p>

<p style="margin-top: 1em">This functionality should
probably be available through dacs_admin(8)[53] and
dacsauth(1)[54], but it&rsquo;s not.</p>

<p style="margin-top: 1em">Mutual authentication using
tokens should be implemented.</p>

<p style="margin-top: 1em">Although release 1.4.25
introduced many improvements, some cause incompatibilities
with earlier versions of dacstoken.</p>

<p style="margin-top: 1em">SEE ALSO <br>
RFC 4226[4], draft-mraihi-totp-timebased-05.txt[55], RFC
6238[5], dacs_authenticate(8)[2], dacs_token(8)[8],
dacsgrid(1)[56], dacspasswd(1)[10], opie(4)[57], Mobile One
Time <br>
Passwords[58], mod_authn_otp[59]</p>

<p style="margin-top: 1em">AUTHOR <br>
Distributed Systems Software (www.dss.ca[60])</p>

<p style="margin-top: 1em">ACKNOWLEDGEMENTS <br>
Our sincere thanks to Authenex, Inc.[25] and HyperSecu
Information Systems, Inc.[27] for generously providing
samples of their products and technical support.</p>

<p style="margin-top: 1em">COPYING <br>
Copyright2003-2016 Distributed Systems Software. See the
LICENSE[61] file that accompanies the distribution for
licensing information.</p>

<p style="margin-top: 1em">NOTES <br>
1. dacsoptions <br>
http://dacs.dss.ca/man/dacs.1.html#dacsoptions</p>

<p style="margin-top: 1em">2. dacs_authenticate <br>
http://dacs.dss.ca/man/dacs_authenticate.8.html</p>

<p style="margin-top: 1em">3. local_token_authenticate <br>
http://dacs.dss.ca/man/dacs_authenticate.8.html#token</p>

<p style="margin-top: 1em">4. RFC 4226 <br>
http://www.rfc-editor.org/rfc/rfc4226.txt</p>

<p style="margin-top: 1em">5. RFC 6238 <br>
http://www.rfc-editor.org/rfc/rfc6238.txt</p>

<p style="margin-top: 1em">6. RFC 6287 <br>
http://www.rfc-editor.org/rfc/rfc6287.txt</p>

<p style="margin-top: 1em">7. -convert flag <br>
http://dacs.dss.ca/man/#convert_flag</p>

<p style="margin-top: 1em">8. dacs_token(8) <br>
http://dacs.dss.ca/man/dacs_token.8.html</p>

<p style="margin-top: 1em">9. TOKEN_REQUIRES_PIN <br>

http://dacs.dss.ca/man/dacs.conf.5.html#TOKEN_REQUIRES_PIN</p>

<p style="margin-top: 1em">10. dacspasswd(1) <br>
http://dacs.dss.ca/man/dacspasswd.1.html</p>

<p style="margin-top: 1em">11. dacs_passwd(8) <br>
http://dacs.dss.ca/man/dacs_passwd.8.html</p>

<p style="margin-top: 1em">12. PASSWORD_DIGEST <br>
http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_DIGEST</p>

<p style="margin-top: 1em">13. PASSWORD_SALT_PREFIX <br>

http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_SALT_PREFIX</p>

<p style="margin-top: 1em">14. PASSWORD_CONSTRAINTS <br>

http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_CONSTRAINTS</p>

<p style="margin-top: 1em">15. RFC 2104 <br>
http://www.rfc-editor.org/rfc/rfc2104.txt</p>

<p style="margin-top: 1em">16. FIPS 198 <br>

http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf</p>

<p style="margin-top: 1em">17. time(3) <br>

http://www.freebsd.org/cgi/man.cgi?query=time&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">18. dacsexpr(1) <br>
http://dacs.dss.ca/man/dacsexpr.1.html</p>

<p style="margin-top: 1em">19. man-in-the-middle attack
<br>
http://en.wikipedia.org/wiki/Man-in-the-middle_attack</p>

<p style="margin-top: 1em">20. revocation list <br>
http://dacs.dss.ca/man/dacs.acls.5.html#revocation_list</p>

<p style="margin-top: 1em">21. local_passwd_authenticate
<br>
http://dacs.dss.ca/man/dacs_authenticate.8.html#passwd</p>

<p style="margin-top: 1em">22. DACS identities <br>
http://dacs.dss.ca/man/dacs.1.html#gloss_identity</p>

<p style="margin-top: 1em">23. VFS <br>
http://dacs.dss.ca/man/dacs.conf.5.html#VFS</p>

<p style="margin-top: 1em">24. dacskey(1) <br>
http://dacs.dss.ca/man/dacskey.1.html</p>

<p style="margin-top: 1em">25. Authenex A-Key 3600 <br>
http://www.authenex.com</p>

<p style="margin-top: 1em">26. Feitian Technologies <br>
http://www.ftSafe.com</p>

<p style="margin-top: 1em">27. HyperSecu Information
Systems <br>
http://www.hypersecu.com</p>

<p style="margin-top: 1em">28. Google Authenticator <br>

https://itunes.apple.com/ca/app/google-authenticator/id388497605</p>

<p style="margin-top: 1em">29. open source <br>
https://fedorahosted.org/freeotp</p>

<p style="margin-top: 1em">30. FreeOTP Authenticator <br>

https://itunes.apple.com/ca/app/freeotp-authenticator/id872559395</p>

<p style="margin-top: 1em">31. Red Hat <br>
http://www.redhat.com</p>

<p style="margin-top: 1em">32. OATH Token <br>
http://oathtoken.googlecode.com</p>

<p style="margin-top: 1em">33. iPod Touch, iPhone, and iPad
<br>
http://itunes.apple.com/us/app/oath-token/id364017137</p>

<p style="margin-top: 1em">34. OTP Auth <br>
https://itunes.apple.com/ca/app/otp-auth/id659877384</p>

<p style="margin-top: 1em">35. contact <br>
http://www.dss.ca/contactus.html</p>

<p style="margin-top: 1em">36. Photo <br>
http://dacs.dss.ca/otp-tokens2.jpg</p>

<p style="margin-top: 1em">37. KeyUriFormat <br>

https://code.google.com/p/google-authenticator/wiki/KeyUriFormat</p>

<p style="margin-top: 1em">38. dacsoptions <br>
http://dacs.dss.ca/man/dacs.1.html#format-arg</p>

<p style="margin-top: 1em">39. QR Code <br>
http://en.wikipedia.org/wiki/QR_code</p>

<p style="margin-top: 1em">40. ZBar <br>
http://zbar.sourceforge.net</p>

<p style="margin-top: 1em">41. libqrencode library <br>
http://fukuchi.org/works/qrencode/</p>

<p style="margin-top: 1em">42. base-32 encoded <br>
https://en.wikipedia.org/wiki/Base32</p>

<p style="margin-top: 1em">43. -validate <br>
http://dacs.dss.ca/man/#validate_flag</p>

<p style="margin-top: 1em">44. -set <br>
http://dacs.dss.ca/man/#set_flag</p>

<p style="margin-top: 1em">45. RFC 4648 <br>
http://www.rfc-editor.org/rfc/rfc4648.txt</p>

<p style="margin-top: 1em">46. dacs.exprs(5) <br>
http://dacs.dss.ca/man/dacs.exprs.5.html#digest</p>

<p style="margin-top: 1em">47. Tokens and secret keys <br>
http://dacs.dss.ca/man/#security1</p>

<p style="margin-top: 1em">48. XML record <br>
http://dacs.dss.ca/man/#user_provisioning</p>

<p style="margin-top: 1em">49. -import <br>
http://dacs.dss.ca/man/#import_flag</p>

<p style="margin-top: 1em">50. Google Authenticator <br>
http://en.wikipedia.org/wiki/Google_Authenticator</p>

<p style="margin-top: 1em">51. base-32 encoding and
decoding functions <br>
http://dacs.dss.ca/man/dacs.exprs.5.html#encode</p>

<p style="margin-top: 1em">52. RFC 1305 <br>
http://www.rfc-editor.org/rfc/rfc1305.txt</p>

<p style="margin-top: 1em">53. dacs_admin(8) <br>
http://dacs.dss.ca/man/dacs_admin.8.html</p>

<p style="margin-top: 1em">54. dacsauth(1) <br>
http://dacs.dss.ca/man/dacsauth.1.html</p>

<p style="margin-top: 1em">55.
draft-mraihi-totp-timebased-05.txt <br>

http://www.ietf.org/id/draft-mraihi-totp-timebased-05.txt</p>

<p style="margin-top: 1em">56. dacsgrid(1) <br>
http://dacs.dss.ca/man/dacsgrid.1.html</p>

<p style="margin-top: 1em">57. opie(4) <br>

http://www.freebsd.org/cgi/man.cgi?query=opie&amp;apropos=0&amp;sektion=4&amp;manpath=FreeBSD+10.1-RELEASE&amp;format=html</p>

<p style="margin-top: 1em">58. Mobile One Time Passwords
<br>
http://motp.sourceforge.net</p>

<p style="margin-top: 1em">59. mod_authn_otp <br>
http://code.google.com/p/mod-authn-otp</p>

<p style="margin-top: 1em">60. www.dss.ca <br>
http://www.dss.ca</p>

<p style="margin-top: 1em">61. LICENSE <br>
http://dacs.dss.ca/man/../misc/LICENSE</p>

<p style="margin-top: 1em">DACS 1.4.38a 01/12/2017
DACSTOKEN(1)</p>
<hr>
</body>
</html>
