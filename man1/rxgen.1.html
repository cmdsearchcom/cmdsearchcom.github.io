<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>RXGEN(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">RXGEN(1)</td>
    <td class="head-vol">AFS Command Reference</td>
    <td class="head-rtitle">RXGEN(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
rxgen - Stub generator for the Rx remote procedure call package
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>rxgen</b> [<b>-h</b> | <b>-c</b> | <b>-C</b> | <b>-S</b> | <b>-r</b>]
  [<b>-dkpR</b>]
<br/>
 [ <b>-I</b> <i>dir</i>] [<b>-P</b> <i>prefix</i>] [<b>-o</b> <i>outfile</i>]
  [<i>infile</i>]
<div class="Pp"></div>
<b>rxgen</b> <b>-s</b> <i>transport</i> [<b>-o</b> <i>outfile</i>]
  [<i>infile</i>]
<div class="Pp"></div>
<b>rxgen</b> <b>-l</b> [<b>-o</b> <i>outfile</i>] [<i>infile</i>]
<div class="Pp"></div>
<b>rxgen</b> <b>-m</b> [<b>-o</b> <i>outfile</i>] [<i>infile</i>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>rxgen</b> is a tool that generates C code to implement the Rx RPC protocol;
  it takes as input a description of an application interface similar to C and
  produces a number of server and/or client stub routines to be linked with
  RPC-based programs. These stubs allow programs to invoke remote procedures
  through local procedure calls. <b>rxgen</b> is an extension of Sun's
  <b>rpcgen</b> (version 3.9) and retains full <b>rpcgen</b> functionality (at
  least as of that version). Please refer to <i>rpcgen</i>(1) for more details
  on the Sun's RPC specific flags, and to the RPC programming guide regarding
  the RPC language along with useful examples.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<b>rxgen</b> operates in several different modes. The generated output files can
  be produced individually (using one of <b>-h</b>, <b>-c</b>, <b>-C</b>, or
  <b>-S</b>) or collectively. All output files are created when the default is
  used (i.e., no options), or the output is limited to the server stubs (
  <b>-C</b> and <b>-S</b>) when the <b>-r</b> flag is used. The following
  describes the types of generated output files (for simplicity, <i>filename</i>
  refers to the main output filename):
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">Generate C data definitions (a header file) from standard
      RPCL definitions (default extension: <i>filename</i>.h).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag">Compile the XDR routines required to serialize the protocol
      described by RPCL. Generate XDR routines for all declarations (default
      extension: <i>filename</i>.xdr.c).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C</b></dt>
  <dd class="It-tag">Generate all the client-side stub routines (default
      extension: <i>filename</i>.cs.c). Calling a routine in this file will
      cause the arguments to be packed up and sent via Rx (or R).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b></dt>
  <dd class="It-tag">Generate all the server-side stub routines (default
      extension: <i>filename</i>.ss.c). Arguments are unpacked, and the
      corresponding server routine is called.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b></dt>
  <dd class="It-tag">Generate the two default extension files produced by the
      <b>-C</b> and <b>-S</b> options.</dd>
</dl>
<div class="Pp"></div>
The following options can be used on any combination of <b>rxgen</b> calls:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b></dt>
  <dd class="It-tag">Generate code for the older \R protocol, as opposed to Rx,
      which is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b></dt>
  <dd class="It-tag">Must be specified when the generated code is intended to be
      used by the kernel; special &quot;includes&quot; and other specifics are
      produced when the target output is for the kernel.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag">Package combination flag: when multiple packages are
      included within a single specification file, a single Execute Request
      routine will be used for all of them as a result of this flag. The default
      is to generate individual Execute Request stubs for each package.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b> <i>dir</i></dt>
  <dd class="It-tag">Similar to the <b>-I</b> flag in the C compiler
      (<b>cc</b>). This flag is passed to the pre-processor ( <b>cpp</b>) so
      that directory <i>dir</i> is searched before the standard lookup list for
      #include files. As expected, multiple <b>-I</b> flags can be used
      simultaneously.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b> <i>prefix</i></dt>
  <dd class="It-tag">The <i>prefix</i> string following this switch is prepended
      to all generated output files; useful when multiple runs want to produce
      different versions of the same interface (say, kernel and non-kernel
      versions).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b></dt>
  <dd class="It-tag">Debugging mode; only needed when <b>rxgen</b> is to be
      debugged (say, via <b>dbx</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b> <i>outfile</i></dt>
  <dd class="It-tag">Specify the name of the output file. If none is specified,
      the standard output is used ( <b>-c</b>, <b>-h</b>, <b>-C</b>, and
      <b>-S</b> modes only). Note that if an output file is specified in a
      multi-output file option (such as the default, or with option <b>-r</b>),
      then the <i>outfile</i> replaces the name generated by default (which is
      based on the configuration's main file name).</dd>
</dl>
<div class="Pp"></div>
The <b>-s</b>, <b>-l</b>, and <b>-m</b> options are present only for
  <b>rpcgen</b> support. See <i>rpcgen</i>(1) for information on their use.
<h1 class="Sh" title="Sh" id="rxgen_SYNTAX_SUMMARY"><a class="selflink" href="#rxgen_SYNTAX_SUMMARY"><b>rxgen</b>
  SYNTAX SUMMARY</a></h1>
<pre>
    Specification file:
        &lt;Package description option&gt; |
        &lt;Prefix description option&gt; |
        &lt;StartingOpcode description option&gt; |
        &lt;SplitPrefix description option&gt; |
        &lt;Procedure description option&gt; |
        &lt;RPCL language description option&gt;
    &lt;Package description option&gt;:
        &quot;package&quot; &lt;Package_ident&gt;
    &lt;Prefix description option&gt;:
        &quot;prefix&quot; &lt;Prefix_ident&gt;
    &lt;StartingOpcode description option&gt;:
        &quot;startingopcode&quot; &lt;constant&gt;
    &lt;SplitPrefix description option&gt;:
        &quot;splitprefix&quot; &lt;split options&gt; &quot;;&quot;
    &lt;Split options&gt;:
        &quot;IN =&quot; &lt;Start_prefix_ident&gt; &quot;|&quot;
        &quot;OUT =&quot; &lt;End_prefix_ident&gt; &quot;|&quot;
        &lt;Split options&gt;
    &lt;Procedure description option&gt;:
        [&quot;proc&quot;] [&lt;Procedure_ident&gt;] [&lt;ServerStub_ident&gt;]
            &lt;Argument list&gt; [&quot;split&quot; | &quot;multi&quot;]
            [&quot;=&quot; &lt;Opcode_ident&gt;] &quot;;&quot;
    &lt;Argument list&gt;:
        &quot;(&quot; &lt;Argument definition&gt; &lt;Comma_joined argument&gt; &quot;)&quot;
    &lt;Argument definition&gt;:
        &lt;Direction option&gt; &lt;Standard RPCL type decl&gt; &lt;Arg_ident&gt;
            [&quot;&lt;&quot; &lt;Max_size&gt; &quot;&gt;&quot; | &quot;[&quot; &lt;Max_size&gt; &quot;]&quot;] | NULL
    &lt;Comma_joined argument&gt;:
        &quot;,&quot; &lt;Argument definition&gt; | NULL
    &lt;Direction option&gt;:
        &quot;IN&quot; | &quot;OUT&quot; | &quot;INOUT&quot; | NULL
    &lt;Max_size&gt;:
        &lt;constant&gt; | NULL
    &lt;Package_ident&gt;:
    &lt;Prefix_ident&gt;:
    &lt;String_ident&gt;:
    &lt;Start_prefix_ident&gt;:
    &lt;End_prefix_ident&gt;:
    &lt;Procedure_ident&gt;:
    &lt;ServerStub_ident&gt;:
    &lt;Arg_ident&gt;:
    &lt;Opcode_ident&gt;:
        &lt;identifier&gt;
    &lt;RPCL language description option&gt;:
    &lt;Standard RPCL type decl&gt;:
        Sun's RPCL language syntax (see rpcgen(1))
</pre>
<h1 class="Sh" title="Sh" id="rxgen_COMMANDS"><a class="selflink" href="#rxgen_COMMANDS"><b>rxgen</b>
  COMMANDS</a></h1>
<h2 class="Ss" title="Ss" id="Comments_and_Preprocessing"><a class="selflink" href="#Comments_and_Preprocessing">Comments
  and Preprocessing</a></h2>
The input interface may contain preprocessor directives which are passed through
  the C preprocessor (i.e. &quot;cpp&quot;). Since the preprocessor runs on all
  input files before they are actually interpreted by <b>rxgen</b>, all
  <b>cpp</b> directives (#include, #ifdefs, #defines, etc.) are legal and
  welcomed within an <b>rxgen</b> input file. Of course, none of these
  preprocessor directives will be included in any of the generated files. To
  facilitate distinctions between the different types of output files,
  <b>rxgen</b> defines certain special <b>cpp</b> symbols for use by the
  <b>rxgen</b> programmer. These are RPC_HDR (defined when compiling into
  header, <i>filename</i>.h, files), RPC_XDR (defined when compiling into xdr,
  <i>filename</i>.xdr.c, files), RPC_CLIENT (defined when compiling into client
  stubs, <i>filename</i>.cs.c, files), and RPC_SERVER (defined when compiling
  into server stubs, <i>filename</i>.ss.c, files).
<div class="Pp"></div>
In addition, <b>rxgen</b> does a little preprocessing of its own. Any line
  beginning with &quot;%&quot; is passed directly into the output file,
  uninterpreted by <b>rxgen</b>. For a more heavy en masse dumping of
  uninterpreted code, it would be advised to include all such code in an
  &quot;#include&quot; file and pass it in preceded by &quot;%&quot;. The input
  interface may also contain any C-style comments which are, of course, ignored.
  Interpretation is token-based, thus special line-orientation of separate
  statements is not necessary. <b>rxgen</b> also provides a quite rich and
  helpful set of error reports, identifying them by exact line location and
  error type. Also, <b>rxgen</b> will automatically generate #include lines for
  standard include files, such as <i>rx/xdr.h</i> and <i>rx/rx.h</i>, along with
  the generated header file from this interface.
<h2 class="Ss" title="Ss" id="Prefixing_stub_procedures"><a class="selflink" href="#Prefixing_stub_procedures">Prefixing
  stub procedures</a></h2>
The <i>package</i> statement tells <b>rxgen</b> the name of the interface
  package. It is used for prefixing the naming of all generated stub routines
  and the execute request procedure. For example:
<div class="Pp"></div>
<pre>
    package AFS_
</pre>
<div class="Pp"></div>
causes the execute request procedure to be named AFS_ExecuteRequest (Warning: in
  the older version an additional &quot;_&quot; was appended after the package
  name to the ExecuteRequest name; thus make sure you don't have an
  ExecuteRequest interface routine) and a given stub routine, say Fetch, to be
  actually named AFS_Fetch. Multiple package statements (current maximum size is
  10) per configuration are permitted and are useful when multiple sets of
  interfaces are implemented (see the example at the end). Note that in such
  cases, use of the <b>-p</b> flag results in the generation of just one
  ExecuteRequest procedure which recognizes the multiple interfaces and whose
  name is prefixed by the first package statement. In the default case,
  independent ExecuteRequest procedures will be created for each packaged group
  of remote procedure calls.
<div class="Pp"></div>
The <i>prefix</i> statement supplies a name to prepend to all calls to remote
  procedure names in the ExecuteRequest stub routine. It is useful when the
  server makes RPC calls to other servers (say, for debugging purposes). For
  example:
<div class="Pp"></div>
<pre>
    prefix S
</pre>
<div class="Pp"></div>
causes the name &quot;S&quot; to be prepended to the name of all routines called
  from the server stubs. The server can then call the original name and get the
  client stubs.
<h2 class="Ss" title="Ss" id="rxgen_procedure_declaration"><a class="selflink" href="#rxgen_procedure_declaration"><b>rxgen</b>
  procedure declaration</a></h2>
The <i>proc</i> statement is the most common (and meaningful) in the
  <b>rxgen</b> interface. Its syntax description is:
<div class="Pp"></div>
<pre>
        [proc] [&lt;proc_name&gt;] [&lt;server_stub&gt;] (&lt;arg&gt;, ..., &lt;arg&gt;)
            [split | multi] [= &lt;opcode&gt;] ;
</pre>
<div class="Pp"></div>
where:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;proc&quot; is an optional prefix of the procedure
      statement. This is just a stylistic item and not a required procedure
      delimiter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&lt;proc_name&gt; is the name of the procedure. Note that
      even the name of the procedure is optional. This only makes sense when the
      name of the given procedure is identical to the name of the last
      <i>package</i> statement (i.e., &quot;package RCallBack&quot; and the
      declaration of the &quot;RCallBack&quot; procedure).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&lt;server_stub&gt;, if present, causes the ExecuteRequest
      procedure to call that stub instead of the automatically generated stub
      when a call with that opcode is decoded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&lt;opcode&gt; is a constant or symbol that is the opcode
      for that procedure. One might use the preprocessor features (i.e.,
      #define), the <i>const</i> RPC-language feature, or the old good constants
      as opcodes. Some further evaluation/processing of opcodes is done.
      Particularly, checks for duplicate and non-existent opcodes are performed,
      along with checks for &quot;holes&quot; (i.e., gaps in consecutive
      opcodes) in the opcode sequences. For example, we use the fact that when
      &quot;holes&quot; in opcodes exist, the ExecuteRequest procedure uses the
      <i>case</i> statement rather than the faster (and smaller, codewise)
      indexed array method.
    <div style="height: 1.00em;">&#x00A0;</div>
    Also, <b>rxgen</b> defines (i.e., appends to the header file) three valuable
      macros for each package group: &lt;package-name&gt;LOWEST_OPCODE,
      &lt;package-name&gt;HIGHEST_OPCODE, and
      &lt;package-name&gt;NUMBER_OPCODES. These may be useful to the
      <b>rxgen</b> programmer. Also, notice that the <i>opcode</i> statement is
      an optional feature, and can be omitted. In such cases, automatic opcode
      numbers are generated sequentially, starting from 0.
    <div style="height: 1.00em;">&#x00A0;</div>
    One can change the initial opcode number by using the <i>startingopcode</i>
      (for lack of a better name) <b>rxgen</b> command. Its syntax is:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    startingopcode &lt;constant&gt;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    where &lt;constant&gt; must be reasonable! Note that one can not mix
      procedures, some with opcodes and some without, nor allow opcodes after
      the specification of the <i>startingopcode</i> statement. <b>rxgen</b>
      will complain in all such cases.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The <i>argument</i> entry represents a given parameter of
      the procedure. Its syntax is:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    [IN | INOUT | OUT | &lt;null&gt;] &lt;type_decl&gt; &lt;arg_name&gt;
        [&lt;max&gt;|&lt;&gt;|[max]|[]]
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If the type is an indirect type (i.e., is followed by *), it is assumed that
      the pointer should be followed one level and the data pointed to is to be
      transmitted. This should normally be used for all structures/arrays and
      out parameters. A noticeable exception is when explicit array/structure
      maximum size is given; since no array-of-pointer declarations are allowed
      one should use typedefs to achieve the similar effect. The parameters
      could be input parameters (preceded by IN), output parameters (preceded by
      OUT), or input/output parameters (preceded by INOUT). If not specified,
      then the direction of the previous parameter in the procedure is used.
      (Note: the first parameter must be preceded by the directional
    primitive!)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;split&quot; is a hack to handle stub routines that do
      things such as file transfers or any other operation that has to exchange
      information (e.g., length of a file) before the call returns its output
      parameters. Because of the particular handshake that is involved when
      doing remote file transfer, we currently break all such calls into two
      client-side stub routines. The first (with the default prefix of
      &quot;Begin&quot;) is used to pass all IN and INOUT parameters to the
      server side. The second (with the default prefix of &quot;End&quot;) is
      used to get back the INOUT and OUT parameters from the server. Between the
      two calls, the user is supposed to do the appropriate calls for the file
      transfer. For example, the following procedure declaration in package AFS_
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    Fetch (IN a, b,INOUT c, OUT d) split = FETCHOPCODE;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will roughly generate the two independent client stub routines:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    BeginAFS_Fetch (IN a, b, c)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    EndAFS_Fetch(OUT c, d)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>splitprefix</i> statement is used to change the default prefix names
      used by the two client-side stub generated routines when dealing with file
      transfer-related procedure calls. For example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    splitprefix IN=Before_ OUT=After_
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will cause the naming of the two client stubs for a file transfer-related
      routine, say <i>Fetch()</i>, to be <i>Before_AFS_Fetch()</i> and
      <i>After_AFS_Fetch()</i>, respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;multi&quot; option is nearly identical to the
      &quot;split&quot; feature described above. The only significant visible
      difference is that along with the two client stubs, the standard client
      stub is also generated. Since the intention is to handle the multi-Rx
      calls, we need the whole standard procedure stub in the cases where no
      multi-Rx call of the procedure is performed. A side effect of the
      &quot;multi&quot; option is the generation of a special macro (i.e.,
      &quot;multi_&lt;Procedure-name&gt;&quot; which passes back as arguments
      the &quot;Begin&quot; and &quot;End&quot; stubs in the header output file.
      This macro is used directly by the Rx code when a multi-Rx call of this
      procedure is performed.</dd>
</dl>
<h2 class="Ss" title="Ss" id="OBSOLETE_rxgen_FEATURES"><a class="selflink" href="#OBSOLETE_rxgen_FEATURES">OBSOLETE
  <b>rxgen</b> FEATURES</a></h2>
Although the following rxgen commands are still in effect, they will soon be
  removed since there are better alternatives. DO NOT USE THEM!
<div class="Pp"></div>
The <i>special</i> statement is a temporary hack used to handle certain
  inefficiencies of standard xdr routines to handle some user-customized
  declarations. In particular, this applies to a string pointer specified as
  part of a declaration. For example,
<div class="Pp"></div>
<pre>
    special struct BBS SeqBody;
</pre>
<div class="Pp"></div>
tells <b>rxgen</b> that the entry &quot;SeqBody&quot; in the user-defined BBS
  xdr routine is a string (note that more than one string can be
  &quot;special&quot; per structure -- multiple ones are separated by commas);
  it will thus allocate and de-allocate space properly in the server-generated
  stubs that contain this structure as an IN or INOUT parameter.
<div class="Pp"></div>
A better alternative to <i>special</i> is the <i>customized</i> statement, which
  is simply the &quot;customized&quot; token followed by the regular declaration
  of a struct based on the RPCL rules. In this case, the declaration will be
  included in the generated header file ( <b>-h</b> option) but no xdr routine
  will be generated for this structure -- the user will supply this. All pointer
  entries in this structure will be remembered so when the structure is used as
  an IN or INOUT in the server stub, no core leaks will occur. For example,
  consider
<div class="Pp"></div>
<pre>
    customized struct CBS {
        long Seqlen;
        char *SeqBody;
    }
</pre>
<div class="Pp"></div>
The &quot;xdr_CBS&quot; routine would be provided by the user where during the
  DECODE xdr opcode, appropriate space for the &quot;SeqBody&quot; string is
  allocated. Similarly, that space is freed during the FREE xdr opcode.
<div class="Pp"></div>
Note: Old style &quot;Array parameter specifications&quot; are not supported any
  more.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
In case there are some requirements not available by the current RPC language,
  one can customize some XDR routines by leaving those data types undefined. For
  every data type that is undefined, it will be assumed that a routine exists
  with the name &quot;xdr_&quot; prepended to it. A selected set of <b>rxgen</b>
  features is presented below, but for a more comprehensive one (unions, complex
  examples, etc) please refer to the <i>rpcgen Programming</i> <i>Guide</i> and
  <i>eXternal Data Representation: Sun Technical Notes</i>.
<h2 class="Ss" title="Ss" id="Typedefs"><a class="selflink" href="#Typedefs">Typedefs</a></h2>
The RPC typedef statement is identical to the C typedef (i.e. &quot;typedef
  &lt;declaration&gt;&quot;). By default, most user declarations (i.e. structs,
  unions, etc) are automatically typedef'ed by <b>rxgen</b>. Since it makes
  parsing simpler, its usage is recommended by <b>rxgen</b> scripts.
<h2 class="Ss" title="Ss" id="Strings"><a class="selflink" href="#Strings">Strings</a></h2>
The C &quot;char *&quot; string convention is kind of ambiguous, since it is
  usually intended to mean a null-terminated string of characters, but it could
  also represent a pointer to a single character, a pointer to an array of
  characters, etc. In the RPC language, a null-terminated string is
  unambiguously called a &quot;string&quot;. Examples,
<div class="Pp"></div>
<pre>
    string bigname&lt;&gt;;
    string name&lt;MAXNAMELEN&gt;;
    typedef string volname&lt;MAXVOLNAME&gt;;
</pre>
<div class="Pp"></div>
Notice that the maximum size of string can be arbitrary (like
  &quot;bigname&quot; above) or, preferably, or specified in angle brackets
  (i.e. &quot;name&quot; and &quot;volname&quot; above). In practice, one should
  always use only bounded strings in interfaces. A sample calling proc using the
  declarations above would be:
<div class="Pp"></div>
<pre>
    GetEntryByName (IN volname name, 
        OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;
</pre>
<div class="Pp"></div>
or, of course,
<div class="Pp"></div>
<pre>
    GetEntryByName (IN string volname&lt;MAXVOLNAME&gt;,
        OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;
</pre>
<div class="Pp"></div>
It is very important for the user to understand when the string parameters
  should be allocated and/or freed by the his/her client and/or server programs.
  A short analysis on string parameters handling follows (note that a similar
  method is used for the handling of variable length arrays as it will be shown
  later on):
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">In the client side: IN and INOUT string parameters are the
      programmer's responsibility and should be allocated (static or via malloc)
      before calling the rpc and freed (if malloc was used) after the rpc's
      return in the user's client program; of course, for INOUT parameters, the
      returned string can't be bigger than the malloced input string.
    <div style="height: 1.00em;">&#x00A0;</div>
    OUT string parameters are automatically malloced (based on the length of the
      returned string and not the maxsize) by the <b>rxgen</b> client stubs (in
      <i>filename</i>.cs.c) and must be freed by the client program; admittedly,
      this could be somewhat confusing since the user needs to free something
      that he/she didn't allocate.}</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">In the server side: IN and INOUT string parameters are
      automatically malloced (based on the size of incoming strings) by the
      rxgen server stubs (in <i>filename</i>.ss.c) before they are passed to the
      user's server procedure; that space is automatically freed just before the
      rxgen server stub returns; therefore the user need not do anything special
      for IN and INOUT string parameters.
    <div style="height: 1.00em;">&#x00A0;</div>
    OUT string parameters must be malloced by the user's server procedure (i.e.
      null pointer is passed to it by the rxgen server stub) and it is
      automatically freed at the end of the <b>rxgen</b> server stub. Like in
      the client side, the OUT parameters are somewhat unorthodox (i.e. the
      server routine must malloc a string without ever freeing it itself; this
      is done by the <b>rxgen</b> server stub).</dd>
</dl>
<div class="Pp"></div>
Note that for INOUT and OUT string parameters, in both the client and server
  sides their arguments must be char of pointers (i.e. char **).
<h2 class="Ss" title="Ss" id="Pointers"><a class="selflink" href="#Pointers">Pointers</a></h2>
Pointer declarations in RPC are also exactly as they are in C (i.e. &quot;struct
  single_vldbentry *vldblist;&quot;). Of course, one can't send pointers over
  the network, but one can use XDR pointers for sending recursive data types
  such as lists and trees (an example of a linked list will be demonstrated
  shortly).
<h2 class="Ss" title="Ss" id="Arrays"><a class="selflink" href="#Arrays">Arrays</a></h2>
Fixed arrays are just like standard C array declarations (i.e. &quot;struct
  UpdateEntry entries[20]&quot;) without any side effect problems in
  <b>rxgen</b>. Since variable-length arrays have no explicit syntax in C, the
  angle-brackets are used for it and the array declarations are actually
  compiled into &quot;struct&quot;s. For example, declarations such as:
<div class="Pp"></div>
<pre>
    const   MAXBULKSIZE     = 10000;
    const   MAXENTRIES      = 100;
    opaque  bulk&lt;MAXBULKSIZE&gt;;           /* At most 10000 items */
    int     hosts&lt;&gt;;                     /* any number of items */
    typedef vldbentry blkentries&lt;100&gt;;   /* Preferable array decl */
</pre>
<div class="Pp"></div>
are compiled into the following structs:
<div class="Pp"></div>
<pre>
    struct {
        u_int   bulk_len;       /* no of items */
        char    *bulk_val;      /* pointer to array */
    } bulk;
</pre>
<div class="Pp"></div>
for the &quot;bulk&quot; array, and similarly for the
  &quot;blkentries&lt;100&gt;&quot; array,
<div class="Pp"></div>
<pre>
    struct {
        u_int      blkentries_len;   /* no of items in array */
        vldbentry  *blkentries_val;  /* pointer to array */
    } blkentries;
</pre>
<div class="Pp"></div>
Therefore the user should be aware of the &quot;magically&quot; generated
  structure entries such as the number of items in the array
  (&lt;array_name&gt;_len) and the pointer to the array (&lt;array_name&gt;_val)
  since some of the entries will have to be filled in from the client/server
  programs. A sample proc would be:
<div class="Pp"></div>
<pre>
    typedef vldbentry blkentries&lt;MAXENTRIES&gt;;
    proc GetBlk (OUT blkentries *vlentries) = VL_GETBLK;
</pre>
<div class="Pp"></div>
or, more directly,
<div class="Pp"></div>
<pre>
    GetBlk(OUT vldbentry vlentries&lt;MAXENTRIES&gt;) = VL_GETBLK;
</pre>
<div class="Pp"></div>
Note that although the latest method is preferable since one does not have to
  first use the typedef statement (and admittedly, programmers prefer avoiding
  typedefs), one should realize that <b>rxgen</b> does the structure expansion
  and the xdr creation implicitly; therefore the user should be aware of the
  &quot;vldbentries_val&quot; and &quot;vldbentries_len&quot; fields as before
  (see following examples).
<div class="Pp"></div>
<i>Array example I (least desirable)</i>
<div class="Pp"></div>
Procedure declaration in the interface configuration:
<div class="Pp"></div>
<pre>
    proc ListAttributes (IN vldblistbyattributes *attributes, 
                 INOUT blkentries *vldbentries) = VL_LISTATTRIBUTES;
</pre>
<div class="Pp"></div>
Sample CLIENT code:
<div class="Pp"></div>
<pre>
    blkentries entries, *pnt;
    entries.blkentries_len = 10;   /* max # returned entries */
    entries.blkentries_val = (vldbentry *)malloc(LEN);
                                   /* It must be set */
    code = VL_ListAttributes(&amp;attributes, &amp;entries);
    if (!code) {
        pnt = entries.blkentries_val;
        for (i=0; i &lt; entries.blkentries_len; i++, pnt++)
                display_vldbentry(pnt);
        /* Make sure you free the allocated space */
        free((char *)entries.blkentries_val);   
    }
</pre>
<div class="Pp"></div>
Sample SERVER code:
<div class="Pp"></div>
<pre>
    VL_ListAttributes(attributes, entries)
    {
        vldbentry *singleentry = entries-&gt;blkentries_val;
        entries-&gt;blkentries_len = 0;
        while (copy_to_vldbentry(&amp;vlentry, singleentry))
            singleentry++, vldbentries-&gt;entries_len++;
    }
</pre>
<div class="Pp"></div>
Although this method for variable-size arrays works fine, there are some major
  drawbacks. The array parameter (i.e. vldbentries above) must be declared as
  INOUT since we need to pass the max length of the expected returned array;
  more importantly, a big (depending on the value of &quot;_len&quot;) chunk of
  junk code is going to be transferred to the server as result of the IN(out)
  side-effect of the array. It's an easy and convenient method if the returned
  array size can be predicted from the start and when the size is quite high.
  This method is included as an example of erroneous use (and abuse) of
  <b>rxgen</b> and should not be used.
<div class="Pp"></div>
<i>Array example II (Desirable method)</i>
<div class="Pp"></div>
Procedure declaration in the interface configuration (using Example I above):
<div class="Pp"></div>
<pre>
    proc ListAttributes (IN vldblistbyattributes *attributes, 
        OUT blkentries *vldbentries) = VL_LISTATTRIBUTES;
</pre>
<div class="Pp"></div>
Sample CLIENT code:
<div class="Pp"></div>
<pre>
    blkentries entries, *pnt;
    code = VL_ListAttributes(&amp;attributes, &amp;entries);
    if (!code) {
        pnt = entries.blkentries_val;
        for (i=0; i &lt; entries.blkentries_len; i++, pnt++)
                display_vldbentry(pnt);
        /* Make sure you free the allocated space (by rxgen) */
        free((char *)entries.blkentries_val);   
    }
</pre>
<div class="Pp"></div>
Sample SERVER code:
<div class="Pp"></div>
<pre>
    VL_ListAttributes(attributes, entries)
    {
        vldbentry *singleentry;
        entries-&gt;blkentries_len = 0;
        singleentry = entries-&gt;blkentries_val
            = (vldbentry *)malloc(MAXENTRIES * sizeof(vldbentry));
        while (copy_to_vldbentry(&amp;vlentry, singleentry))
                singleentry++, vldbentries-&gt;entries_len++;
    }
</pre>
<div class="Pp"></div>
This is the best (and simplest) way of using variable-size arrays as an output
  parameter. It is the responsibility of the server-side stub to <i>malloc()</i>
  the adequate space which is automatically freed by the <b>rxgen</b> stub; the
  client side should free the space allocated by the <b>rxgen</b>-calling stub.
<div class="Pp"></div>
<i>Array example III (Linked Lists)</i>
<div class="Pp"></div>
Considering the following 3 declarations (could have applied some optimizations)
  in the configuration file:
<div class="Pp"></div>
<pre>
    typedef struct single_vldbentry *vldblist;
    struct single_vldbentry {
        vldbentry vlentry;
        vldblist  next_vldb;
    };
    struct vldb_list {
        vldblist node;
    };
</pre>
<div class="Pp"></div>
and the rxgen procedure declaration:
<div class="Pp"></div>
<pre>
    LinkedList (IN vldblistbyattributes *attributes, 
        OUT vldb_list *linkedentries) = VL_LINKEDLIST;
</pre>
<div class="Pp"></div>
Sample CLIENT code:
<div class="Pp"></div>
<pre>
    vldb_list       linkedvldbs;
    vldblist        vllist, vllist1;
    bzero(&amp;linkedvldbs, sizeof(vldb_list));
    code = VL_LinkedList(&amp;attributes, &amp;nentries, &amp;linkedvldbs);
    if (!code) {
        printf(&quot;We got %d vldb entries\n&quot;, nentries);
        for (vllist = linkedvldbs.node; vllist; vllist = vllist1) {
            vllist1 = vllist-&gt;next_vldb;
            display_entry(&amp;vllist-&gt;vlentry);
            free((char *)vllist);
        }
    }
</pre>
<div class="Pp"></div>
Sample SERVER code:
<div class="Pp"></div>
<pre>
    VL_LinkedList(rxcall, attributes, nentries, linkedvldbs);
    {
        vldblist vllist, *vllistptr = &amp;linkedvldbs-&gt;node;
        while (...) {
            vllist = *vllistptr
                = (single_vldbentry *)malloc (sizeof (single_vldbentry));
            copy_to_vldbentry(&amp;tentry, &amp;vllist-&gt;vlentry);
            nentries++;     
            vllistptr = &amp;vllist-&gt;next_vldb;
        };
        *vllistptr = NULL;
    }
</pre>
<div class="Pp"></div>
Using a linked list offers many advantages: Nothing is passed to the server (the
  parameter is OUT), no additional overhead is involved, and the caller doesn't
  have to explicitly prepare for an arbitrary return size. A drawback is that
  the caller has the responsibility of <i>malloc()</i> (on the server) and free
  (on the client) of each entry (to avoid unwanted core-leaks). Another drawback
  is that since it's a recursive call, the C stack will grow linearly with
  respect to the number of nodes in the list (so it's wise to increase the Rx
  LWP stack if huge amounts of data are expected back -- default stack size is
  4K). The advantages should outweigh the disadvantages here.
<div class="Pp"></div>
It's important to pay attention to the comments of the three array examples
  above particularly when they're references to when the user should
  allocate/free space for the variable length arrays. The mechanism is very
  similar to the handling of strings thus you might need to review the strings
  section above; note that the linked lists are handled somewhat differently...
<h2 class="Ss" title="Ss" id="Miscellaneous_examples"><a class="selflink" href="#Miscellaneous_examples">Miscellaneous
  examples</a></h2>
Below is an abbreviated version of a random interface file which shows some of
  the common cases.
<div class="Pp"></div>
<pre>
    /* Declaration of all structures used by the R.xg script interface */
    struct AFSFid {
        unsigned long Volume;
        unsigned long Vnode;
        unsigned long Unique;
    };
    typedef long ViceDataType;
    /* Note that TEST would be equivalent to &quot;HEADER&quot; only during the 
       processing of the header, *.h, file */
    #ifdef RPC_HDR
    #define TEST &quot;HEADER&quot;
    #else
    #define TEST &quot;REST&quot;
    #endif
    /* This is the standard *.xg specification file */
    package AFS_
    splitprefix IN=BEFORE_ OUT=AFTER_;
    Prefix Test
    proc Remove(IN struct AFSFid *Did, IN string volname&lt;64&gt;,
        OUT struct AFSStatus *Status) = AFS_REMOVE;
    DisconnectFS AUX_disconnectFS() = AFS_DISCONNECTFS;
    proc GetVolumeInfo(IN string Vid, 
        OUT struct VolumeInfo *Info) = AFS_GETVOLUMEINFO;
    /* You could have more than an interface per configuration */
    package VOTE_
    /* Using the &quot;multi&quot; feature; thus VOTE_Beacon can be called as an 
       multi-Rx call or as a regular call */
    Beacon (IN long state, long voteStart, 
        net_version *version, net_tid *tid) 
        multi = VOTE_BEACON;
    package DISK_
    /* Using the &quot;split&quot; feature */
    SendFile (IN long file, long offset, 
        long length, net_version *version) 
        split = DISK_SENDFILE;
</pre>
<h2 class="Ss" title="Ss" id="Output_of_an_actual_interface_configuration"><a class="selflink" href="#Output_of_an_actual_interface_configuration">Output
  of an actual interface configuration</a></h2>
We'll demonstrate some of the actual output generated by <b>rxgen</b> by
  following an abbreviated actual interface configuration.
<div class="Pp"></div>
<i>Configuration file</i>
<div class="Pp"></div>
Contents of the interface configuration file ( <i>vldbint.xg</i>):
<div class="Pp"></div>
<pre>
    package VL_
    #include &quot;vl_opcodes.h&quot;   /* The opcodes are included here */
    %#include &quot;vl_opcodes.h&quot;  /* directly to other places */
    /* Current limitations on parameters that affect other packages
       (i.e. volume) */
    const   MAXNAMELEN      =       65;
    const   MAXNSERVERS     =       8;
    const   MAXTYPES        =       3;
    /* External (visible) representation of an individual vldb entry */
    struct vldbentry {
        char    name[MAXNAMELEN];       
        long    volumeType;             
        long    nServers;               
        long    serverNumber[MAXNSERVERS];
        long    serverPartition[MAXNSERVERS];
        long    serverFlags[MAXNSERVERS];
        u_long  volumeId[MAXTYPES];     
        long    flags;                  
    };
    typedef struct single_vldbentry  *vldblist;
    struct single_vldbentry {
        vldbentry VldbEntry;
        vldblist next_vldb;
    };
    struct vldb_list {
        vldblist node;
    };
    /* vldb interface calls */
    CreateEntry     (IN long Volid, 
                    vldbentry *newentry) = VLCREATEENTRY;
    GetEntryByName  (IN string volumename&lt;MAXNAMELEN&gt;, 
                    OUT vldbentry *entry) = VLGETENTRYBYNAME;
    GetNewVolumeId  (IN long bumpcount,
                    OUT long *newvolumid) = VLGETNEWVOLUMEID;
    ReplaceEntry    (IN long Volid, 
                    long voltype,
                    vldbentry *newentry,
                    long ReleaseType) multi = VLREPLACEENTRY;
    ListAttributes  (IN VldbListByAttributes *attributes, 
                    OUT long *nentries, 
                    OUT vldbentry bulkentries&lt;MAXVLDBLEN&gt;) 
                    = VLLISTATTRIBUTES;
    LinkedList      (IN VldbListByAttributes *attributes, 
                    OUT long *nentries, 
                    OUT vldb_list *linkedentries) = VLLINKEDLIST;
</pre>
<div class="Pp"></div>
We'll concentrate only on the Rx generated code since the R generated code (
  <b>-R</b> option) will soon be obsolete. For a detailed description on the
  Rx-related calls inside the generated stubs (i.e., <i>rx_NewCall()</i>,
  <i>rx_EndCall()</i>), along with details on what happens inside certain calls
  (like <i>xdrrx_create()</i>) please refer to the Rx documentation. Typing
  &quot;rxgen vldbint.xg&quot; will result in the creation of four files:
  <i>vldbint.h</i>, <i>vldbint.xdr.c</i>, <i>vldbint.cs.c</i> and
  <i>vldbint.ss.c</i>. A closer look at these files follows.
<div class="Pp"></div>
<i>Header file (</i><i>vldbint.h</i><i>)</i>
<div class="Pp"></div>
<pre>
    /* Machine generated file -- Do NOT edit */
    #include &quot;vl_opcodes.h&quot;  /* directly to other places */
    #define MAXNAMELEN 65
    #define MAXNSERVERS 8
    #define MAXTYPES 3
    struct vldbentry {
        char name[MAXNAMELEN];
        long volumeType;
        long nServers;
        long serverNumber[MAXNSERVERS];
        long serverPartition[MAXNSERVERS];
        long serverFlags[MAXNSERVERS];
        u_long volumeId[MAXTYPES];
        long flags;
    };
    typedef struct vldbentry vldbentry;
    bool_t xdr_vldbentry();
    typedef struct single_vldbentry *vldblist;
    bool_t xdr_vldblist();
    struct single_vldbentry {
        vldbentry VldbEntry;
        vldblist next_vldb;
    };
    typedef struct single_vldbentry single_vldbentry;
    bool_t xdr_single_vldbentry();
    struct vldb_list {
        vldblist node;
    };
    typedef struct vldb_list vldb_list;
    bool_t xdr_vldb_list();
    #include &lt;rx/rx_multi.h&gt;
    #define multi_VL_ReplaceEntry(Volid, voltype, newentry, ReleaseType) \
        multi_Body(StartVL_ReplaceEntry(multi_call, Volid, voltype,
                   newentry, ReleaseType), EndVL_ReplaceEntry(multi_call))
    typedef struct bulkentries {
        u_int bulkentries_len;
        vldbentry *bulkentries_val;
    } bulkentries;
    bool_t xdr_bulkentries();
    /* Opcode-related useful stats for package: VL_ */
    #define VL_LOWEST_OPCODE        501
    #define VL_HIGHEST_OPCODE       506
    #define VL_NUMBER_OPCODES       6
</pre>
<div class="Pp"></div>
Notice that all structures are automatically typedef'ed and all
  &quot;const&quot;s are converted to &quot;#define&quot;s. Some data
  structures, such as bulkentries, are taken from procedure params (from
  ListAttributes proc). Thus, this should be kept in mind when creating stubs
  piecemeal with <b>rxgen</b> (i.e., using the <b>-c</b>, <b>-h</b>, <b>-C</b>,
  or <b>-S</b> flags). Also, one of the side effects of the &quot;multi&quot;
  option (in &quot;ReplaceEntry&quot; proc) is the generation of the
  &quot;multi_VL_ReplaceEntry&quot; above.
<div class="Pp"></div>
<i>XDR routines for structures (vldbint.xdr.c)</i>
<div class="Pp"></div>
<pre>
    /* Machine generated file -- Do NOT edit */
    #include &lt;rx/xdr.h&gt;
    #include &quot;vldbint.h&quot;
    #include &quot;vl_opcodes.h&quot;  /* directly to other places */
    bool_t
    xdr_vldbentry(xdrs, objp)
        XDR *xdrs;
        vldbentry *objp;
    {
        if (!xdr_vector(xdrs, (char *)objp-&gt;name, MAXNAMELEN,
                        sizeof(char), xdr_char))
            return (FALSE);
        if (!xdr_long(xdrs, &amp;objp-&gt;volumeType))
            return (FALSE);
        if (!xdr_long(xdrs, &amp;objp-&gt;nServers))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&gt;serverNumber, MAXNSERVERS,
                        sizeof(long), xdr_long))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&gt;serverPartition,
                        MAXNSERVERS, sizeof(long), xdr_long))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&gt;serverFlags, MAXNSERVERS,
                        sizeof(long), xdr_long))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&gt;volumeId, MAXTYPES,
                        sizeof(u_long), xdr_u_long))
            return (FALSE);
        if (!xdr_long(xdrs, &amp;objp-&gt;flags))
            return (FALSE);
        return (TRUE);
    }
    bool_t
    xdr_vldblist(xdrs, objp)
        XDR *xdrs;
        vldblist *objp;
    {
        if (!xdr_pointer(xdrs, (char **)objp,
                         sizeof(struct single_vldbentry), 
                         xdr_single_vldbentry))
            return (FALSE);
        return (TRUE);
    }
    bool_t
    xdr_single_vldbentry(xdrs, objp)
        XDR *xdrs;
        single_vldbentry *objp;
    {
        if (!xdr_vldbentry(xdrs, &amp;objp-&gt;VldbEntry))
            return (FALSE);
        if (!xdr_vldblist(xdrs, &amp;objp-&gt;next_vldb))
            return (FALSE);
        return (TRUE);
    }
    bool_t
    xdr_vldb_list(xdrs, objp)
        XDR *xdrs;
        vldb_list *objp;
    {
        if (!xdr_vldblist(xdrs, &amp;objp-&gt;node))
            return (FALSE);
        return (TRUE);
    }
    bool_t
    xdr_bulkentries(xdrs, objp)
        XDR *xdrs;
        bulkentries *objp;
    {
        if (!xdr_array(xdrs, (char **)&amp;objp-&gt;bulkentries_val,
                       (u_int *)&amp;objp-&gt;bulkentries_len, MAXVLDBLEN,
                       sizeof(vldbentry), xdr_vldbentry))
            return (FALSE);
        return (TRUE);
    }
</pre>
<div class="Pp"></div>
Note that the <i>xdr_bulkentries()</i> is automatically generated as a side
  effect of a procedure parameter declaration. Thus, if identical multiple type
  parameter declarations are used, then multiply-defined xdr_* stubs will be
  created! We felt this was a better alternative to having the <b>rxgen</b>
  programmer deal with types such as bulkentries_1, bulkentries_2...
<div class="Pp"></div>
<i>Client-Side stub routines (vldbint.cs.c)</i>
<div class="Pp"></div>
<pre>
    /* Machine generated file -- Do NOT edit */
    #include &lt;rx/xdr.h&gt;
    #include &lt;rx/rx.h&gt;
    #include &lt;afs/rxgen_consts.h&gt;
    #include &quot;vldbint.h&quot;
    #include &quot;vl_opcodes.h&quot;  /* directly to other places */
    int VL_CreateEntry(z_conn, Volid, newentry)
        register struct rx_connection *z_conn;
        long Volid;
        vldbentry * newentry;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 501;
        int z_result;
        XDR z_xdrs;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);
        /* Marshal the arguments */
        if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
             || (!xdr_long(&amp;z_xdrs, &amp;Volid))
             || (!xdr_vldbentry(&amp;z_xdrs, newentry))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }
        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }
    int VL_GetEntryByName(z_conn, volumename, entry)
        register struct rx_connection *z_conn;
        char * volumename;
        vldbentry * entry;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 504;
        int z_result;
        XDR z_xdrs;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);
        /* Marshal the arguments */
        if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
             || (!xdr_string(&amp;z_xdrs, &amp;volumename, 65))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }
        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_vldbentry(&amp;z_xdrs, entry))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }
        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }
    int VL_GetNewVolumeId(z_conn, bumpcount, newvolumid)
        register struct rx_connection *z_conn;
        long bumpcount;
        long * newvolumid;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 505;
        int z_result;
        XDR z_xdrs;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);
        /* Marshal the arguments */
        if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
             || (!xdr_long(&amp;z_xdrs, &amp;bumpcount))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }
        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_long(&amp;z_xdrs, newvolumid))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }
        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }
    int VL_ReplaceEntry(z_conn, Volid, voltype, newentry, ReleaseType)
        register struct rx_connection *z_conn;
        long Volid, voltype, ReleaseType;
        vldbentry * newentry;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 506;
        int z_result;
        XDR z_xdrs;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);
        /* Marshal the arguments */
        if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
             || (!xdr_long(&amp;z_xdrs, &amp;Volid))
             || (!xdr_long(&amp;z_xdrs, &amp;voltype))
             || (!xdr_vldbentry(&amp;z_xdrs, newentry))
             || (!xdr_long(&amp;z_xdrs, &amp;ReleaseType))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }
        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }
    int StartVL_ReplaceEntry(z_call, Volid, voltype, newentry, ReleaseType)
        register struct rx_call *z_call;
        long Volid, voltype, ReleaseType;
        vldbentry * newentry;
    {
        static int z_op = 506;
        int z_result;
        XDR z_xdrs;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);
        /* Marshal the arguments */
        if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
             || (!xdr_long(&amp;z_xdrs, &amp;Volid))
             || (!xdr_long(&amp;z_xdrs, &amp;voltype))
             || (!xdr_vldbentry(&amp;z_xdrs, newentry))
             || (!xdr_long(&amp;z_xdrs, &amp;ReleaseType))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }
        z_result = RXGEN_SUCCESS;
    fail:
        return z_result;
    }
    int EndVL_ReplaceEntry(z_call)
        register struct rx_call *z_call;
    {
        int z_result;
        XDR z_xdrs;
        z_result = RXGEN_SUCCESS;
    fail:
        return z_result;
    }
    int VL_ListAttributes(z_conn, attributes, nentries, bulkentries_1)
        register struct rx_connection *z_conn;
        VldbListByAttributes * attributes;
        long * nentries;
        bulkentries * bulkentries_1;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 511;
        int z_result;
        XDR z_xdrs;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);
        /* Marshal the arguments */
        if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
             || (!xdr_VldbListByAttributes(&amp;z_xdrs, attributes))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }
        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_long(&amp;z_xdrs, nentries))
             || (!xdr_bulkentries(&amp;z_xdrs, bulkentries_1))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }
        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }
    int VL_LinkedList(z_conn, attributes, nentries, linkedentries)
        register struct rx_connection *z_conn;
        VldbListByAttributes * attributes;
        long * nentries;
        vldb_list * linkedentries;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 512;
        int z_result;
        XDR z_xdrs;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);
        /* Marshal the arguments */
        if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
             || (!xdr_VldbListByAttributes(&amp;z_xdrs, attributes))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }
        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_long(&amp;z_xdrs, nentries))
             || (!xdr_vldb_list(&amp;z_xdrs, linkedentries))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }
        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }
</pre>
<div class="Pp"></div>
Notice the side effect of the &quot;multi&quot; feature (three different modules
  for &quot;ReplaceEntry&quot; proc).
<div class="Pp"></div>
<i>Server-Side stub routines (vldbint.ss.c)</i>
<div class="Pp"></div>
<pre>
    /* Machine generated file -- Do NOT edit */
    #include &lt;rx/xdr.h&gt;
    #include &lt;rx/rx.h&gt;
    #include &lt;afs/rxgen_consts.h&gt;
    #include &quot;vldbint.h&quot;
    #include &quot;vl_opcodes.h&quot;  /* directly to other places */
    long _VL_CreateEntry(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        long Volid;
        vldbentry newentry;
        if ((!xdr_long(z_xdrs, &amp;Volid))
             || (!xdr_vldbentry(z_xdrs, &amp;newentry))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }
        z_result = VL_CreateEntry(z_call, Volid, &amp;newentry);
    fail:
        return z_result;
    }
    long _VL_GetEntryByName(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        char *volumename = (char *)0;
        vldbentry entry;
        if ((!xdr_string(z_xdrs, &amp;volumename, 65))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }
        z_result = VL_GetEntryByName(z_call, &amp;volumename, &amp;entry);
        z_xdrs-&gt;x_op = XDR_ENCODE;
        if ((!xdr_vldbentry(z_xdrs, &amp;entry)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        z_xdrs-&gt;x_op = XDR_FREE;
        if (!xdr_string(z_xdrs, &amp;volumename, 65)) goto fail1;
        return z_result;
    fail1:
        return RXGEN_SS_XDRFREE;
    }
    long _VL_GetNewVolumeId(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        long bumpcount;
        long newvolumid;
        if ((!xdr_long(z_xdrs, &amp;bumpcount))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }
        z_result = VL_GetNewVolumeId(z_call, bumpcount, &amp;newvolumid);
        z_xdrs-&gt;x_op = XDR_ENCODE;
        if ((!xdr_long(z_xdrs, &amp;newvolumid)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        return z_result;
    }
    long _VL_ReplaceEntry(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        long Volid, voltype, ReleaseType;
        vldbentry newentry;
        if ((!xdr_long(z_xdrs, &amp;Volid))
             || (!xdr_long(z_xdrs, &amp;voltype))
             || (!xdr_vldbentry(z_xdrs, &amp;newentry))
             || (!xdr_long(z_xdrs, &amp;ReleaseType))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }
        z_result = VL_ReplaceEntry(z_call, Volid, voltype, &amp;newentry,
                                   ReleaseType);
    fail:
        return z_result;
    }
    long _VL_ListAttributes(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        VldbListByAttributes attributes;
        long nentries;
        bulkentries bulkentries_1;
        if ((!xdr_VldbListByAttributes(z_xdrs, &amp;attributes))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }
        z_result = VL_ListAttributes(z_call, &amp;attributes, &amp;nentries,
                                     &amp;bulkentries_1);
        z_xdrs-&gt;x_op = XDR_ENCODE;
        if ((!xdr_long(z_xdrs, &amp;nentries))
             || (!xdr_bulkentries(z_xdrs, &amp;bulkentries_1)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        z_xdrs-&gt;x_op = XDR_FREE;
        if (!xdr_bulkentries(z_xdrs, &amp;bulkentries_1)) goto fail1;
        return z_result;
    fail1:
        return RXGEN_SS_XDRFREE;
    }
    long _VL_LinkedList(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        VldbListByAttributes attributes;
        long nentries;
        vldb_list linkedentries;
        if ((!xdr_VldbListByAttributes(z_xdrs, &amp;attributes))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }
        z_result = VL_LinkedList(z_call, &amp;attributes, &amp;nentries,
                                 &amp;linkedentries);
        z_xdrs-&gt;x_op = XDR_ENCODE;
        if ((!xdr_long(z_xdrs, &amp;nentries))
             || (!xdr_vldb_list(z_xdrs, &amp;linkedentries)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        return z_result;
    }
    long _VL_CreateEntry();
    long _VL_GetEntryByName();
    long _VL_GetNewVolumeId();
    long _VL_ReplaceEntry();
    long _VL_ListAttributes();
    long _VL_LinkedList();
    static long (*StubProcsArray0[])() = {_VL_CreateEntry,
        _VL_GetEntryByName, _VL_GetNewVolumeId, _VL_ReplaceEntry,
        _VL_ListAttributes, _VL_LinkedList};
    VL_ExecuteRequest(z_call)
        register struct rx_call *z_call;
    {
        int op;
        XDR z_xdrs;
        long z_result;
        xdrrx_create(&amp;z_xdrs, z_call, XDR_DECODE);
        if (!xdr_int(&amp;z_xdrs, &amp;op))
            z_result = RXGEN_DECODE;
        else if (op &lt; VL_LOWEST_OPCODE || op &gt; VL_HIGHEST_OPCODE)
            z_result = RXGEN_OPCODE;
        else
            z_result = (*StubProcsArray0[op - VL_LOWEST_OPCODE])
                (z_call, &amp;z_xdrs);
        return z_result;
    }
</pre>
<div class="Pp"></div>
If there were gaps in the procedures' opcode sequence the code for
  <i>VL_ExecuteRequest()</i> routine would be have been drastically different
  (it would have been a case statement for each procedure).
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
<b>rxgen</b> is implemented from Sun's <b>rpcgen</b> utility. All of the
  standard <b>rpcgen</b>'s functionality is fully maintained. Note that some
  active <b>rpcgen</b> options that don't apply to <b>rxgen</b>'s purpose aren't
  referenced here (i.e., <b>-s</b>, <b>-l</b>, <b>-m</b> options) and the
  interested reader should refer to <i>rpcgen</i>(1) for details.
<div class="Pp"></div>
When the &quot;%#include &lt;include file&quot;&gt; feature is used make sure
  that you don't have any <b>rxgen</b> language features (i.e. %#defines) since
  you'll get syntax errors during compilations..
<div class="Pp"></div>
Since this is an ongoing project many of the above may change/disappear without
  a major warning.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>Rxgen Syntax Summary</i>: Summary description of rxgen's grammar.
<div class="Pp"></div>
<i>Rpcgen Programming Guide</i>: Sun's RPC protocol compiler. <b>rxgen</b> was
  implemented as an extension to that compiler.
<div class="Pp"></div>
<i>External Data Representation: Sun Technical Notes</i>: Detailed examples in
  using XDR.
<div class="Pp"></div>
<i>RPCL Syntax Summary</i>: Summary of Sun's Remote Procedure Call Language.
<div class="Pp"></div>
<i>Rx</i>: An extended Remote Procedure Call Protocol.
<div class="Pp"></div>
<i>rgen</i>: An earlier version of a similar stub generator used for the R RPC
  protocol.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
IBM Corporation 2000. &lt;http://www.ibm.com/&gt; All Rights Reserved.
<div class="Pp"></div>
This documentation is covered by the IBM Public License Version 1.0. It was
  converted from the original TeX <b>rxgen</b> manual to POD by Russ
  Allbery.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-02-14</td>
    <td class="foot-os">OpenAFS</td>
  </tr>
</table>
</body>
</html>
